// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register word32 fn00401000(Register (ptr Eq_3) es, Register (ptr Eq_4) ds, Stack word32 dwArg04, Stack word32 dwArg08, Register out ptr32 edxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
word32 fn00401000(Eq_3 * es, Eq_4 * ds, word32 dwArg04, word32 dwArg08, ptr32 & edxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 esp_35;
	byte SCZO_36;
	word32 eax_37;
	byte SZO_38;
	byte C_39;
	<anonymous> * ebx_40;
	word32 esi_42;
	word32 edi_43;
	word32 ecx_44;
	word32 edx_45;
	byte al_46;
	byte Z_47;
	byte SO_48;
	byte cl_49;
	byte CZ_50;
	word16 ax_51;
	struct Eq_27 * es_52;
	struct Eq_28 * ds_53;
	int32 ebp_211;
	MSVCR90.dll!sprintf();
	ui32 eax_5 = globals->dw403000 ^ fp - 88;
	struct Eq_38 * esp_218 = fp - 0x68;
	if (ebp_211 > 0x10)
		ebp_211 = 0x10;
	int32 esi_210 = 0x00;
	if (ebp_211 > 0x00)
	{
		ptr32 edi_249 = fp - 0x4B;
		do
		{
			Eq_207 eax_253[] = esp_218->ptr0010;
			word32 ecx_254 = (word32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&eax_253[esi_210].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
			word32 * esp_255 = esp_218 - 0x04;
			*esp_255 = ecx_254;
			*(esp_255 - 0x04) = 0x0040210C;
			*(esp_255 - 0x08) = edi_249;
			word32 esp_261;
			byte SCZO_262;
			word32 eax_263;
			byte SZO_264;
			byte C_265;
			word32 ebx_266;
			int32 esi_268;
			word32 edi_269;
			word32 ecx_270;
			word32 edx_271;
			byte al_272;
			byte Z_273;
			byte SO_274;
			byte cl_275;
			byte CZ_276;
			word16 ax_277;
			struct Eq_98 * es_278;
			struct Eq_99 * ds_279;
			ebx_40();
			esi_210 = esi_268 + 0x01;
			esp_218 = esp_261 + 0x0C;
			edi_249 = edi_269 + 0x03;
		} while (esi_268 + 0x01 < ebp_211);
		if (esi_268 >= ~0x0E)
		{
l00401094:
			byte * eax_76 = (char *) &esp_218->ptr0010 + 0x04;
			eax_80 = eax_76;
			do
			{
				byte * eax_80;
				byte cl_81 = *eax_80;
				eax_80 = eax_80 + 0x01;
			} while (cl_81 != 0x00);
			int32 eax_88 = eax_80 - (eax_76 + 0x01);
			((char *) &esp_218->ptr0010 + 0x04)[eax_88] = (char) 0x007C2020;
			int32 esi_152 = 0x00;
			if (ebp_211 <= 0x00)
			{
l004010E4:
				size_t edi_158 = 0x10 - esi_152;
				size_t * esp_159 = esp_218 - 0x04;
				*esp_159 = (uint32) edi_158;
				*(esp_159 - 0x04) = 0x20;
				*(esp_159 - 0x08) = esp_159 + 0x06 + ((eax_88 + 0x03) + esi_152);
				memset(*(esp_159 - 0x08), *(esp_159 - 0x04), *esp_159);
				esi_152 = (word32) edi_158 + esi_152;
				goto l00401100;
			}
			Eq_205 ecx_171[] = (char *) &esp_218->ptr0010 + 0x04 + (eax_88 + 0x03);
l004010C0:
			Eq_205 al_186;
			Eq_207 al_179 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&esp_218->ptr0010[esi_152].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
			if (al_179 >=u 0x20)
			{
				al_186 = (byte) (word32) al_179;
				if (al_179 <=u 0x7E)
				{
l004010D7:
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&ecx_171[esi_152].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = al_186;
					esi_152 = esi_152 + 0x01;
					if (esi_152 < ebp_211)
						goto l004010C0;
					if (esi_152 >= 0x10)
					{
l00401100:
						ptr32 ecx_97 = (char *) &esp_218->ptr0010 + 0x04;
						struct Eq_229 * esp_98 = esp_218 - 0x04;
						esp_98->ptr0000 = ecx_97;
						*(esp_98 - 0x04) = 0x00402118;
						int32 ebx_102 = eax_88 + 0x03 + esi_152;
						(&esp_98->a0018->w0000)[ebx_102 / 0x0018] = (struct Eq_229) 0x7C;
						struct Eq_249 * esp_107;
						byte SCZO_108;
						word32 eax_109;
						byte SZO_110;
						byte C_111;
						word32 ebx_112;
						word32 ebp_113;
						word32 esi_114;
						word32 edi_115;
						word32 ecx_116;
						word32 edx_117;
						byte al_118;
						byte Z_119;
						byte SO_120;
						byte cl_121;
						byte CZ_122;
						word16 ax_123;
						struct Eq_266 * es_124;
						struct Eq_267 * ds_125;
						MSVCR90.dll!printf();
						word32 edi_128 = esp_107->dw0008;
						*ediOut = edi_128;
						word32 esi_130 = esp_107->dw000C;
						*esiOut = esi_130;
						word32 ebp_132 = esp_107->dw0010;
						*ebpOut = ebp_132;
						return fn0040123B(eax_109, esp_107->dw006C ^ &esp_107->dw0014 + 0x01, edx_117, esp_107->dw0014, ebp_132, esi_130, edi_128, es_124, ds_125, eax_5);
					}
					goto l004010E4;
				}
			}
			al_186 = 0x2E;
			goto l004010D7;
		}
	}
	word32 edx_223 = globals->dw402114;
	word32 ecx_225 = 0x10 - esi_210;
	do
	{
		struct Eq_108 * edi_236 = (char *) &esp_218->ptr0010 + 0x03 + 0x01;
		do
		{
			edi_236 = edi_288 + 0x01;
			struct Eq_108 * edi_288 = edi_236;
		} while (edi_288->dw0000 != 0x00);
		edi_236->dw0000 = edx_223;
		ecx_225 = ecx_225 - 0x01;
	} while (ecx_225 != 0x00);
	goto l00401094;
}

// 00401140: Register word32 fn00401140(Register word32 ecx, Register word32 edx, Register (ptr Eq_309) es, Register (ptr Eq_310) ds, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out (ptr Eq_313) ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
word32 fn00401140(word32 ecx, word32 edx, Eq_309 * es, Eq_310 * ds, ptr32 & edxOut, ptr32 & ebxOut, Eq_313 * & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 esp_28;
	byte SCZO_29;
	word32 eax_30;
	byte SZO_31;
	byte C_32;
	word32 ebx_33;
	word32 ebp_34;
	word32 edi_36;
	word32 ecx_37;
	byte Z_38;
	byte CZ_39;
	struct Eq_267 * ds_113;
	struct Eq_266 * es_112;
	word32 edx_111;
	char * esi_106;
	stat64i32();
	ptr32 esp_115 = fp - 0x60;
	if ((fp - 0x4C & fp - 0x4C) == 0x00)
	{
		*(fp - (char *******) 100) = (char *******) "rb";
		*(fp - (char *******) 0x68) = (char *******) esi_106;
		struct Eq_354 * esp_99;
		byte SCZO_100;
		word32 eax_101;
		byte SZO_102;
		byte C_103;
		word32 ebx_104;
		word32 ebp_105;
		word32 edi_107;
		word32 ecx_108;
		byte Z_109;
		byte CZ_110;
		MSVCR90.dll!fopen();
		word32 edi_114 = eax_101;
		esp_115 = (char *) esp_99 + 0x08;
		if (eax_101 != 0x00)
		{
			if (esp_99->dw002C > 0x00)
			{
				esp_115 = (char *) esp_99 + 0x08;
				do
				{
					word32 * esp_162 = esp_115 - 0x04;
					*esp_162 = edi_114;
					*(esp_162 - 0x04) = 0x10;
					*(esp_162 - 0x08) = 0x01;
					*(esp_162 - 0x0C) = esp_162 + 0x0012;
					struct Eq_472 * esp_171;
					byte SCZO_172;
					word32 eax_173;
					byte SZO_174;
					byte C_175;
					word32 ebx_176;
					word32 ebp_177;
					word32 esi_178;
					word32 ecx_180;
					byte Z_181;
					byte CZ_182;
					word32 edx_183;
					struct Eq_3 * es_184;
					struct Eq_4 * ds_185;
					MSVCR90.dll!fread();
					esp_115 = &esp_171->dw000C + 0x01;
					if (eax_173 == 0x00)
						goto l004011DD;
					esp_171->dw000C = eax_173;
					esp_171->ptr0008 = &esp_171->dw0034 + 0x08;
					word32 edx_199;
					uint32 ebp_200;
					uint32 esi_201;
					fn00401000(es_184, ds_185, dwArg00, dwArg04, out edx_199, out ebp_200, out esi_201, out edi_114);
					esp_115 = &esp_171->dw000C + 0x01;
				} while (ebp_200 + esi_201 < esp_171->dw0034);
			}
l004011DD:
			word32 * esp_124 = esp_115 - 0x04;
			*esp_124 = edi_114;
			struct Eq_425 * esp_126;
			byte SCZO_127;
			word32 eax_128;
			byte SZO_129;
			byte C_130;
			word32 ebx_131;
			word32 ebp_132;
			word32 esi_133;
			word32 edi_134;
			word32 ecx_135;
			byte Z_136;
			byte CZ_137;
			word32 edx_138;
			struct Eq_266 * es_139;
			struct Eq_267 * ds_140;
			MSVCR90.dll!fclose();
			word32 edi_143 = esp_126->dw0004;
			*ediOut = edi_143;
			word32 esi_145 = esp_126->dw0008;
			*esiOut = esi_145;
			word32 ebp_147 = esp_126->dw000C;
			*ebpOut = ebp_147;
			word32 ebx_149 = esp_126->dw0010;
			*ebxOut = ebx_149;
			return fn0040123B(0x00, esp_126->dw0058 ^ &esp_126->dw0010 + 0x01, edx_138, ebx_149, ebp_147, esi_145, edi_143, es_139, ds_140, dwLoc04);
		}
	}
	struct Eq_371 * esp_75 = esp_115 - 0x04;
	esp_75->ptr0000 = esi_106;
	perror(esp_75->ptr0000);
	word32 edi_79 = esp_75->dw0004;
	*ediOut = edi_79;
	word32 esi_81 = esp_75->dw0008;
	*esiOut = esi_81;
	word32 ebp_83 = esp_75->dw000C;
	*ebpOut = ebp_83;
	word32 ebx_85 = esp_75->dw0010;
	*ebxOut = ebx_85;
	return fn0040123B(0x01, esp_75->dw0058 ^ &esp_75->dw0010 + 0x01, edx_111, ebx_85, ebp_83, esi_81, edi_79, es_112, ds_113, dwLoc04);
}

// 00401200: Register word32 fn00401200(Register word32 edx, Register (ptr Eq_309) es, Register (ptr Eq_310) ds, Stack word32 dwArg04, Register out ptr32 ebxOut, Register out ptr32 ebpOut)
word32 fn00401200(word32 edx, Eq_309 * es, Eq_310 * ds, word32 dwArg04, ptr32 & ebxOut, ptr32 & ebpOut)
{
	__align(fp - 0x04);
	struct Eq_554 * ebp_32 = fp - 0x04;
	ui32 esi_21 = 0x01;
	if (dwArg04 > 0x01)
	{
		do
		{
			int32 ebx_61;
			int32 esi_63;
			word32 edi_64;
			eax = fn00401140(*((word32) ebp_32[0x0C].dw0000 + esi_21 * 0x04), edx, es, ds, out edx, out ebx_61, out ebp_32, out esi_63, out edi_64);
			esi_21 = esi_63 + 0x01;
		} while (esi_63 + 0x01 < ebx_61);
	}
	word32 edi_34 = *(fp - 0x14);
	word32 * ebp_40 = ebp_32->dw0000;
	struct Eq_571 * esp_41 = ebp_32 + 0x04;
	return eax;
	word32 ebx_47;
	*ebxOut = esp_41->dw0008;
	word32 ebp_49;
	*ebpOut = *ebp_40;
	return edi_34;
}

// 0040123B: Register word32 fn0040123B(Register word32 eax, Register ui32 ecx, Register word32 edx, Register word32 ebx, Register word32 ebp, Register word32 esi, Register word32 edi, Register (ptr Eq_266) es, Register (ptr Eq_267) ds, Stack ui32 dwArg00)
word32 fn0040123B(word32 eax, ui32 ecx, word32 edx, word32 ebx, word32 ebp, word32 esi, word32 edi, Eq_266 * es, Eq_267 * ds, ui32 dwArg00)
{
	if (ecx != globals->dw403000)
	{
		globals->dw403140 = eax;
		globals->dw40313C = ecx;
		globals->dw403138 = edx;
		globals->dw403134 = ebx;
		globals->dw403130 = esi;
		globals->dw40312C = edi;
		globals->ptr403158 = ss;
		globals->ptr40314C = cs;
		globals->ptr403128 = ds;
		globals->ptr403124 = es;
		globals->ptr403120 = fs;
		globals->ptr40311C = gs;
		Eq_636 SCZO_51 = cond(fp - 0x032C);
		globals->t403150 = SCZO_51;
		globals->dw403144 = ebp;
		globals->dw403148 = dwArg00;
		globals->ptr403154 = fp + 0x04;
		globals->dw403090 = 0x00010001;
		globals->dw403044 = globals->dw403148;
		globals->dw403038 = 0xC0000409;
		globals->dw40303C = 0x01;
		Eq_665 eax_87 = IsDebuggerPresent();
		globals->t403088 = eax_87;
		word32 esp_91;
		word32 ecx_92;
		byte SCZO_93;
		byte Z_94;
		word32 edi_95;
		word32 ebp_96;
		word32 eax_97;
		word32 edx_98;
		word32 ebx_99;
		word32 esi_100;
		struct Eq_681 * ss_101;
		struct Eq_682 * cs_102;
		struct Eq_683 * ds_103;
		struct Eq_684 * es_104;
		struct Eq_685 * fs_105;
		struct Eq_686 * gs_106;
		byte SCZDOP_107;
		crt_debugger_hook();
		SetUnhandledExceptionFilter(null);
		Eq_695 eax_117 = UnhandledExceptionFilter(&globals->t4020FC);
		ptr32 esp_118 = fp - 0x0330;
		if (globals->t403088 == 0x00)
		{
			*(fp - 0x0334) = 0x01;
			ptr32 esp_148;
			word32 ecx_149;
			byte SCZO_150;
			byte Z_151;
			word32 edi_152;
			word32 ebp_153;
			word32 eax_154;
			word32 edx_155;
			word32 ebx_156;
			word32 esi_157;
			struct Eq_751 * ss_158;
			struct Eq_752 * cs_159;
			struct Eq_753 * ds_160;
			struct Eq_754 * es_161;
			struct Eq_755 * fs_162;
			struct Eq_756 * gs_163;
			byte SCZDOP_164;
			crt_debugger_hook();
			esp_118 = esp_148;
		}
		UINT * esp_137 = esp_118 - 0x04;
		*esp_137 = (uint32) 0xC0000409;
		*(esp_137 - 0x04) = (HANDLE *) GetCurrentProcess();
		return TerminateProcess(*(esp_137 - 0x04), *esp_137);
	}
	else
		return eax;
}

// 004014EC: Register Eq_760 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00401968();
	word32 * ebp_10 = fn004018BC(ebx, esi, edi, dwLoc0C, 0x004021D8, 0x10);
	*(ebp_10 - 0x04) = 0x00;
	Eq_695 esi_17 = fs->ptr0018->t0004;
	*(ebp_10 - 0x1C) = 0x00;
	while (true)
	{
		*(fp - 0x0C) = 0x00;
		*(fp - 0x10) = (int32) esi_17;
		*(fp - 0x14) = 0x00403374;
		Eq_695 eax_27 = InterlockedCompareExchange(*(fp - 0x14), *(fp - 0x10), *(fp - 0x0C));
		ptr32 esp_213 = fp - 0x08;
		if (eax_27 == 0x00)
			break;
		if (eax_27 == esi_17)
		{
			*(ebp_10 - 0x1C) = 0x01;
			break;
		}
		*(fp - 0x0C) = 1000;
		Sleep(*(fp - 0x0C));
	}
	int32 eax_137;
	word32 esi_228 = 0x01;
	word32 eax_34 = globals->dw403370;
	if (eax_34 == 0x01)
	{
		*(fp - 0x0C) = 0x1F;
		ptr32 esp_221;
		word32 ebx_222;
		byte SZO_223;
		byte C_224;
		word32 eax_226;
		struct Eq_845 * fs_227;
		word32 edi_229;
		byte SCZO_230;
		byte Z_231;
		word32 ecx_232;
		amsg_exit();
		esp_213 = esp_221;
	}
	else
	{
		word32 eax_239 = globals->dw403370;
		if (eax_239 == 0x00)
		{
			globals->dw403370 = 0x01;
			*(fp - 0x0C) = 0x004020DC;
			*(fp - 0x10) = 0x004020D0;
			word32 esp_248;
			word32 ebx_249;
			byte SZO_250;
			byte C_251;
			word32 eax_253;
			struct Eq_919 * fs_254;
			word32 edi_256;
			byte SCZO_257;
			byte Z_258;
			word32 ecx_259;
			initterm_e();
			esp_213 = esp_248 + 0x04;
			if (eax_253 != 0x00)
			{
				*(ebp_10 - 0x04) = ~0x01;
				eax_137 = 0xFF;
				goto l00401405;
			}
		}
		else
			globals->dw403034 = 0x01;
	}
	word32 eax_68 = globals->dw403370;
	if (eax_68 == esi_228)
	{
		word32 * esp_190 = esp_213 - 0x04;
		*esp_190 = 0x004020CC;
		*(esp_190 - 0x04) = 0x004020C4;
		word32 esp_194;
		word32 ebx_195;
		byte SZO_196;
		byte C_197;
		word32 eax_199;
		struct Eq_976 * fs_200;
		word32 esi_201;
		word32 edi_202;
		byte SCZO_203;
		byte Z_204;
		word32 ecx_205;
		initterm();
		globals->dw403370 = 0x02;
		esp_213 = esp_194 + 0x04;
	}
	if (*(ebp_10 - 0x1C) == 0x00)
	{
		LONG * esp_184 = esp_213 - 0x04;
		*esp_184 = (int32) 0x00;
		*(esp_184 - 0x04) = 0x00403374;
		InterlockedExchange(*(esp_184 - 0x04), *esp_184);
	}
	ptr32 esp_159 = esp_213;
	if (globals->ptr403380 != null)
	{
		word32 * esp_154 = esp_213 - 0x04;
		*esp_154 = 0x00403380;
		word32 eax_157 = fn004017F0(dwArg00, out edx);
		esp_159 = esp_154 + 0x01;
		if (eax_157 != 0x00)
		{
			*esp_154 = 0x00;
			*(esp_154 - 0x04) = 0x02;
			*(esp_154 - 0x08) = 0x00;
			word32 ebx_170;
			byte SZO_171;
			byte C_172;
			word32 ebp_173;
			word32 eax_174;
			struct Eq_1102 * fs_175;
			word32 esi_176;
			word32 edi_177;
			byte SCZO_178;
			byte Z_179;
			word32 ecx_180;
			globals->ptr403380();
		}
	}
	*_initenv = globals->dw40301C;
	int32 * esp_103 = esp_159 - 0x04;
	*esp_103 = globals->dw40301C;
	*(esp_103 - 0x04) = globals->dw403020;
	*(esp_103 - 0x08) = globals->dw403018;
	word32 ebx_111;
	int32 eax_113 = fn00401200(edx, es, ds, dwArg00, out ebx_111, out ebp_10);
	globals->dw403030 = eax_113;
	if (globals->dw403024 == ebx_111)
	{
		*esp_103 = eax_113;
		exit(*esp_103);
	}
	if (globals->dw403034 == ebx_111)
	{
		word32 esp_138;
		word32 ebx_139;
		byte SZO_140;
		byte C_141;
		word32 eax_143;
		struct Eq_1136 * fs_144;
		word32 esi_145;
		word32 edi_146;
		byte SCZO_147;
		byte Z_148;
		word32 ecx_149;
		word32 edx_150;
		struct Eq_1143 * es_151;
		struct Eq_1144 * ds_152;
		cexit();
	}
	*(ebp_10 - 0x04) = ~0x01;
	eax_137 = globals->dw403030;
l00401405:
	fn00401901(ebp_10, 0x10, dwArg00, dwArg04, dwArg08, dwArg0C);
	return eax_137;
}

// 00401760: Register word32 fn00401760(Stack word32 dwArg04, Register out ptr32 edxOut)
word32 fn00401760(word32 dwArg04, ptr32 & edxOut)
{
	*edxOut = edx;
	if (dwArg04->w0000 == 23117)
	{
		struct Eq_1158 * eax_40 = dwArg04 + dwArg04->dw003C / 0x0040;
		if (eax_40->dw0000 == 0x4550)
		{
			word32 edx_50 = (word32) (eax_40->w0018 == 0x010B);
			*edxOut = edx_50;
			return edx_50;
		}
	}
	return 0x00;
}

// 004017A0: Register (ptr Eq_1177) fn004017A0(Stack word32 dwArg04, Stack ui32 dwArg08, Register out ptr32 edxOut)
Eq_1177 * fn004017A0(word32 dwArg04, ui32 dwArg08, ptr32 & edxOut)
{
	struct Eq_1181 * ecx_12 = dwArg04 + dwArg04->dw003C / 0x0040;
	uint32 esi_20 = (word32) ecx_12->w0006;
	uint32 edx_21;
	*edxOut = 0x00;
	struct Eq_1177 * eax_24 = &(ecx_12 + ((word32) ecx_12->w0014 + 0x18) / 22)->w0006 + 0x03;
	if (true)
	{
		do
		{
			uint32 ecx_57 = eax_24->dw0000;
			if (dwArg08 >= ecx_57 && dwArg08 < eax_24->dw0008 + ecx_57)
				return eax_24;
			edx_21 = edx_21 + 0x01;
			*edxOut = edx_21;
			eax_24 = eax_24 + 0x01;
		} while (edx_21 < esi_20);
	}
	eax_24 = null;
	return eax_24;
}

// 004017F0: Register ui32 fn004017F0(Stack word32 dwArg04, Register out ptr32 edxOut)
ui32 fn004017F0(word32 dwArg04, ptr32 & edxOut)
{
	ptr32 eax_16 = fs->ptr0000;
	fs->ptr0000 = fp - 0x14;
	word32 edx_43;
	if (fn00401760(0x00400000, out edx_43) != 0x00)
	{
		word32 edx_96;
		struct Eq_1246 * eax_97 = fn004017A0(0x00400000, dwArg04 - 0x00400000, out edx_96);
		if (eax_97 != null)
		{
			uint32 eax_104 = ~(eax_97->dw0024 >> 0x1F);
			fs->ptr0000 = eax_16;
			return eax_104 & 0x01;
		}
	}
	fs->ptr0000 = eax_16;
	return 0x00;
}

// 004018BC: Register ptr32 fn004018BC(Register word32 ebx, Register word32 esi, Register word32 edi, Stack word32 dwArg00, Stack word32 dwArg04, Stack word32 dwArg08)
ptr32 fn004018BC(word32 ebx, word32 esi, word32 edi, word32 dwArg00, word32 dwArg04, word32 dwArg08)
{
	ptr32 esp_14 = fp - 0x08 - dwArg08;
	*(esp_14 - 0x04) = ebx;
	*(esp_14 - 0x08) = esi;
	*(esp_14 - 0x0C) = edi;
	*(esp_14 - 0x10) = globals->dw403000 ^ fp + 0x08;
	*(esp_14 - 0x14) = dwArg00;
	fs->ptr0000 = fp - 0x08;
	return fp + 0x08;
}

// 00401901: void fn00401901(Register (ptr word32) ebp, Stack word32 dwArg00, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
void fn00401901(word32 * ebp, word32 dwArg00, word32 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	fs->dw0000 = *(ebp - 0x10);
	*ebp = dwArg00;
	return;
}

// 00401968: void fn00401968()
void fn00401968()
{
	ui32 eax_10 = globals->dw403000;
	if (eax_10 != 0xBB40E64E && (eax_10 & 0xFFFF0000) != 0x00)
		globals->dw403004 = ~eax_10;
	else
	{
		GetSystemTimeAsFileTime(fp - 0x0C);
		ui32 esi_59 = dwLoc08 & 0x00 ^ dwLoc0C & 0x00 ^ GetCurrentProcessId() ^ GetCurrentThreadId() ^ GetTickCount();
		QueryPerformanceCounter(fp - 0x14);
		ui32 esi_69 = esi_59 ^ (dwLoc10 ^ dwLoc14);
		if (esi_69 == 0xBB40E64E)
			esi_69 = ~0x44BF19B0;
		else if ((esi_69 & 0xFFFF0000) == 0x00)
			esi_69 = esi_69 | esi_69 << 0x10;
		globals->dw403000 = esi_69;
		globals->dw403004 = ~esi_69;
	}
	return;
}

