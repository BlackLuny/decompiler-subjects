//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker * e12;
    struct _IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_marker {
    struct _IO_marker * e0;
    struct _IO_FILE * e1;
    int32_t e2;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

void dumpline(char * p, int32_t offset, int32_t cnt);
int32_t hexdump(char * fname);

// ------------------------ Functions -------------------------

// From module:   /home/gcaprino/t/hd.c
// Address range: 0x8048634 - 0x80487c5
// Line range:    5 - 27
void dumpline(char * p, int32_t offset, int32_t cnt) {
    char v1[80];
    char str[80];
    int32_t v2;
    int32_t c = v2; // bp-104
    int32_t v3;
    int32_t v4 = &v3; // ebp
    int32_t v5 = (int32_t)p; // 0x804863e_0
    int32_t v6 = *(int32_t *)20; // 0x8048645
    int32_t v7 = (int32_t)&str; // 0x804865f_0
    sprintf(str, "%08lX:", offset);
    int32_t v8 = cnt > 16 ? 16 : cnt;
    v1[0] = 0;
    char v9 = 0; // 0x80486db
    int32_t v10; // 0x8048712
    char v11; // 0x8048771
    int32_t v12; // 0x804871f_0
    int32_t v13;
    char v14;
    char * v15;
    char v16; // 0x80486d4
    int32_t v17; // 0x8048722
    if (v8 > 0) {
        int32_t v18 = 0; // 0x8048680_0
        unsigned char v19 = *(char *)(v18 + v5); // 0x8048686
        sprintf((char *)(v7 + 9 + 3 * v18), " %02lX", (int32_t)v19);
        char v20 = v1[0] + 1; // 0x80486b2
        v1[0] = v20;
        int32_t dest_str = v20; // 0x80486b6_0
        v9 = v20;
        // branch -> 0x8048680
        while (dest_str < v8) {
            // 0x8048680
            v18 = v20;
            v19 = *(char *)(v18 + v5);
            sprintf((char *)(v7 + 9 + 3 * v18), " %02lX", (int32_t)v19);
            v20 = v1[0] + 1;
            v1[0] = v20;
            dest_str = v20;
            v9 = v20;
            // continue -> 0x8048680
        }
        while (true) {
            // 0x80486d4
            v16 = v9 - 15;
            v1[0] = v9 + 1;
            if (((int32_t)(v16 == 0 || v16 < 0 ^ (14 - v9 & v9) < 0) || dest_str & -256) == 0) {
                // 0x80486e3
                c = strlen(str);
                memcpy((char *)&v13, "  |", 4);
                v10 = c + 3;
                c = v10;
                v1[0] = 0;
                if (v8 > 0) {
                    v17 = v10;
                    char v21 = 0; // 0x8048741
                    while (true) {
                        // 0x804871f
                        v12 = v21;
                        v15 = (char *)(v12 + v5);
                        v14 = 46;
                        if (*v15 >= 32) {
                          lab_0x8048734:
                            // 0x8048734
                            if (*v15 <= 126) {
                                // 0x8048741
                                v14 = *v15;
                                // branch -> 0x8048751
                            } else {
                                v14 = 46;
                            }
                        }
                      lab_0x8048751:
                        // 0x8048751
                        *(char *)(v17 - 92 + v12 + v4) = v14;
                        char v22 = v1[0] + 1; // 0x8048755
                        v1[0] = v22;
                        if ((int32_t)v22 >= v8) {
                            // 0x8048775
                            if (v22 >= 16) {
                                // 0x804877b
                                memcpy((char *)(c + v7 + (int32_t)v22), "|", 2);
                                puts(str);
                                if (*(int32_t *)20 != v6) {
                                    // 0x80487b8
                                    __stack_chk_fail();
                                    // branch -> 0x80487bd
                                }
                                // 0x80487bd
                                return;
                            }
                            *(char *)(v4 - 92 + (int32_t)v22 + c) = 32;
                            v11 = v1[0] + 1;
                            v1[0] = v11;
                            while (v11 < 16) {
                                // 0x8048763
                                *(char *)(v4 - 92 + (int32_t)v11 + c) = 32;
                                v11 = v1[0] + 1;
                                v1[0] = v11;
                                // continue -> 0x8048763
                            }
                            // 0x804877b
                            memcpy((char *)(c + v7 + (int32_t)v11), "|", 2);
                            puts(str);
                            if (*(int32_t *)20 != v6) {
                                // 0x80487b8
                                __stack_chk_fail();
                                // branch -> 0x80487bd
                            }
                            // 0x80487bd
                            return;
                        }
                        // 0x8048751
                        v17 = c;
                        v21 = v22;
                        // branch -> 0x804871f
                    }
                }
                *(char *)(v4 - 92 + (int32_t)0 + c) = 32;
                v11 = v1[0] + 1;
                v1[0] = v11;
                while (v11 < 16) {
                    // 0x8048763
                    *(char *)(v4 - 92 + (int32_t)v11 + c) = 32;
                    v11 = v1[0] + 1;
                    v1[0] = v11;
                    // continue -> 0x8048763
                }
                // 0x804877b
                memcpy((char *)(c + v7 + (int32_t)v11), "|", 2);
                puts(str);
                if (*(int32_t *)20 != v6) {
                    // 0x80487b8
                    __stack_chk_fail();
                    // branch -> 0x80487bd
                }
                // 0x80487bd
                return;
            }
          lab_0x80486c0:
            // 0x80486c0
            dest_str = (int32_t)strcat(str, "   ");
            v9 = v1[0];
            // branch -> 0x80486d4
        }
    }
    while (true) {
        // 0x80486d4
        v16 = v9 - 15;
        v1[0] = v9 + 1;
        if ((int32_t)(v16 == 0 || v16 < 0 ^ (14 - v9 & v9) < 0) != 0) {
            goto lab_0x80486c0;
        }
        // 0x80486e3
        c = strlen(str);
        memcpy((char *)&v13, "  |", 4);
        v10 = c + 3;
        c = v10;
        v1[0] = 0;
        if (v8 > 0) {
            v17 = v10;
            while (true) {
                // 0x804871f
                v12 = 0;
                v15 = (char *)(v12 + v5);
                if (*v15 < 32) {
                    v14 = 46;
                    goto lab_0x8048751;
                }
                goto lab_0x8048734;
            }
        }
        *(char *)(v4 - 92 + (int32_t)0 + c) = 32;
        v11 = v1[0] + 1;
        v1[0] = v11;
        while (v11 < 16) {
            // 0x8048763
            *(char *)(v4 - 92 + (int32_t)v11 + c) = 32;
            v11 = v1[0] + 1;
            v1[0] = v11;
            // continue -> 0x8048763
        }
        // 0x804877b
        memcpy((char *)(c + v7 + (int32_t)v11), "|", 2);
        puts(str);
        if (*(int32_t *)20 != v6) {
            // 0x80487b8
            __stack_chk_fail();
            // branch -> 0x80487bd
        }
        // 0x80487bd
        return;
    }
}

// From module:   /home/gcaprino/t/hd.c
// Address range: 0x80487c6 - 0x80488c9
// Line range:    29 - 56
int32_t hexdump(char * fname) {
    char v1[16];
    char data[16];
    struct _IO_FILE * v2;
    struct _IO_FILE * fp = v2; // bp-44
    int32_t v3;
    int32_t offset = v3; // bp-40
    int32_t v4 = *(int32_t *)20; // 0x80487d9
    int32_t buf;
    if (stat(fname, (struct stat *)&buf) != 0) {
        // 0x80487fc
        perror(fname);
        // branch -> 0x80488b7
        // 0x80488b7
        if (*(int32_t *)20 != v4) {
            // 0x80488c3
            __stack_chk_fail();
            // branch -> 0x80488c8
        }
        // 0x80488c8
        return 1;
    }
    struct _IO_FILE * file = fopen(fname, "rb"); // 0x8048826
    int32_t file2 = (int32_t)file; // 0x8048826_5
    offset = file2;
    int32_t v5; // eax
    int32_t v6; // bp+214
    if (file == NULL) {
        // 0x8048834
        perror(fname);
        v5 = 1;
        v6 = 1;
        // branch -> 0x80488b7
    } else {
        // 0x8048849
        v1[0] = 0;
        uint32_t v7;
        if (v7 != 0) {
            int32_t items_read = fread(data, 1, 16, file); // 0x804886f23
            fp = (struct _IO_FILE *)items_read;
            if (items_read != 0) {
                while (true) {
                    // 0x804887d
                    dumpline(data, (int32_t)v1[0], items_read);
                    uint32_t v8 = (int32_t)v1[0] + (int32_t)fp; // 0x8048899
                    v1[0] = v8;
                    if (v7 > v8) {
                        int32_t items_read2 = fread(data, 1, 16, (struct _IO_FILE *)offset); // 0x804886f
                        fp = (struct _IO_FILE *)items_read2;
                        if (items_read2 == 0) {
                            // break -> 0x80488a7
                            break;
                        }
                        items_read = items_read2;
                        // continue -> 0x804887d
                        continue;
                    }
                }
                // 0x80488a7
                // branch -> 0x80488a7
                // 0x80488a7
                fclose((struct _IO_FILE *)offset);
                // branch -> 0x80488b7
                // 0x80488b7
                if (*(int32_t *)20 != v4) {
                    // 0x80488c3
                    __stack_chk_fail();
                    // branch -> 0x80488c8
                }
                // 0x80488c8
                return 0;
            }
            // 0x80488a7
            file2 = offset;
            // branch -> 0x80488a7
        }
        // 0x80488a7
        fclose((struct _IO_FILE *)file2);
        v5 = 0;
        v6 = 0;
        // branch -> 0x80488b7
    }
    // 0x80488b7
    int32_t result; // 0x80488c9_2
    if (*(int32_t *)20 != v4) {
        // 0x80488c3
        __stack_chk_fail();
        result = v5;
        // branch -> 0x80488c8
    } else {
        result = v6;
    }
    // 0x80488c8
    return result;
}

// From module:   /home/gcaprino/t/hd.c
// Address range: 0x80488ca - 0x804891f
// Line range:    58 - 67
int main(int argc, char ** argv) {
    // 0x80488ca
    int32_t v1;
    int32_t errs = v1; // bp-24
    int32_t v2;
    int32_t i = v2; // bp-20
    errs = 0;
    i = 1;
    int32_t result = 0; // 0x804890b
    if (argc > 1) {
        int32_t v3 = *(int32_t *)(4 + (int32_t)argv); // 0x80488ef
        int32_t v4 = errs + hexdump((char *)v3); // 0x80488f9
        errs = v4;
        int32_t v5 = i + 1; // 0x80488fd
        i = v5;
        // branch -> 0x80488e5
        while (v5 < argc) {
            // 0x80488e5
            v3 = *(int32_t *)(4 * v5 + (int32_t)argv);
            v4 = errs + hexdump((char *)v3);
            errs = v4;
            v5 = i + 1;
            i = v5;
            // continue -> 0x80488e5
        }
        // 0x8048902
        result = v4;
        // branch -> 0x804890b
    }
    // 0x804890b
    return result;
}

// --------------- Statically Linked Functions ----------------

// int stat(const char * restrict file, struct stat * restrict buf);

// --------------- Dynamically Linked Functions ---------------

// void __stack_chk_fail(void);
// int fclose(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void perror(const char * s);
// int puts(const char * s);
// int sprintf(char * restrict s, const char * restrict format, ...);
// char * strcat(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected language: C
// Detected functions: 3
// Decompiler release: VERSION
// Decompilation date: DATE
