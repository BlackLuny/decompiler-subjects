// Generated by Rec Studio 4 - build Apr 15 2012

_init()
{// addr = 0x08049BFC
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0x8b3e8)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    return;
}

L08049C08()
{
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0x8b3e8)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

int fileno(struct _IO_FILE* fp)
{// addr = 0x08049C3C
    goto __imp__fileno;
}

int fputs(char* str, struct _IO_FILE* fp)
{// addr = 0x08049C4C
    goto __imp__fputs;
}

void abort()
{// addr = 0x08049C5C
    goto __imp__abort;
}

int* __errno_location()
{// addr = 0x08049C6C
    goto __imp____errno_location;
}

sigemptyset()
{// addr = 0x08049C7C
    goto __imp__sigemptyset;
}

inet_ntop()
{// addr = 0x08049C8C
    goto __imp__inet_ntop;
}

int sprintf(char* dst, char* format)
{// addr = 0x08049C9C
    goto __imp__sprintf;
}

struct _IO_FILE* popen(char* name, char* mode)
{// addr = 0x08049CAC
    goto __imp__popen;
}

int open()
{// addr = 0x08049CBC
    goto __imp__open;
}

connect()
{// addr = 0x08049CCC
    goto __imp__connect;
}

int getpid()
{// addr = 0x08049CDC
    goto __imp__getpid;
}

mkdir()
{// addr = 0x08049CEC
    goto __imp__mkdir;
}

void srand48(long __seedval)
{// addr = 0x08049CFC
    goto __imp__srand48;
}

char* strerror(int __errnum)
{// addr = 0x08049D0C
    goto __imp__strerror;
}

getsockname()
{// addr = 0x08049D1C
    goto __imp__getsockname;
}

memcmp()
{// addr = 0x08049D2C
    goto __imp__memcmp;
}

void qsort(void* __base, int __nmemb, int __size, __compar_fn_t __compar)
{// addr = 0x08049D3C
    goto __imp__qsort;
}

inet_ntoa()
{// addr = 0x08049D4C
    goto __imp__inet_ntoa;
}

freeaddrinfo()
{// addr = 0x08049D5C
    goto __imp__freeaddrinfo;
}

void* bsearch(void* __key, void* __base, int __nmemb, int __size, __compar_fn_t __compar)
{// addr = 0x08049D6C
    goto __imp__bsearch;
}

tgetflag()
{// addr = 0x08049D7C
    goto __imp__tgetflag;
}

__xstat()
{// addr = 0x08049D8C
    goto __imp____xstat;
}

__gmon_start__()
{// addr = 0x08049D9C
    goto __imp____gmon_start__;
}

__lxstat()
{// addr = 0x08049DAC
    goto __imp____lxstat;
}

__isoc99_sscanf()
{// addr = 0x08049DBC
    goto __imp____isoc99_sscanf;
}

int vsprintf(char* string, char* format, _G_va_list vals)
{// addr = 0x08049DCC
    goto __imp__vsprintf;
}

localtime()
{// addr = 0x08049DDC
    goto __imp__localtime;
}

__caddr_t getpass(char* __prompt)
{// addr = 0x08049DEC
    goto __imp__getpass;
}

char* strchr(char* __s, int __c)
{// addr = 0x08049DFC
    goto __imp__strchr;
}

char* getenv(char* __name)
{// addr = 0x08049E0C
    goto __imp__getenv;
}

int system(char* __command)
{// addr = 0x08049E1C
    goto __imp__system;
}

char* strncpy(char* __dest, char* __src, int __n)
{// addr = 0x08049E2C
    goto __imp__strncpy;
}

int putchar(int ch)
{// addr = 0x08049E3C
    goto __imp__putchar;
}

__caddr_t ttyname(int __fd)
{// addr = 0x08049E4C
    goto __imp__ttyname;
}

int write(int __fd, void* __buf, int __n)
{// addr = 0x08049E5C
    goto __imp__write;
}

GC_realloc()
{// addr = 0x08049E6C
    goto __imp__GC_realloc;
}

int rename(char* _old, char* _new)
{// addr = 0x08049E7C
    goto __imp__rename;
}

void* memset(void* __s, int __c, int __n)
{// addr = 0x08049E8C
    goto __imp__memset;
}

__libc_start_main()
{// addr = 0x08049E9C
    goto __imp____libc_start_main;
}

int execl(char* __path, char* __arg)
{// addr = 0x08049EAC
    goto __imp__execl;
}

_IO_getc()
{// addr = 0x08049EBC
    goto __imp___IO_getc;
}

floor()
{// addr = 0x08049ECC
    goto __imp__floor;
}

tcgetattr()
{// addr = 0x08049EEC
    goto __imp__tcgetattr;
}

chmod()
{// addr = 0x08049EFC
    goto __imp__chmod;
}

GC_set_warn_proc()
{// addr = 0x08049F0C
    goto __imp__GC_set_warn_proc;
}

__builtin_va_list bindtextdomain(char* __domainname, char* __dirname)
{// addr = 0x08049F1C
    goto __imp__bindtextdomain;
}

GC_malloc()
{// addr = 0x08049F2C
    goto __imp__GC_malloc;
}

int read(int __fd, void* __buf, int __nbytes)
{// addr = 0x08049F3C
    goto __imp__read;
}

strtoll()
{// addr = 0x08049F4C
    goto __imp__strtoll;
}

__builtin_va_list gettext(char* __msgid)
{// addr = 0x08049F5C
    goto __imp__gettext;
}

int ungetc(int c, struct _IO_FILE* fp)
{// addr = 0x08049F6C
    goto __imp__ungetc;
}

readdir()
{// addr = 0x08049F7C
    goto __imp__readdir;
}

long strtol(char* __nptr, char** __endptr, int __base)
{// addr = 0x08049F8C
    goto __imp__strtol;
}

struct _IO_FILE* fdopen(int fd, char* name)
{// addr = 0x08049F9C
    goto __imp__fdopen;
}

siglongjmp()
{// addr = 0x08049FAC
    goto __imp__siglongjmp;
}

tgetent()
{// addr = 0x08049FBC
    goto __imp__tgetent;
}

sigaction()
{// addr = 0x08049FCC
    goto __imp__sigaction;
}

int fflush(struct _IO_FILE* fp)
{// addr = 0x08049FDC
    goto __imp__fflush;
}

sqrt()
{// addr = 0x08049FEC
    goto __imp__sqrt;
}

opendir()
{// addr = 0x08049FFC
    goto __imp__opendir;
}

int symlink(char* __from, char* __to)
{// addr = 0x0804A00C
    goto __imp__symlink;
}

ioctl()
{// addr = 0x0804A01C
    goto __imp__ioctl;
}

socket()
{// addr = 0x0804A02C
    goto __imp__socket;
}

int dup2(int __fd, int __fd2)
{// addr = 0x0804A03C
    goto __imp__dup2;
}

int fseek(struct _IO_FILE* fp, long offset, int whence)
{// addr = 0x0804A04C
    goto __imp__fseek;
}

int execlp(char* __file, char* arg)
{// addr = 0x0804A05C
    goto __imp__execlp;
}

int isatty(int __fd)
{// addr = 0x0804A06C
    goto __imp__isatty;
}

getaddrinfo()
{// addr = 0x0804A07C
    goto __imp__getaddrinfo;
}

int fclose(struct _IO_FILE* fp)
{// addr = 0x0804A08C
    goto __imp__fclose;
}

void bcopy(void* __src, void* __dest, int __n)
{// addr = 0x0804A09C
    goto __imp__bcopy;
}

int dup(int __fd)
{// addr = 0x0804A0AC
    goto __imp__dup;
}

mktime()
{// addr = 0x0804A0BC
    goto __imp__mktime;
}

void* memcpy(void* __dest, void* __src, int __n)
{// addr = 0x0804A0CC
    goto __imp__memcpy;
}

utime()
{// addr = 0x0804A0DC
    goto __imp__utime;
}

int strlen(char* __s)
{// addr = 0x0804A0EC
    goto __imp__strlen;
}

struct _IO_FILE* fopen(char* name, char* mode)
{// addr = 0x0804A0FC
    goto __imp__fopen;
}

int alarm(int __seconds)
{// addr = 0x0804A10C
    goto __imp__alarm;
}

int unlink(char* __name)
{// addr = 0x0804A11C
    goto __imp__unlink;
}

getpwuid()
{// addr = 0x0804A12C
    goto __imp__getpwuid;
}

struct _IO_FILE* freopen(char* name, char* mode, struct _IO_FILE* fp)
{// addr = 0x0804A13C
    goto __imp__freopen;
}

__builtin_va_list setlocale(int __category, char* __locale)
{// addr = 0x0804A14C
    goto __imp__setlocale;
}

waitpid()
{// addr = 0x0804A15C
    goto __imp__waitpid;
}

int fgetc(struct _IO_FILE* fp)
{// addr = 0x0804A16C
    goto __imp__fgetc;
}

int feof(struct _IO_FILE* fp)
{// addr = 0x0804A17C
    goto __imp__feof;
}

char* strcpy(char* __dest, char* __src)
{// addr = 0x0804A18C
    goto __imp__strcpy;
}

short getegid()
{// addr = 0x0804A19C
    goto __imp__getegid;
}

int printf(char* format)
{// addr = 0x0804A1AC
    goto __imp__printf;
}

int chdir(char* __path)
{// addr = 0x0804A1BC
    goto __imp__chdir;
}

ctime()
{// addr = 0x0804A1CC
    goto __imp__ctime;
}

tputs()
{// addr = 0x0804A1DC
    goto __imp__tputs;
}

short getuid()
{// addr = 0x0804A1EC
    goto __imp__getuid;
}

long atol(char* __nptr)
{// addr = 0x0804A1FC
    goto __imp__atol;
}

long lrand48()
{// addr = 0x0804A20C
    goto __imp__lrand48;
}

gethostbyaddr()
{// addr = 0x0804A21C
    goto __imp__gethostbyaddr;
}

int atoi(char* __nptr)
{// addr = 0x0804A22C
    goto __imp__atoi;
}

int strcasecmp(char* __s1, char* __s2)
{// addr = 0x0804A23C
    goto __imp__strcasecmp;
}

double atof(char* __nptr)
{// addr = 0x0804A24C
    goto __imp__atof;
}

GC_free()
{// addr = 0x0804A25C
    goto __imp__GC_free;
}

select()
{// addr = 0x0804A26C
    goto __imp__select;
}

closedir()
{// addr = 0x0804A27C
    goto __imp__closedir;
}

Gpm_Wgetch()
{// addr = 0x0804A28C
    goto __imp__Gpm_Wgetch;
}

int close(int __fd)
{// addr = 0x0804A29C
    goto __imp__close;
}

int fwrite(void* src, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x0804A2AC
    goto __imp__fwrite;
}

int fprintf(struct _IO_FILE* fp, char* format)
{// addr = 0x0804A2BC
    goto __imp__fprintf;
}

char* strstr(char* __haystack, char* __needle)
{// addr = 0x0804A2CC
    goto __imp__strstr;
}

time()
{// addr = 0x0804A2DC
    goto __imp__time;
}

nl_langinfo()
{// addr = 0x0804A2EC
    goto __imp__nl_langinfo;
}

__stack_chk_fail()
{// addr = 0x0804A2FC
    goto __imp____stack_chk_fail;
}

Gpm_Close()
{// addr = 0x0804A30C
    goto __imp__Gpm_Close;
}

int gethostname(__caddr_t __name, int __len)
{// addr = 0x0804A31C
    goto __imp__gethostname;
}

atan2()
{// addr = 0x0804A32C
    goto __imp__atan2;
}

int fputc(int ch, struct _IO_FILE* fp)
{// addr = 0x0804A33C
    goto __imp__fputc;
}

char* strtok(char* __s, char* __delim)
{// addr = 0x0804A34C
    goto __imp__strtok;
}

tgoto()
{// addr = 0x0804A35C
    goto __imp__tgoto;
}

strcasestr()
{// addr = 0x0804A36C
    goto __imp__strcasestr;
}

int sleep(int __seconds)
{// addr = 0x0804A37C
    goto __imp__sleep;
}

tgetnum()
{// addr = 0x0804A38C
    goto __imp__tgetnum;
}

int readlink(char* __path, __caddr_t __buf, int __len)
{// addr = 0x0804A39C
    goto __imp__readlink;
}

int strncasecmp(char* __s1, char* __s2, int __n)
{// addr = 0x0804A3AC
    goto __imp__strncasecmp;
}

getnameinfo()
{// addr = 0x0804A3BC
    goto __imp__getnameinfo;
}

char* strcat(char* __dest, char* __src)
{// addr = 0x0804A3CC
    goto __imp__strcat;
}

__caddr_t getcwd(__caddr_t __buf, int __size)
{// addr = 0x0804A3DC
    goto __imp__getcwd;
}

log()
{// addr = 0x0804A3EC
    goto __imp__log;
}

int puts(char* str)
{// addr = 0x0804A3FC
    goto __imp__puts;
}

int fork()
{// addr = 0x0804A40C
    goto __imp__fork;
}

int setpgrp()
{// addr = 0x0804A41C
    goto __imp__setpgrp;
}

__builtin_va_list textdomain(char* __domainname)
{// addr = 0x0804A42C
    goto __imp__textdomain;
}

tcsetattr()
{// addr = 0x0804A43C
    goto __imp__tcsetattr;
}

void bzero(void* __s, int __n)
{// addr = 0x0804A44C
    goto __imp__bzero;
}

int strspn(char* __s, char* __accept)
{// addr = 0x0804A45C
    goto __imp__strspn;
}

int sscanf(char* string, char* format)
{// addr = 0x0804A46C
    goto __imp__sscanf;
}

__fxstat()
{// addr = 0x0804A47C
    goto __imp____fxstat;
}

gmtime()
{// addr = 0x0804A48C
    goto __imp__gmtime;
}

int fscanf(struct _IO_FILE* fp, char* format)
{// addr = 0x0804A49C
    goto __imp__fscanf;
}

void* memchr(void* __s, int __c, int __n)
{// addr = 0x0804A4AC
    goto __imp__memchr;
}

int strncmp(char* __s1, char* __s2, int __n)
{// addr = 0x0804A4BC
    goto __imp__strncmp;
}

_IO_putc()
{// addr = 0x0804A4CC
    goto __imp___IO_putc;
}

int pipe(int* __pipedes)
{// addr = 0x0804A4DC
    goto __imp__pipe;
}

Gpm_Open()
{// addr = 0x0804A4EC
    goto __imp__Gpm_Open;
}

int fread(_G_va_list dst, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x0804A4FC
    goto __imp__fread;
}

strftime()
{// addr = 0x0804A50C
    goto __imp__strftime;
}

GC_malloc_atomic()
{// addr = 0x0804A51C
    goto __imp__GC_malloc_atomic;
}

tgetstr()
{// addr = 0x0804A52C
    goto __imp__tgetstr;
}

kill()
{// addr = 0x0804A53C
    goto __imp__kill;
}

int strcspn(char* __s, char* __reject)
{// addr = 0x0804A54C
    goto __imp__strcspn;
}

char* strdup(char* __s)
{// addr = 0x0804A55C
    goto __imp__strdup;
}

getpeername()
{// addr = 0x0804A56C
    goto __imp__getpeername;
}

int ferror(struct _IO_FILE* fp)
{// addr = 0x0804A57C
    goto __imp__ferror;
}

getpwnam()
{// addr = 0x0804A58C
    goto __imp__getpwnam;
}

tolower()
{// addr = 0x0804A59C
    goto __imp__tolower;
}

int strcmp(char* __s1, char* __s2)
{// addr = 0x0804A5AC
    goto __imp__strcmp;
}

__sigsetjmp()
{// addr = 0x0804A5BC
    goto __imp____sigsetjmp;
}

int setenv(char* __name, char* __value, int __overwrite)
{// addr = 0x0804A5CC
    goto __imp__setenv;
}

void exit(int __status)
{// addr = 0x0804A5DC
    goto __imp__exit;
}

int pclose(struct _IO_FILE* fp)
{// addr = 0x0804A5EC
    goto __imp__pclose;
}

ceil()
{// addr = 0x0804A5FC
    goto __imp__ceil;
}

short geteuid()
{// addr = 0x0804A60C
    goto __imp__geteuid;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x0804A620
    _unknown_ __ebx;                       // r1
    signed int _t5;                        // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __edx = __edx;
    _t4 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & 240;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(_t10);
    _push(main);
    __libc_start_main();
    asm("hlt ");
    0;
    0;
    _push(0);
    _push(_t6);
    __esp = __esp - 4;
    if(completed.7065 == 0) {
        _t4 = dtor_idx.7067;
        _t6 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t4 < _t6) {
            while(1) {
                _t5 = _t4 + 1;
                dtor_idx.7067 = _t5;
                 *((intOrPtr*)(_t5 * 4 +  &__DTOR_LIST__))();
                _t4 = dtor_idx.7067;
                if(_t4 >= _t6) {
                    break;
                }
            }
        }
        completed.7065 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
    return;
}

__do_global_dtors_aux(
    _unknown_ __esi                        // r5
)
{// addr = 0x0804A650
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    signed int _t5;                        // _t5
    signed int _t6;                        // _t6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    if(completed.7065 == 0) {
        _t5 = dtor_idx.7067;
        _t10 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t5 >= _t10) {
L4:
            completed.7065 = 1;
            return;
        }
        while(1) {
            _t6 = _t5 + 1;
            dtor_idx.7067 = _t6;
             *((intOrPtr*)(_t6 * 4 +  &__DTOR_LIST__))();
            _t5 = dtor_idx.7067;
            if(_t5 >= _t10) {
                break;
            }
        }
        goto L4;
    }
    return;
}

frame_dummy()
{// addr = 0x0804A6B0
    _unknown_ __ebp;                       // r6

    __eax = __JCR_LIST__;
    if(__JCR_LIST__ != 0) {
        __eax = 0;
        if(__eax == 0) {
        } else {
             *__esp =  &__JCR_LIST__;
             *__eax();
            return;
        }
    }
    return;
}

fversion(FILE* f)
{// addr = 0x0804A6D4  --  defined in 'main.c' at line 117
    char* _v16;                            // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    _v16 = "lang=en,m17n,image,color,ansi-color,mouse,gpm,menu,cookie,external-uri-loader,w3mmailer,nntp,gopher,ipv6,alarm,mark,migemo";
    _v20 = w3m_version;
    fprintf(f, "w3m version %s, options %s\n");
    return;
}

fusage(FILE* f, int err)
{// addr = 0x0804A702  --  defined in 'main.c' at line 186
    char* _v0;                             // _cfa_0
    _unknown_ _v16;                        // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    FILE* _v64;           // _cfa_ffffffc0
    FILE* _v68;           // _cfa_ffffffbc
    _unknown_ __ebp;                       // r6
    _unknown_ _t219;                       // _t219
    _unknown_ _t221;                       // _t221
    _unknown_ _t223;                       // _t223
    _unknown_ _t225;                       // _t225
    _unknown_ _t227;                       // _t227
    _unknown_ _t229;                       // _t229
    _unknown_ _t231;                       // _t231
    _unknown_ _t233;                       // _t233
    _unknown_ _t235;                       // _t235
    _unknown_ _t237;                       // _t237
    _unknown_ _t239;                       // _t239
    _unknown_ _t241;                       // _t241
    _unknown_ _t243;                       // _t243
    _unknown_ _t245;                       // _t245
    _unknown_ _t247;                       // _t247
    _unknown_ _t249;                       // _t249
    _unknown_ _t251;                       // _t251
    _unknown_ _t253;                       // _t253
    _unknown_ _t255;                       // _t255
    _unknown_ _t257;                       // _t257
    _unknown_ _t259;                       // _t259
    _unknown_ _t261;                       // _t261
    _unknown_ _t263;                       // _t263
    _unknown_ _t265;                       // _t265
    _unknown_ _t267;                       // _t267
    _unknown_ _t269;                       // _t269
    _unknown_ _t271;                       // _t271
    _unknown_ _t273;                       // _t273
    _unknown_ _t275;                       // _t275
    _unknown_ _t277;                       // _t277
    _unknown_ _t279;                       // _t279
    _unknown_ _t281;                       // _t281
    _unknown_ _t283;                       // _t283
    _unknown_ _t285;                       // _t285
    _unknown_ _t287;                       // _t287
    _unknown_ _t289;                       // _t289
    _unknown_ _t291;                       // _t291
    _unknown_ _t293;                       // _t293
    _unknown_ _t295;                       // _t295
    _unknown_ _t297;                       // _t297
    _unknown_ _t299;                       // _t299
    _unknown_ _t301;                       // _t301
    _unknown_ _t303;                       // _t303
    _unknown_ _t305;                       // _t305
    _unknown_ _t307;                       // _t307
    _unknown_ _t310;                       // _t310
    _unknown_ _t319;                       // _t319
    _unknown_ _t333;                       // _t333
    _unknown_ _t342;                       // _t342
    _unknown_ _t343;                       // _t343
    _unknown_ _t402;                       // _t402
    _unknown_ _t409;                       // _t409
    _unknown_ _t415;                       // _t415
    _unknown_ _t416;                       // _t416

    fversion(f);
    fwrite("usage: w3m [options] [URL or filename]\noptions:\n", 1, 48, f);
    fwrite("    -t tab           set tab width\n", 1, 35, f);
    fwrite("    -r               ignore backspace effect\n", 1, 45, f);
    fwrite("    -l line          # of preserved line (default 10000)\n", 1, 57, f);
    fwrite("    -I charset       document charset\n", 1, 38, f);
    fwrite("    -O charset       display/output charset\n", 1, 44, f);
    fwrite("    -B               load bookmark\n", 1, 35, f);
    fwrite("    -bookmark file   specify bookmark file\n", 1, 43, f);
    fwrite("    -T type          specify content-type\n", 1, 42, f);
    fwrite("    -m               internet message mode\n", 1, 43, f);
    fwrite("    -v               visual startup mode\n", 1, 41, f);
    fwrite("    -M               monochrome display\n", 1, 40, f);
    fwrite("    -N               open URL of command line on each new tab\n", 1, 62, f);
    fwrite("    -F               automatically render frame\n", 1, 48, f);
    fwrite("    -cols width      specify column width (used with -dump)\n", 1, 60, f);
    fwrite("    -ppc count       specify the number of pixels per character (4.0...32.0)\n", 1, 77, f);
    fwrite("    -ppl count       specify the number of pixels per line (4.0...64.0)\n", 1, 72, f);
    fwrite("    -dump            dump formatted page into stdout\n", 1, 53, f);
    fwrite("    -dump_head       dump response of HEAD request into stdout\n", 1, 63, f);
    fwrite("    -dump_source     dump page source into stdout\n", 1, 50, f);
    fwrite("    -dump_both       dump HEAD and source into stdout\n", 1, 54, f);
    fwrite("    -dump_extra      dump HEAD, source, and extra information into stdout\n", 1, 74, f);
    fwrite("    -post file       use POST method with file content\n", 1, 55, f);
    fwrite("    -header string   insert string as a header\n", 1, 47, f);
    fwrite("    +<num>           goto <num> line\n", 1, 37, f);
    fwrite("    -num             show line number\n", 1, 38, f);
    fwrite("    -no-proxy        don't use proxy\n", 1, 37, f);
    fwrite("    -4               IPv4 only (-o dns_order=4)\n", 1, 48, f);
    fwrite("    -6               IPv6 only (-o dns_order=6)\n", 1, 48, f);
    fwrite("    -no-mouse        don't use mouse\n", 1, 37, f);
    fwrite("    -cookie          use cookie (-no-cookie: don't use cookie)\n", 1, 63, f);
    fwrite("    -pauth user:pass proxy authentication\n", 1, 42, f);
    fwrite("    -graph           use graphic character\n", 1, 43, f);
    fwrite("    -no-graph        don't use graphic character\n", 1, 49, f);
    fwrite("    -s               squeeze multiple blank lines\n", 1, 50, f);
    fwrite("    -W               toggle wrap search mode\n", 1, 45, f);
    fwrite("    -X               don't use termcap init/deinit\n", 1, 51, f);
    fwrite("    -title[=TERM]    set buffer name to terminal title string\n", 1, 62, f);
    fwrite("    -o opt=value     assign value to config option\n", 1, 51, f);
    fwrite("    -show-option     print all config options\n", 1, 46, f);
    fwrite("    -config file     specify config file\n", 1, 41, f);
    fwrite("    -help            print this usage message\n", 1, 46, f);
    fwrite("    -version         print w3m version\n", 1, 39, f);
    fwrite("    -reqlog          write request logfile\n", 1, 43, f);
    fwrite("    -debug           DO NOT USE\n", 1, 32, f);
    if(show_params_p != 0) {
        show_params(f);
    }
    exit(err);
    _push(_t415);
    __esp = __esp - 40;
    if((fmInitialized & 0xff) == 0) {
        if(orig_GC_warn_proc == 0) {
            _v64 = f;
            fprintf(__imp__stderr, _v0);
            return;
        }
        goto L13;
    }
    _v20 = i + n - (((i + n) * -858993459 >> 32 >> 4 << 2) + ((i + n) * -858993459 >> 32 >> 4) << 2);
     *( &msg_ring + _v20 * 8) = _v0;
     *(135775524 + _v20 * 8) = f;
    if(n > 19) {
        i = i + 1;
    } else {
        n = n + 1;
    }
    if(lock == 0) {
        lock = 1;
        while(n > 0) {
            i = i - ((i * -858993459 >> 32 >> 4 << 2) + (i * -858993459 >> 32 >> 4) << 2);
            _v68 =  *(135775524 + i * 8);
            printf( *( &msg_ring + i * 8));
            sleep_till_anykey(1, 1);
            n = n - 1;
            i = i + 1;
        }
        lock = 0;
        return;
    }
    return;
L13:
    _v68 = f;
     *__esp = _v0;
     *orig_GC_warn_proc();
    return;
}

wrap_GC_warn_proc(char* msg, GC_word arg)
{// addr = 0x0804AD86  --  defined in 'main.c' at line 279
    int j;                                 // _cfa_fffffff0
    long unsigned int _v36;                // _cfa_ffffffdc
    long unsigned int _v40;                // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t42;                        // _t42
    _unknown_ _t56;                        // _t56
    _unknown_ _t65;                        // _t65
    _unknown_ _t66;                        // _t66
    _unknown_ _t79;                        // _t79
    _unknown_ _t86;                        // _t86

    if((fmInitialized & 0xff) == 0) {
        if(orig_GC_warn_proc == 0) {
            _v36 = arg;
            fprintf(__imp__stderr, msg);
            return;
        }
        goto L10;
    }
    j = i + n - (((i + n) * -858993459 >> 32 >> 4 << 2) + ((i + n) * -858993459 >> 32 >> 4) << 2);
     *( &msg_ring + j * 8) = msg;
     *(135775524 + j * 8) = arg;
    if(n > 19) {
        i = i + 1;
    } else {
        n = n + 1;
    }
    if(lock == 0) {
        lock = 1;
        while(n > 0) {
            i = i - ((i * -858993459 >> 32 >> 4 << 2) + (i * -858993459 >> 32 >> 4) << 2);
            _v40 =  *(135775524 + i * 8);
            printf( *( &msg_ring + i * 8));
            sleep_till_anykey(1, 1);
            n = n - 1;
            i = i + 1;
        }
        lock = 0;
        return;
    }
    return;
L10:
    _v40 = arg;
     *__esp = msg;
     *orig_GC_warn_proc();
    return;
}

sig_chld(int signo)
{// addr = 0x0804AEF1  --  defined in 'main.c' at line 323
    int p_stat;                            // _cfa_fffffff0
    pid_t pid;           // _cfa_ffffffec
    intOrPtr _v36;                         // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t7;                               // _t7
    _unknown_ _t8;                         // _t8

    while(1) {
        _v36 = 1;
        _t7 =  &p_stat;
        _v40 = _t7;
         *__esp = -1;
        waitpid();
        pid = _t7;
        if(pid <= 0) {
            break;
        }
    }
    mySignal(17, sig_chld);
    return;
}

Str make_optional_header_string(char* s)
{// addr = 0x0804AF31  --  defined in 'main.c' at line 347
    char* p;                               // _cfa_fffffff0
    Str hs;                // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t56;                        // _t56
    _unknown_ _t64;                        // _t64

    if(strchr(s, 10) != 0) {
L2:
        return 0;
    }
    if(strchr(s, 13) == 0) {
        p = s;
        while(( *p & 0xff) != 0 && ( *p & 0xff) != 58) {
        }
        if(( *p & 0xff) != 58 || p == s) {
            return 0;
        }
        hs = Strnew_size(strlen(s) + 3);
        Strcopy_charp_n(hs, s, p - s);
        if(strcasecmp(hs->ptr, "content-type") == 0) {
            override_content_type = 1;
        }
        Strcat_charp(hs, ": ");
        p =  &(p[1]);
        if(( *p & 0xff) == 0) {
L18:
            Strcat_charp(hs, "\n");
            return hs;
        } else {
            while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p =  &(p[1]);
            }
            Strcat_charp(hs, p);
            goto L18;
        }
        return __eax;
    }
    goto L2;
}

int main(int argc, char** argv, char** envp)
{// addr = 0x0804B07E  --  defined in 'main.c' at line 371
    Buffer* newbuf;     // r4+136
    char* p;                               // r4+132
    char c;                                // r4+143
    int i;                                 // r4+128
    InputStream redin;   // r4+124
    char* line_str;                        // r4+120
    char** load_argv;                      // r4+116
    FormList* request;   // r4+112
    int load_argc;                         // r4+108
    int load_bookmark;                     // r4+104
    int visual_start;                      // r4+100
    int open_new_tab;                      // r4+96
    char search_header;                    // r4+142
    char* default_type;                    // r4+92
    char* post_file;                       // r4+88
    Str err_msg;           // r4+84
    char* Locale;                          // r4+80
    wc_uint8 auto_detect;   // r4+141
    Str tmp;               // r4+76
    double ppc;                            // r4+48
    double ppc;                            // r4+40
    Str hs;                // r4+72
    Str s_page;            // r4+68
    FILE* fp;             // r4+64
    Str body;              // r4+60
    Anchor* a;          // r4+56
    _unknown_ _v21;                        // _cfa_ffffffeb
    signed int _v22;                       // _cfa_ffffffea
    signed char _v23;                      // _cfa_ffffffe9
    Buffer* _v28;       // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    union input_stream* _v40;   // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    char* _v76;                            // _cfa_ffffffb4
    struct _Str* _v80;    // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    struct _Str* _v88;    // _cfa_ffffffa8
    struct _Str* _v92;    // _cfa_ffffffa4
    struct _Str* _v96;    // _cfa_ffffffa0
    FILE* _v100;          // _cfa_ffffff9c
    struct _Str* _v104;   // _cfa_ffffff98
    _unknown_ _v108;                       // _cfa_ffffff94
    _unknown_ _v140;                       // _cfa_ffffff74
    _unknown_ _v144;                       // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    _None _v152;                           // _cfa_ffffff68
    char* _v156;                           // _cfa_ffffff64
    char* _v160;                           // _cfa_ffffff60
    _unknown_ _t810;                       // _t810
    _unknown_ _t811;                       // _t811
    _unknown_ _t812;                       // _t812
    signed int _t817;                      // _t817
    _unknown_ _t848;                       // _t848
    _unknown_ _t1085;                      // _t1085
    _unknown_ _t1152;                      // _t1152
    _unknown_ _t1162;                      // _t1162
    struct _Str* _t1203;   // _t1203
    signed int _t1252;                     // _t1252
    signed int _t1259;                     // _t1259
    int _t1298;                            // _t1298
    _unknown_ _t1399;                      // _t1399
    _None* _t1400;                         // _t1400
    TabBuffer* _t1427;   // _t1427
    int _t1440;                            // _t1440
    char _t1447;                           // _t1447
    _unknown_ _t1452;                      // _t1452
    _unknown_ _t1460;                      // _t1460
    _unknown_ _t1482;                      // _t1482
    _unknown_ _t1521;                      // _t1521
    _unknown_ _t1603;                      // _t1603
    _unknown_ _t1605;                      // _t1605
    int _t1615;                            // _t1615
    _unknown_ _t1616;                      // _t1616
    _unknown_ _t1635;                      // _t1635
    _unknown_ _t1644;                      // _t1644
    _unknown_ _t1651;                      // _t1651
    _unknown_ _t1677;                      // _t1677
    _unknown_ _t1678;                      // _t1678
    _unknown_ _t1679;                      // _t1679
    _unknown_ _t1683;                      // _t1683
    _unknown_ _t1723;                      // _t1723
    TabBuffer* _t1724;   // _t1724
    int _t1757;                            // _t1757
    _unknown_ _t1758;                      // _t1758
    _unknown_ _t1781;                      // _t1781
    TabBuffer* _t1782;   // _t1782

    __esp = __esp & 240;
    _push(_t1781);
    _push(_t1723);
    __esp = __esp - 152;
    _v28 = 0;
    _v44 = 0;
    _v56 = 0;
    _v60 = 0;
    _v64 = 0;
    _v68 = 0;
    _v22 = 0;
    _v72 = 0;
    _v76 = 0;
    _v84 = 0;
    setlocale(6, 135036496);
    bindtextdomain("w3m", "/usr/share/locale");
    textdomain("w3m");
    NO_proxy_domains = newGeneralList();
    fileToDelete = newGeneralList();
    _t817 = argc - 1 << 2;
     *__esp = _t817;
    GC_malloc();
    _v48 = _t817;
    _v56 = 0;
    CurrentDir = currentdir();
    CurrentPid = getpid();
    BookmarkFile = 0;
    config_file = 0;
    _v36 = 1;
    while(_v36 < argc) {
    }
    _v84 = getenv("LC_ALL");
    if(non_null(_v84) != 0) {
L17:
        DisplayCharset = wc_guess_locale_charset(_v84, DisplayCharset);
        DocumentCharset = wc_guess_locale_charset(_v84, DocumentCharset);
        SystemCharset = wc_guess_locale_charset(_v84, SystemCharset);
        goto L18;
    }
    _v84 = getenv("LC_CTYPE");
    if(non_null(_v84) != 0) {
        goto L17;
    }
    _v84 = getenv("LANG");
    if(non_null(_v84) == 0) {
        goto L18;
    }
    goto L17;
L18:
    init_rc();
    LoadHist = newHist();
    SaveHist = newHist();
    ShellHist = newHist();
    TextHist = newHist();
    URLHist = newHist();
    if((FollowLocale & 0xff) != 0) {
        if(_v84 != 0) {
            DisplayCharset = wc_guess_locale_charset(_v84, DisplayCharset);
            SystemCharset = wc_guess_locale_charset(_v84, SystemCharset);
        }
    }
    _v23 = WcOption.auto_detect & 0xff;
    BookmarkCharset = DocumentCharset;
    if(non_null(HTTP_proxy) != 0) {
L26:
        if(non_null(GOPHER_proxy) != 0) {
L31:
            if(non_null(FTP_proxy) != 0) {
L36:
                if(non_null(NO_proxy) != 0) {
L41:
                    if(non_null(NNTP_server) == 0) {
                        _v32 = getenv("NNTPSERVER");
                        if(_v32 != 0) {
                            NNTP_server = _v32;
                        }
                    }
                    if(non_null(NNTP_mode) == 0) {
                        _v32 = getenv("NNTPMODE");
                        if(_v32 != 0) {
                            NNTP_mode = _v32;
                        }
                    }
                    if(non_null(Editor) == 0) {
                        _v32 = getenv("EDITOR");
                        if(_v32 != 0) {
                            Editor = _v32;
                        }
                    }
                    if(non_null(Mailer) == 0) {
                        _v32 = getenv("MAILER");
                        if(_v32 != 0) {
                            Mailer = _v32;
                        }
                    }
                    _v36 = 1;
                    while(_v36 < argc) {
                        if(( *(argv[_v36]) & 0xff) != 45) {
                            if(( *(argv[_v36]) & 0xff) != 43) {
                                 *((_v56 << 2) + _v48) = argv[_v36];
                                _v56 = _v56 + 1;
                            } else {
                                _v44 =  &(argv[_v36][1]);
                            }
                            goto L224;
                        }
                        if(strcmp("-t", argv[_v36]) != 0) {
                            if(strcmp("-r", argv[_v36]) != 0) {
                                if(strcmp("-l", argv[_v36]) != 0) {
                                    if(strncmp("-I", argv[_v36], 2) != 0) {
                                        if(strncmp("-O", argv[_v36], 2) != 0) {
                                            if(strcmp("-graph", argv[_v36]) != 0) {
                                                if(strcmp("-no-graph", argv[_v36]) != 0) {
                                                    if(strcmp("-T", argv[_v36]) != 0) {
                                                        if(strcmp("-m", argv[_v36]) != 0) {
                                                            if(strcmp("-v", argv[_v36]) != 0) {
                                                                if(strcmp("-N", argv[_v36]) != 0) {
                                                                    if(strcmp("-M", argv[_v36]) != 0) {
                                                                        if(strcmp("-B", argv[_v36]) != 0) {
                                                                            if(strcmp("-bookmark", argv[_v36]) != 0) {
                                                                                if(strcmp("-F", argv[_v36]) != 0) {
                                                                                    if(strcmp("-W", argv[_v36]) != 0) {
                                                                                        if(strcmp("-dump", argv[_v36]) != 0) {
                                                                                            if(strcmp("-dump_source", argv[_v36]) != 0) {
                                                                                                if(strcmp("-dump_head", argv[_v36]) != 0) {
                                                                                                    if(strcmp("-dump_both", argv[_v36]) != 0) {
                                                                                                        if(strcmp("-dump_extra", argv[_v36]) != 0) {
                                                                                                            if(strcmp("-halfdump", argv[_v36]) != 0) {
                                                                                                                if(strcmp("-halfload", argv[_v36]) != 0) {
                                                                                                                    if(strcmp("-backend", argv[_v36]) != 0) {
                                                                                                                        if(strcmp("-backend_batch", argv[_v36]) != 0) {
                                                                                                                            if(strcmp("-cols", argv[_v36]) != 0) {
                                                                                                                                if(strcmp("-ppc", argv[_v36]) != 0) {
                                                                                                                                    if(strcmp("-ppl", argv[_v36]) != 0) {
                                                                                                                                        if(strcmp("-num", argv[_v36]) != 0) {
                                                                                                                                            if(strcmp("-no-proxy", argv[_v36]) != 0) {
                                                                                                                                                if(strcmp("-4", argv[_v36]) == 0 || strcmp("-6", argv[_v36]) == 0) {
                                                                                                                                                    _v160 = argv[_v36][1] & 0xff;
                                                                                                                                                    set_param_option( *(Sprintf("dns_order=%c")));
                                                                                                                                                    goto L224;
                                                                                                                                                }
                                                                                                                                                if(strcmp("-post", argv[_v36]) != 0) {
                                                                                                                                                    if(strcmp("-header", argv[_v36]) != 0) {
                                                                                                                                                        if(strcmp("-no-mouse", argv[_v36]) != 0) {
                                                                                                                                                            if(strcmp("-no-cookie", argv[_v36]) != 0) {
                                                                                                                                                                if(strcmp("-cookie", argv[_v36]) != 0) {
                                                                                                                                                                    if(strcmp("-pauth", argv[_v36]) != 0) {
                                                                                                                                                                        if(strcmp("-s", argv[_v36]) != 0) {
                                                                                                                                                                            if(strcmp("-X", argv[_v36]) != 0) {
                                                                                                                                                                                if(strcmp("-title", argv[_v36]) != 0) {
                                                                                                                                                                                    if(strncmp("-title=", argv[_v36], 7) != 0) {
                                                                                                                                                                                        if(strcmp("-o", argv[_v36]) == 0 || strcmp("-show-option", argv[_v36]) == 0) {
                                                                                                                                                                                            if(strcmp("-show-option", argv[_v36]) == 0) {
L202:
                                                                                                                                                                                                show_params(__imp__stdout);
                                                                                                                                                                                                exit(0);
                                                                                                                                                                                                goto L203;
                                                                                                                                                                                            }
                                                                                                                                                                                            goto L200;
L203:
                                                                                                                                                                                            if(set_param_option(argv[_v36]) == 0) {
                                                                                                                                                                                                _v156 = argv[_v36];
                                                                                                                                                                                                fprintf(__imp__stderr, "%s: bad option\n");
                                                                                                                                                                                                show_params_p = 1;
                                                                                                                                                                                                fusage(__imp__stderr, 1);
                                                                                                                                                                                            }
                                                                                                                                                                                        } else {
                                                                                                                                                                                            if(strcmp("-dummy", argv[_v36]) != 0) {
                                                                                                                                                                                                if(strcmp("-debug", argv[_v36]) != 0) {
                                                                                                                                                                                                    if(strcmp("-reqlog", argv[_v36]) != 0) {
                                                                                                                                                                                                        fusage(__imp__stderr, 1);
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        w3m_reqlog = rcFile("request.log");
                                                                                                                                                                                                    }
                                                                                                                                                                                                } else {
                                                                                                                                                                                                    w3m_debug = 1;
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                        goto L224;
L200:
                                                                                                                                                                                        _v36 = _v36 + 1;
                                                                                                                                                                                        if(_v36 >= argc || strcmp(argv[_v36], "?") == 0) {
                                                                                                                                                                                            goto L202;
                                                                                                                                                                                        }
                                                                                                                                                                                        goto L203;
                                                                                                                                                                                    }
                                                                                                                                                                                    goto L196;
                                                                                                                                                                                }
                                                                                                                                                                                goto L194;
L196:
                                                                                                                                                                                displayTitleTerm =  &(argv[_v36][7]);
                                                                                                                                                                                goto L224;
                                                                                                                                                                            }
                                                                                                                                                                            goto L192;
L194:
                                                                                                                                                                            displayTitleTerm = getenv("TERM");
                                                                                                                                                                            goto L224;
                                                                                                                                                                        }
                                                                                                                                                                        goto L190;
L192:
                                                                                                                                                                        Do_not_use_ti_te = 1;
                                                                                                                                                                        goto L224;
                                                                                                                                                                    }
                                                                                                                                                                    goto L183;
L190:
                                                                                                                                                                    squeezeBlankLine = 1;
                                                                                                                                                                    goto L224;
                                                                                                                                                                }
                                                                                                                                                                goto L181;
L183:
                                                                                                                                                                _v36 = _v36 + 1;
                                                                                                                                                                if(_v36 >= argc) {
                                                                                                                                                                    fusage(__imp__stderr, 1);
                                                                                                                                                                }
                                                                                                                                                                _t1203 = encodeB(argv[_v36]);
                                                                                                                                                                _v156 = 0;
                                                                                                                                                                _v160 = _t1203->ptr;
                                                                                                                                                                proxy_auth_cookie = Strnew_m_charp("Basic ");
                                                                                                                                                                while(( *(argv[_v36]) & 0xff) != 0) {
                                                                                                                                                                     *(argv[_v36]) = 0;
                                                                                                                                                                    argv[_v36] =  &(argv[_v36][1]);
                                                                                                                                                                }
                                                                                                                                                                goto L224;
                                                                                                                                                            }
                                                                                                                                                            goto L179;
L181:
                                                                                                                                                            use_cookie = 1;
                                                                                                                                                            accept_cookie = 1;
                                                                                                                                                            goto L224;
                                                                                                                                                        }
                                                                                                                                                        goto L177;
L179:
                                                                                                                                                        use_cookie = 0;
                                                                                                                                                        accept_cookie = 0;
                                                                                                                                                        goto L224;
                                                                                                                                                    }
                                                                                                                                                    goto L166;
L177:
                                                                                                                                                    use_mouse = 0;
                                                                                                                                                    goto L224;
                                                                                                                                                }
                                                                                                                                                _v36 = _v36 + 1;
                                                                                                                                                if(_v36 >= argc) {
                                                                                                                                                    fusage(__imp__stderr, 1);
                                                                                                                                                }
                                                                                                                                                _v76 = argv[_v36];
                                                                                                                                                goto L224;
L166:
                                                                                                                                                _v36 = _v36 + 1;
                                                                                                                                                if(_v36 >= argc) {
                                                                                                                                                    fusage(__imp__stderr, 1);
                                                                                                                                                }
                                                                                                                                                _v92 = make_optional_header_string(argv[_v36]);
                                                                                                                                                if(_v92 != 0) {
                                                                                                                                                    if(header_string != 0) {
                                                                                                                                                        Strcat(header_string, _v92);
                                                                                                                                                    } else {
                                                                                                                                                        header_string = _v92;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                while(( *(argv[_v36]) & 0xff) != 0) {
                                                                                                                                                     *(argv[_v36]) = 0;
                                                                                                                                                    argv[_v36] =  &(argv[_v36][1]);
                                                                                                                                                }
                                                                                                                                                goto L224;
                                                                                                                                            }
                                                                                                                                            goto L157;
                                                                                                                                        }
                                                                                                                                        goto L155;
L157:
                                                                                                                                        use_proxy = 0;
                                                                                                                                        goto L224;
                                                                                                                                    }
                                                                                                                                    goto L149;
L155:
                                                                                                                                    showLineNum = 1;
                                                                                                                                    goto L224;
                                                                                                                                }
                                                                                                                                goto L143;
L149:
                                                                                                                                _v36 = _v36 + 1;
                                                                                                                                if(_v36 >= argc) {
                                                                                                                                    fusage(__imp__stderr, 1);
                                                                                                                                }
                                                                                                                                _t1252 = atof(argv[_v36]);
                                                                                                                                asm("fstp qword [esp+0x28]");
                                                                                                                                asm("fld qword [esp+0x28]");
                                                                                                                                asm("fld qword [0x80c8e50]");
                                                                                                                                asm("fxch st0, st1");
                                                                                                                                asm("fucomip st0, st1");
                                                                                                                                asm("fstp st0");
                                                                                                                                asm("setnb al");
                                                                                                                                if((_t1252 & 255) != 0) {
                                                                                                                                    asm("fld qword [esp+0x28]");
                                                                                                                                    asm("fld qword [0x80c8e60]");
                                                                                                                                    asm("fucomip st0, st1");
                                                                                                                                    asm("fstp st0");
                                                                                                                                    asm("setnb al");
                                                                                                                                    if((_t1252 & 255) != 0) {
                                                                                                                                        asm("fld qword [esp+0x28]");
                                                                                                                                        asm("fstp qword [0x80d53a8]");
                                                                                                                                        set_pixel_per_line = 1;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                goto L224;
                                                                                                                            }
                                                                                                                            goto L139;
L143:
                                                                                                                            _v36 = _v36 + 1;
                                                                                                                            if(_v36 >= argc) {
                                                                                                                                fusage(__imp__stderr, 1);
                                                                                                                            }
                                                                                                                            _t1259 = atof(argv[_v36]);
                                                                                                                            asm("fstp qword [esp+0x30]");
                                                                                                                            asm("fld qword [esp+0x30]");
                                                                                                                            asm("fld qword [0x80c8e50]");
                                                                                                                            asm("fxch st0, st1");
                                                                                                                            asm("fucomip st0, st1");
                                                                                                                            asm("fstp st0");
                                                                                                                            asm("setnb al");
                                                                                                                            if((_t1259 & 255) != 0) {
                                                                                                                                asm("fld qword [esp+0x30]");
                                                                                                                                asm("fld qword [0x80c8e58]");
                                                                                                                                asm("fucomip st0, st1");
                                                                                                                                asm("fstp st0");
                                                                                                                                asm("setnb al");
                                                                                                                                if((_t1259 & 255) != 0) {
                                                                                                                                    asm("fld qword [esp+0x30]");
                                                                                                                                    asm("fstp qword [0x80d53a0]");
                                                                                                                                    set_pixel_per_char = 1;
                                                                                                                                }
                                                                                                                            }
                                                                                                                            goto L224;
                                                                                                                        }
                                                                                                                        goto L133;
L139:
                                                                                                                        _v36 = _v36 + 1;
                                                                                                                        if(_v36 >= argc) {
                                                                                                                            fusage(__imp__stderr, 1);
                                                                                                                        }
                                                                                                                        COLS = atoi(argv[_v36]);
                                                                                                                        goto L224;
                                                                                                                    }
                                                                                                                    goto L131;
L133:
                                                                                                                    w3m_backend = 1;
                                                                                                                    _v36 = _v36 + 1;
                                                                                                                    if(_v36 >= argc) {
                                                                                                                        fusage(__imp__stderr, 1);
                                                                                                                    }
                                                                                                                    if(backend_batch_commands == 0) {
                                                                                                                        backend_batch_commands = newGeneralList();
                                                                                                                    }
                                                                                                                    pushValue(backend_batch_commands, allocStr(argv[_v36], -1));
                                                                                                                    goto L224;
                                                                                                                }
                                                                                                                goto L129;
L131:
                                                                                                                w3m_backend = 1;
                                                                                                                goto L224;
                                                                                                            }
                                                                                                            goto L127;
L129:
                                                                                                            w3m_dump = 0;
                                                                                                            w3m_halfload = 1;
                                                                                                            _v72 = "text/html";
                                                                                                            DefaultType = _v72;
                                                                                                            goto L224;
                                                                                                        }
                                                                                                        goto L125;
L127:
                                                                                                        w3m_dump = 16;
                                                                                                        goto L224;
                                                                                                    }
                                                                                                    goto L123;
L125:
                                                                                                    w3m_dump = 14;
                                                                                                    goto L224;
                                                                                                }
                                                                                                goto L121;
L123:
                                                                                                w3m_dump = 6;
                                                                                                goto L224;
                                                                                            }
                                                                                            goto L119;
L121:
                                                                                            w3m_dump = 2;
                                                                                            goto L224;
                                                                                        }
                                                                                        goto L117;
L119:
                                                                                        w3m_dump = 4;
                                                                                        goto L224;
                                                                                    }
                                                                                    goto L113;
L117:
                                                                                    w3m_dump = 1;
                                                                                    goto L224;
                                                                                }
                                                                                goto L111;
L113:
                                                                                if(WrapDefault == 0) {
                                                                                    WrapDefault = 1;
                                                                                } else {
                                                                                    WrapDefault = 0;
                                                                                }
                                                                            } else {
                                                                                _v36 = _v36 + 1;
                                                                                if(_v36 >= argc) {
                                                                                    fusage(__imp__stderr, 1);
                                                                                }
                                                                                BookmarkFile = argv[_v36];
                                                                                if(( *BookmarkFile & 0xff) != 126) {
                                                                                    if(( *BookmarkFile & 0xff) != 47) {
                                                                                        _v88 = Strnew_charp(CurrentDir);
                                                                                        if(_v88->length <= 0 || (( *_v88)[_v88->length - 1] & 0xff) != 47) {
                                                                                            if(_v88->length + 1 >= _v88->area_size) {
                                                                                                Strgrow(_v88);
                                                                                            }
                                                                                            _t1298 = _v88->length;
                                                                                            ( *_v88)[_t1298] = 47;
                                                                                            _v88->length = _t1298 + 1;
                                                                                            ( *_v88)[_v88->length] = 0;
                                                                                        }
                                                                                        Strcat_charp(_v88, BookmarkFile);
                                                                                        BookmarkFile = cleanupName( *_v88);
                                                                                    }
                                                                                }
                                                                            }
                                                                            goto L224;
L111:
                                                                            RenderFrame = 1;
                                                                        } else {
                                                                            _v60 = 1;
                                                                        }
                                                                    } else {
                                                                        useColor = 0;
                                                                    }
                                                                } else {
                                                                    _v68 = 1;
                                                                }
                                                            } else {
                                                                _v64 = 1;
                                                            }
                                                        } else {
                                                            _v22 = 1;
                                                            SearchHeader = _v22 & 0xff;
                                                        }
                                                    } else {
                                                        _v36 = _v36 + 1;
                                                        if(_v36 >= argc) {
                                                            fusage(__imp__stderr, 1);
                                                        }
                                                        _v72 = argv[_v36];
                                                        DefaultType = _v72;
                                                    }
                                                } else {
                                                    UseGraphicChar = 0;
                                                }
                                            } else {
                                                UseGraphicChar = 1;
                                            }
                                        } else {
                                            if((argv[_v36][2] & 0xff) == 0) {
                                                _v36 = _v36 + 1;
                                                if(_v36 >= argc) {
                                                    fusage(__imp__stderr, 1);
                                                }
                                                _v32 = argv[_v36];
                                            } else {
                                                _v32 =  &(argv[_v36][2]);
                                            }
                                            DisplayCharset = wc_guess_charset_short(_v32, DisplayCharset);
                                        }
                                    } else {
                                        if((argv[_v36][2] & 0xff) == 0) {
                                            _v36 = _v36 + 1;
                                            if(_v36 >= argc) {
                                                fusage(__imp__stderr, 1);
                                            }
                                            _v32 = argv[_v36];
                                        } else {
                                            _v32 =  &(argv[_v36][2]);
                                        }
                                        DocumentCharset = wc_guess_charset_short(_v32, DocumentCharset);
                                        WcOption.auto_detect = 0;
                                        UseContentCharset = 0;
                                    }
                                } else {
                                    _v36 = _v36 + 1;
                                    if(_v36 >= argc) {
                                        fusage(__imp__stderr, 1);
                                    }
                                    if(atoi(argv[_v36]) > 0) {
                                        PagerMax = atoi(argv[_v36]);
                                    }
                                }
                            } else {
                                ShowEffect = 0;
                            }
                        } else {
                            _v36 = _v36 + 1;
                            if(_v36 >= argc) {
                                fusage(__imp__stderr, 1);
                            }
                            if(atoi(argv[_v36]) > 0) {
                                Tabstop = atoi(argv[_v36]);
                            }
                        }
L224:
                        _v36 = _v36 + 1;
                    }
                    FirstTab = 0;
                    LastTab = 0;
                    nTab = 0;
                    CurrentTab = 0;
                    CurrentKey = -1;
                    if(BookmarkFile == 0) {
                        BookmarkFile = rcFile("bookmark.html");
                    }
                    if(isatty(1) == 0 && w3m_dump == 0) {
                        w3m_dump = 1;
                    }
                    if(w3m_dump != 0 && COLS == 0) {
                        COLS = 80;
                    }
                    if(w3m_dump != 0 || w3m_backend != 0) {
                        if((w3m_dump & 16) != 0 && displayImage != 0) {
                            activeImage = 1;
                        }
                    } else {
                        fmInit();
                        mySignal(28, resize_hook);
                    }
                    sync_with_option();
                    initCookie();
                    if(UseHistory != 0) {
                        loadHistory(URLHist);
                    }
                    wtf_init(DocumentCharset, DisplayCharset);
                    if(w3m_backend != 0) {
                        backend();
                    }
                    if(w3m_dump != 0) {
                        mySignal(2, 1);
                    }
                    mySignal(17, sig_chld);
                    _t1400 = mySignal(13, SigPipe);
                     *__esp = wrap_GC_warn_proc;
                    GC_set_warn_proc();
                    orig_GC_warn_proc = _t1400;
                    _v80 = Strnew();
                    if(_v56 != 0) {
                        _v36 = 0;
                        goto L324;
                    } else {
                        if(isatty(0) != 0) {
                            if(_v60 == 0) {
                                if(_v64 == 0) {
                                    _v32 = getenv("HTTP_HOME");
                                    if(_v32 != 0) {
L259:
                                        _v148 = 0;
                                        _v152 = 0;
                                        _v28 = loadGeneralFile(_v32, 0, -1);
                                        if(_v28 != 0) {
                                            if(_v28 != 1) {
                                                pushHashHist(URLHist,  *(parsedURL2Str(_v28 + 132)));
                                            }
                                        } else {
                                            _v160 = _v32;
                                            Strcat(_v80, Sprintf("w3m: Can't load %s.\n"));
                                        }
                                        goto L267;
                                    }
                                    goto L258;
                                }
                                goto L253;
L258:
                                _v32 = getenv("WWW_HOME");
                                if(_v32 == 0) {
                                    if((fmInitialized & 0xff) != 0) {
                                        fmTerm();
                                    }
                                    fusage(__imp__stderr, 1);
                                    goto L267;
                                }
                                goto L259;
                            }
                            goto L250;
L253:
                            _v96 = Strnew_charp("<title>W3M startup page</title><center><b>Welcome to ");
                            Strcat_charp(_v96, "<a href='http://w3m.sourceforge.net/'>");
                            _v148 = 0;
                            _v152 = "<br>Written by <a href='mailto:aitofw.ipsj.or.jp'>Akinori Ito</a>";
                            _v156 = w3m_version;
                            _v160 = "w3m</a>!<p><p>This is w3m version ";
                            Strcat_m_charp(_v96);
                            _v152 = 0;
                            _v156 = "You can read <a href='file:///usr/share/doc/w3m/'>w3m documents on your local system</a>.";
                            _v160 = "<p>Debian package is maintained by <a href='mailto:ukaidebian.or.jp'>Fumitoshi UKAI</a>.";
                            Strcat_m_charp(_v96);
                            _v28 = loadHTMLString(_v96);
                            if(_v28 != 0) {
                                if(_v28 != 1) {
                                    _v28->bufferprop = (_v28->bufferprop & 65535 | 24) & 65535;
                                }
                            } else {
                                Strcat_charp(_v80, "w3m: Can't load string.\n");
                            }
                            goto L267;
                        }
                        _v40 = newFileStream(fdopen(dup(0), "rb"), pclose);
                        _v28 = openGeneralPagerBuffer(_v40);
                        dup2(1, 0);
L267:
                        if(_v28 == 0) {
                            if((fmInitialized & 0xff) != 0) {
                                fmTerm();
                            }
                            if(_v80->length != 0) {
                                fputs( *_v80, __imp__stderr);
                            }
                            w3m_exit(2);
                        }
                        _v36 = -1;
L324:
                        while(_v36 < _v56) {
                            goto L275;
                        }
                        if(w3m_dump != 0) {
                            if(_v80->length != 0) {
                                fputs( *_v80, __imp__stderr);
                            }
                            save_cookies();
                            w3m_exit(0);
                        }
                        if(add_download_list == 0) {
                            CurrentTab = FirstTab;
                        } else {
                            add_download_list = 0;
                            CurrentTab = LastTab;
                            if(FirstTab == 0) {
                                CurrentTab = newTab();
                                LastTab = CurrentTab;
                                FirstTab = LastTab;
                                nTab = 1;
                            }
                            if(CurrentTab->firstBuffer == 0 || CurrentTab->firstBuffer == 1) {
                                _t1782 = CurrentTab;
                                _t1724 = CurrentTab;
                                _t1757 = COLS;
                                if(showLineNum == 0) {
                                    _t1615 = 1;
                                } else {
                                    _t1615 = 6;
                                }
                                _t1616 = _t1757 - _t1615;
                                _t1617 = _t1616 >= 0 ? 0 : _t1616;
                                _t1724->currentBuffer = newBuffer(_t1616 >= 0 ? 0 : _t1616);
                                _t1782->firstBuffer = _t1724->currentBuffer;
                                CurrentTab->currentBuffer->bufferprop = 24;
                                CurrentTab->currentBuffer->buffername = "Download List Panel";
                            } else {
                                CurrentTab->currentBuffer = CurrentTab->firstBuffer;
                            }
                            ldDL();
                        }
                        if(FirstTab == 0 || CurrentTab->firstBuffer == 0 || CurrentTab->firstBuffer == 1) {
                            if(_v28 == 1 && (fmInitialized & 0xff) != 0) {
                                inputLineHistSearch("Hit any key to quit w3m:", 135036496, 512, 0, 0);
                            }
                            if((fmInitialized & 0xff) != 0) {
                                fmTerm();
                            }
                            if(_v80->length != 0) {
                                fputs( *_v80, __imp__stderr);
                            }
                            if(_v28 == 1) {
                                save_cookies();
                                if(_v80->length == 0) {
                                    w3m_exit(0);
                                }
                            }
                            w3m_exit(2);
                        }
                        if(_v80->length != 0) {
                            disp_message_nsec( *_v80, 0, 1, 1, 0);
                        }
                        SearchHeader = 0;
                        DefaultType = 0;
                        UseContentCharset = 1;
                        WcOption.auto_detect = _v23 & 0xff;
                        CurrentTab->currentBuffer = CurrentTab->firstBuffer;
                        displayBuffer(CurrentTab->currentBuffer, 1);
                        if(_v44 != 0) {
                            _goLine(_v44);
                        }
                        while() {
                        }
L250:
                        _v148 = 0;
                        _v152 = 0;
                        _v28 = loadGeneralFile(BookmarkFile, 0, -1);
                        if(_v28 == 0) {
                            Strcat_charp(_v80, "w3m: Can't load bookmark.\n");
                        }
                        goto L267;
                    }
L275:
                    if(_v36 >= 0) {
L299:
                        if(_v28 == 1) {
                            goto L322;
                        }
                        goto L300;
                    }
                    SearchHeader = _v22 & 0xff;
                    DefaultType = _v72;
                    _t1440 = w3m_dump;
                    if(_t1440 != 2) {
                        if(_v76 == 0 || _v36 != 0) {
                            _v52 = 0;
                        } else {
                            if(strcmp(_v76, "-") != 0) {
                                _v100 = fopen(_v76, "r");
                            } else {
                                _v100 = __imp__stdin;
                            }
                            if(_v100 != 0) {
                                _v104 = Strfgetall(_v100);
                                if(_v100 != __imp__stdin) {
                                    fclose(_v100);
                                }
                                _v52 = newFormList(0, "post", 0, 0, 0, 0, 0);
                                _v52->body =  *_v104;
                                _v52->boundary = 0;
                                _v52->length = _v104->length;
                                goto L289;
                            }
                            _v160 = _v76;
                            Strcat(_v80, Sprintf("w3m: Can't open %s.\n"));
L323:
                            _v36 = _v36 + 1;
                            goto L324;
                        }
L289:
                        _v148 = _v52;
                        _v152 = 0;
                        _v28 = loadGeneralFile( *((_v36 << 2) + _v48), 0, -1);
L290:
                        if(_v28 != 0) {
                            if(_v28 == 1) {
                                goto L323;
                            }
                            goto L293;
L322:
                            goto L323;
                        }
                        _v160 =  *((_v36 << 2) + _v48);
                        Strcat(_v80, Sprintf("w3m: Can't load %s.\n"));
                        goto L323;
L293:
                        _t1447 = _v28->real_scheme;
                        if(_t1447 < 4) {
L298:
                            pushHashHist(URLHist,  *(parsedURL2Str(_v28 + 132)));
                            goto L302;
                        }
                        if(_t1447 <= 5) {
                            unshiftHist(LoadHist,  *(wc_Str_conv(Strnew_charp( *((_v36 << 2) + _v48)), SystemCharset, InnerCharset)));
                            goto L298;
                        }
                        if(_t1447 == 12) {
                            goto L302;
                        }
                        goto L298;
L302:
                        if( *((intOrPtr*)(_v28 + 92)) != 0 || _v28->real_scheme == 4 && _v28->header_source != 0 &&  *(_v28 + 152) != 0 && strcmp( *(_v28 + 152), "-") != 0) {
                            _v28->search_header = _v22 & 0xff;
                        }
                        if(CurrentTab != 0) {
                            if(_v68 == 0) {
                                CurrentTab->currentBuffer->nextBuffer = _v28;
                                CurrentTab->currentBuffer = _v28;
                            } else {
                                _newT();
                                CurrentTab->currentBuffer->nextBuffer = _v28;
                                delBuffer(CurrentTab->currentBuffer);
                            }
                        } else {
                            CurrentTab = newTab();
                            LastTab = CurrentTab;
                            FirstTab = LastTab;
                            nTab = 1;
                            _t1427 = CurrentTab;
                            _t1427->currentBuffer = _v28;
                            CurrentTab->firstBuffer = _t1427->currentBuffer;
                        }
                        if(w3m_dump == 0 || w3m_dump == 1) {
                            if(CurrentTab->currentBuffer->frameset != 0 && (RenderFrame & 0xff) != 0) {
                                rFrame();
                            }
                        }
                        if(w3m_dump == 0) {
                            CurrentTab->currentBuffer = _v28;
                        } else {
                            do_dump(CurrentTab->currentBuffer);
                        }
                        goto L323;
                    }
                     *__esp = 52;
                    GC_malloc();
                    _v52 = _t1440;
                    _v52->method = 3;
                    _v148 = _v52;
                    _v152 = 0;
                    _v28 = loadGeneralFile( *((_v36 << 2) + _v48), 0, -1);
                    goto L290;
L300:
                    goto L302;
                }
                goto L37;
            }
            goto L32;
L37:
            _v32 = getenv("NO_PROXY");
            if(_v32 != 0) {
L40:
                NO_proxy = _v32;
                goto L41;
            }
            _v32 = getenv("no_proxy");
            if(_v32 != 0) {
                goto L40;
            }
            _v32 = getenv("NO_proxy");
            if(_v32 == 0) {
                goto L41;
            }
            goto L40;
        }
        goto L27;
L32:
        _v32 = getenv("FTP_PROXY");
        if(_v32 != 0) {
L35:
            FTP_proxy = _v32;
            goto L36;
        }
        _v32 = getenv("ftp_proxy");
        if(_v32 != 0) {
            goto L35;
        }
        _v32 = getenv("FTP_proxy");
        if(_v32 == 0) {
            goto L36;
        }
        goto L35;
    }
    _v32 = getenv("HTTP_PROXY");
    if(_v32 != 0) {
L25:
        HTTP_proxy = _v32;
        goto L26;
    }
    _v32 = getenv("http_proxy");
    if(_v32 != 0) {
        goto L25;
    }
    _v32 = getenv("HTTP_proxy");
    if(_v32 == 0) {
        goto L26;
    }
    goto L25;
L27:
    _v32 = getenv("GOPHER_PROXY");
    if(_v32 != 0) {
L30:
        GOPHER_proxy = _v32;
        goto L31;
    }
    _v32 = getenv("gopher_proxy");
    if(_v32 != 0) {
        goto L30;
    }
    _v32 = getenv("GOPHER_proxy");
    if(_v32 == 0) {
        goto L31;
    }
    goto L30;
}

keyPressEventProc(int c)
{// addr = 0x0804D821  --  defined in 'main.c' at line 1182
    _unknown_ __ebp;                       // r6

    CurrentKey = c;
     *((intOrPtr*)( *((intOrPtr*)(135103140 + ( *( &GlobalKeymap + c) & 0xff) * 8))))();
    return;
}

pushEvent(int cmd, _Unknown_base* data)
{// addr = 0x0804D847  --  defined in 'main.c' at line 1189
    Event* event;        // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

     *__esp = 12;
    GC_malloc();
    event = __eax;
    event->cmd = cmd;
    event->data = data;
    event->next = 0;
    if(CurrentEvent == 0) {
        CurrentEvent = event;
    } else {
        LastEvent->next = event;
    }
    LastEvent = event;
    return;
}

dump_source(Buffer* buf)
{// addr = 0x0804D89F  --  defined in 'main.c' at line 1205
    char c;                                // _cfa_fffffff3
    FILE* f;              // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(buf->sourcefile != 0) {
        f = fopen(buf->sourcefile, "r");
        if(f != 0) {
            while(1) {
                fgetc(f);
                c = f & 255;
                feof(f);
                if(f != 0) {
                    break;
                }
                putchar(c);
            }
            fclose(f);
            return;
        }
        return;
    }
    return;
}

dump_head(Buffer* buf)
{// addr = 0x0804D913  --  defined in 'main.c' at line 1221
    TextListItem* ti;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    struct _Str _v40;     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27
    _unknown_ _t30;                        // _t30
    _unknown_ _t33;                        // _t33

    if(buf->document_header != 0) {
        ti = buf->document_header->first;
L5:
        while(ti != 0) {
            goto L4;
        }
        puts(135036496);
        return;
    }
    if((w3m_dump & 8) != 0) {
        goto L2;
    }
    return;
L2:
    putchar(10);
    return;
L4:
    _v40 =  *(wc_Str_conv_strict(Strnew_charp(ti->ptr), InnerCharset,  *(buf + 208)));
    printf("%s");
    ti = ti->next;
    goto L5;
}

dump_extra(Buffer* buf)
{// addr = 0x0804D9B6  --  defined in 'main.c' at line 1243
    struct _Str _v24;     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t21;                        // _t21
    _unknown_ _t26;                        // _t26

    _v24 =  *(parsedURL2Str(buf + 132));
    printf("W3m-current-url: %s\n");
    if(buf->baseURL != 0) {
        _v24 =  *(parsedURL2Str(buf->baseURL));
        printf("W3m-base-url: %s\n");
    }
    _v24 = wc_ces_to_charset( *(buf + 208));
    printf("W3m-document-charset: %s\n");
    return;
}

do_dump(Buffer* buf)
{// addr = 0x0804DA34  --  defined in 'main.c' at line 1272
    _None prevtrap;                        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _None _t16;                            // _t16
    _unknown_ _t25;                        // _t25
    _unknown_ _t32;                        // _t32

    prevtrap = 0;
    _t16 = mySignal(2, intTrap);
    prevtrap = _t16;
    _v40 = 1;
     *__esp =  &IntReturn;
    __sigsetjmp();
    if(_t16 == 0) {
        if((w3m_dump & 8) != 0) {
            dump_extra(buf);
        }
        if((w3m_dump & 2) != 0) {
            dump_head(buf);
        }
        if((w3m_dump & 4) != 0) {
            dump_source(buf);
        }
        if(w3m_dump == 1) {
            saveBuffer(buf, __imp__stdout, 0);
        }
        mySignal(2, prevtrap);
        return;
    }
    mySignal(2, prevtrap);
    return;
}

nulcmd()
{// addr = 0x0804DB05  --  defined in 'main.c' at line 1292
    _unknown_ __ebp;                       // r6

    return;
}

pcmap()
{// addr = 0x0804DB0A  --  defined in 'main.c' at line 1303
    _unknown_ __ebp;                       // r6

    return;
}

escKeyProc(int c, int esc, unsigned char* map)
{// addr = 0x0804DB0F  --  defined in 'main.c' at line 1309
    unsigned char** mmap;                  // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    int _t38;                              // _t38

    if(CurrentKey >= 0 || (CurrentKey & 268435456) == 0) {
L12:
        CurrentKey = c | esc;
         *((intOrPtr*)( *((intOrPtr*)(135103140 + (map[c] & 0xff) * 8))))();
        return;
    } else {
        mmap = getKeyData(CurrentKey >> 16 & 1919);
        if(mmap == 0) {
            goto L13;
        }
        _t38 = esc;
        if(_t38 == 512) {
            map = mmap[2];
        } else {
            if(_t38 == 1024) {
                map = mmap[3];
            } else {
                if(_t38 == 256) {
                    map = mmap[1];
                } else {
                    map =  *mmap;
                }
            }
        }
        esc = esc | CurrentKey;
        goto L12;
    }
L13:
    return;
}

escmap()
{// addr = 0x0804DBCA  --  defined in 'main.c' at line 1336
    char c;                                // _cfa_fffffff3
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13

    c = do_getch() & 255;
    if(( *( &MYCTYPE_MAP + (c & 0xff)) & 0x11) != 0) {
        escKeyProc(c, 256,  &EscKeymap);
        return;
    }
    return;
}

escbmap()
{// addr = 0x0804DC0E  --  defined in 'main.c' at line 1344
    char c;                                // _cfa_fffffff3
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    c = do_getch() & 255;
    if(( *( &MYCTYPE_MAP + (c & 0xff)) & 8) != 0) {
        escdmap(c);
        return;
    }
    if(( *( &MYCTYPE_MAP + (c & 0xff)) & 0x11) == 0) {
    } else {
        escKeyProc(c, 512,  &EscBKeymap);
        return;
    }
    goto L4;
L5:
L4:
    return;
    goto L5;
}

escdmap(char c)
{// addr = 0x0804DC78  --  defined in 'main.c' at line 1357
    int d;                                 // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t33;                       // _t33

    _v32 = _a4 & 255;
    d = _v32 - 48;
    _v32 = do_getch() & 255;
    _t33 =  *( &MYCTYPE_MAP + (_v32 & 0xff)) & 255;
    _t35 = _t33 & 8;
    if((_t33 & 8) != 0) {
        d = (d << 2) + d + (d << 2) + d + _v32 - 48;
        _v32 = do_getch() & 255;
    }
    if(_v32 == 126) {
        escKeyProc(d, 1024,  &EscDKeymap);
        return;
    }
    return;
}

multimap()
{// addr = 0x0804DCF4  --  defined in 'main.c' at line 1370
    char c;                                // _cfa_fffffff3
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14

    c = do_getch() & 255;
    if(( *( &MYCTYPE_MAP + (c & 0xff)) & 0x11) != 0) {
        CurrentKey = c | CurrentKey << 16 | 268435456;
        escKeyProc(c, 0, 0);
        return;
    }
    return;
}

tmpClearBuffer(Buffer* buf)
{// addr = 0x0804DD53  --  defined in 'main.c' at line 1381
    _unknown_ __ebp;                       // r6
    Buffer* _t12;       // _t12

    _t12 = buf;
    _t13 =  *((intOrPtr*)(_t12 + 92));
    if( *((intOrPtr*)(_t12 + 92)) != 0 || writeBufferCache(buf) != 0) {
        return;
    } else {
        buf->firstLine = 0;
        buf->topLine = 0;
        buf->currentLine = 0;
        buf->lastLine = 0;
        return;
    }
}

pushBuffer(Buffer* buf)
{// addr = 0x0804DD9C  --  defined in 'main.c' at line 1410
    Buffer* b;          // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    TabBuffer* _t41;   // _t41

    deleteImage(CurrentTab->currentBuffer);
    if(clear_buffer != 0) {
        tmpClearBuffer(CurrentTab->currentBuffer);
    }
    if(CurrentTab->firstBuffer == CurrentTab->currentBuffer) {
        buf->nextBuffer = CurrentTab->firstBuffer;
        _t41 = CurrentTab;
        _t41->currentBuffer = buf;
        CurrentTab->firstBuffer = _t41->currentBuffer;
        return;
    }
    b = prevBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer);
    if(b == 0) {
    } else {
        b->nextBuffer = buf;
        buf->nextBuffer = CurrentTab->currentBuffer;
        CurrentTab->currentBuffer = buf;
        return;
    }
    goto L6;
L7:
L6:
    return;
    goto L7;
}

delBuffer(Buffer* buf)
{// addr = 0x0804DE4F  --  defined in 'main.c' at line 1435
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(buf != 0) {
        if(CurrentTab->currentBuffer == buf) {
            CurrentTab->currentBuffer = buf->nextBuffer;
        }
        CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
        if(CurrentTab->currentBuffer != 0) {
        } else {
            CurrentTab->currentBuffer = CurrentTab->firstBuffer;
            return;
        }
L7:
    }
    return;
    goto L7;
}

repBuffer(Buffer* oldbuf, Buffer* buf)
{// addr = 0x0804DEBD  --  defined in 'main.c' at line 1447
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    CurrentTab->firstBuffer = replaceBuffer(CurrentTab->firstBuffer, oldbuf, buf);
    CurrentTab->currentBuffer = buf;
    return;
}

intTrap(int _dummy)
{// addr = 0x0804DEFC  --  defined in 'main.c' at line 1455
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    _v24 = 0;
     *__esp =  &IntReturn;
    siglongjmp();
    _push(_t3);
    __esp = __esp - 24;
    need_resize_screen = 1;
    mySignal(28, resize_hook);
    return;
}

resize_hook(int _dummy)
{// addr = 0x0804DF16  --  defined in 'main.c' at line 1463
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    need_resize_screen = 1;
    mySignal(28, resize_hook);
    return;
}

resize_screen()
{// addr = 0x0804DF3C  --  defined in 'main.c' at line 1471
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    need_resize_screen = 0;
    setlinescols();
    setupscreen();
    if(CurrentTab != 0) {
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    return;
}

SigPipe(int _dummy)
{// addr = 0x0804DF79  --  defined in 'main.c' at line 1483
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    init_migemo();
    mySignal(13, SigPipe);
    return;
}

nscroll(int n, int mode)
{// addr = 0x0804DF9A  --  defined in 'main.c' at line 1498
    Buffer* buf;        // _cfa_fffffff0
    Line* top;            // _cfa_ffffffec
    Line* cur;            // _cfa_ffffffe8
    int lnum;                              // _cfa_ffffffe4
    int tlnum;                             // _cfa_ffffffe0
    int llnum;                             // _cfa_ffffffdc
    int diff_n;                            // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    buf = CurrentTab->currentBuffer;
    top = buf->topLine;
    cur = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    } else {
        lnum = cur->linenumber;
        buf->topLine = lineSkip(buf, top, n, 0);
        if(buf->topLine != top) {
            tlnum = buf->topLine->linenumber;
            asm("cwde ");
            llnum = buf->topLine->linenumber + (buf->LINES & 65535) - 1;
            if(nextpage_topline == 0) {
                diff_n = top->linenumber - tlnum + n;
            } else {
                diff_n = 0;
            }
            if(lnum < tlnum) {
                lnum = tlnum + diff_n;
            }
            if(lnum > llnum) {
                lnum = llnum + diff_n;
            }
        } else {
            lnum = lnum + n;
            if(buf->topLine->linenumber <= lnum) {
                if(buf->lastLine->linenumber < lnum) {
                    lnum = buf->lastLine->linenumber;
                }
            } else {
                lnum = buf->topLine->linenumber;
            }
        }
        gotoLine(buf, lnum);
        arrangeLine(buf);
        if(n <= 0) {
            if(buf->currentLine->bwidth + buf->currentLine->width >= buf->currentColumn + buf->visualpos) {
                while(buf->currentLine->prev != 0 && buf->currentLine->bpos != 0 && buf->currentLine->bwidth >= buf->currentColumn + buf->visualpos) {
                    cursorUp0(buf, 1);
                }
                goto L31;
            }
            goto L25;
        }
        if(buf->currentLine->bpos == 0) {
L20:
            while(buf->currentLine->next != 0 && buf->currentLine->next->bpos != 0) {
                if(buf->currentLine->bwidth + buf->currentLine->width < buf->currentColumn + buf->visualpos) {
                    cursorDown0(buf, 1);
                    continue;
                }
                goto L31;
            }
            goto L31;
        }
        if(buf->currentLine->bwidth < buf->currentColumn + buf->visualpos) {
            goto L19;
        }
        cursorDown(buf, 1);
L31:
        displayBuffer(buf, mode);
        return;
L19:
        goto L20;
L25:
        cursorUp(buf, 1);
        goto L31;
    }
}

pgFore()
{// addr = 0x0804E22A  --  defined in 'main.c' at line 1555
    _unknown_ _v24;                        // _cfa_ffffffe8
    int __ebx;                             // r1
    _unknown_ __ebp;                       // r6
    int _t15;                              // _t15

    if(vi_prec_num == 0) {
        if(prec_num == 0) {
            __ebx = 0;
        } else {
            __ebx = 3;
        }
        if(prec_num == 0) {
            _t15 = searchKeyNum() * ((CurrentTab->currentBuffer->LINES & 0xffff) - 1);
        } else {
            _t15 = searchKeyNum();
        }
        nscroll(_t15, __ebx);
        return;
    }
    nscroll(searchKeyNum() * ((CurrentTab->currentBuffer->LINES & 0xffff) - 1), 0);
    return;
}

pgBack()
{// addr = 0x0804E2B9  --  defined in 'main.c' at line 1565
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    int _t15;                              // _t15
    int _t19;                              // _t19
    _unknown_ _t20;                        // _t20
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    _unknown_ _t34;                        // _t34

    if(vi_prec_num == 0) {
        if(prec_num == 0) {
            _t19 = 0;
        } else {
            _t19 = 3;
        }
        if(prec_num == 0) {
            _t15 = searchKeyNum() * (1 - (CurrentTab->currentBuffer->LINES & 0xffff));
        } else {
            _t15 =  ~(searchKeyNum());
        }
        nscroll(_t15, _t19);
        return;
    }
    nscroll(searchKeyNum() * (1 - (CurrentTab->currentBuffer->LINES & 0xffff)), 0);
    return;
}

lup1()
{// addr = 0x0804E35C  --  defined in 'main.c' at line 1575
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    nscroll(searchKeyNum(), 3);
    return;
}

ldown1()
{// addr = 0x0804E379  --  defined in 'main.c' at line 1581
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    nscroll( ~(searchKeyNum()), 3);
    return;
}

ctrCsrV()
{// addr = 0x0804E398  --  defined in 'main.c' at line 1587
    int offsety;                           // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(CurrentTab->currentBuffer->firstLine != 0) {
        _t37 = CurrentTab->currentBuffer->LINES & 65535;
        asm("cwde ");
        offsety = ((CurrentTab->currentBuffer->LINES & 65535) + _t37 & 65535) - (CurrentTab->currentBuffer->cursorY & 65535);
        if(offsety == 0) {
        } else {
            CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->topLine,  ~offsety, 0);
            arrangeLine(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
L5:
    }
    return;
    goto L5;
}

ctrCsrH()
{// addr = 0x0804E457  --  defined in 'main.c' at line 1606
    int offsetx;                           // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39

    if(CurrentTab->currentBuffer->firstLine != 0) {
        _t34 = CurrentTab->currentBuffer->COLS & 65535;
        asm("cwde ");
        offsetx = (CurrentTab->currentBuffer->cursorX & 0xffff) - (CurrentTab->currentBuffer->COLS & 65535) + _t34;
        if(offsetx == 0) {
        } else {
            columnSkip(CurrentTab->currentBuffer, offsetx);
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
L5:
    }
    return;
    goto L5;
}

rdrwSc()
{// addr = 0x0804E4E7  --  defined in 'main.c' at line 1620
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    clear();
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

clear_mark(Line* l)
{// addr = 0x0804E51C  --  defined in 'main.c' at line 1628
    int pos;                               // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    if(l != 0) {
        pos = 0;
        while(l->size > pos) {
             *(l->propBuf + pos + pos) =  *(l->propBuf + pos + pos) & 0xfe;
            pos = pos + 1;
        }
        return;
    }
    return;
}

int srchcore(_None str, _None* func)
{// addr = 0x0804E569  --  defined in 'main.c' at line 1639
    _None* prevtrap;                       // _cfa_fffffff0
    _None i;                               // _cfa_ffffffec
    _None result;                          // _cfa_ffffffe8
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    _None* _t37;                           // _t37
    _unknown_ _t39;                        // _t39
    _unknown_ _t41;                        // _t41
    _unknown_ _t44;                        // _t44
    _unknown_ _t46;                        // _t46

    result = 2;
    if(str != 0) {
        if(str != SearchString) {
            SearchString = str;
        }
    }
    if(SearchString == 0 || ( *SearchString & 0xff) == 0) {
        return;
    }
    str = conv_search_string(SearchString, DisplayCharset);
    _t37 = mySignal(2, intTrap);
    prevtrap = _t37;
    crmode();
    _v40 = 1;
     *__esp =  &IntReturn;
    __sigsetjmp();
    if(_t37 != 0) {
        mySignal(2, prevtrap);
        term_raw();
        return;
    }
    i = 0;
    while() {
    }
    return;
}

disp_srchresult(int result, char* prompt, char* str)
{// addr = 0x0804E6A3  --  defined in 'main.c' at line 1665
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(str == 0) {
        str = 135036496;
    }
    if((result & 2) != 0) {
        _v24 = str;
        disp_message( *(Sprintf("Not found: %s")), 1);
        return;
    }
    if((result & 4) == 0) {
    } else {
        _v24 = str;
        disp_message( *(Sprintf("Search wrapped: %s")), 1);
        return;
    }
    goto L6;
L8:
    return;
L9:
L6:
    if(show_srch_str == 0) {
    } else {
        _v20 = str;
        _v24 = prompt;
        disp_message( *(Sprintf("%s%s")), 1);
        return;
    }
    goto L8;
}

int dispincsrch(int ch, Str buf, Lineprop* prop)
{// addr = 0x0804E74F  --  defined in 'main.c' at line 1678
    char* str;                             // _cfa_fffffff0
    int do_next_search;                    // _cfa_ffffffec
    _None* _v40;                           // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t137;                             // _t137
    _unknown_ _t150;                       // _t150
    _unknown_ _t169;                       // _t169
    _unknown_ _t180;                       // _t180
    _unknown_ _t213;                       // _t213
    _unknown_ _t266;                       // _t266

    do_next_search = 0;
    if(ch == 0 && buf == 0) {
         *135775244 = CurrentTab->currentBuffer->topLine;
         *135775248 = CurrentTab->currentBuffer->currentLine;
         *135775308 = CurrentTab->currentBuffer->pos;
         *135775304 = CurrentTab->currentBuffer->cursorX & 0xffff;
         *135775306 = CurrentTab->currentBuffer->cursorY & 0xffff;
         *135775312 = CurrentTab->currentBuffer->visualpos;
         *135775300 = CurrentTab->currentBuffer->currentColumn;
        currentLine =  *135775248;
        pos.11062 =  *135775308;
        return -1;
    }
    str = buf->ptr;
    _t137 = ch;
    if(_t137 == 19) {
        searchRoutine = forwardSearch;
        do_next_search = 1;
        goto L11;
    } else {
        if(_t137 == 28) {
            goto L8;
        }
        if(_t137 != 18) {
            goto L9;
        }
        searchRoutine = backwardSearch;
        do_next_search = 1;
L11:
        if(do_next_search == 0) {
            if(( *str & 0xff) != 0) {
                CurrentTab->currentBuffer->topLine =  *135775244;
                CurrentTab->currentBuffer->currentLine =  *135775248;
                CurrentTab->currentBuffer->pos =  *135775308;
                CurrentTab->currentBuffer->cursorX =  *135775304 & 0xffff;
                CurrentTab->currentBuffer->cursorY =  *135775306 & 0xffff;
                CurrentTab->currentBuffer->visualpos =  *135775312;
                CurrentTab->currentBuffer->currentColumn =  *135775300;
                arrangeCursor(CurrentTab->currentBuffer);
                _v40 = searchRoutine;
                srchcore(str);
                arrangeCursor(CurrentTab->currentBuffer);
                currentLine = CurrentTab->currentBuffer->currentLine;
                pos.11062 = CurrentTab->currentBuffer->pos;
            }
            displayBuffer(CurrentTab->currentBuffer, 1);
            clear_mark(CurrentTab->currentBuffer->currentLine);
            while(1) {
L26:
                str =  &(str[1]);
                if(( *str & 0xff) == 0) {
                    break;
                }
                if(migemo_active <= 0) {
                     *prop =  *prop & 0xfd;
                    prop =  &(prop[1]);
                } else {
                     *prop = ( *prop & 65535 | 2) & 65535;
                    prop =  &(prop[1]);
                }
            }
            return -1;
        }
        if(( *str & 0xff) == 0) {
            return 16;
        }
        if(searchRoutine == forwardSearch) {
            CurrentTab->currentBuffer->pos =  &(CurrentTab->currentBuffer->pos->lineBuf);
        }
         *135775244 = CurrentTab->currentBuffer->topLine;
         *135775248 = CurrentTab->currentBuffer->currentLine;
         *135775308 = CurrentTab->currentBuffer->pos;
         *135775304 = CurrentTab->currentBuffer->cursorX & 0xffff;
         *135775306 = CurrentTab->currentBuffer->cursorY & 0xffff;
         *135775312 = CurrentTab->currentBuffer->visualpos;
         *135775300 = CurrentTab->currentBuffer->currentColumn;
        _v40 = searchRoutine;
        if(srchcore(str) == 2 && searchRoutine == forwardSearch) {
            CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos - 1;
             *135775244 = CurrentTab->currentBuffer->topLine;
             *135775248 = CurrentTab->currentBuffer->currentLine;
             *135775308 = CurrentTab->currentBuffer->pos;
             *135775304 = CurrentTab->currentBuffer->cursorX & 0xffff;
             *135775306 = CurrentTab->currentBuffer->cursorY & 0xffff;
             *135775312 = CurrentTab->currentBuffer->visualpos;
             *135775300 = CurrentTab->currentBuffer->currentColumn;
        }
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 1);
        clear_mark(CurrentTab->currentBuffer->currentLine);
        return -1;
L9:
        if(ch >= 0) {
            goto L11;
        }
        return ch;
    }
L8:
    migemo_active =  ~migemo_active;
    goto L26;
}

isrch(_None* func, char* prompt)
{// addr = 0x0804EB6D  --  defined in 'main.c' at line 1756
    Buffer sbuf;        // _cfa_fffffeec
    char* str;                             // _cfa_fffffff0
    int _v196;                             // _cfa_ffffff3c
    int _v200;                             // _cfa_ffffff38
    signed short _v202;                    // _cfa_ffffff36
    signed short _v204;                    // _cfa_ffffff34
    int _v208;                             // _cfa_ffffff30
    Line* _v260;          // _cfa_fffffefc
    Line* _v264;          // _cfa_fffffef8
    _unknown_ _v300;                       // _cfa_fffffed4
    _unknown_ _v304;                       // _cfa_fffffed0
    _unknown_ _v308;                       // _cfa_fffffecc
    _unknown_ _v312;                       // _cfa_fffffec8
    _unknown_ __ebp;                       // r6
    _unknown_ _t84;                        // _t84

    _v264 = CurrentTab->currentBuffer->topLine;
    _v260 = CurrentTab->currentBuffer->currentLine;
    _v200 = CurrentTab->currentBuffer->pos;
    _v204 = CurrentTab->currentBuffer->cursorX & 0xffff;
    _v202 = CurrentTab->currentBuffer->cursorY & 0xffff;
    _v196 = CurrentTab->currentBuffer->visualpos;
    _v208 = CurrentTab->currentBuffer->currentColumn;
    dispincsrch(0, 0, 0);
    searchRoutine = func;
    str = inputLineHistSearch(prompt, 0, 16, TextHist, dispincsrch);
    if(str == 0) {
        CurrentTab->currentBuffer->topLine = _v264;
        CurrentTab->currentBuffer->currentLine = _v260;
        CurrentTab->currentBuffer->pos = _v200;
        CurrentTab->currentBuffer->cursorX = _v204 & 0xffff;
        CurrentTab->currentBuffer->cursorY = _v202 & 0xffff;
        CurrentTab->currentBuffer->visualpos = _v196;
        CurrentTab->currentBuffer->currentColumn = _v208;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

srch(_None* func, char* prompt)
{// addr = 0x0804ECDF  --  defined in 'main.c' at line 1772
    char* str;                             // _cfa_fffffff0
    int result;                            // _cfa_ffffffec
    int disp;                              // _cfa_ffffffe8
    int pos;                               // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _None* _v56;                           // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t51;                        // _t51

    disp = 0;
    str = searchKeyData();
    if(str == 0 || ( *str & 0xff) == 0) {
        str = inputLineHistSearch(prompt, 0, 16, TextHist, 0);
        if(str != 0 && ( *str & 0xff) == 0) {
            str = SearchString;
        }
        if(str != 0) {
            disp = 1;
            goto L8;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
L8:
    pos = CurrentTab->currentBuffer->pos;
    if(func == forwardSearch) {
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
    }
    _v56 = func;
    result = srchcore(str);
    if((result & 1) == 0) {
        CurrentTab->currentBuffer->pos = pos;
    } else {
        clear_mark(CurrentTab->currentBuffer->currentLine);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    if(disp != 0) {
        disp_srchresult(result, prompt, str);
    }
    searchRoutine = func;
    return;
}

srchfor()
{// addr = 0x0804EE29  --  defined in 'main.c' at line 1806
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    srch(forwardSearch, "Forward: ");
    return;
}

isrchfor()
{// addr = 0x0804EE45  --  defined in 'main.c' at line 1811
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    isrch(forwardSearch, "I-search: ");
    return;
}

srchbak()
{// addr = 0x0804EE61  --  defined in 'main.c' at line 1818
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    srch(backwardSearch, "Backward: ");
    return;
}

isrchbak()
{// addr = 0x0804EE7D  --  defined in 'main.c' at line 1823
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    isrch(backwardSearch, "I-search backward: ");
    return;
}

srch_nxtprv(int reverse)
{// addr = 0x0804EE99  --  defined in 'main.c' at line 1829
    int result;                            // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _None*[1] _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t36;                            // _t36
    char* _t44;                            // _t44

    if(searchRoutine != 0) {
        if(reverse != 0) {
            reverse = 1;
        }
        if(searchRoutine == backwardSearch) {
            reverse = reverse ^ 1;
        }
        if(reverse == 0) {
            CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
        }
        _v40 = ( &routine)[reverse];
        result = srchcore(SearchString);
        if((result & 1) != 0) {
            clear_mark(CurrentTab->currentBuffer->currentLine);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        _t44 = SearchString;
        if(reverse == 0) {
            _t36 = "Forward: ";
        } else {
            _t36 = "Backward: ";
        }
        disp_srchresult(result, _t36, _t44);
        return;
    }
    disp_message("No previous regular expression", 1);
    return;
}

srchnxt()
{// addr = 0x0804EF7E  --  defined in 'main.c' at line 1858
    _unknown_ __ebp;                       // r6

    srch_nxtprv(0);
    return;
}

srchprv()
{// addr = 0x0804EF92  --  defined in 'main.c' at line 1864
    _unknown_ __ebp;                       // r6

    srch_nxtprv(1);
    return;
}

shiftvisualpos(Buffer* buf, int shift)
{// addr = 0x0804EFA6  --  defined in 'main.c' at line 1870
    Line* l;              // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    l = buf->currentLine;
    buf->visualpos = buf->visualpos - shift;
    asm("cwde ");
    if(buf->visualpos - l->bwidth < (buf->COLS & 65535)) {
        if(buf->visualpos - l->bwidth < 0) {
            buf->visualpos = l->bwidth;
        }
    } else {
        asm("cwde ");
        buf->visualpos = l->bwidth + (buf->COLS & 65535) - 1;
    }
    arrangeLine(buf);
    if(buf->visualpos - l->bwidth !=  ~shift || (buf->cursorX & 0xffff) != 0) {
        return;
    } else {
        buf->visualpos = l->bwidth;
        return;
    }
}

shiftl()
{// addr = 0x0804F05A  --  defined in 'main.c' at line 1884
    int column;                            // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t30;                        // _t30

    if(CurrentTab->currentBuffer->firstLine != 0) {
        column = CurrentTab->currentBuffer->currentColumn;
        columnSkip(CurrentTab->currentBuffer, searchKeyNum() * (1 - (CurrentTab->currentBuffer->COLS & 0xffff)) + 1);
        shiftvisualpos(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentColumn - column);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

shiftr()
{// addr = 0x0804F101  --  defined in 'main.c' at line 1897
    int column;                            // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t30;                        // _t30

    if(CurrentTab->currentBuffer->firstLine != 0) {
        column = CurrentTab->currentBuffer->currentColumn;
        columnSkip(CurrentTab->currentBuffer, searchKeyNum() * ((CurrentTab->currentBuffer->COLS & 0xffff) - 1) - 1);
        shiftvisualpos(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentColumn - column);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

col1R()
{// addr = 0x0804F197  --  defined in 'main.c' at line 1909
    Buffer* buf;        // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int column;                            // _cfa_ffffffe4
    int n;                                 // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35

    buf = CurrentTab->currentBuffer;
    l = buf->currentLine;
    n = searchKeyNum();
    if(l != 0) {
        j = 0;
        while(j < n) {
            column = buf->currentColumn;
            columnSkip(CurrentTab->currentBuffer, 1);
            if(buf->currentColumn == column) {
                goto L7;
            }
            shiftvisualpos(CurrentTab->currentBuffer, 1);
            j = j + 1;
            continue;
L7:
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        goto L7;
    }
    return;
}

col1L()
{// addr = 0x0804F238  --  defined in 'main.c' at line 1927
    Buffer* buf;        // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int n;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31

    buf = CurrentTab->currentBuffer;
    l = buf->currentLine;
    n = searchKeyNum();
    if(l != 0) {
        j = 0;
        while(j < n) {
            if(buf->currentColumn == 0) {
                goto L7;
            }
            columnSkip(CurrentTab->currentBuffer, -1);
            shiftvisualpos(CurrentTab->currentBuffer, -1);
            j = j + 1;
            continue;
L7:
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        goto L7;
    }
    return;
}

setEnv()
{// addr = 0x0804F2CF  --  defined in 'main.c' at line 1944
    char* env;                             // _cfa_fffffff0
    char* var;                             // _cfa_ffffffec
    char* value;                           // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45

    CurrentKeyData = 0;
    env = searchKeyData();
    if(env == 0 || ( *env & 0xff) == 0 || strchr(env, 61) == 0) {
        if(env != 0) {
            if(( *env & 0xff) != 0) {
                _v56 = env;
                env =  *(Sprintf("%s="));
            }
        }
        env = inputLineHistSearch("Set environ: ", env, 16, TextHist, 0);
        if(env == 0 || ( *env & 0xff) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
    value = strchr(env, 61);
    if(value != 0 && value > env) {
        var = allocStr(env, value - env);
        value =  &(value[1]);
        set_environ(var, value);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

pipeBuf()
{// addr = 0x0804F405  --  defined in 'main.c' at line 1968
    Buffer* buf;        // _cfa_fffffff0
    char* cmd;                             // _cfa_ffffffec
    char* tmpf;                            // _cfa_ffffffe8
    FILE* f;              // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    struct _Str _v52;     // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t67;                        // _t67
    _unknown_ _t82;                        // _t82

    CurrentKeyData = 0;
    cmd = searchKeyData();
    if(cmd == 0 || ( *cmd & 0xff) == 0) {
        cmd = inputLineHistSearch("Pipe buffer to: ", 135036496, 128, ShellHist, 0);
    }
    if(cmd != 0) {
        cmd =  *(wc_Str_conv_strict(Strnew_charp(cmd), InnerCharset, SystemCharset));
    }
    if(cmd == 0 || ( *cmd & 0xff) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    tmpf =  *(tmpfname(0, 0));
    f = fopen(tmpf, "w");
    if(f != 0) {
        saveBuffer(CurrentTab->currentBuffer, f, 1);
        fclose(f);
        buf = getpipe( *(myExtCommand(cmd, shell_quote(tmpf), 1)));
        if(buf != 0) {
            buf->filename = cmd;
            _v52 =  *(wc_Str_conv(Strnew_charp(cmd), SystemCharset, InnerCharset));
            _v56 = "*stream*";
            buf->buffername =  *(Sprintf("%s %s"));
            buf->bufferprop = (buf->bufferprop & 65535 | 24) & 65535;
            if(buf->type == 0) {
                buf->type = "text/plain";
            }
             *(buf + 152) = "-";
            pushBuffer(buf);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        goto L11;
    }
    _v56 = cmd;
    disp_message( *(Sprintf("Can't save buffer to %s")), 1);
    return;
L11:
    disp_message("Execution failed", 1);
    return;
}

pipesh()
{// addr = 0x0804F645  --  defined in 'main.c' at line 2014
    Buffer* buf;        // _cfa_fffffff0
    char* cmd;                             // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39

    CurrentKeyData = 0;
    cmd = searchKeyData();
    if(cmd == 0 || ( *cmd & 0xff) == 0) {
        cmd = inputLineHistSearch("(read shell[pipe])!", 135036496, 128, ShellHist, 0);
    }
    if(cmd != 0) {
        cmd =  *(wc_Str_conv_strict(Strnew_charp(cmd), InnerCharset, SystemCharset));
    }
    if(cmd == 0 || ( *cmd & 0xff) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    buf = getpipe(cmd);
    if(buf != 0) {
        buf->bufferprop = (buf->bufferprop & 65535 | 24) & 65535;
        if(buf->type == 0) {
            buf->type = "text/plain";
        }
        pushBuffer(buf);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    disp_message("Execution failed", 1);
    return;
}

readsh()
{// addr = 0x0804F776  --  defined in 'main.c' at line 2045
    Buffer* buf;        // _cfa_fffffff0
    _None* prevtrap;                       // _cfa_ffffffec
    char* cmd;                             // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43
    _unknown_ _t55;                        // _t55

    CurrentKeyData = 0;
    cmd = searchKeyData();
    if(cmd == 0 || ( *cmd & 0xff) == 0) {
        cmd = inputLineHistSearch("(read shell)!", 135036496, 128, ShellHist, 0);
    }
    if(cmd != 0) {
        cmd =  *(wc_Str_conv_strict(Strnew_charp(cmd), InnerCharset, SystemCharset));
    }
    if(cmd == 0 || ( *cmd & 0xff) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    prevtrap = mySignal(2, intTrap);
    crmode();
    buf = getshell(cmd);
    mySignal(2, prevtrap);
    term_raw();
    if(buf != 0) {
        buf->bufferprop = (buf->bufferprop & 65535 | 24) & 65535;
        if(buf->type == 0) {
            buf->type = "text/plain";
        }
        pushBuffer(buf);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    disp_message("Execution failed", 1);
    return;
}

execsh()
{// addr = 0x0804F8DE  --  defined in 'main.c' at line 2082
    char* cmd;                             // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t31;                        // _t31
    _unknown_ _t33;                        // _t33
    _unknown_ _t35;                        // _t35
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38

    CurrentKeyData = 0;
    cmd = searchKeyData();
    if(cmd == 0 || ( *cmd & 0xff) == 0) {
        cmd = inputLineHistSearch("(exec shell)!", 135036496, 128, ShellHist, 0);
    }
    if(cmd != 0) {
        cmd =  *(wc_Str_conv_strict(Strnew_charp(cmd), InnerCharset, SystemCharset));
    }
    if(cmd != 0 && ( *cmd & 0xff) != 0) {
        fmTerm();
        putchar(10);
        system(cmd);
        printf("\n[Hit any key]");
        fflush(__imp__stdout);
        fmInit();
        do_getch();
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

ldfile()
{// addr = 0x0804F9D9  --  defined in 'main.c' at line 2107
    char* fn;                              // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23

    fn = searchKeyData();
    if(fn == 0 || ( *fn & 0xff) == 0) {
        fn = inputLineHistSearch("(Load)Filename? ", 0, 32, LoadHist, 0);
    }
    if(fn != 0) {
        fn =  *(wc_Str_conv_strict(Strnew_charp(fn), InnerCharset, SystemCharset));
    }
    if(fn == 0 || ( *fn & 0xff) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    cmd_loadfile(fn);
    return;
}

ldhelp()
{// addr = 0x0804FA97  --  defined in 'main.c' at line 2126
    char* lang;                            // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct _Str* _t21;    // _t21
    struct _Str* _t24;    // _t24

    lang = AcceptLang;
    n = strcspn(lang, ";, \t");
    _t21 = Str_form_quote(Strnew_charp_n(lang, n));
    _t24 = Str_form_quote(Strnew_charp(w3m_version));
    _v36 = _t21->ptr;
    _v40 = _t24->ptr;
    tmp = Sprintf("file:///$LIB/w3mhelp.cgi?version=%s&lang=%s");
    cmd_loadURL(tmp->ptr, 0, -1, 0);
    return;
}

cmd_loadfile(char* fn)
{// addr = 0x0804FB31  --  defined in 'main.c' at line 2145
    Buffer* buf;        // _cfa_fffffff0
    char* emsg;                            // _cfa_ffffffec
    int _v44;                              // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    struct _Str _v56;     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    char* _t24;                            // _t24

    _t24 = file_to_url(fn);
    _v44 = 0;
    _v56.area_size = 0;
    buf = loadGeneralFile(_t24, 0, -1);
    if(buf != 0) {
        if(buf != 1) {
            pushBuffer(buf);
            if((RenderFrame & 0xff) != 0 && CurrentTab->currentBuffer->frameset != 0) {
                rFrame();
            }
        }
    } else {
        _v56 =  *(wc_Str_conv(Strnew_charp(fn), SystemCharset, InnerCharset));
        emsg =  *(Sprintf("%s not found"));
        disp_err_message(emsg, 0);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

_movL(int n)
{// addr = 0x0804FC1A  --  defined in 'main.c' at line 2165
    int i;                                 // _cfa_fffffff0
    int m;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14

    m = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i = 0;
        while(i < m) {
            cursorLeft(CurrentTab->currentBuffer, n);
            i = i + 1;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

movL()
{// addr = 0x0804FC80  --  defined in 'main.c' at line 2175
    _unknown_ __ebp;                       // r6

    _t13 = CurrentTab->currentBuffer->COLS & 65535;
    asm("cwde ");
    _movL((CurrentTab->currentBuffer->COLS & 65535) + _t13);
    return;
}

movL1()
{// addr = 0x0804FCA9  --  defined in 'main.c' at line 2181
    _unknown_ __ebp;                       // r6

    _movL(1);
    return;
}

_movD(int n)
{// addr = 0x0804FCBD  --  defined in 'main.c' at line 2188
    int i;                                 // _cfa_fffffff0
    int m;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14

    m = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i = 0;
        while(i < m) {
            cursorDown(CurrentTab->currentBuffer, n);
            i = i + 1;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

movD()
{// addr = 0x0804FD23  --  defined in 'main.c' at line 2198
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    _movD(((CurrentTab->currentBuffer->LINES & 65535) + 1 >> 31) + (CurrentTab->currentBuffer->LINES & 65535) + 1 >> 1);
    return;
}

movD1()
{// addr = 0x0804FD4D  --  defined in 'main.c' at line 2204
    _unknown_ __ebp;                       // r6

    _movD(1);
    return;
}

_movU(int n)
{// addr = 0x0804FD61  --  defined in 'main.c' at line 2212
    int i;                                 // _cfa_fffffff0
    int m;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14

    m = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i = 0;
        while(i < m) {
            cursorUp(CurrentTab->currentBuffer, n);
            i = i + 1;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

movU()
{// addr = 0x0804FDC7  --  defined in 'main.c' at line 2222
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    _movU(((CurrentTab->currentBuffer->LINES & 65535) + 1 >> 31) + (CurrentTab->currentBuffer->LINES & 65535) + 1 >> 1);
    return;
}

movU1()
{// addr = 0x0804FDF1  --  defined in 'main.c' at line 2228
    _unknown_ __ebp;                       // r6

    _movU(1);
    return;
}

_movR(int n)
{// addr = 0x0804FE05  --  defined in 'main.c' at line 2235
    int i;                                 // _cfa_fffffff0
    int m;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14

    m = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i = 0;
        while(i < m) {
            cursorRight(CurrentTab->currentBuffer, n);
            i = i + 1;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

movR()
{// addr = 0x0804FE6B  --  defined in 'main.c' at line 2245
    _unknown_ __ebp;                       // r6

    _t13 = CurrentTab->currentBuffer->COLS & 65535;
    asm("cwde ");
    _movR((CurrentTab->currentBuffer->COLS & 65535) + _t13);
    return;
}

movR1()
{// addr = 0x0804FE94  --  defined in 'main.c' at line 2251
    _unknown_ __ebp;                       // r6

    _movR(1);
    return;
}

int prev_nonnull_line(Line* line)
{// addr = 0x0804FEA8  --  defined in 'main.c' at line 2265
    Line* l;              // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t29;                        // _t29

    l = line;
    while(l != 0 && l->len == 0) {
    }
    if(l == 0 || l->len == 0) {
        return -1;
    }
    CurrentTab->currentBuffer->currentLine = l;
    if(l != line) {
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len;
    }
    return 0;
}

movLW()
{// addr = 0x0804FF1D  --  defined in 'main.c' at line 2279
    char* lb;                              // _cfa_fffffff0
    Lineprop* pb;     // _cfa_ffffffec
    Line* pline;          // _cfa_ffffffe8
    int ppos;                              // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int n;                                 // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t86;                        // _t86

    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    } else {
        i = 0;
        while(i < n) {
            pline = CurrentTab->currentBuffer->currentLine;
            ppos = CurrentTab->currentBuffer->pos;
            if(prev_nonnull_line(CurrentTab->currentBuffer->currentLine) >= 0) {
                goto L21;
            } else {
                goto L3;
            }
            while(1) {
L3:
                lb = CurrentTab->currentBuffer->currentLine->lineBuf;
                pb = CurrentTab->currentBuffer->currentLine->propBuf;
                goto L5;
            }
L21:
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        goto L21;
    }
}

int next_nonnull_line(Line* line)
{// addr = 0x08050144  --  defined in 'main.c' at line 2329
    Line* l;              // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    _unknown_ _t26;                        // _t26

    l = line;
    while(l != 0 && l->len == 0) {
    }
    if(l == 0 || l->len == 0) {
        return -1;
    }
    CurrentTab->currentBuffer->currentLine = l;
    if(l != line) {
        CurrentTab->currentBuffer->pos = 0;
    }
    return 0;
}

movRW()
{// addr = 0x080501AE  --  defined in 'main.c' at line 2344
    char* lb;                              // _cfa_fffffff0
    Lineprop* pb;     // _cfa_ffffffec
    Line* pline;          // _cfa_ffffffe8
    int ppos;                              // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int n;                                 // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t92;                        // _t92

    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    i = 0;
L20:
    while(i < n) {
        pline = CurrentTab->currentBuffer->currentLine;
        ppos = CurrentTab->currentBuffer->pos;
        if(next_nonnull_line(CurrentTab->currentBuffer->currentLine) >= 0) {
            goto L23;
        }
        lb = CurrentTab->currentBuffer->currentLine->lineBuf;
        pb = CurrentTab->currentBuffer->currentLine->propBuf;
        while((lb[CurrentTab->currentBuffer->pos] & 0xff) != 0) {
            if(( *( &MYCTYPE_MAP + (lb[CurrentTab->currentBuffer->pos] & 0xff)) & 0xc) == 0) {
                goto L12;
            }
            if(( *(CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos + pb) & 0x3f00) == 0) {
                CurrentTab->currentBuffer->pos =  &(CurrentTab->currentBuffer->pos->lineBuf);
                continue;
            }
L12:
            while((lb[CurrentTab->currentBuffer->pos] & 0xff) == 0 || ( *( &MYCTYPE_MAP + (lb[CurrentTab->currentBuffer->pos] & 0xff)) & 0xc) != 0 && ( *(CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos + pb) & 0x3f00) == 0) {
                if((lb[CurrentTab->currentBuffer->pos] & 0xff) == 0) {
                    if(next_nonnull_line(CurrentTab->currentBuffer->currentLine->next) >= 0) {
                        CurrentTab->currentBuffer->pos = 0;
                        lb = CurrentTab->currentBuffer->currentLine->lineBuf;
                        pb = CurrentTab->currentBuffer->currentLine->propBuf;
                        continue;
                    }
                    goto L18;
                }
                i = i + 1;
                goto L20;
L18:
                CurrentTab->currentBuffer->currentLine = pline;
                CurrentTab->currentBuffer->pos = ppos;
                goto L23;
            }
            CurrentTab->currentBuffer->pos =  &(CurrentTab->currentBuffer->pos->lineBuf);
            goto L12;
        }
        goto L12;
L23:
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    goto L23;
}

_quitfm(int confirm)
{// addr = 0x080503D6  --  defined in 'main.c' at line 2391
    char* ans;                             // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29

    ans = "y";
    if(checkDownloadList() == 0) {
        if(confirm != 0) {
            ans = inputLineHistSearch("Do you want to exit w3m? (y/n)", 135036496, 512, 0, 0);
        }
    } else {
        ans = inputLineHistSearch("Download process retains. Do you want to exit w3m? (y/n)", 135036496, 512, 0, 0);
    }
    if(ans == 0) {
L9:
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        if(( *( &MYCTYPE_MAP + ( *ans & 0xff)) & 4) == 0) {
            if(( *ans & 0xff) == 121) {
                goto L10;
            }
            goto L9;
        }
        if((( *ans & 255 | 32) & 255) != 121) {
            goto L9;
        }
        goto L10;
    }
L10:
    term_title(135036496);
    if(activeImage != 0) {
        termImage();
    }
    fmTerm();
    save_cookies();
    if(UseHistory != 0 && SaveURLHist != 0) {
        saveHistory(URLHist, URLHistSize);
    }
    w3m_exit(0);
    return;
}

quitfm()
{// addr = 0x08050501  --  defined in 'main.c' at line 2424
    _unknown_ __ebp;                       // r6

    _quitfm(0);
    return;
}

qquitfm()
{// addr = 0x08050515  --  defined in 'main.c' at line 2430
    _unknown_ __ebp;                       // r6

    _quitfm(confirm_on_quit);
    return;
}

selBuf()
{// addr = 0x0805052A  --  defined in 'main.c' at line 2436
    char cmd;                              // _cfa_fffffff3
    Buffer* buf;        // _cfa_ffffffec
    int ok;                                // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t38;                       // _t38

    ok = 0;
    goto L1;
    do {
L1:
        buf = selectBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer,  &cmd);
        _t38 = cmd & 0xff;
        if(_t38 == 68) {
            delBuffer(buf);
            if(CurrentTab->firstBuffer == 0) {
                CurrentTab->firstBuffer = nullBuffer();
                CurrentTab->currentBuffer = CurrentTab->firstBuffer;
            }
            goto L18;
        }
        if(_t38 <= 68) {
            if(_t38 == 66) {
                ok = 1;
            } else {
                if(_t38 <= 66 && (_t38 == 10 || _t38 == 32)) {
                    CurrentTab->currentBuffer = buf;
                    ok = 1;
                }
            }
        } else {
            if(_t38 == 81) {
                quitfm();
            } else {
                if(_t38 == 113) {
                    qquitfm();
                }
            }
        }
L18:
    } while(ok == 0);
    buf = CurrentTab->firstBuffer;
    while(buf != 0) {
        if(CurrentTab->currentBuffer != buf) {
            deleteImage(buf);
            if(clear_buffer != 0) {
                tmpClearBuffer(buf);
            }
        }
        buf = buf->nextBuffer;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

susp()
{// addr = 0x08050668  --  defined in 'main.c' at line 2484
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    move(LINES - 1, 0);
    clrtoeolx();
    refresh();
    fmTerm();
    _v24 = 19;
     *__esp = 0;
    kill();
    fmInit();
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

_goLine(char* l)
{// addr = 0x080506C8  --  defined in 'main.c' at line 2507
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    Buffer* _t91;       // _t91

    if(l == 0 || ( *l & 0xff) == 0 || CurrentTab->currentBuffer->currentLine == 0) {
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    CurrentTab->currentBuffer->pos = 0;
    if(( *l & 0xff) == 94 || ( *l & 0xff) == 36) {
        if(prec_num == 0) {
            goto L8;
        } else {
            gotoRealLine(CurrentTab->currentBuffer, prec_num);
        }
L13:
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
L8:
    if(( *l & 0xff) != 94) {
        if(( *l & 0xff) != 36) {
            gotoRealLine(CurrentTab->currentBuffer, atoi(l));
        } else {
            asm("cwde ");
            CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->lastLine, ( !(CurrentTab->currentBuffer->LINES & 65535) >> 31) +  !(CurrentTab->currentBuffer->LINES & 65535) >> 1, 1);
            CurrentTab->currentBuffer->currentLine = CurrentTab->currentBuffer->lastLine;
        }
    } else {
        _t91 = CurrentTab->currentBuffer;
        _t91->currentLine = CurrentTab->currentBuffer->firstLine;
        CurrentTab->currentBuffer->topLine = _t91->currentLine;
    }
    goto L13;
}

goLine()
{// addr = 0x0805084C  --  defined in 'main.c' at line 2532
    char* str;                             // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8

    str = searchKeyData();
    if(prec_num == 0) {
        if(str == 0) {
            _goLine(inputLineHistSearch("Goto line: ", 135036496, 16, 0, 0));
            return;
        }
        goto L3;
    }
    _goLine("^");
    return;
L3:
    _goLine(str);
    return;
}

goLineF()
{// addr = 0x080508BA  --  defined in 'main.c' at line 2546
    _unknown_ __ebp;                       // r6

    _goLine("^");
    return;
}

goLineL()
{// addr = 0x080508CE  --  defined in 'main.c' at line 2551
    _unknown_ __ebp;                       // r6

    _goLine("$");
    return;
}

linbeg()
{// addr = 0x080508E2  --  defined in 'main.c' at line 2557
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(CurrentTab->currentBuffer->firstLine != 0) {
        while(CurrentTab->currentBuffer->currentLine->prev != 0 && CurrentTab->currentBuffer->currentLine->bpos != 0) {
            cursorUp0(CurrentTab->currentBuffer, 1);
        }
        CurrentTab->currentBuffer->pos = 0;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

linend()
{// addr = 0x08050971  --  defined in 'main.c' at line 2569
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(CurrentTab->currentBuffer->firstLine != 0) {
        while(CurrentTab->currentBuffer->currentLine->next != 0 && CurrentTab->currentBuffer->currentLine->next->bpos != 0) {
            cursorDown0(CurrentTab->currentBuffer, 1);
        }
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len - 1;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

int cur_real_linenumber(Buffer* buf)
{// addr = 0x08050A14  --  defined in 'main.c' at line 2582
    Line* l;              // _cfa_fffffff8
    Line* cur;            // _cfa_fffffff4
    int n;                                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    int _t30;                              // _t30
    _unknown_ _t42;                        // _t42

    cur = buf->currentLine;
    if(cur == 0) {
        return 1;
    }
    if(cur->real_linenumber == 0) {
        _t30 = 1;
    } else {
        _t30 = cur->real_linenumber;
    }
    n = _t30;
    l = buf->firstLine;
    while(l != 0 && l != cur && l->real_linenumber == 0) {
        if(l->bpos == 0) {
            n = n + 1;
        }
        l = l->next;
    }
    return n;
}

editBf()
{// addr = 0x08050A89  --  defined in 'main.c' at line 2598
    char* fn;                              // _cfa_fffffff0
    Str cmd;               // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    TabBuffer* _t40;   // _t40
    Buffer* _t44;       // _t44
    Buffer* _t49;       // _t49
    Buffer* _t54;       // _t54
    int _t61;                              // _t61
    _unknown_ _t67;                        // _t67
    Buffer* _t76;       // _t76

    _t40 = CurrentTab;
    _t42 = _t40->currentBuffer->filename;
    fn = _t40->currentBuffer->filename;
    if(fn == 0) {
L7:
        disp_err_message("Can't edit other than local file", 1);
        return;
    }
    _t44 = CurrentTab->currentBuffer;
    _t42 =  *(_t44 + 92);
    if( *(_t44 + 92) != 0) {
        goto L7;
    }
    if(CurrentTab->currentBuffer->type != 0) {
L4:
        _t49 = CurrentTab->currentBuffer;
        _t42 = _t49->real_scheme;
        if(_t49->real_scheme != 4 || strcmp( *(CurrentTab->currentBuffer + 152), "-") == 0) {
            goto L7;
        }
        _t54 = CurrentTab->currentBuffer;
        asm("cwde ");
        _t42 = _t54->bufferprop & 2;
        if((_t54->bufferprop & 2) == 0) {
            goto L8;
        }
        goto L7;
    }
    _t76 = CurrentTab->currentBuffer;
    _t42 = _t76->edit;
    if(_t76->edit == 0) {
        goto L7;
    }
    goto L4;
L8:
    if(CurrentTab->currentBuffer->edit == 0) {
        _t61 = cur_real_linenumber(CurrentTab->currentBuffer);
        cmd = myEditor(Editor, shell_quote(fn), _t61);
    } else {
        cmd = unquote_mailcap(CurrentTab->currentBuffer->edit, CurrentTab->currentBuffer->real_type, fn, checkHeader(CurrentTab->currentBuffer, "Content-Type:"), 0);
    }
    fmTerm();
    system(cmd->ptr);
    fmInit();
    displayBuffer(CurrentTab->currentBuffer, 1);
    reload();
    return;
}

editScr()
{// addr = 0x08050C0E  --  defined in 'main.c' at line 2625
    char* tmpf;                            // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    _unknown_ _t30;                        // _t30
    int _t33;                              // _t33
    _unknown_ _t38;                        // _t38
    _unknown_ _t40;                        // _t40

    tmpf =  *(tmpfname(0, 0));
    f = fopen(tmpf, "w");
    if(f != 0) {
        saveBuffer(CurrentTab->currentBuffer, f, 1);
        fclose(f);
        fmTerm();
        _t33 = cur_real_linenumber(CurrentTab->currentBuffer);
        system( *(myEditor(Editor, shell_quote(tmpf), _t33)));
        fmInit();
        unlink(tmpf);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    _v40 = tmpf;
    disp_err_message( *(Sprintf("Can't open %s")), 1);
    return;
}

_mark()
{// addr = 0x08050D0F  --  defined in 'main.c' at line 2650
    Line* l;              // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(use_mark == 0) {
        return;
    }
    if(CurrentTab->currentBuffer->firstLine == 0) {
    } else {
        goto L2;
    }
    goto L4;
L2:
    l = CurrentTab->currentBuffer->currentLine;
     *(l->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) = ( *(l->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 65535 ^ 1) & 65535;
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
L4:
    return;
}

nextMk()
{// addr = 0x08050D8F  --  defined in 'main.c' at line 2663
    Line* l;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(use_mark == 0) {
        return;
    }
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i =  &(CurrentTab->currentBuffer->pos->lineBuf);
        l = CurrentTab->currentBuffer->currentLine;
        if(l->len <= i) {
            i = 0;
            l = l->next;
        }
        while(l != 0) {
            while(l->len > i) {
                if(( *(l->propBuf + i + i) & 1) == 0) {
                    i = i + 1;
                    continue;
                }
                CurrentTab->currentBuffer->currentLine = l;
                CurrentTab->currentBuffer->pos = i;
                arrangeCursor(CurrentTab->currentBuffer);
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            l = l->next;
            i = 0;
        }
        disp_message("No mark exist after here", 1);
        return;
    }
    return;
}

prevMk()
{// addr = 0x08050E9C  --  defined in 'main.c' at line 2696
    Line* l;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(use_mark == 0) {
        return;
    }
    if(CurrentTab->currentBuffer->firstLine != 0) {
        i = CurrentTab->currentBuffer->pos - 1;
        l = CurrentTab->currentBuffer->currentLine;
        if(i < 0) {
            l = l->prev;
            if(l != 0) {
                i = l->len - 1;
            }
        }
        while(l != 0) {
            while(i >= 0) {
                if(( *(l->propBuf + i + i) & 1) == 0) {
                    i = i - 1;
                    continue;
                }
                CurrentTab->currentBuffer->currentLine = l;
                CurrentTab->currentBuffer->pos = i;
                arrangeCursor(CurrentTab->currentBuffer);
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            l = l->prev;
            if(l != 0) {
                i = l->len - 1;
            }
        }
        disp_message("No mark exist before here", 1);
        return;
    }
    return;
}

reMark()
{// addr = 0x08050FB6  --  defined in 'main.c' at line 2731
    Line* l;              // _cfa_fffffff0
    char* str;                             // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* p1;                              // _cfa_ffffffe4
    char* p2;                              // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6

    if(use_mark == 0) {
        return;
    }
    str = searchKeyData();
    if(str == 0 || ( *str & 0xff) == 0) {
        str = inputLineHistSearch("(Mark)Regexp: ", MarkString, 16, TextHist, 0);
        if(str == 0 || ( *str & 0xff) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
    str = conv_search_string(str, DisplayCharset);
    str = regexCompile(str, 1);
    if(str == 0) {
        MarkString = str;
        l = CurrentTab->currentBuffer->firstLine;
L13:
        while(l != 0) {
            goto L9;
        }
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    disp_message(str, 1);
    return;
L9:
    p = l->lineBuf;
    while(regexMatch(p, l->lineBuf + l->len - p, l->lineBuf & 0xff) == 1) {
        matchedPosition( &p1,  &p2);
         *(l->propBuf + p1 - l->lineBuf + p1 - l->lineBuf) = ( *(l->propBuf + p1 - l->lineBuf + p1 - l->lineBuf) & 65535 | 1) & 65535;
        p = p2;
    }
    l = l->next;
    goto L13;
}

Buffer* loadNormalBuf(Buffer* buf, int renderframe)
{// addr = 0x0805117F  --  defined in 'main.c' at line 2771
    _unknown_ __ebp;                       // r6

    pushBuffer(buf);
    if(renderframe != 0 && (RenderFrame & 0xff) != 0 && CurrentTab->currentBuffer->frameset != 0) {
        rFrame();
    }
    return buf;
}

Buffer* loadLink(char* url, char* target, char* referer, FormList* request)
{// addr = 0x080511BD  --  defined in 'main.c' at line 2780
    Buffer* buf;        // _cfa_fffffff0
    Buffer* nfbuf;      // _cfa_ffffffec
    union frameset_element* f_element;   // _cfa_ffffffe8
    int flag;                              // _cfa_ffffffe4
    ParsedURL* base;   // _cfa_ffffffe0
    char* emsg;                            // _cfa_ffffffdc
    Anchor* al;         // _cfa_ffffffd8
    char* label;                           // _cfa_ffffffd4
    char* _v52;                            // _cfa_ffffffcc
    ParsedURL pu;    // _cfa_ffffffac
    FormList* _v108;   // _cfa_ffffff94
    int _v112;                             // _cfa_ffffff90
    Buffer* _v116;      // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _None _t138;                           // _t138
    _unknown_ _t147;                       // _t147
    _unknown_ _t222;                       // _t222
    _unknown_ _t227;                       // _t227

    f_element = 0;
    flag = 0;
    _v120 = url;
    message( *(Sprintf("loading %s")), 0, 0);
    refresh();
    base = baseURL(CurrentTab->currentBuffer);
    if(base == 0 || base->scheme == 4 || base->scheme == 5) {
        referer = -1;
    }
    if(referer == 0) {
        referer =  *(parsedURL2Str(CurrentTab->currentBuffer + 132));
    }
    _t138 = baseURL(CurrentTab->currentBuffer);
    _v108 = request;
    _v112 = flag;
    buf = loadGeneralFile(url, _t138, referer);
    if(buf == 0) {
        _v120 = url;
        emsg =  *(Sprintf("Can't load %s"));
        disp_err_message(emsg, 0);
        return 0;
    }
    parseURL2(url,  &(pu.scheme), base);
    pushHashHist(URLHist,  *(parsedURL2Str( &(pu.scheme))));
    if(buf != 1) {
        if(on_target != 0) {
            if(do_download == 0) {
                if(target == 0 || strcmp(target, "_top") == 0) {
L17:
                    return loadNormalBuf(buf, 1);
                }
                asm("cwde ");
                if((CurrentTab->currentBuffer->bufferprop & 2) != 0) {
                    nfbuf = CurrentTab->currentBuffer->linkBuffer[1];
                    if(nfbuf != 0) {
                        f_element = search_frame(nfbuf->frameset, target);
                        if(f_element != 0) {
                            pushFrameTree( &(nfbuf->frameQ), copyFrameSet(nfbuf->frameset), CurrentTab->currentBuffer);
                            delBuffer(CurrentTab->currentBuffer);
                            CurrentTab->currentBuffer = nfbuf;
                            resetFrameElement(f_element, buf, referer, request);
                            discardBuffer(buf);
                            rFrame();
                            al = 0;
                            label = _v52;
                            if(label != 0 && ( *( *f_element) & 0xff) == 1) {
                                al = searchAnchor( *( *f_element + 28), label);
                            }
                            if(al == 0) {
                                _v116 = 0;
                                _v120 = target;
                                label =  *(Strnew_m_charp("_"));
                                al = searchURLLabel(CurrentTab->currentBuffer, label);
                            }
                            if(al != 0) {
                                gotoLine(CurrentTab->currentBuffer,  *(al + 20));
                                if(label_topline != 0) {
                                    CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->topLine, CurrentTab->currentBuffer->currentLine->linenumber - CurrentTab->currentBuffer->topLine->linenumber, 0);
                                }
                                CurrentTab->currentBuffer->pos =  *(al + 24);
                                arrangeCursor(CurrentTab->currentBuffer);
                            }
                            displayBuffer(CurrentTab->currentBuffer, 0);
                            return buf;
                        }
                        goto L21;
                    }
                    goto L19;
L21:
                    return loadNormalBuf(buf, 1);
                }
                goto L17;
L19:
                return loadNormalBuf(buf, 1);
            }
            goto L13;
        }
        goto L11;
L13:
        return loadNormalBuf(buf, 0);
    } else {
        return 0;
    }
L11:
    return loadNormalBuf(buf, 1);
}

gotoLabel(char* label)
{// addr = 0x080515BC  --  defined in 'main.c' at line 2872
    Buffer* buf;        // _cfa_fffffff0
    Anchor* al;         // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t75;                        // _t75

    al = searchURLLabel(CurrentTab->currentBuffer, label);
    if(al != 0) {
        asm("cwde ");
        buf = newBuffer(CurrentTab->currentBuffer->width & 65535);
        copyBuffer(buf, CurrentTab->currentBuffer);
        i = 0;
L4:
        while(i <= 4) {
            goto L3;
        }
         *(buf + 164) = allocStr(label, -1);
        pushHashHist(URLHist,  *(parsedURL2Str(buf + 132)));
         *(buf->clone) =  &(buf->filename);
        pushBuffer(buf);
        gotoLine(CurrentTab->currentBuffer,  *(al + 20));
        if(label_topline != 0) {
            CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->topLine, CurrentTab->currentBuffer->currentLine->linenumber - CurrentTab->currentBuffer->topLine->linenumber, 0);
        }
        CurrentTab->currentBuffer->pos =  *(al + 24);
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    _v40 = label;
    disp_message( *(Sprintf("%s is not found")), 1);
    return;
L3:
     *(buf + 12 + (i + 4) * 4) = 0;
    i = i + 1;
    goto L4;
}

followA()
{// addr = 0x08051773  --  defined in 'main.c' at line 2905
    Line* l;              // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    int x;                                 // _cfa_ffffffe8
    int y;                                 // _cfa_ffffffe4
    int map;                               // _cfa_ffffffe0
    char* url;                             // _cfa_ffffffdc
    Str to;                // _cfa_ffffffd8
    Buffer* buf;        // _cfa_ffffffd4
    char* _v52;                            // _cfa_ffffffcc
    ParsedURL u;     // _cfa_ffffffac
    int _v96;                              // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    struct _Str* _t129;   // _t129
    _unknown_ _t144;                       // _t144
    _unknown_ _t159;                       // _t159
    _unknown_ _t163;                       // _t163
    _unknown_ _t189;                       // _t189
    _unknown_ _t194;                       // _t194
    _unknown_ _t207;                       // _t207

    x = 0;
    y = 0;
    map = 0;
    if(CurrentTab->currentBuffer->firstLine == 0) {
L32:
        return;
    }
    l = CurrentTab->currentBuffer->currentLine;
    a = retrieveCurrentImg(CurrentTab->currentBuffer);
    if(a == 0) {
L5:
        if(a != 0) {
L6:
            if(a->image != 0) {
                if((a->image->ismap & 0xff) != 0) {
                    getMapXY(CurrentTab->currentBuffer, a,  &x,  &y);
                    map = 1;
                }
            }
        }
        a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
        if(a != 0) {
            if((a & 0xff) != 35) {
                parseURL2(a->url,  &(u.scheme), baseURL(CurrentTab->currentBuffer));
                _t129 = parsedURL2Str(CurrentTab->currentBuffer + 132);
                if(strcmp( *(parsedURL2Str( &(u.scheme))),  *_t129) != 0 || _v52 == 0) {
                    if(strncasecmp(a->url, "mailto:", 7) != 0 || non_null(Mailer) == 0 || strchr(a->url, 63) != 0) {
                        url = a->url;
                        if(map != 0) {
                            _v96 = y;
                            _v100 = x;
                            _v104 = a->url;
                            url =  *(Sprintf("%s?%d,%d"));
                        }
                        if(check_target == 0 || open_tab_blank == 0 || a->target == 0 || strcasecmp(a->target, "_new") != 0 && strcasecmp(a->target, "_blank") != 0) {
                            loadLink(url, a->target, a->referer, 0);
                            displayBuffer(CurrentTab->currentBuffer, 0);
                            return;
                        } else {
                            _newT();
                            buf = CurrentTab->currentBuffer;
                            loadLink(url, a->target, a->referer, 0);
                            if(CurrentTab->currentBuffer == buf) {
                                deleteTab(CurrentTab);
                            } else {
                                delBuffer(buf);
                            }
                            displayBuffer(CurrentTab->currentBuffer, 1);
                            return;
                        }
                        goto L32;
                    }
                    to = Strnew_charp( &(a->url->ext));
                    fmTerm();
                    system( *(myExtCommand(Mailer, shell_quote(file_unquote(to->ptr)), 0)));
                    fmInit();
                    displayBuffer(CurrentTab->currentBuffer, 1);
                    pushHashHist(URLHist, a->url);
                    return;
                }
                gotoLabel(_v52);
                return;
            }
            goto L12;
        }
        _followForm(0);
        return;
L12:
        gotoLabel( &(a->url->url));
        return;
    }
    if(a->image == 0) {
        goto L5;
    } else {
        if(a->image->map == 0) {
            goto L5;
        } else {
            _followForm(0);
            return;
        }
    }
    goto L6;
}

bufferA()
{// addr = 0x08051B2B  --  defined in 'main.c' at line 3012
    _unknown_ __ebp;                       // r6

    on_target = 0;
    followA();
    on_target = 1;
    return;
}

followI()
{// addr = 0x08051B4C  --  defined in 'main.c' at line 3020
    Line* l;              // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8
    char* emsg;                            // _cfa_ffffffe4
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _None _t45;                            // _t45

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    l = CurrentTab->currentBuffer->currentLine;
    a = retrieveCurrentImg(CurrentTab->currentBuffer);
    if(a != 0) {
        _v56 = a->url;
        message( *(Sprintf("loading %s")), 0, 0);
        refresh();
        _t45 = baseURL(CurrentTab->currentBuffer);
        _v44 = 0;
        _v48 = 0;
        buf = loadGeneralFile(a->url, _t45, 0);
        if(buf != 0) {
            if(buf != 1) {
                pushBuffer(buf);
            }
        } else {
            _v56 = a->url;
            emsg =  *(Sprintf("Can't load %s"));
            disp_err_message(emsg, 0);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

FormItemList* save_submit_formlist(FormItemList* src)
{// addr = 0x08051C66  --  defined in 'main.c' at line 3049
    FormList* list;   // _cfa_fffffff0
    FormList* srclist;   // _cfa_ffffffec
    FormItemList* srcitem;   // _cfa_ffffffe8
    FormItemList* item;   // _cfa_ffffffe4
    FormItemList* ret;   // _cfa_ffffffe0
    FormSelectOptionItem* opt;   // _cfa_ffffffdc
    FormSelectOptionItem* curopt;   // _cfa_ffffffd8
    FormSelectOptionItem* srcopt;   // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    FormList* _t151;   // _t151
    FormItemList* _t170;   // _t170
    FormSelectOptionItem* _t195;   // _t195
    _unknown_ _t233;                       // _t233

    ret = 0;
    if(src != 0) {
        _t151 = src->parent;
        srclist = _t151;
         *__esp = 52;
        GC_malloc();
        list = _t151;
        list->method = srclist->method;
         *(list + 12) = Strdup( *(srclist + 12));
         *((intOrPtr*)(list + 24)) =  *((intOrPtr*)(srclist + 24));
        list->enctype = srclist->enctype;
        list->nitems = srclist->nitems;
        list->body = srclist->body;
        list->boundary = srclist->boundary;
        list->length = srclist->length;
        _t170 = srclist->item;
        srcitem = _t170;
L19:
        while(srcitem != 0) {
            goto L3;
        }
        return ret;
    }
    return 0;
L3:
     *__esp = 72;
    GC_malloc();
    item = _t170;
    item->type = srcitem->type;
     *(item + 4) = Strdup( *(srcitem + 4));
     *(item + 8) = Strdup( *(srcitem + 8));
    item->checked = srcitem->checked;
    item->accept = srcitem->accept;
    item->size = srcitem->size;
    item->rows = srcitem->rows;
    item->maxlength = srcitem->maxlength;
    item->readonly = srcitem->readonly;
    curopt = 0;
    opt = curopt;
    srcopt = srcitem->select_option;
    while(srcopt != 0) {
        _t195 = srcopt->checked;
        if(_t195 != 0) {
             *__esp = 16;
            GC_malloc();
            opt = _t195;
            opt->value = Strdup(srcopt->value);
             *(opt + 4) = Strdup( *(srcopt + 4));
            opt->checked = srcopt->checked;
            if(item->select_option != 0) {
                curopt->next = opt;
                curopt = curopt->next;
            } else {
                curopt = opt;
                item->select_option = curopt;
            }
        }
        srcopt = srcopt->next;
    }
    item->select_option = opt;
    if( *(srcitem + 48) != 0) {
         *(item + 48) = Strdup( *(srcitem + 48));
    }
    item->parent = list;
    item->next = 0;
    if(list->lastitem != 0) {
        list->lastitem->next = item;
        list->lastitem = item;
    } else {
        list->lastitem = item;
        list->item = list->lastitem;
    }
    if(srcitem == src) {
        ret = item;
    }
    _t170 = srcitem->next;
    srcitem = _t170;
    goto L19;
}

Str conv_form_encoding(Str val, FormItemList* fi, Buffer* buf)
{// addr = 0x08051ED7  --  defined in 'main.c' at line 3129
    wc_ces charset;     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    charset = SystemCharset;
    if( *(fi->parent + 24) == 0) {
        if( *(buf + 208) != 0 &&  *(buf + 208) != 256) {
            charset =  *(buf + 208);
        }
    } else {
        charset =  *(fi->parent + 24);
    }
    return wc_Str_conv_strict(val, InnerCharset, charset);
}

query_from_followform(Str* query, FormItemList* fi, int multipart)
{// addr = 0x08051F46  --  defined in 'main.c' at line 3144
    int x;                                 // _cfa_ffffffe8
    int y;                                 // _cfa_ffffffe4
    FormItemList* f2;   // _cfa_fffffff0
    FILE* body;           // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t256;                       // _t256
    _unknown_ _t269;                       // _t269
    _unknown_ _t271;                       // _t271
    struct _Str* _t294;   // _t294
    struct _Str* _t331;   // _t331
    _unknown_ _t343;                       // _t343
    struct _Str* _t385;   // _t385
    _unknown_ _t399;                       // _t399
    _unknown_ _t430;                       // _t430
    int _t469;                             // _t469
    int _t483;                             // _t483

    body = 0;
    if(multipart == 0) {
L3:
         *query = Strnew();
        f2 = fi->parent->item;
L38:
        while(f2 != 0) {
            goto L4;
        }
        if(multipart == 0) {
            while(1) {
                query =  *query;
                __eax =  *query->length;
                if( *query->length <= 0) {
                    break;
                }
                query =  *query;
                query =  *query;
                 *query->length =  *query->length - 1;
                 *( *query) +  *query->length - 1 =  *( *( *query) +  *query->length - 1) & 255;
                if(( *( *( *query) +  *query->length - 1) & 0xff) == 38) {
                    query =  *query;
                    Strshrink( *query, 1);
                    continue;
                }
                return;
            }
            goto L47;
        }
        _v52 = fi->parent->boundary;
        fprintf(body, "--%s--\n");
        fclose(body);
        return;
    }
     *query = tmpfname(0, 0);
    body = fopen( *( *query), "w");
    if(body == 0) {
L47:
        return;
    } else {
        fi->parent->body =  *( *query);
        _v44 = fi->parent->boundary;
        _v48 = fi->parent->body;
        _v52 = fi->parent;
        _v56 = CurrentPid;
        fi->parent->boundary =  *(Sprintf("------------------------------%d%ld%ld%ld"));
    }
    goto L3;
L4:
    if( *(f2 + 4) == 0) {
L37:
        f2 = f2->next;
        goto L38;
    }
    if( *(f2 + 4)->length != 0) {
L8:
        if(f2->type <= 7) {
            goto __eax;
        }
        if(multipart == 0) {
            if(f2->type != 7) {
                if( *(f2 + 4) != 0 &&  *(f2 + 4)->length > 0) {
                    Strcat( *query, Str_form_quote(conv_form_encoding( *(f2 + 4), fi, CurrentTab->currentBuffer)));
                    if( *query->length + 1 >=  *query->area_size) {
                        Strgrow( *query);
                    }
                    _t331 =  *query;
                    _t483 = _t331->length;
                     *((char*)( *( *query) + _t483)) = 61;
                    _t331->length = _t483 + 1;
                     *( *( *query) +  *query->length) = 0;
                }
                if( *(f2 + 8) != 0) {
                    if(fi->parent->method != 2) {
                        Strcat( *query, Str_form_quote(conv_form_encoding( *(f2 + 8), fi, CurrentTab->currentBuffer)));
                    } else {
                        Strcat( *query, Str_form_quote( *(f2 + 8)));
                    }
                }
            } else {
                y = 0;
                x = 0;
                getMapXY(CurrentTab->currentBuffer, retrieveCurrentImg(CurrentTab->currentBuffer),  &y,  &x);
                Strcat( *query, Str_form_quote(conv_form_encoding( *(f2 + 4), fi, CurrentTab->currentBuffer)));
                _v56 = y;
                Strcat( *query, Sprintf(".x=%d&"));
                Strcat( *query, Str_form_quote(conv_form_encoding( *(f2 + 4), fi, CurrentTab->currentBuffer)));
                _v56 = x;
                Strcat( *query, Sprintf(".y=%d"));
            }
            if(f2->next != 0) {
                if( *query->length + 1 >=  *query->area_size) {
                    Strgrow( *query);
                }
                _t294 =  *query;
                _t469 = _t294->length;
                 *((char*)( *( *query) + _t469)) = 38;
                _t294->length = _t469 + 1;
                 *( *( *query) +  *query->length) = 0;
            }
        } else {
            if(f2->type != 7) {
                if( *(f2 + 4) != 0 &&  *(f2 + 4)->length > 0 &&  *(f2 + 8) != 0) {
                     *query = conv_form_encoding( *(f2 + 8), fi, CurrentTab->currentBuffer);
                    if(f2->type != 11) {
                        form_write_data(body, fi->parent->boundary,  *(conv_form_encoding( *(f2 + 4), fi, CurrentTab->currentBuffer)),  *( *query));
                    } else {
                        _t385 = wc_Str_conv_strict( *(f2 + 8), InnerCharset, SystemCharset);
                        form_write_from_file(body, fi->parent->boundary,  *(conv_form_encoding( *(f2 + 4), fi, CurrentTab->currentBuffer)),  *( *query),  *_t385);
                    }
                }
            } else {
                x = 0;
                y = 0;
                getMapXY(CurrentTab->currentBuffer, retrieveCurrentImg(CurrentTab->currentBuffer),  &x,  &y);
                 *query = Strdup(conv_form_encoding( *(f2 + 4), fi, CurrentTab->currentBuffer));
                Strcat_charp( *query, ".x");
                _v56 = x;
                form_write_data(body, fi->parent->boundary,  *( *query),  *(Sprintf("%d")));
                 *query = Strdup(conv_form_encoding( *(f2 + 4), fi, CurrentTab->currentBuffer));
                Strcat_charp( *query, ".y");
                _v56 = y;
                form_write_data(body, fi->parent->boundary,  *( *query),  *(Sprintf("%d")));
            }
        }
        goto L37;
    }
    if(multipart != 0) {
        goto L37;
    }
    if(f2->type != 0) {
        goto L37;
    }
    goto L8;
}

submitForm()
{// addr = 0x08052630  --  defined in 'main.c' at line 3263
    _unknown_ __ebp;                       // r6

    _followForm(1);
    return;
}

followForm()
{// addr = 0x08052644  --  defined in 'main.c' at line 3270
    _unknown_ __ebp;                       // r6

    _followForm(0);
    return;
}

_followForm(int submit)
{// addr = 0x08052658  --  defined in 'main.c' at line 3276
    Anchor* a2;         // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    FormItemList* f2;   // _cfa_ffffffdc
    Str tmp;               // _cfa_ffffffd8
    Str tmp2;              // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffcc
    Buffer* buf;        // _cfa_ffffffc8
    struct stat st;       // _cfa_ffffff70
    Line* l;              // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    FormItemList* fi;   // _cfa_ffffffe0
    int multipart;                         // _cfa_ffffffd0
    _unknown_ _v184;                       // _cfa_ffffff48
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32

    multipart = 0;
    if(CurrentTab->currentBuffer->firstLine == 0) {
L5:
        return;
    }
    l = CurrentTab->currentBuffer->currentLine;
    a = retrieveCurrentForm(CurrentTab->currentBuffer);
    if(a == 0) {
    } else {
        fi = a->url;
        if(fi->type > 11) {
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        goto __eax;
        goto L5;
    }
    goto L6;
L7:
    return;
L6:
    goto L7;
}

topA()
{// addr = 0x08052F9E  --  defined in 'main.c' at line 3470
    HmarkerList* hl;   // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    Anchor* an;         // _cfa_ffffffe8
    int hseq;                              // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    hl = CurrentTab->currentBuffer->hmarklist;
    hseq = 0;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        goto L13;
    }
    if(hl->nmark == 0) {
        goto L14;
    }
    if(hl->nmark >= prec_num) {
        if(prec_num > 0) {
            hseq = prec_num - 1;
        }
    } else {
        hseq = hl->nmark - 1;
    }
    while(hl->nmark > hseq) {
        po = hl->marks + (hseq + hseq + _t102 << 2);
        an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
        if(an == 0) {
            an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
        }
        hseq = hseq + 1;
        if(an == 0) {
            continue;
        }
        gotoLine(CurrentTab->currentBuffer, po->line);
        CurrentTab->currentBuffer->pos = po->pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
L14:
    return;
L13:
    return;
}

lastA()
{// addr = 0x08053101  --  defined in 'main.c' at line 3503
    HmarkerList* hl;   // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    Anchor* an;         // _cfa_ffffffe8
    int hseq;                              // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    hl = CurrentTab->currentBuffer->hmarklist;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        goto L14;
    }
    if(hl->nmark == 0) {
        goto L15;
    }
    if(hl->nmark > prec_num) {
        if(prec_num <= 0) {
            hseq = hl->nmark - 1;
        } else {
            hseq = hl->nmark - prec_num;
        }
    } else {
        hseq = 0;
    }
    while(hseq < 0) {
        po = hl->marks + (hseq + hseq + _t103 << 2);
        an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
        if(an == 0) {
            an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
        }
        hseq = hseq - 1;
        if(an == 0) {
            continue;
        }
        gotoLine(CurrentTab->currentBuffer, po->line);
        CurrentTab->currentBuffer->pos = po->pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
L15:
    return;
L14:
    return;
}

nextA()
{// addr = 0x0805326A  --  defined in 'main.c' at line 3538
    _unknown_ __ebp;                       // r6

    _nextA(0);
    return;
}

prevA()
{// addr = 0x0805327E  --  defined in 'main.c' at line 3544
    _unknown_ __ebp;                       // r6

    _prevA(0);
    return;
}

nextVA()
{// addr = 0x08053292  --  defined in 'main.c' at line 3550
    _unknown_ __ebp;                       // r6

    _nextA(1);
    return;
}

prevVA()
{// addr = 0x080532A6  --  defined in 'main.c' at line 3556
    _unknown_ __ebp;                       // r6

    _prevA(1);
    return;
}

_nextA(int visited)
{// addr = 0x080532BA  --  defined in 'main.c' at line 3563
    HmarkerList* hl;   // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    Anchor* an;         // _cfa_ffffffe8
    Anchor* pan;        // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    int hseq;                              // _cfa_ffffffd0
    ParsedURL url;   // _cfa_ffffffa8
    _unknown_ _v96;                        // _cfa_ffffffa0
    _unknown_ _v100;                       // _cfa_ffffff9c
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebp;                       // r6

    hl = CurrentTab->currentBuffer->hmarklist;
    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        goto L41;
    }
    if(hl->nmark == 0) {
        goto L42;
    }
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(visited != 1) {
        if(an == 0) {
            an = retrieveCurrentForm(CurrentTab->currentBuffer);
        }
    }
    y = CurrentTab->currentBuffer->currentLine->linenumber;
    x = CurrentTab->currentBuffer->pos;
    if(visited == 1) {
        n = hl->nmark;
    }
    i = 0;
    while(1) {
L32:
        _t156 = i;
        if(i >= n) {
            break;
        }
        pan = an;
        if(an == 0 || an->hseq >= 0) {
            an = closest_next_anchor(CurrentTab->currentBuffer->href, 0, x, y);
            if(visited != 1) {
                an = closest_next_anchor(CurrentTab->currentBuffer->formitem, an, x, y);
            }
            if(an != 0) {
                x =  *(an + 24);
                y =  *(an + 20);
                if(visited != 1) {
                    goto L31;
                }
            } else {
                if(visited == 1) {
                    goto L44;
                }
                _t156 = pan;
                an = pan;
                break;
            }
            parseURL2(an->url,  &(url.scheme), baseURL(CurrentTab->currentBuffer));
            if(getHashHist(URLHist,  *(parsedURL2Str( &(url.scheme)))) != 0) {
                goto L36;
            }
            goto L31;
        } else {
            hseq = an->hseq + 1;
            while(hl->nmark > hseq) {
                po = hl->marks + (hseq + hseq + _t240 << 2);
                an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
                if(visited != 1 && an == 0) {
                    an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
                }
                hseq = hseq + 1;
                if(visited != 1 || an == 0) {
L21:
                    if(an == 0 || an == pan) {
                        continue;
                    }
L31:
                    i = i + 1;
                    goto L32;
                }
                parseURL2(an->url,  &(url.scheme), baseURL(CurrentTab->currentBuffer));
                if(getHashHist(URLHist,  *(parsedURL2Str( &(url.scheme)))) != 0) {
L37:
                    if(an == 0) {
L46:
                        return;
                    }
                    if(an->hseq >= 0) {
                        goto L47;
                    }
                    po = hl->marks + (an->hseq + an->hseq + _t242 << 2);
                    gotoLine(CurrentTab->currentBuffer, po->line);
                    CurrentTab->currentBuffer->pos = po->pos;
                    arrangeCursor(CurrentTab->currentBuffer);
                    displayBuffer(CurrentTab->currentBuffer, 0);
                    return;
L47:
                    return;
                }
                goto L21;
L36:
                goto L37;
            }
            if(visited == 1) {
                goto L43;
            }
            _t156 = pan;
            an = pan;
            goto L37;
L44:
            return;
        }
    }
    if(visited == 1) {
        return;
    }
    goto L37;
L43:
    return;
L42:
    return;
L41:
    return;
}

_prevA(int visited)
{// addr = 0x0805363C  --  defined in 'main.c' at line 3647
    HmarkerList* hl;   // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    Anchor* an;         // _cfa_ffffffe8
    Anchor* pan;        // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    int hseq;                              // _cfa_ffffffd0
    ParsedURL url;   // _cfa_ffffffa8
    _unknown_ _v96;                        // _cfa_ffffffa0
    _unknown_ _v100;                       // _cfa_ffffff9c
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    Anchor* _t197;      // _t197

    hl = CurrentTab->currentBuffer->hmarklist;
    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        goto L42;
    }
    if(hl->nmark == 0) {
        goto L43;
    }
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(visited != 1) {
        if(an == 0) {
            an = retrieveCurrentForm(CurrentTab->currentBuffer);
        }
    }
    y = CurrentTab->currentBuffer->currentLine->linenumber;
    x = CurrentTab->currentBuffer->pos;
    if(visited == 1) {
        n = hl->nmark;
    }
    i = 0;
    while(1) {
L33:
        _t155 = i;
        if(i >= n) {
            break;
        }
        pan = an;
        if(an == 0 || an->hseq >= 0) {
            an = closest_prev_anchor(CurrentTab->currentBuffer->href, 0, x, y);
            if(visited != 1) {
                an = closest_prev_anchor(CurrentTab->currentBuffer->formitem, an, x, y);
            }
            if(an != 0) {
                x =  *(an + 24);
                y =  *(an + 20);
                if(visited != 1 || an == 0) {
                    goto L32;
                }
                parseURL2(an->url,  &(url.scheme), baseURL(CurrentTab->currentBuffer));
                if(getHashHist(URLHist,  *(parsedURL2Str( &(url.scheme)))) != 0) {
                    goto L37;
                }
                goto L32;
            } else {
                if(visited == 1) {
                    goto L45;
                }
                _t155 = pan;
                an = pan;
                break;
            }
        } else {
            _t197 = an;
            _t199 = _t197->hseq - 1;
            hseq = _t197->hseq - 1;
            while(hseq >= 0) {
                po = hl->marks + (hseq + hseq + _t234 << 2);
                an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
                if(visited != 1 && an == 0) {
                    an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
                }
                hseq = hseq - 1;
                if(visited != 1 || an == 0) {
L21:
                    if(an == 0) {
                        continue;
                    }
                } else {
                    parseURL2(an->url,  &(url.scheme), baseURL(CurrentTab->currentBuffer));
                    if(getHashHist(URLHist,  *(parsedURL2Str( &(url.scheme)))) != 0) {
L38:
                        if(an == 0) {
L47:
                            return;
                        }
                        if(an->hseq >= 0) {
                            goto L48;
                        }
                        po = hl->marks + (an->hseq + an->hseq + _t236 << 2);
                        gotoLine(CurrentTab->currentBuffer, po->line);
                        CurrentTab->currentBuffer->pos = po->pos;
                        arrangeCursor(CurrentTab->currentBuffer);
                        displayBuffer(CurrentTab->currentBuffer, 0);
                        return;
L48:
                        return;
                    }
                    goto L21;
L37:
                    goto L38;
                }
                _t199 = an;
                if(an == pan) {
                    continue;
                }
L32:
                i = i + 1;
                goto L33;
            }
            if(visited == 1) {
                goto L44;
            }
            _t155 = pan;
            an = pan;
            goto L38;
L45:
            return;
        }
    }
    if(visited == 1) {
        return;
    }
    goto L38;
L44:
    return;
L43:
    return;
L42:
    return;
}

nextX(int d, int dy)
{// addr = 0x080539BF  --  defined in 'main.c' at line 3731
    HmarkerList* hl;   // _cfa_fffffff0
    Anchor* an;         // _cfa_ffffffec
    Anchor* pan;        // _cfa_ffffffe8
    Line* l;              // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    Line* _t113;          // _t113
    int _t114;                             // _t114
    int _t134;                             // _t134

    hl = CurrentTab->currentBuffer->hmarklist;
    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        goto L38;
    }
    if(hl->nmark == 0) {
        goto L39;
    }
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(an == 0) {
        an = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    l = CurrentTab->currentBuffer->currentLine;
    x = CurrentTab->currentBuffer->pos;
    y = l->linenumber;
    pan = 0;
    i = 0;
L32:
    while(i < n) {
        if(an != 0) {
            if(d <= 0) {
                _t134 =  *((intOrPtr*)(an + 24)) - 1;
            } else {
                _t134 =  *(an + 36);
            }
            x = _t134;
        }
        an = 0;
L17:
        while(1) {
            while(x < 0 && l->len > x) {
                an = retrieveAnchor(CurrentTab->currentBuffer->href, y, x);
                if(an == 0) {
                    an = retrieveAnchor(CurrentTab->currentBuffer->formitem, y, x);
                }
                if(an == 0) {
                    x = x + d;
                    continue;
                }
                pan = an;
                break;
            }
            if(dy == 0 || an != 0) {
L30:
                if(an == 0) {
                    goto L35;
                }
                goto L31;
L35:
                if(pan == 0) {
                    goto L40;
                }
                gotoLine(CurrentTab->currentBuffer, y);
                CurrentTab->currentBuffer->pos =  *(pan + 24);
                arrangeCursor(CurrentTab->currentBuffer);
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            } else {
                if(dy <= 0) {
                    _t113 = l->prev;
                } else {
                    _t113 = l->next;
                }
                l = _t113;
                if(l == 0) {
                } else {
                    if(d > 0) {
                        _t114 = 0;
                    } else {
                        _t114 = l->len - 1;
                    }
                    x = _t114;
                    y = l->linenumber;
                    continue;
                }
                goto L30;
            }
L31:
            i = i + 1;
            goto L32;
        }
    }
    goto L35;
L40:
    return;
L39:
    return;
L38:
    return;
}

nextY(int d)
{// addr = 0x08053BD2  --  defined in 'main.c' at line 3787
    HmarkerList* hl;   // _cfa_fffffff0
    Anchor* an;         // _cfa_ffffffec
    Anchor* pan;        // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int x;                                 // _cfa_ffffffe0
    int y;                                 // _cfa_ffffffdc
    int n;                                 // _cfa_ffffffd8
    int hseq;                              // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t116;                      // _t116
    signed int _t130;                      // _t130

    hl = CurrentTab->currentBuffer->hmarklist;
    n = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(hl == 0) {
        goto L25;
    }
    if(hl->nmark == 0) {
        goto L26;
    }
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(an == 0) {
        an = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    x = CurrentTab->currentBuffer->pos;
    y = CurrentTab->currentBuffer->currentLine->linenumber + d;
    pan = 0;
    hseq = -1;
    i = 0;
    while(i < n) {
        if(an != 0) {
            _t130 = an->hseq;
            _t116 = _t130 >> 31;
            hseq = _t130 ^ _t116;
            hseq = hseq - _t116;
        }
        an = 0;
        while(y < 0 && CurrentTab->currentBuffer->lastLine->linenumber >= y) {
            an = retrieveAnchor(CurrentTab->currentBuffer->href, y, x);
            if(an == 0) {
                an = retrieveAnchor(CurrentTab->currentBuffer->formitem, y, x);
            }
            if(an == 0 || (an->hseq ^ an->hseq >> 31) - (an->hseq >> 31) == hseq) {
                y = y + d;
                continue;
            }
            pan = an;
            break;
        }
        if(an == 0) {
            goto L22;
        }
        i = i + 1;
        continue;
L22:
        if(pan == 0) {
            goto L27;
        }
        gotoLine(CurrentTab->currentBuffer,  *(pan + 20));
        arrangeLine(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    goto L22;
L27:
    return;
L26:
    return;
L25:
    return;
}

nextL()
{// addr = 0x08053DA5  --  defined in 'main.c' at line 3832
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    nextX(-1, 0);
    return;
}

nextLU()
{// addr = 0x08053DC1  --  defined in 'main.c' at line 3838
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    nextX(-1, -1);
    return;
}

nextR()
{// addr = 0x08053DDD  --  defined in 'main.c' at line 3844
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    nextX(1, 0);
    return;
}

nextRD()
{// addr = 0x08053DF9  --  defined in 'main.c' at line 3850
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    nextX(1, 1);
    return;
}

nextD()
{// addr = 0x08053E15  --  defined in 'main.c' at line 3856
    _unknown_ __ebp;                       // r6

    nextY(1);
    return;
}

nextU()
{// addr = 0x08053E29  --  defined in 'main.c' at line 3862
    _unknown_ __ebp;                       // r6

    nextY(-1);
    return;
}

nextBf()
{// addr = 0x08053E3D  --  defined in 'main.c' at line 3868
    Buffer* buf;        // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16

    i = 0;
    while() {
    }
}

prevBf()
{// addr = 0x08053EBF  --  defined in 'main.c' at line 3886
    Buffer* buf;        // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15

    i = 0;
    while() {
    }
}

int checkBackBuffer(Buffer* buf)
{// addr = 0x08053F30  --  defined in 'main.c' at line 3904
    Buffer* fbuf;       // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31

    fbuf = buf->linkBuffer[1];
    if(fbuf == 0) {
L8:
        if(buf->nextBuffer == 0) {
            return 0;
        }
        goto L9;
    }
    if(fbuf->frameQ == 0) {
        if((RenderFrame & 0xff) == 0 || buf->nextBuffer != fbuf) {
        } else {
            if(fbuf->nextBuffer == 0) {
                return 0;
            }
            return 1;
        }
        goto L8;
    }
    return 1;
L9:
    return 1;
}

backBf()
{// addr = 0x08053F9F  --  defined in 'main.c' at line 3928
    Buffer* buf;        // _cfa_fffffff0
    struct frameset* fs;   // _cfa_ffffffec
    long int linenumber;                   // _cfa_ffffffe8
    long int top;                          // _cfa_ffffffe4
    int pos;                               // _cfa_ffffffe0
    int currentColumn;                     // _cfa_ffffffdc
    AnchorList* formitem;   // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t130;                       // _t130

    buf = CurrentTab->currentBuffer->linkBuffer[1];
    if(checkBackBuffer(CurrentTab->currentBuffer) == 0) {
        if(close_tab_back != 0 && nTab > 0) {
            deleteTab(CurrentTab);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        disp_message("Can't back...", 1);
        return;
    }
    delBuffer(CurrentTab->currentBuffer);
    if(buf != 0) {
        if(buf->frameQ == 0) {
            if((RenderFrame & 0xff) != 0 && CurrentTab->currentBuffer == buf) {
                delBuffer(CurrentTab->currentBuffer);
            }
        } else {
            linenumber = buf->frameQ->linenumber;
            top = buf->frameQ->top_linenumber;
            pos = buf->frameQ->pos;
            currentColumn = buf->frameQ->currentColumn;
            formitem = buf->frameQ->formitem;
            fs = popFrameTree( &(buf->frameQ));
            deleteFrameSet(buf->frameset);
            buf->frameset = fs;
            if(CurrentTab->currentBuffer == buf) {
                rFrame();
                CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->firstLine, top - 1, 0);
                gotoLine(CurrentTab->currentBuffer, linenumber);
                CurrentTab->currentBuffer->pos = pos;
                CurrentTab->currentBuffer->currentColumn = currentColumn;
                arrangeCursor(CurrentTab->currentBuffer);
                formResetBuffer(CurrentTab->currentBuffer, formitem);
            }
        }
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

deletePrevBuf()
{// addr = 0x080541B8  --  defined in 'main.c' at line 3977
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    buf = CurrentTab->currentBuffer->nextBuffer;
    if(buf != 0) {
        delBuffer(buf);
        return;
    }
    return;
}

cmd_loadURL(char* url, ParsedURL* current, char* referer, FormList* request)
{// addr = 0x080541DF  --  defined in 'main.c' at line 3986
    Buffer* buf;        // _cfa_fffffff0
    Str to;                // _cfa_ffffffec
    char* emsg;                            // _cfa_ffffffe8
    FormList* _v44;   // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    struct _Str _v56;     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t74;                        // _t74
    _unknown_ _t78;                        // _t78

    if(strncasecmp(url, "mailto:", 7) != 0) {
L4:
        refresh();
        _v44 = request;
        _v56.area_size = 0;
        buf = loadGeneralFile(url, current, referer);
        if(buf != 0) {
            if(buf != 1) {
                pushBuffer(buf);
                if((RenderFrame & 0xff) != 0 && CurrentTab->currentBuffer->frameset != 0) {
                    rFrame();
                }
            }
        } else {
            _v56 =  *(wc_Str_conv(Strnew_charp(url), SystemCharset, InnerCharset));
            emsg =  *(Sprintf("Can't load %s"));
            disp_err_message(emsg, 0);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        if(non_null(Mailer) == 0 || strchr(url, 63) != 0) {
            goto L4;
        } else {
            to = Strnew_charp( &(url[7]));
            fmTerm();
            system( *(myExtCommand(Mailer, shell_quote(file_unquote(to->ptr)), 0)));
            fmInit();
            displayBuffer(CurrentTab->currentBuffer, 1);
            pushHashHist(URLHist, url);
            return;
        }
    }
}

goURL0(char* prompt, int relative)
{// addr = 0x0805439A  --  defined in 'main.c' at line 4042
    char* url;                             // _cfa_fffffff0
    char* referer;                         // _cfa_ffffffec
    ParsedURL* current;   // _cfa_ffffffe8
    Buffer* cur_buf;    // _cfa_ffffffe4
    Hist* hist;           // _cfa_ffffffe0
    Anchor* a;          // _cfa_ffffffdc
    char* c_url;                           // _cfa_ffffffd8
    char* a_url;                           // _cfa_ffffffd4
    ParsedURL p_url;   // _cfa_ffffffac
    _unknown_ _v108;                       // _cfa_ffffff94
    _unknown_ _v112;                       // _cfa_ffffff90
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t125;                       // _t125
    _unknown_ _t136;                       // _t136
    _unknown_ _t190;                       // _t190
    _unknown_ _t204;                       // _t204

    cur_buf = CurrentTab->currentBuffer;
    url = searchKeyData();
    if(url != 0) {
L16:
        if(url == 0) {
L22:
            if(url == 0 || ( *url & 0xff) == 0) {
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            if(( *url & 0xff) != 35) {
                if(relative == 0) {
                    current = 0;
                    referer = 0;
                } else {
                    current = baseURL(CurrentTab->currentBuffer);
                    referer =  *(parsedURL2Str(CurrentTab->currentBuffer + 132));
                }
                parseURL2(url,  &(p_url.scheme), current);
                pushHashHist(URLHist,  *(parsedURL2Str( &(p_url.scheme))));
                cmd_loadURL(url, current, referer, 0);
                if(CurrentTab->currentBuffer == cur_buf) {
                    return;
                } else {
                    pushHashHist(URLHist,  *(parsedURL2Str(CurrentTab->currentBuffer + 132)));
                    return;
                }
            }
            gotoLabel( &(url[1]));
            return;
        }
        goto L17;
    }
    hist = copyHist(URLHist);
    current = baseURL(CurrentTab->currentBuffer);
    if(current != 0) {
        c_url =  *(parsedURL2Str(current));
        if(DefaultURLString != 1) {
            pushHist(hist, c_url);
        } else {
            url = c_url;
            if(DecodeURL != 0) {
                url = url_unquote_conv(url, 0);
            }
        }
    }
    a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(a != 0) {
        parseURL2(a->url,  &(p_url.scheme), current);
        a_url =  *(parsedURL2Str( &(p_url.scheme)));
        if(DefaultURLString != 2) {
            pushHist(hist, a_url);
        } else {
            url = a_url;
            if(DecodeURL != 0) {
                url = url_unquote_conv(url,  *(CurrentTab->currentBuffer + 208));
            }
        }
    }
    url = inputLineHistSearch(prompt, url, 256, hist, 0);
    if(url == 0) {
    } else {
        while(( *url & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *url & 0xff)) & 2) != 0) {
            url =  &(url[1]);
        }
    }
L17:
    if(relative != 0 || ( *url & 0xff) == 35) {
        if( *(CurrentTab->currentBuffer + 208) == 0) {
            goto L21;
        }
        url =  *(wc_Str_conv_strict(Strnew_charp(url), InnerCharset,  *(CurrentTab->currentBuffer + 208)));
        goto L22;
    }
L21:
    url =  *(wc_Str_conv_strict(Strnew_charp(url), InnerCharset, SystemCharset));
    goto L22;
}

goURL()
{// addr = 0x080546D7  --  defined in 'main.c' at line 4113
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    goURL0("Goto URL: ", 0);
    return;
}

gorURL()
{// addr = 0x080546F3  --  defined in 'main.c' at line 4118
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    goURL0("Goto relative URL: ", 1);
    return;
}

cmd_loadBuffer(Buffer* buf, int prop, int linkid)
{// addr = 0x0805470F  --  defined in 'main.c' at line 4124
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(buf != 0) {
        if(buf != 1) {
            buf->bufferprop = (buf->bufferprop & 65535 | prop | 8) & 65535;
            asm("cwde ");
            if((buf->bufferprop & 0x10) == 0) {
                copyParsedURL(buf + 132, CurrentTab->currentBuffer + 132);
            }
            if(linkid != 255) {
                 *(buf + 12 + ( *((intOrPtr*)( &REV_LB + linkid * 4)) + 4) * 4) = CurrentTab->currentBuffer;
                 *(CurrentTab->currentBuffer + 12 + (linkid + 4) * 4) = buf;
            }
            pushBuffer(buf);
        }
    } else {
        disp_err_message("Can't load string", 0);
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

ldBmark()
{// addr = 0x080547E1  --  defined in 'main.c' at line 4143
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    cmd_loadURL(BookmarkFile, 0, -1, 0);
    return;
}

adBmark()
{// addr = 0x0805480E  --  defined in 'main.c' at line 4150
    Str tmp;               // _cfa_ffffffe0
    FormList* request;   // _cfa_ffffffdc
    struct _Str _v48;     // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc
    struct _Str _v76;     // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    char* _t33;                            // _t33
    struct _Str* _t45;    // _t45
    struct _Str* _t48;    // _t48
    struct _Str* _t50;    // _t50

    _t33 = wc_ces_to_charset(BookmarkCharset);
    _v48.ptr =  *(Str_form_quote(wc_Str_conv_strict(Strnew_charp(CurrentTab->currentBuffer->buffername), InnerCharset, BookmarkCharset)));
    _t45 = Str_form_quote(parsedURL2Str(CurrentTab->currentBuffer + 132));
    _t48 = Str_form_quote(Strnew_charp(BookmarkFile));
    _t50 = Str_form_quote(localCookie());
    _v76.length = _t33;
    _v76 = _v48;
    _v80 = _t45->ptr;
    _v84 = _t48->ptr;
    _v88 = _t50->ptr;
    tmp = Sprintf("mode=panel&cookie=%s&bmark=%s&url=%s&title=%s&charset=%s");
    request = newFormList(0, "post", 0, 0, 0, 0, 0);
    request->body = tmp->ptr;
    request->length = tmp->length;
    cmd_loadURL("file:///$LIB/w3mbookmark", 0, -1, request);
    return;
}

ldOpt()
{// addr = 0x08054950  --  defined in 'main.c' at line 4180
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    cmd_loadBuffer(load_option_panel(), 16, -1);
    return;
}

setOpt()
{// addr = 0x08054975  --  defined in 'main.c' at line 4186
    char* opt;                             // _cfa_fffffff0
    char* v;                               // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    intOrPtr _t52;                         // _t52

    CurrentKeyData = 0;
    opt = searchKeyData();
    if(opt == 0 || ( *opt & 0xff) == 0 || strchr(opt, 61) == 0) {
        if(opt != 0 && ( *opt & 0xff) != 0) {
            _v52 = _t52;
            _v56 = opt;
            opt =  *(Sprintf("%s=%s"));
        }
        opt = inputLineHistSearch("Set option: ", opt, 16, TextHist, 0);
        if(opt == 0 || ( *opt & 0xff) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
    if(set_param_option(opt) != 0) {
        sync_with_option();
    }
    displayBuffer(CurrentTab->currentBuffer, 4);
    return;
}

msgs()
{// addr = 0x08054A89  --  defined in 'main.c' at line 4209
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    cmd_loadBuffer(message_list_panel(), 16, -1);
    return;
}

pginfo()
{// addr = 0x08054AAE  --  defined in 'main.c' at line 4215
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    buf = CurrentTab->currentBuffer->linkBuffer[3];
    if(buf == 0) {
        buf = CurrentTab->currentBuffer->linkBuffer[2];
        if(buf != 0) {
            delBuffer(buf);
        }
        buf = page_info_panel(CurrentTab->currentBuffer);
        cmd_loadBuffer(buf, 0, 2);
        return;
    }
    CurrentTab->currentBuffer = buf;
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

follow_map(struct parsed_tagarg* arg)
{// addr = 0x08054B3C  --  defined in 'main.c' at line 4231
    char* name;                            // _cfa_fffffff0
    Anchor* an;         // _cfa_ffffffec
    MapArea* a;        // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    int y;                                 // _cfa_ffffffe0
    Buffer* buf;        // _cfa_ffffffdc
    ParsedURL p_url;   // _cfa_ffffffb4
    _unknown_ _v92;                        // _cfa_ffffffa4
    _unknown_ _v96;                        // _cfa_ffffffa0
    _unknown_ _v100;                       // _cfa_ffffff9c
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t112;                       // _t112
    struct _Str* _t117;   // _t117
    struct _Str* _t132;   // _t132
    _unknown_ _t139;                       // _t139

    name = tag_get_value(arg, "link");
    an = retrieveCurrentImg(CurrentTab->currentBuffer);
    asm("cwde ");
    x = (CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    y = (CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535);
    a = follow_map_menu(CurrentTab->currentBuffer, name, an, x, y);
    if(a == 0) {
L15:
        return;
    }
    if(a->url == 0) {
        goto L16;
    }
    if((a & 0xff) == 0) {
        goto L17;
    }
    if((a & 0xff) == 35) {
        gotoLabel( &(a->url[1]));
        return;
    }
    parseURL2(a->url,  &(p_url.scheme), baseURL(CurrentTab->currentBuffer));
    pushHashHist(URLHist,  *(parsedURL2Str( &(p_url.scheme))));
    if(check_target == 0 || open_tab_blank == 0 || a->target == 0 || strcasecmp(a->target, "_new") != 0 && strcasecmp(a->target, "_blank") != 0) {
        _t117 = parsedURL2Str(CurrentTab->currentBuffer + 132);
        cmd_loadURL(a->url, baseURL(CurrentTab->currentBuffer),  *_t117, 0);
        return;
    } else {
        _newT();
        buf = CurrentTab->currentBuffer;
        _t132 = parsedURL2Str(CurrentTab->currentBuffer + 132);
        cmd_loadURL(a->url, baseURL(CurrentTab->currentBuffer),  *_t132, 0);
        if(CurrentTab->currentBuffer == buf) {
            deleteTab(CurrentTab);
        } else {
            delBuffer(buf);
        }
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    goto L15;
L17:
    return;
L16:
    return;
}

linkMn()
{// addr = 0x08054DB5  --  defined in 'main.c' at line 4283
    LinkList* l;      // _cfa_fffffff0
    ParsedURL p_url;   // _cfa_ffffffc8
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37
    struct _Str* _t41;    // _t41

    l = link_menu(CurrentTab->currentBuffer);
    if(l == 0) {
L5:
        return;
    }
    if(l->url == 0) {
    } else {
        if((l & 0xff) != 35) {
            parseURL2(l->url,  &(p_url.scheme), baseURL(CurrentTab->currentBuffer));
            pushHashHist(URLHist,  *(parsedURL2Str( &(p_url.scheme))));
            _t41 = parsedURL2Str(CurrentTab->currentBuffer + 132);
            cmd_loadURL(l->url, baseURL(CurrentTab->currentBuffer),  *_t41, 0);
            return;
        }
        gotoLabel( &(l->url[1]));
        return;
        goto L5;
    }
    goto L6;
L7:
    return;
L6:
    goto L7;
}

anchorMn(_None* menu_func, int go)
{// addr = 0x08054E9D  --  defined in 'main.c' at line 4301
    Anchor* a;          // _cfa_fffffff0
    BufferPoint* po;   // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    Anchor* _t36;       // _t36

    if(CurrentTab->currentBuffer->href == 0) {
        return;
    }
    if(CurrentTab->currentBuffer->hmarklist == 0) {
        goto L7;
    }
     *__esp = CurrentTab->currentBuffer;
    _t36 = menu_func;
    _t36->url();
    a = _t36;
    if(a == 0) {
        goto L8;
    }
    if(a->hseq < 0) {
        po = CurrentTab->currentBuffer->hmarklist->marks + (a->hseq + a->hseq + _t58 << 2);
        gotoLine(CurrentTab->currentBuffer, po->line);
        CurrentTab->currentBuffer->pos = po->pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        if(go == 0) {
        } else {
            goto L5;
        }
        goto L10;
L5:
        followA();
        return;
    }
L10:
    return;
L8:
    return;
L7:
    return;
}

accessKey()
{// addr = 0x08054F83  --  defined in 'main.c' at line 4321
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    anchorMn(accesskey_menu, 1);
    return;
}

listMn()
{// addr = 0x08054F9F  --  defined in 'main.c' at line 4327
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    anchorMn(list_menu, 1);
    return;
}

movlistMn()
{// addr = 0x08054FBB  --  defined in 'main.c' at line 4332
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    anchorMn(list_menu, 0);
    return;
}

linkLst()
{// addr = 0x08054FD7  --  defined in 'main.c' at line 4340
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    buf = link_list_panel(CurrentTab->currentBuffer);
    if(buf != 0) {
         *((intOrPtr*)(buf + 208)) =  *((intOrPtr*)(CurrentTab->currentBuffer + 208));
        cmd_loadBuffer(buf, 0, -1);
        return;
    }
    return;
}

cooLst()
{// addr = 0x0805502A  --  defined in 'main.c' at line 4355
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6

    buf = cookie_list_panel();
    if(buf != 0) {
        cmd_loadBuffer(buf, 16, -1);
        return;
    }
    return;
}

ldHist()
{// addr = 0x0805505B  --  defined in 'main.c' at line 4367
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    cmd_loadBuffer(historyBuffer(URLHist), 16, -1);
    return;
}

svA()
{// addr = 0x08055088  --  defined in 'main.c' at line 4374
    _unknown_ __ebp;                       // r6

    CurrentKeyData = 0;
    do_download = 1;
    followA();
    do_download = 0;
    return;
}

svI()
{// addr = 0x080550B3  --  defined in 'main.c' at line 4383
    _unknown_ __ebp;                       // r6

    CurrentKeyData = 0;
    do_download = 1;
    followI();
    do_download = 0;
    return;
}

svBuf()
{// addr = 0x080550DE  --  defined in 'main.c' at line 4392
    char* qfile;                           // _cfa_fffffff0
    char* file;                            // _cfa_ffffffec
    FILE* f;              // _cfa_ffffffe8
    int is_pipe;                           // _cfa_ffffffe4
    char* emsg;                            // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    struct _Str _v72;     // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t64;                        // _t64
    char* _t72;                            // _t72
    _unknown_ _t87;                        // _t87
    _unknown_ _t91;                        // _t91
    unsigned int _t114;                    // _t114
    unsigned int _t119;                    // _t119

    qfile = 0;
    CurrentKeyData = 0;
    file = searchKeyData();
    if(file == 0 || ( *file & 0xff) == 0) {
        qfile = inputLineHistSearch("Save buffer to: ", 0, 128, SaveHist, 0);
        if(qfile == 0 || ( *qfile & 0xff) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            goto L5;
        }
    }
L5:
    _t119 = SystemCharset;
    _t114 = InnerCharset;
    if(qfile == 0) {
        _t72 = file;
    } else {
        _t72 = qfile;
    }
    file =  *(wc_Str_conv_strict(Strnew_charp(_t72), _t114, _t119));
    if(( *file & 0xff) != 124) {
        if(qfile != 0) {
            file =  *(unescape_spaces(Strnew_charp(qfile)));
            file =  *(wc_Str_conv_strict(Strnew_charp(file), InnerCharset, SystemCharset));
        }
        file = expandPath(file);
        if(checkOverWrite(file) >= 0) {
            f = fopen(file, "w");
            is_pipe = 0;
        } else {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
L15:
        if(f != 0) {
            saveBuffer(CurrentTab->currentBuffer, f, 1);
            if(is_pipe == 0) {
                fclose(f);
            } else {
                pclose(f);
            }
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        _v72 =  *(wc_Str_conv(Strnew_charp(file), SystemCharset, InnerCharset));
        emsg =  *(Sprintf("Can't open %s"));
        disp_err_message(emsg, 1);
        return;
    }
    is_pipe = 1;
    f = popen( &(file[1]), "w");
    goto L15;
}

svSrc()
{// addr = 0x08055329  --  defined in 'main.c' at line 4441
    char* file;                            // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37

    if(CurrentTab->currentBuffer->sourcefile != 0) {
        CurrentKeyData = 0;
        PermitSaveToPipe = 1;
        if(CurrentTab->currentBuffer->real_scheme != 4) {
            file = guess_save_name(CurrentTab->currentBuffer,  *(CurrentTab->currentBuffer + 152));
        } else {
            file =  *(wc_Str_conv(Strnew_charp(guess_save_name(0,  *(CurrentTab->currentBuffer + 156))), SystemCharset, InnerCharset));
        }
        _doFileCopy(CurrentTab->currentBuffer->sourcefile, file, 0);
        PermitSaveToPipe = 0;
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    return;
}

_peekURL(int only_img)
{// addr = 0x08055427  --  defined in 'main.c' at line 4461
    Anchor* a;          // _cfa_fffffff0
    Lineprop* pp;     // _cfa_ffffffec
    ParsedURL pu;    // _cfa_ffffffc4
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    Anchor* _t47;       // _t47
    void* _t54;           // _t54
    _unknown_ _t58;                        // _t58
    Anchor* _t94;       // _t94

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(CurrentKey != prev_key || s.15239 == 0) {
        offset = 0;
        s.15239 = 0;
        if(only_img != 0) {
            _t47 = 0;
        } else {
            _t47 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
        }
        a = _t47;
        if(a != 0) {
L18:
            if(s.15239 == 0) {
                parseURL2(a->url,  &(pu.scheme), baseURL(CurrentTab->currentBuffer));
                s.15239 = parsedURL2Str( &(pu.scheme));
            }
            if(DecodeURL != 0) {
                s.15239 = Strnew_charp(url_unquote_conv( *s.15239,  *(CurrentTab->currentBuffer + 208)));
            }
            s.15239 = checkType(s.15239,  &pp, 0);
            _t54 = s.15239->length + s.15239->length;
             *__esp = _t54;
            GC_malloc_atomic();
            p.15240 = _t54;
            bcopy(pp, p.15240, s.15239->length + s.15239->length);
            goto L24;
        } else {
            if(only_img != 0) {
                _t94 = 0;
            } else {
                _t94 = retrieveCurrentForm(CurrentTab->currentBuffer);
            }
            a = _t94;
            if(a != 0) {
                s.15239 = Strnew_charp(form2str(a->url));
            } else {
                a = retrieveCurrentImg(CurrentTab->currentBuffer);
                if(a != 0) {
                    goto L18;
                }
                return;
            }
            goto L18;
        }
    } else {
        if(s.15239->length - offset < COLS) {
            if(s.15239->length <= offset) {
                offset = 0;
            }
        } else {
            offset = offset + 1;
        }
L24:
        n.15243 = searchKeyNum();
        if(n.15243 > 1) {
            if(s.15239->length > (COLS - 1) * (n.15243 - 1)) {
                offset = (COLS - 1) * (n.15243 - 1);
            }
        }
        while(s.15239->length > offset && ( *(p.15240 + offset + offset) & 0x400) != 0) {
            offset = offset + 1;
        }
        disp_message_nomouse( *s.15239 + offset, 1);
        return;
    }
}

peekURL()
{// addr = 0x080556C8  --  defined in 'main.c' at line 4521
    _unknown_ __ebp;                       // r6

    _peekURL(0);
    return;
}

peekIMG()
{// addr = 0x080556DC  --  defined in 'main.c' at line 4527
    _unknown_ __ebp;                       // r6

    _peekURL(1);
    return;
}

Str currentURL()
{// addr = 0x080556F0  --  defined in 'main.c' at line 4534
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 8) == 0) {
        return parsedURL2Str(CurrentTab->currentBuffer + 132);
    }
    return Strnew_size(0);
}

curURL()
{// addr = 0x0805572F  --  defined in 'main.c' at line 4541
    Lineprop* pp;     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    void* _t34;           // _t34
    _unknown_ _t38;                        // _t38

    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 8) != 0) {
        return;
    } else {
        if(CurrentKey != prev_key || s.15396 == 0) {
            offset.15399 = 0;
            s.15396 = currentURL();
            if(DecodeURL != 0) {
                s.15396 = Strnew_charp(url_unquote_conv( *s.15396, 0));
            }
            s.15396 = checkType(s.15396,  &pp, 0);
            _t34 = s.15396->length + s.15396->length;
             *__esp = _t34;
            GC_malloc_atomic();
            p.15397 = _t34;
            bcopy(pp, p.15397, s.15396->length + s.15396->length);
        } else {
            if(s.15396->length - offset.15399 < COLS) {
                if(s.15396->length <= offset.15399) {
                    offset.15399 = 0;
                }
            } else {
                offset.15399 = offset.15399 + 1;
            }
        }
        n.15400 = searchKeyNum();
        if(n.15400 > 1) {
            if(s.15396->length > (COLS - 1) * (n.15400 - 1)) {
                offset.15399 = (COLS - 1) * (n.15400 - 1);
            }
        }
        while(s.15396->length > offset.15399 && ( *(p.15397 + offset.15399 + offset.15399) & 0x400) != 0) {
            offset.15399 = offset.15399 + 1;
        }
        disp_message_nomouse( *s.15396 + offset.15399, 1);
        return;
    }
}

vwSrc()
{// addr = 0x08055906  --  defined in 'main.c' at line 4580
    wc_bool old_fix_width_conv;   // _cfa_fffffff3
    Buffer* buf;        // _cfa_ffffffec
    wc_ces old_charset;   // _cfa_ffffffe8
    FILE* f;              // _cfa_ffffffe4
    Str tmpf;              // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t182;                             // _t182
    _unknown_ _t183;                       // _t183
    Buffer* _t211;      // _t211
    unsigned int _t282;                    // _t282
    _unknown_ _t288;                       // _t288
    int _t305;                             // _t305
    _unknown_ _t306;                       // _t306
    Buffer* _t311;      // _t311

    if(CurrentTab->currentBuffer->type == 0) {
        return;
    }
    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 2) != 0) {
        goto L30;
    }
    buf =  *(CurrentTab->currentBuffer + 44);
    if(buf != 0) {
L4:
        CurrentTab->currentBuffer = buf;
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    buf =  *(CurrentTab->currentBuffer + 44);
    if(buf == 0) {
        if(CurrentTab->currentBuffer->sourcefile != 0) {
L13:
            _t305 = COLS;
            if(showLineNum == 0) {
                _t182 = 1;
            } else {
                _t182 = 6;
            }
            _t183 = _t305 - _t182;
            _t184 = _t183 >= 0 ? 0 : _t183;
            buf = newBuffer(_t183 >= 0 ? 0 : _t183);
            if(is_html_type(CurrentTab->currentBuffer->type) == 0) {
                if(strcasecmp(CurrentTab->currentBuffer->type, "text/plain") != 0) {
L34:
                    return;
                }
            } else {
                buf->type = "text/plain";
                if(CurrentTab->currentBuffer->real_type == 0 || is_html_type(CurrentTab->currentBuffer->real_type) == 0) {
                    buf->real_type = CurrentTab->currentBuffer->real_type;
                } else {
                    buf->real_type = "text/plain";
                }
                _v56 = CurrentTab->currentBuffer->buffername;
                buf->buffername =  *(Sprintf("source of %s"));
                 *(buf + 44) = CurrentTab->currentBuffer;
                 *(CurrentTab->currentBuffer + 44) = buf;
L28:
                _t311 = CurrentTab->currentBuffer;
                _t211 = buf;
                 *((intOrPtr*)(_t211 + 132)) =  *((intOrPtr*)(_t311 + 132));
                 *((intOrPtr*)(_t211 + 136)) =  *((intOrPtr*)(_t311 + 136));
                 *((intOrPtr*)(_t211 + 140)) =  *((intOrPtr*)(_t311 + 140));
                 *((intOrPtr*)(_t211 + 144)) =  *((intOrPtr*)(_t311 + 144));
                 *((intOrPtr*)(_t211 + 148)) =  *((intOrPtr*)(_t311 + 148));
                 *((intOrPtr*)(_t211 + 152)) =  *((intOrPtr*)(_t311 + 152));
                 *((intOrPtr*)(_t211 + 156)) =  *((intOrPtr*)(_t311 + 156));
                 *((intOrPtr*)(_t211 + 160)) =  *((intOrPtr*)(_t311 + 160));
                 *((intOrPtr*)(_t211 + 164)) =  *((intOrPtr*)(_t311 + 164));
                 *((intOrPtr*)(_t211 + 168)) =  *((intOrPtr*)(_t311 + 168));
                buf->real_scheme = CurrentTab->currentBuffer->real_scheme;
                buf->filename = CurrentTab->currentBuffer->filename;
                buf->sourcefile = CurrentTab->currentBuffer->sourcefile;
                buf->header_source = CurrentTab->currentBuffer->header_source;
                buf->search_header = CurrentTab->currentBuffer->search_header & 0xff;
                 *(buf + 208) =  *(CurrentTab->currentBuffer + 208);
                buf->clone = CurrentTab->currentBuffer->clone;
                 *(buf->clone) =  &(buf->filename);
                buf->need_reshape = 1;
                reshapeBuffer(buf);
                pushBuffer(buf);
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            buf->type = "text/html";
            if(CurrentTab->currentBuffer->real_type == 0 || strcasecmp(CurrentTab->currentBuffer->real_type, "text/plain") != 0) {
                buf->real_type = CurrentTab->currentBuffer->real_type;
            } else {
                buf->real_type = "text/html";
            }
            _v56 = CurrentTab->currentBuffer->buffername;
            buf->buffername =  *(Sprintf("HTML view of %s"));
             *(buf + 44) = CurrentTab->currentBuffer;
             *(CurrentTab->currentBuffer + 44) = buf;
            goto L28;
        }
        goto L6;
    }
    goto L4;
L6:
    if( *((intOrPtr*)(CurrentTab->currentBuffer + 92)) == 0) {
        goto L31;
    }
    if(strcasecmp(CurrentTab->currentBuffer->type, "text/plain") != 0) {
        goto L32;
    }
    tmpf = tmpfname(1, 0);
    f = fopen(tmpf->ptr, "w");
    if(f == 0) {
        goto L33;
    }
    old_charset = DisplayCharset;
    old_fix_width_conv =  *135119013 & 0xff;
    if( *(CurrentTab->currentBuffer + 208) == 256) {
        _t282 = 0;
    } else {
        _t282 =  *(CurrentTab->currentBuffer + 208);
    }
    DisplayCharset = _t282;
     *135119013 = 0;
    saveBufferBody(CurrentTab->currentBuffer, f, 1);
    DisplayCharset = old_charset;
     *135119013 = old_fix_width_conv & 0xff;
    fclose(f);
    CurrentTab->currentBuffer->sourcefile = tmpf->ptr;
    goto L13;
L33:
    return;
L32:
    return;
L31:
    return;
L30:
    return;
}

reload()
{// addr = 0x08055DB6  --  defined in 'main.c' at line 4671
    Buffer* buf;        // _cfa_fffffff0
    Buffer* fbuf;       // _cfa_ffffffec
    wc_ces old_charset;   // _cfa_ffffffe8
    Str url;               // _cfa_ffffffe4
    FormList* request;   // _cfa_ffffffe0
    int multipart;                         // _cfa_ffffffdc
    Str query;             // _cfa_ffffffd8
    struct stat st;       // _cfa_ffffff80
    signed char _v144;                     // _cfa_ffffff70
    short int _v168;                       // _cfa_ffffff58
    signed int _v298;                      // _cfa_fffffed6
    signed int _v300;                      // _cfa_fffffed4
    signed int _v302;                      // _cfa_fffffed2
    signed int _v304;                      // _cfa_fffffed0
    char* _v336;                           // _cfa_fffffeb0
    Buffer sbuf;        // _cfa_fffffe7c
    FormList* _v412;   // _cfa_fffffe64
    int _v416;                             // _cfa_fffffe60
    _unknown_ _v420;                       // _cfa_fffffe5c
    _unknown_ _v424;                       // _cfa_fffffe58
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    fbuf = 0;
    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 8) != 0) {
        if(strcmp(CurrentTab->currentBuffer->buffername, "Download List Panel") == 0) {
            ldDL();
            return;
        }
        disp_err_message("Can't reload...", 1);
        return;
    }
    if( *(CurrentTab->currentBuffer + 132) != 4) {
L7:
        copyBuffer( &(sbuf.filename), CurrentTab->currentBuffer);
        asm("cwde ");
        if((CurrentTab->currentBuffer->bufferprop & 2) == 0) {
L22:
            if(CurrentTab->currentBuffer->frameset != 0) {
                fbuf = CurrentTab->currentBuffer->linkBuffer;
            }
            multipart = 0;
            if(CurrentTab->currentBuffer->form_submit == 0) {
                request = 0;
            } else {
                request =  *(CurrentTab->currentBuffer->form_submit + 64);
                if(request->method == 1 && request->enctype == 1) {
                    multipart = 1;
                    query_from_followform( &query, CurrentTab->currentBuffer->form_submit, multipart);
                    __stat(request->body,  &(st.st_dev));
                    request->length = st.st_size;
                }
            }
            url = parsedURL2Str(CurrentTab->currentBuffer + 132);
            message("Reloading...", 0, 0);
            refresh();
            old_charset = DocumentCharset;
            if( *(CurrentTab->currentBuffer + 208) != 256) {
                DocumentCharset =  *(CurrentTab->currentBuffer + 208);
            }
            SearchHeader = CurrentTab->currentBuffer->search_header & 0xff;
            DefaultType = CurrentTab->currentBuffer->real_type;
            _v412 = request;
            _v416 = 1;
            buf = loadGeneralFile(url->ptr, 0, -1);
            _t246 = old_charset;
            DocumentCharset = old_charset;
            SearchHeader = 0;
            DefaultType = 0;
            if(multipart != 0) {
                unlink(request->body);
            }
            if(buf != 0) {
                if(buf != 1) {
                    if(fbuf != 0) {
                        CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, fbuf);
                    }
                    repBuffer(CurrentTab->currentBuffer, buf);
                    if(buf->type == 0 || _v336 == 0) {
L47:
                        CurrentTab->currentBuffer->search_header = _v144 & 0xff;
                        CurrentTab->currentBuffer->form_submit = _v168;
                        if(CurrentTab->currentBuffer->firstLine != 0) {
L48:
                            CurrentTab->currentBuffer->rootX = _v304 & 0xffff;
                            CurrentTab->currentBuffer->rootY = _v302 & 0xffff;
                            CurrentTab->currentBuffer->COLS = _v300 & 0xffff;
                            CurrentTab->currentBuffer->LINES = _v298 & 0xffff;
                            restorePosition(CurrentTab->currentBuffer,  &(sbuf.filename));
                        }
                        displayBuffer(CurrentTab->currentBuffer, 1);
                        return;
                    } else {
                        if(strcasecmp(buf->type, "text/plain") != 0 || is_html_type(_v336) == 0) {
                            if(is_html_type(buf->type) == 0 || strcasecmp(_v336, "text/plain") != 0) {
                                goto L47;
                            } else {
                                goto L45;
                            }
                            goto L48;
                        }
L45:
                        vwSrc();
                        if(CurrentTab->currentBuffer != buf) {
                            CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
                        }
                        goto L47;
                    }
                }
            } else {
                disp_err_message("Can't reload...", 1);
                return;
            }
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    } else {
        if(strcmp( *(CurrentTab->currentBuffer + 152), "-") != 0) {
            goto L7;
        } else {
            disp_err_message("Can't reload stdin", 1);
            return;
        }
    }
    fbuf = CurrentTab->currentBuffer->linkBuffer[1];
    if(fbuf == 0) {
        goto L22;
    }
    if((fmInitialized & 0xff) != 0) {
        message("Rendering frame", 0, 0);
        refresh();
    }
    buf = renderFrame(fbuf, 1);
    if(buf != 0) {
        if(fbuf->linkBuffer != 0) {
            if(buf->sourcefile != 0 && fbuf->linkBuffer[0x2e] != 0 && strcmp(buf->sourcefile, fbuf->linkBuffer[0x2e]) == 0) {
                fbuf->linkBuffer[0x2e] = 0;
            }
            delBuffer(fbuf->linkBuffer);
        }
        fbuf->linkBuffer = buf;
        buf->linkBuffer[1] = fbuf;
        pushBuffer(buf);
        CurrentTab->currentBuffer = buf;
        if(CurrentTab->currentBuffer->firstLine != 0) {
            CurrentTab->currentBuffer->rootX = _v304 & 0xffff;
            CurrentTab->currentBuffer->rootY = _v302 & 0xffff;
            CurrentTab->currentBuffer->COLS = _v300 & 0xffff;
            CurrentTab->currentBuffer->LINES = _v298 & 0xffff;
            restorePosition(CurrentTab->currentBuffer,  &(sbuf.filename));
        }
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

reshape()
{// addr = 0x080563C2  --  defined in 'main.c' at line 4796
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    CurrentTab->currentBuffer->need_reshape = 1;
    reshapeBuffer(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

_docCSet(wc_ces charset)
{// addr = 0x08056401  --  defined in 'main.c' at line 4805
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 8) == 0) {
        if(CurrentTab->currentBuffer->sourcefile != 0) {
             *(CurrentTab->currentBuffer + 208) = charset;
            CurrentTab->currentBuffer->need_reshape = 1;
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        disp_message("Can't reload...", 0);
        return;
        goto L5;
    }
L5:
    return;
}

change_charset(struct parsed_tagarg* arg)
{// addr = 0x08056480  --  defined in 'main.c' at line 4819
    Buffer* buf;        // _cfa_fffffff0
    wc_ces charset;     // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    buf = CurrentTab->currentBuffer->linkBuffer[3];
    if(buf == 0) {
        return;
    }
    delBuffer(CurrentTab->currentBuffer);
    CurrentTab->currentBuffer = buf;
    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 8) != 0) {
    } else {
        charset =  *(CurrentTab->currentBuffer + 208);
        while(arg != 0) {
            if(strcmp(arg->arg, "charset") == 0) {
                charset = atoi(arg->value);
            }
            arg = arg->next;
        }
        _docCSet(charset);
        return;
    }
    goto L9;
L10:
    return;
L9:
    goto L10;
}

docCSet()
{// addr = 0x0805652C  --  defined in 'main.c' at line 4838
    char* cs;                              // _cfa_fffffff0
    wc_ces charset;     // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    cs = searchKeyData();
    if(cs == 0 || ( *cs & 0xff) == 0) {
        cs = inputLineHistSearch("Document charset: ", wc_ces_to_charset( *(CurrentTab->currentBuffer + 208)), 16, 0, 0);
    }
    charset = wc_guess_charset_short(cs, 0);
    if(charset != 0) {
        _docCSet(charset);
        return;
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

defCSet()
{// addr = 0x080565CE  --  defined in 'main.c' at line 4856
    char* cs;                              // _cfa_fffffff0
    wc_ces charset;     // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18

    cs = searchKeyData();
    if(cs == 0 || ( *cs & 0xff) == 0) {
        cs = inputLineHistSearch("Default document charset: ", wc_ces_to_charset(DocumentCharset), 16, 0, 0);
    }
    charset = wc_guess_charset_short(cs, 0);
    if(charset != 0) {
        DocumentCharset = charset;
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

chkURLBuffer(Buffer* buf)
{// addr = 0x08056662  --  defined in 'main.c' at line 4875
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23

    i = 0;
    while( *( &url_like_pat + i * 4) != 0) {
        reAnchor(buf,  *( &url_like_pat + i * 4));
        i = i + 1;
    }
    chkExternalURIBuffer(buf);
    buf->check_url = (buf->check_url & 255 | 1) & 255;
    return;
}

chkURL()
{// addr = 0x080566C1  --  defined in 'main.c' at line 4907
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    chkURLBuffer(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

chkWORD()
{// addr = 0x080566F1  --  defined in 'main.c' at line 4913
    char* p;                               // _cfa_fffffff0
    int spos;                              // _cfa_ffffffec
    int epos;                              // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    p = getCurWord(CurrentTab->currentBuffer,  &spos,  &epos, ":"'`<>()[]{}&|;*?$");
    if(p != 0) {
        reAnchorWord(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentLine, spos, epos);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    return;
}

chkNMIDBuffer(Buffer* buf)
{// addr = 0x08056775  --  defined in 'main.c' at line 4927
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22

    i = 0;
    while( *(i * 4 +  &url_like_pat.16013) != 0) {
        reAnchorNews(buf,  *(i * 4 +  &url_like_pat.16013));
        i = i + 1;
    }
    buf->check_url = (buf->check_url & 255 | 2) & 255;
    return;
}

chkNMID()
{// addr = 0x080567C9  --  defined in 'main.c' at line 4940
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    chkNMIDBuffer(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

rFrame()
{// addr = 0x080567F9  --  defined in 'main.c' at line 4948
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    buf = CurrentTab->currentBuffer->linkBuffer;
    if(buf == 0) {
        if(CurrentTab->currentBuffer->frameset != 0) {
            if((fmInitialized & 0xff) != 0) {
                message("Rendering frame", 0, 0);
                refresh();
            }
            buf = renderFrame(CurrentTab->currentBuffer, 0);
            if(buf != 0) {
                buf->linkBuffer[1] = CurrentTab->currentBuffer;
                CurrentTab->currentBuffer->linkBuffer = buf;
                pushBuffer(buf);
                if((fmInitialized & 0xff) == 0 || display_ok == 0) {
L13:
                    return;
                } else {
                    displayBuffer(CurrentTab->currentBuffer, 1);
                    return;
                }
            }
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        goto L3;
    }
    CurrentTab->currentBuffer = buf;
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
L3:
    buf = CurrentTab->currentBuffer->linkBuffer[1];
    if(buf == 0) {
        goto L13;
    }
    CurrentTab->currentBuffer = buf;
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

invoke_browser(char* url)
{// addr = 0x0805694C  --  defined in 'main.c' at line 4982
    Str cmd;               // _cfa_fffffff0
    char* browser;                         // _cfa_ffffffec
    int bg;                                // _cfa_ffffffe8
    int len;                               // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t62;                        // _t62
    int _t64;                              // _t64

    browser = 0;
    bg = 0;
    CurrentKeyData = 0;
    browser = searchKeyData();
    if(browser == 0 || ( *browser & 0xff) == 0) {
        _t64 = prec_num;
        if(_t64 == 2) {
            browser = ExtBrowser2;
        } else {
            if(_t64 > 2) {
                if(_t64 == 3) {
                    browser = ExtBrowser3;
                }
            } else {
                if(_t64 < 0) {
                    browser = ExtBrowser;
                }
            }
        }
        if(browser == 0 || ( *browser & 0xff) == 0) {
            browser = inputLineHistSearch("Browse command: ", 0, 16, 0, 0);
            if(browser != 0) {
                browser =  *(wc_Str_conv_strict(Strnew_charp(browser), InnerCharset, SystemCharset));
            }
        }
L18:
        if(browser == 0 || ( *browser & 0xff) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        len = strlen(browser);
        if(len > 1 && ( *(len - 1 + browser) & 0xff) == 38 && (browser[len - 2] & 0xff) != 92) {
            browser = allocStr(browser, len - 2);
            bg = 1;
        }
        cmd = myExtCommand(browser, shell_quote(url), 0);
        Strremovetrailingspaces(cmd);
        fmTerm();
        mySystem(cmd->ptr, bg);
        fmInit();
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    browser =  *(wc_Str_conv_strict(Strnew_charp(browser), InnerCharset, SystemCharset));
    goto L18;
}

extbrz()
{// addr = 0x08056B56  --  defined in 'main.c' at line 5030
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 8) == 0) {
        if( *(CurrentTab->currentBuffer + 132) != 4 || strcmp( *(CurrentTab->currentBuffer + 152), "-") != 0) {
            invoke_browser( *(parsedURL2Str(CurrentTab->currentBuffer + 132)));
            return;
        }
        disp_err_message("Can't browse stdin", 1);
        return;
    }
    disp_err_message("Can't browse...", 1);
    return;
}

linkbrz()
{// addr = 0x08056BF2  --  defined in 'main.c' at line 5047
    Anchor* a;          // _cfa_fffffff0
    ParsedURL pu;    // _cfa_ffffffc8
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(a == 0) {
    } else {
        goto L2;
    }
    goto L4;
L2:
    parseURL2(a->url,  &(pu.scheme), baseURL(CurrentTab->currentBuffer));
    invoke_browser( *(parsedURL2Str( &(pu.scheme))));
    return;
L4:
    return;
}

curlno()
{// addr = 0x08056C65  --  defined in 'main.c' at line 5062
    Line* l;              // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int cur;                               // _cfa_ffffffe8
    int all;                               // _cfa_ffffffe4
    int col;                               // _cfa_ffffffe0
    int len;                               // _cfa_ffffffdc
    signed short _v46;                     // _cfa_ffffffd2
    signed int _v48;                       // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    int _v72;                              // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    int _v80;                              // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6

    l = CurrentTab->currentBuffer->currentLine;
    cur = 0;
    all = 0;
    col = 0;
    len = 0;
    if(l == 0) {
L8:
        if(CurrentTab->currentBuffer->lastLine != 0) {
            all =  *(CurrentTab->currentBuffer->lastLine + 32);
        }
        if( *((intOrPtr*)(CurrentTab->currentBuffer + 92)) == 0) {
L13:
            asm("fild dword [ebp-0x14]");
            asm("fld qword [0x80c8e68]");
            asm("fmulp st1, st0");
            if(all == 0) {
                asm("fld1 ");
            } else {
                asm("fild dword [ebp-0x18]");
            }
            asm("fdivp st1, st0");
            asm("fld qword [0x80c8e70]");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp-0x2a]");
            _v48 = _v46 & 0xffff;
            asm("fldcw word [ebp-0x2c]");
            asm("fistp dword [ebp-0x30]");
            asm("fldcw word [ebp-0x2a]");
            _v72 = len;
            _v76 = col;
            _v80 = _v52;
            _v84 = all;
            _v88 = cur;
            tmp = Sprintf("line %d/%d (%d%%) col %d/%d");
L17:
            Strcat_charp(tmp, "  ");
            Strcat_charp(tmp, wc_ces_to_charset_desc( *(CurrentTab->currentBuffer + 208)));
            disp_message(tmp->ptr, 0);
            return;
        }
        asm("cwde ");
        if((CurrentTab->currentBuffer->bufferprop & 0x40) != 0) {
            goto L13;
        }
        _v80 = len;
        _v84 = col;
        _v88 = cur;
        tmp = Sprintf("line %d col %d/%d");
        goto L17;
    }
    cur = l->real_linenumber;
    asm("cwde ");
    col = l->bwidth + CurrentTab->currentBuffer->currentColumn + (CurrentTab->currentBuffer->cursorX & 65535) + 1;
    while(l->next != 0 && l->next->bpos != 0) {
        l = l->next;
    }
    if(l->width < 0) {
        l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
    }
    len = l->bwidth + l->width;
    goto L8;
}

dispI()
{// addr = 0x08056E77  --  defined in 'main.c' at line 5094
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(displayImage == 0) {
        initImage();
    }
    if(activeImage != 0) {
        displayImage = 1;
        CurrentTab->currentBuffer->image_flag = 2;
        CurrentTab->currentBuffer->need_reshape = 1;
        displayBuffer(CurrentTab->currentBuffer, 4);
        return;
    }
    return;
}

stopI()
{// addr = 0x08056ED9  --  defined in 'main.c' at line 5110
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(activeImage != 0) {
        CurrentTab->currentBuffer->image_flag = 1;
        displayBuffer(CurrentTab->currentBuffer, 4);
        return;
    }
    return;
}

int mouse_scroll_line()
{// addr = 0x08056F14  --  defined in 'main.c' at line 5126
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t19;                        // _t19

    if(relative_wheel_scroll == 0) {
        return fixed_wheel_scroll_count;
    }
    return ((relative_wheel_scroll_ratio * (LINES - 1) + 99) * 1374389535 >> 32 >> 5) - (relative_wheel_scroll_ratio * (LINES - 1) + 99 >> 31);
}

TabBuffer* posTab(int x, int y)
{// addr = 0x08056F53  --  defined in 'main.c' at line 5135
    TabBuffer* tab;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27
    _unknown_ _t33;                        // _t33
    _unknown_ _t35;                        // _t35

    if(mouse_action.menu_str != 0 &&  *135792264 > x && y == 0) {
        return 1;
    }
    asm("cwde ");
    if((LastTab->y & 65535) >= y) {
        tab = FirstTab;
L12:
        while(tab != 0) {
            goto L7;
        }
        return 0;
    }
    return 0;
L7:
    asm("cwde ");
    if((tab->x1 & 65535) > x) {
L11:
        tab = tab->nextTab;
        goto L12;
    }
    asm("cwde ");
    if((tab->x2 & 65535) < x) {
        goto L11;
    }
    asm("cwde ");
    if((tab->y & 65535) != y) {
        goto L11;
    }
    return tab;
}

do_mouse_action(int btn, int x, int y)
{// addr = 0x08056FDA  --  defined in 'main.c' at line 5151
    MouseActionMap* map;   // _cfa_fffffff0
    int ny;                                // _cfa_ffffffec
    int cx;                                // _cfa_ffffffe8
    int cy;                                // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t155;                             // _t155

    map = 0;
    ny = -1;
    if(nTab > 1 || mouse_action.menu_str != 0) {
        asm("cwde ");
        ny = (LastTab->y & 65535) + 1;
    }
    _t155 = btn;
    if(_t155 == 1) {
        btn = 1;
L9:
        if(y >= ny) {
            if(LINES - 1 != y) {
                if(y <= ny) {
                    goto L54;
                }
                asm("cwde ");
                if((CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535) != y) {
L34:
                    asm("cwde ");
                    cx = CurrentTab->currentBuffer->cursorX & 65535;
                    asm("cwde ");
                    cy = CurrentTab->currentBuffer->cursorY & 65535;
                    asm("cwde ");
                    asm("cwde ");
                    cursorXY(CurrentTab->currentBuffer, x - (CurrentTab->currentBuffer->rootX & 65535), y - (CurrentTab->currentBuffer->rootY & 65535));
                    asm("cwde ");
                    if((CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535) != y) {
L43:
                        cursorXY(CurrentTab->currentBuffer, cx, cy);
                        goto L47;
                    }
                    goto L35;
                }
                asm("cwde ");
                if((CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535) == x) {
L29:
                    if(retrieveCurrentAnchor(CurrentTab->currentBuffer) == 0 && retrieveCurrentForm(CurrentTab->currentBuffer) == 0) {
                    } else {
                        map = (btn << 3) + 135792332;
                        if(map == 0 || map->func == 0) {
                            map = (btn << 3) + 135792308;
                        }
                    }
                    goto L47;
                }
                if(( *135119023 & 0xff) == 0 || CurrentTab->currentBuffer->currentLine == 0 || ( *(CurrentTab->currentBuffer->currentLine->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 0x3f00) != 2560) {
                    goto L34;
                } else {
                    asm("cwde ");
                    if((CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535) + 1 != x) {
                        goto L34;
                    }
                    goto L29;
                }
L35:
                asm("cwde ");
                if((CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535) == x) {
L40:
                    if(retrieveCurrentAnchor(CurrentTab->currentBuffer) != 0 || retrieveCurrentForm(CurrentTab->currentBuffer) != 0) {
                        map = (btn << 3) + 135792308;
                    }
                    goto L43;
                }
                if(( *135119023 & 0xff) == 0 || CurrentTab->currentBuffer->currentLine == 0 || ( *(CurrentTab->currentBuffer->currentLine->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 0x3f00) != 2560) {
                    goto L43;
                }
                asm("cwde ");
                if((CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535) + 1 != x) {
                    goto L43;
                }
                goto L40;
            } else {
                if( *135792260 != 0) {
                    if(x < 0) {
                        if( *135792268 > x) {
                            if( *((intOrPtr*)(135792264 + (btn + 32) * 4)) != 0) {
                                map =  *((intOrPtr*)(135792264 + (btn + 32) * 4)) + (x << 3);
                            }
                        }
                    }
                }
            }
L47:
            if(map == 0 || map->func == 0) {
                map = (btn << 3) + 135792284;
            }
            if(map == 0 || map->func == 0) {
                goto L55;
            } else {
                 *135792272 = 1;
                 *135792276 = x;
                 *135792280 = y;
                CurrentKey = -1;
                CurrentKeyData = 0;
                CurrentCmdData = map->data;
                map();
                CurrentCmdData = 0;
                return;
            }
        }
        goto L10;
    }
    if(_t155 == 2) {
        btn = 2;
        goto L9;
    }
    if(_t155 != 0) {
        return;
    } else {
        btn = 0;
        goto L9;
    }
L54:
L55:
    return;
L10:
    if(mouse_action.menu_str != 0 && x < 0 &&  *135792264 > x) {
        if( *((intOrPtr*)(135792268 + (btn + 28) * 4)) != 0) {
            map =  *((intOrPtr*)(135792268 + (btn + 28) * 4)) + (x << 3);
        }
    } else {
        map = (btn << 3) + 135792356;
    }
    goto L47;
}

process_mouse(int btn, int x, int y)
{// addr = 0x0805743D  --  defined in 'main.c' at line 5240
    int delta_x;                           // _cfa_fffffff0
    int delta_y;                           // _cfa_ffffffec
    TabBuffer* t;    // _cfa_ffffffe4
    Buffer* buf;        // _cfa_ffffffdc
    int cx;                                // _cfa_ffffffd8
    int cy;                                // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffe8
    int ny;                                // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32

    ny = -1;
    if(nTab > 1 || mouse_action.menu_str != 0) {
        asm("cwde ");
        ny = (LastTab->y & 65535) + 1;
    }
    if(btn != 3) {
        if(btn != 64) {
            if(btn != 65) {
                goto L17;
            }
            goto L12;
        }
        goto L7;
L12:
        i = 0;
        while(mouse_scroll_line() > i) {
            lup1();
            i = i + 1;
        }
        goto L17;
    }
    if(press_btn > 4) {
        goto L17;
    }
    goto __eax;
L17:
    if(btn != 3 || press_btn == 255) {
        press_btn = btn;
        press_x = x;
        press_y = y;
        return;
    }
    press_btn = -1;
    return;
L7:
    i = 0;
    while(mouse_scroll_line() > i) {
        ldown1();
        i = i + 1;
    }
    goto L17;
}

msToggle()
{// addr = 0x0805794D  --  defined in 'main.c' at line 5354
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(use_mouse == 0) {
        use_mouse = 1;
    } else {
        use_mouse = 0;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

mouse()
{// addr = 0x0805798C  --  defined in 'main.c' at line 5365
    int btn;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25

    btn = (do_getch() & 0xff) - 32;
    x = (do_getch() & 0xff) - 33;
    if(x < 0) {
        x = x + 256;
    }
    y = (do_getch() & 0xff) - 33;
    if(y < 0) {
        y = y + 256;
    }
    if(x >= 0) {
        return;
    }
    if(x >= COLS) {
        goto L10;
    }
    if(y >= 0) {
        goto L11;
    }
    if(LINES - 1 < y) {
    } else {
        goto L8;
    }
    goto L12;
L8:
    process_mouse(btn, x, y);
    return;
L12:
    return;
L11:
    return;
L10:
    return;
}

int gpm_process_mouse(Gpm_Event* event, _Unknown_base* data)
{// addr = 0x08057A20  --  defined in 'main.c' at line 5392
    int btn;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    int* _v36;                             // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed short* _t49;                    // _t49
    signed short* _t53;                    // _t53
    _unknown_ _t58;                        // _t58
    signed int _t61;                       // _t61
    _unknown_ _t70;                        // _t70

    btn = -1;
    if((event->type & 8) == 0) {
        if((event->type & 4) == 0) {
             *135774721 = 2;
            _t49 =  &(__imp___gpm_arg[1]);
             *_t49 = (event->x & 65535) + __imp__gpm_zerobased & 65535;
             *__imp___gpm_arg =  *_t49 & 0xffff;
            _t53 =  &(__imp___gpm_arg[1]);
             *_t53 = (event->y & 65535) + __imp__gpm_zerobased & 65535;
            __imp___gpm_arg[0] =  *_t53 & 0xffff;
            __imp___gpm_arg[2] = 3;
            _v36 = 135774721;
            _v40 = 21532;
             *__esp = __imp__gpm_consolefd;
            ioctl();
            return 0;
        } else {
            _t61 = event->buttons & 0xff;
            if(_t61 == 2) {
                btn = 1;
            } else {
                if(_t61 == 4) {
                    btn = 0;
                } else {
                    if(_t61 == 1) {
                        btn = 2;
                    }
                }
            }
        }
    } else {
        btn = 3;
    }
    asm("cwde ");
    x = event->x & 65535;
    asm("cwde ");
    y = event->y & 65535;
    process_mouse(btn, x - 1, y - 1);
    return 0;
}

movMs()
{// addr = 0x08057B62  --  defined in 'main.c' at line 5443
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if( *135792272 == 0) {
        return;
    }
    if(nTab > 1 || mouse_action.menu_str != 0) {
        asm("cwde ");
        if( *135792280 < (LastTab->y & 65535) + 1) {
            goto L9;
        }
    }
    asm("cwde ");
    if( *135792276 >= (CurrentTab->currentBuffer->rootX & 65535) &&  *135792280 < LINES - 1) {
        asm("cwde ");
        asm("cwde ");
        cursorXY(CurrentTab->currentBuffer,  *135792276 - (CurrentTab->currentBuffer->rootX & 65535),  *135792280 - (CurrentTab->currentBuffer->rootY & 65535));
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
L9:
    return;
}

menuMs()
{// addr = 0x08057C30  --  defined in 'main.c' at line 5465
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if( *135792272 == 0) {
        return;
    }
    if(nTab > 1 || mouse_action.menu_str != 0) {
        asm("cwde ");
        if( *135792280 >= (LastTab->y & 65535) + 1) {
            goto L5;
        } else {
             *135792276 =  *135792276 - 2;
        }
L8:
        mainMn();
        return;
    }
L5:
    asm("cwde ");
    if( *135792276 >= (CurrentTab->currentBuffer->rootX & 65535) &&  *135792280 < LINES - 1) {
        asm("cwde ");
        asm("cwde ");
        cursorXY(CurrentTab->currentBuffer,  *135792276 - (CurrentTab->currentBuffer->rootX & 65535),  *135792280 - (CurrentTab->currentBuffer->rootY & 65535));
        displayBuffer(CurrentTab->currentBuffer, 0);
    }
    goto L8;
}

tabMs()
{// addr = 0x08057D0E  --  defined in 'main.c' at line 5482
    TabBuffer* tab;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if( *135792272 == 0) {
        return;
    }
    tab = posTab( *135792276,  *135792280);
    if(tab == 0) {
        goto L5;
    }
    if(tab != 1) {
        goto L3;
    }
    goto L7;
L3:
    CurrentTab = tab;
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
L7:
    return;
L5:
    return;
}

closeTMs()
{// addr = 0x08057D6E  --  defined in 'main.c' at line 5495
    TabBuffer* tab;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12

    if( *135792272 == 0) {
        return;
    }
    tab = posTab( *135792276,  *135792280);
    if(tab == 0) {
        goto L5;
    }
    if(tab != 1) {
        goto L3;
    }
    goto L7;
L3:
    deleteTab(tab);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
L7:
    return;
L5:
    return;
}

dispVer()
{// addr = 0x08057DD1  --  defined in 'main.c' at line 5510
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _v24 = w3m_version;
    disp_message( *(Sprintf("w3m version %s")), 1);
    return;
}

wrapToggle()
{// addr = 0x08057E00  --  defined in 'main.c' at line 5515
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(WrapSearch == 0) {
        WrapSearch = 1;
        disp_message("Wrap search on", 1);
        return;
    }
    WrapSearch = 0;
    disp_message("Wrap search off", 1);
    return;
}

int is_wordchar(int c, const char* badchars)
{// addr = 0x08057E4F  --  defined in 'main.c' at line 5530
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    int _t26;                              // _t26

    if(badchars == 0) {
        return  *( &MYCTYPE_MAP + (c & 0xff)) & 4;
    }
    if(( *( &MYCTYPE_MAP + (c & 0xff)) & 2) != 0 || strchr(badchars, c) != 0) {
        _t26 = 0;
    } else {
        _t26 = 1;
    }
    return _t26;
    return __eax;
}

char* getCurWord(Buffer* buf, int* spos, int* epos, const char* badchars)
{// addr = 0x08057EAB  --  defined in 'main.c' at line 5539
    char* p;                               // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    int b;                                 // _cfa_ffffffe8
    int e;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t86;                        // _t86
    _unknown_ _t92;                        // _t92

    l = buf->currentLine;
     *spos = 0;
     *epos = 0;
    if(l == 0) {
        return 0;
    }
    p = l->lineBuf;
    e = buf->pos;
    while(e > 0 && is_wordchar(p[e] & 0xff, badchars) == 0) {
        e = e - 1;
    }
    if(is_wordchar(p[e] & 0xff, badchars) != 0) {
        b = e;
L10:
        while(b > 0) {
            if(is_wordchar(p[b - 1] & 0xff, badchars) != 0) {
                goto L9;
            }
L15:
            while(l->len > e && is_wordchar(p[e] & 0xff, badchars) != 0) {
                e = e + 1;
            }
             *spos = b;
             *epos = e;
            return  &(p[b]);
        }
        goto L15;
    }
    return 0;
L9:
    b = b - 1;
    goto L10;
}

char* GetWord(Buffer* buf)
{// addr = 0x08057FBD  --  defined in 'main.c' at line 5566
    int b;                                 // _cfa_fffffff0
    int e;                                 // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    p = getCurWord(buf,  &b,  &e, 0);
    if(p == 0) {
        return 0;
    }
    return  *(Strnew_charp_n(p, e - b));
}

execdict(char* word)
{// addr = 0x08058013  --  defined in 'main.c' at line 5579
    char* w;                               // _cfa_fffffff0
    char* dictcmd;                         // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8
    struct _Str _v52;     // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    if(UseDictCommand == 0 || word == 0 || ( *word & 0xff) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    w =  *(wc_Str_conv_strict(Strnew_charp(word), InnerCharset, SystemCharset));
    if(( *w & 0xff) != 0) {
        _v52 =  *(Str_form_quote(Strnew_charp(w)));
        _v56 = DictCommand;
        dictcmd =  *(Sprintf("%s?%s"));
        _v52.area_size = 0;
        _v52.length = 0;
        buf = loadGeneralFile(dictcmd, 0, -1);
        if(buf != 0) {
            buf->filename = w;
            _v52 = word;
            _v56 = "*dictionary*";
            buf->buffername =  *(Sprintf("%s %s"));
            if(buf->type == 0) {
                buf->type = "text/plain";
            }
            pushBuffer(buf);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
    } else {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    disp_message("Execution failed", 1);
    return;
}

dictword()
{// addr = 0x0805818A  --  defined in 'main.c' at line 5610
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5

    execdict(inputLineHistSearch("(dictionary)!", 135036496, 16, 0, 0));
    return;
}

dictwordat()
{// addr = 0x080581C6  --  defined in 'main.c' at line 5615
    _unknown_ __ebp;                       // r6

    execdict(GetWord(CurrentTab->currentBuffer));
    return;
}

set_buffer_environ(Buffer* buf)
{// addr = 0x080581E6  --  defined in 'main.c' at line 5623
    Line* l;              // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    ParsedURL pu;    // _cfa_ffffffc0
    _unknown_ _v84;                        // _cfa_ffffffac
    long int _v88;                         // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    char* _t94;                            // _t94
    char* _t142;                           // _t142

    if(buf == 0) {
        return;
    }
    if(buf == prev_buf) {
L6:
        l = buf->currentLine;
        if(l == 0 || buf == prev_buf && l == prev_line && buf->pos == prev_pos) {
            if(l == 0) {
                set_environ("W3M_CURRENT_WORD", 135036496);
                set_environ("W3M_CURRENT_LINK", 135036496);
                set_environ("W3M_CURRENT_IMG", 135036496);
                set_environ("W3M_CURRENT_FORM", 135036496);
                set_environ("W3M_CURRENT_LINE", "0");
                set_environ("W3M_CURRENT_COLUMN", "0");
            }
        } else {
            s = GetWord(buf);
            if(s == 0) {
                _t94 = 135036496;
            } else {
                _t94 = s;
            }
            set_environ("W3M_CURRENT_WORD", _t94);
            a = retrieveCurrentAnchor(buf);
            if(a == 0) {
                set_environ("W3M_CURRENT_LINK", 135036496);
            } else {
                parseURL2(a->url,  &(pu.scheme), baseURL(buf));
                set_environ("W3M_CURRENT_LINK",  *(parsedURL2Str( &(pu.scheme))));
            }
            a = retrieveCurrentImg(buf);
            if(a == 0) {
                set_environ("W3M_CURRENT_IMG", 135036496);
            } else {
                parseURL2(a->url,  &(pu.scheme), baseURL(buf));
                set_environ("W3M_CURRENT_IMG",  *(parsedURL2Str( &(pu.scheme))));
            }
            a = retrieveCurrentForm(buf);
            if(a == 0) {
                set_environ("W3M_CURRENT_FORM", 135036496);
            } else {
                set_environ("W3M_CURRENT_FORM", form2str(a->url));
            }
            _v88 = l->real_linenumber;
            set_environ("W3M_CURRENT_LINE",  *(Sprintf("%d")));
            asm("cwde ");
            _v88 = buf->currentColumn + (buf->cursorX & 65535) + 1;
            set_environ("W3M_CURRENT_COLUMN",  *(Sprintf("%d")));
        }
        prev_buf = buf;
        prev_line = l;
        prev_pos = buf->pos;
        return;
    }
    set_environ("W3M_SOURCEFILE", buf->sourcefile);
    set_environ("W3M_FILENAME", buf->filename);
    set_environ("W3M_TITLE", buf->buffername);
    set_environ("W3M_URL",  *(parsedURL2Str(buf + 132)));
    if(buf->real_type == 0) {
        _t142 = "unknown";
    } else {
        _t142 = buf->real_type;
    }
    set_environ("W3M_TYPE", _t142);
    set_environ("W3M_CHARSET", wc_ces_to_charset( *(buf + 208)));
    goto L6;
}

char* searchKeyData()
{// addr = 0x08058533  --  defined in 'main.c' at line 5687
    char* data;                            // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18

    data = 0;
    if(CurrentKeyData == 0) {
L3:
        if(CurrentCmdData == 0 || ( *CurrentCmdData & 0xff) == 0) {
            if(CurrentKey < 0) {
                data = getKeyData(CurrentKey);
            }
        } else {
            data = CurrentCmdData;
        }
        goto L8;
    }
    if(( *CurrentKeyData & 0xff) == 0) {
        goto L3;
    } else {
        data = CurrentKeyData;
    }
L8:
    CurrentKeyData = 0;
    CurrentCmdData = 0;
    if(data == 0 || ( *data & 0xff) == 0) {
        return 0;
    }
    return allocStr(data, -1);
}

int searchKeyNum()
{// addr = 0x080585D7  --  defined in 'main.c' at line 5705
    char* d;                               // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    signed int _t10;                       // _t10

    n = 1;
    d = searchKeyData();
    if(d != 0) {
        n = atoi(d);
    }
    if(prec_num == 0) {
        _t10 = 1;
    } else {
        _t10 = prec_num;
    }
    return _t10 * n;
}

deleteFiles()
{// addr = 0x0805861B  --  defined in 'main.c' at line 5731
    Buffer* buf;        // _cfa_fffffff0
    char* f;                               // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    CurrentTab = FirstTab;
    while(CurrentTab != 0) {
        while(CurrentTab->firstBuffer != 0 && CurrentTab->firstBuffer != 1) {
            buf = CurrentTab->firstBuffer->nextBuffer;
            discardBuffer(CurrentTab->firstBuffer);
            CurrentTab->firstBuffer = buf;
        }
        CurrentTab = CurrentTab->nextTab;
    }
    while(1) {
        f = popValue(fileToDelete);
        if(f == 0) {
            break;
        }
        unlink(f);
    }
    return;
}

w3m_exit(int i)
{// addr = 0x080586AC  --  defined in 'main.c' at line 5748
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    int _v28;                              // _cfa_ffffffe4
    char* _v44;                            // _cfa_ffffffd4
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ __ebp;                       // r6
    _unknown_ _t51;                        // _t51
    char* _t75;                            // _t75
    _unknown_ _t92;                        // _t92
    _unknown_ _t93;                        // _t93

    init_migemo();
    stopDownload();
    deleteFiles();
    disconnectFTP();
    disconnectNews();
    exit(i);
    _push(_t92);
    __esp = __esp - 56;
    CurrentKeyData = 0;
    _v44 = searchKeyData();
    if(_v44 == 0 || ( *_v20 & 0xff) == 0) {
        _v20 = inputLineHistSearch("command [; ...]: ", 135036496, 16, TextHist, 0);
        if(_v20 != 0) {
L21:
            while(( *_v20 & 0xff) != 0) {
                while(( *_v20 & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *_v20 & 0xff)) & 2) != 0) {
                    _v20 =  &(_v20[1]);
                }
                if(( *_v20 & 0xff) != 59) {
                    _v24 = getWord( &_v20);
                    _v28 = getFuncList(_v24);
                    if(_v28 >= 0) {
                        goto L24;
                    }
                    goto L11;
L24:
                    displayBuffer(CurrentTab->currentBuffer, 0);
                    return;
                }
                _v20 =  &(_v20[1]);
                continue;
L11:
                _v24 = getQWord( &_v20);
                CurrentKey = -1;
                CurrentKeyData = 0;
                if(( *_v24 & 0xff) == 0) {
                    _t75 = 0;
                } else {
                    _t75 = _v24;
                }
                CurrentCmdData = _t75;
                if(use_mouse != 0) {
                    mouse_inactive();
                }
                 *((intOrPtr*)( *((intOrPtr*)(135103140 + _v28 * 8))))();
                if(use_mouse != 0) {
                    mouse_active();
                }
                CurrentCmdData = 0;
            }
            goto L24;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    goto L21;
}

execCmd()
{// addr = 0x080586D6  --  defined in 'main.c' at line 5768
    char* data;                            // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int cmd;                               // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t49;                        // _t49
    char* _t73;                            // _t73

    CurrentKeyData = 0;
    data = searchKeyData();
    if(data == 0 || ( *data & 0xff) == 0) {
        data = inputLineHistSearch("command [; ...]: ", 135036496, 16, TextHist, 0);
        if(data == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
    while(( *data & 0xff) != 0) {
        while(( *data & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *data & 0xff)) & 2) != 0) {
            data =  &(data[1]);
        }
        if(( *data & 0xff) != 59) {
            p = getWord( &data);
            cmd = getFuncList(p);
            if(cmd >= 0) {
                goto L23;
            }
            goto L10;
L23:
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        data =  &(data[1]);
        continue;
L10:
        p = getQWord( &data);
        CurrentKey = -1;
        CurrentKeyData = 0;
        if(( *p & 0xff) == 0) {
            _t73 = 0;
        } else {
            _t73 = p;
        }
        CurrentCmdData = _t73;
        if(use_mouse != 0) {
            mouse_inactive();
        }
         *((intOrPtr*)( *((intOrPtr*)(135103140 + cmd * 8))))();
        if(use_mouse != 0) {
            mouse_active();
        }
        CurrentCmdData = 0;
    }
    goto L23;
}

SigAlarm(int _dummy)
{// addr = 0x08058864  --  defined in 'main.c' at line 5813
    char* data;                            // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(CurrentAlarm->sec <= 0) {
L15:
        return;
L16:
    }
    CurrentKey = -1;
    CurrentKeyData = 0;
    data = CurrentAlarm->data;
    CurrentCmdData = data;
    if(use_mouse != 0) {
        mouse_inactive();
    }
     *((intOrPtr*)( *((intOrPtr*)(135103140 + CurrentAlarm->cmd * 8))))();
    if(use_mouse != 0) {
        mouse_active();
    }
    CurrentCmdData = 0;
    if((CurrentAlarm->status & 0xffff) == 3) {
        CurrentAlarm->sec = 0;
        CurrentAlarm->status = 0;
    }
    if(CurrentTab->currentBuffer->event != 0) {
        if((CurrentTab->currentBuffer->event->status & 0xffff) == 0) {
            CurrentTab->currentBuffer->event = 0;
        } else {
            CurrentAlarm = CurrentTab->currentBuffer->event;
        }
    }
    if(CurrentTab->currentBuffer->event == 0) {
        CurrentAlarm =  &DefaultAlarm;
    }
    if(CurrentAlarm->sec <= 0) {
        goto L15;
    } else {
        mySignal(14, SigAlarm);
        alarm(CurrentAlarm->sec);
        return;
    }
    goto L16;
}

setAlarm()
{// addr = 0x08058998  --  defined in 'main.c' at line 5852
    char* data;                            // _cfa_fffffff0
    int sec;                               // _cfa_ffffffec
    int cmd;                               // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t52;                        // _t52
    _unknown_ _t60;                        // _t60
    _unknown_ _t68;                        // _t68

    sec = 0;
    cmd = -1;
    CurrentKeyData = 0;
    data = searchKeyData();
    if(data == 0 || ( *data & 0xff) == 0) {
        data = inputLineHistSearch("(Alarm)sec command: ", 135036496, 16, TextHist, 0);
        if(data != 0) {
            goto L4;
        } else {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
L4:
    if(( *data & 0xff) != 0) {
        sec = atoi(getWord( &data));
        if(sec > 0) {
            cmd = getFuncList(getWord( &data));
        }
    }
    if(cmd >= 0) {
        setAlarmEvent( &DefaultAlarm, 0, 0, 0, 0);
    } else {
        data = getQWord( &data);
        setAlarmEvent( &DefaultAlarm, sec, 1, cmd, data);
        _v48 = data;
        _v52 =  *((intOrPtr*)( &w3mFuncList + cmd * 8));
        _v56 = sec;
        disp_message_nsec( *(Sprintf("%dsec %s %s")), 0, 1, 0, 1);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

AlarmEvent* setAlarmEvent(AlarmEvent* event, int sec, short int status, int cmd, _Unknown_base* data)
{// addr = 0x08058B3A  --  defined in 'main.c' at line 5884
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    AlarmEvent* _t21;   // _t21

    _t21 = _a12;
    _v16 = _t21 & 65535;
    if(event == 0) {
         *__esp = 16;
        GC_malloc();
        event = _t21;
    }
    event->sec = sec;
    event->status = _v16 & 0xffff;
    event->cmd = cmd;
    event->data = data;
    return event;
}

reinit()
{// addr = 0x08058B86  --  defined in 'main.c' at line 5896
    char* resource;                        // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t30;                        // _t30

    resource = searchKeyData();
    if(resource != 0) {
        if(strcasecmp(resource, "CONFIG") == 0 || strcasecmp(resource, "RC") == 0) {
            init_rc();
            sync_with_option();
            displayBuffer(CurrentTab->currentBuffer, 4);
            return;
        }
        if(strcasecmp(resource, "COOKIE") != 0) {
            if(strcasecmp(resource, "KEYMAP") != 0) {
                if(strcasecmp(resource, "MAILCAP") != 0) {
                    if(strcasecmp(resource, "MOUSE") != 0) {
                        if(strcasecmp(resource, "MENU") != 0) {
                            if(strcasecmp(resource, "MIMETYPES") != 0) {
                                if(strcasecmp(resource, "URIMETHODS") != 0) {
                                    _v40 = resource;
                                    disp_err_message( *(Sprintf("Don't know how to reinitialize '%s'")), 0);
                                    return;
                                }
                                goto L18;
                                return;
                            }
                            goto L16;
L18:
                            initURIMethods();
                            return;
                        }
                        goto L14;
L16:
                        initMimeTypes();
                        return;
                    }
                    goto L12;
L14:
                    initMenu();
                    return;
                }
                goto L10;
L12:
                initMouseAction();
                displayBuffer(CurrentTab->currentBuffer, 4);
                return;
            }
            goto L8;
L10:
            initMailcap();
            return;
        }
        initCookie();
        return;
L8:
        initKeymap(1);
        return;
    }
    init_rc();
    sync_with_option();
    initCookie();
    displayBuffer(CurrentTab->currentBuffer, 4);
    return;
}

defKey()
{// addr = 0x08058D3C  --  defined in 'main.c' at line 5965
    char* data;                            // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23

    CurrentKeyData = 0;
    data = searchKeyData();
    if(data == 0 || ( *data & 0xff) == 0) {
        data = inputLineHistSearch("Key definition: ", 135036496, 16, TextHist, 0);
        if(data == 0 || ( *data & 0xff) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            goto L5;
        }
    }
L5:
    setKeymap(allocStr(data, -1), -1, 1);
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

TabBuffer* newTab()
{// addr = 0x08058E03  --  defined in 'main.c' at line 5984
    TabBuffer* n;    // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14

     *__esp = 24;
    GC_malloc();
    n = __eax;
    if(n != 0) {
        n->nextTab = 0;
        n->currentBuffer = 0;
        n->firstBuffer = 0;
        return n;
    }
    return 0;
}

_newT()
{// addr = 0x08058E47  --  defined in 'main.c' at line 5998
    TabBuffer* tag;   // _cfa_fffffff0
    Buffer* buf;        // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37

    tag = newTab();
    if(tag != 0) {
        asm("cwde ");
        buf = newBuffer(CurrentTab->currentBuffer->width & 65535);
        copyBuffer(buf, CurrentTab->currentBuffer);
        buf->nextBuffer = 0;
        i = 0;
        while(i <= 4) {
             *(buf + 12 + (i + 4) * 4) = 0;
            i = i + 1;
        }
        buf->clone->filename =  &(buf->filename);
        tag->currentBuffer = buf;
        tag->firstBuffer = tag->currentBuffer;
        tag->nextTab = CurrentTab->nextTab;
        tag->prevTab = CurrentTab;
        if(CurrentTab->nextTab == 0) {
            LastTab = tag;
        } else {
            CurrentTab->nextTab->prevTab = tag;
        }
        CurrentTab->nextTab = tag;
        CurrentTab = tag;
        nTab = nTab + 1;
        return;
    }
    return;
}

newT()
{// addr = 0x08058F3F  --  defined in 'main.c' at line 6027
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _newT();
    displayBuffer(CurrentTab->currentBuffer, 4);
    return;
}

TabBuffer* numTab(int n)
{// addr = 0x08058F64  --  defined in 'main.c' at line 6034
    TabBuffer* tab;   // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t19;                        // _t19

    if(n != 0) {
        if(n != 1) {
            if(nTab > 1) {
                tab = FirstTab;
                i = 1;
L8:
                while(tab != 0 && i < n) {
                    goto L7;
                }
                return tab;
            }
            goto L5;
L7:
            tab = tab->nextTab;
            i = i + 1;
            goto L8;
        }
        goto L3;
L5:
        return 0;
    }
    return CurrentTab;
L3:
    return FirstTab;
}

calcTabPos()
{// addr = 0x08058FC5  --  defined in 'main.c' at line 6050
    TabBuffer* tab;   // _cfa_fffffff8
    int lcol;                              // _cfa_fffffff4
    int rcol;                              // _cfa_fffffff0
    int col;                               // _cfa_ffffffec
    int n1;                                // _cfa_ffffffe8
    int n2;                                // _cfa_ffffffe4
    int na;                                // _cfa_ffffffe0
    int nx;                                // _cfa_ffffffdc
    int ny;                                // _cfa_ffffffd8
    int ix;                                // _cfa_ffffffd4
    int iy;                                // _cfa_ffffffd0
    signed int _v56;                       // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t138;                             // _t138
    _unknown_ _t208;                       // _t208
    _unknown_ _t209;                       // _t209
    _unknown_ _t211;                       // _t211
    _unknown_ _t212;                       // _t212
    _unknown_ _t214;                       // _t214
    _unknown_ _t215;                       // _t215
    _unknown_ _t218;                       // _t218
    _unknown_ _t219;                       // _t219
    _unknown_ _t225;                       // _t225
    _unknown_ _t226;                       // _t226
    _unknown_ _t229;                       // _t229
    _unknown_ _t230;                       // _t230
    _unknown_ _t233;                       // _t233
    _unknown_ _t234;                       // _t234

    lcol = 0;
    rcol = 0;
    if(mouse_action.menu_str == 0) {
        _t138 = 0;
    } else {
        _t138 =  *135792264;
    }
    lcol = _t138;
    if(nTab > 0) {
        _v56 = TabCols;
        n1 = (COLS - rcol - lcol) / _v56;
        if(n1 < nTab) {
            if(n1 < 0) {
                n1 = 0;
            }
            _v56 = TabCols;
            n2 = COLS / _v56;
            if(n2 == 0) {
                n2 = 1;
            }
            ny = (nTab - n1 - 1) / n2 + 2;
        } else {
            n2 = 1;
            ny = 1;
        }
        na = (ny - 1) * n2 + n1;
        n1 = n1 - (na - nTab) / ny;
        if(n1 < 0) {
            n1 = 0;
        }
        na = (ny - 1) * n2 + n1;
        tab = FirstTab;
        iy = 0;
        while(iy < ny) {
            if(tab != 0) {
                if(iy != 0) {
                    _v56 = ny - 1;
                    nx = n2 - (na - nTab + iy - 1) / _v56;
                    col = COLS;
                } else {
                    nx = n1;
                    col = COLS - rcol - lcol;
                }
                ix = 0;
                while(ix < nx && tab != 0) {
                    tab->x1 = col * ix / nx & 65535;
                    tab->x2 = (ix + 1) * col / nx - 1 & 65535;
                    tab->y = iy & 65535;
                    if(iy == 0) {
                        tab->x1 = (tab->x1 & 65535) + lcol & 65535;
                        tab->x2 = (tab->x2 & 65535) + lcol & 65535;
                    }
                    ix = ix + 1;
                    tab = tab->nextTab;
                }
                iy = iy + 1;
                continue;
            }
            return;
        }
    }
    return;
}

TabBuffer* deleteTab(TabBuffer* tab)
{// addr = 0x080591EE  --  defined in 'main.c' at line 6107
    Buffer* buf;        // _cfa_fffffff0
    Buffer* next;       // _cfa_ffffffec
    _unknown_ __ebp;                       // r6

    if(nTab <= 1) {
        return FirstTab;
    }
    if(tab->prevTab == 0) {
        tab->nextTab->prevTab = 0;
        FirstTab = tab->nextTab;
        if(tab == CurrentTab) {
            CurrentTab = tab->nextTab;
        }
    } else {
        if(tab->nextTab == 0) {
            LastTab = tab->prevTab;
        } else {
            tab->nextTab->prevTab = tab->prevTab;
        }
        tab->prevTab->nextTab = tab->nextTab;
        if(tab == CurrentTab) {
            CurrentTab = tab->prevTab;
        }
    }
    nTab = nTab - 1;
    buf = tab->firstBuffer;
    while(buf != 0 && buf != 1) {
        next = buf->nextBuffer;
        discardBuffer(buf);
        buf = next;
    }
    return FirstTab;
}

closeT()
{// addr = 0x080592C9  --  defined in 'main.c' at line 6138
    TabBuffer* tab;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    int _t15;                              // _t15

    if(nTab > 1) {
        if(prec_num == 0) {
            tab = CurrentTab;
        } else {
            if(prec_num == 0) {
                _t15 = 1;
            } else {
                _t15 = prec_num;
            }
            tab = numTab(_t15);
        }
        if(tab != 0) {
            deleteTab(tab);
        }
        displayBuffer(CurrentTab->currentBuffer, 4);
        return;
    }
    return;
}

nextT()
{// addr = 0x0805933A  --  defined in 'main.c' at line 6153
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9

    if(nTab > 1) {
        i = 0;
        while() {
        }
    }
    return;
}

prevT()
{// addr = 0x080593B1  --  defined in 'main.c' at line 6168
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11

    if(nTab > 1) {
        i = 0;
        while() {
        }
    }
    return;
}

followTab(TabBuffer* tab)
{// addr = 0x0805942A  --  defined in 'main.c' at line 6184
    Buffer* buf;        // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    Buffer* c;          // _cfa_ffffffe8
    Buffer* p;          // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t65;                        // _t65
    _unknown_ _t76;                        // _t76

    a = retrieveCurrentImg(CurrentTab->currentBuffer);
    if(a == 0 || a->image == 0 || a->image->map == 0) {
        a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    }
    if(a == 0) {
L16:
        return;
    }
    if(tab != CurrentTab) {
        _newT();
        buf = CurrentTab->currentBuffer;
        check_target = 0;
        followA();
        check_target = 1;
        if(tab != 0) {
            if(CurrentTab->currentBuffer == buf) {
L15:
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            goto L12;
        }
        goto L8;
L12:
        c = CurrentTab->currentBuffer;
        p = prevBuffer(c, buf);
        p->nextBuffer = 0;
        CurrentTab->firstBuffer = buf;
        deleteTab(CurrentTab);
        CurrentTab = tab;
        buf = p;
        while(buf != 0) {
            p = prevBuffer(c, buf);
            pushBuffer(buf);
            buf = p;
        }
        goto L15;
    }
    check_target = 0;
    followA();
    check_target = 1;
    return;
L8:
    if(CurrentTab->currentBuffer == buf) {
        deleteTab(CurrentTab);
    } else {
        delBuffer(buf);
    }
    goto L15;
}

tabA()
{// addr = 0x080595AB  --  defined in 'main.c' at line 6232
    _unknown_ __ebp;                       // r6
    TabBuffer* _t2;   // _t2
    int _t4;                               // _t4

    if(prec_num == 0) {
        _t2 = 0;
    } else {
        if(prec_num == 0) {
            _t4 = 1;
        } else {
            _t4 = prec_num;
        }
        _t2 = numTab(_t4);
    }
    followTab(_t2);
    return;
}

tabURL0(TabBuffer* tab, char* prompt, int relative)
{// addr = 0x080595E8  --  defined in 'main.c' at line 6238
    Buffer* buf;        // _cfa_fffffff0
    Buffer* c;          // _cfa_ffffffec
    Buffer* p;          // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t56;                        // _t56
    _unknown_ _t67;                        // _t67

    if(tab != CurrentTab) {
        _newT();
        buf = CurrentTab->currentBuffer;
        goURL0(prompt, relative);
        if(tab != 0) {
            if(CurrentTab->currentBuffer == buf) {
L10:
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            goto L7;
            return;
        }
        goto L3;
L7:
        c = CurrentTab->currentBuffer;
        p = prevBuffer(c, buf);
        p->nextBuffer = 0;
        CurrentTab->firstBuffer = buf;
        deleteTab(CurrentTab);
        CurrentTab = tab;
        buf = p;
        while(buf != 0) {
            p = prevBuffer(c, buf);
            pushBuffer(buf);
            buf = p;
        }
        goto L10;
    }
    goURL0(prompt, relative);
    return;
L3:
    if(CurrentTab->currentBuffer == buf) {
        deleteTab(CurrentTab);
    } else {
        delBuffer(buf);
    }
    goto L10;
}

tabURL()
{// addr = 0x0805970B  --  defined in 'main.c' at line 6273
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    TabBuffer* _t4;   // _t4
    int _t6;                               // _t6

    if(prec_num == 0) {
        _t4 = 0;
    } else {
        if(prec_num == 0) {
            _t6 = 1;
        } else {
            _t6 = prec_num;
        }
        _t4 = numTab(_t6);
    }
    tabURL0(_t4, "Goto URL on new tab: ", 0);
    return;
}

tabrURL()
{// addr = 0x08059758  --  defined in 'main.c' at line 6279
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    TabBuffer* _t4;   // _t4
    int _t6;                               // _t6

    if(prec_num == 0) {
        _t4 = 0;
    } else {
        if(prec_num == 0) {
            _t6 = 1;
        } else {
            _t6 = prec_num;
        }
        _t4 = numTab(_t6);
    }
    tabURL0(_t4, "Goto relative URL on new tab: ", 1);
    return;
}

moveTab(TabBuffer* t, TabBuffer* t2, int right)
{// addr = 0x080597A5  --  defined in 'main.c' at line 6286
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(t2 == 1) {
        t2 = FirstTab;
    }
    if(t == 0) {
        return;
    }
    if(t2 == 0) {
        goto L23;
    }
    if(t == t2) {
        goto L24;
    }
    if(t == 1) {
    } else {
        if(t->prevTab == 0) {
            t->nextTab->prevTab = 0;
            FirstTab = t->nextTab;
        } else {
            if(t->nextTab == 0) {
                LastTab = t->prevTab;
            } else {
                t->nextTab->prevTab = t->prevTab;
            }
            t->prevTab->nextTab = t->nextTab;
        }
        if(right == 0) {
            t->prevTab = t2->prevTab;
            t->nextTab = t2;
            if(t2->prevTab == 0) {
                FirstTab = t;
            } else {
                t2->prevTab->nextTab = t;
            }
            t2->prevTab = t;
        } else {
            t->nextTab = t2->nextTab;
            t->prevTab = t2;
            if(t2->nextTab == 0) {
                LastTab = t;
            } else {
                t2->nextTab->prevTab = t;
            }
            t2->nextTab = t;
        }
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    goto L25;
L26:
    return;
L25:
    goto L26;
L24:
    return;
L23:
    return;
}

tabR()
{// addr = 0x080598D9  --  defined in 'main.c' at line 6324
    TabBuffer* tab;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    TabBuffer* _t14;   // _t14
    int _t16;                              // _t16

    tab = CurrentTab;
    i = 0;
    while(tab != 0) {
        if(prec_num == 0) {
            _t16 = 1;
        } else {
            _t16 = prec_num;
        }
        if(_t16 > i) {
            tab = tab->nextTab;
            i = i + 1;
            continue;
        }
        break;
    }
    if(tab == 0) {
        _t14 = LastTab;
    } else {
        _t14 = tab;
    }
    moveTab(CurrentTab, _t14, 1);
    return;
}

tabL()
{// addr = 0x08059948  --  defined in 'main.c' at line 6334
    TabBuffer* tab;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    TabBuffer* _t15;   // _t15
    int _t17;                              // _t17

    tab = CurrentTab;
    i = 0;
    while(tab != 0) {
        if(prec_num == 0) {
            _t17 = 1;
        } else {
            _t17 = prec_num;
        }
        if(_t17 > i) {
            tab = tab->prevTab;
            i = i + 1;
            continue;
        }
        break;
    }
    if(tab == 0) {
        _t15 = FirstTab;
    } else {
        _t15 = tab;
    }
    moveTab(CurrentTab, _t15, 0);
    return;
}

addDownloadList(pid_t pid, char* url, char* save, char* lock, clen_t size)
{// addr = 0x080599B8  --  defined in 'main.c' at line 6345
    DownloadList* d;   // _cfa_fffffff0
    DownloadList* _v32;   // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    struct _DownloadList* _v48;   // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    DownloadList* _t46;   // _t46
    intOrPtr _t54;                         // _t54

    _v36 = _a20;
    _t46 = _a24;
    _v32 = _t46;
     *__esp = 40;
    GC_malloc();
    d = _t46;
    d->pid = pid;
    d->url = url;
    if(( *save & 0xff) != 47 && ( *save & 0xff) != 126) {
        _v48 = 0;
        _v52 = save;
        _v56 = "/";
        save =  *(Strnew_m_charp(CurrentDir));
    }
    d->save = expandPath(save);
    d->lock = lock;
    __ecx = d;
    _t54 = _v36;
     *((intOrPtr*)(__ecx + 16)) = _t54;
     *(__ecx + 20) = _v32;
     *__esp = 0;
    time();
     *((intOrPtr*)(d + 24)) = _t54;
    d->ok = 0;
    d->next = 0;
    d->prev = LastDL;
    if(LastDL == 0) {
        FirstDL = d;
    } else {
        LastDL->next = d;
    }
    LastDL = d;
    add_download_list = 1;
    return;
}

int checkDownloadList()
{// addr = 0x08059AB4  --  defined in 'main.c' at line 6370
    DownloadList* d;   // _cfa_fffffff0
    struct stat st;       // _cfa_ffffff98
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    char* _t20;                            // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22

    if(FirstDL != 0) {
        d = FirstDL;
L7:
        while(d != 0) {
            goto L3;
        }
        return 0;
    }
    return 0;
L3:
    if(d->ok != 0) {
L6:
        d = d->next;
        goto L7;
    }
    _t20 = d->lock;
    __lstat(_t20,  &(st.st_dev));
    if(_t20 != 0) {
        goto L6;
    }
    return 1;
}

char* convert_size3(clen_t size)
{// addr = 0x08059B14  --  defined in 'main.c' at line 6385
    Str tmp;               // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v48;                        // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29
    char* _t40;                            // _t40
    _unknown_ _t46;                        // _t46
    signed int _t48;                       // _t48
    char* _t49;                            // _t49

    _v36 = _a4;
    _v32 = _a8;
    tmp = Strnew();
    while(1) {
        n = __moddi3(_v36, _v32, 1000, 0);
        _t48 = _v32;
        _v36 = __divdi3(_v36, _t48, 1000, 0);
        _v32 = _t48;
        _t49 = tmp->ptr;
        if((_v36 | _v32) == 0) {
            _t40 = "%d%s";
        } else {
            _t40 = ",%.3d%s";
        }
        _v52 = _t49;
        _v56 = n;
        tmp = Sprintf(_t40);
        if((_v36 | _v32) == 0) {
            break;
        }
    }
    return tmp->ptr;
}

Buffer* DownloadListBuffer()
{// addr = 0x08059BC5  --  defined in 'main.c' at line 6399
    DownloadList* d;   // _cfa_ffffffe0
    Str src;               // _cfa_ffffffdc
    time_t cur_time;    // _cfa_ffffffd8
    int duration;                          // _cfa_ffffffd4
    int rate;                              // _cfa_ffffffd0
    int eta;                               // _cfa_ffffffcc
    size_t size;        // _cfa_ffffffc8
    int i;                                 // _cfa_ffffffc4
    int l;                                 // _cfa_ffffffc0
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ _v108;                       // _cfa_ffffff94
    struct stat st;       // _cfa_ffffff68
    Buffer* _v160;      // _cfa_ffffff60
    unsigned int _v164;                    // _cfa_ffffff5c
    signed int _v166;                      // _cfa_ffffff5a
    signed int _v168;                      // _cfa_ffffff58
    intOrPtr _v172;                        // _cfa_ffffff54
    int _v176;                             // _cfa_ffffff50
    char* _v204;                           // _cfa_ffffff34
    intOrPtr _v208;                        // _cfa_ffffff30
    char* _v212;                           // _cfa_ffffff2c
    Buffer* _v216;      // _cfa_ffffff28
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t304;                       // _t304
    long int _t305;                        // _t305
    _unknown_ _t309;                       // _t309
    _unknown_ _t316;                       // _t316
    _unknown_ _t319;                       // _t319
    _unknown_ _t326;                       // _t326
    int _t342;                             // _t342
    DownloadList* _t364;   // _t364
    intOrPtr _t365;                        // _t365
    signed int _t372;                      // _t372
    char* _t373;                           // _t373
    _unknown_ _t375;                       // _t375
    _unknown_ _t382;                       // _t382
    _unknown_ _t387;                       // _t387
    _unknown_ _t394;                       // _t394
    DownloadList* _t403;   // _t403
    intOrPtr _t404;                        // _t404
    _unknown_ _t410;                       // _t410
    _unknown_ _t417;                       // _t417
    _unknown_ _t422;                       // _t422
    _unknown_ _t429;                       // _t429
    DownloadList* _t436;   // _t436
    intOrPtr _t437;                        // _t437
    DownloadList* _t439;   // _t439
    DownloadList* _t442;   // _t442
    char* _t444;                           // _t444
    char* _t446;                           // _t446
    DownloadList* _t451;   // _t451
    intOrPtr _t452;                        // _t452
    signed int _t454;                      // _t454
    int _t461;                             // _t461
    int _t473;                             // _t473
    int _t485;                             // _t485
    DownloadList* _t493;   // _t493
    _unknown_ _t504;                       // _t504
    _unknown_ _t507;                       // _t507
    _unknown_ _t512;                       // _t512
    _unknown_ _t513;                       // _t513
    _unknown_ _t520;                       // _t520
    _unknown_ _t522;                       // _t522
    unsigned int _t526;                    // _t526
    unsigned int _t534;                    // _t534
    unsigned int _t544;                    // _t544
    unsigned int _t545;                    // _t545
    _unknown_ _t549;                       // _t549
    _unknown_ _t556;                       // _t556
    intOrPtr _t562;                        // _t562
    _unknown_ _t563;                       // _t563
    _unknown_ _t564;                       // _t564
    _unknown_ _t567;                       // _t567
    _unknown_ _t574;                       // _t574
    _unknown_ _t578;                       // _t578
    _unknown_ _t585;                       // _t585
    intOrPtr _t589;                        // _t589
    _unknown_ _t591;                       // _t591
    _unknown_ _t598;                       // _t598
    _unknown_ _t602;                       // _t602
    _unknown_ _t609;                       // _t609
    intOrPtr _t613;                        // _t613
    _unknown_ _t614;                       // _t614
    _unknown_ _t617;                       // _t617
    intOrPtr _t618;                        // _t618
    _unknown_ _t634;                       // _t634
    _unknown_ _t636;                       // _t636

    src = 0;
    _t305 = FirstDL;
    if(_t305 == 0) {
        return 0;
    }
     *__esp = 0;
    time();
    cur_time = _t305;
    src = Strnew_charp("<html><head><title>Download List Panel</title></head>\n<body><h1 align=center>Download List Panel</h1>\n<form method=internal action=download><hr>\n");
    d = LastDL;
    while(d != 0) {
        if(( *(d + 16) |  *(d + 20)) == 0) {
L28:
            if(d->ok != 0) {
L33:
                 *__esp = size;
                _v216 = 0;
                _v216 = convert_size3();
                Strcat(src, Sprintf("  %s bytes loaded"));
                goto L34;
            }
            goto L29;
L34:
            if(duration > 0) {
                _v176 = duration;
                rate = size / _v176;
                _t372 = rate;
                _v212 = 1;
                 *__esp = _t372;
                _v216 = _t372 >> 31;
                _t373 = convert_size();
                _t527 = duration;
                _t528 = duration;
                _t530 = ((duration * -2004318071 >> 32) + duration >> 5) - (_t528 >> 31);
                _v204 = _t373;
                _v208 = duration - (((duration * -2004318071 >> 32) + duration >> 5) - (_t527 >> 31) << 2 << 4) - (((duration * -2004318071 >> 32) + duration >> 5) - (_t527 >> 31) << 2);
                _v212 = ((duration * -2004318071 >> 32) + duration >> 5) - (_t528 >> 31) - ((((((duration * -2004318071 >> 32) + duration >> 5) - (_t528 >> 31)) * -2004318071 >> 32) + ((duration * -2004318071 >> 32) + duration >> 5) - (_t528 >> 31) >> 5) - (_t530 >> 31) << 2 << 4) - ((((((duration * -2004318071 >> 32) + duration >> 5) - (_t528 >> 31)) * -2004318071 >> 32) + ((duration * -2004318071 >> 32) + duration >> 5) - (_t528 >> 31) >> 5) - (_t530 >> 31) << 2);
                _v216 = ((duration * -1851608123 >> 32) + duration >> 11) - (duration >> 31);
                Strcat(src, Sprintf("  %02d:%02d:%02d  rate %s/sec"));
                if(d->ok == 0) {
                    _t534 = size;
                    _t403 = d;
                    _t589 =  *((intOrPtr*)(_t403 + 20));
                    _t404 =  *((intOrPtr*)(_t403 + 16));
                    if(0 <= _t589 && (0 < _t589 || _t534 < _t404) && rate != 0) {
                        asm("sbb edx, ebx");
                        eta = __divdi3( *(d + 16) - size,  *(d + 20), rate, rate >> 31);
                        _t537 = eta;
                        _t538 = eta;
                        _t540 = ((eta * -2004318071 >> 32) + eta >> 5) - (_t538 >> 31);
                        _v208 = eta - (((eta * -2004318071 >> 32) + eta >> 5) - (_t537 >> 31) << 2 << 4) - (((eta * -2004318071 >> 32) + eta >> 5) - (_t537 >> 31) << 2);
                        _v212 = ((eta * -2004318071 >> 32) + eta >> 5) - (_t538 >> 31) - ((((((eta * -2004318071 >> 32) + eta >> 5) - (_t538 >> 31)) * -2004318071 >> 32) + ((eta * -2004318071 >> 32) + eta >> 5) - (_t538 >> 31) >> 5) - (_t540 >> 31) << 2 << 4) - ((((((eta * -2004318071 >> 32) + eta >> 5) - (_t538 >> 31)) * -2004318071 >> 32) + ((eta * -2004318071 >> 32) + eta >> 5) - (_t538 >> 31) >> 5) - (_t540 >> 31) << 2);
                        _v216 = ((eta * -1851608123 >> 32) + eta >> 11) - (eta >> 31);
                        Strcat(src, Sprintf("  eta %02d:%02d:%02d"));
                    }
                }
            }
            if( &((1)[src->length]) >= src->area_size) {
                Strgrow(src);
            }
            _t342 = src->length;
             *((char*)(src->ptr + _t342)) = 10;
            src->length =  &((1)[_t342]);
             *(src->ptr + src->length) = 0;
            if(d->ok == 0) {
                _v216 = d->pid;
                Strcat(src, Sprintf("<input type=submit name=stop%d value=STOP>"));
            } else {
                _v216 = d->pid;
                Strcat(src, Sprintf("<input type=submit name=ok%d value=OK>"));
                _t526 = size;
                _t364 = d;
                _t562 =  *((intOrPtr*)(_t364 + 20));
                _t365 =  *((intOrPtr*)(_t364 + 16));
                if(0 > _t562 || 0 >= _t562 && _t526 >= _t365) {
                    Strcat_charp(src, " Download completed");
                } else {
                    Strcat_charp(src, " Download incompleted");
                }
            }
            Strcat_charp(src, "\n</pre><hr>\n");
            d = d->prev;
            continue;
        } else {
            l = COLS - 6;
            _t545 = size;
            _t451 = d;
            _t618 =  *((intOrPtr*)(_t451 + 20));
            _t452 =  *((intOrPtr*)(_t451 + 16));
            if(0 > _t618 || 0 >= _t618 && _t545 >= _t452) {
                i = l;
            } else {
                asm("fild dword [ebp-0x3c]");
                _v164 = size;
                _v160 = 0;
                asm("fild qword [ebp+0xffffff60]");
                asm("fmulp st1, st0");
                _t493 = d;
                _v164 =  *(_t493 + 16);
                _v160 =  *(_t493 + 20);
                asm("fild qword [ebp+0xffffff60]");
                asm("fdivp st1, st0");
                asm("fnstcw word [ebp+0xffffff5e]");
                _v168 = _v166 & 0xffff;
                asm("fldcw word [ebp+0xffffff5c]");
                asm("fistp dword [ebp-0x38]");
                asm("fldcw word [ebp+0xffffff5e]");
            }
            _t454 = i;
            l = l - _t454;
            while(1) {
                i = i - 1;
                if((_t454 & 255) == 0) {
                    break;
                }
                if( &((1)[src->length]) >= src->area_size) {
                    Strgrow(src);
                }
                _t461 = src->length;
                 *((char*)(src->ptr + _t461)) = 35;
                src->length =  &((1)[_t461]);
                _t454 = src->ptr + src->length;
                 *_t454 = 0;
            }
            while(1) {
                l = l - 1;
                if((_t454 & 255) == 0) {
                    break;
                }
                if( &((1)[src->length]) >= src->area_size) {
                    Strgrow(src);
                }
                _t473 = src->length;
                 *((char*)(src->ptr + _t473)) = 95;
                src->length =  &((1)[_t473]);
                _t454 = src->ptr + src->length;
                 *_t454 = 0;
            }
            if( &((1)[src->length]) >= src->area_size) {
                Strgrow(src);
            }
            _t485 = src->length;
             *((char*)(src->ptr + _t485)) = 10;
            src->length =  &((1)[_t485]);
             *(src->ptr + src->length) = 0;
            goto L28;
        }
L29:
        _t544 = size;
        _t436 = d;
        _t613 =  *((intOrPtr*)(_t436 + 20));
        _t437 =  *((intOrPtr*)(_t436 + 16));
        if(0 > _t613 || 0 >= _t613 && _t544 >= _t437) {
            goto L33;
        } else {
            _v164 = size;
            _v160 = 0;
            asm("fild qword [ebp+0xffffff60]");
            asm("fld qword [0x80c8e68]");
            asm("fmulp st1, st0");
            _t439 = d;
            _v164 =  *(_t439 + 16);
            _v160 =  *(_t439 + 20);
            asm("fild qword [ebp+0xffffff60]");
            asm("fdivp st1, st0");
            asm("fnstcw word [ebp+0xffffff5e]");
            _v168 = _v166 & 0xffff;
            asm("fldcw word [ebp+0xffffff5c]");
            asm("fistp dword [ebp+0xffffff58]");
            asm("fldcw word [ebp+0xffffff5e]");
            _t442 = d;
             *__esp =  *(_t442 + 16);
            _v216 =  *(_t442 + 20);
            _t444 = convert_size3();
             *__esp = size;
            _v216 = 0;
            _t446 = convert_size3();
            _v208 = _v172;
            _v212 = _t444;
            _v216 = _t446;
            Strcat(src, Sprintf("  %s / %s bytes (%d%%)"));
        }
        goto L34;
    }
    Strcat_charp(src, "</form></body></html>");
    return loadHTMLString(src);
}

download_action(struct parsed_tagarg* arg)
{// addr = 0x0805A352  --  defined in 'main.c' at line 6481
    DownloadList* d;   // _cfa_fffffff0
    pid_t pid;           // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t63;                        // _t63

L18:
    while(arg != 0) {
        if(strncmp(arg->arg, "stop", 4) != 0) {
            if(strncmp(arg->arg, "ok", 2) != 0) {
                goto L17;
            }
            goto L4;
        }
        pid = atoi( &(arg->arg->value));
        _v40 = 9;
         *__esp = pid;
        kill();
L5:
        d = FirstDL;
        while(d != 0) {
            if(d->pid != pid) {
                d = d->next;
                continue;
            }
            unlink(d->lock);
            if(d->prev == 0) {
                FirstDL = d->next;
            } else {
                d->prev->next = d->next;
            }
            if(d->next == 0) {
                LastDL = d->prev;
            } else {
                d->next->prev = d->prev;
            }
L17:
            arg = arg->next;
            goto L18;
        }
        goto L17;
L4:
        pid = atoi( &(arg->arg[2]));
        goto L5;
    }
    ldDL();
    return;
}

stopDownload()
{// addr = 0x0805A47A  --  defined in 'main.c' at line 6516
    DownloadList* d;   // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    if(FirstDL != 0) {
        d = FirstDL;
        while(d != 0) {
            if(d->ok == 0) {
                _v40 = 9;
                 *__esp = d->pid;
                kill();
                unlink(d->lock);
            }
            d = d->next;
        }
        return;
    }
    return;
}

ldDL()
{// addr = 0x0805A4D7  --  defined in 'main.c' at line 6533
    Buffer* buf;        // _cfa_fffffff0
    int replace;                           // _cfa_ffffffec
    int new_tab;                           // _cfa_ffffffe8
    int reload;                            // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t120;                       // _t120

    replace = 0;
    new_tab = 0;
    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 8) != 0) {
        if(strcmp(CurrentTab->currentBuffer->buffername, "Download List Panel") == 0) {
            replace = 1;
        }
    }
    if(FirstDL != 0) {
        reload = checkDownloadList();
        buf = DownloadListBuffer();
        if(buf != 0) {
            buf->bufferprop = (buf->bufferprop & 65535 | 24) & 65535;
            if(replace != 0) {
                buf->rootX = CurrentTab->currentBuffer->rootX & 0xffff;
                buf->rootY = CurrentTab->currentBuffer->rootY & 0xffff;
                buf->COLS = CurrentTab->currentBuffer->COLS & 0xffff;
                buf->LINES = CurrentTab->currentBuffer->LINES & 0xffff;
                restorePosition(buf, CurrentTab->currentBuffer);
            }
            if(replace == 0 && open_tab_dl_list != 0) {
                _newT();
                new_tab = 1;
            }
            pushBuffer(buf);
            if(replace != 0 || new_tab != 0) {
                deletePrevBuf();
            }
            if(reload != 0) {
                CurrentTab->currentBuffer->event = setAlarmEvent(CurrentTab->currentBuffer->event, 1, 2, 112, 0);
            }
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        goto L13;
    }
    if(replace == 0) {
        return;
    }
    if(CurrentTab->currentBuffer != CurrentTab->firstBuffer || CurrentTab->currentBuffer->nextBuffer != 0) {
        delBuffer(CurrentTab->currentBuffer);
    } else {
        if(nTab > 1) {
            deleteTab(CurrentTab);
        }
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
L13:
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

save_buffer_position(Buffer* buf)
{// addr = 0x0805A6F6  --  defined in 'main.c' at line 6585
    BufferPos* b;    // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    int _t75;                              // _t75
    long int _t78;                         // _t78
    long int _t81;                         // _t81
    int _t88;                              // _t88
    long int _t125;                        // _t125
    long int _t126;                        // _t126

    b = buf->undo;
    _t75 = buf->firstLine;
    if(_t75 == 0) {
        return;
    }
    if(b == 0) {
L12:
         *__esp = 28;
        GC_malloc();
        b = _t75;
        if(buf->topLine == 0) {
            _t78 = 1;
        } else {
            _t78 = buf->topLine->linenumber;
        }
        b->top_linenumber = _t78;
        if(buf->currentLine == 0) {
            _t81 = 1;
        } else {
            _t81 = buf->currentLine->linenumber;
        }
        b->cur_linenumber = _t81;
        b->currentColumn = buf->currentColumn;
        b->pos = buf->pos;
        if(buf->currentLine == 0) {
            _t88 = 0;
        } else {
            _t88 = buf->currentLine->bpos;
        }
        b->bpos = _t88;
        b->next = 0;
        b->prev = buf->undo;
        if(buf->undo != 0) {
            buf->undo->next = b;
        }
        buf->undo = b;
        return;
    }
    _t125 = b->top_linenumber;
    if(buf->topLine == 0) {
        _t75 = 1;
    } else {
        _t75 = buf->topLine->linenumber;
    }
    if(_t125 != _t75) {
        goto L12;
    }
    _t126 = b->cur_linenumber;
    if(buf->currentLine == 0) {
        _t75 = 1;
    } else {
        _t75 = buf->currentLine->linenumber;
    }
    if(_t126 != _t75) {
        goto L12;
    }
    _t75 = buf->currentColumn;
    if(b->currentColumn != _t75) {
        goto L12;
    }
    _t75 = buf->pos;
    if(b->pos == _t75) {
    } else {
        goto L12;
    }
    goto L25;
L26:
    return;
L25:
    goto L26;
}

resetPos(BufferPos* b)
{// addr = 0x0805A856  --  defined in 'main.c' at line 6609
    long int _v36;                         // _cfa_ffffffdc
    Line top;             // _cfa_ffffffc0
    int _v72;                              // _cfa_ffffffb8
    long int _v88;                         // _cfa_ffffffa8
    Line cur;             // _cfa_ffffff8c
    int _v300;                             // _cfa_fffffed4
    int _v308;                             // _cfa_fffffecc
    char** _v360;                          // _cfa_fffffe98
    char** _v364;                          // _cfa_fffffe94
    Buffer buf;         // _cfa_fffffe88
    _unknown_ _v392;                       // _cfa_fffffe78
    _unknown_ __ebp;                       // r6

    _v36 = b->top_linenumber;
    _v88 = b->cur_linenumber;
    _v72 = b->bpos;
    _v364 =  &(top.lineBuf);
    _v360 =  &(cur.lineBuf);
    _v300 = b->pos;
    _v308 = b->currentColumn;
    restorePosition(CurrentTab->currentBuffer,  &(buf.filename));
    CurrentTab->currentBuffer->undo = b;
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

undoPos()
{// addr = 0x0805A8E8  --  defined in 'main.c' at line 6626
    BufferPos* b;    // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t28;                        // _t28

    b = CurrentTab->currentBuffer->undo;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(b == 0) {
        goto L12;
    }
    if(b->prev != 0) {
        i = 0;
        while() {
        }
    }
    return;
L12:
    return;
}

redoPos()
{// addr = 0x0805A96E  --  defined in 'main.c' at line 6639
    BufferPos* b;    // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t28;                        // _t28

    b = CurrentTab->currentBuffer->undo;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return;
    }
    if(b == 0) {
        goto L12;
    }
    if(b->next != 0) {
        i = 0;
        while() {
        }
    }
    return;
L12:
    return;
}

KeyAbort(int _dummy)
{// addr = 0x0805A9F4  --  defined in 'file.c' at line 181
    intOrPtr _v0;                          // _cfa_0
    signed char* _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t13;                       // _t13
    _unknown_ _t18;                        // _t18
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t20);
    __esp = __esp - 24;
    _t13 =  *_v24 & 0xff;
    if(_t13 == 7 || _t13 == 9) {
        closeNews();
        return;
    }
    if(_t13 == 2) {
        goto L4;
    }
    if(ISclose( *(_v0 + 4)) == 0) {
        goto L7;
    }
    return;
L4:
    closeFTP();
    return;
L7:
     *(_v0 + 4) = 0;
    return;
}

UFhalfclose(URLFile* f)
{// addr = 0x0805AA0E  --  defined in 'file.c' at line 188
    _unknown_ __ebp;                       // r6
    signed int _t12;                       // _t12
    _unknown_ _t17;                        // _t17

    _t12 = f->scheme & 0xff;
    if(_t12 == 7 || _t12 == 9) {
        closeNews();
        return;
    } else {
        if(_t12 != 2) {
            goto L5;
        }
        closeFTP();
        return;
    }
L5:
    if(ISclose( *(f + 4)) != 0) {
        return;
    }
     *(f + 4) = 0;
    return;
}

int currentLn(Buffer* buf)
{// addr = 0x0805AA60  --  defined in 'file.c' at line 207
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8

    if(buf->currentLine == 0) {
        return 1;
    }
    return buf->currentLine->linenumber + 1;
}

Buffer* loadSomething(URLFile* f, char* path, _None* loadproc, Buffer* defaultbuf)
{// addr = 0x0805AA82  --  defined in 'file.c' at line 217
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    Buffer* _v40;       // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    Buffer* _t49;       // _t49
    char* _t53;                            // _t53
    _unknown_ _t63;                        // _t63
    struct _Str* _t70;    // _t70
    _unknown_ _t75;                        // _t75

    _v40 = defaultbuf;
     *__esp = f;
    _t49 = loadproc;
    _t49->filename();
    buf = _t49;
    if(buf == 0) {
        return;
    }
    buf->filename = path;
    if(buf->buffername == 0 || (buf & 0xff) == 0) {
        _v40 = "Subject:";
        _t53 = buf;
         *__esp = _t53;
        checkHeader();
        buf->buffername = _t53;
        if(buf->buffername == 0) {
            _t70 = path;
            lastFileName(_t70);
            Strnew_charp(_t70);
            wc_Str_conv(_t70, SystemCharset, InnerCharset);
            buf->buffername =  *_t70;
        }
    }
    if( *(buf + 132) == 255) {
         *(buf + 132) = f->scheme & 0xff;
    }
    buf->real_scheme = f->scheme & 0xff;
    if((f->scheme & 0xff) == 4 && buf->sourcefile == 0) {
        buf->sourcefile = path;
    }
    return;
}

int dir_exist(char* path)
{// addr = 0x0805AB89  --  defined in 'file.c' at line 241
    struct stat stbuf;    // _cfa_ffffff9c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    char* _t15;                            // _t15
    _unknown_ _t19;                        // _t19

    if(path == 0 || ( *path & 0xff) == 0) {
        return 0;
    }
    _t15 = path;
    __stat(_t15,  &(stbuf.st_dev));
    if(_t15 != 255) {
        return stbuf.st_mode & 0;
    }
    return 0;
    return __eax;
}

int is_dump_text_type(char* type)
{// addr = 0x0805ABD9  --  defined in 'file.c' at line 253
    struct mailcap* mcap;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t13;                        // _t13

    if(type == 0) {
L4:
        return 0;
    }
    mcap = searchExtViewer(type);
    if(mcap == 0 || (mcap->flags & 6) == 0) {
        goto L4;
    }
    return 1;
    return __eax;
}

int is_text_type(char* type)
{// addr = 0x0805AC14  --  defined in 'file.c' at line 261
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t18;                        // _t18

    if(type != 0) {
        if(( *type & 0xff) == 0 || strncasecmp(type, "text/", 5) == 0 || strncasecmp(type, "message/", 8) == 0) {
            goto L4;
        } else {
            return 0;
        }
    }
L4:
    return 1;
}

int is_plain_text_type(char* type)
{// addr = 0x0805AC76  --  defined in 'file.c' at line 269
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t11;                        // _t11

    if(type == 0 || strcasecmp(type, "text/plain") != 0) {
        if(is_text_type(type) == 0 || is_dump_text_type(type) != 0) {
            return 0;
        } else {
            goto L4;
        }
    }
L4:
    return 1;
}

int is_html_type(char* type)
{// addr = 0x0805ACC5  --  defined in 'file.c' at line 276
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    _unknown_ _t9;                         // _t9

    if(type != 0 && (strcasecmp(type, "text/html") == 0 || strcasecmp(type, "application/xhtml+xml") == 0)) {
        return 1;
    }
    return 0;
}

check_compression(char* path, URLFile* uf)
{// addr = 0x0805AD0D  --  defined in 'file.c' at line 283
    int len;                               // _cfa_fffffff0
    struct compression_decoder* d;   // _cfa_ffffffec
    int elen;                              // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    if(path != 0) {
        len = strlen(path);
        uf->compression = 0;
        d =  &compression_decoders;
        while(d->type != 0) {
            if(d->ext == 0) {
                goto L7;
            }
            elen = strlen(d->ext);
            if(len <= elen || strcasecmp(len - elen + path, d->ext) != 0) {
                goto L7;
            }
            uf->compression = d->type;
            uf->guess_type = d->mime_type;
            return;
L7:
            d = d + 44;
        }
        return;
    }
    return;
}

char* compress_application_type(int compression)
{// addr = 0x0805ADB7  --  defined in 'file.c' at line 307
    struct compression_decoder* d;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15

    d =  &compression_decoders;
    while(d->type != 0) {
        if(d->type != compression) {
            d = d + 44;
            continue;
        }
        return d->mime_type;
    }
    return 0;
}

char* uncompressed_file_type(char* path, char** ext)
{// addr = 0x0805ADEC  --  defined in 'file.c' at line 319
    int len;                               // _cfa_fffffff0
    int slen;                              // _cfa_ffffffec
    Str fn;                // _cfa_ffffffe8
    char* t0;                              // _cfa_ffffffe4
    struct compression_decoder* d;   // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t65;                        // _t65
    _unknown_ _t66;                        // _t66

    if(path != 0) {
        slen = 0;
        len = strlen(path);
        d =  &compression_decoders;
L9:
        while(d->type != 0) {
            goto L3;
        }
L12:
        if(d->type != 0) {
            fn = Strnew_charp(path);
            Strshrink(fn, slen);
            if(ext != 0) {
                 *ext = filename_extension(fn->ptr, 0);
            }
            t0 = guessContentType(fn->ptr);
            if(t0 == 0) {
                t0 = "text/plain";
            }
            return t0;
        }
        return 0;
    }
    return 0;
L3:
    if(d->ext == 0) {
        goto L8;
    }
    slen = strlen(d->ext);
    if(len <= slen) {
        goto L8;
    }
    if(strcasecmp(len - slen + path, d->ext) == 0) {
        goto L12;
    }
L8:
    d = d + 44;
    goto L9;
}

int setModtime(char* path, time_t modtime)
{// addr = 0x0805AEF2  --  defined in 'file.c' at line 352
    struct utimbuf t;   // _cfa_ffffffec
    struct stat st;       // _cfa_ffffff94
    long int* _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    long int _t12;                         // _t12
    int _t15;                              // _t15

    _t12 = path;
    __stat(_t12,  &(st.st_dev));
    if(_t12 != 0) {
         *__esp = 0;
        time();
        t.actime = _t12;
    } else {
        t.actime = st.st_atim;
    }
    t.modtime = modtime;
    _v120 =  &(t.actime);
    _t15 = path;
     *__esp = _t15;
    utime();
    return _t15;
}

examineFile(char* path, URLFile* uf)
{// addr = 0x0805AF3F  --  defined in 'file.c' at line 366
    FILE* fp;             // _cfa_fffffff0
    char* ext;                             // _cfa_ffffffec
    char* t0;                              // _cfa_ffffffe8
    signed int _v96;                       // _cfa_ffffffa0
    struct stat stbuf;    // _cfa_ffffff90
    char** _v136;                          // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    char* _t65;                            // _t65
    _unknown_ _t102;                       // _t102

    uf->guess_type = 0;
    if(path == 0 || ( *path & 0xff) == 0) {
L4:
         *(uf + 4) = 0;
        return;
    } else {
        _t65 = path;
        __stat(_t65,  &(stbuf.st_dev));
        if(_t65 == 255 || (_v96 & 61440) != 32768) {
            goto L4;
        }
    }
    _v136 = 0;
     *__esp = path;
     *(uf + 4) = newInputStream(open());
    if(do_download != 0) {
L18:
        return;
L19:
    }
    if(use_lessopen == 0 || getenv("LESSOPEN") == 0) {
L15:
        check_compression(path, uf);
        if(uf->compression == 0) {
            goto L18;
        }
    } else {
        uf->guess_type = guessContentType(path);
        if(uf->guess_type == 0) {
            uf->guess_type = "text/plain";
        }
        if(is_html_type(uf->guess_type) != 0) {
            goto L18;
        }
        fp = lessopen_stream(path);
        if(fp == 0) {
            goto L15;
        }
        if(ISclose( *(uf + 4)) == 0) {
             *(uf + 4) = 0;
        }
         *(uf + 4) = newFileStream(fp, pclose);
        uf->guess_type = "text/plain";
        return;
    }
    ext = uf->ext;
    t0 = uncompressed_file_type(path,  &ext);
    uf->guess_type = t0;
    uf->ext = ext;
    uncompress_stream(uf, 0);
    return;
}

int check_command(char* cmd, int auxbin_p)
{// addr = 0x0805B0E4  --  defined in 'file.c' at line 407
    Str dirs;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* np;                              // _cfa_ffffffe8
    Str pathname;          // _cfa_ffffffe4
    signed int _v100;                      // _cfa_ffffff9c
    struct stat st;       // _cfa_ffffff8c
    _unknown_ _v136;                       // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    int _t61;                              // _t61
    char* _t70;                            // _t70
    _unknown_ _t72;                        // _t72
    _unknown_ _t77;                        // _t77

    if(path.9119 == 0) {
        path.9119 = getenv("PATH");
    }
    if(auxbin_p == 0) {
        dirs = Strnew_charp(path.9119);
    } else {
        dirs = Strnew_charp(w3m_auxbin_dir());
    }
    p = dirs->ptr;
    while(p != 0) {
        np = strchr(p, 58);
        if(np != 0) {
             *np = 0;
            np =  &(np[1]);
        }
        pathname = Strnew();
        Strcat_charp(pathname, p);
        if(pathname->length + 1 >= pathname->area_size) {
            Strgrow(pathname);
        }
        _t61 = pathname->length;
         *((char*)(pathname->ptr + _t61)) = 47;
        pathname->length = _t61 + 1;
         *(pathname->ptr + pathname->length) = 0;
        Strcat_charp(pathname, cmd);
        _t70 = pathname->ptr;
        __stat(_t70,  &(st.st_dev));
        if(_t70 != 0 || (_v100 & 61440) != 32768 || (_v100 & 73) == 0) {
            p = np;
            continue;
        }
        return 1;
    }
    return 0;
}

char* acceptableEncoding()
{// addr = 0x0805B228  --  defined in 'file.c' at line 437
    struct compression_decoder* d;   // _cfa_fffffff0
    TextList* l;      // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(encodings == 0) {
        l = newGeneralList();
        d =  &compression_decoders;
L6:
        while(d->type != 0) {
            goto L3;
        }
        encodings = Strnew();
        while(1) {
            p = popValue(l);
            if(p == 0) {
                break;
            }
            if(encodings->length != 0) {
                Strcat_charp(encodings, ", ");
            }
            Strcat_charp(encodings, p);
        }
        return encodings->ptr;
    }
    return encodings->ptr;
L3:
    if(check_command(d->cmd, d->auxbin_p) != 0) {
        pushValue(l, allocStr(d->encoding, -1));
    }
    d = d + 44;
    goto L6;
}

Str convertLine(URLFile* uf, Str line, int mode, wc_ces* charset, wc_ces doc_charset)
{// addr = 0x0805B300  --  defined in 'file.c' at line 466
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    line = wc_Str_conv_with_detect(line, charset, doc_charset, InnerCharset);
    if(mode != 0) {
        cleanup_line(line, mode);
    }
    if(uf != 0 && (uf->scheme & 0xff) == 9) {
        Strchop(line);
    }
    return line;
}

Buffer* loadFile(char* path)
{// addr = 0x0805B363  --  defined in 'file.c' at line 489
    Buffer* buf;        // _cfa_fffffff0
    union input_stream* _v44;   // _cfa_ffffffd4
    URLFile uf;        // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t38;                        // _t38
    int _t41;                              // _t41
    _unknown_ _t42;                        // _t42

    init_stream( &(uf.scheme), 4, 0);
    examineFile(path,  &(uf.scheme));
    if(_v44 != 0) {
        _t41 = COLS;
        if(showLineNum == 0) {
            _t26 = 1;
        } else {
            _t26 = 6;
        }
        _t27 = _t41 - _t26;
        _t28 = _t27 >= 0 ? 0 : _t27;
        buf = newBuffer(_t27 >= 0 ? 0 : _t27);
        current_content_length = 0;
         *135776436 = 0;
        content_charset = 0;
        buf = loadSomething( &(uf.scheme), path, loadBuffer, buf);
        if(ISclose(_v44) == 0) {
            _v44 = 0;
        }
        return buf;
    }
    return 0;
}

int matchattr(char* p, char* attr, int len, Str* value)
{// addr = 0x0805B43F  --  defined in 'file.c' at line 508
    int quoted;                            // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t110;                       // _t110
    _unknown_ _t116;                       // _t116
    _unknown_ _t126;                       // _t126
    signed int _t146;                      // _t146
    struct _Str* _t156;   // _t156
    int _t192;                             // _t192

    q = 0;
    if(strncasecmp(p, attr, len) != 0) {
L33:
        return 0;
    } else {
        p =  &(p[len]);
        while(( *p & 0xff) != 0) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        if(value == 0) {
L28:
            if(( *p & 0xff) == 0 || ( *p & 0xff) == 13 || ( *p & 0xff) == 10 || ( *p & 0xff) == 59) {
                return 1;
            }
            goto L33;
        }
         *value = Strnew();
        if(( *p & 0xff) != 61) {
L27:
            return 1;
        } else {
            p =  &(p[1]);
L9:
            while(( *p & 0xff) != 0) {
L10:
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                    p =  &(p[1]);
                    goto L9;
                }
                break;
            }
            quoted = 0;
            while(( *p & 0xff) != 0 && ( *p & 0xff) != 13 && ( *p & 0xff) != 10 && (quoted != 0 || ( *p & 0xff) != 59)) {
                _t146 =  *p & 255;
                if((_t146 & 255) != 34) {
                    if( *value->length + 1 >=  *value->area_size) {
                        Strgrow( *value);
                    }
                    _t156 =  *value;
                    _t192 = _t156->length;
                     *( *( *value) + _t192) =  *p & 0xff;
                    _t156->length = _t192 + 1;
                     *( *( *value) +  *value->length) = 0;
                } else {
                    quoted = _t146 & 0xff;
                }
                p =  &(p[1]);
            }
            if(q != 0) {
                Strshrink( *value, p - q - 1);
            }
            goto L27;
        }
        goto L28;
    }
    return __eax;
}

char* xface2xpm(char* xface)
{// addr = 0x0805B62E  --  defined in 'file.c' at line 548
    ImageCache* cache;   // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    short _v46;                            // _cfa_ffffffd2
    short _v48;                            // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    Image image;         // _cfa_ffffffc8
    intOrPtr _v100;                        // _cfa_ffffff9c
    struct stat st;       // _cfa_ffffff70
    char* _v164;                           // _cfa_ffffff5c
    char* _v168;                           // _cfa_ffffff58
    _unknown_ __ebp;                       // r6
    char* _t70;                            // _t70
    char* _t72;                            // _t72
    _unknown_ _t77;                        // _t77
    _unknown_ _t79;                        // _t79
    char* _t81;                            // _t81
    _unknown_ _t82;                        // _t82
    _unknown_ _t88;                        // _t88
    char* _t90;                            // _t90

    while(( *xface & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *xface & 0xff)) & 2) != 0) {
    }
    image.url = xface;
    _v52 = ".xpm";
    _v48 = 48;
    _v46 = 48;
    _v24 = 0;
    cache = getImage( &(image.url), 0, 2);
    if((cache->loaded & 1) == 0) {
L7:
        cache->loaded = 2;
        _t70 = shell_quote(cache->file);
        _t72 = shell_quote(auxbinFile("xface2xpm"));
        _v164 = _t70;
        _v168 = _t72;
        f = popen( *(Sprintf("%s > %s")), "w");
        if(f != 0) {
            fputs(xface, f);
            pclose(f);
            _t81 = cache->file;
            __stat(_t81,  &(st.st_dev));
            if(_t81 != 0 || _v100 == 0) {
                return 0;
            }
            cache->loaded = 5;
            cache->index = 0;
            return cache->file;
        }
        goto L8;
    }
    _t90 = cache->file;
    __stat(_t90,  &(st.st_dev));
    if(_t90 != 0) {
        goto L7;
    }
    return cache->file;
L8:
    return 0;
}

readHeader(URLFile* uf, Buffer* newBuf, int thru, ParsedURL* pu)
{// addr = 0x0805B7A0  --  defined in 'file.c' at line 582
    char c;                                // _cfa_fffffff3
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    char* emsg;                            // _cfa_ffffffe4
    Str lineBuf2;          // _cfa_ffffffe0
    Str tmp;               // _cfa_ffffffdc
    TextList* headerlist;   // _cfa_ffffffd8
    wc_ces charset;     // _cfa_ffffffd4
    wc_ces mime_charset;   // _cfa_ffffffd0
    char* tmpf;                            // _cfa_ffffffcc
    FILE* src;            // _cfa_ffffffc8
    Lineprop* propBuffer;   // _cfa_ffffffc4
    FILE* ff;             // _cfa_ffffffc0
    Str src;               // _cfa_ffffffbc
    Line* l;              // _cfa_ffffffb8
    wc_ces old_charset;   // _cfa_ffffffb4
    struct compression_decoder* d;   // _cfa_ffffffb0
    char** e;                              // _cfa_ffffffac
    Str name;              // _cfa_ffffffa8
    Str value;             // _cfa_ffffffa4
    Str domain;            // _cfa_ffffffa0
    Str path;              // _cfa_ffffff9c
    Str comment;           // _cfa_ffffff98
    Str commentURL;        // _cfa_ffffff94
    Str port;              // _cfa_ffffff90
    Str tmp2;              // _cfa_ffffff8c
    int version;                           // _cfa_ffffff88
    int quoted;                            // _cfa_ffffff84
    int flag;                              // _cfa_ffffff80
    time_t expires;     // _cfa_ffffff7c
    int err;                               // _cfa_ffffff78
    char* ans;                             // _cfa_ffffff74
    Str msg;               // _cfa_ffffff70
    Str funcname;          // _cfa_ffffff6c
    int f;                                 // _cfa_ffffff68
    URLFile f;         // _cfa_ffffff48
    _unknown_ _v196;                       // _cfa_ffffff3c
    _unknown_ _v200;                       // _cfa_ffffff38
    _unknown_ _v204;                       // _cfa_ffffff34
    _unknown_ _v208;                       // _cfa_ffffff30
    _unknown_ _v212;                       // _cfa_ffffff2c
    _unknown_ _v216;                       // _cfa_ffffff28
    _unknown_ _v220;                       // _cfa_ffffff24
    _unknown_ _v224;                       // _cfa_ffffff20
    _unknown_ _v228;                       // _cfa_ffffff1c
    _unknown_ _v232;                       // _cfa_ffffff18
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t794;                       // _t794
    _unknown_ _t813;                       // _t813
    _unknown_ _t883;                       // _t883
    _unknown_ _t928;                       // _t928
    _unknown_ _t958;                       // _t958
    _unknown_ _t999;                       // _t999
    _unknown_ _t1043;                      // _t1043
    _unknown_ _t1084;                      // _t1084
    _unknown_ _t1091;                      // _t1091
    _unknown_ _t1122;                      // _t1122
    _unknown_ _t1213;                      // _t1213
    _unknown_ _t1219;                      // _t1219
    _unknown_ _t1240;                      // _t1240
    _unknown_ _t1250;                      // _t1250
    _unknown_ _t1251;                      // _t1251
    _unknown_ _t1286;                      // _t1286
    _unknown_ _t1294;                      // _t1294
    _unknown_ _t1308;                      // _t1308
    _unknown_ _t1315;                      // _t1315
    _unknown_ _t1317;                      // _t1317
    _unknown_ _t1330;                      // _t1330
    _unknown_ _t1338;                      // _t1338
    _unknown_ _t1382;                      // _t1382
    _unknown_ _t1392;                      // _t1392
    _unknown_ _t1393;                      // _t1393

    lineBuf2 = 0;
    charset = 256;
    src = 0;
    newBuf->document_header = newGeneralList();
    headerlist = newBuf->document_header;
    if((uf->scheme & 0xff) != 0) {
        http_response_code = 0;
    } else {
        http_response_code = -1;
    }
    if(thru != 0) {
        if(newBuf->header_source == 0) {
            if(image_source == 0) {
                tmpf =  *(tmpfname(0, 0));
                src = fopen(tmpf, "w");
                if(src != 0) {
                    newBuf->header_source = tmpf;
                }
            }
        }
    }
    while(1) {
        tmp = StrmyISgets( *(uf + 4));
        if(tmp->length == 0) {
            break;
        } else {
            if((uf->scheme & 0xff) == 9) {
                if(( *(tmp->ptr) & 0xff) == 46) {
                    Strdelete(tmp, 0, 1);
                }
            }
            if(w3m_reqlog != 0) {
                ff = fopen(w3m_reqlog, "a");
                fwrite(tmp->ptr, 1, tmp->length, ff);
                fclose(ff);
            }
            if(src != 0) {
                fwrite(tmp->ptr, 1, tmp->length, src);
            }
            goto L15;
        }
    }
    if(thru != 0) {
        addnewline(newBuf, 135041709, propBuffer, 0, 0, -1, -1);
    }
    if(src == 0) {
        return;
    }
    fclose(src);
    return;
}

char* checkHeader(Buffer* buf, char* field)
{// addr = 0x0805CB59  --  defined in 'file.c' at line 927
    int len;                               // _cfa_fffffff0
    TextListItem* i;   // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24
    _unknown_ _t37;                        // _t37

    if(buf == 0 || field == 0 || buf->document_header == 0) {
        return 0;
    }
    len = strlen(field);
    i = buf->document_header->first;
    while(i != 0) {
        if(strncasecmp(i->ptr, field, len) != 0) {
            i = i->next;
            continue;
        }
        p =  &(i->ptr[len]);
        return remove_space(p);
    }
    return 0;
}

char* checkContentType(Buffer* buf)
{// addr = 0x0805CBED  --  defined in 'file.c' at line 946
    char* p;                               // _cfa_fffffff0
    Str r;                 // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t85;                            // _t85
    int _t124;                             // _t124
    _unknown_ _t131;                       // _t131

    p = checkHeader(buf, "Content-Type:");
    if(p == 0) {
        return 0;
    }
    r = Strnew();
    while(( *p & 0xff) != 0 && ( *p & 0xff) != 59 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
        if(r->length + 1 >= r->area_size) {
            Strgrow(r);
        }
        _t124 = r->length;
         *(r->ptr + _t124) =  *p & 0xff;
        r->length = _t124 + 1;
        p =  &(p[1]);
         *(r->ptr + r->length) = 0;
    }
    _v40 = "charset";
    _t85 = p;
     *__esp = _t85;
    strcasestr();
    p = _t85;
    if(p == 0) {
L22:
        return r->ptr;
    }
    p =  &(p[7]);
    while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
        p =  &(p[1]);
    }
    if(( *p & 0xff) != 61) {
        goto L22;
    }
    p =  &(p[1]);
    while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
        p =  &(p[1]);
    }
    if(( *p & 0xff) == 34) {
        p =  &(p[1]);
    }
    content_charset = wc_guess_charset(p, 0);
    goto L22;
    return __eax;
}

int skip_auth_token(char** pp)
{// addr = 0x0805CD5B  --  defined in 'file.c' at line 992
    char* p;                               // _cfa_fffffff8
    int first;                             // _cfa_fffffff4
    int typ;                               // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35

    first = 0;
    p =  *pp;
    while(( *p & 0xff) > 127) {
        if(( *p & 0xff) <= 31) {
            typ = 1;
        } else {
            typ = 2;
        }
        if(first == 0) {
            first = typ;
L9:
            p =  &(p[1]);
            continue;
        }
        if(first != typ) {
        } else {
            goto L9;
        }
        goto L10;
L11:
L10:
         *pp = p;
        return first;
        goto L11;
    }
    goto __eax;
}

Str extract_auth_val(char** q)
{// addr = 0x0805CDCE  --  defined in 'file.c' at line 1040
    unsigned char* qq;                     // _cfa_fffffff0
    int quoted;                            // _cfa_ffffffec
    Str val;               // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    int _t145;                             // _t145
    int _t159;                             // _t159
    int _t174;                             // _t174
    _unknown_ _t191;                       // _t191
    int _t200;                             // _t200

    qq =  *q;
    quoted = 0;
    val = Strnew();
L2:
    while(( *qq & 0xff) != 0) {
L3:
        if(( *( &MYCTYPE_MAP + ( *qq & 0xff)) & 2) != 0) {
            qq =  &(qq[1]);
            goto L2;
        }
        break;
    }
    if(( *qq & 0xff) == 34) {
        quoted = 1;
        if(val->length + 1 >= val->area_size) {
            Strgrow(val);
        }
        _t145 = val->length;
         *(val->ptr + _t145) =  *qq & 0xff;
        val->length = _t145 + 1;
        qq =  &(qq[1]);
         *(val->ptr + val->length) = 0;
    }
    while(( *qq & 0xff) != 0) {
        if(quoted == 0 || ( *qq & 0xff) != 34) {
            if(quoted != 0) {
L19:
                if(quoted != 0 && ( *qq & 0xff) == 92) {
                    if(val->length + 1 >= val->area_size) {
                        Strgrow(val);
                    }
                    _t174 = val->length;
                     *(val->ptr + _t174) =  *qq & 0xff;
                    val->length = _t174 + 1;
                    qq =  &(qq[1]);
                     *(val->ptr + val->length) = 0;
                }
L24:
                if(val->length + 1 >= val->area_size) {
                    Strgrow(val);
                }
                _t159 = val->length;
                 *(val->ptr + _t159) =  *qq & 0xff;
                val->length = _t159 + 1;
                qq =  &(qq[1]);
                 *(val->ptr + val->length) = 0;
                continue;
            }
        } else {
            if(val->length + 1 >= val->area_size) {
                Strgrow(val);
            }
            _t200 = val->length;
             *(val->ptr + _t200) =  *qq & 0xff;
            val->length = _t200 + 1;
            qq =  &(qq[1]);
             *(val->ptr + val->length) = 0;
L30:
             *q = qq;
            return val;
        }
        if(( *qq & 0xff) - 9 > 84) {
            if(( *qq & 0xff) <= 31 || ( *qq & 0xff) == 127) {
                qq =  &(qq[1]);
                goto L30;
            } else {
                goto L24;
            }
            goto L19;
        }
        goto __eax;
    }
    goto L30;
}

Str qstr_unquote(Str s)
{// addr = 0x0805D007  --  defined in 'file.c' at line 1094
    char* p;                               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t67;                              // _t67
    _unknown_ _t84;                        // _t84

    if(s != 0) {
        p = s->ptr;
        if(( *p & 0xff) != 34) {
            return s;
        }
        goto L3;
        return __eax;
    }
    return 0;
L3:
    tmp = Strnew();
    p =  &(p[1]);
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) == 92) {
            p =  &(p[1]);
        }
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t67 = tmp->length;
         *(tmp->ptr + _t67) =  *p & 0xff;
        tmp->length = _t67 + 1;
         *(tmp->ptr + tmp->length) = 0;
        p =  &(p[1]);
    }
    if(tmp->length > 0 && ( *(tmp->ptr + tmp->length - 1) & 0xff) == 34) {
        Strshrink(tmp, 1);
    }
    return tmp;
}

char* extract_auth_param(char* q, struct auth_param* auth)
{// addr = 0x0805D0EB  --  defined in 'file.c' at line 1117
    struct auth_param* ap;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    size_t len;         // _cfa_ffffffe8
    int token_type;                        // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t191;                       // _t191

    ap = auth;
    while(ap->name != 0) {
L39:
        while(( *q & 0xff) != 0) {
            while(( *q & 0xff) != 0) {
                if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
                    q =  &(q[1]);
                    continue;
                }
                break;
            }
            ap = auth;
            while(ap->name != 0) {
                len = strlen(ap->name);
                if(strncasecmp(q, ap->name, len) != 0 || ( *( &MYCTYPE_MAP + (q[len] & 0xff)) & 2) == 0 && (q[len] & 0xff) != 61) {
L18:
                    ap = ap + 8;
                } else {
                    p =  &(q[len]);
                    while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                        p =  &(p[1]);
                    }
                    if(( *p & 0xff) == 61) {
                        q =  &(p[1]);
                         *(ap + 4) = extract_auth_val( &q);
                        break;
                    }
                    return q;
                    goto L18;
                }
            }
            if(ap->name != 0) {
L32:
                if(( *q & 0xff) == 0) {
                    continue;
                }
                goto L33;
            }
            p = q;
            token_type = skip_auth_token( &q);
            if(token_type != 2) {
L31:
                return p;
            }
            if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
L26:
                while(( *q & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
                    q =  &(q[1]);
                }
                if(( *q & 0xff) == 61) {
                    q =  &(q[1]);
                    extract_auth_val( &q);
                    goto L32;
                }
                return p;
                goto L31;
            }
            if(( *q & 0xff) != 61) {
                goto L31;
            }
            goto L26;
L33:
            while(( *q & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
                q =  &(q[1]);
            }
            if(( *q & 0xff) != 44) {
                goto L42;
            }
            q =  &(q[1]);
            continue;
L42:
            return q;
        }
        goto L42;
    }
    goto L39;
}

Str get_auth_param(struct auth_param* auth, char* name)
{// addr = 0x0805D322  --  defined in 'file.c' at line 1170
    struct auth_param* ap;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    ap = auth;
    while(ap->name != 0) {
        if(strcasecmp(name, ap->name) != 0) {
            ap = ap + 8;
            continue;
        }
        return  *(ap + 4);
    }
    return 0;
}

Str AuthBasicCred(struct http_auth* ha, Str uname, Str pw, ParsedURL* pu, HRequest* hr, FormList* request)
{// addr = 0x0805D364  --  defined in 'file.c' at line 1181
    Str s;                 // _cfa_fffffff0
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t34;                              // _t34
    struct _Str* _t44;    // _t44

    s = Strdup(uname);
    if(s->length + 1 >= s->area_size) {
        Strgrow(s);
    }
    _t34 = s->length;
     *((char*)(s->ptr + _t34)) = 58;
    s->length = _t34 + 1;
     *((char*)(s->ptr + s->length)) = 0;
    Strcat(s, pw);
    _t44 = encodeB(s->ptr);
    _v36 = 0;
    _v40 = _t44->ptr;
    return Strnew_m_charp("Basic ");
}

struct http_auth* findAuthentication(struct http_auth* hauth, Buffer* buf, char* auth_field)
{// addr = 0x0805D3FE  --  defined in 'file.c' at line 1469
    struct http_auth* ha;   // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int slen;                              // _cfa_ffffffe8
    TextListItem* i;   // _cfa_ffffffe4
    char* p0;                              // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    int token_type;                        // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t116;                       // _t116
    _unknown_ _t127;                       // _t127
    struct http_auth* _t155;   // _t155
    struct http_auth* _t206;   // _t206

    len = strlen(auth_field);
    bzero(hauth, 16);
    i = buf->document_header->first;
    while(i != 0) {
        if(strncasecmp(i->ptr, auth_field, len) != 0) {
L27:
            i = i->next;
        } else {
            p =  &(i->ptr[len]);
            while(p != 0 && ( *p & 0xff) != 0) {
                while(( *p & 0xff) != 0) {
                    if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                        p =  &(p[1]);
                        continue;
                    }
                    break;
                }
                p0 = p;
                ha =  &www_auth;
                while(ha->scheme != 0) {
                    slen = strlen(ha->scheme);
                    if(strncasecmp(p, ha->scheme, slen) != 0) {
L15:
                        ha = ha + 16;
                    } else {
                        p =  &(p[slen]);
                        while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                            p =  &(p[1]);
                        }
                        if(hauth->pri >= ha->pri) {
                            p = extract_auth_param(p,  &none_auth_param);
                            goto L15;
                        }
                        _t155 = hauth;
                        _t206 = ha;
                        _t155->pri = _t206->pri;
                        _t155->scheme = _t206->scheme;
                        _t155->param = _t206->param;
                        _t155->cred = _t206->cred;
                        p = extract_auth_param(p, hauth->param);
                        break;
                    }
                }
                if(p0 != p) {
                    continue;
                }
                token_type = skip_auth_token( &p);
                if(token_type != 2 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                    goto L27;
                }
                while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                    p =  &(p[1]);
                }
                p = extract_auth_param(p,  &none_auth_param);
            }
            goto L27;
        }
    }
    if(hauth->scheme == 0) {
        return 0;
    }
    return hauth;
}

getAuthCookie(struct http_auth* hauth, char* auth_header, TextList* extra_header, ParsedURL* pu, HRequest* hr, FormList* request, _None* uname, _None* pwd)
{// addr = 0x0805D642  --  defined in 'file.c' at line 1515
    Str ss;                // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    TextListItem* i;   // _cfa_ffffffe8
    int a_found;                           // _cfa_ffffffe4
    int auth_header_len;                   // _cfa_ffffffe0
    char* realm;                           // _cfa_ffffffdc
    int proxy;                             // _cfa_ffffffd8
    char* pp;                              // _cfa_ffffffd4
    FormList* _v56;   // _cfa_ffffffc8
    HRequest* _v60;   // _cfa_ffffffc4
    ParsedURL* _v64;   // _cfa_ffffffc0
    _None _v68;                            // _cfa_ffffffbc
    _None _v72;                            // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t149;                       // _t149
    _unknown_ _t154;                       // _t154
    _unknown_ _t155;                       // _t155
    char* _t156;                           // _t156
    _unknown_ _t157;                       // _t157
    _unknown_ _t159;                       // _t159
    char* _t164;                           // _t164
    struct _Str* _t171;   // _t171
    struct _Str* _t174;   // _t174
    _Unknown_base* _t179;                  // _t179
    _unknown_ _t206;                       // _t206
    _unknown_ _t207;                       // _t207
    struct _Str* _t217;   // _t217

    ss = 0;
    auth_header_len = strlen(auth_header);
    realm = 0;
    if(hauth != 0) {
        _t217 = qstr_unquote(get_auth_param(hauth->param, "realm"));
        _t134 = _t217->ptr;
        realm = _t217->ptr;
    }
    if(realm == 0) {
L34:
        return;
    } else {
        a_found = 0;
        i = extra_header->first;
        while(i != 0) {
            if(strncasecmp(i->ptr, auth_header, auth_header_len) != 0) {
                i = i->next;
                continue;
            }
            a_found = 1;
            break;
        }
        proxy = strncasecmp("Proxy-Authorization:", auth_header, auth_header_len) & 0xff;
        if(a_found != 0) {
            if((fmInitialized & 0xff) == 0) {
                fwrite("Wrong username or password\n", 1, 27, __imp__stderr);
            } else {
                message("Wrong username or password", 0, 0);
                refresh();
            }
            sleep(1);
            delValue(extra_header, i);
            invalidate_auth_user_passwd(pu, realm,  *uname,  *pwd, proxy);
        }
         *uname = 0;
         *pwd = 0;
        if(a_found != 0 || find_auth_user_passwd(pu, realm, uname, pwd, proxy) == 0) {
            if((QuietMessage & 0xff) != 0) {
                goto L35;
            }
            sleep(2);
            if((fmInitialized & 0xff) == 0) {
                if(feof(__imp__stdin) != 0 || ferror(__imp__stdin) != 0) {
                    _v68 = realm;
                    fprintf(__imp__stderr, "w3m: Authorization required for %s\n");
                    exit(1);
                }
                if(proxy == 0) {
                    _t156 = "Username for %s: ";
                } else {
                    _t156 = "Proxy Username for %s: ";
                }
                _v72 = realm;
                printf(_t156);
                fflush(__imp__stdout);
                 *uname = Strfgets(__imp__stdin);
                Strchop( *uname);
                if(proxy == 0) {
                    _t164 = "Password: ";
                } else {
                    _t164 = "Proxy Password: ";
                }
                 *pwd = Strnew_charp(getpass(_t164));
                goto L31;
            }
            term_raw();
            _v72 = realm;
            pp = inputLineHistSearch( *(Sprintf("Username for %s: ")), 0, 16, 0, 0);
            if(pp == 0) {
                goto L36;
            }
             *uname = wc_Str_conv_strict(Strnew_charp(pp), InnerCharset, SystemCharset);
            _v72 = realm;
            pp = inputLineHistSearch( *(Sprintf("Password for %s: ")), 0, 64, 0, 0);
            if(pp != 0) {
                 *pwd = wc_Str_conv_strict(Strnew_charp(pp), InnerCharset, SystemCharset);
                term_cbreak();
                goto L31;
            }
             *uname = 0;
            return;
L36:
            return;
        }
L31:
        _v56 = request;
        _v60 = hr;
        _v64 = pu;
        _v68 =  *pwd;
        _v72 =  *uname;
        _t171 = hauth;
         *__esp = _t171;
        hauth();
        ss = _t171;
        if(ss == 0) {
             *uname = 0;
             *pwd = 0;
            return;
        }
        _t174 = auth_header;
        Strnew_charp(_t174);
        tmp = _t174;
        _v60 = 0;
        _v64 = "\n";
        _v68 = ss->ptr;
        _v72 = " ";
        Strcat_m_charp(tmp);
        _t179 = tmp->ptr;
        allocStr(_t179, -1);
        pushValue(extra_header, _t179);
        return;
        goto L34;
    }
L35:
    return;
}

int same_url_p(ParsedURL* pu1, ParsedURL* pu2)
{// addr = 0x0805DAA4  --  defined in 'file.c' at line 1640
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t28;                        // _t28
    _unknown_ _t36;                        // _t36

    if(pu1->scheme != pu2->scheme || pu1->port != pu2->port) {
L9:
        return 0;
    } else {
        if(pu1->host == 0 || pu2->host != 0 && strcasecmp(pu1->host, pu2->host) == 0) {
            if(pu1->file == 0 || pu2->file != 0 && strcmp(pu1->file, pu2->file) == 0) {
                return 1;
            } else {
                goto L9;
            }
        } else {
            goto L9;
        }
    }
    return __eax;
}

int checkRedirection(ParsedURL* pu)
{// addr = 0x0805DB36  --  defined in 'file.c' at line 1649
    Str tmp;               // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    struct _Str _v56;     // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t46;                        // _t46
    _unknown_ _t55;                        // _t55
    ParsedURL* _t64;   // _t64
    _unknown_ _t71;                        // _t71
    _unknown_ _t75;                        // _t75
    _unknown_ _t90;                        // _t90
    _unknown_ _t96;                        // _t96
    _unknown_ _t111;                       // _t111
    _unknown_ _t112;                       // _t112
    _unknown_ _t120;                       // _t120
    _unknown_ _t130;                       // _t130
    _unknown_ _t136;                       // _t136

    if(pu == 0) {
        nredir = 0;
        nredir_size = 0;
        puv = 0;
        return 1;
    }
    if(nredir < FollowRedirection) {
        if(nredir_size <= 0) {
L9:
            if(puv == 0) {
                nredir_size = ((FollowRedirection >> 31) + FollowRedirection >> 1) + 1;
                _t64 = (nredir_size << 2) + nredir_size << 3;
                 *__esp = _t64;
                GC_malloc();
                puv = _t64;
                memset(puv, 0, (nredir_size << 2) + nredir_size << 3);
            }
            copyParsedURL(puv + ((nredir % nredir_size << 2) + nredir % nredir_size << 3), pu);
            nredir = nredir + 1;
            return 1;
        }
    } else {
        _v56.length =  *(parsedURL2Str(pu));
        _v56.ptr = FollowRedirection;
        tmp = Sprintf("Number of redirections exceeded %d at %s");
        disp_err_message(tmp->ptr, 0);
        return 0;
    }
    _v32 = nredir_size;
    if(same_url_p(pu, puv + (((nredir - 1) % _v32 << 2) + (nredir - 1) % _v32 << 3)) != 0 || (nredir & 1) == 0 && same_url_p(pu, puv + ((((nredir >> 31) + nredir >> 1) % nredir_size << 2) + ((nredir >> 31) + nredir >> 1) % nredir_size << 3)) != 0) {
        _v56 =  *(parsedURL2Str(pu));
        tmp = Sprintf("Redirection loop detected (%s)");
        disp_err_message(tmp->ptr, 0);
        return 0;
    }
    goto L9;
}

Buffer* loadGeneralFile(char* path, _None current, char* referer, int flag, _None request)
{// addr = 0x0805DD60  --  defined in 'file.c' at line 1693
    struct http_auth hauth;   // _cfa_fffffeb4
    struct http_auth hauth;   // _cfa_fffffeb4
    struct stat st;       // _cfa_fffffeb4
    char _v16;                             // _cfa_fffffff0
    unsigned char status;                  // _cfa_ffffffe3
    _None of;                              // _cfa_ffffffdc
    Buffer* b;          // _cfa_ffffffd8
    _None proc;                            // _cfa_ffffffd4
    _None tpath;                           // _cfa_ffffffd0
    _None t;                               // _cfa_ffffffcc
    char* p;                               // _cfa_ffffffc8
    _None real_type;                       // _cfa_ffffffc4
    _None t_buf;                           // _cfa_ffffffc0
    _None searchHeader;                    // _cfa_ffffffbc
    _None searchHeader_through;            // _cfa_ffffffb8
    _None prevtrap;                        // _cfa_ffffffb4
    TextList* extra_header;   // _cfa_ffffffb0
    _None uname;                           // _cfa_ffffffac
    _None pwd;                             // _cfa_ffffffa8
    _None realm;                           // _cfa_ffffffa4
    _None add_auth_cookie_flag;            // _cfa_ffffffa0
    Str tmp;               // _cfa_ffffff9c
    _None page;                            // _cfa_ffffff98
    wc_ces charset;     // _cfa_ffffff94
    _None auth_pu;                         // _cfa_ffffff90
    Str cmd;               // _cfa_ffffff8c
    char* t1;                              // _cfa_ffffff88
    FILE* src;            // _cfa_ffffff84
    Str s;                 // _cfa_ffffff80
    char* file;                            // _cfa_ffffff7c
    char* file;                            // _cfa_ffffff78
    Buffer* b;          // _cfa_ffffff74
    Str s;                 // _cfa_ffffff70
    Anchor* a;          // _cfa_ffffff6c
    int l;                                 // _cfa_ffffff68
    int _v156;                             // _cfa_ffffff64
    URLOption url_option;   // _cfa_ffffff60
    HRequest hr;      // _cfa_ffffff54
    long int _v176;                        // _cfa_ffffff50
    intOrPtr _v180;                        // _cfa_ffffff4c
    _None _v184;                           // _cfa_ffffff48
    _None _v188;                           // _cfa_ffffff44
    Buffer* _v192;      // _cfa_ffffff40
    char* _v196;                           // _cfa_ffffff3c
    union input_stream* _v200;   // _cfa_ffffff38
    signed int _v202;                      // _cfa_ffffff36
    signed int _v203;                      // _cfa_ffffff35
    URLFile f;         // _cfa_ffffff34
    char* _v212;                           // _cfa_ffffff2c
    char* _v220;                           // _cfa_ffffff24
    char* _v224;                           // _cfa_ffffff20
    char* _v232;                           // _cfa_ffffff18
    ParsedURL pu;    // _cfa_ffffff0c
    signed int _v316;                      // _cfa_fffffec4
    struct stat st;       // _cfa_fffffeb4
    long int _v336;                        // _cfa_fffffeb0
    intOrPtr _v340;                        // _cfa_fffffeac
    _None _v344;                           // _cfa_fffffea8
    _None _v348;                           // _cfa_fffffea4
    Buffer* _v352;      // _cfa_fffffea0
    char* _v356;                           // _cfa_fffffe9c
    union input_stream* _v360;   // _cfa_fffffe98
    intOrPtr _v364;                        // _cfa_fffffe94
    _None _v372;                           // _cfa_fffffe8c
    unsigned char* _v376;                  // _cfa_fffffe88
    _None _v380;                           // _cfa_fffffe84
    char* _v384;                           // _cfa_fffffe80
    long int _v388;                        // _cfa_fffffe7c
    intOrPtr _v392;                        // _cfa_fffffe78
    _None _v396;                           // _cfa_fffffe74
    _None _v400;                           // _cfa_fffffe70
    int _v404;                             // _cfa_fffffe6c
    char* _v408;                           // _cfa_fffffe68
    char* _v412;                           // _cfa_fffffe64
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t873;                       // _t873
    signed int _t887;                      // _t887
    char* _t934;                           // _t934
    _unknown_ _t943;                       // _t943
    Buffer* _t946;      // _t946
    _unknown_ _t950;                       // _t950
    int _t996;                             // _t996
    _unknown_ _t997;                       // _t997
    _unknown_ _t1033;                      // _t1033
    _unknown_ _t1038;                      // _t1038
    char* _t1040;                          // _t1040
    _unknown_ _t1057;                      // _t1057
    _unknown_ _t1099;                      // _t1099
    int _t1102;                            // _t1102
    _unknown_ _t1103;                      // _t1103
    _unknown_ _t1122;                      // _t1122
    int _t1124;                            // _t1124
    _unknown_ _t1125;                      // _t1125
    char* _t1163;                          // _t1163
    _unknown_ _t1173;                      // _t1173
    _unknown_ _t1198;                      // _t1198
    _unknown_ _t1211;                      // _t1211
    _unknown_ _t1213;                      // _t1213
    _unknown_ _t1235;                      // _t1235
    _unknown_ _t1255;                      // _t1255
    _unknown_ _t1280;                      // _t1280
    _unknown_ _t1283;                      // _t1283
    _unknown_ _t1284;                      // _t1284
    int _t1290;                            // _t1290
    _unknown_ _t1291;                      // _t1291
    int _t1307;                            // _t1307
    _unknown_ _t1308;                      // _t1308
    _None _t1342;                          // _t1342
    int _t1345;                            // _t1345
    _unknown_ _t1346;                      // _t1346
    int _t1351;                            // _t1351
    _unknown_ _t1352;                      // _t1352
    signed int _t1370;                     // _t1370
    _unknown_ _t1379;                      // _t1379
    _unknown_ _t1398;                      // _t1398
    _unknown_ _t1406;                      // _t1406
    signed int _t1408;                     // _t1408
    char* _t1409;                          // _t1409
    _unknown_ _t1452;                      // _t1452
    Buffer* _t1463;     // _t1463
    _None _t1468;                          // _t1468
    ParsedURL* _t1496;   // _t1496
    _None* _t1497;                         // _t1497
    int _t1513;                            // _t1513
    _unknown_ _t1514;                      // _t1514
    _None _t1518;                          // _t1518
    int _t1523;                            // _t1523
    _unknown_ _t1524;                      // _t1524
    int _t1530;                            // _t1530
    _unknown_ _t1531;                      // _t1531
    _unknown_ _t1550;                      // _t1550
    _unknown_ _t1551;                      // _t1551
    int _t1554;                            // _t1554
    _unknown_ _t1555;                      // _t1555
    int _t1557;                            // _t1557
    _unknown_ _t1558;                      // _t1558
    int _t1561;                            // _t1561
    _unknown_ _t1562;                      // _t1562
    int _t1565;                            // _t1565
    _unknown_ _t1566;                      // _t1566

    __esp = __esp - 396;
    of = 0;
    b = 0;
    proc = loadBuffer;
    t = "text/plain";
    real_type = 0;
    t_buf = 0;
    searchHeader = SearchHeader & 0xff;
    searchHeader_through = 1;
    prevtrap = 0;
    extra_header = newGeneralList();
    uname = 0;
    pwd = 0;
    realm = 0;
    status = 0;
    page = 0;
    charset = 256;
    tpath = path;
    prevtrap = 0;
    add_auth_cookie_flag = 0;
    checkRedirection(0);
L1:
    while(1) {
L1:
        while(1) {
            do {
L105:
                auth_pu =  &(pu.scheme);
                getAuthCookie( &(st.st_dev), "Authorization:", extra_header, auth_pu,  &(hr.command), request,  &uname,  &pwd);
                if(uname != 0) {
                    if(ISclose(_v200) == 0) {
                        _v200 = 0;
                    }
                    add_auth_cookie_flag = 1;
                    status = 0;
L1:
                    while(1) {
                        do {
                            if((TrapSignal & 0xff) != 0) {
                                if((fmInitialized & 0xff) != 0) {
                                    term_raw();
                                }
                                if(prevtrap != 0) {
                                    mySignal(2, prevtrap);
                                }
                            }
                            url_option.referer = referer;
                            _v156 = flag;
                            _v376 =  &status;
                            openURL( &_v364, tpath,  &(pu.scheme), current,  &(url_option.referer), request, extra_header, of,  &(hr.command));
                            __esp = __esp - 4;
                            f.scheme = _v364;
                            _v200 = _v360;
                            _v196 = _v356;
                            _v192 = _v352;
                            _v188 = _v348;
                            _v184 = _v344;
                            _v180 = _v340;
                            _v176 = _v336;
                            of = 0;
                            content_charset = 0;
                            if(_v200 != 0) {
                                _t887 = status & 255;
                                if((_t887 & 255) != 254) {
                                    _v412 = 1;
                                     *__esp =  &AbortLoading;
                                    __sigsetjmp();
                                    if(_t887 == 0) {
                                        b = 0;
                                        if((_v203 & 0xff) != 0) {
                                            searchHeader = 1;
                                            searchHeader_through = 0;
                                        }
                                        if(header_string != 0) {
                                            header_string = 0;
                                        }
                                        if((TrapSignal & 0xff) != 0) {
                                            prevtrap = mySignal(2, KeyAbort);
                                            if((fmInitialized & 0xff) != 0) {
                                                term_cbreak();
                                            }
                                        }
                                        if(pu.scheme == 0) {
L69:
                                            if((fmInitialized & 0xff) != 0) {
                                                term_cbreak();
                                                _v412 = _v232;
                                                message( *(Sprintf("%s contacted. Waiting for reply...")), 0, 0);
                                                refresh();
                                            }
                                            if(t_buf == 0) {
                                                _t1554 = COLS;
                                                if(showLineNum == 0) {
                                                    _t1290 = 1;
                                                } else {
                                                    _t1290 = 6;
                                                }
                                                _t1291 = _t1554 - _t1290;
                                                _t1292 = _t1291 >= 0 ? 0 : _t1291;
                                                t_buf = newBuffer(_t1291 >= 0 ? 0 : _t1291);
                                            }
                                            readHeader( &(f.scheme), t_buf, 0,  &(pu.scheme));
                                            if(http_response_code <= 300 || http_response_code > 303) {
                                                if(http_response_code != 307) {
                                                    break;
                                                }
                                            }
                                            goto L79;
                                        }
                                        if(pu.scheme != 1 || non_null(GOPHER_proxy) == 0) {
                                            if(pu.scheme != 2 || non_null(FTP_proxy) == 0) {
L130:
                                                if(pu.scheme == 9 || pu.scheme == 7) {
                                                    if(t_buf == 0) {
                                                        _t1557 = COLS;
                                                        if(showLineNum == 0) {
                                                            _t1307 = 1;
                                                        } else {
                                                            _t1307 = 6;
                                                        }
                                                        _t1308 = _t1557 - _t1307;
                                                        _t1309 = _t1308 >= 0 ? 0 : _t1308;
                                                        t_buf = newBuffer(_t1308 >= 0 ? 0 : _t1308);
                                                    }
                                                    readHeader( &(f.scheme), t_buf, 1,  &(pu.scheme));
                                                    t = checkContentType(t_buf);
                                                    if(t == 0) {
                                                        t = "text/plain";
                                                    }
L192:
                                                    _v184 = t;
                                                    goto L200;
                                                }
                                                if(pu.scheme != 1) {
                                                    if(pu.scheme != 2) {
                                                        if(pu.scheme != 11) {
                                                            if(searchHeader == 0) {
                                                                if(DefaultType == 0) {
                                                                    t = guessContentType(_v224);
                                                                    if(t == 0) {
                                                                        t = "text/plain";
                                                                    }
                                                                    real_type = t;
                                                                    if(_v184 != 0) {
                                                                        t = _v184;
                                                                    }
                                                                } else {
                                                                    t = DefaultType;
                                                                    DefaultType = 0;
                                                                }
                                                                goto L192;
                                                            }
                                                            goto L169;
                                                        }
                                                        goto L167;
L169:
                                                        SearchHeader = 0;
                                                        searchHeader = 0;
                                                        if(t_buf == 0) {
                                                            _t1565 = COLS;
                                                            if(showLineNum == 0) {
                                                                _t1351 = 1;
                                                            } else {
                                                                _t1351 = 6;
                                                            }
                                                            _t1352 = _t1565 - _t1351;
                                                            _t1353 = _t1352 >= 0 ? 0 : _t1352;
                                                            t_buf = newBuffer(_t1352 >= 0 ? 0 : _t1352);
                                                        }
                                                        readHeader( &(f.scheme), t_buf, searchHeader_through,  &(pu.scheme));
                                                        if((_v203 & 0xff) == 0) {
L183:
                                                            t = checkContentType(t_buf);
                                                            if(t == 0) {
L184:
                                                                t = "text/plain";
                                                            }
                                                            goto L192;
                                                        } else {
                                                            p = checkHeader(t_buf, "Location:");
                                                            if(p == 0 || checkRedirection( &(pu.scheme)) == 0) {
                                                                goto L183;
                                                            } else {
                                                                tpath = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(p)), InnerCharset, DocumentCharset)));
                                                                request = 0;
                                                                _t1342 = ISclose(_v200);
                                                                if(_t1342 == 0) {
                                                                    _v200 = 0;
                                                                    _t1342 = _v200;
                                                                }
                                                                add_auth_cookie_flag = 0;
                                                                 *__esp = 40;
                                                                GC_malloc();
                                                                current = _t1342;
                                                                copyParsedURL(current,  &(pu.scheme));
                                                                _t1561 = COLS;
                                                                if(showLineNum == 0) {
                                                                    _t1345 = 1;
                                                                } else {
                                                                    _t1345 = 6;
                                                                }
                                                                _t1346 = _t1561 - _t1345;
                                                                _t1347 = _t1346 >= 0 ? 0 : _t1346;
                                                                t_buf = newBuffer(_t1346 >= 0 ? 0 : _t1346);
                                                                 *(t_buf + 64) = ( *(t_buf + 64) & 65535 | 32) & 65535;
                                                                status = 0;
                                                                continue;
                                                            }
                                                            goto L184;
                                                        }
                                                    }
                                                    goto L159;
L167:
                                                    t = _v184;
                                                    goto L192;
                                                }
                                                _t1370 =  *_v224 & 0xff;
                                                if(_t1370 == 103) {
                                                    t = "image/gif";
                                                    goto L192;
                                                }
                                                if(_t1370 > 103) {
                                                    if(_t1370 == 109) {
                                                        goto L150;
                                                    }
                                                    goto L146;
                                                }
                                                if(_t1370 == 48) {
                                                    t = "text/plain";
                                                    goto L192;
                                                }
                                                if(_t1370 == 49) {
                                                    goto L150;
                                                }
                                                goto L192;
L150:
                                                page = loadGopherDir( &(f.scheme),  &(pu.scheme),  &charset);
                                                t = "gopher:directory";
                                                if((TrapSignal & 0xff) != 0) {
                                                    if((fmInitialized & 0xff) != 0) {
                                                        term_raw();
                                                    }
                                                    if(prevtrap != 0) {
                                                        mySignal(2, prevtrap);
                                                    }
                                                }
                                                goto L200;
L146:
                                                if(_t1370 == 115) {
                                                    t = "audio/basic";
                                                } else {
                                                    if(_t1370 == 104) {
                                                        t = "text/html";
                                                    }
                                                }
                                                goto L192;
L159:
                                                check_compression(path,  &(f.scheme));
                                                if(_v192 == 0) {
                                                    real_type = guessContentType(_v224);
                                                    if(real_type == 0) {
                                                        real_type = "text/plain";
                                                    }
                                                    t = real_type;
                                                } else {
                                                    t1 = uncompressed_file_type(_v224, 0);
                                                    real_type = _v184;
                                                    if(t1 == 0) {
                                                        t = real_type;
                                                    } else {
                                                        t = t1;
                                                    }
                                                }
                                                goto L192;
                                            } else {
                                                goto L67;
                                            }
                                        }
L67:
                                        if((use_proxy & 0xff) == 0 || check_no_proxy(_v232) != 0) {
                                            goto L130;
                                        }
                                        goto L69;
                                    } else {
                                        if((TrapSignal & 0xff) != 0) {
                                            if((fmInitialized & 0xff) != 0) {
                                                term_raw();
                                            }
                                            if(prevtrap != 0) {
                                                mySignal(2, prevtrap);
                                            }
                                        }
                                        if(b != 0) {
                                            discardBuffer(b);
                                        }
                                        if(ISclose(_v200) == 0) {
                                            _v200 = 0;
                                        }
                                        _t946 = 0;
                                    }
                                } else {
                                    if((TrapSignal & 0xff) != 0) {
                                        if((fmInitialized & 0xff) != 0) {
                                            term_raw();
                                        }
                                        if(prevtrap != 0) {
                                            mySignal(2, prevtrap);
                                        }
                                    }
                                    if(ISclose(_v200) == 0) {
                                        _v200 = 0;
                                    }
                                    _t946 = 0;
                                }
L365:
                                 &_v16 =  &_v16;
                                return _t946;
                            }
                            _t1408 = f.scheme & 0xff;
                            if(_t1408 == 4) {
                                _t1409 = _v220;
                                __stat(_t1409,  &(st.st_dev));
                                if(_t1409 >= 0) {
                                    if((_v316 & 61440) != 16384) {
                                        goto L32;
                                    }
                                    if(UseExternalDirBuffer == 0) {
                                        page = loadLocalDir(_v220);
                                        t = "local:directory";
                                        charset = SystemCharset;
                                        goto L32;
                                    } else {
                                        _v408 = _v224;
                                        _v412 = DirBufferCommand;
                                        cmd = Sprintf("%s?dir=%s#current");
                                        _v400 = 0;
                                        _v404 = 0;
                                        b = loadGeneralFile(cmd->ptr, 0, -1);
                                        if(b != 0) {
                                            if(b != 1) {
                                                copyParsedURL(b + 132,  &(pu.scheme));
                                                b->filename =  *(b + 156);
                                            }
                                        }
                                        _t946 = b;
                                    }
                                } else {
                                    _t946 = 0;
                                }
                                goto L365;
                            }
                            if(_t1408 > 4) {
                                if(_t1408 == 10) {
                                    page = loadNewsgroup( &(pu.scheme),  &charset);
                                    t = "news:group";
                                    goto L32;
                                }
                            } else {
                                if(_t1408 == 3) {
                                    page = loadFTPDir( &(pu.scheme),  &charset);
                                    t = "ftp:directory";
                                }
L32:
                                if(page == 0 ||  *((intOrPtr*)(page + 4)) <= 0) {
                                    _t946 = 0;
                                    goto L365;
                                } else {
                                    goto L200;
                                }
                            }
                            if(_t1408 == 255) {
                                tmp = searchURIMethods( &(pu.scheme));
                                if(tmp == 0) {
                                    _v412 =  *(parsedURL2Str( &(pu.scheme)));
                                    disp_err_message( *(Sprintf("Unknown URI: %s")), 0);
                                    goto L32;
                                } else {
                                    _v400 = request;
                                    _v404 = flag;
                                    b = loadGeneralFile(tmp->ptr, current, referer);
                                    if(b != 0) {
                                        if(b != 1) {
                                            copyParsedURL(b + 132,  &(pu.scheme));
                                        }
                                    }
                                    _t946 = b;
                                }
                                goto L365;
                            } else {
                            }
                            goto L32;
L79:
                            p = checkHeader(t_buf, "Location:");
                        } while(p != 0 && checkRedirection( &(pu.scheme)) != 0);
                        t = checkContentType(t_buf);
                        if(t == 0 && _v224 != 0 && (http_response_code <= 399 || http_response_code > 407) && (http_response_code <= 499 || http_response_code > 505)) {
                            t = guessContentType(_v224);
                        }
                        if(t == 0) {
                            t = "text/plain";
                        }
                        if(add_auth_cookie_flag != 0 && realm != 0 && uname != 0 && pwd != 0) {
                            add_auth_user_passwd( &(pu.scheme),  *(qstr_unquote(realm)), uname, pwd, 0);
                            add_auth_cookie_flag = 0;
                        }
                        p = checkHeader(t_buf, "WWW-Authenticate:");
                        if(p == 0 || http_response_code != 401 || findAuthentication( &(st.st_dev), t_buf, "WWW-Authenticate:") == 0) {
L114:
                            p = checkHeader(t_buf, "Proxy-Authenticate:");
                            if(p == 0 || http_response_code != 407 || findAuthentication( &(st.st_dev), t_buf, "Proxy-Authenticate:") == 0) {
L127:
                                if((status & 0xff) != 1) {
                                    _v176 = mymktime(checkHeader(t_buf, "Last-Modified:"));
                                    goto L192;
                                }
                            } else {
                                realm = get_auth_param(st.__pad1, "realm");
                                if(realm == 0) {
                                    goto L127;
                                }
                                auth_pu = schemeToProxy(pu.scheme);
                                getAuthCookie( &(st.st_dev), "Proxy-Authorization:", extra_header, auth_pu,  &(hr.command), request,  &uname,  &pwd);
                                if(uname != 0) {
                                    if(ISclose(_v200) == 0) {
                                        _v200 = 0;
                                    }
                                    add_auth_cookie_flag = 1;
                                    status = 0;
                                    continue;
                                } else {
                                    if((TrapSignal & 0xff) != 0) {
                                        if((fmInitialized & 0xff) != 0) {
                                            term_raw();
                                        }
                                        if(prevtrap != 0) {
                                            mySignal(2, prevtrap);
                                        }
                                    }
                                }
                                goto L200;
                            }
                            of =  &(f.scheme);
                            continue;
                        }
                        realm = get_auth_param(st.__pad1, "realm");
                        if(realm == 0) {
                            goto L114;
                        }
                        goto L105;
                    }
                } else {
                    if((TrapSignal & 0xff) != 0) {
                        if((fmInitialized & 0xff) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                }
                break;
            } while();
L200:
            if(page == 0) {
                if(real_type == 0) {
                    real_type = t;
                }
                proc = loadBuffer;
                 *__esp = 40;
                GC_malloc();
                cur_baseURL = loadBuffer;
                _t1496 =  &(pu.scheme);
                copyParsedURL(cur_baseURL, _t1496);
                current_content_length = 0;
                 *135776436 = 0;
                p = checkHeader(t_buf, "Content-Length:");
                if(p != 0) {
                    current_content_length = strtoclen(p);
                     *135776436 = _t1496;
                }
                if(do_download == 0) {
                    if(_v188 == 0 || (AutoUncompress & 0xff) == 0 || (w3m_dump & 8) != 0) {
                        if(_v192 != 0) {
                            if((w3m_dump & 4) != 0 || (w3m_dump & 223) == 0 && is_text_type(t) == 0 && searchExtViewer(t) == 0) {
                                t = compress_application_type(_v192);
                                _v192 = 0;
                            } else {
                                if(t_buf == 0) {
                                    _t1530 = COLS;
                                    if(showLineNum == 0) {
                                        _t1124 = 1;
                                    } else {
                                        _t1124 = 6;
                                    }
                                    _t1125 = _t1530 - _t1124;
                                    _t1126 = _t1125 >= 0 ? 0 : _t1125;
                                    t_buf = newBuffer(_t1125 >= 0 ? 0 : _t1125);
                                }
                                uncompress_stream( &(f.scheme), t_buf + 184);
                                uncompressed_file_type(_v224,  &(( &(f.scheme))[8]));
                            }
                        }
                    } else {
                        uncompress_stream( &(f.scheme),  &(( &(pu.scheme))[6]));
                    }
                    if(image_source == 0) {
                        if(is_html_type(t) == 0) {
                            if(is_plain_text_type(t) == 0) {
                                if(activeImage == 0 || displayImage == 0 || useExtImageViewer != 0 || (w3m_dump & 223) != 0 || strncasecmp(t, "image/", 6) != 0) {
                                    if(w3m_backend != 0) {
                                        goto L324;
                                    }
                                } else {
                                    proc = loadImageBuffer;
L324:
                                    if((flag & 2) != 0) {
                                        if(t_buf == 0) {
                                            _t1513 = COLS;
                                            if(showLineNum == 0) {
                                                _t996 = 1;
                                            } else {
                                                _t996 = 6;
                                            }
                                            _t997 = _t1513 - _t996;
                                            _t998 = _t997 >= 0 ? 0 : _t997;
                                            t_buf = newBuffer(_t997 >= 0 ? 0 : _t997);
                                        }
                                         *(t_buf + 64) = ( *(t_buf + 64) & 65535 | 2) & 65535;
                                    }
                                    frame_source = flag & 4;
                                    _t1463 = t_buf;
                                    _t1497 = proc;
                                    if(_v220 == 0) {
                                        _t934 = _v224;
                                    } else {
                                        _t934 = _v220;
                                    }
                                    b = loadSomething( &(f.scheme), _t934, _t1497, _t1463);
                                    if(ISclose(_v200) == 0) {
                                        _v200 = 0;
                                    }
                                    frame_source = 0;
                                    if(b != 0) {
                                        b->real_scheme = f.scheme & 0xff;
                                        b->real_type = real_type;
                                        if( *((intOrPtr*)(b + 144)) == 0 &&  *((intOrPtr*)(b + 152)) == 0) {
                                            copyParsedURL(b + 132,  &(pu.scheme));
                                        }
                                        if(is_html_type(t) == 0) {
                                            if(w3m_backend == 0) {
                                                if(proc != loadImageBuffer) {
                                                    b->type = "text/plain";
                                                } else {
                                                    b->type = "text/html";
                                                }
                                            } else {
                                                s = Strnew_charp(t);
                                                b->type = s->ptr;
                                            }
                                        } else {
                                            b->type = "text/html";
                                        }
                                        if(_v212 != 0) {
                                            if(proc != loadHTMLBuffer) {
                                                l = atoi(_v212);
                                                gotoRealLine(b, l);
                                                b->pos = 0;
                                                arrangeCursor(b);
                                            } else {
                                                a = searchURLLabel(b, _v212);
                                                if(a != 0) {
                                                    gotoLine(b,  *(a + 20));
                                                    if(label_topline != 0) {
                                                        b->topLine = lineSkip(b, b->topLine, b->currentLine->linenumber - b->topLine->linenumber, 0);
                                                    }
                                                    b->pos =  *(a + 24);
                                                    arrangeCursor(b);
                                                }
                                            }
                                        }
                                    }
                                    if(header_string != 0) {
                                        header_string = 0;
                                    }
                                    if((f.scheme & 0xff) == 7 || (f.scheme & 0xff) == 9) {
                                        reAnchorNewsheader(b);
                                    }
                                    preFormUpdateBuffer(b);
                                    if((TrapSignal & 0xff) != 0) {
                                        if((fmInitialized & 0xff) != 0) {
                                            term_raw();
                                        }
                                        if(prevtrap != 0) {
                                            mySignal(2, prevtrap);
                                        }
                                    }
                                    _t946 = b;
                                    goto L365;
                                }
                                if((w3m_dump & 223) == 0 || is_dump_text_type(t) != 0) {
                                    if(do_download != 0) {
L305:
                                        if((TrapSignal & 0xff) != 0) {
L306:
                                            if((fmInitialized & 0xff) != 0) {
                                                term_raw();
                                            }
                                            if(prevtrap != 0) {
                                                mySignal(2, prevtrap);
                                            }
                                        }
                                        if(pu.scheme != 4) {
                                            if((DecodeCTE & 0xff) != 0 && (_v200->base.stream.cur & 0xff) != 4) {
                                                _v200 = newEncodedStream(_v200, _v202 & 0xff);
                                            }
                                            _v384 = guess_save_name(t_buf, _v224);
                                             *__esp = f.scheme;
                                            _v412 = _v200;
                                            _v408 = _v196;
                                            _v404 = _v192;
                                            _v400 = _v188;
                                            _v396 = _v184;
                                            _v392 = _v180;
                                            _v388 = _v176;
                                            if(doFileSave() != 0) {
                                                if(ISclose(_v200) == 0) {
                                                    _v200 = 0;
                                                }
                                            } else {
                                                UFhalfclose( &(f.scheme));
                                            }
                                        } else {
                                            if(ISclose(_v200) == 0) {
                                                _v200 = 0;
                                            }
                                            _doFileCopy(_v220,  *(wc_Str_conv(Strnew_charp(guess_save_name(0, _v220)), SystemCharset, InnerCharset)), 1);
                                        }
                                        _t946 = 1;
                                        goto L365;
                                    }
                                } else {
                                    if((w3m_dump & 32) == 0) {
                                        goto L324;
                                    }
                                    _t946 = 0;
                                    goto L365;
                                }
                                _t1468 = t_buf;
                                _t1518 = t;
                                if(_v220 == 0) {
                                    _t1040 = _v224;
                                } else {
                                    _t1040 = _v220;
                                }
                                _v372 = _t1468;
                                _v376 =  &b;
                                _v380 = _t1518;
                                _v384 = _t1040;
                                 *__esp = f.scheme;
                                _v412 = _v200;
                                _v408 = _v196;
                                _v404 = _v192;
                                _v400 = _v188;
                                _v396 = _v184;
                                _v392 = _v180;
                                _v388 = _v176;
                                if(doExternal() == 0) {
                                    goto L305;
                                } else {
                                    if(b != 0 && b != 1) {
                                        b->real_scheme = f.scheme & 0xff;
                                        b->real_type = real_type;
                                        if( *((intOrPtr*)(b + 144)) == 0 &&  *((intOrPtr*)(b + 152)) == 0) {
                                            copyParsedURL(b + 132,  &(pu.scheme));
                                        }
                                    }
                                    if(ISclose(_v200) == 0) {
                                        _v200 = 0;
                                    }
                                    if((TrapSignal & 0xff) != 0) {
                                        if((fmInitialized & 0xff) != 0) {
                                            term_raw();
                                        }
                                        if(prevtrap != 0) {
                                            mySignal(2, prevtrap);
                                        }
                                    }
                                    _t946 = b;
                                    goto L365;
                                }
                                goto L306;
                            }
                            goto L277;
                        }
                        goto L275;
L277:
                        proc = loadBuffer;
                        goto L324;
                    } else {
                        b = 0;
                        if((_v200->base.stream.cur & 0xff) != 4) {
                            _v200 = newEncodedStream(_v200, _v202 & 0xff);
                        }
                        _v384 = image_source;
                         *__esp = f.scheme;
                        _v412 = _v200;
                        _v408 = _v196;
                        _v404 = _v192;
                        _v400 = _v188;
                        _v396 = _v184;
                        _v392 = _v180;
                        _v388 = _v176;
                        if(save2tmp() == 0) {
                            _t1523 = COLS;
                            if(showLineNum == 0) {
                                _t1102 = 1;
                            } else {
                                _t1102 = 6;
                            }
                            _t1103 = _t1523 - _t1102;
                            _t1104 = _t1103 >= 0 ? 0 : _t1103;
                            b = newBuffer(_t1103 >= 0 ? 0 : _t1103);
                            b->sourcefile = image_source;
                            b->real_type = t;
                        }
                        if(ISclose(_v200) == 0) {
                            _v200 = 0;
                        }
                        if((TrapSignal & 0xff) != 0) {
                            if((fmInitialized & 0xff) != 0) {
                                term_raw();
                            }
                            if(prevtrap != 0) {
                                mySignal(2, prevtrap);
                            }
                        }
                        _t946 = b;
                        goto L365;
                    }
L275:
                    proc = loadHTMLBuffer;
                    goto L324;
                } else {
                    if((TrapSignal & 0xff) != 0) {
                        if((fmInitialized & 0xff) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                    if((DecodeCTE & 0xff) != 0 && (_v200->base.stream.cur & 0xff) != 4) {
                        _v200 = newEncodedStream(_v200, _v202 & 0xff);
                    }
                    if(pu.scheme != 4) {
                        file = guess_save_name(t_buf, _v224);
                    } else {
                        if((PreserveTimestamp & 0xff) != 0) {
                            _t1163 = _v220;
                            __stat(_t1163,  &(st.st_dev));
                            if(_t1163 == 0) {
                                _v176 = st.st_mtim;
                            }
                        }
                        file =  *(wc_Str_conv(Strnew_charp(guess_save_name(0, _v220)), SystemCharset, InnerCharset));
                    }
                    _v384 = file;
                     *__esp = f.scheme;
                    _v412 = _v200;
                    _v408 = _v196;
                    _v404 = _v192;
                    _v400 = _v188;
                    _v396 = _v184;
                    _v392 = _v180;
                    _v388 = _v176;
                    if(doFileSave() != 0) {
                        if(ISclose(_v200) == 0) {
                            _v200 = 0;
                        }
                    } else {
                        UFhalfclose( &(f.scheme));
                    }
                    _t946 = 1;
                    goto L365;
                }
            }
            if(image_source == 0) {
                tmp = tmpfname(1, ".html");
                src = fopen(tmp->ptr, "w");
                if(src != 0) {
                    s = wc_Str_conv_strict(page, InnerCharset, charset);
                    fwrite(s->ptr, 1, s->length, src);
                    fclose(src);
                }
                if(do_download == 0) {
                    b = loadHTMLString(page);
                    if(b != 0) {
                        copyParsedURL(b + 132,  &(pu.scheme));
                        b->real_scheme = pu.scheme;
                        b->real_type = t;
                        if(src != 0) {
                            b->sourcefile = tmp->ptr;
                        }
                         *(b + 208) = charset;
                    }
                    _t946 = b;
                } else {
                    if(src != 0) {
                        file = guess_filename(_v224);
                        if((f.scheme & 0xff) == 1) {
                            _v412 = file;
                            file =  *(Sprintf("%s.html"));
                        }
                        if((f.scheme & 0xff) == 10) {
                            _v412 = file;
                            file =  *(Sprintf("%s.html"));
                        }
                        doFileMove(tmp->ptr, file);
                        _t946 = 1;
                    } else {
                        _t946 = 0;
                    }
                }
            } else {
                _t946 = 0;
            }
            goto L365;
        }
    }
}

char* has_hidden_link(struct readbuffer* obuf, int cmd)
{// addr = 0x0805FA4E  --  defined in 'file.c' at line 2293
    Str line;              // _cfa_fffffff8
    struct link_stack* p;   // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    _unknown_ _t50;                        // _t50
    _unknown_ _t55;                        // _t55

    line = obuf->line;
    if(line->length <= 0 || ( *(line->ptr + line->length - 1) & 0xff) != 62) {
        return 0;
    }
    p = link_stack;
    while(p != 0) {
        if(p->cmd == cmd) {
            goto L9;
        }
        p = p->next;
        continue;
L9:
        if(p != 0) {
            if((obuf->pos & 0xffff) != (p->pos & 0xffff)) {
                return 0;
            }
            goto L12;
            return __eax;
        }
        return 0;
L12:
        asm("cwde ");
        return  &(line->ptr[p->offset & 65535]);
    }
    goto L9;
}

push_link(int cmd, int offset, int pos)
{// addr = 0x0805FAE4  --  defined in 'file.c' at line 2314
    struct link_stack* p;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

     *__esp = 12;
    GC_malloc();
    p = __eax;
    p->cmd = cmd;
    p->offset = offset & 65535;
    p->pos = pos & 65535;
    p->next = link_stack;
    link_stack = p;
    return;
}

int is_period_char(unsigned char* ch)
{// addr = 0x0805FB2F  --  defined in 'file.c' at line 2326
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    if(( *ch & 0xff) - 33 <= 92) {
        goto __eax;
    }
    return 0;
}

int is_beginning_char(unsigned char* ch)
{// addr = 0x0805FB5A  --  defined in 'file.c' at line 2346
    _unknown_ __ebp;                       // r6
    signed int _t5;                        // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7

    _t5 =  *ch & 0xff;
    if(_t5 == 91) {
L7:
        return 1;
    }
    if(_t5 > 91) {
        if(_t5 == 96 || _t5 == 123) {
            goto L7;
        }
        goto L8;
    }
    if(_t5 == 40 || _t5 == 60) {
        goto L7;
    } else {
    }
L8:
    return 0;
}

int is_word_char(unsigned char* ch)
{// addr = 0x0805FB94  --  defined in 'file.c' at line 2361
    Lineprop ctype;   // _cfa_fffffffa
    _unknown_ __ebp;                       // r6
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    _unknown_ _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    _unknown_ _t52;                        // _t52

    ctype = ( *( &WTF_TYPE_MAP + ( *ch & 0xff)) & 0xff) << 8 & 65535;
    if((ctype & 0x1900) == 0) {
        if((ctype & 0x600) == 0) {
            if(( *( &MYCTYPE_MAP + ( *ch & 0xff)) & 0xc) == 0) {
                if(( *ch & 0xff) - 34 > 92) {
                    if(( *ch & 0xff) != 160) {
                        return 0;
                    }
                    goto L9;
                }
                goto L7;
L9:
                return 1;
            }
            goto L5;
L7:
            goto __eax;
        }
        goto L3;
L5:
        return 1;
    }
    return 0;
L3:
    return 1;
}

int is_combining_char(unsigned char* ch)
{// addr = 0x0805FC36  --  defined in 'file.c' at line 2408
    Lineprop ctype;   // _cfa_fffffffa
    _unknown_ __ebp;                       // r6
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20

    ctype = ( *( &WTF_TYPE_MAP + ( *ch & 0xff)) & 0xff) << 8 & 65535;
    if((ctype & 0x400) == 0) {
        return 0;
    }
    return 1;
}

int is_boundary(unsigned char* ch1, unsigned char* ch2)
{// addr = 0x0805FC71  --  defined in 'file.c' at line 2419
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    _unknown_ _t39;                        // _t39
    _unknown_ _t42;                        // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t46;                        // _t46
    _unknown_ _t49;                        // _t49
    _unknown_ _t52;                        // _t52

    if(( *ch1 & 0xff) == 0 || ( *ch2 & 0xff) == 0) {
        return 1;
    }
    if(( *ch1 & 0xff) != 32) {
L6:
        if(( *ch1 & 0xff) == 32 || is_period_char(ch2) == 0) {
            if(( *ch2 & 0xff) == 32 || is_beginning_char(ch1) == 0) {
                if(is_combining_char(ch2) == 0) {
                    if(is_word_char(ch1) == 0 || is_word_char(ch2) == 0) {
                        return 1;
                    }
                    return 0;
                }
            } else {
                return 0;
            }
            return 0;
        }
        return 0;
    } else {
        if(( *ch2 & 0xff) != 32) {
            goto L6;
        } else {
            return 0;
        }
    }
}

set_breakpoint(struct readbuffer* obuf, int tag_length)
{// addr = 0x0805FD35  --  defined in 'file.c' at line 2445
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t105;                       // _t105

     *((intOrPtr*)(obuf + 192)) = obuf->line->length;
     *(obuf + 188) = obuf->pos & 0xffff;
     *(obuf + 196) = tag_length;
     *(obuf + 200) = obuf->flag;
     *(obuf + 282) = obuf->top_margin & 0xffff;
     *(obuf + 284) = obuf->bottom_margin & 0xffff;
    if(( *(obuf + 280) & 0xff) != 0) {
        bcopy(obuf + 72, obuf + 204, 60);
         *((intOrPtr*)(obuf + 264)) =  *((intOrPtr*)(obuf + 132));
         *(obuf + 268) = obuf->fontstat & 0xff;
         *(obuf + 270) = obuf->fontstat[2] & 0xff;
         *(obuf + 269) = obuf->fontstat[1] & 0xff;
         *(obuf + 271) = obuf->fontstat[3] & 0xff;
         *(obuf + 272) = obuf->fontstat[4] & 0xff;
         *(obuf + 276) = obuf->nobr_level & 0xffff;
         *(obuf + 278) =  *(obuf + 184) & 0xffff;
         *(obuf + 280) = 0;
        return;
    }
    return;
}

back_to_breakpoint(struct readbuffer* obuf)
{// addr = 0x0805FE7C  --  defined in 'file.c' at line 2474
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t80;                        // _t80

    obuf->flag =  *(obuf + 200);
    bcopy(obuf + 204, obuf + 72, 60);
     *((intOrPtr*)(obuf + 132)) =  *((intOrPtr*)(obuf + 264));
    obuf->fontstat =  *(obuf + 268) & 0xff;
    obuf->fontstat[2] =  *(obuf + 270) & 0xff;
    obuf->fontstat[1] =  *(obuf + 269) & 0xff;
    obuf->fontstat[3] =  *(obuf + 271) & 0xff;
    obuf->fontstat[4] =  *(obuf + 272) & 0xff;
     *(obuf + 184) =  *(obuf + 278) & 0xffff;
    obuf->pos =  *(obuf + 188) & 65535;
    obuf->top_margin =  *(obuf + 282) & 0xffff;
    obuf->bottom_margin =  *(obuf + 284) & 0xffff;
    if((obuf->flag & 128) != 0) {
        obuf->nobr_level =  *(obuf + 276) & 0xffff;
        return;
    }
    return;
}

append_tags(struct readbuffer* obuf)
{// addr = 0x0805FF94  --  defined in 'file.c' at line 2494
    int i;                                 // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int set_bp;                            // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t60;                              // _t60
    int _t74;                              // _t74

    len =  *(obuf->line + 4);
    set_bp = 0;
    i = 0;
    while(obuf->tag_sp > i) {
        _t60 = ( *(obuf + (i + 72) * 4))[1];
        if(_t60 == 65) {
L9:
            push_link(( *(obuf + (i + 72) * 4))[1],  *(obuf->line + 4), obuf->pos & 0xffff);
            goto L10;
        }
        if(_t60 > 65) {
            if(_t60 == 109 || _t60 == 136 || _t60 == 105) {
                goto L9;
            }
            goto L10;
        }
        if(_t60 == 1 || _t60 == 7) {
            goto L9;
        }
L10:
        Strcat_charp(obuf->line,  *((char**)( *(obuf + (i + 72) * 4))));
        _t74 = ( *(obuf + (i + 72) * 4))[1];
        if(_t74 == 50) {
            if((obuf->nobr_level & 0xffff) > 1) {
                goto L15;
            }
            goto L14;
        }
        if(_t74 == 69) {
            goto L14;
        } else {
L16:
            i = i + 1;
            continue;
        }
L15:
        goto L16;
L14:
        set_bp = 1;
        goto L16;
    }
    obuf->tag_sp = 0;
    if(set_bp == 0) {
        return;
    }
    set_breakpoint(obuf, obuf->line->length - len);
    return;
}

push_tag(struct readbuffer* obuf, char* cmdname, int cmd)
{// addr = 0x080600BA  --  defined in 'file.c' at line 2527
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    _t31 = obuf;
     *__esp = 8;
    GC_malloc();
     *(obuf + (_t31->tag_sp + 72) * 4) = obuf;
     *((char**)( *(obuf + (obuf->tag_sp + 72) * 4))) = allocStr(cmdname, -1);
    ( *(obuf + (obuf->tag_sp + 72) * 4))[1] = cmd;
    obuf->tag_sp = obuf->tag_sp + 1;
    if(obuf->tag_sp > 9 || (obuf->flag & 527) != 0) {
        append_tags(obuf);
        return;
    }
    return;
}

push_nchars(struct readbuffer* obuf, int width, char* str, int len, Lineprop mode)
{// addr = 0x08060163  --  defined in 'file.c' at line 2538
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v16 = _a20 & 65535;
    append_tags(obuf);
    Strcat_charp_n(obuf->line, str, len);
    obuf->pos = (obuf->pos & 65535) + width & 65535;
    if(width > 0) {
        Strcopy_charp_n( *(obuf + 8), str, len);
         *(obuf + 184) = _v16 & 0xffff;
    }
    obuf->flag = obuf->flag;
    return;
}

check_breakpoint(struct readbuffer* obuf, int pre_mode, char* ch)
{// addr = 0x080601F1  --  defined in 'file.c' at line 2558
    int tlen;                              // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    len = obuf->line->length;
    append_tags(obuf);
    if(pre_mode != 0) {
        goto L5;
    }
    tlen = obuf->line->length - len;
    if(tlen > 0 || is_boundary( *( *(obuf + 8)), ch) != 0) {
        set_breakpoint(obuf, tlen);
        return;
    }
L5:
    return;
}

push_char(struct readbuffer* obuf, int pre_mode, char ch)
{// addr = 0x08060259  --  defined in 'file.c' at line 2573
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    struct _Str* _t65;    // _t65
    int _t89;                              // _t89

    _v16 = _a12 & 255;
    check_breakpoint(obuf, pre_mode,  &_v16);
    if(obuf->line->length + 1 >= obuf->line->area_size) {
        Strgrow(obuf->line);
    }
    _t65 = obuf->line;
    _t89 = _t65->length;
     *( *(obuf->line) + _t89) = _v16 & 0xff;
    _t65->length = _t89 + 1;
     *((char*)( *(obuf->line) + obuf->line->length)) = 0;
    obuf->pos = (obuf->pos & 65535) + 1 & 65535;
    Strcopy_charp_n( *(obuf + 8),  &_v16, 1);
    if((_v16 & 0xff) != 32) {
         *((short*)(obuf + 184)) = 0;
    }
    obuf->flag = obuf->flag;
    return;
}

push_spaces(struct readbuffer* obuf, int pre_mode, int width)
{// addr = 0x08060330  --  defined in 'file.c' at line 2587
    int i;                                 // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct _Str* _t58;    // _t58
    int _t80;                              // _t80

    if(width > 0) {
        check_breakpoint(obuf, pre_mode, " ");
        i = 0;
        while(i < width) {
            if(obuf->line->length + 1 >= obuf->line->area_size) {
                Strgrow(obuf->line);
            }
            _t58 = obuf->line;
            _t80 = _t58->length;
             *((char*)( *(obuf->line) + _t80)) = 32;
            _t58->length = _t80 + 1;
             *( *(obuf->line) + obuf->line->length) = 0;
            i = i + 1;
        }
        obuf->pos = (obuf->pos & 65535) + width & 65535;
        Strcopy_charp_n( *(obuf + 8), " ", 1);
        obuf->flag = obuf->flag;
        return;
    }
    return;
}

proc_mchar(struct readbuffer* obuf, int pre_mode, int width, char** str, Lineprop mode)
{// addr = 0x08060416  --  defined in 'file.c' at line 2602
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v16 = _a20 & 65535;
    check_breakpoint(obuf, pre_mode,  *str);
    obuf->pos = (obuf->pos & 65535) + width & 65535;
    Strcat_charp_n(obuf->line,  *str,  *( &WTF_LEN_MAP + ( *( *str) & 0xff)) & 0xff);
    if(width > 0) {
        Strcopy_charp_n( *(obuf + 8),  *str, 1);
        if(( *( *str) & 0xff) != 32) {
             *(obuf + 184) = _v16 & 0xffff;
        }
    }
     *str =  &(( *str)[ *( &WTF_LEN_MAP + ( *( *str) & 0xff)) & 0xff]);
    obuf->flag = obuf->flag;
    return;
}

push_render_image(Str str, int width, int limit, struct html_feed_environ* h_env)
{// addr = 0x080604F8  --  defined in 'file.c' at line 2618
    struct readbuffer* obuf;   // _cfa_fffffff0
    int indent;                            // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    obuf = h_env->obuf;
    indent =  &(h_env->envs[h_env->envc])->indent & 0xff;
    push_spaces(obuf, 1, (limit - width >> 31) + limit - width >> 1);
    push_nchars(obuf, width, str->ptr, str->length, 0);
    push_spaces(obuf, 1, (limit - width + 1 >> 31) + limit - width + 1 >> 1);
    if(width > 0) {
        flushline(h_env, obuf, indent, 0, h_env->limit);
        return;
    }
    return;
}

int sloppy_parse_line(char** str)
{// addr = 0x080605DF  --  defined in 'file.c' at line 2632
    _unknown_ __ebp;                       // r6
    _unknown_ _t36;                        // _t36

    if(( *( *str) & 0xff) != 60) {
        while(1) {
            str =  *str;
            __eax =  *( *str) & 255;
            if(( *( *str) & 0xff) == 0) {
                break;
            }
            str =  *str;
            __eax =  *( *str) & 255;
            if(( *( *str) & 0xff) != 60) {
                str =  *str;
                __eax = str;
                 *str =  &(( *str)[1]);
                continue;
            }
            break;
        }
        __eax = 0;
        return 0;
    }
    while(( *( *str) & 0xff) != 0 && ( *( *str) & 0xff) != 62) {
         *str =  &(( *str)[1]);
    }
    if(( *( *str) & 0xff) == 62) {
         *str =  &(( *str)[1]);
    }
    return 1;
}

passthrough(struct readbuffer* obuf, char* str, int back)
{// addr = 0x08060664  --  defined in 'file.c' at line 2649
    int cmd;                               // _cfa_fffffff0
    Str tok;               // _cfa_ffffffec
    char* str_bak;                         // _cfa_ffffffe8
    Str str_save;          // _cfa_ffffffe4
    char* q;                               // _cfa_ffffffe0
    struct link_stack* p;   // _cfa_ffffffdc
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t58;                        // _t58

    tok = Strnew();
    if(back != 0) {
        str_save = Strnew_charp(str);
        Strshrink(obuf->line, obuf->line->ptr + obuf->line->length - str);
        str = str_save->ptr;
    }
    while(( *str & 0xff) != 0) {
        str_bak = str;
        if(sloppy_parse_line( &str) == 0) {
L11:
            push_nchars(obuf, 0, str_bak, str - str_bak,  *(obuf + 184) & 0xffff);
            continue;
        }
        q = str_bak;
        cmd = gethtmlcmd( &q);
        if(back == 0) {
            Strcat_charp_n(tok, str_bak, str - str_bak);
            push_tag(obuf, tok->ptr, cmd);
            Strclear(tok);
            continue;
        }
        p = link_stack;
        while(p != 0) {
            if(p->cmd != cmd) {
                p = p->next;
                continue;
            }
            link_stack = p->next;
            break;
        }
        back = 0;
    }
    return;
}

fillline(struct readbuffer* obuf, int indent)
{// addr = 0x080607D1  --  defined in 'file.c' at line 2708
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    push_spaces(obuf, 1, indent - (obuf->pos & 65535));
    obuf->flag = obuf->flag;
    return;
}

flushline(struct html_feed_environ* h_env, struct readbuffer* obuf, int indent, int force, int width)
{// addr = 0x08060812  --  defined in 'file.c' at line 2715
    struct html_feed_environ h;   // _cfa_ffffff54
    struct readbuffer o;   // _cfa_fffffe04
    struct environment[0] e;   // _cfa_ffffff84
    TextLineList* buf;   // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    Str line;              // _cfa_ffffffe8
    Str pass;              // _cfa_ffffffe4
    char* hidden_anchor;                   // _cfa_ffffffe0
    char* hidden_img;                      // _cfa_ffffffdc
    char* hidden_bold;                     // _cfa_ffffffd8
    char* hidden_under;                    // _cfa_ffffffd4
    char* hidden_italic;                   // _cfa_ffffffd0
    char* hidden_strike;                   // _cfa_ffffffcc
    char* hidden_ins;                      // _cfa_ffffffc8
    char* hidden;                          // _cfa_ffffffc4
    char* tp;                              // _cfa_ffffffc0
    char* ep;                              // _cfa_ffffffbc
    int i;                                 // _cfa_ffffffb8
    TextLine* lbuf;   // _cfa_ffffffb4
    char* p;                               // _cfa_ffffffb0
    char* q;                               // _cfa_ffffffac
    Str tmp;               // _cfa_ffffffa8
    Str tmp2;              // _cfa_ffffffa4
    int i;                                 // _cfa_ffffffa0
    Str tmp;               // _cfa_ffffff9c
    char* c;                               // _cfa_ffffff98
    Str tmp;               // _cfa_ffffff94
    struct environment[0] e;   // _cfa_ffffff84
    struct html_feed_environ h;   // _cfa_ffffff54
    struct readbuffer o;   // _cfa_fffffe04
    _unknown_ _v516;                       // _cfa_fffffdfc
    _unknown_ _v520;                       // _cfa_fffffdf8
    _unknown_ _v524;                       // _cfa_fffffdf4
    _unknown_ _v528;                       // _cfa_fffffdf0
    _unknown_ _v532;                       // _cfa_fffffdec
    signed int _v536;                      // _cfa_fffffde8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t802;                             // _t802
    struct _Str* _t850;   // _t850
    struct _Str* _t872;   // _t872
    struct _Str* _t876;   // _t876
    _unknown_ _t878;                       // _t878
    _unknown_ _t880;                       // _t880
    _unknown_ _t922;                       // _t922
    _unknown_ _t932;                       // _t932
    struct _Str* _t954;   // _t954
    _unknown_ _t1000;                      // _t1000
    int _t1056;                            // _t1056
    int _t1089;                            // _t1089
    int _t1102;                            // _t1102

    buf = h_env->buf;
    f = h_env->f;
    line = obuf->line;
    pass = 0;
    hidden_anchor = 0;
    hidden_img = 0;
    hidden_bold = 0;
    hidden_under = 0;
    hidden_italic = 0;
    hidden_strike = 0;
    hidden_ins = 0;
    hidden = 0;
    if((obuf->flag & 527) == 0) {
        if(line->length > 0) {
            if(( *(line->ptr + line->length - 1) & 0xff) == 32) {
                Strshrink(line, 1);
                obuf->pos = (obuf->pos & 65535) - 1 & 65535;
            }
        }
    }
    append_tags(obuf);
    if( *(obuf + 72) != 0) {
        hidden_anchor = has_hidden_link(obuf, 1);
        hidden = hidden_anchor;
    }
    if( *(obuf + 132) != 0) {
        hidden_img = has_hidden_link(obuf, 136);
        if(hidden_img != 0) {
            if(hidden == 0 || hidden_img < hidden) {
                hidden = hidden_img;
            }
        }
    }
    if((obuf->fontstat & 0xff) != 0) {
        hidden_bold = has_hidden_link(obuf, 7);
        if(hidden_bold != 0) {
            if(hidden == 0 || hidden_bold < hidden) {
                hidden = hidden_bold;
            }
        }
    }
    if((obuf->fontstat[2] & 0xff) != 0) {
        hidden_italic = has_hidden_link(obuf, 109);
        if(hidden_italic != 0) {
            if(hidden == 0 || hidden_italic < hidden) {
                hidden = hidden_italic;
            }
        }
    }
    if((obuf->fontstat[1] & 0xff) != 0) {
        hidden_under = has_hidden_link(obuf, 65);
        if(hidden_under != 0) {
            if(hidden == 0 || hidden_under < hidden) {
                hidden = hidden_under;
            }
        }
    }
    if((obuf->fontstat[3] & 0xff) != 0) {
        hidden_strike = has_hidden_link(obuf, 105);
        if(hidden_strike != 0) {
            if(hidden == 0 || hidden_strike < hidden) {
                hidden = hidden_strike;
            }
        }
    }
    if((obuf->fontstat[4] & 0xff) != 0) {
        hidden_ins = has_hidden_link(obuf, 63);
        if(hidden_ins != 0) {
            if(hidden == 0 || hidden_ins < hidden) {
                hidden = hidden_ins;
            }
        }
    }
    if(hidden != 0) {
        pass = Strnew_charp(hidden);
        Strshrink(line, line->ptr + line->length - hidden);
    }
    if((obuf->flag & 527) == 0) {
        asm("cwde ");
        if((obuf->pos & 65535) > width) {
            tp = line->ptr +  *((intOrPtr*)(obuf + 192)) -  *((intOrPtr*)(obuf + 196));
            ep = line->ptr + line->length;
            asm("cwde ");
            if( *((intOrPtr*)(obuf + 188)) == (obuf->pos & 65535)) {
                if(tp <= ep) {
                    if(line->ptr < tp) {
                        if(( *(tp - 1) & 0xff) == 32) {
                            bcopy(tp, tp - 1, ep - tp + 1);
                            line->length = line->length - 1;
                            obuf->pos = (obuf->pos & 65535) - 1 & 65535;
                        }
                    }
                }
            }
        }
    }
    if( *(obuf + 72) != 0) {
        if(hidden_anchor == 0) {
            Strcat_charp(line, 135043896);
        }
    }
    if( *(obuf + 132) != 0) {
        if(hidden_img == 0) {
            Strcat_charp(line, "</img_alt>");
        }
    }
    if((obuf->fontstat & 0xff) != 0 && hidden_bold == 0) {
        Strcat_charp(line, "</b>");
    }
    if((obuf->fontstat[2] & 0xff) != 0 && hidden_italic == 0) {
        Strcat_charp(line, "</i>");
    }
    if((obuf->fontstat[1] & 0xff) != 0 && hidden_under == 0) {
        Strcat_charp(line, "</u>");
    }
    if((obuf->fontstat[3] & 0xff) != 0 && hidden_strike == 0) {
        Strcat_charp(line, "</s>");
    }
    if((obuf->fontstat[4] & 0xff) != 0 && hidden_ins == 0) {
        Strcat_charp(line, "</ins>");
    }
    if((obuf->top_margin & 0xffff) <= 0) {
L75:
        if(force == 1 || (obuf->flag & 32768) != 0) {
            asm("cwde ");
            lbuf = newTextLine(line, obuf->pos & 65535);
            if((obuf->flag & 112) != 32) {
                if((obuf->flag & 112) != 64) {
                    if((obuf->flag & 112) == 16 && (obuf->flag & 131072) != 0) {
                        align(lbuf, width, 1);
                    }
                } else {
                    align(lbuf, width, 2);
                }
            } else {
                align(lbuf, width, 0);
            }
            if((lbuf->pos & 0xffff) > h_env->maxlimit) {
                h_env->maxlimit = lbuf->pos & 0xffff;
            }
            if(buf == 0) {
                if(f != 0) {
                    if((ExtHalfdump & 0xff) == 0) {
                        _t872 = lbuf->line;
                    } else {
                        _t872 = wc_Str_conv(lbuf->line, InnerCharset, DisplayCharset);
                    }
                    _t1056 = _t872->length;
                    if((ExtHalfdump & 0xff) == 0) {
                        _t876 = lbuf->line;
                    } else {
                        _t876 = wc_Str_conv(lbuf->line, InnerCharset, DisplayCharset);
                    }
                    fwrite( *_t876, 1, _t1056, f);
                    fputc(10, f);
                }
            } else {
                pushValue(buf, lbuf);
            }
            if((obuf->flag & 655) != 0 || (obuf->flag & 32768) != 0) {
                h_env->blank_lines = 0;
            } else {
                h_env->blank_lines =  &(h_env->blank_lines->first);
            }
L120:
            if((obuf->bottom_margin & 0xffff) <= 0) {
L129:
                if((obuf->top_margin & 0xffff) >= 0) {
                    return;
                }
                goto L130;
L169:
L170:
                return;
            }
            init_henv( &(h.obuf),  &(o.line),  &e, 1, 0, width, indent);
            o.line = Strnew_size(width + 20);
            o.pos = obuf->pos & 0xffff;
            o.flag = obuf->flag;
            o.top_margin = 65535;
            o.bottom_margin = 65535;
            Strcat_charp(o.line, "<pre_int>");
            i = 0;
            while(1) {
                asm("cwde ");
                if((_v502 & 65535) <= i) {
                    break;
                }
                if(o.line->length + 1 >= o.line->area_size) {
                    Strgrow(o.line);
                }
                _t850 = o.line;
                _t1089 = _t850->length;
                 *((char*)(o.line->ptr + _t1089)) = 32;
                _t850->length = _t1089 + 1;
                 *(o.line->ptr + o.line->length) = 0;
                i = i + 1;
            }
            Strcat_charp(o.line, "</pre_int>");
            i = 0;
            while(1) {
                asm("cwde ");
                if((obuf->bottom_margin & 65535) <= i) {
                    break;
                }
                flushline(h_env,  &(o.line), indent, force, width);
                i = i + 1;
            }
            goto L129;
L130:
            if((obuf->bottom_margin & 0xffff) >= 0) {
                goto L169;
            }
            obuf->line = Strnew_size(256);
            obuf->pos = 0;
            obuf->top_margin = 0;
            obuf->bottom_margin = 0;
            Strcopy_charp_n( *(obuf + 8), " ", 1);
             *(obuf + 280) = 1;
            obuf->flag = obuf->flag;
            set_breakpoint(obuf, 0);
             *(obuf + 184) = 0;
            link_stack = 0;
            fillline(obuf, indent);
            if(pass != 0) {
                passthrough(obuf, pass->ptr, 0);
            }
            if(hidden_anchor == 0 &&  *(obuf + 72) != 0) {
                if( *(obuf + 116) > 0) {
                     *(obuf + 116) =  ~( *(obuf + 116));
                }
                _v536 =  *(obuf + 116);
                tmp = Sprintf("<A HSEQ="%d" HREF="");
                Strcat_charp(tmp, html_quote( *(obuf + 72)));
                if( *(obuf + 76) != 0) {
                    Strcat_charp(tmp, "" TARGET="");
                    Strcat_charp(tmp, html_quote( *(obuf + 76)));
                }
                if( *(obuf + 80) != 0) {
                    Strcat_charp(tmp, "" REFERER="");
                    Strcat_charp(tmp, html_quote( *(obuf + 80)));
                }
                if( *(obuf + 84) != 0) {
                    Strcat_charp(tmp, "" TITLE="");
                    Strcat_charp(tmp, html_quote( *(obuf + 84)));
                }
                if(( *(obuf + 88) & 0xff) != 0) {
                    c =  *( &HTML_QUOTE_MAP + ( *( &QUOTE_MAP + ( *(obuf + 88) & 0xff)) & 7) * 4);
                    Strcat_charp(tmp, "" ACCESSKEY="");
                    if(c == 0) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t802 = tmp->length;
                         *(tmp->ptr + _t802) =  *(obuf + 88) & 0xff;
                        tmp->length = _t802 + 1;
                         *(tmp->ptr + tmp->length) = 0;
                    } else {
                        Strcat_charp(tmp, c);
                    }
                }
                Strcat_charp(tmp, "">");
                push_tag(obuf, tmp->ptr, 1);
            }
            if(hidden_img == 0 &&  *(obuf + 132) != 0) {
                tmp = Strnew_charp("<IMG_ALT SRC="");
                Strcat_charp(tmp, html_quote( *( *(obuf + 132))));
                Strcat_charp(tmp, "">");
                push_tag(obuf, tmp->ptr, 136);
            }
            if(hidden_bold == 0 && (obuf->fontstat & 0xff) != 0) {
                push_tag(obuf, "<B>", 7);
            }
            if(hidden_italic == 0 && (obuf->fontstat[2] & 0xff) != 0) {
                push_tag(obuf, "<I>", 109);
            }
            if(hidden_under == 0 && (obuf->fontstat[1] & 0xff) != 0) {
                push_tag(obuf, "<U>", 65);
            }
            if(hidden_strike == 0 && (obuf->fontstat[3] & 0xff) != 0) {
                push_tag(obuf, "<S>", 105);
            }
            if(hidden_ins != 0 || (obuf->fontstat[4] & 0xff) == 0) {
            } else {
                push_tag(obuf, "<INS>", 63);
                return;
            }
            goto L170;
        }
        p = line->ptr;
        tmp = Strnew();
        tmp2 = Strnew();
        while(( *p & 0xff) != 0) {
            q = p;
            if(sloppy_parse_line( &p) != 0) {
                Strcat_charp_n(tmp, q, p - q);
                if(force != 2) {
                    Strcat(tmp2, tmp);
                } else {
                    if(buf == 0) {
                        if(f != 0) {
                            fwrite(tmp->ptr, 1, tmp->length, f);
                        }
                    } else {
                        appendTextLine(buf, tmp, 0);
                    }
                }
                Strclear(tmp);
            }
        }
        if(force != 2) {
            if(pass != 0) {
                Strcat(tmp2, pass);
            }
            pass = tmp2;
        } else {
            if(pass != 0) {
                if(buf == 0) {
                    if(f != 0) {
                        fwrite(pass->ptr, 1, pass->length, f);
                    }
                } else {
                    appendTextLine(buf, pass, 0);
                }
            }
            pass = 0;
        }
        goto L120;
    }
    init_henv( &(h.obuf),  &(o.line),  &e, 1, 0, width, indent);
    o.line = Strnew_size(width + 20);
    o.pos = obuf->pos & 0xffff;
    o.flag = obuf->flag;
    o.top_margin = 65535;
    o.bottom_margin = 65535;
    Strcat_charp(o.line, "<pre_int>");
    i = 0;
    while(1) {
        asm("cwde ");
        if((_v502 & 65535) <= i) {
            break;
        }
        if(o.line->length + 1 >= o.line->area_size) {
            Strgrow(o.line);
        }
        _t954 = o.line;
        _t1102 = _t954->length;
         *((char*)(o.line->ptr + _t1102)) = 32;
        _t954->length = _t1102 + 1;
         *(o.line->ptr + o.line->length) = 0;
        i = i + 1;
    }
    Strcat_charp(o.line, "</pre_int>");
    i = 0;
    while(1) {
        asm("cwde ");
        if((obuf->top_margin & 65535) <= i) {
            break;
        }
        flushline(h_env,  &(o.line), indent, force, width);
        i = i + 1;
    }
    goto L75;
}

do_blankline(struct html_feed_environ* h_env, struct readbuffer* obuf, int indent, int indent_incr, int width)
{// addr = 0x08061711  --  defined in 'file.c' at line 3029
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(h_env->blank_lines == 0) {
        flushline(h_env, obuf, indent, 1, width);
        return;
    }
    return;
}

purgeline(struct html_feed_environ* h_env)
{// addr = 0x0806174B  --  defined in 'file.c' at line 3037
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(h_env->buf == 0) {
        return;
    }
    if(h_env->blank_lines != 0) {
        p =  *( *(rpopValue(h_env->buf)));
        tmp = Strnew();
        while(( *p & 0xff) != 0) {
            q = p;
            if(sloppy_parse_line( &p) != 0) {
                Strcat_charp_n(tmp, q, p - q);
            }
        }
        appendTextLine(h_env->buf, tmp, 0);
        h_env->blank_lines = h_env->blank_lines - 1;
        return;
    }
    return;
}

int close_effect0(struct readbuffer* obuf, int cmd)
{// addr = 0x08061803  --  defined in 'file.c' at line 3058
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t51;                        // _t51
    _unknown_ _t54;                        // _t54
    _unknown_ _t69;                        // _t69
    _unknown_ _t70;                        // _t70

    i = obuf->tag_sp - 1;
    while(i >= 0) {
        if( *((intOrPtr*)( *((intOrPtr*)(obuf + (i + 72) * 4)) + 4)) == cmd) {
            goto L6;
        }
        i = i - 1;
        continue;
L6:
        if(i >= 0) {
            p = has_hidden_link(obuf, cmd);
            if(p == 0) {
                return 0;
            }
            goto L9;
        }
        obuf->tag_sp = obuf->tag_sp - 1;
        bcopy( &(( &(obuf->tag_stack))[i + 1]),  &(( &(obuf->tag_stack))[i]), 0 + (obuf->tag_sp - i) * 4);
        return 1;
L9:
        passthrough(obuf, p, 1);
        return 1;
    }
    goto L6;
}

close_anchor(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x080618EE  --  defined in 'file.c' at line 3081
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int is_erased;                         // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t110;                       // _t110
    _unknown_ _t123;                       // _t123
    _unknown_ _t138;                       // _t138
    struct _Str* _t152;   // _t152
    int _t195;                             // _t195

    if( *(obuf + 72) == 0) {
L25:
        bzero(obuf + 72, 60);
        return;
    } else {
        p = 0;
        is_erased = 0;
        i = obuf->tag_sp - 1;
        while(i >= 0) {
            if( *((intOrPtr*)( *((intOrPtr*)(obuf + (i + 72) * 4)) + 4)) != 1) {
                i = i - 1;
                continue;
            }
L7:
            if(i < 0 &&  *((intOrPtr*)(obuf + 116)) > 0 && obuf->line->length > 0 && ( *( *(obuf->line) + obuf->line->length - 1) & 0xff) == 32) {
                Strshrink(obuf->line, 1);
                obuf->pos = (obuf->pos & 65535) - 1 & 65535;
                is_erased = 1;
            }
            if(i >= 0) {
L14:
                if( *((intOrPtr*)(obuf + 116)) <= 0) {
                    if(i >= 0) {
                        passthrough(obuf, p, 1);
                    } else {
                        obuf->tag_sp = obuf->tag_sp - 1;
                        bcopy( &(obuf->tag_stack) + (i + 1 << 2),  &(obuf->tag_stack) + (i << 2), 0 + (obuf->tag_sp - i) * 4);
                    }
                    bzero(obuf + 72, 60);
                    return;
                }
            } else {
                p = has_hidden_link(obuf, 1);
                if(p == 0) {
L20:
                    if(is_erased != 0) {
                        if(obuf->line->length + 1 >= obuf->line->area_size) {
                            Strgrow(obuf->line);
                        }
                        _t152 = obuf->line;
                        _t195 = _t152->length;
                         *((char*)( *(obuf->line) + _t195)) = 32;
                        _t152->length = _t195 + 1;
                         *( *(obuf->line) + obuf->line->length) = 0;
                        obuf->pos = (obuf->pos & 65535) + 1 & 65535;
                    }
                    push_tag(obuf, 135043896, 2);
                    goto L25;
                }
                goto L14;
            }
            HTMLlineproc0(135044067, h_env, 1);
            Strcopy_charp_n( *(obuf + 8), " ", 1);
            is_erased = 0;
            goto L20;
        }
        goto L7;
    }
    return;
}

save_fonteffect(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x08061B5C  --  defined in 'file.c' at line 3128
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t70;                        // _t70
    _unknown_ _t84;                        // _t84

    if(obuf->fontstat_sp <= 4) {
        bcopy( &(obuf->fontstat),  &(obuf->fontstat_stack) + (obuf->fontstat_sp << 3) - obuf->fontstat_sp, 7);
    }
    obuf->fontstat_sp = obuf->fontstat_sp + 1;
    if((obuf->fontstat & 0xff) != 0) {
        push_tag(obuf, "</b>", 8);
    }
    if((obuf->fontstat[2] & 0xff) != 0) {
        push_tag(obuf, "</i>", 110);
    }
    if((obuf->fontstat[1] & 0xff) != 0) {
        push_tag(obuf, "</u>", 66);
    }
    if((obuf->fontstat[3] & 0xff) != 0) {
        push_tag(obuf, "</s>", 106);
    }
    if((obuf->fontstat[4] & 0xff) != 0) {
        push_tag(obuf, "</ins>", 64);
    }
    bzero( &(obuf->fontstat), 7);
    return;
}

restore_fonteffect(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x08061CA6  --  defined in 'file.c' at line 3148
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t81;                        // _t81

    if(obuf->fontstat_sp > 0) {
        obuf->fontstat_sp = obuf->fontstat_sp - 1;
    }
    if(obuf->fontstat_sp <= 4) {
        bcopy( &(obuf->fontstat_stack) + (obuf->fontstat_sp << 3) - obuf->fontstat_sp,  &(obuf->fontstat), 7);
    }
    if((obuf->fontstat & 0xff) != 0) {
        push_tag(obuf, 135044069, 7);
    }
    if((obuf->fontstat[2] & 0xff) != 0) {
        push_tag(obuf, 135044073, 109);
    }
    if((obuf->fontstat[1] & 0xff) != 0) {
        push_tag(obuf, 135044077, 65);
    }
    if((obuf->fontstat[3] & 0xff) != 0) {
        push_tag(obuf, 135044081, 105);
    }
    if((obuf->fontstat[4] & 0xff) != 0) {
        push_tag(obuf, 135044085, 63);
        return;
    }
    return;
}

Str process_title(struct parsed_tag* tag)
{// addr = 0x08061DEB  --  defined in 'file.c' at line 3168
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3

    cur_title = Strnew();
    return 0;
}

Str process_n_title(struct parsed_tag* tag)
{// addr = 0x08061E02  --  defined in 'file.c' at line 3175
    Str tmp;               // _cfa_fffffff0
    struct _Str* _v32;    // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t11;                            // _t11
    _unknown_ _t14;                        // _t14

    if(cur_title != 0) {
        Strremovefirstspaces(cur_title);
        Strremovetrailingspaces(cur_title);
        _t11 = html_quote(cur_title->ptr);
        _v32 = 0;
        _v36 = "">";
        _v40 = _t11;
        tmp = Strnew_m_charp("<title_alt title="");
        cur_title = 0;
        return tmp;
    }
    return 0;
}

feed_title(char* str)
{// addr = 0x08061E73  --  defined in 'file.c' at line 3190
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    __eax = cur_title;
    if(cur_title == 0) {
        goto L1;
    }
    while(1) {
        str =  *str & 255;
        if(( *str & 0xff) == 0) {
            break;
        }
        str =  *str & 255;
        if(( *str & 0xff) != 38) {
            str =  *str & 255;
            if(( *str & 0xff) == 10) {
L6:
                cur_title = cur_title->length;
                __edx = cur_title->length + 1;
                cur_title = cur_title->area_size;
                if(cur_title->length + 1 >= cur_title->area_size) {
                    __eax = cur_title;
                    Strgrow(cur_title);
                }
                __eax = cur_title;
                __eax = cur_title;
                __edx = __eax->length;
                __edx = __edx + cur_title->ptr;
                 *(__edx + cur_title->ptr) = 32;
                __eax->length = __edx;
                __eax = cur_title;
                __edx = cur_title->ptr;
                cur_title = cur_title->length;
                __eax = cur_title->ptr + cur_title->length;
                 *(cur_title->ptr + cur_title->length) = 0;
                str =  &(str[1]);
                str =  &(str[1]);
            } else {
                str =  *str & 255;
                if(( *str & 0xff) != 13) {
                    cur_title = cur_title->length;
                    __edx = cur_title->length + 1;
                    cur_title = cur_title->area_size;
                    if(cur_title->length + 1 >= cur_title->area_size) {
                        __eax = cur_title;
                        Strgrow(cur_title);
                    }
                    __eax = cur_title;
                    __eax = cur_title;
                    __ecx = __eax->length;
                    __edx = __ecx;
                    __edx = str;
                     *(cur_title->ptr + __ecx) = __edx->ptr & 0xff;
                    __eax->length = __ecx;
                    __eax =  &(__edx->ptr);
                    str =  &(__edx->ptr);
                    __eax = cur_title;
                    __edx = cur_title->ptr;
                    cur_title = cur_title->length;
                    __eax = cur_title->ptr + cur_title->length;
                     *(cur_title->ptr + cur_title->length) = 0;
                } else {
                    goto L6;
                }
            }
        } else {
             &str = getescapecmd( &str);
            __edx = cur_title;
            Strcat_charp(cur_title,  &str);
        }
    }
    return;
L1:
    return;
}

Str process_img(struct parsed_tag* tag, int width)
{// addr = 0x08061FA7  --  defined in 'file.c' at line 3207
    char* p;                               // _cfa_ffffffe0
    char* q;                               // _cfa_ffffffdc
    char* r;                               // _cfa_ffffffd8
    char* r2;                              // _cfa_ffffffd4
    char* s;                               // _cfa_ffffffd0
    char* t;                               // _cfa_ffffffcc
    int w;                                 // _cfa_ffffffc8
    int i;                                 // _cfa_ffffffc4
    int nw;                                // _cfa_ffffffc0
    int ni;                                // _cfa_ffffffbc
    int n;                                 // _cfa_ffffffb8
    int w0;                                // _cfa_ffffffb4
    int i0;                                // _cfa_ffffffb0
    int align;                             // _cfa_ffffffac
    int xoffset;                           // _cfa_ffffffa8
    int yoffset;                           // _cfa_ffffffa4
    int top;                               // _cfa_ffffffa0
    int bottom;                            // _cfa_ffffff9c
    int ismap;                             // _cfa_ffffff98
    int use_image;                         // _cfa_ffffff94
    int pre_int;                           // _cfa_ffffff90
    int ext_pre_int;                       // _cfa_ffffff8c
    Str tmp;               // _cfa_ffffff88
    Str tmp2;              // _cfa_ffffff84
    char* r;                               // _cfa_ffffff80
    ImageCache* _v132;   // _cfa_ffffff7c
    signed int _v154;                      // _cfa_ffffff66
    signed int _v156;                      // _cfa_ffffff64
    char* _v160;                           // _cfa_ffffff60
    Image image;         // _cfa_ffffff5c
    char* _v184;                           // _cfa_ffffff48
    ParsedURL u;     // _cfa_ffffff34
    int _v208;                             // _cfa_ffffff30
    signed int _v210;                      // _cfa_ffffff2e
    signed int _v212;                      // _cfa_ffffff2c
    _unknown_ _v224;                       // _cfa_ffffff20
    int _v228;                             // _cfa_ffffff1c
    int _v232;                             // _cfa_ffffff18
    _unknown_ __ebp;                       // r6
    int _t687;                             // _t687
    _unknown_ _t696;                       // _t696
    _unknown_ _t700;                       // _t700
    _unknown_ _t706;                       // _t706
    _unknown_ _t709;                       // _t709
    int _t716;                             // _t716
    int _t742;                             // _t742
    int _t763;                             // _t763
    int _t784;                             // _t784
    _unknown_ _t797;                       // _t797
    int _t806;                             // _t806
    char* _t836;                           // _t836
    char* _t838;                           // _t838
    signed int _t861;                      // _t861
    signed int _t873;                      // _t873
    int _t891;                             // _t891
    char* _t899;                           // _t899
    signed int _t936;                      // _t936
    int _t977;                             // _t977
    int _t979;                             // _t979
    int _t980;                             // _t980
    int _t1013;                            // _t1013
    char* _t1016;                          // _t1016
    int _t1020;                            // _t1020
    int _t1030;                            // _t1030
    _unknown_ _t1051;                      // _t1051
    int _t1125;                            // _t1125

    r2 = 0;
    ni = 1;
    w0 = -1;
    i0 = -1;
    ismap = 0;
    if(activeImage == 0) {
L3:
        _t687 = 0;
        goto L4;
    }
    if(displayImage == 0) {
        goto L3;
    } else {
        _t687 = 1;
    }
L4:
    use_image = _t687;
    pre_int = 0;
    ext_pre_int = 0;
    tmp = Strnew();
    if(parsedtag_get_value(tag, 31,  &p) == 0) {
        return tmp;
    }
    p = remove_space(p);
    q = 0;
    parsedtag_get_value(tag, 5,  &q);
    t = q;
    parsedtag_get_value(tag, 49,  &t);
    w = -1;
    if(parsedtag_get_value(tag, 38,  &w) != 0) {
        if(w < 0) {
            if(width <= 0) {
                w = -1;
            } else {
                _v208 =  ~width;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53a0]");
                asm("fmulp st1, st0");
                _v208 = w;
                asm("fild dword [ebp+0xffffff34]");
                asm("fmulp st1, st0");
                asm("fld qword [0x80cab78]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80cab80]");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                w = _v208;
            }
        }
        if(use_image != 0) {
            if(w > 0) {
                _v208 = w;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53b0]");
                asm("fmulp st1, st0");
                asm("fld qword [0x80cab78]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80cab80]");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                w = _v208;
                if(w != 0) {
                    if(w > 2048) {
                        w = 2048;
                    }
                } else {
                    w = 1;
                }
            }
        }
    }
    if(use_image == 0) {
        parsedtag_get_value(tag, 17,  &i);
    } else {
        i = -1;
        if(parsedtag_get_value(tag, 17,  &i) != 0) {
            if(i <= 0) {
                i = -1;
            } else {
                _v208 = i;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53b0]");
                asm("fmulp st1, st0");
                asm("fld qword [0x80cab78]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80cab80]");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                i = _v208;
                if(i != 0) {
                    if(i > 2048) {
                        i = 2048;
                    }
                } else {
                    i = 1;
                }
            }
        }
        align = -1;
        parsedtag_get_value(tag, 4,  &align);
        ismap = 0;
        if(tag->map != 0 && (tag->map[0x2e] & 0xff) != 75 && (tag->attrid[tag->map[0x2e] & 0xff] & 0xff) != 0) {
            ismap = 1;
        }
    }
    r = 0;
    parsedtag_get_value(tag, 34,  &r);
    if(tag->map != 0 && (tag->map[0x4a] & 0xff) != 75 && (tag->attrid[tag->map[0x4a] & 0xff] & 0xff) != 0) {
        ext_pre_int = 1;
    }
    tmp = Strnew_size(128);
    if(use_image != 0) {
        _t1030 = align;
        if(_t1030 == 1) {
            Strcat_charp(tmp, "<div_int align=left>");
        } else {
            if(_t1030 == 2) {
                Strcat_charp(tmp, "<div_int align=right>");
            } else {
                if(_t1030 == 0) {
                    Strcat_charp(tmp, "<div_int align=center>");
                }
            }
        }
    }
    if(r == 0) {
L55:
        if(use_image == 0) {
            if(w < 0) {
                asm("fld qword [0x80d53a0]");
                asm("fld qword [0x80cab90]");
                asm("fmulp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                w = _v208;
            }
            if(w == 0) {
                _t716 = 1;
            } else {
                _v208 = w - 1;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53a0]");
                asm("fdivp st1, st0");
                asm("fld1 ");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                _t716 = _v208;
            }
            nw = _t716;
            if(r != 0) {
                Strcat_charp(tmp, "<pre_int>");
                pre_int = 1;
            }
            Strcat_charp(tmp, "<img_alt src="");
        } else {
            w0 = w;
            i0 = i;
            if(w >= 0 || i < 0) {
                parseURL2( *(wc_Str_conv(Strnew_charp(p), InnerCharset, cur_document_charset & 0xff)),  &(u.scheme), cur_baseURL);
                image.url =  *(parsedURL2Str( &(u.scheme)));
                if(uncompressed_file_type(_v184,  &(( &(image.url))[1])) == 0) {
                    _v160 = filename_extension(_v184, 1);
                }
                _v132 = 0;
                _v156 = w & 65535;
                _v154 = i & 65535;
                _v132 = getImage( &(image.url), cur_baseURL, 1);
                if(_v132 != 0 && (_v132->width & 0xffff) > 0 && (_v132->height & 0xffff) > 0) {
                    asm("cwde ");
                    w0 = _v132->width & 65535;
                    w = w0;
                    asm("cwde ");
                    i0 = _v132->height & 65535;
                    i = i0;
                }
                if(w < 0) {
                    asm("fld qword [0x80d53a0]");
                    asm("fld qword [0x80cab88]");
                    asm("fmulp st1, st0");
                    asm("fnstcw word [ebp+0xffffff32]");
                    _v212 = _v210 & 0xffff;
                    asm("fldcw word [ebp+0xffffff30]");
                    asm("fistp dword [ebp+0xffffff34]");
                    asm("fldcw word [ebp+0xffffff32]");
                    w = _v208;
                }
                if(i < 0) {
                    asm("fld qword [0x80d53a8]");
                    asm("fnstcw word [ebp+0xffffff32]");
                    _v212 = _v210 & 0xffff;
                    asm("fldcw word [ebp+0xffffff30]");
                    asm("fistp dword [ebp+0xffffff34]");
                    asm("fldcw word [ebp+0xffffff32]");
                    i = _v208;
                }
            }
            if(w <= 3) {
                _t977 = 1;
            } else {
                _v208 = w - 3;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53a0]");
                asm("fdivp st1, st0");
                asm("fld1 ");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                _t977 = _v208;
            }
            nw = _t977;
            if(i <= 3) {
                _t979 = 1;
            } else {
                _v208 = i - 3;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53a8]");
                asm("fdivp st1, st0");
                asm("fld1 ");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                _t979 = _v208;
            }
            ni = _t979;
            _t980 = cur_iseq;
            cur_iseq = _t980 + 1;
            _v232 = _t980;
            Strcat(tmp, Sprintf("<pre_int><img_alt hseq="%d" src=""));
            pre_int = 1;
        }
        Strcat_charp(tmp, html_quote(p));
        Strcat_charp(tmp, """);
        if(t != 0) {
            Strcat_charp(tmp, " title="");
            Strcat_charp(tmp, html_quote(t));
            Strcat_charp(tmp, """);
        }
        if(use_image == 0) {
L119:
            Strcat_charp(tmp, ">");
            if(q != 0 && ( *q & 0xff) == 0 && ignore_null_img_alt != 0) {
                q = 0;
            }
            if(q == 0) {
L141:
                if(w <= 0 || i <= 0) {
L160:
                    q = p;
L162:
                    while(( *q & 0xff) != 0) {
                        goto L161;
                    }
                    while(q > p && ( *q & 0xff) != 47) {
                        q = q - 1;
                    }
                    if(( *q & 0xff) == 47) {
                        q =  &(q[1]);
                    }
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t742 = tmp->length;
                     *((char*)(tmp->ptr + _t742)) = 91;
                    tmp->length = _t742 + 1;
                     *(tmp->ptr + tmp->length) = 0;
                    n = 1;
                    p = q;
                    while(( *q & 0xff) != 0) {
                        if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 0xc) != 0 || ( *q & 0xff) == 95 || ( *q & 0xff) == 45) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t763 = tmp->length;
                             *(tmp->ptr + _t763) =  *q & 0xff;
                            tmp->length = _t763 + 1;
                             *(tmp->ptr + tmp->length) = 0;
                            n = n + 1;
                            if(n + 1 < nw) {
                                q =  &(q[1]);
                                continue;
                            }
L183:
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t784 = tmp->length;
                             *((char*)(tmp->ptr + _t784)) = 93;
                            tmp->length = _t784 + 1;
                             *(tmp->ptr + tmp->length) = 0;
                            n = n + 1;
                            goto L186;
                        }
                        goto L183;
                    }
                    goto L183;
                } else {
                    if(w > 31 || i > 47) {
                        if(w <= 200 || i > 12) {
                            goto L160;
                        } else {
                            if(pre_int == 0) {
                                Strcat_charp(tmp, "<pre_int>");
                                pre_int = 1;
                            }
                            _v208 = w;
                            asm("fild dword [ebp+0xffffff34]");
                            asm("fld qword [0x80d53a0]");
                            asm("fdivp st1, st0");
                            _v208 = symbol_width;
                            asm("fild dword [ebp+0xffffff34]");
                            asm("fdivp st1, st0");
                            asm("fnstcw word [ebp+0xffffff32]");
                            _v212 = _v210 & 0xffff;
                            asm("fldcw word [ebp+0xffffff30]");
                            asm("fistp dword [ebp+0xffffff34]");
                            asm("fldcw word [ebp+0xffffff32]");
                            w = _v208;
                            if(w <= 0) {
                                w = 1;
                            }
                            push_symbol(tmp, 26, symbol_width, w);
                            n = symbol_width * w;
L186:
                            if(use_image == 0) {
L192:
                                Strcat_charp(tmp, "</img_alt>");
                                if(pre_int != 0 && ext_pre_int == 0) {
                                    Strcat_charp(tmp, "</pre_int>");
                                }
                                if(r != 0) {
                                    Strcat_charp(tmp, "</input_alt>");
                                    process_n_form();
                                }
                                if(use_image != 0 && align <= 2) {
                                    Strcat_charp(tmp, "</div_int>");
                                }
                                return tmp;
                            }
                            while(n < nw) {
                                if(tmp->length + 1 >= tmp->area_size) {
                                    Strgrow(tmp);
                                }
                                _t806 = tmp->length;
                                 *((char*)(tmp->ptr + _t806)) = 32;
                                tmp->length = _t806 + 1;
                                 *(tmp->ptr + tmp->length) = 0;
                                n = n + 1;
                            }
                            goto L192;
                        }
                        goto L161;
                    }
                    n = 1;
                    _t836 = p;
                    _v232 = "space";
                     *__esp = _t836;
                    strcasestr();
                    if(_t836 != 0) {
L147:
                        Strcat_charp(tmp, "_");
                        goto L186;
                    }
                    _t838 = p;
                    _v232 = "blank";
                     *__esp = _t838;
                    strcasestr();
                    if(_t838 == 0) {
                        if(i * w > 127) {
                            if(pre_int == 0) {
                                Strcat_charp(tmp, "<pre_int>");
                                pre_int = 1;
                            }
                            push_symbol(tmp, 44, symbol_width, 1);
                            n = symbol_width;
                        } else {
                            Strcat_charp(tmp, "*");
                        }
                        goto L186;
                    }
                    goto L147;
                }
L161:
                q =  &(q[1]);
                goto L162;
            }
            n = wtf_strwidth(q);
            if(use_image == 0) {
L140:
                Strcat_charp(tmp, html_quote(q));
                goto L186;
            }
            if(n <= nw) {
                Strcat_charp(tmp, html_quote(q));
                goto L186;
            }
            r = q;
            n = 0;
            while(r != 0) {
                if(( *135119023 & 0xff) == 0) {
                    _t861 =  *( &WTF_WIDTH_MAP + ( *r & 0xff)) & 0xff;
                } else {
                    _t861 =  *( &WTF_WIDTH_MAP + ( *r & 0xff)) & 0xff;
                }
                if(_t861 + n <= nw) {
                    r =  &(r[ *( &WTF_LEN_MAP + ( *r & 0xff)) & 0xff]);
                    if(( *135119023 & 0xff) == 0) {
                        _t873 =  *( &WTF_WIDTH_MAP + ( *r & 0xff)) & 0xff;
                    } else {
                        _t873 =  *( &WTF_WIDTH_MAP + ( *r & 0xff)) & 0xff;
                    }
                    n = n + _t873;
                    continue;
                }
L138:
                Strcat_charp(tmp, html_quote( *(Strnew_charp_n(q, r - q))));
                goto L186;
            }
            goto L138;
        } else {
            if(w0 < 0) {
                _v232 = w0;
                Strcat(tmp, Sprintf(" width=%d"));
            }
            if(i0 < 0) {
                _v232 = i0;
                Strcat(tmp, Sprintf(" height=%d"));
            }
            _t891 = align;
            if(_t891 == 5) {
                top = 0;
                bottom = ni - 1;
                yoffset = 0;
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
            } else {
                if(_t891 == 6) {
                    top = ni - 1;
                    bottom = 0;
                    asm("fild dword [ebp-0x40]");
                    asm("fld qword [0x80d53a8]");
                    asm("fmulp st1, st0");
                    _v208 = i;
                    asm("fild dword [ebp+0xffffff34]");
                    asm("fsubp st1, st0");
                    asm("fnstcw word [ebp+0xffffff32]");
                    _v212 = _v210 & 0xffff;
                    asm("fldcw word [ebp+0xffffff30]");
                    asm("fistp dword [ebp-0x58]");
                    asm("fldcw word [ebp+0xffffff32]");
L104:
                    asm("fild dword [ebp-0x3c]");
                    asm("fld qword [0x80d53a0]");
                    asm("fmulp st1, st0");
                    _v208 = w;
                    asm("fild dword [ebp+0xffffff34]");
                    asm("fsubp st1, st0");
                    asm("fld qword [0x80cab98]");
                    asm("fdivp st1, st0");
                    asm("fldcw word [ebp+0xffffff30]");
                    asm("fistp dword [ebp-0x54]");
                    asm("fldcw word [ebp+0xffffff32]");
                    if(xoffset != 0) {
                        _v232 = xoffset;
                        Strcat(tmp, Sprintf(" xoffset=%d"));
                    }
                    if(yoffset != 0) {
                        _v232 = yoffset;
                        Strcat(tmp, Sprintf(" yoffset=%d"));
                    }
                    if(top != 0) {
                        _v232 = top;
                        Strcat(tmp, Sprintf(" top_margin=%d"));
                    }
                    if(bottom != 0) {
                        _v232 = bottom;
                        Strcat(tmp, Sprintf(" bottom_margin=%d"));
                    }
                    if(r != 0) {
                        Strcat_charp(tmp, " usemap="");
                        if(r2 == 0) {
                            _t899 = r;
                        } else {
                            _t899 =  &(r2[1]);
                        }
                        Strcat_charp(tmp, html_quote(_t899));
                        Strcat_charp(tmp, """);
                    }
                    if(ismap != 0) {
                        Strcat_charp(tmp, " ismap");
                    }
                    goto L119;
                }
                if(_t891 == 4) {
                    goto L95;
                }
                top = ni - 1;
                bottom = 0;
                if(ni != 1) {
L102:
                    asm("fild dword [ebp-0x40]");
                    asm("fld qword [0x80d53a8]");
                    asm("fmulp st1, st0");
                    _v208 = i;
                    asm("fild dword [ebp+0xffffff34]");
                    asm("fsubp st1, st0");
                    asm("fnstcw word [ebp+0xffffff32]");
                    _v212 = _v210 & 0xffff;
                    asm("fldcw word [ebp+0xffffff30]");
                    asm("fistp dword [ebp-0x58]");
                    asm("fldcw word [ebp+0xffffff32]");
                    if(yoffset < 255) {
                        yoffset = yoffset + 1;
                    }
                    goto L104;
                }
                asm("fild dword [ebp-0x40]");
                asm("fld qword [0x80d53a8]");
                asm("fmulp st1, st0");
                _t936 = i;
                _v208 = _t936;
                asm("fild dword [ebp+0xffffff34]");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t936 & 255) == 0) {
                    goto L102;
                }
                yoffset = 0;
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
            }
            goto L104;
L95:
            top = (ni >> 31) + ni >> 1;
            bottom = top;
            if(top + top != ni) {
                asm("fild dword [ebp-0x40]");
                asm("fld qword [0x80d53a8]");
                asm("fmulp st1, st0");
                _v208 = i;
                asm("fild dword [ebp+0xffffff34]");
                asm("fsubp st1, st0");
                asm("fld qword [0x80cab98]");
                asm("fdivp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp-0x58]");
                asm("fldcw word [ebp+0xffffff32]");
            } else {
                _v208 = ni + 1;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53a8]");
                asm("fmulp st1, st0");
                _v208 = i;
                asm("fild dword [ebp+0xffffff34]");
                asm("fsubp st1, st0");
                asm("fld qword [0x80cab98]");
                asm("fdivp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 0xffff;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp-0x58]");
                asm("fldcw word [ebp+0xffffff32]");
            }
            goto L104;
        }
    }
    r2 = strchr(r, 35);
    s = "<form_int method=internal action=map>";
    tmp2 = process_form(parse_tag( &s, 1));
    if(tmp2 != 0) {
        Strcat(tmp, tmp2);
    }
    if(form_sp >= 0) {
        _t1013 = -1;
    } else {
        _t1013 = form_stack[form_sp];
    }
    _v232 = _t1013;
    Strcat(tmp, Sprintf("<input_alt fid="%d" type=hidden name=link value=""));
    if(r2 == 0) {
        _t1016 = r;
    } else {
        _t1016 =  &(r2[1]);
    }
    Strcat_charp(tmp, html_quote(_t1016));
    if(form_sp >= 0) {
        _t1020 = -1;
    } else {
        _t1020 = form_stack[form_sp];
    }
    _t1125 = cur_hseq;
    cur_hseq = _t1125 + 1;
    _v228 = _t1020;
    _v232 = _t1125;
    Strcat(tmp, Sprintf(""><input_alt hseq="%d" fid="%d" type=submit no_effect=true>"));
    goto L55;
}

Str process_anchor(struct parsed_tag* tag, char* tagbuf)
{// addr = 0x08063264  --  defined in 'file.c' at line 3524
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t18;                              // _t18
    int _t25;                              // _t25
    _unknown_ _t30;                        // _t30

    if((tag->need_reconstruct & 0xff) == 0) {
        _t18 = cur_hseq;
        cur_hseq = _t18 + 1;
        _v40 = _t18;
        tmp = Sprintf("<a hseq="%d"");
        Strcat_charp(tmp,  &(tagbuf[2]));
        return tmp;
    }
    _t25 = cur_hseq;
    cur_hseq = _t25 + 1;
    _v40 = _t25;
    parsedtag_set_value(tag, 69,  *(Sprintf("%d")));
    return parsedtag2str(tag);
}

Str process_input(struct parsed_tag* tag)
{// addr = 0x080632F6  --  defined in 'file.c' at line 3538
    int i;                                 // _cfa_ffffffe0
    int w;                                 // _cfa_ffffffdc
    int v;                                 // _cfa_ffffffd8
    int x;                                 // _cfa_ffffffd4
    int y;                                 // _cfa_ffffffd0
    int z;                                 // _cfa_ffffffcc
    int iw;                                // _cfa_ffffffc8
    int ih;                                // _cfa_ffffffc4
    char* q;                               // _cfa_ffffffc0
    char* p;                               // _cfa_ffffffbc
    char* r;                               // _cfa_ffffffb8
    char* p2;                              // _cfa_ffffffb4
    char* s;                               // _cfa_ffffffb0
    Str tmp;               // _cfa_ffffffac
    char* qq;                              // _cfa_ffffffa8
    int qlen;                              // _cfa_ffffffa4
    char* s;                               // _cfa_ffffffa0
    int _v112;                             // _cfa_ffffff90
    char* _v128;                           // _cfa_ffffff80
    int _v132;                             // _cfa_ffffff7c
    int _v136;                             // _cfa_ffffff78
    char* _v140;                           // _cfa_ffffff74
    char* _v144;                           // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    int _v152;                             // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    int __edi;                             // r4
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t285;                       // _t285
    _unknown_ _t288;                       // _t288
    _unknown_ _t291;                       // _t291
    _unknown_ _t294;                       // _t294
    _unknown_ _t297;                       // _t297
    _unknown_ _t300;                       // _t300
    int _t303;                             // _t303
    int _t306;                             // _t306
    int _t309;                             // _t309
    int _t315;                             // _t315
    int _t322;                             // _t322
    int _t332;                             // _t332
    int _t344;                             // _t344
    int _t351;                             // _t351
    int _t358;                             // _t358
    int _t373;                             // _t373
    signed int _t381;                      // _t381
    _unknown_ _t386;                       // _t386
    _unknown_ _t387;                       // _t387
    signed int _t389;                      // _t389
    _unknown_ _t395;                       // _t395
    int _t435;                             // _t435
    _unknown_ _t447;                       // _t447
    _unknown_ _t448;                       // _t448
    _unknown_ _t449;                       // _t449
    _unknown_ _t491;                       // _t491
    _unknown_ _t493;                       // _t493
    char* _t496;                           // _t496
    int _t508;                             // _t508
    _unknown_ _t524;                       // _t524
    _unknown_ _t527;                       // _t527

    tmp = 0;
    qq = 135041709;
    qlen = 0;
    if(form_sp >= 0 || form_stack[form_sp] < 0) {
        s = "<form_int method=internal action=none>";
        tmp = process_form(parse_tag( &s, 1));
    }
    if(tmp == 0) {
        tmp = Strnew();
    }
    p = "text";
    parsedtag_get_value(tag, 33,  &p);
    q = 0;
    parsedtag_get_value(tag, 36,  &q);
    r = 135041709;
    parsedtag_get_value(tag, 25,  &r);
    w = 20;
    parsedtag_get_value(tag, 30,  &w);
    i = 20;
    parsedtag_get_value(tag, 22,  &i);
    p2 = 0;
    parsedtag_get_value(tag, 5,  &p2);
    if(tag->map == 0 || (tag->map[0xc] & 0xff) == 75) {
L9:
        _t303 = 0;
    } else {
        if((tag->attrid[tag->map[0xc] & 0xff] & 0xff) == 0) {
            goto L9;
        } else {
            _t303 = 1;
        }
    }
    x = _t303;
    if(tag->map == 0) {
L14:
        _t306 = 0;
        goto L15;
    }
    if((tag->map[1] & 0xff) == 75 || (tag->attrid[tag->map[1] & 0xff] & 0xff) == 0) {
        goto L14;
    } else {
        _t306 = 1;
    }
L15:
    y = _t306;
    if(tag->map == 0 || (tag->map[0x2b] & 0xff) == 75 || (tag->attrid[tag->map[0x2b] & 0xff] & 0xff) == 0) {
        _t309 = 0;
    } else {
        _t309 = 1;
    }
    z = _t309;
    v = formtype(p);
    if(v == 255) {
        return 0;
    }
    if(q != 0 || v > 10) {
        if(v == 11) {
            q = 0;
        }
        if(q != 0) {
            qq = html_quote(q);
            qlen = wtf_strwidth(q);
        }
        Strcat_charp(tmp, "<pre_int>");
        _t315 = v;
        if(_t315 == 3) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t322 = tmp->length;
             *((char*)(tmp->ptr + _t322)) = 40;
            tmp->length = _t322 + 1;
             *(tmp->ptr + tmp->length) = 0;
L40:
            _v112 = i;
            __edi = w;
            _t496 = html_quote(r);
            __esi = p;
            if(form_sp >= 0) {
                _t508 = -1;
            } else {
                _t508 = form_stack[form_sp];
            }
            _t332 = cur_hseq;
            cur_hseq = _t332 + 1;
            _v128 = qq;
            _v132 = _v112;
            _v136 = __edi;
            _v140 = _t496;
            _v144 = __esi;
            _v148 = _t508;
            _v152 = _t332;
            Strcat(tmp, Sprintf("<input_alt hseq="%d" fid="%d" type=%s name="%s" width=%d maxlength=%d value="%s""));
            if(x != 0) {
                Strcat_charp(tmp, " checked");
            }
            if(y != 0) {
                Strcat_charp(tmp, " accept");
            }
            if(z != 0) {
                Strcat_charp(tmp, " readonly");
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t344 = tmp->length;
             *((char*)(tmp->ptr + _t344)) = 62;
            tmp->length = _t344 + 1;
             *(tmp->ptr + tmp->length) = 0;
            if(v != 6) {
                if(v > 11) {
L68:
                    if(v > 11) {
                        if(v <= 11) {
                            _t381 = 1 << (v & 255);
                            if((_t381 & 1200) != 0) {
                                Strcat_charp(tmp, "]");
                            } else {
                                if((_t381 & 2051) != 0) {
                                    Strcat_charp(tmp, "</u>");
                                }
                            }
                        }
                        Strcat_charp(tmp, "</input_alt>");
                        _t351 = v;
                        if(_t351 == 3) {
                            if(tmp->length + 1 >= tmp->area_size) {
                                Strgrow(tmp);
                            }
                            _t358 = tmp->length;
                             *((char*)(tmp->ptr + _t358)) = 41;
                            tmp->length = _t358 + 1;
                             *(tmp->ptr + tmp->length) = 0;
                            goto L86;
                        }
                        if(_t351 > 3) {
                            if(_t351 != 11) {
                                goto L86;
                            }
                            goto L80;
                        }
                        if(_t351 >= 0) {
L86:
                            Strcat_charp(tmp, "</pre_int>");
                            goto L87;
                        }
                        goto L80;
L80:
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t373 = tmp->length;
                         *((char*)(tmp->ptr + _t373)) = 93;
                        tmp->length = _t373 + 1;
                         *(tmp->ptr + tmp->length) = 0;
                        goto L86;
                    }
                    goto L69;
                }
                goto L54;
L69:
                goto __eax;
            } else {
                Strcat_charp(tmp, "</input_alt></pre_int>");
L87:
                return tmp;
            }
L54:
            _t389 = 1 << (v & 255);
            if((_t389 & 1072) != 0) {
L67:
                Strcat_charp(tmp, "[");
                goto L68;
            }
            if((_t389 & 2051) != 0) {
                Strcat_charp(tmp, 135044077);
                goto L68;
            }
            if((_t389 & 128) != 0) {
                goto L59;
            }
            goto L68;
L59:
            s = 0;
            parsedtag_get_value(tag, 31,  &s);
            if(s == 0) {
                goto L67;
            }
            _v152 = html_quote(s);
            Strcat(tmp, Sprintf("<img src="%s""));
            if(p2 != 0) {
                _v152 = html_quote(p2);
                Strcat(tmp, Sprintf(" alt="%s""));
            }
            if(parsedtag_get_value(tag, 38,  &iw) != 0) {
                _v152 = iw;
                Strcat(tmp, Sprintf(" width="%d""));
            }
            if(parsedtag_get_value(tag, 17,  &ih) != 0) {
                _v152 = ih;
                Strcat(tmp, Sprintf(" height="%d""));
            }
            Strcat_charp(tmp, " pre_int>");
            Strcat_charp(tmp, "</input_alt></pre_int>");
            return tmp;
            goto L68;
        }
        if(_t315 > 3) {
            if(_t315 != 11) {
                goto L40;
            }
            goto L34;
        }
        if(_t315 >= 0) {
            goto L40;
        }
L34:
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t435 = tmp->length;
         *((char*)(tmp->ptr + _t435)) = 91;
        tmp->length = _t435 + 1;
         *(tmp->ptr + tmp->length) = 0;
        goto L40;
    }
    goto __eax;
}

Str process_select(struct parsed_tag* tag)
{// addr = 0x08063D02  --  defined in 'file.c' at line 3718
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    int _v44;                              // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    int __esi;                             // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t44;                        // _t44
    int _t49;                              // _t49
    int _t56;                              // _t56
    FormSelectOption* _t67;   // _t67
    int _t85;                              // _t85

    tmp = 0;
    if(form_sp >= 0 || form_stack[form_sp] < 0) {
        s = "<form_int method=internal action=none>";
        tmp = process_form(parse_tag( &s, 1));
    }
    p = 135041709;
    parsedtag_get_value(tag, 25,  &p);
    cur_select = Strnew_charp(p);
    if(tag->map == 0 || (tag->map[0x18] & 0xff) == 75 || (tag->attrid[tag->map[0x18] & 0xff] & 0xff) == 0) {
        _t49 = 0;
    } else {
        _t49 = 1;
    }
    select_is_multiple = _t49;
    if(select_is_multiple != 0) {
        select_str = Strnew();
    } else {
        __esi = n_select;
        __ecx = html_quote(p);
        if(form_sp >= 0) {
            _t56 = -1;
        } else {
            _t56 = form_stack[form_sp];
        }
        _t85 = cur_hseq;
        cur_hseq = _t85 + 1;
        _v44 = __esi;
        _v48 = __ecx;
        _v52 = _t56;
        _v56 = _t85;
        select_str = Sprintf("<pre_int>[<input_alt hseq="%d" fid="%d" type=select name="%s" selectnumber=%d");
        Strcat_charp(select_str, ">");
        if(n_select == max_select) {
            max_select = max_select + max_select;
            _t67 = select_option;
            _v56 = 0 + max_select * 8;
             *__esp = _t67;
            GC_realloc();
            select_option = _t67;
        }
         *(select_option + (n_select << 3)) = 0;
        (select_option + (n_select << 3))[1] = 0;
        cur_option_maxwidth = 0;
    }
    cur_option = 0;
    cur_status = 0;
    n_selectitem = 0;
    return tmp;
}

Str process_n_select()
{// addr = 0x08063F01  --  defined in 'file.c' at line 3758
    struct _Str* _v36;    // _cfa_ffffffdc
    FormItemList sitem;   // _cfa_ffffffac
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24

    if(cur_select != 0) {
        process_option();
        if(select_is_multiple != 0) {
            Strcat_charp(select_str, "<br>");
        } else {
            if( *(select_option + (n_select << 3)) != 0) {
                chooseSelectOption( &(sitem.type),  *(select_option + (n_select << 3)));
                Strcat(select_str, textfieldrep(_v36, cur_option_maxwidth));
            }
            Strcat_charp(select_str, "</input_alt>]</pre_int>");
            n_select = n_select + 1;
        }
        cur_select = 0;
        n_selectitem = 0;
        return select_str;
    }
    return 0;
}

feed_select(char* str)
{// addr = 0x08063FDE  --  defined in 'file.c' at line 3782
    Str tmp;               // _cfa_fffffff0
    int prev_status;                       // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    struct parsed_tag* tag;   // _cfa_ffffffe4
    char* q;                               // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t90;                        // _t90
    struct _Str* _t125;   // _t125
    int _t162;                             // _t162
    int _t181;                             // _t181
    char* _t185;                           // _t185

    tmp = Strnew();
    prev_status = cur_status;
    if(cur_select == 0) {
        return;
    }
    while(read_token(tmp,  &str,  &cur_status, 0, 0) != 0) {
        if(cur_status != 0) {
            continue;
        }
        if(prev_status != 0) {
            goto L40;
        }
        p = tmp->ptr;
        if(( *(tmp->ptr) & 0xff) != 60 || tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 62) {
            if(cur_option == 0) {
                continue;
            }
        } else {
            tag = parse_tag( &p, 0);
            if(tag != 0) {
                if((tag->tagid & 0xff) == 49) {
                    process_option();
                    cur_option = Strnew();
                    if(parsedtag_get_value(tag, 36,  &q) == 0) {
                        cur_option_value = 0;
                    } else {
                        cur_option_value = Strnew_charp(q);
                    }
                    if(parsedtag_get_value(tag, 42,  &q) == 0) {
                        cur_option_label = 0;
                    } else {
                        cur_option_label = Strnew_charp(q);
                    }
                    if(tag->map == 0 || (tag->map[0x29] & 0xff) == 75 || (tag->attrid[tag->map[0x29] & 0xff] & 0xff) == 0) {
                        _t162 = 0;
                    } else {
                        _t162 = 1;
                    }
                    cur_option_selected = _t162;
                    prev_spaces = -1;
                }
            }
            continue;
        }
        while(( *p & 0xff) != 0) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0 || prev_spaces == 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                    prev_spaces = 0;
                } else {
                    prev_spaces = 1;
                }
                if(( *p & 0xff) != 38) {
                    if(cur_option->length + 1 >= cur_option->area_size) {
                        Strgrow(cur_option);
                    }
                    _t125 = cur_option;
                    _t181 = _t125->length;
                    _t185 = p;
                     *(cur_option->ptr + _t181) =  *_t185 & 0xff;
                    _t125->length = _t181 + 1;
                    p =  &(_t185[1]);
                     *(cur_option->ptr + cur_option->length) = 0;
                } else {
                    Strcat_charp(cur_option, getescapecmd( &p));
                }
            } else {
                p =  &(p[1]);
                if(prev_spaces > 0) {
                    prev_spaces = prev_spaces + 1;
                }
            }
        }
        continue;
L40:
    }
    return;
}

process_option()
{// addr = 0x080642DF  --  defined in 'file.c' at line 3846
    char begin_char;                       // _cfa_ffffffe3
    char end_char;                         // _cfa_ffffffe2
    int len;                               // _cfa_ffffffdc
    char* _v52;                            // _cfa_ffffffcc
    FormSelectOption* _v56;   // _cfa_ffffffc8
    struct _Str* _v60;    // _cfa_ffffffc4
    struct _Str* _v64;    // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    FormSelectOption* __ebx;   // r1
    int __edi;                             // r4
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6

    begin_char = 91;
    end_char = 93;
    if(cur_select != 0) {
        if(cur_option != 0) {
L4:
            while(1) {
                __eax = cur_option;
                __eax = cur_option->length;
                if(cur_option->length <= 0) {
                    break;
                }
                __eax = cur_option;
                __eax = cur_option->length;
                if(cur_option->length <= 0) {
                    __eax = 0;
                } else {
                    __eax = cur_option;
                    __edx = cur_option->ptr;
                    __eax = cur_option;
                    __eax = cur_option->length;
                    __eax = cur_option->length - 1;
                    __eax = cur_option->length - 1 + cur_option->ptr;
                    __eax =  *(cur_option->length - 1 + cur_option->ptr) & 255;
                    __eax =  *(cur_option->length - 1 + cur_option->ptr) & 0xff;
                }
                __eax =  *(__eax +  &MYCTYPE_MAP) & 255;
                __eax = __eax & 0xff;
                if(__eax != 0) {
                    __eax = cur_option;
                    Strshrink(cur_option, 1);
                    continue;
                } else {
                    break;
                }
                goto L4;
            }
            __eax = cur_option_value;
            if(cur_option_value == 0) {
                __eax = cur_option;
                cur_option_value = cur_option;
            }
            __eax = cur_option_label;
            if(cur_option_label == 0) {
                __eax = cur_option;
                cur_option_label = cur_option;
            }
            __eax = select_is_multiple;
            if(select_is_multiple != 0) {
                __eax = select_is_multiple;
                if(select_is_multiple == 0) {
                    begin_char = 40;
                    end_char = 41;
                }
                cur_option_value = cur_option_value->ptr;
                __eax = html_quote(cur_option_value->ptr);
                __esi = cur_option_value->ptr;
                cur_select = cur_select->ptr;
                __eax = html_quote(cur_select->ptr);
                __ebx = cur_select->ptr;
                __eax = select_is_multiple;
                if(select_is_multiple == 0) {
                    __edx = "radio";
                } else {
                    __edx = "checkbox";
                }
                __eax = form_sp;
                if(form_sp >= 0) {
                    __eax = -1;
                } else {
                    __eax = form_stack;
                    form_sp = form_sp << 2;
                    __eax =  &(form_stack[form_sp]);
                    __eax = form_stack[form_sp];
                }
                __ecx = cur_hseq;
                __edi = __ecx;
                cur_hseq = __ecx;
                __ecx = begin_char;
                _v52 = __esi;
                _v56 = __ebx;
                _v60 = __edx;
                _v64 = __eax;
                _v68 = __edi;
                _v72 = begin_char;
                __eax = Sprintf("<br><pre_int>%c<input_alt hseq="%d" fid="%d" type=%s name="%s" value="%s"");
                __edx = select_str;
                Strcat(select_str, __eax);
                __eax = cur_option_selected;
                if(cur_option_selected == 0) {
                    __eax = select_str;
                    Strcat_charp(select_str, "> </input_alt>");
                } else {
                    __eax = select_str;
                    Strcat_charp(select_str, " checked>*</input_alt>");
                }
                __eax = select_str;
                __eax = select_str->length;
                __edx = select_str->length + 1;
                __eax = select_str;
                __eax = select_str->area_size;
                if(select_str->length + 1 >= select_str->area_size) {
                    __eax = select_str;
                    Strgrow(select_str);
                }
                __eax = select_str;
                __ebx = select_str->ptr;
                __eax = select_str;
                __edx = __eax->length;
                __ecx = __edx;
                __ebx = __edx + select_str->ptr;
                __ecx = end_char & 255;
                 *(__edx + select_str->ptr) = end_char & 0xff;
                __eax->length = __edx;
                __eax = select_str;
                __edx = select_str->ptr;
                __eax = select_str;
                __eax = select_str->length;
                __eax = select_str->ptr + select_str->length;
                 *(select_str->ptr + select_str->length) = 0;
                cur_option_label = cur_option_label->ptr;
                __eax = html_quote(cur_option_label->ptr);
                __edx = select_str;
                Strcat_charp(select_str, cur_option_label->ptr);
                __eax = select_str;
                Strcat_charp(select_str, "</pre_int>");
                n_selectitem = n_selectitem + 1;
                n_selectitem = n_selectitem + 1;
                return;
            } else {
                cur_option_label = cur_option_label->ptr;
                __eax = wtf_strwidth(cur_option_label->ptr);
                len = cur_option_label->ptr;
                __eax = cur_option_maxwidth;
                if(len > cur_option_maxwidth) {
                    __eax = len;
                    cur_option_maxwidth = len;
                }
                __ecx = cur_option_selected;
                __edx = cur_option_label;
                __eax = cur_option_value;
                __ebx = select_option;
                n_select = n_select << 3;
                __ebx = select_option + (n_select << 3);
                addSelectOption(select_option + (n_select << 3), cur_option_value, cur_option_label, cur_option_selected);
                return;
            }
        }
        return;
    }
    return;
}

Str process_textarea(struct parsed_tag* tag, int width)
{// addr = 0x0806458C  --  defined in 'file.c' at line 3891
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t58;                        // _t58
    int _t69;                              // _t69
    Str* _t77;             // _t77
    _unknown_ _t103;                       // _t103
    _unknown_ _t122;                       // _t122

    tmp = 0;
    if(form_sp >= 0 || form_stack[form_sp] < 0) {
        s = "<form_int method=internal action=none>";
        tmp = process_form(parse_tag( &s, 1));
    }
    p = 135041709;
    parsedtag_get_value(tag, 25,  &p);
    cur_textarea = Strnew_charp(p);
    cur_textarea_size = 20;
    if(parsedtag_get_value(tag, 13,  &p) != 0) {
        cur_textarea_size = atoi(p);
        if((p[strlen(p) - 1] & 0xff) == 37) {
            cur_textarea_size = (cur_textarea_size * width * 1374389535 >> 32 >> 5) - (cur_textarea_size * width >> 31) - 2;
        }
        if(cur_textarea_size <= 0) {
            cur_textarea_size = 20;
        }
    }
    cur_textarea_rows = 1;
    if(parsedtag_get_value(tag, 28,  &p) != 0) {
        cur_textarea_rows = atoi(p);
        if(cur_textarea_rows <= 0) {
            cur_textarea_rows = 1;
        }
    }
    if(tag->map == 0 || (tag->map[0x2b] & 0xff) == 75 || (tag->attrid[tag->map[0x2b] & 0xff] & 0xff) == 0) {
        _t69 = 0;
    } else {
        _t69 = 1;
    }
    cur_textarea_readonly = _t69;
    if(n_textarea >= max_textarea) {
        max_textarea = max_textarea + max_textarea;
        _t77 = textarea_str;
        _v40 = 0 + max_textarea * 4;
         *__esp = _t77;
        GC_realloc();
        textarea_str = _t77;
    }
     *(textarea_str + (n_textarea << 2)) = Strnew();
    ignore_nl_textarea = 1;
    return tmp;
}

Str process_n_textarea()
{// addr = 0x0806479C  --  defined in 'file.c' at line 3930
    Str tmp;               // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    intOrPtr _v48;                         // _cfa_ffffffd0
    int _v64;                              // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    int __ebx;                             // r1
    _unknown_ __edi;                       // r4
    int __esi;                             // r5
    _unknown_ __ebp;                       // r6
    int _t50;                              // _t50
    int _t62;                              // _t62
    _unknown_ _t79;                        // _t79
    char* _t80;                            // _t80
    int _t89;                              // _t89

    if(cur_textarea != 0) {
        tmp = Strnew();
        _t89 = n_textarea;
        _v48 = cur_textarea_rows - 1;
        __esi = cur_textarea_rows;
        __ebx = cur_textarea_size;
        _t80 = html_quote(cur_textarea->ptr);
        if(form_sp >= 0) {
            _t50 = -1;
        } else {
            _t50 = form_stack[form_sp];
        }
        _v64 = _t89;
        _v68 = _v48;
        _v72 = __esi;
        _v76 = __ebx;
        _v80 = _t80;
        _v84 = _t50;
        _v88 = cur_hseq;
        Strcat(tmp, Sprintf("<pre_int>[<input_alt hseq="%d" fid="%d" type=textarea name="%s" size=%d rows=%d top_margin=%d textareanumber=%d"));
        if(cur_textarea_readonly != 0) {
            Strcat_charp(tmp, " readonly");
        }
        Strcat_charp(tmp, "><u>");
        i = 0;
        while(i < cur_textarea_size) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t62 = tmp->length;
             *((char*)(tmp->ptr + _t62)) = 32;
            tmp->length = _t62 + 1;
             *(tmp->ptr + tmp->length) = 0;
            i = i + 1;
        }
        Strcat_charp(tmp, "</u></input_alt>]</pre_int>\n");
        cur_hseq = cur_hseq + 1;
        n_textarea = n_textarea + 1;
        cur_textarea = 0;
        return tmp;
    }
    return 0;
}

feed_textarea(char* str)
{// addr = 0x08064924  --  defined in 'file.c' at line 3960
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    struct _Str* _t63;    // _t63
    int _t94;                              // _t94
    char* _t109;                           // _t109

    if(cur_textarea == 0) {
        return;
    }
    if(ignore_nl_textarea != 0) {
        if(( *str & 0xff) == 10) {
            str =  &(str[1]);
        }
    }
    ignore_nl_textarea = 0;
    while(( *str & 0xff) != 0) {
        if(( *str & 0xff) != 38) {
            if(( *str & 0xff) != 10) {
                if(( *str & 0xff) != 13) {
                    if( *(textarea_str + (n_textarea << 2))->length + 1 >=  *(textarea_str + (n_textarea << 2))->area_size) {
                        Strgrow( *(textarea_str + (n_textarea << 2)));
                    }
                    _t63 =  *(textarea_str + (n_textarea << 2));
                    _t94 = _t63->length;
                    _t109 = str;
                     *( *( *(textarea_str + (n_textarea << 2))) + _t94) =  *_t109 & 0xff;
                    _t63->length = _t94 + 1;
                    str =  &(_t109[1]);
                     *( *( *(textarea_str + (n_textarea << 2))) +  *(textarea_str + (n_textarea << 2))->length) = 0;
                }
            } else {
                Strcat_charp( *(textarea_str + (n_textarea << 2)), "\n");
                str =  &(str[1]);
            }
        } else {
            Strcat_charp( *(textarea_str + (n_textarea << 2)), getescapecmd( &str));
        }
    }
    return;
}

Str process_hr(struct parsed_tag* tag, int width, int indent_width)
{// addr = 0x08064ACC  --  defined in 'file.c' at line 3984
    Str tmp;               // _cfa_fffffff0
    int w;                                 // _cfa_ffffffec
    int x;                                 // _cfa_ffffffe8
    int _v32;                              // _cfa_ffffffe0
    signed short _v34;                     // _cfa_ffffffde
    signed int _v36;                       // _cfa_ffffffdc
    int _v48;                              // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t62;                        // _t62
    _unknown_ _t71;                        // _t71
    int _t72;                              // _t72
    _unknown_ _t87;                        // _t87
    int _t90;                              // _t90
    _unknown_ _t100;                       // _t100
    _unknown_ _t101;                       // _t101
    _unknown_ _t103;                       // _t103

    tmp = Strnew_charp("<nobr>");
    w = 0;
    x = 0;
    if(width > indent_width) {
        width = width - indent_width;
    }
    if(parsedtag_get_value(tag, 38,  &w) == 0) {
        w = width;
    } else {
        if(w >= 0) {
            _t90 = ( ~w * width * 1374389535 >> 32 >> 5) - ( ~w * width >> 31);
        } else {
            _v32 = w;
            asm("fild dword [ebp-0x1c]");
            asm("fld qword [0x80d53a0]");
            asm("fdivp st1, st0");
            asm("fnstcw word [ebp-0x1e]");
            _v36 = _v34 & 0xffff;
            asm("fldcw word [ebp-0x20]");
            asm("fistp dword [ebp-0x1c]");
            asm("fldcw word [ebp-0x1e]");
            _t90 = _v32;
        }
        w = _t90;
    }
    parsedtag_get_value(tag, 4,  &x);
    _t72 = x;
    if(_t72 == 1) {
        Strcat_charp(tmp, "<div_int align=left>");
    } else {
        if(_t72 == 2) {
            Strcat_charp(tmp, "<div_int align=right>");
        } else {
            if(_t72 == 0) {
                Strcat_charp(tmp, "<div_int align=center>");
            }
        }
    }
    _v48 = symbol_width;
    w = w / _v48;
    if(w <= 0) {
        w = 1;
    }
    push_symbol(tmp, 26, symbol_width, w);
    Strcat_charp(tmp, "</div_int></nobr>");
    return tmp;
}

char* check_charset(char* p)
{// addr = 0x08064C43  --  defined in 'file.c' at line 4019
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6

    if(wc_guess_charset(p, 0) == 0) {
        return 0;
    }
    return p;
}

char* check_accept_charset(char* ac)
{// addr = 0x08064C6C  --  defined in 'file.c' at line 4025
    char* s;                               // _cfa_fffffff0
    char* e;                               // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t49;                        // _t49

    s = ac;
    while(( *s & 0xff) != 0) {
        while(1) {
            s =  *s & 255;
            if(( *s & 0xff) == 0) {
                break;
            }
            s =  *s & 255;
             *s & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
             *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 2;
            if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 2) != 0) {
L1:
                s =  &(s[1]);
                continue;
            }
            s =  *s & 255;
            if(( *s & 0xff) == 44) {
                goto L1;
            }
            break;
        }
        s =  *s & 255;
        if(( *s & 0xff) == 0) {
            goto L18;
        }
        __eax = s;
        e = s;
        while(1) {
            e =  *e & 255;
            if(( *e & 0xff) == 0) {
                break;
            }
            e =  *e & 255;
             *e & 0xff =  *( &MYCTYPE_MAP + ( *e & 0xff)) & 255;
             *( &MYCTYPE_MAP + ( *e & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *e & 0xff)) & 2;
            if(( *( &MYCTYPE_MAP + ( *e & 0xff)) & 2) != 0) {
                break;
            }
            e =  *e & 255;
            if(( *e & 0xff) != 44) {
                e =  &(e[1]);
                continue;
            }
            break;
L13:
            __eax = ac;
            return ac;
        }
        s = e - s;
        _v40 = e - s;
        __eax = s;
         *__esp = s;
        Strnew_charp_n() =  *s;
        __eax = wc_guess_charset( *s, 0);
        if( *s == 0) {
            __eax = e;
            s = e;
            continue;
        }
        goto L13;
L18:
        return 0;
    }
    goto L18;
}

Str process_form_int(struct parsed_tag* tag, int fid)
{// addr = 0x08064D4E  --  defined in 'file.c' at line 4046
    char* p;                               // _cfa_ffffffe0
    char* q;                               // _cfa_ffffffdc
    char* r;                               // _cfa_ffffffd8
    char* s;                               // _cfa_ffffffd4
    char* tg;                              // _cfa_ffffffd0
    char* n;                               // _cfa_ffffffcc
    Str tmp;               // _cfa_ffffffc8
    FormList** _v64;   // _cfa_ffffffc0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ _v92;                        // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t101;                       // _t101
    _unknown_ _t104;                       // _t104
    _unknown_ _t111;                       // _t111
    _unknown_ _t114;                       // _t114
    _unknown_ _t117;                       // _t117
    _unknown_ _t130;                       // _t130
    char* _t132;                           // _t132
    char* _t134;                           // _t134
    FormList** _t162;   // _t162
    int* _t164;                            // _t164
    FormList** _t166;   // _t166
    int* _t168;                            // _t168

    p = "get";
    parsedtag_get_value(tag, 23,  &p);
    q = "!CURRENT_URL!";
    parsedtag_get_value(tag, 3,  &q);
    r = 0;
    if(parsedtag_get_value(tag, 2,  &r) != 0) {
        r = check_accept_charset(r);
    }
    if(r == 0 && parsedtag_get_value(tag, 11,  &r) != 0) {
        r = check_charset(r);
    }
    s = 0;
    parsedtag_get_value(tag, 16,  &s);
    tg = 0;
    parsedtag_get_value(tag, 32,  &tg);
    n = 0;
    parsedtag_get_value(tag, 25,  &n);
    if(fid >= 0) {
        if(form_max < fid) {
            form_max = fid;
        }
        form_sp = fid;
    } else {
        form_max = form_max + 1;
        form_sp = form_sp + 1;
        fid = form_max;
    }
    if(forms_size != 0) {
        if(forms_size <= form_max) {
            forms_size = forms_size + form_max;
            _t162 = forms;
            _v104 = 0 + forms_size * 4;
             *__esp = _t162;
            GC_realloc();
            forms = _t162;
            _t164 = form_stack;
            _v104 = 0 + forms_size * 4;
             *__esp = _t164;
            GC_realloc();
            form_stack = _t164;
        }
    } else {
        forms_size = 10;
        _t166 = forms_size << 2;
         *__esp = _t166;
        GC_malloc();
        forms = _t166;
        _t168 = forms_size << 2;
         *__esp = _t168;
        GC_malloc_atomic();
        form_stack = _t168;
    }
    form_stack[form_sp] = fid;
    if((w3m_dump & 16) == 0) {
        _v64 =  &(forms[fid]);
         *_v64 = newFormList(q, p, r, s, tg, n, 0);
        return 0;
    } else {
        _t132 = html_quote(p);
        _t134 = html_quote(q);
        _v96 = _t132;
        _v100 = _t134;
        _v104 = fid;
        tmp = Sprintf("<form_int fid="%d" action="%s" method="%s"");
        if(s != 0) {
            _v104 = html_quote(s);
            Strcat(tmp, Sprintf(" enctype="%s""));
        }
        if(tg != 0) {
            _v104 = html_quote(tg);
            Strcat(tmp, Sprintf(" target="%s""));
        }
        if(n != 0) {
            _v104 = html_quote(n);
            Strcat(tmp, Sprintf(" name="%s""));
        }
        if(r != 0) {
            _v104 = html_quote(r);
            Strcat(tmp, Sprintf(" accept-charset="%s""));
        }
        Strcat_charp(tmp, ">");
        return tmp;
    }
    return __eax;
}

Str process_form(struct parsed_tag* tag)
{// addr = 0x080650DB  --  defined in 'file.c' at line 4112
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return process_form_int(tag, -1);
}

Str process_n_form()
{// addr = 0x080650F6  --  defined in 'file.c' at line 4118
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    if(form_sp < 0) {
        form_sp = form_sp - 1;
    }
    return 0;
}

clear_ignore_p_flag(int cmd, struct readbuffer* obuf)
{// addr = 0x08065116  --  defined in 'file.c' at line 4126
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    i = 0;
    while(( &clear_flag_cmd)[i] != 0) {
        if(( &clear_flag_cmd)[i] == cmd) {
            goto L2;
        }
        i = i + 1;
        continue;
L2:
        obuf->flag = obuf->flag;
        return;
    }
    return;
}

set_alignment(struct readbuffer* obuf, struct parsed_tag* tag)
{// addr = 0x0806515B  --  defined in 'file.c' at line 4142
    long int flag;                         // _cfa_fffffff0
    int align;                             // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t45;                              // _t45
    int _t46;                              // _t46

    flag = -1;
    if(parsedtag_get_value(tag, 4,  &align) != 0) {
        _t46 = align;
        if(_t46 == 1) {
            flag = 16;
        } else {
            if(_t46 == 2) {
                flag = 64;
            } else {
                if(_t46 == 0) {
                    flag = 32;
                }
            }
        }
    }
    if(obuf->flag_sp <= 9) {
        _t45 = obuf->flag_sp;
         *(obuf + (_t45 + 4) * 4) = obuf->flag & 112;
        obuf->flag_sp = _t45 + 1;
    }
    if(flag == 255) {
        return;
    } else {
        obuf->flag = obuf->flag & 143;
        obuf->flag = obuf->flag | flag;
        return;
    }
}

process_idattr(struct readbuffer* obuf, int cmd, struct parsed_tag* tag)
{// addr = 0x0806520D  --  defined in 'file.c' at line 4167
    char* id;                              // _cfa_fffffff0
    char* framename;                       // _cfa_ffffffec
    Str idtag;             // _cfa_ffffffe8
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27
    _unknown_ _t30;                        // _t30
    _unknown_ _t33;                        // _t33
    char* _t43;                            // _t43
    char* _t45;                            // _t45

    id = 0;
    framename = 0;
    idtag = 0;
    if(cmd == 31) {
        return;
    }
    parsedtag_get_value(tag, 20,  &id);
    parsedtag_get_value(tag, 67,  &framename);
    if(id == 0) {
    } else {
        if(framename == 0) {
            _v40 = html_quote(id);
            idtag = Sprintf("<_id id="%s">");
        } else {
            _t43 = html_quote(framename);
            _t45 = html_quote(id);
            _v36 = _t43;
            _v40 = _t45;
            idtag = Sprintf("<_id id="%s" framename="%s">");
        }
        push_tag(obuf, idtag->ptr, 138);
        return;
    }
    goto L7;
L8:
    return;
L7:
    goto L8;
}

int ul_type(struct parsed_tag* tag, int default_type)
{// addr = 0x080652EC  --  defined in 'file.c' at line 4223
    char* p;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24

    if(parsedtag_get_value(tag, 33,  &p) == 0) {
L7:
        return default_type;
    }
    if(strcasecmp(p, "disc") != 0) {
        if(strcasecmp(p, "circle") != 0) {
            if(strcasecmp(p, "square") != 0) {
                goto L7;
            }
            goto L6;
        }
        goto L4;
L6:
        return 115;
    }
    return 100;
L4:
    return 99;
    return __eax;
}

int getMetaRefreshParam(char* q, Str* refresh_uri)
{// addr = 0x0806536F  --  defined in 'file.c' at line 4238
    int refresh_interval;                  // _cfa_fffffff0
    char* r;                               // _cfa_ffffffec
    Str s_tmp;             // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t82;                        // _t82
    _unknown_ _t85;                        // _t85

    s_tmp = 0;
    if(q == 0 || refresh_uri == 0) {
        return 0;
    }
    refresh_interval = atoi(q);
    if(refresh_interval >= 0) {
        while(1) {
L28:
            q =  *q & 255;
            if(( *q & 0xff) == 0) {
                break;
            }
            _v36 = 4;
            _v40 = "url=";
            __eax = q;
             *__esp = q;
            __eax = strncasecmp();
            if(q != 0) {
L17:
                goto L18;
            }
            q =  &(q[4]);
            q =  *q & 255;
            if(( *q & 0xff) == 34) {
                q =  &(q[1]);
            }
            __eax = q;
            r = q;
            while(1) {
                r =  *r & 255;
                if(( *r & 0xff) == 0) {
                    break;
                }
                r =  *r & 255;
                 *r & 0xff =  *( &MYCTYPE_MAP + ( *r & 0xff)) & 255;
                 *( &MYCTYPE_MAP + ( *r & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *r & 0xff)) & 2;
                if(( *( &MYCTYPE_MAP + ( *r & 0xff)) & 2) != 0) {
                    break;
                }
                r =  *r & 255;
                if(( *r & 0xff) != 59) {
                    r =  &(r[1]);
                    continue;
                }
                break;
            }
            q = r - q;
            _v40 = r - q;
            __eax = q;
             *__esp = q;
            __eax = Strnew_charp_n();
            s_tmp = q;
            s_tmp = s_tmp;
            s_tmp->length = s_tmp->length - 1;
            s_tmp->ptr + s_tmp->length - 1 =  *(s_tmp->ptr + s_tmp->length - 1) & 255;
            if(( *(s_tmp->ptr + s_tmp->length - 1) & 0xff) == 34) {
                s_tmp = s_tmp->length;
                __eax = s_tmp;
                s_tmp->length = s_tmp->length - 1;
                s_tmp = s_tmp;
                s_tmp->length = s_tmp->ptr + s_tmp->length;
                 *(s_tmp->ptr + s_tmp->length) = 0;
            }
            __eax = r;
            q = r;
            while(1) {
L18:
                q =  *q & 255;
                if(( *q & 0xff) == 0) {
                    break;
                }
                q =  *q & 255;
                if(( *q & 0xff) != 59) {
                    q =  &(q[1]);
                    continue;
                }
                break;
            }
            q =  *q & 255;
            if(( *q & 0xff) == 59) {
                q =  &(q[1]);
            }
            while(1) {
                q =  *q & 255;
                if(( *q & 0xff) == 0) {
                    break;
                }
                q =  *q & 255;
                if(( *q & 0xff) == 32) {
                    q =  &(q[1]);
                    continue;
                }
                goto L28;
            }
        }
        __eax = refresh_uri;
         *refresh_uri = s_tmp;
        __eax = refresh_interval;
        return refresh_interval;
    }
    return 0;
}

int HTMLtagproc1(struct parsed_tag* tag, struct html_feed_environ* h_env)
{// addr = 0x080654E5  --  defined in 'file.c' at line 4280
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    char* r;                               // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int w;                                 // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int z;                                 // _cfa_ffffffd4
    int count;                             // _cfa_ffffffd0
    int width;                             // _cfa_ffffffcc
    Str tmp;               // _cfa_ffffffc0
    int hseq;                              // _cfa_ffffffbc
    Str num;               // _cfa_ffffffb0
    int refresh_interval;                  // _cfa_ffffffac
    Str s;                 // _cfa_ffffffa8
    Str s;                 // _cfa_ffffffa4
    Str s;                 // _cfa_ffffffa0
    Str s;                 // _cfa_ffffff9c
    struct readbuffer* obuf;   // _cfa_ffffffc8
    struct environment* envs;   // _cfa_ffffffc4
    int cmd;                               // _cfa_ffffffb8
    char* id;                              // _cfa_ffffffb4
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32
    int _t33;                              // _t33
    _unknown_ _t34;                        // _t34

    obuf = h_env->obuf;
    envs = h_env->envs;
    id = 0;
    cmd = tag->tagid & 0xff;
    if((obuf->flag & 1) != 0) {
        _t33 = cmd;
        if(_t33 < 50 || _t33 > 51 && _t33 + -128 > 1) {
            goto L5;
        } else {
            return 1;
        }
    }
L5:
    if(cmd > 144) {
        return 0;
    }
    goto __eax;
}

Str textlist_feed()
{// addr = 0x08069B8B  --  defined in 'file.c' at line 5232
    TextLine* p;      // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5

    if(_tl_lp2 == 0) {
        return 0;
    }
    p = _tl_lp2->ptr;
    _tl_lp2 = _tl_lp2->next;
    return p->line;
}

int ex_efct(int ex)
{// addr = 0x08069BBF  --  defined in 'file.c' at line 5243
    int effect;                            // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22

    effect = 0;
    if(ex != 0) {
        if((ex & 1) != 0) {
            effect = effect | 2;
        }
        if((ex & 2) != 0) {
            effect = effect | 2;
        }
        if((ex & 4) != 0) {
            effect = effect | 4;
        }
        return effect;
    }
    return 0;
}

HTMLlineproc2body(Buffer* buf, _None* feed, int llimit)
{// addr = 0x08069C08  --  defined in 'file.c' at line 5263
    char* q;                               // _cfa_ffffffc8
    char* r;                               // _cfa_ffffffc4
    char* s;                               // _cfa_ffffffc0
    char* t;                               // _cfa_ffffffbc
    struct frameset*[9] frameset_s;   // _cfa_fffffef8
    int hseq;                              // _cfa_ffffffa0
    int selected;                          // _cfa_ffffff20
    FormItemList* item;   // _cfa_ffffff24
    FormItemList* item;   // _cfa_ffffff28
    Str tmp;               // _cfa_ffffff30
    int refresh_interval;                  // _cfa_ffffff2c
    union frameset_element element;   // _cfa_ffffff34
    MapArea* a;        // _cfa_ffffff38
    MapList* m;        // _cfa_ffffff3c
    FormList* form;   // _cfa_ffffff50
    int top;                               // _cfa_ffffff4c
    int bottom;                            // _cfa_ffffff48
    int textareanumber;                    // _cfa_ffffff44
    int selectnumber;                      // _cfa_ffffff30
    int hpos;                              // _cfa_ffffff40
    int w;                                 // _cfa_ffffff6c
    int h;                                 // _cfa_ffffff68
    int iseq;                              // _cfa_ffffff64
    int ismap;                             // _cfa_ffffff60
    int xoffset;                           // _cfa_ffffff30
    int yoffset;                           // _cfa_ffffff44
    int top;                               // _cfa_ffffff48
    int bottom;                            // _cfa_ffffff4c
    ParsedURL u;     // _cfa_fffffed0
    Image* image;        // _cfa_ffffff5c
    BufferPoint* po;   // _cfa_ffffff58
    Anchor* a;          // _cfa_ffffff54
    int h;                                 // _cfa_ffffff70
    char symbol;                           // _cfa_ffffffe3
    Lineprop mode;    // _cfa_ffffffe0
    Lineprop effect;   // _cfa_ffffffde
    Lineprop ex_effect;   // _cfa_ffffffdc
    Anchor* a_href;     // _cfa_ffffffd8
    Anchor* a_img;      // _cfa_ffffffd4
    Anchor* a_form;     // _cfa_ffffffd0
    char* p;                               // _cfa_ffffffcc
    char* str;                             // _cfa_ffffffb8
    int pos;                               // _cfa_ffffffb4
    int nlines;                            // _cfa_ffffffb0
    int frameset_sp;                       // _cfa_ffffffac
    union frameset_element* idFrame;   // _cfa_ffffffa8
    char* id;                              // _cfa_ffffffa4
    int form_id;                           // _cfa_ffffff9c
    Str line;              // _cfa_ffffff98
    char* endp;                            // _cfa_ffffff94
    int internal;                          // _cfa_ffffff90
    Anchor** a_textarea;   // _cfa_ffffff8c
    Anchor** a_select;   // _cfa_ffffff88
    char** buf;                            // _cfa_ffffff84
    int len;                               // _cfa_ffffff80
    int len;                               // _cfa_ffffff7c
    int len;                               // _cfa_ffffff78
    struct parsed_tag* tag;   // _cfa_ffffff74
    _unknown_ _v364;                       // _cfa_fffffe94
    _unknown_ _v368;                       // _cfa_fffffe90
    _unknown_ _v372;                       // _cfa_fffffe8c
    _unknown_ _v376;                       // _cfa_fffffe88
    _unknown_ _v380;                       // _cfa_fffffe84
    _unknown_ _v384;                       // _cfa_fffffe80
    _unknown_ _v388;                       // _cfa_fffffe7c
    _unknown_ _v392;                       // _cfa_fffffe78
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    struct _Str* _t481;   // _t481
    _unknown_ _t559;                       // _t559
    _unknown_ _t560;                       // _t560
    _unknown_ _t596;                       // _t596
    _unknown_ _t598;                       // _t598
    _unknown_ _t608;                       // _t608
    _unknown_ _t615;                       // _t615
    _unknown_ _t617;                       // _t617
    _unknown_ _t637;                       // _t637
    _unknown_ _t639;                       // _t639
    _unknown_ _t654;                       // _t654
    _unknown_ _t656;                       // _t656
    _unknown_ _t666;                       // _t666
    _unknown_ _t673;                       // _t673
    _unknown_ _t675;                       // _t675
    _unknown_ _t715;                       // _t715
    _unknown_ _t719;                       // _t719
    _unknown_ _t729;                       // _t729
    _unknown_ _t736;                       // _t736
    _unknown_ _t738;                       // _t738
    _unknown_ _t745;                       // _t745
    _unknown_ _t747;                       // _t747
    FormList* _t771;   // _t771
    FormSelectOption* _t782;   // _t782
    Anchor** _t784;     // _t784
    Str* _t786;            // _t786
    Anchor** _t788;     // _t788
    char* _t789;                           // _t789
    Lineprop* _t791;   // _t791

    a_href = 0;
    a_img = 0;
    a_form = 0;
    frameset_sp = -1;
    idFrame = 0;
    id = 0;
    symbol = 0;
    internal = 0;
    a_textarea = 0;
    a_select = 0;
    if(out_size == 0) {
        out_size = 256;
        _t789 = out_size;
         *__esp = _t789;
        GC_malloc_atomic();
        outc = _t789;
        _t791 = out_size + out_size;
         *__esp = _t791;
        GC_malloc_atomic();
        outp = _t791;
    }
    n_textarea = -1;
    if(max_textarea == 0) {
        max_textarea = 10;
        _t786 = max_textarea << 2;
         *__esp = _t786;
        GC_malloc();
        textarea_str = _t786;
        _t788 = max_textarea << 2;
         *__esp = _t788;
        GC_malloc();
        a_textarea = _t788;
    }
    n_select = -1;
    if(max_select == 0) {
        max_select = 10;
        _t782 = max_select << 3;
         *__esp = _t782;
        GC_malloc();
        select_option = _t782;
        _t784 = max_select << 2;
         *__esp = _t784;
        GC_malloc();
        a_select = _t784;
    }
    effect = 0;
    ex_effect = 0;
    nlines = 0;
    while(1) {
        _t481 = feed;
        _t481->ptr();
        line = _t481;
        if(line == 0) {
            break;
        }
        if(n_textarea >= 0) {
            goto L10;
        }
        if(( *(line->ptr) & 0xff) == 60) {
            while(1) {
L10:
                nlines = nlines + 1;
                if(nlines == llimit) {
                    break;
                } else {
                    pos = 0;
                    Strremovetrailingspaces(line);
                    str = line->ptr;
                    endp =  &(str[line->length]);
                    goto L71;
                }
            }
L81:
            form_id = 1;
            while(form_id <= form_max) {
                forms[form_id]->next = forms[form_id - 1];
                form_id = form_id + 1;
            }
            if(form_max >= 0) {
                _t771 = 0;
            } else {
                _t771 = forms[form_max];
            }
            buf->formlist = _t771;
            if(n_textarea != 0) {
                addMultirowsForm(buf, buf->formitem);
            }
            addMultirowsImg(buf, buf->img);
            return;
        } else {
            Strcat( *(textarea_str + (n_textarea << 2)), line);
        }
    }
    goto L81;
}

addLink(Buffer* buf, struct parsed_tag* tag)
{// addr = 0x0806C0A4  --  defined in 'file.c' at line 5934
    char type;                             // _cfa_fffffff3
    char* href;                            // _cfa_ffffffec
    char* title;                           // _cfa_ffffffe8
    char* ctype;                           // _cfa_ffffffe4
    char* rel;                             // _cfa_ffffffe0
    char* rev;                             // _cfa_ffffffdc
    LinkList* l;      // _cfa_ffffffd8
    LinkList* i;      // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t78;                        // _t78
    _unknown_ _t82;                        // _t82
    _unknown_ _t85;                        // _t85
    _unknown_ _t88;                        // _t88
    _unknown_ _t92;                        // _t92
    LinkList* _t93;   // _t93

    href = 0;
    title = 0;
    ctype = 0;
    rel = 0;
    rev = 0;
    type = 0;
    parsedtag_get_value(tag, 18,  &href);
    if(href != 0) {
        href = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(href)), InnerCharset,  *(buf + 208))));
    }
    parsedtag_get_value(tag, 49,  &title);
    parsedtag_get_value(tag, 33,  &ctype);
    parsedtag_get_value(tag, 47,  &rel);
    if(rel != 0) {
        type = 1;
        if(title == 0) {
            title = rel;
        }
    }
    parsedtag_get_value(tag, 48,  &rev);
    _t93 = rev;
    if(_t93 != 0) {
        type = 2;
        _t93 = title;
        if(_t93 == 0) {
            _t93 = rev;
            title = _t93;
        }
    }
     *__esp = 20;
    GC_malloc();
    l = _t93;
    l->url = href;
    l->title = title;
    l->ctype = ctype;
    l->type = type & 0xff;
    l->next = 0;
    if(buf->linklist == 0) {
        buf->linklist = l;
        return;
    } else {
        i = buf->linklist;
        while(i->next != 0) {
            i = i->next;
        }
        i->next = l;
        return;
    }
    return;
}

HTMLlineproc2(Buffer* buf, TextLineList* tl)
{// addr = 0x0806C24B  --  defined in 'file.c' at line 5976
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _tl_lp2 = tl->first;
    HTMLlineproc2body(buf, textlist_feed, -1);
    return;
}

Str file_feed()
{// addr = 0x0806C278  --  defined in 'file.c' at line 5985
    Str s;                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    s = StrISgets(_file_lp2);
    if(s->length != 0) {
        return s;
    }
    ISclose(_file_lp2);
    return 0;
}

HTMLlineproc3(Buffer* buf, InputStream stream)
{// addr = 0x0806C2B1  --  defined in 'file.c' at line 5997
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _file_lp2 = stream;
    HTMLlineproc2body(buf, file_feed, -1);
    return;
}

proc_escape(struct readbuffer* obuf, char** str_return)
{// addr = 0x0806C2DC  --  defined in 'file.c' at line 6004
    Lineprop mode;    // _cfa_fffffff2
    char* str;                             // _cfa_ffffffec
    char* estr;                            // _cfa_ffffffe8
    int ech;                               // _cfa_ffffffe4
    int width;                             // _cfa_ffffffe0
    int n_add;                             // _cfa_ffffffdc
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    signed int _t99;                       // _t99

    str =  *str_return;
    ech = getescapechar(str_return);
    n_add =  *str_return - str;
    mode = 0;
    if(ech < 0) {
         *str_return = str;
        proc_mchar(obuf, obuf->flag & 655, 1, str_return, 0);
        return;
    }
    if(( *( &MYCTYPE_MAP + (ech & 0xff)) & 1) == 0) {
        _t99 = 0;
    } else {
        _t99 = 256;
    }
    mode = _t99 & 65535;
    estr = conv_entity(ech);
    check_breakpoint(obuf, obuf->flag & 655, estr);
    width = wtf_strwidth(estr);
    if(width != 1 || ( *estr & 0xff) != ech || ech == 38 || ech == 60 || ech == 62) {
        push_nchars(obuf, width, str, n_add, mode & 65535);
    } else {
        if(( *( &MYCTYPE_MAP + (ech & 0xff)) & 1) != 0) {
            mode = 256;
        }
        push_nchars(obuf, width, estr, strlen(estr), mode & 65535);
    }
    Strcopy_charp_n( *(obuf + 8), estr, strlen(estr));
     *(obuf + 184) = mode & 0xffff;
    return;
}

int need_flushline(struct html_feed_environ* h_env, struct readbuffer* obuf, Lineprop mode)
{// addr = 0x0806C497  --  defined in 'file.c' at line 6035
    char ch;                               // _cfa_fffffffb
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t36;                       // _t36
    _unknown_ _t41;                        // _t41
    _unknown_ _t42;                        // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t55;                        // _t55
    _unknown_ _t56;                        // _t56

    _v24 = _a12 & 65535;
    if((obuf->flag & 512) == 0) {
        if(obuf->line->length <= 0) {
            _t36 = 0;
        } else {
            _t36 =  *( *(obuf->line) + obuf->line->length - 1) & 255;
        }
        ch = _t36 & 255;
        if(ch != 32) {
            if((obuf->pos & 0xffff) <= h_env->limit) {
                return 0;
            }
        } else {
            return 0;
        }
        return 1;
    }
    if((obuf->pos & 0xffff) <= h_env->limit) {
        return 0;
    }
    return 1;
}

int table_width(struct html_feed_environ* h_env, int table_level)
{// addr = 0x0806C532  --  defined in 'file.c' at line 6059
    int width;                             // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32

    if(table_level >= 0) {
        width =  *( *((intOrPtr*)( &tables + table_level * 4)) + 24);
        if(table_level > 0 || width > 0) {
            return width;
        }
        return h_env->limit - ( &(h_env->envs[h_env->envc])->indent & 0xff);
    }
    return 0;
}

HTMLlineproc0(char* line, struct html_feed_environ* h_env, int internal)
{// addr = 0x0806C58D  --  defined in 'file.c' at line 6072
    char ch;                               // _cfa_fffffff3
    Lineprop mode;    // _cfa_fffffff0
    int cmd;                               // _cfa_ffffffec
    struct readbuffer* obuf;   // _cfa_ffffffe8
    int indent;                            // _cfa_ffffffe4
    int delta;                             // _cfa_ffffffe0
    struct parsed_tag* tag;   // _cfa_ffffffdc
    Str tokbuf;            // _cfa_ffffffd8
    struct table* tbl;   // _cfa_ffffffd4
    struct table_mode* tbl_mode;   // _cfa_ffffffd0
    int tbl_width;                         // _cfa_ffffffcc
    int is_hangul;                         // _cfa_ffffffc8
    int prev_is_hangul;                    // _cfa_ffffffc4
    int level;                             // _cfa_ffffffc0
    char* str;                             // _cfa_ffffffbc
    char* p;                               // _cfa_ffffffb8
    int is_tag;                            // _cfa_ffffffb4
    int pre_mode;                          // _cfa_ffffffb0
    int end_tag;                           // _cfa_ffffffac
    struct table* tbl0;   // _cfa_ffffffa8
    int indent;                            // _cfa_ffffffa4
    int indent;                            // _cfa_ffffffa0
    char* p;                               // _cfa_ffffff9c
    int ech;                               // _cfa_ffffff98
    char* p;                               // _cfa_ffffff94
    char* bp;                              // _cfa_ffffff90
    char* tp;                              // _cfa_ffffff8c
    int i;                                 // _cfa_ffffff88
    Str line;              // _cfa_ffffff84
    char* tp;                              // _cfa_ffffff80
    int i;                                 // _cfa_ffffff7c
    _unknown_ _v144;                       // _cfa_ffffff70
    _unknown_ _v172;                       // _cfa_ffffff54
    _unknown_ _v176;                       // _cfa_ffffff50
    _unknown_ _v180;                       // _cfa_ffffff4c
    _unknown_ _v184;                       // _cfa_ffffff48
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t807;                       // _t807
    _unknown_ _t812;                       // _t812
    _unknown_ _t823;                       // _t823
    _unknown_ _t866;                       // _t866
    _unknown_ _t949;                       // _t949
    _unknown_ _t1035;                      // _t1035
    _unknown_ _t1085;                      // _t1085
    _unknown_ _t1110;                      // _t1110

    obuf = h_env->obuf;
    tbl = 0;
    tbl_mode = 0;
    tbl_width = 0;
    prev_is_hangul = 0;
    tokbuf = Strnew();
    while(1) {
    }
}

addnewline2(Buffer* buf, char* line, Lineprop* prop, Linecolor* color, int pos, int nlines)
{// addr = 0x0806D554  --  defined in 'file.c' at line 6439
    Line* l;              // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

     *__esp = 52;
    GC_malloc();
    l = __eax;
    l->next = 0;
    l->lineBuf = line;
    l->propBuf = prop;
    l->colorBuf = color;
    l->len = pos;
    l->width = -1;
    l->size = pos;
    l->bpos = 0;
    l->bwidth = 0;
    l->prev = buf->currentLine;
    if(buf->currentLine == 0) {
        l->next = 0;
    } else {
        l->next = buf->currentLine->next;
        buf->currentLine->next = l;
    }
    if(buf->lastLine == 0 || buf->lastLine == buf->currentLine) {
        buf->lastLine = l;
    }
    buf->currentLine = l;
    if(buf->firstLine == 0) {
        buf->firstLine = l;
    }
    buf->allLine =  &(buf->allLine->lineBuf);
    l->linenumber = buf->allLine;
    if(nlines >= 0) {
        l->real_linenumber = nlines;
    } else {
        l->real_linenumber = 0;
    }
    l = 0;
    return;
}

addnewline(Buffer* buf, char* line, Lineprop* prop, Linecolor* color, int pos, int width, int nlines)
{// addr = 0x0806D678  --  defined in 'file.c' at line 6479
    char* s;                               // _cfa_fffffff0
    Lineprop* p;      // _cfa_ffffffec
    Linecolor* c;    // _cfa_ffffffe8
    Line* l;              // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int bpos;                              // _cfa_ffffffdc
    int bwidth;                            // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    Linecolor* _t161;   // _t161
    _unknown_ _t165;                       // _t165
    Lineprop* _t170;   // _t170
    _unknown_ _t175;                       // _t175

    if(pos <= 0) {
        s = NullLine;
        p =  &NullProp;
    } else {
        s = allocStr(line, pos);
        _t170 = pos + pos;
         *__esp = _t170;
        GC_malloc_atomic();
        p = _t170;
        bcopy(prop, p, pos + pos);
    }
    if(pos <= 0 || color == 0) {
        c = 0;
    } else {
        _t161 = pos;
         *__esp = _t161;
        GC_malloc_atomic();
        c = _t161;
        bcopy(color, c, pos);
    }
    addnewline2(buf, s, p, c, pos, nlines);
    if(pos <= 0) {
        return;
    } else {
        if(width <= 0) {
            goto L20;
        }
        bpos = 0;
        bwidth = 0;
        while(1) {
L10:
            l = buf->currentLine;
            l->bpos = bpos;
            l->bwidth = bwidth;
            i = columnLen(l, width);
            if(i != 0) {
                break;
            }
            i = i + 1;
            while(l->len > i && ( *(i + i + p) & 0x400) != 0) {
                i = i + 1;
            }
            break;
        }
        l->len = i;
        l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
        if(pos <= i) {
            goto L21;
        }
        bpos = bpos + l->len;
        bwidth = bwidth + l->width;
        s =  &(s[i]);
        p = p + i + i;
        if(c != 0) {
            c = c + i;
        }
        pos = pos - i;
        addnewline2(buf, s, p, c, pos, nlines);
        goto L10;
L21:
        return;
    }
L20:
    return;
}

Buffer* loadHTMLBuffer(URLFile* f, Buffer* newBuf)
{// addr = 0x0806D888  --  defined in 'file.c' at line 6546
    FILE* src;            // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t65;                        // _t65
    int _t80;                              // _t80
    _unknown_ _t81;                        // _t81
    int _t91;                              // _t91
    _unknown_ _t92;                        // _t92

    src = 0;
    if(newBuf != 0) {
L5:
        if(newBuf->sourcefile == 0 && ((f->scheme & 0xff) != 4 || newBuf->mailcap != 0)) {
            tmp = tmpfname(1, ".html");
            src = fopen(tmp->ptr, "w");
            if(src != 0) {
                newBuf->sourcefile = tmp->ptr;
            }
        }
        asm("cwde ");
        loadHTMLstream(f, newBuf, src, newBuf->bufferprop & 2);
        newBuf->topLine = newBuf->firstLine;
        newBuf->lastLine = newBuf->currentLine;
        newBuf->currentLine = newBuf->firstLine;
        if(n_textarea != 0) {
            formResetBuffer(newBuf, newBuf->formitem);
        }
        if(src != 0) {
            fclose(src);
        }
        return newBuf;
    }
    _t91 = COLS;
    if(showLineNum == 0) {
        _t80 = 1;
    } else {
        _t80 = 6;
    }
    _t81 = _t91 - _t80;
    _t82 = _t81 >= 0 ? 0 : _t81;
    newBuf = newBuffer(_t81 >= 0 ? 0 : _t81);
    goto L5;
}

char* convert_size(clen_t size, int usefloat)
{// addr = 0x0806D9B9  --  defined in 'file.c' at line 6579
    float csize;                           // _cfa_fffffff0
    int sizepos;                           // _cfa_ffffffec
    char** sizes;                          // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v48;                            // _cfa_ffffffd0
    char* __ebx;                           // r1
    _unknown_ __ebp;                       // r6
    signed int _t18;                       // _t18
    char* _t22;                            // _t22

    _v36 = _a4;
    _t18 = _a8;
    _v32 = _t18;
    sizepos = 0;
    sizes =  &_size_unit;
    asm("fild qword [ebp-0x20]");
    asm("fstp dword [ebp-0xc]");
    while(1) {
        asm("fld dword [ebp-0xc]");
        asm("fld qword [0x80caba8]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t18 & 255) == 0) {
            break;
        }
        _t18 = sizes[sizepos + 1];
        if(_t18 != 0) {
            asm("fld dword [ebp-0xc]");
            asm("fld dword [0x80caba0]");
            asm("fdivp st1, st0");
            asm("fstp dword [ebp-0xc]");
            sizepos = sizepos + 1;
            continue;
        }
        break;
    }
    __ebx = sizes[sizepos];
    asm("fld dword [ebp-0xc]");
    asm("fld qword [0x80cab78]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80cab80]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fld qword [0x80cab78]");
    asm("fdivp st1, st0");
    if(usefloat == 0) {
        _t22 = "%.0f%s";
    } else {
        _t22 = "%.3g%s";
    }
    _v48 = __ebx;
    asm("fstp qword [esp+0x4]");
    return  *(Sprintf(_t22));
}

char* convert_size2(clen_t size1, clen_t size2, int usefloat)
{// addr = 0x0806DA74  --  defined in 'file.c' at line 6595
    float csize;                           // _cfa_ffffffec
    char** sizes;                          // _cfa_fffffff0
    float factor;                          // _cfa_ffffffe8
    int sizepos;                           // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    signed int _t33;                       // _t33
    char* _t37;                            // _t37
    intOrPtr _t44;                         // _t44
    char* _t45;                            // _t45

    _v36 = _a4;
    _v32 = _a8;
    _v44 = _a12;
    _v40 = _a16;
    sizes =  &_size_unit;
    factor = 1065353216;
    sizepos = 0;
    __ecx = _v36;
    _t44 = _v32;
    _t33 = _v44;
    __edx = _v40;
    if(__edx <= _t44 && (__edx < _t44 || _t33 < __ecx)) {
        _t33 = __ecx;
        __edx = _t44;
    }
    _v52 = _t33;
    _v48 = __edx;
    asm("fild qword [ebp-0x30]");
    asm("fstp dword [ebp-0x10]");
    while(1) {
        asm("fld dword [ebp-0x10]");
        asm("fdiv dword [ebp-0x14]");
        asm("fld qword [0x80caba8]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t33 & 255) == 0) {
            break;
        }
        _t33 = sizes[sizepos + 1];
        if(_t33 != 0) {
            asm("fld dword [ebp-0x14]");
            asm("fld dword [0x80caba0]");
            asm("fmulp st1, st0");
            asm("fstp dword [ebp-0x14]");
            sizepos = sizepos + 1;
            continue;
        }
        break;
    }
    _t45 = sizes[sizepos];
    asm("fild qword [ebp-0x28]");
    asm("fdiv dword [ebp-0x14]");
    asm("fld qword [0x80cab78]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80cab80]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fld qword [0x80cab78]");
    asm("fdivp st1, st0");
    asm("fstp qword [ebp-0x38]");
    asm("fild qword [ebp-0x20]");
    asm("fdiv dword [ebp-0x14]");
    asm("fld qword [0x80cab78]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80cab80]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fld qword [0x80cab78]");
    asm("fdivp st1, st0");
    if(usefloat == 0) {
        _t37 = "%.0f/%.0f%s";
    } else {
        _t37 = "%.3g/%.3g%s";
    }
    _v72 = _t45;
    asm("fld qword [ebp-0x38]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    return  *(Sprintf(_t37));
}

showProgress(clen_t* linelen, clen_t* trbyte)
{// addr = 0x0806DB9B  --  defined in 'file.c' at line 6613
    double ratio;                          // _cfa_ffffffb4
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int rate;                              // _cfa_ffffffd8
    int duration;                          // _cfa_ffffffd4
    int eta;                               // _cfa_ffffffd0
    int pos;                               // _cfa_ffffffcc
    time_t cur_time;    // _cfa_ffffffc8
    Str messages;          // _cfa_ffffffc4
    char* fmtrbyte;                        // _cfa_ffffffc0
    char* fmrate;                          // _cfa_ffffffbc
    long long int _v80;                    // _cfa_ffffffb0
    long long int _v84;                    // _cfa_ffffffac
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    long long int _v108;                   // _cfa_ffffff94
    long long int _v112;                   // _cfa_ffffff90
    long long int _v116;                   // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t158;                       // _t158
    clen_t* _t160;      // _t160
    long long int _t161;                   // _t161
    long int _t162;                        // _t162
    clen_t* _t167;      // _t167
    clen_t* _t170;      // _t170
    clen_t* _t175;      // _t175
    signed int _t186;                      // _t186
    clen_t* _t198;      // _t198
    clen_t* _t201;      // _t201
    clen_t* _t206;      // _t206
    clen_t* _t209;      // _t209
    signed int _t235;                      // _t235
    int _t237;                             // _t237
    _unknown_ _t239;                       // _t239
    _unknown_ _t246;                       // _t246
    _unknown_ _t251;                       // _t251
    _unknown_ _t258;                       // _t258
    _unknown_ _t271;                       // _t271
    _unknown_ _t274;                       // _t274
    _unknown_ _t285;                       // _t285
    clen_t* _t289;      // _t289
    clen_t* _t294;      // _t294
    _unknown_ _t311;                       // _t311
    long long int _t312;                   // _t312
    long long int _t313;                   // _t313
    long long int _t318;                   // _t318
    _unknown_ _t333;                       // _t333
    _unknown_ _t340;                       // _t340
    _unknown_ _t344;                       // _t344
    _unknown_ _t351;                       // _t351

    if((fmInitialized & 0xff) == 0) {
        return;
    }
    _t160 = linelen;
    _t312 = _t160[0];
    _t161 =  *_t160;
    if(_t312 > 0) {
L4:
        _t162 = current_content_length;
        _t313 =  *135776436;
        if(_t313 >= 0 || _t313 <= 0 && _t162 <= 0) {
             *__esp = 0;
            time();
            cur_time = _t162;
            if(( *trbyte | trbyte[0]) == 0) {
                move(LINES - 1, 0);
                clrtoeolx();
                start_time = cur_time;
            }
            _t167 = linelen;
            asm("adc edx, ebx");
            _t289 = trbyte;
             *_t289 =  *_t167 +  *trbyte;
            _t289[0] = _t167[0];
            _t170 = linelen;
             *_t170 = 0;
            _t170[0] = 0;
            if(cur_time == last_time) {
                goto L31;
            } else {
                last_time = cur_time;
                move(LINES - 1, 0);
                _t175 = trbyte;
                _v116 = 1;
                 *__esp =  *_t175;
                _v120 = _t175[0];
                fmtrbyte = convert_size();
                duration = cur_time - start_time;
                if(duration == 0) {
                    _v120 = fmtrbyte;
                    messages = Sprintf("%7s loaded");
                } else {
                    _t318 = trbyte[0];
                    _t186 = __divdi3( *trbyte, _t318, duration, duration >> 31);
                    _v116 = 1;
                     *__esp = _t186;
                    _v120 = _t318;
                    fmrate = convert_size();
                    _v116 = fmrate;
                    _v120 = fmtrbyte;
                    messages = Sprintf("%7s loaded %7s/s");
                }
                message(messages->ptr, 0, 0);
                refresh();
                return;
            }
        } else {
             *__esp = 0;
            time();
            cur_time = _t162;
            if(( *trbyte | trbyte[0]) == 0) {
                move(LINES - 1, 0);
                clrtoeolx();
                start_time = cur_time;
            }
            _t198 = linelen;
            asm("adc edx, ebx");
            _t294 = trbyte;
             *_t294 =  *_t198 +  *trbyte;
            _t294[0] = _t198[0];
            _t201 = linelen;
             *_t201 = 0;
            _t201[0] = 0;
            if(cur_time == last_time) {
L30:
                return;
            } else {
                last_time = cur_time;
                move(LINES - 1, 0);
                _t206 = trbyte;
                _v84 =  *_t206;
                _v80 = _t206[0];
                asm("fild qword [ebp-0x50]");
                asm("fld qword [0x80cab78]");
                asm("fmulp st1, st0");
                _v84 = current_content_length;
                _v80 =  *135776436;
                asm("fild qword [ebp-0x50]");
                asm("fdivp st1, st0");
                asm("fstp qword [ebp-0x48]");
                _t209 = trbyte;
                _v108 = 1;
                _v116 = current_content_length;
                _v112 =  *135776436;
                 *__esp =  *_t209;
                _v120 = _t209[0];
                fmtrbyte = convert_size2();
                duration = cur_time - start_time;
                if(duration == 0) {
                    asm("fld qword [ebp-0x48]");
                    asm("fstp qword [esp+0x8]");
                    _v120 = fmtrbyte;
                    messages = Sprintf("%11s %3.0f%%                          ");
                } else {
                    rate = __divdi3( *trbyte, trbyte[0], duration, duration >> 31);
                    _t235 = rate;
                    _v116 = 1;
                     *__esp = _t235;
                    _v120 = _t235 >> 31;
                    fmrate = convert_size();
                    if(rate == 0) {
                        _t237 = -1;
                    } else {
                        asm("sbb edx, ebx");
                        _t237 = __divdi3(current_content_length -  *trbyte,  *135776436, rate, rate >> 31);
                    }
                    eta = _t237;
                    _t301 = eta;
                    _t302 = eta;
                    _t304 = ((eta * -2004318071 >> 32) + eta >> 5) - (_t302 >> 31);
                    _v96 = eta - (((eta * -2004318071 >> 32) + eta >> 5) - (_t301 >> 31) << 2 << 4) - (((eta * -2004318071 >> 32) + eta >> 5) - (_t301 >> 31) << 2);
                    _v100 = ((eta * -2004318071 >> 32) + eta >> 5) - (_t302 >> 31) - ((((((eta * -2004318071 >> 32) + eta >> 5) - (_t302 >> 31)) * -2004318071 >> 32) + ((eta * -2004318071 >> 32) + eta >> 5) - (_t302 >> 31) >> 5) - (_t304 >> 31) << 2 << 4) - ((((((eta * -2004318071 >> 32) + eta >> 5) - (_t302 >> 31)) * -2004318071 >> 32) + ((eta * -2004318071 >> 32) + eta >> 5) - (_t302 >> 31) >> 5) - (_t304 >> 31) << 2);
                    _v104 = ((eta * -1851608123 >> 32) + eta >> 11) - (eta >> 31);
                    _v108 = fmrate;
                    asm("fld qword [ebp-0x48]");
                    asm("fstp qword [esp+0x8]");
                    _v120 = fmtrbyte;
                    messages = Sprintf("%11s %3.0f%% %7s/s eta %02d:%02d:%02d     ");
                }
                addstr(messages->ptr);
                pos = 42;
                i = __divdi3( *trbyte * (COLS - pos - 1), (COLS - pos - 1 >> 31) *  *trbyte + trbyte[0] * (COLS - pos - 1) + ( *trbyte * (COLS - pos - 1) >> 32), current_content_length,  *135776436) + pos;
                move(LINES - 1, pos);
                standout();
                addch(32);
                j = pos + 1;
                while(j <= i) {
                    addch(124);
                    j = j + 1;
                }
                standend();
                refresh();
                return;
            }
L31:
            return;
        }
    }
    if(_t312 >= 0) {
        goto L28;
    }
    if(_t161 <= 1023) {
        return;
    }
    goto L4;
L28:
    return;
}

init_henv(struct html_feed_environ* h_env, struct readbuffer* obuf, struct environment* envs, int nenv, TextLineList* buf, int limit, int indent)
{// addr = 0x0806E0B9  --  defined in 'file.c' at line 6698
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t98;                        // _t98

    envs->indent = indent & 255;
    obuf->line = Strnew();
     *(obuf + 4) = 0;
    obuf->pos = 0;
     *(obuf + 8) = Strnew_size(8);
    Strcopy_charp_n( *(obuf + 8), " ", 1);
    obuf->flag = 8192;
    obuf->flag_sp = 0;
    obuf->status = 0;
    obuf->table_level = 65535;
    obuf->nobr_level = 0;
    bzero(obuf + 72, 60);
     *(obuf + 132) = 0;
    obuf->fontstat = 0;
    obuf->fontstat[2] = 0;
    obuf->fontstat[1] = 0;
    obuf->fontstat[3] = 0;
    obuf->fontstat[4] = 0;
     *(obuf + 184) = 0;
    obuf->tag_sp = 0;
    obuf->fontstat_sp = 0;
    obuf->top_margin = 0;
    obuf->bottom_margin = 0;
     *(obuf + 280) = 1;
    set_breakpoint(obuf, 0);
    h_env->buf = buf;
    h_env->f = 0;
    h_env->obuf = obuf;
     *(h_env + 12) = Strnew();
    h_env->limit = limit;
    h_env->maxlimit = 0;
    h_env->envs = envs;
    h_env->nenv = nenv;
    h_env->envc = 0;
    h_env->envc_real = 0;
    h_env->title = 0;
    h_env->blank_lines = 0;
    return;
}

completeHTMLstream(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x0806E26B  --  defined in 'file.c' at line 6744
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    close_anchor(h_env, obuf);
    if( *(obuf + 132) != 0) {
        push_tag(obuf, "</img_alt>", 137);
         *(obuf + 132) = 0;
    }
    if((obuf->fontstat & 0xff) != 0) {
        push_tag(obuf, "</b>", 8);
        obuf->fontstat = 0;
    }
    if((obuf->fontstat[2] & 0xff) != 0) {
        push_tag(obuf, "</i>", 110);
        obuf->fontstat[2] = 0;
    }
    if((obuf->fontstat[1] & 0xff) != 0) {
        push_tag(obuf, "</u>", 66);
        obuf->fontstat[1] = 0;
    }
    if((obuf->fontstat[3] & 0xff) != 0) {
        push_tag(obuf, "</s>", 106);
        obuf->fontstat[3] = 0;
    }
    if((obuf->fontstat[4] & 0xff) != 0) {
        push_tag(obuf, "</ins>", 64);
        obuf->fontstat[4] = 0;
    }
    if((obuf->flag & 2048) != 0) {
        HTMLlineproc0("</textarea>", h_env, 1);
    }
    if((obuf->flag & 4096) != 0) {
        HTMLlineproc0("</select>", h_env, 1);
    }
    if((obuf->flag & 16384) != 0) {
        HTMLlineproc0("</title>", h_env, 1);
    }
    if((obuf->table_level & 0xffff) > 19) {
        obuf->table_level = 19;
    }
    while((obuf->table_level & 0xffff) >= 0) {
        asm("cwde ");
         *( &table_mode + ((obuf->table_level & 0xffff) << 4)) =  *( &table_mode + ((obuf->table_level & 65535) << 4)) & 241;
        HTMLlineproc0("</table>", h_env, 1);
    }
    return;
}

print_internal_information(struct html_feed_environ* henv)
{// addr = 0x0806E4A4  --  defined in 'file.c' at line 6791
    int i;                                 // _cfa_fffffff0
    Str s;                 // _cfa_ffffffec
    TextLineList* tl;   // _cfa_ffffffe8
    FormSelectOptionItem* ip;   // _cfa_ffffffe4
    TextLineListItem* p;   // _cfa_ffffffe0
    int _v48;                              // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* __ebx;                           // r1
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t105;                       // _t105
    struct _Str* _t125;   // _t125
    _unknown_ _t128;                       // _t128
    _unknown_ _t135;                       // _t135
    char* _t168;                           // _t168
    char* _t169;                           // _t169
    char* _t182;                           // _t182

    tl = newGeneralList();
    s = Strnew_charp("<internal>");
    pushValue(tl, newTextLine(s, 0));
    if(henv->title != 0) {
        _t182 = html_quote(henv->title);
        _v48 = 0;
        _v52 = "">";
        _v56 = _t182;
        s = Strnew_m_charp("<title_alt title="");
        pushValue(tl, newTextLine(s, 0));
    }
    if(n_select > 0) {
        i = 0;
        while(i < n_select) {
            _v56 = i;
            s = Sprintf("<select_int selectnumber=%d>");
            pushValue(tl, newTextLine(s, 0));
            ip =  *(select_option + (i << 3));
            while(ip != 0) {
                if(ip->checked == 0) {
                    __ebx = 135041709;
                } else {
                    __ebx = " selected";
                }
                __esi = html_quote( *( *(ip + 4)));
                if(ip->value == 0) {
                    _t168 =  *( *(ip + 4));
                } else {
                    _t168 = ip->value->value;
                }
                _t169 = html_quote(_t168);
                _v48 = __ebx;
                _v52 = __esi;
                _v56 = _t169;
                s = Sprintf("<option_int value="%s" label="%s"%s>");
                pushValue(tl, newTextLine(s, 0));
                ip = ip->next;
            }
            s = Strnew_charp("</select_int>");
            pushValue(tl, newTextLine(s, 0));
            i = i + 1;
        }
    }
    if(n_textarea <= 0) {
    } else {
        i = 0;
        while(i < n_textarea) {
            _v56 = i;
            s = Sprintf("<textarea_int textareanumber=%d>");
            pushValue(tl, newTextLine(s, 0));
            s = Strnew_charp(html_quote( *( *(textarea_str + (i << 2)))));
            Strcat_charp(s, "</textarea_int>");
            pushValue(tl, newTextLine(s, 0));
            i = i + 1;
        }
    }
    goto L19;
L21:
    if(henv->f != 0) {
        p = tl->first;
        while(p != 0) {
            if((ExtHalfdump & 0xff) == 0) {
                _t125 = p->ptr->ptr;
            } else {
                _t125 = wc_Str_conv(p->ptr->ptr, InnerCharset, DisplayCharset);
            }
            _v52 = _t125->ptr;
            fprintf(henv->f, "%s\n");
            p = p->next;
        }
    }
L28:
    return;
L19:
    s = Strnew_charp("</internal>");
    pushValue(tl, newTextLine(s, 0));
    if(henv->buf == 0) {
    } else {
        appendGeneralList(henv->buf, tl);
        return;
    }
    goto L21;
}

loadHTMLstream(URLFile* f, Buffer* newBuf, FILE* src, int internal)
{// addr = 0x0806E813  --  defined in 'file.c' at line 6869
    Str lineBuf2;          // _cfa_fffffff0
    wc_ces charset;     // _cfa_ffffffec
    _None doc_charset;                     // _cfa_ffffffe8
    _None image_flag;                      // _cfa_ffffffe4
    _None prevtrap;                        // _cfa_ffffffe0
    int _v40;                              // _cfa_ffffffd8
    clen_t linelen;     // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    clen_t trbyte;      // _cfa_ffffffcc
    struct html_feed_environ htmlenv1;   // _cfa_ffffff9c
    struct environment[19] envs;   // _cfa_fffffe5c
    struct readbuffer obuf;   // _cfa_fffffd0c
    _unknown_ _v772;                       // _cfa_fffffcfc
    _unknown_ _v776;                       // _cfa_fffffcf8
    int _v780;                             // _cfa_fffffcf4
    intOrPtr _v784;                        // _cfa_fffffcf0
    long long int _v788;                   // _cfa_fffffcec
    int _v792;                             // _cfa_fffffce8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t226;                       // _t226
    _unknown_ _t231;                       // _t231
    int _t233;                             // _t233
    Str* _t235;            // _t235
    FormSelectOption* _t237;   // _t237
    FILE* _t251;          // _t251
    _unknown_ _t290;                       // _t290
    _unknown_ _t295;                       // _t295
    _unknown_ _t328;                       // _t328
    _unknown_ _t335;                       // _t335
    _unknown_ _t341;                       // _t341
    _unknown_ _t388;                       // _t388
    _unknown_ _t398;                       // _t398
    _unknown_ _t399;                       // _t399

    linelen = 0;
    _v40 = 0;
    trbyte = 0;
    _v48 = 0;
    lineBuf2 = Strnew();
    charset = 256;
    doc_charset = DocumentCharset;
    prevtrap = 0;
    if((fmInitialized & 0xff) == 0) {
L3:
        symbol_width0 = 0;
        get_symbol(DisplayCharset,  &symbol_width0);
        if(( *135119023 & 0xff) == 0) {
            _t233 = 1;
        } else {
            _t233 = symbol_width0;
        }
        symbol_width = _t233;
        goto L7;
    }
    if(graph_ok() == 0) {
        goto L3;
    } else {
        symbol_width0 = 1;
        symbol_width = symbol_width0;
    }
L7:
    cur_title = 0;
    n_textarea = 0;
    cur_textarea = 0;
    max_textarea = 10;
    _t235 = max_textarea << 2;
     *__esp = _t235;
    GC_malloc();
    textarea_str = _t235;
    n_select = 0;
    max_select = 10;
    _t237 = max_select << 3;
     *__esp = _t237;
    GC_malloc();
    select_option = _t237;
    cur_select = 0;
    form_sp = -1;
    form_max = -1;
    forms_size = 0;
    forms = 0;
    cur_hseq = 1;
    cur_iseq = 1;
    if((newBuf->image_flag & 0xff) == 0) {
        if(activeImage == 0 || displayImage == 0) {
L13:
            image_flag = 1;
        } else {
            if(autoImage == 0) {
                goto L13;
            } else {
                image_flag = 2;
            }
        }
    } else {
        image_flag = newBuf->image_flag & 0xff;
    }
    if( *((intOrPtr*)(newBuf + 152)) != 0) {
        cur_baseURL = baseURL(newBuf);
    }
    if(w3m_halfload != 0) {
        newBuf->buffername = "---";
         *(newBuf + 208) = InnerCharset;
        max_textarea = 0;
        max_select = 0;
        HTMLlineproc3(newBuf,  *(f + 4));
        w3m_halfload = 0;
        return;
    }
    asm("cwde ");
    init_henv( &(htmlenv1.obuf),  &(obuf.line),  &envs, 20, 0, newBuf->width & 65535, 0);
    if((w3m_dump & 16) == 0) {
        _t251 = newGeneralList();
        htmlenv1.buf = _t251;
    } else {
        _t251 = __imp__stdout;
        htmlenv1.f = _t251;
    }
    _v792 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t251 == 0) {
        if((TrapSignal & 0xff) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 0xff) != 0) {
                term_cbreak();
            }
        }
        if(newBuf != 0) {
            asm("cwde ");
            if((newBuf->bufferprop & 2) == 0) {
                if( *(newBuf + 208) != 0) {
                    doc_charset =  *(newBuf + 208);
                    charset = doc_charset;
                }
            } else {
                charset = InnerCharset;
            }
        }
        if(content_charset == 0 || (UseContentCharset & 0xff) == 0) {
            if(f->guess_type != 0 && strcasecmp(f->guess_type, "application/xhtml+xml") == 0) {
                doc_charset = 3178565;
            }
        } else {
            doc_charset = content_charset;
        }
        meta_charset = 0;
        if(( *(f + 4)->base.stream.cur & 0xff) != 4) {
             *(f + 4) = newEncodedStream( *(f + 4), f->encoding & 0xff);
        }
        while(1) {
            lineBuf2 = StrmyISgets( *(f + 4));
            if(lineBuf2->length == 0) {
                break;
            }
            if((f->scheme & 0xff) != 9 || ( *(lineBuf2->ptr) & 0xff) != 46) {
L44:
                if(src != 0) {
                    fwrite(lineBuf2->ptr, 1, lineBuf2->length, src);
                }
                asm("adc edx, ebx");
                linelen = linelen + lineBuf2->length;
                _v40 = _v40;
                if((w3m_dump & 8) != 0) {
                    _v780 = 1;
                    _v788 = current_content_length;
                    _v784 =  *135776436;
                     *__esp = linelen;
                    _v792 = _v40;
                    _v792 = convert_size2();
                    printf("W3m-in-progress: %s\n");
                }
                if((w3m_dump & 4) == 0) {
                    showProgress( &linelen,  &trbyte);
                    if(meta_charset != 0) {
                        if(content_charset == 0 && (UseContentCharset & 0xff) != 0) {
                            doc_charset = meta_charset;
                            charset = 256;
                        }
                        meta_charset = 0;
                    }
                    lineBuf2 = convertLine(f, lineBuf2, 2,  &charset, doc_charset);
                    cur_document_charset = charset & 255;
                    HTMLlineproc0(lineBuf2->ptr,  &(htmlenv1.obuf), internal);
                }
                continue;
            } else {
                Strdelete(lineBuf2, 0, 1);
                if((lineBuf2 & 0xff) == 10 || (lineBuf2 & 0xff) == 13 || (lineBuf2 & 0xff) == 0) {
                    break;
                }
                goto L44;
            }
        }
        if(_v696 != 0) {
            obuf.status = 7;
            HTMLlineproc0("\n",  &(htmlenv1.obuf), internal);
        }
        obuf.status = 0;
        completeHTMLstream( &(htmlenv1.obuf),  &(obuf.line));
        flushline( &(htmlenv1.obuf),  &(obuf.line), 0, 2, htmlenv1.limit);
        if(_v60 != 0) {
            newBuf->buffername = htmlenv1.title;
        }
        if((w3m_dump & 16) == 0) {
            if(w3m_backend == 0) {
                goto L76;
            }
        } else {
            if((TrapSignal & 0xff) != 0) {
                if((fmInitialized & 0xff) != 0) {
                    term_raw();
                }
                if(prevtrap != 0) {
                    mySignal(2, prevtrap);
                }
            }
            print_internal_information( &(htmlenv1.obuf));
            return;
        }
        if((TrapSignal & 0xff) != 0) {
            if((fmInitialized & 0xff) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        print_internal_information( &(htmlenv1.obuf));
        backend_halfdump_buf = htmlenv1.buf;
        return;
    } else {
        HTMLlineproc0("<br>Transfer Interrupted!<br>",  &(htmlenv1.obuf), 1);
    }
L76:
     *((intOrPtr*)(newBuf + 200)) = trbyte + linelen;
    if((TrapSignal & 0xff) != 0) {
        if((fmInitialized & 0xff) != 0) {
            term_raw();
        }
        if(prevtrap != 0) {
            mySignal(2, prevtrap);
        }
    }
    asm("cwde ");
    if((newBuf->bufferprop & 2) == 0) {
         *(newBuf + 208) = charset;
    }
    newBuf->image_flag = image_flag & 255;
    HTMLlineproc2(newBuf, htmlenv1.buf);
    return;
}

Buffer* loadHTMLString(Str page)
{// addr = 0x0806EF44  --  defined in 'file.c' at line 7050
    _None prevtrap;                        // _cfa_fffffff0
    Buffer* newBuf;     // _cfa_ffffffec
    URLFile f;         // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    int _t63;                              // _t63
    _unknown_ _t64;                        // _t64
    Buffer* _t66;       // _t66
    _unknown_ _t93;                        // _t93
    _unknown_ _t98;                        // _t98
    _unknown_ _t102;                       // _t102
    int _t105;                             // _t105
    _unknown_ _t106;                       // _t106

    prevtrap = 0;
    _t105 = COLS;
    if(showLineNum == 0) {
        _t63 = 1;
    } else {
        _t63 = 6;
    }
    _t64 = _t105 - _t63;
    _t65 = _t64 >= 0 ? 0 : _t64;
    _t66 = newBuffer(_t64 >= 0 ? 0 : _t64);
    newBuf = _t66;
    _v72 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t66 == 0) {
        if((TrapSignal & 0xff) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 0xff) != 0) {
                term_cbreak();
            }
        }
        init_stream( &(f.scheme), 4, newStrStream(page));
         *(newBuf + 208) = InnerCharset;
        loadHTMLstream( &(f.scheme), newBuf, 0, 1);
         *(newBuf + 208) = 256;
        if((TrapSignal & 0xff) != 0) {
            if((fmInitialized & 0xff) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        newBuf->topLine = newBuf->firstLine;
        newBuf->lastLine = newBuf->currentLine;
        newBuf->currentLine = newBuf->firstLine;
        newBuf->type = "text/html";
        newBuf->real_type = newBuf->type;
        if(n_textarea != 0) {
            formResetBuffer(newBuf, newBuf->formitem);
        }
        return newBuf;
    } else {
        if((TrapSignal & 0xff) != 0) {
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        discardBuffer(newBuf);
        return 0;
    }
}

Str loadGopherDir(URLFile* uf, ParsedURL* pu, wc_ces* charset)
{// addr = 0x0806F10D  --  defined in 'file.c' at line 7091
    _None tmp;                             // _cfa_ffffffe0
    Str lbuf;              // _cfa_ffffffdc
    Str name;              // _cfa_ffffffd8
    Str file;              // _cfa_ffffffd4
    Str host;              // _cfa_ffffffd0
    Str port;              // _cfa_ffffffcc
    _None p;                               // _cfa_ffffffc8
    _None q;                               // _cfa_ffffffc4
    _None prevtrap;                        // _cfa_ffffffc0
    wc_ces doc_charset;   // _cfa_ffffffbc
    unsigned int _v80;                     // _cfa_ffffffb0
    URLFile* _v96;     // _cfa_ffffffa0
    URLFile* _v100;    // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    char* _v108;                           // _cfa_ffffff94
    char* _v112;                           // _cfa_ffffff90
    char* _v116;                           // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _None _t202;                           // _t202
    _unknown_ _t209;                       // _t209
    signed int _t269;                      // _t269
    char* _t279;                           // _t279
    char* _t287;                           // _t287

    prevtrap = 0;
    doc_charset = DocumentCharset;
    tmp = parsedURL2Str(pu);
    p = html_quote( *tmp);
    tmp = convertLine(0, Strnew_charp(file_unquote( *tmp)), 0, charset, doc_charset);
    q = html_quote( *tmp);
    _v96 = 0;
    _v100 = "</h1>\n<table>\n";
    _v104 = q;
    _v108 = "</title>\n</head>\n<body>\n<h1>Index of ";
    _v112 = q;
    _v116 = "">\n<title>";
    _v120 = p;
    _t202 = Strnew_m_charp("<html>\n<head>\n<base href="");
    tmp = _t202;
    _v120 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t202 != 0) {
        goto L52;
    } else {
        if((TrapSignal & 0xff) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 0xff) != 0) {
                term_cbreak();
            }
        }
        while(1) {
            lbuf = StrISgets( *(uf + 4));
            if(lbuf->length == 0) {
                break;
            }
            if((lbuf & 0xff) != 46 || (lbuf->ptr[1] & 0xff) != 10 && (lbuf->ptr[1] & 0xff) != 13) {
                lbuf = convertLine(uf, lbuf, 2, charset, doc_charset);
                p = lbuf->ptr;
                q = p;
L10:
                while(( *q & 0xff) != 0) {
L11:
                    if(( *q & 0xff) != 9) {
                        q =  &((1)[q]);
                        goto L10;
                    }
                    break;
                }
                name = Strnew_charp_n(p, q - p);
                if(( *q & 0xff) != 0) {
                    p =  &((1)[q]);
                    q = p;
                    while(( *q & 0xff) != 0 && ( *q & 0xff) != 9) {
                        q =  &((1)[q]);
                    }
                    file = Strnew_charp_n(p, q - p);
                    if(( *q & 0xff) != 0) {
                        p =  &((1)[q]);
                        q = p;
L22:
                        while(( *q & 0xff) != 0 && ( *q & 0xff) != 9) {
                            goto L21;
                        }
                        host = Strnew_charp_n(p, q - p);
                        if(( *q & 0xff) != 0) {
                            p =  &((1)[q]);
                            q = p;
L28:
                            while(( *q & 0xff) != 0 && ( *q & 0xff) != 9 && ( *q & 0xff) != 13 && ( *q & 0xff) != 10) {
                                goto L27;
                            }
                            port = Strnew_charp_n(p, q - p);
                            _t269 = name & 0xff;
                            if(_t269 == 103) {
L45:
                                p = "[gif]";
                                goto L48;
                            }
                            if(_t269 > 103) {
                                if(_t269 == 109) {
                                    goto L43;
                                }
                                goto L38;
L44:
                                p = "[sound]";
                                goto L48;
                            }
                            if(_t269 == 48) {
                                p = "[text file]";
                                goto L48;
                            }
                            if(_t269 == 49) {
                                goto L42;
                            }
L47:
                            p = "[unsupported]";
L48:
                            _v100 = 0;
                            _v104 = file->ptr;
                            _v108 = "/";
                            _v112 = port->ptr;
                            _v116 = ":";
                            _v120 = host->ptr;
                            q =  *(Strnew_m_charp("gopher://"));
                            _t279 = html_quote( &(name->ptr[1]));
                            _v80 =  *charset;
                            _t287 = html_quote(url_quote( *(wc_Str_conv_strict(Strnew_charp(q), InnerCharset, _v80))));
                            _v96 = 0;
                            _v100 = "</a>\n";
                            _v104 = _t279;
                            _v108 = p;
                            _v112 = "">";
                            _v116 = _t287;
                            _v120 = "<a href="";
                            Strcat_m_charp(tmp);
                            continue;
L43:
                            p = "[message]";
                            goto L48;
L42:
                            p = "[directory]";
                            goto L48;
L38:
                            if(_t269 == 115) {
                                goto L44;
                            }
                            if(_t269 == 104) {
                                goto L46;
                            }
                            goto L47;
L46:
                            p = "[HTML]";
                            goto L48;
                        }
                        goto L49;
L27:
                        q =  &((1)[q]);
                        goto L28;
                    }
                    goto L49;
L21:
                    q =  &((1)[q]);
                    goto L22;
                } else {
                }
L49:
                continue;
            }
L52:
            if((TrapSignal & 0xff) != 0) {
                if((fmInitialized & 0xff) != 0) {
                    term_raw();
                }
                if(prevtrap != 0) {
                    mySignal(2, prevtrap);
                }
            }
            Strcat_charp(tmp, "</table>\n</body>\n</html>\n");
            return tmp;
        }
    }
    goto L52;
}

Buffer* loadBuffer(URLFile* uf, _None newBuf)
{// addr = 0x0806F5A5  --  defined in 'file.c' at line 7183
    _None pre_lbuf;                        // _cfa_ffffffe3
    _None src;                             // _cfa_ffffffdc
    wc_ces charset;     // _cfa_ffffffd8
    _None doc_charset;                     // _cfa_ffffffd4
    Str lineBuf2;          // _cfa_ffffffd0
    int nlines;                            // _cfa_ffffffcc
    Str tmpf;              // _cfa_ffffffc8
    Lineprop* propBuffer;   // _cfa_ffffffc4
    Linecolor* colorBuffer;   // _cfa_ffffffc0
    _None prevtrap;                        // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    clen_t linelen;     // _cfa_ffffffb4
    int _v80;                              // _cfa_ffffffb0
    clen_t trbyte;      // _cfa_ffffffac
    _unknown_ _v100;                       // _cfa_ffffff9c
    _unknown_ _v104;                       // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    intOrPtr _v112;                        // _cfa_ffffff90
    long long int _v116;                   // _cfa_ffffff8c
    int _v120;                             // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    struct _Str* _t188;   // _t188
    int _t228;                             // _t228
    int _t231;                             // _t231
    _unknown_ _t232;                       // _t232
    _unknown_ _t243;                       // _t243
    _unknown_ _t248;                       // _t248
    _unknown_ _t267;                       // _t267
    _unknown_ _t271;                       // _t271
    int _t301;                             // _t301
    _unknown_ _t302;                       // _t302
    _unknown_ _t306;                       // _t306
    _unknown_ _t327;                       // _t327
    _unknown_ _t328;                       // _t328
    int _t333;                             // _t333
    _unknown_ _t334;                       // _t334
    int _t342;                             // _t342
    _unknown_ _t343;                       // _t343

    src = 0;
    charset = 256;
    doc_charset = DocumentCharset;
    pre_lbuf = 0;
    linelen = 0;
    _v72 = 0;
    trbyte = 0;
    _v80 = 0;
    propBuffer = 0;
    colorBuffer = 0;
    prevtrap = 0;
    if(newBuf == 0) {
        _t342 = COLS;
        if(showLineNum == 0) {
            _t301 = 1;
        } else {
            _t301 = 6;
        }
        _t302 = _t342 - _t301;
        _t303 = _t302 >= 0 ? 0 : _t302;
        newBuf = newBuffer(_t302 >= 0 ? 0 : _t302);
    }
    _t188 = Strnew();
    lineBuf2 = _t188;
    _v120 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t188 == 0) {
        if((TrapSignal & 0xff) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 0xff) != 0) {
                term_cbreak();
            }
        }
        if( *(newBuf + 184) == 0 && ((uf->scheme & 0xff) != 4 ||  *((intOrPtr*)(newBuf + 232)) != 0)) {
            tmpf = tmpfname(1, 0);
            src = fopen(tmpf->ptr, "w");
            if(src != 0) {
                 *(newBuf + 184) = tmpf->ptr;
            }
        }
        if( *(newBuf + 208) != 0) {
            doc_charset =  *(newBuf + 208);
            charset = doc_charset;
        }
        if(content_charset != 0 && (UseContentCharset & 0xff) != 0) {
            doc_charset = content_charset;
        }
        nlines = 0;
        if(( *(uf + 4)->base.stream.cur & 0xff) != 4) {
             *(uf + 4) = newEncodedStream( *(uf + 4), uf->encoding & 0xff);
        }
        while(1) {
            lineBuf2 = StrmyISgets( *(uf + 4));
            if(lineBuf2->length == 0) {
                break;
            }
            if((uf->scheme & 0xff) != 9 || ( *(lineBuf2->ptr) & 0xff) != 46) {
L26:
                if(src != 0) {
                    fwrite(lineBuf2->ptr, 1, lineBuf2->length, src);
                }
                asm("adc edx, ebx");
                linelen = linelen + lineBuf2->length;
                _v72 = _v72;
                if((w3m_dump & 8) != 0) {
                    _v108 = 1;
                    _v116 = current_content_length;
                    _v112 =  *135776436;
                     *__esp = linelen;
                    _v120 = _v72;
                    _v120 = convert_size2();
                    printf("W3m-in-progress: %s\n");
                }
                if((w3m_dump & 4) != 0) {
                    continue;
                } else {
                    showProgress( &linelen,  &trbyte);
                    if(frame_source != 0) {
                        goto L46;
                    }
                    lineBuf2 = convertLine(uf, lineBuf2, 1,  &charset, doc_charset);
                    if(squeezeBlankLine == 0) {
L37:
                        nlines = nlines + 1;
                        Strchop(lineBuf2);
                        lineBuf2 = checkType(lineBuf2,  &propBuffer, 0);
                        if(FoldLine == 0) {
                            _t228 = -1;
                        } else {
                            _t333 = COLS;
                            if(showLineNum == 0) {
                                _t231 = 1;
                            } else {
                                _t231 = 6;
                            }
                            _t232 = _t333 - _t231;
                            _t233 = _t232 >= 0 ? 0 : _t232;
                            _t228 = (_t232 >= 0 ? 0 : _t232) + 1;
                        }
                        addnewline(newBuf, lineBuf2->ptr, propBuffer, colorBuffer, lineBuf2->length, _t228, nlines);
                        continue;
                    }
                    if((lineBuf2 & 0xff) != 10 || (pre_lbuf & 0xff) != 10) {
                        pre_lbuf = lineBuf2 & 0xff;
                    } else {
                        nlines = nlines + 1;
                        continue;
                    }
                    goto L37;
                }
L46:
                continue;
            } else {
                Strdelete(lineBuf2, 0, 1);
                if((lineBuf2 & 0xff) == 10 || (lineBuf2 & 0xff) == 13 || (lineBuf2 & 0xff) == 0) {
                    goto L50;
                } else {
                    goto L26;
                }
            }
        }
    }
L50:
    if((TrapSignal & 0xff) != 0) {
        if((fmInitialized & 0xff) != 0) {
            term_raw();
        }
        if(prevtrap != 0) {
            mySignal(2, prevtrap);
        }
    }
     *((intOrPtr*)(newBuf + 12)) =  *((intOrPtr*)(newBuf + 8));
     *((intOrPtr*)(newBuf + 20)) =  *((intOrPtr*)(newBuf + 16));
     *((intOrPtr*)(newBuf + 16)) =  *((intOrPtr*)(newBuf + 8));
     *((intOrPtr*)(newBuf + 200)) = trbyte + linelen;
     *(newBuf + 208) = charset;
    if(src != 0) {
        fclose(src);
    }
    return newBuf;
}

Buffer* loadImageBuffer(URLFile* uf, Buffer* newBuf)
{// addr = 0x0806FA5B  --  defined in 'file.c' at line 7282
    ImageCache* cache;   // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    Str tmpf;              // _cfa_ffffffe8
    FILE* src;            // _cfa_ffffffe4
    _None prevtrap;                        // _cfa_ffffffe0
    URLFile f;         // _cfa_ffffffc0
    Buffer* _v68;       // _cfa_ffffffbc
    short _v90;                            // _cfa_ffffffa6
    short _v92;                            // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    Image image;         // _cfa_ffffff9c
    struct stat st;       // _cfa_ffffff44
    char* _v204;                           // _cfa_ffffff34
    intOrPtr _v208;                        // _cfa_ffffff30
    char* _v212;                           // _cfa_ffffff2c
    char* _v216;                           // _cfa_ffffff28
    int _v220;                             // _cfa_ffffff24
    int _v224;                             // _cfa_ffffff20
    char* _v228;                           // _cfa_ffffff1c
    char* _v232;                           // _cfa_ffffff18
    _unknown_ __ebp;                       // r6
    URLFile* _t169;    // _t169
    _unknown_ _t207;                       // _t207
    int _t213;                             // _t213
    _unknown_ _t214;                       // _t214
    _unknown_ _t220;                       // _t220
    _unknown_ _t222;                       // _t222
    _unknown_ _t228;                       // _t228
    _unknown_ _t232;                       // _t232
    _unknown_ _t234;                       // _t234
    char* _t248;                           // _t248
    int _t266;                             // _t266
    _unknown_ _t267;                       // _t267
    _unknown_ _t279;                       // _t279

    src = 0;
    prevtrap = 0;
    loadImage(newBuf, 1);
    image.url = uf->url;
    _v96 = uf->ext;
    _v92 = 65535;
    _v90 = 65535;
    _v68 = 0;
    cache = getImage( &(image.url), cur_baseURL, 2);
    if(cur_baseURL->is_nocache != 0 || (cache->loaded & 1) == 0) {
L3:
        if((TrapSignal & 0xff) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 0xff) != 0) {
                term_cbreak();
            }
        }
        if(( *(uf + 4)->lastLine & 0xff) != 4) {
             *(uf + 4) = newEncodedStream( *(uf + 4), uf->encoding & 0xff);
        }
        _v204 = cache->file;
        _t169 = uf;
         *__esp = _t169->scheme;
        _v232 =  *(_t169 + 4);
        _v228 = _t169->ext;
        _v224 = _t169->compression;
        _v220 = _t169->content_encoding;
        _v216 = _t169->guess_type;
        _v212 = _t169->url;
        _v208 =  *((intOrPtr*)(_t169 + 28));
        if(save2tmp() >= 0) {
            if(ISclose( *(uf + 4)) == 0) {
                 *(uf + 4) = 0;
            }
            if((TrapSignal & 0xff) != 0) {
                if((fmInitialized & 0xff) != 0) {
                    term_raw();
                }
                if(prevtrap != 0) {
                    mySignal(2, prevtrap);
                }
            }
            cache->loaded = 1;
            cache->index = 0;
L26:
            if(newBuf == 0) {
                _t266 = COLS;
                if(showLineNum == 0) {
                    _t213 = 1;
                } else {
                    _t213 = 6;
                }
                _t214 = _t266 - _t213;
                _t215 = _t214 >= 0 ? 0 : _t214;
                newBuf = newBuffer(_t214 >= 0 ? 0 : _t214);
            }
            cache->loaded = (cache->loaded & 255 | 4) & 255;
            if(newBuf->sourcefile == 0 && (uf->scheme & 0xff) != 4) {
                newBuf->sourcefile = cache->file;
            }
            _v232 = html_quote(image.url);
            tmp = Sprintf("<img src="%s"><br><br>");
            tmpf = tmpfname(1, ".html");
            src = fopen(tmpf->ptr, "w");
            newBuf->mailcap_source = tmpf->ptr;
            init_stream( &(f.scheme), 4, newStrStream(tmp));
            loadHTMLstream( &(f.scheme), newBuf, src, 1);
            if(src != 0) {
                fclose(src);
            }
            newBuf->topLine = newBuf->firstLine;
            newBuf->lastLine = newBuf->currentLine;
            newBuf->currentLine = newBuf->firstLine;
            newBuf->image_flag = 2;
            return newBuf;
        }
        if(ISclose( *(uf + 4)) == 0) {
             *(uf + 4) = 0;
        }
        if((TrapSignal & 0xff) != 0) {
            if((fmInitialized & 0xff) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        return 0;
    }
    _t248 = cache->file;
    __stat(_t248,  &(st.st_dev));
    if(_t248 == 0) {
        goto L26;
    }
    goto L3;
}

Str conv_symbol(Line* l)
{// addr = 0x0806FDDB  --  defined in 'file.c' at line 7343
    char c;                                // _cfa_fffffff3
    Str tmp;               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* ep;                              // _cfa_ffffffe4
    Lineprop* pr;     // _cfa_ffffffe0
    int w;                                 // _cfa_ffffffdc
    char** symbol;                         // _cfa_ffffffd8
    int len;                               // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t101;                             // _t101
    int _t139;                             // _t139

    tmp = 0;
    p = l->lineBuf;
    ep =  &(p[l->len]);
    pr = l->propBuf;
    symbol = 0;
    while(p < ep) {
        if(( *pr & 0xffff) >= 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t101 = tmp->length;
                 *(tmp->ptr + _t101) =  *p & 0xff;
                tmp->length = _t101 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
        } else {
            c = (wtf_get_code(p) & 127) - 32 & 255;
            len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
            if(tmp == 0) {
                tmp = Strnew_size(l->len);
                Strcopy_charp_n(tmp, l->lineBuf, p - l->lineBuf);
                if(( *pr & 0x800) == 0) {
                    _t139 = 1;
                } else {
                    _t139 = 2;
                }
                w = _t139;
                symbol = get_symbol(DisplayCharset,  &w);
            }
            Strcat_charp(tmp, symbol[c]);
            p =  &(p[len - 1]);
            pr = pr + len - 1 + len - 1;
        }
        p =  &(p[1]);
        pr =  &(pr[1]);
    }
    if(tmp == 0) {
        return Strnew_charp_n(l->lineBuf, l->len);
    }
    return tmp;
}

_saveBuffer(Buffer* buf, Line* l, FILE* f, int cont)
{// addr = 0x0806FF79  --  defined in 'file.c' at line 7390
    Str tmp;               // _cfa_fffffff0
    int is_html;                           // _cfa_ffffffec
    int set_charset;                       // _cfa_ffffffe8
    wc_ces charset;     // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    FILE* _v40;           // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t65;                     // _t65
    _unknown_ _t80;                        // _t80

    is_html = 0;
    set_charset = DisplayCharset & 0xff;
    if(DisplayCharset == 0) {
        _t65 = 256;
    } else {
        _t65 = DisplayCharset;
    }
    charset = _t65;
    is_html = is_html_type(buf->type);
L14:
    while(l == 0) {
        if( *((intOrPtr*)(buf + 92)) == 0) {
L20:
            return;
        }
        asm("cwde ");
        if((buf->bufferprop & 0x40) != 0) {
            goto L20;
        }
        l = getNextPage(buf, PagerMax);
        if(set_charset != 0) {
            charset =  *(buf + 208);
        }
    }
    if(is_html == 0) {
        tmp = Strnew_charp_n(l->lineBuf, l->len);
    } else {
        tmp = conv_symbol(l);
    }
    tmp = wc_Str_conv(tmp, InnerCharset, charset);
    fwrite(tmp->ptr, 1, tmp->length, f);
    if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 10) {
        if(cont == 0 || l->next == 0 || l->next->bpos == 0) {
            _v40 = f;
             *__esp = 10;
            _IO_putc();
        }
    }
    l = l->next;
    goto L14;
}

saveBuffer(Buffer* buf, FILE* f, int cont)
{// addr = 0x080700E6  --  defined in 'file.c' at line 7423
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _saveBuffer(buf, buf->firstLine, f, cont);
    return;
}

saveBufferBody(Buffer* buf, FILE* f, int cont)
{// addr = 0x08070111  --  defined in 'file.c' at line 7429
    Line* l;              // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    l = buf->firstLine;
    while(l != 0 && l->real_linenumber == 0) {
        l = l->next;
    }
    _saveBuffer(buf, l, f, cont);
    return;
}

Buffer* loadcmdout(char* cmd, _None* loadproc, Buffer* defaultbuf)
{// addr = 0x0807015D  --  defined in 'file.c' at line 7439
    FILE* f;              // _cfa_fffffff0
    Buffer* buf;        // _cfa_ffffffec
    union input_stream* _v48;   // _cfa_ffffffd0
    URLFile uf;        // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc
    Buffer* _v72;       // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    Buffer* _t34;       // _t34
    union input_stream* _t35;   // _t35
    _unknown_ _t36;                        // _t36
    _unknown_ _t38;                        // _t38

    if(cmd == 0 || ( *cmd & 0xff) == 0) {
        return;
    }
    f = popen(cmd, "r");
    __eflags = f;
    if(__eflags != 0) {
        init_stream( &(uf.scheme), 255, newFileStream(f, pclose));
        _v72 = defaultbuf;
         *__esp =  &(uf.scheme);
        _t34 = loadproc;
        _t34->filename();
        buf = _t34;
        _t35 = _v48;
        ISclose(_t35);
        __eflags = _t35;
        if(__eflags == 0) {
            _v48 = 0;
            __eflags = _v48;
        }
        return;
    }
    return;
}

Buffer* getshell(char* cmd)
{// addr = 0x08070200  --  defined in 'file.c' at line 7461
    Buffer* buf;        // _cfa_fffffff0
    struct _Str _v36;     // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27

    buf = loadcmdout(cmd, loadBuffer, 0);
    if(buf != 0) {
        buf->filename = cmd;
        _v36 =  *(wc_Str_conv(Strnew_charp(cmd), SystemCharset, InnerCharset));
        _v40 = "*Shellout*";
        buf->buffername =  *(Sprintf("%s %s"));
        return buf;
    }
    return 0;
}

Buffer* getpipe(char* cmd)
{// addr = 0x0807028F  --  defined in 'file.c' at line 7478
    FILE* f;              // _cfa_fffffff0
    Buffer* buf;        // _cfa_ffffffec
    struct _Str _v36;     // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33
    _unknown_ _t39;                        // _t39
    _unknown_ _t40;                        // _t40
    _unknown_ _t58;                        // _t58
    int _t61;                              // _t61
    _unknown_ _t62;                        // _t62

    if(cmd == 0 || ( *cmd & 0xff) == 0) {
        return 0;
    }
    f = popen(cmd, "r");
    if(f != 0) {
        _t61 = COLS;
        if(showLineNum == 0) {
            _t39 = 1;
        } else {
            _t39 = 6;
        }
        _t40 = _t61 - _t39;
        _t41 = _t40 >= 0 ? 0 : _t40;
        buf = newBuffer(_t40 >= 0 ? 0 : _t40);
         *(buf + 92) = newFileStream(f, pclose);
        buf->filename = cmd;
        _v36 =  *(wc_Str_conv(Strnew_charp(cmd), SystemCharset, InnerCharset));
        _v40 = "*stream*";
        buf->buffername =  *(Sprintf("%s %s"));
        buf->bufferprop = (buf->bufferprop & 65535 | 1) & 65535;
         *((intOrPtr*)(buf + 208)) = 256;
        return buf;
    }
    return 0;
}

Buffer* openPagerBuffer(InputStream stream, Buffer* buf)
{// addr = 0x080703A2  --  defined in 'file.c' at line 7504
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t57;                        // _t57
    _unknown_ _t58;                        // _t58
    int _t70;                              // _t70
    _unknown_ _t71;                        // _t71

    if(buf == 0) {
        _t70 = COLS;
        if(showLineNum == 0) {
            _t57 = 1;
        } else {
            _t57 = 6;
        }
        _t58 = _t70 - _t57;
        _t59 = _t58 >= 0 ? 0 : _t58;
        buf = newBuffer(_t58 >= 0 ? 0 : _t58);
    }
     *(buf + 92) = stream;
    buf->buffername = getenv("MAN_PN");
    if(buf->buffername != 0) {
        buf->buffername =  *(wc_Str_conv(Strnew_charp(buf->buffername), SystemCharset, InnerCharset));
    } else {
        buf->buffername = "*stream*";
    }
    buf->bufferprop = (buf->bufferprop & 65535 | 1) & 65535;
    if(content_charset == 0 || (UseContentCharset & 0xff) == 0) {
         *(buf + 208) = 256;
    } else {
         *(buf + 208) = content_charset;
    }
    buf->currentLine = buf->firstLine;
    return buf;
}

Buffer* openGeneralPagerBuffer(InputStream stream)
{// addr = 0x080704A4  --  defined in 'file.c' at line 7528
    Buffer* buf;        // _cfa_fffffff0
    char* t;                               // _cfa_ffffffec
    Buffer* t_buf;      // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    union input_stream* _v52;   // _cfa_ffffffcc
    signed int _v54;                       // _cfa_ffffffca
    URLFile uf;        // _cfa_ffffffc8
    Buffer* _v64;       // _cfa_ffffffc0
    Buffer** _v68;      // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    char* _v76;                            // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    union input_stream* _v104;   // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    ParsedURL* _t163;   // _t163
    int _t185;                             // _t185
    _unknown_ _t186;                       // _t186
    int _t200;                             // _t200
    _unknown_ _t201;                       // _t201

    t = "text/plain";
    t_buf = 0;
    init_stream( &(uf.scheme), 255, stream);
    content_charset = 0;
    if((SearchHeader & 0xff) == 0) {
        if(DefaultType != 0) {
            t = DefaultType;
            DefaultType = 0;
        }
        goto L11;
    } else {
        _t200 = COLS;
        if(showLineNum == 0) {
            _t185 = 1;
        } else {
            _t185 = 6;
        }
        _t186 = _t200 - _t185;
        _t187 = _t186 >= 0 ? 0 : _t186;
        t_buf = newBuffer(_t186 >= 0 ? 0 : _t186);
        readHeader( &(uf.scheme), t_buf, 1, 0);
        t = checkContentType(t_buf);
        if(t == 0) {
            t = "text/plain";
        }
        if(t_buf != 0) {
            t_buf->topLine = t_buf->firstLine;
            t_buf->currentLine = t_buf->lastLine;
        }
        SearchHeader = 0;
L11:
        if(is_html_type(t) == 0) {
            if(is_plain_text_type(t) == 0) {
                if(activeImage == 0 || displayImage == 0 || useExtImageViewer != 0 || (w3m_dump & 223) != 0) {
L23:
                    _v64 = t_buf;
                    _v68 =  &buf;
                    _v72 = t;
                    _v76 = "-";
                     *__esp = uf.scheme;
                    _v104 = _v52;
                    _v100 = _v48;
                    _v96 = _v44;
                    _v92 = _v40;
                    _v88 = _v36;
                    _v84 = _v32;
                    _v80 = _v28;
                    if(doExternal() == 0) {
L29:
                        if((stream->base.stream.cur & 0xff) != 4) {
                            stream = newEncodedStream(stream, _v54 & 0xff);
                        }
                        buf = openPagerBuffer(stream, t_buf);
                        buf->type = "text/plain";
                        goto L32;
                    }
                } else {
                    _t163 = strncasecmp(t, "image/", 6);
                    if(_t163 != 0) {
                        goto L23;
                    }
                     *__esp = 40;
                    GC_malloc();
                    cur_baseURL = _t163;
                    parseURL("-", cur_baseURL, 0);
                    buf = loadImageBuffer( &(uf.scheme), t_buf);
                    buf->type = "text/html";
                    goto L32;
                }
                if(ISclose(_v52) == 0) {
                    _v52 = 0;
                }
                if(buf == 0 || buf == 1) {
                    return buf;
                } else {
                    goto L32;
                }
                goto L29;
            }
            goto L14;
        }
        buf = loadHTMLBuffer( &(uf.scheme), t_buf);
        buf->type = "text/html";
L32:
        buf->real_type = t;
         *((intOrPtr*)(buf + 132)) = 4;
         *(buf + 152) = "-";
        return buf;
L14:
        if((stream->base.stream.cur & 0xff) != 4) {
            stream = newEncodedStream(stream, _v54 & 0xff);
        }
        buf = openPagerBuffer(stream, t_buf);
        buf->type = "text/plain";
        goto L32;
    }
}

Line* getNextPage(Buffer* buf, int plen)
{// addr = 0x080707C1  --  defined in 'file.c' at line 7595
    _None pre_lbuf;                        // _cfa_ffffffe3
    wc_uint8 old_auto_detect;   // _cfa_ffffffe2
    _None top;                             // _cfa_ffffffdc
    _None last;                            // _cfa_ffffffd8
    _None cur;                             // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffd0
    _None nlines;                          // _cfa_ffffffcc
    Str lineBuf2;          // _cfa_ffffffc8
    wc_ces charset;     // _cfa_ffffffc4
    _None doc_charset;                     // _cfa_ffffffc0
    _None squeeze_flag;                    // _cfa_ffffffbc
    Lineprop* propBuffer;   // _cfa_ffffffb8
    Linecolor* colorBuffer;   // _cfa_ffffffb4
    _None prevtrap;                        // _cfa_ffffffb0
    Line* l;              // _cfa_ffffffac
    _None _v88;                            // _cfa_ffffffa8
    clen_t linelen;     // _cfa_ffffffa4
    _None _v96;                            // _cfa_ffffffa0
    clen_t trbyte;      // _cfa_ffffff9c
    URLFile uf;        // _cfa_ffffff7c
    _unknown_ _v148;                       // _cfa_ffffff6c
    _unknown_ _v152;                       // _cfa_ffffff68
    _unknown_ _v156;                       // _cfa_ffffff64
    _unknown_ _v160;                       // _cfa_ffffff60
    struct _Str _v164;    // _cfa_ffffff5c
    _None _v168;                           // _cfa_ffffff58
    _unknown_ __ebx;                       // r1
    int __edi;                             // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t249;                      // _t249
    int _t278;                             // _t278
    _None _t307;                           // _t307
    _unknown_ _t308;                       // _t308
    _unknown_ _t346;                       // _t346
    _unknown_ _t358;                       // _t358
    _unknown_ _t370;                       // _t370
    _unknown_ _t372;                       // _t372
    _unknown_ _t380;                       // _t380
    _unknown_ _t389;                       // _t389
    _unknown_ _t390;                       // _t390
    int _t397;                             // _t397
    _unknown_ _t398;                       // _t398

    top = buf->topLine;
    last = buf->lastLine;
    cur = buf->currentLine;
    nlines = 0;
    linelen = 0;
    _v88 = 0;
    trbyte =  *(buf + 200);
    _v96 = 0;
    pre_lbuf = 0;
    doc_charset = DocumentCharset;
    old_auto_detect = WcOption.auto_detect & 0xff;
    squeeze_flag = 0;
    propBuffer = 0;
    colorBuffer = 0;
    prevtrap = 0;
    if( *(buf + 92) == 0) {
        return 0;
    }
    if(last != 0) {
        nlines =  *(last + 32);
        pre_lbuf =  *( *last) & 0xff;
        if((pre_lbuf & 0xff) == 0) {
            pre_lbuf = 10;
        }
        buf->currentLine = last;
    }
    charset =  *(buf + 208);
    if( *(buf + 208) == 256) {
        if((UseContentCharset & 0xff) != 0) {
            content_charset = 0;
            checkContentType(buf);
            if(content_charset != 0) {
                doc_charset = content_charset;
            }
        }
    } else {
        doc_charset =  *(buf + 208);
    }
    _t249 =  *(buf + 212) & 255;
    WcOption.auto_detect = _t249 & 255;
    _v168 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t249 != 0) {
        goto L50;
    }
    if((TrapSignal & 0xff) != 0) {
        prevtrap = mySignal(2, KeyAbort);
        if((fmInitialized & 0xff) != 0) {
            term_cbreak();
        }
    }
    init_stream( &(uf.scheme), 255, 0);
    i = 0;
    while(i < plen) {
        lineBuf2 = StrmyISgets( *(buf + 92));
        if(lineBuf2->length != 0) {
            asm("adc edx, ebx");
            linelen = linelen + lineBuf2->length;
            _v88 = _v88;
            showProgress( &linelen,  &trbyte);
            lineBuf2 = convertLine( &(uf.scheme), lineBuf2, 1,  &charset, doc_charset);
            if(squeezeBlankLine == 0) {
L27:
                nlines = nlines + 1;
                Strchop(lineBuf2);
                lineBuf2 = checkType(lineBuf2,  &propBuffer,  &colorBuffer);
                __edi = nlines;
                if(FoldLine == 0) {
                    _t278 = -1;
                } else {
                    _t397 = COLS;
                    if(showLineNum == 0) {
                        _t307 = 1;
                    } else {
                        _t307 = 6;
                    }
                    _t308 = _t397 - _t307;
                    _t309 = _t308 >= 0 ? 0 : _t308;
                    _t278 = (_t308 >= 0 ? 0 : _t308) + 1;
                }
                addnewline(buf, lineBuf2->ptr, propBuffer, colorBuffer, lineBuf2->length, _t278, __edi);
                if(top == 0) {
                    top = buf->firstLine;
                    cur = top;
                }
                if(buf->lastLine->real_linenumber - buf->firstLine->real_linenumber < PagerMax) {
L46:
                    i = i + 1;
                    continue;
                }
                l = buf->firstLine;
                while() {
                }
            }
            goto L23;
        }
        if(buf->filename == 0) {
            if(getenv("MAN_PN") == 0) {
                buf->buffername = "*stream(closed)*";
            }
        } else {
            _v164 =  *(wc_Str_conv(Strnew_charp(buf->filename), SystemCharset, InnerCharset));
            _v168 = "*stream(closed)*";
            buf->buffername =  *(Sprintf("%s %s"));
        }
        buf->bufferprop = (buf->bufferprop & 65535 | 64) & 65535;
        goto L50;
L23:
        squeeze_flag = 0;
        if((lineBuf2 & 0xff) != 10 || (pre_lbuf & 0xff) != 10) {
            pre_lbuf = lineBuf2 & 0xff;
        } else {
            nlines = nlines + 1;
            i = i - 1;
            squeeze_flag = 1;
            goto L46;
        }
        goto L27;
    }
L50:
    if((TrapSignal & 0xff) != 0) {
        if((fmInitialized & 0xff) != 0) {
            term_raw();
        }
        if(prevtrap != 0) {
            mySignal(2, prevtrap);
        }
    }
     *(buf + 200) = trbyte + linelen;
     *(buf + 208) = charset;
    WcOption.auto_detect = old_auto_detect & 0xff;
    buf->topLine = top;
    buf->currentLine = cur;
    if(last != 0) {
        if(last != 0 && ( *(last + 12) != 0 || squeeze_flag == 0)) {
            last =  *(last + 12);
        }
    } else {
        last = buf->firstLine;
    }
    return last;
}

int save2tmp(URLFile uf, char* tmpf)
{// addr = 0x08070CBA  --  defined in 'file.c' at line 7719
    char c;                                // _cfa_fffffff3
    FILE* ff;             // _cfa_ffffffec
    int check;                             // _cfa_ffffffe8
    _None prevtrap;                        // _cfa_ffffffe4
    Str buf;               // _cfa_ffffffe0
    int _v40;                              // _cfa_ffffffd8
    clen_t linelen;     // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    clen_t trbyte;      // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    void _t88;                             // _t88
    _unknown_ _t98;                        // _t98
    _unknown_ _t105;                       // _t105
    _unknown_ _t108;                       // _t108
    _unknown_ _t109;                       // _t109
    _unknown_ _t113;                       // _t113
    _unknown_ _t125;                       // _t125
    _unknown_ _t127;                       // _t127

    linelen = 0;
    _v40 = 0;
    trbyte = 0;
    _v48 = 0;
    prevtrap = 0;
    ff = fopen(tmpf, "wb");
    if(ff == 0) {
        return -1;
    }
    _t88 = bcopy( &AbortLoading,  &env_bak, 156);
    _v72 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t88 == 0) {
        if((TrapSignal & 0xff) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 0xff) != 0) {
                term_cbreak();
            }
        }
        check = 0;
        if((uf.scheme & 0xff) != 9) {
            buf = Strnew_size(1536);
L25:
            while(ISread(uf.stream, buf, 1536) != 0) {
                goto L24;
            }
            goto L28;
        }
        while(1) {
            c = ISgetc(uf.stream) & 255;
            if((uf.stream->base.stream.cur & 0xff) != 0) {
                break;
            }
            if(c != 10) {
                if(c != 46 || check != 1) {
                    if(c != 13 || check != 2) {
                        check = 0;
                    } else {
                        check = check + 1;
                    }
                } else {
                    check = check + 1;
                }
L20:
                _v72 = ff;
                 *__esp = c;
                _IO_putc();
                asm("adc edx, 0x0");
                linelen = linelen + 1;
                _v40 = _v40;
                showProgress( &linelen,  &trbyte);
                continue;
            }
            if(check != 0) {
                if(check != 3) {
                    goto L20;
                }
                goto L12;
            }
            check = check + 1;
            goto L20;
L12:
            goto L28;
        }
        goto L28;
L24:
        fwrite(buf->ptr, 1, buf->length, ff);
        asm("adc edx, ebx");
        linelen = linelen + buf->length;
        _v40 = _v40;
        showProgress( &linelen,  &trbyte);
        goto L25;
    }
L28:
    bcopy( &env_bak,  &AbortLoading, 156);
    if((TrapSignal & 0xff) != 0) {
        if((fmInitialized & 0xff) != 0) {
            term_raw();
        }
        if(prevtrap != 0) {
            mySignal(2, prevtrap);
        }
    }
    fclose(ff);
    current_content_length = 0;
     *135776436 = 0;
    return 0;
}

int doExternal(URLFile uf, char* path, char* type, Buffer** bufp, Buffer* defaultbuf)
{// addr = 0x08070F2F  --  defined in 'file.c' at line 7778
    Str tmpf;              // _cfa_fffffff0
    Str command;           // _cfa_ffffffec
    struct mailcap* mcap;   // _cfa_ffffffe8
    int mc_stat;                           // _cfa_ffffffe4
    Buffer* buf;        // _cfa_ffffffe0
    char* header;                          // _cfa_ffffffdc
    char* src;                             // _cfa_ffffffd8
    char* ext;                             // _cfa_ffffffd4
    Str tmp;               // _cfa_ffffffd0
    char* _v76;                            // _cfa_ffffffb4
    long int _v80;                         // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    int _v92;                              // _cfa_ffffffa4
    int _v96;                              // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    union input_stream* _v104;   // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    char* _t207;                           // _t207
    _unknown_ _t249;                       // _t249
    int _t294;                             // _t294
    _unknown_ _t295;                       // _t295
    _unknown_ _t299;                       // _t299
    _unknown_ _t306;                       // _t306
    _unknown_ _t325;                       // _t325
    _unknown_ _t348;                       // _t348
    int _t370;                             // _t370
    _unknown_ _t371;                       // _t371

    buf = 0;
    src = 0;
    ext = uf.ext;
    mcap = searchExtViewer(type);
    if(mcap == 0) {
        return 0;
    }
    if(mcap->nametemplate != 0) {
        tmpf = unquote_mailcap(mcap->nametemplate, 0, 135041709, 0, 0);
        if((tmpf & 0xff) == 46) {
            ext = tmpf->ptr;
        }
    }
    if(ext == 0) {
L8:
        _t207 = 0;
        goto L9;
    }
    if(( *ext & 0xff) == 0) {
        goto L8;
    } else {
        _t207 = ext;
    }
L9:
    tmpf = tmpfname(0, _t207);
    if((uf.stream->base.stream.cur & 0xff) != 4) {
        uf.stream = newEncodedStream(uf.stream, uf.encoding & 0xff);
    }
    header = checkHeader(defaultbuf, "Content-Type:");
    if(header != 0) {
        header =  *(wc_Str_conv_strict(Strnew_charp(header), InnerCharset, SystemCharset));
    }
    command = unquote_mailcap(mcap->viewer, type, tmpf->ptr, header,  &mc_stat);
    if((mc_stat & 1) == 0) {
        _v100 = shell_quote(tmpf->ptr);
        _v104 = command->ptr;
        tmp = Sprintf("(%s) < %s");
        command = tmp;
    }
    if((mcap->flags & 6) != 0 || (mcap->flags & 1) != 0 || BackgroundExtViewer == 0) {
L25:
        _v76 = tmpf->ptr;
         *__esp = uf.scheme;
        _v104 = uf.stream;
        _v100 = uf.ext;
        _v96 = uf.compression;
        _v92 = uf.content_encoding;
        _v88 = uf.guess_type;
        _v84 = uf.url;
        _v80 = uf.modtime;
        if(save2tmp() >= 0) {
            if((mcap->flags & 6) != 0) {
                if(defaultbuf == 0) {
                    _t370 = COLS;
                    if(showLineNum == 0) {
                        _t294 = 1;
                    } else {
                        _t294 = 6;
                    }
                    _t295 = _t370 - _t294;
                    _t296 = _t295 >= 0 ? 0 : _t295;
                    defaultbuf = newBuffer(_t295 >= 0 ? 0 : _t295);
                }
                if(defaultbuf->sourcefile == 0) {
                    src = tmpf->ptr;
                } else {
                    src = defaultbuf->sourcefile;
                }
                defaultbuf->sourcefile = 0;
                defaultbuf->mailcap = mcap;
            }
            if((mcap->flags & 4) == 0) {
                if((mcap->flags & 2) == 0) {
                    if((mcap->flags & 1) != 0 || BackgroundExtViewer == 0) {
                        fmTerm();
                        mySystem(command->ptr, 0);
                        fmInit();
                        if(CurrentTab != 0) {
                            if(CurrentTab->currentBuffer != 0) {
                                displayBuffer(CurrentTab->currentBuffer, 1);
                            }
                        }
                    } else {
                        mySystem(command->ptr, 1);
                    }
                    buf = 1;
                } else {
                    buf = loadcmdout(command->ptr, loadBuffer, defaultbuf);
                    if(buf != 0 && buf != 1) {
                        buf->type = "text/plain";
                        buf->mailcap_source = buf->sourcefile;
                        buf->sourcefile = src;
                    }
                }
            } else {
                buf = loadcmdout(command->ptr, loadHTMLBuffer, defaultbuf);
                if(buf != 0 && buf != 1) {
                    buf->type = "text/html";
                    buf->mailcap_source = buf->sourcefile;
                    buf->sourcefile = src;
                }
            }
            if(buf != 0 && buf != 1) {
                buf->filename = path;
                if(buf->buffername == 0 || (buf & 0xff) == 0) {
                    buf->buffername =  *(wc_Str_conv(Strnew_charp(lastFileName(path)), SystemCharset, InnerCharset));
                }
                buf->edit = mcap->edit;
                buf->mailcap = mcap;
            }
             *bufp = buf;
            return 1;
        }
    } else {
        flush_tty();
        if(fork() != 0) {
L24:
             *bufp = 1;
            return 1;
        } else {
            setup_child(0, 0, ISfileno(uf.stream));
            _v76 = tmpf->ptr;
             *__esp = uf.scheme;
            _v104 = uf.stream;
            _v100 = uf.ext;
            _v96 = uf.compression;
            _v92 = uf.content_encoding;
            _v88 = uf.guess_type;
            _v84 = uf.url;
            _v80 = uf.modtime;
            if(save2tmp() < 0) {
                exit(1);
            }
            if(ISclose(uf.stream) == 0) {
                uf.stream = 0;
            }
            myExec(command->ptr);
            goto L24;
        }
        goto L25;
    }
     *bufp = 0;
    return 1;
}

int _MoveFile(char* path1, char* path2)
{// addr = 0x08071480  --  defined in 'file.c' at line 7883
    InputStream f1;   // _cfa_fffffff0
    FILE* f2;             // _cfa_ffffffec
    int is_pipe;                           // _cfa_ffffffe8
    Str buf;               // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    clen_t linelen;     // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    clen_t trbyte;      // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t64;                        // _t64
    _unknown_ _t72;                        // _t72
    _unknown_ _t74;                        // _t74
    _unknown_ _t75;                        // _t75
    _unknown_ _t77;                        // _t77
    _unknown_ _t79;                        // _t79
    _unknown_ _t80;                        // _t80
    _unknown_ _t85;                        // _t85
    _unknown_ _t87;                        // _t87

    linelen = 0;
    _v32 = 0;
    trbyte = 0;
    _v40 = 0;
    _v56 = 0;
     *__esp = path1;
    f1 = newInputStream(open());
    if(f1 != 0) {
        if(( *path2 & 0xff) != 124 || (PermitSaveToPipe & 0xff) == 0) {
            is_pipe = 0;
            f2 = fopen(path2, "wb");
        } else {
            is_pipe = 1;
            f2 = popen( &(path2[1]), "w");
        }
        if(f2 != 0) {
            current_content_length = 0;
             *135776436 = 0;
            buf = Strnew_size(1536);
L10:
            while(ISread(f1, buf, 1536) != 0) {
                goto L9;
            }
            ISclose(f1);
            if(is_pipe == 0) {
                fclose(f2);
            } else {
                pclose(f2);
            }
            return 0;
        } else {
            ISclose(f1);
            return -1;
        }
L9:
        fwrite(buf->ptr, 1, buf->length, f2);
        asm("adc edx, ebx");
        linelen = linelen + buf->length;
        _v32 = _v32;
        showProgress( &linelen,  &trbyte);
        goto L10;
    }
    return -1;
}

int _doFileCopy(char* tmpf, char* defstr, int download)
{// addr = 0x0807160F  --  defined in 'file.c' at line 7922
    Str msg;               // _cfa_ffffffe0
    Str filen;             // _cfa_ffffffdc
    char* p;                               // _cfa_ffffffd8
    char* q;                               // _cfa_ffffffd4
    pid_t pid;           // _cfa_ffffffd0
    char* lock;                            // _cfa_ffffffcc
    int is_pipe;                           // _cfa_ffffffc8
    signed int _v64;                       // _cfa_ffffffc0
    clen_t size;        // _cfa_ffffffbc
    struct stat st;       // _cfa_ffffff64
    signed int _v168;                      // _cfa_ffffff58
    long long int _v172;                   // _cfa_ffffff54
    struct _Str _v184;    // _cfa_ffffff48
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t168;                       // _t168
    _unknown_ _t170;                       // _t170
    _unknown_ _t205;                       // _t205
    char* _t206;                           // _t206
    _unknown_ _t209;                       // _t209
    _unknown_ _t211;                       // _t211
    _unknown_ _t212;                       // _t212
    _unknown_ _t214;                       // _t214
    _unknown_ _t215;                       // _t215
    _unknown_ _t216;                       // _t216
    _unknown_ _t218;                       // _t218
    _unknown_ _t219;                       // _t219
    _unknown_ _t226;                       // _t226
    _unknown_ _t246;                       // _t246
    char* _t248;                           // _t248
    struct _Str* _t251;   // _t251
    signed int _t256;                      // _t256
    _unknown_ _t261;                       // _t261
    _unknown_ _t262;                       // _t262
    char* _t264;                           // _t264
    _unknown_ _t267;                       // _t267
    _unknown_ _t271;                       // _t271
    struct _Str* _t281;   // _t281
    struct _Str* _t284;   // _t284
    _unknown_ _t289;                       // _t289
    _unknown_ _t290;                       // _t290

    q = 0;
    size = 0;
    _v64 = 0;
    is_pipe = 0;
    if((fmInitialized & 0xff) == 0) {
        q = searchKeyData();
        if(q == 0 || ( *q & 0xff) == 0) {
            printf("(Download)Save file to: ");
            fflush(__imp__stdout);
            filen = Strfgets(__imp__stdin);
            if(filen->length != 0) {
                q = filen->ptr;
                goto L35;
            }
            return -1;
        }
L35:
        p = strlen(q) - 1 + q;
        while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p = p - 1;
        }
        p[1] = 0;
        if(( *q & 0xff) != 0) {
            p = q;
            if(( *p & 0xff) != 124 || (PermitSaveToPipe & 0xff) == 0) {
                p = expandPath(p);
                if(checkOverWrite(p) >= 0) {
                    goto L45;
                }
            } else {
                is_pipe = 1;
L45:
                if(checkCopyFile(tmpf, p) >= 0) {
                    if(_MoveFile(tmpf, p) >= 0) {
                        if((PreserveTimestamp & 0xff) != 0 && is_pipe == 0) {
                            _t206 = tmpf;
                            __stat(_t206,  &(st.st_dev));
                            if(_t206 == 0) {
                                setModtime(p, st.st_mtim);
                            }
                        }
                        goto L53;
                    }
                    goto L48;
                }
L46:
                _v184.length = p;
                _v184.ptr = tmpf;
                printf("Can't copy. %s and %s are identical.");
                return -1;
L48:
                _v184.ptr = p;
                printf("Can't save to %s\n");
                return -1;
            }
            return -1;
        }
        return -1;
    }
    p = searchKeyData();
    if(p == 0 || ( *p & 0xff) == 0) {
        q = inputLineHistSearch("(Download)Save file to: ", defstr, 128, SaveHist, 0);
        if(q == 0) {
L5:
            return 0;
        }
        if(( *q & 0xff) != 0) {
            p =  *(wc_Str_conv_strict(Strnew_charp(q), InnerCharset, SystemCharset));
            goto L7;
        }
        goto L5;
L8:
        if((PermitSaveToPipe & 0xff) == 0) {
L10:
            if(q != 0) {
                p =  *(unescape_spaces(Strnew_charp(q)));
                p =  *(wc_Str_conv_strict(Strnew_charp(q), InnerCharset, SystemCharset));
            }
            p = expandPath(p);
            if(checkOverWrite(p) >= 0) {
            } else {
                return -1;
            }
        } else {
            is_pipe = 1;
        }
        if(checkCopyFile(tmpf, p) < 0) {
            _t281 = wc_Str_conv(Strnew_charp(p), SystemCharset, InnerCharset);
            _t284 = wc_Str_conv(Strnew_charp(tmpf), SystemCharset, InnerCharset);
            _v184.length = _t281->ptr;
            _v184.ptr = _t284->ptr;
            msg = Sprintf("Can't copy. %s and %s are identical.");
            disp_err_message(msg->ptr, 0);
            return -1;
        }
        if(download != 0) {
            lock =  *(tmpfname(0, ".lock"));
            symlink(p, lock);
            flush_tty();
            pid = fork();
            if(pid == 0) {
                setup_child(0, 0, -1);
                if(_MoveFile(tmpf, p) == 0 && (PreserveTimestamp & 0xff) != 0 && is_pipe == 0) {
                    _t264 = tmpf;
                    __stat(_t264,  &(st.st_dev));
                    if(_t264 == 0) {
                        setModtime(p, st.st_mtim);
                    }
                }
                unlink(lock);
                exit(0);
            }
            _t248 = tmpf;
            __stat(_t248,  &(st.st_dev));
            if(_t248 == 0) {
                _t256 = st.st_size;
                size = _t256;
                _v64 = _t256 >> 31;
            }
            _t251 = wc_Str_conv(Strnew_charp(tmpf), SystemCharset, InnerCharset);
            _v172 = size;
            _v168 = _v64;
            _v184.area_size = lock;
            _v184.length = p;
            _v184.ptr = _t251->ptr;
             *__esp = pid;
            addDownloadList();
L53:
            return 0;
        } else {
            if(_MoveFile(tmpf, p) < 0) {
                _v184 =  *(wc_Str_conv(Strnew_charp(p), SystemCharset, InnerCharset));
                msg = Sprintf("Can't save to %s");
                disp_err_message(msg->ptr, 0);
            }
        }
        return -1;
    }
L7:
    if(( *p & 0xff) != 124) {
        goto L10;
    }
    goto L8;
}

int doFileMove(char* tmpf, char* defstr)
{// addr = 0x08071B71  --  defined in 'file.c' at line 8036
    int ret;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12

    ret = _doFileCopy(tmpf, defstr, 0);
    unlink(tmpf);
    return ret;
}

int doFileSave(URLFile uf, char* defstr)
{// addr = 0x08071BA4  --  defined in 'file.c' at line 8044
    Str msg;               // _cfa_fffffff0
    Str filen;             // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    pid_t pid;           // _cfa_ffffffe0
    char* lock;                            // _cfa_ffffffdc
    char* tmpf;                            // _cfa_ffffffd8
    char* _v60;                            // _cfa_ffffffc4
    long int _v64;                         // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    long long int _v76;                    // _cfa_ffffffb4
    int _v80;                              // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    union input_stream* _v88;   // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t157;                       // _t157
    _unknown_ _t159;                       // _t159
    _unknown_ _t198;                       // _t198
    _unknown_ _t202;                       // _t202
    _unknown_ _t204;                       // _t204
    _unknown_ _t205;                       // _t205
    _unknown_ _t211;                       // _t211
    _unknown_ _t213;                       // _t213
    _unknown_ _t214;                       // _t214
    _unknown_ _t215;                       // _t215
    _unknown_ _t216;                       // _t216
    _unknown_ _t217;                       // _t217
    _unknown_ _t224;                       // _t224
    _unknown_ _t239;                       // _t239
    _unknown_ _t261;                       // _t261
    _unknown_ _t262;                       // _t262
    _unknown_ _t268;                       // _t268
    _unknown_ _t274;                       // _t274
    _unknown_ _t282;                       // _t282
    _unknown_ _t283;                       // _t283

    tmpf = 0;
    if((fmInitialized & 0xff) == 0) {
        q = searchKeyData();
        if(q == 0 || ( *q & 0xff) == 0) {
            printf("(Download)Save file to: ");
            fflush(__imp__stdout);
            filen = Strfgets(__imp__stdin);
            if(filen->length != 0) {
                q = filen->ptr;
                goto L29;
            }
            return -1;
        }
L29:
        p = strlen(q) - 1 + q;
        while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p = p - 1;
        }
        p[1] = 0;
        if(( *q & 0xff) != 0) {
            p = expandPath(q);
            if(checkOverWrite(p) >= 0) {
                if(checkSaveFile(uf.stream, p) >= 0) {
                    if(uf.content_encoding != 0 && (AutoUncompress & 0xff) != 0) {
                        uncompress_stream( &(uf.scheme),  &tmpf);
                        if(tmpf != 0) {
                            unlink(tmpf);
                        }
                    }
                    _v60 = p;
                     *__esp = uf.scheme;
                    _v88 = uf.stream;
                    _v84 = uf.ext;
                    _v80 = uf.compression;
                    _v76 = uf.content_encoding;
                    _v72 = uf.guess_type;
                    _v68 = uf.url;
                    _v64 = uf.modtime;
                    if(save2tmp() >= 0) {
                        if((PreserveTimestamp & 0xff) != 0 && uf.modtime != 255) {
                            setModtime(p, uf.modtime);
                        }
                        goto L47;
                    }
                    _v88 = p;
                    printf("Can't save to %s\n");
                    return -1;
                }
                goto L37;
            }
            goto L35;
L37:
            _v88 = p;
            printf("Can't save. Load file and %s are identical.");
            return -1;
        }
        return -1;
L35:
        return -1;
    }
    p = searchKeyData();
    if(p == 0 || ( *p & 0xff) == 0) {
        p = inputLineHistSearch("(Download)Save file to: ", defstr, 32, SaveHist, 0);
        if(p == 0) {
L5:
            return -1;
        }
    } else {
L7:
        if(checkOverWrite(p) < 0) {
            return -1;
        }
        if(checkSaveFile(uf.stream, p) < 0) {
            _v88 =  *(wc_Str_conv(Strnew_charp(p), SystemCharset, InnerCharset));
            msg = Sprintf("Can't save. Load file and %s are identical.");
            disp_err_message(msg->ptr, 0);
            return -1;
        }
        lock =  *(tmpfname(0, ".lock"));
        symlink(p, lock);
        flush_tty();
        pid = fork();
        if(pid == 0) {
            setup_child(0, 0, ISfileno(uf.stream));
            _v60 = p;
             *__esp = uf.scheme;
            _v88 = uf.stream;
            _v84 = uf.ext;
            _v80 = uf.compression;
            _v76 = uf.content_encoding;
            _v72 = uf.guess_type;
            _v68 = uf.url;
            _v64 = uf.modtime;
            if(save2tmp() == 0 && (PreserveTimestamp & 0xff) != 0 && uf.modtime != 255) {
                setModtime(p, uf.modtime);
            }
            if(ISclose(uf.stream) == 0) {
                uf.stream = 0;
            }
            unlink(lock);
            exit(0);
        }
        _v76 = current_content_length;
        _v72 =  *135776436;
        _v80 = lock;
        _v84 = p;
        _v88 = uf.url;
         *__esp = pid;
        addDownloadList();
L47:
        return 0;
    }
    if(( *p & 0xff) != 0) {
        p =  *(wc_Str_conv_strict(Strnew_charp(p), InnerCharset, SystemCharset));
        goto L7;
    }
    goto L5;
}

int checkCopyFile(char* path1, char* path2)
{// addr = 0x0807201D  --  defined in 'file.c' at line 8148
    intOrPtr _v88;                         // _cfa_ffffffa8
    struct stat st1;      // _cfa_ffffff9c
    intOrPtr _v176;                        // _cfa_ffffff50
    struct stat st2;      // _cfa_ffffff44
    _unknown_ _v200;                       // _cfa_ffffff38
    _unknown_ __ebp;                       // r6
    char* _t16;                            // _t16
    _unknown_ _t17;                        // _t17
    char* _t18;                            // _t18
    _unknown_ _t20;                        // _t20
    _unknown_ _t22;                        // _t22

    if(( *path2 & 0xff) == 124 && (PermitSaveToPipe & 0xff) != 0) {
        return 0;
    }
    _t16 = path1;
    __stat(_t16,  &(st1.st_dev));
    if(_t16 != 0) {
L7:
        return 0;
    }
    _t18 = path2;
    __stat(_t18,  &(st2.st_dev));
    if(_t18 != 0 || _v88 != _v176) {
        goto L7;
    }
    return -1;
    return __eax;
}

int checkSaveFile(InputStream stream, char* path2)
{// addr = 0x0807208C  --  defined in 'file.c' at line 8161
    int des;                               // _cfa_fffffff0
    intOrPtr _v92;                         // _cfa_ffffffa4
    struct stat st1;      // _cfa_ffffff98
    intOrPtr _v180;                        // _cfa_ffffff4c
    struct stat st2;      // _cfa_ffffff40
    long long unsigned int* _v216;         // _cfa_ffffff28
    _unknown_ __ebp;                       // r6
    int _t22;                              // _t22
    _unknown_ _t23;                        // _t23
    char* _t24;                            // _t24
    _unknown_ _t26;                        // _t26
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29

    des = ISfileno(stream);
    if(des < 0) {
        return 0;
    }
    if(( *path2 & 0xff) != 124 || (PermitSaveToPipe & 0xff) == 0) {
        _v216 =  &(st1.st_dev);
        _t22 = des;
         *__esp = _t22;
        __fstat();
        if(_t22 != 0) {
L9:
            return 0;
        }
        goto L6;
        return __eax;
    } else {
        return 0;
    }
L6:
    _t24 = path2;
    __stat(_t24,  &(st2.st_dev));
    if(_t24 != 0 || _v92 != _v180) {
        goto L9;
    }
    return -1;
}

int checkOverWrite(char* path)
{// addr = 0x08072116  --  defined in 'file.c' at line 8177
    char* ans;                             // _cfa_fffffff0
    struct stat st;       // _cfa_ffffff98
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    char* _t17;                            // _t17
    _unknown_ _t19;                        // _t19
    _unknown_ _t28;                        // _t28
    _unknown_ _t32;                        // _t32

    _t17 = path;
    __stat(_t17,  &(st.st_dev));
    if(_t17 >= 0) {
        ans = inputAnswer("File exists. Overwrite? (y/n)");
        if(ans == 0) {
L8:
            return -1;
        }
        goto L3;
        return __eax;
    }
    return 0;
L3:
    if(( *( &MYCTYPE_MAP + ( *ans & 0xff)) & 4) == 0) {
        if(( *ans & 0xff) != 121) {
            goto L8;
        }
        goto L7;
    }
    if((( *ans & 255 | 32) & 255) == 121) {
        goto L7;
    }
    goto L8;
L7:
    return 0;
}

char* inputAnswer(char* prompt)
{// addr = 0x0807218F  --  defined in 'file.c' at line 8193
    char* ans;                             // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    _unknown_ _t20;                        // _t20

    if((QuietMessage & 0xff) == 0) {
        if((fmInitialized & 0xff) == 0) {
            _v56 = prompt;
            printf("%s");
            fflush(__imp__stdout);
            ans =  *(Strfgets(__imp__stdin));
        } else {
            term_raw();
            ans = inputLineHistSearch(prompt, 135041709, 512, 0, 0);
        }
        return ans;
    }
    return "n";
}

uncompress_stream(URLFile* uf, char** src)
{// addr = 0x0807221F  --  defined in 'file.c' at line 8212
    pid_t pid1;          // _cfa_fffffff0
    FILE* f1;             // _cfa_ffffffec
    char* expand_cmd;                      // _cfa_ffffffe8
    char* expand_name;                     // _cfa_ffffffe4
    char* tmpf;                            // _cfa_ffffffe0
    char* ext;                             // _cfa_ffffffdc
    struct compression_decoder* d;   // _cfa_ffffffd8
    pid_t pid2;          // _cfa_ffffffd4
    FILE* f2;             // _cfa_ffffffd0
    Str buf;               // _cfa_ffffffcc
    FILE* f;              // _cfa_ffffffc8
    _unknown_ _v64;                        // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t156;                       // _t156
    _unknown_ _t159;                       // _t159
    _unknown_ _t160;                       // _t160
    _unknown_ _t175;                       // _t175
    _unknown_ _t180;                       // _t180
    _unknown_ _t184;                       // _t184
    _unknown_ _t186;                       // _t186
    _unknown_ _t188;                       // _t188
    _unknown_ _t193;                       // _t193
    _unknown_ _t195;                       // _t195
    _unknown_ _t201;                       // _t201
    _unknown_ _t234;                       // _t234

    expand_cmd = "gunzip";
    expand_name = "gunzip";
    tmpf = 0;
    ext = 0;
    if(( *( *(uf + 4) + 20) & 0xff) != 4) {
         *(uf + 4) = newEncodedStream( *(uf + 4), uf->encoding & 0xff);
        uf->encoding = 0;
    }
    d =  &compression_decoders;
    while(d->type != 0) {
        if(uf->compression != d->type) {
            d = d + 44;
        } else {
            if(d->auxbin_p == 0) {
                expand_cmd = d->cmd;
            } else {
                expand_cmd = auxbinFile(d->cmd);
            }
            expand_name = d->name;
            ext = d->ext;
            break;
        }
    }
    uf->compression = 0;
    if((uf->scheme & 0xff) != 4 && image_source == 0) {
        tmpf =  *(tmpfname(0, ext));
    }
    pid1 = open_pipe_rw( &f1, 0);
    if(pid1 >= 0) {
        if(pid1 != 0) {
L34:
            if(tmpf != 0) {
                if(src == 0) {
                    uf->scheme = 4;
                } else {
                     *src = tmpf;
                }
            }
            UFhalfclose(uf);
             *(uf + 4) = newFileStream(f1, fclose);
            return;
        }
    } else {
        if(ISclose( *(uf + 4)) != 0) {
            return;
        }
         *(uf + 4) = 0;
        return;
    }
    f2 = __imp__stdin;
    pid2 = open_pipe_rw( &f2, 0);
    if(pid2 < 0) {
        if(ISclose( *(uf + 4)) == 0) {
             *(uf + 4) = 0;
        }
        exit(1);
    }
    if(pid2 != 0) {
L33:
        dup2(1, 2);
        setup_child(1, -1, -1);
        _v68 = 0;
        execlp(expand_cmd, expand_name);
        exit(1);
    } else {
        buf = Strnew_size(1536);
        f = 0;
        setup_child(1, 2, ISfileno( *(uf + 4)));
        if(tmpf != 0) {
            f = fopen(tmpf, "wb");
        }
        while(ISread( *(uf + 4), buf, 1536) != 0) {
            fwrite(buf->ptr, 1, buf->length, __imp__stdout);
            if(f != 0) {
                fwrite(buf->ptr, 1, buf->length, f);
            }
        }
        if(ISclose( *(uf + 4)) == 0) {
             *(uf + 4) = 0;
        }
        if(f != 0) {
            fclose(f);
        }
        exit(0);
        goto L33;
    }
    goto L34;
}

FILE* lessopen_stream(char* path)
{// addr = 0x08072573  --  defined in 'file.c' at line 8302
    char* lessopen;                        // _cfa_fffffff0
    FILE* fp;             // _cfa_ffffffec
    Str tmpf;              // _cfa_ffffffe8
    int c;                                 // _cfa_ffffffe4
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t28;                        // _t28
    int _t42;                              // _t42
    _unknown_ _t45;                        // _t45
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    _unknown_ _t50;                        // _t50
    _unknown_ _t51;                        // _t51

    lessopen = getenv("LESSOPEN");
    if(lessopen != 0) {
        if(( *lessopen & 0xff) != 0) {
            if(( *lessopen & 0xff) != 124) {
L10:
                fp = 0;
                goto L11;
            }
            goto L5;
L11:
            return fp;
        }
        goto L3;
L5:
        lessopen =  &(lessopen[1]);
        _v40 = shell_quote(path);
        tmpf = Sprintf(lessopen);
        fp = popen(tmpf->ptr, "r");
        if(fp != 0) {
            _t42 = fp;
             *__esp = _t42;
            _IO_getc();
            c = _t42;
            if(c != 255) {
                ungetc(c, fp);
                goto L11;
            }
            goto L8;
        }
        return 0;
L8:
        fclose(fp);
        return 0;
    }
    return 0;
L3:
    return 0;
}

char* guess_filename(char* file)
{// addr = 0x08072646  --  defined in 'file.c' at line 8376
    char* p;                               // _cfa_fffffff0
    char* s;                               // _cfa_ffffffec
    _unknown_ __ebp;                       // r6

    p = 0;
    if(file != 0) {
        p = mybasename(file);
    }
    if(p == 0 || ( *p & 0xff) == 0) {
        return "index.html";
    }
    s = p;
    if(( *p & 0xff) == 35) {
        p =  &(p[1]);
    }
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) != 35 || (p[1] & 0xff) == 0) {
            if(( *p & 0xff) != 63) {
                p =  &(p[1]);
                continue;
            }
        }
         *p = 0;
        break;
    }
    return s;
}

char* guess_save_name(Buffer* buf, char* path)
{// addr = 0x080726D3  --  defined in 'file.c' at line 8398
    Str name;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t66;                            // _t66
    char* _t83;                            // _t83

    if(buf == 0 || buf->document_header == 0) {
L16:
        return guess_filename(path);
    } else {
        name = 0;
        p = checkHeader(buf, "Content-Disposition:");
        if(p == 0) {
L9:
            p = checkHeader(buf, "Content-Type:");
            if(p != 0) {
L10:
                _v40 = "name";
                _t66 = p;
                 *__esp = _t66;
                strcasestr();
                q = _t66;
                if(q != 0 && (q == p || ( *( &MYCTYPE_MAP + ( *(q - 1) & 0xff)) & 2) != 0 || ( *(q - 1) & 0xff) == 59)) {
                    if(matchattr(q, "name", 4,  &name) != 0) {
                        path = name->ptr;
                    }
                }
            }
            goto L16;
        }
        _v40 = "filename";
        _t83 = p;
         *__esp = _t83;
        strcasestr();
        q = _t83;
        if(q == 0 || q != p && ( *( &MYCTYPE_MAP + ( *(q - 1) & 0xff)) & 2) == 0 && ( *(q - 1) & 0xff) != 59) {
            goto L9;
        } else {
            if(matchattr(q, "filename", 8,  &name) == 0) {
                goto L9;
            } else {
                path = name->ptr;
            }
            goto L16;
        }
        goto L10;
    }
}

Buffer* newBuffer(int width)
{// addr = 0x08072844  --  defined in 'buffer.c' at line 25
    Buffer* n;          // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t41;                        // _t41
    int* _t53;                             // _t53
    _unknown_ _t60;                        // _t60

     *__esp = 260;
    GC_malloc();
    n = __eax;
    if(n != 0) {
        bzero(n, 260);
        n->width = width & 65535;
        n->COLS = COLS & 65535;
        n->LINES = LINES - 1 & 65535;
         *((intOrPtr*)(n + 132)) = 255;
        n->baseURL = 0;
        n->baseTarget = 0;
        n->buffername = 135048112;
        _t53 = n;
        _t53[0x10] = 0;
         *__esp = 4;
        GC_malloc();
        n->clone = _t53;
        n = 1;
         *(n + 200) = 0;
         *(n + 212) = WcOption.auto_detect & 0xff;
        return n;
    }
    return 0;
}

Buffer* nullBuffer()
{// addr = 0x08072929  --  defined in 'buffer.c' at line 57
    Buffer* b;          // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    b = newBuffer(COLS);
    b->buffername = "*Null*";
    return b;
}

clearBuffer(Buffer* buf)
{// addr = 0x0807294E  --  defined in 'buffer.c' at line 70
    _unknown_ __ebp;                       // r6

    buf->lastLine = 0;
    buf->currentLine = buf->lastLine;
    buf->topLine = buf->currentLine;
    buf->firstLine = buf->topLine;
    buf->allLine = 0;
    return;
}

discardBuffer(Buffer* buf)
{// addr = 0x0807298B  --  defined in 'buffer.c' at line 81
    int i;                                 // _cfa_fffffff0
    Buffer* b;          // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    short int _t69;                        // _t69
    _unknown_ _t81;                        // _t81
    _unknown_ _t91;                        // _t91
    _unknown_ _t98;                        // _t98
    _unknown_ _t107;                       // _t107
    _unknown_ _t110;                       // _t110

    deleteImage(buf);
    clearBuffer(buf);
    i = 0;
    while(i <= 4) {
        b =  *(buf + 12 + (i + 4) * 4);
        if(b != 0) {
             *(b + 12 + ( *((intOrPtr*)( &REV_LB + i * 4)) + 4) * 4) = 0;
        }
        i = i + 1;
    }
    if(buf->savecache != 0) {
        unlink(buf->savecache);
    }
    _t69 = buf->clone;
     *_t69 =  *_t69 - 1;
    if( *_t69 != 0) {
        return;
    } else {
        if( *(buf + 92) != 0) {
            ISclose( *(buf + 92));
        }
        if(buf->sourcefile == 0 || buf->real_type != 0 && strncasecmp(buf->real_type, "image/", 6) == 0) {
L17:
            if(buf->header_source != 0) {
                unlink(buf->header_source);
            }
            if(buf->mailcap_source != 0) {
                unlink(buf->mailcap_source);
            }
            while(buf->frameset != 0) {
                deleteFrameSet(buf->frameset);
                buf->frameset = popFrameTree( &(buf->frameQ));
            }
            return;
        }
        if(buf->real_scheme != 4) {
L16:
            unlink(buf->sourcefile);
            goto L17;
        }
        asm("cwde ");
        if((buf->bufferprop & 2) == 0) {
            goto L17;
        }
        goto L16;
    }
}

Buffer* namedBuffer(Buffer* first, char* name)
{// addr = 0x08072B1F  --  defined in 'buffer.c' at line 121
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t34;                        // _t34

    if(strcmp(first->buffername, name) != 0) {
        buf = first;
L6:
        while(buf->nextBuffer != 0) {
            goto L3;
        }
        return 0;
    }
    return first;
L3:
    if(strcmp(buf->nextBuffer->buffername, name) != 0) {
        buf = buf->nextBuffer;
        goto L6;
    }
    return buf->nextBuffer;
}

Buffer* deleteBuffer(Buffer* first, Buffer* delbuf)
{// addr = 0x08072B89  --  defined in 'buffer.c' at line 140
    Buffer* buf;        // _cfa_fffffff0
    Buffer* b;          // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(first != delbuf || first->nextBuffer == 0) {
        buf = prevBuffer(first, delbuf);
        if(buf != 0) {
            b = buf->nextBuffer;
            buf->nextBuffer = b->nextBuffer;
            discardBuffer(b);
        }
        return first;
    }
    buf = first->nextBuffer;
    discardBuffer(first);
    return buf;
}

Buffer* replaceBuffer(Buffer* first, Buffer* delbuf, Buffer* newbuf)
{// addr = 0x08072BFA  --  defined in 'buffer.c' at line 161
    Buffer* buf;        // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(delbuf != 0) {
        if(first != delbuf) {
            if(delbuf == 0) {
L7:
                newbuf->nextBuffer = first;
                return newbuf;
            }
            goto L5;
            return __eax;
        }
        goto L3;
L5:
        buf = prevBuffer(first, delbuf);
        if(buf == 0) {
            goto L7;
        }
        buf->nextBuffer = newbuf;
        newbuf->nextBuffer = delbuf->nextBuffer;
        discardBuffer(delbuf);
        return first;
    }
    newbuf->nextBuffer = first;
    return newbuf;
L3:
    newbuf->nextBuffer = delbuf->nextBuffer;
    discardBuffer(delbuf);
    return newbuf;
}

Buffer* nthBuffer(Buffer* firstbuf, int n)
{// addr = 0x08072C8C  --  defined in 'buffer.c' at line 185
    int i;                                 // _cfa_fffffff8
    Buffer* buf;        // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t19;                        // _t19

    buf = firstbuf;
    if(n >= 0) {
        i = 0;
L6:
        while(i < n) {
            goto L3;
        }
        return buf;
    }
    return firstbuf;
L3:
    if(buf != 0) {
        buf = buf->nextBuffer;
        i = i + 1;
        goto L6;
    }
    return 0;
}

writeBufferName(Buffer* buf, int n)
{// addr = 0x08072CD3  --  defined in 'buffer.c' at line 201
    Str msg;               // _cfa_fffffff0
    int all;                               // _cfa_ffffffec
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct _ParsedURL _t83;   // _t83
    int _t90;                              // _t90
    int _t110;                             // _t110

    all = buf->allLine;
    if(all == 0 && buf->lastLine != 0) {
        all = buf->lastLine->linenumber;
    }
    move(n, 0);
    _v36 = all;
    _v40 = buf->buffername;
    msg = Sprintf("<%s> [%d lines]");
    if(buf->filename == 0) {
L16:
        addnstr_sup(msg->ptr, COLS - 1);
        return;
    }
    _t83 =  *(buf + 132);
    if(_t83 < 4) {
L12:
        if(msg->length + 1 >= msg->area_size) {
            Strgrow(msg);
        }
        _t90 = msg->length;
         *((char*)(msg->ptr + _t90)) = 32;
        msg->length = _t90 + 1;
         *(msg->ptr + msg->length) = 0;
        Strcat(msg, parsedURL2Str(buf + 132));
        goto L16;
    }
    if(_t83 <= 5) {
        if(strcmp( *(buf + 152), "-") != 0) {
            if(msg->length + 1 >= msg->area_size) {
                Strgrow(msg);
            }
            _t110 = msg->length;
             *((char*)(msg->ptr + _t110)) = 32;
            msg->length = _t110 + 1;
             *(msg->ptr + msg->length) = 0;
            Strcat_charp(msg,  *(wc_Str_conv(Strnew_charp( *(buf + 156)), SystemCharset, InnerCharset)));
        }
        goto L16;
    }
    if(_t83 - 254 > 1) {
        goto L12;
    }
    goto L16;
}

gotoLine(Buffer* buf, int n)
{// addr = 0x08072EA3  --  defined in 'buffer.c' at line 238
    signed int _v16;                       // _cfa_fffffff0
    char[31] msg;                          // _cfa_ffffffd0
    Line* l;              // _cfa_ffffffcc
    Buffer* _v64;       // _cfa_ffffffc0
    _unknown_ _v80;                        // _cfa_ffffffb0
    long int _v84;                         // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t105;                       // _t105
    signed int _t109;                      // _t109
    _unknown_ _t144;                       // _t144
    _unknown_ _t156;                       // _t156
    _unknown_ _t177;                       // _t177
    _unknown_ _t187;                       // _t187
    _unknown_ _t200;                       // _t200

    _v64 = _a4;
    _v16 =  *gs:0x14];
    l = _v64->firstLine;
    if(l == 0) {
        goto L20;
    }
    if( *((intOrPtr*)(_v64 + 92)) == 0) {
L7:
        _t200 = l->linenumber - n;
        if(_t200 <= 0) {
            if(_v64->lastLine->linenumber >= n) {
                while(l != 0) {
                    if(l->linenumber < n) {
                        l = l->next;
                        continue;
                    }
                    _v64->currentLine = l;
                    if(_v64->topLine->linenumber > n) {
L14:
                        asm("cwde ");
                        _v64->topLine = lineSkip(_v64, l, ( !(_v64->LINES & 65535) >> 31) +  !(_v64->LINES & 65535) >> 1, 0);
                        goto L20;
                    }
                    asm("cwde ");
                    if(_v64->topLine->linenumber + (_v64->LINES & 65535) > n) {
                        goto L19;
                    }
                    goto L14;
L20:
                    _t109 = _v16 ^  *gs:0x14];
                    if(_t200 == 0) {
                        return _t109;
                    }
                    __stack_chk_fail();
                    return _t109;
                }
                goto L20;
            }
            goto L10;
        }
        goto L8;
L10:
        l = _v64->lastLine;
        _v84 = _v64->lastLine->linenumber;
        sprintf( &msg, "Last line is #%ld");
        set_delayed_message( &msg);
        _v64->currentLine = l;
        asm("cwde ");
        _v64->topLine = lineSkip(_v64, _v64->currentLine, 1 - (_v64->LINES & 65535), 0);
        goto L20;
    }
    asm("cwde ");
    if((_v64->bufferprop & 0x40) != 0) {
    } else {
        if(_v64->lastLine->linenumber < n) {
            getNextPage(_v64, n - _v64->lastLine->linenumber);
        }
        while(_v64->lastLine->linenumber < n && getNextPage(_v64, 1) != 0) {
        }
    }
L8:
    _v84 = l->linenumber;
    sprintf( &msg, "First line is #%ld");
    set_delayed_message( &msg);
    _v64->currentLine = l;
    _v64->topLine = _v64->currentLine;
    goto L20;
L19:
    goto L20;
}

gotoRealLine(Buffer* buf, int n)
{// addr = 0x080730B4  --  defined in 'buffer.c' at line 283
    signed int _v16;                       // _cfa_fffffff0
    char[31] msg;                          // _cfa_ffffffd0
    Line* l;              // _cfa_ffffffcc
    Buffer* _v64;       // _cfa_ffffffc0
    _unknown_ _v80;                        // _cfa_ffffffb0
    long int _v84;                         // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t105;                       // _t105
    signed int _t109;                      // _t109
    _unknown_ _t144;                       // _t144
    _unknown_ _t156;                       // _t156
    _unknown_ _t177;                       // _t177
    _unknown_ _t187;                       // _t187
    _unknown_ _t200;                       // _t200

    _v64 = _a4;
    _v16 =  *gs:0x14];
    l = _v64->firstLine;
    if(l == 0) {
        goto L20;
    }
    if( *((intOrPtr*)(_v64 + 92)) == 0) {
L7:
        _t200 = l->real_linenumber - n;
        if(_t200 <= 0) {
            if(_v64->lastLine->real_linenumber >= n) {
                while(l != 0) {
                    if(l->real_linenumber < n) {
                        l = l->next;
                        continue;
                    }
                    _v64->currentLine = l;
                    if(_v64->topLine->real_linenumber > n) {
L14:
                        asm("cwde ");
                        _v64->topLine = lineSkip(_v64, l, ( !(_v64->LINES & 65535) >> 31) +  !(_v64->LINES & 65535) >> 1, 0);
                        goto L20;
                    }
                    asm("cwde ");
                    if(_v64->topLine->real_linenumber + (_v64->LINES & 65535) > n) {
                        goto L19;
                    }
                    goto L14;
L20:
                    _t109 = _v16 ^  *gs:0x14];
                    if(_t200 == 0) {
                        return _t109;
                    }
                    __stack_chk_fail();
                    return _t109;
                }
                goto L20;
            }
            goto L10;
        }
        goto L8;
L10:
        l = _v64->lastLine;
        _v84 = _v64->lastLine->real_linenumber;
        sprintf( &msg, "Last line is #%ld");
        set_delayed_message( &msg);
        _v64->currentLine = l;
        asm("cwde ");
        _v64->topLine = lineSkip(_v64, _v64->currentLine, 1 - (_v64->LINES & 65535), 0);
        goto L20;
    }
    asm("cwde ");
    if((_v64->bufferprop & 0x40) != 0) {
    } else {
        if(_v64->lastLine->real_linenumber < n) {
            getNextPage(_v64, n - _v64->lastLine->real_linenumber);
        }
        while(_v64->lastLine->real_linenumber < n && getNextPage(_v64, 1) != 0) {
        }
    }
L8:
    _v84 = l->real_linenumber;
    sprintf( &msg, "First line is #%ld");
    set_delayed_message( &msg);
    _v64->currentLine = l;
    _v64->topLine = _v64->currentLine;
    goto L20;
L19:
    goto L20;
}

Buffer* listBuffer(Buffer* top, Buffer* current)
{// addr = 0x080732C5  --  defined in 'buffer.c' at line 326
    int i;                                 // _cfa_fffffff0
    int c;                                 // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    c = 0;
    buf = top;
    move(0, 0);
    if(useColor != 0) {
        setfcolor(basic_color);
        setbcolor(bg_color);
    }
    clrtobotx();
    i = 0;
    while(LINES - 1 > i) {
        if(buf == current) {
            c = i;
            standout();
        }
        writeBufferName(buf, i);
        if(buf != current) {
            clrtoeolx();
        } else {
            standend();
            clrtoeolx();
            move(i, 0);
            toggle_stand();
        }
        if(buf->nextBuffer != 0) {
            buf = buf->nextBuffer;
            i = i + 1;
            continue;
        }
        move(i + 1, 0);
        clrtobotx();
        break;
    }
    standout();
    message("Buffer selection mode: SPC for select / D for delete buffer", 0, 0);
    standend();
    move(c, 0);
    refresh();
    return buf->nextBuffer;
}

Buffer* selectBuffer(Buffer* firstbuf, Buffer* currentbuf, char* selectchar)
{// addr = 0x08073401  --  defined in 'buffer.c' at line 379
    char c;                                // _cfa_fffffff3
    int i;                                 // _cfa_ffffffec
    int cpoint;                            // _cfa_ffffffe8
    int spoint;                            // _cfa_ffffffe4
    int maxbuf;                            // _cfa_ffffffe0
    int sclimit;                           // _cfa_ffffffdc
    Buffer* buf;        // _cfa_ffffffd8
    Buffer* topbuf;     // _cfa_ffffffd4
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t145;                       // _t145
    _unknown_ _t147;                       // _t147
    _unknown_ _t160;                       // _t160
    _unknown_ _t179;                       // _t179
    _unknown_ _t193;                       // _t193

    sclimit = LINES - 1;
    cpoint = 0;
    i = cpoint;
    buf = firstbuf;
    while() {
    }
}

reshapeBuffer(Buffer* buf)
{// addr = 0x080736FB  --  defined in 'buffer.c' at line 504
    wc_uint8 old_auto_detect;   // _cfa_fffffff3
    Line* cur;            // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    union input_stream* _v52;   // _cfa_ffffffcc
    URLFile f;         // _cfa_ffffffc8
    union input_stream* _v84;   // _cfa_ffffffac
    URLFile h;         // _cfa_ffffffa8
    AnchorList* _v240;   // _cfa_ffffff10
    intOrPtr _v272;                        // _cfa_fffffef0
    int _v280;                             // _cfa_fffffee8
    Line* _v332;          // _cfa_fffffeb4
    intOrPtr _v336;                        // _cfa_fffffeb0
    intOrPtr _v340;                        // _cfa_fffffeac
    Buffer sbuf;        // _cfa_fffffea4
    _unknown_ _v352;                       // _cfa_fffffea0
    _unknown_ _v356;                       // _cfa_fffffe9c
    Buffer* _v360;      // _cfa_fffffe98
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char _t215;                            // _t215
    _unknown_ _t216;                       // _t216
    char* _t225;                           // _t225
    _unknown_ _t255;                       // _t255
    _unknown_ _t274;                       // _t274
    _unknown_ _t337;                       // _t337
    int _t369;                             // _t369
    _unknown_ _t370;                       // _t370
    _unknown_ _t400;                       // _t400
    _unknown_ _t403;                       // _t403

    old_auto_detect = WcOption.auto_detect & 0xff;
    if((buf->need_reshape & 0xff) == 0) {
        return;
    } else {
        buf->need_reshape = 0;
        _t369 = COLS;
        if(showLineNum == 0) {
            _t215 = 1;
        } else {
            _t215 = 6;
        }
        _t216 = _t369 - _t215;
        _t217 = _t216 >= 0 ? 0 : _t216;
        _t371 = _t216 >= 0 ? 0 : _t216;
        buf->width = (_t216 >= 0 ? 0 : _t216) & 65535;
        if(buf->sourcefile == 0) {
            goto L59;
        } else {
            init_stream( &(f.scheme), 4, 0);
            if(buf->mailcap_source == 0) {
                _t225 = buf->sourcefile;
            } else {
                _t225 = buf->mailcap_source;
            }
            examineFile(_t225,  &(f.scheme));
            if(_v52 == 0) {
                goto L60;
            } else {
                copyBuffer( &(sbuf.filename), buf);
                clearBuffer(buf);
                while(buf->frameset != 0) {
                }
                buf->href = 0;
                buf->name = 0;
                buf->img = 0;
                buf->formitem = 0;
                buf->formlist = 0;
                buf->linklist = 0;
                buf->maplist = 0;
                if(buf->hmarklist != 0) {
                    buf->hmarklist->nmark = 0;
                }
                if(buf->imarklist != 0) {
                    buf->imarklist->nmark = 0;
                }
                if(buf->header_source != 0) {
                    if( *((intOrPtr*)(buf + 132)) != 4 || buf->mailcap_source != 0 || strcmp( *(buf + 152), "-") == 0) {
                        init_stream( &(h.scheme), 4, 0);
                        examineFile(buf->header_source,  &(h.scheme));
                        if(_v84 != 0) {
                            readHeader( &(h.scheme), buf, 1, 0);
                            if(ISclose(_v84) == 0) {
                                _v84 = 0;
                            }
                        }
                    } else {
                        if((buf->search_header & 0xff) != 0) {
                            readHeader( &(f.scheme), buf, 1, 0);
                        }
                    }
                }
                WcOption.auto_detect = 0;
                UseContentCharset = 0;
                if(is_html_type(buf->type) == 0) {
                    _v360 = buf;
                    loadBuffer( &(f.scheme));
                } else {
                    loadHTMLBuffer( &(f.scheme), buf);
                }
                if(ISclose(_v52) == 0) {
                    _v52 = 0;
                }
                WcOption.auto_detect = old_auto_detect & 0xff;
                UseContentCharset = 1;
                buf->height = LINES & 65535;
                if(buf->firstLine == 0 || _v340 == 0) {
L50:
                    if((buf->check_url & 1) != 0) {
                        chkURLBuffer(buf);
                    }
                    if((buf->check_url & 2) != 0) {
                        chkNMIDBuffer(buf);
                    }
                    if(buf->real_scheme == 7 || buf->real_scheme == 9) {
                        reAnchorNewsheader(buf);
                    }
                    formResetBuffer(buf, _v240);
                    return;
                }
                cur = _v332;
                buf->pos = _v272 + cur->bpos;
                while(cur->bpos != 0 && cur->prev != 0) {
                    cur = cur->prev;
                }
                if(cur->real_linenumber <= 0) {
                    gotoLine(buf, cur->linenumber);
                } else {
                    gotoRealLine(buf, cur->real_linenumber);
                }
                n = buf->currentLine->linenumber - buf->topLine->linenumber +  *((intOrPtr*)(_v336 + 28)) - cur->linenumber;
                if(n != 0) {
                    buf->topLine = lineSkip(buf, buf->topLine, n, 0);
                    if(cur->real_linenumber <= 0) {
                        gotoLine(buf, cur->linenumber);
                    } else {
                        gotoRealLine(buf, cur->real_linenumber);
                    }
                }
                buf->pos = buf->pos - buf->currentLine->bpos;
                if(FoldLine == 0 || is_html_type(buf->type) != 0) {
                    buf->currentColumn = _v280;
                } else {
                    buf->currentColumn = 0;
                }
                arrangeCursor(buf);
                goto L50;
            }
        }
L60:
        return;
    }
L59:
    return;
}

copyBuffer(Buffer* a, Buffer* b)
{// addr = 0x08073C16  --  defined in 'buffer.c' at line 612
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10

    readBufferCache(b);
    bcopy(b, a, 260);
    return;
}

Buffer* prevBuffer(Buffer* first, Buffer* buf)
{// addr = 0x08073C43  --  defined in 'buffer.c' at line 619
    Buffer* b;          // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    b = first;
    while(b != 0 && b->nextBuffer != buf) {
        b = b->nextBuffer;
    }
    return b;
}

int writeBufferCache(Buffer* buf)
{// addr = 0x08073C70  --  defined in 'buffer.c' at line 631
    Str tmp;               // _cfa_fffffff0
    FILE* cache;          // _cfa_ffffffec
    Line* l;              // _cfa_ffffffe8
    int colorflag;                         // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t136;                       // _t136
    _unknown_ _t148;                       // _t148
    _unknown_ _t151;                       // _t151
    _unknown_ _t191;                       // _t191
    _unknown_ _t192;                       // _t192
    _unknown_ _t210;                       // _t210

    cache = 0;
    if(buf->savecache != 0) {
        return -1;
    }
    if(buf->firstLine == 0) {
L27:
L29:
        buf->savecache = 0;
        return -1;
    } else {
        tmp = tmpfname(3, 0);
        buf->savecache = tmp->ptr;
        cache = fopen(buf->savecache, "w");
        if(cache == 0) {
            goto L29;
        }
        if(fwrite( &(buf->currentLine->linenumber), 4, 1, cache) == 0) {
L26:
            fclose(cache);
            unlink(buf->savecache);
            goto L29;
        }
        if(fwrite( &(buf->topLine->linenumber), 4, 1, cache) == 0) {
            goto L26;
        } else {
            l = buf->firstLine;
            while() {
            }
        }
        goto L27;
    }
    return __eax;
}

int readBufferCache(Buffer* buf)
{// addr = 0x08073FE8  --  defined in 'buffer.c' at line 694
    FILE* cache;          // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    Line* prevl;          // _cfa_ffffffe8
    Line* basel;          // _cfa_ffffffe4
    long int lnum;                         // _cfa_ffffffe0
    long int clnum;                        // _cfa_ffffffdc
    long int tlnum;                        // _cfa_ffffffd8
    int colorflag;                         // _cfa_ffffffd4
    FILE* _v48;           // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t181;                       // _t181
    _unknown_ _t188;                       // _t188

    l = 0;
    prevl = 0;
    basel = 0;
    lnum = 0;
    if(buf->savecache == 0) {
        return -1;
    }
    __edx = "r";
    cache = fopen(buf->savecache, "r");
    if(cache == 0 || fread( &clnum, 4, 1, cache) == 0 || fread( &tlnum, 4, 1, cache) == 0) {
        buf->savecache = 0;
        return -1;
    }
    while(1) {
        cache = feof(cache);
        if(cache != 0) {
            break;
        }
        lnum = lnum + 1;
        __eax = l;
        prevl = __eax;
         *__esp = 52;
        GC_malloc();
        l = __eax;
        __eax = l;
        __edx = prevl;
        l->prev = prevl;
        if(prevl == 0) {
            __eax = buf;
            __edx = l;
            buf->firstLine = l;
        } else {
            __eax = prevl;
            __edx = l;
            prevl->next = l;
        }
        __eax = l;
        __edx = lnum;
        l->linenumber = lnum;
        __eax = clnum;
        if(lnum == clnum) {
            __eax = buf;
            __edx = l;
            buf->currentLine = l;
        }
        __eax = tlnum;
        if(lnum == tlnum) {
            __eax = buf;
            __edx = l;
            buf->topLine = l;
        }
        __eax = l;
        __edx =  &(l->real_linenumber);
        cache = fread( &(l->real_linenumber), 4, 1, cache);
        if(cache == 0) {
L35:
            __eax = buf;
            __edx = prevl;
            buf->lastLine = prevl;
            buf = buf->lastLine;
            buf->lastLine->next = 0;
            cache = fclose(cache);
            buf = buf->savecache;
            unlink(buf->savecache) = buf;
            buf->savecache = 0;
            __eax = 0;
            return 0;
        } else {
            __eax = l;
            __edx =  &(l->usrflags);
            cache = fread( &(l->usrflags), 2, 1, cache);
            if(cache == 0) {
                goto L35;
            }
            __eax = l;
            __edx =  &(l->width);
            cache = fread( &(l->width), 4, 1, cache);
            if(cache == 0) {
                goto L35;
            }
            __eax = l;
            __edx =  &(l->len);
            cache = fread( &(l->len), 4, 1, cache);
            if(cache == 0) {
                goto L35;
            }
            __eax = l;
            __edx =  &(l->size);
            cache = fread( &(l->size), 4, 1, cache);
            if(cache == 0) {
                goto L35;
            }
            __eax = l;
            __edx =  &(l->bpos);
            cache = fread( &(l->bpos), 4, 1, cache);
            if(cache == 0) {
                goto L35;
            }
            __eax = l;
            __edx =  &(l->bwidth);
            cache = fread( &(l->bwidth), 4, 1, cache);
            if(cache == 0) {
                goto L35;
            }
            l = l->bpos;
            if(l->bpos != 0) {
                if(basel == 0) {
                    goto L35;
                }
                goto L23;
            }
            __eax = l;
            basel = l;
            l = l->size;
            __eax =  &(l->size->lineBuf);
             *__esp = __eax;
            GC_malloc_atomic();
            __edx = __eax;
            __eax = l;
            l->lineBuf = __edx;
            l = l->size;
            __edx = l->size;
            l = l->lineBuf;
            fread(l->lineBuf, 1, l->size, cache) = l;
            __edx = l->lineBuf;
            l = l->size;
            __eax = l->lineBuf + l->size;
             *(l->lineBuf + l->size) = 0;
            __eax = l;
            __eax = l->size;
            __eax = l->size + l->size;
             *__esp = __eax;
            GC_malloc_atomic();
            __edx = __eax;
            __eax = l;
            l->propBuf = __edx;
            l = l->size;
            __edx = l->size;
            l = l->propBuf;
            __eax = fread(l->propBuf, 2, l->size, cache);
L24:
            __eax = cache;
            _v48 = cache;
            _v52 = 1;
            _v56 = 4;
            __eax =  &colorflag;
             *__esp =  &colorflag;
            __eax = fread();
            if( &colorflag == 0) {
                goto L35;
            }
            __eax = colorflag;
            if(colorflag == 0) {
                __eax = l;
                l->colorBuf = 0;
            } else {
                l = l->bpos;
                if(l->bpos != 0) {
                    __eax = basel;
                    __edx = basel->colorBuf;
                    l = l->bpos;
                    __edx = basel->colorBuf + l->bpos;
                    __eax = l;
                    l->colorBuf = basel->colorBuf + l->bpos;
                } else {
                    __eax = l;
                    __eax = l->size;
                     *__esp = __eax;
                    GC_malloc_atomic();
                    __edx = __eax;
                    __eax = l;
                    l->colorBuf = __edx;
                    l = l->size;
                    __edx = l->size;
                    l = l->colorBuf;
                    __eax = fread(l->colorBuf, 1, l->size, cache);
                }
            }
            continue;
L23:
            __eax = basel;
            __edx = basel->lineBuf;
            l = l->bpos;
            __edx = basel->lineBuf + l->bpos;
            __eax = l;
            l->lineBuf = basel->lineBuf + l->bpos;
            __eax = basel;
            __edx = basel->propBuf;
            __eax = l;
            __eax = l->bpos;
            __eax = l->bpos + l->bpos;
            __edx = basel->propBuf + l->bpos + l->bpos;
            __eax = l;
            l->propBuf = basel->propBuf + l->bpos + l->bpos;
            goto L24;
        }
        return __eax;
    }
    goto L35;
}

effect_anchor_start()
{// addr = 0x08074428  --  defined in 'display.c' at line 73
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
        underline();
        return;
    }
    setfcolor(anchor_color);
    return;
}

effect_anchor_end()
{// addr = 0x0807444D  --  defined in 'display.c' at line 73
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
        underlineend();
        return;
    }
    setfcolor(basic_color);
    return;
}

effect_image_start()
{// addr = 0x08074472  --  defined in 'display.c' at line 75
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
        standout();
        return;
    }
    setfcolor(image_color);
    return;
}

effect_image_end()
{// addr = 0x08074497  --  defined in 'display.c' at line 75
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
        standend();
        return;
    }
    setfcolor(basic_color);
    return;
}

effect_form_start()
{// addr = 0x080744BC  --  defined in 'display.c' at line 77
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
        standout();
        return;
    }
    setfcolor(form_color);
    return;
}

effect_form_end()
{// addr = 0x080744E1  --  defined in 'display.c' at line 77
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
        standend();
        return;
    }
    setfcolor(basic_color);
    return;
}

effect_mark_start()
{// addr = 0x08074506  --  defined in 'display.c' at line 79
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
        standout();
        return;
    }
    setbcolor(mark_color);
    return;
}

effect_mark_end()
{// addr = 0x0807452B  --  defined in 'display.c' at line 79
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
        standend();
        return;
    }
    setbcolor(bg_color);
    return;
}

effect_active_start()
{// addr = 0x08074550  --  defined in 'display.c' at line 84
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
L4:
        bold();
        return;
    }
    if(useActiveColor == 0) {
        underline();
        return;
    }
    setfcolor(active_color);
    underline();
    return;
    goto L4;
    return;
}

effect_active_end()
{// addr = 0x0807458A  --  defined in 'display.c' at line 105
    _unknown_ __ebp;                       // r6

    if(useColor == 0) {
L4:
        boldend();
        return;
    }
    if(useActiveColor == 0) {
        underlineend();
        return;
    }
    setfcolor(basic_color);
    underlineend();
    return;
    goto L4;
    return;
}

effect_visited_start()
{// addr = 0x080745C4  --  defined in 'display.c' at line 119
    _unknown_ __ebp;                       // r6

    if(useVisitedColor == 0 || useColor == 0) {
        return;
    } else {
        setfcolor(visited_color);
        return;
    }
}

effect_visited_end()
{// addr = 0x080745EB  --  defined in 'display.c' at line 131
    _unknown_ __ebp;                       // r6

    if(useVisitedColor == 0 || useColor == 0) {
        return;
    } else {
        setfcolor(basic_color);
        return;
    }
}

fmTerm()
{// addr = 0x08074612  --  defined in 'display.c' at line 160
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if((fmInitialized & 0xff) != 0) {
        move(LINES - 1, 0);
        clrtoeolx();
        refresh();
        if(activeImage != 0) {
            loadImage(0, 1);
        }
        if(use_mouse != 0) {
            mouse_end();
        }
        reset_tty();
        fmInitialized = 0;
        return;
    }
    return;
}

fmInit()
{// addr = 0x0807467E  --  defined in 'display.c' at line 184
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    if((fmInitialized & 0xff) == 0) {
        initscr();
        term_raw();
        term_noecho();
        if(displayImage != 0) {
            initImage();
        }
    }
    fmInitialized = 1;
    return;
}

Str make_lastline_link(Buffer* buf, char* title, char* url)
{// addr = 0x080746B5  --  defined in 'display.c' at line 233
    Str s;                 // _cfa_fffffff0
    Str u;                 // _cfa_ffffffec
    Lineprop* pr;     // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    int l;                                 // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    ParsedURL pu;    // _cfa_ffffffb4
    Linecolor** _v80;   // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    int _t137;                             // _t137

    s = 0;
    l = COLS - 1;
    if(title == 0) {
L12:
        if(url != 0) {
            parseURL2(url,  &(pu.scheme), baseURL(buf));
            u = parsedURL2Str( &(pu.scheme));
            if(DecodeURL != 0) {
                u = Strnew_charp(url_unquote_conv(u->ptr,  *(buf + 208)));
            }
            u = checkType(u,  &pr, 0);
            if(l <= 4 || wtf_strwidth(u->ptr) <= l) {
                if(s != 0) {
                    Strcat(s, u);
                    return s;
                }
            } else {
                if(s == 0) {
                    s = Strnew_size(COLS);
                }
                i = (l - 2 >> 31) + l - 2 >> 1;
                while(i != 0 && ( *(pr + i + i) & 0x400) != 0) {
                    i = i - 1;
                }
                Strcat_charp_n(s, u->ptr, i);
                Strcat_charp(s, "..");
                _t137 = wtf_strwidth(u->ptr);
                i = _t137 + wtf_strwidth(s->ptr) + 1 - COLS;
                while(u->length > i && ( *(pr + i + i) & 0x400) != 0) {
                    i = i + 1;
                }
                Strcat_charp(s,  &(u->ptr[i]));
                return s;
            }
            return u;
        }
        goto L13;
    }
    if(( *title & 0xff) == 0) {
        goto L12;
    } else {
        _v80 = 0;
        _v84 = "]";
        _v88 = title;
        s = Strnew_m_charp("[");
        p = s->ptr;
        while(( *p & 0xff) != 0) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 1) != 0 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                 *p = 32;
            }
            p =  &(p[1]);
        }
        if(url != 0) {
            Strcat_charp(s, " ");
        }
        l = l - wtf_strwidth(s->ptr);
        if(l > 0) {
            goto L12;
        }
        return s;
    }
L13:
    return s;
}

Str make_lastline_message(Buffer* buf)
{// addr = 0x0807495D  --  defined in 'display.c' at line 289
    Str msg;               // _cfa_fffffff0
    Str s;                 // _cfa_ffffffec
    int sl;                                // _cfa_ffffffe8
    MapArea* a;        // _cfa_ffffffe4
    Anchor* a;          // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    Anchor* a_img;      // _cfa_ffffffd8
    int cl;                                // _cfa_ffffffd4
    int ll;                                // _cfa_ffffffd0
    int r;                                 // _cfa_ffffffcc
    int l;                                 // _cfa_ffffffc8
    char* p;                               // _cfa_ffffffc4
    signed short _v62;                     // _cfa_ffffffc2
    signed int _v64;                       // _cfa_ffffffc0
    int _v80;                              // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    signed int _t171;                      // _t171
    char* _t211;                           // _t211

    s = 0;
    sl = 0;
    if(displayLink == 0) {
L20:
        if(use_mouse == 0 ||  *135792260 == 0) {
            msg = Strnew();
        } else {
            msg = Strnew_charp( *135792260);
        }
        if(displayLineInfo == 0 || buf->currentLine == 0 || buf->lastLine == 0) {
            Strcat_charp(msg, "Viewing");
        } else {
            cl = buf->currentLine->real_linenumber;
            ll = buf->lastLine->real_linenumber;
            asm("fild dword [ebp-0x28]");
            asm("fld qword [0x80cad58]");
            asm("fmulp st1, st0");
            if(ll == 0) {
                asm("fld1 ");
            } else {
                asm("fild dword [ebp-0x2c]");
            }
            asm("fdivp st1, st0");
            asm("fld qword [0x80cad60]");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp-0x3a]");
            _v64 = _v62 & 0xffff;
            asm("fldcw word [ebp-0x3c]");
            asm("fistp dword [ebp-0x30]");
            asm("fldcw word [ebp-0x3a]");
            _v80 = r;
            _v84 = ll;
            _v88 = cl;
            Strcat(msg, Sprintf("%d/%d (%d%%)"));
        }
        Strcat_charp(msg, " <");
        Strcat_charp(msg, buf->buffername);
        if(s == 0) {
            Strcat_charp(msg, ">");
        } else {
            l = COLS - 3 - sl;
            if(wtf_strwidth(msg->ptr) <= l) {
L44:
                Strcat_charp(msg, "> ");
                Strcat(msg, s);
                goto L46;
            }
            p = msg->ptr;
            while(( *p & 0xff) != 0) {
                if(( *135119023 & 0xff) == 0) {
                    _t171 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
                } else {
                    _t171 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
                }
                l = l - _t171;
                if(l < 0) {
                    p =  &(p[ *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff]);
                    continue;
                }
L43:
                l = p - msg->ptr;
                Strtruncate(msg, l);
                goto L44;
            }
            goto L43;
        }
L46:
        return msg;
    }
    a = retrieveCurrentMapArea(buf);
    if(a == 0) {
        a = retrieveCurrentAnchor(buf);
        p = 0;
        if(a == 0 || a->title == 0) {
L7:
            a_img = retrieveCurrentImg(buf);
            if(a_img != 0 && a_img->title != 0) {
                if((a_img & 0xff) != 0) {
                    p = a_img->title;
                }
            }
            goto L11;
        } else {
            if((a & 0xff) == 0) {
                goto L7;
            } else {
                p = a->title;
            }
L11:
            if(p != 0 || a != 0) {
                if(a == 0) {
                    _t211 = 0;
                } else {
                    _t211 = a->url;
                }
                s = make_lastline_link(buf, p, _t211);
            }
            goto L17;
        }
    } else {
        s = make_lastline_link(buf, a->alt, a->url);
    }
L17:
    if(s != 0) {
        sl = wtf_strwidth(s->ptr);
        if(COLS - 3 > sl) {
            goto L20;
        } else {
            return s;
        }
    }
    goto L20;
}

displayBuffer(Buffer* buf, int mode)
{// addr = 0x08074C9B  --  defined in 'display.c' at line 367
    Str msg;               // _cfa_fffffff0
    int ny;                                // _cfa_ffffffec
    long int _v32;                         // _cfa_ffffffe0
    signed short _v34;                     // _cfa_ffffffde
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char _t189;                            // _t189
    _unknown_ _t190;                       // _t190
    _unknown_ _t197;                       // _t197
    _unknown_ _t198;                       // _t198
    _unknown_ _t212;                       // _t212
    char _t306;                            // _t306
    _unknown_ _t307;                       // _t307
    int _t316;                             // _t316
    _unknown_ _t317;                       // _t317
    signed int _t322;                      // _t322
    int _t341;                             // _t341
    _unknown_ _t342;                       // _t342

    ny = 0;
    if(buf != 0) {
        if(buf->topLine == 0) {
            if(readBufferCache(buf) == 0) {
                mode = 1;
            }
        }
        if((buf->width & 0xffff) == 0) {
            _t341 = COLS;
            if(showLineNum == 0) {
                _t306 = 1;
            } else {
                _t306 = 6;
            }
            _t307 = _t341 - _t306;
            _t308 = _t307 >= 0 ? 0 : _t307;
            _t343 = _t307 >= 0 ? 0 : _t307;
            buf->width = (_t307 >= 0 ? 0 : _t307) & 65535;
        }
        if((buf->height & 0xffff) == 0) {
            buf->height = LINES & 65535;
        }
        _t322 = buf->width & 0xffff;
        _t316 = COLS;
        if(showLineNum == 0) {
            _t189 = 1;
        } else {
            _t189 = 6;
        }
        _t190 = _t316 - _t189;
        _t191 = _t190 >= 0 ? 0 : _t190;
        _t353 = _t322 - (_t190 >= 0 ? 0 : _t190);
        if(_t322 == (_t190 >= 0 ? 0 : _t190) || is_html_type(buf->type) == 0 && FoldLine == 0) {
            if((buf->need_reshape & 0xff) == 0) {
L19:
                if(showLineNum == 0) {
                    buf->rootX = 0;
                } else {
                    if(buf->lastLine != 0 && buf->lastLine->real_linenumber > 0) {
                        _v32 = buf->lastLine->real_linenumber;
                        asm("fild dword [ebp-0x1c]");
                        asm("fld qword [0x80cad68]");
                        asm("faddp st1, st0");
                        asm("fstp qword [esp]");
                        log();
                        asm("fld qword [0x80cad70]");
                        asm("fdivp st1, st0");
                        asm("fnstcw word [ebp-0x1e]");
                        _v36 = _v34 & 0xffff;
                        asm("fldcw word [ebp-0x20]");
                        asm("fistp dword [ebp-0x1c]");
                        asm("fldcw word [ebp-0x1e]");
                        buf->rootX = _v32 + 2 & 65535;
                    }
                    if((buf->rootX & 0xffff) <= 4) {
                        buf->rootX = 5;
                    }
                    if((buf->rootX & 0xffff) > COLS) {
                        buf->rootX = COLS & 65535;
                    }
                }
                buf->COLS = COLS & 65535;
                if(nTab > 1 || mouse_action.menu_str != 0) {
                    if(mode == 1 || mode == 4) {
                        calcTabPos();
                    }
                    asm("cwde ");
                    ny = (LastTab->y & 65535) + 2;
                    if(LINES - 1 < ny) {
                        ny = LINES - 1;
                    }
                }
                asm("cwde ");
                if((buf->rootY & 65535) != ny || (buf->LINES & 0xffff) != LINES - 1 - ny) {
                    buf->rootY = ny & 65535;
                    buf->LINES = LINES - 1 & 65535;
                    arrangeCursor(buf);
                    mode = 4;
                }
                if(mode == 1 || mode == 3 || mode == 4 || buf->topLine != cline || buf->currentColumn != ccolumn) {
                    if(activeImage != 0 && (mode == 4 || buf->topLine != cline || buf->currentColumn != ccolumn)) {
                        if(draw_image_flag != 0) {
                            clear();
                        }
                        clearImage();
                        loadImage(buf, 1);
                        image_touch = image_touch + 1;
                        draw_image_flag = 0;
                    }
                    redrawNLine(buf, LINES - 1);
                    cline = buf->topLine;
                    ccolumn = buf->currentColumn;
                }
                if(buf->topLine == 0) {
                    buf->topLine = buf->firstLine;
                }
                if((buf->need_reshape & 0xff) == 0) {
                    drawAnchorCursor(buf);
                    msg = make_lastline_message(buf);
                    if(buf->firstLine == 0) {
                        Strcat_charp(msg, "\tNo Line");
                    }
                    if(delayed_msg != 0) {
                        disp_message(delayed_msg, 0);
                        delayed_msg = 0;
                        refresh();
                    }
                    standout();
                    asm("cwde ");
                    asm("cwde ");
                    message(msg->ptr, (buf->cursorX & 0xffff) + (buf->rootX & 65535), (buf->cursorY & 0xffff) + (buf->rootY & 65535));
                    standend();
                    term_title( *(wc_Str_conv_strict(Strnew_charp(buf->buffername), InnerCharset, SystemCharset)));
                    refresh();
                    if(activeImage == 0 || displayImage == 0 || buf->img == 0) {
                        goto L64;
                    } else {
                        drawImage();
                        return;
                    }
                }
                displayBuffer(buf, 1);
                return;
            }
        }
        buf->need_reshape = 1;
        reshapeBuffer(buf);
        goto L19;
    }
L64:
    return;
}

drawAnchorCursor0(Buffer* buf, AnchorList* al, int hseq, int prevhseq, int tline, int eline, int active)
{// addr = 0x08075138  --  defined in 'display.c' at line 503
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    Line* l;              // _cfa_ffffffe8
    Anchor* an;         // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t141;                       // _t141
    _unknown_ _t169;                       // _t169

    l = buf->topLine;
    j = 0;
    while(al->nanchor > j) {
        an = al->anchors + (j << 2 << 4) - (j << 2);
        if( *((intOrPtr*)(an + 20)) < tline) {
L24:
            j = j + 1;
            continue;
        }
        if( *((intOrPtr*)(an + 20)) >= eline) {
            return;
        }
L3:
        while(l != 0) {
L4:
            if(l->linenumber !=  *((intOrPtr*)(an + 20))) {
                l = l->next;
                goto L3;
            }
            if(hseq >= 0) {
                if(an->hseq != hseq) {
                    goto L18;
                } else {
                    i =  *(an + 24);
                }
                while( *(an + 36) > i) {
                    if(( *(l->propBuf + i + i) & 0x70) != 0) {
                        if(active == 0) {
                             *(l->propBuf + i + i) =  *(l->propBuf + i + i) & 0xffff;
                        } else {
                             *(l->propBuf + i + i) =  *(l->propBuf + i + i) & 0xffff;
                        }
                    }
                    i = i + 1;
                }
                if(active != 0) {
                    redrawLineRegion(buf, l, l->linenumber - tline + (buf->rootY & 0xffff),  *(an + 24),  *(an + 36));
                }
                goto L24;
            } else {
            }
L18:
            if(prevhseq < 0 && an->hseq == prevhseq && active != 0) {
                redrawLineRegion(buf, l, l->linenumber - tline + (buf->rootY & 0xffff),  *(an + 24),  *(an + 36));
            }
            goto L24;
        }
        return;
    }
    return;
}

drawAnchorCursor(Buffer* buf)
{// addr = 0x0807531B  --  defined in 'display.c' at line 545
    Anchor* an;         // _cfa_fffffff0
    int hseq;                              // _cfa_ffffffec
    int prevhseq;                          // _cfa_ffffffe8
    int tline;                             // _cfa_ffffffe4
    int eline;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6

    if(buf->firstLine == 0) {
        return;
    }
    if(buf->hmarklist == 0) {
        goto L15;
    }
    if(buf->href != 0 || buf->formitem != 0) {
        an = retrieveCurrentAnchor(buf);
        if(an == 0) {
            an = retrieveCurrentMap(buf);
        }
        if(an == 0) {
            hseq = -1;
        } else {
            hseq = an->hseq;
        }
        tline = buf->topLine->linenumber;
        asm("cwde ");
        eline = (buf->LINES & 65535) + tline;
        prevhseq = buf->hmarklist->prevhseq;
        if(buf->href != 0) {
            drawAnchorCursor0(buf, buf->href, hseq, prevhseq, tline, eline, 1);
            drawAnchorCursor0(buf, buf->href, hseq, -1, tline, eline, 0);
        }
        if(buf->formitem != 0) {
            drawAnchorCursor0(buf, buf->formitem, hseq, prevhseq, tline, eline, 1);
            drawAnchorCursor0(buf, buf->formitem, hseq, -1, tline, eline, 0);
        }
        buf->hmarklist->prevhseq = hseq;
        return;
    }
    return;
L15:
    return;
}

redrawNLine(Buffer* buf, int n)
{// addr = 0x080754C6  --  defined in 'display.c' at line 579
    Line* l;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    TabBuffer* t;    // _cfa_ffffffe8
    int l;                                 // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t222;                       // _t222

    if(useColor != 0) {
        setfcolor(basic_color);
        setbcolor(bg_color);
    }
    if(nTab > 1 || mouse_action.menu_str != 0) {
        move(0, 0);
        if(mouse_action.menu_str != 0) {
            addstr(mouse_action.menu_str);
        }
        clrtoeolx();
        t = FirstTab;
        while(t != 0) {
            asm("cwde ");
            move(t->y & 65535, t->x1 & 0xffff);
            if(t == CurrentTab) {
                bold();
            }
            addch(91);
            asm("cwde ");
            l = (t->x2 & 0xffff) - (t->x1 & 65535) - 1 - wtf_strwidth( *(t->currentBuffer + 4));
            if(l < 0) {
                l = 0;
            }
            if(l > 1) {
                addnstr_sup(" ", (l >> 31) + l >> 1);
            }
            if(t == CurrentTab) {
                effect_active_start();
            }
            asm("cwde ");
            addnstr( *(t->currentBuffer + 4), (t->x2 & 0xffff) - (t->x1 & 65535) - l);
            if(t == CurrentTab) {
                effect_active_end();
            }
            if(l + 1 > 1) {
                addnstr_sup(" ", (l + 1 >> 31) + l + 1 >> 1);
            }
            asm("cwde ");
            move(t->y & 65535, t->x2 & 0xffff);
            addch(93);
            if(t == CurrentTab) {
                boldend();
            }
            t = t->nextTab;
        }
        asm("cwde ");
        move((LastTab->y & 65535) + 1, 0);
        i = 0;
        while(i < COLS) {
            addch(126);
            i = i + 1;
        }
    }
    i = 0;
    l = buf->topLine;
    while(1) {
        asm("cwde ");
        if((buf->LINES & 65535) <= i) {
            break;
        }
        asm("cwde ");
        if((buf->LINES & 65535) - n <= i ||  ~n > i) {
            asm("cwde ");
            l = redrawLine(buf, l, (buf->rootY & 65535) + i);
        }
        if(l != 0) {
            i = i + 1;
            l = l->next;
            continue;
        }
L35:
        if(n > 0) {
            asm("cwde ");
            move((buf->rootY & 65535) + i, 0);
            clrtobotx();
        }
        if(activeImage == 0) {
            return;
        } else {
            if(displayImage == 0) {
                goto L49;
            }
            if(buf->img == 0) {
                goto L50;
            }
            asm("cwde ");
            asm("cwde ");
            move((buf->cursorY & 0xffff) + (buf->rootY & 65535), (buf->cursorX & 0xffff) + (buf->rootX & 65535));
            i = 0;
            l = buf->topLine;
            while(1) {
                asm("cwde ");
                if((buf->LINES & 65535) <= i || l == 0) {
                    break;
                }
                asm("cwde ");
                if((buf->LINES & 65535) - n <= i ||  ~n > i) {
                    asm("cwde ");
                    redrawLineImage(buf, l, (buf->rootY & 65535) + i);
                }
                i = i + 1;
                l = l->next;
            }
            getAllImage(buf);
            return;
L50:
            return;
        }
L49:
        return;
    }
    goto L35;
}

Line* redrawLine(Buffer* buf, Line* l, int i)
{// addr = 0x08075864  --  defined in 'display.c' at line 660
    intOrPtr _v16;                         // _cfa_fffffff0
    char[15] tmp;                          // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int pos;                               // _cfa_ffffffd8
    int rcol;                              // _cfa_ffffffd4
    int ncol;                              // _cfa_ffffffd0
    int delta;                             // _cfa_ffffffcc
    int column;                            // _cfa_ffffffc8
    char* p;                               // _cfa_ffffffc4
    Lineprop* pr;     // _cfa_ffffffc0
    Linecolor* pc;   // _cfa_ffffffbc
    Anchor* a;          // _cfa_ffffffb8
    int k;                                 // _cfa_ffffffb4
    int vpos;                              // _cfa_ffffffb0
    ParsedURL url;   // _cfa_ffffff88
    Buffer* _v128;      // _cfa_ffffff80
    Line* _v132;          // _cfa_ffffff7c
    _unknown_ _v136;                       // _cfa_ffffff78
    _unknown_ _v138;                       // _cfa_ffffff76
    _unknown_ _v140;                       // _cfa_ffffff74
    _unknown_ _v152;                       // _cfa_ffffff68
    _unknown_ _v156;                       // _cfa_ffffff64
    long int _v160;                        // _cfa_ffffff60
    intOrPtr _v164;                        // _cfa_ffffff5c
    _unknown_ _v168;                       // _cfa_ffffff58
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t284;                       // _t284
    Line* _t296;          // _t296
    _unknown_ _t418;                       // _t418
    _unknown_ _t427;                       // _t427
    _unknown_ _t437;                       // _t437
    _unknown_ _t438;                       // _t438
    _unknown_ _t478;                       // _t478
    Line* _t520;          // _t520

    _v128 = _a4;
    _v132 = _a8;
    _v16 =  *gs:0x14];
    delta = 1;
    column = _v128->currentColumn;
    vpos = -1;
    if(_v132 != 0) {
L5:
        move(i, 0);
        if(showLineNum != 0) {
            if((_v128->rootX & 0xffff) == 0) {
                if((_v128->rootX & 0xffff) <= 4) {
                    _v128->rootX = 5;
                }
                if((_v128->rootX & 0xffff) > COLS) {
                    _v128->rootX = COLS & 65535;
                }
                _v128->COLS = COLS & 65535;
            }
            if(_v132->real_linenumber == 0 || _v132->bpos != 0) {
                asm("cwde ");
                _v160 = 135048306;
                _v164 = (_v128->rootX & 65535) - 1;
                sprintf( &tmp, "%*s ");
            } else {
                asm("cwde ");
                _v160 = _v132->real_linenumber;
                _v164 = (_v128->rootX & 65535) - 1;
                sprintf( &tmp, "%*ld:");
            }
            addstr( &tmp);
        }
        asm("cwde ");
        move(i, _v128->rootX & 65535);
        if(_v132->width < 0) {
            _v132->width = calcPosition( *_v132, _v132->propBuf, _v132->len, _v132->len, 0, 0);
        }
        if(_v132->len == 0 || _v132->width - 1 < column) {
            clrtoeolx();
            _t296 = _v132;
L85:
            if(_t520 == 0) {
                return _t296;
            }
L86:
            __stack_chk_fail();
            return _t296;
        }
        pos = columnPos(_v132, column);
        p =  *_v132 + pos;
        pr = _v132->propBuf + pos + pos;
        if(useColor == 0 || _v132->colorBuf == 0) {
            pc = 0;
        } else {
            pc = _v132->colorBuf + pos;
        }
        rcol = calcPosition( *_v132, _v132->propBuf, _v132->len, pos, 0, 0);
        j = 0;
        while(1) {
            asm("cwde ");
            if(rcol - column >= (_v128->COLS & 65535)) {
                break;
            }
            if(pos + j < _v132->len) {
                if(useVisitedColor == 0 || pos + j < vpos || ( *(j + j + pr) & 0x4000) != 0) {
L38:
                    delta = wtf_len( &(p[j]));
                    ncol = calcPosition( *_v132, _v132->propBuf, _v132->len, pos + j + delta, 0, 0);
                    asm("cwde ");
                    if(ncol - column > (_v128->COLS & 65535)) {
                        break;
                    }
                } else {
                    a = retrieveAnchor(_v128->href, _v132->linenumber, pos + j);
                    if(a == 0) {
                        goto L38;
                    }
                    parseURL2(a->url,  &(url.scheme), baseURL(_v128));
                    if(getHashHist(URLHist,  *(parsedURL2Str( &(url.scheme)))) == 0) {
L37:
                        vpos =  *(a + 36);
                        goto L38;
                    }
                    k =  *(a + 24);
                    while( *(a + 36) > k) {
                         *(k - pos + k - pos + pr) =  *(k - pos + k - pos + pr) & 0xffff;
                        k = k + 1;
                    }
                    goto L37;
                }
                if(pc != 0) {
                    do_color( *(pc + j) & 0xff);
                }
                if(rcol >= column) {
                    if((p[j] & 0xff) != 9) {
                        addMChar( &(p[j]),  *(j + j + pr) & 0xffff, delta);
                        goto L52;
                    }
                    goto L47;
L52:
                    rcol = ncol;
                    goto L53;
                } else {
                    rcol = column;
                    while(rcol < ncol) {
                        addChar(32, 0);
                        rcol = rcol + 1;
                    }
L53:
                    j = j + delta;
                    continue;
                }
L47:
                while(rcol < ncol) {
                    addChar(32, 0);
                    rcol = rcol + 1;
                }
                goto L52;
            }
            break;
        }
        if(somode != 0) {
            somode = 0;
            standend();
        }
        if(ulmode != 0) {
            ulmode = 0;
            underlineend();
        }
        if(bomode != 0) {
            bomode = 0;
            boldend();
        }
        if(emph_mode != 0) {
            emph_mode = 0;
            boldend();
        }
        if(anch_mode != 0) {
            anch_mode = 0;
            effect_anchor_end();
        }
        if(imag_mode != 0) {
            imag_mode = 0;
            effect_image_end();
        }
        if(form_mode != 0) {
            form_mode = 0;
            effect_form_end();
        }
        if(visited_mode != 0) {
            visited_mode = 0;
            effect_visited_end();
        }
        if(active_mode != 0) {
            active_mode = 0;
            effect_active_end();
        }
        if(mark_mode != 0) {
            mark_mode = 0;
            effect_mark_end();
        }
        if(graph_mode != 0) {
            graph_mode = 0;
            graphend();
        }
        if((color_mode & 0xff) != 0) {
            do_color(0);
        }
        asm("cwde ");
        if(rcol - column < (_v128->COLS & 65535)) {
            clrtoeolx();
        }
        _t296 = _v132;
        goto L85;
    }
    if( *((intOrPtr*)(_v128 + 92)) == 0) {
        _t296 = 0;
        goto L85;
    }
    asm("cwde ");
    _v132 = getNextPage(_v128, (_v128->LINES & 0xffff) + (_v128->rootY & 65535) - i);
    _t520 = _v132;
    if(_t520 != 0) {
        goto L5;
    } else {
        _t296 = 0;
    }
    goto L85;
}

Line* redrawLineImage(Buffer* buf, Line* l, int i)
{// addr = 0x08075F31  --  defined in 'display.c' at line 820
    int j;                                 // _cfa_fffffff0
    int pos;                               // _cfa_ffffffec
    int rcol;                              // _cfa_ffffffe8
    int column;                            // _cfa_ffffffe4
    Anchor* a;          // _cfa_ffffffe0
    int x;                                 // _cfa_ffffffdc
    int y;                                 // _cfa_ffffffd8
    int sx;                                // _cfa_ffffffd4
    int sy;                                // _cfa_ffffffd0
    int w;                                 // _cfa_ffffffcc
    int h;                                 // _cfa_ffffffc8
    Image* image;        // _cfa_ffffffc4
    ImageCache* cache;   // _cfa_ffffffc0
    intOrPtr _v80;                         // _cfa_ffffffb0
    signed int _v82;                       // _cfa_ffffffae
    signed int _v84;                       // _cfa_ffffffac
    _unknown_ _v100;                       // _cfa_ffffff9c
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ _v108;                       // _cfa_ffffff94
    _unknown_ _v112;                       // _cfa_ffffff90
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t409;                       // _t409

    column = buf->currentColumn;
    if(l == 0) {
        return 0;
    }
    if(l->width < 0) {
        l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
    }
    if(l->len == 0) {
L6:
        return l;
    }
    if(l->width - 1 >= column) {
        pos = columnPos(l, column);
        rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos, 0, 0);
        j = 0;
        while(1) {
            asm("cwde ");
            if(rcol - column >= (buf->COLS & 65535) || pos + j >= l->len) {
                break;
            }
            if(rcol - column >= 0) {
                a = retrieveAnchor(buf->img, l->linenumber, pos + j);
                if(a == 0 || a->image == 0 || a->image->touch >= image_touch) {
L38:
                    rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos + j + 1, 0, 0);
                } else {
                    image = a->image;
                    image->cache = getImage(image, baseURL(buf), buf->image_flag & 0xff);
                    cache = image->cache;
                    if(cache == 0) {
                        goto L38;
                    }
                    if((image->width & 0xffff) >= 0 || (cache->width & 0xffff) <= 0) {
                        if((image->height & 0xffff) >= 0 || (cache->height & 0xffff) <= 0) {
L19:
                            asm("cwde ");
                            _v80 = rcol - column + (buf->rootX & 65535);
                            asm("fild dword [ebp-0x4c]");
                            asm("fld qword [0x80d53a0]");
                            asm("fmulp st1, st0");
                            asm("fnstcw word [ebp-0x4e]");
                            _v84 = _v82 & 0xffff;
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x20]");
                            asm("fldcw word [ebp-0x4e]");
                            asm("fild dword [ebp+0x10]");
                            asm("fld qword [0x80d53a8]");
                            asm("fmulp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x24]");
                            asm("fldcw word [ebp-0x4e]");
                            _v80 = rcol - calcPosition(l->lineBuf, l->propBuf, l->len,  *(a + 24), 0, 0);
                            asm("fild dword [ebp-0x4c]");
                            asm("fld qword [0x80d53a0]");
                            asm("fmulp st1, st0");
                            asm("fnstcw word [ebp-0x4e]");
                            _v84 = _v82 & 0xffff;
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x28]");
                            asm("fldcw word [ebp-0x4e]");
                            asm("cwde ");
                            _v80 = l->linenumber - (image->y & 65535);
                            asm("fild dword [ebp-0x4c]");
                            asm("fld qword [0x80d53a8]");
                            asm("fmulp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x2c]");
                            asm("fldcw word [ebp-0x4e]");
                            if(sx != 0) {
L22:
                                asm("cwde ");
                                sx = sx - (image->xoffset & 65535);
                                goto L23;
                            }
                            goto L20;
L23:
                            if(sy != 0) {
L26:
                                asm("cwde ");
                                sy = sy - (image->yoffset & 65535);
                                goto L27;
                            }
                            asm("cwde ");
                            if((image->yoffset & 65535) + y >= 0) {
                                goto L26;
                            }
                            asm("cwde ");
                            y = y + (image->yoffset & 65535);
L27:
                            if((image->width & 0xffff) <= 0) {
                                asm("fld qword [0x80d53a0]");
                                asm("fld qword [0x80cad78]");
                                asm("fmulp st1, st0");
                                asm("fild dword [ebp-0x28]");
                                asm("fsubp st1, st0");
                                asm("fldcw word [ebp-0x50]");
                                asm("fistp dword [ebp-0x30]");
                                asm("fldcw word [ebp-0x4e]");
                            } else {
                                asm("cwde ");
                                w = (image->width & 65535) - sx;
                            }
                            if((image->height & 0xffff) <= 0) {
                                asm("fld qword [0x80d53a8]");
                                asm("fild dword [ebp-0x2c]");
                                asm("fsubp st1, st0");
                                asm("fldcw word [ebp-0x50]");
                                asm("fistp dword [ebp-0x34]");
                                asm("fldcw word [ebp-0x4e]");
                            } else {
                                asm("cwde ");
                                h = (image->height & 65535) - sy;
                            }
                            asm("cwde ");
                            _v80 = (buf->rootX & 0xffff) + (buf->COLS & 65535);
                            asm("fild dword [ebp-0x4c]");
                            asm("fld qword [0x80d53a0]");
                            asm("fmulp st1, st0");
                            asm("fild dword [ebp-0x20]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x4c]");
                            asm("fldcw word [ebp-0x4e]");
                            if(_v80 < w) {
                                asm("cwde ");
                                _v80 = (buf->rootX & 0xffff) + (buf->COLS & 65535);
                                asm("fild dword [ebp-0x4c]");
                                asm("fld qword [0x80d53a0]");
                                asm("fmulp st1, st0");
                                asm("fild dword [ebp-0x20]");
                                asm("fsubp st1, st0");
                                asm("fldcw word [ebp-0x50]");
                                asm("fistp dword [ebp-0x30]");
                                asm("fldcw word [ebp-0x4e]");
                            }
                            _v80 = LINES - 1;
                            asm("fild dword [ebp-0x4c]");
                            asm("fld qword [0x80d53a8]");
                            asm("fmulp st1, st0");
                            asm("fild dword [ebp-0x24]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x4c]");
                            asm("fldcw word [ebp-0x4e]");
                            if(_v80 < h) {
                                _v80 = LINES - 1;
                                asm("fild dword [ebp-0x4c]");
                                asm("fld qword [0x80d53a8]");
                                asm("fmulp st1, st0");
                                asm("fild dword [ebp-0x24]");
                                asm("fsubp st1, st0");
                                asm("fldcw word [ebp-0x50]");
                                asm("fistp dword [ebp-0x34]");
                                asm("fldcw word [ebp-0x4e]");
                            }
                            addImage(cache, x, y, sx, sy, w, h);
                            image->touch = image_touch;
                            draw_image_flag = 1;
                            goto L38;
                        } else {
                            goto L18;
                        }
L20:
                        asm("cwde ");
                        if((image->xoffset & 65535) + x >= 0) {
                            goto L22;
                        }
                        asm("cwde ");
                        x = x + (image->xoffset & 65535);
                        goto L23;
                    }
L18:
                    image->width = cache->width & 0xffff;
                    image->height = cache->height & 0xffff;
                    buf->need_reshape = 1;
                    goto L19;
                }
L39:
                j = j + 1;
                continue;
            }
            rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos + j + 1, 0, 0);
            goto L39;
        }
        return l;
    }
    goto L6;
}

int redrawLineRegion(Buffer* buf, Line* l, int i, int bpos, int epos)
{// addr = 0x0807648A  --  defined in 'display.c' at line 890
    int j;                                 // _cfa_fffffff0
    int pos;                               // _cfa_ffffffec
    int rcol;                              // _cfa_ffffffe8
    int ncol;                              // _cfa_ffffffe4
    int delta;                             // _cfa_ffffffe0
    int column;                            // _cfa_ffffffdc
    char* p;                               // _cfa_ffffffd8
    Lineprop* pr;     // _cfa_ffffffd4
    Linecolor* pc;   // _cfa_ffffffd0
    int bcol;                              // _cfa_ffffffcc
    int ecol;                              // _cfa_ffffffc8
    Anchor* a;          // _cfa_ffffffc4
    int k;                                 // _cfa_ffffffc0
    int vpos;                              // _cfa_ffffffbc
    ParsedURL url;   // _cfa_ffffff94
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ _v124;                       // _cfa_ffffff84
    _unknown_ _v128;                       // _cfa_ffffff80
    _unknown_ _v132;                       // _cfa_ffffff7c
    _unknown_ _v136;                       // _cfa_ffffff78
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t301;                       // _t301

    delta = 1;
    column = buf->currentColumn;
    vpos = -1;
    if(l == 0) {
        return 0;
    }
    pos = columnPos(l, column);
    p = l->lineBuf + pos;
    pr = l->propBuf + pos + pos;
    if(useColor == 0 || l->colorBuf == 0) {
        pc = 0;
    } else {
        pc = l->colorBuf + pos;
    }
    rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos, 0, 0);
    bcol = bpos - pos;
    ecol = epos - pos;
    j = 0;
    while(1) {
        asm("cwde ");
        if(rcol - column >= (buf->COLS & 65535)) {
            break;
        }
        if(pos + j < l->len) {
            if(useVisitedColor == 0 || pos + j < vpos || ( *(j + j + pr) & 0x4000) != 0) {
L16:
                delta = wtf_len( &(p[j]));
                ncol = calcPosition(l->lineBuf, l->propBuf, l->len, pos + j + delta, 0, 0);
                asm("cwde ");
                if(ncol - column > (buf->COLS & 65535)) {
                    break;
                }
            } else {
                a = retrieveAnchor(buf->href, l->linenumber, pos + j);
                if(a == 0) {
                    goto L16;
                }
                parseURL2(a->url,  &(url.scheme), baseURL(buf));
                if(getHashHist(URLHist,  *(parsedURL2Str( &(url.scheme)))) == 0) {
L15:
                    vpos =  *(a + 36);
                    goto L16;
                }
                k =  *(a + 24);
                while( *(a + 36) > k) {
                     *(k - pos + k - pos + pr) =  *(k - pos + k - pos + pr) & 0xffff;
                    k = k + 1;
                }
                goto L15;
            }
            if(pc != 0) {
                do_color( *(pc + j) & 0xff);
            }
            if(j < bcol || j >= ecol) {
L32:
                rcol = ncol;
            } else {
                if(rcol >= column) {
                    asm("cwde ");
                    move(i, rcol - column + (buf->rootX & 65535));
                    if((p[j] & 0xff) != 9) {
                        addMChar( &(p[j]),  *(j + j + pr) & 0xffff, delta);
                        goto L32;
                    }
                    goto L27;
                }
                asm("cwde ");
                move(i, buf->rootX & 65535);
                rcol = column;
                while(rcol < ncol) {
                    addChar(32, 0);
                    rcol = rcol + 1;
                }
                goto L33;
L27:
                while(rcol < ncol) {
                    addChar(32, 0);
                    rcol = rcol + 1;
                }
                goto L32;
            }
L33:
            j = j + delta;
            continue;
        }
        break;
    }
    if(somode != 0) {
        somode = 0;
        standend();
    }
    if(ulmode != 0) {
        ulmode = 0;
        underlineend();
    }
    if(bomode != 0) {
        bomode = 0;
        boldend();
    }
    if(emph_mode != 0) {
        emph_mode = 0;
        boldend();
    }
    if(anch_mode != 0) {
        anch_mode = 0;
        effect_anchor_end();
    }
    if(imag_mode != 0) {
        imag_mode = 0;
        effect_image_end();
    }
    if(form_mode != 0) {
        form_mode = 0;
        effect_form_end();
    }
    if(visited_mode != 0) {
        visited_mode = 0;
        effect_visited_end();
    }
    if(active_mode != 0) {
        active_mode = 0;
        effect_active_end();
    }
    if(mark_mode != 0) {
        mark_mode = 0;
        effect_mark_end();
    }
    if(graph_mode != 0) {
        graph_mode = 0;
        graphend();
    }
    if((color_mode & 0xff) != 0) {
        do_color(0);
    }
    return rcol - column;
}

do_effects(Lineprop m)
{// addr = 0x08076954  --  defined in 'display.c' at line 1033
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    _v16 = _a4 & 65535;
    if(ulmode != 0) {
        underlineend();
        ulmode = 0;
    }
    if(somode != 0) {
        standend();
        somode = 0;
    }
    if(bomode != 0) {
        boldend();
        bomode = 0;
    }
    if(emph_mode != 0) {
        boldend();
        emph_mode = 0;
    }
    if(anch_mode != 0) {
        effect_anchor_end();
        anch_mode = 0;
    }
    if(imag_mode != 0) {
        effect_image_end();
        imag_mode = 0;
    }
    if(form_mode != 0) {
        effect_form_end();
        form_mode = 0;
    }
    if(visited_mode != 0) {
        effect_visited_end();
        visited_mode = 0;
    }
    if(active_mode != 0) {
        effect_active_end();
        active_mode = 0;
    }
    if(mark_mode != 0) {
        effect_mark_end();
        mark_mode = 0;
    }
    if(graph_mode != 0) {
        graphend();
        graph_mode = 0;
    }
    if((_v16 & 2) != 0 && ulmode == 0) {
        underline();
        ulmode = 1;
    }
    if((_v16 & 4) != 0 && somode == 0) {
        standout();
        somode = 1;
    }
    if((_v16 & 8) != 0 && bomode == 0) {
        bold();
        bomode = 1;
    }
    if((_v16 & 8) != 0 && emph_mode == 0) {
        bold();
        emph_mode = 1;
    }
    if((_v16 & 0x10) != 0 && anch_mode == 0) {
        effect_anchor_start();
        anch_mode = 1;
    }
    if((_v16 & 0x20) != 0 && imag_mode == 0) {
        effect_image_start();
        imag_mode = 1;
    }
    if((_v16 & 0x40) != 0 && form_mode == 0) {
        effect_form_start();
        form_mode = 1;
    }
    if((_v16 & 0x4000) != 0 && visited_mode == 0) {
        effect_visited_start();
        visited_mode = 1;
    }
    if((_v16 & 0x80) != 0 && active_mode == 0) {
        effect_active_start();
        active_mode = 1;
    }
    if((_v16 & 1) == 0 || mark_mode != 0) {
        return;
    } else {
        effect_mark_start();
        mark_mode = 1;
        return;
    }
}

do_color(Linecolor c)
{// addr = 0x08076BCD  --  defined in 'display.c' at line 1068
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    _v16 = _a4 & 255;
    if((_v16 & 8) == 0) {
        if((color_mode & 8) != 0) {
            setfcolor(basic_color);
        }
    } else {
        setfcolor(_v16 & 7);
    }
    if((_v16 & 0xff) >= 0) {
        if((color_mode & 0xff) < 0) {
            setbcolor(bg_color);
        }
    } else {
        setbcolor(_v16 & 7);
    }
    color_mode = _v16 & 0xff;
    return;
}

addChar(char c, Lineprop mode)
{// addr = 0x08076C55  --  defined in 'display.c' at line 1086
    char _v16;                             // _cfa_fffffff0
    signed short _v20;                     // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v16 = _a4 & 255;
    _v20 = _a8 & 65535;
    addMChar( &_v16, _v20 & 65535, 1);
    return;
}

addMChar(char* p, Lineprop mode, size_t len)
{// addr = 0x08076C85  --  defined in 'display.c' at line 1092
    char c;                                // _cfa_fffffff3
    Lineprop m;       // _cfa_fffffff0
    char** symbol;                         // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    char[4] buf;                           // _cfa_ffffffe3
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v68;                       // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t81;                        // _t81
    char _t83;                             // _t83
    int _t90;                              // _t90

    _v48 = _a8 & 65535;
    m = _v48 & 0xffff;
    c =  *p & 0xff;
    if((_v48 & 0x400) != 0) {
L29:
        return;
    }
    do_effects(m & 65535);
    if((_v48 & 0xffff) >= 0) {
L14:
        if((_v48 & 0x100) == 0) {
            if((_v48 & 0x1000) == 0) {
                addmch(p, len);
                return;
            }
            goto L27;
        }
        goto L15;
L27:
        _v68 = (wtf_get_code(p) | 128) & 0xff;
        sprintf( &buf, "[%.2X]");
        addstr( &buf);
        return;
    }
    if((_v48 & 0x800) == 0) {
        _t90 = 1;
    } else {
        _t90 = 2;
    }
    w = _t90;
    c = (wtf_get_code(p) & 127) - 32 & 255;
    if(graph_ok() == 0 || c > 31) {
L13:
        symbol = get_symbol(DisplayCharset,  &w);
        addstr(symbol[c]);
        return;
    } else {
        if(graph_mode == 0) {
            graphstart();
            graph_mode = 1;
        }
        if(w != 2 || ( *135119023 & 0xff) == 0) {
            addch( *( *( &graph_symbol + c * 4)) & 0xff);
            return;
        } else {
            addstr( *( &graph2_symbol + c * 4));
            return;
        }
        goto L13;
    }
    goto L14;
L15:
    _t83 = c;
    if(_t83 == 10) {
L23:
        addch(32);
        return;
    }
    if(_t83 > 10) {
        if(_t83 == 13) {
            goto L30;
        }
        goto L20;
    }
    if(_t83 == 9) {
        addch(c);
        return;
    }
L25:
    addch(94);
    addch((c & 255) + 64 & 255);
    return;
    goto L23;
L20:
    if(_t83 == 127) {
        goto L24;
    }
    goto L25;
L24:
    addstr("^?");
    return;
L30:
    return;
}

record_err_message(char* s)
{// addr = 0x08076E82  --  defined in 'display.c' at line 1176
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    if((fmInitialized & 0xff) != 0) {
        if(message_list == 0) {
            message_list = newGeneralList();
        }
        if((message_list->nitem & 0xffff) >= LINES) {
            popValue(message_list);
        }
        pushValue(message_list, allocStr(s, -1));
        return;
    }
    return;
}

Buffer* message_list_panel()
{// addr = 0x08076EEF  --  defined in 'display.c' at line 1191
    Str tmp;               // _cfa_fffffff0
    ListItem* p;      // _cfa_ffffffec
    intOrPtr _v44;                         // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    char* _t34;                            // _t34

    tmp = Strnew_size(COLS * LINES);
    Strcat_charp(tmp, "<html><head><title>List of error messages</title></head><body><h1>List of error messages</h1><table cellpadding=0>\n");
    if(message_list == 0) {
        Strcat_charp(tmp, "<tr><td>(no message recorded)</td></tr>\n");
    } else {
        p = message_list->last;
        while(p != 0) {
            _t34 = html_quote(p->ptr);
            _v44 = 0;
            _v48 = "</pre></td></tr>\n";
            _v52 = _t34;
            _v56 = "<tr><td><pre>";
            Strcat_m_charp(tmp);
            p = p->prev;
        }
    }
    Strcat_charp(tmp, "</table></body></html>");
    return loadHTMLString(tmp);
}

message(char* s, int return_x, int return_y)
{// addr = 0x08076FAF  --  defined in 'display.c' at line 1211
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if((fmInitialized & 0xff) != 0) {
        move(LINES - 1, 0);
        addnstr(s, COLS - 1);
        clrtoeolx();
        move(return_y, return_x);
        return;
    }
    return;
}

disp_err_message(char* s, int redraw_current)
{// addr = 0x0807700B  --  defined in 'display.c' at line 1222
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    record_err_message(s);
    disp_message(s, redraw_current);
    return;
}

disp_message_nsec(char* s, int redraw_current, int sec, int purge, int mouse)
{// addr = 0x08077030  --  defined in 'display.c' at line 1229
    struct _Str _v20;     // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t47;                        // _t47
    _unknown_ _t74;                        // _t74

    if((QuietMessage & 0xff) != 0) {
        goto L18;
    }
    if((fmInitialized & 0xff) == 0) {
        _v20 =  *(wc_Str_conv_strict(Strnew_charp(s), InnerCharset, SystemCharset));
        fprintf(__imp__stderr, "%s\n");
        return;
    }
    if(CurrentTab == 0) {
L6:
        message(s, LINES - 1, 0);
    } else {
        if(CurrentTab->currentBuffer == 0) {
            goto L6;
        } else {
            asm("cwde ");
            asm("cwde ");
            message(s, (CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535), (CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535));
        }
    }
    refresh();
    if(mouse != 0 && use_mouse != 0) {
        mouse_active();
    }
    sleep_till_anykey(sec, purge);
    if(mouse != 0 && use_mouse != 0) {
        mouse_inactive();
    }
    if(CurrentTab != 0 && CurrentTab->currentBuffer != 0 && redraw_current != 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
L18:
    return;
}

disp_message(char* s, int redraw_current)
{// addr = 0x0807719C  --  defined in 'display.c' at line 1257
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    disp_message_nsec(s, redraw_current, 10, 0, 1);
    return;
}

disp_message_nomouse(char* s, int redraw_current)
{// addr = 0x080771CE  --  defined in 'display.c' at line 1263
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    disp_message_nsec(s, redraw_current, 10, 0, 0);
    return;
}

set_delayed_message(char* s)
{// addr = 0x08077200  --  defined in 'display.c' at line 1270
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    delayed_msg = allocStr(s, -1);
    return;
}

cursorUp0(Buffer* buf, int n)
{// addr = 0x08077220  --  defined in 'display.c' at line 1276
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if((buf->cursorY & 0xffff) <= 0) {
        buf->topLine = lineSkip(buf, buf->topLine,  ~n, 0);
        if(buf->currentLine->prev != 0) {
            buf->currentLine = buf->currentLine->prev;
        }
        arrangeLine(buf);
        return;
    }
    cursorUpDown(buf, -1);
    return;
}

cursorUp(Buffer* buf, int n)
{// addr = 0x0807729E  --  defined in 'display.c' at line 1289
    Line* l;              // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    l = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    }
    while(buf->currentLine->prev != 0 && buf->currentLine->bpos != 0) {
        cursorUp0(buf, n);
    }
    if(buf->currentLine != buf->firstLine) {
        cursorUp0(buf, n);
L10:
        while(buf->currentLine->prev != 0 && buf->currentLine->bpos != 0 && buf->currentLine->bwidth >= buf->currentColumn + buf->visualpos) {
            goto L9;
        }
        return;
    }
    gotoLine(buf, l->linenumber);
    arrangeLine(buf);
    return;
L9:
    cursorUp0(buf, n);
    goto L10;
}

cursorDown0(Buffer* buf, int n)
{// addr = 0x0807737B  --  defined in 'display.c' at line 1308
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    if((buf->cursorY & 0xffff) >= (buf->LINES & 65535) - 1) {
        buf->topLine = lineSkip(buf, buf->topLine, n, 0);
        if(buf->currentLine->next != 0) {
            buf->currentLine = buf->currentLine->next;
        }
        arrangeLine(buf);
        return;
    }
    cursorUpDown(buf, 1);
    return;
}

cursorDown(Buffer* buf, int n)
{// addr = 0x08077402  --  defined in 'display.c' at line 1321
    Line* l;              // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    l = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    }
    while(buf->currentLine->next != 0 && buf->currentLine->next->bpos != 0) {
        cursorDown0(buf, n);
    }
    if(buf->currentLine != buf->lastLine) {
        cursorDown0(buf, n);
L10:
        while(buf->currentLine->next != 0 && buf->currentLine->next->bpos != 0 && buf->currentLine->bwidth + buf->currentLine->width < buf->currentColumn + buf->visualpos) {
            goto L9;
        }
        return;
    }
    gotoLine(buf, l->linenumber);
    arrangeLine(buf);
    return;
L9:
    cursorDown0(buf, n);
    goto L10;
}

cursorUpDown(Buffer* buf, int n)
{// addr = 0x080774F1  --  defined in 'display.c' at line 1341
    Line* cl;             // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    cl = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    }
    buf->currentLine = currentLineSkip(buf, cl, n, 0);
    if(buf->currentLine == cl) {
    } else {
        goto L2;
    }
    goto L4;
L2:
    arrangeLine(buf);
    return;
L4:
    return;
}

cursorRight(Buffer* buf, int n)
{// addr = 0x0807754F  --  defined in 'display.c' at line 1353
    int i;                                 // _cfa_fffffff0
    int delta;                             // _cfa_ffffffec
    int cpos;                              // _cfa_ffffffe8
    int vpos2;                             // _cfa_ffffffe4
    Line* l;              // _cfa_ffffffe0
    Lineprop* p;      // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t216;                       // _t216
    _unknown_ _t217;                       // _t217
    _unknown_ _t226;                       // _t226
    _unknown_ _t230;                       // _t230
    _unknown_ _t307;                       // _t307

    delta = 1;
    l = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    }
    if(buf->pos != l->len) {
L4:
        i = buf->pos;
        p = l->propBuf;
L6:
        while(i + delta < l->len) {
L7:
            if(( *(i + delta + i + delta + p) & 0x400) != 0) {
                delta = delta + 1;
                goto L6;
            }
            break;
        }
        if(i + delta >= l->len) {
            if(l->len != 0) {
                if(l->next == 0 || l->next->bpos == 0) {
                    buf->pos = l->len - 1;
L17:
                    while(buf->pos != 0 && ( *(buf->pos + buf->pos + p) & 0x400) != 0) {
                        goto L16;
                    }
                    goto L19;
                } else {
                    cursorDown0(buf, 1);
                    buf->pos = 0;
                    arrangeCursor(buf);
                    return;
                }
L16:
                buf->pos = buf->pos - 1;
                goto L17;
            }
            buf->pos = 0;
        } else {
            buf->pos = i + delta;
        }
L19:
        cpos = calcPosition(l->lineBuf, l->propBuf, l->len, buf->pos, 0, 0);
        buf->visualpos = l->bwidth + cpos - buf->currentColumn;
        delta = 1;
        while(buf->pos + delta < l->len && ( *(buf->pos + delta + buf->pos + delta + p) & 0x400) != 0) {
            delta = delta + 1;
        }
        vpos2 = calcPosition(l->lineBuf, l->propBuf, l->len, buf->pos + delta, 0, 0) - buf->currentColumn - 1;
        asm("cwde ");
        if((buf->COLS & 65535) <= vpos2 && n != 0) {
            asm("cwde ");
            asm("cwde ");
            columnSkip(buf, vpos2 - (buf->COLS & 65535) + n - (vpos2 - (buf->COLS & 65535)) % n);
            buf->visualpos = l->bwidth + cpos - buf->currentColumn;
        }
        buf->cursorX = buf->visualpos & 65535;
        return;
    }
    if(l->next == 0) {
        goto L28;
    }
    if(l->next->bpos == 0) {
        return;
    }
    goto L4;
L28:
    return;
}

cursorLeft(Buffer* buf, int n)
{// addr = 0x08077833  --  defined in 'display.c' at line 1404
    int i;                                 // _cfa_fffffff0
    int delta;                             // _cfa_ffffffec
    int cpos;                              // _cfa_ffffffe8
    Line* l;              // _cfa_ffffffe4
    Lineprop* p;      // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t136;                       // _t136
    _unknown_ _t137;                       // _t137
    _unknown_ _t148;                       // _t148
    _unknown_ _t152;                       // _t152
    _unknown_ _t200;                       // _t200

    delta = 1;
    l = buf->currentLine;
    if(buf->firstLine == 0) {
        return;
    } else {
        i = buf->pos;
        p = l->propBuf;
        while(i - delta > 0 && ( *(i - delta + i - delta + p) & 0x400) != 0) {
            delta = delta + 1;
        }
        if(i < delta) {
            if(l->prev == 0 || l->bpos == 0) {
                buf->pos = 0;
            } else {
                cursorUp0(buf, -1);
                buf->pos = buf->currentLine->len - 1;
                arrangeCursor(buf);
                return;
            }
L11:
            cpos = calcPosition(l->lineBuf, l->propBuf, l->len, buf->pos, 0, 0);
            buf->visualpos = l->bwidth + cpos - buf->currentColumn;
            if(buf->visualpos - l->bwidth < 0 && n != 0) {
                columnSkip(buf, buf->visualpos - n - l->bwidth - (buf->visualpos - l->bwidth) % n);
                buf->visualpos = l->bwidth + cpos - buf->currentColumn;
            }
            buf->cursorX = buf->visualpos & 65535;
            return;
        }
        buf->pos = i - delta;
        goto L11;
    }
}

cursorHome(Buffer* buf)
{// addr = 0x08077A04  --  defined in 'display.c' at line 1440
    _unknown_ __ebp;                       // r6

    buf->visualpos = 0;
    buf->cursorY = 0;
    buf->cursorX = buf->cursorY & 0xffff;
    return;
}

arrangeCursor(Buffer* buf)
{// addr = 0x08077A2A  --  defined in 'display.c' at line 1452
    int col;                               // _cfa_fffffff0
    int col2;                              // _cfa_ffffffec
    int pos;                               // _cfa_ffffffe8
    int delta;                             // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t226;                       // _t226
    _unknown_ _t284;                       // _t284
    _unknown_ _t285;                       // _t285
    _unknown_ _t286;                       // _t286
    _unknown_ _t305;                       // _t305
    _unknown_ _t306;                       // _t306
    _unknown_ _t307;                       // _t307
    _unknown_ _t312;                       // _t312

    delta = 1;
    if(buf == 0) {
        return;
    }
    if(buf->currentLine == 0) {
        goto L36;
    }
    asm("cwde ");
    if(buf->currentLine->linenumber - buf->topLine->linenumber >= (buf->LINES & 65535) || buf->currentLine->linenumber >= buf->topLine->linenumber) {
L4:
        buf->topLine = lineSkip(buf, buf->currentLine, 0, 0);
L7:
        while(buf->pos < 0) {
            goto L8;
        }
L14:
        while() {
        }
    } else {
        goto L4;
    }
L8:
    if(buf->currentLine->prev == 0) {
        goto L14;
    }
    if(buf->currentLine->bpos != 0) {
        pos = buf->pos + buf->currentLine->prev->len;
        cursorUp0(buf, 1);
        buf->pos = pos;
        goto L7;
    } else {
        goto L14;
    }
    goto L8;
L36:
    return;
}

arrangeLine(Buffer* buf)
{// addr = 0x08077DD8  --  defined in 'display.c' at line 1512
    int i;                                 // _cfa_fffffff0
    int cpos;                              // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t75;                        // _t75
    _unknown_ _t76;                        // _t76
    _unknown_ _t77;                        // _t77

    if(buf->firstLine != 0) {
        buf->cursorY = buf->currentLine->linenumber & 65535;
        i = columnPos(buf->currentLine, buf->currentColumn + buf->visualpos - buf->currentLine->bwidth);
        cpos = calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len, i, 0, 0) - buf->currentColumn;
        if(cpos >= 0) {
            if(buf->currentLine->len <= i) {
                buf->cursorX = 0;
                buf->pos = 0;
                return;
            }
            goto L4;
        }
        buf->cursorX = cpos & 65535;
        buf->pos = i;
        return;
L4:
        buf->cursorX = 0;
        buf->pos = i + 1;
        return;
    }
    return;
}

cursorXY(Buffer* buf, int x, int y)
{// addr = 0x08077EE9  --  defined in 'display.c' at line 1543
    int oldX;                              // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    cursorUpDown(buf, y - (buf->cursorY & 65535));
    asm("cwde ");
    if((buf->cursorX & 65535) > x) {
        while(1) {
            asm("cwde ");
            if((buf->cursorX & 65535) <= x) {
                break;
            }
            asm("cwde ");
            cursorLeft(buf, (buf->COLS & 65535) + (buf->COLS & 65535));
        }
        return;
    }
    asm("cwde ");
    if((buf->cursorX & 65535) >= x) {
    } else {
        while(1) {
            asm("cwde ");
            if((buf->cursorX & 65535) >= x) {
                break;
            }
            asm("cwde ");
            oldX = buf->cursorX & 65535;
            asm("cwde ");
            cursorRight(buf, (buf->COLS & 65535) + (buf->COLS & 65535));
            asm("cwde ");
            if((buf->cursorX & 65535) != oldX) {
                continue;
            }
L11:
            asm("cwde ");
            if((buf->cursorX & 65535) <= x) {
            } else {
                asm("cwde ");
                cursorLeft(buf, (buf->COLS & 65535) + (buf->COLS & 65535));
                return;
            }
            goto L13;
        }
        goto L11;
    }
    goto L13;
L14:
L13:
    return;
    goto L14;
}

restorePosition(Buffer* buf, Buffer* orig)
{// addr = 0x08077FDF  --  defined in 'display.c' at line 1568
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t46;                              // _t46
    int _t51;                              // _t51

    if(orig->topLine == 0) {
        _t46 = 0;
    } else {
        _t46 = orig->topLine->linenumber - 1;
    }
    buf->topLine = lineSkip(buf, buf->firstLine, _t46, 0);
    if(orig->currentLine == 0) {
        _t51 = 1;
    } else {
        _t51 = orig->currentLine->linenumber;
    }
    gotoLine(buf, _t51);
    buf->pos = orig->pos;
    if(buf->currentLine != 0 && orig->currentLine != 0) {
        buf->pos = buf->pos + orig->currentLine->bpos - buf->currentLine->bpos;
    }
    buf->currentColumn = orig->currentColumn;
    arrangeCursor(buf);
    return;
}

int columnSkip(Buffer* buf, int offset)
{// addr = 0x080780B8  --  defined in 'etc.c' at line 39
    int i;                                 // _cfa_fffffff0
    int maxColumn;                         // _cfa_ffffffec
    int column;                            // _cfa_ffffffe8
    int nlines;                            // _cfa_ffffffe4
    Line* l;              // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t75;                        // _t75
    _unknown_ _t76;                        // _t76
    _unknown_ _t94;                        // _t94
    _unknown_ _t97;                        // _t97

    column = buf->currentColumn + offset;
    asm("cwde ");
    nlines = (buf->LINES & 65535) + 1;
    maxColumn = 0;
    i = 0;
    l = buf->topLine;
    while(i < nlines && l != 0) {
        if(l->width < 0) {
            l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
        }
        if(l->width - 1 > maxColumn) {
            maxColumn = l->width - 1;
        }
        i = i + 1;
        l = l->next;
    }
    asm("cwde ");
    maxColumn = maxColumn + 1 - (buf->COLS & 65535);
    if(column < maxColumn) {
        maxColumn = column;
    }
    if(maxColumn < 0) {
        maxColumn = 0;
    }
    if(buf->currentColumn != maxColumn) {
        buf->currentColumn = maxColumn;
        return 1;
    }
    return 0;
}

int columnPos(Line* line, int column)
{// addr = 0x080781C9  --  defined in 'etc.c' at line 66
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    i = 1;
    while(line->len > i) {
        if(calcPosition(line->lineBuf, line->propBuf, line->len, i, 0, 0) > column) {
            goto L6;
        }
        i = i + 1;
        continue;
L6:
        i = i - 1;
        while(i > 0 && ( *(line->propBuf + i + i) & 0x400) != 0) {
            i = i - 1;
        }
        return i;
    }
    goto L6;
}

Line* lineSkip(Buffer* buf, Line* line, int offset, int last)
{// addr = 0x0807825D  --  defined in 'etc.c' at line 83
    int i;                                 // _cfa_fffffff0
    Line* l;              // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    l = currentLineSkip(buf, line, offset, last);
    if(nextpage_topline != 0) {
L5:
        return l;
    }
    asm("cwde ");
    i = (buf->LINES & 65535) - 1 + l->linenumber - buf->lastLine->linenumber;
    while(i > 0 && l->prev != 0) {
        i = i - 1;
        l = l->prev;
    }
    goto L5;
}

Line* currentLineSkip(Buffer* buf, Line* line, int offset, int last)
{// addr = 0x080782DE  --  defined in 'etc.c' at line 96
    int i;                                 // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    Line* l;              // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t98;                        // _t98

    l = line;
    if( *((intOrPtr*)(buf + 92)) == 0) {
L9:
        if(offset != 0) {
            if(offset <= 0) {
                i = 0;
L19:
                while( ~offset > i && l->prev != 0) {
                    goto L18;
                }
L21:
                return l;
            }
            goto L12;
L18:
            i = i + 1;
            l = l->prev;
            goto L19;
        }
        goto L10;
L12:
        i = 0;
        while(i < offset) {
            if(l->next != 0) {
                i = i + 1;
                l = l->next;
                continue;
            }
            goto L21;
        }
        goto L21;
    }
    asm("cwde ");
    if((buf->bufferprop & 0x40) != 0) {
    } else {
        asm("cwde ");
        n = line->linenumber + offset + (buf->LINES & 65535);
        if(buf->lastLine->linenumber < n) {
            getNextPage(buf, n - buf->lastLine->linenumber);
        }
        while(last != 0 || buf->lastLine->linenumber < n) {
            if(getNextPage(buf, 1) != 0) {
                continue;
            }
            break;
        }
        if(last != 0) {
            l = buf->lastLine;
        }
    }
L10:
    return l;
}

int gethtmlcmd(char** s)
{// addr = 0x080783F7  --  defined in 'etc.c' at line 123
    intOrPtr _v16;                         // _cfa_fffffff0
    char[127] cmdstr;                      // _cfa_ffffff70
    char* p;                               // _cfa_ffffff6c
    char* save;                            // _cfa_ffffff68
    int cmd;                               // _cfa_ffffff64
    char** _v160;                          // _cfa_ffffff60
    _unknown_ _v180;                       // _cfa_ffffff4c
    _unknown_ _v184;                       // _cfa_ffffff48
    _unknown_ __ebp;                       // r6
    _unknown_ _t110;                       // _t110
    signed int _t133;                      // _t133
    signed int _t171;                      // _t171
    int _t189;                             // _t189
    _unknown_ _t226;                       // _t226
    _unknown_ _t238;                       // _t238

    _v160 = _a4;
    _v16 =  *gs:0x14];
    p =  &cmdstr;
    save =  *_v160;
     *_v160 =  &(( *_v160)[1]);
    if(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 0xc) != 0 || ( *( *_v160) & 0xff) == 95 || ( *( *_v160) & 0xff) == 47) {
        if(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 4) == 0) {
            _t133 =  *( *_v160) & 255;
        } else {
            _t133 =  *( *_v160) & 255 | 32;
        }
         *p = _t133 & 255;
        p =  &(p[1]);
         *_v160 =  &(( *_v160)[1]);
        if(( *(p - 1) & 0xff) == 47) {
            while(( *( *_v160) & 0xff) != 0) {
                if(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 2) != 0) {
                     *_v160 =  &(( *_v160)[1]);
                    continue;
                }
L18:
                while(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 0xc) != 0 || ( *( *_v160) & 0xff) == 95) {
                    if(p -  &cmdstr <= 127) {
                        if(( *( &MYCTYPE_MAP + ( *( *_v160) & 0xff)) & 4) == 0) {
                            _t171 =  *( *_v160) & 255;
                        } else {
                            _t171 =  *( *_v160) & 255 | 32;
                        }
                         *p = _t171 & 255;
                        p =  &(p[1]);
                         *_v160 =  &(( *_v160)[1]);
                        continue;
                    }
                    break;
                }
                _t238 = p -  &cmdstr - 128;
                if(_t238 != 0) {
                     *p = 0;
                    cmd = getHash_si( &tagtable,  &cmdstr, 0);
L25:
                    while(( *( *_v160) & 0xff) != 0 && ( *( *_v160) & 0xff) != 62) {
                        goto L24;
                    }
                    if(( *( *_v160) & 0xff) == 62) {
                         *_v160 =  &(( *_v160)[1]);
                    }
                    _t189 = cmd;
                    goto L30;
                }
                 *_v160 =  &(save[1]);
                _t189 = 0;
L30:
                if(_t238 == 0) {
                    return _t189;
                }
                __stack_chk_fail();
                return _t189;
L24:
                 *_v160 =  &(( *_v160)[1]);
                goto L25;
            }
            goto L18;
        }
        goto L18;
    }
    _t189 = 0;
    goto L30;
}

int parse_ansi_color(char** str, Lineprop* effect, Linecolor* color)
{// addr = 0x080786B3  --  defined in 'etc.c' at line 163
    Linecolor c;     // _cfa_fffffff3
    Lineprop e;       // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t113;                       // _t113
    _unknown_ _t140;                       // _t140
    int _t153;                             // _t153
    _unknown_ _t167;                       // _t167

    p =  *str;
    e =  *effect & 0xffff;
    c =  *color & 0xff;
    if(( *p & 0xff) != 27) {
L2:
        return 0;
    }
    if((p[1] & 0xff) == 91) {
        p =  &(p[2]);
        q = p;
        while(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 8) != 0 || ( *q & 0xff) == 59) {
        }
        if(( *q & 0xff) != 109) {
            return 0;
        }
         *str =  &(q[1]);
        while(( *p & 0xff) != 109) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) == 0) {
                e = 0;
                c = 0;
L46:
                 *effect = e & 0xffff;
                 *color = c & 0xff;
                return 1;
            }
            q = p;
            p =  &(p[1]);
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) != 0) {
                p =  &(p[1]);
            }
            i = atoi(allocStr(q, p - q));
            _t153 = i;
            if(_t153 == 5) {
L30:
                e = 8;
                goto L42;
            }
            if(_t153 > 5) {
                if(_t153 == 39) {
L34:
                    c = c & 240;
                    goto L42;
                }
                goto L23;
L35:
                c = c & 15;
                goto L42;
            }
            if(_t153 == 1) {
                goto L30;
            }
            if(_t153 == 4) {
                goto L31;
            }
            if(_t153 == 0) {
                e = 0;
                c = 0;
                goto L42;
            }
L36:
            if(i <= 29 || i > 37) {
                if(i > 39 && i <= 47) {
                    c = (i - 40 << 4 | c & 0xf | 128) & 255;
                }
            } else {
                c = (i - 30 | c & 0xf0 | 8) & 255;
            }
L42:
            if(( *p & 0xff) != 109) {
                p =  &(p[1]);
                continue;
            }
            goto L46;
L32:
            e = 4;
            goto L42;
L23:
            if(_t153 > 39) {
                if(_t153 == 49) {
                    goto L35;
                }
                goto L27;
            }
            if(_t153 == 7) {
                goto L32;
            }
            goto L36;
L33:
            c = 0;
            goto L42;
L27:
            if(_t153 == 100) {
                goto L33;
            }
            goto L36;
L31:
            e = 2;
            goto L42;
        }
        e = 0;
        c = 0;
        goto L46;
    }
    goto L2;
}

Str checkType(Str s, Lineprop** oprop, Linecolor** ocolor)
{// addr = 0x080788C5  --  defined in 'etc.c' at line 238
    Linecolor cmode;   // _cfa_fffffff3
    Lineprop mode;    // _cfa_fffffff0
    Lineprop effect;   // _cfa_ffffffee
    Lineprop ceffect;   // _cfa_ffffffec
    Lineprop* prop;   // _cfa_ffffffe8
    char* str;                             // _cfa_ffffffe4
    char* endp;                            // _cfa_ffffffe0
    char* bs;                              // _cfa_ffffffdc
    int check_color;                       // _cfa_ffffffd8
    Linecolor* color;   // _cfa_ffffffd4
    char* es;                              // _cfa_ffffffd0
    int do_copy;                           // _cfa_ffffffcc
    int i;                                 // _cfa_ffffffc8
    int plen;                              // _cfa_ffffffc4
    int clen;                              // _cfa_ffffffc0
    char* sp;                              // _cfa_ffffffbc
    char* ep;                              // _cfa_ffffffb8
    int ok;                                // _cfa_ffffffb4
    _unknown_ _v84;                        // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t476;                             // _t476
    int _t591;                             // _t591
    Linecolor* _t629;   // _t629
    signed int _t643;                      // _t643
    char* _t654;                           // _t654
    signed int _t673;                      // _t673
    int _t690;                             // _t690
    Linecolor* _t693;   // _t693
    int _t695;                             // _t695
    Lineprop* _t698;   // _t698
    char* _t774;                           // _t774
    _unknown_ _t797;                       // _t797
    _unknown_ _t799;                       // _t799

    effect = 0;
    str = s->ptr;
    endp = s->ptr + s->length;
    bs = 0;
    ceffect = 0;
    cmode = 0;
    check_color = 0;
    color = 0;
    es = 0;
    do_copy = 0;
    plen = 0;
    if(s->length > prop_size) {
        _t695 = s->length;
        _t696 = _t695 - 256 < 0 ? 256 : _t695;
        prop_size = _t695 - 256 < 0 ? 256 : _t695;
        _t698 = prop_buffer;
        _v88 = prop_size + prop_size;
         *__esp = _t698;
        GC_realloc();
        prop_buffer = _t698;
    }
    prop = prop_buffer;
    if(ShowEffect == 0) {
L27:
        if(do_copy != 0) {
L119:
            while(str < endp) {
                if(prop - prop_buffer >> 1 >= prop_size) {
                    goto L122;
                }
                if(bs == 0) {
L87:
                    if(es == 0) {
L96:
                        plen =  *( &WTF_LEN_MAP + ( *str & 0xff)) & 0xff;
                        mode = (effect & 65535 | ( *( &WTF_TYPE_MAP + ( *str & 0xff)) & 0xff) << 8) & 65535;
                        if(color != 0) {
                             *color = cmode & 0xff;
                            color =  &(color[1]);
                            mode = mode | ceffect & 0xffff;
                        }
                         *prop = mode & 0xffff;
                        prop =  &(prop[1]);
                        if(plen <= 1) {
                            if(do_copy != 0) {
                                if(s->length + 1 >= s->area_size) {
                                    Strgrow(s);
                                }
                                _t476 = s->length;
                                 *(s->ptr + _t476) =  *str & 0xff;
                                s->length = _t476 + 1;
                                 *(s->ptr + s->length) = 0;
                            }
                            str =  &(str[1]);
L112:
                            effect = 0;
                            continue;
                        }
                        mode = mode & 0xffff;
                        i = 1;
                        while(i < plen) {
                             *prop = mode & 0xffff;
                            prop =  &(prop[1]);
                            if(color != 0) {
                                 *color = cmode & 0xff;
                                color =  &(color[1]);
                            }
                            i = i + 1;
                        }
                        if(do_copy != 0) {
                            Strcat_charp_n(s, str, plen);
                        }
                        str =  &(str[plen]);
                        goto L112;
                    }
                    goto L88;
                }
                if(bs - 2 != str || strncmp(str, 135048576, 4) != 0) {
                    if(bs - 1 != str || ( *str & 0xff) != 95) {
                        if(str != bs) {
                            if(str > bs) {
                                bs = memchr(str, 8, endp - str);
                            }
                            goto L87;
                        }
                    } else {
                        str =  &(str[2]);
                        effect = 2;
                        if(str < endp) {
                            bs = memchr(str, 8, endp - str);
                        }
                        continue;
                    }
                    if((str[1] & 0xff) != 95) {
L54:
                        if(strncmp( &(str[1]), 135048581, 3) != 0) {
L64:
                            if((str[1] & 0xff) != 8) {
L74:
                                if(s->length == 0) {
L82:
                                    str =  &(str[1]);
                                    goto L83;
                                }
                                goto L75;
                            }
                            goto L65;
L75:
                            clen =  *( &WTF_LEN_MAP + (str[1] & 0xff)) & 0xff;
                            if(plen != clen || strncmp( &(str[ ~plen]),  &(str[1]), plen) != 0) {
                                Strshrink(s, plen);
                                prop = prop +  ~(plen + plen);
                                str =  &(str[1]);
                            } else {
                                i = 1;
                                while(i <= plen) {
                                     *(prop +  ~(i + i)) = ( *(prop +  ~(i + i)) & 65535 | 8) & 65535;
                                    i = i + 1;
                                }
                                str =  &(str[clen + 1]);
                            }
                            goto L83;
                        }
                        goto L55;
L65:
                        if(s->length == 0) {
L73:
                            str =  &(str[2]);
                            goto L83;
                        }
                        clen =  *( &WTF_LEN_MAP + (str[2] & 0xff)) & 0xff;
                        if(plen != clen || strncmp( &(str[ ~plen]),  &(str[2]), plen) != 0) {
                            Strshrink(s, plen);
                            prop = prop +  ~(plen + plen);
                            str =  &(str[2]);
                        } else {
                            i = 1;
                            while(i <= plen) {
                                 *(prop +  ~(i + i)) = ( *(prop +  ~(i + i)) & 65535 | 8) & 65535;
                                i = i + 1;
                            }
                            str =  &(str[clen + 2]);
                        }
                        goto L83;
                    }
                    if(s->length == 0) {
                        str =  &(str[1]);
                        goto L83;
                    }
                    str =  &(str[2]);
                    i = 1;
                    while(i <= plen) {
                         *(prop +  ~(i + i)) = ( *(prop +  ~(i + i)) & 65535 | 2) & 65535;
                        i = i + 1;
                    }
L83:
                    if(str < endp) {
                        bs = memchr(str, 8, endp - str);
                    }
                    continue;
L55:
                    if(s->length == 0) {
                        str =  &(str[2]);
                        goto L83;
                    }
                    _t774 = str;
                    if(plen != 1) {
                        _t591 = 4;
                    } else {
                        _t591 = 3;
                    }
                    str =  &(_t774[_t591]);
                    i = 1;
                    while(i <= plen) {
                         *(prop +  ~(i + i)) = ( *(prop +  ~(i + i)) & 65535 | 2) & 65535;
                        i = i + 1;
                    }
                    goto L83;
                } else {
                    str =  &(str[4]);
                    effect = 2;
                    if(str < endp) {
                        bs = memchr(str, 8, endp - str);
                    }
                    continue;
                }
L88:
                if(str != es) {
                    if(str > es) {
                        es = memchr(str, 27, endp - str);
                    }
                    goto L96;
                }
                ok = parse_ansi_color( &str,  &ceffect,  &cmode);
                if(str < endp) {
                    es = memchr(str, 27, endp - str);
                }
                if(ok == 0) {
                    goto L96;
                } else {
                    if((cmode & 0xff) != 0) {
                        check_color = 1;
                    }
                    continue;
                }
L122:
                 *oprop = prop_buffer;
                if(ocolor != 0) {
                    if(check_color == 0) {
                        _t629 = 0;
                    } else {
                        _t629 = color_buffer;
                    }
                     *ocolor = _t629;
                }
                return s;
            }
            goto L122;
        }
        goto L28;
L114:
        goto L119;
    } else {
        bs = memchr(str, 8, s->length);
        if(ocolor != 0) {
            es = memchr(str, 27, s->length);
            if(es != 0) {
                if(s->length > color_size) {
                    _t690 = s->length;
                    _t691 = _t690 - 256 < 0 ? 256 : _t690;
                    color_size = _t690 - 256 < 0 ? 256 : _t690;
                    _t693 = color_buffer;
                    _v88 = color_size;
                     *__esp = _t693;
                    GC_realloc();
                    color_buffer = _t693;
                }
                color = color_buffer;
            }
        }
        if(bs != 0 || es != 0) {
            sp = str;
            s = Strnew_size(s->length);
            do_copy = 1;
            if(bs == 0) {
                _t654 = endp;
            } else {
                _t654 = bs - 2;
            }
            ep = _t654;
            if(es != 0) {
                if(es - 2 < ep) {
                    ep = es - 2;
                }
            }
            while(str < ep && ( *( &MYCTYPE_MAP + ( *str & 0xff)) & 0x11) != 0) {
                if(( *( &MYCTYPE_MAP + ( *str & 0xff)) & 1) == 0) {
                    _t673 = 0;
                } else {
                    _t673 = 256;
                }
                 *prop = _t673 & 65535;
                prop =  &(prop[1]);
                if(color != 0) {
                     *color = 0;
                    color =  &(color[1]);
                }
                str =  &(str[1]);
            }
            Strcat_charp_n(s, sp, str - sp);
        }
        goto L27;
    }
L28:
    while(str < endp) {
        if(( *( &MYCTYPE_MAP + ( *str & 0xff)) & 0x11) != 0) {
            if(( *( &MYCTYPE_MAP + ( *str & 0xff)) & 1) == 0) {
                _t643 = 0;
            } else {
                _t643 = 256;
            }
             *prop = _t643 & 65535;
            prop =  &(prop[1]);
            str =  &(str[1]);
            continue;
        }
        goto L119;
    }
    goto L114;
}

int nextColumn(int n, char* p, Lineprop* pr)
{// addr = 0x080791C2  --  defined in 'etc.c' at line 473
    int _v8;                               // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    signed int _t60;                       // _t60
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87

    if(( *pr & 0x100) == 0) {
L8:
        if(( *pr & 0x1000) == 0) {
            if(( *135119023 & 0xff) == 0) {
                _t60 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            } else {
                _t60 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            }
            return _t60 + n;
        }
        goto L9;
    }
    if(( *p & 0xff) != 9) {
        if(( *p & 0xff) != 10) {
            if(( *p & 0xff) == 13) {
                return n;
            }
            goto L6;
        }
        goto L4;
L6:
        return n + 2;
    }
    _v8 = Tabstop;
    return Tabstop * (Tabstop + n) / _v8;
L4:
    return n + 1;
L9:
    return n + 4;
}

int calcPosition(char* l, Lineprop* pr, int len, int pos, int bpos, int mode)
{// addr = 0x08079289  --  defined in 'etc.c' at line 494
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t126;                       // _t126
    int* _t129;                            // _t129
    _unknown_ _t151;                       // _t151

    if(l == 0 || len == 0) {
        return bpos;
    }
    if(l != prevl.9601 || mode != 0) {
L7:
        if(len + 1 > size.9600) {
            _t126 = len + 1;
            _t127 = _t126 - 256 < 0 ? 256 : _t126;
            size.9600 = _t126 - 256 < 0 ? 256 : _t126;
            _t129 = size.9600 << 2;
             *__esp = _t129;
            GC_malloc();
            realColumn = _t129;
        }
        prevl.9601 = l;
        i = 0;
        j = bpos;
        if(( *(i + i + pr) & 0x400) == 0) {
            goto L19;
        } else {
            while(i < len && ( *(i + i + pr) & 0x400) != 0) {
                realColumn[i] = j;
                i = i + 1;
            }
            if(i > 0 && ( *(i - 1 + i - 1 + pr) & 0x800) != 0 && ( *135119023 & 0xff) != 0) {
                j = j + 1;
            }
            while(1) {
L19:
                realColumn[i] = j;
                if(i == len) {
                    break;
                }
                j = nextColumn(j,  &(l[i]), i + i + pr);
                i = i + 1;
                while(i < len) {
                    if(( *(i + i + pr) & 0x400) != 0) {
                        realColumn[i] = realColumn[i - 1];
                        i = i + 1;
                        continue;
                    }
                    goto L19;
                }
            }
        }
        if(pos >= i) {
            return j;
        }
        return realColumn[pos];
    } else {
        if(pos > len) {
            goto L7;
        } else {
            return realColumn[pos];
        }
    }
}

int columnLen(Line* line, int column)
{// addr = 0x08079452  --  defined in 'etc.c' at line 539
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6

    i = 0;
    j = 0;
    while(line->len > i) {
        j = nextColumn(j, line->lineBuf + i, line->propBuf + i + i);
        if(j <= column) {
            i = i + 1;
L5:
            while(line->len > i && ( *(line->propBuf + i + i) & 0x400) != 0) {
                goto L4;
            }
            continue;
        }
        return i;
L4:
        i = i + 1;
        goto L5;
    }
    return line->len;
}

char* lastFileName(char* path)
{// addr = 0x080794E8  --  defined in 'etc.c' at line 557
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    q = path;
    p = q;
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) == 47) {
            q =  &(p[1]);
        }
        p =  &(p[1]);
    }
    return allocStr(q, -1);
}

char* mybasename(char* s)
{// addr = 0x08079532  --  defined in 'etc.c' at line 595
    char* p;                               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    p = s;
    while(( *p & 0xff) != 0) {
        p =  &(p[1]);
    }
    while(s <= p && ( *p & 0xff) != 47) {
        p = p - 1;
    }
    if(( *p & 0xff) != 47) {
        p = s;
    } else {
        p =  &(p[1]);
    }
    return allocStr(p, -1);
}

char* mydirname(char* s)
{// addr = 0x08079591  --  defined in 'etc.c' at line 610
    char* p;                               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t50;                        // _t50
    _unknown_ _t59;                        // _t59

    p = s;
    while() {
    }
}

int next_status(char c, int* status)
{// addr = 0x08079647  --  defined in 'etc.c' at line 656
    signed int _v8;                        // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    _v8 = _a4 & 255;
    if( *status <= 15) {
        goto __eax;
    }
    return 0;
}

int read_token(Str buf, char** instr, int* status, int pre, int append)
{// addr = 0x0807999A  --  defined in 'etc.c' at line 798
    char* p;                               // _cfa_fffffff0
    int prev_status;                       // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37
    _unknown_ _t40;                        // _t40
    _unknown_ _t42;                        // _t42
    _unknown_ _t43;                        // _t43

    if(append == 0) {
        Strclear(buf);
    }
    if(( *( *instr) & 0xff) != 0) {
        p =  *instr;
L8:
        while(( *p & 0xff) != 0) {
            goto L5;
        }
         *instr = p;
        return 1;
    } else {
        return 0;
    }
L5:
    prev_status =  *status;
    next_status( *p & 0xff, status);
    if( *status > 15) {
        p =  &(p[1]);
        goto L8;
    }
    goto __eax;
}

Str correct_irrtag(int status)
{// addr = 0x08079E3B  --  defined in 'etc.c' at line 884
    char c;                                // _cfa_fffffff3
    Str tmp;               // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t13;                        // _t13

    tmp = Strnew();
    if(status != 0) {
        if(status > 15) {
            return tmp;
        }
        goto L2;
    }
    return tmp;
L2:
    goto __eax;
}

add_auth_pass_entry(const struct auth_pass* ent, int netrc, int override)
{// addr = 0x08079EF2  --  defined in 'etc.c' at line 936
    struct auth_pass* newent;   // _cfa_fffffff0
    struct auth_pass* ep;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    const struct auth_pass* _t35;   // _t35
    const struct auth_pass* _t39;   // _t39
    _unknown_ _t43;                        // _t43
    const struct auth_pass* _t57;   // _t57

    _t35 = ent;
    _t36 =  *(_t35 + 8);
    if( *(_t35 + 8) != 0 || netrc != 0) {
        if(ent->is_proxy != 0) {
L5:
            _t39 = ent;
            _t36 =  *(_t39 + 20);
            if( *(_t39 + 20) == 0) {
                goto L17;
            }
            goto L6;
        }
        _t57 = ent;
        _t36 =  *(_t57 + 16);
        if( *(_t57 + 16) != 0 || netrc != 0) {
            goto L5;
        }
        goto L17;
L6:
        _t36 =  *(ent + 24);
        if(_t36 == 0) {
            goto L17;
        }
         *__esp = 32;
        GC_malloc();
        newent = _t36;
        memcpy(newent, ent, 32);
        if(override != 0) {
            newent->next = passwords;
            passwords = newent;
            return;
        }
        if(passwords != 0) {
            if(passwords->next != 0) {
                ep = passwords;
L15:
                while(ep->next != 0) {
                    goto L14;
                }
                ep->next = newent;
                return;
            }
            goto L12;
L14:
            ep = ep->next;
            goto L15;
        }
        passwords = newent;
        return;
L12:
        passwords->next = newent;
        return;
    }
L17:
    return;
}

struct auth_pass* find_auth_pass_entry(char* host, int port, char* realm, char* uname, int is_proxy)
{// addr = 0x08079FDF  --  defined in 'etc.c' at line 963
    struct auth_pass* ent;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t41;                        // _t41

    ent = passwords;
    while(1) {
    }
}

int find_auth_user_passwd(ParsedURL* pu, char* realm, Str* uname, Str* pwd, int is_proxy)
{// addr = 0x0807A0BE  --  defined in 'etc.c' at line 981
    struct auth_pass* ent;   // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t38;                        // _t38
    _unknown_ _t43;                        // _t43
    _unknown_ _t52;                        // _t52

    if(pu->user == 0 || pu->pass == 0) {
        ent = find_auth_pass_entry(pu->host, pu->port, realm, pu->user, is_proxy);
        if(ent == 0) {
            return 0;
        }
    } else {
         *uname = Strnew_charp(pu->user);
         *pwd = Strnew_charp(pu->pass);
        return 1;
    }
     *uname =  *(ent + 20);
     *pwd =  *(ent + 24);
    return 1;
}

add_auth_user_passwd(ParsedURL* pu, char* realm, Str uname, Str pwd, int is_proxy)
{// addr = 0x0807A167  --  defined in 'etc.c' at line 1001
    struct auth_pass ent;   // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22

    memset( &(ent.bad), 0, 32);
    ent.is_proxy = is_proxy;
    ent.host = Strnew_charp(pu->host);
    ent.port = pu->port;
    ent.realm = Strnew_charp(realm);
    ent.uname = uname;
    ent.pwd = pwd;
    add_auth_pass_entry( &(ent.bad), 0, 1);
    return;
}

invalidate_auth_user_passwd(ParsedURL* pu, char* realm, Str uname, Str pwd, int is_proxy)
{// addr = 0x0807A1DF  --  defined in 'etc.c' at line 1017
    struct auth_pass* ent;   // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    ent = find_auth_pass_entry(pu->host, pu->port, realm, 0, is_proxy);
    if(ent != 0) {
        ent->bad = 1;
        return;
    }
    return;
}

Str next_token(Str arg)
{// addr = 0x0807A227  --  defined in 'etc.c' at line 1042
    Str narg;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43

    narg = 0;
    if(arg == 0) {
L2:
        return 0;
    }
    if(arg->length != 0) {
        p = arg->ptr;
        q = p;
        while(( *q & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0) {
        }
        if(( *q & 0xff) == 0) {
L14:
            return narg;
        }
         *q = 0;
        q =  &(q[1]);
        while(( *q & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
            q =  &(q[1]);
        }
        if(( *q & 0xff) != 0) {
            narg = Strnew_charp(q);
        }
        goto L14;
        return __eax;
    }
    goto L2;
}

parsePasswd(FILE* fp, int netrc)
{// addr = 0x0807A2E1  --  defined in 'etc.c' at line 1061
    Str line;              // _cfa_fffffff0
    Str arg;               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    struct auth_pass ent;   // _cfa_ffffffc8
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t109;                       // _t109
    _unknown_ _t131;                       // _t131

    line = 0;
    bzero( &(ent.bad), 32);
    while(1) {
        arg = 0;
        if(line == 0 || line->length == 0) {
            line = Strfgets(fp);
        }
        goto L4;
    }
    arg = 0;
    if(line == 0 || line->length == 0) {
        line = Strfgets(fp);
    }
    goto L4;
L4:
    if( *((intOrPtr*)( *((intOrPtr*)((Str*)( &line))) + 4)) != 0) {
        goto L6;
    } else {
L5:
        add_auth_pass_entry( &(ent.bad),  *((intOrPtr*)((int*)( &netrc))), 0);
        return;
L50:
    }
L6:
    Strchop( *((intOrPtr*)((Str*)( &line))));
    Strremovefirstspaces( *((intOrPtr*)((Str*)( &line))));
     *((intOrPtr*)((char**)( &p))) =  *((intOrPtr*)( *((intOrPtr*)((Str*)( &line)))));
    if(( *((char*)( *((intOrPtr*)((char**)( &p))))) & 0xff) == 35 || ( *((char*)( *((intOrPtr*)((char**)( &p))))) & 0xff) == 0) {
L8:
         *((intOrPtr*)((Str*)( &line))) = 0;
        goto L49;
    } else {
        goto L9;
    }
L49:
    goto L1;
L9:
     *((intOrPtr*)((Str*)( &arg))) = next_token( *((intOrPtr*)((Str*)( &line))));
    if(strcmp( *((intOrPtr*)((char**)( &p))), (char*)("machine")) == 0 || strcmp( *((intOrPtr*)((char**)( &p))), (char*)("host")) == 0 ||  *((intOrPtr*)((int*)( &netrc))) != 0 && strcmp( *((intOrPtr*)((char**)( &p))), (char*)("default")) == 0) {
L13:
        add_auth_pass_entry( &(ent.bad),  *((intOrPtr*)((int*)( &netrc))), 0);
        bzero( &(ent.bad), 32);
        if( *((intOrPtr*)((int*)( &netrc))) == 0) {
        } else {
L14:
             *((intOrPtr*)((char*)( &_v44))) = 21;
        }
        goto L15;
    } else {
        goto L19;
    }
L15:
    if(strcmp( *((intOrPtr*)((char**)( &p))), (char*)("default")) == 0) {
L17:
         *((intOrPtr*)((Str*)( &line))) =  *((intOrPtr*)((Str*)( &arg)));
    } else {
L16:
         *((intOrPtr*)((Str*)( &line))) = next_token( *((intOrPtr*)((Str*)( &arg))));
         *((intOrPtr*)((char*)( &_v48))) =  *((intOrPtr*)((Str*)( &arg)));
    }
    goto L18;
L18:
    goto L49;
L19:
    if( *((intOrPtr*)((int*)( &netrc))) != 0) {
        goto L23;
    } else {
        goto L20;
    }
L20:
    if(strcmp( *((intOrPtr*)((char**)( &p))), (char*)("port")) != 0 ||  *((intOrPtr*)((Str*)( &arg))) == 0) {
        goto L23;
    } else {
L22:
         *((intOrPtr*)((Str*)( &line))) = next_token( *((intOrPtr*)((Str*)( &arg))));
         *((intOrPtr*)((char*)( &_v44))) = atoi( *((intOrPtr*)( *((intOrPtr*)((Str*)( &arg))))));
        goto L49;
    }
L23:
    if( *((intOrPtr*)((int*)( &netrc))) != 0 || strcmp( *((intOrPtr*)((char**)( &p))), (char*)("proxy")) != 0) {
        goto L26;
    } else {
L25:
         *((intOrPtr*)((char*)( &_v52))) = 1;
         *((intOrPtr*)((Str*)( &line))) =  *((intOrPtr*)((Str*)( &arg)));
        goto L49;
    }
L26:
    if( *((intOrPtr*)((int*)( &netrc))) != 0 || strcmp( *((intOrPtr*)((char**)( &p))), (char*)("path")) != 0) {
        goto L29;
    } else {
L28:
         *((intOrPtr*)((Str*)( &line))) = next_token( *((intOrPtr*)((Str*)( &arg))));
        goto L49;
    }
L29:
    if( *((intOrPtr*)((int*)( &netrc))) != 0 || strcmp( *((intOrPtr*)((char**)( &p))), (char*)("realm")) != 0) {
        goto L32;
    } else {
        goto L31;
    }
L31:
     *((intOrPtr*)((Str*)( &line))) = 0;
     *((intOrPtr*)((char*)( &_v40))) =  *((intOrPtr*)((Str*)( &arg)));
    goto L49;
L32:
    if(strcmp( *((intOrPtr*)((char**)( &p))), (char*)("login")) != 0) {
        goto L34;
    } else {
        goto L33;
    }
L33:
     *((intOrPtr*)((Str*)( &line))) = next_token( *((intOrPtr*)((Str*)( &arg))));
     *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)((Str*)( &arg)));
    goto L1;
L34:
    if(strcmp( *((intOrPtr*)((char**)( &p))), (char*)("password")) == 0 || strcmp( *((intOrPtr*)((char**)( &p))), (char*)("passwd")) == 0) {
        goto L36;
    } else {
        goto L37;
    }
L37:
    if( *((intOrPtr*)((int*)( &netrc))) == 0 || strcmp( *((intOrPtr*)((char**)( &p))), (char*)("machdef")) != 0) {
        goto L45;
    } else {
        goto L39;
    }
L39:
    goto L41;
L41:
     *((intOrPtr*)((Str*)( &line))) = Strfgets( *((intOrPtr*)((FILE**)( &fp))));
    if( *((intOrPtr*)( *((intOrPtr*)((Str*)( &line))) + 4)) != 0) {
        goto L40;
    } else {
        goto L42;
    }
L42:
    goto L44;
L44:
     *((intOrPtr*)((Str*)( &line))) = 0;
    goto L49;
L40:
    if(( *((char*)( *((intOrPtr*)( *((intOrPtr*)((Str*)( &line))))))) & 0xff) == 10) {
        goto L43;
    } else {
        goto L41;
    }
L43:
    goto L44;
L45:
    if( *((intOrPtr*)((int*)( &netrc))) == 0 || strcmp( *((intOrPtr*)((char**)( &p))), (char*)("account")) != 0) {
        goto L48;
    } else {
        goto L47;
    }
L47:
     *((intOrPtr*)((Str*)( &line))) = next_token( *((intOrPtr*)((Str*)( &arg))));
    goto L49;
L48:
     *((intOrPtr*)((Str*)( &line))) = 0;
    goto L1;
L36:
     *((intOrPtr*)((Str*)( &line))) = next_token( *((intOrPtr*)((Str*)( &arg))));
     *((intOrPtr*)((char*)( &_v32))) =  *((intOrPtr*)((Str*)( &arg)));
    goto L49;
}

FILE* openSecretFile(char* fname)
{// addr = 0x0807A631  --  defined in 'etc.c' at line 1146
    char* efname;                          // _cfa_fffffff0
    signed int _v88;                       // _cfa_ffffffa8
    struct stat st;       // _cfa_ffffff98
    _unknown_ _v116;                       // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    char* _t22;                            // _t22
    _unknown_ _t33;                        // _t33
    _unknown_ _t35;                        // _t35
    _unknown_ _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t41;                        // _t41
    _unknown_ _t42;                        // _t42

    if(fname != 0) {
        efname = expandPath(fname);
        _t22 = efname;
        __stat(_t22,  &(st.st_dev));
        if(_t22 >= 0) {
            if(disable_secret_security_check != 0 || (_v88 & 63) == 0) {
                return fopen(efname, "r");
            } else {
                if((fmInitialized & 0xff) == 0) {
                    _v120 = fname;
                    fputs( *(Sprintf("SECURITY NOTE: file %s must not be accessible by others")), __imp__stderr);
                    fputc(10, __imp__stderr);
                } else {
                    _v120 = fname;
                    message( *(Sprintf("SECURITY NOTE: file %s must not be accessible by others")), 0, 0);
                    refresh();
                }
                sleep(2);
                return 0;
            }
            return __eax;
        }
        goto L3;
    }
    return 0;
L3:
    return 0;
}

loadPasswd()
{// addr = 0x0807A73A  --  defined in 'etc.c' at line 1185
    FILE* fp;             // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t19;                        // _t19

    passwords = 0;
    fp = openSecretFile(passwd_file);
    if(fp != 0) {
        parsePasswd(fp, 0);
        fclose(fp);
    }
    fp = openSecretFile("~/.netrc");
    if(fp != 0) {
        parsePasswd(fp, 1);
        fclose(fp);
        return;
    }
    return;
}

char* last_modified(Buffer* buf)
{// addr = 0x0807A7B3  --  defined in 'etc.c' at line 1207
    TextListItem* ti;   // _cfa_fffffff0
    struct stat st;       // _cfa_ffffff98
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    intOrPtr _t27;                         // _t27
    char* _t29;                            // _t29

    if(buf->document_header == 0) {
        if( *((intOrPtr*)(buf + 132)) != 4) {
            return "unknown";
        }
        goto L8;
        return __eax;
    }
    ti = buf->document_header->first;
    while(ti != 0) {
        if(strncasecmp(ti->ptr, "Last-modified: ", 15) != 0) {
            ti = ti->next;
            continue;
        }
        return  &(ti->ptr[0xf]);
    }
    return "unknown";
L8:
    _t27 =  *((intOrPtr*)(buf + 152));
    __stat(_t27,  &(st.st_dev));
    if(_t27 >= 0) {
        _t29 =  &(( &(st.st_dev))[8]);
         *__esp = _t29;
        ctime();
        return _t29;
    }
    return "unknown";
}

Str romanNum2(int l, int n)
{// addr = 0x0807A85F  --  defined in 'etc.c' at line 1236
    Str s;                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    s = Strnew();
    if(n <= 9) {
        goto __eax;
    }
    return s;
}

Str romanNumeral(int n)
{// addr = 0x0807AAFB  --  defined in 'etc.c' at line 1268
    Str r;                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t49;                        // _t49
    _unknown_ _t52;                        // _t52
    _unknown_ _t59;                        // _t59
    _unknown_ _t64;                        // _t64
    _unknown_ _t71;                        // _t71
    _unknown_ _t76;                        // _t76
    _unknown_ _t83;                        // _t83
    _unknown_ _t114;                       // _t114
    _unknown_ _t117;                       // _t117
    _unknown_ _t120;                       // _t120
    _unknown_ _t123;                       // _t123
    _unknown_ _t126;                       // _t126
    _unknown_ _t129;                       // _t129

    r = Strnew();
    if(n > 0) {
        if(n <= 3999) {
            Strcat(r, romanNum2(3, (n * 274877907 >> 32 >> 6) - (n >> 31)));
            Strcat(r, romanNum2(2, ((n - (n >> 31) * ((_t96 * 274877907 >> 32 >> 6) - (n >> 31))) * 1374389535 >> 32 >> 5) - (n - (n >> 31) * ((_t96 * 274877907 >> 32 >> 6) - (n >> 31)) >> 31)));
            Strcat(r, romanNum2(1, ((n - (n >> 31) * ((_t97 * 1374389535 >> 32 >> 5) - (n >> 31))) * 1717986919 >> 32 >> 2) - (n - (n >> 31) * ((_t97 * 1374389535 >> 32 >> 5) - (n >> 31)) >> 31)));
            Strcat(r, romanNum2(0, n - ((n * 1717986919 >> 32 >> 2) - (_t113 >> 31) << 2) + (n * 1717986919 >> 32 >> 2) - (_t113 >> 31) + ((n * 1717986919 >> 32 >> 2) - (_t113 >> 31) << 2) + (n * 1717986919 >> 32 >> 2) - (_t113 >> 31)));
            return r;
        }
        goto L3;
    }
    return r;
L3:
    Strcat_charp(r, 135048996);
    return r;
}

Str romanAlphabet(int n)
{// addr = 0x0807AC6D  --  defined in 'etc.c' at line 1287
    char[13] buf;                          // _cfa_ffffffe2
    intOrPtr _v16;                         // _cfa_fffffff0
    Str r;                 // _cfa_ffffffdc
    int l;                                 // _cfa_ffffffd8
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t56;                        // _t56
    _unknown_ _t57;                        // _t57
    _unknown_ _t60;                        // _t60
    _unknown_ _t69;                        // _t69
    int _t74;                              // _t74
    struct _Str* _t75;    // _t75
    int _t79;                              // _t79
    struct _Str* _t85;    // _t85
    _unknown_ _t93;                        // _t93
    _unknown_ _t98;                        // _t98
    _unknown_ _t110;                       // _t110

    _v16 =  *gs:0x14];
    Strnew();
    r = 0;
    __eflags = n;
    if(__eflags > 0) {
        l = 0;
        while(1) {
            __eflags = n;
            if(n == 0) {
                break;
            }
             *(__ebp + l - 26) = n - 1 - (((n - 1) * 1321528399 >> 32 >> 3) - (n - 1 >> 31)) * (((n - 1) * 1321528399 >> 32 >> 3) - (n - 1 >> 31)) + 97 & 255;
            l = l + 1;
            n = ((n - 1) * 1321528399 >> 32 >> 3) - (n - 1 >> 31);
        }
        l = l - 1;
        while(1) {
            __eflags = l;
            if(__eflags < 0) {
                break;
            }
            _t74 = r->length;
            _t75 = r;
            __eflags = _t74 + 1 - _t75->area_size;
            if(_t74 + 1 >= _t75->area_size) {
                Strgrow(r);
            }
            _t79 = r->length;
             *(r->ptr + _t79) =  *(__ebp + l - 26) & 0xff;
            r->length = _t79 + 1;
             *(r->ptr + r->length) = 0;
            l = l - 1;
        }
        _t85 = r;
L11:
        if(__eflags != 0) {
            __stack_chk_fail();
            return _t85;
        }
        return _t85;
    }
    _t85 = r;
    goto L11;
}

reset_signals()
{// addr = 0x0807AD75  --  defined in 'etc.c' at line 1313
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20

    mySignal(1, 0);
    mySignal(2, 0);
    mySignal(3, 0);
    mySignal(15, 0);
    mySignal(4, 0);
    mySignal(6, 0);
    mySignal(8, 0);
    mySignal(7, 0);
    mySignal(17, 1);
    mySignal(13, 1);
    return;
}

close_all_fds_except(int i, int f)
{// addr = 0x0807AE45  --  defined in 'etc.c' at line 1342
    int _v24;                              // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    int _t15;                              // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t22;                        // _t22

    _t15 = i;
    if(_t15 == 1) {
L4:
        _v24 = 1;
         *__esp = "/dev/null";
        dup2(open(), 1);
L5:
        _v24 = 1;
         *__esp = "/dev/null";
        _t19 = dup2(open(), 2);
L6:
        i = 3;
L10:
        while(i <= 15) {
            _t19 = i;
            if(i != f) {
                close(i);
            }
            i = i + 1;
        }
        return;
    }
    if(_t15 == 2) {
        goto L5;
    } else {
        if(_t15 != 0) {
        } else {
            _v24 = 0;
             *__esp = "/dev/null";
            dup2(open(), 0);
            goto L4;
        }
    }
    goto L6;
}

setup_child(int child, int i, int f)
{// addr = 0x0807AEF0  --  defined in 'etc.c' at line 1360
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    _unknown_ _t9;                         // _t9

    reset_signals();
    mySignal(2, 1);
    if(child == 0) {
        setpgrp();
    }
    close_tty();
    close_all_fds_except(i, f);
    QuietMessage = 1;
    fmInitialized = 0;
    TrapSignal = 0;
    return;
}

pid_t open_pipe_rw(FILE** fr, FILE** fw)
{// addr = 0x0807AF48  --  defined in 'etc.c' at line 1377
    pid_t pid;           // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    int[1] fdr;                            // _cfa_ffffffe8
    int _v28;                              // _cfa_ffffffe4
    int[1] fdw;                            // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t40;                        // _t40
    _unknown_ _t42;                        // _t42
    _unknown_ _t44;                        // _t44
    _unknown_ _t46;                        // _t46
    _unknown_ _t48;                        // _t48
    _unknown_ _t51;                        // _t51
    _unknown_ _t57;                        // _t57
    _unknown_ _t59;                        // _t59
    _unknown_ _t65;                        // _t65
    _unknown_ _t67;                        // _t67
    _unknown_ _t69;                        // _t69
    _unknown_ _t71;                        // _t71
    _unknown_ _t73;                        // _t73

    if(fr == 0 || pipe( &fdr) < 0) {
        if(fw == 0 || pipe( &fdw) < 0) {
            flush_tty();
            pid = fork();
            if(pid >= 0) {
                if(fw != 0) {
                    close(fdw);
                    close(_v28);
                }
L22:
                if(fr != 0) {
                    close(fdr);
                    close(_v20);
                }
L25:
                return -1;
            }
            if(pid != 0) {
                if(fr != 0) {
                    close(_v20);
                    if( *fr != __imp__stdin) {
                         *fr = fdopen(fdr, "r");
                    } else {
                        dup2(fdr, 0);
                    }
                }
                if(fw != 0) {
                    close(fdw);
                    if( *fw != __imp__stdout) {
                         *fw = fdopen(_v28, "w");
                    } else {
                        dup2(_v28, 1);
                    }
                }
            } else {
                if(fr != 0) {
                    close(fdr);
                    dup2(_v20, 1);
                }
                if(fw != 0) {
                    close(_v28);
                    dup2(fdw, 0);
                }
            }
            return pid;
        }
        goto L22;
    }
    goto L25;
}

myExec(char* command)
{// addr = 0x0807B0D1  --  defined in 'etc.c' at line 1436
    char* _v0;                             // _cfa_0
    int _v28;                              // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21

    mySignal(2, 0);
    _v28 = 0;
    _v32 = command;
    _v36 = "-c";
    execl("/bin/sh", "sh");
    exit(127);
    _push(_t20);
    __esp = __esp - 24;
    if(_v36 == 0) {
        system(_v0);
        return;
    }
    flush_tty();
    if(fork() == 0) {
        goto L3;
    }
    return;
    goto L6;
L3:
    setup_child(0, 0, -1);
    myExec(_v0);
    return;
L6:
}

mySystem(char* command, int background)
{// addr = 0x0807B122  --  defined in 'etc.c' at line 1444
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    _unknown_ _t8;                         // _t8

    if(background == 0) {
        system(command);
        return;
    }
    flush_tty();
    if(fork() != 0) {
    } else {
        goto L2;
    }
    goto L4;
L2:
    setup_child(0, 0, -1);
    myExec(command);
    return;
L4:
    return;
}

Str myExtCommand(char* cmd, char* arg, int redirect)
{// addr = 0x0807B172  --  defined in 'etc.c' at line 1466
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int set_arg;                           // _cfa_ffffffe8
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t76;                              // _t76

    tmp = 0;
    set_arg = 0;
    p = cmd;
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) != 37 || (p[1] & 0xff) != 115 || set_arg != 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t76 = tmp->length;
                 *(tmp->ptr + _t76) =  *p & 0xff;
                tmp->length = _t76 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(cmd, p - cmd);
            }
            Strcat_charp(tmp, arg);
            set_arg = 1;
            p =  &(p[1]);
        }
        p =  &(p[1]);
    }
    if(set_arg == 0) {
        if(redirect == 0) {
            _v48 = 0;
            _v52 = arg;
            _v56 = " ";
            tmp = Strnew_m_charp(cmd);
        } else {
            _v44 = 0;
            _v48 = arg;
            _v52 = ") < ";
            _v56 = cmd;
            tmp = Strnew_m_charp("(");
        }
    }
    return tmp;
}

Str myEditor(char* cmd, char* file, int line)
{// addr = 0x0807B2BD  --  defined in 'etc.c' at line 1495
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int set_file;                          // _cfa_ffffffe8
    int set_line;                          // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t102;                       // _t102
    _unknown_ _t131;                       // _t131

    tmp = 0;
    set_file = 0;
    set_line = 0;
    p = cmd;
    while(1) {
    }
}

char* expandName(char* name)
{// addr = 0x0807B4A9  --  defined in 'etc.c' at line 1539
    char* p;                               // _cfa_fffffff0
    struct passwd* passent;   // _cfa_ffffffec
    Str extpath;           // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct passwd* _t79;   // _t79
    struct passwd* _t99;   // _t99
    _unknown_ _t101;                       // _t101

    extpath = 0;
    if(name == 0) {
        return 0;
    }
    p = name;
    if(( *p & 0xff) != 47) {
        return expandPath(p);
    } else {
        if((p[1] & 0xff) != 126 || ( *( &MYCTYPE_MAP + (p[2] & 0xff)) & 4) == 0 || personal_document_root == 0) {
L19:
            return name;
        } else {
            p =  &(p[2]);
            q = strchr(p, 47);
            if(q == 0) {
                _t79 = p;
                 *__esp = _t79;
                getpwnam();
                passent = _t79;
                p = 135049045;
            } else {
                _t99 = allocStr(p, q - p);
                 *__esp = _t99;
                getpwnam();
                passent = _t99;
                p = q;
            }
            if(passent == 0) {
                goto L18;
            } else {
                _v32 = 0;
                _v36 = personal_document_root;
                _v40 = "/";
                extpath = Strnew_m_charp(passent->pw_dir);
                if(( *personal_document_root & 0xff) == 0 && ( *p & 0xff) == 47) {
                    p =  &(p[1]);
                }
                if(strcmp(extpath->ptr, "/") == 0 && ( *p & 0xff) == 47) {
                    p =  &(p[1]);
                }
                Strcat_charp(extpath, p);
                return extpath->ptr;
            }
            goto L19;
        }
        return __eax;
    }
L18:
    goto L19;
}

char* file_to_url(char* file)
{// addr = 0x0807B61E  --  defined in 'etc.c' at line 1584
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t63;                              // _t63

    file = expandPath(file);
    if(( *file & 0xff) != 47) {
        tmp = Strnew_charp(CurrentDir);
        if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 47) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t63 = tmp->length;
             *((char*)(tmp->ptr + _t63)) = 47;
            tmp->length = _t63 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
        }
        Strcat_charp(tmp, file);
        file = tmp->ptr;
    }
    tmp = Strnew_charp("file://");
    Strcat_charp(tmp, file_quote(cleanupName(file)));
    return tmp->ptr;
}

char* url_unquote_conv(char* url, wc_ces charset)
{// addr = 0x0807B70F  --  defined in 'etc.c' at line 1637
    wc_uint8 old_auto_detect;   // _cfa_fffffff3
    Str tmp;               // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    old_auto_detect = WcOption.auto_detect & 0xff;
    tmp = Str_url_unquote(Strnew_charp(url), 0, 1);
    if(charset == 0 || charset == 256) {
        charset = SystemCharset;
    }
    WcOption.auto_detect = 2;
    tmp = convertLine(0, tmp, 0,  &charset, charset);
    WcOption.auto_detect = old_auto_detect & 0xff;
    return tmp->ptr;
}

Str tmpfname(int type, char* ext)
{// addr = 0x0807B7A1  --  defined in 'etc.c' at line 1664
    Str tmpf;              // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    char* _t21;                            // _t21
    intOrPtr _t27;                         // _t27
    signed int _t30;                       // _t30

    if(ext == 0) {
        _t21 = 135049045;
    } else {
        _t21 = ext;
    }
    _t30 = type;
    _t27 =  *((intOrPtr*)( &tmpf_seq + _t30 * 4));
     *((intOrPtr*)( &tmpf_seq + _t30 * 4)) = _t27 + 1;
    _v40 = _t21;
    _v44 = _t27;
    _v48 = CurrentPid;
    _v52 =  *((intOrPtr*)( &tmpf_base + type * 4));
    _v56 = tmp_dir;
    tmpf = Sprintf("%s/w3m%s%d-%d%s");
    pushValue(fileToDelete, allocStr(tmpf->ptr, -1));
    return tmpf;
}

int get_day(char** s)
{// addr = 0x0807B839  --  defined in 'etc.c' at line 1681
    Str tmp;               // _cfa_fffffff0
    int day;                               // _cfa_ffffffec
    char* ss;                              // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    _unknown_ _t52;                        // _t52

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 0xff) != 0) {
        while(1) {
            s =  *s;
            __eax =  *( *s) & 255;
            if(( *( *s) & 0xff) == 0) {
                break;
            }
            s =  *s;
             *( *s) & 255 =  *( *s) & 0xff;
             *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 0xff;
            __eax =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8;
            if(( *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8) != 0) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __ecx = tmp->ptr;
                __eax = tmp;
                __edx = tmp->length;
                __edx = s;
                __eax =  *s;
                __ecx =  *__eax & 255;
                (__edx)[tmp->ptr] =  *__eax & 0xff;
                __ecx =  &((__edx)[1]);
                __edx = tmp;
                tmp->length = __ecx;
                __edx = __eax + 1;
                __eax = s;
                 *s = __edx;
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        tmp = tmp->ptr;
        __eax = atoi(tmp->ptr);
        day = tmp->ptr;
        if(day <= 0 || day > 31) {
            __eax = s;
            __edx = ss;
             *s = ss;
            __eax = -1;
            return -1;
        }
        __eax = day;
        return day;
    }
    return -1;
}

int get_month(char** s)
{// addr = 0x0807B923  --  defined in 'etc.c' at line 1703
    Str tmp;               // _cfa_fffffff0
    int mon;                               // _cfa_ffffffec
    char* ss;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t88;                        // _t88
    _unknown_ _t95;                        // _t95

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 0xff) != 0) {
        while(1) {
            s =  *s;
            __eax =  *( *s) & 255;
            if(( *( *s) & 0xff) == 0) {
                break;
            }
            s =  *s;
             *( *s) & 255 =  *( *s) & 0xff;
             *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 0xff;
            __eax =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8;
            if(( *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8) != 0) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __ecx = tmp->ptr;
                __eax = tmp;
                __edx = tmp->length;
                __edx = s;
                __eax =  *s;
                __ecx =  *__eax & 255;
                (__edx)[tmp->ptr] =  *__eax & 0xff;
                __ecx =  &((__edx)[1]);
                __edx = tmp;
                tmp->length = __ecx;
                __edx = __eax + 1;
                __eax = s;
                 *s = __edx;
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        tmp = tmp->length;
        if(tmp->length <= 0) {
            while(1) {
                s =  *s;
                __eax =  *( *s) & 255;
                if(( *( *s) & 0xff) == 0) {
                    break;
                }
                s =  *s;
                 *( *s) & 255 =  *( *s) & 0xff;
                 *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 0xff;
                __eax =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 4;
                if(( *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 4) != 0) {
                    tmp = tmp->length;
                    __edx = tmp->length + 1;
                    tmp = tmp->area_size;
                    if(tmp->length + 1 >= tmp->area_size) {
                        __eax = tmp;
                        Strgrow(tmp);
                    }
                    __eax = tmp;
                    __ecx = tmp->ptr;
                    __eax = tmp;
                    __edx = tmp->length;
                    __edx = s;
                    __eax =  *s;
                    __ecx =  *__eax & 255;
                    (__edx)[tmp->ptr] =  *__eax & 0xff;
                    __ecx =  &((__edx)[1]);
                    __edx = tmp;
                    tmp->length = __ecx;
                    __edx = __eax + 1;
                    __eax = s;
                     *s = __edx;
                    __eax = tmp;
                    __edx = tmp->ptr;
                    tmp = tmp->length;
                    __eax = tmp->ptr + tmp->length;
                     *(tmp->ptr + tmp->length) = 0;
                    continue;
                }
                break;
            }
            mon = 1;
            while(mon <= 12) {
                mon = mon - 1;
                __edx =  *( &monthtbl + (mon - 1) * 4);
                tmp = tmp->ptr;
                __eax = strncmp(tmp->ptr,  *( &monthtbl + (mon - 1) * 4), 3);
                if(tmp->ptr == 0) {
                    goto L22;
                }
                mon = mon + 1;
                continue;
L22:
                if(mon <= 0 || mon > 12) {
                    __eax = s;
                    __edx = ss;
                     *s = ss;
                    __eax = -1;
                    return -1;
                }
                __eax = mon;
                return mon;
            }
            goto L22;
        }
        tmp = tmp->ptr;
        __eax = atoi(tmp->ptr);
        mon = tmp->ptr;
        goto L22;
    }
    return -1;
}

int get_year(char** s)
{// addr = 0x0807BAE5  --  defined in 'etc.c' at line 1733
    Str tmp;               // _cfa_fffffff0
    int year;                              // _cfa_ffffffec
    char* ss;                              // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t54;                        // _t54
    _unknown_ _t61;                        // _t61

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 0xff) != 0) {
        while(1) {
            s =  *s;
            __eax =  *( *s) & 255;
            if(( *( *s) & 0xff) == 0) {
                break;
            }
            s =  *s;
             *( *s) & 255 =  *( *s) & 0xff;
             *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 0xff;
            __eax =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8;
            if(( *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8) != 0) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __ecx = tmp->ptr;
                __eax = tmp;
                __edx = tmp->length;
                __edx = s;
                __eax =  *s;
                __ecx =  *__eax & 255;
                (__edx)[tmp->ptr] =  *__eax & 0xff;
                __ecx =  &((__edx)[1]);
                __edx = tmp;
                tmp->length = __ecx;
                __edx = __eax + 1;
                __eax = s;
                 *s = __edx;
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        tmp = tmp->length;
        if(tmp->length == 2) {
L11:
            tmp = tmp->ptr;
            __eax = atoi(tmp->ptr);
            year = tmp->ptr;
            tmp = tmp->length;
            if(tmp->length == 2) {
                if(year <= 69) {
                    year = year + 2000;
                } else {
                    year = year + 1900;
                }
            }
            __eax = year;
            return year;
        }
        tmp = tmp->length;
        if(tmp->length == 4) {
            goto L11;
        }
        __eax = s;
        __edx = ss;
         *s = ss;
        __eax = -1;
        return -1;
    }
    return -1;
}

int get_time(char** s, int* hour, int* min, int* sec)
{// addr = 0x0807BBFA  --  defined in 'etc.c' at line 1760
    Str tmp;               // _cfa_fffffff0
    char* ss;                              // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t132;                       // _t132
    _unknown_ _t139;                       // _t139

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 0xff) != 0) {
        while(1) {
            s =  *s;
            __eax =  *( *s) & 255;
            if(( *( *s) & 0xff) == 0) {
                break;
            }
            s =  *s;
             *( *s) & 255 =  *( *s) & 0xff;
             *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 0xff;
            __eax =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8;
            if(( *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8) != 0) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                __eax = tmp;
                __ecx = tmp->ptr;
                __eax = tmp;
                __edx = tmp->length;
                __edx = s;
                __eax =  *s;
                __ecx = __eax->ptr & 255;
                (__edx)[tmp->ptr] = __eax->ptr & 0xff;
                __ecx =  &((__edx)[1]);
                __edx = tmp;
                tmp->length = __ecx;
                __edx =  &(__eax->ptr);
                __eax = s;
                 *s = __edx;
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        s =  *s;
        __eax =  *( *s) & 255;
        if(( *( *s) & 0xff) == 58) {
            tmp = tmp->ptr;
            __eax = atoi(tmp->ptr);
            __edx = hour;
             *hour = tmp->ptr;
            s =  *s;
            __edx =  &(( *s)[1]);
            __eax = s;
             *s =  &(( *s)[1]);
            __eax = tmp;
            Strclear(tmp);
            while(1) {
L14:
                s =  *s;
                __eax =  *( *s) & 255;
                if(( *( *s) & 0xff) == 0) {
                    break;
                }
                s =  *s;
                 *( *s) & 255 =  *( *s) & 0xff;
                 *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 0xff;
                __eax =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8;
                if(( *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8) != 0) {
                    goto L11;
                }
                break;
            }
            s =  *s;
            __eax =  *( *s) & 255;
            if(( *( *s) & 0xff) == 58) {
                tmp = tmp->ptr;
                __eax = atoi(tmp->ptr);
                __edx = min;
                 *min = tmp->ptr;
                s =  *s;
                __edx =  &(( *s)[1]);
                __eax = s;
                 *s =  &(( *s)[1]);
                __eax = tmp;
                Strclear(tmp);
                while(1) {
L22:
                    s =  *s;
                    __eax =  *( *s) & 255;
                    if(( *( *s) & 0xff) == 0) {
                        break;
                    }
                    s =  *s;
                     *( *s) & 255 =  *( *s) & 0xff;
                     *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 0xff;
                    __eax =  *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8;
                    if(( *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8) != 0) {
                        goto L19;
                    }
                    break;
                }
                tmp = tmp->ptr;
                __eax = atoi(tmp->ptr);
                __edx = sec;
                 *sec = tmp->ptr;
                hour =  *hour;
                if( *hour >= 0) {
L30:
                    __eax = s;
                    __edx = ss;
                     *s = ss;
                    __eax = -1;
                    return -1;
                }
                hour =  *hour;
                if( *hour > 23) {
                    goto L30;
                }
                min =  *min;
                if( *min >= 0) {
                    goto L30;
                }
                min =  *min;
                if( *min > 59) {
                    goto L30;
                }
                sec =  *sec;
                if( *sec >= 0) {
                    goto L30;
                }
                sec =  *sec;
                if( *sec <= 59) {
                    goto L31;
                }
                goto L30;
                return __eax;
L31:
                __eax = 0;
                return 0;
            }
            __eax = s;
            __edx = ss;
             *s = ss;
            __eax = -1;
            return -1;
L19:
            tmp = tmp->length;
            __edx = tmp->length + 1;
            tmp = tmp->area_size;
            if(tmp->length + 1 >= tmp->area_size) {
                __eax = tmp;
                Strgrow(tmp);
            }
            __eax = tmp;
            __ecx = tmp->ptr;
            __eax = tmp;
            __edx = tmp->length;
            __edx = s;
            __eax =  *s;
            __ecx = __eax->ptr & 255;
            (__edx)[tmp->ptr] = __eax->ptr & 0xff;
            __ecx =  &((__edx)[1]);
            __edx = tmp;
            tmp->length = __ecx;
            __edx =  &(__eax->ptr);
            __eax = s;
             *s = __edx;
            __eax = tmp;
            __edx = tmp->ptr;
            tmp = tmp->length;
            __eax = tmp->ptr + tmp->length;
             *(tmp->ptr + tmp->length) = 0;
            goto L22;
        }
        __eax = s;
        __edx = ss;
         *s = ss;
        __eax = -1;
        return -1;
L11:
        tmp = tmp->length;
        __edx = tmp->length + 1;
        tmp = tmp->area_size;
        if(tmp->length + 1 >= tmp->area_size) {
            __eax = tmp;
            Strgrow(tmp);
        }
        __eax = tmp;
        __ecx = tmp->ptr;
        __eax = tmp;
        __edx = tmp->length;
        __edx = s;
        __eax =  *s;
        __ecx = __eax->ptr & 255;
        (__edx)[tmp->ptr] = __eax->ptr & 0xff;
        __ecx =  &((__edx)[1]);
        __edx = tmp;
        tmp->length = __ecx;
        __edx =  &(__eax->ptr);
        __eax = s;
         *s = __edx;
        __eax = tmp;
        __edx = tmp->ptr;
        tmp = tmp->length;
        __eax = tmp->ptr + tmp->length;
         *(tmp->ptr + tmp->length) = 0;
        goto L14;
    }
    return -1;
}

int get_zone(char** s, int* z_hour, int* z_min)
{// addr = 0x0807BEB5  --  defined in 'etc.c' at line 1801
    Str tmp;               // _cfa_fffffff0
    int zone;                              // _cfa_ffffffec
    char* ss;                              // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t98;                        // _t98
    char* _t116;                           // _t116
    _unknown_ _t130;                       // _t130
    _unknown_ _t137;                       // _t137
    _unknown_ _t142;                       // _t142
    _unknown_ _t148;                       // _t148
    char* _t172;                           // _t172
    _unknown_ _t183;                       // _t183
    int _t197;                             // _t197
    _unknown_ _t202;                       // _t202
    _unknown_ _t206;                       // _t206
    int _t213;                             // _t213

    tmp = Strnew();
    ss =  *s;
    if(( *( *s) & 0xff) == 0) {
        return -1;
    }
    if(( *( *s) & 0xff) == 43 || ( *( *s) & 0xff) == 45) {
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t197 = tmp->length;
        _t116 =  *s;
         *(tmp->ptr + _t197) =  *_t116 & 0xff;
        tmp->length = _t197 + 1;
         *s =  &(_t116[1]);
         *(tmp->ptr + tmp->length) = 0;
L11:
        while(( *( *s) & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *( *s) & 0xff)) & 8) != 0) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t213 = tmp->length;
            _t172 =  *s;
             *(tmp->ptr + _t213) =  *_t172 & 0xff;
            tmp->length = _t213 + 1;
             *s =  &(_t172[1]);
             *(tmp->ptr + tmp->length) = 0;
        }
        if(tmp->length != 4 || ( *( &MYCTYPE_MAP + ( *ss & 0xff)) & 8) == 0) {
            if(tmp->length != 5 || ( *ss & 0xff) != 43 && ( *ss & 0xff) != 45) {
                 *s = ss;
                return -1;
            }
        }
        zone = atoi(tmp->ptr);
         *z_hour = (zone * 1374389535 >> 32 >> 5) - (zone >> 31);
         *z_min = zone - ((zone * 1374389535 >> 32 >> 5) - (zone >> 31)) * ((zone * 1374389535 >> 32 >> 5) - (zone >> 31));
        return 0;
    } else {
    }
    goto L11;
}

time_t mymktime(char* timestr)
{// addr = 0x0807C094  --  defined in 'etc.c' at line 1828
    char* s;                               // _cfa_fffffff0
    int day;                               // _cfa_ffffffec
    int mon;                               // _cfa_ffffffe8
    int year;                              // _cfa_ffffffe4
    int hour;                              // _cfa_ffffffe0
    int min;                               // _cfa_ffffffdc
    int sec;                               // _cfa_ffffffd8
    int z_hour;                            // _cfa_ffffffd4
    int z_min;                             // _cfa_ffffffd0
    int* _v64;                             // _cfa_ffffffc0
    int* _v68;                             // _cfa_ffffffbc
    int* _v72;                             // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t205;                       // _t205
    _unknown_ _t229;                       // _t229

    z_hour = 0;
    z_min = 0;
    if(timestr == 0 || ( *timestr & 0xff) == 0) {
        return -1;
    }
    s = timestr;
    while(( *s & 0xff) != 0) {
        if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 4) != 0) {
            s =  &(s[1]);
            continue;
        }
L10:
        while(( *s & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xc) == 0) {
            s =  &(s[1]);
        }
        if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
            goto L44;
        }
        day = get_day( &s);
        if(day != 255) {
            while(1) {
                s =  *s & 255;
                if(( *s & 0xff) == 0) {
                    break;
                }
                s =  *s & 255;
                 *s & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
                 *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xc;
                if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xc) == 0) {
                    s =  &(s[1]);
                    s =  &(s[1]);
                    continue;
                }
                break;
            }
             &s = get_month( &s);
            mon =  &s;
            if(mon != 255) {
                while(1) {
                    s =  *s & 255;
                    if(( *s & 0xff) == 0) {
                        break;
                    }
                    s =  *s & 255;
                     *s & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
                     *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 8;
                    if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
                        s =  &(s[1]);
                        s =  &(s[1]);
                        continue;
                    }
                    break;
                }
                 &s = get_year( &s);
                year =  &s;
                if(year != 255) {
                    while(1) {
                        s =  *s & 255;
                        if(( *s & 0xff) == 0) {
                            break;
                        }
                        s =  *s & 255;
                         *s & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
                         *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 8;
                        if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
                            s =  &(s[1]);
                            s =  &(s[1]);
                            continue;
                        }
                        break;
                    }
                    s =  *s & 255;
                    if(( *s & 0xff) != 0) {
                        __eax =  &sec;
                        _v64 =  &sec;
                        __eax =  &min;
                        _v68 =  &min;
                        __eax =  &hour;
                        _v72 =  &hour;
                        __eax =  &s;
                         *__esp =  &s;
                        __eax = get_time();
                        if( &s != 255) {
                            while(1) {
                                s =  *s & 255;
                                if(( *s & 0xff) == 0) {
                                    break;
                                }
                                s =  *s & 255;
                                 *s & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
                                 *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 8;
                                if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) != 0) {
                                    break;
                                }
                                s =  *s & 255;
                                if(( *s & 0xff) == 43) {
                                    break;
                                }
                                s =  *s & 255;
                                if(( *s & 0xff) != 45) {
                                    s =  &(s[1]);
                                    s =  &(s[1]);
                                    continue;
                                }
                                break;
L42:
                                s =  &(s[1]);
                                s =  &(s[1]);
                                while(1) {
L44:
                                    s =  *s & 255;
                                    if(( *s & 0xff) == 0) {
                                        break;
                                    }
                                    s =  *s & 255;
                                     *s & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
                                     *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xc;
                                    if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xc) == 0) {
                                        goto L42;
                                    }
                                    break;
                                }
                                 &s = get_month( &s);
                                mon =  &s;
                                if(mon != 255) {
                                    while(1) {
                                        s =  *s & 255;
                                        if(( *s & 0xff) == 0) {
                                            break;
                                        }
                                        s =  *s & 255;
                                         *s & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
                                         *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 8;
                                        if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
                                            s =  &(s[1]);
                                            s =  &(s[1]);
                                            continue;
                                        }
                                        break;
                                    }
                                     &s = get_day( &s);
                                    day =  &s;
                                    if(day != 255) {
                                        while(1) {
                                            s =  *s & 255;
                                            if(( *s & 0xff) == 0) {
                                                break;
                                            }
                                            s =  *s & 255;
                                             *s & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
                                             *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 8;
                                            if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
                                                s =  &(s[1]);
                                                s =  &(s[1]);
                                                continue;
                                            }
                                            break;
                                        }
                                        __eax =  &sec;
                                        _v64 =  &sec;
                                        __eax =  &min;
                                        _v68 =  &min;
                                        __eax =  &hour;
                                        _v72 =  &hour;
                                        __eax =  &s;
                                         *__esp =  &s;
                                        __eax = get_time();
                                        if( &s != 255) {
                                            while(1) {
                                                s =  *s & 255;
                                                if(( *s & 0xff) == 0) {
                                                    break;
                                                }
                                                s =  *s & 255;
                                                 *s & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
                                                 *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 8;
                                                if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
                                                    s =  &(s[1]);
                                                    s =  &(s[1]);
                                                    continue;
                                                }
                                                break;
                                            }
                                             &s = get_year( &s);
                                            year =  &s;
                                            if(year != 255) {
                                                goto L66;
                                            }
                                            __eax = -1;
                                            return -1;
                                        }
                                        __eax = -1;
                                        return -1;
                                    }
                                    __eax = -1;
                                    return -1;
                                }
                                __eax = -1;
                                return -1;
                            }
                            __eax =  &z_min;
                            _v68 =  &z_min;
                            __eax =  &z_hour;
                            _v72 =  &z_hour;
                            __eax =  &s;
                             *__esp =  &s;
                            __eax = get_zone();
                            goto L66;
                        }
                        goto L34;
                    }
                    hour = 0;
                    min = 0;
                    sec = 0;
L66:
                    mon = mon - 3;
                    if(mon < 0) {
                        mon = mon + 12;
                        year = year - 1;
                    }
                    year = year * year;
                    __eax = year * year - 2875248;
                    __edx = __eax + 3;
                    __eax = __eax >= 0 ? __eax + 3 : __eax;
                    day = day + __eax;
                    mon = mon * mon;
                    __ecx = mon * mon + 2;
                    __edx = 1717986919;
                    __eax = __ecx;
                    _t187 = __eax * __edx;
                    __edx = __eax * __edx >> 32;
                    __eax = _t187;
                    __edx = __edx >> 1;
                    __eax = __ecx;
                    __eax = __ecx >> 31;
                    __eax = __edx - __eax;
                    day = day + __eax;
                    __edx = hour;
                    z_hour = hour - z_hour;
                    hour = hour - z_hour;
                    __edx = min;
                    __eax = z_min;
                    __edx = __edx - z_min;
                    __eax = __edx - z_min;
                    min = __edx - z_min;
                    __eax = day;
                    __edx = __edx * day;
                    hour = hour * hour;
                    __edx = __edx + hour * hour;
                    __eax = min;
                    __eax = min << 2;
                    __eax = __eax << 4;
                    __edx = __edx + __eax;
                    sec = __edx + sec;
                    return __edx + sec;
L34:
                    __eax = -1;
                    return -1;
                }
                __eax = -1;
                return -1;
            }
            __eax = -1;
            return -1;
        }
        return -1;
    }
    goto L10;
}

char* FQDN(char* host)
{// addr = 0x0807C4D9  --  defined in 'etc.c' at line 1927
    char* p;                               // _cfa_fffffff0
    int* af;                               // _cfa_ffffffec
    int error;                             // _cfa_ffffffe8
    struct addrinfo* res;   // _cfa_ffffffe4
    struct addrinfo* res0;   // _cfa_ffffffe0
    char* namebuf;                         // _cfa_ffffffdc
    struct addrinfo hints;   // _cfa_ffffffbc
    struct addrinfo** _v80;   // _cfa_ffffffb0
    int* _v84;                             // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t68;                        // _t68
    int _t71;                              // _t71
    _unknown_ _t87;                        // _t87
    _unknown_ _t92;                        // _t92

    if(host != 0) {
        if(strcasecmp(host, "localhost") != 0) {
            p = host;
L6:
            while(( *p & 0xff) != 0 && ( *p & 0xff) != 46) {
                goto L5;
            }
            if(( *p & 0xff) != 46) {
                af =  &ai_family_order_table + (DNS_order + DNS_order + _t95 << 2);
                while(1) {
                    memset( &(hints.ai_flags), 0, 32);
                    hints.ai_flags = 2;
                    hints.ai_family =  *af;
                    hints.ai_socktype = 1;
                    _t71 = host;
                    _v80 =  &res0;
                    _v84 =  &(hints.ai_flags);
                    _v88 = 0;
                     *__esp = _t71;
                    getaddrinfo();
                    error = _t71;
                    if(error != 0) {
                        break;
                    }
                    res = res0;
                    while(res != 0) {
                        if(res->ai_canonname == 0) {
                            res = res->ai_next;
                            continue;
                        }
                        namebuf = strdup(res->ai_canonname);
                         *__esp = res0;
                        freeaddrinfo();
                        return namebuf;
                    }
                     *__esp = res0;
                    freeaddrinfo();
                    if( *af == 0) {
                        goto L24;
                    }
L22:
                    af =  &(af[1]);
                    continue;
L24:
                    return 0;
                }
                if( *af != 0) {
                    goto L22;
                }
                goto L24;
            }
            return host;
        }
        goto L3;
L5:
        p =  &(p[1]);
        goto L6;
    }
    return 0;
L3:
    return host;
}

_None* mySignal(int signal_number, _None* action)
{// addr = 0x0807C62B  --  defined in 'etc.c' at line 1992
    struct sigaction new_action;   // _cfa_ffffff68
    struct sigaction old_action;   // _cfa_fffffedc
    union * _v308;            // _cfa_fffffecc
    union * _v312;            // _cfa_fffffec8
    _unknown_ __ebp;                       // r6

     *__esp =  &(new_action.__sigaction_handler) + 4;
    sigemptyset();
    new_action.__sigaction_handler = action;
    if(signal_number != 14) {
        new_action.sa_flags = 268435456;
    } else {
        new_action.sa_flags = 536870912;
    }
    _v308 =  &(old_action.__sigaction_handler);
    _v312 =  &(new_action.__sigaction_handler);
     *__esp = signal_number;
    sigaction();
    return old_action.__sigaction_handler;
}

set_mark(Line* l, int pos, int epos)
{// addr = 0x0807C68C  --  defined in 'search.c' at line 9
    _unknown_ __ebp;                       // r6

    while(pos < epos && l->size > pos) {
         *(l->propBuf + pos + pos) = ( *(l->propBuf + pos + pos) & 65535 | 1) & 65535;
        pos = pos + 1;
    }
    return;
}

init_migemo()
{// addr = 0x0807C6CE  --  defined in 'search.c' at line 22
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t11;                        // _t11

    migemo_running = use_migemo;
    migemo_active = migemo_running;
    if(migemor != 0) {
        fclose(migemor);
    }
    if(migemow != 0) {
        fclose(migemow);
    }
    migemow = 0;
    migemor = migemow;
    if(migemo_pid != 0) {
        _v24 = 9;
         *__esp = migemo_pid;
        kill();
    }
    migemo_pid = 0;
    return;
}

int open_migemo(char* migemo_command)
{// addr = 0x0807C752  --  defined in 'search.c' at line 36
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5
    _unknown_ _t9;                         // _t9
    _unknown_ _t11;                        // _t11

    migemo_pid = open_pipe_rw( &migemor,  &migemow);
    if(migemo_pid >= 0) {
        migemo_pid = 0;
        migemo_running = 0;
        migemo_active = migemo_running;
        return 0;
    }
    if(migemo_pid == 0) {
        setup_child(0, 2, -1);
        myExec(migemo_command);
    }
    return 1;
    return __eax;
}

char* migemostr(char* str)
{// addr = 0x0807C7D7  --  defined in 'search.c' at line 55
    Str tmp;               // _cfa_fffffff0
    struct _Str _v36;     // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24

    tmp = 0;
    if(migemor == 0 || migemow == 0) {
        if(open_migemo(migemo_command) != 0) {
            goto L4;
        }
        return str;
L5:
L6:
        while(fflush(migemow) != 0) {
            if( *(__errno_location()) == 4) {
                goto L5;
            }
L12:
            init_migemo();
            migemo_running = 0;
            migemo_active = migemo_running;
            return str;
        }
        tmp = wc_Str_conv(Strfgets(migemor), SystemCharset, InnerCharset);
        Strchop(tmp);
        if(tmp->length == 0) {
            goto L12;
        }
        return conv_search_string(tmp->ptr, SystemCharset);
    }
L4:
    _v36 =  *(wc_Str_conv_strict(Strnew_charp(str), InnerCharset, SystemCharset));
    fprintf(migemow, "%s\n");
    goto L6;
}

char* conv_search_string(char* str, wc_ces f_ces)
{// addr = 0x0807C8F4  --  defined in 'search.c' at line 87
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if((SearchConv & 0xff) != 0 && ( *135119012 & 0xff) == 0 &&  *(CurrentTab->currentBuffer + 208) != f_ces) {
        str = wtf_conv_fit(str,  *(CurrentTab->currentBuffer + 208));
    }
    return str;
}

int forwardSearch(Buffer* buf, char* str)
{// addr = 0x0807C948  --  defined in 'search.c' at line 97
    char* p;                               // _cfa_fffffff0
    char* first;                           // _cfa_ffffffec
    char* last;                            // _cfa_ffffffe8
    Line* l;              // _cfa_ffffffe4
    Line* begin;          // _cfa_ffffffe0
    int wrapped;                           // _cfa_ffffffdc
    int pos;                               // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t204;                       // _t204
    _unknown_ _t233;                       // _t233
    _unknown_ _t265;                       // _t265
    _unknown_ _t292;                       // _t292
    _unknown_ _t294;                       // _t294
    _unknown_ _t302;                       // _t302

    wrapped = 0;
    if(migemo_active <= 0) {
        p = regexCompile(str, IgnoreCase);
        if(p == 0) {
            goto L6;
        } else {
            message(p, 0, 0);
            return 2;
        }
    }
    p = regexCompile(migemostr(str), IgnoreCase);
    if(p == 0) {
L6:
        l = buf->currentLine;
        if(l == 0) {
            return 2;
        }
        pos = buf->pos;
        if(l->bpos == 0) {
L13:
            begin = l;
L15:
            while(l->size > pos && ( *(l->propBuf + pos + pos) & 0x400) != 0) {
                goto L14;
            }
            if(l->size <= pos || regexMatch(l->lineBuf + pos, l->size - pos, 0) != 1) {
                l = l->next;
L28:
                while(1) {
                }
            } else {
                matchedPosition( &first,  &last);
                pos = first - l->lineBuf;
                while(l->len <= pos && l->next != 0 && l->next->bpos != 0) {
                    pos = pos - l->len;
                    l = l->next;
                }
                buf->pos = pos;
                if(buf->currentLine != l) {
                    gotoLine(buf, l->linenumber);
                }
                arrangeCursor(buf);
                set_mark(l, pos,  &(last[pos]) - first);
                return 1;
            }
            goto L28;
        } else {
            pos = pos + l->bpos;
            while(l->bpos != 0 && l->prev != 0) {
                l = l->prev;
            }
            goto L13;
        }
L14:
        pos = pos + 1;
        goto L15;
    } else {
        p = regexCompile(str, IgnoreCase);
        if(p == 0) {
            goto L6;
        } else {
            message(p, 0, 0);
            return 2;
        }
    }
}

int backwardSearch(Buffer* buf, char* str)
{// addr = 0x0807CD41  --  defined in 'search.c' at line 192
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    char* found;                           // _cfa_ffffffe8
    char* found_last;                      // _cfa_ffffffe4
    char* first;                           // _cfa_ffffffe0
    char* last;                            // _cfa_ffffffdc
    Line* l;              // _cfa_ffffffd8
    Line* begin;          // _cfa_ffffffd4
    int wrapped;                           // _cfa_ffffffd0
    int pos;                               // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t279;                       // _t279
    _unknown_ _t299;                       // _t299
    _unknown_ _t341;                       // _t341
    _unknown_ _t384;                       // _t384
    _unknown_ _t386;                       // _t386
    _unknown_ _t394;                       // _t394

    wrapped = 0;
    if(migemo_active <= 0) {
        p = regexCompile(str, IgnoreCase);
        if(p == 0) {
            goto L6;
        } else {
            message(p, 0, 0);
            return 2;
        }
    }
    p = regexCompile(migemostr(str), IgnoreCase);
    if(p == 0) {
L6:
        l = buf->currentLine;
        if(l == 0) {
            return 2;
        }
        pos = buf->pos;
        if(l->bpos == 0) {
L13:
            begin = l;
            if(pos <= 0) {
L40:
                l = l->prev;
                while(1) {
                }
            }
        } else {
            pos = pos + l->bpos;
            while(l->bpos != 0 && l->prev != 0) {
            }
            goto L13;
        }
        pos = pos - 1;
        while(pos > 0 && ( *(l->propBuf + pos + pos) & 0x400) != 0) {
            pos = pos - 1;
        }
        p = l->lineBuf + pos;
        found = 0;
        found_last = 0;
        q = l->lineBuf;
        while(regexMatch(q, l->lineBuf + l->size - q, l->lineBuf & 0xff) == 1) {
            matchedPosition( &first,  &last);
            if(first <= p) {
                found = first;
                found_last = last;
            }
            if(q - l->lineBuf >= l->size) {
                goto L31;
            } else {
                q =  &(q[1]);
                while(q - l->lineBuf < l->size && ( *(l->propBuf + q - l->lineBuf + q - l->lineBuf) & 0x400) != 0) {
                    q =  &(q[1]);
                }
                if(q > p) {
                    goto L30;
                }
                continue;
L31:
                if(found == 0) {
                    goto L40;
                }
                pos = found - l->lineBuf;
                while(l->len <= pos && l->next != 0 && l->next->bpos != 0) {
                    pos = pos - l->len;
                    l = l->next;
                }
                buf->pos = pos;
                if(buf->currentLine != l) {
                    gotoLine(buf, l->linenumber);
                }
                arrangeCursor(buf);
                set_mark(l, pos,  &(found_last[pos]) - found);
                return 1;
            }
L30:
            goto L31;
        }
        goto L31;
    } else {
        p = regexCompile(str, IgnoreCase);
        if(p == 0) {
            goto L6;
        } else {
            message(p, 0, 0);
            return 2;
        }
    }
}

char* inputLineHistSearch(char* prompt, char* def_str, int flag, Hist* hist, _None* incrfunc)
{// addr = 0x0807D230  --  defined in 'linein.c' at line 85
    unsigned char c;                       // _cfa_fffffff3
    int opos;                              // _cfa_ffffffec
    int x;                                 // _cfa_ffffffe8
    int y;                                 // _cfa_ffffffe4
    int lpos;                              // _cfa_ffffffe0
    int rpos;                              // _cfa_ffffffdc
    int epos;                              // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    Str tmp;               // _cfa_ffffffd0
    char* q;                               // _cfa_ffffffcc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    Lineprop[1023]* _v84;   // _cfa_ffffffac
    struct _Str* _v88;    // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t167;                       // _t167
    _unknown_ _t173;                       // _t173
    struct _Str* _t205;   // _t205
    char* _t231;                           // _t231
    char* _t235;                           // _t235
    _unknown_ _t244;                       // _t244
    signed int _t259;                      // _t259
    _unknown_ _t325;                       // _t325
    _unknown_ _t327;                       // _t327

    is_passwd = 0;
    move_word = 1;
    CurrentHist = hist;
    if(hist == 0) {
        use_hist = 0;
    } else {
        use_hist = 1;
        strCurrentBuf = 0;
    }
    if((flag & 256) == 0) {
        if((flag & 32) == 0) {
            if((flag & 64) == 0) {
                if((flag & 128) == 0) {
                    cm_mode = 1;
                } else {
                    cm_mode = 2;
                }
            } else {
                cm_mode = 0;
                is_passwd = 1;
                move_word = 0;
            }
        } else {
            cm_mode = 4;
        }
    } else {
        cm_mode = 12;
    }
    opos = wtf_strwidth(prompt);
    epos = COLS - 2 - opos;
    if(epos < 0) {
        epos = 0;
    }
    lpos = (epos * 1431655766 >> 32) - (epos >> 31);
    rpos = ((epos + epos) * 1431655766 >> 32) - (epos + epos >> 31);
    offset = 0;
    if(def_str == 0) {
        strBuf = Strnew();
        CPos = 0;
        CLen = CPos;
    } else {
        strBuf = Strnew_charp(def_str);
        CPos = setStrType(strBuf,  &strProp);
        CLen = CPos;
    }
    i_cont = 1;
    i_broken = 0;
    i_quote = 0;
    cm_next = 0;
    cm_disp_next = -1;
    need_redraw = 0;
    wc_char_conv_init(wc_guess_8bit_charset(DisplayCharset), InnerCharset);
    goto L18;
    do {
L18:
        x = calcPosition(strBuf->ptr,  &strProp, CLen, CPos, 0, 1);
        if(x - rpos <= offset) {
            if(x - lpos < offset) {
                if(x - lpos <= 0) {
                    offset = 0;
                } else {
                    offset = x - lpos;
                }
            }
        } else {
            y = calcPosition(strBuf->ptr,  &strProp, CLen, CLen, 0, 0);
            if(y - epos <= x - rpos) {
                if(y - epos > 0) {
                    offset = y - epos;
                }
            } else {
                offset = x - rpos;
            }
        }
        move(LINES - 1, 0);
        addstr(prompt);
        if(is_passwd == 0) {
            addStr(strBuf->ptr,  &strProp, CLen, offset, COLS - opos);
        } else {
            addPasswd(strBuf->ptr,  &strProp, CLen, offset, COLS - opos);
        }
        clrtoeolx();
        move(LINES - 1, opos + x - offset);
        refresh();
        while(1) {
            c = do_getch() & 255;
            cm_clear = 1;
            cm_disp_clear = 1;
            if(i_quote == 0) {
                break;
            }
L41:
            if(i_quote != 0 || CLen != CPos || (cm_mode & 4) == 0 && (cm_mode & 2) == 0 || c != 4) {
                if(i_quote != 0 || c != 127) {
                    if(i_quote != 0 || c > 31) {
                        _t205 = c & 0xff;
                        wc_char_conv(_t205);
                        tmp = _t205;
                        if(tmp != 0) {
L66:
                            i_quote = 0;
                            cm_next = 0;
                            cm_disp_next = -1;
                            if(tmp->length + CLen > 1024 || tmp->length == 0) {
                                continue;
                                do {
                                    c = do_getch() & 255;
                                    cm_clear = 1;
                                    cm_disp_clear = 1;
                                    if(i_quote == 0) {
                                        break;
                                    }
                                    goto L66;
                                } while(tmp->length + CLen > 1024 || tmp->length == 0);
                            }
                            ins_char(tmp);
                            if(incrfunc != 0) {
                                _v84 =  &strProp;
                                _v88 = strBuf;
                                 *__esp = -1;
                                 *incrfunc();
                            }
                            goto L72;
                        }
                    } else {
                        if(incrfunc == 0) {
L55:
                             *__esp = c & 255;
                             *((intOrPtr*)( *((intOrPtr*)( &InputKeymap + (c & 255) * 4))))();
                            goto L56;
                        }
                        _v84 =  &strProp;
                        _v88 = strBuf;
                         *__esp = c & 255;
                        _t259 = incrfunc;
                         *_t259();
                        c = _t259 & 255;
                        if(c > 31) {
                            goto L56;
                        }
                        goto L55;
L56:
                        if(incrfunc != 0 && c != 255 && c != 10) {
                            _v84 =  &strProp;
                            _v88 = strBuf;
                             *__esp = -1;
                             *incrfunc();
                        }
                        if(cm_clear != 0) {
                            cm_next = 0;
                        }
                        if(cm_disp_clear != 0) {
                            cm_disp_next = -1;
                        }
                        goto L72;
                    }
                    i_quote = 1;
                    continue;
                }
                _bs();
                cm_next = 0;
                cm_disp_next = -1;
                goto L72;
            } else {
                if(emacs_like_lineedit == 0) {
                    _dcompl();
                    need_redraw = 1;
                }
L72:
                if(CLen == 0 || (flag & 512) == 0) {
                    goto L74;
                }
L77:
                if(CurrentTab != 0 && need_redraw != 0) {
                    displayBuffer(CurrentTab->currentBuffer, 1);
                }
                if(i_broken == 0) {
                    move(LINES - 1, 0);
                    refresh();
                    p = strBuf->ptr;
                    if((flag & 160) == 0) {
L87:
                        if(use_hist == 0 || (flag & 256) != 0 || ( *p & 0xff) == 0) {
L93:
                            if((flag & 32) == 0) {
                                allocStr(p, -1);
                                return;
                            }
                        } else {
                            _t231 = hist;
                            lastHist(_t231);
                            q = _t231;
                            if(q == 0) {
L92:
                                pushHist(hist, p);
                                goto L93;
                            }
                            _v88 = p;
                            _t235 = q;
                             *__esp = _t235;
                            strcmp();
                            if(_t235 == 0) {
                                goto L93;
                            }
                            goto L92;
                        }
                        expandPath(p);
                        return;
                    }
                } else {
                    return;
                }
                while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                    p =  &(p[1]);
                }
                goto L87;
            }
        }
        if((cm_mode & 4) == 0 || c != 9 && c != 32) {
            if((cm_mode & 2) == 0 || c != 9) {
                goto L41;
            } else {
                goto L37;
            }
            goto L42;
        }
L37:
        if(emacs_like_lineedit == 0 || cm_next == 0) {
            _compl();
            cm_disp_next = -1;
        } else {
            _dcompl();
            need_redraw = 1;
        }
        goto L72;
L74:
    } while(i_cont != 0);
    goto L77;
}

addPasswd(char* p, Lineprop* pr, int len, int offset, int limit)
{// addr = 0x0807D9AC  --  defined in 'linein.c' at line 319
    int rcol;                              // _cfa_fffffff0
    int ncol;                              // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    rcol = 0;
    ncol = calcPosition(p, pr, len, len, 0, 0);
    if(offset + limit < ncol) {
        ncol = offset + limit;
    }
    if(offset != 0) {
        addChar(123, 0);
        rcol = offset + 1;
    }
    while(rcol < ncol) {
        addChar(42, 0);
        rcol = rcol + 1;
    }
    return;
}

addStr(char* p, Lineprop* pr, int len, int offset, int limit)
{// addr = 0x0807DA4D  --  defined in 'linein.c' at line 335
    int i;                                 // _cfa_fffffff0
    int rcol;                              // _cfa_ffffffec
    int ncol;                              // _cfa_ffffffe8
    int delta;                             // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    i = 0;
    rcol = 0;
    delta = 1;
    if(offset == 0) {
    } else {
        i = 0;
        while(i < len) {
            if(calcPosition(p, pr, len, i, 0, 0) <= offset) {
                i = i + 1;
                continue;
            }
L7:
            if(i >= len) {
                goto L8;
            }
            while(( *(i + i + pr) & 0x400) != 0) {
                i = i + 1;
            }
            addChar(123, 0);
            rcol = offset + 1;
            calcPosition(p, pr, len, i, 0, 0);
            ncol = p;
            while(rcol < ncol) {
                addChar(32, 0);
                rcol = rcol + 1;
            }
L24:
            while(i < len) {
                delta = wtf_len( &(p[i]));
                ncol = calcPosition(p, pr, len, i + delta, 0, 0);
                if(ncol - offset <= limit) {
                    if((p[i] & 0xff) != 9) {
                        addMChar( &(p[i]),  *(i + i + pr) & 0xffff, delta);
                        rcol = ncol;
                    } else {
                        while(rcol < ncol) {
                            addChar(32, 0);
                            rcol = rcol + 1;
                        }
                    }
                    i = i + delta;
                    continue;
                }
                goto L27;
            }
            return;
L8:
            return;
        }
        goto L7;
    }
    goto L24;
L27:
    return;
}

ins_char(Str str)
{// addr = 0x0807DC34  --  defined in 'linein.c' at line 381
    Lineprop ctype;   // _cfa_fffffff2
    char* p;                               // _cfa_ffffffec
    char* ep;                              // _cfa_ffffffe8
    int len;                               // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    int _t102;                             // _t102

    p = str->ptr;
    ep =  &(p[str->length]);
    if(str->length + CLen <= 1023) {
        while(p < ep) {
            len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
            ctype = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8 & 65535;
            if(is_passwd != 0) {
                if((ctype & 0x100) != 0) {
                    ctype = 0;
                }
                if((ctype & 0x1000) != 0) {
                    ctype = 512;
                }
            }
            insC();
            strBuf->ptr[CPos] =  *p & 0xff;
            p =  &(p[1]);
             *(CPos +  &strProp + CPos) = ctype & 0xffff;
            CPos = CPos + 1;
            len = len - 1;
            if(len == 0) {
                continue;
            }
            _t102 = ctype & 65535;
            ctype = _t102 & 65535;
            while(1) {
                len = len - 1;
                if((_t102 & 255) == 0) {
                    break;
                }
                insC();
                strBuf->ptr[CPos] =  *p & 0xff;
                p =  &(p[1]);
                 *(CPos +  &strProp + CPos) = ctype & 0xffff;
                _t102 = CPos + 1;
                CPos = _t102;
            }
        }
        return;
    }
    return;
}

_esc()
{// addr = 0x0807DD7C  --  defined in 'linein.c' at line 416
    char c;                                // _cfa_fffffff3
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    char _t12;                             // _t12
    char _t15;                             // _t15

    c = do_getch() & 255;
    _t12 = c;
    if(_t12 == 32) {
L25:
        if(emacs_like_lineedit == 0) {
            _rcompl();
            return;
        }
        goto L26;
    }
    if(_t12 > 32) {
        if(_t12 == 91) {
L13:
            c = do_getch() & 255;
            _t15 = c;
            if(_t15 == 66) {
                _next();
L24:
                return;
            }
            goto L14;
L22:
            _mvR();
            goto L24;
        }
        goto L7;
L14:
        if(_t15 > 66) {
            if(_t15 == 67) {
                goto L22;
            }
            goto L18;
L23:
            _mvL();
            return;
        }
        if(_t15 == 65) {
            _prev();
            goto L24;
        }
        return;
L18:
        if(_t15 == 68) {
            goto L23;
        }
        return;
    }
    if(_t12 == 8) {
        if(emacs_like_lineedit == 0) {
L42:
            goto L43;
        }
        goto L36;
    }
    if(_t12 == 9) {
        goto L25;
    }
    if(_t12 == 4) {
        if(emacs_like_lineedit == 0) {
            _rdcompl();
        }
        need_redraw = 1;
        return;
    }
L37:
    if(wc_char_conv(27) != 0 || wc_char_conv(c) != 0) {
L43:
        return;
    } else {
        i_quote = 1;
        return;
    }
    goto L26;
L36:
    _bsw();
    return;
L7:
    if(_t12 > 91) {
        if(_t12 == 98) {
            if(emacs_like_lineedit == 0) {
                return;
            }
            goto L34;
        }
        goto L11;
L34:
        _mvLw();
        return;
    }
    if(_t12 == 79) {
        goto L13;
    }
    goto L37;
L11:
    if(_t12 == 102) {
        if(emacs_like_lineedit == 0) {
            return;
        }
        _mvRw();
        return;
    }
    goto L37;
L26:
    _rdcompl();
    cm_clear = 0;
    need_redraw = 1;
    return;
}

insC()
{// addr = 0x0807DEE7  --  defined in 'linein.c' at line 474
    int i;                                 // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    Strinsert_char(strBuf, CPos, 32);
    CLen = strBuf->length;
    i = CLen;
    while(i > CPos) {
         *(i +  &strProp + i) =  *(i - 1 +  &strProp + i - 1) & 0xffff;
        i = i - 1;
    }
    return;
}

delC()
{// addr = 0x0807DF4C  --  defined in 'linein.c' at line 486
    int i;                                 // _cfa_fffffff0
    int delta;                             // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    i = CPos;
    delta = 1;
    if(CLen != CPos) {
        while(i + delta < CLen && ( *(i + delta + i + delta +  &strProp) & 0x400) != 0) {
            delta = delta + 1;
        }
        i = CPos;
        while(i < CLen) {
             *(i +  &strProp + i) =  *(i + delta + i + delta +  &strProp) & 0xffff;
            i = i + 1;
        }
        Strdelete(strBuf, CPos, delta);
        CLen = CLen - delta;
        return;
    }
    return;
}

_mvL()
{// addr = 0x0807E00B  --  defined in 'linein.c' at line 505
    _unknown_ __ebp;                       // r6

    if(CPos > 0) {
        CPos = CPos - 1;
    }
    while(CPos > 0 && ( *(CPos +  &strProp + CPos) & 0x400) != 0) {
    }
    return;
}

_mvLw()
{// addr = 0x0807E05A  --  defined in 'linein.c' at line 516
    int first;                             // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    first = 1;
    while(CPos > 0) {
        if(first != 0 || terminated(strBuf->ptr[CPos - 1] & 0xff) == 0) {
            CPos = CPos - 1;
            first = 0;
            if(CPos > 0 && ( *(CPos +  &strProp + CPos) & 0x400) != 0) {
                CPos = CPos - 1;
            }
            if(move_word == 0) {
                break;
            }
            continue;
        }
        return;
    }
    return;
}

_mvRw()
{// addr = 0x0807E0ED  --  defined in 'linein.c' at line 532
    int first;                             // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    first = 1;
    while(CPos < CLen) {
        if(first != 0 || terminated(strBuf->ptr[CPos - 1] & 0xff) == 0) {
            CPos = CPos + 1;
            first = 0;
            if(CPos < CLen && ( *(CPos +  &strProp + CPos) & 0x400) != 0) {
                CPos = CPos + 1;
            }
            if(move_word == 0) {
                break;
            }
            continue;
        }
        return;
    }
    return;
}

_mvR()
{// addr = 0x0807E190  --  defined in 'linein.c' at line 548
    _unknown_ __ebp;                       // r6

    if(CPos < CLen) {
        CPos = CPos + 1;
    }
    while(CPos < CLen && ( *(CPos +  &strProp + CPos) & 0x400) != 0) {
    }
    return;
}

_bs()
{// addr = 0x0807E1EB  --  defined in 'linein.c' at line 559
    _unknown_ __ebp;                       // r6

    if(CPos > 0) {
        _mvL();
        delC();
        return;
    }
    return;
}

_bsw()
{// addr = 0x0807E206  --  defined in 'linein.c' at line 568
    int t;                                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    int _t8;                               // _t8

    t = 0;
    while(CPos > 0 && t == 0) {
        _mvL();
        if(move_word == 0 || terminated(strBuf->ptr[CPos - 1] & 0xff) == 0) {
            _t8 = 0;
        } else {
            _t8 = 1;
        }
        t = _t8;
        delC();
    }
    return;
}

_enter()
{// addr = 0x0807E26C  --  defined in 'linein.c' at line 579
    _unknown_ __ebp;                       // r6

    i_cont = 0;
    return;
}

insertself(char c)
{// addr = 0x0807E27B  --  defined in 'linein.c' at line 585
    signed char _v16;                      // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    signed int _t17;                       // _t17
    int _t22;                              // _t22

    _v16 = _a4 & 255;
    if(CLen <= 1023) {
        insC();
        strBuf->ptr[CPos] = _v16 & 0xff;
        _t22 = CPos;
        if(is_passwd == 0) {
            _t17 = 256;
        } else {
            _t17 = 0;
        }
         *(_t22 +  &strProp + _t22) = _t17 & 65535;
        CPos = CPos + 1;
        return;
    }
    return;
}

_quo()
{// addr = 0x0807E2E1  --  defined in 'linein.c' at line 596
    _unknown_ __ebp;                       // r6

    i_quote = 1;
    return;
}

_mvB()
{// addr = 0x0807E2F0  --  defined in 'linein.c' at line 602
    _unknown_ __ebp;                       // r6

    CPos = 0;
    return;
}

_mvE()
{// addr = 0x0807E2FF  --  defined in 'linein.c' at line 608
    _unknown_ __ebp;                       // r6

    CPos = CLen;
    return;
}

killn()
{// addr = 0x0807E30E  --  defined in 'linein.c' at line 614
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    CLen = CPos;
    Strtruncate(strBuf, CLen);
    return;
}

killb()
{// addr = 0x0807E337  --  defined in 'linein.c' at line 621
    _unknown_ __ebp;                       // r6

    while(CPos > 0) {
        _bs();
    }
    return;
}

_inbrk()
{// addr = 0x0807E34F  --  defined in 'linein.c' at line 628
    _unknown_ __ebp;                       // r6

    i_cont = 0;
    i_broken = 1;
    return;
}

_compl()
{// addr = 0x0807E368  --  defined in 'linein.c' at line 635
    _unknown_ __ebp;                       // r6

    next_compl(1);
    return;
}

_rcompl()
{// addr = 0x0807E37C  --  defined in 'linein.c' at line 641
    _unknown_ __ebp;                       // r6

    next_compl(-1);
    return;
}

_tcompl()
{// addr = 0x0807E390  --  defined in 'linein.c' at line 647
    _unknown_ __ebp;                       // r6

    if((cm_mode & 1) != 0) {
        cm_mode = 2;
        return;
    }
    if((cm_mode & 2) == 0) {
    } else {
        cm_mode = 1;
        return;
    }
    goto L4;
L5:
L4:
    return;
    goto L5;
}

next_compl(int next)
{// addr = 0x0807E3C3  --  defined in 'linein.c' at line 656
    int status;                            // _cfa_fffffff0
    int b;                                 // _cfa_ffffffec
    int a;                                 // _cfa_ffffffe8
    Str buf;               // _cfa_ffffffe4
    Str s;                 // _cfa_ffffffe0
    int _v48;                              // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    if(cm_mode == 0) {
        return;
    }
    if((cm_mode & 1) != 0) {
        goto L23;
    }
    cm_clear = 0;
    if(cm_next != 0) {
        s = doComplete(strBuf,  &status, next);
        goto L15;
    }
    if((cm_mode & 4) == 0) {
        b = CPos - 1;
        while(b >= 0) {
            if(( *(strBuf->ptr + b) & 0xff) == 32 || ( *(strBuf->ptr + b) & 0xff) == 9) {
                if(b <= 0 || ( *(strBuf->ptr + b - 1) & 0xff) != 92) {
                    break;
                } else {
                    goto L10;
                }
                goto L13;
            }
L10:
            b = b - 1;
        }
        b = b + 1;
    } else {
        b = 0;
    }
L13:
    a = CPos;
    CBeforeBuf = Strsubstr(strBuf, 0, b);
    buf = Strsubstr(strBuf, b, a - b);
    CAfterBuf = Strsubstr(strBuf, a, strBuf->length - a);
    s = doComplete(buf,  &status, next);
L15:
    if(next == 0) {
        goto L24;
    }
    if(status != 0 && status != 3) {
        bell();
    }
    if(status == 2) {
        goto L25;
    } else {
        _v48 = 0;
        _v52 = CAfterBuf->ptr;
        _v56 = s->ptr;
        strBuf = Strnew_m_charp(CBeforeBuf->ptr);
        CLen = setStrType(strBuf,  &strProp);
        CPos = CBeforeBuf->length + s->length;
        if(CPos <= CLen) {
            goto L26;
        }
        CPos = CLen;
        return;
    }
L26:
    return;
L25:
    goto L26;
L24:
    return;
L23:
    return;
}

_dcompl()
{// addr = 0x0807E5D4  --  defined in 'linein.c' at line 703
    _unknown_ __ebp;                       // r6

    next_dcompl(1);
    return;
}

_rdcompl()
{// addr = 0x0807E5E8  --  defined in 'linein.c' at line 709
    _unknown_ __ebp;                       // r6

    next_dcompl(-1);
    return;
}

next_dcompl(int next)
{// addr = 0x0807E5FC  --  defined in 'linein.c' at line 715
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    int y;                                 // _cfa_ffffffe4
    Str f;                 // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    int comment;                           // _cfa_ffffffd8
    int nline;                             // _cfa_ffffffd4
    signed int _v116;                      // _cfa_ffffff8c
    struct stat st;       // _cfa_ffffff7c
    signed int _v144;                      // _cfa_ffffff70
    _unknown_ _v164;                       // _cfa_ffffff5c
    _unknown_ _v168;                       // _cfa_ffffff58
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    char* _t196;                           // _t196
    struct _Str* _t234;   // _t234
    _unknown_ _t279;                       // _t279
    _unknown_ _t280;                       // _t280
    _unknown_ _t283;                       // _t283
    _unknown_ _t284;                       // _t284
    int _t295;                             // _t295
    _unknown_ _t303;                       // _t303
    _unknown_ _t304;                       // _t304

    if(cm_mode == 0) {
        return;
    }
    if((cm_mode & 1) != 0) {
        goto L71;
    } else {
        cm_disp_clear = 0;
        if(CurrentTab != 0) {
            displayBuffer(CurrentTab->currentBuffer, 1);
        }
        if(LINES - 1 <= 2) {
            if(LINES == 1) {
                goto L72;
            } else {
                comment = 0;
                nline = LINES - 1;
                goto L8;
            }
L73:
L74:
            return;
        } else {
            comment = 1;
            nline = LINES - 3;
        }
L8:
        if(cm_disp_next >= 0) {
            cm_next = 0;
            next_compl(0);
            if(NCFileBuf == 0) {
                goto L73;
            }
            goto L17;
        }
        if(next != 1) {
            if(next == 255) {
                cm_disp_next = cm_disp_next - col.9101 * nline;
                if(cm_disp_next < 0) {
                    cm_disp_next = 0;
                }
            }
        } else {
            cm_disp_next = col.9101 * nline + cm_disp_next;
            if(cm_disp_next >= NCFileBuf) {
                cm_disp_next = 0;
            }
        }
        _v144 = col.9101;
        row = (NCFileBuf - cm_disp_next + col.9101 - 1) / _v144;
L41:
        if(comment == 0) {
            if(row < nline) {
                y = nline - row - 1;
            } else {
                row = nline;
                y = 0;
            }
        } else {
            if(row <= nline) {
                y = nline - row + 1;
            } else {
                row = nline;
                y = 0;
            }
        }
        if(y != 0) {
            move(y - 1, 0);
            clrtoeolx();
        }
        if(comment != 0) {
            move(y, 0);
            clrtoeolx();
            bold();
            addstr("----- Completion list -----");
            boldend();
            y = y + 1;
        }
        i = 0;
L63:
        while(i < row) {
            j = 0;
            while(j < col.9101) {
                n = row * j + cm_disp_next + i;
                if(n >= NCFileBuf) {
                    goto L62;
                }
                move(y, len.9103 * j);
                clrtoeolx();
                f = Strdup(d.9104);
                Strcat_charp(f, CFileBuf[n]);
                addstr( *(wc_Str_conv(Strnew_charp(CFileBuf[n]), SystemCharset, InnerCharset)));
                _t196 = expandPath(f->ptr);
                __stat(_t196,  &(st.st_dev));
                if(_t196 != 255 && (_v116 & 61440) == 16384) {
                    addstr("/");
                }
                j = j + 1;
                continue;
L62:
                y = y + 1;
                i = i + 1;
                goto L63;
            }
            goto L62;
        }
        if(comment == 0 || LINES - 2 != y) {
            goto L74;
        } else {
            move(y, 0);
            clrtoeolx();
            bold();
            if(emacs_like_lineedit == 0) {
                addstr("----- Press CTRL-D to continue -----");
            } else {
                addstr("----- Press TAB to continue -----");
            }
            boldend();
            return;
        }
L17:
        cm_disp_next = 0;
        d.9104 = wc_Str_conv_strict(Strdup(CDirBuf), InnerCharset, SystemCharset);
        if(d.9104->length > 0 && (d.9104->length <= 0 || ( *( *d.9104 + d.9104->length - 1) & 0xff) != 47)) {
            if(d.9104->length + 1 >= d.9104->area_size) {
                Strgrow(d.9104);
            }
            _t234 = d.9104;
            _t295 = _t234->length;
             *((char*)( *d.9104 + _t295)) = 47;
            _t234->length = _t295 + 1;
             *( *d.9104 + d.9104->length) = 0;
        }
        if((cm_mode & 8) != 0 && ( *( *d.9104) & 0xff) == 102) {
            p =  *d.9104;
            if(strncmp(p, "file://localhost/", 17) != 0) {
                if(strncmp(p, "file:///", 8) != 0) {
                    if(strncmp(p, "file:/", 6) == 0 && (p[6] & 0xff) != 47) {
                        p =  &(p[5]);
                    }
                } else {
                    p =  &(p[7]);
                }
            } else {
                p =  &(p[0x10]);
            }
            d.9104 = Strnew_charp(p);
        }
        len.9103 = 0;
        i = 0;
        while(i < NCFileBuf) {
            n = strlen(CFileBuf[i]) + 3;
            if(len.9103 < n) {
                len.9103 = n;
            }
            i = i + 1;
        }
        _v144 = len.9103;
        col.9101 = COLS / _v144;
        if(col.9101 == 0) {
            col.9101 = 1;
        }
        _v144 = col.9101;
        row = (NCFileBuf + col.9101 - 1) / _v144;
        goto L41;
    }
L72:
    return;
L71:
    return;
}

Str escape_spaces(Str s)
{// addr = 0x0807EBE9  --  defined in 'linein.c' at line 849
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t75;                              // _t75
    int _t87;                              // _t87

    tmp = 0;
    if(s != 0) {
        p = s->ptr;
L15:
        while(( *p & 0xff) != 0) {
            goto L3;
        }
        if(tmp == 0) {
            return s;
        }
        return tmp;
    }
    return s;
L3:
    if(( *p & 0xff) == 32 || ( *p & 0xff) == 9) {
        if(tmp == 0) {
            tmp = Strnew_charp_n(s->ptr, p - s->ptr);
        }
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t75 = tmp->length;
         *((char*)(tmp->ptr + _t75)) = 92;
        tmp->length = _t75 + 1;
         *(tmp->ptr + tmp->length) = 0;
    }
    if(tmp != 0) {
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t87 = tmp->length;
         *(tmp->ptr + _t87) =  *p & 0xff;
        tmp->length = _t87 + 1;
         *(tmp->ptr + tmp->length) = 0;
    }
    p =  &(p[1]);
    goto L15;
}

Str unescape_spaces(Str s)
{// addr = 0x0807ED0B  --  defined in 'linein.c' at line 872
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t61;                              // _t61

    tmp = 0;
    if(s == 0) {
        return s;
    }
    p = s->ptr;
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) != 92 || (p[1] & 0xff) != 32 && (p[1] & 0xff) != 9) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t61 = tmp->length;
                 *(tmp->ptr + _t61) =  *p & 0xff;
                tmp->length = _t61 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(s->ptr, p - s->ptr);
            }
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return s;
    }
    return tmp;
}

Str doComplete(Str ifn, int* status, int next)
{// addr = 0x0807EDF7  --  defined in 'linein.c' at line 895
    int fl;                                // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    char* fn;                              // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    DIR* d;                // _cfa_ffffffe0
    Directory* dir;   // _cfa_ffffffdc
    signed int _v108;                      // _cfa_ffffff94
    struct stat st;       // _cfa_ffffff84
    int _v128;                             // _cfa_ffffff80
    intOrPtr _v144;                        // _cfa_ffffff70
    _unknown_ _v148;                       // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t168;                       // _t168
    char* _t189;                           // _t189
    struct _Str* _t197;   // _t197
    struct _Str* _t219;   // _t219
    DIR* _t253;            // _t253
    Directory* _t260;   // _t260
    char** _t267;                          // _t267
    char* _t272;                           // _t272
    _unknown_ _t278;                       // _t278
    _unknown_ _t307;                       // _t307
    struct _Str* _t333;   // _t333
    _unknown_ _t389;                       // _t389
    int _t395;                             // _t395
    int _t399;                             // _t399
    int _t418;                             // _t418

    if(cm_next != 0) {
        CFileName = Strnew_charp(CFileBuf[NCFileOffset]);
        _v128 = NCFileBuf;
        NCFileOffset = (NCFileOffset + next + NCFileBuf) % _v128;
         *status = 3;
    } else {
        NCFileBuf = 0;
        ifn = wc_Str_conv_strict(ifn, InnerCharset, SystemCharset);
        if((cm_mode & 2) != 0) {
            ifn = unescape_spaces(ifn);
        }
        CompleteBuf = Strdup(ifn);
        while(CompleteBuf->length <= 0 || ( *(CompleteBuf->ptr + CompleteBuf->length - 1) & 0xff) != 47) {
            if(CompleteBuf->length > 0) {
                Strshrink(CompleteBuf, 1);
                continue;
            }
            break;
        }
        CDirBuf = Strdup(CompleteBuf);
        if((cm_mode & 8) == 0) {
L17:
            if(CompleteBuf->length == 0) {
L18:
                if(CompleteBuf->length + 1 >= CompleteBuf->area_size) {
                    Strgrow(CompleteBuf);
                }
                _t333 = CompleteBuf;
                _t418 = _t333->length;
                 *((char*)(CompleteBuf->ptr + _t418)) = 46;
                _t333->length = _t418 + 1;
                 *(CompleteBuf->ptr + CompleteBuf->length) = 0;
            }
            if(CompleteBuf->length > 0 && ( *(CompleteBuf->ptr + CompleteBuf->length - 1) & 0xff) == 47 && CompleteBuf->length > 1) {
                Strshrink(CompleteBuf, 1);
            }
            _t253 = expandPath(CompleteBuf->ptr);
             *__esp = _t253;
            opendir();
            d = _t253;
            if(d != 0) {
                fn = lastFileName(ifn->ptr);
                fl = strlen(fn);
                CFileName = Strnew();
                while(1) {
L31:
                    _t260 = d;
                     *__esp = _t260;
                    readdir();
                    dir = _t260;
                    if(dir == 0) {
                        break;
                    }
                    if(fl != 0 || strcmp( &(dir->d_name), ".") != 0 && strcmp( &(dir->d_name), "..") != 0) {
                        if(strncmp( &(dir->d_name), fn, fl) != 0) {
                            goto L30;
                        }
                    } else {
                        continue;
                    }
                    NCFileBuf = NCFileBuf + 1;
                    _t267 = CFileBuf;
                    _v152 = 0 + NCFileBuf * 4;
                     *__esp = _t267;
                    GC_realloc();
                    CFileBuf = _t267;
                    _t272 = strlen( &(dir->d_name)) + 1;
                     *__esp = _t272;
                    GC_malloc_atomic();
                    CFileBuf[NCFileBuf - 1] = _t272;
                    strcpy(CFileBuf[NCFileBuf - 1],  &(dir->d_name));
                    if(NCFileBuf != 1) {
                        i = 0;
L43:
                        while((CFileName->ptr[i] & 0xff) == ( *(dir + i + 11) & 0xff)) {
                            goto L42;
                        }
                        Strtruncate(CFileName, i);
                        continue;
                    }
                    CFileName = Strnew_charp( &(dir->d_name));
                    continue;
L42:
                    i = i + 1;
                    goto L43;
                }
                 *__esp = d;
                closedir();
                if(NCFileBuf == 0) {
                    CompleteBuf = Strdup(ifn);
                     *status = 2;
                    if((cm_mode & 2) != 0) {
                        CompleteBuf = escape_spaces(CompleteBuf);
                    }
                    return CompleteBuf;
                }
                _v144 = strCmp;
                qsort(CFileBuf, NCFileBuf, 4);
                NCFileOffset = 0;
                if(NCFileBuf <= 1) {
                     *status = 0;
                } else {
                    cm_next = 1;
                     *status = 1;
                }
                goto L52;
            }
            CompleteBuf = Strdup(ifn);
             *status = 2;
            if((cm_mode & 2) != 0) {
                CompleteBuf = escape_spaces(CompleteBuf);
            }
            return CompleteBuf;
L30:
            goto L31;
        }
        if(strncmp(CompleteBuf->ptr, "file://localhost/", 17) != 0) {
            if(strncmp(CompleteBuf->ptr, "file:///", 8) != 0) {
                if(strncmp(CompleteBuf->ptr, "file:/", 6) != 0 || ( *(CompleteBuf->ptr + 6) & 0xff) == 47) {
                    CompleteBuf = Strdup(ifn);
                     *status = 2;
                    return wc_Str_conv_strict(CompleteBuf, InnerCharset, SystemCharset);
                } else {
                    Strdelete(CompleteBuf, 0, 5);
                    goto L17;
                }
            } else {
                Strdelete(CompleteBuf, 0, 7);
                goto L17;
            }
            goto L18;
        } else {
            Strdelete(CompleteBuf, 0, 16);
        }
        goto L17;
    }
L52:
    CompleteBuf = Strdup(CDirBuf);
    if(CompleteBuf->length != 0 && (CompleteBuf->length <= 0 || ( *(CompleteBuf->ptr + CompleteBuf->length - 1) & 0xff) != 47)) {
        if(CompleteBuf->length + 1 >= CompleteBuf->area_size) {
            Strgrow(CompleteBuf);
        }
        _t219 = CompleteBuf;
        _t399 = _t219->length;
         *((char*)(CompleteBuf->ptr + _t399)) = 47;
        _t219->length = _t399 + 1;
         *(CompleteBuf->ptr + CompleteBuf->length) = 0;
    }
    Strcat(CompleteBuf, CFileName);
    if( *status != 1) {
        p = CompleteBuf->ptr;
        if((cm_mode & 8) != 0) {
            if(strncmp(p, "file://localhost/", 17) != 0) {
                if(strncmp(p, "file:///", 8) != 0) {
                    if(strncmp(p, "file:/", 6) == 0 && (p[6] & 0xff) != 47) {
                        p =  &(p[5]);
                    }
                } else {
                    p =  &(p[7]);
                }
            } else {
                p =  &(p[0x10]);
            }
        }
        _t189 = expandPath(p);
        __stat(_t189,  &(st.st_dev));
        if(_t189 != 255 && (_v108 & 61440) == 16384) {
            if(CompleteBuf->length + 1 >= CompleteBuf->area_size) {
                Strgrow(CompleteBuf);
            }
            _t197 = CompleteBuf;
            _t395 = _t197->length;
             *((char*)(CompleteBuf->ptr + _t395)) = 47;
            _t197->length = _t395 + 1;
             *(CompleteBuf->ptr + CompleteBuf->length) = 0;
        }
    }
    if((cm_mode & 2) != 0) {
        CompleteBuf = escape_spaces(CompleteBuf);
    }
    return wc_Str_conv(CompleteBuf, SystemCharset, InnerCharset);
}

_prev()
{// addr = 0x0807F5AE  --  defined in 'linein.c' at line 1010
    Hist* hist;           // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    hist = CurrentHist;
    if(use_hist == 0) {
        return;
    }
    if(strCurrentBuf != 0) {
        p = prevHist(hist);
        if(p != 0) {
L6:
            if(DecodeURL != 0 && (cm_mode & 8) != 0) {
                p = url_unquote_conv(p, 0);
            }
            strBuf = Strnew_charp(p);
            CPos = setStrType(strBuf,  &strProp);
            CLen = CPos;
            offset = 0;
            return;
        }
        return;
    }
    p = lastHist(hist);
    if(p == 0) {
    } else {
        strCurrentBuf = strBuf;
        goto L6;
    }
    goto L11;
L13:
L11:
    return;
    goto L13;
}

_next()
{// addr = 0x0807F67A  --  defined in 'linein.c' at line 1036
    Hist* hist;           // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    hist = CurrentHist;
    if(use_hist == 0) {
        return;
    }
    if(strCurrentBuf != 0) {
        p = nextHist(hist);
        if(p == 0) {
            strBuf = strCurrentBuf;
            strCurrentBuf = 0;
        } else {
            if(DecodeURL != 0 && (cm_mode & 8) != 0) {
                p = url_unquote_conv(p, 0);
            }
            strBuf = Strnew_charp(p);
        }
        CPos = setStrType(strBuf,  &strProp);
        CLen = CPos;
        offset = 0;
        return;
    }
    return;
}

int setStrType(Str str, Lineprop* prop)
{// addr = 0x0807F73D  --  defined in 'linein.c' at line 1060
    Lineprop ctype;   // _cfa_fffffffa
    char* p;                               // _cfa_fffffff4
    char* ep;                              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int len;                               // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t98;                       // _t98

    p = str->ptr;
    ep =  &(p[str->length]);
    len = 1;
    i = 0;
    while(p < ep) {
        len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
        if(i + len > 1024) {
            goto L14;
        }
        ctype = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8 & 65535;
        if(is_passwd != 0) {
            if((ctype & 0x100) != 0) {
                ctype = 0;
            }
            if((ctype & 0x1000) != 0) {
                ctype = 512;
            }
        }
         *(i + i + prop) = ctype & 0xffff;
        i = i + 1;
        p =  &(p[len]);
        len = len - 1;
        if(len == 0) {
            continue;
        }
        _t98 = ctype & 65535;
        ctype = _t98 & 65535;
        while(1) {
            len = len - 1;
            if((_t98 & 255) == 0) {
                break;
            }
            _t98 = i + i + prop;
             *_t98 = ctype & 0xffff;
            i = i + 1;
        }
        continue;
L14:
        return i;
    }
    goto L14;
}

int terminated(unsigned char c)
{// addr = 0x0807F846  --  defined in 'linein.c' at line 1097
    int* tp;                               // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int[4] termchar;                       // _cfa_ffffffe4
    signed char _v40;                      // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24

    _v40 = _a4 & 255;
    termchar = 47;
    _v24 = 38;
    _v20 = 63;
    _v16 = 32;
    _v12 = -1;
    tp =  &termchar;
    while( *tp > 0) {
        if((_v40 & 255) !=  *tp) {
            tp =  &(tp[1]);
            continue;
        }
        return 1;
    }
    return 0;
}

_editor()
{// addr = 0x0807F8A5  --  defined in 'linein.c' at line 1112
    char* p;                               // _cfa_fffffff0
    char _v48;                             // _cfa_ffffffd0
    struct _Str* _v80;    // _cfa_ffffffb0
    FormItemList fi;   // _cfa_ffffffa8
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    struct _Str* _t53;    // _t53
    struct _Str* _t73;    // _t73
    int _t95;                              // _t95
    int _t99;                              // _t99

    if(is_passwd != 0) {
        goto L16;
    }
    _v48 = 0;
    _v80 = Strdup(strBuf);
    if(_v80->length + 1 >= _v80->area_size) {
        Strgrow(_v80);
    }
    _t53 = _v80;
    _t95 = _t53->length;
    ( *_v80)[_t95] = 10;
    _t53->length = _t95 + 1;
    ( *_v80)[_v80->length] = 0;
    input_textarea( &(fi.type));
    strBuf = Strnew();
    p =  *_v80;
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) != 13) {
            if(( *p & 0xff) != 10) {
                if(strBuf->length + 1 >= strBuf->area_size) {
                    Strgrow(strBuf);
                }
                _t73 = strBuf;
                _t99 = _t73->length;
                 *(strBuf->ptr + _t99) =  *p & 0xff;
                _t73->length = _t99 + 1;
                 *(strBuf->ptr + strBuf->length) = 0;
            }
        }
        p =  &(p[1]);
    }
    CPos = setStrType(strBuf,  &strProp);
    CLen = CPos;
    if(CurrentTab == 0) {
        goto L16;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
L16:
    return;
}

int LUfactor(Matrix A, int* indexarray)
{// addr = 0x0807FA0C  --  defined in 'matrix.c' at line 69
    double mx;                             // _cfa_ffffffcc
    double tmp;                            // _cfa_ffffffc4
    double tmp;                            // _cfa_ffffffbc
    int dim;                               // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int i_max;                             // _cfa_ffffffe0
    int k_max;                             // _cfa_ffffffdc
    Vector scale;       // _cfa_ffffffd8
    int tmp;                               // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    _unknown_ _t185;                       // _t185
    _unknown_ _t193;                       // _t193
    _unknown_ _t202;                       // _t202
    _unknown_ _t206;                       // _t206
    _unknown_ _t207;                       // _t207
    _unknown_ _t217;                       // _t217
    _unknown_ _t221;                       // _t221
    _unknown_ _t222;                       // _t222
    _unknown_ _t227;                       // _t227
    _unknown_ _t233;                       // _t233
    _unknown_ _t237;                       // _t237
    _unknown_ _t238;                       // _t238
    _unknown_ _t240;                       // _t240
    _unknown_ _t244;                       // _t244
    _unknown_ _t245;                       // _t245
    _unknown_ _t258;                       // _t258
    _unknown_ _t262;                       // _t262
    _unknown_ _t263;                       // _t263
    _unknown_ _t265;                       // _t265
    _unknown_ _t271;                       // _t271
    _unknown_ _t275;                       // _t275
    _unknown_ _t276;                       // _t276
    _unknown_ _t278;                       // _t278
    _unknown_ _t282;                       // _t282
    _unknown_ _t283;                       // _t283
    _unknown_ _t285;                       // _t285
    _unknown_ _t289;                       // _t289
    _unknown_ _t290;                       // _t290
    _unknown_ _t291;                       // _t291
    _unknown_ _t292;                       // _t292
    _unknown_ _t293;                       // _t293
    _unknown_ _t294;                       // _t294
    _unknown_ _t295;                       // _t295
    _unknown_ _t296;                       // _t296
    _unknown_ _t304;                       // _t304
    _unknown_ _t306;                       // _t306
    _unknown_ _t310;                       // _t310
    _unknown_ _t311;                       // _t311
    _unknown_ _t313;                       // _t313
    _unknown_ _t317;                       // _t317
    _unknown_ _t318;                       // _t318
    _unknown_ _t320;                       // _t320
    _unknown_ _t326;                       // _t326
    _unknown_ _t328;                       // _t328
    _unknown_ _t329;                       // _t329
    _unknown_ _t330;                       // _t330
    _unknown_ _t331;                       // _t331

    dim = A->dim;
    scale = new_vector(dim);
    i = 0;
    while(i < dim) {
        indexarray[i] = i;
        i = i + 1;
    }
    i = 0;
    while(i < dim) {
        asm("fldz ");
        asm("fstp qword [ebp-0x30]");
        j = 0;
        while(j < dim) {
            asm("fld qword [eax]");
            asm("fabs ");
            asm("fstp qword [ebp-0x38]");
            asm("fld qword [ebp-0x30]");
            asm("fld qword [ebp-0x38]");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((A->me + (A->dim * i + j << 3) & 255) != 0) {
                asm("fld qword [ebp-0x38]");
                asm("fstp qword [ebp-0x30]");
            }
            j = j + 1;
        }
        asm("fld qword [ebp-0x30]");
        asm("fstp qword [eax]");
        i = i + 1;
    }
    k_max = dim - 1;
    k = 0;
    while(k < k_max) {
        asm("fldz ");
        asm("fstp qword [ebp-0x30]");
        i_max = -1;
        i = k;
        while(i < dim) {
            asm("fld qword [eax]");
            asm("fabs ");
            asm("fld qword [eax]");
            asm("fabs ");
            asm("fld qword [0x80d56c0]");
            asm("fmulp st1, st0");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            asm("setnb al");
            if((A->me + (A->dim * i + k << 3) & 255) != 0) {
                asm("fld qword [eax]");
                asm("fabs ");
                asm("fld qword [eax]");
                asm("fdivp st1, st0");
                asm("fstp qword [ebp-0x38]");
                asm("fld qword [ebp-0x30]");
                asm("fld qword [ebp-0x38]");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if(( &(scale->ve[i]) & 255) != 0) {
                    asm("fld qword [ebp-0x38]");
                    asm("fstp qword [ebp-0x30]");
                    i_max = i;
                }
            }
            i = i + 1;
        }
        if(i_max != 255) {
            if(i_max == k) {
L24:
                i = k + 1;
L29:
                while(i < dim) {
                    goto L25;
                }
                goto L30;
            }
            goto L21;
L25:
            asm("fld qword [edx]");
            asm("fld qword [edx]");
            asm("fdivp st1, st0");
            asm("fstp qword [eax]");
            asm("fld qword [eax]");
            asm("fstp qword [ebp-0x38]");
            j = k + 1;
            while(j < dim) {
                asm("fld qword [eax]");
                asm("fld qword [eax]");
                asm("fmul qword [ebp-0x38]");
                asm("fsubp st1, st0");
                asm("fstp qword [edx]");
                j = j + 1;
            }
            i = i + 1;
            goto L29;
        }
        asm("fldz ");
        asm("fstp qword [eax]");
L30:
        k = k + 1;
        continue;
L21:
        tmp = indexarray[i_max];
        indexarray[i_max] = indexarray[k];
        indexarray[k] = tmp;
        j = 0;
        while(j < dim) {
            asm("fld qword [eax]");
            asm("fstp qword [ebp-0x40]");
            asm("fld qword [eax]");
            asm("fstp qword [edx]");
            asm("fld qword [ebp-0x40]");
            asm("fstp qword [eax]");
            j = j + 1;
        }
        goto L24;
    }
    return 0;
}

int LUsolve(Matrix A, int* indexarray, Vector b, Vector x)
{// addr = 0x0807FD68  --  defined in 'matrix.c' at line 128
    int i;                                 // _cfa_fffffff0
    int dim;                               // _cfa_ffffffec
    struct vector* _v52;   // _cfa_ffffffcc
    struct vector* _v56;   // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t30;                        // _t30
    _unknown_ _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t42;                        // _t42
    _unknown_ _t47;                        // _t47
    _unknown_ _t49;                        // _t49
    _unknown_ _t50;                        // _t50

    dim = A->dim;
    i = 0;
    while(i < dim) {
        asm("fld qword [eax]");
        asm("fstp qword [edx]");
        i = i + 1;
    }
    asm("fld1 ");
    asm("fstp qword [esp+0xc]");
    _v52 = x;
    _v56 = x;
     *__esp = A;
    if(Lsolve() == 255) {
L5:
        return -1;
    }
    asm("fldz ");
    asm("fstp qword [esp+0xc]");
    _v52 = x;
    _v56 = x;
     *__esp = A;
    if(Usolve() != 255) {
        return 0;
    }
    goto L5;
    return __eax;
}

Matrix LUinverse(Matrix A, int* indexarray, Matrix out)
{// addr = 0x0807FE0A  --  defined in 'matrix.c' at line 155
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int dim;                               // _cfa_ffffffe8
    Vector tmp;         // _cfa_ffffffe4
    Vector tmp2;        // _cfa_ffffffe0
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t55;                        // _t55
    _unknown_ _t58;                        // _t58
    _unknown_ _t66;                        // _t66
    _unknown_ _t73;                        // _t73
    _unknown_ _t74;                        // _t74
    _unknown_ _t85;                        // _t85

    dim = A->dim;
    if(out == 0) {
        out = new_matrix(dim);
    }
    tmp = new_vector(dim);
    tmp2 = new_vector(dim);
    i = 0;
    while(i < dim) {
        j = 0;
        while(j < dim) {
            asm("fldz ");
            asm("fstp qword [eax]");
            j = j + 1;
        }
        asm("fld1 ");
        asm("fstp qword [eax]");
        if(LUsolve(A, indexarray, tmp, tmp2) != 255) {
            j = 0;
L10:
            while(j < dim) {
                goto L9;
            }
            i = i + 1;
            continue;
        }
        return 0;
L9:
        asm("fld qword [eax]");
        asm("fstp qword [edx]");
        j = j + 1;
        goto L10;
    }
    return out;
}

int Usolve(Matrix mat, Vector b, Vector out, double diag)
{// addr = 0x0807FF0A  --  defined in 'matrix.c' at line 182
    double sum;                            // _cfa_ffffffe4
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int i_lim;                             // _cfa_fffffff0
    int dim;                               // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    _unknown_ _t63;                        // _t63
    _unknown_ _t66;                        // _t66
    _unknown_ _t70;                        // _t70
    _unknown_ _t75;                        // _t75
    _unknown_ _t79;                        // _t79
    _unknown_ _t80;                        // _t80
    _unknown_ _t83;                        // _t83
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87
    signed int _t94;                       // _t94
    _unknown_ _t96;                        // _t96
    _unknown_ _t98;                        // _t98
    _unknown_ _t102;                       // _t102
    _unknown_ _t103;                       // _t103
    _unknown_ _t104;                       // _t104
    _unknown_ _t111;                       // _t111
    _unknown_ _t118;                       // _t118
    _unknown_ _t119;                       // _t119

    _v44 = _a16;
    _v40 = _a20;
    dim = mat->dim;
    i = dim - 1;
    while(i >= 0) {
        asm("fld qword [eax]");
        asm("fldz ");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if(__eflags == 0 && __eflags == 0) {
            asm("fldz ");
            asm("fstp qword [eax]");
            i = i - 1;
            continue;
        }
L7:
        i_lim = i;
        while(i >= 0) {
            asm("fld qword [eax]");
            asm("fstp qword [ebp-0x18]");
            j = i + 1;
            while(1) {
                __eflags = j - i_lim;
                if(__eflags > 0) {
                    break;
                }
                asm("fld qword [eax]");
                asm("fld qword [eax]");
                asm("fmulp st1, st0");
                asm("fld qword [ebp-0x18]");
                asm("fsubrp st1, st0");
                asm("fstp qword [ebp-0x18]");
                j = j + 1;
            }
            asm("fld qword [ebp-0x28]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if(__eflags != 0 || __eflags != 0) {
L16:
                asm("fld qword [ebp-0x18]");
                asm("fdiv qword [ebp-0x28]");
                asm("fstp qword [eax]");
            } else {
                _t94 = mat->me + (mat->dim + 1 << 3) * i;
                asm("fld qword [eax]");
                asm("fabs ");
                asm("fld qword [ebp-0x18]");
                asm("fabs ");
                asm("fld qword [0x80d56c0]");
                asm("fmulp st1, st0");
                asm("fucomip st0, st1");
                asm("fstp st0");
                asm("setnb al");
                __eflags = _t94 & 255;
                if((_t94 & 255) == 0) {
                    asm("fld qword [eax]");
                    asm("fld qword [ebp-0x18]");
                    asm("fdivrp st1, st0");
                    asm("fstp qword [edx]");
                    goto L17;
                }
                return -1;
                goto L16;
            }
L17:
            i = i - 1;
        }
        return 0;
    }
    goto L7;
}

int Lsolve(Matrix mat, Vector b, Vector out, double diag)
{// addr = 0x08080075  --  defined in 'matrix.c' at line 217
    double sum;                            // _cfa_ffffffe4
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int i_lim;                             // _cfa_fffffff0
    int dim;                               // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    _unknown_ _t63;                        // _t63
    _unknown_ _t66;                        // _t66
    _unknown_ _t71;                        // _t71
    _unknown_ _t75;                        // _t75
    _unknown_ _t79;                        // _t79
    _unknown_ _t80;                        // _t80
    _unknown_ _t83;                        // _t83
    _unknown_ _t86;                        // _t86
    signed int _t93;                       // _t93
    _unknown_ _t95;                        // _t95
    _unknown_ _t97;                        // _t97
    _unknown_ _t101;                       // _t101
    _unknown_ _t102;                       // _t102
    _unknown_ _t103;                       // _t103
    _unknown_ _t104;                       // _t104
    _unknown_ _t111;                       // _t111
    _unknown_ _t118;                       // _t118
    _unknown_ _t119;                       // _t119

    _v44 = _a16;
    _v40 = _a20;
    dim = mat->dim;
    i = 0;
    while(i < dim) {
        asm("fld qword [eax]");
        asm("fldz ");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if(__eflags == 0 && __eflags == 0) {
            asm("fldz ");
            asm("fstp qword [eax]");
            i = i + 1;
            continue;
        }
L7:
        i_lim = i;
        while(i < dim) {
            asm("fld qword [eax]");
            asm("fstp qword [ebp-0x18]");
            j = i_lim;
            while(1) {
                __eflags = j - i;
                if(__eflags >= 0) {
                    break;
                }
                asm("fld qword [eax]");
                asm("fld qword [eax]");
                asm("fmulp st1, st0");
                asm("fld qword [ebp-0x18]");
                asm("fsubrp st1, st0");
                asm("fstp qword [ebp-0x18]");
                j = j + 1;
            }
            asm("fld qword [ebp-0x28]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if(__eflags != 0 || __eflags != 0) {
L16:
                asm("fld qword [ebp-0x18]");
                asm("fdiv qword [ebp-0x28]");
                asm("fstp qword [eax]");
            } else {
                _t93 = mat->me + (mat->dim + 1 << 3) * i;
                asm("fld qword [eax]");
                asm("fabs ");
                asm("fld qword [ebp-0x18]");
                asm("fabs ");
                asm("fld qword [0x80d56c0]");
                asm("fmulp st1, st0");
                asm("fucomip st0, st1");
                asm("fstp st0");
                asm("setnb al");
                __eflags = _t93 & 255;
                if((_t93 & 255) == 0) {
                    asm("fld qword [eax]");
                    asm("fld qword [ebp-0x18]");
                    asm("fdivrp st1, st0");
                    asm("fstp qword [edx]");
                    goto L17;
                }
                return -1;
                goto L16;
            }
L17:
            i = i + 1;
        }
        return 0;
    }
    goto L7;
}

Matrix new_matrix(int n)
{// addr = 0x080801DF  --  defined in 'matrix.c' at line 252
    Matrix mat;         // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    double* _t13;                          // _t13

     *__esp = 8;
    GC_malloc();
    mat = __eax;
    mat->dim = n;
    _t13 = n * n << 3;
     *__esp = _t13;
    GC_malloc_atomic();
    mat->me = _t13;
    return mat;
}

Vector new_vector(int n)
{// addr = 0x0808021B  --  defined in 'matrix.c' at line 267
    Vector vec;         // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    double* _t11;                          // _t11

     *__esp = 8;
    GC_malloc();
    vec = __eax;
    vec->dim = n;
    _t11 = n << 3;
     *__esp = _t11;
    GC_malloc_atomic();
    vec->ve = _t11;
    return vec;
}

double weight(int x)
{// addr = 0x08080253  --  defined in 'table.c' at line 70
    double _v16;                           // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    double _t4;                            // _t4
    double _t6;                            // _t6

    _t4 = COLS;
    if(x >= _t4) {
        _v16 = COLS;
        asm("fild dword [ebp-0xc]");
        asm("fstp qword [ebp-0x18]");
        asm("fild dword [ebp+0x8]");
        _t6 = COLS;
        _v16 = _t6;
        asm("fild dword [ebp-0xc]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        log();
        asm("fld1 ");
        asm("faddp st1, st0");
        asm("fmul qword [ebp-0x18]");
        return _t6;
    }
    asm("fild dword [ebp+0x8]");
    return _t4;
}

double weight2(int a)
{// addr = 0x08080297  --  defined in 'table.c' at line 80
    double _v8;                            // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    asm("fild dword [ebp+0x8]");
    __eax = COLS;
    _v8 = __eax;
    asm("fild dword [ebp-0x4]");
    asm("fdivp st1, st0");
    asm("fld qword [0x80cb5c0]");
    asm("fmulp st1, st0");
    asm("fld1 ");
    asm("faddp st1, st0");
    return __eax;
}

int bsearch_2short(short int e1, short int* ent1, short int e2, short int* ent2, int base, short int* indexarray, int nent)
{// addr = 0x080802BB  --  defined in 'table.c' at line 104
    int n;                                 // _cfa_fffffff8
    int k;                                 // _cfa_fffffff4
    int e;                                 // _cfa_fffffff0
    int nn;                                // _cfa_ffffffec
    int idx;                               // _cfa_ffffffe8
    int ne;                                // _cfa_ffffffe4
    signed short _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6

    _v40 = _a4 & 65535;
    _v44 = _a12 & 65535;
    n = nent;
    k = 0;
    e = _v40 * base + _v44;
    while(n > 0) {
        nn = (n >> 31) + n >> 1;
        asm("cwde ");
        idx =  *(k + nn + k + nn + indexarray) & 65535;
        asm("cwde ");
        asm("cwde ");
        ne = ( *(idx + idx + ent1) & 65535) * base + ( *(idx + idx + ent2) & 65535);
        if(ne != e) {
            if(ne >= e) {
                n = nn;
            } else {
                n = n +  !nn;
                k = k + nn + 1;
            }
            continue;
        }
        k = k + nn;
        break;
    }
    return k;
}

int bsearch_double(double e, double* ent, short int* indexarray, int nent)
{// addr = 0x08080377  --  defined in 'table.c' at line 131
    double ne;                             // _cfa_ffffffe4
    int n;                                 // _cfa_fffffff8
    int k;                                 // _cfa_fffffff4
    int nn;                                // _cfa_fffffff0
    int idx;                               // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    signed int _t48;                       // _t48

    _v44 = _a4;
    _v40 = _a8;
    n = nent;
    k = 0;
    while(1) {
        __eflags = n;
        if(__eflags <= 0) {
            break;
        }
        nn = (n >> 31) + n >> 1;
        asm("cwde ");
        idx =  *(k + nn + k + nn + indexarray) & 65535;
        _t48 =  &(ent[idx]);
        asm("fld qword [eax]");
        asm("fstp qword [ebp-0x18]");
        asm("fld qword [ebp-0x18]");
        asm("fld qword [ebp-0x28]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if(__eflags != 0 || __eflags != 0) {
            asm("fld qword [ebp-0x18]");
            asm("fld qword [ebp-0x28]");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            __eflags = _t48 & 255;
            if((_t48 & 255) == 0) {
                n = nn;
            } else {
                n = n +  !nn;
                k = k + nn + 1;
            }
            continue;
        } else {
            k = k + nn;
            break;
        }
    }
    return k;
}

int ceil_at_intervals(int x, int step)
{// addr = 0x0808041A  --  defined in 'table.c' at line 156
    int mo;                                // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    _unknown_ _t28;                        // _t28

    mo = x % step;
    if(mo <= 0) {
        if(mo < 0) {
            x = x - mo;
        }
    } else {
        x = x + step - mo;
    }
    return x;
}

int floor_at_intervals(int x, int step)
{// addr = 0x08080456  --  defined in 'table.c' at line 167
    int mo;                                // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    _unknown_ _t28;                        // _t28

    mo = x % step;
    if(mo <= 0) {
        if(mo < 0) {
            x = x + step - mo;
        }
    } else {
        x = x - mo;
    }
    return x;
}

int table_colspan(struct table* t, int row, int col)
{// addr = 0x08080492  --  defined in 'table.c' at line 221
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    i = col + 1;
    while(t->maxcol >= i && ( *(t->tabattr[row] + i + i) & 1) != 0) {
        i = i + 1;
    }
    return i - col;
}

int table_rowspan(struct table* t, int row, int col)
{// addr = 0x080804E4  --  defined in 'table.c' at line 229
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t44;                        // _t44

    if(t->tabattr[row] == 0) {
        return 0;
    }
    i = row + 1;
    while(t->maxrow >= i && t->tabattr[i] != 0 && ( *(t->tabattr[i] + col + col) & 2) != 0) {
        i = i + 1;
    }
    return i - row;
}

int minimum_cellspacing(int border_mode)
{// addr = 0x08080565  --  defined in 'table.c' at line 240
    _unknown_ __ebp;                       // r6
    int _t2;                               // _t2
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    _t2 = border_mode;
    if(_t2 == 0) {
        return 1;
    }
    if(_t2 >= 0 || _t2 > 3) {
        goto L5;
    }
    return symbol_width;
L5:
    return 0;
}

int table_border_width(struct table* t)
{// addr = 0x0808058D  --  defined in 'table.c' at line 256
    _unknown_ __ebp;                       // r6
    int _t16;                              // _t16
    _unknown_ _t21;                        // _t21

    _t16 = t->border_mode;
    if(_t16 > 2) {
        if(_t16 == 3) {
            goto L7;
        }
        goto L5;
    }
    if(_t16 >= 1) {
        return t->maxcol * t->cellspacing + t->cellpadding + symbol_width + t->cellpadding + symbol_width;
    }
    if(_t16 == 0) {
        goto L7;
    }
L8:
    return 0;
L7:
    return t->cellspacing * t->maxcol;
L5:
    goto L8;
}

struct table* newTable()
{// addr = 0x080805E9  --  defined in 'table.c' at line 272
    struct table* t;     // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct table* _t81;   // _t81
    struct table* _t82;   // _t82
    struct table* _t83;   // _t83
    struct _Str* _t84;    // _t84
    Str* _t85;             // _t85

     *__esp = 716;
    GC_malloc();
    t = __eax;
    _t81 = t;
    _t81->max_rowsize = 50;
     *__esp = 200;
    GC_malloc();
    _t82 = t;
    _t82->tabdata = _t81;
     *__esp = 200;
    GC_malloc();
    _t83 = t;
    _t83->tabattr = _t82;
     *__esp = 100;
    GC_malloc_atomic();
    _t84 = t;
     *(_t84 + 676) = _t83;
     *__esp = 200;
    GC_malloc();
    _t85 = t;
    _t85[0x14] = _t84;
     *__esp = 200;
    GC_malloc();
    t->tridvalue = _t85;
    i = 0;
    while(i <= 49) {
        t->tabdata[i] = 0;
        t->tabattr[i] = 0;
         *(t->tabheight + i + i) = 0;
        t->tabidvalue[i] = 0;
         *(t->tridvalue + (i << 2)) = 0;
        i = i + 1;
    }
    j = 0;
    while(j <= 49) {
         *(t + 8 + (j + 40) * 2) = 0;
         *(t + 12 + (j + 88) * 2) = 0;
         *(t + (j + 144) * 2) = 0;
        j = j + 1;
    }
    t->cell.maxcell = 65535;
    t->cell.icell = 65535;
    t->ntable = 0;
    t->tables_size = 0;
    t->tables = 0;
    t->matrix = 0;
    t->vector = 0;
    t->linfo = Strnew_size(8);
    Strcopy_charp_n(t->linfo, 135049312, 0);
     *(t + 76) = 0;
     *(t + 60) = Strnew();
    t->suspended_data = 0;
     *(t + 64) = 0;
    return t;
}

check_row(struct table* t, int row)
{// addr = 0x080807E9  --  defined in 'table.c' at line 329
    int i;                                 // _cfa_fffffff0
    int r;                                 // _cfa_ffffffec
    GeneralList*** tabdata;   // _cfa_ffffffe8
    table_attr** tabattr;   // _cfa_ffffffe4
    short int* tabheight;                  // _cfa_ffffffe0
    Str** tabidvalue;      // _cfa_ffffffdc
    Str* tridvalue;        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t144;                       // _t144
    GeneralList*** _t147;   // _t147
    table_attr** _t149;   // _t149
    short int* _t151;                      // _t151
    Str** _t153;           // _t153
    Str* _t155;            // _t155
    _unknown_ _t228;                       // _t228

    if(t->max_rowsize <= row) {
        _t228 = row + 1;
        _t144 = t->max_rowsize + t->max_rowsize;
        _t145 = _t228 - _t144 >= 0 ? _t228 : _t144;
        r = _t228 - _t144 >= 0 ? _t228 : _t144;
        _t147 = r << 2;
         *__esp = _t147;
        GC_malloc();
        tabdata = _t147;
        _t149 = r << 2;
         *__esp = _t149;
        GC_malloc();
        tabattr = _t149;
        _t151 = r + r;
         *__esp = _t151;
        GC_malloc_atomic();
        tabheight = _t151;
        _t153 = r << 2;
         *__esp = _t153;
        GC_malloc();
        tabidvalue = _t153;
        _t155 = r << 2;
         *__esp = _t155;
        GC_malloc();
        tridvalue = _t155;
        i = 0;
        while(t->max_rowsize > i) {
            tabdata[i] = t->tabdata[i];
            tabattr[i] = t->tabattr[i];
             *(i + i + tabheight) =  *(t->tabheight + i + i) & 0xffff;
            tabidvalue[i] = t->tabidvalue[i];
             *(tridvalue + (i << 2)) =  *(t->tridvalue + (i << 2));
            i = i + 1;
        }
        while(i < r) {
            tabdata[i] = 0;
            tabattr[i] = 0;
             *(i + i + tabheight) = 0;
            tabidvalue[i] = 0;
             *(tridvalue + (i << 2)) = 0;
            i = i + 1;
        }
        t->tabdata = tabdata;
        t->tabattr = tabattr;
        t->tabheight = tabheight;
        t->tabidvalue = tabidvalue;
        t->tridvalue = tridvalue;
        t->max_rowsize = r;
    }
    if(t->tabdata[row] != 0) {
    } else {
         *__esp = 200;
        GC_malloc();
        t->tabdata[row] = t->tabdata;
         *__esp = 100;
        GC_malloc_atomic();
        t->tabattr[row] = t->tabattr;
         *__esp = 200;
        GC_malloc();
        t->tabidvalue[row] = t->tabidvalue;
        i = 0;
        while(i <= 49) {
            t->tabdata[row][i] = 0;
             *(t->tabattr[row] + i + i) = 0;
            t->tabidvalue[row][i] = 0;
            i = i + 1;
        }
    }
    goto L12;
L13:
L12:
    return;
    goto L13;
}

pushdata(struct table* t, int row, int col, char* data)
{// addr = 0x08080A82  --  defined in 'table.c' at line 394
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    const char* _t29;   // _t29

    check_row(t, row);
    if(t->tabdata[row][col] == 0) {
        t->tabdata[row][col] = newGeneralList();
    }
    if(data == 0) {
        _t29 = 135049312;
    } else {
        _t29 = data;
    }
    pushValue(t->tabdata[row][col], allocStr(_t29, -1));
    return;
}

suspend_or_pushdata(struct table* tbl, char* line)
{// addr = 0x08080B25  --  defined in 'table.c' at line 404
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    const char* _t26;   // _t26

    if((tbl->flag & 4) == 0) {
        if(tbl->suspended_data == 0) {
            tbl->suspended_data = newGeneralList();
        }
        if(line == 0) {
            _t26 = 135049312;
        } else {
            _t26 = line;
        }
        pushValue(tbl->suspended_data, allocStr(_t26, -1));
        return;
    }
    pushdata(tbl, tbl->row, tbl->col, line);
    return;
}

int visible_length(char* str)
{// addr = 0x08080BB3  --  defined in 'table.c' at line 423
    int len;                               // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    int max_len;                           // _cfa_ffffffe8
    int status;                            // _cfa_ffffffe4
    int prev_status;                       // _cfa_ffffffe0
    Str tagbuf;            // _cfa_ffffffdc
    char* t;                               // _cfa_ffffffd8
    char* r2;                              // _cfa_ffffffd4
    int amp_len;                           // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t194;                       // _t194
    int _t206;                             // _t206
    _unknown_ _t229;                       // _t229
    int _t240;                             // _t240
    int _t251;                             // _t251
    _unknown_ _t259;                       // _t259

    len = 0;
    max_len = 0;
    status = 0;
    prev_status = status;
    tagbuf = Strnew();
    amp_len = 0;
    t = str;
    while(( *str & 0xff) != 0) {
        if(status != 1) {
            if(status == 2 || status == 4 || status == 3 || status == 5 || status == 15) {
                Strcat_charp_n(tagbuf, str, n);
            } else {
                if(status != 6) {
                    if(status != 0 || prev_status != 6) {
                        if(status != 0 || prev_status != 2 && prev_status != 1 && prev_status != 5 && prev_status != 15) {
                            if(( *str & 0xff) != 9) {
                                if(( *str & 0xff) == 13 || ( *str & 0xff) == 10) {
                                    len = len - 1;
                                    if(len > max_len) {
                                        max_len = len;
                                    }
                                    len = 0;
                                }
                                goto L42;
                            } else {
                                len = len - 1;
                                goto L35;
                            }
                            while(1) {
L35:
                                len = len + 1;
                                if((visible_length_offset + len) % Tabstop == 0) {
                                    break;
                                }
                            }
                        }
                    } else {
                        Strcat_charp_n(tagbuf, str, n);
                        r2 = tagbuf->ptr;
                        t = getescapecmd( &r2);
                        if(( *r2 & 0xff) != 0 || ( *t & 0xff) != 13 && ( *t & 0xff) != 10) {
                            _t206 = wtf_strwidth(t);
                            len = len + _t206 + wtf_strwidth(r2);
                        } else {
                            if(len > max_len) {
                                max_len = len;
                            }
                            len = 0;
                        }
                    }
                } else {
                    if(prev_status != 0) {
                        Strcat_charp_n(tagbuf, str, n);
                        amp_len = amp_len + 1;
                    } else {
                        Strclear(tagbuf);
                        len = len - 1;
                        amp_len = 0;
                    }
                }
            }
        } else {
            Strclear(tagbuf);
            Strcat_charp_n(tagbuf, str, n);
        }
L42:
        str =  &(str[n]);
    }
    if(status == 6) {
        r2 = tagbuf->ptr;
        t = getescapecmd( &r2);
        if(( *t & 0xff) != 13 && ( *t & 0xff) != 10) {
            _t251 = wtf_strwidth(t);
            len = len + _t251 + wtf_strwidth(r2);
        }
    }
    _t240 = len;
    _t241 = max_len - _t240 >= 0 ? max_len : _t240;
    return max_len - _t240 >= 0 ? max_len : _t240;
}

int visible_length_plain(char* str)
{// addr = 0x08080EB9  --  defined in 'table.c' at line 510
    int len;                               // _cfa_fffffff8
    int max_len;                           // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    signed int _t78;                       // _t78
    _unknown_ _t90;                        // _t90
    int _t92;                              // _t92
    _unknown_ _t95;                        // _t95

    len = 0;
    max_len = 0;
L13:
    while(( *str & 0xff) != 0) {
        if(( *str & 0xff) != 9) {
            if(( *str & 0xff) == 13 || ( *str & 0xff) == 10) {
                if(len > max_len) {
                    max_len = len;
                }
                len = 0;
                str =  &(str[1]);
            } else {
                if(( *135119023 & 0xff) == 0) {
                    _t78 =  *( &WTF_WIDTH_MAP + ( *str & 0xff)) & 0xff;
                } else {
                    _t78 =  *( &WTF_WIDTH_MAP + ( *str & 0xff)) & 0xff;
                }
                len = len + _t78;
                str =  &(str[ *( &WTF_LEN_MAP + ( *str & 0xff)) & 0xff]);
            }
            continue;
        } else {
            goto L2;
        }
        while(1) {
L2:
            len = len + 1;
            if((visible_length_offset + len) % Tabstop != 0) {
                continue;
            } else {
                str =  &(str[1]);
                goto L13;
            }
        }
    }
    _t92 = len;
    _t93 = max_len - _t92 >= 0 ? max_len : _t92;
    return max_len - _t92 >= 0 ? max_len : _t92;
}

int maximum_visible_length(char* str, int offset)
{// addr = 0x08080F9E  --  defined in 'table.c' at line 541
    _unknown_ __ebp;                       // r6

    visible_length_offset = offset;
    return visible_length(str);
}

int maximum_visible_length_plain(char* str, int offset)
{// addr = 0x08080FB9  --  defined in 'table.c' at line 548
    _unknown_ __ebp;                       // r6

    visible_length_offset = offset;
    return visible_length_plain(str);
}

align(TextLine* lbuf, int width, int mode)
{// addr = 0x08080FD4  --  defined in 'table.c' at line 555
    int i;                                 // _cfa_fffffff0
    int l;                                 // _cfa_ffffffec
    int l1;                                // _cfa_ffffffe8
    int l2;                                // _cfa_ffffffe4
    Str buf;               // _cfa_ffffffe0
    Str line;              // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t158;                             // _t158
    int _t168;                             // _t168
    int _t187;                             // _t187
    int _t208;                             // _t208
    int _t224;                             // _t224
    int _t238;                             // _t238

    line = lbuf->line;
    if(line->length == 0) {
        i = 0;
        while(i < width) {
            if(line->length + 1 >= line->area_size) {
                Strgrow(line);
            }
            _t238 = line->length;
             *((char*)(line->ptr + _t238)) = 32;
            line->length = _t238 + 1;
             *(line->ptr + line->length) = 0;
            i = i + 1;
        }
        lbuf->pos = width & 65535;
        return;
    }
    buf = Strnew();
    asm("cwde ");
    l = width - (lbuf->pos & 65535);
    _t158 = mode;
    if(_t158 == 1) {
        Strcat(buf, line);
        i = 0;
        while(i < l) {
            if(buf->length + 1 >= buf->area_size) {
                Strgrow(buf);
            }
            _t168 = buf->length;
             *((char*)(buf->ptr + _t168)) = 32;
            buf->length = _t168 + 1;
             *(buf->ptr + buf->length) = 0;
            i = i + 1;
        }
L33:
        lbuf->line = buf;
        asm("cwde ");
        if((lbuf->pos & 65535) >= width) {
        } else {
            lbuf->pos = width & 65535;
            return;
        }
        goto L36;
L37:
    }
    if(_t158 == 2) {
        i = 0;
        while(i < l) {
            if(buf->length + 1 >= buf->area_size) {
                Strgrow(buf);
            }
            _t187 = buf->length;
             *((char*)(buf->ptr + _t187)) = 32;
            buf->length = _t187 + 1;
             *(buf->ptr + buf->length) = 0;
            i = i + 1;
        }
        Strcat(buf, line);
        goto L33;
    }
    if(_t158 != 0) {
    } else {
        l1 = (l >> 31) + l >> 1;
        l2 = l - l1;
        i = 0;
        while(i < l1) {
            if(buf->length + 1 >= buf->area_size) {
                Strgrow(buf);
            }
            _t208 = buf->length;
             *((char*)(buf->ptr + _t208)) = 32;
            buf->length = _t208 + 1;
             *(buf->ptr + buf->length) = 0;
            i = i + 1;
        }
        Strcat(buf, line);
        i = 0;
        while(i < l2) {
            if(buf->length + 1 >= buf->area_size) {
                Strgrow(buf);
            }
            _t224 = buf->length;
             *((char*)(buf->ptr + _t224)) = 32;
            buf->length = _t224 + 1;
             *(buf->ptr + buf->length) = 0;
            i = i + 1;
        }
        goto L33;
    }
L36:
    return;
    goto L37;
}

print_item(struct table* t, int row, int col, int width, Str buf)
{// addr = 0x08081299  --  defined in 'table.c' at line 597
    int alignment;                         // _cfa_fffffff0
    TextLine* lbuf;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(t->tabdata[row] == 0) {
        lbuf = 0;
    } else {
        lbuf = popValue(t->tabdata[row][col]);
    }
    if(lbuf == 0) {
        lbuf = newTextLine(0, 0);
        align(lbuf, width, 0);
        Strcat(buf, lbuf->line);
        return;
    } else {
        check_row(t, row);
        alignment = 0;
        if(( *(t->tabattr[row] + col + col) & 0x30) != 0) {
            if(( *(t->tabattr[row] + col + col) & 0x30) != 32) {
                if(( *(t->tabattr[row] + col + col) & 0x30) == 16) {
                    alignment = 0;
                }
            } else {
                alignment = 2;
            }
        } else {
            alignment = 1;
        }
        align(lbuf, width, alignment);
        Strcat(buf, lbuf->line);
        return;
    }
    return;
}

print_sep(struct table* t, int row, int type, int maxcol, Str buf)
{// addr = 0x08081401  --  defined in 'table.c' at line 632
    int forbid;                            // _cfa_fffffff0
    int rule_mode;                         // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int l;                                 // _cfa_ffffffe0
    int m;                                 // _cfa_ffffffdc
    int w;                                 // _cfa_ffffffd8
    int _v48;                              // _cfa_ffffffd0
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    char _t265;                            // _t265
    char _t301;                            // _t301
    char _t380;                            // _t380
    char _t387;                            // _t387
    int _t399;                             // _t399
    int _t418;                             // _t418
    int _t441;                             // _t441
    _unknown_ _t457;                       // _t457
    _unknown_ _t458;                       // _t458
    int _t459;                             // _t459

    if(row < 0) {
        check_row(t, row);
    }
    check_row(t, row + 1);
    if(type == 0 || type == 2) {
        if(t->border_mode != 2) {
            goto L6;
        } else {
            rule_mode = 2;
        }
L7:
        forbid = 1;
        if(type != 0) {
            if(type != 2) {
                if(( *(t->tabattr[row + 1]) & 2) != 0) {
                    forbid = forbid | 4;
                }
            } else {
                forbid = forbid | 8;
            }
        } else {
            forbid = forbid | 2;
        }
        if(t->border_mode != 3) {
            _t459 = symbol_width;
            if(t->border_mode != 2) {
                _t387 = forbid & 255;
            } else {
                _t387 = forbid + 16 & 255;
            }
            push_symbol(buf, _t387, _t459, 1);
        }
        i = 0;
        while(i <= maxcol) {
            forbid = 10;
            if(type == 2 || ( *(t->tabattr[row + 1] + i + i) & 2) == 0) {
                w = ( *(t + 8 + (i + 40) * 2) & 0xffff) + t->cellpadding + t->cellpadding;
                if(symbol_width == 2) {
                    _v48 = symbol_width;
                    w = (w + 1) / _v48;
                }
                _t399 = symbol_width;
                if(rule_mode != 2) {
                    _t265 = forbid & 255;
                } else {
                    _t265 = forbid + 16 & 255;
                }
                push_symbol(buf, _t265, _t399, w);
L39:
                if(i < maxcol) {
                    forbid = 0;
                    if(type != 0) {
                        if(( *(t->tabattr[row] + i + 1 + i + 1) & 1) != 0) {
                            forbid = forbid | 2;
                        }
                    } else {
                        forbid = forbid | 2;
                    }
                    if(type != 2) {
                        if(( *(t->tabattr[row + 1] + i + 1 + i + 1) & 1) != 0) {
                            forbid = forbid | 8;
                        }
                        if(( *(t->tabattr[row + 1] + i + 1 + i + 1) & 2) != 0) {
                            forbid = forbid | 4;
                        }
                        if(( *(t->tabattr[row + 1] + i + i) & 2) != 0) {
                            forbid = forbid | 1;
                        }
                    } else {
                        forbid = forbid | 8;
                    }
                    if(forbid != 15) {
                        _t441 = symbol_width;
                        if(rule_mode != 2) {
                            _t301 = forbid & 255;
                        } else {
                            _t301 = forbid + 16 & 255;
                        }
                        push_symbol(buf, _t301, _t441, 1);
                    }
                }
                i = i + 1;
                continue;
            }
            if(( *(t->tabattr[row + 1] + i + i) & 1) != 0) {
                goto L39;
            }
            k = row;
            while(k < 0 && t->tabattr[k] != 0 && ( *(t->tabattr[k] + i + i) & 2) != 0) {
                k = k - 1;
            }
            m = ( *(t + 8 + (i + 40) * 2) & 0xffff) + t->cellpadding + t->cellpadding;
            l = i + 1;
            while(t->maxcol >= l && ( *(t->tabattr[row] + l + l) & 1) != 0) {
                m = m + ( *(t + 8 + (l + 40) * 2) & 0xffff) + t->cellspacing;
                l = l + 1;
            }
            print_item(t, k, i, m, buf);
            goto L39;
        }
        forbid = 4;
        if(type == 0) {
            forbid = forbid | 2;
        }
        if(type == 2) {
            forbid = forbid | 8;
        }
        if(( *(t->tabattr[row + 1] + maxcol + maxcol) & 2) != 0) {
            forbid = forbid | 1;
        }
        if(t->border_mode == 3) {
            return;
        } else {
            _t418 = symbol_width;
            if(t->border_mode != 2) {
                _t380 = forbid & 255;
            } else {
                _t380 = forbid + 16 & 255;
            }
            push_symbol(buf, _t380, _t418, 1);
            return;
        }
    }
L6:
    rule_mode = 1;
    goto L7;
}

int get_spec_cell_width(struct table* tbl, int row, int col)
{// addr = 0x08081881  --  defined in 'table.c' at line 719
    int i;                                 // _cfa_fffffff0
    int w;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    w =  *(tbl + 8 + (col + 40) * 2) & 65535;
    i = col + 1;
    while(tbl->maxcol >= i) {
        check_row(tbl, row);
        if(( *(tbl->tabattr[row] + i + i) & 1) != 0) {
            w = w + ( *(tbl + 8 + (i + 40) * 2) & 0xffff) + tbl->cellspacing;
            i = i + 1;
            continue;
        }
L6:
        return w;
    }
    goto L6;
}

do_refill(struct table* tbl, int row, int col, int maxlimit)
{// addr = 0x0808190E  --  defined in 'table.c' at line 735
    TextList* orgdata;   // _cfa_ffffffe0
    TextListItem* l;   // _cfa_ffffffdc
    int colspan;                           // _cfa_ffffffd8
    int icell;                             // _cfa_ffffffd4
    int id;                                // _cfa_ffffffd0
    char* p;                               // _cfa_ffffffcc
    struct parsed_tag* tag;   // _cfa_ffffffc8
    int alignment;                         // _cfa_ffffffc4
    TextLineListItem* ti;   // _cfa_ffffffc0
    struct table* t;     // _cfa_ffffffbc
    int limit;                             // _cfa_ffffffb8
    int rowspan;                           // _cfa_ffffffb4
    struct table_cell* cell;   // _cfa_ffffffb0
    int k;                                 // _cfa_ffffffac
    struct html_feed_environ h_env;   // _cfa_ffffff7c
    struct environment[19] envs;   // _cfa_fffffe3c
    struct readbuffer obuf;   // _cfa_fffffcec
    _unknown_ _v804;                       // _cfa_fffffcdc
    _unknown_ _v808;                       // _cfa_fffffcd8
    _unknown_ _v812;                       // _cfa_fffffcd4
    _unknown_ _v816;                       // _cfa_fffffcd0
    _unknown_ _v820;                       // _cfa_fffffccc
    _unknown_ _v824;                       // _cfa_fffffcc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t445;                       // _t445
    _unknown_ _t473;                       // _t473

    if( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) == 0) {
        return;
    }
    if( *( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) + (col << 2)) == 0) {
        goto L56;
    } else {
        orgdata =  *( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) + (col << 2));
         *( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) + (col << 2)) = newGeneralList();
        init_henv( &(h_env.obuf),  &(obuf.line),  &envs, 20,  *( *((intOrPtr*)(tbl->tabdata.col + (row << 2))) + (col << 2)), get_spec_cell_width(tbl, row, col), 0);
        obuf.flag = obuf.flag | 131072;
        if(_v116 > maxlimit) {
            h_env.limit = maxlimit;
        }
        if(tbl->border_mode.col != 0) {
            if(tbl->vcellpadding.col > 0) {
                do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
            }
        }
        l = orgdata->first;
        while(l != 0) {
            if(strncasecmp(l->ptr, "<table_alt", 10) != 0 || (l->ptr->prev & 0xff) != 62 && ( *( &MYCTYPE_MAP + (l->ptr->prev & 0xff)) & 2) == 0) {
                HTMLlineproc0(l->ptr,  &(h_env.obuf), 1);
            } else {
                id = -1;
                p = l->ptr;
                tag = parse_tag( &p, 1);
                if(tag != 0) {
                    parsedtag_get_value(tag, 64,  &id);
                }
                if(id >= 0) {
                    goto L32;
                }
                if((tbl->ntable.col & 0xffff) > id) {
                    t =  *(tbl->tables.col + (id << 4));
                    limit = ((tbl->tables.col + (id << 4))[2] & 0xffff) + t->total_width;
                     *(tbl->tables.col + (id << 4)) = 0;
                    save_fonteffect( &(h_env.obuf), h_env.obuf);
                    flushline( &(h_env.obuf),  &(obuf.line), 0, 2, h_env.limit);
                    if(t->vspace > 0 && (_v776 & 8192) == 0) {
                        do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
                    }
                    if((h_env.obuf->flag & 112) != 32) {
                        if((h_env.obuf->flag & 112) != 64) {
                            alignment = 1;
                        } else {
                            alignment = 2;
                        }
                    } else {
                        alignment = 0;
                    }
                    if(alignment == 1) {
L27:
                        appendGeneralList(h_env.buf, (tbl->tables.col + (id << 4))[3]);
                        if(_v112 < limit) {
                            h_env.maxlimit = limit;
                        }
                        restore_fonteffect( &(h_env.obuf), h_env.obuf);
                        obuf.flag = obuf.flag;
                        h_env.blank_lines = 0;
                        if(t->vspace > 0) {
                            do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
                            obuf.flag = obuf.flag;
                        }
L35:
                        l = l->next;
                        continue;
                    }
                    ti =  *((tbl->tables.col + (id << 4))[3]);
                    while(ti != 0) {
                        align(ti->ptr, h_env.limit, alignment);
                        ti = ti->next;
                    }
                    goto L27;
                }
            }
            goto L35;
L32:
            goto L35;
        }
        if(_v728 != 0) {
            obuf.status = 7;
            HTMLlineproc0("\n",  &(h_env.obuf), 1);
        }
        completeHTMLstream( &(h_env.obuf),  &(obuf.line));
        flushline( &(h_env.obuf),  &(obuf.line), 0, 2, h_env.limit);
        if(tbl->border_mode.col != 0) {
            if(tbl->vcellpadding.col <= 0) {
                purgeline( &(h_env.obuf));
            } else {
                if((_v776 & 8192) == 0) {
                    do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
                }
            }
        } else {
            rowspan = table_rowspan(tbl, row, col);
            if(row + rowspan > tbl->maxrow.col) {
                if(tbl->vspace.col > 0) {
                    purgeline( &(h_env.obuf));
                }
            } else {
                if(tbl->vcellpadding.col > 0 && (_v776 & 8192) == 0) {
                    do_blankline( &(h_env.obuf),  &(obuf.line), 0, 0, h_env.limit);
                }
            }
        }
        colspan = table_colspan(tbl, row, col);
        if(colspan <= 1) {
            if(( *(tbl + 12 + (col + 88) * 2) & 0xffff) >= _v112) {
                goto L57;
            }
        } else {
            cell =  &(tbl->cell);
            asm("cwde ");
            asm("cwde ");
            k = bsearch_2short(colspan,  &(cell->colspan), col & 65535, cell, 50,  &(cell->index), (cell->maxcell & 65535) + 1);
            asm("cwde ");
            icell =  *(cell + (k + 40) * 2) & 65535;
            if(( *(cell + 14 + (icell + 96) * 2) & 0xffff) >= _v112) {
                goto L57;
            }
             *(cell + 14 + (icell + 96) * 2) = h_env.maxlimit & 65535;
            return;
        }
         *(tbl + 12 + (col + 88) * 2) = h_env.maxlimit & 65535;
        return;
    }
L57:
    return;
L56:
    goto L57;
}

int table_rule_width(struct table* t)
{// addr = 0x08081FAE  --  defined in 'table.c' at line 842
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6

    if(t->border_mode != 0) {
        return symbol_width;
    }
    return 1;
}

check_cell_width(short int* tabwidth, short int* cellwidth, short int* col, short int* colspan, short int maxcell, short int* indexarray, int space, int dir)
{// addr = 0x08081FC9  --  defined in 'table.c' at line 850
    int i;                                 // _cfa_fffffff4
    int j;                                 // _cfa_fffffff0
    int k;                                 // _cfa_ffffffec
    int bcol;                              // _cfa_ffffffe8
    int ecol;                              // _cfa_ffffffe4
    int swidth;                            // _cfa_ffffffe0
    int width;                             // _cfa_ffffffdc
    int w;                                 // _cfa_ffffffd8
    int r;                                 // _cfa_ffffffd4
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t149;                       // _t149
    _unknown_ _t164;                       // _t164
    _unknown_ _t166;                       // _t166
    _unknown_ _t175;                       // _t175
    _unknown_ _t176;                       // _t176
    _unknown_ _t179;                       // _t179

    _v60 = _a20 & 65535;
    k = 0;
    while(_v60 >= k) {
        asm("cwde ");
        j =  *(k + k + indexarray) & 65535;
        if(( *(j + j + cellwidth) & 0xffff) <= 0) {
            goto L17;
        }
        asm("cwde ");
        bcol =  *(j + j + col) & 65535;
        asm("cwde ");
        ecol = ( *(j + j + colspan) & 65535) + bcol;
        swidth = 0;
        i = bcol;
        while(i < ecol) {
            asm("cwde ");
            swidth = swidth + ( *(i + i + tabwidth) & 65535);
            i = i + 1;
        }
        asm("cwde ");
        width = ( *(j + j + cellwidth) & 0xffff) + (1 - ( *(j + j + colspan) & 65535)) * space;
        if(width <= swidth) {
            goto L17;
        }
        asm("cwde ");
        _v68 =  *(j + j + colspan) & 65535;
        w = (width - swidth) / _v68;
        asm("cwde ");
        _v64 =  *(j + j + colspan) & 65535;
        r = (width - swidth) % _v64;
        i = bcol;
        while(i < ecol) {
             *(i + i + tabwidth) = ( *(i + i + tabwidth) & 65535) + w & 65535;
            i = i + 1;
        }
        if(dir == 1 && r > 0) {
            asm("cwde ");
            r =  *(j + j + colspan) & 65535;
        }
        i = 1;
        while(i <= r) {
             *(ecol - i + ecol - i + tabwidth) = ( *(ecol - i + ecol - i + tabwidth) & 65535) + 1 & 65535;
            i = i + 1;
        }
L17:
        k = k + 1;
    }
    return;
}

check_minimum_width(struct table* t, short int* tabwidth)
{// addr = 0x0808216A  --  defined in 'table.c' at line 883
    int i;                                 // _cfa_ffffffec
    struct table_cell* cell;   // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    cell =  &(t->cell);
    i = 0;
    while(t->maxcol >= i) {
        if(( *(i + i + tabwidth) & 0xffff) < ( *(t + 12 + (i + 88) * 2) & 0xffff)) {
             *(i + i + tabwidth) =  *(t + 12 + (i + 88) * 2) & 0xffff;
        }
        i = i + 1;
    }
    check_cell_width(tabwidth,  &(cell->minimum_width), cell,  &(cell->colspan), cell->maxcell & 0xffff,  &(cell->index), t->cellspacing, 0);
    return;
}

check_maximum_width(struct table* t)
{// addr = 0x08082228  --  defined in 'table.c' at line 898
    struct table_cell* cell;   // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4
    int j;                                 // _cfa_fffffff0
    int bcol;                              // _cfa_ffffffec
    int ecol;                              // _cfa_ffffffe8
    int swidth;                            // _cfa_ffffffe4
    int width;                             // _cfa_ffffffe0
    _unknown_ __ebp;                       // r6
    _unknown_ _t105;                       // _t105

    cell =  &(t->cell);
    cell->necell = 0;
    j = 0;
    while(1) {
        asm("cwde ");
        if((cell->maxcell & 65535) < j) {
            break;
        }
        asm("cwde ");
        bcol =  *(cell + j * 2) & 65535;
        asm("cwde ");
        ecol = ( *(cell + 8 + (j + 16) * 2) & 65535) + bcol;
        swidth = 0;
        i = bcol;
        while(i < ecol) {
            asm("cwde ");
            swidth = swidth + ( *(t + 8 + (i + 40) * 2) & 65535);
            i = i + 1;
        }
        asm("cwde ");
        width = ( *(cell + 6 + (j + 80) * 2) & 0xffff) + t->cellspacing * (1 - ( *(cell + 8 + (j + 16) * 2) & 65535));
        if(width > swidth) {
             *(cell + 12 + ((cell->necell & 0xffff) + 56) * 2) = j & 65535;
            cell->necell = (cell->necell & 65535) + 1 & 65535;
        }
        j = j + 1;
    }
    return;
}

set_integered_width(struct table* t, double* dwidth, short int* iwidth)
{// addr = 0x0808232A  --  defined in 'table.c' at line 929
    double sum;                            // _cfa_ffffff8c
    double x;                              // _cfa_ffffff84
    double nsum;                           // _cfa_ffffff7c
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int n;                                 // _cfa_ffffffe4
    int bcol;                              // _cfa_ffffffe0
    int ecol;                              // _cfa_ffffffdc
    int step;                              // _cfa_ffffffd8
    short int* indexarray;                 // _cfa_ffffffd4
    char* fixed;                           // _cfa_ffffffd0
    double* mod;                           // _cfa_ffffffcc
    struct table_cell* cell;   // _cfa_ffffffc8
    int rulewidth;                         // _cfa_ffffffc4
    int ii;                                // _cfa_ffffffc0
    int nn;                                // _cfa_ffffffbc
    char* idx;                             // _cfa_ffffffb8
    int ii;                                // _cfa_ffffffb4
    int ii;                                // _cfa_ffffffb0
    int kk;                                // _cfa_ffffffac
    int w;                                 // _cfa_ffffffa8
    int width;                             // _cfa_ffffffa4
    int m;                                 // _cfa_ffffffa0
    int ii;                                // _cfa_ffffff9c
    int ii;                                // _cfa_ffffff98
    int ii;                                // _cfa_ffffff94
    _unknown_ _v144;                       // _cfa_ffffff70
    _unknown_ _v146;                       // _cfa_ffffff6e
    _unknown_ _v148;                       // _cfa_ffffff6c
    _unknown_ _v150;                       // _cfa_ffffff6a
    _unknown_ _v172;                       // _cfa_ffffff54
    _unknown_ _v176;                       // _cfa_ffffff50
    _unknown_ _v180;                       // _cfa_ffffff4c
    _unknown_ _v184;                       // _cfa_ffffff48
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    short int* _t391;                      // _t391
    double* _t395;                         // _t395
    _unknown_ _t402;                       // _t402
    _unknown_ _t408;                       // _t408
    _unknown_ _t413;                       // _t413
    _unknown_ _t429;                       // _t429
    _unknown_ _t434;                       // _t434
    _unknown_ _t449;                       // _t449
    _unknown_ _t481;                       // _t481
    _unknown_ _t581;                       // _t581
    _unknown_ _t617;                       // _t617
    _unknown_ _t649;                       // _t649

    asm("fldz ");
    asm("fstp qword [ebp-0x70]");
    asm("fldz ");
    asm("fstp qword [ebp-0x78]");
    cell =  &(t->cell);
    rulewidth = table_rule_width(t);
    _t391 = t->maxcol + 1 + t->maxcol + 1;
     *__esp = _t391;
    GC_malloc_atomic();
    indexarray = _t391;
    _t395 = t->maxcol + 1 << 3;
     *__esp = _t395;
    GC_malloc_atomic();
    mod = _t395;
    i = 0;
    while() {
    }
}

double correlation_coefficient(double sxx, double syy, double sxy)
{// addr = 0x08082A0A  --  defined in 'table.c' at line 1051
    double coe;                            // _cfa_ffffffec
    double tmp;                            // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    double _v48;                           // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ __ebp;                       // r6
    double _t29;                           // _t29
    signed int _t31;                       // _t31

    _v36 = _a4;
    _v32 = _a8;
    _v44 = _a12;
    _v40 = _a16;
    _v52 = _a20;
    _t29 = _a24;
    _v48 = _t29;
    asm("fld qword [ebp-0x20]");
    asm("fmul qword [ebp-0x28]");
    asm("fstp qword [ebp-0x18]");
    asm("fld qword [0x80d56c0]");
    asm("fld qword [ebp-0x18]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    _t31 = _t29 & 255;
    if(_t31 != 0) {
        asm("fld qword [0x80d56c0]");
        asm("fstp qword [ebp-0x18]");
    }
    asm("fld qword [ebp-0x18]");
    asm("fsqrt ");
    asm("fucomi st0, st0");
    if(_t31 != 0) {
        asm("fstp st0");
    } else {
        if(_t31 == 0) {
L7:
            asm("fld qword [ebp-0x30]");
            asm("fdivrp st1, st0");
            asm("fstp qword [ebp-0x10]");
            asm("fld qword [ebp-0x10]");
            asm("fld1 ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t29 & 255) == 0) {
                asm("fld qword [ebp-0x10]");
                asm("fld1 ");
                asm("fchs ");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t29 & 255) == 0) {
                    asm("fld qword [ebp-0x10]");
                    return _t29;
                }
                goto L10;
            }
            goto L8;
L10:
            asm("fld1 ");
            asm("fchs ");
            return _t29;
        }
        asm("fstp st0");
        goto L6;
L8:
        asm("fld1 ");
        return _t29;
    }
L6:
    asm("fld qword [ebp-0x18]");
    asm("fstp qword [esp]");
    sqrt();
    goto L7;
}

double correlation_coefficient2(double sxx, double syy, double sxy)
{// addr = 0x08082AB3  --  defined in 'table.c' at line 1066
    double coe;                            // _cfa_ffffffec
    double tmp;                            // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    double _v48;                           // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ __ebp;                       // r6
    double _t29;                           // _t29

    _v36 = _a4;
    _v32 = _a8;
    _v44 = _a12;
    _v40 = _a16;
    _v52 = _a20;
    _t29 = _a24;
    _v48 = _t29;
    asm("fld qword [ebp-0x28]");
    asm("fadd qword [ebp-0x20]");
    asm("fld qword [ebp-0x30]");
    asm("fld qword [0x80cb5d8]");
    asm("fmulp st1, st0");
    asm("faddp st1, st0");
    asm("fmul qword [ebp-0x20]");
    asm("fstp qword [ebp-0x18]");
    asm("fld qword [0x80d56c0]");
    asm("fld qword [ebp-0x18]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t29 & 255) != 0) {
        asm("fld qword [0x80d56c0]");
        asm("fstp qword [ebp-0x18]");
    }
    asm("fld qword [ebp-0x20]");
    asm("fsub qword [ebp-0x30]");
    asm("fstp qword [ebp-0x38]");
    asm("fld qword [ebp-0x18]");
    asm("fstp qword [esp]");
    sqrt();
    asm("fdivr qword [ebp-0x38]");
    asm("fstp qword [ebp-0x10]");
    asm("fld qword [ebp-0x10]");
    asm("fld1 ");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t29 & 255) == 0) {
        asm("fld qword [ebp-0x10]");
        asm("fld1 ");
        asm("fchs ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t29 & 255) == 0) {
            asm("fld qword [ebp-0x10]");
            return _t29;
        }
    } else {
        asm("fld1 ");
        return _t29;
    }
    asm("fld1 ");
    asm("fchs ");
    return _t29;
}

double recalc_width(double old, double swidth, int cwidth, double sxx, double syy, double sxy, int is_inclusive)
{// addr = 0x08082B62  --  defined in 'table.c' at line 1081
    double delta;                          // _cfa_ffffffec
    double rat;                            // _cfa_ffffffe4
    double coe;                            // _cfa_ffffffdc
    double w;                              // _cfa_ffffffd4
    double ww;                             // _cfa_ffffffcc
    double wmin;                           // _cfa_ffffffc4
    double coe1;                           // _cfa_ffffffbc
    double wmin;                           // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    intOrPtr _v108;                        // _cfa_ffffff94
    signed int _v112;                      // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    _unknown_ __ebp;                       // r6
    signed int _t79;                       // _t79

    _v84 = _a4;
    _v80 = _a8;
    _v92 = _a12;
    _v88 = _a16;
    _v100 = _a24;
    _v96 = _a28;
    _v108 = _a32;
    _v104 = _a36;
    _v116 = _a40;
    _t79 = _a44;
    _v112 = _t79;
    asm("fild dword [ebp+0x18]");
    asm("fld qword [ebp-0x58]");
    asm("fsubrp st1, st0");
    asm("fstp qword [ebp-0x10]");
    asm("fld qword [ebp-0x70]");
    asm("fdiv qword [ebp-0x60]");
    asm("fstp qword [ebp-0x18]");
    asm("fld qword [ebp-0x70]");
    asm("fstp qword [esp+0x10]");
    asm("fld qword [ebp-0x68]");
    asm("fstp qword [esp+0x8]");
    asm("fld qword [ebp-0x60]");
    asm("fstp qword [esp]");
    correlation_coefficient();
    asm("fstp qword [ebp-0x20]");
    asm("fld qword [ebp-0x50]");
    asm("fldz ");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t79 & 255) != 0) {
        asm("fldz ");
        asm("fstp qword [ebp-0x50]");
    }
    asm("fld qword [ebp-0x20]");
    asm("fabs ");
    asm("fld qword [0x80cb5e0]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t79 & 255) == 0) {
        asm("fld qword [ebp-0x18]");
        asm("fmul qword [ebp-0x50]");
        asm("fstp qword [ebp-0x28]");
        asm("fld qword [ebp-0x10]");
        asm("fstp qword [ebp-0x30]");
        asm("fld qword [ebp-0x28]");
        asm("fldz ");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t79 & 255) == 0) {
            asm("fld qword [ebp-0x68]");
            asm("fstp qword [esp]");
            sqrt();
            asm("fld qword [0x80cb5e8]");
            asm("fmulp st1, st0");
            asm("fld qword [ebp-0x20]");
            asm("fabs ");
            asm("fmulp st1, st0");
            asm("fstp qword [ebp-0x48]");
            asm("fld qword [ebp-0x18]");
            asm("fld qword [0x80cb608]");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t79 & 255) == 0) {
                asm("fld qword [ebp-0x48]");
                asm("fld qword [0x80cb610]");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t79 & 255) != 0) {
                    asm("fld qword [0x80cb610]");
                    asm("fstp qword [ebp-0x48]");
                }
                asm("fld qword [ebp-0x30]");
                asm("fldz ");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t79 & 255) != 0) {
                    asm("fldz ");
                    asm("fstp qword [ebp-0x30]");
                }
                asm("fld qword [ebp-0x30]");
                asm("fsub qword [ebp-0x48]");
                asm("fstp qword [ebp-0x30]");
L23:
                asm("fld qword [ebp-0x28]");
                asm("fld qword [ebp-0x30]");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t79 & 255) == 0) {
                    asm("fld qword [ebp-0x50]");
                    return _t79;
                }
                asm("fld qword [ebp-0x30]");
                asm("fdiv qword [ebp-0x18]");
                return _t79;
            }
            goto L17;
        }
        goto L5;
L17:
        asm("fld qword [ebp-0x50]");
        return _t79;
    }
    asm("fld qword [ebp-0x50]");
    return _t79;
L5:
    asm("fld qword [ebp-0x20]");
    asm("fmul qword [ebp-0x20]");
    asm("fld1 ");
    asm("fsubrp st1, st0");
    asm("fmul qword [ebp-0x68]");
    asm("fstp qword [esp]");
    sqrt();
    asm("fld qword [0x80cb5e8]");
    asm("fmulp st1, st0");
    asm("fstp qword [ebp-0x38]");
    asm("fld qword [ebp-0x58]");
    asm("fld qword [0x80cb5f0]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t79 & 255) == 0 || cwidth <= 0 || is_inclusive == 0) {
L11:
        asm("fld qword [ebp-0x38]");
        asm("fld qword [0x80cb600]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t79 & 255) != 0) {
            asm("fld qword [0x80cb600]");
            asm("fstp qword [ebp-0x38]");
        }
        asm("fld qword [ebp-0x30]");
        asm("fldz ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t79 & 255) != 0) {
            asm("fldz ");
            asm("fstp qword [ebp-0x30]");
        }
        asm("fld qword [ebp-0x30]");
        asm("fadd qword [ebp-0x38]");
        asm("fstp qword [ebp-0x30]");
        goto L23;
    }
    asm("fld qword [ebp-0x70]");
    asm("fstp qword [esp+0x10]");
    asm("fld qword [ebp-0x68]");
    asm("fstp qword [esp+0x8]");
    asm("fld qword [ebp-0x60]");
    asm("fstp qword [esp]");
    correlation_coefficient2();
    asm("fstp qword [ebp-0x40]");
    asm("fld qword [ebp-0x20]");
    asm("fld qword [0x80cb5f8]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t79 & 255) != 0) {
L10:
        asm("fldz ");
        return _t79;
    }
    asm("fld qword [ebp-0x40]");
    asm("fld qword [0x80cb5f8]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t79 & 255) == 0) {
        goto L11;
    }
    goto L10;
}

int check_compressible_cell(struct table* t, MAT* minv, double* newwidth, double* swidth, short int* cwidth, double totalwidth, double* Sxx, int icol, int icell, double sxx, int corr)
{// addr = 0x08082D94  --  defined in 'table.c' at line 1122
    double delta;                          // _cfa_ffffffb4
    double owidth;                         // _cfa_ffffffac
    double dmax;                           // _cfa_ffffffa4
    double dmin;                           // _cfa_ffffff9c
    double sxy;                            // _cfa_ffffff94
    struct table_cell* cell;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int m;                                 // _cfa_ffffffe0
    int bcol;                              // _cfa_ffffffdc
    int ecol;                              // _cfa_ffffffd8
    int span;                              // _cfa_ffffffd4
    int rulewidth;                         // _cfa_ffffffd0
    int bcol1;                             // _cfa_ffffffcc
    int ecol1;                             // _cfa_ffffffc8
    int is_inclusive;                      // _cfa_ffffffc4
    int is_inclusive;                      // _cfa_ffffffc0
    int nwidth;                            // _cfa_ffffffbc
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    signed short _v126;                    // _cfa_ffffff82
    signed int _v128;                      // _cfa_ffffff80
    int _v132;                             // _cfa_ffffff7c
    signed int _v134;                      // _cfa_ffffff7a
    int _v144;                             // _cfa_ffffff70
    signed int _v172;                      // _cfa_ffffff54
    int _v176;                             // _cfa_ffffff50
    intOrPtr _v180;                        // _cfa_ffffff4c
    int _v184;                             // _cfa_ffffff48
    _unknown_ __ebp;                       // r6
    signed int _t247;                      // _t247
    signed int _t252;                      // _t252
    signed int _t257;                      // _t257
    signed int _t260;                      // _t260
    _unknown_ _t269;                       // _t269
    _unknown_ _t283;                       // _t283
    _unknown_ _t287;                       // _t287
    _unknown_ _t288;                       // _t288
    signed int _t289;                      // _t289
    _unknown_ _t292;                       // _t292
    _unknown_ _t299;                       // _t299
    _unknown_ _t309;                       // _t309
    _unknown_ _t313;                       // _t313
    _unknown_ _t314;                       // _t314
    signed int _t315;                      // _t315
    _unknown_ _t317;                       // _t317
    _unknown_ _t321;                       // _t321
    _unknown_ _t322;                       // _t322
    _unknown_ _t326;                       // _t326
    _unknown_ _t330;                       // _t330
    _unknown_ _t331;                       // _t331
    _unknown_ _t336;                       // _t336
    _unknown_ _t339;                       // _t339
    _unknown_ _t351;                       // _t351
    _unknown_ _t354;                       // _t354
    _unknown_ _t372;                       // _t372
    _unknown_ _t375;                       // _t375
    _unknown_ _t377;                       // _t377
    _unknown_ _t378;                       // _t378
    _unknown_ _t383;                       // _t383
    _unknown_ _t385;                       // _t385
    _unknown_ _t390;                       // _t390
    _unknown_ _t394;                       // _t394

    _v116 = _a24;
    _v112 = _a28;
    _v124 = _a44;
    _v120 = _a48;
    cell =  &(t->cell);
    _t247 = table_rule_width(t);
    rulewidth = _t247;
    asm("fld qword [ebp-0x78]");
    asm("fld qword [0x80cb618]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t247 & 255) != 0) {
        return corr;
    }
    if(icol >= 0) {
        if(icell >= 0) {
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [ebp-0x50]");
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [ebp-0x48]");
            bcol = 0;
            ecol = t->maxcol + 1;
        } else {
            asm("fld qword [eax]");
            asm("fstp qword [ebp-0x50]");
            asm("fld qword [eax]");
            _v134 =  *(icell + icell + cwidth) & 0xffff;
            asm("fild word [ebp+0xffffff7e]");
            asm("fsubp st1, st0");
            asm("fstp qword [ebp-0x48]");
            asm("cwde ");
            bcol =  *(cell + icell * 2) & 65535;
            asm("cwde ");
            ecol = ( *(cell + 8 + (icell + 16) * 2) & 65535) + bcol;
        }
    } else {
        asm("fld qword [eax]");
        asm("fstp qword [ebp-0x50]");
        asm("fld qword [eax]");
        _v134 =  *(t + 8 + (icol + 40) * 2) & 0xffff;
        asm("fild word [ebp+0xffffff7e]");
        asm("fsubp st1, st0");
        asm("fstp qword [ebp-0x48]");
        bcol = icol;
        ecol = bcol + 1;
    }
    asm("fld qword [ebp-0x48]");
    asm("fstp qword [ebp-0x60]");
    asm("fld1 ");
    asm("fchs ");
    asm("fstp qword [ebp-0x58]");
    k = 0;
    while(1) {
        _t252 = cell->maxcell & 65535;
        asm("cwde ");
        if(_t252 < k) {
            break;
        }
        is_inclusive = 0;
        asm("fld qword [ebp-0x60]");
        asm("fldz ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t252 & 255) != 0) {
L43:
            asm("fld qword [ebp-0x58]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t252 & 255) != 0) {
                asm("fld qword [ebp-0x60]");
                asm("fld qword [ebp-0x58]");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t252 & 255) != 0) {
                    asm("fld qword [ebp-0x58]");
                    asm("fstp qword [ebp-0x60]");
                }
            }
            span = ecol - bcol;
            _t257 = t->maxcol + 1;
            if(_t257 != span) {
L48:
                _t260 = t->maxcol + 1;
                if(_t260 == span) {
                    goto L51;
                }
                goto L49;
                return __eax;
            } else {
                asm("fld qword [ebp-0x60]");
                asm("fldz ");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                asm("setnb al");
                if((_t257 & 255) != 0) {
L50:
                    asm("fld qword [ebp-0x50]");
                    asm("fsub qword [ebp-0x60]");
                    asm("fld qword [0x80cb5c8]");
                    asm("faddp st1, st0");
                    asm("fstp qword [esp]");
                    floor();
                    asm("fnstcw word [ebp-0x7a]");
                    _v128 = _v126 & 0xffff;
                    asm("fldcw word [ebp-0x7c]");
                    asm("fistp dword [ebp-0x80]");
                    asm("fldcw word [ebp-0x7a]");
                    nwidth = ceil_at_intervals(_v132, rulewidth);
                    asm("fld1 ");
                    asm("fstp qword [esp+0x10]");
                    _v176 = nwidth;
                    _v180 = ecol - bcol;
                    _v184 = bcol;
                     *__esp = t;
                    correct_table_matrix();
                    corr = corr + 1;
                    goto L51;
                }
                goto L48;
L51:
                return corr;
            }
L49:
            asm("fild dword [ebp-0x2c]");
            asm("fld qword [0x80cb5c8]");
            asm("fmulp st1, st0");
            asm("fld qword [ebp-0x60]");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t260 & 255) == 0) {
                goto L51;
            }
            goto L50;
        }
        asm("cwde ");
        j =  *(cell + (k + 40) * 2) & 65535;
        if(j != icell) {
            asm("cwde ");
            bcol1 =  *(cell + j * 2) & 65535;
            asm("cwde ");
            ecol1 = ( *(cell + 8 + (j + 16) * 2) & 65535) + bcol1;
            asm("fldz ");
            asm("fstp qword [ebp-0x68]");
            m = bcol1;
            while(m < ecol1) {
                i = bcol;
                while(i < ecol) {
                    asm("fld qword [eax]");
                    asm("fld qword [ebp-0x68]");
                    asm("faddp st1, st0");
                    asm("fstp qword [ebp-0x68]");
                    i = i + 1;
                }
                m = m + 1;
            }
            _t289 = bcol1;
            if(_t289 >= bcol) {
                _t289 = ecol1;
                if(_t289 <= ecol) {
                    is_inclusive = 1;
                }
            }
            asm("fld qword [ebp-0x68]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t289 & 255) == 0) {
                asm("fld qword [eax]");
                asm("cwde ");
                asm("fld qword [edx]");
                _v144 = is_inclusive;
                asm("fld qword [ebp-0x68]");
                asm("fstp qword [esp+0x24]");
                asm("fxch st0, st1");
                asm("fstp qword [esp+0x1c]");
                asm("fld qword [ebp-0x78]");
                asm("fstp qword [esp+0x14]");
                _v172 =  *(j + j + cwidth) & 65535;
                asm("fstp qword [esp+0x8]");
                asm("fld qword [ebp-0x58]");
                asm("fstp qword [esp]");
                recalc_width();
                asm("fstp qword [ebp-0x58]");
            } else {
                asm("fld qword [eax]");
                asm("cwde ");
                asm("fld qword [edx]");
                _v144 = is_inclusive;
                asm("fld qword [ebp-0x68]");
                asm("fstp qword [esp+0x24]");
                asm("fxch st0, st1");
                asm("fstp qword [esp+0x1c]");
                asm("fld qword [ebp-0x78]");
                asm("fstp qword [esp+0x14]");
                _v172 =  *(j + j + cwidth) & 65535;
                asm("fstp qword [esp+0x8]");
                asm("fld qword [ebp-0x60]");
                asm("fstp qword [esp]");
                recalc_width();
                asm("fstp qword [ebp-0x60]");
            }
        }
        k = k + 1;
        continue;
L42:
        goto L43;
    }
    m = 0;
    while(1) {
        _t252 = t->maxcol;
        if(_t252 < m) {
            break;
        }
        is_inclusive = 0;
        asm("fld qword [ebp-0x60]");
        asm("fldz ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t252 & 255) != 0) {
            goto L42;
        }
        if(m == icol) {
            goto L38;
        }
        asm("fldz ");
        asm("fstp qword [ebp-0x68]");
        i = bcol;
        while(i < ecol) {
            asm("fld qword [eax]");
            asm("fld qword [ebp-0x68]");
            asm("faddp st1, st0");
            asm("fstp qword [ebp-0x68]");
            i = i + 1;
        }
        _t315 = m;
        if(_t315 >= bcol) {
            _t315 = m;
            if(_t315 < ecol) {
                is_inclusive = 1;
            }
        }
        asm("fld qword [ebp-0x68]");
        asm("fldz ");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t315 & 255) == 0) {
            asm("fld qword [eax]");
            asm("cwde ");
            asm("fld qword [edx]");
            _v144 = is_inclusive;
            asm("fld qword [ebp-0x68]");
            asm("fstp qword [esp+0x24]");
            asm("fxch st0, st1");
            asm("fstp qword [esp+0x1c]");
            asm("fld qword [ebp-0x78]");
            asm("fstp qword [esp+0x14]");
            _v172 =  *(t + 8 + (m + 40) * 2) & 65535;
            asm("fstp qword [esp+0x8]");
            asm("fld qword [ebp-0x58]");
            asm("fstp qword [esp]");
            recalc_width();
            asm("fstp qword [ebp-0x58]");
        } else {
            asm("fld qword [eax]");
            asm("cwde ");
            asm("fld qword [edx]");
            _v144 = is_inclusive;
            asm("fld qword [ebp-0x68]");
            asm("fstp qword [esp+0x24]");
            asm("fxch st0, st1");
            asm("fstp qword [esp+0x1c]");
            asm("fld qword [ebp-0x78]");
            asm("fstp qword [esp+0x14]");
            _v172 =  *(t + 8 + (m + 40) * 2) & 65535;
            asm("fstp qword [esp+0x8]");
            asm("fld qword [ebp-0x60]");
            asm("fstp qword [esp]");
            recalc_width();
            asm("fstp qword [ebp-0x60]");
        }
L38:
        m = m + 1;
    }
    goto L43;
}

int check_table_width(struct table* t, double* newwidth, MAT* minv, int itr)
{// addr = 0x080832E2  --  defined in 'table.c' at line 1216
    short int orgwidth;                    // <nowhere>
    short int corwidth;                    // <nowhere>
    short int cwidth;                      // <nowhere>
    double swidth;                         // <nowhere>
    double twidth;                         // _cfa_ffffff8c
    double sxy;                            // _cfa_ffffff84
    double stotal;                         // _cfa_ffffff7c
    double sx;                             // _cfa_ffffff74
    double w;                              // _cfa_ffffff6c
    double sx;                             // _cfa_ffffff64
    double w;                              // _cfa_ffffff5c
    _unknown_ _v16;                        // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    int j;                                 // _cfa_ffffffd8
    int k;                                 // _cfa_ffffffd4
    int m;                                 // _cfa_ffffffd0
    int bcol;                              // _cfa_ffffffcc
    int ecol;                              // _cfa_ffffffc8
    int corr;                              // _cfa_ffffffc4
    struct table_cell* cell;   // _cfa_ffffffc0
    double* Sxx;                           // _cfa_ffffffbc
    int nwidth;                            // _cfa_ffffffb8
    int mwidth;                            // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    signed int _v108;                      // _cfa_ffffff94
    intOrPtr _v176;                        // _cfa_ffffff50
    intOrPtr _v180;                        // _cfa_ffffff4c
    intOrPtr _v184;                        // _cfa_ffffff48
    _unknown_ _v186;                       // _cfa_ffffff46
    _unknown_ _v188;                       // _cfa_ffffff44
    _unknown_ _v192;                       // _cfa_ffffff40
    signed int _v200;                      // _cfa_ffffff38
    signed int _v204;                      // _cfa_ffffff34
    signed int _v208;                      // _cfa_ffffff30
    signed int _v212;                      // _cfa_ffffff2c
    signed int _v216;                      // _cfa_ffffff28
    signed int _v220;                      // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    signed int _v228;                      // _cfa_ffffff1c
    signed int _v232;                      // _cfa_ffffff18
    signed int _v236;                      // _cfa_ffffff14
    signed int _v240;                      // _cfa_ffffff10
    signed int _v244;                      // _cfa_ffffff0c
    signed int _v248;                      // _cfa_ffffff08
    signed int _v252;                      // _cfa_ffffff04
    signed int _v256;                      // _cfa_ffffff00
    signed int _v260;                      // _cfa_fffffefc
    signed int _v264;                      // _cfa_fffffef8
    signed int _v268;                      // _cfa_fffffef4
    signed int _v272;                      // _cfa_fffffef0
    signed int _v276;                      // _cfa_fffffeec
    signed int _v280;                      // _cfa_fffffee8
    signed int _v284;                      // _cfa_fffffee4
    signed int _v288;                      // _cfa_fffffee0
    signed int _v292;                      // _cfa_fffffedc
    signed int _v296;                      // _cfa_fffffed8
    signed int _v300;                      // _cfa_fffffed4
    signed int _v304;                      // _cfa_fffffed0
    signed int _v308;                      // _cfa_fffffecc
    signed int _v312;                      // _cfa_fffffec8
    signed int _v316;                      // _cfa_fffffec4
    char _v328;                            // _cfa_fffffeb8
    _unknown_ _v332;                       // _cfa_fffffeb4
    _unknown_ _v344;                       // _cfa_fffffea8
    _unknown_ _v348;                       // _cfa_fffffea4
    _unknown_ _v352;                       // _cfa_fffffea0
    _unknown_ _v364;                       // _cfa_fffffe94
    _unknown_ _v368;                       // _cfa_fffffe90
    _unknown_ _v372;                       // _cfa_fffffe8c
    _unknown_ _v376;                       // _cfa_fffffe88
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t585;                       // _t585
    _unknown_ _t595;                       // _t595
    _unknown_ _t599;                       // _t599
    _unknown_ _t616;                       // _t616
    _unknown_ _t620;                       // _t620
    _unknown_ _t637;                       // _t637
    _unknown_ _t641;                       // _t641
    _unknown_ _t658;                       // _t658
    _unknown_ _t662;                       // _t662
    _unknown_ _t677;                       // _t677
    _unknown_ _t679;                       // _t679
    _unknown_ _t683;                       // _t683
    _unknown_ _t684;                       // _t684
    _unknown_ _t687;                       // _t687
    _unknown_ _t691;                       // _t691
    _unknown_ _t692;                       // _t692
    _unknown_ _t696;                       // _t696
    _unknown_ _t706;                       // _t706
    _unknown_ _t709;                       // _t709
    _unknown_ _t712;                       // _t712
    _unknown_ _t713;                       // _t713
    _unknown_ _t726;                       // _t726
    _unknown_ _t731;                       // _t731
    _unknown_ _t737;                       // _t737
    _unknown_ _t749;                       // _t749
    _unknown_ _t758;                       // _t758
    _unknown_ _t762;                       // _t762
    _unknown_ _t763;                       // _t763
    _unknown_ _t769;                       // _t769
    _unknown_ _t774;                       // _t774
    _unknown_ _t796;                       // _t796
    _unknown_ _t798;                       // _t798
    _unknown_ _t801;                       // _t801
    _unknown_ _t805;                       // _t805
    _unknown_ _t806;                       // _t806
    _unknown_ _t811;                       // _t811
    _unknown_ _t837;                       // _t837
    _unknown_ _t839;                       // _t839
    _unknown_ _t844;                       // _t844
    _unknown_ _t848;                       // _t848
    _unknown_ _t849;                       // _t849
    _unknown_ _t855;                       // _t855
    _unknown_ _t874;                       // _t874
    _unknown_ _t876;                       // _t876
    signed int _t877;                      // _t877
    signed int _t878;                      // _t878
    signed int _t879;                      // _t879
    signed int _t880;                      // _t880
    _unknown_ _t881;                       // _t881
    _unknown_ _t886;                       // _t886
    _unknown_ _t899;                       // _t899
    _unknown_ _t903;                       // _t903
    _unknown_ _t904;                       // _t904
    _unknown_ _t906;                       // _t906
    _unknown_ _t907;                       // _t907
    _unknown_ _t909;                       // _t909
    _unknown_ _t910;                       // _t910
    _unknown_ _t912;                       // _t912
    _unknown_ _t913;                       // _t913
    _unknown_ _t915;                       // _t915
    _unknown_ _t916;                       // _t916
    _unknown_ _t918;                       // _t918
    _unknown_ _t919;                       // _t919
    _unknown_ _t921;                       // _t921
    _unknown_ _t922;                       // _t922
    _unknown_ _t924;                       // _t924
    _unknown_ _t925;                       // _t925
    _unknown_ _t927;                       // _t927
    _unknown_ _t928;                       // _t928
    _unknown_ _t929;                       // _t929
    _unknown_ _t935;                       // _t935
    _unknown_ _t936;                       // _t936
    _unknown_ _t940;                       // _t940
    _unknown_ _t942;                       // _t942
    _unknown_ _t946;                       // _t946
    _unknown_ _t947;                       // _t947
    _unknown_ _t952;                       // _t952
    _unknown_ _t968;                       // _t968
    _unknown_ _t970;                       // _t970
    _unknown_ _t971;                       // _t971
    _unknown_ _t977;                       // _t977
    _unknown_ _t982;                       // _t982
    _unknown_ _t984;                       // _t984
    _unknown_ _t988;                       // _t988
    _unknown_ _t989;                       // _t989
    _unknown_ _t990;                       // _t990
    _unknown_ _t994;                       // _t994
    _unknown_ _t998;                       // _t998
    _unknown_ _t1002;                      // _t1002
    _unknown_ _t1006;                      // _t1006
    _unknown_ _t1010;                      // _t1010
    _unknown_ _t1014;                      // _t1014
    _unknown_ _t1018;                      // _t1018
    _unknown_ _t1022;                      // _t1022
    _unknown_ _t1028;                      // _t1028

    __esp = __esp - 364;
    _v176 = _a4;
    _v180 = _a8;
    _v184 = _a12;
    _v32 =  *gs:0x14];
    __edi = __esp;
    corr = 0;
    cell = _v176 + 388;
    _t877 =  *((intOrPtr*)(_v176 + 12)) + 1;
    _v80 = _t877 - 1;
    asm("shld edx, eax, 0x4");
    _v204 = _t877 << 4;
    _v200 = 0;
    _v212 = _t877;
    _v208 = 0;
    asm("shld edx, eax, 0x4");
    _v220 = _v212 << 4;
    _v216 = _v208 & 15;
    __esp = __esp - (_t877 + _t877 + 0x1e >> 4 << 4);
    _v84 =  &_v328 + 15 >> 4 << 4;
    _t878 =  *((intOrPtr*)(_v176 + 12)) + 1;
    _v88 = _t878 - 1;
    _v228 = _t878;
    _v224 = 0;
    asm("shld edx, eax, 0x4");
    _v236 = _v228 << 4;
    _v232 = _v224 & 15;
    _v244 = _t878;
    _v240 = 0;
    asm("shld edx, eax, 0x4");
    _v252 = _v244 << 4;
    _v248 = _v240 & 15;
    __esp = __esp - (_t878 + _t878 + 0x1e >> 4 << 4);
    _v92 =  &_v328 + 15 >> 4 << 4;
    asm("cwde ");
    _t879 = (cell->maxcell & 65535) + 1;
    _v96 = _t879 - 1;
    _v260 = _t879;
    _v256 = 0;
    asm("shld edx, eax, 0x4");
    _v268 = _v260 << 4;
    _v264 = _v256 & 15;
    _v276 = _t879;
    _v272 = 0;
    asm("shld edx, eax, 0x4");
    _v284 = _v276 << 4;
    _v280 = _v272 & 15;
    __esp = __esp - (_t879 + _t879 + 0x1e >> 4 << 4);
    _v100 =  &_v328 + 15 >> 4 << 4;
    asm("cwde ");
    _t880 = (cell->maxcell & 65535) + 1;
    _v104 = _t880 - 1;
    _v292 = _t880;
    _v288 = 0;
    asm("shld edx, eax, 0x6");
    _v300 = _v292 << 6;
    _v296 = _v288 & 15;
    _v308 = _t880;
    _v304 = 0;
    asm("shld edx, eax, 0x6");
    _v316 = _v308 << 6;
    _v312 = _v304 & 15;
    __esp = __esp - ((_t880 << 3) + 0x1e >> 4 << 4);
    _v108 =  &_v328 + 15 >> 4 << 4;
    asm("fldz ");
    asm("fstp qword [ebp-0x70]");
    asm("fldz ");
    asm("fstp qword [ebp-0x80]");
    i = 0;
    while() {
    }
}

check_table_height(struct table* t)
{// addr = 0x08083EF8  --  defined in 'table.c' at line 1473
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int space;                             // _cfa_ffffffd4
    int t_dep;                             // _cfa_ffffffd0
    int rowspan;                           // _cfa_ffffffcc
    int c;                                 // _cfa_ffffffc8
    int idx;                               // _cfa_ffffffc4
    int ii;                                // _cfa_ffffffc0
    struct  cell;             // _cfa_ffffffac
    int _v96;                              // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c
    short int* _v112;                      // _cfa_ffffff90
    int _v128;                             // _cfa_ffffff80
    int _v132;                             // _cfa_ffffff7c
    short int* _v136;                      // _cfa_ffffff78
    signed int _v140;                      // _cfa_ffffff74
    short int* _v144;                      // _cfa_ffffff70
    short int* _v148;                      // _cfa_ffffff6c
    short int* _v152;                      // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    short int* _t294;                      // _t294
    short int* _t296;                      // _t296
    short int* _t298;                      // _t298
    short int* _t300;                      // _t300
    short int* _t305;                      // _t305
    short int* _t307;                      // _t307
    short int* _t309;                      // _t309
    short int* _t311;                      // _t311
    int _t323;                             // _t323
    _unknown_ _t384;                       // _t384

    space = 0;
    cell.size = 0;
    cell.maxcell = 65535;
    j = 0;
    while(t->maxrow >= j) {
        if(t->tabattr[j] != 0) {
            i = 0;
            while(t->maxcol >= i) {
                if(( *(t->tabattr[j] + i + i) & 3) != 0) {
                    goto L30;
                } else {
                    if(t->tabdata[j][i] != 0) {
                        asm("cwde ");
                        t_dep = t->tabdata[j][i]->nitem & 65535;
                    } else {
                        t_dep = 0;
                    }
                    rowspan = table_rowspan(t, j, i);
                    if(rowspan <= 1) {
                        asm("cwde ");
                        if(( *(t->tabheight + j + j) & 65535) < t_dep) {
                             *(t->tabheight + j + j) = t_dep & 65535;
                        }
                        goto L30;
                    } else {
                        asm("cwde ");
                        c = (cell.maxcell & 65535) + 1;
                        _v96 = t->maxrow + 1;
                        asm("cwde ");
                        k = bsearch_2short(rowspan, cell.rowspan, j & 65535, cell.row, _v96, cell.indexarray, c);
                        asm("cwde ");
                        if((_v72 & 65535) >= k) {
                            asm("cwde ");
                            idx =  *(cell.indexarray + k + k) & 65535;
                            asm("cwde ");
                            if(( *(cell.row + idx + idx) & 65535) == j) {
                                asm("cwde ");
                                if(( *(_v80 + idx + idx) & 65535) == rowspan) {
                                    c = idx;
                                }
                            }
                        }
                        if(c > 999) {
                            goto L28;
                        }
                        asm("cwde ");
                        if((_v70 & 65535) <= c) {
                            if((_v70 & 0xffff) != 0) {
                                _t379 = c + 1;
                                asm("cwde ");
                                _t291 = (cell.size & 65535) + 20;
                                _t292 = c + 1 - (cell.size & 65535) + 20 >= 0 ? _t379 : _t291;
                                cell.size = (c + 1 - (cell.size & 65535) + 20 >= 0 ? _t379 : _t291) & 65535;
                                asm("cwde ");
                                _t294 = cell.row;
                                _v152 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t294;
                                GC_realloc();
                                cell.row = _t294;
                                asm("cwde ");
                                _t296 = cell.rowspan;
                                _v152 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t296;
                                GC_realloc();
                                cell.rowspan = _t296;
                                asm("cwde ");
                                _t298 = cell.indexarray;
                                _v152 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t298;
                                GC_realloc();
                                cell.indexarray = _t298;
                                asm("cwde ");
                                _t300 = cell.height;
                                _v152 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t300;
                                GC_realloc();
                                cell.height = _t300;
                            } else {
                                _t302 = c + 1;
                                _t303 = c + 1 - 20 < 0 ? 20 : _t302;
                                cell.size = (c + 1 - 20 < 0 ? 20 : _t302) & 65535;
                                asm("cwde ");
                                _t305 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t305;
                                GC_malloc_atomic();
                                cell.row = _t305;
                                asm("cwde ");
                                _t307 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t307;
                                GC_malloc_atomic();
                                cell.rowspan = _t307;
                                asm("cwde ");
                                _t309 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t309;
                                GC_malloc_atomic();
                                cell.indexarray = _t309;
                                asm("cwde ");
                                _t311 = (cell.size & 65535) + (cell.size & 65535);
                                 *__esp = _t311;
                                GC_malloc_atomic();
                                cell.height = _t311;
                            }
                        }
                        asm("cwde ");
                        if((_v72 & 65535) >= c) {
L23:
                            asm("cwde ");
                            if(( *(_v68 + c + c) & 65535) < t_dep) {
                                 *(cell.height + c + c) = t_dep & 65535;
                            }
L30:
                            i = i + 1;
                            continue;
                        } else {
                            cell.maxcell = (cell.maxcell & 65535) + 1 & 65535;
                             *(cell.row + (cell.maxcell & 0xffff) + (cell.maxcell & 0xffff)) = j & 65535;
                             *(cell.rowspan + (cell.maxcell & 0xffff) + (cell.maxcell & 0xffff)) = rowspan & 65535;
                             *(cell.height + (cell.maxcell & 0xffff) + (cell.maxcell & 0xffff)) = 0;
                            asm("cwde ");
                            if((_v72 & 65535) <= k) {
L22:
                                 *(cell.indexarray + k + k) = cell.maxcell & 0xffff;
                                goto L23;
                            }
                            asm("cwde ");
                            ii = cell.maxcell & 65535;
                            while(ii > k) {
                                 *(cell.indexarray + ii + ii) =  *(cell.indexarray + ii - 1 + ii - 1) & 0xffff;
                                ii = ii - 1;
                            }
                            goto L22;
                        }
                    }
                }
L28:
                goto L30;
            }
        }
        j = j + 1;
    }
    _t323 = t->border_mode;
    if(_t323 == 0) {
        space = 0;
    } else {
        if(_t323 < 0 && _t323 <= 3) {
            space = 1;
        }
    }
    _v112 = t->tabheight;
    _v128 = 1;
    _v100 = space;
    _v132 = _v100;
    _v136 = cell.indexarray;
    _v140 = cell.maxcell & 0xffff;
    _v144 = cell.rowspan;
    _v148 = cell.row;
    _v152 = cell.height;
     *__esp = _v112;
    check_cell_width();
    return;
}

int get_table_width(struct table* t, short int* orgwidth, short int* cellwidth, int flag)
{// addr = 0x08084329  --  defined in 'table.c' at line 1572
    short int newwidth;                    // <nowhere>
    short int ccellwidth;                  // <nowhere>
    char _v16;                             // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    int swidth;                            // _cfa_ffffffd8
    struct table_cell* cell;   // _cfa_ffffffd4
    int rulewidth;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    short int* _v56;                       // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    struct table* _v80;   // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    short int* _v88;                       // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    short int** _v100;                     // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    signed int _v108;                      // _cfa_ffffff94
    signed int _v112;                      // _cfa_ffffff90
    signed int _v116;                      // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    signed int _v124;                      // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    signed int _v132;                      // _cfa_ffffff7c
    signed int _v136;                      // _cfa_ffffff78
    signed int _v140;                      // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    signed int _v148;                      // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    char _v156;                            // _cfa_ffffff64
    _unknown_ _v160;                       // _cfa_ffffff60
    _unknown_ _v164;                       // _cfa_ffffff5c
    _unknown_ _v168;                       // _cfa_ffffff58
    _unknown_ _v172;                       // _cfa_ffffff54
    _unknown_ _v176;                       // _cfa_ffffff50
    _unknown_ _v180;                       // _cfa_ffffff4c
    _unknown_ _v184;                       // _cfa_ffffff48
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t246;                       // _t246
    _unknown_ _t254;                       // _t254
    _unknown_ _t258;                       // _t258
    int _t298;                             // _t298
    _unknown_ _t308;                       // _t308
    _unknown_ _t312;                       // _t312
    _unknown_ _t348;                       // _t348
    _unknown_ _t352;                       // _t352
    _unknown_ _t358;                       // _t358
    _unknown_ _t364;                       // _t364
    _unknown_ _t377;                       // _t377
    signed int _t378;                      // _t378
    _unknown_ _t391;                       // _t391
    _unknown_ _t393;                       // _t393
    _unknown_ _t394;                       // _t394
    _unknown_ _t396;                       // _t396
    _unknown_ _t397;                       // _t397
    _unknown_ _t402;                       // _t402
    _unknown_ _t404;                       // _t404
    _unknown_ _t405;                       // _t405
    _unknown_ _t407;                       // _t407
    signed int _t419;                      // _t419
    _unknown_ _t427;                       // _t427

    __esp = __esp - 172;
    _v80 = _a4;
    _v84 = _a8;
    _v88 = _a12;
    _v32 =  *gs:0x14];
    _v92 = __esp;
    _t419 = _v80->maxcol + 1;
    _v52 = _t419 - 1;
    asm("shld edx, eax, 0x4");
    _v108 = _t419 << 4;
    _v104 = 0;
    _v116 = _t419;
    _v112 = 0;
    asm("shld edx, eax, 0x4");
    _v124 = _v116 << 4;
    _v120 = _v112 & 15;
    __esp = __esp - (_t419 + _t419 + 0x1e >> 4 << 4);
    _v56 =  &((char*)( &_v156)[3]) >> 4 << 4;
    cell =  &(_v80->cell);
    rulewidth = table_rule_width(_v80);
    i = 0;
    while(_v80->maxcol >= i) {
        _t278 =  *(i + i + _v84) & 65535;
        _t398 = ( *(i + i + _v84) & 0xffff) >= 0 ? _t278 : 0;
        _v56[i] = (( *(i + i + _v84) & 0xffff) >= 0 ? _t278 : 0) & 65535;
        i = i + 1;
    }
    if((flag & 2) == 0) {
        check_cell_width(_v56, _v88, cell,  &(cell->colspan), cell->maxcell & 0xffff,  &(cell->index), _v80->cellspacing, 0);
    } else {
        _v96 = __esp;
        asm("cwde ");
        _t378 = (cell->maxcell & 65535) + 1;
        _v60 = _t378 - 1;
        _v132 = _t378;
        _v128 = 0;
        asm("shld edx, eax, 0x4");
        _v140 = _v132 << 4;
        _v136 = _v128 & 15;
        _v148 = _t378;
        _v144 = 0;
        asm("shld edx, eax, 0x4");
        _v156 = _v148 << 4;
        _v152 = _v144 & 15;
        __esp = __esp - (_t378 + _t378 + 0x1e >> 4 << 4);
        _v64 =  &((char*)( &_v156)[3]) >> 4 << 4;
        i = 0;
        while(_v80->maxcol >= i) {
            if((_v56[i] & 0xffff) < ( *(_v80 + (i + 144) * 2) & 0xffff)) {
                _v56[i] =  *(_v80 + (i + 144) * 2) & 0xffff;
            }
            i = i + 1;
        }
        i = 0;
        while(1) {
            asm("cwde ");
            if((cell->maxcell & 65535) < i) {
                break;
            }
            _v64[i] =  *(i + i + _v88) & 0xffff;
            if((_v64[i] & 0xffff) < ( *(cell + 6 + (i + 120) * 2) & 0xffff)) {
                _v64[i] =  *(cell + 6 + (i + 120) * 2) & 0xffff;
            }
            i = i + 1;
        }
        _v100 =  &(cell->colspan);
        check_cell_width(_v56, _v64, cell, _v100, cell->maxcell & 0xffff,  &(cell->index), _v80->cellspacing, 0);
        __esp = _v96;
    }
    if((flag & 1) != 0) {
        check_minimum_width(_v80, _v56);
    }
    swidth = 0;
    i = 0;
    while(1) {
        _t427 = _v80->maxcol - i;
        if(_t427 < 0) {
            break;
        }
        asm("cwde ");
        swidth = swidth + ceil_at_intervals(_v56[i] & 65535, rulewidth);
        i = i + 1;
    }
    swidth = swidth + table_border_width(_v80);
    _t298 = swidth;
    __esp = _v92;
    if(_t427 != 0) {
        __stack_chk_fail();
    }
     &_v16 =  &_v16;
    return _t298;
}

renderCoTable(struct table* tbl, int maxlimit)
{// addr = 0x08084705  --  defined in 'table.c' at line 1628
    struct table* t;     // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int col;                               // _cfa_ffffffe8
    int row;                               // _cfa_ffffffe4
    int indent;                            // _cfa_ffffffe0
    int maxwidth;                          // _cfa_ffffffdc
    struct html_feed_environ h_env;   // _cfa_ffffffac
    struct environment[19] envs;   // _cfa_fffffe6c
    struct readbuffer obuf;   // _cfa_fffffd1c
    _unknown_ _v756;                       // _cfa_fffffd0c
    _unknown_ _v760;                       // _cfa_fffffd08
    _unknown_ _v764;                       // _cfa_fffffd04
    _unknown_ _v768;                       // _cfa_fffffd00
    _unknown_ _v772;                       // _cfa_fffffcfc
    _unknown_ _v776;                       // _cfa_fffffcf8
    _unknown_ __ebp;                       // r6
    _unknown_ _t115;                       // _t115
    _unknown_ _t148;                       // _t148

    i = 0;
    while(1) {
        asm("cwde ");
        if((tbl->ntable & 65535) <= i) {
            break;
        }
        t = tbl->tables[i].ptr;
        asm("cwde ");
        col =  &(tbl->tables[i])->col & 65535;
        asm("cwde ");
        row =  &(tbl->tables[i])->row & 65535;
        asm("cwde ");
        indent =  &(tbl->tables[i])->indent & 65535;
        init_henv( &(h_env.obuf),  &(obuf.line),  &envs, 20,  &(tbl->tables[i])->buf, get_spec_cell_width(tbl, row, col), indent);
        check_row(tbl, row);
        if(_v68 > maxlimit) {
            h_env.limit = maxlimit;
        }
        if(t->total_width != 0) {
            if(t->total_width <= 0) {
                t->total_width = ( ~(t->total_width) * h_env.limit * 1374389535 >> 32 >> 5) - ( ~(t->total_width) * h_env.limit >> 31);
                maxwidth = t->total_width;
            } else {
                maxwidth = t->total_width;
            }
        } else {
            maxwidth = h_env.limit - indent;
        }
        renderTable(t, maxwidth,  &(h_env.obuf));
        i = i + 1;
    }
    return;
}

make_caption(struct table* t, struct html_feed_environ* h_env)
{// addr = 0x0808488F  --  defined in 'table.c' at line 1659
    int limit;                             // _cfa_fffffff0
    struct html_feed_environ henv;   // _cfa_ffffffc0
    struct environment[19] envs;   // _cfa_fffffe80
    struct readbuffer obuf;   // _cfa_fffffd30
    _unknown_ _v740;                       // _cfa_fffffd1c
    _unknown_ _v744;                       // _cfa_fffffd18
    _unknown_ _v748;                       // _cfa_fffffd14
    _unknown_ _v752;                       // _cfa_fffffd10
    _unknown_ _v756;                       // _cfa_fffffd0c
    _unknown_ _v760;                       // _cfa_fffffd08
    _unknown_ __ebp;                       // r6

    if(( *(t + 60))[1] > 0) {
        if(t->total_width <= 0) {
            limit = h_env->limit;
        } else {
            limit = t->total_width;
        }
        init_henv( &(henv.obuf),  &(obuf.line),  &envs, 20, newGeneralList(), limit,  &(h_env->envs[h_env->envc])->indent & 0xff);
        HTMLlineproc0("<center>",  &(henv.obuf), 1);
        HTMLlineproc0( *( *(t + 60)),  &(henv.obuf), 0);
        HTMLlineproc0("</center>",  &(henv.obuf), 1);
        if(t->total_width < _v44) {
            t->total_width = henv.maxlimit;
        }
        limit = h_env->limit;
        h_env->limit = t->total_width;
        HTMLlineproc0("<center>", h_env, 1);
        HTMLlineproc0( *( *(t + 60)), h_env, 0);
        HTMLlineproc0("</center>", h_env, 1);
        h_env->limit = limit;
        return;
    }
    return;
}

renderTable(struct table* t, int max_width, struct html_feed_environ* h_env)
{// addr = 0x08084A06  --  defined in 'table.c' at line 1690
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int r;                                 // _cfa_ffffffe4
    int h;                                 // _cfa_ffffffe0
    Str renderbuf;         // _cfa_ffffffdc
    int itr;                               // _cfa_ffffffd8
    VEC* newwidth;         // _cfa_ffffffd4
    MAT* mat;              // _cfa_ffffffd0
    MAT* minv;             // _cfa_ffffffcc
    PERM* pivot;          // _cfa_ffffffc8
    int width;                             // _cfa_ffffffc4
    int rulewidth;                         // _cfa_ffffffc0
    Str vrulea;            // _cfa_ffffffbc
    Str vruleb;            // _cfa_ffffffb8
    Str vrulec;            // _cfa_ffffffb4
    Str idtag;             // _cfa_ffffffb0
    TextLineList* l;   // _cfa_ffffffac
    int k;                                 // _cfa_ffffffa8
    short int[49] new_tabwidth;            // _cfa_ffffff44
    _unknown_ _v204;                       // _cfa_ffffff34
    _unknown_ _v208;                       // _cfa_ffffff30
    _unknown_ _v212;                       // _cfa_ffffff2c
    char* _v216;                           // _cfa_ffffff28
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    PERM* _t778;          // _t778
    _unknown_ _t797;                       // _t797
    _unknown_ _t800;                       // _t800
    _unknown_ _t805;                       // _t805
    _unknown_ _t809;                       // _t809
    int _t968;                             // _t968
    int _t979;                             // _t979
    char _t1165;                           // _t1165
    int _t1175;                            // _t1175
    int _t1187;                            // _t1187
    int _t1199;                            // _t1199
    char _t1210;                           // _t1210
    int _t1220;                            // _t1220
    int _t1373;                            // _t1373
    int _t1389;                            // _t1389

    vrulea = 0;
    vruleb = 0;
    vrulec = 0;
    t->total_height = 0;
    if(t->maxcol < 0) {
        make_caption(t, h_env);
        return;
    }
    if(t->sloppy_width > max_width) {
        max_width = t->sloppy_width;
    }
    rulewidth = table_rule_width(t);
    max_width = max_width - table_border_width(t);
    if(rulewidth > 1) {
        max_width = floor_at_intervals(max_width, rulewidth);
    }
    if(max_width < rulewidth) {
        max_width = rulewidth;
    }
    check_maximum_width(t);
    if(t->maxcol != 0) {
        set_table_matrix(t, max_width);
        itr = 0;
        mat = new_matrix(t->maxcol + 1);
        _t778 = t->maxcol + 1 << 2;
         *__esp = _t778;
        GC_malloc();
        pivot = _t778;
        newwidth = new_vector(t->maxcol + 1);
        minv = new_matrix(t->maxcol + 1);
        while(1) {
L18:
            bcopy(t->matrix->me, mat->me, 0 + t->matrix->dim * t->matrix->dim * 8);
            LUfactor(mat, pivot);
            LUsolve(mat, pivot, t->vector, newwidth);
            LUinverse(mat, pivot, minv);
            itr = itr + 1;
            if(check_table_width(t, newwidth->ve, minv, itr) == 0) {
                break;
            }
        }
        set_integered_width(t, newwidth->ve,  &new_tabwidth);
        check_minimum_width(t,  &new_tabwidth);
        newwidth = 0;
        pivot = 0;
        mat = 0;
        minv = 0;
        t->matrix = 0;
        t->vector = 0;
        i = 0;
        while(t->maxcol >= i) {
             *(t + 8 + (i + 40) * 2) =  *(__ebp + -184 + i * 2) & 0xffff;
            i = i + 1;
        }
        goto L22;
    } else {
        asm("cwde ");
        if((t->tabwidth & 65535) > max_width) {
            t->tabwidth = max_width & 65535;
        }
        if(t->total_width <= 0) {
            if((t->fixed_width & 0xffff) > 0) {
                t->tabwidth = t->fixed_width & 0xffff;
            }
        } else {
            t->tabwidth = max_width & 65535;
        }
        if((t->tabwidth & 0xffff) < (t->minimum_width & 0xffff)) {
            t->tabwidth = t->minimum_width & 0xffff;
        }
L22:
        check_minimum_width(t,  &(t->tabwidth));
        i = 0;
        while(t->maxcol >= i) {
            asm("cwde ");
             *(t + 8 + (i + 40) * 2) = ceil_at_intervals( *(t + 8 + (i + 40) * 2) & 65535, rulewidth) & 65535;
            i = i + 1;
        }
        renderCoTable(t, h_env->limit);
        i = 0;
        while(t->maxcol >= i) {
            j = 0;
            while(t->maxrow >= j) {
                check_row(t, j);
                if(( *(t->tabattr[j] + i + i) & 2) == 0) {
                    do_refill(t, j, i, h_env->limit);
                }
                j = j + 1;
            }
            i = i + 1;
        }
        check_minimum_width(t,  &(t->tabwidth));
        t->total_width = 0;
        i = 0;
        while(t->maxcol >= i) {
            asm("cwde ");
             *(t + 8 + (i + 40) * 2) = ceil_at_intervals( *(t + 8 + (i + 40) * 2) & 65535, rulewidth) & 65535;
            asm("cwde ");
            t->total_width = t->total_width + ( *(t + 8 + (i + 40) * 2) & 65535);
            i = i + 1;
        }
        t->total_width = t->total_width + table_border_width(t);
        check_table_height(t);
        i = 0;
        while(t->maxcol >= i) {
            j = 0;
L62:
            while(t->maxrow >= j) {
                if(( *(t->tabattr[j] + i + i) & 2) != 0) {
                    goto L61;
                }
                if(( *(t->tabattr[j] + i + i) & 0x100) != 0) {
                    goto L58;
                }
                if(t->tabdata[j][i] == 0) {
                    goto L59;
                }
                asm("cwde ");
                h =  *(t->tabheight + j + j) & 65535;
                k = j + 1;
                while(t->maxrow >= k) {
                    if(( *(t->tabattr[k] + i + i) & 2) == 0) {
                        goto L50;
                    }
                    asm("cwde ");
                    h = h + ( *(t->tabheight + k + k) & 65535);
                    if(t->border_mode - 1 <= 2) {
                        h = h + 1;
                    }
                    k = k + 1;
                    continue;
L50:
                    asm("cwde ");
                    h = h - (t->tabdata[j][i]->nitem & 65535);
                    if(( *(t->tabattr[j] + i + i) & 0x200) != 0) {
                        h = (h >> 31) + h >> 1;
                    }
                    if(h <= 0) {
                        goto L60;
                    } else {
                        l = newGeneralList();
                        k = 0;
                        while(k < h) {
                            pushValue(l, newTextLine(0, 0));
                            k = k + 1;
                        }
                        t->tabdata[j][i] = appendGeneralList(l, t->tabdata[j][i]);
                    }
L61:
                    j = j + 1;
                    goto L62;
                }
                goto L50;
L60:
                goto L61;
L59:
                goto L61;
L58:
                goto L61;
            }
            i = i + 1;
        }
        width = t->total_width;
        make_caption(t, h_env);
        HTMLlineproc0("<pre for_table>", h_env, 1);
        if( *(t + 64) != 0) {
            _v216 = html_quote( *( *(t + 64)));
            idtag = Sprintf("<_id id="%s">");
            HTMLlineproc0(idtag->ptr, h_env, 1);
        }
        if(t->border_mode - 1 <= 1) {
            renderbuf = Strnew();
            print_sep(t, -1, 0, t->maxcol, renderbuf);
            push_render_image(renderbuf, width, t->total_width, h_env);
            t->total_height = t->total_height + 1;
        }
        vruleb = Strnew();
        _t968 = t->border_mode;
        if(_t968 > 2) {
            if(_t968 == 3) {
                goto L91;
            }
        } else {
            if(_t968 >= 1) {
                vrulea = Strnew();
                vrulec = Strnew();
                _t1373 = symbol_width;
                if(t->border_mode != 2) {
                    _t1165 = 5;
                } else {
                    _t1165 = 21;
                }
                push_symbol(vrulea, _t1165, _t1373, 1);
                i = 0;
                while(t->cellpadding > i) {
                    if(vrulea->length + 1 >= vrulea->area_size) {
                        Strgrow(vrulea);
                    }
                    _t1175 = vrulea->length;
                     *((char*)(vrulea->ptr + _t1175)) = 32;
                    vrulea->length = _t1175 + 1;
                     *(vrulea->ptr + vrulea->length) = 0;
                    if(vruleb->length + 1 >= vruleb->area_size) {
                        Strgrow(vruleb);
                    }
                    _t1187 = vruleb->length;
                     *((char*)(vruleb->ptr + _t1187)) = 32;
                    vruleb->length = _t1187 + 1;
                     *(vruleb->ptr + vruleb->length) = 0;
                    if(vrulec->length + 1 >= vrulec->area_size) {
                        Strgrow(vrulec);
                    }
                    _t1199 = vrulec->length;
                     *((char*)(vrulec->ptr + _t1199)) = 32;
                    vrulec->length = _t1199 + 1;
                     *(vrulec->ptr + vrulec->length) = 0;
                    i = i + 1;
                }
                _t1389 = symbol_width;
                if(t->border_mode != 2) {
                    _t1210 = 5;
                } else {
                    _t1210 = 21;
                }
                push_symbol(vrulec, _t1210, _t1389, 1);
L91:
                push_symbol(vruleb, 5, symbol_width, 1);
                i = 0;
L95:
                while(t->cellpadding > i) {
L92:
                    if(vruleb->length + 1 >= vruleb->area_size) {
                        Strgrow(vruleb);
                    }
                    _t979 = vruleb->length;
                     *((char*)(vruleb->ptr + _t979)) = 32;
                    vruleb->length = _t979 + 1;
                     *(vruleb->ptr + vruleb->length) = 0;
                    i = i + 1;
                    goto L95;
                }
L102:
                r = 0;
                while(t->maxrow >= r) {
                    h = 0;
                    while(1) {
                        asm("cwde ");
                        if(( *(t->tabheight + r + r) & 65535) <= h) {
                            break;
                        }
                        renderbuf = Strnew();
                        if(t->border_mode == 1 || t->border_mode == 2) {
                            Strcat(renderbuf, vrulea);
                        }
                        if( *(t->tridvalue + (r << 2)) != 0 && h == 0) {
                            _v216 = html_quote( *( *(t->tridvalue + (r << 2))));
                            idtag = Sprintf("<_id id="%s">");
                            Strcat(renderbuf, idtag);
                        }
                        i = 0;
                        while(t->maxcol >= i) {
                            check_row(t, r);
                            if( *(t->tabidvalue[r] + (i << 2)) != 0 && h == 0) {
                                _v216 = html_quote( *( *(t->tabidvalue[r] + (i << 2))));
                                idtag = Sprintf("<_id id="%s">");
                                Strcat(renderbuf, idtag);
                            }
                            if(( *(t->tabattr[r] + i + i) & 1) != 0) {
L127:
                                if(t->maxcol > i && ( *(t->tabattr[r] + i + 1 + i + 1) & 1) == 0) {
                                    Strcat(renderbuf, vruleb);
                                }
                                i = i + 1;
                                continue;
                            }
                            asm("cwde ");
                            w =  *(t + 8 + (i + 40) * 2) & 65535;
                            j = i + 1;
                            while(t->maxcol >= j && ( *(t->tabattr[r] + j + j) & 1) != 0) {
                                w = w + ( *(t + 8 + (j + 40) * 2) & 0xffff) + t->cellspacing;
                                j = j + 1;
                            }
                            if(( *(t->tabattr[r] + i + i) & 2) == 0) {
                                print_item(t, r, i, w, renderbuf);
                                goto L127;
                            }
                            j = r - 1;
                            while(j < 0 && t->tabattr[j] != 0 && ( *(t->tabattr[j] + i + i) & 2) != 0) {
                                j = j - 1;
                            }
                            print_item(t, j, i, w, renderbuf);
                            goto L127;
                        }
                        if(t->border_mode - 1 <= 1) {
                            Strcat(renderbuf, vrulec);
                            t->total_height = t->total_height + 1;
                        }
                        push_render_image(renderbuf, width, t->total_width, h_env);
                        h = h + 1;
                    }
                    if(t->maxrow > r && t->border_mode != 0) {
                        renderbuf = Strnew();
                        print_sep(t, r, 1, t->maxcol, renderbuf);
                        push_render_image(renderbuf, width, t->total_width, h_env);
                    }
                    asm("cwde ");
                    t->total_height = t->total_height + ( *(t->tabheight + r + r) & 65535);
                    r = r + 1;
                }
                if(t->border_mode - 1 <= 1) {
                    renderbuf = Strnew();
                    print_sep(t, t->maxrow, 2, t->maxcol, renderbuf);
                    push_render_image(renderbuf, width, t->total_width, h_env);
                    t->total_height = t->total_height + 1;
                }
                if(t->total_height == 0) {
                    renderbuf = Strnew_charp(" ");
                    t->total_height = t->total_height + 1;
                    t->total_width = 1;
                    push_render_image(renderbuf, 1, t->total_width, h_env);
                }
                HTMLlineproc0("</pre>", h_env, 1);
                return;
            }
            if(_t968 == 0) {
                i = 0;
                while(t->cellspacing > i) {
                    if(vruleb->length + 1 >= vruleb->area_size) {
                        Strgrow(vruleb);
                    }
                    _t1220 = vruleb->length;
                     *((char*)(vruleb->ptr + _t1220)) = 32;
                    vruleb->length = _t1220 + 1;
                     *(vruleb->ptr + vruleb->length) = 0;
                    i = i + 1;
                }
                goto L102;
            }
            goto L102;
        }
        goto L102;
    }
    goto L18;
}

struct table* begin_table(int border, int spacing, int padding, int vspace)
{// addr = 0x0808594A  --  defined in 'table.c' at line 1972
    struct table* t;     // _cfa_fffffff0
    int mincell;                           // _cfa_ffffffec
    int rcellspacing;                      // _cfa_ffffffe8
    int mincell_pixels;                    // _cfa_ffffffe4
    int ppc;                               // _cfa_ffffffe0
    signed int _v46;                       // _cfa_ffffffd2
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ __ebp;                       // r6
    int _t120;                             // _t120
    int _t128;                             // _t128
    _unknown_ _t177;                       // _t177
    _unknown_ _t178;                       // _t178

    mincell = minimum_cellspacing(border);
    asm("fild dword [ebp-0x10]");
    asm("fld qword [0x80d53a0]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80cb5c8]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = _v46 & 0xffff;
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x18]");
    asm("fldcw word [ebp-0x2a]");
    asm("fld qword [0x80d53a0]");
    asm("fld qword [0x80cb5c8]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = _v46 & 0xffff;
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x1c]");
    asm("fldcw word [ebp-0x2a]");
    t = newTable();
    t->col = -1;
    t->row = t->col;
    t->maxcol = -1;
    t->maxrow = -1;
    t->border_mode = border;
    t->flag = 0;
    if(border == 3) {
        t->flag = t->flag | 2;
    }
    rcellspacing = padding + padding + spacing;
    _t120 = border;
    if(_t120 == 0) {
        t->cellpadding = rcellspacing - mincell_pixels;
    } else {
        if(_t120 < 0 && _t120 <= 3) {
            t->cellpadding = padding - ((mincell_pixels - 4 >> 31) + mincell_pixels - 4 >> 1);
        }
    }
    if(t->cellpadding < ppc) {
        if(t->cellpadding <= 0) {
            t->cellpadding = 0;
        } else {
            t->cellpadding = 1;
        }
    } else {
        t->cellpadding = t->cellpadding / ppc;
    }
    _t128 = border;
    if(_t128 == 0) {
        t->cellspacing = t->cellpadding + mincell;
    } else {
        if(_t128 < 0 && _t128 <= 3) {
            t->cellspacing = t->cellpadding + t->cellpadding + mincell;
        }
    }
    if(border != 0) {
        if(vspace >= ppc) {
            t->vspace = 1;
        } else {
            t->vspace = 0;
        }
    } else {
        if(((rcellspacing >> 31) + rcellspacing >> 1) + vspace > 1) {
            t->vspace = 1;
        } else {
            t->vspace = 0;
        }
    }
    if(border != 0) {
        if(ppc - 1 + ppc - 1 <= padding) {
            t->vcellpadding = 1;
        } else {
            t->vcellpadding = 0;
        }
    } else {
        if(rcellspacing > 4) {
            t->vcellpadding = 1;
        } else {
            t->vcellpadding = 0;
        }
    }
    return t;
}

end_table(struct table* tbl)
{// addr = 0x08085B72  --  defined in 'table.c' at line 2046
    struct table_cell* cell;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int rulewidth;                         // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    cell =  &(tbl->cell);
    rulewidth = table_rule_width(tbl);
    if(rulewidth > 1) {
        if(tbl->total_width > 0) {
            tbl->total_width = ceil_at_intervals(tbl->total_width, rulewidth);
        }
        i = 0;
        while(tbl->maxcol >= i) {
            asm("cwde ");
             *(tbl + 12 + (i + 88) * 2) = ceil_at_intervals( *(tbl + 12 + (i + 88) * 2) & 65535, rulewidth) & 65535;
            asm("cwde ");
             *(tbl + 8 + (i + 40) * 2) = ceil_at_intervals( *(tbl + 8 + (i + 40) * 2) & 65535, rulewidth) & 65535;
            if(( *(tbl + (i + 144) * 2) & 0xffff) > 0) {
                asm("cwde ");
                 *(tbl + (i + 144) * 2) = ceil_at_intervals( *(tbl + (i + 144) * 2) & 65535, rulewidth) & 65535;
            }
            i = i + 1;
        }
        i = 0;
        while(1) {
            asm("cwde ");
            if((cell->maxcell & 65535) < i) {
                break;
            }
            asm("cwde ");
             *(cell + 14 + (i + 96) * 2) = ceil_at_intervals( *(cell + 14 + (i + 96) * 2) & 65535, rulewidth) & 65535;
            asm("cwde ");
             *(cell + 6 + (i + 80) * 2) = ceil_at_intervals( *(cell + 6 + (i + 80) * 2) & 65535, rulewidth) & 65535;
            if(( *(cell + 6 + (i + 120) * 2) & 0xffff) > 0) {
                asm("cwde ");
                 *(cell + 6 + (i + 120) * 2) = ceil_at_intervals( *(cell + 6 + (i + 120) * 2) & 65535, rulewidth) & 65535;
            }
            i = i + 1;
        }
    }
    tbl->sloppy_width = get_table_width(tbl,  &(tbl->fixed_width),  &(tbl->cell.fixed_width), 1);
    if(tbl->total_width <= tbl->sloppy_width) {
    } else {
        tbl->sloppy_width = tbl->total_width;
        return;
    }
    goto L15;
L16:
L15:
    return;
    goto L16;
}

check_minimum0(struct table* t, int min)
{// addr = 0x08085D9E  --  defined in 'table.c' at line 2076
    int i;                                 // _cfa_fffffff0
    int w;                                 // _cfa_ffffffec
    int ww;                                // _cfa_ffffffe8
    struct table_cell* cell;   // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(t->col >= 0) {
        return;
    }
    if(( *(t + 8 + (t->col + 40) * 2) & 0xffff) >= 0) {
        goto L16;
    }
    check_row(t, t->row);
    w = table_colspan(t, t->row, t->col);
    min = min + t->indent;
    if(w != 1) {
        cell =  &(t->cell);
        ww = 0;
        if((cell->icell & 0xffff) < 0) {
            asm("cwde ");
            if(( *(cell + 14 + ((cell->icell & 0xffff) + 96) * 2) & 65535) < min) {
                 *(cell + 14 + ((cell->icell & 0xffff) + 96) * 2) = min & 65535;
            }
        }
    } else {
        ww = min;
    }
    i = t->col;
    while(t->maxcol >= i) {
        if(t->col == i || ( *(t->tabattr[t->row] + i + i) & 1) != 0) {
            asm("cwde ");
            if(( *(t + 12 + (i + 88) * 2) & 65535) < ww) {
                 *(t + 12 + (i + 88) * 2) = ww & 65535;
            }
            i = i + 1;
            continue;
        }
        return;
    }
L17:
    return;
L16:
    goto L17;
}

int setwidth0(struct table* t, struct table_mode* mode)
{// addr = 0x08085EE6  --  defined in 'table.c' at line 2105
    int w;                                 // _cfa_fffffff0
    int width;                             // _cfa_ffffffec
    struct table_cell* cell;   // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t117;                       // _t117
    _unknown_ _t118;                       // _t118

    width = t->tabcontentssize;
    cell =  &(t->cell);
    if(t->col < 0) {
        return -1;
    }
    if(( *(t + 8 + (t->col + 40) * 2) & 0xffff) >= 0) {
        check_row(t, t->row);
        if((t->linfo.prev_spaces & 0xff) > 0) {
            width = width - (t->linfo.prev_spaces & 0xff);
        }
        w = table_colspan(t, t->row, t->col);
        if(w != 1) {
            if((cell->icell & 0xffff) < 0) {
                asm("cwde ");
                if(( *(cell + 6 + ((cell->icell & 0xffff) + 80) * 2) & 65535) < width) {
                     *(cell + 6 + ((cell->icell & 0xffff) + 80) * 2) = width & 65535;
                }
            }
        } else {
            asm("cwde ");
            if(( *(t + 8 + (t->col + 40) * 2) & 65535) < width) {
                 *(t + 8 + (t->col + 40) * 2) = width & 65535;
            }
        }
        return width;
    }
    return -1;
}

setwidth(struct table* t, struct table_mode* mode)
{// addr = 0x08086002  --  defined in 'table.c' at line 2131
    int width;                             // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    width = setwidth0(t, mode);
    if(width >= 0) {
        goto L7;
    }
    if(( *(t->tabattr[t->row] + t->col + t->col) & 4) != 0) {
        check_minimum0(t, width);
    }
    if((mode->pre_mode & 641) != 0 && (mode->nobr_offset & 0xffff) < 0) {
        asm("cwde ");
        check_minimum0(t, width - (mode->nobr_offset & 65535));
        return;
    }
L7:
    return;
}

addcontentssize(struct table* t, int width)
{// addr = 0x0808609F  --  defined in 'table.c' at line 2146
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(t->col >= 0) {
        return;
    }
    if(( *(t + 8 + (t->col + 40) * 2) & 0xffff) >= 0) {
    } else {
        goto L2;
    }
    goto L4;
L2:
    check_row(t, t->row);
    t->tabcontentssize = t->tabcontentssize + width;
    return;
L4:
    return;
}

clearcontentssize(struct table* t, struct table_mode* mode)
{// addr = 0x080860F2  --  defined in 'table.c' at line 2160
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    table_close_anchor0(t, mode);
    mode->nobr_offset = 0;
    t->linfo.prev_spaces = 255;
    Strcopy_charp_n(t->linfo, " ", 1);
    t->linfo = 0;
    t->linfo.length = 0;
    t->tabcontentssize = 0;
    return;
}

begin_cell(struct table* t, struct table_mode* mode)
{// addr = 0x08086162  --  defined in 'table.c' at line 2172
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t82;                        // _t82

    clearcontentssize(t, mode);
    mode->indent_level = 0;
    mode->nobr_level = 0;
    mode->pre_mode = 0;
    t->indent = 0;
    t->flag = t->flag | 4;
    if(t->suspended_data != 0) {
        check_row(t, t->row);
        if(t->tabdata[t->row][t->col] == 0) {
            t->tabdata[t->row][t->col] = newGeneralList();
        }
        appendGeneralList(t->tabdata[t->row][t->col], t->suspended_data);
        t->suspended_data = 0;
        return;
    }
    return;
}

check_rowcol(struct table* tbl, struct table_mode* mode)
{// addr = 0x08086268  --  defined in 'table.c' at line 2192
    int row;                               // _cfa_fffffff0
    int col;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    row = tbl->row;
    col = tbl->col;
    if((tbl->flag & 1) == 0) {
        tbl->col = -1;
    }
    if(tbl->row == 255) {
        tbl->row = 0;
    }
    if(tbl->col == 255) {
        tbl->col = 0;
    }
    while(1) {
        check_row(tbl, tbl->row);
        goto L10;
    }
}

int skip_space(struct table* t, char* line, struct table_linfo* linfo, int checkminimum)
{// addr = 0x080863EA  --  defined in 'table.c' at line 2227
    Lineprop ctype;   // _cfa_fffffff2
    Lineprop prev_ctype;   // _cfa_fffffff0
    int skip;                              // _cfa_ffffffec
    int s;                                 // _cfa_ffffffe8
    Str prevchar;          // _cfa_ffffffe4
    int w;                                 // _cfa_ffffffe0
    int min;                               // _cfa_ffffffdc
    char* save;                            // _cfa_ffffffd8
    char* c;                               // _cfa_ffffffd4
    int ec;                                // _cfa_ffffffd0
    int len;                               // _cfa_ffffffcc
    int wlen;                              // _cfa_ffffffc8
    int plen;                              // _cfa_ffffffc4
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    int _t207;                             // _t207
    _unknown_ _t283;                       // _t283

    skip = 0;
    s = linfo->prev_spaces & 0xff;
    prev_ctype = linfo->prev_ctype & 0xffff;
    prevchar =  *(linfo + 4);
    asm("cwde ");
    w = linfo->length & 65535;
    min = 1;
    if(( *line & 0xff) == 60) {
        if((line[strlen(line) - 1] & 0xff) == 62) {
            if(checkminimum != 0) {
                check_minimum0(t, visible_length(line));
            }
            return 0;
        }
    }
    while(( *line & 0xff) != 0) {
        save = line;
        c = line;
        ctype = ( *( &WTF_TYPE_MAP + ( *line & 0xff)) & 0xff) << 8 & 65535;
        if(( *135119023 & 0xff) == 0) {
            _t207 =  *( &WTF_WIDTH_MAP + ( *line & 0xff)) & 0xff;
        } else {
            _t207 =  *( &WTF_WIDTH_MAP + ( *line & 0xff)) & 0xff;
        }
        len = _t207;
        plen =  *( &WTF_LEN_MAP + ( *line & 0xff)) & 0xff;
        wlen = plen;
        if(min < w) {
            min = w;
        }
        if(ctype != 0 || ( *( &MYCTYPE_MAP + ( *c & 0xff)) & 2) == 0) {
            if(( *c & 0xff) == 38) {
                ec = getescapechar( &line);
                if(ec < 0) {
                    c = conv_entity(ec);
                    ctype = ( *( &WTF_TYPE_MAP + ( *c & 0xff)) & 0xff) << 8 & 65535;
                    len = wtf_strwidth(c);
                    wlen = line - save;
                    plen =  *( &WTF_LEN_MAP + ( *c & 0xff)) & 0xff;
                }
            }
            if(prevchar->length == 0 || is_boundary(prevchar->ptr, c) == 0) {
                w = w + len;
            } else {
                w = len;
            }
            if(s > 0) {
                if(ctype != 2560 || prev_ctype != 2560) {
                    skip = skip + s - 1;
                } else {
                    skip = skip + s;
                }
            }
            s = 0;
            prev_ctype = ctype & 0xffff;
        } else {
            w = 0;
            s = s + 1;
        }
        Strcopy_charp_n(prevchar, c, plen);
        line =  &(save[wlen]);
    }
    if(s <= 1) {
        linfo->prev_spaces = s & 255;
    } else {
        skip = skip + s - 1;
        linfo->prev_spaces = 1;
    }
    linfo->prev_ctype = prev_ctype & 0xffff;
     *(linfo + 4) = prevchar;
    if(checkminimum != 0) {
        if(min < w) {
            min = w;
        }
        linfo->length = w & 65535;
        check_minimum0(t, min);
    }
    return skip;
}

feed_table_inline_tag(struct table* tbl, char* line, struct table_mode* mode, int width)
{// addr = 0x080866C5  --  defined in 'table.c' at line 2307
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    check_rowcol(tbl, mode);
    pushdata(tbl, tbl->row, tbl->col, line);
    if(width < 0) {
        check_minimum0(tbl, width);
        addcontentssize(tbl, width);
        setwidth(tbl, mode);
        return;
    }
    return;
}

feed_table_block_tag(struct table* tbl, char* line, struct table_mode* mode, int indent, int cmd)
{// addr = 0x08086740  --  defined in 'table.c' at line 2320
    int offset;                            // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if((mode->indent_level & 0xff) > 0 || indent != 255) {
        setwidth(tbl, mode);
        feed_table_inline_tag(tbl, line, mode, -1);
        clearcontentssize(tbl, mode);
        if(indent != 1) {
            if(indent == 255) {
                mode->indent_level = (mode->indent_level & 255) - 1 & 255;
                if((mode->indent_level & 0xff) <= 9) {
                    tbl->indent = tbl->indent - IndentIncr;
                }
            }
        } else {
            mode->indent_level = (mode->indent_level & 255) + 1 & 255;
            if((mode->indent_level & 0xff) <= 10) {
                tbl->indent = tbl->indent + IndentIncr;
            }
        }
        offset = tbl->indent;
        if(cmd == 19 && (mode->indent_level & 0xff) > 0 && (mode->indent_level & 0xff) <= 10) {
            offset = offset - IndentIncr;
        }
        if(tbl->indent <= 0) {
L15:
            return;
        } else {
            check_minimum0(tbl, 0);
            addcontentssize(tbl, offset);
            return;
        }
    }
    goto L15;
}

table_close_select(struct table* tbl, struct table_mode* mode, int width)
{// addr = 0x0808686B  --  defined in 'table.c' at line 2351
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    tmp = process_n_select();
    mode->pre_mode = mode->pre_mode;
    mode->end_tag = 0;
    feed_table1(tbl, tmp, mode, width);
    return;
}

table_close_textarea(struct table* tbl, struct table_mode* mode, int width)
{// addr = 0x080868B1  --  defined in 'table.c' at line 2360
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    tmp = process_n_textarea();
    mode->pre_mode = mode->pre_mode;
    mode->end_tag = 0;
    feed_table1(tbl, tmp, mode, width);
    return;
}

table_close_anchor0(struct table* tbl, struct table_mode* mode)
{// addr = 0x080868F7  --  defined in 'table.c' at line 2369
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if((mode->pre_mode & 16777216) == 0) {
        goto L8;
    }
    mode->pre_mode = mode->pre_mode & -16777217;
    asm("cwde ");
    if(tbl->tabcontentssize != (mode->anchor_offset & 65535)) {
        if((tbl->linfo.prev_spaces & 0xff) <= 0) {
            goto L8;
        }
        goto L4;
    }
    check_minimum0(tbl, 1);
    addcontentssize(tbl, 1);
    setwidth(tbl, mode);
    return;
L4:
    asm("cwde ");
    if(tbl->tabcontentssize - 1 != (mode->anchor_offset & 65535) || (tbl->linfo.prev_spaces & 0xff) <= 0) {
        goto L8;
    } else {
        tbl->linfo.prev_spaces = 255;
        return;
    }
    goto L9;
L8:
    return;
L9:
}

int feed_table_tag(struct table* tbl, char* line, struct table_mode* mode, int width, struct parsed_tag* tag)
{// addr = 0x080869AD  --  defined in 'table.c' at line 2412
    char* p;                               // _cfa_ffffffd8
    int colspan;                           // _cfa_ffffffd0
    int rowspan;                           // _cfa_ffffffcc
    int col;                               // _cfa_ffffffc8
    int prev_col;                          // _cfa_ffffffc4
    int i;                                 // _cfa_ffffffc0
    int j;                                 // _cfa_ffffffbc
    int k;                                 // _cfa_ffffffb8
    int v;                                 // _cfa_ffffffb4
    int v0;                                // _cfa_ffffffb0
    int w;                                 // _cfa_ffffffac
    int id;                                // _cfa_ffffffa8
    Str tok;               // _cfa_ffffffa4
    Str tmp;               // _cfa_ffffffa0
    Str anchor;            // _cfa_ffffff9c
    table_attr align;   // _cfa_ffffffe2
    table_attr valign;   // _cfa_ffffffe0
    int ii;                                // _cfa_ffffff98
    Str tmp;               // _cfa_ffffff94
    struct table* tbl1;   // _cfa_ffffff90
    int cmd;                               // _cfa_ffffffdc
    struct table_cell* cell;   // _cfa_ffffffd4
    _unknown_ _v156;                       // _cfa_ffffff64
    _unknown_ _v160;                       // _cfa_ffffff60
    _unknown_ _v164;                       // _cfa_ffffff5c
    _unknown_ _v168;                       // _cfa_ffffff58
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t92;                        // _t92
    _unknown_ _t94;                        // _t94
    _unknown_ _t95;                        // _t95
    int _t96;                              // _t96
    _unknown_ _t97;                        // _t97
    _unknown_ _t101;                       // _t101
    _unknown_ _t102;                       // _t102
    _unknown_ _t105;                       // _t105
    _unknown_ _t106;                       // _t106
    _unknown_ _t110;                       // _t110
    _unknown_ _t115;                       // _t115
    _unknown_ _t119;                       // _t119
    _unknown_ _t124;                       // _t124
    _unknown_ _t127;                       // _t127
    _unknown_ _t128;                       // _t128
    _unknown_ _t132;                       // _t132
    _unknown_ _t141;                       // _t141

    cell =  &(tbl->cell);
    cmd = tag->tagid & 0xff;
    if((mode->pre_mode & 8) == 0) {
        if((mode->pre_mode & 2048) == 0) {
L8:
            if((mode->pre_mode & 2) == 0) {
                if((mode->pre_mode & 4) == 0) {
                    if((mode->pre_mode & 4096) == 0) {
L20:
                        if((mode->caption & 0xff) == 0) {
L24:
                            if((mode->pre_mode & 1) == 0) {
L29:
                                if(cmd > 140) {
                                    return 1;
                                }
                                goto L30;
                            }
                            goto L25;
L30:
                            goto __eax;
                        }
                        goto L21;
L25:
                        _t96 = cmd;
                        if(_t96 < 50 || _t96 > 51 && _t96 + -128 > 1) {
                            goto L29;
                        } else {
                            return 0;
                        }
                        goto L30;
                    }
                    goto L17;
L21:
                    if(cmd - 31 > 59) {
                        return 1;
                    }
                    goto __eax;
                    goto L24;
                }
                goto L13;
L17:
                if(cmd - 31 > 59) {
                    return 1;
                }
                goto __eax;
                goto L20;
            }
            goto L9;
L13:
            if((mode->end_tag & 0xff) != cmd) {
                return 4;
            }
            mode->pre_mode = mode->pre_mode & 251;
            mode->end_tag = 0;
            return 0;
        }
        goto L5;
L9:
        if((mode->end_tag & 0xff) != cmd) {
            return 4;
        }
        mode->pre_mode = mode->pre_mode & 253;
        mode->end_tag = 0;
        return 0;
    }
    if((mode->end_tag & 0xff) == cmd) {
        mode->pre_mode = mode->pre_mode & 247;
        mode->end_tag = 0;
        feed_table_block_tag(tbl, line, mode, 0, cmd);
        return 0;
    }
    return 4;
L5:
    if(cmd - 31 > 59) {
        return 1;
    }
    goto __eax;
    goto L8;
}

int feed_table(struct table* tbl, char* line, struct table_mode* mode, int width, int internal)
{// addr = 0x0808822A  --  defined in 'table.c' at line 3090
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    struct table_linfo* linfo;   // _cfa_ffffffe4
    struct parsed_tag* tag;   // _cfa_ffffffe0
    char* q;                               // _cfa_ffffffdc
    char* r;                               // _cfa_ffffffd8
    int ec;                                // _cfa_ffffffd4
    int nl;                                // _cfa_ffffffd0
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t459;                       // _t459
    _unknown_ _t513;                       // _t513
    int _t536;                             // _t536
    int _t553;                             // _t553
    int _t569;                             // _t569
    int _t581;                             // _t581
    int _t601;                             // _t601
    int _t614;                             // _t614
    _unknown_ _t629;                       // _t629
    _unknown_ _t631;                       // _t631
    _unknown_ _t632;                       // _t632
    _unknown_ _t633;                       // _t633
    _unknown_ _t636;                       // _t636
    _unknown_ _t637;                       // _t637
    _unknown_ _t655;                       // _t655
    int _t661;                             // _t661
    _unknown_ _t662;                       // _t662
    _unknown_ _t663;                       // _t663
    _unknown_ _t669;                       // _t669

    linfo =  &(tbl->linfo);
    if(( *line & 0xff) != 60 || (line[1] & 0xff) == 0 || ( *( &MYCTYPE_MAP + (line[1] & 0xff)) & 4) == 0 && (line[1] & 0xff) != 47 && (line[1] & 0xff) != 33 && (line[1] & 0xff) != 63 && (line[1] & 0xff) != 0 && (line[1] & 0xff) != 95) {
        if((mode->pre_mode & 3145728) == 0) {
            goto L28;
        } else {
            return -1;
        }
    } else {
        p = line;
        tag = parse_tag( &p, internal);
        if(tag == 0) {
            if((mode->pre_mode & 6158) == 0) {
                return -1;
            }
L28:
            if((mode->caption & 0xff) != 0) {
L29:
                Strcat_charp( *(tbl + 60), line);
                return -1;
            }
            if((mode->pre_mode & 2) == 0) {
                if((mode->pre_mode & 4) == 0) {
                    if((mode->pre_mode & 2048) == 0) {
                        if((mode->pre_mode & 4096) == 0) {
                            if((mode->pre_mode & 8) != 0 || ( *line & 0xff) == 60 && ( *(strlen(line) - 1 + line) & 0xff) == 62 || strchr(line, 38) == 0) {
L78:
                                if((mode->pre_mode & 527) != 0) {
                                    if((mode->pre_mode & 512) == 0) {
                                        check_rowcol(tbl, mode);
L112:
                                        while(( *line & 0xff) != 0) {
                                            goto L96;
                                        }
L113:
                                        return -1;
                                    }
                                    goto L92;
L96:
                                    nl = 0;
                                    p = strchr(line, 13);
                                    if(p != 0) {
L98:
                                        if(( *p & 0xff) == 13 && (p[1] & 0xff) == 10) {
                                            p =  &(p[1]);
                                        }
                                        if((p[1] & 0xff) == 0) {
                                            p = line;
                                            line = 135049312;
                                        } else {
                                            p =  &(p[1]);
                                            tmp = Strnew_charp_n(line, p - line);
                                            line = p;
                                            p = tmp->ptr;
                                        }
                                        nl = 1;
L106:
                                        if((mode->pre_mode & 8) == 0) {
                                            i = maximum_visible_length(p, tbl->tabcontentssize);
                                        } else {
                                            i = maximum_visible_length_plain(p, tbl->tabcontentssize);
                                        }
                                        addcontentssize(tbl, i);
                                        setwidth(tbl, mode);
                                        if(nl != 0) {
                                            clearcontentssize(tbl, mode);
                                        }
                                        pushdata(tbl, tbl->row, tbl->col, p);
                                        goto L112;
                                    }
                                    p = strchr(line, 10);
                                    if(p == 0) {
                                        p = line;
                                        line = 135049312;
                                        goto L106;
                                    }
                                    goto L98;
                                }
                                goto L79;
L92:
                                check_rowcol(tbl, mode);
                                if((mode->nobr_offset & 0xffff) < 0) {
                                    mode->nobr_offset = tbl->tabcontentssize & 65535;
                                }
                                addcontentssize(tbl, maximum_visible_length(line, tbl->tabcontentssize));
                                setwidth(tbl, mode);
                                pushdata(tbl, tbl->row, tbl->col, line);
                                goto L113;
                            } else {
                                tmp = Strnew();
                                p = line;
                                while(( *p & 0xff) != 0) {
                                    if(( *p & 0xff) != 38) {
                                        if(tmp->length + 1 >= tmp->area_size) {
                                            Strgrow(tmp);
                                        }
                                        _t536 = tmp->length;
                                         *(tmp->ptr + _t536) =  *p & 0xff;
                                        tmp->length = _t536 + 1;
                                         *(tmp->ptr + tmp->length) = 0;
                                        p =  &(p[1]);
                                        continue;
                                    }
                                    if(strncasecmp(p, 135050668, 5) == 0 || strncasecmp(p, 135050674, 4) == 0 || strncasecmp(p, 135050679, 4) == 0) {
                                        if(tmp->length + 1 >= tmp->area_size) {
                                            Strgrow(tmp);
                                        }
                                        _t553 = tmp->length;
                                         *(tmp->ptr + _t553) =  *p & 0xff;
                                        tmp->length = _t553 + 1;
                                         *(tmp->ptr + tmp->length) = 0;
                                        p =  &(p[1]);
                                        continue;
                                    }
                                    q = p;
                                    ec = getescapechar( &p);
                                    _t569 = ec;
                                    if(_t569 == 38) {
L60:
                                        Strcat_charp(tmp, 135050668);
                                        continue;
                                    }
                                    if(_t569 > 38) {
                                        if(_t569 == 60) {
                                            Strcat_charp(tmp, 135050679);
                                            continue;
                                        }
                                        goto L56;
L59:
                                        Strcat_charp(tmp, 135050674);
                                        continue;
                                    }
                                    if(_t569 == 255) {
L70:
                                        if(tmp->length + 1 >= tmp->area_size) {
                                            Strgrow(tmp);
                                        }
                                        _t581 = tmp->length;
                                         *(tmp->ptr + _t581) =  *q & 0xff;
                                        tmp->length = _t581 + 1;
                                         *(tmp->ptr + tmp->length) = 0;
                                        p =  &(q[1]);
                                        continue;
                                    }
                                    if(_t569 == 13) {
                                        goto L61;
                                    }
L64:
                                    r = conv_entity(ec);
                                    if(r == 0 || strlen(r) != 1 || ( *r & 0xff) != ec) {
                                        goto L70;
                                    } else {
                                        if(tmp->length + 1 >= tmp->area_size) {
                                            Strgrow(tmp);
                                        }
                                        _t601 = tmp->length;
                                         *(tmp->ptr + _t601) =  *r & 0xff;
                                        tmp->length = _t601 + 1;
                                         *(tmp->ptr + tmp->length) = 0;
                                        continue;
                                    }
L56:
                                    if(_t569 == 62) {
                                        goto L59;
                                    }
                                    goto L64;
L61:
                                    if(tmp->length + 1 >= tmp->area_size) {
                                        Strgrow(tmp);
                                    }
                                    _t614 = tmp->length;
                                     *(tmp->ptr + _t614) = 10;
                                    tmp->length = _t614 + 1;
                                     *(tmp->ptr + tmp->length) = 0;
                                }
                                line = tmp->ptr;
                                goto L78;
                            }
L79:
                            if((tbl->flag & 4) == 0) {
                                goto L84;
                            }
                            if((linfo->prev_spaces & 0xff) == 0) {
L85:
                                if(( *line & 0xff) != 0) {
                                    check_rowcol(tbl, mode);
                                    if((mode->pre_mode & 128) != 0 && (mode->nobr_offset & 0xffff) < 0) {
                                        mode->nobr_offset = tbl->tabcontentssize & 65535;
                                    }
                                    i = skip_space(tbl, line, linfo, mode->pre_mode & 0x80);
                                    addcontentssize(tbl, visible_length(line) - i);
                                    setwidth(tbl, mode);
                                    pushdata(tbl, tbl->row, tbl->col, line);
                                    goto L113;
                                }
                                return -1;
                            }
L84:
                            while(( *( &MYCTYPE_MAP + ( *line & 0xff)) & 2) != 0) {
                                line =  &(line[1]);
                            }
                            goto L85;
                        }
                        goto L37;
                    }
                    goto L35;
L37:
                    feed_select(line);
                    return -1;
                }
                goto L33;
L35:
                feed_textarea(line);
                return -1;
            }
            return -1;
L33:
            return -1;
        }
    }
    _t661 = feed_table_tag(tbl, line, mode, width, tag);
    if(_t661 == 2) {
        return 1;
    }
    if(_t661 > 2) {
        if(_t661 == 3) {
            return 0;
        }
        if(_t661 == 4) {
        } else {
L20:
            if((tag->need_reconstruct & 0xff) != 0) {
                line =  *(parsedtag2str(tag));
            }
        }
        goto L28;
    } else {
        if(_t661 == 0) {
            return -1;
        } else {
            goto L20;
        }
    }
}

feed_table1(struct table* tbl, Str tok, struct table_mode* mode, int width)
{// addr = 0x08088AE3  --  defined in 'table.c' at line 3257
    Str tokbuf;            // _cfa_fffffff0
    int status;                            // _cfa_ffffffec
    char* line;                            // _cfa_ffffffe8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    _unknown_ _t36;                        // _t36

    if(tok != 0) {
        tokbuf = Strnew();
        status = 0;
        line = tok->ptr;
        while(read_token(tokbuf,  &line,  &status, mode->pre_mode & 2575, 0) != 0) {
            feed_table(tbl, tokbuf->ptr, mode, width, 1);
        }
        return;
    }
    return;
}

pushTable(struct table* tbl, struct table* tbl1)
{// addr = 0x08088B6A  --  defined in 'table.c' at line 3273
    int col;                               // _cfa_fffffff0
    int row;                               // _cfa_ffffffec
    struct table_in* tmp;   // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct table_in* _t173;   // _t173
    _unknown_ _t181;                       // _t181

    col = tbl->col;
    row = tbl->row;
    if((tbl->ntable & 0xffff) >= (tbl->tables_size & 0xffff)) {
        tbl->tables_size = (tbl->tables_size & 65535) + 20 & 65535;
        asm("cwde ");
        _t173 = (tbl->tables_size & 65535) << 4;
         *__esp = _t173;
        GC_malloc();
        tmp = _t173;
        if(tbl->tables != 0) {
            asm("cwde ");
            bcopy(tbl->tables, tmp, (tbl->ntable & 65535) << 4);
        }
        tbl->tables = tmp;
    }
    asm("cwde ");
     *(tbl->tables + ((tbl->ntable & 65535) << 4)) = tbl1;
    asm("cwde ");
    (tbl->tables + ((tbl->ntable & 65535) << 4))[1] = col & 65535;
    asm("cwde ");
    (tbl->tables + ((tbl->ntable & 65535) << 4))[1] = row & 65535;
    asm("cwde ");
    (tbl->tables + ((tbl->ntable & 65535) << 4))[2] = tbl->indent & 65535;
    asm("cwde ");
    (tbl->tables + ((tbl->ntable & 65535) << 4))[3] = newGeneralList();
    check_row(tbl, row);
    if(col + 1 > tbl->maxcol || ( *( *((intOrPtr*)(tbl->tabattr + (row << 2))) + col + 1 + col + 1) & 1) == 0) {
        asm("cwde ");
        (tbl->tables + ((tbl->ntable & 65535) << 4))[2] = 65535;
    } else {
        asm("cwde ");
        (tbl->tables + ((tbl->ntable & 65535) << 4))[2] = tbl->cell.icell & 0xffff;
    }
    tbl->ntable = (tbl->ntable & 65535) + 1 & 65535;
    return;
}

int correct_table_matrix(struct table* t, int col, int cspan, int a, double b)
{// addr = 0x08088D64  --  defined in 'table.c' at line 3305
    double w;                              // _cfa_ffffffe4
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int ecol;                              // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    _unknown_ _t65;                        // _t65
    _unknown_ _t67;                        // _t67
    _unknown_ _t68;                        // _t68
    _unknown_ _t71;                        // _t71
    _unknown_ _t74;                        // _t74
    _unknown_ _t76;                        // _t76
    _unknown_ _t77;                        // _t77
    _unknown_ _t82;                        // _t82
    _unknown_ _t84;                        // _t84
    _unknown_ _t85;                        // _t85
    _unknown_ _t89;                        // _t89
    _unknown_ _t90;                        // _t90
    _unknown_ _t91;                        // _t91
    _unknown_ _t93;                        // _t93
    _unknown_ _t94;                        // _t94
    _unknown_ _t99;                        // _t99
    _unknown_ _t101;                       // _t101
    _unknown_ _t102;                       // _t102
    _unknown_ _t106;                       // _t106
    _unknown_ _t107;                       // _t107
    _unknown_ _t111;                       // _t111
    _unknown_ _t112;                       // _t112
    _unknown_ _t115;                       // _t115
    _unknown_ _t116;                       // _t116
    _unknown_ _t118;                       // _t118
    _unknown_ _t120;                       // _t120

    _v44 = _a20;
    _v40 = _a24;
    ecol = col + cspan;
    asm("fld qword [ebp-0x28]");
    asm("fmul qword [ebp-0x28]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fstp qword [ebp-0x18]");
    i = col;
    while(i < ecol) {
        asm("fld qword [eax]");
        asm("fild dword [ebp+0x14]");
        asm("fmul qword [ebp-0x18]");
        asm("faddp st1, st0");
        asm("fstp qword [edx]");
        j = i;
        while(j < ecol) {
            asm("fld qword [eax]");
            asm("fadd qword [ebp-0x18]");
            asm("fstp qword [edx]");
            asm("fld qword [eax]");
            asm("fstp qword [edx]");
            j = j + 1;
        }
        i = i + 1;
    }
    return i;
}

correct_table_matrix2(struct table* t, int col, int cspan, double s, double b)
{// addr = 0x08088E96  --  defined in 'table.c' at line 3322
    double w;                              // _cfa_ffffffe4
    double ss;                             // _cfa_ffffffdc
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int ecol;                              // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ __ebp;                       // r6
    _unknown_ _t73;                        // _t73
    _unknown_ _t75;                        // _t75
    _unknown_ _t76;                        // _t76
    _unknown_ _t77;                        // _t77
    _unknown_ _t78;                        // _t78
    _unknown_ _t81;                        // _t81
    _unknown_ _t83;                        // _t83
    _unknown_ _t84;                        // _t84
    _unknown_ _t86;                        // _t86
    _unknown_ _t88;                        // _t88
    _unknown_ _t89;                        // _t89
    _unknown_ _t96;                        // _t96
    _unknown_ _t97;                        // _t97

    _v44 = _a16;
    _v40 = _a20;
    _v52 = _a24;
    _v48 = _a28;
    ecol = col + cspan;
    size = t->maxcol + 1;
    asm("fld qword [ebp-0x30]");
    asm("fmul qword [ebp-0x30]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fstp qword [ebp-0x18]");
    i = 0;
    while(i < size) {
        while(j < size) {
            if(i < col || i >= ecol) {
L7:
                if(i < col || i >= ecol) {
                    if(j < col || j >= ecol) {
                        asm("fld qword [ebp-0x28]");
                        asm("fmul qword [ebp-0x28]");
                        asm("fstp qword [ebp-0x20]");
                        goto L13;
                    }
                }
                asm("fld1 ");
                asm("fsub qword [ebp-0x28]");
                asm("fchs ");
                asm("fmul qword [ebp-0x28]");
                asm("fstp qword [ebp-0x20]");
                goto L13;
            } else {
                if(j < col || j >= ecol) {
                    goto L7;
                } else {
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fmulp st1, st0");
                    asm("fstp qword [ebp-0x20]");
L13:
                    asm("fld qword [eax]");
                    asm("fld qword [ebp-0x18]");
                    asm("fmul qword [ebp-0x20]");
                    asm("faddp st1, st0");
                    asm("fstp qword [edx]");
                    j = j + 1;
                    continue;
                }
                goto L8;
            }
        }
        i = i + 1;
    }
    return;
}

correct_table_matrix3(struct table* t, int col, char* flags, double s, double b)
{// addr = 0x08088FCE  --  defined in 'table.c' at line 3344
    double ss;                             // _cfa_ffffffe4
    double w;                              // _cfa_ffffffdc
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int size;                              // _cfa_fffffff0
    int flg;                               // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ __ebp;                       // r6
    _unknown_ _t97;                        // _t97
    _unknown_ _t99;                        // _t99
    _unknown_ _t100;                       // _t100
    _unknown_ _t105;                       // _t105
    _unknown_ _t107;                       // _t107
    _unknown_ _t108;                       // _t108
    _unknown_ _t112;                       // _t112
    _unknown_ _t113;                       // _t113
    _unknown_ _t123;                       // _t123

    _v44 = _a16;
    _v40 = _a20;
    _v52 = _a24;
    _v48 = _a28;
    size = t->maxcol + 1;
    asm("fld qword [ebp-0x30]");
    asm("fmul qword [ebp-0x30]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fstp qword [ebp-0x20]");
    flg = flags[col] & 0xff;
    i = 0;
    while(i < size) {
        if(flg == 0 || (flags[i] & 0xff) != 0) {
            if(flg != 0) {
                goto L25;
            }
            if((flags[i] & 0xff) == 0) {
                goto L24;
            }
            goto L5;
L25:
            i = i + 1;
            continue;
L24:
            goto L25;
        }
L5:
        j = i;
        while(j < size) {
            if(flg == 0 || (flags[j] & 0xff) != 0) {
                if(flg != 0) {
                    goto L20;
                }
            } else {
L10:
                if(i != col || j != col) {
                    if(i == col || j == col) {
                        asm("fld1 ");
                        asm("fsub qword [ebp-0x28]");
                        asm("fchs ");
                        asm("fmul qword [ebp-0x28]");
                        asm("fstp qword [ebp-0x18]");
                    } else {
                        asm("fld qword [ebp-0x28]");
                        asm("fmul qword [ebp-0x28]");
                        asm("fstp qword [ebp-0x18]");
                    }
                } else {
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fmulp st1, st0");
                    asm("fstp qword [ebp-0x18]");
                }
                asm("fld qword [eax]");
                asm("fld qword [ebp-0x20]");
                asm("fmul qword [ebp-0x18]");
                asm("faddp st1, st0");
                asm("fstp qword [edx]");
L20:
                j = j + 1;
                continue;
            }
            if((flags[j] & 0xff) == 0) {
                goto L20;
            }
            goto L10;
        }
        goto L25;
    }
    return;
}

correct_table_matrix4(struct table* t, int col, int cspan, char* flags, double s, double b)
{// addr = 0x08089156  --  defined in 'table.c' at line 3371
    double ss;                             // _cfa_ffffffe4
    double w;                              // _cfa_ffffffdc
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int ecol;                              // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ __ebp;                       // r6
    _unknown_ _t95;                        // _t95
    _unknown_ _t97;                        // _t97
    _unknown_ _t98;                        // _t98
    _unknown_ _t103;                       // _t103
    _unknown_ _t105;                       // _t105
    _unknown_ _t106;                       // _t106
    _unknown_ _t110;                       // _t110
    _unknown_ _t111;                       // _t111
    _unknown_ _t123;                       // _t123

    _v44 = _a20;
    _v40 = _a24;
    _v52 = _a28;
    _v48 = _a32;
    ecol = col + cspan;
    size = t->maxcol + 1;
    asm("fld qword [ebp-0x30]");
    asm("fmul qword [ebp-0x30]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fstp qword [ebp-0x20]");
    i = 0;
    while(i < size) {
        if((flags[i] & 0xff) == 0) {
L4:
            j = i;
L23:
            while(j < size) {
                goto L5;
            }
            goto L27;
        }
        if(i < col) {
L27:
            i = i + 1;
            continue;
        }
        if(i >= ecol) {
            goto L27;
        }
        goto L4;
L5:
        if((flags[j] & 0xff) == 0) {
L8:
            if(i < col || i >= ecol || j < col) {
L13:
                if(i < col || i >= ecol) {
                    if(j < col || j >= ecol) {
                        asm("fld qword [ebp-0x28]");
                        asm("fmul qword [ebp-0x28]");
                        asm("fstp qword [ebp-0x18]");
                        goto L19;
                    }
                }
                asm("fld1 ");
                asm("fsub qword [ebp-0x28]");
                asm("fchs ");
                asm("fmul qword [ebp-0x28]");
                asm("fstp qword [ebp-0x18]");
                goto L19;
            } else {
                if(j >= ecol) {
                    goto L13;
                } else {
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fmulp st1, st0");
                    asm("fstp qword [ebp-0x18]");
L19:
                    asm("fld qword [eax]");
                    asm("fld qword [ebp-0x20]");
                    asm("fmul qword [ebp-0x18]");
                    asm("faddp st1, st0");
                    asm("fstp qword [edx]");
L22:
                    j = j + 1;
                    goto L23;
                }
                goto L14;
            }
        }
        if(j < col) {
            goto L22;
        }
        if(j >= ecol) {
            goto L22;
        }
        goto L8;
    }
    return;
}

set_table_matrix0(struct table* t, int maxwidth)
{// addr = 0x080892E4  --  defined in 'table.c' at line 3398
    double w0;                             // _cfa_ffffffa4
    double w1;                             // _cfa_ffffff9c
    double w;                              // _cfa_ffffff94
    double s;                              // _cfa_ffffff8c
    double b;                              // _cfa_ffffff84
    double we;                             // <nowhere>
    char expand;                           // <nowhere>
    char _v16;                             // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    int size;                              // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    int j;                                 // _cfa_ffffffd4
    int k;                                 // _cfa_ffffffd0
    int bcol;                              // _cfa_ffffffcc
    int ecol;                              // _cfa_ffffffc8
    int width;                             // _cfa_ffffffc4
    struct table_cell* cell;   // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    void* _v80;           // _cfa_ffffffb0
    intOrPtr _v128;                        // _cfa_ffffff80
    signed int _v130;                      // _cfa_ffffff7e
    signed int _v132;                      // _cfa_ffffff7c
    int _v136;                             // _cfa_ffffff78
    signed int _v138;                      // _cfa_ffffff76
    intOrPtr* _v144;                       // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    signed int _v156;                      // _cfa_ffffff64
    signed int _v160;                      // _cfa_ffffff60
    signed int _v164;                      // _cfa_ffffff5c
    signed int _v168;                      // _cfa_ffffff58
    int _v172;                             // _cfa_ffffff54
    signed int _v176;                      // _cfa_ffffff50
    signed int _v180;                      // _cfa_ffffff4c
    signed int _v184;                      // _cfa_ffffff48
    int _v188;                             // _cfa_ffffff44
    signed int _v192;                      // _cfa_ffffff40
    signed int _v196;                      // _cfa_ffffff3c
    char _v204;                            // _cfa_ffffff34
    void* _v224;          // _cfa_ffffff20
    void* _v228;          // _cfa_ffffff1c
    int _v232;                             // _cfa_ffffff18
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t316;                       // _t316
    _unknown_ _t326;                       // _t326
    _unknown_ _t330;                       // _t330
    _unknown_ _t345;                       // _t345
    _unknown_ _t349;                       // _t349
    signed int _t361;                      // _t361
    _unknown_ _t364;                       // _t364
    _unknown_ _t365;                       // _t365
    _unknown_ _t369;                       // _t369
    _unknown_ _t399;                       // _t399
    signed int _t400;                      // _t400
    _unknown_ _t401;                       // _t401
    _unknown_ _t404;                       // _t404
    signed int _t438;                      // _t438
    _unknown_ _t440;                       // _t440
    _unknown_ _t445;                       // _t445
    _unknown_ _t450;                       // _t450
    _unknown_ _t456;                       // _t456
    _unknown_ _t461;                       // _t461
    _unknown_ _t463;                       // _t463
    _unknown_ _t464;                       // _t464
    int _t468;                             // _t468
    _unknown_ _t471;                       // _t471
    _unknown_ _t476;                       // _t476
    _unknown_ _t480;                       // _t480
    _unknown_ _t482;                       // _t482
    _unknown_ _t483;                       // _t483
    _unknown_ _t485;                       // _t485
    _unknown_ _t486;                       // _t486
    _unknown_ _t488;                       // _t488
    _unknown_ _t489;                       // _t489
    _unknown_ _t491;                       // _t491
    _unknown_ _t494;                       // _t494
    _unknown_ _t511;                       // _t511
    _unknown_ _t512;                       // _t512
    _unknown_ _t522;                       // _t522
    _unknown_ _t523;                       // _t523
    _unknown_ _t524;                       // _t524
    _unknown_ _t525;                       // _t525
    _unknown_ _t526;                       // _t526
    _unknown_ _t534;                       // _t534

    __esp = __esp - 220;
    _v128 = _a4;
    _v32 =  *gs:0x14];
    _v144 = __esp;
    size =  *((intOrPtr*)(_v128 + 12)) + 1;
    _v148 = size;
    _v68 = _v148 - 1;
    asm("shld edx, eax, 0x6");
    _v156 = _v148;
    _v152 = 0;
    asm("shld edx, eax, 0x6");
    _v164 = _v156 << 6;
    _v160 = _v152 & 15;
    __esp = __esp - ((_v148 << 3) + 0x1e >> 4 << 4);
    _v72 =  &_v204 + 15 >> 4 << 4;
    _t468 = size;
    _v76 = _t468 - 1;
    _v172 = _t468;
    _v168 = 0;
    asm("shld edx, eax, 0x3");
    _v180 = _v172 << 3;
    _v176 = _v168 & 15;
    _v188 = _t468;
    _v184 = 0;
    asm("shld edx, eax, 0x3");
    _v196 = _v188 << 3;
    _v192 = _v184 & 15;
    __esp = __esp - (_t468 + 0x1e >> 4 << 4);
    _v80 =  &_v204 + 15 >> 4 << 4;
    cell = _v128 + 388;
    asm("fldz ");
    asm("fstp qword [ebp-0x58]");
    i = 0;
    while(1) {
        _t361 = i;
        if(_t361 >= size) {
            break;
        }
        asm("cwde ");
        weight( *(_v128 + 8 + (i + 40) * 2) & 65535);
        asm("fstp qword [eax+ebx*8]");
        asm("fld qword [eax+edx*8]");
        asm("fld qword [ebp-0x58]");
        asm("faddp st1, st0");
        asm("fstp qword [ebp-0x58]");
        i = i + 1;
    }
    asm("fld qword [ebp-0x58]");
    asm("fldz ");
    asm("fucomip st0, st1");
    asm("fstp st0");
    asm("setnb al");
    if((_t361 & 255) != 0) {
        asm("fld1 ");
        asm("fstp qword [ebp-0x58]");
    }
    if((cell->necell & 0xffff) != 0) {
        bzero(_v80, size);
        k = 0;
        while(1) {
L20:
            asm("cwde ");
            if((cell->necell & 65535) <= k) {
                break;
            }
            asm("cwde ");
            j =  *(cell + 12 + (k + 56) * 2) & 65535;
            asm("cwde ");
            bcol =  *(cell + j * 2) & 65535;
            asm("cwde ");
            ecol = ( *(cell + 8 + (j + 16) * 2) & 65535) + bcol;
            asm("cwde ");
            width = ( *(cell + 6 + (j + 80) * 2) & 0xffff) +  *(_v128 + 40) * (1 - ( *(cell + 8 + (j + 16) * 2) & 65535));
            asm("fldz ");
            asm("fstp qword [ebp-0x60]");
            i = bcol;
            while(i < ecol) {
                _v138 =  *(_v128 + 8 + (i + 40) * 2) & 0xffff;
                asm("fild word [ebp+0xffffff7a]");
                asm("fld qword [0x80cb620]");
                asm("faddp st1, st0");
                asm("fld qword [ebp-0x60]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x60]");
                 *(_v80 + i) = ( *(_v80 + i) & 255) + 1 & 255;
                i = i + 1;
            }
            i = bcol;
            while(i < ecol) {
                asm("fild dword [ebp-0x38]");
                _v138 =  *(_v128 + 8 + (i + 40) * 2) & 0xffff;
                asm("fild word [ebp+0xffffff7a]");
                asm("fld qword [0x80cb620]");
                asm("faddp st1, st0");
                asm("fmulp st1, st0");
                asm("fdiv qword [ebp-0x60]");
                asm("fnstcw word [ebp-0x7e]");
                _v132 = _v130 & 0xffff;
                asm("fldcw word [ebp-0x80]");
                asm("fistp dword [ebp+0xffffff7c]");
                asm("fldcw word [ebp-0x7e]");
                weight(_v136);
                asm("fstp qword [ebp-0x68]");
                asm("fld qword [eax+edx*8]");
                asm("fld qword [ebp-0x68]");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_v72 & 255) != 0) {
                    asm("fld qword [ebp-0x68]");
                    asm("fstp qword [eax+edx*8]");
                }
                i = i + 1;
            }
            k = k + 1;
        }
        asm("fldz ");
        asm("fstp qword [ebp-0x58]");
        asm("fldz ");
        asm("fstp qword [ebp-0x60]");
        i = 0;
        while(1) {
            _t400 = i;
            if(_t400 >= size) {
                break;
            }
            asm("fld qword [eax+edx*8]");
            asm("fld qword [ebp-0x58]");
            asm("faddp st1, st0");
            asm("fstp qword [ebp-0x58]");
            if(( *(_v80 + i) & 0xff) == 0) {
                asm("fld qword [eax+edx*8]");
                asm("fld qword [ebp-0x60]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x60]");
            }
            i = i + 1;
        }
        asm("fld qword [ebp-0x58]");
        asm("fldz ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t400 & 255) != 0) {
            asm("fld1 ");
            asm("fstp qword [ebp-0x58]");
        }
        k = 0;
        while(1) {
            asm("cwde ");
            if((cell->necell & 65535) <= k) {
                break;
            }
            asm("cwde ");
            j =  *(cell + 12 + (k + 56) * 2) & 65535;
            asm("cwde ");
            bcol =  *(cell + j * 2) & 65535;
            asm("cwde ");
            width = ( *(cell + 6 + (j + 80) * 2) & 0xffff) +  *(_v128 + 40) * (1 - ( *(cell + 8 + (j + 16) * 2) & 65535));
            weight(width);
            asm("fstp qword [ebp-0x68]");
            asm("fld qword [ebp-0x60]");
            asm("fadd qword [ebp-0x68]");
            asm("fld qword [ebp-0x68]");
            asm("fdivrp st1, st0");
            asm("fstp qword [ebp-0x70]");
            asm("fild dword [ebp+0xc]");
            asm("fmul qword [ebp-0x70]");
            asm("fnstcw word [ebp-0x7e]");
            _v132 = _v130 & 0xffff;
            asm("fldcw word [ebp-0x80]");
            asm("fistp dword [ebp+0xffffff7c]");
            asm("fldcw word [ebp-0x7e]");
            weight2(_v136);
            asm("fld qword [0x80cb628]");
            asm("fmulp st1, st0");
            asm("fstp qword [ebp-0x78]");
            asm("cwde ");
            asm("fld qword [ebp-0x78]");
            asm("fstp qword [esp+0x18]");
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [esp+0x10]");
            _v224 = _v80;
            _v228 =  *(cell + 8 + (j + 16) * 2) & 65535;
            _v232 = bcol;
             *__esp = _v128;
            correct_table_matrix4();
            k = k + 1;
        }
        i = 0;
        while(i < size) {
            if(( *(_v80 + i) & 0xff) != 0) {
                asm("fld qword [eax+edx*8]");
                asm("fld qword [ebp-0x58]");
                asm("fsub qword [ebp-0x60]");
                asm("fld1 ");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_v72 & 255) == 0) {
                    asm("fld1 ");
                } else {
                    asm("fld qword [ebp-0x58]");
                    asm("fsub qword [ebp-0x60]");
                }
                asm("fdivp st1, st0");
                asm("fstp qword [ebp-0x70]");
                weight2(maxwidth);
                asm("fld qword [0x80cb628]");
                asm("fmulp st1, st0");
                asm("fstp qword [ebp-0x78]");
            } else {
                asm("fld qword [eax+edx*8]");
                asm("fld qword [ebp-0x60]");
                asm("fld1 ");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_v72 & 255) == 0) {
                    asm("fld1 ");
                } else {
                    asm("fld qword [ebp-0x60]");
                }
                asm("fdivp st1, st0");
                asm("fstp qword [ebp-0x70]");
                asm("fild dword [ebp+0xc]");
                asm("fmul qword [ebp-0x70]");
                asm("fnstcw word [ebp-0x7e]");
                _v132 = _v130 & 0xffff;
                asm("fldcw word [ebp-0x80]");
                asm("fistp dword [ebp+0xffffff7c]");
                asm("fldcw word [ebp-0x7e]");
                weight2(_v136);
                asm("fld qword [0x80cb628]");
                asm("fmulp st1, st0");
                asm("fstp qword [ebp-0x78]");
            }
            asm("fld qword [ebp-0x78]");
            asm("fstp qword [esp+0x14]");
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [esp+0xc]");
            _v228 = _v80;
            _v232 = i;
             *__esp = _v128;
            correct_table_matrix3();
            i = i + 1;
        }
        goto L43;
    } else {
        i = 0;
        while(1) {
            _t534 = i - size;
            if(_t534 >= 0) {
                break;
            }
            asm("fld qword [eax+edx*8]");
            asm("fdiv qword [ebp-0x58]");
            asm("fstp qword [ebp-0x70]");
            asm("fild dword [ebp+0xc]");
            asm("fmul qword [ebp-0x70]");
            asm("fnstcw word [ebp-0x7e]");
            _v132 = _v130 & 0xffff;
            asm("fldcw word [ebp-0x80]");
            asm("fistp dword [ebp+0xffffff7c]");
            asm("fldcw word [ebp-0x7e]");
            weight2(_v136);
            asm("fld qword [0x80cb628]");
            asm("fmulp st1, st0");
            asm("fstp qword [ebp-0x78]");
            asm("fld qword [ebp-0x78]");
            asm("fstp qword [esp+0x14]");
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [esp+0xc]");
            _v228 = 1;
            _v232 = i;
             *__esp = _v128;
            correct_table_matrix2();
            i = i + 1;
        }
L43:
        __esp = _v144;
        _t438 = _v32 ^  *gs:0x14];
        if(_t534 != 0) {
            __stack_chk_fail();
        }
         &_v16 =  &_v16;
        return _t438;
    }
    goto L20;
}

check_relative_width(struct table* t, int maxwidth)
{// addr = 0x080899B4  --  defined in 'table.c' at line 3483
    double rel_total;                      // _cfa_ffffffc4
    double w;                              // _cfa_ffffffbc
    double r;                              // _cfa_ffffffb4
    double r;                              // _cfa_ffffffac
    int i;                                 // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    double* rcolwidth;                     // _cfa_ffffffe8
    struct table_cell* cell;   // _cfa_ffffffe4
    int n_leftcol;                         // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int n_leftcell;                        // _cfa_ffffffd4
    int j;                                 // _cfa_ffffffd0
    int k;                                 // _cfa_ffffffcc
    _unknown_ _v94;                        // _cfa_ffffffa2
    _unknown_ _v96;                        // _cfa_ffffffa0
    _unknown_ _v98;                        // _cfa_ffffff9e
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    double* _t266;                         // _t266
    _unknown_ _t272;                       // _t272
    _unknown_ _t275;                       // _t275
    _unknown_ _t277;                       // _t277
    _unknown_ _t280;                       // _t280
    _unknown_ _t283;                       // _t283
    _unknown_ _t287;                       // _t287
    _unknown_ _t293;                       // _t293
    _unknown_ _t297;                       // _t297
    _unknown_ _t298;                       // _t298
    _unknown_ _t301;                       // _t301
    _unknown_ _t304;                       // _t304
    _unknown_ _t307;                       // _t307
    _unknown_ _t308;                       // _t308
    _unknown_ _t311;                       // _t311
    _unknown_ _t324;                       // _t324
    _unknown_ _t328;                       // _t328
    _unknown_ _t331;                       // _t331
    _unknown_ _t334;                       // _t334
    _unknown_ _t337;                       // _t337
    _unknown_ _t339;                       // _t339
    _unknown_ _t342;                       // _t342
    _unknown_ _t344;                       // _t344
    _unknown_ _t347;                       // _t347
    _unknown_ _t370;                       // _t370
    _unknown_ _t377;                       // _t377
    _unknown_ _t378;                       // _t378
    _unknown_ _t387;                       // _t387
    _unknown_ _t390;                       // _t390
    _unknown_ _t391;                       // _t391

    asm("fldz ");
    asm("fstp qword [ebp-0x38]");
    size = t->maxcol.col + 1;
    _t266 = size << 3;
     *__esp = _t266;
    GC_malloc();
    rcolwidth = _t266;
    cell =  &(t->cell);
    n_leftcol = 0;
    i = 0;
    while() {
    }
}

set_table_matrix(struct table* t, int width)
{// addr = 0x08089E51  --  defined in 'table.c' at line 3566
    double b;                              // _cfa_ffffffd4
    double s;                              // _cfa_ffffffcc
    int size;                              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int a;                                 // _cfa_ffffffe4
    struct table_cell* cell;   // _cfa_ffffffe0
    signed int _v62;                       // _cfa_ffffffc2
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v66;                       // _cfa_ffffffbe
    int _v72;                              // _cfa_ffffffb8
    int _v96;                              // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    _unknown_ _t202;                       // _t202
    _unknown_ _t204;                       // _t204
    _unknown_ _t205;                       // _t205
    _unknown_ _t209;                       // _t209
    _unknown_ _t210;                       // _t210
    _unknown_ _t211;                       // _t211
    _unknown_ _t214;                       // _t214
    signed int _t230;                      // _t230
    _unknown_ _t236;                       // _t236
    signed int _t254;                      // _t254
    _unknown_ _t262;                       // _t262
    _unknown_ _t271;                       // _t271
    _unknown_ _t282;                       // _t282
    signed int _t300;                      // _t300
    signed int _t308;                      // _t308

    size = t->maxcol + 1;
    cell =  &(t->cell);
    if(size <= 0) {
        return;
    }
    t->matrix = new_matrix(size);
    t->vector = new_vector(size);
    i = 0;
    while(i < size) {
        j = i;
        while(j < size) {
            asm("fldz ");
            asm("fstp qword [eax]");
            j = j + 1;
        }
        asm("fldz ");
        asm("fstp qword [eax]");
        i = i + 1;
    }
    check_relative_width(t, width);
    i = 0;
    while(i < size) {
        if(( *(t + (i + 144) * 2) & 0xffff) <= 0) {
            if(( *(t + (i + 144) * 2) & 0xffff) < 0) {
                _v62 =  *(t + (i + 144) * 2) & 0xffff;
                asm("fild word [ebp-0x3a]");
                asm("fld qword [0x80cb630]");
                asm("fdivp st1, st0");
                asm("fstp qword [ebp-0x30]");
                asm("fild dword [ebp+0xc]");
                asm("fmul qword [ebp-0x30]");
                asm("fnstcw word [ebp-0x3c]");
                _v66 = _v64 & 0xffff;
                asm("fldcw word [ebp-0x3e]");
                asm("fistp dword [ebp-0x44]");
                asm("fldcw word [ebp-0x3c]");
                weight2(_v72);
                asm("fld qword [0x80cb5c8]");
                asm("fmulp st1, st0");
                asm("fstp qword [ebp-0x28]");
                asm("fld qword [ebp-0x28]");
                asm("fstp qword [esp+0x14]");
                asm("fld qword [ebp-0x30]");
                asm("fstp qword [esp+0xc]");
                _v100 = 1;
                _v104 = i;
                 *__esp = t;
                correct_table_matrix2();
            }
        } else {
            _t308 =  *(t + 12 + (i + 88) * 2) & 65535;
            _t230 =  *(t + (i + 144) * 2) & 65535;
            _t231 = (_t308 & 65535) - (_t230 & 65535) >= 0 ? _t308 : _t230;
            asm("cwde ");
            a = (_t308 & 65535) - (_t230 & 65535) >= 0 ? _t308 : _t230;
            weight2(a);
            asm("fld qword [0x80cb5c8]");
            asm("fmulp st1, st0");
            asm("fstp qword [ebp-0x28]");
            asm("fld qword [ebp-0x28]");
            asm("fstp qword [esp+0x10]");
            _v96 = a;
            _v100 = 1;
            _v104 = i;
             *__esp = t;
            correct_table_matrix();
        }
        i = i + 1;
    }
    j = 0;
    while(1) {
        asm("cwde ");
        if((cell->maxcell & 65535) < j) {
            break;
        }
        if(( *(cell + 6 + (j + 120) * 2) & 0xffff) <= 0) {
            if(( *(cell + 6 + (j + 120) * 2) & 0xffff) < 0) {
                _v62 =  *(cell + 6 + (j + 120) * 2) & 0xffff;
                asm("fild word [ebp-0x3a]");
                asm("fld qword [0x80cb630]");
                asm("fdivp st1, st0");
                asm("fstp qword [ebp-0x30]");
                asm("fild dword [ebp+0xc]");
                asm("fmul qword [ebp-0x30]");
                asm("fnstcw word [ebp-0x3c]");
                _v66 = _v64 & 0xffff;
                asm("fldcw word [ebp-0x3e]");
                asm("fistp dword [ebp-0x44]");
                asm("fldcw word [ebp-0x3c]");
                weight2(_v72);
                asm("fld qword [0x80cb5c8]");
                asm("fmulp st1, st0");
                asm("fstp qword [ebp-0x28]");
                asm("cwde ");
                asm("fld qword [ebp-0x28]");
                asm("fstp qword [esp+0x14]");
                asm("fld qword [ebp-0x30]");
                asm("fstp qword [esp+0xc]");
                _v100 =  *(cell + 8 + (j + 16) * 2) & 0xffff;
                _v104 =  *(cell + j * 2) & 65535;
                 *__esp = t;
                correct_table_matrix2();
            }
        } else {
            _t300 =  *(cell + 14 + (j + 96) * 2) & 65535;
            _t254 =  *(cell + 6 + (j + 120) * 2) & 65535;
            _t255 = (_t300 & 65535) - (_t254 & 65535) >= 0 ? _t300 : _t254;
            asm("cwde ");
            a = (_t300 & 65535) - (_t254 & 65535) >= 0 ? _t300 : _t254;
            weight2(a);
            asm("fld qword [0x80cb5c8]");
            asm("fmulp st1, st0");
            asm("fstp qword [ebp-0x28]");
            asm("cwde ");
            asm("fld qword [ebp-0x28]");
            asm("fstp qword [esp+0x10]");
            _v96 = a;
            _v100 =  *(cell + 8 + (j + 16) * 2) & 0xffff;
            _v104 =  *(cell + j * 2) & 65535;
             *__esp = t;
            correct_table_matrix();
        }
        j = j + 1;
    }
    set_table_matrix0(t, width);
    if(t->total_width <= 0) {
        weight2(width);
        asm("fadd st0, st0");
        asm("fstp qword [ebp-0x28]");
    } else {
        weight2(width);
        asm("fld qword [0x80cb640]");
        asm("fmulp st1, st0");
        asm("fstp qword [ebp-0x28]");
    }
    asm("fld qword [ebp-0x28]");
    asm("fstp qword [esp+0x10]");
    _v96 = width;
    _v100 = size;
    _v104 = 0;
     *__esp = t;
    correct_table_matrix();
    return;
}

writeLocalCookie()
{// addr = 0x0808A210  --  defined in 'local.c' at line 31
    FILE* f;              // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    _unknown_ _t25;                        // _t25
    _unknown_ _t27;                        // _t27

    if(no_rc_dir != 0) {
        return;
    }
    if(Local_cookie_file != 0) {
        goto L5;
    }
    Local_cookie_file =  *(tmpfname(4, 0));
    set_environ("LOCAL_COOKIE_FILE", Local_cookie_file);
    f = fopen(Local_cookie_file, "wb");
    if(f != 0) {
        goto L3;
    }
    goto L7;
L3:
    localCookie();
    fwrite(Local_cookie->ptr, 1, Local_cookie->length, f);
    fclose(f);
    _v40 = 384;
     *__esp = Local_cookie_file;
    chmod();
    return;
L7:
    return;
L5:
    return;
}

Str localCookie()
{// addr = 0x0808A2DB  --  defined in 'local.c' at line 52
    intOrPtr _v16;                         // _cfa_fffffff0
    char[255] hostname;                    // _cfa_fffffef0
    char[255]* _v292;                      // _cfa_fffffedc
    long _v296;                            // _cfa_fffffed8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    int _t13;                              // _t13
    _unknown_ _t15;                        // _t15
    long _t16;                             // _t16
    struct _Str* _t18;    // _t18
    _unknown_ _t21;                        // _t21

    _v16 =  *gs:0x14];
    __eflags = Local_cookie;
    if(__eflags == 0) {
        _t13 = gethostname( &hostname, 256);
         *__esp = 1;
        GC_malloc();
         *__esp = 0;
        time();
        srand48(_t13 + _t13);
        _t16 = lrand48();
        _v292 =  &hostname;
        _v296 = _t16;
        Local_cookie = Sprintf("%ld%s");
        _t18 = Local_cookie;
    } else {
        _t18 = Local_cookie;
    }
    if(__eflags != 0) {
        __stack_chk_fail();
        return _t18;
    }
    return _t18;
}

Str loadLocalDir(char* dname)
{// addr = 0x0808A37E  --  defined in 'local.c' at line 65
    intOrPtr _v16;                         // _cfa_fffffff0
    char[1023] lbuf;                       // _cfa_fffffbf0
    Str tmp;               // _cfa_fffffbec
    DIR* d;                // _cfa_fffffbe8
    Directory* dir;   // _cfa_fffffbe4
    char** flist;                          // _cfa_fffffbe0
    char* p;                               // _cfa_fffffbdc
    char* qdir;                            // _cfa_fffffbd8
    Str fbuf;              // _cfa_fffffbd4
    int i;                                 // _cfa_fffffbd0
    int l;                                 // _cfa_fffffbcc
    int nrow;                              // _cfa_fffffbc8
    int n;                                 // _cfa_fffffbc4
    int maxlen;                            // _cfa_fffffbc0
    int nfile;                             // _cfa_fffffbbc
    int nfile_max;                         // _cfa_fffffbb8
    Str dirname;           // _cfa_fffffbb4
    struct stat st;       // _cfa_fffffb5c
    struct stat lst;      // _cfa_fffffb04
    DIR* _v1280;           // _cfa_fffffb00
    signed int _v1296;                     // _cfa_fffffaf0
    struct _Str* _v1312;   // _cfa_fffffae0
    char* _v1316;                          // _cfa_fffffadc
    char* _v1320;                          // _cfa_fffffad8
    char* _v1324;                          // _cfa_fffffad4
    struct _Str* _v1328;   // _cfa_fffffad0
    char* _v1332;                          // _cfa_fffffacc
    char* _v1336;                          // _cfa_fffffac8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t277;                       // _t277
    _unknown_ _t278;                       // _t278
    DIR* _t279;            // _t279
    struct _Str* _t282;   // _t282
    int _t285;                             // _t285
    struct _Str* _t286;   // _t286
    int _t290;                             // _t290
    char* _t304;                           // _t304
    char** _t307;                          // _t307
    Directory* _t308;   // _t308
    char** _t323;                          // _t323
    _unknown_ _t327;                       // _t327
    int _t334;                             // _t334
    struct _Str* _t337;   // _t337
    int _t340;                             // _t340
    struct _Str* _t341;   // _t341
    int _t345;                             // _t345
    int _t354;                             // _t354
    int _t356;                             // _t356
    char* _t365;                           // _t365
    char* _t373;                           // _t373
    char* _t390;                           // _t390
    int _t395;                             // _t395
    struct _Str* _t396;   // _t396
    int _t400;                             // _t400
    signed int _t407;                      // _t407
    int _t411;                             // _t411
    struct _Str* _t412;   // _t412
    int _t416;                             // _t416
    int _t424;                             // _t424
    struct _Str* _t425;   // _t425
    int _t429;                             // _t429
    signed int _t445;                      // _t445
    struct _Str* _t448;   // _t448
    signed int _t463;                      // _t463
    _unknown_ _t482;                       // _t482
    _unknown_ _t510;                       // _t510
    _unknown_ _t511;                       // _t511
    _unknown_ _t514;                       // _t514
    _unknown_ _t515;                       // _t515

    _v1280 = _a4;
    _v16 =  *gs:0x14];
    Strnew();
    fbuf = 0;
    nrow = 0;
    n = 0;
    maxlen = 0;
    nfile_max = 100;
    _t279 = _v1280;
     *__esp = _t279;
    opendir();
    d = _t279;
    __eflags = d;
    if(__eflags != 0) {
        dirname = Strnew_charp(_v1280);
        _t282 = dirname;
        __eflags = _t282->length;
        if(_t282->length <= 0) {
L4:
            _t285 = dirname->length;
            _t286 = dirname;
            __eflags = _t285 + 1 - _t286->area_size;
            if(_t285 + 1 >= _t286->area_size) {
                Strgrow(dirname);
            }
            _t290 = dirname->length;
             *((char*)(dirname->ptr + _t290)) = 47;
            dirname->length = _t290 + 1;
             *(dirname->ptr + dirname->length) = 0;
L7:
            qdir = html_quote( *(wc_Str_conv(dirname, SystemCharset, InnerCharset)));
            _t304 = html_quote(file_quote(dirname->ptr));
            _v1312 = 0;
            _v1316 = "</H1>\n";
            _v1320 = qdir;
            _v1324 = "</TITLE>\n</HEAD>\n<BODY>\n<H1>Directory list of ";
            _v1328 = qdir;
            _v1332 = "">\n<TITLE>Directory list of ";
            _v1336 = _t304;
            tmp = Strnew_m_charp("<HTML>\n<HEAD>\n<BASE HREF="file://");
            _t307 = nfile_max << 2;
             *__esp = _t307;
            GC_malloc();
            flist = _t307;
            nfile = 0;
            while(1) {
                _t308 = d;
                 *__esp = _t308;
                readdir();
                dir = _t308;
                __eflags = dir;
                if(dir == 0) {
                    break;
                } else {
                    flist[nfile] = allocStr( &(dir->d_name), -1);
                    nfile = nfile + 1;
                    __eflags = nfile - nfile_max;
                    if(nfile == nfile_max) {
                        nfile_max = nfile_max << 1;
                        _v1336 = nfile_max << 2;
                        _t323 = flist;
                         *__esp = _t323;
                        GC_realloc();
                        flist = _t323;
                    }
                    __eflags = multicolList;
                    if(multicolList != 0) {
                        l = strlen( &(dir->d_name));
                        __eflags = l - maxlen;
                        if(l > maxlen) {
                            maxlen = l;
                        }
                        n = n + 1;
                    }
                    continue;
                }
            }
            __eflags = multicolList;
            if(multicolList != 0) {
                _v1296 = maxlen + 2;
                l = COLS / _v1296;
                __eflags = l;
                if(l == 0) {
                    l = 1;
                }
                nrow = (n + l - 1) / l;
                n = 1;
                Strcat_charp(tmp, "<TABLE CELLPADDING=0>\n<TR VALIGN=TOP>\n");
            }
            _v1328 = strCmp;
            qsort(flist, nfile, 4);
            i = 0;
            while(1) {
                __eflags = i - nfile;
                if(i >= nfile) {
                    break;
                }
                p = flist[i];
                _t334 = strcmp(p, ".");
                __eflags = _t334;
                if(_t334 == 0) {
L58:
                    i = i + 1;
                    continue;
                }
                Strcopy(fbuf, dirname);
                _t337 = fbuf;
                __eflags = _t337->length;
                if(_t337->length <= 0) {
L23:
                    _t340 = fbuf->length;
                    _t341 = fbuf;
                    __eflags = _t340 + 1 - _t341->area_size;
                    if(_t340 + 1 >= _t341->area_size) {
                        Strgrow(fbuf);
                    }
                    _t345 = fbuf->length;
                     *((char*)(fbuf->ptr + _t345)) = 47;
                    fbuf->length = _t345 + 1;
                     *(fbuf->ptr + fbuf->length) = 0;
L26:
                    Strcat_charp(fbuf, p);
                    _t354 = fbuf->ptr;
                    __lstat(_t354,  &(lst.st_dev));
                    __eflags = _t354;
                    if(_t354 < 0) {
                        _t356 = fbuf->ptr;
                        __stat(_t356,  &(st.st_dev));
                        __eflags = _t356;
                        if(_t356 < 0) {
                            __eflags = multicolList;
                            if(multicolList == 0) {
                                __eflags = (lst.st_mode & 61440) - 40960;
                                if((lst.st_mode & 61440) != 40960) {
                                    __eflags = (st.st_mode & 61440) - 16384;
                                    if((st.st_mode & 61440) != 16384) {
                                        Strcat_charp(tmp, "[FILE] ");
                                    } else {
                                        Strcat_charp(tmp, "[DIR]&nbsp; ");
                                    }
                                } else {
                                    Strcat_charp(tmp, "[LINK] ");
                                }
                            } else {
                                __eflags = n - 1;
                                if(n == 1) {
                                    Strcat_charp(tmp, "<TD><NOBR>");
                                }
                            }
                            _t365 = html_quote(file_quote(p));
                            _v1328 = 0;
                            _v1332 = _t365;
                            _v1336 = "<A HREF="";
                            Strcat_m_charp(tmp);
                            __eflags = (st.st_mode & 61440) - 16384;
                            if((st.st_mode & 61440) == 16384) {
                                _t424 = tmp->length;
                                _t425 = tmp;
                                __eflags = _t424 + 1 - _t425->area_size;
                                if(_t424 + 1 >= _t425->area_size) {
                                    Strgrow(tmp);
                                }
                                _t429 = tmp->length;
                                 *((char*)(tmp->ptr + _t429)) = 47;
                                tmp->length = _t429 + 1;
                                 *(tmp->ptr + tmp->length) = 0;
                            }
                            _t373 = html_quote( *(wc_Str_conv(Strnew_charp(p), SystemCharset, InnerCharset)));
                            _v1328 = 0;
                            _v1332 = _t373;
                            _v1336 = "">";
                            Strcat_m_charp(tmp);
                            __eflags = (st.st_mode & 61440) - 16384;
                            if((st.st_mode & 61440) == 16384) {
                                _t411 = tmp->length;
                                _t412 = tmp;
                                __eflags = _t411 + 1 - _t412->area_size;
                                if(_t411 + 1 >= _t412->area_size) {
                                    Strgrow(tmp);
                                }
                                _t416 = tmp->length;
                                 *((char*)(tmp->ptr + _t416)) = 47;
                                tmp->length = _t416 + 1;
                                 *(tmp->ptr + tmp->length) = 0;
                            }
                            Strcat_charp(tmp, "</A>");
                            __eflags = multicolList;
                            if(multicolList == 0) {
                                __eflags = (lst.st_mode & 61440) - 40960;
                                if((lst.st_mode & 61440) == 40960) {
                                    l = readlink(fbuf->ptr,  &lbuf, 1024);
                                    __eflags = l;
                                    if(l > 0) {
                                         *(__ebp + l + -1036) = 0;
                                        _t390 = html_quote( *(wc_Str_conv(Strnew_charp( &lbuf), SystemCharset, InnerCharset)));
                                        _v1328 = 0;
                                        _v1332 = _t390;
                                        _v1336 = " -> ";
                                        Strcat_m_charp(tmp);
                                        __eflags = (st.st_mode & 61440) - 16384;
                                        if((st.st_mode & 61440) == 16384) {
                                            _t395 = tmp->length;
                                            _t396 = tmp;
                                            __eflags = _t395 + 1 - _t396->area_size;
                                            if(_t395 + 1 >= _t396->area_size) {
                                                Strgrow(tmp);
                                            }
                                            _t400 = tmp->length;
                                             *((char*)(tmp->ptr + _t400)) = 47;
                                            tmp->length = _t400 + 1;
                                             *(tmp->ptr + tmp->length) = 0;
                                        }
                                    }
                                }
                                Strcat_charp(tmp, "<br>\n");
                            } else {
                                _t407 = n;
                                __eflags = _t407 - nrow;
                                n = n + 1;
                                __eflags = _t407 & 255;
                                if((_t407 & 255) == 0) {
                                    Strcat_charp(tmp, "<BR>\n");
                                } else {
                                    Strcat_charp(tmp, "</NOBR></TD>\n");
                                    n = 1;
                                }
                            }
                        }
                    }
                    goto L58;
                }
                _t445 =  *(fbuf->ptr + fbuf->length - 1) & 255;
                __eflags = (_t445 & 255) - 47;
                if((_t445 & 255) == 47) {
                    goto L26;
                }
                goto L23;
            }
            __eflags = multicolList;
            if(__eflags != 0) {
                Strcat_charp(tmp, "</TR>\n</TABLE>\n");
            }
            Strcat_charp(tmp, "</BODY>\n</HTML>\n");
            _t448 = tmp;
            goto L63;
        }
        _t463 =  *(dirname->ptr + dirname->length - 1) & 255;
        __eflags = (_t463 & 255) - 47;
        if((_t463 & 255) == 47) {
            goto L7;
        }
        goto L4;
    } else {
        _t448 = 0;
    }
L63:
    if(__eflags == 0) {
        return _t448;
    }
    __stack_chk_fail();
    return _t448;
}

int check_local_cgi(char* file, int status)
{// addr = 0x0808AC49  --  defined in 'local.c' at line 191
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    signed int _v84;                       // _cfa_ffffffac
    struct stat st;       // _cfa_ffffff9c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char* _t13;                            // _t13
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28

    if(status != 1) {
        if(status == 2) {
            goto L3;
        } else {
            return -1;
        }
    }
L3:
    _t13 = file;
    __stat(_t13,  &(st.st_dev));
    if(_t13 >= 0) {
        if((_v84 & 61440) != 16384) {
            if(_v76 != geteuid() || (_v84 & 64) == 0) {
                if(_v72 != getegid() || (_v84 & 8) == 0) {
                    if((_v84 & 1) == 0) {
                        return -1;
                    }
                }
            }
            return 0;
        }
    } else {
        return -1;
    }
    return -1;
}

set_environ(char* var, char* value)
{// addr = 0x0808ACDE  --  defined in 'local.c' at line 209
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10

    if(var == 0 || value == 0) {
        return;
    } else {
        setenv(var, value, 1);
        return;
    }
}

set_cgi_environ(char* name, char* fn, char* req_uri)
{// addr = 0x0808AD0C  --  defined in 'local.c' at line 261
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    set_environ("SERVER_SOFTWARE", w3m_version);
    set_environ("SERVER_PROTOCOL", "HTTP/1.0");
    set_environ("SERVER_NAME", "localhost");
    set_environ("SERVER_PORT", "80");
    set_environ("REMOTE_HOST", "localhost");
    set_environ("REMOTE_ADDR", "127.0.0.1");
    set_environ("GATEWAY_INTERFACE", "CGI/1.1");
    set_environ("SCRIPT_NAME", name);
    set_environ("SCRIPT_FILENAME", fn);
    set_environ("REQUEST_URI", req_uri);
    return;
}

Str checkPath(char* fn, char* path)
{// addr = 0x0808ADDA  --  defined in 'local.c' at line 277
    char* p;                               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    struct stat st;       // _cfa_ffffff94
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    char* _t57;                            // _t57
    int _t68;                              // _t68
    char* _t77;                            // _t77
    _unknown_ _t93;                        // _t93

    while(( *path & 0xff) != 0) {
        p = strchr(path, 58);
        if(p == 0) {
            _t57 = path;
        } else {
            _t57 = allocStr(path, p - path);
        }
        tmp = Strnew_charp(expandPath(_t57));
        if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 47) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t68 = tmp->length;
             *((char*)(tmp->ptr + _t68)) = 47;
            tmp->length = _t68 + 1;
             *(tmp->ptr + tmp->length) = 0;
        }
        Strcat_charp(tmp, fn);
        _t77 = tmp->ptr;
        __stat(_t77,  &(st.st_dev));
        if(_t77 != 0) {
            if(p == 0) {
                goto L18;
            }
            goto L12;
L18:
            return 0;
        } else {
            return tmp;
        }
L12:
        path =  &(p[1]);
        while(( *path & 0xff) == 58) {
            path =  &(path[1]);
        }
    }
    goto L18;
}

int cgi_filename(char* uri, char** fn, char** name, char** path_info)
{// addr = 0x0808AF07  --  defined in 'local.c' at line 300
    Str tmp;               // _cfa_fffffff0
    int offset;                            // _cfa_ffffffec
    Str tmp2;              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t143;                             // _t143
    _unknown_ _t159;                       // _t159
    int _t171;                             // _t171
    _unknown_ _t202;                       // _t202
    _unknown_ _t209;                       // _t209
    _unknown_ _t237;                       // _t237
    _unknown_ _t238;                       // _t238

     *fn = uri;
     *name = uri;
     *path_info = 0;
    if(cgi_bin == 0) {
L7:
        tmp = Strnew_charp(w3m_lib_dir());
        if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 47) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t143 = tmp->length;
             *(tmp->ptr + _t143) = 47;
            tmp->length = _t143 + 1;
             *(tmp->ptr + tmp->length) = 0;
        }
        if(strncmp(uri, "/$LIB/", 6) != 0) {
            if(strncmp(uri, tmp->ptr, tmp->length) != 0) {
                if(( *uri & 0xff) != 47 || document_root == 0) {
L26:
                    return 0;
                } else {
                    tmp2 = Strnew_charp(document_root);
                    if(tmp2->length <= 0 || ( *(tmp2->ptr + tmp2->length - 1) & 0xff) != 47) {
                        if(tmp2->length + 1 >= tmp2->area_size) {
                            Strgrow(tmp2);
                        }
                        _t171 = tmp2->length;
                         *(tmp2->ptr + _t171) = 47;
                        tmp2->length = _t171 + 1;
                         *(tmp2->ptr + tmp2->length) = 0;
                    }
                    Strcat_charp(tmp2,  &(uri[1]));
                    if(strncmp(tmp2->ptr, tmp->ptr, tmp->length) == 0) {
                        uri = tmp2->ptr;
                         *name = uri;
                        offset = tmp->length;
                        goto L27;
                    } else {
                        return 0;
                    }
                    goto L26;
                }
                goto L27;
            }
        } else {
            offset = 6;
L27:
             *path_info = strchr( &(uri[offset]), 47);
            if( *path_info != 0) {
                 *name = allocStr(uri,  *path_info - uri);
            }
            Strcat_charp(tmp,  &(( *name)[offset]));
             *fn = tmp->ptr;
            return 1;
        }
        offset = tmp->length;
        goto L27;
    }
    if(strncmp(uri, "/cgi-bin/", 9) != 0) {
        goto L7;
    } else {
        offset = 9;
         *path_info = strchr( &(uri[offset]), 47);
        if( *path_info != 0) {
             *name = allocStr(uri,  *path_info - uri);
        }
    }
    tmp = checkPath( &(( *name)[offset]), cgi_bin);
    if(tmp != 0) {
         *fn = tmp->ptr;
        return 2;
    }
    return 0;
    goto L7;
}

FILE* localcgi_post(char* uri, char* qstr, FormList* request, char* referer)
{// addr = 0x0808B234  --  defined in 'local.c' at line 356
    FILE* fr;             // _cfa_fffffff0
    FILE* fw;             // _cfa_ffffffec
    int status;                            // _cfa_ffffffe8
    pid_t pid;           // _cfa_ffffffe4
    char* file;                            // _cfa_ffffffe0
    char* name;                            // _cfa_ffffffdc
    char* path_info;                       // _cfa_ffffffd8
    char* tmpf;                            // _cfa_ffffffd4
    char* _v60;                            // _cfa_ffffffc4
    FILE* _v64;           // _cfa_ffffffc0
    FILE* _v68;           // _cfa_ffffffbc
    long unsigned int _v72;                // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    int _t120;                             // _t120
    char* _t123;                           // _t123
    _unknown_ _t126;                       // _t126
    _unknown_ _t129;                       // _t129
    char* _t131;                           // _t131
    _unknown_ _t132;                       // _t132
    char* _t135;                           // _t135
    char* _t137;                           // _t137
    _unknown_ _t138;                       // _t138
    _unknown_ _t149;                       // _t149
    _unknown_ _t151;                       // _t151
    _unknown_ _t154;                       // _t154
    _unknown_ _t162;                       // _t162
    _unknown_ _t173;                       // _t173
    _unknown_ _t174;                       // _t174
    _unknown_ _t181;                       // _t181
    _unknown_ _t182;                       // _t182

    fr = 0;
    fw = 0;
    file = uri;
    name = uri;
    path_info = 0;
    tmpf = 0;
    status = cgi_filename(uri,  &file,  &name,  &path_info);
    if(check_local_cgi(file, status) < 0) {
        return 0;
    }
    writeLocalCookie();
    if(request == 0 || request->enctype == 1) {
L6:
        pid = open_pipe_rw( &fr, 0);
        if(pid >= 0) {
            if(pid == 0) {
                if(fw == 0) {
                    _t120 = -1;
                } else {
                    _t120 = fileno(fw);
                }
                setup_child(1, 2, _t120);
                if(qstr != 0) {
                    _v64 = 0;
                    _v68 = qstr;
                    _v72 = "?";
                    uri =  *(Strnew_m_charp(uri));
                }
                set_cgi_environ(name, file, uri);
                if(path_info != 0) {
                    set_environ("PATH_INFO", path_info);
                }
                if(referer != 0 && referer != 255) {
                    set_environ("HTTP_REFERER", referer);
                }
                if(request == 0) {
                    set_environ("REQUEST_METHOD", "GET");
                    if(qstr == 0) {
                        _t123 = 135051494;
                    } else {
                        _t123 = qstr;
                    }
                    set_environ("QUERY_STRING", _t123);
                    freopen("/dev/null", "r", __imp__stdin);
                } else {
                    set_environ("REQUEST_METHOD", "POST");
                    if(qstr != 0) {
                        set_environ("QUERY_STRING", qstr);
                    }
                    _v72 = request->length;
                    set_environ("CONTENT_LENGTH",  *(Sprintf("%d")));
                    if(request->enctype != 1) {
                        set_environ("CONTENT_TYPE", "application/x-www-form-urlencoded");
                        fwrite(request->body, 1, request->length, fw);
                        fclose(fw);
                        freopen(tmpf, "r", __imp__stdin);
                    } else {
                        _v72 = request->boundary;
                        set_environ("CONTENT_TYPE",  *(Sprintf("multipart/form-data; boundary=%s")));
                        freopen(request->body, "r", __imp__stdin);
                    }
                }
                chdir(mydirname(file));
                _t131 = mybasename(file);
                _v68 = 0;
                execl(file, _t131);
                _t135 = strerror( *(__errno_location()));
                _t137 = mybasename(file);
                _v60 = _t135;
                _v64 = _t137;
                _v68 = file;
                fprintf(__imp__stderr, "execl("%s", "%s", NULL): %s\n");
                return exit(1);
            }
            goto L9;
        }
        goto L7;
L9:
        if(fw != 0) {
            fclose(fw);
        }
        return fr;
    } else {
        tmpf =  *(tmpfname(0, 0));
        fw = fopen(tmpf, "w");
        if(fw != 0) {
            goto L6;
        }
        return 0;
    }
L7:
    return 0;
}

struct form_list* newFormList(char* action, char* method, char* charset, char* enctype, char* target, char* name, struct form_list* _next)
{// addr = 0x0808B5F0  --  defined in 'form.c' at line 38
    struct form_list* l;   // _cfa_fffffff0
    Str a;                 // _cfa_ffffffec
    int m;                                 // _cfa_ffffffe8
    int e;                                 // _cfa_ffffffe4
    wc_ces c;           // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t61;                              // _t61

    _t61 = Strnew_charp(action);
    a = _t61;
    m = 0;
    e = 0;
    c = 0;
    if(method == 0) {
L2:
        m = 0;
L7:
        if(enctype != 0) {
            _t61 = strcasecmp(enctype, "multipart/form-data");
            if(_t61 == 0) {
                e = 1;
                if(m == 0) {
                    m = 1;
                }
            }
        }
        if(charset != 0) {
            _t61 = wc_guess_charset(charset, 0);
            c = _t61;
        }
         *__esp = 52;
        GC_malloc();
        l = _t61;
        l->lastitem = 0;
        l->item = l->lastitem;
         *(l + 12) = a;
        l->method = m;
         *(l + 24) = c;
        l->enctype = e;
        l->target = target;
        l->name = name;
        l->next = _next;
        l->nitems = 0;
        l->body = 0;
        l->length = 0;
        return l;
    }
    _t61 = strcasecmp(method, "get");
    if(_t61 != 0) {
        _t61 = strcasecmp(method, "post");
        if(_t61 != 0) {
            _t61 = strcasecmp(method, "internal");
            if(_t61 == 0) {
                m = 2;
            }
        } else {
            m = 1;
        }
        goto L7;
    }
    goto L2;
}

struct form_item_list* formList_addInput(struct form_list* fl, struct parsed_tag* tag)
{// addr = 0x0808B750  --  defined in 'form.c' at line 89
    struct form_item_list* item;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct form_item_list* _t195;   // _t195
    int _t219;                             // _t219
    int _t224;                             // _t224
    _unknown_ _t228;                       // _t228
    _unknown_ _t232;                       // _t232
    int _t235;                             // _t235
    _unknown_ _t264;                       // _t264
    _unknown_ _t273;                       // _t273
    _unknown_ _t283;                       // _t283
    _unknown_ _t347;                       // _t347

    if(fl == 0) {
        return 0;
    }
     *__esp = 72;
    GC_malloc();
    item = _t195;
    item->type = -1;
    item->size = -1;
    item->rows = 0;
    item->init_checked = 0;
    item->checked = item->init_checked;
    item->accept = 0;
     *(item + 4) = 0;
     *(item + 12) = 0;
     *(item + 8) =  *(item + 12);
    item->readonly = 0;
    if(parsedtag_get_value(tag, 33,  &p) != 0) {
        item->type = formtype(p);
        if(item->size < 0) {
            if(item->type == 0 || item->type == 11 || item->type == 1) {
                item->size = 40;
            }
        }
    }
    if(parsedtag_get_value(tag, 25,  &p) != 0) {
         *(item + 4) = Strnew_charp(p);
    }
    if(parsedtag_get_value(tag, 36,  &p) != 0) {
         *(item + 12) = Strnew_charp(p);
         *(item + 8) =  *(item + 12);
    }
    if(tag->map == 0 || (tag->map[0xc] & 0xff) == 75) {
L16:
        _t219 = 0;
    } else {
        if((tag->attrid[tag->map[0xc] & 0xff] & 0xff) == 0) {
            goto L16;
        } else {
            _t219 = 1;
        }
    }
    item->init_checked = _t219;
    item->checked = item->init_checked;
    if(tag->map == 0 || (tag->map[1] & 0xff) == 75 || (tag->attrid[tag->map[1] & 0xff] & 0xff) == 0) {
        _t224 = 0;
    } else {
        _t224 = 1;
    }
    item->accept = _t224;
    parsedtag_get_value(tag, 30,  &(item->size));
    parsedtag_get_value(tag, 22,  &(item->maxlength));
    if(tag->map == 0 || (tag->map[0x2b] & 0xff) == 75 || (tag->attrid[tag->map[0x2b] & 0xff] & 0xff) == 0) {
        _t235 = 0;
    } else {
        _t235 = 1;
    }
    item->readonly = _t235;
    if(parsedtag_get_value(tag, 73,  &i) != 0) {
         *(item + 12) =  *(textarea_str + (i << 2));
         *(item + 8) =  *(item + 12);
    }
    if(parsedtag_get_value(tag, 72,  &i) != 0) {
        item->select_option =  *(select_option + (i << 3));
    }
    if(parsedtag_get_value(tag, 28,  &p) != 0) {
        item->rows = atoi(p);
    }
    if(item->type != 255) {
        if(item->type == 8) {
            chooseSelectOption(item, item->select_option);
            item->init_selected = item->selected;
             *(item + 12) =  *(item + 8);
             *((intOrPtr*)(item + 52)) =  *((intOrPtr*)(item + 48));
        }
        if(item->type != 11 ||  *(item + 8) == 0 ||  *(item + 8)->length == 0) {
            item->parent = fl;
            item->next = 0;
            if(fl->item != 0) {
                fl->lastitem->next = item;
                fl->lastitem = item;
            } else {
                fl->lastitem = item;
                fl->item = fl->lastitem;
            }
            if(item->type != 6) {
                fl->nitems =  &(fl->nitems->type);
                return item;
            }
            return 0;
        }
        return 0;
    }
    return 0;
}

char* form2str(FormItemList* fi)
{// addr = 0x0808BB58  --  defined in 'form.c' at line 174
    Str tmp;               // _cfa_fffffff0
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t51;                        // _t51

    tmp = Strnew();
    if(fi->type != 8) {
        if(fi->type != 9) {
            Strcat_charp(tmp, "input type=");
        }
    }
    Strcat_charp(tmp,  *( &_formtypetbl + fi->type * 4));
    if( *((intOrPtr*)(fi + 4)) != 0 &&  *((intOrPtr*)( *((intOrPtr*)(fi + 4)) + 4)) != 0) {
        _v44 = 0;
        _v48 = """;
        _v52 =  *((intOrPtr*)( *((intOrPtr*)(fi + 4))));
        _v56 = " name="";
        Strcat_m_charp(tmp);
    }
    if(fi->type == 3 || fi->type == 2 || fi->type == 8) {
        if( *((intOrPtr*)(fi + 8)) != 0) {
            _v44 = 0;
            _v48 = """;
            _v52 =  *((intOrPtr*)( *((intOrPtr*)(fi + 8))));
            _v56 = " value="";
            Strcat_m_charp(tmp);
        }
    }
    _v36 = 0;
    _v40 = ")";
    _v44 =  *((intOrPtr*)( *((intOrPtr*)(fi->parent + 12))));
    _v48 = " ";
    _v52 =  *((intOrPtr*)( &_formmethodtbl + fi->parent->method * 4));
    _v56 = " (";
    Strcat_m_charp(tmp);
    return tmp->ptr;
}

int formtype(char* typestr)
{// addr = 0x0808BC9A  --  defined in 'form.c' at line 192
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    i = 0;
    while( *( &_formtypetbl + i * 4) != 0) {
        if(strcasecmp(typestr,  *( &_formtypetbl + i * 4)) != 0) {
            i = i + 1;
            continue;
        }
        return i;
    }
    return -1;
}

formRecheckRadio(Anchor* a, Buffer* buf, FormItemList* fi)
{// addr = 0x0808BCE4  --  defined in 'form.c' at line 203
    int i;                                 // _cfa_fffffff0
    Anchor* a2;         // _cfa_ffffffec
    FormItemList* f2;   // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    i = 0;
    while(buf->formitem->nanchor > i) {
        i = i + 1;
    }
    fi->checked = 1;
    formUpdateBuffer(a, buf, fi);
    return;
}

formResetBuffer(Buffer* buf, AnchorList* formitem)
{// addr = 0x0808BDC2  --  defined in 'form.c' at line 223
    int i;                                 // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    FormItemList* f1;   // _cfa_ffffffe8
    FormItemList* f2;   // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t95;                        // _t95
    AnchorList* _t99;   // _t99
    char* _t127;                           // _t127
    signed int _t129;                      // _t129
    signed int _t130;                      // _t130
    _unknown_ _t165;                       // _t165
    char* _t176;                           // _t176
    _unknown_ _t177;                       // _t177

    if(buf == 0) {
        return;
    }
    if(buf->formitem == 0) {
        goto L29;
    }
    if(formitem != 0) {
        i = 0;
        while(1) {
            _t99 = buf->formitem;
            _t100 = _t99->nanchor;
            if(_t99->nanchor <= i) {
                break;
            }
            if(formitem->nanchor > i) {
                a = buf->formitem->anchors + (i << 2 << 4) - (i << 2);
                if((a->y & 0xffff) !=  *((intOrPtr*)(a + 20))) {
L24:
                    i = i + 1;
                    continue;
                }
                f1 = a->url;
                f2 =  *(formitem->anchors + (i << 2 << 4) - (i << 2));
                _t100 = f2->type;
                if(f1->type != f2->type) {
                } else {
                    if( *(f2 + 4) == 0) {
                        _t176 = 135051758;
                    } else {
                        _t176 =  *( *(f2 + 4));
                    }
                    if( *(f1 + 4) == 0) {
                        _t127 = 135051758;
                    } else {
                        _t127 =  *( *(f1 + 4));
                    }
                    if(strcmp(_t127, _t176) != 0) {
                    } else {
                        _t129 = f1->type;
                        if(_t129 > 11) {
                        } else {
                            _t130 = 1 << (_t129 & 255);
                            if((_t130 & 2563) != 0) {
                                 *((intOrPtr*)(f1 + 8)) =  *((intOrPtr*)(f2 + 8));
                                 *((intOrPtr*)(f1 + 12)) =  *((intOrPtr*)(f2 + 12));
L21:
                                formUpdateBuffer(a, buf, f1);
                                goto L24;
                            }
                            if((_t130 & 256) != 0) {
                                f1->select_option = f2->select_option;
                                 *((intOrPtr*)(f1 + 8)) =  *((intOrPtr*)(f2 + 8));
                                 *((intOrPtr*)(f1 + 48)) =  *((intOrPtr*)(f2 + 48));
                                f1->selected = f2->selected;
                                 *((intOrPtr*)(f1 + 12)) =  *((intOrPtr*)(f2 + 12));
                                 *((intOrPtr*)(f1 + 52)) =  *((intOrPtr*)(f2 + 52));
                                f1->init_selected = f2->init_selected;
                                goto L21;
                            }
                            if((_t130 & 12) != 0) {
                                f1->checked = f2->checked;
                                f1->init_checked = f2->init_checked;
                                goto L21;
                            }
                        }
                        goto L24;
                    }
                }
                goto L31;
L32:
            }
            return;
        }
    }
L31:
    return;
    goto L32;
L29:
    return;
}

int form_update_line(Line* line, char** str, int spos, int epos, int width, int newline, int password)
{// addr = 0x0808BFC3  --  defined in 'form.c' at line 273
    Lineprop c_type;   // _cfa_fffffff2
    Lineprop effect;   // _cfa_fffffff0
    int c_len;                             // _cfa_ffffffec
    int c_width;                           // _cfa_ffffffe8
    int w;                                 // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int len;                               // _cfa_ffffffdc
    int pos;                               // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    char* buf;                             // _cfa_ffffffd0
    Lineprop* prop;   // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char* _t359;                           // _t359
    Lineprop* _t361;   // _t361
    _unknown_ _t364;                       // _t364
    _unknown_ _t368;                       // _t368
    _unknown_ _t390;                       // _t390
    _unknown_ _t397;                       // _t397
    int _t431;                             // _t431
    signed int _t466;                      // _t466
    int _t493;                             // _t493
    char* _t555;                           // _t555

    c_len = 1;
    c_width = 1;
    p =  *str;
    w = 0;
    pos = 0;
    while(( *p & 0xff) != 0) {
        if(w < width) {
            c_type = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8 & 65535;
            c_len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
            if(( *135119023 & 0xff) == 0) {
                _t493 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            } else {
                _t493 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            }
            c_width = _t493;
            if(c_type != 256) {
                if(password == 0) {
                    if((c_type & 0x1000) == 0) {
                        if(w + c_width > width) {
L22:
                            break;
                        }
                        goto L15;
                    }
                    goto L13;
L15:
                    w = w + c_width;
                    pos = pos + c_len;
                    goto L16;
                }
                goto L10;
L13:
                w = w + 1;
                pos = pos + 1;
                goto L16;
            }
            if(newline == 0 || ( *p & 0xff) != 10) {
                if(( *p & 0xff) != 13) {
                    w = w + 1;
                    pos = pos + 1;
                }
L16:
                p =  &(p[c_len]);
                continue;
            }
            break;
L10:
            if(w + c_width > width) {
                break;
            }
            w = w + c_width;
            pos = pos + c_width;
            goto L16;
        }
        break;
    }
    pos = pos + width - w;
    len = line->len + pos + spos - epos;
    _t359 = len;
     *__esp = _t359;
    GC_malloc();
    buf = _t359;
    _t361 = len + len;
     *__esp = _t361;
    GC_malloc();
    prop = _t361;
    bcopy(line->lineBuf, buf, spos);
    bcopy(line->propBuf, prop, spos + spos);
    effect =  *(line->propBuf + spos + spos) & 0xffff;
    p =  *str;
    w = 0;
    pos = spos;
    while(( *p & 0xff) != 0) {
        if(w < width) {
            c_type = ( *( &WTF_TYPE_MAP + ( *p & 0xff)) & 0xff) << 8 & 65535;
            c_len =  *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff;
            if(( *135119023 & 0xff) == 0) {
                _t431 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            } else {
                _t431 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            }
            c_width = _t431;
            if(c_type != 256) {
                if(password == 0) {
                    if((c_type & 0x1000) == 0) {
                        if(w + c_width <= width) {
                            buf[pos] =  *p & 0xff;
                             *(pos + pos + prop) = (c_type & 65535 | effect & 65535) & 65535;
                            pos = pos + 1;
                            c_type = c_type & 0xffff;
                            i = 1;
L49:
                            while(i < c_len) {
                                goto L48;
                            }
                            w = w + c_width;
                            goto L51;
                        }
                        goto L46;
L48:
                        buf[pos] = p[i] & 0xff;
                         *(pos + pos + prop) = (c_type & 65535 | effect & 65535) & 65535;
                        pos = pos + 1;
                        i = i + 1;
                        goto L49;
                    }
                    goto L44;
L46:
                    goto L55;
                }
                goto L37;
L44:
                buf[pos] = 32;
                 *(pos + pos + prop) = effect & 0xffff;
                pos = pos + 1;
                w = w + 1;
                goto L51;
            } else {
                if(newline == 0 || ( *p & 0xff) != 10) {
                    if(( *p & 0xff) != 13) {
                        _t555 =  &(buf[pos]);
                        if(password == 0) {
                            _t466 = 32;
                        } else {
                            _t466 = 42;
                        }
                         *_t555 = _t466 & 255;
                         *(pos + pos + prop) = effect & 0xffff;
                        pos = pos + 1;
                        w = w + 1;
                    }
L51:
                    p =  &(p[c_len]);
                    continue;
                }
L55:
L57:
                while(w < width) {
                    buf[pos] = 32;
                     *(pos + pos + prop) = effect & 0xffff;
                    pos = pos + 1;
                    w = w + 1;
                }
                if(newline == 0) {
L69:
                     *str = p;
                    bcopy(line->lineBuf + epos,  &(buf[pos]), line->len - epos);
                    bcopy(line->propBuf + epos + epos, pos + pos + prop, line->len - epos + line->len - epos);
                    line->lineBuf = buf;
                    line->propBuf = prop;
                    line->len = len;
                    line->size = len;
                    return pos;
                }
                if(FoldTextarea != 0) {
L65:
                    if(( *p & 0xff) == 13) {
                        p =  &(p[1]);
                    }
                    if(( *p & 0xff) == 10) {
                        p =  &(p[1]);
                    }
                    goto L69;
                }
                while(( *p & 0xff) != 0 && ( *p & 0xff) != 13 && ( *p & 0xff) != 10) {
                    p =  &(p[1]);
                }
                goto L65;
            }
L37:
            if(w + c_width <= width) {
                i = 0;
L41:
                while(i < c_width) {
                    goto L40;
                }
                goto L51;
            }
            goto L55;
L40:
            buf[pos] = 42;
             *(pos + pos + prop) = effect & 0xffff;
            pos = pos + 1;
            w = w + 1;
            i = i + 1;
            goto L41;
        }
        goto L57;
    }
    goto L57;
}

formUpdateBuffer(Anchor* a, Buffer* buf, FormItemList* form)
{// addr = 0x0808C4B8  --  defined in 'form.c' at line 412
    char* p;                               // _cfa_ffffffe0
    int spos;                              // _cfa_ffffffdc
    int epos;                              // _cfa_ffffffd8
    int rows;                              // _cfa_ffffffd4
    int c_rows;                            // _cfa_ffffffd0
    int pos;                               // _cfa_ffffffcc
    int col;                               // _cfa_ffffffc8
    Line* l;              // _cfa_ffffffc4
    int n;                                 // _cfa_ffffffc0
    Buffer save;        // _cfa_fffffebc
    _unknown_ _v340;                       // _cfa_fffffeac
    _unknown_ _v344;                       // _cfa_fffffea8
    _unknown_ _v348;                       // _cfa_fffffea4
    _unknown_ _v352;                       // _cfa_fffffea0
    _unknown_ _v356;                       // _cfa_fffffe9c
    _unknown_ _v360;                       // _cfa_fffffe98
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t220;                      // _t220
    signed int _t228;                      // _t228
    signed int _t232;                      // _t232
    int _t244;                             // _t244
    _unknown_ _t333;                       // _t333
    _unknown_ _t349;                       // _t349
    _unknown_ _t362;                       // _t362
    _unknown_ _t379;                       // _t379

    col = 0;
    copyBuffer( &(save.filename), buf);
    gotoLine(buf,  *(a + 20));
    _t220 = form->type;
    if(_t220 > 11 || (1 << (_t220 & 255) & 2831) == 0) {
        spos =  *(a + 24) + 1;
        epos =  *(a + 36) - 1;
    } else {
        spos =  *(a + 24);
        epos =  *(a + 36);
    }
    _t228 = form->type;
    if(_t228 > 11) {
L40:
        copyBuffer(buf,  &(save.filename));
        arrangeLine(buf);
        return;
    } else {
        _t232 = 1 << (_t228 & 255);
        if((_t232 & 2819) != 0) {
            if(form->type != 8) {
                p =  *( *(form + 8));
            } else {
                p =  *( *(form + 48));
                updateSelectOption(form, form->select_option);
            }
            l = buf->currentLine;
            if(form->type != 9) {
L26:
                if(form->rows == 0) {
                    _t244 = 1;
                } else {
                    _t244 = form->rows;
                }
                rows = _t244;
                col = calcPosition(l->lineBuf, l->propBuf, l->len,  *(a + 24), 0, 0);
                c_rows = 0;
                while(c_rows < rows) {
                    if(rows <= 1) {
L33:
                        _t253 = form->type;
                        pos = form_update_line(l,  &p, spos, epos, calcPosition(l->lineBuf, l->propBuf, l->len, epos, 0, 0) - col, form->type & 0xff, _t253 & 0xff);
                        if(pos != epos) {
                            shiftAnchorPosition(buf->href, buf->hmarklist,  *(a + 20), spos, pos - epos);
                            shiftAnchorPosition(buf->name, buf->hmarklist,  *(a + 20), spos, pos - epos);
                            shiftAnchorPosition(buf->img, buf->hmarklist,  *(a + 20), spos, pos - epos);
                            shiftAnchorPosition(buf->formitem, buf->hmarklist,  *(a + 20), spos, pos - epos);
                        }
                        c_rows = c_rows + 1;
                        l = l->next;
                        continue;
                    }
                    pos = columnPos(l, col);
                    a = retrieveAnchor(buf->formitem, l->linenumber, pos);
                    if(a == 0) {
                        goto L39;
                    }
                    spos =  *(a + 24);
                    epos =  *(a + 36);
                    goto L33;
                }
                goto L40;
            } else {
                n = (a->y & 0xffff) - buf->currentLine->linenumber;
                if(n <= 0) {
                    if(n >= 0) {
                        goto L25;
                    }
                    goto L21;
                }
                while(l != 0) {
                    if(n != 0) {
                        l = l->prev;
                        n = n - 1;
                        continue;
                    }
                    break;
                }
L25:
                if(l == 0) {
                    goto L40;
                }
                goto L26;
L39:
                goto L40;
L21:
                while(l != 0 && n != 0) {
                    l = l->prev;
                    n = n + 1;
                }
                goto L25;
            }
        }
        if((_t232 & 12) != 0) {
            if(form->checked == 0) {
                buf->currentLine->lineBuf[spos] = 32;
            } else {
                buf->currentLine->lineBuf[spos] = 42;
            }
        }
        goto L40;
    }
}

Str textfieldrep(Str s, int width)
{// addr = 0x0808C8CE  --  defined in 'form.c' at line 502
    Lineprop c_type;   // _cfa_fffffff2
    Str n;                 // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int j;                                 // _cfa_ffffffe4
    int k;                                 // _cfa_ffffffe0
    int c_len;                             // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t183;                      // _t183
    int _t215;                             // _t215
    int _t228;                             // _t228
    int _t242;                             // _t242

    n = Strnew_size(width + 2);
    j = 0;
    i = 0;
    while(s->length > i) {
        c_type = ( *( &WTF_TYPE_MAP + (s->ptr[i] & 0xff)) & 0xff) << 8 & 65535;
        c_len =  *( &WTF_LEN_MAP + (s->ptr[i] & 0xff)) & 0xff;
        if((s->ptr[i] & 0xff) != 13) {
            if(( *135119023 & 0xff) == 0) {
                _t183 =  *( &WTF_WIDTH_MAP + (s->ptr[i] & 0xff)) & 0xff;
            } else {
                _t183 =  *( &WTF_WIDTH_MAP + (s->ptr[i] & 0xff)) & 0xff;
            }
            k = _t183 + j;
            if(k <= width) {
                if(c_type != 256) {
                    if((c_type & 0x1000) == 0) {
                        if((s->ptr[i] & 0xff) != 38) {
                            if((s->ptr[i] & 0xff) != 60) {
                                if((s->ptr[i] & 0xff) != 62) {
                                    Strcat_charp_n(n,  &(s->ptr[i]), c_len);
                                } else {
                                    Strcat_charp(n, "&gt;");
                                }
                            } else {
                                Strcat_charp(n, "&lt;");
                            }
                        } else {
                            Strcat_charp(n, "&amp;");
                        }
                    } else {
                        if(n->length + 1 >= n->area_size) {
                            Strgrow(n);
                        }
                        _t215 = n->length;
                         *((char*)(n->ptr + _t215)) = 32;
                        n->length = _t215 + 1;
                         *(n->ptr + n->length) = 0;
                    }
                } else {
                    if(n->length + 1 >= n->area_size) {
                        Strgrow(n);
                    }
                    _t228 = n->length;
                     *((char*)(n->ptr + _t228)) = 32;
                    n->length = _t228 + 1;
                     *(n->ptr + n->length) = 0;
                }
                j = k;
                goto L24;
            }
L30:
            while(j < width) {
                if(n->length + 1 >= n->area_size) {
                    Strgrow(n);
                }
                _t242 = n->length;
                 *((char*)(n->ptr + _t242)) = 32;
                n->length = _t242 + 1;
                 *(n->ptr + n->length) = 0;
                j = j + 1;
            }
            return n;
        }
L24:
        i = i + c_len;
    }
    goto L30;
}

form_fputs_decode(Str s, FILE* f)
{// addr = 0x0808CB78  --  defined in 'form.c' at line 539
    char* p;                               // _cfa_fffffff0
    Str z;                 // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t47;                        // _t47
    int _t62;                              // _t62
    _unknown_ _t79;                        // _t79

    z = Strnew();
    p = s->ptr;
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) == 13 && (p[1] & 0xff) == 10) {
            p =  &(p[1]);
        }
        if(z->length + 1 >= z->area_size) {
            Strgrow(z);
        }
        _t62 = z->length;
         *(z->ptr + _t62) =  *p & 0xff;
        z->length = _t62 + 1;
         *((char*)(z->ptr + z->length)) = 0;
        p =  &(p[1]);
    }
    z = wc_Str_conv_strict(z, InnerCharset, DisplayCharset);
    fwrite(z->ptr, 1, z->length, f);
    return;
}

input_textarea(FormItemList* fi)
{// addr = 0x0808CC57  --  defined in 'form.c' at line 567
    wc_uint8 auto_detect;   // _cfa_fffffff3
    char* tmpf;                            // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    FILE* f;              // _cfa_ffffffe4
    wc_ces charset;     // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t78;                        // _t78
    _unknown_ _t87;                        // _t87
    _unknown_ _t91;                        // _t91
    _unknown_ _t135;                       // _t135
    _unknown_ _t137;                       // _t137

    tmpf =  *(tmpfname(0, 0));
    charset = DisplayCharset;
    f = fopen(tmpf, "w");
    if(f == 0) {
        disp_err_message("Can't open temporary file", 0);
        return;
    }
    if( *(fi + 8) != 0) {
        form_fputs_decode( *(fi + 8), f);
    }
    fclose(f);
    fmTerm();
    system( *(myEditor(Editor, tmpf, 1)));
    fmInit();
    if(fi->readonly != 0) {
        goto L19;
    }
    f = fopen(tmpf, "r");
    if(f != 0) {
         *(fi + 8) = Strnew();
        auto_detect = WcOption.auto_detect & 0xff;
        WcOption.auto_detect = 2;
        while(1) {
L16:
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            goto L8;
        }
        WcOption.auto_detect = auto_detect & 0xff;
        fclose(f);
        goto L19;
    }
    disp_err_message("Can't open temporary file", 0);
    goto L19;
L8:
    if(tmp->length != 1 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 10) {
        if(tmp->length > 1 && ( *(tmp->ptr + tmp->length - 1) & 0xff) == 10 && ( *(tmp->ptr + tmp->length - 2) & 0xff) != 13) {
            Strshrink(tmp, 1);
            Strcat_charp(tmp, "\n");
        }
    } else {
        tmp = Strnew_charp("\n");
    }
    tmp = convertLine(0, tmp, 0,  &charset, DisplayCharset);
    Strcat( *(fi + 8), tmp);
    goto L16;
L19:
    unlink(tmpf);
    return;
}

do_internal(char* action, char* data)
{// addr = 0x0808CE8B  --  defined in 'form.c' at line 626
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    i = 0;
    while( *( &internal_action + i * 8) != 0) {
        if(strcasecmp( *( &internal_action + i * 8), action) != 0) {
            i = i + 1;
            continue;
        }
        if( *((intOrPtr*)(135091940 + i * 8)) != 0) {
             *__esp = cgistr2tagarg(data);
             *((intOrPtr*)( *((intOrPtr*)(135091940 + i * 8))))();
            return;
        }
        return;
    }
    return;
}

addSelectOption(FormSelectOption* fso, Str value, Str label, int chk)
{// addr = 0x0808CEFD  --  defined in 'form.c' at line 641
    FormSelectOptionItem* o;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

     *__esp = 16;
    GC_malloc();
    o = __eax;
    if(value == 0) {
        value = label;
    }
    o->value = value;
    Strremovefirstspaces(label);
    Strremovetrailingspaces(label);
     *(o + 4) = label;
    o->checked = chk;
    o->next = 0;
    if(fso->first != 0) {
        fso->last->next = o;
        fso->last = o;
        return;
    }
    fso->last = o;
    fso->first = fso->last;
    return;
}

chooseSelectOption(FormItemList* fi, FormSelectOptionItem* item)
{// addr = 0x0808CF8E  --  defined in 'form.c' at line 662
    FormSelectOptionItem* opt;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    fi->selected = 0;
    if(item != 0) {
         *(fi + 8) = item->value;
         *(fi + 48) =  *(item + 4);
        i = 0;
        opt = item;
L6:
        while(opt != 0) {
            goto L3;
        }
L7:
        updateSelectOption(fi, item);
        return;
    }
     *(fi + 8) = Strnew_size(0);
     *(fi + 48) = Strnew_size(0);
    return;
L3:
    if(opt->checked == 0) {
        i = i + 1;
        opt = opt->next;
        goto L6;
    }
     *(fi + 8) = opt->value;
     *(fi + 48) =  *(opt + 4);
    fi->selected = i;
    goto L7;
}

updateSelectOption(FormItemList* fi, FormSelectOptionItem* item)
{// addr = 0x0808D043  --  defined in 'form.c' at line 687
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    if(fi == 0) {
        return;
    }
    if(item == 0) {
    } else {
        i = 0;
        while(item != 0) {
            if(fi->selected != i) {
                item->checked = 0;
            } else {
                item->checked = 1;
            }
            i = i + 1;
            item = item->next;
        }
        return;
    }
    goto L10;
L11:
    return;
L10:
    goto L11;
}

int formChooseOptionByMenu(struct form_item_list* fi, int x, int y)
{// addr = 0x0808D09A  --  defined in 'form.c' at line 702
    int i;                                 // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    int selected;                          // _cfa_ffffffe8
    int init_select;                       // _cfa_ffffffe4
    FormSelectOptionItem* opt;   // _cfa_ffffffe0
    char** label;                          // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    char** _t78;                           // _t78
    _unknown_ _t103;                       // _t103
    _unknown_ _t109;                       // _t109

    selected = -1;
    init_select = fi->selected;
    n = 0;
    opt = fi->select_option;
    while(opt != 0) {
        n = n + 1;
        opt = opt->next;
    }
    _t78 = n + 1 << 2;
     *__esp = _t78;
    GC_malloc();
    label = _t78;
    i = 0;
    opt = fi->select_option;
    while(opt != 0) {
        label[i] =  *((char**)( *(opt + 4)));
        i = i + 1;
        opt = opt->next;
    }
    label[n] = 0;
    optionMenu(x, y, label,  &selected, init_select, 0);
    if(selected >= 0) {
        i = 0;
        opt = fi->select_option;
L12:
        while(opt != 0) {
            goto L9;
        }
L13:
        updateSelectOption(fi, fi->select_option);
        return 1;
    }
    return 0;
L9:
    if(i != selected) {
        i = i + 1;
        opt = opt->next;
        goto L12;
    }
    fi->selected = selected;
     *(fi + 8) = opt->value;
     *(fi + 48) =  *(opt + 4);
    goto L13;
}

form_write_data(FILE* f, char* boundary, char* name, char* value)
{// addr = 0x0808D1D8  --  defined in 'form.c' at line 732
    char* _v20;                            // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t18;                        // _t18
    _unknown_ _t21;                        // _t21

    _v20 = boundary;
    fprintf(f, "--%s\n");
    _v20 = name;
    fprintf(f, "Content-Disposition: form-data; name="%s"\n\n");
    _v20 = value;
    fprintf(f, "%s\n");
    return;
}

form_write_from_file(FILE* f, char* boundary, char* name, char* filename, char* file)
{// addr = 0x0808D231  --  defined in 'form.c' at line 740
    FILE* fd;             // _cfa_fffffff0
    int c;                                 // _cfa_ffffffec
    char* type;                            // _cfa_ffffffe8
    signed int _v96;                       // _cfa_ffffffa0
    struct stat st;       // _cfa_ffffff90
    char* _v128;                           // _cfa_ffffff80
    char* _v132;                           // _cfa_ffffff7c
    _unknown_ _v136;                       // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39
    _unknown_ _t44;                        // _t44
    char* _t47;                            // _t47
    _unknown_ _t49;                        // _t49
    char* _t50;                            // _t50
    _unknown_ _t52;                        // _t52
    _unknown_ _t61;                        // _t61
    _unknown_ _t63;                        // _t63

    _v132 = boundary;
    fprintf(f, "--%s\n");
    _v128 = mybasename(filename);
    _v132 = name;
    fprintf(f, "Content-Disposition: form-data; name="%s"; filename="%s"\n");
    type = guessContentType(file);
    if(type == 0) {
        _t47 = "application/octet-stream";
    } else {
        _t47 = type;
    }
    _v132 = _t47;
    fprintf(f, "Content-Type: %s\n\n");
    _t50 = file;
    __lstat(_t50,  &(st.st_dev));
    if(_t50 < 0) {
        if((_v96 & 61440) == 16384) {
        } else {
            fd = fopen(file, "r");
            if(fd == 0) {
            } else {
                while(1) {
                    c = fgetc(fd);
                    if(c == 255) {
                        break;
                    }
                    fputc(c, f);
                }
                fclose(fd);
            }
L13:
        }
    }
    fwrite("\n", 1, 2, f);
    return;
    goto L13;
}

struct pre_form* add_pre_form(struct pre_form* prev, char* url, char* name, char* action)
{// addr = 0x0808D356  --  defined in 'form.c' at line 790
    struct pre_form* new;   // _cfa_fffffff0
    int l;                                 // _cfa_ffffffec
    ParsedURL pu;    // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    struct pre_form* _t64;   // _t64
    char* _t66;                            // _t66
    char* _t67;                            // _t67

    _t64 = __eax;
    if(prev == 0) {
         *__esp = 24;
        GC_malloc();
        PreForm = _t64;
        new = PreForm;
    } else {
         *__esp = 24;
        GC_malloc();
        prev->next = _t64;
        new = prev->next;
    }
    if(url == 0 || ( *url & 0xff) != 47) {
        if(url != 0) {
            parseURL2(url,  &(pu.scheme), 0);
            new->url =  *(parsedURL2Str( &(pu.scheme)));
            new->re_url = 0;
        }
    } else {
        l = strlen(url);
        if(l <= 1 || ( *(l - 1 + url) & 0xff) != 47) {
            new->url =  &(url[1]);
        } else {
            new->url = allocStr( &(url[1]), l - 2);
        }
        new->re_url = newRegex(new->url, 0, 0, 0);
        if(new->re_url == 0) {
            new->url = 0;
        }
    }
    if(name == 0 || ( *name & 0xff) == 0) {
        _t66 = 0;
    } else {
        _t66 = name;
    }
    new->name = _t66;
    if(action == 0 || ( *action & 0xff) == 0) {
        _t67 = 0;
    } else {
        _t67 = action;
    }
    new->action = _t67;
    new->item = 0;
    new->next = 0;
    return new;
}

struct pre_form_item* add_pre_form_item(struct pre_form* pf, struct pre_form_item* prev, int type, char* name, char* value, char* checked)
{// addr = 0x0808D4D8  --  defined in 'form.c' at line 822
    struct pre_form_item* new;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct pre_form_item* _t38;   // _t38
    _unknown_ _t60;                        // _t60

    if(pf == 0) {
        return 0;
    }
    if(prev == 0) {
         *__esp = 20;
        GC_malloc();
        pf->item = _t38;
        new = pf->item;
    } else {
         *__esp = 20;
        GC_malloc();
        prev->next = _t38;
        new = prev->next;
    }
    new->type = type;
    new->name = name;
    new->value = value;
    if(checked == 0 || ( *checked & 0xff) == 0 || strcmp(checked, "0") != 0 && strcasecmp(checked, "off") == 0 && strcasecmp(checked, "no") != 0) {
        new->checked = 1;
    } else {
        new->checked = 0;
    }
    new->next = 0;
    return new;
}

loadPreForm()
{// addr = 0x0808D5C4  --  defined in 'form.c' at line 863
    FILE* fp;             // _cfa_fffffff0
    Str line;              // _cfa_ffffffec
    Str textarea;          // _cfa_ffffffe8
    struct pre_form* pf;   // _cfa_ffffffe4
    struct pre_form_item* pi;   // _cfa_ffffffe0
    int type;                              // _cfa_ffffffdc
    char* name;                            // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    char* s;                               // _cfa_ffffffd0
    char* arg;                             // _cfa_ffffffcc
    struct pre_form* prev;   // _cfa_ffffffc8
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    char* _t247;                           // _t247
    _unknown_ _t287;                       // _t287

    line = 0;
    textarea = 0;
    pf = 0;
    pi = 0;
    type = -1;
    name = 0;
    PreForm = 0;
    fp = openSecretFile(pre_form_file);
    if(fp == 0) {
L58:
        return;
    } else {
        goto L1;
    }
    while(1) {
L1:
        line = Strfgets(fp);
        if(line->length == 0) {
            fclose(fp);
            return;
        }
L3:
        if(textarea != 0) {
            break;
        }
L7:
        Strchop(line);
        Strremovefirstspaces(line);
        p = line->ptr;
        if(( *p & 0xff) == 35 || ( *p & 0xff) == 0) {
L57:
            continue;
        } else {
            s = getWord( &p);
            arg = getWord( &p);
            if(strcmp(s, "url") != 0) {
                if(pf != 0) {
                    if(strcmp(s, "form") != 0) {
                        if(strcmp(s, "text") != 0) {
                            if(strcmp(s, "file") != 0) {
                                if(strcmp(s, "passwd") == 0 || strcmp(s, "password") == 0) {
                                    type = 1;
                                    goto L56;
                                }
                                if(strcmp(s, "checkbox") != 0) {
                                    if(strcmp(s, "radio") != 0) {
                                        if(strcmp(s, "submit") != 0) {
                                            if(strcmp(s, "image") != 0) {
                                                if(strcmp(s, "select") != 0) {
                                                    if(strcmp(s, "textarea") != 0) {
                                                        if(textarea != 0 && name != 0 && strcmp(s, "/textarea") == 0) {
                                                            pi = add_pre_form_item(pf, pi, type, name, textarea->ptr, 0);
                                                            textarea = 0;
                                                            name = 0;
                                                        }
                                                    } else {
                                                        type = 9;
                                                        name =  *(Strnew_charp(arg));
                                                        textarea = Strnew();
                                                    }
                                                    goto L57;
                                                }
                                                goto L48;
                                            }
                                            goto L46;
L48:
                                            type = 8;
                                            goto L56;
                                        }
                                        goto L44;
L46:
                                        type = 7;
                                        goto L56;
                                    }
                                    goto L42;
L44:
                                    type = 4;
                                    goto L56;
                                }
                                type = 2;
                                goto L56;
L42:
                                type = 3;
                                goto L56;
                            }
                            goto L35;
                        }
                        type = 0;
L56:
                        s = getQWord( &p);
                        pi = add_pre_form_item(pf, pi, type, arg, s, getQWord( &p));
                        while(1) {
L1:
                            line = Strfgets(fp);
                            if(line->length == 0) {
                                fclose(fp);
                                return;
                            }
L3:
                            if(textarea != 0) {
                                break;
                            }
                        }
L35:
                        type = 11;
                        goto L56;
                    } else {
                        if(arg != 0 && ( *arg & 0xff) != 0) {
                            s = getQWord( &p);
                            p = getQWord( &p);
                            if(p == 0 || ( *p & 0xff) == 0) {
                                p = s;
                                s = 0;
                            }
                            if(pf->item == 0) {
                                pf->name = s;
                                if(p == 0 || ( *p & 0xff) == 0) {
                                    _t247 = 0;
                                } else {
                                    _t247 = p;
                                }
                                pf->action = _t247;
                            } else {
                                prev = pf;
                                pf = add_pre_form(prev, 135051758, s, p);
                                pf->url = prev->url;
                                pf->re_url = prev->re_url;
                            }
                            pi = pf->item;
                        }
                    }
                } else {
                }
                goto L57;
            }
            if(arg == 0) {
L13:
                goto L57;
            }
            if(( *arg & 0xff) != 0) {
                p = getQWord( &p);
                pf = add_pre_form(pf, arg, 0, p);
                pi = pf->item;
                goto L57;
            }
            goto L13;
        }
        goto L58;
    }
    if(strncmp(line->ptr, "/textarea", 9) != 0 || ( *( &MYCTYPE_MAP + (line->ptr[9] & 0xff)) & 2) == 0) {
        Strcat(textarea, line);
        goto L57;
    } else {
        goto L7;
    }
    goto L58;
}

preFormUpdateBuffer(Buffer* buf)
{// addr = 0x0808DA7C  --  defined in 'form.c' at line 965
    FormSelectOptionItem* opt;   // _cfa_ffffffd8
    int j;                                 // _cfa_ffffffd4
    struct pre_form* pf;   // _cfa_fffffff0
    struct pre_form_item* pi;   // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    Anchor* a;          // _cfa_ffffffe4
    FormList* fl;     // _cfa_ffffffe0
    FormItemList* fi;   // _cfa_ffffffdc
    Str url;               // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t112;                       // _t112
    _unknown_ _t192;                       // _t192

    if(buf == 0) {
        return;
    }
    if(buf->formitem == 0) {
        goto L58;
    }
    if(PreForm != 0) {
        pf = PreForm;
        while(pf != 0) {
            if(pf->re_url == 0) {
                if(pf->url == 0) {
                    goto L54;
                }
                goto L8;
L53:
                goto L54;
            }
            url = parsedURL2Str(buf + 132);
            if(RegexMatch(pf->re_url, url->ptr, url->length, 1) != 0) {
L9:
                i = 0;
L50:
                while(buf->formitem->nanchor > i) {
                    goto L10;
                }
                goto L54;
            }
L54:
            pf = pf->next;
            continue;
L10:
            a = buf->formitem->anchors + (i << 2 << 4) - (i << 2);
            fi = a->url;
            fl = fi->parent;
            if(pf->name == 0) {
L13:
                if(pf->action == 0) {
L16:
                    pi = pf->item;
L43:
                    while(pi != 0) {
                        goto L17;
                    }
                    goto L49;
                }
                goto L14;
L17:
                if(pi->type != fi->type) {
                    goto L42;
                }
                if(pi->type == 4 || pi->type == 7) {
                    if(pi->name == 0 || (pi & 0xff) == 0) {
L24:
                        if(pi->value == 0 || (pi & 0xff) == 0) {
L28:
                            buf->submit = a;
                            goto L42;
                        }
                        if( *(fi + 8) == 0) {
                            goto L37;
                        }
                        if(strcmp( *( *(fi + 8)), pi->value) != 0) {
                            goto L42;
                        }
                        goto L28;
                    } else {
                        if( *(fi + 4) == 0) {
                            goto L35;
                        }
                        if(strcmp( *( *(fi + 4)), pi->name) != 0) {
                            goto L42;
                        }
                        goto L24;
L37:
                        goto L42;
                    }
                } else {
                    if(pi->name == 0) {
L39:
                        goto L42;
                    }
                    if( *(fi + 4) == 0) {
                        goto L40;
                    }
                    if(strcmp( *( *(fi + 4)), pi->name) != 0) {
                        goto L41;
                    }
                    if(pi->type > 11) {
                        goto L42;
                    }
                    goto __eax;
L42:
                    pi = pi->next;
                    goto L43;
L41:
                    goto L42;
L40:
                    goto L42;
                }
L35:
                goto L42;
            }
            if(fl->name == 0) {
L49:
                i = i + 1;
                goto L50;
            }
            if(strcmp(fl->name, pf->name) != 0) {
                goto L49;
            }
            goto L13;
L47:
            goto L49;
L14:
            if( *(fl + 12) == 0) {
                goto L47;
            }
            if(strcmp( *( *(fl + 12)), pf->action) != 0) {
                goto L49;
            }
            goto L16;
L8:
            if(strcmp( *(parsedURL2Str(buf + 132)), pf->url) != 0) {
                goto L53;
            }
            goto L9;
        }
        return;
    }
    return;
L58:
    return;
}

MapList* searchMapList(Buffer* buf, char* name)
{// addr = 0x0808DF40  --  defined in 'map.c' at line 9
    MapList* ml;       // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22

    if(name != 0) {
        ml = buf->maplist;
L5:
        while(ml != 0) {
            goto L3;
        }
L8:
        return ml;
    }
    return 0;
L3:
    if(strcmp(ml->name->name, name) == 0) {
        goto L8;
    }
    ml = ml->next;
    goto L5;
}

int inMapArea(MapArea* a, int x, int y)
{// addr = 0x0808DF8F  --  defined in 'map.c' at line 24
    double r1;                             // _cfa_ffffffe4
    double r2;                             // _cfa_ffffffdc
    double s;                              // _cfa_ffffffd4
    double c;                              // _cfa_ffffffcc
    double t;                              // _cfa_ffffffc4
    int i;                                 // _cfa_fffffff0
    intOrPtr _v64;                         // _cfa_ffffffc0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t128;                      // _t128
    MapArea* _t129;    // _t129
    _unknown_ _t132;                       // _t132
    MapArea* _t133;    // _t133
    MapArea* _t137;    // _t137
    MapArea* _t141;    // _t141
    _unknown_ _t145;                       // _t145
    signed int _t162;                      // _t162
    signed int _t166;                      // _t166
    MapArea* _t167;    // _t167
    _unknown_ _t172;                       // _t172
    signed int _t174;                      // _t174
    _unknown_ _t255;                       // _t255
    _unknown_ _t256;                       // _t256
    _unknown_ _t257;                       // _t257
    _unknown_ _t258;                       // _t258
    signed int _t293;                      // _t293

    __eflags = a;
    if(a == 0) {
        return 0;
    }
    _t128 = a->shape & 0xff;
    __eflags = _t128 - 2;
    if(_t128 == 2) {
        _t129 = a;
        asm("cwde ");
        __eflags = (_t129 & 65535) - x;
        if((_t129 & 65535) > x) {
            goto L33;
        }
        goto L10;
L34:
        goto L39;
    }
    __eflags = _t128 - 2;
    if(_t128 > 2) {
        __eflags = _t128 - 3;
        if(_t128 == 3) {
            asm("cwde ");
            asm("cwde ");
            _t293 = (x - (a & 65535)) * (x - (a & 65535));
            asm("cwde ");
            asm("cwde ");
            _t162 = (y - (a->coords[1] & 65535)) * (y - (a->coords[1] & 65535));
            _t166 = a->coords[2] & 65535;
            _t167 = a;
            asm("cwde ");
            __eflags = _t293 + _t162 - (_t167->coords[2] & 65535) * (_t166 & 65535);
            if(_t293 + _t162 > (_t167->coords[2] & 65535) * (_t166 & 65535)) {
                goto L39;
            }
            goto L15;
L38:
            goto L39;
        }
        goto L7;
L15:
        return 1;
    }
    __eflags = _t128 - 1;
    if(_t128 == 1) {
        return 1;
    }
L39:
    return 0;
L33:
    goto L39;
L7:
    __eflags = _t128 - 4;
    if(_t128 == 4) {
        asm("fldz ");
        asm("fstp qword [ebp-0x38]");
        i = 0;
        while(1) {
            _t174 = a->ncoords;
            __eflags = _t174 - i;
            if(__eflags <= 0) {
                break;
            }
            asm("cwde ");
            _v64 = x - ( *(a->coords + i + i) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = x - ( *(a->coords + i + i) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("cwde ");
            _v64 = y - ( *(a->coords + i + 1 + i + 1) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = y - ( *(a->coords + i + 1 + i + 1) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("faddp st1, st0");
            asm("fld st0, st0");
            asm("fsqrt ");
            asm("fucomi st0, st0");
            if(__eflags != 0) {
                asm("fstp st0");
                goto L21;
            }
            if(__eflags == 0) {
                asm("fstp st1");
                goto L23;
            }
            asm("fstp st0");
            goto L21;
L23:
            asm("fstp qword [ebp-0x18]");
            asm("cwde ");
            _v64 = x - ( *(a->coords + i + 2 + i + 2) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = x - ( *(a->coords + i + 2 + i + 2) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("cwde ");
            _v64 = y - ( *(a->coords + i + 3 + i + 3) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = y - ( *(a->coords + i + 3 + i + 3) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("faddp st1, st0");
            asm("fstp qword [esp]");
            sqrt();
            asm("fstp qword [ebp-0x20]");
            asm("fld qword [ebp-0x18]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if(__eflags != 0 || __eflags != 0) {
                asm("fld qword [ebp-0x20]");
                asm("fldz ");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if(__eflags != 0 || __eflags != 0) {
                    asm("cwde ");
                    _v64 = x - ( *(a->coords + i + i) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    asm("cwde ");
                    _v64 = y - ( *(a->coords + i + 3 + i + 3) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    asm("fmulp st1, st0");
                    asm("cwde ");
                    _v64 = x - ( *(a->coords + i + 2 + i + 2) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    asm("cwde ");
                    _v64 = y - ( *(a->coords + i + 1 + i + 1) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    asm("fmulp st1, st0");
                    asm("fsubp st1, st0");
                    asm("fdiv qword [ebp-0x18]");
                    asm("fdiv qword [ebp-0x20]");
                    asm("fstp qword [ebp-0x28]");
                    asm("cwde ");
                    _v64 = x - ( *(a->coords + i + i) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    asm("cwde ");
                    _v64 = x - ( *(a->coords + i + 2 + i + 2) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    asm("fmulp st1, st0");
                    asm("cwde ");
                    _v64 = y - ( *(a->coords + i + 1 + i + 1) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    asm("cwde ");
                    _v64 = y - ( *(a->coords + i + 3 + i + 3) & 65535);
                    asm("fild dword [ebp-0x3c]");
                    asm("fmulp st1, st0");
                    asm("faddp st1, st0");
                    asm("fdiv qword [ebp-0x18]");
                    asm("fdiv qword [ebp-0x20]");
                    asm("fstp qword [ebp-0x30]");
                    asm("fld qword [ebp-0x30]");
                    asm("fstp qword [esp+0x8]");
                    asm("fld qword [ebp-0x28]");
                    asm("fstp qword [esp]");
                    atan2();
                    asm("fld qword [ebp-0x38]");
                    asm("faddp st1, st0");
                    asm("fstp qword [ebp-0x38]");
                    i = i + 2;
                    continue;
                }
            }
            return 1;
L21:
            asm("fstp qword [esp]");
            sqrt();
            goto L23;
        }
        asm("fld qword [ebp-0x38]");
        asm("fabs ");
        asm("fld qword [0x80cc020]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        __eflags = _t174 & 255;
        if((_t174 & 255) == 0) {
            goto L38;
        }
        return 1;
    }
    goto L39;
L10:
    _t133 = a;
    asm("cwde ");
    __eflags = (_t133->coords[1] & 65535) - y;
    if((_t133->coords[1] & 65535) > y) {
        goto L34;
    }
    _t137 = a;
    asm("cwde ");
    __eflags = (_t137->coords[2] & 65535) - x;
    if((_t137->coords[2] & 65535) < x) {
        goto L35;
    }
    _t141 = a;
    asm("cwde ");
    __eflags = (_t141->coords[3] & 65535) - y;
    if((_t141->coords[3] & 65535) < y) {
        goto L36;
    }
    return 1;
L36:
    goto L39;
L35:
    goto L39;
}

int nearestMapArea(MapList* ml, int x, int y)
{// addr = 0x0808E3E5  --  defined in 'map.c' at line 75
    ListItem* al;     // _cfa_fffffff8
    MapArea* a;        // _cfa_fffffff4
    int i;                                 // _cfa_fffffff0
    int l;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    int min;                               // _cfa_ffffffe4
    int limit;                             // _cfa_ffffffe0
    signed short _v38;                     // _cfa_ffffffda
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    n = -1;
    min = -1;
    asm("fld qword [0x80d53a0]");
    asm("fld qword [0x80d53a0]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80d53a8]");
    asm("fld qword [0x80d53a8]");
    asm("fmulp st1, st0");
    asm("faddp st1, st0");
    asm("fnstcw word [ebp-0x22]");
    _v40 = _v38 & 0xffff;
    asm("fldcw word [ebp-0x24]");
    asm("fistp dword [ebp-0x1c]");
    asm("fldcw word [ebp-0x22]");
    if(ml == 0 || ml->area == 0) {
        return n;
    }
    i = 0;
    al = ml->area->first;
    while(al != 0) {
        a = al->ptr;
        if(a != 0) {
            asm("cwde ");
            asm("cwde ");
            asm("cwde ");
            asm("cwde ");
            l = ((a->center_x & 65535) - x) * ((a->center_x & 65535) - x) + ((a->center_y & 65535) - y) * ((a->center_y & 65535) - y);
            if(min >= 0 || l < min) {
                if(l < limit) {
                    n = i;
                    min = l;
                }
            }
        }
        i = i + 1;
        al = al->next;
    }
    return n;
}

int searchMapArea(Buffer* buf, MapList* ml, Anchor* a_img)
{// addr = 0x0808E4DD  --  defined in 'map.c' at line 99
    ListItem* al;     // _cfa_fffffff0
    MapArea* a;        // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int n;                                 // _cfa_ffffffe4
    int px;                                // _cfa_ffffffe0
    int py;                                // _cfa_ffffffdc
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t63;                        // _t63
    _unknown_ _t107;                       // _t107

    if(ml == 0 || ml->area == 0 || (ml->area->nitem & 0xffff) == 0) {
        return -1;
    }
    if(getMapXY(buf, a_img,  &px,  &py) == 0) {
        return -1;
    }
    asm("cwde ");
    n =  ~(ml->area->nitem & 65535);
    i = 0;
    al = ml->area->first;
    while(al != 0) {
        a = al->ptr;
        if(a != 0) {
            if(n < 0 && inMapArea(a, px, py) != 0) {
                if((a->shape & 0xff) != 1) {
                    n = i;
                } else {
                    asm("cwde ");
                    if( ~(ml->area->nitem & 65535) == n) {
                        n =  ~i;
                    }
                }
            }
        }
        i = i + 1;
        al = al->next;
    }
    asm("cwde ");
    if( ~(ml->area->nitem & 65535) != n) {
        if(n >= 0) {
            return n;
        }
        goto L20;
        return __eax;
    }
    return nearestMapArea(ml, px, py);
L20:
    return  ~n;
}

MapArea* retrieveCurrentMapArea(Buffer* buf)
{// addr = 0x0808E611  --  defined in 'map.c' at line 132
    Anchor* a_img;      // _cfa_fffffff0
    Anchor* a_form;     // _cfa_ffffffec
    FormItemList* fi;   // _cfa_ffffffe8
    MapList* ml;       // _cfa_ffffffe4
    ListItem* al;     // _cfa_ffffffe0
    MapArea* a;        // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t56;                        // _t56
    _unknown_ _t64;                        // _t64
    _unknown_ _t69;                        // _t69
    char* _t80;                            // _t80
    _unknown_ _t94;                        // _t94
    _unknown_ _t97;                        // _t97
    _unknown_ _t98;                        // _t98

    a_img = retrieveCurrentImg(buf);
    if(a_img == 0 || a_img->image == 0 || a_img->image->map == 0) {
        return 0;
    }
    a_form = retrieveCurrentForm(buf);
    if(a_form == 0 || a_form->url == 0) {
        return 0;
    }
    fi = a_form->url;
    if(fi == 0 || fi->parent == 0 || fi->parent->item == 0) {
        return 0;
    }
    fi = fi->parent->item;
    if( *(fi + 8) == 0) {
        _t80 = 0;
    } else {
        _t80 =  *( *(fi + 8));
    }
    ml = searchMapList(buf, _t80);
    if(ml != 0) {
        n = searchMapArea(buf, ml, a_img);
        if(n >= 0) {
            i = 0;
            al = ml->area->first;
L23:
            while(al != 0) {
                goto L19;
            }
            return 0;
        }
        goto L17;
L19:
        a = al->ptr;
        if(a == 0 || i != n) {
            i = i + 1;
            al = al->next;
            goto L23;
        }
        return a;
    } else {
        return 0;
    }
L17:
    return 0;
}

int getMapXY(Buffer* buf, Anchor* a, int* x, int* y)
{// addr = 0x0808E756  --  defined in 'map.c' at line 166
    intOrPtr _v16;                         // _cfa_fffffff0
    signed short _v18;                     // _cfa_ffffffee
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t55;                        // _t55
    _unknown_ _t90;                        // _t90

    if(buf == 0) {
L5:
        return 0;
    }
    if(a == 0 || a->image == 0 || x == 0 || y == 0) {
        goto L5;
    } else {
        asm("cwde ");
        _v16 = buf->currentColumn + (buf->cursorX & 65535) - calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len,  *(a + 24), 0, 0);
        asm("fild dword [ebp-0xc]");
        asm("fld qword [0x80cc028]");
        asm("faddp st1, st0");
        asm("fld qword [0x80d53a0]");
        asm("fmulp st1, st0");
        asm("fnstcw word [ebp-0xe]");
        _v20 = _v18 & 0xffff;
        asm("fldcw word [ebp-0x10]");
        asm("fistp dword [ebp-0xc]");
        asm("fldcw word [ebp-0xe]");
        asm("cwde ");
         *x = _v16 - (a->image->xoffset & 65535);
        asm("cwde ");
        _v16 = buf->currentLine->linenumber - (a->image->y & 65535);
        asm("fild dword [ebp-0xc]");
        asm("fld qword [0x80cc028]");
        asm("faddp st1, st0");
        asm("fld qword [0x80d53a8]");
        asm("fmulp st1, st0");
        asm("fldcw word [ebp-0x10]");
        asm("fistp dword [ebp-0xc]");
        asm("fldcw word [ebp-0xe]");
        asm("cwde ");
         *y = _v16 - (a->image->yoffset & 65535);
        if( *x <= 0) {
             *x = 1;
        }
    }
    if( *y <= 0) {
         *y = 1;
    }
    return 1;
}

Anchor* retrieveCurrentMap(Buffer* buf)
{// addr = 0x0808E8A4  --  defined in 'map.c' at line 184
    Anchor* a;          // _cfa_fffffff0
    FormItemList* fi;   // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t25;                        // _t25

    a = retrieveCurrentForm(buf);
    if(a == 0 || a->url == 0) {
        return 0;
    }
    fi = a->url;
    if(fi->parent->method != 2 || strcmp( *( *(fi->parent + 12)), 135052056) != 0) {
        return 0;
    }
    return a;
}

MapArea* follow_map_menu(Buffer* buf, char* name, Anchor* a_img, int x, int y)
{// addr = 0x0808E90F  --  defined in 'map.c' at line 201
    MapList* ml;       // _cfa_fffffff0
    ListItem* al;     // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int selected;                          // _cfa_ffffffe4
    int initial;                           // _cfa_ffffffe0
    MapArea* a;        // _cfa_ffffffdc
    char** label;                          // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t85;                        // _t85
    char** _t100;                          // _t100
    _unknown_ _t122;                       // _t122
    char* _t139;                           // _t139
    char** _t143;                          // _t143

    selected = -1;
    initial = 0;
    ml = searchMapList(buf, name);
    if(ml == 0 || ml->area == 0 || (ml->area->nitem & 0xffff) == 0) {
        return 0;
    }
    initial = searchMapArea(buf, ml, a_img);
    if(initial >= 0) {
        if(image_map_list != 0) {
            goto L8;
        }
        selected = initial;
L18:
        if(selected >= 0) {
L25:
            return 0;
        }
        i = 0;
        al = ml->area->first;
        while(al != 0) {
            if(al->ptr == 0 || i != selected) {
                i = i + 1;
                al = al->next;
                continue;
            }
            return al->ptr;
        }
        goto L25;
        return __eax;
L9:
        a = al->ptr;
        if(a == 0) {
            label[i] = 135052060;
            goto L15;
        }
        _t143 =  &(label[i]);
        if((a & 0xff) == 0) {
            _t139 = a->url;
        } else {
            _t139 = a->alt;
        }
         *_t143 = _t139;
L15:
        i = i + 1;
        al = al->next;
L16:
        while(al != 0) {
            goto L9;
        }
        asm("cwde ");
        label[ml->area->nitem & 65535] = 0;
        optionMenu(x, y, label,  &selected, initial, 0);
        goto L18;
    } else {
        initial = 0;
    }
L8:
    asm("cwde ");
    _t100 = (ml->area->nitem & 65535) + 1 << 2;
     *__esp = _t100;
    GC_malloc();
    label = _t100;
    i = 0;
    al = ml->area->first;
    goto L16;
}

MapArea* newMapArea(char* url, char* target, char* alt, char* shape, char* coords)
{// addr = 0x0808EABC  --  defined in 'map.c' at line 301
    MapArea* a;        // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int max;                               // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char _t295;                            // _t295
    char _t307;                            // _t307
    char _t309;                            // _t309
    _unknown_ _t441;                       // _t441
    _unknown_ _t442;                       // _t442
    _unknown_ _t445;                       // _t445
    _unknown_ _t446;                       // _t446

     *__esp = 28;
    GC_malloc();
    a = __eax;
    a->url = url;
    a->target = target;
    if(alt == 0) {
        _t295 = 135052060;
    } else {
        _t295 = alt;
    }
    a->alt = _t295;
    a->shape = 2;
    if(shape != 0) {
        if(strcasecmp(shape, "default") != 0) {
            if(strncasecmp(shape, "rect", 4) != 0) {
                if(strncasecmp(shape, "circ", 4) != 0) {
                    if(strncasecmp(shape, "poly", 4) != 0) {
                        a->shape = 0;
                    } else {
                        a->shape = 4;
                    }
                } else {
                    a->shape = 3;
                }
            } else {
                a->shape = 2;
            }
        } else {
            a->shape = 1;
        }
    }
    a->coords = 0;
    a->ncoords = 0;
    a->center_x = 0;
    a->center_y = 0;
    if((a->shape & 0xff) == 0 || (a->shape & 0xff) == 1) {
        return a;
    }
    if(coords != 0) {
        _t307 = a->shape & 255;
        if((_t307 & 255) != 2) {
            _t309 = a->shape & 255;
            if((_t309 & 255) == 3) {
                 *__esp = 6;
                GC_malloc();
                a->coords = _t309;
                a->ncoords = 3;
            }
        } else {
             *__esp = 8;
            GC_malloc();
            a->coords = _t307;
            a->ncoords = 4;
        }
        max = a->ncoords;
        i = 0;
        p = coords;
        while((a->shape & 0xff) == 4 || a->ncoords > i) {
            if(( *p & 0xff) != 0) {
                while(1) {
                    p =  *p & 255;
                     *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
                     *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 2;
                    if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                        break;
                    }
                    p =  &(p[1]);
                }
                p =  *p & 255;
                 *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
                 *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 8;
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) != 0) {
L29:
                    a = a->shape & 255;
                    if((a->shape & 0xff) == 4) {
                        __eax = max;
                        if(max <= i) {
                            if(i == 0) {
                                __eax = 6;
                            } else {
                                __eax = i;
                                __eax = i + i;
                            }
                            max = __eax;
                            max = max + 2;
                            __eax = max + 2 + max + 2;
                            __edx = max + 2 + max + 2;
                            __eax = a;
                            __eax = a->coords;
                            _v40 = max + 2 + max + 2;
                             *__esp = __eax;
                            GC_realloc();
                            __edx = __eax;
                            __eax = a;
                            a->coords = __edx;
                        }
                        a = a->ncoords;
                        __edx = a->ncoords + 1;
                        __eax = a;
                        a->ncoords = a->ncoords + 1;
                    }
                    a = a->coords;
                    i = i + i;
                    p = atoi(p);
                     *(a->coords + i + i) = p & 65535;
                    i = i + 1;
                    p =  *p & 255;
                    if(( *p & 0xff) == 45) {
L38:
                        p =  &(p[1]);
                        goto L41;
                    } else {
                        p =  *p & 255;
                        if(( *p & 0xff) != 43) {
                            while(1) {
L41:
                                p =  *p & 255;
                                 *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
                                 *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 8;
                                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) == 0) {
                                    break;
                                }
                                goto L39;
                            }
                            p =  *p & 255;
                            if(( *p & 0xff) == 44) {
                                while(1) {
L48:
                                    p =  *p & 255;
                                     *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
                                     *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 2;
                                    if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                                        break;
                                    }
                                    p =  &(p[1]);
                                }
                                p =  *p & 255;
                                if(( *p & 0xff) == 44) {
                                    p =  &(p[1]);
                                }
                                continue;
                            }
                            p =  *p & 255;
                             *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
                             *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 2;
                            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                                goto L47;
                            }
                            break;
L47:
                            goto L48;
                        }
                        goto L38;
                    }
L39:
                    p =  &(p[1]);
                    goto L41;
                }
                p =  *p & 255;
                if(( *p & 0xff) == 45) {
                    goto L29;
                }
                p =  *p & 255;
                if(( *p & 0xff) != 43) {
                    break;
                }
                goto L29;
            }
            break;
        }
        if(a->ncoords != i || (a->shape & 0xff) == 4 && a->ncoords <= 5) {
            a->shape = 0;
            a->coords = 0;
            a->ncoords = 0;
            return a;
        }
        if((a->shape & 0xff) == 4) {
            a->ncoords = ((a->ncoords >> 31) + a->ncoords >> 1) + ((a->ncoords >> 31) + a->ncoords >> 1);
             *(a->coords + a->ncoords + a->ncoords) =  *(a->coords) & 0xffff;
             *(a->coords + a->ncoords + 1 + a->ncoords + 1) =  *(a->coords + 2) & 0xffff;
        }
        if((a->shape & 0xff) != 3) {
            i = 0;
L66:
            while((a->ncoords >> 31) + a->ncoords >> 1 > i) {
                goto L65;
            }
            a->center_x = (a->center_x & 0xffff) / ((a->ncoords >> 31) + a->ncoords >> 1) & 65535;
            a->center_y = (a->center_y & 0xffff) / ((a->ncoords >> 31) + a->ncoords >> 1) & 65535;
            goto L68;
        } else {
            a->center_x =  *(a->coords) & 0xffff;
            a->center_y =  *(a->coords + 2) & 0xffff;
L68:
            return a;
        }
L65:
        a->center_x = (a->center_x & 65535) + ( *(a->coords + (i << 2)) & 65535) & 65535;
        a->center_y = (a->center_y & 65535) + ( *(a->coords + i + i + 1 + i + i + 1) & 65535) & 65535;
        i = i + 1;
        goto L66;
    }
    a->shape = 0;
    return a;
}

append_map_info(Buffer* buf, Str tmp, FormItemList* fi)
{// addr = 0x0808EFA6  --  defined in 'map.c' at line 399
    MapList* ml;       // _cfa_fffffff0
    ListItem* al;     // _cfa_ffffffec
    MapArea* a;        // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    char* q;                               // _cfa_ffffffe0
    ParsedURL pu;    // _cfa_ffffffb8
    char* _v92;                            // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    char* _v108;                           // _cfa_ffffff94
    char* _v112;                           // _cfa_ffffff90
    char* _v116;                           // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    char* _t59;                            // _t59
    char* _t84;                            // _t84
    char* _t85;                            // _t85

    if( *(fi + 8) == 0) {
        _t59 = 0;
    } else {
        _t59 =  *( *(fi + 8));
    }
    ml = searchMapList(buf, _t59);
    if(ml != 0) {
        _v112 = 0;
        _v116 = "<tr valign=top><td colspan=2><table>";
        _v120 = "<tr valign=top><td colspan=2>Links of current image map";
        Strcat_m_charp(tmp);
        al = ml->area->first;
        while(al != 0) {
            a = al->ptr;
            if(a != 0) {
                parseURL2(a->url,  &(pu.scheme), baseURL(buf));
                q = html_quote( *(parsedURL2Str( &(pu.scheme))));
                if(DecodeURL == 0) {
                    p = html_quote(a->url);
                } else {
                    p = html_quote(url_unquote_conv(a->url,  *(buf + 208)));
                }
                if((a & 0xff) == 0) {
                    _t84 = mybasename(a->url);
                } else {
                    _t84 = a->alt;
                }
                _t85 = html_quote(_t84);
                _v92 = 0;
                _v96 = "\n";
                _v100 = p;
                _v104 = "</a><td>";
                _v108 = _t85;
                _v112 = "">";
                _v116 = q;
                _v120 = "<tr valign=top><td>&nbsp;&nbsp;<td><a href="";
                Strcat_m_charp(tmp);
            }
            al = al->next;
        }
        Strcat_charp(tmp, "</table>");
        return;
    }
    return;
}

append_link_info(Buffer* buf, Str html, LinkList* link)
{// addr = 0x0808F13E  --  defined in 'map.c' at line 434
    LinkList* l;      // _cfa_fffffff0
    char* url;                             // _cfa_ffffffec
    ParsedURL pu;    // _cfa_ffffffc4
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    char* _v76;                            // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    char* _t76;                            // _t76
    char* _t99;                            // _t99

    if(link == 0) {
        return;
    }
    Strcat_charp(html, "<hr width=50%><h1>Link information</h1><table>\n");
    l = link;
    while(l != 0) {
        if(l->url == 0) {
            url = "(empty)";
        } else {
            parseURL2(l->url,  &(pu.scheme), baseURL(buf));
            url = html_quote( *(parsedURL2Str( &(pu.scheme))));
        }
        if(l->title == 0) {
            _t76 = "(empty)";
        } else {
            _t76 = html_quote(l->title);
        }
        _v68 = 0;
        _v72 = "</a><td>";
        _v76 = _t76;
        _v80 = "">";
        _v84 = url;
        _v88 = "<tr valign=top><td><a href="";
        Strcat_m_charp(html);
        if((l->type & 0xff) != 1) {
            if((l->type & 0xff) == 2) {
                Strcat_charp(html, "[Rev]");
            }
        } else {
            Strcat_charp(html, "[Rel]");
        }
        if(l->url != 0) {
            if(DecodeURL == 0) {
                url = html_quote(l->url);
            } else {
                url = html_quote(url_unquote_conv(l->url,  *(buf + 208)));
            }
        } else {
            url = "(empty)";
        }
        _v80 = 0;
        _v84 = url;
        _v88 = "<td>";
        Strcat_m_charp(html);
        if(l->ctype != 0) {
            _t99 = html_quote(l->ctype);
            _v76 = 0;
            _v80 = ")";
            _v84 = _t99;
            _v88 = " (";
            Strcat_m_charp(html);
        }
        Strcat_charp(html, "\n");
        l = l->next;
    }
    Strcat_charp(html, "</table>\n");
    return;
}

append_frame_info(Buffer* buf, Str html, struct frameset* set, int level)
{// addr = 0x0808F33D  --  defined in 'map.c' at line 474
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int j;                                 // _cfa_ffffffe4
    union frameset_element frame;   // _cfa_ffffffe0
    int _v60;                              // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    signed int _t82;                       // _t82

    if(set != 0) {
        i = 0;
        while(set->row * set->col > i) {
            frame = set->frame[i];
            if(frame == 0) {
L19:
                i = i + 1;
                continue;
            }
            _t82 =  *frame & 0xff;
            if(_t82 >= 0) {
                goto L19;
            }
            if(_t82 <= 1) {
                if( *(frame + 8) == 0) {
                    goto L19;
                }
                goto L8;
            }
            if(_t82 == 2) {
                append_frame_info(buf, html, frame, level + 1);
            }
            goto L19;
L8:
            Strcat_charp(html, "<pre_int>");
            j = 0;
            while(j < level) {
                Strcat_charp(html, "   ");
                j = j + 1;
            }
            q = html_quote( *(frame + 8));
            _v60 = 0;
            _v64 = "">";
            _v68 = q;
            _v72 = "<a href="";
            Strcat_m_charp(html);
            if( *(frame + 4) != 0) {
                p = html_quote(url_unquote_conv( *(frame + 4),  *(buf + 208)));
                Strcat_charp(html, p);
            }
            if(DecodeURL == 0) {
                p = q;
            } else {
                p = html_quote(url_unquote_conv( *(frame + 8),  *(buf + 208)));
            }
            _v60 = 0;
            _v64 = "</a></pre_int><br>\n";
            _v68 = p;
            _v72 = " ";
            Strcat_m_charp(html);
            goto L19;
        }
        return;
    }
    return;
}

Buffer* page_info_panel(Buffer* buf)
{// addr = 0x0808F50B  --  defined in 'map.c' at line 526
    intOrPtr _v32;                         // _cfa_ffffffe0
    char[15] charset;                      // _cfa_ffffffd0
    Str tmp;               // _cfa_ffffffcc
    Anchor* a;          // _cfa_ffffffc8
    TextListItem* ti;   // _cfa_ffffffc4
    struct frameset* f_set;   // _cfa_ffffffc0
    int all;                               // _cfa_ffffffbc
    char* p;                               // _cfa_ffffffb8
    char* q;                               // _cfa_ffffffb4
    wc_ces_list* list;   // _cfa_ffffffb0
    Buffer* newbuf;     // _cfa_ffffffac
    FormItemList* fi;   // _cfa_ffffffa8
    ParsedURL pu;    // _cfa_ffffff80
    Buffer* _v144;      // _cfa_ffffff70
    int _v164;                             // _cfa_ffffff5c
    char* _v168;                           // _cfa_ffffff58
    char* _v172;                           // _cfa_ffffff54
    char* _v176;                           // _cfa_ffffff50
    int _v180;                             // _cfa_ffffff4c
    char* _v184;                           // _cfa_ffffff48
    int _v188;                             // _cfa_ffffff44
    char* _v192;                           // _cfa_ffffff40
    unsigned int _v196;                    // _cfa_ffffff3c
    char* _v200;                           // _cfa_ffffff38
    _unknown_ __ebx;                       // r1
    char* __edi;                           // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t240;                       // _t240
    _unknown_ _t241;                       // _t241
    char* _t257;                           // _t257
    char* _t260;                           // _t260
    struct _Str* _t266;   // _t266
    struct _Str* _t268;   // _t268
    Buffer* _t293;      // _t293
    char* _t316;                           // _t316
    _unknown_ _t391;                       // _t391
    char* _t396;                           // _t396
    char* _t411;                           // _t411
    _unknown_ _t415;                       // _t415
    char* _t422;                           // _t422
    Buffer* _t442;      // _t442

    _v144 = _a4;
    _v32 =  *gs:0x14];
    Strnew_size(1024);
    tmp = 0;
    f_set = 0;
    Strcat_charp(tmp, "<html><head><title>Information about current page</title></head><body><h1>Information about current page</h1>\n");
    if(_v144 != 0) {
        all = _v144->allLine;
        if(all == 0) {
            if(_v144->lastLine != 0) {
                all = _v144->lastLine->linenumber;
            }
        }
        Strcat_charp(tmp, "<form method=internal action=charset>");
        p =  *(parsedURL2Str(_v144 + 132));
        if(DecodeURL != 0) {
            p = url_unquote_conv(p, 0);
        }
        __edi = html_quote(last_modified(_v144));
        if(_v144->real_type == 0) {
            _t411 = "unknown";
        } else {
            _t411 = html_quote(_v144->real_type);
        }
        _t257 = html_quote(p);
        _t260 = html_quote(_v144->buffername);
        _v164 = 0;
        _v168 = __edi;
        _v172 = "<tr valign=top><td nowrap>Last Modified<td>";
        _v176 = _t411;
        _v180 = "<tr valign=top><td nowrap>Document Type<td>";
        _v184 = _t257;
        _v188 = "<tr valign=top><td nowrap>Current URL<td>";
        _v192 = _t260;
        _v196 = "<tr valign=top><td nowrap>Title<td>";
        _v200 = "<table cellpadding=0>";
        Strcat_m_charp(tmp);
        if( *(_v144 + 208) == InnerCharset) {
L17:
            _v200 =  *(_v144 + 200);
            _t266 = Sprintf("%d");
            _v200 = all;
            _t268 = Sprintf("%d");
            _v184 = 0;
            _v188 = _t266->ptr;
            _v192 = "<tr valign=top><td nowrap>Transferred bytes<td>";
            _v196 = _t268->ptr;
            _v200 = "<tr valign=top><td nowrap>Number of lines<td>";
            Strcat_m_charp(tmp);
            a = retrieveCurrentAnchor(_v144);
            if(a != 0) {
                parseURL2(a->url,  &(pu.scheme), baseURL(_v144));
                p =  *(parsedURL2Str( &(pu.scheme)));
                q = html_quote(p);
                if(DecodeURL == 0) {
                    p = q;
                } else {
                    p = html_quote(url_unquote_conv(p,  *(_v144 + 208)));
                }
                _v180 = 0;
                _v184 = "</a>";
                _v188 = p;
                _v192 = "">";
                _v196 = q;
                _v200 = "<tr valign=top><td nowrap>URL of current anchor<td><a href="";
                Strcat_m_charp(tmp);
            }
            a = retrieveCurrentImg(_v144);
            if(a != 0) {
                parseURL2(a->url,  &(pu.scheme), baseURL(_v144));
                p =  *(parsedURL2Str( &(pu.scheme)));
                q = html_quote(p);
                if(DecodeURL == 0) {
                    p = q;
                } else {
                    p = html_quote(url_unquote_conv(p,  *(_v144 + 208)));
                }
                _v180 = 0;
                _v184 = "</a>";
                _v188 = p;
                _v192 = "">";
                _v196 = q;
                _v200 = "<tr valign=top><td nowrap>URL of current image<td><a href="";
                Strcat_m_charp(tmp);
            }
            a = retrieveCurrentForm(_v144);
            if(a != 0) {
                fi = a->url;
                p = form2str(fi);
                if(DecodeURL == 0) {
                    p = html_quote(p);
                } else {
                    p = html_quote(url_unquote_conv(p,  *(_v144 + 208)));
                }
                _v192 = 0;
                _v196 = p;
                _v200 = "<tr valign=top><td nowrap>Method/type of current form&nbsp;<td>";
                Strcat_m_charp(tmp);
                if(fi->parent->method == 2 && strcmp( *( *(fi->parent + 12)), 135052056) == 0) {
                    append_map_info(_v144, tmp, fi->parent->item);
                }
            }
            Strcat_charp(tmp, "</table>\n");
            Strcat_charp(tmp, "</form>");
            append_link_info(_v144, tmp, _v144->linklist);
            if(_v144->document_header == 0) {
L39:
                if(_v144->frameset == 0) {
                    asm("cwde ");
                    if((_v144->bufferprop & 2) != 0 && _v144->nextBuffer != 0 && _v144->nextBuffer->frameset != 0) {
                        f_set = _v144->nextBuffer->frameset;
                    }
                } else {
                    f_set = _v144->frameset;
                }
                if(f_set != 0) {
                    Strcat_charp(tmp, "<hr width=50%><h1>Frame information</h1>\n");
                    append_frame_info(_v144, tmp, f_set, 0);
                }
                goto L48;
            }
            Strcat_charp(tmp, "<hr width=50%><h1>Header information</h1><pre>\n");
            ti =  *(_v144->document_header);
            while(ti != 0) {
                _t316 = html_quote(ti->ptr);
                _v188 = 0;
                _v192 = "</pre_int>\n";
                _v196 = _t316;
                _v200 = "<pre_int>";
                Strcat_m_charp(tmp);
                ti = ti->next;
            }
            Strcat_charp(tmp, "</pre>\n");
            goto L39;
        }
        list = wc_get_ces_list();
        Strcat_charp(tmp, "<tr><td nowrap>Document Charset<td><select name=charset>");
        while(list->name != 0) {
            _v196 = list->id;
            sprintf( &charset, "%d");
            _t422 = list->desc;
            if( *(_v144 + 208) != list->id) {
                _t396 = ">";
            } else {
                _t396 = " selected>";
            }
            _v184 = 0;
            _v188 = _t422;
            _v192 = _t396;
            _v196 =  &charset;
            _v200 = "<option value=";
            Strcat_m_charp(tmp);
            list = list + 12;
        }
        Strcat_charp(tmp, "</select>");
        Strcat_charp(tmp, "<tr><td><td><input type=submit value=Change>");
        goto L17;
    }
L48:
    Strcat_charp(tmp, "</body></html>");
    newbuf = loadHTMLString(tmp);
    _t442 = newbuf;
    if(_t442 != 0) {
         *(newbuf + 208) =  *(_v144 + 208);
    }
    _t293 = newbuf;
    if(_t442 == 0) {
        return _t293;
    } else {
        __stack_chk_fail();
        return _t293;
    }
}

KeyAbort(int _dummy)
{// addr = 0x0808FC0C  --  defined in 'frame.c' at line 12
    char* _v0;                             // _cfa_0
    signed int _v20;                       // _cfa_ffffffec
    long _v24;                             // _cfa_ffffffe8
    char* _v28;                            // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    long _v44;                             // _cfa_ffffffd4
    _unknown_ _v80;                        // _cfa_ffffffb0
    long _v84;                             // _cfa_ffffffac
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t65;                       // _t65
    signed int _t73;                       // _t73
    _unknown_ _t105;                       // _t105
    _unknown_ _t106;                       // _t106

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t105);
    _push(_t100);
    __esp = __esp - 52;
    _v44 = 1;
    if(_v24 == 0) {
        _v0 = 135053360;
    } else {
        _v28 = _v0;
        while(1) {
            _v28 = strchr(_v28, 44);
            if(_v28 == 0) {
                break;
            }
            _v20 = _v20 + 1;
            _v28 =  &(_v28[1]);
        }
    }
    _t65 = _v20 << 2;
     *__esp = _t65;
    GC_malloc();
    _v36 = _t65;
    _v20 = 0;
    _v28 = _v0;
L9:
    while(( *_v28 & 0xff) == 0 || ( *( &MYCTYPE_MAP + ( *_v28 & 0xff)) & 2) == 0) {
        _v24 = strtol(_v28,  &_v32, 10);
        _t73 =  *_v32 & 0xff;
        if(_t73 == 37) {
            _t100 = (_v20 << 2) + _v36;
            _v84 = _v24;
             *((_v20 << 2) + _v36) =  *(Sprintf(135053362));
            _v20 = _v20 + 1;
        } else {
            if(_t73 == 42) {
                 *((_v20 << 2) + _v36) = 135053360;
                _v20 = _v20 + 1;
            } else {
                _t100 = (_v20 << 2) + _v36;
                _v84 = _v24;
                 *((_v20 << 2) + _v36) =  *(Sprintf(135053367));
                _v20 = _v20 + 1;
            }
        }
        _v28 = strchr(_v32, 44);
        if(_v28 != 0) {
            _v28 =  &(_v28[1]);
            continue;
        }
         *_dummy = _v36;
        __esp =  &((__esp)[0xd]);
        _pop(__ebx);
        return _v20;
    }
    _v28 =  &(_v28[1]);
    goto L9;
}

int parseFrameSetLength(char* s, char*** ret)
{// addr = 0x0808FC26  --  defined in 'frame.c' at line 18
    int i;                                 // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    char** lv;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char** _t64;                           // _t64
    signed int _t72;                       // _t72

    i = 1;
    if(s == 0) {
        s = 135053360;
        goto L6;
    }
    p = s;
    while(1) {
        p = strchr(p, 44);
        if(p == 0) {
            break;
        }
        i = i + 1;
        p =  &(p[1]);
    }
L6:
    _t64 = i << 2;
     *__esp = _t64;
    GC_malloc();
    lv = _t64;
    i = 0;
    p = s;
L8:
    while(( *p & 0xff) == 0 || ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
        len = strtol(p,  &q, 10);
        _t72 =  *q & 0xff;
        if(_t72 == 37) {
            _v56 = len;
            lv[i] =  *(Sprintf(135053362));
            i = i + 1;
        } else {
            if(_t72 == 42) {
                lv[i] = 135053360;
                i = i + 1;
            } else {
                _v56 = len;
                lv[i] =  *(Sprintf(135053367));
                i = i + 1;
            }
        }
        p = strchr(q, 44);
        if(p != 0) {
            p =  &(p[1]);
            continue;
        }
         *ret = lv;
        return i;
    }
    p =  &(p[1]);
    goto L8;
}

struct frameset* newFrameSet(struct parsed_tag* tag)
{// addr = 0x0808FD83  --  defined in 'frame.c' at line 58
    struct frameset* f;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    char* cols;                            // _cfa_ffffffe8
    char* rows;                            // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t52;                        // _t52
    _unknown_ _t55;                        // _t55
    union frameset_element* _t68;   // _t68

    cols = 0;
    rows = 0;
     *__esp = 36;
    GC_malloc();
    f = __eax;
    f->attr = 2;
    f->name = 0;
    f->currentURL = 0;
    parsedtag_get_value(tag, 13,  &cols);
    parsedtag_get_value(tag, 28,  &rows);
    f->col = parseFrameSetLength(cols,  &(f->width));
    f->row = parseFrameSetLength(rows,  &(f->height));
    f->i = 0;
    i = f->col * f->row;
    _t68 = i << 2;
     *__esp = _t68;
    GC_malloc();
    f->frame = _t68;
    while(1) {
        i = i - 1;
        f->frame[i] = 0;
        if(i == 0) {
            break;
        }
    }
    return f;
}

struct frame_body* newFrame(struct parsed_tag* tag, Buffer* buf)
{// addr = 0x0808FE7F  --  defined in 'frame.c' at line 82
    struct frame_body* body;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39

     *__esp = 36;
    GC_malloc();
    body = __eax;
    bzero(body, 36);
    body->attr = 0;
    body->flags = 0;
    body->baseURL = baseURL(buf);
    if(tag == 0) {
L6:
        return body;
    }
    if(parsedtag_get_value(tag, 31,  &p) != 0) {
        body->url = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(p)), InnerCharset,  *(buf + 208))));
    }
    if(parsedtag_get_value(tag, 25,  &p) != 0 && ( *p & 0xff) != 95) {
        body->name = url_quote( *(wc_Str_conv_strict(Strnew_charp(p), InnerCharset,  *(buf + 208))));
    }
    goto L6;
}

unloadFrame(struct frame_body* b)
{// addr = 0x0808FF9D  --  defined in 'frame.c' at line 102
    _unknown_ __ebp;                       // r6

    b->attr = 0;
    return;
}

deleteFrame(struct frame_body* b)
{// addr = 0x0808FFA8  --  defined in 'frame.c' at line 108
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    if(b != 0) {
        unloadFrame(b);
        bzero(b, 36);
        return;
    }
    return;
}

addFrameSetElement(struct frameset* f, union frameset_element element)
{// addr = 0x0808FFD7  --  defined in 'frame.c' at line 117
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    if(f == 0) {
        return;
    }
    i = f->i;
    if(f->row * f->col <= i) {
    } else {
        goto L2;
    }
    goto L4;
L2:
    f->frame[i] = element;
    f->i = f->i + 1;
    return;
L4:
    return;
}

deleteFrameSet(struct frameset* f)
{// addr = 0x0809002B  --  defined in 'frame.c' at line 131
    int i;                                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    if(f != 0) {
        i = 0;
        while(f->row * f->col > i) {
            deleteFrameSetElement(f->frame[i]);
            i = i + 1;
        }
        f->name = 0;
        f->currentURL = 0;
        return;
    }
    return;
}

deleteFrameSetElement(union frameset_element e)
{// addr = 0x0809008A  --  defined in 'frame.c' at line 146
    _unknown_ __ebp;                       // r6
    signed int _t10;                       // _t10

    if(e != 0) {
        _t10 =  *e & 0xff;
        if(_t10 == 1) {
            deleteFrame(e);
            goto L8;
        }
        if(_t10 == 2) {
            goto L6;
        }
        if(_t10 == 0) {
            goto L7;
        }
        return;
L8:
        return;
L7:
        goto L8;
L6:
        deleteFrameSet(e);
        return;
    }
    return;
}

struct frame_body* copyFrame(struct frame_body* ob)
{// addr = 0x080900D1  --  defined in 'frame.c' at line 166
    struct frame_body* rb;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10

     *__esp = 36;
    GC_malloc();
    rb = __eax;
    bcopy(ob, rb, 36);
    return rb;
}

struct frameset* copyFrameSet(struct frameset* of)
{// addr = 0x08090105  --  defined in 'frame.c' at line 176
    struct frameset* rf;   // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t78;                        // _t78
    char** _t81;                           // _t81
    _unknown_ _t88;                        // _t88
    char** _t91;                           // _t91
    _unknown_ _t98;                        // _t98
    union frameset_element* _t100;   // _t100
    signed int _t111;                      // _t111

     *__esp = 36;
    GC_malloc();
    rf = __eax;
    n = of->row * of->col;
    bcopy(of, rf, 36);
    _t81 = rf->col << 2;
     *__esp = _t81;
    GC_malloc();
    rf->width = _t81;
    bcopy(of->width, rf->width, 0 + rf->col * 4);
    _t91 = rf->row << 2;
     *__esp = _t91;
    GC_malloc();
    rf->height = _t91;
    bcopy(of->height, rf->height, 0 + rf->row * 4);
    _t100 = n << 2;
     *__esp = _t100;
    GC_malloc();
    rf->frame = _t100;
    while(n != 0) {
        n = n - 1;
        if(of->frame[n] != 0) {
            _t111 =  *(of->frame[n]) & 0xff;
            if(_t111 >= 0) {
                goto L9;
            } else {
                if(_t111 <= 1) {
                    rf->frame[n] = copyFrame(of->frame[n]);
                } else {
                    if(_t111 == 2) {
                        rf->frame[n] = copyFrameSet(of->frame[n]);
                        continue;
                    }
                    goto L9;
                }
            }
            continue;
        }
L9:
        rf->frame[n] = 0;
    }
    return rf;
}

flushFrameSet(struct frameset* fs)
{// addr = 0x080902A2  --  defined in 'frame.c' at line 213
    int n;                                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    struct frameset* _t22;   // _t22

    _t22 = fs;
    _t23 = _t22->i;
    n = _t22->i;
    while(n != 0) {
    }
    return;
}

pushFrameTree(struct frameset_queue** fqpp, struct frameset* fs, Buffer* buf)
{// addr = 0x0809032D  --  defined in 'frame.c' at line 238
    struct frameset_queue* rfq;   // _cfa_fffffff0
    struct frameset_queue* cfq;   // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    struct frameset_queue* _t56;   // _t56
    long int _t57;                         // _t57
    long int _t58;                         // _t58
    int _t59;                              // _t59
    int _t60;                              // _t60
    struct _anchorList* _t61;   // _t61

    _t56 =  *fqpp;
    cfq = _t56;
    if(fs == 0) {
        return;
    }
     *__esp = 32;
    GC_malloc();
    rfq = _t56;
    if(buf == 0 || buf->currentLine == 0) {
        _t57 = 1;
    } else {
        _t57 = buf->currentLine->linenumber;
    }
    rfq->linenumber = _t57;
    if(buf == 0 || buf->topLine == 0) {
        _t58 = 1;
    } else {
        _t58 = buf->topLine->linenumber;
    }
    rfq->top_linenumber = _t58;
    if(buf == 0) {
        _t59 = 0;
    } else {
        _t59 = buf->pos;
    }
    rfq->pos = _t59;
    if(buf == 0) {
        _t60 = 0;
    } else {
        _t60 = buf->currentColumn;
    }
    rfq->currentColumn = _t60;
    if(buf == 0) {
        _t61 = 0;
    } else {
        _t61 = buf->formitem;
    }
    rfq->formitem = _t61;
    rfq->back = cfq;
    if(cfq == 0) {
        rfq->next = cfq;
    } else {
        rfq->next = cfq->next;
        if(cfq->next != 0) {
            cfq->next->back = rfq;
        }
        cfq->next = rfq;
    }
    rfq->frameset = fs;
     *fqpp = rfq;
    return;
}

struct frameset* popFrameTree(struct frameset_queue** fqpp)
{// addr = 0x08090441  --  defined in 'frame.c' at line 268
    struct frameset_queue* rfq;   // _cfa_fffffff0
    struct frameset_queue* cfq;   // _cfa_ffffffec
    struct frameset* rfs;   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39

    rfq = 0;
    cfq =  *fqpp;
    rfs = 0;
    if(cfq != 0) {
        rfs = cfq->frameset;
        if(cfq->next != 0) {
            rfq = cfq->next;
            rfq->back = cfq->back;
        }
        if(cfq->back != 0) {
            rfq = cfq->back;
            rfq->next = cfq->next;
        }
         *fqpp = rfq;
        bzero(cfq, 32);
        return rfs;
    }
    return rfs;
}

resetFrameElement(union frameset_element* f_element, Buffer* buf, char* referer, FormList* request)
{// addr = 0x080904CB  --  defined in 'frame.c' at line 289
    char* f_name;                          // _cfa_fffffff0
    struct frame_body* f_body;   // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    f_name =  *( *f_element + 4);
    if(buf->frameset == 0) {
        f_body = newFrame(0, buf);
        f_body->attr = 1;
        f_body->name = f_name;
        f_body->url =  *(parsedURL2Str(buf + 132));
        f_body->source = buf->sourcefile;
        buf->sourcefile = 0;
        if(buf->mailcap_source != 0) {
            f_body->source = buf->mailcap_source;
            buf->mailcap_source = 0;
        }
        f_body->type = buf->type;
        f_body->referer = referer;
        f_body->request = request;
        deleteFrameSetElement( *f_element);
         *f_element = f_body;
        return;
    }
    deleteFrameSetElement( *f_element);
     *f_element = buf->frameset;
    _t92 = f_element;
     *__esp = 40;
    GC_malloc();
     *( *_t92 + 8) = f_element;
    copyParsedURL( *( *f_element + 8), buf + 132);
    buf->frameset = popFrameTree( &(buf->frameQ));
     *( *f_element + 4) = f_name;
    return;
}

struct frameset* frame_download_source(struct frame_body* b, ParsedURL* currentURL, ParsedURL* baseURL, int flag)
{// addr = 0x0809061A  --  defined in 'frame.c' at line 325
    Buffer* buf;        // _cfa_fffffff0
    struct frameset* ret_frameset;   // _cfa_ffffffec
    ParsedURL url;   // _cfa_ffffffc4
    FormList* _v76;   // _cfa_ffffffb4
    signed int _v80;                       // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    FormList* __ebx;   // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t92;                        // _t92
    _None _t108;                           // _t108
    _unknown_ _t114;                       // _t114
    ParsedURL* _t134;   // _t134
    signed int _t151;                      // _t151
    signed int _t161;                      // _t161

    ret_frameset = 0;
    if(b == 0 || b->url == 0 || (b & 0xff) == 0) {
        return 0;
    }
    if(b->baseURL != 0) {
        baseURL = b->baseURL;
    }
    parseURL2(b->url,  &(url.scheme), currentURL);
    if(url.scheme == 4) {
        b->flags = 0;
    }
    is_redisplay = 1;
    w3m_dump = w3m_dump | 32;
    __ebx = b->request;
    _t161 = flag | 4;
    __ecx = b->referer;
    if(baseURL == 0) {
        _t108 = currentURL;
    } else {
        _t108 = baseURL;
    }
    _t151 = b->url;
    _v76 = __ebx;
    _v80 = _t161;
    buf = loadGeneralFile(_t151, _t108, __ecx);
    w3m_dump = w3m_dump & 223;
    is_redisplay = 0;
    if(buf == 0 || buf == 1) {
        b->source = 0;
        b->flags = _t151 & 255;
        return 0;
    }
    b->url =  *(parsedURL2Str(buf + 132));
    b->type = buf->type;
    b->source = buf->sourcefile;
    buf->sourcefile = 0;
    if(buf->mailcap_source != 0) {
        b->source = buf->mailcap_source;
        buf->mailcap_source = 0;
    }
    b->attr = 1;
    if(buf->frameset != 0) {
        ret_frameset = buf->frameset;
        _t134 = ret_frameset;
        _t134->user = b->name;
         *__esp = 40;
        GC_malloc();
        ret_frameset->currentURL = _t134;
        copyParsedURL(ret_frameset->currentURL, buf + 132);
        buf->frameset = popFrameTree( &(buf->frameQ));
    }
    discardBuffer(buf);
    return ret_frameset;
}

int createFrameFile(struct frameset* f, FILE* f1, Buffer* current, int level, int force_reload)
{// addr = 0x0809081D  --  defined in 'frame.c' at line 402
    wc_ces c;           // _cfa_ffffff68
    Str s_tmp;             // _cfa_ffffff70
    int refresh_interval;                  // _cfa_ffffff6c
    int r;                                 // _cfa_ffffffe0
    int c;                                 // _cfa_ffffffdc
    int t_stack;                           // _cfa_ffffffd8
    wc_ces charset;     // _cfa_ffffffd4
    wc_ces doc_charset;   // _cfa_ffffffd0
    char* d_target;                        // _cfa_ffffffcc
    char* p_target;                        // _cfa_ffffffc8
    char* s_target;                        // _cfa_ffffffc4
    char* t_target;                        // _cfa_ffffffc0
    ParsedURL* currentURL;   // _cfa_ffffffbc
    _None prevtrap;                        // _cfa_ffffffb8
    int flag;                              // _cfa_ffffffb4
    union frameset_element frame;   // _cfa_ffffffb0
    struct frameset* f_frameset;   // _cfa_ffffffac
    int i;                                 // _cfa_ffffffa8
    char* p;                               // _cfa_ffffffa4
    int status;                            // _cfa_ffffffa0
    Str tok;               // _cfa_ffffff9c
    int pre_mode;                          // _cfa_ffffff98
    int end_tag;                           // _cfa_ffffff94
    Str tmp;               // _cfa_ffffff90
    int is_tag;                            // _cfa_ffffff8c
    char* q;                               // _cfa_ffffff88
    struct parsed_tag* tag;   // _cfa_ffffff84
    Str tmp;               // _cfa_ffffff80
    char* q;                               // _cfa_ffffff7c
    int j;                                 // _cfa_ffffff78
    int a_target;                          // _cfa_ffffff74
    int _v180;                             // _cfa_ffffff4c
    URLFile f2;        // _cfa_ffffff48
    ParsedURL base;   // _cfa_ffffff20
    ParsedURL url;   // _cfa_fffffef8
    _unknown_ _v284;                       // _cfa_fffffee4
    intOrPtr _v288;                        // _cfa_fffffee0
    int _v292;                             // _cfa_fffffedc
    char* _v296;                           // _cfa_fffffed8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t617;                       // _t617
    _unknown_ _t619;                       // _t619
    ParsedURL* _t623;   // _t623
    _unknown_ _t627;                       // _t627
    _unknown_ _t641;                       // _t641
    _unknown_ _t645;                       // _t645
    signed int _t648;                      // _t648
    char* _t660;                           // _t660
    _unknown_ _t673;                       // _t673
    _unknown_ _t688;                       // _t688
    int _t701;                             // _t701
    _unknown_ _t707;                       // _t707
    _unknown_ _t718;                       // _t718
    _unknown_ _t726;                       // _t726
    _unknown_ _t730;                       // _t730
    signed int _t752;                      // _t752
    signed int _t753;                      // _t753
    _unknown_ _t785;                       // _t785
    _unknown_ _t794;                       // _t794
    _unknown_ _t801;                       // _t801
    _unknown_ _t819;                       // _t819
    _unknown_ _t822;                       // _t822
    _unknown_ _t829;                       // _t829
    _unknown_ _t834;                       // _t834
    _unknown_ _t835;                       // _t835
    _unknown_ _t850;                       // _t850
    _unknown_ _t857;                       // _t857
    _unknown_ _t885;                       // _t885
    _unknown_ _t938;                       // _t938
    _unknown_ _t950;                       // _t950
    _unknown_ _t952;                       // _t952
    char* _t967;                           // _t967
    _unknown_ _t969;                       // _t969
    _unknown_ _t976;                       // _t976
    _unknown_ _t981;                       // _t981
    _unknown_ _t983;                       // _t983
    _unknown_ _t990;                       // _t990
    _unknown_ _t1000;                      // _t1000
    char* _t1018;                          // _t1018
    _unknown_ _t1020;                      // _t1020
    _unknown_ _t1029;                      // _t1029
    _unknown_ _t1034;                      // _t1034
    _unknown_ _t1036;                      // _t1036
    _unknown_ _t1038;                      // _t1038
    _unknown_ _t1040;                      // _t1040
    _unknown_ _t1041;                      // _t1041
    _unknown_ _t1043;                      // _t1043
    _unknown_ _t1048;                      // _t1048
    _unknown_ _t1054;                      // _t1054
    _unknown_ _t1056;                      // _t1056
    _unknown_ _t1058;                      // _t1058
    _unknown_ _t1059;                      // _t1059
    _unknown_ _t1065;                      // _t1065
    _unknown_ _t1069;                      // _t1069
    _unknown_ _t1070;                      // _t1070
    _unknown_ _t1071;                      // _t1071
    _unknown_ _t1096;                      // _t1096

    prevtrap = 0;
    if(f == 0) {
        return -1;
    }
    if(level == 0) {
        _v296 = 1;
         *__esp =  &AbortLoading;
        __sigsetjmp();
        if(_t617 != 0) {
            if((TrapSignal & 0xff) != 0) {
                if((fmInitialized & 0xff) != 0) {
                    term_raw();
                }
                if(prevtrap != 0) {
                    mySignal(2, prevtrap);
                }
            }
            return -1;
        }
        if((TrapSignal & 0xff) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 0xff) != 0) {
                term_cbreak();
            }
        }
        f->name = 135053370;
    }
    if(level > 7) {
        fwrite("Too many frameset tasked.\n", 1, 26, f1);
        return -1;
    }
    if(level != 0) {
        fwrite("<table hborder>\n", 1, 16, f1);
    } else {
        _v292 = html_quote(current->buffername);
        fprintf(f1, "<html><head><title>%s</title></head><body>\n");
        fwrite("<table hborder width="100%">\n", 1, 29, f1);
    }
    if(f->currentURL == 0) {
        _t623 = current + 132;
    } else {
        _t623 = f->currentURL;
    }
    currentURL = _t623;
    r = 0;
    while(f->row > r) {
        while(f->col > c) {
            i = f->col * r + c;
            p = 135053512;
            status = 0;
            tok = Strnew();
            pre_mode = 0;
            end_tag = 0;
            frame = f->frame[i];
            if(frame != 0) {
                fwrite("<td", 1, 3, f1);
                if( *(frame + 4) != 0) {
                    _v292 = html_quote( *(frame + 4));
                    fprintf(f1, " id="_%s"");
                }
                if(r == 0) {
                    _v292 = f->width[c];
                    fprintf(f1, " width="%s"");
                }
                fwrite(">\n", 1, 2, f1);
                flag = 0;
                if(force_reload != 0) {
                    flag = flag | 1;
                    if(( *frame & 0xff) == 1) {
                        unloadFrame(frame);
                    }
                }
                _t648 =  *frame & 0xff;
                if(_t648 == 1) {
L42:
                    init_stream( &(f2.scheme), 4, 0);
                    if( *(frame + 16) != 0) {
                        fflush(f1);
                        examineFile( *(frame + 16),  &(f2.scheme));
                    }
                    if(_v180 != 0) {
                        parseURL2( *(frame + 8),  &(base.scheme), currentURL);
                        p_target = f->name;
                        s_target =  *(frame + 4);
                        t_target = "_blank";
                        if((TargetSelf & 0xff) == 0) {
                            _t660 = t_target;
                        } else {
                            _t660 = s_target;
                        }
                        d_target = _t660;
                        charset = 256;
                        if( *(current + 208) == 256) {
                            doc_charset = DocumentCharset;
                        } else {
                            doc_charset =  *(current + 208);
                        }
                        t_stack = 0;
                        if( *(frame + 20) == 0 || strcasecmp( *(frame + 20), "text/plain") != 0) {
                            goto L66;
                            do {
L66:
                                is_tag = 0;
                                goto L67;
                                do {
                                    goto L67;
L70:
                                    read_token(tok,  &p,  &status, 1, status & 0xff);
                                } while(status != 0);
L71:
L73:
                                if(tok->length == 0) {
                                    goto L150;
                                }
                                if(( *(tok->ptr) & 0xff) == 60) {
                                    if(( *(tok->ptr + 1) & 0xff) == 0 || ( *( &MYCTYPE_MAP + ( *(tok->ptr + 1) & 0xff)) & 4) == 0 && ( *(tok->ptr + 1) & 0xff) != 47 && ( *(tok->ptr + 1) & 0xff) != 33 && ( *(tok->ptr + 1) & 0xff) != 63 && ( *(tok->ptr + 1) & 0xff) != 0 && ( *(tok->ptr + 1) & 0xff) != 95) {
                                        if((pre_mode & 2062) == 0) {
                                            _v292 = 0;
                                            _v296 = p;
                                            p =  *(Strnew_m_charp(tok->ptr + 1));
                                            tok = Strnew_charp("&lt;");
                                        }
                                    } else {
                                        is_tag = 1;
                                    }
                                }
                                if(is_tag == 0) {
L106:
                                    if(is_tag == 0) {
                                        if((pre_mode & 8) == 0) {
                                            if((pre_mode & 2048) == 0) {
                                                fwrite(tok->ptr, 1, tok->length, f1);
                                            } else {
                                                fputs(html_quote(html_unquote(tok->ptr)), f1);
                                            }
                                        } else {
                                            fputs(html_quote(tok->ptr), f1);
                                        }
                                        goto L148;
                                    }
                                } else {
                                    if((pre_mode & 2062) == 0) {
                                        if((pre_mode & 4096) == 0) {
                                            goto L106;
                                        }
                                        goto L97;
                                    }
                                    q = tok->ptr;
                                    tag = parse_tag( &q, 0);
                                    if(tag == 0 || (tag->tagid & 0xff) != end_tag) {
L92:
                                        if(strncmp(tok->ptr, "<!--", 4) != 0) {
                                            q = strchr(tok->ptr + 1, 60);
                                            if(q != 0) {
                                                tok = Strnew_charp_n(tok->ptr, q - tok->ptr);
                                                _v292 = 0;
                                                _v296 = p;
                                                p =  *(Strnew_m_charp(q));
                                                status = 0;
                                            }
                                        }
                                        is_tag = 0;
                                        goto L106;
                                    }
                                    if((pre_mode & 8) == 0) {
                                        pre_mode = 0;
                                        end_tag = 0;
                                        goto L106;
                                    }
                                    fwrite("</PRE_PLAIN>", 1, 12, f1);
                                    pre_mode = 0;
                                    end_tag = 0;
L148:
                                    Strclear(tok);
                                    goto L150;
L97:
                                    q = tok->ptr;
                                    tag = parse_tag( &q, 0);
                                    if(tag == 0) {
                                        goto L106;
                                    }
                                    if((tag->tagid & 0xff) == end_tag || (tag->tagid & 0xff) == 43) {
                                        if((tag->tagid & 0xff) == 43) {
                                            fwrite("</SELECT>", 1, 9, f1);
                                        }
                                        pre_mode = 0;
                                        end_tag = 0;
                                        goto L106;
                                    } else {
                                        if(t_stack == 0 || (tag->tagid & 0xff) - 31 > 59) {
                                            goto L106;
                                        } else {
                                            goto __eax;
                                        }
                                    }
                                }
                                q = tok->ptr;
                                a_target = 0;
                                tag = parse_tag( &q, 0);
                                if(tag == 0) {
                                    goto L148;
                                }
                                if((tag->tagid & 0xff) - 14 > 83) {
                                    j = 0;
L136:
                                    while(( *(((tag->tagid & 0xff) + (tag->tagid & 0xff) + _t1094 << 2) + 135107784) & 0xff) > j) {
                                        goto L111;
                                    }
                                    if(a_target == 1) {
                                        parsedtag_set_value(tag, 32, d_target);
                                    }
                                    if((tag->need_reconstruct & 0xff) != 0) {
                                        tok = parsedtag2str(tag);
                                    }
                                    fwrite(tok->ptr, 1, tok->length, f1);
                                    goto L148;
                                }
                                goto __eax;
L111:
                                _t752 = (tag->attrid[j] & 0xff) - 3;
                                if(_t752 <= 29) {
                                    _t753 = 1 << (_t752 & 255);
                                    if((_t753 & 268468225) != 0) {
                                        if(tag->value[j] != 0) {
                                            tag->value[j] = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(tag->value[j])), InnerCharset, charset)));
                                            tag->need_reconstruct = 1;
                                            parseURL2(tag->value[j],  &(url.scheme),  &(base.scheme));
                                            if(url.scheme != 255 && url.scheme != 254) {
                                                a_target = a_target | 1;
                                                tag->value[j] =  *(parsedURL2Str( &(url.scheme)));
                                                parsedtag_set_value(tag, 71,  *(parsedURL2Str( &(base.scheme))));
                                                if((tag->attrid[j] & 0xff) == 3) {
                                                    if(charset != 256) {
                                                        parsedtag_set_value(tag, 11, wc_ces_to_charset(charset));
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if((_t753 & 4325376) != 0) {
                                            if(tag->value[j] != 0) {
                                                parsedtag_set_value(tag, 67, s_target);
                                            }
                                        } else {
                                            if((_t753 & 536870912) != 0) {
                                                if(tag->value[j] != 0) {
                                                    a_target = a_target | 2;
                                                    if(strcasecmp(tag->value[j], "_self") != 0) {
                                                        if(strcasecmp(tag->value[j], "_parent") == 0) {
                                                            parsedtag_set_value(tag, 32, p_target);
                                                        }
                                                    } else {
                                                        parsedtag_set_value(tag, 32, s_target);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                j = j + 1;
                                goto L136;
L150:
                            } while(( *p & 0xff) != 0 || (_v180->base.stream.cur & 0xff) == 0);
                            if((pre_mode & 8) == 0) {
                                if((pre_mode & 2048) == 0) {
                                    if((pre_mode & 4096) == 0) {
                                        _t701 = pre_mode & 6;
                                        if(_t701 != 0) {
                                            if(status != 0) {
                                                fputs( *(correct_irrtag(status)), f1);
                                            }
                                            if((pre_mode & 2) == 0) {
                                                if((pre_mode & 4) != 0) {
                                                    _t701 = fwrite("</STYLE>\n", 1, 9, f1);
                                                }
                                            } else {
                                                _t701 = fwrite("</SCRIPT>\n", 1, 10, f1);
                                            }
                                        }
                                    } else {
                                        _t701 = fwrite("</SELECT></FORM>\n", 1, 17, f1);
                                    }
                                } else {
                                    _t701 = fwrite("</TEXTAREA></FORM>\n", 1, 19, f1);
                                }
                            } else {
                                _t701 = fwrite("</PRE_PLAIN>\n", 1, 13, f1);
                            }
                            while(1) {
                                t_stack = t_stack - 1;
                                if((_t701 & 255) == 0) {
                                    break;
                                }
                                _t701 = fwrite("</TABLE>\n", 1, 9, f1);
                            }
                            if(ISclose(_v180) == 0) {
                                _v180 = 0;
                            }
                        } else {
                            fwrite("<pre>\n", 1, 6, f1);
                            while(1) {
                                tmp = StrmyISgets(_v180);
                                if(tmp->length == 0) {
                                    break;
                                }
                                tmp = convertLine(0, tmp, 2,  &charset, doc_charset);
                                fputs(html_quote(tmp->ptr), f1);
                            }
                            fwrite("</pre>\n", 1, 7, f1);
                            if(ISclose(_v180) == 0) {
                                _v180 = 0;
                            }
                        }
                        goto L177;
L67:
                        if(( *p & 0xff) != 0) {
                            goto L70;
                        }
                        tmp = StrmyISgets(_v180);
                        if(tmp->length == 0) {
                            goto L73;
                        }
                        tmp = convertLine(0, tmp, 2,  &charset, doc_charset);
                        p = tmp->ptr;
                        goto L70;
                    } else {
                         *frame = 0;
                        if(( *(frame + 1) & 1) == 0) {
                            if( *(frame + 8) == 0) {
                                if( *(frame + 4) == 0) {
                                    _t967 = "(no name)";
                                } else {
                                    _t967 = html_quote( *(frame + 4));
                                }
                                _v292 = _t967;
                                fprintf(f1, "This frame (%s) contains no src attribute");
                            } else {
                                _v292 = html_quote( *(frame + 8));
                                fprintf(f1, "Can't open %s");
                            }
                        } else {
                            _v292 = html_quote( *(frame + 8));
                            fprintf(f1, "Open %s with other method");
                        }
                    }
L177:
                    fwrite("</td>\n", 1, 6, f1);
                    goto L178;
                }
            } else {
                fwrite("<td>\n</td>\n", 1, 11, f1);
L178:
                c = c + 1;
                continue;
            }
            if(_t648 == 2) {
L171:
                if( *(frame + 4) == 0 && f->name != 0) {
                    _v292 = i;
                    _v296 = f->name;
                     *(frame + 4) =  *(Sprintf("%s_%d"));
                }
                createFrameFile(frame, f1, current, level + 1, force_reload);
                goto L177;
            }
            if(_t648 == 0) {
                if( *(frame + 4) == 0 && f->name != 0) {
                    _v292 = i;
                    _v296 = f->name;
                     *(frame + 4) =  *(Sprintf("%s_%d"));
                }
                fflush(f1);
                f_frameset = frame_download_source(frame, currentURL, current->baseURL, flag);
                if(f_frameset == 0) {
                    goto L42;
                } else {
                    deleteFrame(frame);
                    frame = f_frameset;
                    f->frame[i] = frame;
                    goto L171;
                }
            } else {
                _t1018 = html_quote(f->name);
                _v288 = i + 1;
                _v292 = _t1018;
                fprintf(f1, "Frameset "%s" frame %d: type unrecognized");
            }
            goto L177;
        }
        fwrite("</tr>\n", 1, 6, f1);
        r = r + 1;
    }
    fwrite("</table>\n", 1, 9, f1);
    if(level == 0) {
        fwrite("</body></html>\n", 1, 15, f1);
        if((TrapSignal & 0xff) != 0) {
            if((fmInitialized & 0xff) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
    }
    return 0;
}

Buffer* renderFrame(Buffer* Cbuf, int force_reload)
{// addr = 0x08091F71  --  defined in 'frame.c' at line 879
    Str tmp;               // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8
    int flag;                              // _cfa_ffffffe4
    struct frameset* fset;   // _cfa_ffffffe0
    wc_ces doc_charset;   // _cfa_ffffffdc
    Buffer* _v60;       // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t58;                        // _t58
    _unknown_ _t65;                        // _t65
    _unknown_ _t76;                        // _t76
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87

    doc_charset = DocumentCharset;
    tmp = tmpfname(2, 135054624);
    f = fopen(tmp->ptr, 135054630);
    if(f == 0) {
        return 0;
    }
    fset = Cbuf->frameset;
    if(fset == 0 || createFrameFile(fset, f, Cbuf, 0, force_reload) < 0) {
        return 0;
    }
    fclose(f);
    flag = 2;
    if( *((intOrPtr*)(Cbuf + 168)) != 0) {
        flag = flag | 1;
    }
    renderFrameSet = Cbuf->frameset;
    flushFrameSet(renderFrameSet);
    DocumentCharset = InnerCharset;
    _v60 = 0;
    _v64 = flag;
    buf = loadGeneralFile(tmp->ptr, 0, 0);
    DocumentCharset = doc_charset;
    renderFrameSet = 0;
    if(buf == 0 || buf == 1) {
        return 0;
    }
    buf->sourcefile = tmp->ptr;
     *((intOrPtr*)(buf + 208)) =  *((intOrPtr*)(Cbuf + 208));
    copyParsedURL(buf + 132, Cbuf + 132);
    preFormUpdateBuffer(buf);
    return buf;
}

union frameset_element* search_frame(struct frameset* fset, char* name)
{// addr = 0x080920F0  --  defined in 'frame.c' at line 925
    int i;                                 // _cfa_fffffff0
    union frameset_element* e;   // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t55;                        // _t55

    e = 0;
    i = 0;
    while(fset->row * fset->col > i) {
        e =  &(fset->frame[i]);
        if( *e == 0) {
L8:
            i = i + 1;
            continue;
        }
        if( *( *e + 4) == 0 || strcmp( *( *e + 4), name) != 0) {
            if(( *( *e) & 0xff) != 2) {
                goto L8;
            }
        } else {
            return e;
        }
        e = search_frame( *e, name);
        if(e == 0) {
            goto L8;
        }
        return e;
    }
    return 0;
}

int compare_table(struct rc_search_table* a, struct rc_search_table* b)
{// addr = 0x080921A0  --  defined in 'rc.c' at line 706
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return strcmp(a->param->name, b->param->name);
}

create_option_search_table()
{// addr = 0x080921C2  --  defined in 'rc.c' at line 712
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int diff1;                             // _cfa_ffffffe4
    int diff2;                             // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    char* q;                               // _cfa_ffffffd8
    intOrPtr _v48;                         // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct rc_search_table* _t102;   // _t102
    _unknown_ _t121;                       // _t121

    RC_table_size = 0;
    j = 0;
    while( *((intOrPtr*)( &sections + j * 8)) != 0) {
        while( *((intOrPtr*)( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t157 << 3))) != 0) {
            i = i + 1;
            RC_table_size = RC_table_size + 1;
        }
        j = j + 1;
    }
    _t102 = RC_table_size << 3;
     *__esp = _t102;
    GC_malloc();
    RC_search_table = _t102;
    k = 0;
    j = 0;
    while( *((intOrPtr*)( &sections + j * 8)) != 0) {
        i = 0;
        while( *((intOrPtr*)( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t158 << 3))) != 0) {
            RC_search_table[k].param =  *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t161 << 3);
            k = k + 1;
            i = i + 1;
        }
        j = j + 1;
    }
    _v48 = compare_table;
    qsort(RC_search_table, RC_table_size, 8);
    diff2 = 0;
    diff1 = diff2;
    i = 0;
    while(RC_table_size - 1 > i) {
        p = RC_search_table[i].param->name;
        q = RC_search_table[i + 1].param->name;
        j = 0;
        while((p[j] & 0xff) != 0 && (q[j] & 0xff) != 0 && (p[j] & 0xff) == (q[j] & 0xff)) {
            j = j + 1;
        }
        diff1 = j;
        if(diff1 <= diff2) {
             &(RC_search_table[i])->uniq_pos = diff2 + 1 & 65535;
        } else {
             &(RC_search_table[i])->uniq_pos = diff1 + 1 & 65535;
        }
        diff2 = diff1;
        i = i + 1;
    }
    return;
}

struct param_ptr* search_param(char* name)
{// addr = 0x080923C2  --  defined in 'rc.c' at line 757
    size_t b;           // _cfa_fffffff0
    size_t e;           // _cfa_ffffffec
    size_t i;           // _cfa_ffffffe8
    int cmp;                               // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t56;                        // _t56
    _unknown_ _t63;                        // _t63

    len = strlen(name);
    b = 0;
    e = RC_table_size - 1;
    while(b <= e) {
        i = b + e >> 1;
        cmp = strncmp(name, RC_search_table[i].param->name, len);
        if(cmp != 0) {
            if(cmp >= 0) {
                b = i + 1;
                continue;
            }
            goto L13;
        }
        asm("cwde ");
        if(( &(RC_search_table[i])->uniq_pos & 65535) > len) {
            while(1) {
                RC_search_table =  &(RC_search_table[i]);
                RC_search_table[i].param = RC_search_table[i].param->name;
                _v56 = RC_search_table[i].param->name;
                __eax = name;
                 *__esp = name;
                __eax = strcmp();
                cmp = name;
                if(cmp > 0) {
                    break;
                }
                if(cmp != 0) {
                    if(i != 0) {
                        i = i - 1;
                        continue;
                    }
                    goto L7;
                }
                RC_search_table =  &(RC_search_table[i]);
                __eax = RC_search_table[i].param;
                return RC_search_table[i].param;
L7:
                __eax = 0;
                return 0;
            }
            __eax = 0;
            return 0;
        }
        return RC_search_table[i].param;
L13:
        if(i != 0) {
            e = i - 1;
            continue;
        }
        return 0;
    }
    return 0;
}

show_params(FILE* fp)
{// addr = 0x080924EF  --  defined in 'rc.c' at line 797
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int l;                                 // _cfa_ffffffe8
    char* t;                               // _cfa_ffffffe4
    char* cmt;                             // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    struct _Str _v64;     // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t91;                        // _t91
    _unknown_ _t102;                       // _t102
    int _t132;                             // _t132
    _unknown_ _t135;                       // _t135
    struct _Str* _t139;   // _t139
    _unknown_ _t148;                       // _t148
    _unknown_ _t160;                       // _t160

    t = 0;
    OptionCharset = SystemCharset;
    fwrite("\nconfiguration parameters\n", 1, 26, fp);
    j = 0;
    while( *( &sections + j * 8) != 0) {
        if(OptionEncode != 0) {
            cmt =  *( &sections + j * 8);
        } else {
            cmt =  *(wc_Str_conv(Strnew_charp(gettext( *( &sections + j * 8))), OptionCharset, InnerCharset));
        }
        _v64 =  *(wc_Str_conv_strict(Strnew_charp(cmt), InnerCharset, SystemCharset));
        _v68 = j;
        fprintf(fp, "  section[%d]: %s\n");
        i = 0;
        while( *((intOrPtr*)( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t184 << 3))) != 0) {
            if( *((intOrPtr*)( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t185 << 3) + 4)) <= 10) {
                goto __eax;
            }
            if(OptionEncode != 0) {
                cmt =  *( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t186 << 3) + 16);
            } else {
                cmt =  *(wc_Str_conv(Strnew_charp(gettext( *( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t191 << 3) + 16))), OptionCharset, InnerCharset));
            }
            _t132 = strlen( *( *((intOrPtr*)(135096292 + j * 8)) + (i + i + _t187 << 3)));
            l = 30 - _t132 + strlen(t);
            if(l < 0) {
                l = 1;
            }
            _t139 = wc_Str_conv_strict(Strnew_charp(cmt), InnerCharset, SystemCharset);
            _t189 = i;
            _v52 = _t139->ptr;
            _v64.area_size = " ";
            _v64.length = l;
            _v64 = t;
            _v68 =  *( *((intOrPtr*)(135096292 + j * 8)) + (i + _t189 + _t189 << 3));
            fprintf(fp, "    -o %s=<%s>%*s%s\n");
            i = i + 1;
        }
        j = j + 1;
    }
    return;
}

int str_to_bool(char* value, int old)
{// addr = 0x080927EA  --  defined in 'rc.c' at line 877
    _unknown_ __ebp;                       // r6
    signed int _t24;                       // _t24
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t31;                        // _t31

    if(value != 0) {
        if(( *( &MYCTYPE_MAP + ( *value & 0xff)) & 4) == 0) {
            _t24 =  *value & 0xff;
        } else {
            _t24 = ( *value & 255 | 32) & 255;
        }
        if(_t24 - 33 > 87) {
            return 1;
        }
        goto __eax;
    }
    return 1;
}

int str_to_color(char* value)
{// addr = 0x08092905  --  defined in 'rc.c' at line 905
    _unknown_ __ebp;                       // r6
    signed int _t24;                       // _t24
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t31;                        // _t31

    if(value != 0) {
        if(( *( &MYCTYPE_MAP + ( *value & 0xff)) & 4) == 0) {
            _t24 =  *value & 0xff;
        } else {
            _t24 = ( *value & 255 | 32) & 255;
        }
        if(_t24 - 48 > 73) {
            return 8;
        }
        goto __eax;
    }
    return 8;
}

int set_param(char* name, char* value)
{// addr = 0x080929D0  --  defined in 'rc.c' at line 946
    double ppc;                            // _cfa_ffffffe4
    struct param_ptr* p;   // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    if(value != 0) {
        p = search_param(name);
        if(p != 0) {
            if(p->type > 10) {
                return 1;
            }
            goto L5;
        }
        goto L3;
L5:
        goto __eax;
    }
    return 0;
L3:
    return 0;
}

int set_param_option(char* option)
{// addr = 0x08092C20  --  defined in 'rc.c' at line 1015
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t90;                        // _t90
    _unknown_ _t103;                       // _t103
    _unknown_ _t111;                       // _t111
    _unknown_ _t114;                       // _t114
    int _t147;                             // _t147

    tmp = Strnew();
    p = option;
    while(( *p & 0xff) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            goto L11;
        }
        if(( *p & 0xff) != 61) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t147 = tmp->length;
             *(tmp->ptr + _t147) =  *p & 0xff;
            tmp->length = _t147 + 1;
            p =  &(p[1]);
             *(tmp->ptr + tmp->length) = 0;
            continue;
        }
L11:
        while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p =  &(p[1]);
        }
        if(( *p & 0xff) != 61) {
L18:
            Strlower(tmp);
            if(set_param(tmp->ptr, p) != 0) {
L30:
                return 1;
            }
            goto L19;
L29:
            goto L30;
        }
        p =  &(p[1]);
        while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p =  &(p[1]);
        }
        goto L18;
L19:
        q = tmp->ptr;
        if(strncmp(q, 135061856, 2) != 0) {
            if((tmp & 0xff) != 45) {
                return 0;
            }
            goto L24;
        }
        q =  &(q[2]);
        if(( *q & 0xff) == 45 || ( *q & 0xff) == 95) {
            q =  &(q[1]);
        }
L26:
        if(set_param(q, 135054688) != 0) {
            goto L29;
        }
        return 0;
L24:
        q =  &(q[1]);
        goto L26;
    }
    goto L11;
}

char* get_param_option(char* name)
{// addr = 0x08092DCD  --  defined in 'rc.c' at line 1050
    struct param_ptr* p;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    p = search_param(name);
    if(p == 0) {
        return 0;
    }
    return  *(to_str(p));
}

interpret_rc(FILE* f)
{// addr = 0x08092DFD  --  defined in 'rc.c' at line 1059
    Str line;              // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t84;                              // _t84
    _unknown_ _t96;                        // _t96

    while(1) {
L1:
        line = Strfgets(f);
        Strchop(line);
        if(line->length == 0) {
            break;
        }
        Strremovefirstspaces(line);
        if((line & 0xff) != 35) {
            tmp = Strnew();
            p = line->ptr;
L8:
            while(( *p & 0xff) != 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                    goto L5;
                }
L13:
                while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                    p =  &(p[1]);
                }
                Strlower(tmp);
                set_param(tmp->ptr, p);
                goto L1;
            }
            goto L13;
        }
        continue;
L5:
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t84 = tmp->length;
         *(tmp->ptr + _t84) =  *p & 0xff;
        tmp->length = _t84 + 1;
        p =  &(p[1]);
         *((char*)(tmp->ptr + tmp->length)) = 0;
        goto L8;
    }
    return;
}

parse_proxy()
{// addr = 0x08092F21  --  defined in 'rc.c' at line 1085
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(non_null(HTTP_proxy) != 0) {
        parseURL(HTTP_proxy,  &HTTP_proxy_parsed, 0);
    }
    if(non_null(GOPHER_proxy) != 0) {
        parseURL(GOPHER_proxy,  &GOPHER_proxy_parsed, 0);
    }
    if(non_null(FTP_proxy) != 0) {
        parseURL(FTP_proxy,  &FTP_proxy_parsed, 0);
    }
    if(non_null(NO_proxy) != 0) {
        NO_proxy_domains = make_domain_list(NO_proxy);
        return;
    }
    return;
}

parse_cookie()
{// addr = 0x08092FD6  --  defined in 'rc.c' at line 1105
    _unknown_ __ebp;                       // r6

    if(non_null(cookie_reject_domains) != 0) {
        Cookie_reject_domains = make_domain_list(cookie_reject_domains);
    }
    if(non_null(cookie_accept_domains) != 0) {
        Cookie_accept_domains = make_domain_list(cookie_accept_domains);
        return;
    }
    return;
}

sync_with_option()
{// addr = 0x08093024  --  defined in 'rc.c' at line 1140
    _unknown_ __ebp;                       // r6

    if(PagerMax < LINES) {
        PagerMax = LINES;
    }
    WrapSearch = WrapDefault;
    parse_proxy();
    parse_cookie();
    initMailcap();
    initMimeTypes();
    initURIMethods();
    init_migemo();
    if((fmInitialized & 0xff) != 0) {
        if(displayImage != 0) {
            initImage();
        }
    }
    loadPasswd();
    loadPreForm();
    if(AcceptLang == 0 || ( *AcceptLang & 0xff) == 0) {
        AcceptLang = gettext("en;q=1.0");
    }
    if(AcceptEncoding == 0 || ( *AcceptEncoding & 0xff) == 0) {
        AcceptEncoding = acceptableEncoding();
    }
    if(AcceptMedia == 0 || ( *AcceptMedia & 0xff) == 0) {
        AcceptMedia = acceptableMimeTypes();
    }
    if((fmInitialized & 0xff) != 0) {
        initKeymap(0);
        initMouseAction();
        initMenu();
        return;
    }
    return;
}

init_rc()
{// addr = 0x08093115  --  defined in 'rc.c' at line 1190
    int i;                                 // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    signed int _v92;                       // _cfa_ffffffa4
    struct stat st;       // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char* _t49;                            // _t49
    _unknown_ _t64;                        // _t64
    _unknown_ _t67;                        // _t67
    _unknown_ _t70;                        // _t70
    _unknown_ _t73;                        // _t73
    _unknown_ _t84;                        // _t84
    _unknown_ _t88;                        // _t88
    char* _t89;                            // _t89
    _unknown_ _t92;                        // _t92

    if(rc_dir != 0) {
        goto L18;
    }
    rc_dir = expandPath("~/.w3m");
    i = strlen(rc_dir);
    if(i > 1) {
        if((rc_dir[i - 1] & 0xff) == 47) {
            rc_dir[i - 1] = 0;
        }
    }
    display_charset_str = wc_get_ces_list();
    document_charset_str = display_charset_str;
    system_charset_str = display_charset_str;
    _t49 = rc_dir;
    __stat(_t49,  &(st.st_dev));
    if(_t49 >= 0) {
L10:
        if((_v92 & 61440) == 16384) {
            if((_v92 & 128) != 0) {
                no_rc_dir = 0;
                tmp_dir = rc_dir;
                if(config_file == 0) {
                    config_file = rcFile("config");
                }
                create_option_search_table();
                goto L18;
            }
            goto L13;
        }
        goto L11;
L13:
        _v116 = rc_dir;
        fprintf(__imp__stderr, "%s is not writable!");
        goto L24;
    }
    if( *(__errno_location()) != 2) {
L9:
        _v116 = rc_dir;
        fprintf(__imp__stderr, "Can't open config directory (%s)!");
        goto L24;
    }
    _t89 = rc_dir;
    _v120 = 448;
     *__esp = _t89;
    mkdir();
    if(_t89 >= 0) {
        __stat(rc_dir,  &(st.st_dev));
        goto L10;
    }
    _v116 = rc_dir;
    fprintf(__imp__stderr, "Can't create config directory (%s)!");
L24:
    no_rc_dir = 1;
    tmp_dir = getenv("TMPDIR");
    if(tmp_dir == 0 || ( *tmp_dir & 0xff) == 0) {
        tmp_dir = getenv("TMP");
        if(tmp_dir == 0 || ( *tmp_dir & 0xff) == 0) {
            tmp_dir = getenv("TEMP");
            if(tmp_dir == 0 || ( *tmp_dir & 0xff) == 0) {
                tmp_dir = "/tmp";
                return;
            }
        }
    }
L32:
    return;
    goto L9;
L11:
    _v116 = rc_dir;
    fprintf(__imp__stderr, "%s is not a directory!");
    goto L24;
L18:
    f = fopen(etcFile("w3mconfig"), "rt");
    if(f != 0) {
        interpret_rc(f);
        fclose(f);
    }
    f = fopen(confFile("config"), "rt");
    if(f != 0) {
        interpret_rc(f);
        fclose(f);
    }
    f = fopen(config_file, "rt");
    if(f == 0) {
    } else {
        interpret_rc(f);
        fclose(f);
        return;
    }
    goto L32;
}

Str to_str(struct param_ptr* p)
{// addr = 0x08093413  --  defined in 'rc.c' at line 1280
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    if(p->type <= 10) {
        goto __eax;
    }
    return 0;
}

Buffer* load_option_panel()
{// addr = 0x08093526  --  defined in 'rc.c' at line 1314
    Str src;               // _cfa_ffffffe0
    struct param_ptr* p;   // _cfa_ffffffdc
    struct sel_c* s;     // _cfa_ffffffd8
    wc_ces_list* c;   // _cfa_ffffffd4
    int x;                                 // _cfa_ffffffd0
    int i;                                 // _cfa_ffffffcc
    Str tmp;               // _cfa_ffffffc8
    Buffer* buf;        // _cfa_ffffffc4
    signed short _v62;                     // _cfa_ffffffc2
    signed int _v64;                       // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    int _v84;                              // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    char* _v92;                            // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    char* _v108;                           // _cfa_ffffff94
    char* _v112;                           // _cfa_ffffff90
    char* _v116;                           // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    int _t277;                             // _t277
    char* _t283;                           // _t283
    int _t310;                             // _t310
    int _t356;                             // _t356
    char* _t371;                           // _t371
    char* _t422;                           // _t422
    char* _t425;                           // _t425
    char* _t427;                           // _t427
    char* _t440;                           // _t440

    if(optionpanel_str == 0) {
        _t422 = gettext("External Viewer Setup");
        _t425 = html_quote( *(localCookie()));
        _v112 = _t422;
        _v116 = _t425;
        _v120 = w3m_version;
        optionpanel_str = Sprintf("<html><head><title>Option Setting Panel</title></head><body><h1 align=center>Option Setting Panel<br>(w3m version %s)</b></h1><form method=post action="file:///$LIB/w3mhelperpanel"><input type=hidden name=mode value=panel><input type=hidden name=cookie value="%s"><input type=submit value="%s"></form><br><form method=internal action=option>");
    }
    OptionCharset = SystemCharset;
    if(OptionEncode != 0) {
L18:
        src = Strdup(optionpanel_str);
        Strcat_charp(src, "<table><tr><td>");
        i = 0;
L57:
        while( *( &sections + i * 8) != 0) {
            goto L19;
        }
        Strcat_charp(src, "</table></form></body></html>");
        buf = loadHTMLString(src);
        if(buf != 0) {
             *(buf + 208) = OptionCharset;
        }
        return buf;
    } else {
        optionpanel_str = wc_Str_conv(optionpanel_str, OptionCharset, InnerCharset);
        i = 0;
        while( *( &sections + i * 8) != 0) {
            while(p->name != 0) {
                p->comment =  *(wc_Str_conv(Strnew_charp(gettext(p->comment)), OptionCharset, InnerCharset));
                if(p->inputtype != 2 || p->select ==  &colorstr) {
L10:
                    p = p + 24;
                    continue;
                }
                s = p->select;
                while(s->text != 0) {
                    s->text =  *(wc_Str_conv(Strnew_charp(gettext(s->text)), OptionCharset, InnerCharset));
                    s = s + 12;
                }
                goto L10;
            }
            i = i + 1;
        }
        s =  &colorstr;
        while(s->text != 0) {
            s->text =  *(wc_Str_conv(Strnew_charp(gettext(s->text)), OptionCharset, InnerCharset));
            s = s + 12;
        }
        OptionEncode = 1;
        goto L18;
    }
L19:
    _v108 = 0;
    _v112 = "</h1>";
    _v116 =  *( &sections + i * 8);
    _v120 = "<h1>";
    Strcat_m_charp(src);
    p =  *(135096292 + i * 8);
    Strcat_charp(src, "<table width=100% cellpadding=0>");
    while(p->name != 0) {
        _v112 = 0;
        _v116 = p->comment;
        _v120 = "<tr><td>";
        Strcat_m_charp(src);
        asm("fld qword [0x80d53a0]");
        asm("fld qword [0x80ce460]");
        asm("fmulp st1, st0");
        asm("fnstcw word [ebp-0x3a]");
        _v64 = _v62 & 0xffff;
        asm("fldcw word [ebp-0x3c]");
        asm("fistp dword [ebp-0x40]");
        asm("fldcw word [ebp-0x3a]");
        _v120 = _v68;
        Strcat(src, Sprintf("</td><td width=%d>"));
        _t277 = p->inputtype;
        if(_t277 == 1) {
            x = atoi( *(to_str(p)));
            if(x == 0) {
                _t440 = " checked";
            } else {
                _t440 = 135062232;
            }
            _t427 = p->name;
            if(x == 0) {
                _t283 = 135062232;
            } else {
                _t283 = " checked";
            }
            _v84 = 0;
            _v88 = ">NO";
            _v92 = _t440;
            _v96 = " value=0";
            _v100 = _t427;
            _v104 = ">YES&nbsp;&nbsp;<input type=radio name=";
            _v108 = _t283;
            _v112 = " value=1";
            _v116 = p->name;
            _v120 = "<input type=radio name=";
            Strcat_m_charp(src);
            goto L54;
        }
        if(_t277 > 1) {
            if(_t277 == 2) {
                tmp = to_str(p);
                _v108 = 0;
                _v112 = ">";
                _v116 = p->name;
                _v120 = "<select name=";
                Strcat_m_charp(src);
                s = p->select;
L44:
                while(s->text != 0) {
                    goto L36;
                }
                Strcat_charp(src, "</select>");
                goto L54;
            }
            goto L25;
L36:
            Strcat_charp(src, "<option value=");
            _v120 = s->cvalue;
            Strcat(src, Sprintf("%s\n"));
            if(p->type == 3 || s->value != atoi(tmp->ptr)) {
                if(p->type != 3 || (s->value & 255) != (tmp & 0xff)) {
L41:
                    if(src->length + 1 >= src->area_size) {
                        Strgrow(src);
                    }
                    _t310 = src->length;
                     *((char*)(src->ptr + _t310)) = 62;
                    src->length = _t310 + 1;
                     *(src->ptr + src->length) = 0;
                    Strcat_charp(src, s->text);
                    s = s + 12;
                    goto L44;
                }
            }
            Strcat_charp(src, " selected");
            goto L41;
        }
        if(_t277 == 0) {
            _t371 = html_quote( *(to_str(p)));
            _v100 = 0;
            _v104 = "">";
            _v108 = _t371;
            _v112 = " value="";
            _v116 = p->name;
            _v120 = "<input type=text name=";
            Strcat_m_charp(src);
        }
L54:
        Strcat_charp(src, "</td></tr>\n");
        p = p + 24;
        continue;
L25:
        if(_t277 == 3) {
            tmp = to_str(p);
            _v108 = 0;
            _v112 = ">";
            _v116 = p->name;
            _v120 = "<select name=";
            Strcat_m_charp(src);
            c =  *(p->select);
L52:
            while(c->desc != 0) {
                goto L47;
            }
            Strcat_charp(src, "</select>");
            goto L54;
        }
        goto L54;
L47:
        Strcat_charp(src, "<option value=");
        _v120 = c->name;
        Strcat(src, Sprintf("%s\n"));
        if(c->id == atoi(tmp->ptr)) {
            Strcat_charp(src, " selected");
        }
        if(src->length + 1 >= src->area_size) {
            Strgrow(src);
        }
        _t356 = src->length;
         *((char*)(src->ptr + _t356)) = 62;
        src->length = _t356 + 1;
         *(src->ptr + src->length) = 0;
        Strcat_charp(src, c->desc);
        c = c + 12;
        goto L52;
    }
    Strcat_charp(src, "<tr><td></td><td><p><input type=submit value="OK"></td></tr>");
    Strcat_charp(src, "</table><hr width=50%>");
    i = i + 1;
    goto L57;
}

panel_set_option(struct parsed_tagarg* arg)
{// addr = 0x08093C71  --  defined in 'rc.c' at line 1440
    FILE* f;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* _v32;                            // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct parsed_tagarg* _t35;   // _t35
    _unknown_ _t48;                        // _t48

    f = 0;
    if(no_rc_dir == 0) {
        f = fopen(config_file, "wt");
        if(f == 0) {
            disp_message("Can't write option!", 0);
        }
    } else {
        disp_message("There's no ~/.w3m directory... config not saved", 0);
    }
    while(arg != 0) {
        if(arg->value != 0) {
            p =  *(wc_Str_conv_strict(Strnew_charp(arg->value), InnerCharset, SystemCharset));
            if(set_param(arg->arg, p) != 0 && f != 0) {
                _v32 = p;
                _v36 = arg->arg;
                fprintf(f, "%s %s\n");
            }
        }
        _t35 = arg;
        _t32 = _t35->next;
        arg = _t35->next;
    }
    if(f != 0) {
        _t32 = fclose(f);
    }
    sync_with_option();
    backBf();
    return;
}

char* rcFile(char* base)
{// addr = 0x08093D8E  --  defined in 'rc.c' at line 1472
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(base != 0) {
        if(( *base & 0xff) == 47 || ( *base & 0xff) == 46 && ((base[1] & 0xff) == 47 || (base[1] & 0xff) == 46 && (base[2] & 0xff) == 47) || ( *base & 0xff) == 126 && (base[1] & 0xff) == 47) {
            return expandPath(base);
        } else {
            goto L9;
        }
    }
L9:
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(rc_dir)));
}

char* auxbinFile(char* base)
{// addr = 0x08093E29  --  defined in 'rc.c' at line 1485
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5
    char* _t6;                             // _t6

    _t6 = w3m_auxbin_dir();
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(_t6)));
}

char* etcFile(char* base)
{// addr = 0x08093E5F  --  defined in 'rc.c' at line 1499
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5
    char* _t6;                             // _t6

    _t6 = w3m_etc_dir();
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(_t6)));
}

char* confFile(char* base)
{// addr = 0x08093E95  --  defined in 'rc.c' at line 1505
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5
    char* _t6;                             // _t6

    _t6 = w3m_conf_dir();
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(_t6)));
}

new_menu(Menu* menu, MenuItem* item)
{// addr = 0x08093ECC  --  defined in 'menu.c' at line 303
    int i;                                 // _cfa_fffffff0
    int l;                                 // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    menu->cursorX = 0;
    menu->cursorY = 0;
    menu->x = 0;
    menu->y = 0;
    menu->nitem = 0;
    menu->item = item;
    menu->initial = 0;
    menu->select = 0;
    menu->offset = 0;
    menu->active = 0;
    if(item != 0) {
        i = 0;
        while( *((intOrPtr*)(item + (i << 5))) != 0) {
            i = i + 1;
        }
        menu->nitem = i;
        menu->height = menu->nitem;
        i = 0;
        while(i <= 127) {
             *((intOrPtr*)(menu + 4 + (i + 12) * 4)) =  *((intOrPtr*)( &MenuKeymap + i * 4));
            i = i + 1;
        }
        menu->width = 0;
        i = 0;
        while(menu->nitem > i) {
            p =  *(item + (i << 5) + 24);
            if(p == 0) {
L14:
                l = wtf_strwidth( *(item + (i << 5) + 4));
                if(menu->width < l) {
                    menu->width = l;
                }
                i = i + 1;
                continue;
            }
            while(( *p & 0xff) != 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0x11) != 0) {
                     *((intOrPtr*)(menu + 4 + (( *p & 0xff) + 12) * 4)) = mSelect;
                     *(menu + 4 + (( *p & 0xff) + 140) * 4) = i;
                }
                p =  &(p[1]);
            }
            goto L14;
        }
        return;
    }
    return;
}

geom_menu(Menu* menu, int x, int y, int mselect)
{// addr = 0x08094062  --  defined in 'menu.c' at line 345
    int win_x;                             // _cfa_fffffff4
    int win_y;                             // _cfa_fffffff0
    int win_w;                             // _cfa_ffffffec
    int win_h;                             // _cfa_ffffffe8
    int _v28;                              // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    _unknown_ _t90;                        // _t90
    _unknown_ _t132;                       // _t132
    _unknown_ _t140;                       // _t140
    _unknown_ _t161;                       // _t161
    _unknown_ _t182;                       // _t182
    _unknown_ _t190;                       // _t190
    _unknown_ _t191;                       // _t191

    menu->select = mselect;
    if(menu->width % FRAME_WIDTH != 0) {
        _v28 = FRAME_WIDTH;
        menu->width = (menu->width / _v28 + 1) * FRAME_WIDTH;
    }
    win_x = menu->x - FRAME_WIDTH;
    win_w = menu->width + FRAME_WIDTH + FRAME_WIDTH;
    if(win_x + win_w > COLS) {
        win_x = COLS - win_w;
    }
    if(win_x < 0) {
        win_x = 0;
        if(win_w > COLS) {
            menu->width = 0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS;
            menu->width = menu->width - menu->width % FRAME_WIDTH;
            win_w = menu->width + FRAME_WIDTH + FRAME_WIDTH;
        }
    }
    menu->x = FRAME_WIDTH + win_x;
    win_y = menu->y - mselect - 1;
    win_h = menu->height + 2;
    if(win_y + win_h > LINES - 1) {
        win_y = LINES - 1 - win_h;
    }
    if(win_y < 0) {
        win_y = 0;
        if(win_y + win_h > LINES - 1) {
            win_h = LINES - 1 - win_y;
            menu->height = win_h - 2;
            if(menu->height <= mselect) {
                menu->offset = mselect - menu->height + 1;
            }
        }
    }
    menu->y = win_y + 1;
    return;
}

draw_all_menu(Menu* menu)
{// addr = 0x08094220  --  defined in 'menu.c' at line 384
    _unknown_ __ebp;                       // r6

    if(menu->parent != 0) {
        draw_all_menu(menu->parent);
    }
    draw_menu(menu);
    return;
}

draw_menu(Menu* menu)
{// addr = 0x08094249  --  defined in 'menu.c' at line 392
    int x;                                 // _cfa_fffffff0
    int y;                                 // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int j;                                 // _cfa_ffffffe0
    int _v48;                              // _cfa_ffffffd0
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t310;                       // _t310
    _unknown_ _t311;                       // _t311
    _unknown_ _t325;                       // _t325
    _unknown_ _t326;                       // _t326

    x = menu->x - FRAME_WIDTH;
    w = menu->width + FRAME_WIDTH + FRAME_WIDTH;
    y = menu->y - 1;
    if(menu->offset != 0) {
        if(graph_mode != 0) {
            graphstart();
        }
        move(y, x);
        addstr(FRAME[5]);
        if(graph_mode != 0) {
            graphend();
        }
        i = FRAME_WIDTH;
        while(w - FRAME_WIDTH > i) {
            move(y, x + i);
            addstr(135063018);
            i = i + 1;
        }
        if(graph_mode != 0) {
            graphstart();
        }
        move(y, x + i);
        addstr(FRAME[5]);
        if(graph_mode != 0) {
            graphend();
        }
        _t174 = w;
        _v48 = FRAME_WIDTH;
        i = FRAME_WIDTH * (((w >> 31) + _t174 >> 1) - 1) / _v48;
        move(y, x + i);
        addstr(135063020);
        goto L20;
    }
    if(graph_mode != 0) {
        graphstart();
    }
    move(y, x);
    addstr(FRAME[3]);
    i = FRAME_WIDTH;
    while(w - FRAME_WIDTH > i) {
        move(y, x + i);
        addstr(FRAME[0xa]);
        i = i + FRAME_WIDTH;
    }
    move(y, x + i);
    addstr(FRAME[6]);
    if(graph_mode != 0) {
        graphend();
    }
L20:
    j = 0;
    while(menu->height > j) {
        y = y + 1;
        if(graph_mode != 0) {
            graphstart();
        }
        move(y, x);
        addstr(FRAME[5]);
        if(graph_mode != 0) {
            graphend();
        }
        draw_menu_item(menu, menu->offset + j);
        if(graph_mode != 0) {
            graphstart();
        }
        move(y, x + w - FRAME_WIDTH);
        addstr(FRAME[5]);
        if(graph_mode != 0) {
            graphend();
        }
        j = j + 1;
    }
    y = y + 1;
    if(menu->offset + menu->height != menu->nitem) {
        if(graph_mode != 0) {
            graphstart();
        }
        move(y, x);
        addstr(FRAME[5]);
        if(graph_mode != 0) {
            graphend();
        }
        i = FRAME_WIDTH;
        while(w - FRAME_WIDTH > i) {
            move(y, x + i);
            addstr(135063018);
            i = i + 1;
        }
        if(graph_mode != 0) {
            graphstart();
        }
        move(y, x + i);
        addstr(FRAME[5]);
        if(graph_mode != 0) {
            graphend();
        }
        _t232 = w;
        _v48 = FRAME_WIDTH;
        i = FRAME_WIDTH * (((w >> 31) + _t232 >> 1) - 1) / _v48;
        move(y, x + i);
        addstr(135063020);
        return;
    }
    if(graph_mode != 0) {
        graphstart();
    }
    move(y, x);
    addstr(FRAME[9]);
    i = FRAME_WIDTH;
    while(w - FRAME_WIDTH > i) {
        move(y, x + i);
        addstr(FRAME[0xa]);
        i = i + FRAME_WIDTH;
    }
    move(y, x + i);
    addstr(FRAME[0xc]);
    if(graph_mode == 0) {
        return;
    }
    graphend();
    return;
}

draw_menu_item(Menu* menu, int mselect)
{// addr = 0x0809473B  --  defined in 'menu.c' at line 456
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    move(menu->y + mselect - menu->offset, menu->x);
    addnstr_sup( *(menu->item + (mselect << 5) + 4), menu->width);
    return;
}

int select_menu(Menu* menu, int mselect)
{// addr = 0x08094794  --  defined in 'menu.c' at line 463
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t58;                        // _t58

    if(mselect >= 0 || menu->nitem <= mselect) {
        return -1;
    }
    if(menu->offset <= mselect) {
        if(menu->offset + menu->height <= mselect) {
            down_menu(menu, mselect - menu->offset - menu->height + 1);
        }
    } else {
        up_menu(menu, menu->offset - mselect);
    }
    if(menu->select >= menu->offset && menu->select < menu->offset + menu->height) {
        draw_menu_item(menu, menu->select);
    }
    menu->select = mselect;
    standout();
    draw_menu_item(menu, menu->select);
    standend();
    move(menu->y + mselect - menu->offset, menu->x);
    toggle_stand();
    refresh();
    return menu->select;
}

goto_menu(Menu* menu, int mselect, int down)
{// addr = 0x080948BD  --  defined in 'menu.c' at line 489
    int select_in;                         // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t58;                        // _t58

    if(menu->nitem > mselect) {
        if(mselect < 0) {
            mselect = 0;
        }
    } else {
        mselect = menu->nitem - 1;
    }
    select_in = mselect;
    while( *((intOrPtr*)(menu->item + (mselect << 5))) == 1) {
        if(down > 0) {
            mselect = mselect + 1;
            if(mselect < menu->nitem) {
            } else {
                down_menu(menu, select_in - menu->select);
                mselect = menu->select;
                break;
            }
            continue;
        }
        if(down >= 0) {
        } else {
            mselect = mselect - 1;
            if(mselect >= 0) {
            } else {
                up_menu(menu, menu->select - select_in);
                mselect = menu->select;
                break;
            }
            continue;
        }
        goto L13;
L15:
L13:
        return;
        goto L15;
    }
    select_menu(menu, mselect);
    return;
}

up_menu(Menu* menu, int n)
{// addr = 0x08094992  --  defined in 'menu.c' at line 520
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14

    if(n >= 0) {
        return;
    }
    if(menu->offset == 0) {
    } else {
        menu->offset = menu->offset - n;
        if(menu->offset < 0) {
            menu->offset = 0;
        }
        draw_menu(menu);
        return;
    }
    goto L6;
L7:
    return;
L6:
    goto L7;
}

down_menu(Menu* menu, int n)
{// addr = 0x080949E0  --  defined in 'menu.c' at line 532
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26

    if(n >= 0) {
        return;
    }
    if(menu->offset + menu->height == menu->nitem) {
    } else {
        menu->offset = menu->offset + n;
        if(menu->offset + menu->height > menu->nitem) {
            menu->offset = menu->nitem - menu->height;
        }
        draw_menu(menu);
        return;
    }
    goto L6;
L7:
    return;
L6:
    goto L7;
}

int action_menu(Menu* menu)
{// addr = 0x08094A54  --  defined in 'menu.c' at line 544
    char c;                                // _cfa_fffffff3
    int mselect;                           // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    MenuItem item;    // _cfa_ffffffcc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t76;                        // _t76
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87
    _unknown_ _t96;                        // _t96
    _unknown_ _t113;                       // _t113
    _unknown_ _t117;                       // _t117

    if(menu->active == 0) {
        if(menu->parent != 0) {
            menu->parent->active = 0;
        }
        return;
    }
    draw_all_menu(menu);
    select_menu(menu, menu->select);
L7:
    while(1) {
        while(1) {
        }
    }
}

popup_menu(Menu* parent, Menu* menu)
{// addr = 0x08094C1B  --  defined in 'menu.c' at line 607
    int active;                            // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    active = 1;
    if(menu->item == 0) {
        return;
    }
    if(menu->nitem == 0) {
        goto L11;
    }
    if(menu->active == 0) {
        __imp__gpm_handler = gpm_process_menu_mouse;
        menu->parent = parent;
        menu->select = menu->initial;
        menu->offset = 0;
        menu->active = 1;
        if(parent != 0) {
            menu->cursorX = parent->cursorX;
            menu->cursorY = parent->cursorY;
            guess_menu_xy(parent, menu->width,  &(menu->x),  &(menu->y));
        }
        geom_menu(menu, menu->x, menu->y, menu->select);
        CurrentMenu = menu;
        while(active != 0) {
            active = action_menu(CurrentMenu);
            displayBuffer(CurrentTab->currentBuffer, 1);
        }
        menu->active = 0;
        CurrentMenu = parent;
        if(CurrentMenu != 0) {
        } else {
            goto L9;
        }
        goto L13;
L9:
        __imp__gpm_handler = gpm_process_mouse;
        return;
    }
L13:
    return;
L11:
    return;
}

guess_menu_xy(Menu* parent, int width, int* x, int* y)
{// addr = 0x08094D5C  --  defined in 'menu.c' at line 655
    _unknown_ __ebp;                       // r6

     *x = parent->x + parent->width + FRAME_WIDTH - 1;
    if( *x + width + FRAME_WIDTH > COLS) {
         *x = COLS - width - FRAME_WIDTH;
        if(parent->x + ((parent->width >> 31) + parent->width >> 1) >  *x) {
            _t64 = parent->width;
            if(parent->x + ((parent->width >> 31) + _t64 >> 1) > (COLS >> 31) + COLS >> 1) {
                 *x = parent->x - width - FRAME_WIDTH + 1;
            }
        }
    }
     *y = parent->y + parent->select - parent->offset;
    return;
}

new_option_menu(Menu* menu, char** label, int* variable, _None* func)
{// addr = 0x08094E38  --  defined in 'menu.c' at line 668
    int i;                                 // _cfa_fffffff0
    int nitem;                             // _cfa_ffffffec
    char** p;                              // _cfa_ffffffe8
    MenuItem* item;   // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t56;                        // _t56
    MenuItem* _t65;   // _t65

    if(label == 0) {
        return;
    }
    if( *label == 0) {
    } else {
        i = 0;
        p = label;
        while( *p != 0) {
            i = i + 1;
            p =  &(p[1]);
        }
        nitem = i;
        _t65 = nitem + 1 << 5;
         *__esp = _t65;
        GC_malloc();
        item = _t65;
        i = 0;
        p = label;
        while(i < nitem) {
            if(func == 0) {
                 *((intOrPtr*)(item + (i << 5))) = 2;
            } else {
                 *((intOrPtr*)(item + (i << 5))) = 6;
            }
             *(item + (i << 5) + 4) =  *p;
             *(item + (i << 5) + 8) = variable;
             *(item + (i << 5) + 12) = i;
             *(item + (i << 5) + 16) = func;
             *(item + (i << 5) + 20) = 0;
             *((intOrPtr*)(item + (i << 5) + 24)) = 135062802;
            i = i + 1;
            p =  &(p[1]);
        }
         *(item + (nitem << 5)) = 0;
        new_menu(menu, item);
        return;
    }
    goto L13;
L14:
    return;
L13:
    goto L14;
}

set_menu_frame()
{// addr = 0x08094F62  --  defined in 'menu.c' at line 700
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    if(graph_ok() != 0) {
        graph_mode = 1;
        FRAME_WIDTH = 1;
        FRAME =  &graph_symbol;
        return;
    }
    graph_mode = 0;
    FRAME_WIDTH = 0;
    FRAME = get_symbol(DisplayCharset,  &FRAME_WIDTH);
    if(( *135119023 & 0xff) != 0) {
    } else {
        FRAME_WIDTH = 1;
        return;
    }
    goto L4;
L5:
L4:
    return;
    goto L5;
}

int mEsc(char c)
{// addr = 0x08094FD6  --  defined in 'menu.c' at line 733
    signed char _v16;                      // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    _v16 = _a4 & 255;
    _v16 = do_getch() & 255;
     *__esp = _v16;
     *((intOrPtr*)( *((intOrPtr*)( &MenuEscKeymap + _v16 * 4))))();
    return;
}

int mEscB(char c)
{// addr = 0x08095000  --  defined in 'menu.c' at line 740
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29

    _v16 = _a4 & 255;
    _v16 = do_getch() & 255;
    if(( *( &MYCTYPE_MAP + (_v16 & 0xff)) & 8) == 0) {
         *__esp = _v16;
         *((intOrPtr*)( *((intOrPtr*)( &MenuEscBKeymap + _v16 * 4))))();
        return;
    }
    mEscD(_v16);
    return;
}

int mEscD(char c)
{// addr = 0x08095050  --  defined in 'menu.c' at line 750
    int d;                                 // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37

    _v32 = _a4 & 255;
    d = _v32 - 48;
    _v32 = do_getch() & 255;
    if(( *( &MYCTYPE_MAP + (_v32 & 0xff)) & 8) != 0) {
        d = (d << 2) + d + (d << 2) + d + _v32 - 48;
        _v32 = do_getch() & 255;
    }
    if(_v32 != 126) {
        return;
    }
     *__esp = _v32;
     *((intOrPtr*)( *((intOrPtr*)( &MenuEscDKeymap + d * 4))))();
    return;
}

int mNull(char c)
{// addr = 0x080950CB  --  defined in 'menu.c' at line 767
    signed int _v8;                        // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5

    _v8 = _a4 & 255;
    return -1;
}

int mSelect(char c)
{// addr = 0x080950DE  --  defined in 'menu.c' at line 773
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22

    _v16 = _a4 & 255;
    if(( *( &MYCTYPE_MAP + (_v16 & 0xff)) & 0x11) == 0) {
        return -1;
    }
    return select_menu(CurrentMenu,  *(CurrentMenu + 4 + (_v16 + 140) * 4));
}

int mDown(char c)
{// addr = 0x0809512F  --  defined in 'menu.c' at line 782
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20

    _v16 = _a4 & 255;
    if(CurrentMenu->select < CurrentMenu->nitem - 1) {
        goto_menu(CurrentMenu, CurrentMenu->select + 1, 1);
        return -1;
    }
    return -1;
}

int mUp(char c)
{// addr = 0x08095184  --  defined in 'menu.c' at line 791
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    _v16 = _a4 & 255;
    if(CurrentMenu->select > 0) {
        goto_menu(CurrentMenu, CurrentMenu->select - 1, -1);
        return -1;
    }
    return -1;
}

int mLast(char c)
{// addr = 0x080951CE  --  defined in 'menu.c' at line 800
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13

    _v16 = _a4 & 255;
    goto_menu(CurrentMenu, CurrentMenu->nitem - 1, -1);
    return -1;
}

int mTop(char c)
{// addr = 0x08095205  --  defined in 'menu.c' at line 807
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9

    _v16 = _a4 & 255;
    goto_menu(CurrentMenu, 0, 1);
    return -1;
}

int mNext(char c)
{// addr = 0x08095235  --  defined in 'menu.c' at line 814
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27

    _v32 = _a4 & 255;
    mselect = CurrentMenu->select + CurrentMenu->height;
    if(CurrentMenu->nitem > mselect) {
        down_menu(CurrentMenu, CurrentMenu->height);
        goto_menu(CurrentMenu, mselect, -1);
        return -1;
    }
    return mLast(_v32);
}

int mPrev(char c)
{// addr = 0x080952AE  --  defined in 'menu.c' at line 826
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23

    _v32 = _a4 & 255;
    mselect = CurrentMenu->select - CurrentMenu->height;
    if(mselect >= 0) {
        up_menu(CurrentMenu, CurrentMenu->height);
        goto_menu(CurrentMenu, mselect, 1);
        return -1;
    }
    return mTop(_v32);
}

int mFore(char c)
{// addr = 0x08095323  --  defined in 'menu.c' at line 838
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28

    _v16 = _a4 & 255;
    if(CurrentMenu->select < CurrentMenu->nitem - 1) {
        goto_menu(CurrentMenu, CurrentMenu->select + CurrentMenu->height - 1, CurrentMenu->height + 1);
        return -1;
    }
    return -1;
}

int mBack(char c)
{// addr = 0x0809538A  --  defined in 'menu.c' at line 848
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    _unknown_ _t23;                        // _t23

    _v16 = _a4 & 255;
    if(CurrentMenu->select > 0) {
        goto_menu(CurrentMenu, CurrentMenu->select - CurrentMenu->height + 1,  !(CurrentMenu->height));
        return -1;
    }
    return -1;
}

int mLineU(char c)
{// addr = 0x080953EF  --  defined in 'menu.c' at line 858
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37

    _v32 = _a4 & 255;
    mselect = CurrentMenu->select;
    if(CurrentMenu->nitem > mselect) {
        if(CurrentMenu->offset + CurrentMenu->height < CurrentMenu->nitem) {
            down_menu(CurrentMenu, 1);
            if(CurrentMenu->offset > mselect) {
                mselect = mselect + 1;
            }
        } else {
            mselect = mselect + 1;
        }
        goto_menu(CurrentMenu, mselect, 1);
        return -1;
    }
    return mLast(_v32);
}

int mLineD(char c)
{// addr = 0x0809548E  --  defined in 'menu.c' at line 876
    int mselect;                           // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33

    _v32 = _a4 & 255;
    mselect = CurrentMenu->select;
    if(mselect > 0) {
        if(CurrentMenu->offset > 0) {
            up_menu(CurrentMenu, 1);
            if(CurrentMenu->offset + CurrentMenu->height <= mselect) {
                mselect = mselect - 1;
            }
        } else {
            mselect = mselect - 1;
        }
        goto_menu(CurrentMenu, mselect, -1);
        return -1;
    }
    return mTop(_v32);
}

int mOk(char c)
{// addr = 0x0809551F  --  defined in 'menu.c' at line 894
    int mselect;                           // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18

    _v24 = _a4 & 255;
    mselect = CurrentMenu->select;
    if( *((intOrPtr*)(CurrentMenu->item + (mselect << 5))) != 1) {
        return mselect;
    }
    return -1;
}

int mCancel(char c)
{// addr = 0x08095559  --  defined in 'menu.c' at line 904
    signed int _v8;                        // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5

    _v8 = _a4 & 255;
    return -2;
}

int mClose(char c)
{// addr = 0x0809556C  --  defined in 'menu.c' at line 910
    signed int _v8;                        // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5

    _v8 = _a4 & 255;
    return -3;
}

int mSusp(char c)
{// addr = 0x0809557F  --  defined in 'menu.c' at line 916
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    _v16 = _a4 & 255;
    susp();
    draw_all_menu(CurrentMenu);
    select_menu(CurrentMenu, CurrentMenu->select);
    return -1;
}

int menuForwardSearch(Menu* menu, char* str, int from)
{// addr = 0x080955BD  --  defined in 'menu.c' at line 929
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43
    _unknown_ _t45;                        // _t45

    p = regexCompile(str, IgnoreCase);
    if(p == 0) {
        if(from < 0) {
            from = 0;
        }
        i = from;
        while(menu->nitem > i) {
            if( *((intOrPtr*)(menu->item + (i << 5))) == 1 || regexMatch( *(menu->item + (i << 5) + 4), -1, 1) != 1) {
                i = i + 1;
                continue;
            }
            return i;
        }
        return -1;
    }
    message(p, 0, 0);
    return -1;
}

int menu_search_forward(Menu* menu, int from)
{// addr = 0x08095675  --  defined in 'menu.c' at line 947
    char* str;                             // _cfa_fffffff0
    int found;                             // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t36;                        // _t36
    _unknown_ _t49;                        // _t49

    str = inputLineHistSearch("Forward: ", 0, 16, TextHist, 0);
    if(str != 0) {
        if(( *str & 0xff) == 0) {
            str = SearchString;
        }
    }
    if(str == 0 || ( *str & 0xff) == 0) {
        return -1;
    }
    SearchString = str;
    str = conv_search_string(str, DisplayCharset);
    menuSearchRoutine = menuForwardSearch;
    found = menuForwardSearch(menu, str, from + 1);
    if(WrapSearch != 0 && found == 255) {
        found = menuForwardSearch(menu, str, 0);
    }
    if(found >= 0) {
        disp_message("Not found", 1);
        return -1;
    }
    return found;
}

int mSrchF(char c)
{// addr = 0x08095777  --  defined in 'menu.c' at line 969
    int mselect;                           // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16

    _v32 = _a4 & 255;
    mselect = menu_search_forward(CurrentMenu, CurrentMenu->select);
    if(mselect < 0) {
        goto_menu(CurrentMenu, mselect, 1);
    }
    return -1;
}

int menuBackwardSearch(Menu* menu, char* str, int from)
{// addr = 0x080957C8  --  defined in 'menu.c' at line 979
    int i;                                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39
    _unknown_ _t50;                        // _t50

    p = regexCompile(str, IgnoreCase);
    if(p == 0) {
        if(menu->nitem <= from) {
            from = menu->nitem - 1;
        }
        i = from;
        while(i >= 0) {
            if( *((intOrPtr*)(menu->item + (i << 5))) == 1 || regexMatch( *(menu->item + (i << 5) + 4), -1, 1) != 1) {
                i = i - 1;
                continue;
            }
            return i;
        }
        return -1;
    }
    message(p, 0, 0);
    return -1;
}

int menu_search_backward(Menu* menu, int from)
{// addr = 0x08095885  --  defined in 'menu.c' at line 997
    char* str;                             // _cfa_fffffff0
    int found;                             // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t38;                        // _t38
    _unknown_ _t51;                        // _t51

    str = inputLineHistSearch("Backward: ", 0, 16, TextHist, 0);
    if(str != 0) {
        if(( *str & 0xff) == 0) {
            str = SearchString;
        }
    }
    if(str == 0 || ( *str & 0xff) == 0) {
        return -1;
    }
    SearchString = str;
    str = conv_search_string(str, DisplayCharset);
    menuSearchRoutine = menuBackwardSearch;
    found = menuBackwardSearch(menu, str, from - 1);
    if(WrapSearch != 0 && found == 255) {
        found = menuBackwardSearch(menu, str, menu->nitem);
    }
    if(found >= 0) {
        disp_message("Not found", 1);
        return -1;
    }
    return found;
}

int mSrchB(char c)
{// addr = 0x08095989  --  defined in 'menu.c' at line 1019
    int mselect;                           // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16

    _v32 = _a4 & 255;
    mselect = menu_search_backward(CurrentMenu, CurrentMenu->select);
    if(mselect < 0) {
        goto_menu(CurrentMenu, mselect, -1);
    }
    return -1;
}

int menu_search_next_previous(Menu* menu, int from, int reverse)
{// addr = 0x080959DA  --  defined in 'menu.c' at line 1029
    int found;                             // _cfa_fffffff0
    char* str;                             // _cfa_ffffffec
    int _v36;                              // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t39;                              // _t39
    int _t43;                              // _t43
    _unknown_ _t45;                        // _t45
    _unknown_ _t46;                        // _t46
    int _t52;                              // _t52
    _unknown_ _t53;                        // _t53

    if(menuSearchRoutine != 0) {
        str = conv_search_string(SearchString, DisplayCharset);
        if(reverse != 0) {
            reverse = 1;
        }
        if(menuSearchRoutine == menuBackwardSearch) {
            reverse = reverse ^ 1;
        }
        if(reverse == 0) {
            _t39 = 1;
        } else {
            _t39 = -1;
        }
        from = from + _t39;
        _v36 = from;
        _v40 = str;
        _t43 = menu;
         *__esp = _t43;
         *((intOrPtr*)( *((intOrPtr*)(reverse * 4 +  &routine.8886))))();
        found = _t43;
        if(WrapSearch != 0 && found == 255) {
            _v36 = menu->nitem * reverse;
            _v40 = str;
            _t52 = menu;
             *__esp = _t52;
             *((intOrPtr*)( *((intOrPtr*)(reverse * 4 +  &routine.8886))))();
            found = _t52;
        }
        if(found >= 0) {
            disp_message("Not found", 1);
            return;
        }
        return;
    }
    disp_message("No previous regular expression", 1);
    return;
}

int mSrchN(char c)
{// addr = 0x08095AD5  --  defined in 'menu.c' at line 1056
    int mselect;                           // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    _v32 = _a4 & 255;
    mselect = menu_search_next_previous(CurrentMenu, CurrentMenu->select, 0);
    if(mselect < 0) {
        goto_menu(CurrentMenu, mselect, 1);
    }
    return -1;
}

int mSrchP(char c)
{// addr = 0x08095B2E  --  defined in 'menu.c' at line 1066
    int mselect;                           // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    _v32 = _a4 & 255;
    mselect = menu_search_next_previous(CurrentMenu, CurrentMenu->select, 1);
    if(mselect < 0) {
        goto_menu(CurrentMenu, mselect, -1);
    }
    return -1;
}

int mMouse_scroll_line()
{// addr = 0x08095B87  --  defined in 'menu.c' at line 1087
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t20;                        // _t20
    _unknown_ _t28;                        // _t28

    i = 0;
    if(relative_wheel_scroll == 0) {
        i = fixed_wheel_scroll_count;
    } else {
        i = ((relative_wheel_scroll_ratio * CurrentMenu->height + 99) * 1374389535 >> 32 >> 5) - (relative_wheel_scroll_ratio * CurrentMenu->height + 99 >> 31);
    }
    if(i == 0) {
        return 1;
    }
    return i;
}

int process_mMouse(int btn, int x, int y)
{// addr = 0x08095BE6  --  defined in 'menu.c' at line 1098
    char c;                                // _cfa_fffffff3
    Menu* menu;           // _cfa_ffffffec
    int mselect;                           // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t109;                       // _t109
    _unknown_ _t116;                       // _t116
    _unknown_ _t120;                       // _t120
    _unknown_ _t123;                       // _t123
    int _t124;                             // _t124
    _unknown_ _t128;                       // _t128
    _unknown_ _t170;                       // _t170
    _unknown_ _t172;                       // _t172
    _unknown_ _t173;                       // _t173
    _unknown_ _t175;                       // _t175
    _unknown_ _t176;                       // _t176
    _unknown_ _t180;                       // _t180
    _unknown_ _t181;                       // _t181
    _unknown_ _t185;                       // _t185
    _unknown_ _t186;                       // _t186
    _unknown_ _t192;                       // _t192
    _unknown_ _t197;                       // _t197
    _unknown_ _t200;                       // _t200

    c = 32;
    menu = CurrentMenu;
    if(x >= 0 || x >= COLS || y >= 0 || LINES - 1 < y) {
        return -1;
    }
    if(btn != 3) {
        if(btn != 64) {
            if(btn != 65) {
                goto L57;
            }
            goto L54;
        }
        goto L49;
L54:
        i = 0;
        while(mMouse_scroll_line() > i) {
            mLineU(c);
            i = i + 1;
        }
    } else {
        _t124 = press_btn.8969;
        if(_t124 == 2) {
L13:
            if(menu->x - FRAME_WIDTH > x || menu->x + menu->width + FRAME_WIDTH <= x || menu->y - 1 > y || menu->y + menu->height + 1 <= y) {
                return -2;
            }
            if(menu->x - FRAME_WIDTH > x || menu->x <= x) {
                if(menu->x + menu->width > x || menu->x + menu->width + FRAME_WIDTH <= x) {
                    if(press_y.8971 <= y) {
                        if(press_y.8971 >= y) {
                            if(menu->y - 1 != y) {
                                if(menu->y + menu->height != y) {
                                    mselect = y - menu->y + menu->offset;
                                    if( *((intOrPtr*)(menu->item + (mselect << 5))) != 1) {
                                        return select_menu(menu, mselect);
                                    }
                                    goto L38;
                                }
                                goto L36;
L38:
                                return -1;
                            }
                            goto L34;
L36:
                            mNext(c);
                            return -1;
                        }
                        goto L29;
L34:
                        mPrev(c);
                        return -1;
                    } else {
                        i = 0;
                        while(1) {
                        }
                    }
L29:
                    i = 0;
                    while(y - press_y.8971 > i) {
                        mLineD(c);
                        i = i + 1;
                    }
                    return -1;
                }
            }
            return -1;
        }
        if(_t124 > 2) {
            if(_t124 == 3) {
                i = 0;
L42:
                while(mMouse_scroll_line() > i) {
                    goto L41;
                }
                goto L57;
            }
            goto L11;
L41:
            mLineD(c);
            i = i + 1;
            goto L42;
        }
        if(_t124 == 0) {
            goto L13;
        } else {
        }
L57:
        if(btn != 3 || press_btn.8969 == 255) {
            press_btn.8969 = btn;
            press_x.8970 = x;
            press_y.8971 = y;
        } else {
            press_btn.8969 = -1;
        }
        return -1;
L11:
        if(_t124 == 4) {
            i = 0;
            while(mMouse_scroll_line() > i) {
                mLineU(c);
                i = i + 1;
            }
        } else {
        }
    }
L49:
    i = 0;
    while(mMouse_scroll_line() > i) {
        mLineD(c);
        i = i + 1;
    }
    goto L57;
}

int mMouse(char c)
{// addr = 0x08095F06  --  defined in 'menu.c' at line 1181
    int btn;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    _v32 = _a4 & 255;
    btn = (do_getch() & 0xff) - 32;
    x = (do_getch() & 0xff) - 33;
    if(x < 0) {
        x = x + 256;
    }
    y = (do_getch() & 0xff) - 33;
    if(y < 0) {
        y = y + 256;
    }
    return process_mMouse(btn, x, y);
}

int gpm_process_menu_mouse(Gpm_Event* event, _Unknown_base* data)
{// addr = 0x08095F71  --  defined in 'menu.c' at line 1208
    int btn;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    int* _v36;                             // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int* _t49;                      // _t49
    signed int* _t53;                      // _t53
    _unknown_ _t58;                        // _t58
    signed int _t61;                       // _t61
    _unknown_ _t71;                        // _t71

    btn = -1;
    if((event->type & 8) == 0) {
        if((event->type & 4) == 0) {
             *135774721 = 2;
            _t49 =  &(__imp___gpm_arg[1]);
             *_t49 = (event->x & 65535) + __imp__gpm_zerobased & 65535;
             *__imp___gpm_arg =  *_t49 & 0xffff;
            _t53 =  &(__imp___gpm_arg[1]);
             *_t53 = (event->y & 65535) + __imp__gpm_zerobased & 65535;
            __imp___gpm_arg[0] =  *_t53 & 0xffff;
            __imp___gpm_arg[2] = 3;
            _v36 = 135774721;
            _v40 = 21532;
             *__esp = __imp__gpm_consolefd;
            ioctl();
            return 0;
        } else {
            _t61 = event->buttons & 0xff;
            if(_t61 == 2) {
                btn = 1;
            } else {
                if(_t61 == 4) {
                    btn = 0;
                } else {
                    if(_t61 == 1) {
                        btn = 2;
                    }
                }
            }
        }
    } else {
        btn = 3;
    }
    asm("cwde ");
    x = event->x & 65535;
    asm("cwde ");
    y = event->y & 65535;
    X_Mouse_Selection = process_mMouse(btn, x - 1, y - 1);
    return -1;
}

popupMenu(int x, int y, Menu* menu)
{// addr = 0x080960B8  --  defined in 'menu.c' at line 1271
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    set_menu_frame();
    initSelectMenu();
    initSelTabMenu();
    asm("cwde ");
    menu->cursorX = (CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    menu->cursorY = (CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535);
    menu->x = FRAME_WIDTH + x + 1;
    menu->y = y + 2;
    popup_menu(0, menu);
    return;
}

mainMenu(int x, int y)
{// addr = 0x08096147  --  defined in 'menu.c' at line 1287
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    popupMenu(x, y,  &MainMenu);
    return;
}

mainMn()
{// addr = 0x08096169  --  defined in 'menu.c' at line 1292
    Menu* menu;           // _cfa_fffffff0
    char* data;                            // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    int y;                                 // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    menu =  &MainMenu;
    asm("cwde ");
    x = (CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    y = (CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535);
    data = searchKeyData();
    if(data == 0) {
L3:
        if( *135792272 != 0) {
            x =  *135792276;
            y =  *135792280;
        }
        popupMenu(x, y, menu);
        return;
    }
    n = getMenuN(w3mMenuList, data);
    if(n < 0) {
        goto L2;
    }
    return;
L2:
    menu =  *(w3mMenuList + (n + n + _t67 << 2) + 4);
    goto L3;
}

selMn()
{// addr = 0x08096237  --  defined in 'menu.c' at line 1320
    int x;                                 // _cfa_fffffff0
    int y;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    x = (CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    y = (CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535);
    if( *135792272 != 0) {
        x =  *135792276;
        y =  *135792280;
    }
    popupMenu(x, y,  &SelectMenu);
    return;
}

initSelectMenu()
{// addr = 0x080962B6  --  defined in 'menu.c' at line 1335
    int i;                                 // _cfa_fffffff0
    int nitem;                             // _cfa_ffffffec
    int len;                               // _cfa_ffffffe8
    int l;                                 // _cfa_ffffffe4
    Buffer* buf;        // _cfa_ffffffe0
    Str str;               // _cfa_ffffffdc
    char** label;                          // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    char** _t189;                          // _t189
    struct _ParsedURL _t208;   // _t208
    int _t218;                             // _t218
    int _t237;                             // _t237
    _unknown_ _t257;                       // _t257
    int _t262;                             // _t262
    int _t271;                             // _t271
    int _t287;                             // _t287
    _unknown_ _t324;                       // _t324

    len = 0;
    SelectV = -1;
    i = 0;
    buf = CurrentTab->firstBuffer;
    while(buf != 0) {
    }
    nitem = i;
    _t189 = nitem + 2 << 2;
     *__esp = _t189;
    GC_malloc();
    label = _t189;
    i = 0;
    buf = CurrentTab->firstBuffer;
    while(i < nitem) {
        _v56 = buf->buffername;
        str = Sprintf("<%s>");
        if(buf->filename != 0) {
            _t208 =  *(buf + 132);
            if(_t208 == 4) {
                if(strcmp( *(buf + 152), "-") != 0) {
                    if(str->length + 1 >= str->area_size) {
                        Strgrow(str);
                    }
                    _t218 = str->length;
                     *((char*)(str->ptr + _t218)) = 32;
                    str->length = _t218 + 1;
                     *(str->ptr + str->length) = 0;
                    Strcat_charp(str,  *(wc_Str_conv(Strnew_charp( *(buf + 156)), SystemCharset, InnerCharset)));
                }
            } else {
                if(_t208 != 254) {
                    if(str->length + 1 >= str->area_size) {
                        Strgrow(str);
                    }
                    _t237 = str->length;
                     *((char*)(str->ptr + _t237)) = 32;
                    str->length = _t237 + 1;
                     *(str->ptr + str->length) = 0;
                    p =  *(parsedURL2Str(buf + 132));
                    if(DecodeURL != 0) {
                        p = url_unquote_conv(p, 0);
                    }
                    Strcat_charp(str, p);
                }
            }
        }
        label[i] = str->ptr;
        if(str->length > len) {
            len = str->length;
        }
        i = i + 1;
        buf = buf->nextBuffer;
    }
    l = wtf_strwidth(comment.9275);
    if(l + 4 > len) {
        len = l + 4;
    }
    if(0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS < len) {
        len = 0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS;
    }
    if(len <= 1) {
        _t262 = 0;
    } else {
        _t262 = (len - l + 1 >> 31) + len - l + 1 >> 1;
    }
    len = _t262;
    str = Strnew();
    i = 0;
    while(i < len) {
        if(str->length + 1 >= str->area_size) {
            Strgrow(str);
        }
        _t271 = str->length;
         *((char*)(str->ptr + _t271)) = 45;
        str->length = _t271 + 1;
         *(str->ptr + str->length) = 0;
        i = i + 1;
    }
    Strcat_charp(str, comment.9275);
    i = 0;
    while(i < len) {
        if(str->length + 1 >= str->area_size) {
            Strgrow(str);
        }
        _t287 = str->length;
         *((char*)(str->ptr + _t287)) = 45;
        str->length = _t287 + 1;
         *(str->ptr + str->length) = 0;
        i = i + 1;
    }
    label[nitem] = str->ptr;
    label[nitem + 1] = 0;
    new_option_menu( &SelectMenu, label,  &SelectV, smChBuf);
     *135779364 = SelectV;
    asm("cwde ");
     *135779332 = (CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
     *135779336 = (CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535);
     *135779652 = smDelBuf;
     *((intOrPtr*)( *135779360 + (nitem << 5))) = 1;
    return;
}

smChBuf()
{// addr = 0x08096722  --  defined in 'menu.c' at line 1403
    int i;                                 // _cfa_fffffff0
    Buffer* buf;        // _cfa_ffffffec
    _unknown_ __ebp;                       // r6

    if(SelectV >= 0) {
        return;
    }
    if( *135779356 > SelectV) {
        i = 0;
        buf = CurrentTab->firstBuffer;
        while(i < SelectV) {
            i = i + 1;
            buf = buf->nextBuffer;
        }
        CurrentTab->currentBuffer = buf;
        buf = CurrentTab->firstBuffer;
        while(buf != 0) {
            if(CurrentTab->currentBuffer != buf) {
                deleteImage(buf);
                if(clear_buffer != 0) {
                    tmpClearBuffer(buf);
                }
            }
            buf = buf->nextBuffer;
        }
        return;
    }
    return;
}

int smDelBuf(char c)
{// addr = 0x080967D1  --  defined in 'menu.c' at line 1424
    int i;                                 // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    int mselect;                           // _cfa_ffffffe4
    Buffer* buf;        // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t63;                        // _t63
    int _t92;                              // _t92
    _unknown_ _t99;                        // _t99
    _unknown_ _t100;                       // _t100
    _unknown_ _t117;                       // _t117

    _v48 = _a4 & 255;
    if(CurrentMenu->select >= 0 || CurrentMenu->select >=  *135779356) {
        return -1;
    }
    i = 0;
    buf = CurrentTab->firstBuffer;
    while(CurrentMenu->select > i) {
        i = i + 1;
        buf = buf->nextBuffer;
    }
    if(CurrentTab->currentBuffer == buf) {
        CurrentTab->currentBuffer = buf->nextBuffer;
    }
    CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
    if(CurrentTab->currentBuffer == 0) {
        CurrentTab->currentBuffer = nthBuffer(CurrentTab->firstBuffer, i - 1);
    }
    if(CurrentTab->firstBuffer == 0) {
        CurrentTab->firstBuffer = nullBuffer();
        CurrentTab->currentBuffer = CurrentTab->firstBuffer;
    }
    x = CurrentMenu->x;
    y = CurrentMenu->y;
    mselect = CurrentMenu->select;
    initSelectMenu();
    CurrentMenu->x = x;
    CurrentMenu->y = y;
    geom_menu(CurrentMenu, x, y, 0);
    _t117 = CurrentMenu->nitem - 2;
    _t92 = mselect;
    _t93 = _t117 - _t92 <= 0 ? _t117 : _t92;
    CurrentMenu->select = _t117 - _t92 <= 0 ? _t117 : _t92;
    displayBuffer(CurrentTab->currentBuffer, 1);
    draw_all_menu(CurrentMenu);
    select_menu(CurrentMenu, CurrentMenu->select);
    return -1;
}

tabMn()
{// addr = 0x0809698C  --  defined in 'menu.c' at line 1467
    int x;                                 // _cfa_fffffff0
    int y;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    x = (CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    y = (CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535);
    if( *135792272 != 0) {
        x =  *135792276;
        y =  *135792280;
    }
    popupMenu(x, y,  &SelTabMenu);
    return;
}

initSelTabMenu()
{// addr = 0x08096A0B  --  defined in 'menu.c' at line 1482
    int i;                                 // _cfa_fffffff0
    int nitem;                             // _cfa_ffffffec
    int len;                               // _cfa_ffffffe8
    int l;                                 // _cfa_ffffffe4
    TabBuffer* tab;   // _cfa_ffffffe0
    Buffer* buf;        // _cfa_ffffffdc
    Str str;               // _cfa_ffffffd8
    char** label;                          // _cfa_ffffffd4
    char* p;                               // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    char** _t170;                          // _t170
    struct _ParsedURL _t190;   // _t190
    int _t200;                             // _t200
    _unknown_ _t226;                       // _t226
    int _t231;                             // _t231
    int _t240;                             // _t240
    int _t256;                             // _t256
    _unknown_ _t293;                       // _t293

    len = 0;
    SelTabV = -1;
    i = 0;
    tab = LastTab;
    while(tab != 0) {
    }
    nitem = i;
    _t170 = nitem + 2 << 2;
     *__esp = _t170;
    GC_malloc();
    label = _t170;
    i = 0;
    tab = LastTab;
    while(i < nitem) {
        buf = tab->currentBuffer;
        _v72 = buf->buffername;
        str = Sprintf("<%s>");
        if(buf->filename != 0) {
            _t190 =  *(buf + 132);
            if(_t190 == 4) {
                if(strcmp( *(buf + 152), "-") != 0) {
                    if(str->length + 1 >= str->area_size) {
                        Strgrow(str);
                    }
                    _t200 = str->length;
                     *((char*)(str->ptr + _t200)) = 32;
                    str->length = _t200 + 1;
                     *(str->ptr + str->length) = 0;
                    Strcat_charp(str,  *(wc_Str_conv(Strnew_charp( *(buf + 156)), SystemCharset, InnerCharset)));
                }
            } else {
                if(_t190 != 254) {
                    p =  *(parsedURL2Str(buf + 132));
                    if(DecodeURL != 0) {
                        p = url_unquote_conv(p, 0);
                    }
                    Strcat_charp(str, p);
                }
            }
        }
        label[i] = str->ptr;
        if(str->length > len) {
            len = str->length;
        }
        i = i + 1;
        tab = tab->prevTab;
    }
    l = strlen(comment.9583);
    if(l + 4 > len) {
        len = l + 4;
    }
    if(0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS < len) {
        len = 0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS;
    }
    if(len <= 1) {
        _t231 = 0;
    } else {
        _t231 = (len - l + 1 >> 31) + len - l + 1 >> 1;
    }
    len = _t231;
    str = Strnew();
    i = 0;
    while(i < len) {
        if(str->length + 1 >= str->area_size) {
            Strgrow(str);
        }
        _t240 = str->length;
         *((char*)(str->ptr + _t240)) = 45;
        str->length = _t240 + 1;
         *(str->ptr + str->length) = 0;
        i = i + 1;
    }
    Strcat_charp(str, comment.9583);
    i = 0;
    while(i < len) {
        if(str->length + 1 >= str->area_size) {
            Strgrow(str);
        }
        _t256 = str->length;
         *((char*)(str->ptr + _t256)) = 45;
        str->length = _t256 + 1;
         *(str->ptr + str->length) = 0;
        i = i + 1;
    }
    label[nitem] = str->ptr;
    label[nitem + 1] = 0;
    new_option_menu( &SelTabMenu, label,  &SelTabV, smChTab);
     *135780452 = SelTabV;
    asm("cwde ");
     *135780420 = (CurrentTab->currentBuffer->cursorX & 0xffff) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
     *135780424 = (CurrentTab->currentBuffer->cursorY & 0xffff) + (CurrentTab->currentBuffer->rootY & 65535);
     *135780740 = smDelTab;
     *((intOrPtr*)( *135780448 + (nitem << 5))) = 1;
    return;
}

smChTab()
{// addr = 0x08096E29  --  defined in 'menu.c' at line 1551
    int i;                                 // _cfa_fffffff0
    TabBuffer* tab;   // _cfa_ffffffec
    Buffer* buf;        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(SelTabV >= 0) {
        return;
    }
    if( *135780444 <= SelTabV) {
        goto L15;
    }
    i = 0;
    tab = LastTab;
    while(i < SelTabV && tab != 0) {
        i = i + 1;
        tab = tab->prevTab;
    }
    CurrentTab = tab;
    tab = LastTab;
    while(tab != 0) {
        if(tab != CurrentTab) {
            buf = tab->currentBuffer;
            deleteImage(buf);
            if(clear_buffer != 0) {
                tmpClearBuffer(buf);
            }
        }
        tab = tab->prevTab;
    }
    return;
L15:
    return;
}

int smDelTab(char c)
{// addr = 0x08096EDB  --  defined in 'menu.c' at line 1575
    int i;                                 // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int y;                                 // _cfa_ffffffe8
    int mselect;                           // _cfa_ffffffe4
    TabBuffer* tab;   // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    _unknown_ _t52;                        // _t52
    int _t64;                              // _t64
    _unknown_ _t71;                        // _t71
    _unknown_ _t72;                        // _t72
    _unknown_ _t80;                        // _t80

    _v48 = _a4 & 255;
    if(CurrentMenu->select >= 0 || CurrentMenu->select >=  *135780444) {
        return -1;
    }
    i = 0;
    tab = LastTab;
    while(CurrentMenu->select > i && tab != 0) {
        i = i + 1;
        tab = tab->prevTab;
    }
    deleteTab(tab);
    x = CurrentMenu->x;
    y = CurrentMenu->y;
    mselect = CurrentMenu->select;
    initSelTabMenu();
    CurrentMenu->x = x;
    CurrentMenu->y = y;
    geom_menu(CurrentMenu, x, y, 0);
    _t80 = CurrentMenu->nitem - 2;
    _t64 = mselect;
    _t65 = _t80 - _t64 <= 0 ? _t80 : _t64;
    CurrentMenu->select = _t80 - _t64 <= 0 ? _t80 : _t64;
    displayBuffer(CurrentTab->currentBuffer, 1);
    draw_all_menu(CurrentMenu);
    select_menu(CurrentMenu, CurrentMenu->select);
    return -1;
}

optionMenu(int x, int y, char** label, int* variable, int initial, _None* func)
{// addr = 0x0809700A  --  defined in 'menu.c' at line 1611
    int _v1052;                            // _cfa_fffffbe4
    int _v1072;                            // _cfa_fffffbd0
    int _v1076;                            // _cfa_fffffbcc
    intOrPtr _v1080;                       // _cfa_fffffbc8
    intOrPtr _v1084;                       // _cfa_fffffbc4
    Menu menu;            // _cfa_fffffbc0
    _unknown_ _v1104;                      // _cfa_fffffbb0
    _unknown_ _v1108;                      // _cfa_fffffbac
    _unknown_ _v1112;                      // _cfa_fffffba8
    _unknown_ __ebp;                       // r6

    set_menu_frame();
    new_option_menu( &(menu.parent), label, variable, func);
    _v1084 = COLS - 1;
    _v1080 = LINES - 1;
    _v1076 = x;
    _v1072 = y;
    _v1052 = initial;
    popup_menu(0,  &(menu.parent));
    return;
}

interpret_menu(FILE* mf)
{// addr = 0x0809708A  --  defined in 'menu.c' at line 1633
    Str line;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    int in_menu;                           // _cfa_ffffffe4
    int nmenu;                             // _cfa_ffffffe0
    int nitem;                             // _cfa_ffffffdc
    int type;                              // _cfa_ffffffd8
    MenuItem* item;   // _cfa_ffffffd4
    wc_ces charset;     // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t146;                       // _t146

    in_menu = 0;
    nmenu = 0;
    nitem = 0;
    item = 0;
    charset = SystemCharset;
    while(feof(mf) == 0) {
    }
    return;
}

initMenu()
{// addr = 0x08097311  --  defined in 'menu.c' at line 1694
    FILE* mf;             // _cfa_fffffff0
    MenuList* list;   // _cfa_ffffffec
    MenuItem* item;   // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t71;                        // _t71
    _unknown_ _t74;                        // _t74

     *__esp = 36;
    GC_malloc();
    w3mMenuList = __eax;
    w3mMenuList->id = "Main";
    w3mMenuList->menu =  &MainMenu;
    w3mMenuList->item =  &MainMenuItem;
     *(w3mMenuList + 12) = "Select";
     *(w3mMenuList + 0x10) =  &SelectMenu;
     *((intOrPtr*)(w3mMenuList + 0x14)) = 0;
     *(w3mMenuList + 24) = "SelectTab";
     *(w3mMenuList + 0x1c) =  &SelTabMenu;
     *((intOrPtr*)(w3mMenuList + 0x20)) = 0;
     *((intOrPtr*)(w3mMenuList + 36)) = 0;
    if(MainMenuEncode == 0) {
        MainMenuCharset = SystemCharset;
        item =  &MainMenuItem;
        while(item->type != 0) {
            item->label =  *(wc_Str_conv(Strnew_charp(gettext(item->label)), MainMenuCharset, InnerCharset));
            item = item + 32;
        }
        MainMenuEncode = 1;
    }
    mf = fopen(confFile("menu"), "rt");
    if(mf != 0) {
        interpret_menu(mf);
        fclose(mf);
    }
    mf = fopen(rcFile("menu"), "rt");
    if(mf != 0) {
        interpret_menu(mf);
        fclose(mf);
    }
    list = w3mMenuList;
L14:
    while(list->id != 0) {
        if(list->item != 0) {
            new_menu(list->menu, list->item);
        }
        list = list + 12;
    }
    return;
    goto L14;
}

int setMenuItem(MenuItem* item, char* type, char* line)
{// addr = 0x080974DB  --  defined in 'menu.c' at line 1742
    char* label;                           // _cfa_fffffff0
    char* func;                            // _cfa_ffffffec
    char* popup;                           // _cfa_ffffffe8
    char* keys;                            // _cfa_ffffffe4
    char* data;                            // _cfa_ffffffe0
    int f;                                 // _cfa_ffffffdc
    int n;                                 // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t76;                        // _t76
    _unknown_ _t87;                        // _t87
    _unknown_ _t107;                       // _t107
    _unknown_ _t110;                       // _t110
    _unknown_ _t125;                       // _t125
    _unknown_ _t130;                       // _t130
    _unknown_ _t131;                       // _t131
    _unknown_ _t135;                       // _t135
    _unknown_ _t137;                       // _t137

    if(type == 0 || ( *type & 0xff) == 0) {
        return -1;
    }
    if(strcmp(type, "end") != 0) {
        if(strcmp(type, "nop") != 0) {
            if(strcmp(type, "func") != 0) {
                if(strcmp(type, "popup") != 0) {
                    return -1;
                }
                goto L12;
                return __eax;
            }
            goto L8;
L12:
            label = getQWord( &line);
            popup = getQWord( &line);
            keys = getQWord( &line);
            if(( *popup & 0xff) != 0) {
                item->type = 8;
                item->label = label;
                n = getMenuN(w3mMenuList, popup);
                if(n == 255) {
                    n = addMenuList( &w3mMenuList, popup);
                }
                item->popup =  *(w3mMenuList + (n + n + _t140 << 2) + 4);
                item->keys = keys;
                return 8;
            }
            return -1;
        }
        goto L6;
L8:
        label = getQWord( &line);
        func = getWord( &line);
        keys = getQWord( &line);
        data = getQWord( &line);
        if(( *func & 0xff) != 0) {
            item->type = 4;
            item->label = label;
            f = getFuncList(func);
            _t126 = f >= 0 ? f : 0;
            item->func =  *(135103140 + (f >= 0 ? f : 0) * 8);
            item->keys = keys;
            item->data = data;
            return 4;
        }
        return -1;
    }
    item->type = 0;
    return 0;
L6:
    item->type = 1;
    item->label = getQWord( &line);
    return 1;
}

int addMenuList(MenuList** mlist, char* id)
{// addr = 0x080976ED  --  defined in 'menu.c' at line 1792
    int n;                                 // _cfa_fffffff0
    MenuList* list;   // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    MenuList* _t35;   // _t35
    char* _t43;                            // _t43
    MenuItem* _t44;   // _t44

    list =  *mlist;
    n = 0;
    while(list->id != 0) {
        list = list + 12;
        n = n + 1;
    }
    _t49 = n;
    _t35 =  *mlist;
    _v40 = (n + _t49 + _t49 << 2) + 24;
     *__esp = _t35;
    GC_realloc();
     *mlist = _t35;
    list =  *mlist + (n + n + _t52 << 2);
    _t43 = list;
     *_t43 = id;
     *__esp = 1076;
    GC_malloc();
    _t44 = list;
    _t44->label = _t43;
     *__esp = 32;
    GC_malloc();
    list->item = _t44;
     *(list + 12) = 0;
    return n;
}

int getMenuN(MenuList* list, char* id)
{// addr = 0x08097796  --  defined in 'menu.c' at line 1808
    int n;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18

    n = 0;
    while(list->id != 0) {
        if(strcmp(id, list->id) != 0) {
            list = list + 12;
            n = n + 1;
            continue;
        }
        return n;
    }
    return -1;
}

LinkList* link_menu(Buffer* buf)
{// addr = 0x080977DA  --  defined in 'menu.c' at line 1822
    LinkList* l;      // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int nitem;                             // _cfa_ffffffe8
    int len;                               // _cfa_ffffffe4
    int linkV;                             // _cfa_ffffffe0
    char** label;                          // _cfa_ffffffdc
    Str str;               // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    LinkList* _v1084;   // _cfa_fffffbc4
    intOrPtr _v1104;                       // _cfa_fffffbb0
    intOrPtr _v1108;                       // _cfa_fffffbac
    intOrPtr _v1112;                       // _cfa_fffffba8
    intOrPtr _v1116;                       // _cfa_fffffba4
    Menu menu;            // _cfa_fffffba0
    _unknown_ _v1136;                      // _cfa_fffffb90
    _unknown_ _v1140;                      // _cfa_fffffb8c
    _unknown_ _v1144;                      // _cfa_fffffb88
    _unknown_ __ebp;                       // r6
    char** _t124;                          // _t124
    char* _t129;                           // _t129
    _unknown_ _t178;                       // _t178
    _unknown_ _t180;                       // _t180
    _unknown_ _t190;                       // _t190

    len = 0;
    linkV = -1;
    if(buf->linklist == 0) {
        return 0;
    }
    i = 0;
    l = buf->linklist;
    while(l != 0) {
        i = i + 1;
        l = l->next;
    }
    nitem = i;
    _t124 = nitem + 1 << 2;
     *__esp = _t124;
    GC_malloc();
    label = _t124;
    i = 0;
    l = buf->linklist;
    while(l != 0) {
        if(l->title == 0) {
            _t129 = "(empty)";
        } else {
            _t129 = l->title;
        }
        str = Strnew_charp(_t129);
        if((l->type & 0xff) != 1) {
            if((l->type & 0xff) != 2) {
                Strcat_charp(str, 135063018);
            } else {
                Strcat_charp(str, " [Rev] ");
            }
        } else {
            Strcat_charp(str, " [Rel] ");
        }
        if(l->url != 0) {
            if(DecodeURL == 0) {
                p = l->url;
            } else {
                p = url_unquote_conv(l->url,  *(buf + 208));
            }
        } else {
            p = 135062802;
        }
        Strcat_charp(str, p);
        label[i] = str->ptr;
        if(str->length > len) {
            len = str->length;
        }
        i = i + 1;
        l = l->next;
    }
    label[nitem] = 0;
    set_menu_frame();
    new_option_menu( &(menu.parent), label,  &linkV, 0);
    _v1084 = 0;
    asm("cwde ");
    _v1116 = (buf->cursorX & 0xffff) + (buf->rootX & 65535);
    asm("cwde ");
    _v1112 = (buf->cursorY & 0xffff) + (buf->rootY & 65535);
    _v1108 = _v1116 + FRAME_WIDTH + 1;
    _v1104 = _v1112 + 2;
    popup_menu(0,  &(menu.parent));
    if(linkV >= 0) {
        i = 0;
        l = buf->linklist;
L29:
        while(l != 0) {
            goto L26;
        }
        return 0;
    }
    return 0;
L26:
    if(i != linkV) {
        i = i + 1;
        l = l->next;
        goto L29;
    }
    return l;
}

Anchor* accesskey_menu(Buffer* buf)
{// addr = 0x08097A58  --  defined in 'menu.c' at line 1882
    unsigned char c;                       // _cfa_fffffff3
    AnchorList* al;   // _cfa_ffffffec
    Anchor* a;          // _cfa_ffffffe8
    Anchor** ap;        // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int n;                                 // _cfa_ffffffdc
    int nitem;                             // _cfa_ffffffd8
    int key;                               // _cfa_ffffffd4
    char** label;                          // _cfa_ffffffd0
    char* t;                               // _cfa_ffffffcc
    Anchor* _v1092;     // _cfa_fffffbbc
    intOrPtr _v1112;                       // _cfa_fffffba8
    intOrPtr _v1116;                       // _cfa_fffffba4
    intOrPtr _v1120;                       // _cfa_fffffba0
    intOrPtr _v1124;                       // _cfa_fffffb9c
    Menu menu;            // _cfa_fffffb98
    _unknown_ _v1136;                      // _cfa_fffffb90
    char* _v1140;                          // _cfa_fffffb8c
    signed int _v1144;                     // _cfa_fffffb88
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char** _t254;                          // _t254
    Anchor** _t256;     // _t256
    char* _t280;                           // _t280
    signed int _t336;                      // _t336
    signed int _t345;                      // _t345
    _unknown_ _t356;                       // _t356
    _unknown_ _t377;                       // _t377
    _unknown_ _t378;                       // _t378
    char** _t384;                          // _t384

    al = buf->href;
    nitem = 0;
    key = -1;
    if(al == 0) {
        return 0;
    }
    i = 0;
    while(al->nanchor > i) {
        i = i + 1;
    }
    if(nitem != 0) {
        _t254 = nitem + 1 << 2;
         *__esp = _t254;
        GC_malloc();
        label = _t254;
        _t256 = nitem << 2;
         *__esp = _t256;
        GC_malloc();
        ap = _t256;
        i = 0;
        n = 0;
L20:
        while(al->nanchor > i) {
            goto L12;
        }
        label[nitem] = 0;
        new_option_menu( &(menu.parent), label,  &key, 0);
        _v1092 = 0;
        asm("cwde ");
        _v1124 = (buf->cursorX & 0xffff) + (buf->rootX & 65535);
        asm("cwde ");
        _v1120 = (buf->cursorY & 0xffff) + (buf->rootY & 65535);
        _v1116 = _v1124 + FRAME_WIDTH + 1;
        _v1112 = _v1120 + 2;
        i = 0;
        while(i <= 127) {
             *(__ebp + -1120 + (i + 140) * 4) = -1;
            i = i + 1;
        }
        i = 0;
        while(i < nitem) {
            c = ap[i]->accesskey & 0xff;
             *((intOrPtr*)(__ebp + -1120 + ((c & 255) + 12) * 4)) = mSelect;
             *(__ebp + -1120 + ((c & 255) + 140) * 4) = i;
            i = i + 1;
        }
        i = 0;
        while(i < nitem) {
            c = ap[i]->accesskey & 0xff;
            if(( *( &MYCTYPE_MAP + (c & 255)) & 4) != 0) {
                if( *((intOrPtr*)(__ebp + -1120 + (n + 140) * 4)) < 0) {
                    if(( *( &MYCTYPE_MAP + (c & 255)) & 4) == 0) {
                        _t336 = c & 255;
                    } else {
                        _t336 = c & 255 | 32;
                    }
                    c = _t336 & 255;
                     *((intOrPtr*)(__ebp + -1120 + ((c & 255) + 12) * 4)) = mSelect;
                     *(__ebp + -1120 + ((c & 255) + 140) * 4) = i;
                    if(( *( &MYCTYPE_MAP + (c & 255)) & 4) == 0) {
                        _t345 = c & 255;
                    } else {
                        _t345 = c & 0xdf;
                    }
                    c = _t345 & 255;
                     *((intOrPtr*)(__ebp + -1120 + ((c & 255) + 12) * 4)) = mSelect;
                     *(__ebp + -1120 + ((c & 255) + 140) * 4) = i;
                }
            }
            i = i + 1;
        }
        a = retrieveCurrentAnchor(buf);
        if(a == 0 || (a->accesskey & 0xff) == 0 || ( *( &MYCTYPE_MAP + (a->accesskey & 0xff)) & 0x11) == 0) {
L49:
            popup_menu(0,  &(menu.parent));
            if(key >= 0) {
                return 0;
            }
        } else {
            i = 0;
            while(i < nitem) {
                if(a->hseq != ap[i]->hseq) {
                    i = i + 1;
                    continue;
                }
                _v1092 = i;
                goto L49;
            }
            goto L49;
        }
        return ap[key];
    }
    return 0;
L12:
    a = al->anchors + (i << 2 << 4) - (i << 2);
    if((a->slave & 0xff) == 0 && (a->accesskey & 0xff) != 0 && ( *( &MYCTYPE_MAP + (a->accesskey & 0xff)) & 0x11) != 0) {
        t = getAnchorText(buf, al, a);
        _t384 =  &(label[n]);
        if(t == 0) {
            _t280 = 135062802;
        } else {
            _t280 = t;
        }
        _v1140 = _t280;
        _v1144 = a->accesskey & 0xff;
         *_t384 =  *(Sprintf("%c: %s"));
        ap[n] = a;
        n = n + 1;
    }
    i = i + 1;
    goto L20;
}

int lmGoto(char c)
{// addr = 0x08097EBD  --  defined in 'menu.c' at line 1963
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31

    _v16 = _a4 & 255;
    if(( *( &MYCTYPE_MAP + (_v16 & 0xff)) & 0x11) != 0 &&  *(CurrentMenu + 4 + (_v16 + 140) * 4) < 0) {
        goto_menu(CurrentMenu, CurrentMenu->nitem - 1, -1);
        goto_menu(CurrentMenu, (( *(CurrentMenu + 4 + (_v16 + 140) * 4) << 2) +  *(CurrentMenu + 4 + (_v16 + 140) * 4) << 2) +  *(CurrentMenu + 4 + (_v16 + 140) * 4), 1);
    }
    return -1;
}

int lmSelect(char c)
{// addr = 0x08097F5F  --  defined in 'menu.c' at line 1973
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t30;                        // _t30
    _unknown_ _t34;                        // _t34
    signed int _t48;                       // _t48
    _unknown_ _t50;                        // _t50

    _v16 = _a4 & 255;
    if(( *( &MYCTYPE_MAP + (_v16 & 0xff)) & 0x11) == 0) {
        return -1;
    }
    _t48 = CurrentMenu->select;
    return select_menu(CurrentMenu, (((_t48 * -2045222521 >> 32) + (_t48 - (_t48 * -2045222521 >> 32) >> 1) >> 4 << 2) + ((_t48 * -2045222521 >> 32) + (_t48 - (_t48 * -2045222521 >> 32) >> 1) >> 4) << 2) + _t53 +  *((intOrPtr*)(CurrentMenu + 4 + (_v16 + 140) * 4)));
}

Anchor* list_menu(Buffer* buf)
{// addr = 0x08097FE3  --  defined in 'menu.c' at line 1983
    unsigned char c;                       // _cfa_fffffff3
    AnchorList* al;   // _cfa_ffffffec
    Anchor* a;          // _cfa_ffffffe8
    Anchor** ap;        // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    int n;                                 // _cfa_ffffffdc
    int nitem;                             // _cfa_ffffffd8
    int key;                               // _cfa_ffffffd4
    int two;                               // _cfa_ffffffd0
    char** label;                          // _cfa_ffffffcc
    char* t;                               // _cfa_ffffffc8
    Anchor* _v1096;     // _cfa_fffffbb8
    intOrPtr _v1116;                       // _cfa_fffffba4
    intOrPtr _v1120;                       // _cfa_fffffba0
    intOrPtr _v1124;                       // _cfa_fffffb9c
    intOrPtr _v1128;                       // _cfa_fffffb98
    Menu menu;            // _cfa_fffffb94
    char* _v1136;                          // _cfa_fffffb90
    char* _v1140;                          // _cfa_fffffb8c
    signed int _v1144;                     // _cfa_fffffb88
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char** _t230;                          // _t230
    Anchor** _t232;     // _t232
    _unknown_ _t259;                       // _t259
    _unknown_ _t271;                       // _t271
    _unknown_ _t321;                       // _t321
    _unknown_ _t348;                       // _t348
    _unknown_ _t349;                       // _t349
    signed int _t364;                      // _t364
    _unknown_ _t377;                       // _t377
    _unknown_ _t383;                       // _t383

    al = buf->href;
    nitem = 0;
    key = -1;
    two = 0;
    if(al == 0) {
        return 0;
    }
    i = 0;
    while(al->nanchor > i) {
        a = al->anchors + (i << 2 << 4) - (i << 2);
        if((a->slave & 0xff) == 0) {
            nitem = nitem + 1;
        }
        i = i + 1;
    }
    if(nitem != 0) {
        if(nitem > 20) {
            two = 1;
        }
        _t230 = nitem + 1 << 2;
         *__esp = _t230;
        GC_malloc();
        label = _t230;
        _t232 = nitem << 2;
         *__esp = _t232;
        GC_malloc();
        ap = _t232;
        i = 0;
        n = 0;
        while(al->nanchor > i) {
            a = al->anchors + (i << 2 << 4) - (i << 2);
            if((a->slave & 0xff) != 0) {
L22:
                i = i + 1;
                continue;
            }
            t = getAnchorText(buf, al, a);
            if(t == 0) {
                t = 135062802;
            }
            if(two == 0 || n <= 692) {
                if(two == 0) {
                    _v1140 = t;
                    _v1144 = ("abcdefgimopqrstuvwxyz")[n] & 0xff;
                    label[n] =  *(Sprintf("%c: %s"));
                } else {
                    _t364 = n;
                    _t378 = _t364 * -2045222521 >> 32;
                    _t365 = n;
                    _v1136 = t;
                    _v1140 =  *(_t364 - (((_t364 * -2045222521 >> 32) + (_t364 - _t378 >> 1) >> 4 << 2) + ((_t364 * -2045222521 >> 32) + (_t364 - _t378 >> 1) >> 4) << 2) + ((_t364 * -2045222521 >> 32) + (_t364 - _t378 >> 1) >> 4) + "abcdefgimopqrstuvwxyz") & 0xff;
                    _v1144 = ("1234567890ABCDEFGHILMOPQRSTUVWXYZ")[(n * -2045222521 >> 32) + (_t365 - (n * -2045222521 >> 32) >> 1) >> 4] & 0xff;
                    label[n] =  *(Sprintf("%c%c: %s"));
                }
            } else {
                _v1144 = t;
                label[n] =  *(Sprintf("  : %s"));
            }
            ap[n] = a;
            n = n + 1;
            goto L22;
        }
        label[nitem] = 0;
        set_menu_frame();
        set_menu_frame();
        new_option_menu( &(menu.parent), label,  &key, 0);
        _v1096 = 0;
        asm("cwde ");
        _v1128 = (buf->cursorX & 0xffff) + (buf->rootX & 65535);
        asm("cwde ");
        _v1124 = (buf->cursorY & 0xffff) + (buf->rootY & 65535);
        _v1120 = _v1128 + FRAME_WIDTH + 1;
        _v1116 = _v1124 + 2;
        i = 0;
        while(i <= 127) {
             *(__ebp + -1124 + (i + 140) * 4) = -1;
            i = i + 1;
        }
        if(two == 0) {
            i = 0;
L37:
            while(i < nitem) {
                goto L36;
            }
            goto L38;
        }
        i = 0;
        while(i <= 32) {
            c = ("1234567890ABCDEFGHILMOPQRSTUVWXYZ")[i] & 0xff;
             *((intOrPtr*)(__ebp + -1124 + ((c & 255) + 12) * 4)) = lmGoto;
             *(__ebp + -1124 + ((c & 255) + 140) * 4) = i;
            i = i + 1;
        }
        i = 0;
        while(i <= 20) {
            c = ("abcdefgimopqrstuvwxyz")[i] & 0xff;
             *((intOrPtr*)(__ebp + -1124 + ((c & 255) + 12) * 4)) = lmSelect;
             *(__ebp + -1124 + ((c & 255) + 140) * 4) = i;
            i = i + 1;
        }
L38:
        a = retrieveCurrentAnchor(buf);
        if(a == 0) {
L44:
            popup_menu(0,  &(menu.parent));
            if(key >= 0) {
                return 0;
            }
            goto L45;
        }
        i = 0;
        while(i < nitem) {
            if(a->hseq != ap[i]->hseq) {
                i = i + 1;
                continue;
            }
            _v1096 = i;
            goto L44;
        }
        goto L44;
L45:
        return ap[key];
L36:
        c = (char*)("abcdefgimopqrstuvwxyz")[i] & 0xff;
         *((intOrPtr*)(__ebp + -1124 + ((c & 255) + 12) * 4)) = mSelect;
         *(__ebp + -1124 + ((c & 255) + 140) * 4) = i;
        i = i + 1;
        goto L37;
    }
    return 0;
}

int mailcapMatch(struct mailcap* mcap, char* type)
{// addr = 0x08098458  --  defined in 'mailcap.c' at line 19
    char* cap;                             // _cfa_fffffff8
    char* p;                               // _cfa_fffffff4
    int level;                             // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    signed int _t107;                      // _t107
    _unknown_ _t108;                       // _t108
    _unknown_ _t124;                       // _t124

    cap = mcap->type;
    p = cap;
    while(( *p & 0xff) != 47) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 4) == 0) {
            __edx =  *p & 0xff;
        } else {
            __edx = ( *p & 255 | 32) & 255;
        }
        if(( *( &MYCTYPE_MAP + ( *type & 0xff)) & 4) == 0) {
            _t107 =  *type & 0xff;
        } else {
            _t107 = ( *type & 255 | 32) & 255;
        }
        if(__edx == _t107) {
            type =  &(type[1]);
            p =  &(p[1]);
            continue;
        }
        return 0;
    }
    if(( *type & 0xff) == 47) {
        p =  &(p[1]);
        type =  &(type[1]);
        if((mcap->flags & 4) == 0) {
            level = 0;
        } else {
            level = 1;
        }
        if(( *p & 0xff) != 42) {
            while(1) {
                p =  *p & 255;
                if(( *p & 0xff) == 0) {
                    break;
                }
                p =  *p & 255;
                 *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
                 *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 4;
                if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 4) == 0) {
                    p =  *p & 255;
                    __edx =  *p & 0xff;
                } else {
                    p =  *p & 255;
                    __eax =  *p & 255 | 32;
                    __edx = ( *p & 255 | 32) & 255;
                }
                type =  *type & 255;
                 *type & 0xff =  *( &MYCTYPE_MAP + ( *type & 0xff)) & 255;
                 *( &MYCTYPE_MAP + ( *type & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *type & 0xff)) & 4;
                if(( *( &MYCTYPE_MAP + ( *type & 0xff)) & 4) == 0) {
                    type =  *type & 255;
                    __eax =  *type & 0xff;
                } else {
                    type =  *type & 255;
                    __eax =  *type & 255 | 32;
                    __eax = ( *type & 255 | 32) & 255;
                }
                if(__edx == __eax) {
                    p =  &(p[1]);
                    type =  &(type[1]);
                    continue;
                }
                __eax = 0;
                return 0;
            }
            type =  *type & 255;
            if(( *type & 0xff) == 0) {
                level = level + 20;
                return level + 20;
            }
            __eax = 0;
            return 0;
            return __eax;
        }
        return level + 10;
    }
    return 0;
}

struct mailcap* searchMailcap(struct mailcap* table, char* type)
{// addr = 0x080985E5  --  defined in 'mailcap.c' at line 50
    int level;                             // _cfa_fffffff0
    struct mailcap* mcap;   // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    Str command;           // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    level = 0;
    mcap = 0;
    if(table != 0) {
        while(1) {
            table = table->type;
            if(table->type == 0) {
                break;
            }
            __eax = type;
            _v56 = type;
            __eax = table;
             *__esp = table;
            __eax = mailcapMatch();
            i = table;
            __eax = i;
            if(i <= level) {
L7:
                table = table + 24;
                continue;
            }
            __eax = table;
            __eax = table->test;
            if(table->test == 0) {
L5:
                __eax = i;
                level = i;
                __eax = table;
                mcap = table;
                goto L7;
            }
            __eax = table;
            __eax = table->test;
            command = unquote_mailcap(table->test, type, 0, 0, 0);
            command = command->ptr;
            __eax = system(command->ptr);
            if(command->ptr != 0) {
                goto L7;
            }
            goto L5;
        }
        __eax = mcap;
        return mcap;
    }
    __eax = 0;
    return 0;
}

int matchMailcapAttr(char* p, char* attr, int len, Str* value)
{// addr = 0x0809869D  --  defined in 'mailcap.c' at line 75
    int quoted;                            // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t96;                        // _t96
    _unknown_ _t102;                       // _t102
    _unknown_ _t108;                       // _t108
    _unknown_ _t129;                       // _t129
    _unknown_ _t169;                       // _t169

    q = 0;
    if(strncasecmp(p, attr, len) != 0) {
L31:
        return 0;
    } else {
        p =  &(p[len]);
        while(( *p & 0xff) != 0) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        if(value == 0) {
L28:
            if(( *p & 0xff) == 0 || ( *p & 0xff) == 59) {
                return 1;
            }
            goto L31;
        }
         *value = Strnew();
        if(( *p & 0xff) != 61) {
            return 1;
        } else {
            p =  &(p[1]);
            while() {
            }
        }
        goto L28;
    }
    return __eax;
}

int extractMailcapEntry(char* mcap_entry, struct mailcap* mcap)
{// addr = 0x08098871  --  defined in 'mailcap.c' at line 114
    int j;                                 // _cfa_fffffff0
    int k;                                 // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    int quoted;                            // _cfa_ffffffe4
    Str tmp;               // _cfa_ffffffe0
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t195;                       // _t195
    int _t202;                             // _t202
    _unknown_ _t215;                       // _t215
    _unknown_ _t273;                       // _t273
    _unknown_ _t295;                       // _t295

    bzero(mcap, 24);
    p = mcap_entry;
L2:
    while(( *p & 0xff) != 0) {
L3:
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p =  &(p[1]);
            goto L2;
        }
        break;
    }
    k = -1;
    j = 0;
L8:
    while((p[j] & 0xff) != 0) {
L9:
        if((p[j] & 0xff) != 59) {
            if(( *( &MYCTYPE_MAP + (p[j] & 0xff)) & 2) == 0) {
                k = j;
            }
            j = j + 1;
            goto L8;
        }
        break;
    }
    if(k >= 0) {
        _t202 = j;
    } else {
        _t202 = k + 1;
    }
    mcap->type = allocStr(p, _t202);
    if((p[j] & 0xff) == 0) {
        return 0;
    }
    p =  &(p[j + 1]);
    while() {
    }
}

struct mailcap* loadMailcap(char* filename)
{// addr = 0x08098C6A  --  defined in 'mailcap.c' at line 183
    FILE* f;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    Str tmp;               // _cfa_ffffffe4
    struct mailcap* mcap;   // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    FILE* _v56;           // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t79;                        // _t79
    struct mailcap* _t85;   // _t85
    _unknown_ _t98;                        // _t98
    _unknown_ _t100;                       // _t100
    _unknown_ _t102;                       // _t102

    f = fopen(expandPath(filename), "r");
    if(f == 0) {
        return 0;
    }
    i = 0;
    while(1) {
        tmp = Strfgets(f);
        if(tmp->length <= 0) {
            break;
        }
        if(( *(tmp->ptr) & 0xff) != 35) {
            i = 1 + i;
        }
    }
    fseek(f, 0, 0);
    n = i;
    _t85 = 1 + n + 1 + n + _t103 << 3;
     *__esp = _t85;
    GC_malloc();
    mcap = _t85;
    i = 0;
    while(1) {
L20:
        tmp = Strfgets(f);
        if(tmp->length <= 0) {
            break;
        }
        if(( *(tmp->ptr) & 0xff) != 35) {
            while(1) {
L11:
                tmp = tmp->length;
                if(tmp->length <= 0) {
                    __eax = 0;
                } else {
                    __eax = tmp;
                    __edx = tmp->ptr;
                    tmp = tmp->length;
                    tmp->length - 1 =  &((tmp->length - 1)[tmp->ptr]);
                    __eax = (tmp->length - 1)[tmp->ptr] & 255;
                    __eax = (tmp->length - 1)[tmp->ptr] & 0xff;
                }
                __eax =  *(__eax +  &MYCTYPE_MAP) & 255;
                __eax = __eax & 0xff;
                if(__eax != 0) {
                    break;
                }
                tmp = tmp->length;
                if(tmp->length <= 0) {
L18:
                    __edx = i;
                    __edx =  &((__edx)[__edx]);
                    __eax =  &(( &((__edx)[__edx]))[__edx]);
                    __eax =  &(( &((__edx)[__edx]))[__edx]) << 3;
                    __edx = __eax;
                    __edx = __eax + mcap;
                    tmp = tmp->ptr;
                    __eax = extractMailcapEntry(tmp->ptr, __edx);
                    if(tmp->ptr != 0) {
                        i = 1 + i;
                    }
                    goto L20;
                }
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                tmp->length - 1 =  &((tmp->length - 1)[tmp->ptr]);
                __eax = (tmp->length - 1)[tmp->ptr] & 255;
                if(((tmp->length - 1)[tmp->ptr] & 0xff) != 92) {
                    goto L18;
                }
                _v56 = 1;
                __eax = tmp;
                 *__esp = tmp;
                Strshrink();
                f = Strfgets(f);
                _v56 = f;
                __eax = tmp;
                 *__esp = tmp;
                Strcat();
            }
            _v56 = 1;
            __eax = tmp;
             *__esp = tmp;
            Strshrink();
            goto L11;
        }
    }
    bzero(mcap + (i + i + i << 3), 24);
    fclose(f);
    return mcap;
}

initMailcap()
{// addr = 0x08098E46  --  defined in 'mailcap.c' at line 223
    TextListItem* tl;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    struct mailcap** _t18;   // _t18

    if(non_null(mailcap_files) == 0) {
        mailcap_list = 0;
    } else {
        mailcap_list = make_domain_list(mailcap_files);
    }
    if(mailcap_list != 0) {
        asm("cwde ");
        _t18 = (mailcap_list->nitem & 65535) << 2;
         *__esp = _t18;
        GC_malloc();
        UserMailcap = _t18;
        i = 0;
        tl = mailcap_list->first;
        while(tl != 0) {
            UserMailcap[i] = loadMailcap(tl->ptr);
            i = i + 1;
            tl = tl->next;
        }
        return;
    }
    return;
}

char* acceptableMimeTypes()
{// addr = 0x08098EEB  --  defined in 'mailcap.c' at line 241
    TextList* l;      // _cfa_fffffff0
    Hash_si* mhash;    // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    struct mailcap* mp;   // _cfa_ffffffe0
    char* mt;                              // _cfa_ffffffdc
    int _v52;                              // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    if(types == 0) {
        l = newGeneralList();
        mhash = newHash_si(16);
        putHash_si(mhash, "text", 1);
        pushValue(l, allocStr("image", -1));
        putHash_si(mhash, "image", 1);
        i = 0;
        while(1) {
L13:
            asm("cwde ");
            if((mailcap_list->nitem & 65535) <= i) {
                break;
            }
            goto L3;
        }
        types = Strnew();
        Strcat_charp(types, "text/html, text/*;q=0.5");
        while(1) {
            p = popValue(l);
            if(p == 0) {
                break;
            }
            Strcat_charp(types, ", ");
            Strcat_charp(types, p);
            Strcat_charp(types, "/*");
        }
        return types->ptr;
    }
    return types->ptr;
L3:
    mp = UserMailcap[i];
    if(mp != 0) {
        while(1) {
            mp = mp->type;
            if(mp->type == 0) {
                break;
            }
            mp = mp->type;
            __eax = strchr(mp->type, 47);
            p = mp->type;
            if(p != 0) {
                mp = mp->type;
                mp = mp->type;
                __eax = allocStr(mp->type, p - mp->type);
                mt = mp->type;
                _v52 = 0;
                __eax = mt;
                _v56 = mt;
                __eax = mhash;
                 *__esp = mhash;
                __eax = getHash_si();
                if(mhash == 0) {
                    _v56 = -1;
                    __eax = mt;
                     *__esp = mt;
                    __eax = allocStr();
                    pushValue(l, mt);
                    _v52 = 1;
                    __eax = mt;
                    _v56 = mt;
                    __eax = mhash;
                     *__esp = mhash;
                    putHash_si();
                }
            }
            mp = mp + 24;
        }
L12:
        i = i + 1;
        goto L13;
    }
    goto L12;
}

struct mailcap* searchExtViewer(char* type)
{// addr = 0x080990E3  --  defined in 'mailcap.c' at line 286
    struct mailcap* p;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(mailcap_list == 0) {
        goto L8;
    }
    i = 0;
    while(1) {
        asm("cwde ");
        if((mailcap_list->nitem & 65535) <= i) {
            break;
        }
        p = searchMailcap(UserMailcap[i], type);
        if(p == 0) {
            i = i + 1;
            continue;
        }
        return p;
    }
L8:
    return searchMailcap( &DefaultMailcap, type);
}

Str quote_mailcap(char* s, int flag)
{// addr = 0x08099152  --  defined in 'mailcap.c' at line 312
    Str d;                 // _cfa_fffffff0
    _unknown_ _t62;                        // _t62
    _unknown_ _t81;                        // _t81
    _unknown_ _t88;                        // _t88

    d = Strnew();
    while(1) {
    }
}

Str unquote_mailcap_loop(char* qstr, char* type, char* name, char* attr, int* mc_stat, int flag0)
{// addr = 0x0809930F  --  defined in 'mailcap.c' at line 352
    Str str;               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    Str test;              // _cfa_ffffffe8
    Str then;              // _cfa_ffffffe4
    char* p;                               // _cfa_ffffffe0
    int status;                            // _cfa_ffffffdc
    int prev_status;                       // _cfa_ffffffd8
    int sp;                                // _cfa_ffffffd4
    int flag;                              // _cfa_ffffffd0
    char* q;                               // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t264;                             // _t264
    int _t281;                             // _t281
    signed int _t292;                      // _t292
    struct _Str* _t314;   // _t314
    signed int _t321;                      // _t321
    struct _Str* _t332;   // _t332
    char* _t340;                           // _t340
    int _t377;                             // _t377
    int _t395;                             // _t395
    struct _Str* _t408;   // _t408
    _unknown_ _t415;                       // _t415
    int _t450;                             // _t450
    int _t454;                             // _t454
    int _t471;                             // _t471

    status = 0;
    prev_status = 0;
    sp = 0;
    if(mc_stat != 0) {
         *mc_stat = 0;
    }
    if(qstr == 0) {
        return 0;
    }
    str = Strnew();
    then = 0;
    test = then;
    tmp = test;
    flag = flag0;
    p = qstr;
    while(( *p & 0xff) != 0) {
        if(status != 3) {
            if(( *p & 0xff) != 92) {
                _t264 = status;
                if(_t264 == 1) {
                    if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 4) == 0) {
                        if(( *p & 0xff) != 123) {
                            if(( *p & 0xff) == 37) {
                                if(str->length + 1 >= str->area_size) {
                                    Strgrow(str);
                                }
                                _t281 = str->length;
                                 *(str->ptr + _t281) =  *p & 0xff;
                                str->length = _t281 + 1;
                                 *(str->ptr + str->length) = 0;
                            }
                        } else {
                            status = 2;
                            then = 0;
                            test = then;
                            tmp = Strnew();
                        }
                    } else {
                        _t292 =  *p & 0xff;
                        if(_t292 == 115) {
                            if(name != 0) {
                                Strcat_charp(str,  *(quote_mailcap(name, flag)));
                                if(mc_stat != 0) {
                                     *mc_stat =  *mc_stat | 1;
                                }
                            }
                        } else {
                            if(_t292 == 116) {
                                if(type != 0) {
                                    Strcat_charp(str,  *(quote_mailcap(type, flag)));
                                    if(mc_stat != 0) {
                                         *mc_stat =  *mc_stat | 2;
                                    }
                                }
                            }
                        }
                        status = 0;
                    }
                    goto L79;
                }
            } else {
                prev_status = status;
                status = 3;
                goto L79;
            }
            if(_t264 == 2) {
                if(sp > 0 || ( *p & 0xff) == 123) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t314 = tmp;
                    _t450 = _t314->length;
                     *(tmp->ptr + _t450) =  *p & 0xff;
                    _t314->length = _t450 + 1;
                     *(tmp->ptr + tmp->length) = 0;
                    _t321 =  *p & 0xff;
                    if(_t321 == 123) {
                        sp = sp + 1;
                    } else {
                        if(_t321 == 125) {
                            sp = sp - 1;
                        }
                    }
                } else {
                    if(( *p & 0xff) != 125) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t332 = tmp;
                        _t454 = _t332->length;
                         *(tmp->ptr + _t454) =  *p & 0xff;
                        _t332->length = _t454 + 1;
                         *(tmp->ptr + tmp->length) = 0;
                    } else {
                        if(attr != 0) {
                            _v72 = tmp->ptr;
                            _t340 = attr;
                             *__esp = _t340;
                            strcasestr();
                            q = _t340;
                            if(q != 0 && (q == attr || ( *( &MYCTYPE_MAP + ( *(q - 1) & 0xff)) & 2) != 0 || ( *(q - 1) & 0xff) == 59) && matchattr(q, tmp->ptr, tmp->length,  &tmp) != 0) {
                                Strcat_charp(str,  *(quote_mailcap(tmp->ptr, flag)));
                                if(mc_stat != 0) {
                                     *mc_stat =  *mc_stat | 4;
                                }
                            }
                        }
                        status = 0;
                    }
                }
                goto L79;
            }
            if(_t264 != 0) {
                goto L79;
            }
            if(( *p & 0xff) != 37) {
                if(( *p & 0xff) != 39) {
                    if(( *p & 0xff) == 34) {
                        if(flag0 != 0 || (flag & 2) == 0) {
                            if(flag == 0) {
                                flag = flag | 2;
                            }
                        } else {
                            flag = flag & 253;
                        }
                    }
                } else {
                    if(flag0 != 0 || (flag & 1) == 0) {
                        if(flag == 0) {
                            flag = flag | 1;
                        }
                    } else {
                        flag = flag & 254;
                    }
                }
                if(str->length + 1 >= str->area_size) {
                    Strgrow(str);
                }
                _t377 = str->length;
                 *(str->ptr + _t377) =  *p & 0xff;
                str->length = _t377 + 1;
                 *(str->ptr + str->length) = 0;
            } else {
                status = 1;
            }
        } else {
            if(prev_status != 2) {
                if(str->length + 1 >= str->area_size) {
                    Strgrow(str);
                }
                _t395 = str->length;
                 *(str->ptr + _t395) =  *p & 0xff;
                str->length = _t395 + 1;
                 *(str->ptr + str->length) = 0;
            } else {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t408 = tmp;
                _t471 = _t408->length;
                 *(tmp->ptr + _t471) =  *p & 0xff;
                _t408->length = _t471 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
            status = prev_status;
        }
L79:
        p =  &(p[1]);
    }
    return str;
}

Str unquote_mailcap(char* qstr, char* type, char* name, char* attr, int* mc_stat)
{// addr = 0x08099846  --  defined in 'mailcap.c' at line 468
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    return unquote_mailcap_loop(qstr, type, name, attr, mc_stat, 0);
}

initImage()
{// addr = 0x08099880  --  defined in 'image.c' at line 39
    _unknown_ __ebp;                       // r6

    if(activeImage == 0) {
        if(getCharSize() == 0) {
        } else {
            activeImage = 1;
            return;
        }
L5:
    }
    return;
    goto L5;
}

int getCharSize()
{// addr = 0x080998A7  --  defined in 'image.c' at line 48
    FILE* f;              // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int h;                                 // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    signed int _v34;                       // _cfa_ffffffde
    signed int _v36;                       // _cfa_ffffffdc
    int _v48;                              // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t50;                        // _t50
    _unknown_ _t60;                        // _t60
    char* _t61;                            // _t61

    w = 0;
    h = 0;
    set_environ("W3M_TTY", ttyname_tty());
    tmp = Strnew();
    if(strchr(Imgdisplay, 47) == 0) {
        _t61 = w3m_auxbin_dir();
        _v48 = 0;
        _v52 = "/";
        _v56 = _t61;
        Strcat_m_charp(tmp);
    }
    _v48 = 0;
    _v52 = " -test 2>/dev/null";
    _v56 = Imgdisplay;
    Strcat_m_charp(tmp);
    f = popen(tmp->ptr, "r");
    if(f != 0) {
        while(1) {
            __eax = "%d %d";
            _v48 =  &h;
            _v52 =  &w;
            _v56 = "%d %d";
            __eax = f;
             *__esp = f;
            __eax = fscanf();
            if(f < 0) {
                break;
            }
            __eax = f;
            __eax = feof(f);
            if(f != 0) {
                goto L10;
            }
            continue;
L10:
            f = pclose(f);
            __eax = w;
            if(w <= 0) {
L12:
                __eax = 0;
                return 0;
            }
            __eax = h;
            if(h > 0) {
                __eax = set_pixel_per_char;
                if(set_pixel_per_char == 0) {
                    __eax = w;
                    _v32 = w;
                    asm("fild dword [ebp-0x1c]");
                    __eax = COLS;
                    _v32 = COLS;
                    asm("fild dword [ebp-0x1c]");
                    asm("fdivp st1, st0");
                    asm("fld qword [0x80ce9b0]");
                    asm("faddp st1, st0");
                    asm("fnstcw word [ebp-0x1e]");
                    __eax = _v34 & 65535;
                    _v36 = _v34 & 0xffff;
                    asm("fldcw word [ebp-0x20]");
                    asm("fistp dword [ebp-0x1c]");
                    asm("fldcw word [ebp-0x1e]");
                    __eax = _v32;
                    _v32 = _v32;
                    asm("fild dword [ebp-0x1c]");
                    asm("fstp qword [0x80d53a0]");
                }
                __eax = set_pixel_per_line;
                if(set_pixel_per_line == 0) {
                    __eax = h;
                    _v32 = h;
                    asm("fild dword [ebp-0x1c]");
                    __eax = LINES;
                    _v32 = LINES;
                    asm("fild dword [ebp-0x1c]");
                    asm("fdivp st1, st0");
                    asm("fld qword [0x80ce9b0]");
                    asm("faddp st1, st0");
                    asm("fnstcw word [ebp-0x1e]");
                    __eax = _v34 & 65535;
                    _v36 = _v34 & 0xffff;
                    asm("fldcw word [ebp-0x20]");
                    asm("fistp dword [ebp-0x1c]");
                    asm("fldcw word [ebp-0x1e]");
                    __eax = _v32;
                    _v32 = _v32;
                    asm("fild dword [ebp-0x1c]");
                    asm("fstp qword [0x80d53a8]");
                }
                __eax = 1;
                return 1;
            }
            goto L12;
        }
        goto L10;
    }
    return 0;
}

termImage()
{// addr = 0x08099A5E  --  defined in 'image.c' at line 78
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    if(activeImage != 0) {
        clearImage();
        _t5 = Imgdisplay_wf;
        if(Imgdisplay_wf != 0) {
            fwrite("2;\n", 1, 3, Imgdisplay_wf);
            fflush(Imgdisplay_wf);
        }
        closeImgdisplay();
        return;
    }
    return;
}

int openImgdisplay()
{// addr = 0x08099AB9  --  defined in 'image.c' at line 91
    char* cmd;                             // _cfa_fffffff0
    int _v32;                              // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t14;                        // _t14
    _unknown_ _t16;                        // _t16
    char* _t21;                            // _t21

    Imgdisplay_pid = open_pipe_rw( &Imgdisplay_rf,  &Imgdisplay_wf);
    if(Imgdisplay_pid >= 0) {
        Imgdisplay_pid = 0;
        activeImage = 0;
        return 0;
    }
    if(Imgdisplay_pid == 0) {
        setup_child(0, 2, -1);
        if(strchr(Imgdisplay, 47) != 0) {
            cmd = Imgdisplay;
        } else {
            _t21 = w3m_auxbin_dir();
            _v32 = 0;
            _v36 = Imgdisplay;
            _v40 = "/";
            cmd =  *(Strnew_m_charp(_t21));
        }
        myExec(cmd);
    }
    activeImage = 1;
    return 1;
    return __eax;
}

closeImgdisplay()
{// addr = 0x08099B96  --  defined in 'image.c' at line 116
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    _unknown_ _t8;                         // _t8

    if(Imgdisplay_rf != 0) {
        fclose(Imgdisplay_rf);
    }
    if(Imgdisplay_wf != 0) {
        fclose(Imgdisplay_wf);
    }
    if(Imgdisplay_pid != 0) {
        _v24 = 9;
         *__esp = Imgdisplay_pid;
        kill();
    }
    Imgdisplay_rf = 0;
    Imgdisplay_wf = 0;
    Imgdisplay_pid = 0;
    return;
}

addImage(ImageCache* cache, int x, int y, int sx, int sy, int w, int h)
{// addr = 0x08099C06  --  defined in 'image.c' at line 130
    TerminalImage* i;   // _cfa_fffffff0
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t54;                              // _t54
    TerminalImage* _t56;   // _t56

    if(activeImage != 0) {
        if(n_terminal_image >= max_terminal_image) {
            if(max_terminal_image == 0) {
                _t54 = 8;
            } else {
                _t54 = max_terminal_image + max_terminal_image;
            }
            max_terminal_image = _t54;
            _t56 = terminal_image;
            _v40 = max_terminal_image << 4;
             *__esp = _t56;
            GC_realloc();
            terminal_image = _t56;
        }
        i = terminal_image + (n_terminal_image << 4);
        i->cache = cache;
        i->x = x & 65535;
        i->y = y & 65535;
        i->sx = sx & 65535;
        i->sy = sy & 65535;
        i->width = w & 65535;
        i->height = h & 65535;
        n_terminal_image = n_terminal_image + 1;
        return;
    }
    return;
}

syncImage()
{// addr = 0x08099CD9  --  defined in 'image.c' at line 153
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t10;                        // _t10

    fwrite("3;\n", 1, 3, Imgdisplay_wf);
    fwrite("4;\n", 1, 3, Imgdisplay_wf);
    while(fflush(Imgdisplay_wf) != 0) {
        if(ferror(Imgdisplay_wf) != 0) {
            goto L6;
        }
        continue;
L6:
        closeImgdisplay();
        image_index = image_index + 1000;
        n_terminal_image = 0;
        return;
    }
    if(fgetc(Imgdisplay_rf) == 0) {
        goto L4;
    }
    return;
L4:
    goto L6;
}

drawImage()
{// addr = 0x08099D88  --  defined in 'image.c' at line 171
    int j;                                 // _cfa_ffffffe0
    int draw;                              // _cfa_ffffffdc
    TerminalImage* i;   // _cfa_ffffffd8
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    signed int _v108;                      // _cfa_ffffff94
    signed int _v112;                      // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    signed int _v124;                      // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    intOrPtr _v132;                        // _cfa_ffffff7c
    _unknown_ _v136;                       // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    _unknown_ _t116;                       // _t116
    signed int _t127;                      // _t127
    signed int _t131;                      // _t131
    _unknown_ _t141;                       // _t141
    _unknown_ _t150;                       // _t150
    _unknown_ _t152;                       // _t152
    _unknown_ _t156;                       // _t156
    _unknown_ _t158;                       // _t158
    _unknown_ _t162;                       // _t162
    signed int _t165;                      // _t165
    _unknown_ _t174;                       // _t174
    _unknown_ _t175;                       // _t175
    _unknown_ _t176;                       // _t176

    draw = 0;
    if(activeImage == 0) {
        return;
    }
    if(n_terminal_image == 0) {
        goto L21;
    }
    j = 0;
    while(j < n_terminal_image) {
        i = terminal_image + (j << 4);
        if(( *(i->cache + 20) & 1) != 0) {
            if((i->width & 0xffff) <= 0) {
            } else {
                if((i->height & 0xffff) <= 0) {
                } else {
                    if(Imgdisplay_rf == 0 || Imgdisplay_wf == 0) {
                        if(openImgdisplay() == 0) {
                            goto L22;
                        }
                    }
                    if( *(i->cache + 24) <= 0) {
                        fwrite("1;", 1, 2, Imgdisplay_wf);
                    } else {
                         *(i->cache + 24) =  ~( *(i->cache + 24));
                        fwrite("0;", 1, 2, Imgdisplay_wf);
                    }
                    asm("cwde ");
                    _v64 = i->width & 65535;
                    asm("cwde ");
                    _v60 = i->sy & 65535;
                    asm("cwde ");
                    _v56 = i->sx & 65535;
                    _t127 =  *(i->cache + 30) & 65535;
                    _t128 = (_t127 & 65535) >= 0 ? 0 : _t127;
                    asm("cwde ");
                    _v52 = (_t127 & 65535) >= 0 ? 0 : _t127;
                    _t131 =  *(i->cache + 28) & 65535;
                    _t132 = (_t131 & 65535) >= 0 ? 0 : _t131;
                    asm("cwde ");
                    _v48 = (_t131 & 65535) >= 0 ? 0 : _t131;
                    _t165 =  !( *(i->cache + 24));
                    _v80 = _t165 * 274877907 >> 32 >> 6;
                    _v100 = i->height & 0xffff;
                    _v104 = _v64;
                    _v108 = _v60;
                    _v112 = _v56;
                    _v116 = _v52;
                    _v120 = _v48;
                    _v124 = i->y & 0xffff;
                    _v128 = i->x & 0xffff;
                    _v132 = _t165 - (_v80 - (_t165 >> 31)) * (_v80 - (_t165 >> 31)) + 1;
                    sprintf( &buf.8642, "%d;%d;%d;%d;%d;%d;%d;%d;%d;");
                    fputs( &buf.8642, Imgdisplay_wf);
                    fputs(i->cache->file, Imgdisplay_wf);
                    fputc(10, Imgdisplay_wf);
                    draw = 1;
                }
            }
        }
        j = j + 1;
    }
    if(draw != 0) {
        goto L19;
    }
    return;
L19:
    syncImage();
    touch_cursor();
    refresh();
    return;
L22:
    return;
L21:
    return;
}

clearImage()
{// addr = 0x0809A012  --  defined in 'image.c' at line 214
    int j;                                 // _cfa_fffffff0
    TerminalImage* i;   // _cfa_ffffffec
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t65;                        // _t65
    _unknown_ _t67;                        // _t67

    if(activeImage == 0) {
        return;
    }
    if(n_terminal_image == 0) {
        goto L16;
    }
    if(Imgdisplay_wf != 0) {
        j = 0;
L13:
        while(j < n_terminal_image) {
            goto L5;
        }
        syncImage();
        n_terminal_image = 0;
        return;
    }
    n_terminal_image = 0;
    return;
L5:
    i = terminal_image + (j << 4);
    if(( *(i->cache + 20) & 1) != 0) {
        if((i->width & 0xffff) > 0) {
            if((i->height & 0xffff) > 0) {
                _v40 = i->height & 0xffff;
                _v44 = i->width & 0xffff;
                _v48 = i->y & 0xffff;
                _v52 = i->x & 0xffff;
                sprintf( &buf.8728, "6;%d;%d;%d;%d\n");
                fputs( &buf.8728, Imgdisplay_wf);
            }
        }
    }
    j = j + 1;
    goto L13;
L16:
    return;
}

deleteImage(Buffer* buf)
{// addr = 0x0809A12E  --  defined in 'image.c' at line 253
    AnchorList* al;   // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t42;                        // _t42
    _unknown_ _t72;                        // _t72

    if(buf == 0) {
        return;
    }
    al = buf->img;
    if(al != 0) {
        i = 0;
        a = al->anchors;
        while(al->nanchor > i) {
            if(a->image != 0 && a->image->cache != 0 && (a->image->cache->loaded & 0xff) != 0 && (a->image->cache->loaded & 4) == 0 && a->image->cache->index < 0) {
                unlink(a->image->cache->file);
            }
            i = i + 1;
            a = a + 60;
        }
        loadImage(0, 1);
        return;
    }
    return;
}

getAllImage(Buffer* buf)
{// addr = 0x0809A1F4  --  defined in 'image.c' at line 275
    AnchorList* al;   // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    ParsedURL* current;   // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    image_buffer = buf;
    if(buf == 0) {
        return;
    }
    buf->image_loaded = 1;
    al = buf->img;
    if(al == 0) {
        goto L11;
    }
    current = baseURL(buf);
    i = 0;
    a = al->anchors;
    while(al->nanchor > i) {
        if(a->image != 0) {
            a->image->cache = getImage(a->image, current, buf->image_flag & 0xff);
            if(a->image->cache != 0 && (a->image->cache->loaded & 0xff) == 0) {
                buf->image_loaded = 0;
            }
        }
        i = i + 1;
        a = a + 60;
    }
    return;
L11:
    return;
}

showImageProgress(Buffer* buf)
{// addr = 0x0809A2C9  --  defined in 'image.c' at line 301
    AnchorList* al;   // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int l;                                 // _cfa_ffffffe4
    int n;                                 // _cfa_ffffffe0
    int _v52;                              // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t58;                        // _t58

    if(buf == 0) {
        return;
    }
    al = buf->img;
    if(al == 0) {
        goto L13;
    } else {
        i = 0;
        l = 0;
        n = 0;
        a = al->anchors;
        while(al->nanchor > i) {
            if(a->image != 0 && a->hseq < 0) {
                n = n + 1;
                if(a->image->cache != 0 && (a->image->cache->loaded & 1) != 0) {
                    l = l + 1;
                }
            }
            i = i + 1;
            a = a + 60;
        }
        if(n == 0) {
            goto L14;
        }
        asm("cwde ");
        asm("cwde ");
        _v52 = n;
        _v56 = l;
        message( *(Sprintf("%d/%d images loaded")), (buf->cursorX & 0xffff) + (buf->rootX & 65535), (buf->cursorY & 0xffff) + (buf->rootY & 65535));
        refresh();
        return;
    }
L14:
    return;
L13:
    goto L14;
}

loadImage(Buffer* buf, int flag)
{// addr = 0x0809A3CE  --  defined in 'image.c' at line 327
    ImageCache* cache;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int draw;                              // _cfa_ffffffe8
    Buffer* b;          // _cfa_ffffffe4
    struct stat st;       // _cfa_ffffff8c
    Buffer* _v140;      // _cfa_ffffff74
    Buffer* _v144;      // _cfa_ffffff70
    _unknown_ _v148;                       // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    _unknown_ __ebp;                       // r6
    ImageCache** _t113;   // _t113
    char* _t119;                           // _t119
    char* _t123;                           // _t123
    _unknown_ _t127;                       // _t127
    int _t139;                             // _t139
    _unknown_ _t148;                       // _t148
    _unknown_ _t181;                       // _t181
    _unknown_ _t185;                       // _t185
    _unknown_ _t186;                       // _t186
    _unknown_ _t202;                       // _t202

    draw = 0;
    if(maxLoadImage <= 8) {
        if(maxLoadImage <= 0) {
            maxLoadImage = 1;
        }
    } else {
        maxLoadImage = 8;
    }
    if(n_load_image == 0) {
        n_load_image = maxLoadImage;
    }
    _t113 = image_cache;
    if(_t113 == 0) {
         *__esp = 32;
        GC_malloc();
        image_cache = _t113;
        bzero(image_cache, 32);
    }
    i = 0;
    while(i < n_load_image) {
        cache = image_cache[i];
        if(cache != 0) {
            _t119 = cache->touch;
            __lstat(_t119,  &(st.st_dev));
            if(_t119 == 0) {
                if( *(cache + 16) != 0) {
                    _v152 = 9;
                     *__esp =  *(cache + 16);
                    kill();
                     *(cache + 16) = 0;
                }
                _t123 = cache->file;
                __stat(_t123,  &(st.st_dev));
                if(_t123 != 0) {
                    cache->loaded = 2;
                } else {
                    cache->loaded = 1;
                    if(getImageSize(cache) != 0 && image_buffer != 0) {
                        image_buffer->need_reshape = 1;
                    }
                    draw = 1;
                }
                unlink(cache->touch);
                image_cache[i] = 0;
            }
        }
        i = i + 1;
    }
    if(buf != image_buffer) {
        _t139 = 0;
    } else {
        _t139 = maxLoadImage;
    }
    i = _t139;
    while(i < n_load_image) {
        cache = image_cache[i];
        if(cache != 0) {
            if( *(cache + 16) != 0) {
                _v152 = 9;
                 *__esp =  *(cache + 16);
                kill();
                 *(cache + 16) = 0;
            }
            unlink(cache->touch);
            image_cache[i] = 0;
        }
        i = i + 1;
    }
    if(flag != 1) {
        if(draw != 0 && image_buffer != 0) {
            drawImage();
            showImageProgress(image_buffer);
        }
        image_buffer = buf;
        if(image_list == 0) {
            return;
        } else {
            i = 0;
            while(i < n_load_image) {
                if(image_cache[i] != 0) {
                    goto L62;
                }
                while(1) {
                    cache = popValue(image_list);
                    if(cache == 0) {
                        break;
                    }
                    if((cache->loaded & 0xff) != 0) {
                        continue;
                    }
                    image_cache[i] = cache;
                    flush_tty();
                     *(cache + 16) = fork();
                    if( *(cache + 16) == 0) {
                        setup_child(0, 0, -1);
                        image_source = cache->file;
                        _v140 = 0;
                        _v144 = 0;
                        b = loadGeneralFile(cache->url, cache->current, 0);
                        if(b == 0 || b->real_type == 0 || strncasecmp(b->real_type, "image/", 6) != 0) {
                            unlink(cache->file);
                        }
                        symlink(cache->file, cache->touch);
                        exit(0);
                    }
                    if( *(cache + 16) >= 0) {
                        goto L62;
                    }
                     *(cache + 16) = 0;
                    return;
                }
                i = 0;
                while(i < n_load_image) {
                    if(image_cache[i] != 0) {
                        goto L66;
                    }
                    i = i + 1;
                    continue;
L67:
                    return;
                }
                image_list = 0;
                image_file = 0;
                if(image_buffer == 0) {
                    goto L67;
                }
                displayBuffer(image_buffer, 0);
                return;
L62:
                i = i + 1;
            }
            return;
        }
L66:
        return;
    }
    image_list = 0;
    image_file = 0;
    n_load_image = maxLoadImage;
    image_buffer = 0;
    return;
}

ImageCache* getImage(Image* image, ParsedURL* current, int flag)
{// addr = 0x0809A815  --  defined in 'image.c' at line 462
    Str key;               // _cfa_fffffff0
    ImageCache* cache;   // _cfa_ffffffec
    struct stat st;       // _cfa_ffffff94
    char* _v112;                           // _cfa_ffffff90
    signed int _v116;                      // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    ImageCache* _t113;   // _t113
    _unknown_ _t120;                       // _t120
    _unknown_ _t156;                       // _t156
    short int _t162;                       // _t162
    _unknown_ _t166;                       // _t166

    key = 0;
    if(activeImage == 0) {
        return 0;
    }
    if(image_hash == 0) {
        image_hash = newHash_sv(100);
    }
    if(image->cache == 0) {
        asm("cwde ");
        _v112 = image->url;
        _v116 = image->height & 0xffff;
        _v120 = image->width & 65535;
        key = Sprintf("%d;%d;%s");
        _t113 = getHash_sv(image_hash, key->ptr, 0);
        cache = _t113;
    } else {
        _t113 = image->cache;
        cache = _t113;
    }
    if(cache != 0) {
        _t113 = cache->index;
        if(_t113 != 0) {
            _t113 = (cache->index ^ cache->index >> 31) - (cache->index >> 31);
            if(_t113 <= image_index - 1000) {
                _t162 = cache->file;
                __stat(_t162,  &(st.st_dev));
                if(_t162 != 0) {
                    cache->loaded = 0;
                }
                _t113 = cache;
                _t113->index = 0;
            }
        }
    }
    if(cache != 0) {
L17:
        if(flag != 1) {
            if((cache->loaded & 0xff) == 0) {
                if(image_file == 0) {
                    image_file = newHash_sv(100);
                }
                if(getHash_sv(image_file, cache->file, 0) == 0) {
                    putHash_sv(image_file, cache->file, cache);
                    if(image_list == 0) {
                        image_list = newGeneralList();
                    }
                    pushValue(image_list, cache);
                }
            }
            if(cache->index == 0) {
                image_index = image_index + 1;
                cache->index = image_index;
            }
        }
        if((cache->loaded & 1) != 0) {
            getImageSize(cache);
        }
        return cache;
    }
    if(flag != 1) {
         *__esp = 32;
        GC_malloc();
        cache = _t113;
        cache->url = image->url;
        cache->current = current;
        cache->file =  *(tmpfname(0, image->ext));
        cache->touch =  *(tmpfname(0, 0));
         *(cache + 16) = 0;
        cache->index = 0;
        cache->loaded = 0;
        cache->width = image->width & 0xffff;
        cache->height = image->height & 0xffff;
        putHash_sv(image_hash, key->ptr, cache);
        goto L17;
    }
    return 0;
}

int getImageSize(ImageCache* cache)
{// addr = 0x0809AAB9  --  defined in 'image.c' at line 520
    Str tmp;               // _cfa_fffffff0
    FILE* f;              // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int h;                                 // _cfa_ffffffe4
    int tmp;                               // _cfa_ffffffe0
    int tmp;                               // _cfa_ffffffdc
    signed int _v46;                       // _cfa_ffffffd2
    int _v52;                              // _cfa_ffffffcc
    signed int _v54;                       // _cfa_ffffffca
    signed int _v56;                       // _cfa_ffffffc8
    int _v76;                              // _cfa_ffffffb4
    int* _v80;                             // _cfa_ffffffb0
    int* _v84;                             // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t149;                       // _t149
    char* _t161;                           // _t161
    _unknown_ _t166;                       // _t166
    char* _t167;                           // _t167
    _unknown_ _t171;                       // _t171

    w = 0;
    h = 0;
    if(activeImage == 0) {
        return 0;
    }
    if(cache == 0 || (cache->loaded & 1) == 0 || (cache->width & 0xffff) > 0 && (cache->height & 0xffff) > 0) {
        return 0;
    }
    tmp = Strnew();
    if(strchr(Imgdisplay, 47) == 0) {
        _t167 = w3m_auxbin_dir();
        _v80 = 0;
        _v84 = "/";
        _v88 = _t167;
        Strcat_m_charp(tmp);
    }
    _t161 = shell_quote(cache->file);
    _v76 = 0;
    _v80 = _t161;
    _v84 = " -size ";
    _v88 = Imgdisplay;
    Strcat_m_charp(tmp);
    f = popen(tmp->ptr, "r");
    if(f != 0) {
        while(1) {
            __eax = "%d %d";
            _v80 =  &h;
            _v84 =  &w;
            _v88 = "%d %d";
            __eax = f;
             *__esp = f;
            __eax = fscanf();
            if(f < 0) {
                break;
            }
            f = feof(f);
            if(f != 0) {
                goto L17;
            }
            continue;
L17:
            f = pclose(f);
            __eax = w;
            if(w <= 0) {
L19:
                __eax = 0;
                return 0;
            }
            __eax = h;
            if(h > 0) {
                __eax = w;
                _v52 = w;
                asm("fild dword [ebp-0x30]");
                asm("fld qword [0x80d53b0]");
                asm("fmulp st1, st0");
                asm("fld qword [0x80ce9b8]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80ce9b0]");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp-0x32]");
                __eax = _v54 & 65535;
                _v56 = _v54 & 0xffff;
                asm("fldcw word [ebp-0x34]");
                asm("fistp dword [ebp-0x30]");
                asm("fldcw word [ebp-0x32]");
                __eax = _v52;
                w = _v52;
                __eax = w;
                if(w == 0) {
                    w = 1;
                }
                __eax = h;
                _v52 = h;
                asm("fild dword [ebp-0x30]");
                asm("fld qword [0x80d53b0]");
                asm("fmulp st1, st0");
                asm("fld qword [0x80ce9b8]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80ce9b0]");
                asm("faddp st1, st0");
                asm("fldcw word [ebp-0x34]");
                asm("fistp dword [ebp-0x30]");
                asm("fldcw word [ebp-0x32]");
                __eax = _v52;
                h = _v52;
                __eax = h;
                if(h == 0) {
                    h = 1;
                }
                cache = cache->width & 65535;
                if((cache->width & 0xffff) >= 0) {
L27:
                    cache = cache->width & 65535;
                    if((cache->width & 0xffff) >= 0) {
                        cache = cache->height & 65535;
                        if((cache->height & 0xffff) < 0) {
                            cache = cache->width & 65535;
                            _v46 = cache->width & 0xffff;
                            asm("fild word [ebp-0x2a]");
                            __eax = h;
                            _v52 = h;
                            asm("fild dword [ebp-0x30]");
                            asm("fmulp st1, st0");
                            __eax = w;
                            _v52 = w;
                            asm("fild dword [ebp-0x30]");
                            asm("fdivp st1, st0");
                            asm("fld qword [0x80ce9b0]");
                            asm("faddp st1, st0");
                            asm("fldcw word [ebp-0x34]");
                            asm("fistp dword [ebp-0x20]");
                            asm("fldcw word [ebp-0x32]");
                            2048 = tmp - 2048 <= 0 ? tmp : 2048;
                            __edx = tmp - 2048 <= 0 ? tmp : 2048;
                            __eax = cache;
                            cache->height = (tmp - 2048 <= 0 ? tmp : 2048) & 65535;
                        }
                    } else {
                        cache = cache->height & 65535;
                        _v46 = cache->height & 0xffff;
                        asm("fild word [ebp-0x2a]");
                        __eax = w;
                        _v52 = w;
                        asm("fild dword [ebp-0x30]");
                        asm("fmulp st1, st0");
                        __eax = h;
                        _v52 = h;
                        asm("fild dword [ebp-0x30]");
                        asm("fdivp st1, st0");
                        asm("fld qword [0x80ce9b0]");
                        asm("faddp st1, st0");
                        asm("fldcw word [ebp-0x34]");
                        asm("fistp dword [ebp-0x1c]");
                        asm("fldcw word [ebp-0x32]");
                        2048 = tmp - 2048 <= 0 ? tmp : 2048;
                        __edx = tmp - 2048 <= 0 ? tmp : 2048;
                        __eax = cache;
                        cache->width = (tmp - 2048 <= 0 ? tmp : 2048) & 65535;
                    }
L31:
                    cache = cache->width & 65535;
                    if((cache->width & 0xffff) == 0) {
                        __eax = cache;
                        cache->width = 1;
                    }
                    cache = cache->height & 65535;
                    if((cache->height & 0xffff) == 0) {
                        __eax = cache;
                        cache->height = 1;
                    }
                    cache = cache;
                    cache->height & 65535 = cache;
                    __eax = cache->width & 65535;
                    asm("cwde ");
                    _v80 = cache->url;
                    _v84 = cache->height & 0xffff;
                    _v88 = cache->width & 65535;
                    __eax = Sprintf("%d;%d;%s");
                    tmp = cache->width & 65535;
                    tmp = image_hash;
                    putHash_sv(image_hash, tmp->ptr, cache);
                    __eax = 1;
                    return 1;
                }
                cache = cache->height & 65535;
                if((cache->height & 0xffff) >= 0) {
                    goto L27;
                }
                w = w - 2048 > 0 ? 2048 : w;
                __edx = w - 2048 > 0 ? 2048 : w;
                __eax = cache;
                cache->width = (w - 2048 > 0 ? 2048 : w) & 65535;
                h = h - 2048 > 0 ? 2048 : h;
                __edx = h - 2048 > 0 ? 2048 : h;
                __eax = cache;
                cache->height = (h - 2048 > 0 ? 2048 : h) & 65535;
                goto L31;
            }
            goto L19;
        }
        goto L17;
    }
    return 0;
}

encode_symbol(symbol_set* s)
{// addr = 0x0809AE2C  --  defined in 'symbol.c' at line 72
    int i;                                 // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    i = 0;
    while( *(s->item + (i << 2)) != 0) {
        if(( *( *(s->item + (i << 2))) & 0xff) != 0) {
             *(s->item + (i << 2)) =  *(wc_Str_conv(Strnew_charp( *(s->item + (i << 2))), s->ces, InnerCharset));
        }
        i = i + 1;
    }
    s->encode = 1;
    return;
}

char** get_symbol(wc_ces charset, int* width)
{// addr = 0x0809AEC2  --  defined in 'symbol.c' at line 84
    charset_symbol_set* p;   // _cfa_fffffff0
    symbol_set* s;   // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    symbol_set* _t68;   // _t68

    s = 0;
    if(charset != save_charset || save_symbol == 0) {
L4:
        save_charset = charset;
        p =  &charset_symbol_list;
L10:
        while(p->charset != 0) {
            goto L5;
        }
L11:
        if(s == 0) {
            if( *width != 2) {
                _t68 =  &alt_symbol_set;
            } else {
                _t68 =  &alt2_symbol_set;
            }
            s = _t68;
        }
        if(s != save_symbol) {
            if((s->encode & 0xff) == 0) {
                encode_symbol(s);
            }
            save_symbol = s;
        }
         *width = s->width & 0xff;
        return s->item;
    } else {
        if( *width != (save_symbol->width & 0xff)) {
            goto L4;
        } else {
             *width = save_symbol->width & 0xff;
            return save_symbol->item;
        }
    }
L5:
    if(p->charset != charset ||  *width != 0 &&  *width != (p->symbol->width & 0xff)) {
        p = p + 8;
        goto L10;
    }
    s = p->symbol;
    goto L11;
}

char** set_symbol(int width)
{// addr = 0x0809AFC5  --  defined in 'symbol.c' at line 114
    symbol_set* s;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char** _t53;                           // _t53

    s =  &alt_symbol_set;
    if(width != save_width) {
        if(symbol_buf != 0) {
L7:
            i = 0;
L12:
            while(s->item[i] != 0) {
                goto L8;
            }
            save_width = width;
            return symbol_buf;
        }
        goto L3;
L8:
        tmp = Strnew_size(4);
        if(width != 2) {
            wtf_push(tmp, 2048, i + 32);
        } else {
            wtf_push(tmp, 34816, i + 32);
        }
        symbol_buf[i] = tmp->ptr;
        i = i + 1;
        goto L12;
    }
    return symbol_buf;
L3:
    i = 0;
    while(s->item[i] != 0) {
        i = i + 1;
    }
    _t53 = i << 2;
     *__esp = _t53;
    GC_malloc();
    symbol_buf = _t53;
    goto L7;
}

push_symbol(Str str, char symbol, int width, int n)
{// addr = 0x0809B0B9  --  defined in 'symbol.c' at line 150
    char[1] buf;                           // _cfa_fffffff2
    char* p;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    signed char _v56;                      // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t60;                       // _t60

    _v32 = _a8 & 255;
    if(width != 2) {
        p =  *( &alt_symbol + _v32 * 4);
    } else {
        p =  *( &alt2_symbol + _v32 * 4);
    }
    i = 0;
    while(i <= 1 && ( *p & 0xff) != 0) {
        __edx = i;
        if(( *p & 0xff) == 32) {
            _t60 = -96;
        } else {
            _t60 =  *p & 255;
        }
         *(__ebp + __edx - 10) = _t60 & 255;
        i = i + 1;
        p =  &(p[1]);
    }
    _v56 = _v32;
    Strcat(str, Sprintf("<_SYMBOL TYPE=%d>"));
    while(n > 0) {
        Strcat_charp_n(str,  &buf, i);
        n = n - 1;
    }
    Strcat_charp(str, "</_SYMBOL>");
    return;
}

char* conv_entity(unsigned int c)
{// addr = 0x0809B188  --  defined in 'entity.c' at line 35
    char b;                                // _cfa_fffffff3
    wc_uchar[6] utf8;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t30;                        // _t30
    _unknown_ _t33;                        // _t33
    _unknown_ _t46;                        // _t46
    _unknown_ _t47;                        // _t47
    _unknown_ _t51;                        // _t51

    b = c & 255;
    if(c > 31) {
        if(c > 126) {
            if(c > 159) {
                if(c != 160) {
                    if(c > 255) {
                        if(c >= 0) {
                            return 135064828;
                        }
                        goto L13;
                    }
                    goto L9;
L13:
                    wc_ucs_to_utf8(c,  &utf8);
                    return  *(wc_Str_conv(Strnew_charp( &utf8), 3178565, InnerCharset));
                }
                goto L7;
L9:
                if((UseAltEntity & 0xff) == 0) {
                    return  *(wc_Str_conv(Strnew_charp_n( &b, 1), 1049089, InnerCharset));
                }
                return  *( &alt_latin1 + (c - 160) * 4);
            }
            goto L5;
L7:
            return 135064736;
        }
        goto L3;
L5:
        return 135065021;
    }
    return 135065021;
L3:
    return  *(Strnew_charp_n( &b, 1));
}

writestr(char* s)
{// addr = 0x0809B290  --  defined in 'terms.c' at line 459
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _v20 = write1;
    _v24 = 1;
     *__esp = s;
    tputs();
    return;
}

int set_tty()
{// addr = 0x0809B2B3  --  defined in 'terms.c' at line 507
    char* ttyn;                            // _cfa_fffffff0
    struct w3m_term_info* p;   // _cfa_ffffffec
    char* term;                            // _cfa_ffffffe8
    struct w3m_term_info* p;   // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t30;                        // _t30
    _unknown_ _t40;                        // _t40

    if(isatty(0) == 0) {
        ttyn = "/dev/tty";
    } else {
        ttyn = ttyname(0);
    }
    _v40 = 2;
     *__esp = ttyn;
    tty = open();
    if(tty < 0) {
        tty = 2;
    }
    ttyf = fdopen(tty, "w");
    _v40 =  &d_ioval;
     *__esp = tty;
    tcgetattr();
    if(displayTitleTerm != 0) {
        p =  &w3m_term_info_list;
        while(p->term != 0) {
            if(strncmp(displayTitleTerm, p->term, strlen(p->term)) != 0) {
                p = p + 12;
                continue;
            }
            title_str = p->title_str;
            goto L11;
        }
    }
L11:
    term = getenv("TERM");
    if(term == 0) {
    } else {
        p =  &w3m_term_info_list;
        while(p->term != 0) {
            if(strncmp(term, p->term, strlen(p->term)) != 0) {
                p = p + 12;
                continue;
            }
            is_xterm = p->mouse_flag;
            goto L17;
        }
    }
    goto L17;
L18:
L17:
    return 0;
    goto L18;
}

ttymode_set(int mode, int imode)
{// addr = 0x0809B3FC  --  defined in 'terms.c' at line 552
    signed int _v16;                       // _cfa_fffffff0
    signed int _v64;                       // _cfa_ffffffc0
    TerminalMode ioval;   // _cfa_ffffffb4
    unsigned int* _v84;                    // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    int _t24;                              // _t24
    int* _t25;                             // _t25
    int* _t27;                             // _t27
    _unknown_ _t31;                        // _t31
    signed int _t33;                       // _t33

    _v16 =  *gs:0x14];
    _v88 =  &(ioval.c_iflag);
     *__esp = tty;
    tcgetattr();
    _v64 = mode | _v64;
    ioval.c_iflag = imode | ioval.c_iflag;
    while(1) {
        _t24 = tty;
        _v84 =  &(ioval.c_iflag);
        _v88 = 0;
         *__esp = _t24;
        tcsetattr();
        __eflags = _t24 - 255;
        if(__eflags != 0) {
            break;
        } else {
            _t25 = __errno_location();
            __eflags =  *_t25 - 4;
            if( *_t25 != 4) {
                _t27 = __errno_location();
                __eflags =  *_t27 - 11;
                if( *_t27 != 11) {
                    _v84 =  *(__errno_location());
                    _v88 = mode;
                    printf("Error occured while set %x: errno=%d\n");
                    reset_exit(0);
                }
            }
            continue;
        }
    }
    _t33 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t33;
    }
    __stack_chk_fail();
    return _t33;
}

ttymode_reset(int mode, int imode)
{// addr = 0x0809B4B6  --  defined in 'terms.c' at line 573
    signed int _v16;                       // _cfa_fffffff0
    signed int _v64;                       // _cfa_ffffffc0
    TerminalMode ioval;   // _cfa_ffffffb4
    unsigned int* _v84;                    // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    int _t26;                              // _t26
    int* _t27;                             // _t27
    int* _t29;                             // _t29
    _unknown_ _t33;                        // _t33
    signed int _t35;                       // _t35

    _v16 =  *gs:0x14];
    _v88 =  &(ioval.c_iflag);
     *__esp = tty;
    tcgetattr();
    _v64 =  !mode & _v64;
    ioval.c_iflag =  !imode & ioval.c_iflag;
    while(1) {
        _t26 = tty;
        _v84 =  &(ioval.c_iflag);
        _v88 = 0;
         *__esp = _t26;
        tcsetattr();
        __eflags = _t26 - 255;
        if(__eflags != 0) {
            break;
        } else {
            _t27 = __errno_location();
            __eflags =  *_t27 - 4;
            if( *_t27 != 4) {
                _t29 = __errno_location();
                __eflags =  *_t29 - 11;
                if( *_t29 != 11) {
                    _v84 =  *(__errno_location());
                    _v88 = mode;
                    printf("Error occured while reset %x: errno=%d\n");
                    reset_exit(0);
                }
            }
            continue;
        }
    }
    _t35 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t35;
    }
    __stack_chk_fail();
    return _t35;
}

set_cc(int spec, int val)
{// addr = 0x0809B574  --  defined in 'terms.c' at line 595
    signed int _v16;                       // _cfa_fffffff0
    TerminalMode ioval;   // _cfa_ffffffb4
    unsigned int* _v84;                    // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    int _t19;                              // _t19
    int* _t20;                             // _t20
    int* _t22;                             // _t22
    _unknown_ _t26;                        // _t26
    signed int _t28;                       // _t28

    _v16 =  *gs:0x14];
    _v88 =  &(ioval.c_iflag);
     *__esp = tty;
    tcgetattr();
     *(__ebp + spec - 55) = val & 255;
    while(1) {
        _t19 = tty;
        _v84 =  &(ioval.c_iflag);
        _v88 = 0;
         *__esp = _t19;
        tcsetattr();
        __eflags = _t19 - 255;
        if(__eflags != 0) {
            break;
        } else {
            _t20 = __errno_location();
            __eflags =  *_t20 - 4;
            if( *_t20 != 4) {
                _t22 = __errno_location();
                __eflags =  *_t22 - 11;
                if( *_t22 != 11) {
                    _v88 =  *(__errno_location());
                    printf("Error occured: errno=%d\n");
                    reset_exit(0);
                }
            }
            continue;
        }
    }
    _t28 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t28;
    }
    __stack_chk_fail();
    return _t28;
}

close_tty()
{// addr = 0x0809B61B  --  defined in 'terms.c' at line 611
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    if(tty > 2) {
        close(tty);
        return;
    }
    return;
}

char* ttyname_tty()
{// addr = 0x0809B63A  --  defined in 'terms.c' at line 618
    _unknown_ __ebp;                       // r6

    return ttyname(tty);
}

reset_tty()
{// addr = 0x0809B64F  --  defined in 'terms.c' at line 624
    struct termios* _v20;   // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    writestr(T_op);
    writestr(T_me);
    if(Do_not_use_ti_te == 0) {
        if(T_te == 0 || ( *T_te & 0xff) == 0) {
            writestr(T_cl);
        } else {
            writestr(T_te);
        }
    }
    writestr(T_se);
    flush_tty();
    _v20 =  &d_ioval;
    _v24 = 0;
     *__esp = tty;
    tcsetattr();
    close_tty();
    return;
}

reset_exit(int _dummy)
{// addr = 0x0809B6DF  --  defined in 'terms.c' at line 641
    _unknown_ __ebp;                       // r6

    if(mouseActive != 0) {
        mouse_end();
    }
    reset_tty();
    w3m_exit(0);
    return;
}

error_dump(int _dummy)
{// addr = 0x0809B706  --  defined in 'terms.c' at line 653
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21

    mySignal(6, 0);
    reset_tty();
    abort();
    _push(_t20);
    __esp = __esp - 24;
    mySignal(1, reset_exit);
    mySignal(2, reset_exit);
    mySignal(3, reset_exit);
    mySignal(15, reset_exit);
    mySignal(4, error_dump);
    mySignal(6, error_dump);
    mySignal(8, error_dump);
    mySignal(7, error_dump);
    return;
}

set_int()
{// addr = 0x0809B72A  --  defined in 'terms.c' at line 662
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    mySignal(1, reset_exit);
    mySignal(2, reset_exit);
    mySignal(3, reset_exit);
    mySignal(15, reset_exit);
    mySignal(4, error_dump);
    mySignal(6, error_dump);
    mySignal(8, error_dump);
    mySignal(7, error_dump);
    return;
}

setgraphchar()
{// addr = 0x0809B7D2  --  defined in 'terms.c' at line 679
    int c;                                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    c = 0;
    while(c <= 95) {
         *( &gcmap + c) = c + 32 & 255;
        c = c + 1;
    }
    if(T_ac != 0) {
        n = strlen(T_ac);
        i = 0;
        while(n - 1 > i) {
            c = (T_ac[i] & 0xff) - 32;
            if(c < 0 && c <= 95) {
                 *( &gcmap + c) = T_ac[i + 1] & 0xff;
            }
            i = i + 2;
        }
        return;
    }
    return;
}

getTCstr()
{// addr = 0x0809B86E  --  defined in 'terms.c' at line 701
    char* ent;                             // _cfa_fffffff0
    char* suc;                             // _cfa_ffffffec
    char* pt;                              // _cfa_ffffffe8
    int r;                                 // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t220;                       // _t220
    char* _t222;                           // _t222
    int _t223;                             // _t223
    char* _t225;                           // _t225
    char* _t229;                           // _t229
    char* _t233;                           // _t233
    char* _t236;                           // _t236
    char* _t240;                           // _t240
    char* _t244;                           // _t244
    char* _t248;                           // _t248
    char* _t252;                           // _t252
    char* _t256;                           // _t256
    char* _t260;                           // _t260
    char* _t264;                           // _t264
    char* _t268;                           // _t268
    char* _t272;                           // _t272
    char* _t276;                           // _t276
    char* _t280;                           // _t280
    char* _t284;                           // _t284
    char* _t288;                           // _t288
    char* _t292;                           // _t292
    char* _t296;                           // _t296
    char* _t300;                           // _t300
    char* _t304;                           // _t304
    char* _t308;                           // _t308
    char* _t312;                           // _t312
    char* _t316;                           // _t316
    char* _t320;                           // _t320
    char* _t324;                           // _t324
    char* _t329;                           // _t329
    char* _t333;                           // _t333
    _unknown_ _t339;                       // _t339
    _unknown_ _t342;                       // _t342

    pt =  &funcstr;
    if(getenv("TERM") == 0) {
        _t222 = 0;
    } else {
        _t222 = getenv("TERM");
    }
    ent = _t222;
    if(ent == 0) {
        fwrite("TERM is not set\n", 1, 16, __imp__stderr);
        reset_exit(0);
    }
    _t223 = ent;
    _v40 = _t223;
     *__esp =  &bp;
    tgetent();
    r = _t223;
    if(r != 1) {
        _v36 = ent;
        fprintf(__imp__stderr, "Can't find termcap entry %s\n");
        reset_exit(0);
    }
    T_ce = pt;
    _t225 =  &pt;
    _v40 = _t225;
     *__esp = "ce";
    tgetstr();
    suc = _t225;
    if(suc != 0) {
        T_ce = allocStr(suc, -1);
    } else {
        T_ce = 135065234;
    }
    T_cd = pt;
    _t229 =  &pt;
    _v40 = _t229;
     *__esp = "cd";
    tgetstr();
    suc = _t229;
    if(suc != 0) {
        T_cd = allocStr(suc, -1);
    } else {
        T_cd = 135065234;
    }
    T_kr = pt;
    _t233 =  &pt;
    _v40 = _t233;
     *__esp = "nd";
    tgetstr();
    suc = _t233;
    if(suc != 0) {
        _t233 = allocStr(suc, -1);
        T_kr = _t233;
    } else {
        T_kr = 135065234;
    }
    if(suc == 0) {
        T_kr = pt;
        _t233 =  &pt;
        _v40 = _t233;
         *__esp = "kr";
        tgetstr();
        suc = _t233;
        if(suc != 0) {
            _t233 = allocStr(suc, -1);
            T_kr = _t233;
        } else {
            T_kr = 135065234;
        }
    }
     *__esp = "bs";
    tgetflag();
    if(_t233 == 0) {
        T_kl = pt;
        _t236 =  &pt;
        _v40 = _t236;
         *__esp = 135065249;
        tgetstr();
        suc = _t236;
        if(suc != 0) {
            T_kl = allocStr(suc, -1);
        } else {
            T_kl = 135065234;
        }
        if(suc == 0) {
            T_kl = pt;
            _t333 =  &pt;
            _v40 = _t333;
             *__esp = 135065252;
            tgetstr();
            suc = _t333;
            if(suc != 0) {
                T_kl = allocStr(suc, -1);
            } else {
                T_kl = 135065234;
            }
        }
        if(suc == 0) {
            T_kl = pt;
            _t329 =  &pt;
            _v40 = _t329;
             *__esp = 135065255;
            tgetstr();
            suc = _t329;
            if(suc != 0) {
                T_kl = allocStr(suc, -1);
            } else {
                T_kl = 135065234;
            }
        }
    } else {
        T_kl = 135065247;
    }
    T_cr = pt;
    _t240 =  &pt;
    _v40 = _t240;
     *__esp = 135065258;
    tgetstr();
    suc = _t240;
    if(suc != 0) {
        T_cr = allocStr(suc, -1);
    } else {
        T_cr = 135065234;
    }
    T_ta = pt;
    _t244 =  &pt;
    _v40 = _t244;
     *__esp = 135065261;
    tgetstr();
    suc = _t244;
    if(suc != 0) {
        T_ta = allocStr(suc, -1);
    } else {
        T_ta = 135065234;
    }
    T_sc = pt;
    _t248 =  &pt;
    _v40 = _t248;
     *__esp = 135065264;
    tgetstr();
    suc = _t248;
    if(suc != 0) {
        T_sc = allocStr(suc, -1);
    } else {
        T_sc = 135065234;
    }
    T_rc = pt;
    _t252 =  &pt;
    _v40 = _t252;
     *__esp = 135065267;
    tgetstr();
    suc = _t252;
    if(suc != 0) {
        T_rc = allocStr(suc, -1);
    } else {
        T_rc = 135065234;
    }
    T_so = pt;
    _t256 =  &pt;
    _v40 = _t256;
     *__esp = 135065270;
    tgetstr();
    suc = _t256;
    if(suc != 0) {
        T_so = allocStr(suc, -1);
    } else {
        T_so = 135065234;
    }
    T_se = pt;
    _t260 =  &pt;
    _v40 = _t260;
     *__esp = 135065273;
    tgetstr();
    suc = _t260;
    if(suc != 0) {
        T_se = allocStr(suc, -1);
    } else {
        T_se = 135065234;
    }
    T_us = pt;
    _t264 =  &pt;
    _v40 = _t264;
     *__esp = 135065276;
    tgetstr();
    suc = _t264;
    if(suc != 0) {
        T_us = allocStr(suc, -1);
    } else {
        T_us = 135065234;
    }
    T_ue = pt;
    _t268 =  &pt;
    _v40 = _t268;
     *__esp = 135065279;
    tgetstr();
    suc = _t268;
    if(suc != 0) {
        T_ue = allocStr(suc, -1);
    } else {
        T_ue = 135065234;
    }
    T_md = pt;
    _t272 =  &pt;
    _v40 = _t272;
     *__esp = 135065282;
    tgetstr();
    suc = _t272;
    if(suc != 0) {
        T_md = allocStr(suc, -1);
    } else {
        T_md = 135065234;
    }
    T_me = pt;
    _t276 =  &pt;
    _v40 = _t276;
     *__esp = 135065285;
    tgetstr();
    suc = _t276;
    if(suc != 0) {
        T_me = allocStr(suc, -1);
    } else {
        T_me = 135065234;
    }
    T_cl = pt;
    _t280 =  &pt;
    _v40 = _t280;
     *__esp = 135065288;
    tgetstr();
    suc = _t280;
    if(suc != 0) {
        T_cl = allocStr(suc, -1);
    } else {
        T_cl = 135065234;
    }
    T_cm = pt;
    _t284 =  &pt;
    _v40 = _t284;
     *__esp = 135065291;
    tgetstr();
    suc = _t284;
    if(suc != 0) {
        T_cm = allocStr(suc, -1);
    } else {
        T_cm = 135065234;
    }
    T_al = pt;
    _t288 =  &pt;
    _v40 = _t288;
     *__esp = 135065294;
    tgetstr();
    suc = _t288;
    if(suc != 0) {
        T_al = allocStr(suc, -1);
    } else {
        T_al = 135065234;
    }
    T_sr = pt;
    _t292 =  &pt;
    _v40 = _t292;
     *__esp = 135065297;
    tgetstr();
    suc = _t292;
    if(suc != 0) {
        T_sr = allocStr(suc, -1);
    } else {
        T_sr = 135065234;
    }
    T_ti = pt;
    _t296 =  &pt;
    _v40 = _t296;
     *__esp = 135065300;
    tgetstr();
    suc = _t296;
    if(suc != 0) {
        T_ti = allocStr(suc, -1);
    } else {
        T_ti = 135065234;
    }
    T_te = pt;
    _t300 =  &pt;
    _v40 = _t300;
     *__esp = 135065303;
    tgetstr();
    suc = _t300;
    if(suc != 0) {
        T_te = allocStr(suc, -1);
    } else {
        T_te = 135065234;
    }
    T_nd = pt;
    _t304 =  &pt;
    _v40 = _t304;
     *__esp = "nd";
    tgetstr();
    suc = _t304;
    if(suc != 0) {
        T_nd = allocStr(suc, -1);
    } else {
        T_nd = 135065234;
    }
    T_eA = pt;
    _t308 =  &pt;
    _v40 = _t308;
     *__esp = 135065306;
    tgetstr();
    suc = _t308;
    if(suc != 0) {
        T_eA = allocStr(suc, -1);
    } else {
        T_eA = 135065234;
    }
    T_as = pt;
    _t312 =  &pt;
    _v40 = _t312;
     *__esp = 135065309;
    tgetstr();
    suc = _t312;
    if(suc != 0) {
        T_as = allocStr(suc, -1);
    } else {
        T_as = 135065234;
    }
    T_ae = pt;
    _t316 =  &pt;
    _v40 = _t316;
     *__esp = 135065312;
    tgetstr();
    suc = _t316;
    if(suc != 0) {
        T_ae = allocStr(suc, -1);
    } else {
        T_ae = 135065234;
    }
    T_ac = pt;
    _t320 =  &pt;
    _v40 = _t320;
     *__esp = 135065315;
    tgetstr();
    suc = _t320;
    if(suc != 0) {
        T_ac = allocStr(suc, -1);
    } else {
        T_ac = 135065234;
    }
    T_op = pt;
    _t324 =  &pt;
    _v40 = _t324;
     *__esp = 135065318;
    tgetstr();
    suc = _t324;
    if(suc != 0) {
        T_op = allocStr(suc, -1);
    } else {
        T_op = 135065234;
    }
    COLS = 0;
    LINES = COLS;
    setlinescols();
    setgraphchar();
    return;
}

setlinescols()
{// addr = 0x0809C199  --  defined in 'terms.c' at line 777
    char* p;                               // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    struct winsize wins;   // _cfa_ffffffe4
    short unsigned int* _v36;              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t30;                              // _t30
    int _t33;                              // _t33
    int _t34;                              // _t34

    _t30 = tty;
    _v36 =  &(wins.ws_row);
    _v40 = 21523;
     *__esp = _t30;
    ioctl();
    i = _t30;
    if(i < 0 && (wins.ws_row & 0xffff) != 0 && (_v26 & 0xffff) != 0) {
        LINES = wins.ws_row & 0xffff;
        COLS = wins.ws_col & 0xffff;
    }
    if(LINES <= 0) {
        p = getenv(135065321);
        if(p != 0) {
            i = atoi(p);
            if(i < 0) {
                LINES = i;
            }
        }
    }
    if(COLS <= 0) {
        p = getenv("COLUMNS");
        if(p != 0) {
            i = atoi(p);
            if(i < 0) {
                COLS = i;
            }
        }
    }
    _t33 = LINES;
    if(_t33 <= 0) {
         *__esp = "li";
        tgetnum();
        LINES = _t33;
    }
    _t34 = COLS;
    if(_t34 <= 0) {
         *__esp = "co";
        tgetnum();
        COLS = _t34;
    }
    if(COLS > 400) {
        COLS = 400;
    }
    if(LINES > 200) {
        LINES = 200;
        return;
    }
    return;
}

setupscreen()
{// addr = 0x0809C2C4  --  defined in 'terms.c' at line 823
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t67;                       // _t67
    _unknown_ _t75;                        // _t75
    Screen** _t81;      // _t81
    Screen* _t88;       // _t88
    Screen** _t90;      // _t90

    if(LINES + 1 > max_LINES) {
        max_LINES = LINES + 1;
        max_COLS = 0;
        _t88 = max_LINES + max_LINES + _t113 << 2;
         *__esp = _t88;
        GC_malloc();
        ScreenElem = _t88;
        _t90 = max_LINES << 2;
         *__esp = _t90;
        GC_malloc();
        ScreenImage = _t90;
    }
    if(COLS + 1 > max_COLS) {
        max_COLS = COLS + 1;
        i = 0;
        while(i < max_LINES) {
            _t110 = i;
            _t67 = max_COLS << 2;
             *__esp = _t67;
            GC_malloc();
             *(ScreenElem + (i + _t110 + _t110 << 2)) = _t67;
            bzero( *(ScreenElem + (i + i + _t111 << 2)), 0 + max_COLS * 4);
            _t112 = i;
            _t81 = max_COLS + max_COLS;
             *__esp = _t81;
            GC_malloc();
             *(ScreenElem + (i + _t112 + _t112 << 2) + 4) = _t81;
            i = i + 1;
        }
    }
    i = 0;
L8:
    while(i < LINES) {
        ScreenImage[i] = ScreenElem + (i + i + _t104 << 2);
         *(ScreenImage[i]->lineprop) = 8;
        ScreenImage[i]->isdirty = 0;
        i = i + 1;
    }
    while(i < max_LINES) {
         *((short*)(ScreenElem + (i + i + _t109 << 2) + 8)) = 2;
        i = i + 1;
    }
    clear();
    return;
    goto L8;
}

int initscr()
{// addr = 0x0809C480  --  defined in 'terms.c' at line 861
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t4;                         // _t4
    _unknown_ _t7;                         // _t7

    if(set_tty() >= 0) {
        set_int();
        getTCstr();
        if(T_ti != 0 && Do_not_use_ti_te == 0) {
            writestr(T_ti);
        }
        setupscreen();
        return 0;
    }
    return -1;
}

int write1(char c)
{// addr = 0x0809C4CB  --  defined in 'terms.c' at line 874
    signed int _v16;                       // _cfa_fffffff0
    FILE* _v40;           // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9

    _v16 = _a4 & 255;
    _v40 = ttyf;
     *__esp = _v16;
    _IO_putc();
    return 0;
}

move(int line, int column)
{// addr = 0x0809C4F4  --  defined in 'terms.c' at line 884
    _unknown_ __ebp;                       // r6

    if(line < 0 && line < LINES) {
        CurLine = line;
    }
    if(column >= 0 || column >= COLS) {
        return;
    } else {
        CurColumn = column;
        return;
    }
}

int need_redraw(char* c1, l_prop pr1, char* c2, l_prop pr2)
{// addr = 0x0809C529  --  defined in 'terms.c' at line 900
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    _unknown_ _t35;                        // _t35
    _unknown_ _t36;                        // _t36

    _v16 = _a8 & 65535;
    _v20 = _a16 & 65535;
    if(c1 == 0 || c2 == 0 || strcmp(c1, c2) != 0) {
        return 1;
    }
    if(( *c1 & 0xff) != 32) {
        if(((_v20 & 65535 ^ _v16 & 65535) & 0xdf) == 0) {
            return 0;
        }
        goto L7;
    }
    return (_v20 & 65535 ^ _v16 & 65535) & 0xff1f;
L7:
    return 1;
}

addch(char c)
{// addr = 0x0809C5A6  --  defined in 'terms.c' at line 930
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v16 = _a4 & 255;
    addmch( &_v16, 1);
    return;
}

addmch(char* pc, size_t len)
{// addr = 0x0809C5C7  --  defined in 'terms.c' at line 936
    char c;                                // _cfa_fffffff3
    l_prop l;           // _cfa_fffffff0
    l_prop* pr;         // _cfa_ffffffec
    int dest;                              // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    short int* dirty;                      // _cfa_ffffffe0
    char** p;                              // _cfa_ffffffdc
    int width;                             // _cfa_ffffffd8
    int _v48;                              // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t385;                             // _t385
    char* _t459;                           // _t459
    _unknown_ _t464;                       // _t464
    char* _t502;                           // _t502
    _unknown_ _t507;                       // _t507
    char* _t527;                           // _t527
    _unknown_ _t532;                       // _t532
    char* _t554;                           // _t554
    _unknown_ _t559;                       // _t559
    char* _t580;                           // _t580
    _unknown_ _t585;                       // _t585
    char* _t602;                           // _t602
    _unknown_ _t607;                       // _t607
    char* _t663;                           // _t663
    _unknown_ _t668;                       // _t668
    char* _t707;                           // _t707
    _unknown_ _t712;                       // _t712
    _unknown_ _t774;                       // _t774
    _unknown_ _t775;                       // _t775

    c =  *pc & 0xff;
    if(( *135119023 & 0xff) == 0) {
        _t385 =  *( &WTF_WIDTH_MAP + ( *pc & 0xff)) & 0xff;
    } else {
        _t385 =  *( &WTF_WIDTH_MAP + ( *pc & 0xff)) & 0xff;
    }
    width = _t385;
    if(tmp.8815 == 0) {
        tmp.8815 = Strnew();
    }
    Strcopy_charp_n(tmp.8815, pc, len);
    pc =  *tmp.8815;
    if(CurColumn == COLS) {
        wrap();
    }
    if(CurColumn >= COLS) {
        return;
    }
    p =  *(ScreenImage[CurLine]);
    pr = ScreenImage[CurLine]->lineprop;
    dirty =  &(ScreenImage[CurLine]->isdirty);
    if(( *(CurColumn + CurColumn + pr) & 8) == 0) {
L16:
        if(c == 9 || c == 10 || c == 13 || c == 8) {
            CurrentMode = CurrentMode & 0xffff;
L25:
            i = CurColumn + width - 1;
            if(i >= COLS) {
L37:
                if(CurColumn + width <= COLS) {
L43:
                    if(( *(CurColumn + CurColumn + pr) & 0xc0) != 128) {
L50:
                        if((CurrentMode & 0xc0) == 192) {
L60:
                            if(c != 9) {
                                if(c != 10) {
                                    if(c != 13) {
                                        if(c != 8 || CurColumn <= 0) {
L83:
                                            return;
                                        } else {
                                            CurColumn = CurColumn - 1;
                                            while(CurColumn > 0) {
                                                if(( *(CurColumn + CurColumn + pr) & 0xc0) == 128) {
                                                    CurColumn = CurColumn - 1;
                                                    continue;
                                                }
                                                return;
                                            }
                                            goto L83;
                                        }
                                    }
                                    goto L72;
                                }
                                goto L70;
L72:
                                CurColumn = 0;
                                return;
                            }
                            goto L61;
L70:
                            wrap();
                            return;
                        }
                        goto L51;
L61:
                        _v48 = tab_step;
                        dest = tab_step * (CurColumn + tab_step) / _v48;
                        if(dest >= COLS) {
                            wrap();
                            touch_line();
                            dest = tab_step;
                            p =  *(ScreenImage[CurLine]);
                            pr = ScreenImage[CurLine]->lineprop;
                        }
                        i = CurColumn;
                        while(i < dest) {
                            if(need_redraw(p[i],  *(i + i + pr) & 0xffff, " ", CurrentMode & 0xffff) != 0) {
                                _t459 = p[i];
                                _v72 = 2;
                                 *__esp = _t459;
                                GC_realloc();
                                p[i] = _t459;
                                memcpy(p[i], " ", 1);
                                p[i][0] = 0;
                                 *(i + i + pr) = (CurrentMode & 65535 |  *(i + i + pr) & 0x20) & 65535;
                                touch_line();
                                touch_column(i);
                            }
                            i = i + 1;
                        }
                        CurColumn = i;
                        return;
                    }
                    goto L44;
L51:
                    if(need_redraw(p[CurColumn],  *(CurColumn + CurColumn + pr) & 0xffff, pc, CurrentMode & 0xffff) == 0) {
L59:
                        CurColumn = CurColumn + width;
                        return;
                    }
                    _t502 = p[CurColumn];
                    _v72 = len + 1;
                     *__esp = _t502;
                    GC_realloc();
                    p[CurColumn] = _t502;
                    strncpy(p[CurColumn], pc, len);
                    p[CurColumn][len] = 0;
                     *(CurColumn + CurColumn + pr) = (CurrentMode & 65535 |  *(CurColumn + CurColumn + pr) & 0x20) & 65535;
                    touch_line();
                    touch_column(CurColumn);
                    CurrentMode = CurrentMode & 0xffff;
                    i = CurColumn + 1;
                    while(CurColumn + width > i) {
                        _t527 = p[i];
                        _v72 = 2;
                         *__esp = _t527;
                        GC_realloc();
                        p[i] = _t527;
                        memcpy(p[i], " ", 1);
                        p[i][0] = 0;
                         *(i + i + pr) = ( *(CurColumn + CurColumn + pr) & 65535 |  *(i + i + pr) & 0x20) & 65535;
                        touch_column(i);
                        i = i + 1;
                    }
                    while(i < COLS && ( *(i + i + pr) & 0xc0) == 128) {
                        _t554 = p[i];
                        _v72 = 2;
                         *__esp = _t554;
                        GC_realloc();
                        p[i] = _t554;
                        memcpy(p[i], " ", 1);
                        p[i][0] = 0;
                         *(i + i + pr) =  *(i + i + pr) & 0xffff;
                        touch_column(i);
                        i = i + 1;
                    }
                    goto L59;
                }
                goto L38;
L44:
                touch_line();
                i = CurColumn - 1;
                while(i >= 0) {
                    l =  *(i + i + pr) & 0xffff;
                    _t580 = p[i];
                    _v72 = 2;
                     *__esp = _t580;
                    GC_realloc();
                    p[i] = _t580;
                    memcpy(p[i], " ", 1);
                    p[i][0] = 0;
                     *(i + i + pr) =  *(i + i + pr) & 0xffff;
                    touch_column(i);
                    if(l != 128) {
                        goto L50;
                    }
                    i = i - 1;
                }
                goto L50;
            }
            if(( *(i + i + pr) & 4) == 0 || need_redraw(p[i],  *(i + i + pr) & 0xffff, pc, CurrentMode & 0xffff) == 0) {
                if(( *(i + i + pr) & 2) == 0 || (CurrentMode & 2) != 0) {
                    goto L37;
                } else {
                    goto L30;
                }
                goto L38;
            }
L30:
            touch_line();
            i = i + 1;
            if(i >= COLS) {
                goto L37;
            }
            touch_column(i);
            if(( *(i + i + pr) & 8) == 0) {
                i = i + 1;
L35:
                while(i < COLS && ( *(i + i + pr) & 0xc0) == 128) {
                    goto L34;
                }
                goto L37;
            }
            _t663 = p[i];
            _v72 = 2;
             *__esp = _t663;
            GC_realloc();
            p[i] = _t663;
            memcpy(p[i], " ", 1);
            p[i][0] = 0;
             *(i + i + pr) =  *(i + i + pr) & 0x20;
            goto L37;
L34:
            touch_column(i);
            i = i + 1;
            goto L35;
L38:
            touch_line();
            i = CurColumn;
            while(i < COLS) {
                _t602 = p[i];
                _v72 = 2;
                 *__esp = _t602;
                GC_realloc();
                p[i] = _t602;
                memcpy(p[i], " ", 1);
                p[i][0] = 0;
                 *(i + i + pr) =  *(i + i + pr) & 0xffff;
                touch_column(i);
                i = i + 1;
            }
            wrap();
            if(CurColumn + width > COLS) {
L82:
                goto L83;
            }
            p =  *(ScreenImage[CurLine]);
            pr = ScreenImage[CurLine]->lineprop;
            goto L43;
        }
        if(len <= 1) {
            if(( *( &MYCTYPE_MAP + (c & 0xff)) & 1) != 0) {
                goto L81;
            }
            goto L24;
        }
        CurrentMode = (CurrentMode & 65535 | 64) & 65535;
        goto L25;
L24:
        CurrentMode = CurrentMode & 0xffff;
        goto L25;
    }
    if(c != 32) {
L12:
        i = CurColumn;
L14:
        while(i < 0) {
L15:
            if(( *(i + i + pr) & 8) != 0) {
                _t707 = p[i];
                _v72 = 2;
                 *__esp = _t707;
                GC_realloc();
                p[i] = _t707;
                memcpy(p[i], " ", 1);
                p[i][0] = 0;
                 *(i + i + pr) =  *(i + i + pr) & 0x20;
                i = i - 1;
                goto L14;
            }
            goto L16;
        }
        goto L16;
    } else {
        if((CurrentMode & 0xff1f) != 0) {
            goto L12;
        } else {
            CurColumn = CurColumn + 1;
            return;
        }
    }
L81:
    return;
}

wrap()
{// addr = 0x0809D009  --  defined in 'terms.c' at line 1110
    _unknown_ __ebp;                       // r6

    if(LINES - 1 != CurLine) {
        CurLine = CurLine + 1;
        CurColumn = 0;
        return;
    }
    return;
}

touch_column(int col)
{// addr = 0x0809D039  --  defined in 'terms.c' at line 1119
    _unknown_ __ebp;                       // r6

    if(col >= 0 || col >= COLS) {
        return;
    } else {
         *(ScreenImage[CurLine]->lineprop + col + col) = ( *(ScreenImage[CurLine]->lineprop + col + col) & 65535 | 32) & 65535;
        return;
    }
}

touch_line()
{// addr = 0x0809D090  --  defined in 'terms.c' at line 1126
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    asm("cwde ");
    if((ScreenImage[CurLine]->isdirty & 1) == 0) {
        i = 0;
        while(i < COLS) {
             *(ScreenImage[CurLine]->lineprop + i + i) =  *(ScreenImage[CurLine]->lineprop + i + i) & 0xdf;
            i = i + 1;
        }
        ScreenImage[CurLine]->isdirty = (ScreenImage[CurLine]->isdirty & 65535 | 1) & 65535;
        return;
    }
    return;
}

standout()
{// addr = 0x0809D143  --  defined in 'terms.c' at line 1138
    _unknown_ __ebp;                       // r6

    CurrentMode = (CurrentMode & 65535 | 1) & 65535;
    return;
}

standend()
{// addr = 0x0809D158  --  defined in 'terms.c' at line 1144
    _unknown_ __ebp;                       // r6

    CurrentMode = CurrentMode & 0xfe;
    return;
}

toggle_stand()
{// addr = 0x0809D16D  --  defined in 'terms.c' at line 1150
    int i;                                 // _cfa_fffffff8
    l_prop* pr;         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    pr = ScreenImage[CurLine]->lineprop;
     *(CurColumn + CurColumn + pr) = ( *(CurColumn + CurColumn + pr) & 65535 ^ 1) & 65535;
    if(( *(CurColumn + CurColumn + pr) & 0xc0) != 128) {
        i = CurColumn + 1;
        while(( *(i + i + pr) & 0xc0) == 128) {
             *(i + i + pr) = ( *(i + i + pr) & 65535 ^ 1) & 65535;
            i = i + 1;
        }
    }
    return;
}

bold()
{// addr = 0x0809D20B  --  defined in 'terms.c' at line 1166
    _unknown_ __ebp;                       // r6

    CurrentMode = (CurrentMode & 65535 | 4) & 65535;
    return;
}

boldend()
{// addr = 0x0809D220  --  defined in 'terms.c' at line 1172
    _unknown_ __ebp;                       // r6

    CurrentMode = CurrentMode & 0xfb;
    return;
}

underline()
{// addr = 0x0809D235  --  defined in 'terms.c' at line 1178
    _unknown_ __ebp;                       // r6

    CurrentMode = (CurrentMode & 65535 | 2) & 65535;
    return;
}

underlineend()
{// addr = 0x0809D24A  --  defined in 'terms.c' at line 1184
    _unknown_ __ebp;                       // r6

    CurrentMode = CurrentMode & 0xfd;
    return;
}

graphstart()
{// addr = 0x0809D25F  --  defined in 'terms.c' at line 1190
    _unknown_ __ebp;                       // r6

    CurrentMode = (CurrentMode & 65535 | 16) & 65535;
    return;
}

graphend()
{// addr = 0x0809D274  --  defined in 'terms.c' at line 1196
    _unknown_ __ebp;                       // r6

    CurrentMode = CurrentMode & 0xef;
    return;
}

int graph_ok()
{// addr = 0x0809D289  --  defined in 'terms.c' at line 1202
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    if((UseGraphicChar & 0xff) == 0) {
        return 0;
    }
    if(( *T_as & 0xff) == 0 || ( *T_ae & 0xff) == 0 || ( *T_ac & 0xff) == 0) {
        return 0;
    }
    return 1;
}

setfcolor(int color)
{// addr = 0x0809D2D0  --  defined in 'terms.c' at line 1210
    _unknown_ __ebp;                       // r6

    CurrentMode = CurrentMode & 0xffff;
    if((color & 15) <= 7) {
        CurrentMode = (CurrentMode & 65535 | (color & 7 | 8) << 8) & 65535;
        return;
    }
    return;
}

char* color_seq(int colmode)
{// addr = 0x0809D30D  --  defined in 'terms.c' at line 1218
    intOrPtr _v20;                         // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9

    _v20 = (colmode >> 8 & 7) + 30;
    sprintf( &seqbuf, 135065343);
    return  &seqbuf;
}

setbcolor(int color)
{// addr = 0x0809D33F  --  defined in 'terms.c' at line 1227
    _unknown_ __ebp;                       // r6

    CurrentMode = CurrentMode & 0xffff;
    if((color & 15) <= 7) {
        CurrentMode = (CurrentMode & 65535 | (color & 7 | 8) << 12) & 65535;
        return;
    }
    return;
}

char* bcolor_seq(int colmode)
{// addr = 0x0809D37D  --  defined in 'terms.c' at line 1235
    intOrPtr _v20;                         // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9

    _v20 = (colmode >> 12 & 7) + 40;
    sprintf( &seqbuf.9632, 135065343);
    return  &seqbuf.9632;
}

refresh()
{// addr = 0x0809D3AF  --  defined in 'terms.c' at line 1252
    l_prop mode;        // _cfa_fffffff2
    l_prop color;       // _cfa_fffffff0
    l_prop bcolor;      // _cfa_ffffffee
    int line;                              // _cfa_ffffffe8
    int col;                               // _cfa_ffffffe4
    int pcol;                              // _cfa_ffffffe0
    int pline;                             // _cfa_ffffffdc
    int moved;                             // _cfa_ffffffd8
    char** pc;                             // _cfa_ffffffd4
    l_prop* pr;         // _cfa_ffffffd0
    short int* dirty;                      // _cfa_ffffffcc
    _unknown_ _v64;                        // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    char* _t357;                           // _t357
    int _t414;                             // _t414
    char _t482;                            // _t482
    _unknown_ _t483;                       // _t483
    char* _t542;                           // _t542
    char* _t590;                           // _t590
    int _t593;                             // _t593
    _unknown_ _t594;                       // _t594
    _unknown_ _t595;                       // _t595
    char* _t596;                           // _t596
    char* _t635;                           // _t635

    pline = CurLine;
    moved = 0;
    mode = 0;
    color = 0;
    bcolor = 0;
    wc_putc_init(InnerCharset, DisplayCharset);
    line = 0;
    while(LINES - 1 >= line) {
        dirty =  &(ScreenImage[line]->isdirty);
        asm("cwde ");
        if(( *dirty & 1) == 0) {
L102:
             *dirty =  *dirty & 0xf3;
            if((mode & 0xff17) != 0) {
                if((mode & 0xff00) != 0) {
                    writestr(T_op);
                }
                if((mode & 0x10) != 0) {
                    writestr(T_ae);
                    wc_putc_clear_status();
                }
                writestr(T_me);
                mode = mode & 232;
            }
            line = line + 1;
            continue;
        } else {
             *dirty =  *dirty & 0xfe;
            pc =  *(ScreenImage[line]);
            pr = ScreenImage[line]->lineprop;
            col = 0;
            while(col < COLS && ( *(col + col + pr) & 8) == 0) {
                asm("cwde ");
                if(( *dirty & 4) == 0) {
L7:
                    if(( *(col + col + pr) & 0x20) != 0) {
                        break;
                    } else {
                    }
L10:
                    col = col + 1;
                    continue;
                }
                asm("cwde ");
                if((ScreenImage[line]->eol & 65535) > col) {
                    goto L7;
                }
                if(need_redraw(pc[col],  *(col + col + pr) & 0xffff, " ", 0) == 0) {
                    goto L10;
                } else {
                    break;
                }
            }
            asm("cwde ");
            if(( *dirty & 0xc) == 0) {
                pcol = col;
            } else {
                asm("cwde ");
                pcol = ScreenImage[line]->eol & 65535;
                if(pcol >= COLS) {
                     *dirty =  *dirty & 0xf3;
                    pcol = col;
                }
            }
            if(LINES - 2 <= line || line - 1 != pline || pcol != 0) {
                _t357 = T_cm;
                _v68 = line;
                _v72 = pcol;
                 *__esp = _t357;
                tgoto();
                writestr(_t357);
                moved = 1;
L31:
                asm("cwde ");
                if(( *dirty & 0xc) != 0) {
L32:
                    writestr(T_ce);
                    if(col != pcol) {
                        _t590 = T_cm;
                        _v68 = line;
                        _v72 = col;
                         *__esp = _t590;
                        tgoto();
                        writestr(_t590);
                    }
                }
                pline = line;
                pcol = col;
                while(col < COLS) {
                    if(( *(col + col + pr) & 8) != 0) {
                        goto L96;
                    }
                    if(( *(col + col + pr) & 1) != 0 || (mode & 1) == 0) {
                        if(( *(col + col + pr) & 2) != 0 || (mode & 2) == 0) {
                            if(( *(col + col + pr) & 4) != 0 || (mode & 4) == 0) {
                                if(( *(col + col + pr) & 0xf00) != 0 || (mode & 0xf00) == 0) {
                                    if(( *(col + col + pr) & 0xf000) != 0 || (mode & 0xf000) == 0) {
                                        if(( *(col + col + pr) & 0x10) != 0 || (mode & 0x10) == 0) {
L54:
                                            asm("cwde ");
                                            if(( *dirty & 4) == 0) {
L57:
                                                _t414 =  *(col + col + pr) & 0x20;
                                                goto L58;
                                            }
                                            goto L55;
L58:
                                            if((_t414 & 255) != 0) {
                                                if(col - 1 != pcol) {
                                                    if(pcol != col) {
                                                        _t542 = T_cm;
                                                        _v68 = line;
                                                        _v72 = col;
                                                         *__esp = _t542;
                                                        tgoto();
                                                        writestr(_t542);
                                                    }
                                                } else {
                                                    writestr(T_nd);
                                                }
                                                if(( *(col + col + pr) & 1) != 0 && (mode & 1) == 0) {
                                                    writestr(T_so);
                                                    mode = mode | 1;
                                                }
                                                if(( *(col + col + pr) & 2) != 0 && (mode & 2) == 0) {
                                                    writestr(T_us);
                                                    mode = mode | 2;
                                                }
                                                if(( *(col + col + pr) & 4) != 0 && (mode & 4) == 0) {
                                                    writestr(T_md);
                                                    mode = mode | 4;
                                                }
                                                if(( *(col + col + pr) & 0xf00) != 0 && ( *(col + col + pr) & 0xf00) != 0) {
                                                    color =  *(col + col + pr) & 0xffff;
                                                    mode = (color & 65535 | mode & 65535) & 65535;
                                                    writestr(color_seq(color & 65535));
                                                }
                                                if(( *(col + col + pr) & 0xf000) != 0 && ( *(col + col + pr) & 0xf000) != 0) {
                                                    bcolor =  *(col + col + pr) & 0xffff;
                                                    mode = (bcolor & 65535 | mode & 65535) & 65535;
                                                    writestr(bcolor_seq(bcolor & 65535));
                                                }
                                                if(( *(col + col + pr) & 0x10) != 0 && (mode & 0x10) == 0) {
                                                    wc_putc_end(ttyf);
                                                    if(graph_enabled == 0) {
                                                        graph_enabled = 1;
                                                        writestr(T_eA);
                                                    }
                                                    writestr(T_as);
                                                    mode = mode | 16;
                                                }
                                                if(( *(col + col + pr) & 0x10) == 0) {
                                                    if(( *(col + col + pr) & 0xc0) != 128) {
                                                        wc_putc(pc[col], ttyf);
                                                    }
                                                } else {
                                                    if(( *(pc[col]) & 0xff) <= 31 || ( *(pc[col]) & 0xff) >= 0) {
                                                        _t482 =  *(pc[col]) & 0xff;
                                                    } else {
                                                        _t482 =  *(( *(pc[col]) & 0xff) - 32 +  &gcmap) & 0xff;
                                                    }
                                                    write1(_t482);
                                                }
                                                pcol = col + 1;
                                            }
                                            col = col + 1;
                                            continue;
                                        } else {
                                            goto L48;
                                        }
L55:
                                        asm("cwde ");
                                        if((ScreenImage[line]->eol & 65535) > col) {
                                            goto L57;
                                        } else {
                                            _t414 = need_redraw(pc[col],  *(col + col + pr) & 0xffff, " ", 0);
                                        }
                                        goto L58;
                                    }
                                }
                            }
                        }
                    }
L48:
                    if((mode & 0xf00) != 0 || (mode & 0xf000) != 0) {
                        writestr(T_op);
                    }
                    if((mode & 0x10) != 0) {
                        writestr(T_ae);
                    }
                    writestr(T_me);
                    mode = mode & 232;
                    goto L54;
L96:
                    if(col == COLS) {
                        moved = 0;
                    }
                    while(col < COLS && ( *(col + col + pr) & 8) == 0) {
                         *(col + col + pr) = ( *(col + col + pr) & 65535 | 8) & 65535;
                        col = col + 1;
                    }
                    goto L102;
                }
                goto L96;
            }
            _t593 = moved;
            if(_t593 == 1) {
                write1(10);
                write1(13);
L28:
                goto L31;
            }
            if(_t593 == 2) {
                moved = 1;
                goto L31;
            }
            if(_t593 != 0) {
                goto L31;
            } else {
                _t596 = T_cm;
                _v68 = line;
                _v72 = 0;
                 *__esp = _t596;
                tgoto();
                writestr(_t596);
                moved = 1;
                goto L28;
            }
            goto L32;
        }
    }
    wc_putc_end(ttyf);
    _t635 = T_cm;
    _v68 = CurLine;
    _v72 = CurColumn;
     *__esp = _t635;
    tgoto();
    writestr(_t635);
    flush_tty();
    return;
}

clear()
{// addr = 0x0809DBFF  --  defined in 'terms.c' at line 1451
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    l_prop* p;          // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    writestr(T_cl);
    move(0, 0);
    i = 0;
    while(i < LINES) {
        ScreenImage[i]->isdirty = 0;
        p = ScreenImage[i]->lineprop;
        j = 0;
        while(j < COLS) {
             *((short*)(j + j + p)) = 8;
            j = j + 1;
        }
        i = i + 1;
    }
    CurrentMode = 0;
    return;
}

clrtoeol()
{// addr = 0x0809DC96  --  defined in 'terms.c' at line 1581
    int i;                                 // _cfa_fffffff8
    l_prop* lprop;      // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    lprop = ScreenImage[CurLine]->lineprop;
    if(( *(CurColumn + CurColumn + lprop) & 8) != 0) {
        goto L10;
    }
    asm("cwde ");
    if((ScreenImage[CurLine]->isdirty & 0xc) == 0 || (ScreenImage[CurLine]->eol & 0xffff) > CurColumn) {
        ScreenImage[CurLine]->eol = CurColumn & 65535;
    }
    ScreenImage[CurLine]->isdirty = (ScreenImage[CurLine]->isdirty & 65535 | 8) & 65535;
    touch_line();
    i = CurColumn;
    while(i < COLS) {
        if(( *(i + i + lprop) & 8) == 0) {
             *(i + i + lprop) = 40;
            i = i + 1;
            continue;
        }
        return;
    }
L10:
    return;
}

clrtoeol_with_bcolor()
{// addr = 0x0809DD9F  --  defined in 'terms.c' at line 1602
    l_prop pr;          // _cfa_fffffff2
    int i;                                 // _cfa_ffffffec
    int cli;                               // _cfa_ffffffe8
    int cco;                               // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if((CurrentMode & 0xf000) != 0) {
        cli = CurLine;
        cco = CurColumn;
        pr = CurrentMode & 0xffff;
        CurrentMode = CurrentMode & 0xffff;
        i = CurColumn;
L4:
        while(i < COLS) {
            goto L3;
        }
        move(cli, cco);
        CurrentMode = pr & 0xffff;
        return;
    }
    clrtoeol();
    return;
L3:
    addch(32);
    i = i + 1;
    goto L4;
}

clrtoeolx()
{// addr = 0x0809DE2D  --  defined in 'terms.c' at line 1622
    _unknown_ __ebp;                       // r6

    clrtoeol_with_bcolor();
    return;
}

clrtobot_eol(_None* clrtoeol)
{// addr = 0x0809DE3A  --  defined in 'terms.c' at line 1636
    int l;                                 // _cfa_fffffff0
    int c;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6

    l = CurLine;
    c = CurColumn;
     *clrtoeol();
    CurColumn = 0;
    CurLine = CurLine + 1;
    while(CurLine < LINES) {
         *clrtoeol();
        CurLine = CurLine + 1;
    }
    CurLine = l;
    CurColumn = c;
    return;
}

clrtobot()
{// addr = 0x0809DEA1  --  defined in 'terms.c' at line 1652
    _unknown_ __ebp;                       // r6

    clrtobot_eol(clrtoeol);
    return;
}

clrtobotx()
{// addr = 0x0809DEB6  --  defined in 'terms.c' at line 1658
    _unknown_ __ebp;                       // r6

    clrtobot_eol(clrtoeolx);
    return;
}

addstr(char* s)
{// addr = 0x0809DECB  --  defined in 'terms.c' at line 1675
    int len;                               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    while(( *s & 0xff) != 0) {
        len = wtf_len(s);
        addmch(s, len);
        s =  &(s[len]);
    }
    return;
}

addnstr(char* s, int n)
{// addr = 0x0809DF05  --  defined in 'terms.c' at line 1692
    int i;                                 // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int width;                             // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t45;                              // _t45

    i = 0;
    while(( *s & 0xff) != 0) {
        if(( *135119023 & 0xff) == 0) {
            _t45 =  *( &WTF_WIDTH_MAP + ( *s & 0xff)) & 0xff;
        } else {
            _t45 =  *( &WTF_WIDTH_MAP + ( *s & 0xff)) & 0xff;
        }
        width = _t45;
        if(i + width <= n) {
            len = wtf_len(s);
            addmch(s, len);
            s =  &(s[len]);
            i = i + width;
            continue;
        }
        return;
    }
    return;
}

addnstr_sup(char* s, int n)
{// addr = 0x0809DF98  --  defined in 'terms.c' at line 1714
    int i;                                 // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int width;                             // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t50;                              // _t50

    i = 0;
    while(( *s & 0xff) != 0) {
        if(( *135119023 & 0xff) == 0) {
            _t50 =  *( &WTF_WIDTH_MAP + ( *s & 0xff)) & 0xff;
        } else {
            _t50 =  *( &WTF_WIDTH_MAP + ( *s & 0xff)) & 0xff;
        }
        width = _t50;
        if(i + width <= n) {
            len = wtf_len(s);
            addmch(s, len);
            s =  &(s[len]);
            i = i + width;
            continue;
        }
L10:
        while(i < n) {
            addch(32);
            i = i + 1;
        }
        return;
    }
    goto L10;
}

crmode()
{// addr = 0x0809E049  --  defined in 'terms.c' at line 1738
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    ttymode_reset(2, 1024);
    ttymode_set(1, 0);
    set_cc(6, 1);
    return;
}

nocrmode()
{// addr = 0x0809E08D  --  defined in 'terms.c' at line 1756
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    ttymode_set(2, 0);
    set_cc(6, 4);
    return;
}

term_echo()
{// addr = 0x0809E0BD  --  defined in 'terms.c' at line 1773
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    ttymode_set(8, 0);
    return;
}

term_noecho()
{// addr = 0x0809E0D9  --  defined in 'terms.c' at line 1779
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    ttymode_reset(8, 0);
    return;
}

term_raw()
{// addr = 0x0809E0F5  --  defined in 'terms.c' at line 1785
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    ttymode_reset(32779, 5120);
    set_cc(6, 1);
    return;
}

term_cooked()
{// addr = 0x0809E125  --  defined in 'terms.c' at line 1807
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    ttymode_set(32779, 0);
    set_cc(6, 4);
    return;
}

term_cbreak()
{// addr = 0x0809E155  --  defined in 'terms.c' at line 1831
    _unknown_ __ebp;                       // r6

    term_cooked();
    term_noecho();
    return;
}

term_title(char* s)
{// addr = 0x0809E167  --  defined in 'terms.c' at line 1838
    char* _v20;                            // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10

    if((fmInitialized & 0xff) != 0) {
        if(title_str == 0) {
        } else {
            _v20 = s;
            fprintf(ttyf, title_str);
            return;
        }
L5:
    }
    return;
    goto L5;
}

char getch()
{// addr = 0x0809E1A5  --  defined in 'terms.c' at line 1859
    char c;                                // _cfa_fffffff3
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    while(read(tty,  &c, 1) <= 0) {
        if( *(__errno_location()) == 4) {
            continue;
        }
        if( *(__errno_location()) == 11) {
            continue;
        }
        quitfm();
        break;
    }
    return c & 255;
}

char wgetch(_Unknown_base* p)
{// addr = 0x0809E1F6  --  defined in 'terms.c' at line 1882
    char c;                                // _cfa_fffffff3
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    while(read(tty,  &c, 1) <= 0) {
        if( *(__errno_location()) == 4) {
            continue;
        }
        if( *(__errno_location()) == 11) {
            continue;
        }
        quitfm();
        break;
    }
    return c & 255;
}

int do_getch()
{// addr = 0x0809E247  --  defined in 'terms.c' at line 1898
    _unknown_ __ebp;                       // r6
    int _t2;                               // _t2

    _t2 = is_xterm;
    if(_t2 == 0) {
         *__esp = 0;
        Gpm_Wgetch();
        return _t2;
    }
    return getch() & 255;
}

bell()
{// addr = 0x0809E26E  --  defined in 'terms.c' at line 1959
    _unknown_ __ebp;                       // r6

    write1(7);
    return;
}

skip_escseq()
{// addr = 0x0809E282  --  defined in 'terms.c' at line 1965
    int c;                                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32

    c = getch() & 255;
    if(c == 91 || c == 79) {
        c = getch() & 255;
        if(is_xterm == 0) {
L8:
            while(( *( &MYCTYPE_MAP + (c & 0xff)) & 8) != 0) {
                c = getch() & 255;
            }
            goto L9;
        }
        if(c != 77) {
            goto L7;
        }
        getch();
        getch();
        getch();
        return;
L7:
        goto L8;
    }
L9:
    return;
}

int sleep_till_anykey(int sec, int purge)
{// addr = 0x0809E2F4  --  defined in 'terms.c' at line 1986
    intOrPtr _v32;                         // _cfa_ffffffe0
    TerminalMode ioval;   // _cfa_ffffffa4
    int er;                                // _cfa_ffffffa0
    int c;                                 // _cfa_ffffff9c
    int ret;                               // _cfa_ffffff98
    int __d0;                              // _cfa_ffffff94
    int __d1;                              // _cfa_ffffff90
    struct timeval tim;   // _cfa_ffffff88
    fd_set rfd;         // _cfa_ffffff08
    long int* _v268;                       // _cfa_fffffef4
    int _v272;                             // _cfa_fffffef0
    int _v276;                             // _cfa_fffffeec
    int _v280;                             // _cfa_fffffee8
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t44;                        // _t44
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    int _t49;                              // _t49
    int _t60;                              // _t60
    int _t61;                              // _t61
    int _t62;                              // _t62
    _unknown_ _t65;                        // _t65
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    _unknown_ _t78;                        // _t78
    _unknown_ _t82;                        // _t82
    void* _t84;           // _t84
    _unknown_ _t86;                        // _t86
    _unknown_ _t92;                        // _t92

    _v32 =  *gs:0x14];
    _v280 =  &(ioval.c_iflag);
     *__esp = tty;
    tcgetattr();
    term_raw();
    tim.tv_sec = sec;
    tim.tv_usec = 0;
    _t84 =  &(rfd.__fds_bits);
    asm("cld ");
    memset(_t84, 0, 32 << 2);
    __d0 = 0;
    __d1 =  &(_t84[8]);
    _t49 = tty;
    _t50 = _t49 >= 0 ? _t49 + 31 : _t49;
    _t51 = (_t49 >= 0 ? _t49 + 31 : _t49) >> 5;
     *(__ebp + -244 + ((_t49 >= 0 ? _t49 + 31 : _t49) >> 5) * 4) = 1 << ((tty + (tty >> 31 >> 27) & 31) - (tty >> 31 >> 27) & 255) |  *(__ebp + -244 + ((_t49 >= 0 ? _t49 + 31 : _t49) >> 5) * 4);
    _v268 =  &(tim.tv_sec);
    _v272 = 0;
    _v276 = 0;
    _t60 =  &(rfd.__fds_bits);
    _v280 = _t60;
     *__esp = tty + 1;
    select();
    ret = _t60;
    if(ret > 0 && purge != 0) {
        c = getch() & 255;
        if(c == 27) {
            skip_escseq();
        }
    }
    _t61 = tty;
    _v276 =  &(ioval.c_iflag);
    _v280 = 0;
     *__esp = _t61;
    tcsetattr();
    er = _t61;
    _t92 = er - 255;
    if(_t92 == 0) {
        _v280 =  *(__errno_location());
        printf("Error occured: errno=%d\n");
        reset_exit(0);
    }
    _t62 = ret;
    if(_t92 == 0) {
        return _t62;
    } else {
        __stack_chk_fail();
        return _t62;
    }
}

mouse_init()
{// addr = 0x0809E44F  --  defined in 'terms.c' at line 2027
    int r;                                 // _cfa_fffffff0
    int _v26;                              // _cfa_ffffffe6
    int _v28;                              // _cfa_ffffffe4
    int _v30;                              // _cfa_ffffffe2
    Gpm_Connect conn;   // _cfa_ffffffe0
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t14;                              // _t14
    _unknown_ _t16;                        // _t16

    if(mouseActive == 0) {
        conn.eventMask = 65535;
        _v30 = 0;
        _v26 = 0;
        _v28 = 0;
        _v56 = 0;
        _t14 =  &(conn.eventMask);
         *__esp = _t14;
        Gpm_Open();
        r = _t14;
        if(r != 254) {
            if(r < 0) {
                __imp__gpm_handler = gpm_process_mouse;
                is_xterm = 0;
            }
        } else {
            Gpm_Close();
            is_xterm = 3;
        }
        _t15 = is_xterm;
        if(is_xterm != 0) {
            fwrite(135065349, 1, 16, ttyf);
            flush_tty();
        }
        mouseActive = 1;
        return;
    }
    return;
}

mouse_end()
{// addr = 0x0809E505  --  defined in 'terms.c' at line 2063
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6

    if(mouseActive != 0) {
        _t5 = is_xterm;
        if(is_xterm == 0) {
            Gpm_Close();
        } else {
            fwrite(135065366, 1, 16, ttyf);
            flush_tty();
        }
        mouseActive = 0;
        return;
    }
    return;
}

mouse_active()
{// addr = 0x0809E55F  --  defined in 'terms.c' at line 2175
    _unknown_ __ebp;                       // r6

    if(mouseActive == 0) {
        mouse_init();
        return;
    }
    return;
}

mouse_inactive()
{// addr = 0x0809E575  --  defined in 'terms.c' at line 2182
    _unknown_ __ebp;                       // r6

    if(mouseActive == 0 || is_xterm == 0) {
        return;
    } else {
        mouse_end();
        return;
    }
}

flush_tty()
{// addr = 0x0809E594  --  defined in 'terms.c' at line 2191
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    if(ttyf != 0) {
        fflush(ttyf);
        return;
    }
    return;
}

touch_cursor()
{// addr = 0x0809E5B2  --  defined in 'terms.c' at line 2199
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    touch_line();
    i = CurColumn;
    while(i >= 0) {
        touch_column(i);
        if(( *(ScreenImage[CurLine]->lineprop + i + i) & 0xc0) == 128) {
            i = i - 1;
            continue;
        }
L6:
        i = CurColumn + 1;
        while(i < COLS) {
            if(( *(ScreenImage[CurLine]->lineprop + i + i) & 0xc0) == 128) {
                touch_column(i);
                i = i + 1;
                continue;
            }
            return;
        }
        return;
    }
    goto L6;
}

struct table2* loadMimeTypes(char* filename)
{// addr = 0x0809E668  --  defined in 'url.c' at line 153
    FILE* f;              // _cfa_fffffff0
    char* d;                               // _cfa_ffffffec
    char* type;                            // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int n;                                 // _cfa_ffffffe0
    Str tmp;               // _cfa_ffffffdc
    struct table2* mtypes;   // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t79;                        // _t79
    _unknown_ _t82;                        // _t82
    _unknown_ _t84;                        // _t84
    _unknown_ _t88;                        // _t88
    struct table2* _t91;   // _t91
    _unknown_ _t100;                       // _t100
    _unknown_ _t103;                       // _t103
    _unknown_ _t122;                       // _t122
    _unknown_ _t124;                       // _t124
    _unknown_ _t125;                       // _t125

    f = fopen(expandPath(filename), 135065742);
    if(f != 0) {
        n = 0;
        while(1) {
L9:
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            goto L3;
        }
        fseek(f, 0, 0);
        _t91 = n + 1 << 3;
         *__esp = _t91;
        GC_malloc();
        mtypes = _t91;
        i = 0;
        while(1) {
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            d = tmp->ptr;
            if(( *d & 0xff) == 35) {
                continue;
            }
            type = strtok(d, 135065744);
            if(type == 0) {
                goto L16;
            } else {
                goto L13;
            }
            while(1) {
L13:
                d = strtok(0, 135065744);
                if(d == 0) {
                    break;
                }
                mtypes[i].item1 =  *(Strnew_charp(d));
                 &(mtypes[i])->item2 =  *(Strnew_charp(type));
                i = i + 1;
            }
L16:
        }
        mtypes[i] = 0;
         &(mtypes[i])->item2 = 0;
        fclose(f);
        return mtypes;
    }
    return 0;
L3:
    d = tmp->ptr;
    if(( *d & 0xff) == 35) {
        goto L9;
    }
    d = strtok(d, 135065744);
    if(d == 0) {
        goto L9;
    }
    d = strtok(0, 135065744);
    i = 0;
    while(d != 0) {
        d = strtok(0, 135065744);
        i = i + 1;
    }
    n = n + i;
    goto L9;
}

initMimeTypes()
{// addr = 0x0809E854  --  defined in 'url.c' at line 203
    int i;                                 // _cfa_fffffff0
    TextListItem* tl;   // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    struct table2** _t18;   // _t18

    if(non_null(mimetypes_files) == 0) {
        mimetypes_list = 0;
    } else {
        mimetypes_list = make_domain_list(mimetypes_files);
    }
    if(mimetypes_list != 0) {
        asm("cwde ");
        _t18 = (mimetypes_list->nitem & 65535) << 2;
         *__esp = _t18;
        GC_malloc();
        UserMimeTypes = _t18;
        i = 0;
        tl = mimetypes_list->first;
        while(tl != 0) {
            UserMimeTypes[i] = loadMimeTypes(tl->ptr);
            i = i + 1;
            tl = tl->next;
        }
        return;
    }
    return;
}

char* DefaultFile(int scheme)
{// addr = 0x0809E8F9  --  defined in 'url.c' at line 220
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    int _t5;                               // _t5
    _unknown_ _t7;                         // _t7

    _t5 = scheme;
    if(_t5 == 1) {
L7:
        return allocStr(135065751, -1);
    }
    if(_t5 > 1) {
        if(_t5 > 5) {
            goto L9;
        }
        goto L5;
        return __eax;
    }
    if(_t5 == 0) {
        return allocStr(135065749, -1);
    }
L9:
    return 0;
    goto L7;
L5:
    return allocStr(135065749, -1);
}

KeyAbort(int _dummy)
{// addr = 0x0809E962  --  defined in 'url.c' at line 242
    int _v0;                               // _cfa_0
    void _v17;                             // _cfa_ffffffef
    char* _v20;                            // _cfa_ffffffec
    struct _IO_FILE* _v24;   // _cfa_ffffffe8
    int _v28;                              // _cfa_ffffffe4
    struct _IO_FILE* _v48;   // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t28);
    __esp = __esp - 40;
    _v48 = fopen(_v20, 135065742);
    if(_v48 != 0) {
        while(1) {
            _v28 = fgetc(_v24);
            if(_v28 == 255) {
                break;
            }
            _v17 = _v28 & 255;
            write(_v0,  &_v17, 1);
        }
        fclose(_v24);
        return;
    }
    return;
}

write_from_file(int sock, char* file)
{// addr = 0x0809E97C  --  defined in 'url.c' at line 418
    char[0] buf;                           // _cfa_fffffff3
    FILE* fd;             // _cfa_ffffffec
    int c;                                 // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24
    _unknown_ _t26;                        // _t26

    fd = fopen(file, 135065742);
    if(fd != 0) {
        while(1) {
            c = fgetc(fd);
            if(c == 255) {
                break;
            }
            buf = c & 255;
            write(sock,  &buf, 1);
        }
        fclose(fd);
        return;
    }
    return;
}

ParsedURL* baseURL(Buffer* buf)
{// addr = 0x0809E9E2  --  defined in 'url.c' at line 434
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    asm("cwde ");
    if((buf->bufferprop & 0x10) == 0) {
        if(buf->baseURL == 0) {
            return buf + 132;
        }
        goto L3;
    }
    return 0;
L3:
    return buf->baseURL;
}

int openSocket(const char* hostname, char* remoteport_name, short unsigned int remoteport_num)
{// addr = 0x0809EA1D  --  defined in 'url.c' at line 449
    _None sock;                            // _cfa_fffffff0
    int* af;                               // _cfa_ffffffec
    struct addrinfo* res0;   // _cfa_ffffffe8
    struct addrinfo* res;   // _cfa_ffffffe4
    int error;                             // _cfa_ffffffe0
    char* hname;                           // _cfa_ffffffdc
    _None prevtrap;                        // _cfa_ffffffd8
    Str portbuf;           // _cfa_ffffffd4
    struct addrinfo hints;   // _cfa_ffffffb4
    signed short _v80;                     // _cfa_ffffffb0
    struct addrinfo** _v96;   // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    char* _t123;                           // _t123
    _unknown_ _t126;                       // _t126
    _unknown_ _t130;                       // _t130
    _unknown_ _t139;                       // _t139
    _None _t146;                           // _t146
    _unknown_ _t151;                       // _t151
    struct sockaddr* _t152;   // _t152
    _unknown_ _t154;                       // _t154
    _unknown_ _t164;                       // _t164
    int _t172;                             // _t172
    int _t177;                             // _t177
    int _t193;                             // _t193
    _unknown_ _t200;                       // _t200

    _v80 = _a12 & 65535;
    sock = -1;
    prevtrap = 0;
    _t123 = fmInitialized & 255;
    if((_t123 & 255) != 0) {
        _t123 =  *(Sprintf("Opening socket..."));
        message(_t123, 0, 0);
        refresh();
    }
    _v104 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t123 == 0) {
        if((TrapSignal & 0xff) != 0) {
            prevtrap = mySignal(2, KeyAbort);
            if((fmInitialized & 0xff) != 0) {
                term_cbreak();
            }
        }
        if(hostname == 0) {
            goto L49;
        }
        hname = hostname;
        if(hname == 0 || ( *hname & 0xff) != 91 || ( *(strlen(hname) - 1 + hname) & 0xff) != 93) {
L13:
            af =  &ai_family_order_table + (DNS_order + DNS_order + _t210 << 2);
            while(1) {
L14:
                memset( &(hints.ai_flags), 0, 32);
                hints.ai_family =  *af;
                hints.ai_socktype = 1;
                if(_v80 == 0) {
                    error = -1;
                } else {
                    _v104 = _v80 & 65535;
                    portbuf = Sprintf("%d");
                    _t177 = hname;
                    _v96 =  &res0;
                    _v100 =  &(hints.ai_flags);
                    _v104 = portbuf->ptr;
                     *__esp = _t177;
                    getaddrinfo();
                    error = _t177;
                }
                if(error != 0 && remoteport_name != 0 && ( *remoteport_name & 0xff) != 0) {
                    _t172 = hname;
                    _v96 =  &res0;
                    _v100 =  &(hints.ai_flags);
                    _v104 = remoteport_name;
                     *__esp = _t172;
                    getaddrinfo();
                    error = _t172;
                }
                if(error != 0) {
                    break;
                }
                sock = -1;
                res = res0;
                while(res != 0) {
                    _t146 = res->ai_family;
                    _v100 = res->ai_protocol;
                    _v104 = res->ai_socktype;
                     *__esp = _t146;
                    socket();
                    sock = _t146;
                    if(sock >= 0) {
                        goto L29;
                    }
                    _t152 = res->ai_addr;
                    _v100 =  *(res + 16);
                    _v104 = _t152;
                     *__esp = sock;
                    connect();
                    if(_t152 >= 0) {
L33:
                        if(sock >= 0) {
                             *__esp = res0;
                            freeaddrinfo();
                            if((TrapSignal & 0xff) != 0) {
                                if((fmInitialized & 0xff) != 0) {
                                    term_raw();
                                }
                                if(prevtrap != 0) {
                                    mySignal(2, prevtrap);
                                }
                            }
                            return sock;
                        }
                         *__esp = res0;
                        freeaddrinfo();
                        if( *af != 0) {
L39:
L40:
                            af =  &(af[1]);
                            goto L14;
                        }
                        goto L49;
                    }
                    close(sock);
                    sock = -1;
L29:
                    res = res->ai_next;
                }
                goto L33;
            }
            if( *af != 0) {
                goto L40;
            }
            goto L49;
        } else {
            hname = allocStr( &(hostname[1]), -1);
             *(strlen(hname) - 1 + hname) = 0;
            _t193 = strspn(hname, "0123456789abcdefABCDEF:.");
            if(_t193 != strlen(hname)) {
                goto L48;
            }
            goto L13;
        }
        goto L14;
L48:
    } else {
        if(sock < 0) {
            close(sock);
        }
    }
L49:
    if((TrapSignal & 0xff) != 0) {
        if((fmInitialized & 0xff) != 0) {
            term_raw();
        }
        if(prevtrap != 0) {
            mySignal(2, prevtrap);
        }
    }
    return -1;
}

char* copyPath(char* orgpath, int length, int option)
{// addr = 0x0809ED8B  --  defined in 'url.c' at line 640
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t58;                        // _t58
    int _t76;                              // _t76
    int _t83;                              // _t83
    int _t91;                              // _t91

    tmp = Strnew();
    while(( *orgpath & 0xff) != 0 && length != 0) {
        if(( *( &MYCTYPE_MAP + ( *orgpath & 0xff)) & 2) == 0) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t76 = tmp->length;
             *(tmp->ptr + _t76) =  *orgpath & 0xff;
            tmp->length = _t76 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
        } else {
            _t83 = option;
            if(_t83 != 1) {
                if(_t83 == 2) {
                    Strcat_charp(tmp, "%20");
                } else {
                    if(_t83 == 0) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t91 = tmp->length;
                         *(tmp->ptr + _t91) =  *orgpath & 0xff;
                        tmp->length = _t91 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
                    }
                }
            }
        }
        orgpath =  &(orgpath[1]);
        length = length - 1;
    }
    return tmp->ptr;
}

parseURL(char* url, ParsedURL* p_url, ParsedURL* current)
{// addr = 0x0809EEAF  --  defined in 'url.c' at line 666
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    Str tmp;               // _cfa_ffffffe8
    char* cgi;                             // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t536;                           // _t536
    signed int _t608;                      // _t608
    _unknown_ _t713;                       // _t713
    int _t744;                             // _t744

    url = url_quote(url);
    p = url;
    p_url->scheme = 254;
    p_url->port = 0;
    p_url->user = 0;
    p_url->pass = 0;
    p_url->host = 0;
    p_url->is_nocache = 0;
    p_url->file = 0;
    p_url->real_file = 0;
    p_url->query = 0;
    p_url->label = 0;
    if(( *url & 0xff) == 0 || ( *url & 0xff) == 35) {
        if(current != 0) {
            copyParsedURL(p_url, current);
        }
L122:
        if(p_url->scheme != 254) {
            if(( *p & 0xff) != 35) {
                p_url->label = 0;
                return;
            }
            goto L125;
        }
        goto L123;
L125:
        p_url->label = allocStr( &(p[1]), -1);
        return;
    } else {
        p_url->scheme = getURLScheme( &p);
        if(p_url->scheme != 254) {
            if(p_url->scheme == 255) {
                p_url->file = allocStr(url, -1);
                return;
            }
            if(( *p & 0xff) != 47 || (p[1] & 0xff) != 47) {
                p_url->host = 0;
                if(p_url->scheme == 255) {
                    p_url->port = 0;
                } else {
                    p_url->port =  *( &DefaultPort + p_url->scheme * 4);
                }
                goto L59;
            }
            if(p_url->scheme != 4) {
L23:
                p =  &(p[2]);
                goto L24;
            }
            if((p[2] & 0xff) == 47 || (p[2] & 0xff) == 126) {
                p =  &(p[2]);
                goto L59;
            }
            goto L23;
        } else {
            if(current == 0) {
                p_url->scheme = 4;
            } else {
                if(current->scheme <= 10) {
                    goto __eax;
                }
                p_url->scheme = current->scheme;
            }
            p = url;
            if(strncmp(p, "//", 2) != 0) {
L59:
                if(p_url->scheme == 4 && p_url->user == 0 && p_url->host != 0 && (p_url & 0xff) != 0 && strcmp(p_url->host, "localhost") != 0) {
                    p_url->scheme = 2;
                    if(p_url->port == 0) {
                        p_url->port =  *135102632;
                    }
                }
                if(( *p & 0xff) == 0 || ( *p & 0xff) == 35 || ( *p & 0xff) == 63) {
                    if(p_url->host != 0) {
                        goto L71;
                    } else {
                        p_url->file = 135065832;
                    }
L115:
                    if(( *p & 0xff) != 63) {
                        goto L122;
                    }
                    p =  &(p[1]);
                    q = p;
                    while(( *p & 0xff) != 0 && ( *p & 0xff) != 35) {
                        p =  &(p[1]);
                    }
                    p_url->query = copyPath(q, p - q, 0);
                    goto L122;
                }
L71:
                q = p;
                if(p_url->scheme == 1) {
                    if(( *q & 0xff) == 47) {
                        q =  &(q[1]);
                    }
                    if(( *q & 0xff) != 0 && ( *q & 0xff) != 47 && (q[1] & 0xff) != 47 && (q[2] & 0xff) == 47) {
                        q =  &(q[1]);
                    }
                }
                if(( *p & 0xff) == 47) {
                    p =  &(p[1]);
                }
                if(( *p & 0xff) == 0 || ( *p & 0xff) == 35 || ( *p & 0xff) == 63) {
                    p_url->file = DefaultFile(p_url->scheme);
                    goto L115;
                }
                if(p_url->scheme != 1 || ( *p & 0xff) != 82) {
                    cgi = strchr(p, 63);
L99:
                    while(( *p & 0xff) == 0 || ( *p & 0xff) == 35 || p == cgi) {
                        if(( *p & 0xff) != 35 || p_url->scheme != 4) {
L111:
                            if(p_url->scheme == 4 || p_url->scheme == 254) {
                                p_url->file = copyPath(q, p - q, 0);
                            } else {
                                p_url->file = copyPath(q, p - q, 1);
                            }
                            goto L115;
                        } else {
                            if(p <= q || ( *(p - 1) & 0xff) != 47 || cgi != 0 && p >= cgi) {
                                if((p[1] & 0xff) == 0) {
                                    p =  &(p[1]);
                                }
                                goto L111;
                            }
                            p =  &(p[1]);
                            continue;
                        }
                    }
                } else {
                    p =  &(p[1]);
                    tmp = Strnew();
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t744 = tmp->length;
                    _t536 = p;
                     *(tmp->ptr + _t744) =  *_t536 & 0xff;
                    tmp->length = _t744 + 1;
                    p =  &(_t536[1]);
                     *(tmp->ptr + tmp->length) = 0;
                    while(( *p & 0xff) != 0 && ( *p & 0xff) != 47) {
                        p =  &(p[1]);
                    }
                    Strcat_charp(tmp, p);
                    while(( *p & 0xff) != 0) {
                        p =  &(p[1]);
                    }
                    p_url->file = copyPath(tmp->ptr, -1, 1);
                    goto L115;
                }
                p =  &(p[1]);
                goto L99;
            } else {
                p =  &(p[2]);
                goto L24;
                do {
                    do {
L53:
                        if(( *p & 0xff) != 64) {
                            tmp = Strnew_charp_n(q, p - q);
                            p_url->port = atoi(tmp->ptr);
                            goto L59;
                        } else {
                            p_url->pass = copyPath(q, p - q, 0);
                            p =  &(p[1]);
                            q = p;
                            p_url->user = p_url->host;
                            p_url->host = 0;
L24:
                            q = p;
                            if(( *q & 0xff) != 91) {
                                goto L38;
                            } else {
                                p =  &(p[1]);
                                while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0x28) != 0 || ( *p & 0xff) == 58 || ( *p & 0xff) == 46) {
                                }
                                if(( *p & 0xff) != 93) {
L33:
                                    p = q;
L38:
                                    while(( *p & 0xff) != 0) {
                                        goto L39;
                                    }
L40:
                                    _t608 =  *p & 0xff;
                                    if(_t608 == 58) {
                                        p_url->host = copyPath(q, p - q, 1);
                                        p =  &(p[1]);
                                        q = p;
L51:
                                        while(( *p & 0xff) != 0) {
L52:
                                            if(strchr("/?#",  *p & 0xff) == 0) {
                                                p =  &(p[1]);
                                                goto L51;
                                            }
                                            goto L53;
                                        }
                                        continue;
                                    }
                                    if(_t608 > 58) {
                                        if(_t608 == 63) {
                                            goto L57;
                                        }
                                        goto L47;
                                    }
                                    if(_t608 == 35 || _t608 == 47 || _t608 == 0) {
L57:
                                        p_url->host = copyPath(q, p - q, 1);
                                        p_url->port =  *( &DefaultPort + p_url->scheme * 4);
                                    }
                                    goto L59;
                                }
                                if((p[1] & 0xff) == 0) {
                                    goto L38;
                                }
                                if(strchr(":/?#", p[1] & 0xff) != 0) {
                                    goto L38;
                                }
                                goto L33;
                            }
L39:
                            if(strchr(":/?#",  *p & 0xff) == 0) {
                                p =  &(p[1]);
                                goto L38;
                            }
                            goto L40;
                        }
                        goto L60;
                    } while();
                    goto L59;
L47:
                } while(_t608 == 64);
                goto L59;
            }
        }
    }
L123:
    p_url->scheme = 4;
    p_url->file = allocStr(p, -1);
    p_url->label = 0;
    return;
}

copyParsedURL(ParsedURL* p, ParsedURL* q)
{// addr = 0x0809F763  --  defined in 'url.c' at line 960
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    char* _t68;                            // _t68
    char* _t71;                            // _t71
    char* _t74;                            // _t74
    char* _t77;                            // _t77
    char* _t80;                            // _t80
    char* _t83;                            // _t83
    char* _t86;                            // _t86

    p->scheme = q->scheme;
    p->port = q->port;
    p->is_nocache = q->is_nocache;
    if(q->user == 0) {
        _t68 = 0;
    } else {
        _t68 = allocStr(q->user, -1);
    }
    p->user = _t68;
    if(q->pass == 0) {
        _t71 = 0;
    } else {
        _t71 = allocStr(q->pass, -1);
    }
    p->pass = _t71;
    if(q->host == 0) {
        _t74 = 0;
    } else {
        _t74 = allocStr(q->host, -1);
    }
    p->host = _t74;
    if(q->file == 0) {
        _t77 = 0;
    } else {
        _t77 = allocStr(q->file, -1);
    }
    p->file = _t77;
    if(q->real_file == 0) {
        _t80 = 0;
    } else {
        _t80 = allocStr(q->real_file, -1);
    }
    p->real_file = _t80;
    if(q->label == 0) {
        _t83 = 0;
    } else {
        _t83 = allocStr(q->label, -1);
    }
    p->label = _t83;
    if(q->query == 0) {
        _t86 = 0;
    } else {
        _t86 = allocStr(q->query, -1);
    }
    p->query = _t86;
    return;
}

parseURL2(char* url, ParsedURL* pu, ParsedURL* current)
{// addr = 0x0809F8C8  --  defined in 'url.c' at line 975
    char* p;                               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int relative_uri;                      // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t350;                             // _t350
    char* _t445;                           // _t445

    relative_uri = 0;
    parseURL(url, pu, current);
    if(pu->scheme == 11) {
        return;
    }
    if(pu->scheme == 9 || pu->scheme == 10) {
        if(pu->file == 0 || strchr(pu->file, 64) != 0) {
L9:
            pu->scheme = 9;
            return;
        } else {
            p = strchr(pu->file, 47);
            if(p == 0 || strchr( &(p[1]), 45) != 0 || (p[1] & 0xff) == 0) {
                pu->scheme = 10;
                return;
            } else {
                goto L9;
            }
        }
        goto L10;
    } else {
L10:
        if(pu->scheme == 7) {
L12:
            if(pu->file != 0) {
                if((pu & 0xff) == 47) {
                    pu->file = allocStr( &(pu->file[1]), -1);
                }
            }
            if(pu->file == 0 || strchr(pu->file, 64) != 0) {
L21:
                pu->scheme = 7;
            } else {
                p = strchr(pu->file, 47);
                if(p == 0 || strchr( &(p[1]), 45) != 0 || (p[1] & 0xff) == 0) {
                    pu->scheme = 8;
                    goto L22;
                } else {
                    goto L21;
                }
L23:
                if(current->scheme == 7 || current->scheme == 8) {
                    if(pu->host == 0) {
                        pu->host = current->host;
                        pu->port = current->port;
                        return;
                    }
L85:
                    return;
                } else {
L83:
                    return;
                }
            }
L22:
            if(current == 0) {
                goto L82;
            }
            goto L23;
        }
        if(pu->scheme != 8) {
            if(pu->scheme == 4) {
                q = expandName(file_unquote(pu->file));
                pu->file = file_quote(q);
            }
            if(current == 0 || pu->scheme != current->scheme && (pu->scheme != 2 || current->scheme != 3) && (pu->scheme != 4 || current->scheme != 5) || pu->host != 0) {
L63:
                if(pu->file == 0) {
                    goto L85;
                }
            } else {
                pu->user = current->user;
                pu->pass = current->pass;
                pu->host = current->host;
                pu->port = current->port;
                if(pu->file == 0 || (pu & 0xff) == 0) {
                    pu->file = current->file;
                    if(pu->query == 0) {
                        pu->query = current->query;
                    }
                    goto L63;
                } else {
                    if(pu->scheme != 255 || strchr(pu->file, 58) != 0 || current == 0) {
L43:
                        if(pu->scheme == 1 || (pu & 0xff) == 47) {
                            if(pu->scheme == 1) {
                                if((pu & 0xff) == 47) {
                                    p = pu->file;
                                    pu->file = allocStr( &(p[1]), -1);
                                }
                            }
                            goto L63;
                        } else {
                            p = pu->file;
                            if(current->file == 0) {
L54:
                                goto L58;
                            } else {
                                tmp = Strnew_charp(current->file);
                                while(tmp->length > 0) {
                                    if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 47) {
                                        Strshrink(tmp, 1);
                                        continue;
                                    } else {
                                    }
                                    break;
                                }
                                Strcat_charp(tmp, p);
                                pu->file = tmp->ptr;
                                relative_uri = 1;
                                goto L54;
                            }
                        }
                        goto L64;
                    } else {
                        p = strchr(current->file, 58);
                        if(p == 0) {
                            goto L43;
                        } else {
                            _t445 = allocStr(current->file, p - current->file);
                            _v36 = pu->file;
                            _v40 = _t445;
                            pu->file =  *(Sprintf(135065880));
                        }
L58:
                        goto L63;
                    }
                }
            }
L64:
            if(pu->scheme != 4 || (pu & 0xff) == 47 || strcmp(pu->file, 135065886) == 0) {
                if(pu->scheme != 0) {
                    if(pu->scheme != 1 && (pu & 0xff) == 47) {
                        pu->file = cleanupName(pu->file);
                    }
                } else {
                    if(relative_uri != 0) {
                        pu->file = cleanupName(pu->file);
                    }
                }
                goto L79;
            } else {
                tmp = Strnew_charp(CurrentDir);
                if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 47) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t350 = tmp->length;
                     *(tmp->ptr + _t350) = 47;
                    tmp->length = _t350 + 1;
                     *(tmp->ptr + tmp->length) = 0;
                }
                Strcat_charp(tmp, file_unquote(pu->file));
                pu->file = file_quote(cleanupName(tmp->ptr));
L79:
                if(pu->scheme != 4) {
                    goto L85;
                }
                pu->real_file = cleanupName(file_unquote(pu->file));
                return;
            }
        }
        goto L12;
    }
L82:
    return;
}

Str _parsedURL2Str(ParsedURL* pu, int pass)
{// addr = 0x0809FEC0  --  defined in 'url.c' at line 1158
    Str tmp;               // _cfa_fffffff0
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t274;                             // _t274
    int _t306;                             // _t306
    int _t322;                             // _t322
    int _t340;                             // _t340
    int _t363;                             // _t363
    int _t386;                             // _t386
    int _t406;                             // _t406
    int _t421;                             // _t421
    int _t452;                             // _t452

    if(pu->scheme == 254) {
        return Strnew_charp(135065888);
    }
    if(pu->scheme == 255) {
        return Strnew_charp(pu->file);
    }
    if(pu->host != 0) {
L8:
        if(pu->scheme != 4 || strcmp(pu->file, 135065886) != 0) {
            tmp = Strnew_charp( *( &scheme_str + pu->scheme * 4));
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t274 = tmp->length;
             *((char*)(tmp->ptr + _t274)) = 58;
            tmp->length = _t274 + 1;
             *((char*)(tmp->ptr + tmp->length)) = 0;
            if(pu->scheme != 11) {
                if(pu->scheme != 9 && pu->scheme != 10) {
                    Strcat_charp(tmp, "//");
                }
                if(pu->user != 0) {
                    Strcat_charp(tmp, pu->user);
                    if(pass != 0 && pu->pass != 0) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t421 = tmp->length;
                         *((char*)(tmp->ptr + _t421)) = 58;
                        tmp->length = _t421 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
                        Strcat_charp(tmp, pu->pass);
                    }
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t406 = tmp->length;
                     *((char*)(tmp->ptr + _t406)) = 64;
                    tmp->length = _t406 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
                if(pu->host != 0) {
                    Strcat_charp(tmp, pu->host);
                    if(pu->port !=  *((intOrPtr*)( &DefaultPort + pu->scheme * 4))) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t386 = tmp->length;
                         *((char*)(tmp->ptr + _t386)) = 58;
                        tmp->length = _t386 + 1;
                         *((char*)(tmp->ptr + tmp->length)) = 0;
                        _v40 = pu->port;
                        Strcat(tmp, Sprintf("%d"));
                    }
                }
                if(pu->scheme != 9 && pu->scheme != 10 && (pu->file == 0 || (pu & 0xff) != 47)) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t363 = tmp->length;
                     *((char*)(tmp->ptr + _t363)) = 47;
                    tmp->length = _t363 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
                Strcat_charp(tmp, pu->file);
                if(pu->scheme == 3 && (tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 47)) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t340 = tmp->length;
                     *((char*)(tmp->ptr + _t340)) = 47;
                    tmp->length = _t340 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                }
                if(pu->query != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t322 = tmp->length;
                     *((char*)(tmp->ptr + _t322)) = 63;
                    tmp->length = _t322 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                    Strcat_charp(tmp, pu->query);
                }
                if(pu->label != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t306 = tmp->length;
                     *((char*)(tmp->ptr + _t306)) = 35;
                    tmp->length = _t306 + 1;
                     *((char*)(tmp->ptr + tmp->length)) = 0;
                    Strcat_charp(tmp, pu->label);
                }
                return tmp;
            }
            Strcat_charp(tmp, pu->file);
            return tmp;
        } else {
            tmp = Strnew_charp(135065886);
            if(pu->label != 0) {
                _t452 = tmp->length;
                 *((char*)(tmp->ptr + _t452)) = 35;
                tmp->length = _t452 + 1;
                 *((char*)(tmp->ptr + tmp->length)) = 0;
                Strcat_charp(tmp, pu->label);
            }
            return tmp;
        }
    } else {
        if(pu->file != 0) {
            goto L8;
        } else {
            if(pu->label == 0) {
                goto L8;
            } else {
                _v40 = pu->label;
                return Sprintf(135065892);
            }
        }
        goto L9;
    }
}

Str parsedURL2Str(ParsedURL* pu)
{// addr = 0x080A03FA  --  defined in 'url.c' at line 1251
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return _parsedURL2Str(pu, 0);
}

int getURLScheme(char** url)
{// addr = 0x080A0415  --  defined in 'url.c' at line 1257
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    int scheme;                            // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    p =  *url;
    scheme = 254;
L2:
    while(( *p & 0xff) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xc) != 0 || ( *p & 0xff) == 46 || ( *p & 0xff) == 43 || ( *p & 0xff) == 45) {
            p =  &(p[1]);
            goto L2;
        } else {
            break;
        }
    }
    if(( *p & 0xff) != 58) {
L14:
        return scheme;
    } else {
        scheme = 255;
        i = 0;
        while(1) {
            q =  *( &schemetable + i * 8);
            if(q == 0) {
                break;
            }
            len = strlen(q);
            if(strncasecmp(q,  *url, len) != 0 || (( *url)[len] & 0xff) != 58) {
                i = i + 1;
                continue;
            } else {
                scheme =  *(135102692 + i * 8);
                 *url =  &(p[1]);
            }
            goto L14;
        }
        goto L14;
    }
}

char* otherinfo(ParsedURL* target, ParsedURL* current, char* referer)
{// addr = 0x080A0505  --  defined in 'url.c' at line 1280
    Str s;                 // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t98;                        // _t98

    s = Strnew();
    Strcat_charp(s, "User-Agent: ");
    if(UserAgent == 0) {
L2:
        Strcat_charp(s, w3m_version);
L4:
        Strcat_charp(s, "\n");
        _v44 = 0;
        _v48 = "\n";
        _v52 = AcceptMedia;
        _v56 = "Accept: ";
        Strcat_m_charp(s);
        _v44 = 0;
        _v48 = "\n";
        _v52 = AcceptEncoding;
        _v56 = "Accept-Encoding: ";
        Strcat_m_charp(s);
        _v44 = 0;
        _v48 = "\n";
        _v52 = AcceptLang;
        _v56 = "Accept-Language: ";
        Strcat_m_charp(s);
        if(target->host != 0) {
            Strcat_charp(s, "Host: ");
            Strcat_charp(s, target->host);
            if(target->port !=  *((intOrPtr*)( &DefaultPort + target->scheme * 4))) {
                _v56 = target->port;
                Strcat(s, Sprintf(":%d"));
            }
            Strcat_charp(s, "\n");
        }
        if(target->is_nocache != 0 || (NoCache & 0xff) != 0) {
            Strcat_charp(s, "Pragma: no-cache\n");
            Strcat_charp(s, "Cache-control: no-cache\n");
        }
        if(NoSendReferer == 0) {
            if(referer != 0 || current == 0 || current->scheme == 4 || current->scheme == 2 && (current->user != 0 || current->pass != 0)) {
                if(referer != 0 && referer != 255) {
                    p = strchr(referer, 35);
                    Strcat_charp(s, "Referer: ");
                    if(p == 0) {
                        Strcat_charp(s, referer);
                    } else {
                        Strcat_charp_n(s, referer, p - referer);
                    }
                    Strcat_charp(s, "\n");
                }
            } else {
                p = current->label;
                Strcat_charp(s, "Referer: ");
                current->label = 0;
                Strcat(s, parsedURL2Str(current));
                current->label = p;
                Strcat_charp(s, "\n");
            }
        }
        return s->ptr;
    }
    if(( *UserAgent & 0xff) != 0) {
        Strcat_charp(s, UserAgent);
        goto L4;
    }
    goto L2;
}

Str HTTPrequestMethod(HRequest* hr)
{// addr = 0x080A07EC  --  defined in 'url.c' at line 1331
    _unknown_ __ebp;                       // r6
    signed int _t5;                        // _t5

    _t5 = hr->command & 0xff;
    if(_t5 == 2) {
        return Strnew_charp("CONNECT");
    }
    if(_t5 == 3) {
        return Strnew_charp("HEAD");
    }
    if(_t5 == 1) {
        goto L5;
    }
    return Strnew_charp("GET");
L5:
    return Strnew_charp("POST");
}

Str HTTPrequestURI(ParsedURL* pu, HRequest* hr)
{// addr = 0x080A0844  --  defined in 'url.c' at line 1350
    Str tmp;               // _cfa_fffffff0
    char* save_label;                      // _cfa_ffffffec
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t60;                        // _t60
    int _t87;                              // _t87

    tmp = Strnew();
    if((hr->command & 0xff) != 2) {
        if((hr->flag & 1) == 0) {
            save_label = pu->label;
            pu->label = 0;
            Strcat(tmp, _parsedURL2Str(pu, 1));
            pu->label = save_label;
        } else {
            Strcat_charp(tmp, pu->file);
            if(pu->query != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t87 = tmp->length;
                 *((char*)(tmp->ptr + _t87)) = 63;
                tmp->length = _t87 + 1;
                 *(tmp->ptr + tmp->length) = 0;
                Strcat_charp(tmp, pu->query);
            }
        }
    } else {
        Strcat_charp(tmp, pu->host);
        _v40 = pu->port;
        Strcat(tmp, Sprintf(":%d"));
    }
    return tmp;
}

Str HTTPrequest(ParsedURL* pu, ParsedURL* current, HRequest* hr, TextList* extra)
{// addr = 0x080A0978  --  defined in 'url.c' at line 1374
    Str tmp;               // _cfa_fffffff0
    TextListItem* i;   // _cfa_ffffffec
    int seen_www_auth;                     // _cfa_ffffffe8
    int seen_proxy_auth;                   // _cfa_ffffffe4
    Str cookie;            // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    long unsigned int _v56;                // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    seen_www_auth = 0;
    seen_proxy_auth = 0;
    tmp = HTTPrequestMethod(hr);
    Strcat_charp(tmp, " ");
    Strcat_charp(tmp,  *(HTTPrequestURI(pu, hr)));
    Strcat_charp(tmp, " HTTP/1.0\n");
    if(hr->referer != 255) {
        Strcat_charp(tmp, otherinfo(pu, current, hr->referer));
    } else {
        Strcat_charp(tmp, otherinfo(pu, 0, 0));
    }
    if(extra == 0) {
L11:
        if((hr->command & 0xff) != 2 && use_cookie != 0) {
            cookie = find_cookie(pu);
            if(cookie != 0) {
                Strcat_charp(tmp, "Cookie: ");
                Strcat(tmp, cookie);
                Strcat_charp(tmp, "\n");
                if((cookie & 0xff) != 36) {
                    Strcat_charp(tmp, "Cookie2: $Version="1"\n");
                }
            }
        }
        if((hr->command & 0xff) != 1) {
            if(header_string != 0) {
                Strcat(tmp, header_string);
            }
            Strcat_charp(tmp, "\n");
        } else {
            if(hr->request->enctype != 1) {
                if(override_content_type == 0) {
                    Strcat_charp(tmp, "Content-type: application/x-www-form-urlencoded\n");
                }
                _v56 = hr->request->length;
                Strcat(tmp, Sprintf("Content-length: %ld\n"));
                if(header_string != 0) {
                    Strcat(tmp, header_string);
                }
                Strcat_charp(tmp, "\n");
                Strcat_charp_n(tmp, hr->request->body, hr->request->length);
                Strcat_charp(tmp, "\n");
            } else {
                Strcat_charp(tmp, "Content-type: multipart/form-data; boundary=");
                Strcat_charp(tmp, hr->request->boundary);
                Strcat_charp(tmp, "\n");
                _v56 = hr->request->length;
                Strcat(tmp, Sprintf("Content-length: %ld\n"));
                Strcat_charp(tmp, "\n");
            }
        }
        return tmp;
    } else {
        i = extra->first;
    }
    while(i != 0) {
        if(strncasecmp(i->ptr, "Proxy-Authorization:", 20) == 0) {
            seen_proxy_auth = 1;
        }
        Strcat_charp(tmp, i->ptr);
        i = i->next;
    }
    goto L11;
}

init_stream(URLFile* uf, int scheme, InputStream stream)
{// addr = 0x080A0CC5  --  defined in 'url.c' at line 1459
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26

    memset(uf, 0, 32);
     *(uf + 4) = stream;
    uf->scheme = scheme & 255;
    uf->encoding = 0;
    uf->is_cgi = 0;
    uf->compression = 0;
    uf->content_encoding = 0;
    uf->guess_type = 0;
    uf->ext = 0;
     *((intOrPtr*)(uf + 28)) = -1;
    return;
}

URLFile openURL(char* url, ParsedURL* pu, ParsedURL* current, URLOption* option, FormList* request, TextList* extra_header, URLFile* ouf, HRequest* hr, unsigned char* status)
{// addr = 0x080A0D3B  --  defined in 'url.c' at line 1474
    Str tmp;               // _cfa_fffffff0
    int sock;                              // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe4
    char* q;                               // _cfa_ffffffe0
    HRequest hr0;     // _cfa_ffffffc8
    FILE* ff;             // _cfa_ffffffd4
    int scheme;                            // _cfa_ffffffe8
    char* u;                               // _cfa_ffffffdc
    Str tmp2;              // _cfa_ffffffd8
    struct _Str _v64;     // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    URLFile uf;        // _cfa_ffffffa8
    _unknown_ _v100;                       // _cfa_ffffff9c
    _unknown_ _v104;                       // _cfa_ffffff98
    struct  __ebx;            // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t152;                       // _t152
    URLFile* _t179;    // _t179

    __ebx = _a4;
    if(hr == 0) {
        hr =  &(_v64.area_size.command);
    }
    if(ouf == 0) {
        init_stream( &(uf.scheme), 254, 0);
    } else {
        _t179 = ouf;
        uf.scheme =  *_t179;
        _v84 =  *((intOrPtr*)(_t179 + 4));
        _v80 = _t179->ext;
        _v76 = _t179->compression;
        _v72 = _t179->content_encoding;
        _v68 = _t179->guess_type;
        _v64.ptr = _t179->url;
        _v64.length =  *((intOrPtr*)(_t179 + 28));
    }
    u = url;
    scheme = getURLScheme( &u);
    if(current != 0 || scheme != 254 || (ArgvIsURL & 0xff) != 0) {
        u = url;
    } else {
        u = file_to_url(url);
    }
    parseURL2(u, pu, current);
    if(pu->scheme != 4 || pu->file != 0) {
L15:
        uf.scheme = pu->scheme & 255;
        _v64.ptr =  *(parsedURL2Str(pu));
        pu->is_nocache = option->flag & 1;
        _v80 = filename_extension(pu->file, 1);
        hr->command = 0;
        hr->flag = 0;
        hr->referer = option->referer;
        hr->request = request;
        if(pu->scheme > 11) {
             *__ebx = uf.scheme;
             *((intOrPtr*)(__ebx + 4)) = _v84;
             *(__ebx + 8) = _v80;
             *(__ebx + 12) = _v76;
             *(__ebx + 16) = _v72;
             *(__ebx + 20) = _v68;
             *(__ebx + 24) = _v64.ptr;
             *((intOrPtr*)(__ebx + 28)) = _v64.length;
            goto L18;
        }
    } else {
        if(pu->label == 0) {
             *__ebx = uf.scheme;
             *((intOrPtr*)(__ebx + 4)) = _v84;
             *(__ebx + 8) = _v80;
             *(__ebx + 12) = _v76;
             *(__ebx + 16) = _v72;
             *(__ebx + 20) = _v68;
             *(__ebx + 24) = _v64;
             *((intOrPtr*)(__ebx + 28)) = _v64.length;
L18:
            return __ebx;
        }
        tmp2 = Strnew_charp("#");
        Strcat_charp(tmp2, pu->label);
        pu->file = tmp2->ptr;
        pu->real_file = cleanupName(file_unquote(pu->file));
        pu->label = 0;
        goto L15;
    }
    goto __eax;
}

add_index_file(ParsedURL* pu, URLFile* uf)
{// addr = 0x080A1AD3  --  defined in 'url.c' at line 1807
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t31;                            // _t31

    if(index_file == 0 || ( *index_file & 0xff) == 0) {
         *((intOrPtr*)(uf + 4)) = 0;
        return;
    }
    _t31 = file_quote(index_file);
    _v32 = 0;
    _v36 = _t31;
    _v40 = 135065749;
    p =  *(Strnew_m_charp(pu->file));
    p = cleanupName(p);
    q = cleanupName(file_unquote(p));
    examineFile(q, uf);
    if( *((intOrPtr*)(uf + 4)) != 0) {
        pu->file = p;
        pu->real_file = q;
        return;
    }
    return;
}

char* guessContentTypeFromTable(struct table2* table, char* filename)
{// addr = 0x080A1B89  --  defined in 'url.c' at line 1827
    struct table2* t;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t60;                        // _t60
    _unknown_ _t61;                        // _t61
    _unknown_ _t64;                        // _t64

    if(table != 0) {
        p = strlen(filename) - 1 + filename;
L4:
        while(filename < p && ( *p & 0xff) != 46) {
            goto L3;
        }
        if(p != filename) {
            p =  &(p[1]);
            t = table;
L12:
            while(t->item1 != 0) {
                goto L9;
            }
            t = table;
            while(t->item1 != 0) {
                if(strcasecmp(p, t->item1) != 0) {
                    t = t + 8;
                    continue;
                }
                return t->item2;
            }
            return 0;
        }
        return 0;
L9:
        if(strcmp(p, t->item1) != 0) {
            t = t + 8;
            goto L12;
        }
        return t->item2;
    }
    return 0;
L3:
    p = p - 1;
    goto L4;
}

char* guessContentType(char* filename)
{// addr = 0x080A1C4F  --  defined in 'url.c' at line 1851
    char* ret;                             // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25

    if(filename != 0) {
        if(mimetypes_list == 0) {
            goto L10;
        }
        goto L3;
L10:
        return guessContentTypeFromTable( &DefaultGuess, filename);
    }
    return 0;
L3:
    i = 0;
    while(1) {
        asm("cwde ");
        if((mimetypes_list->nitem & 65535) <= i) {
            break;
        }
        ret = guessContentTypeFromTable(UserMimeTypes[i], filename);
        if(ret == 0) {
            i = i + 1;
            continue;
        }
        return ret;
    }
    goto L10;
}

TextList* make_domain_list(char* domain_list)
{// addr = 0x080A1CCB  --  defined in 'url.c' at line 1872
    char* p;                               // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    TextList* domains;   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    domains = 0;
    p = domain_list;
    tmp = Strnew_size(64);
    while(( *p & 0xff) != 0) {
        while(1) {
            p =  *p & 255;
            if(( *p & 0xff) == 0) {
                break;
            }
            p =  *p & 255;
             *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
             *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 2;
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        __eax = tmp;
        Strclear(tmp);
        while(1) {
            p =  *p & 255;
            if(( *p & 0xff) == 0) {
                break;
            }
            p =  *p & 255;
             *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
             *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 2;
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                break;
            }
            p =  *p & 255;
            if(( *p & 0xff) != 44) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                tmp = tmp;
                __eax = tmp->length;
                __eax = p;
                __edx =  *p & 255;
                (__eax)[tmp->ptr] =  *p & 0xff;
                __edx =  &((__eax)[1]);
                __eax = tmp;
                tmp->length = __edx;
                p =  &(p[1]);
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        tmp = tmp->length;
        if(tmp->length > 0) {
            if(domains == 0) {
                domains = newGeneralList();
            }
            tmp = tmp->ptr;
            __eax = allocStr(tmp->ptr, -1);
            __edx = domains;
            pushValue(domains, tmp->ptr);
        }
        while(1) {
            p =  *p & 255;
            if(( *p & 0xff) == 0) {
                break;
            }
            p =  *p & 255;
             *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
             *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 2;
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        p =  *p & 255;
        if(( *p & 0xff) == 44) {
            p =  &(p[1]);
        }
    }
    return domains;
}

int domain_match(char* pat, char* domain)
{// addr = 0x080A1E39  --  defined in 'url.c' at line 1900
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25

    if(domain != 0) {
        if(( *pat & 0xff) == 46) {
            pat =  &(pat[1]);
        }
        while(strcasecmp(pat, domain) != 0) {
            domain = strchr(domain, 46);
            if(domain != 0) {
                domain =  &(domain[1]);
                continue;
            }
            return 0;
        }
        return 1;
    }
    return 0;
}

int check_no_proxy(char* domain)
{// addr = 0x080A1EA2  --  defined in 'url.c' at line 1917
    intOrPtr _v16;                         // _cfa_fffffff0
    char[63] addr;                         // _cfa_ffffffb0
    TextListItem* tl;   // _cfa_ffffffac
    _None ret;                             // _cfa_ffffffa8
    _None prevtrap;                        // _cfa_ffffffa4
    int error;                             // _cfa_ffffffa0
    struct addrinfo* res;   // _cfa_ffffff9c
    struct addrinfo* res0;   // _cfa_ffffff98
    int* af;                               // _cfa_ffffff94
    struct addrinfo hints;   // _cfa_ffffff74
    char* _v144;                           // _cfa_ffffff70
    struct addrinfo** _v160;   // _cfa_ffffff60
    char[63]* _v164;                       // _cfa_ffffff5c
    char* _v168;                           // _cfa_ffffff58
    _unknown_ __ebp;                       // r6
    _unknown_ _t91;                        // _t91
    _None _t93;                            // _t93
    int _t103;                             // _t103
    _unknown_ _t112;                       // _t112
    int _t115;                             // _t115
    int _t118;                             // _t118
    _unknown_ _t141;                       // _t141
    _unknown_ _t152;                       // _t152
    int _t162;                             // _t162

    _v144 = _a4;
    _v16 =  *gs:0x14];
    ret = 0;
    prevtrap = 0;
    if(NO_proxy_domains == 0 || (NO_proxy_domains->nitem & 0xffff) == 0) {
L3:
        _t93 = 0;
L44:
        if(_t162 == 0) {
            return _t93;
        }
        __stack_chk_fail();
        return _t93;
    }
    _t162 = _v144;
    if(_t162 != 0) {
        tl = NO_proxy_domains->first;
        while(tl != 0) {
            if(domain_match(tl->ptr, _v144) == 0) {
                tl = tl->next;
                continue;
            } else {
                _t93 = 1;
            }
            goto L44;
        }
        goto L9;
    }
    goto L3;
L9:
    _t103 = NOproxy_netaddr;
    if(_t103 != 0) {
        _v168 = 1;
         *__esp =  &AbortLoading;
        __sigsetjmp();
        if(_t103 == 0) {
            if((TrapSignal & 0xff) != 0) {
                prevtrap = mySignal(2, KeyAbort);
                if((fmInitialized & 0xff) != 0) {
                    term_cbreak();
                }
            }
            af =  &ai_family_order_table + (DNS_order + DNS_order + _t154 << 2);
            while(1) {
                memset( &(hints.ai_flags), 0, 32);
                hints.ai_family =  *af;
                _t115 = _v144;
                _v160 =  &res0;
                _v164 =  &(hints.ai_flags);
                _v168 = 0;
                 *__esp = _t115;
                getaddrinfo();
                error = _t115;
                if(error != 0) {
                    break;
                }
                res = res0;
                while(res != 0) {
                    _t118 = res->ai_family;
                    if(_t118 == 2) {
                        _v160 = 64;
                        _v164 =  &addr;
                        _v168 =  &(res->ai_addr->sa_data[2]);
                         *__esp = 2;
                        inet_ntop();
                        goto L26;
                    }
                    if(_t118 == 10) {
                        goto L25;
                    }
L31:
                    res = res->ai_next;
                    continue;
L26:
                    tl = NO_proxy_domains->first;
                    while(tl != 0) {
                        if(strncmp(tl->ptr,  &addr, strlen(tl->ptr)) != 0) {
                            tl = tl->next;
                            continue;
                        }
                         *__esp = res0;
                        freeaddrinfo();
                        ret = 1;
L38:
                        if((TrapSignal & 0xff) != 0) {
                            if((fmInitialized & 0xff) != 0) {
                                term_raw();
                            }
                            if(prevtrap != 0) {
                                mySignal(2, prevtrap);
                            }
                        }
                        _t93 = ret;
                        goto L44;
                    }
                    goto L31;
L25:
                    _v160 = 64;
                    _v164 =  &addr;
                    _v168 =  &(res->ai_addr->sa_data[6]);
                     *__esp = 10;
                    inet_ntop();
                    goto L26;
                }
                 *__esp = res0;
                freeaddrinfo();
                if( *af == 0) {
                    goto L38;
                }
L36:
                af =  &(af[1]);
            }
            if( *af != 0) {
                goto L36;
            }
            goto L38;
        }
        goto L12;
    }
    _t93 = 0;
    goto L44;
L12:
    ret = 0;
    goto L38;
}

char* filename_extension(char* path, int is_url)
{// addr = 0x080A2170  --  defined in 'url.c' at line 2022
    char* last_dot;                        // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    last_dot = 135065832;
    p = path;
    if(path == 0) {
        return last_dot;
    }
    if(( *p & 0xff) == 46) {
        p =  &(p[1]);
    }
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) != 46) {
            if(is_url == 0 || ( *p & 0xff) != 63) {
L8:
                p =  &(p[1]);
                continue;
            }
L13:
            if(( *last_dot & 0xff) != 46) {
                return last_dot;
            }
            i = 1;
            while((last_dot[i] & 0xff) != 0) {
                if(i <= 7) {
                    if(is_url == 0 || ( *( &MYCTYPE_MAP + (last_dot[i] & 0xff)) & 0xc) != 0) {
                        i = i + 1;
                        continue;
                    }
                    break;
                }
                break;
            }
            return allocStr(last_dot, i);
            return __eax;
        }
        last_dot = p;
        goto L8;
    }
    goto L13;
}

struct table2* loadURIMethods(char* filename)
{// addr = 0x080A2240  --  defined in 'url.c' at line 2057
    FILE* f;              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    Str tmp;               // _cfa_ffffffe4
    struct table2* um;   // _cfa_ffffffe0
    char* up;                              // _cfa_ffffffdc
    char* p;                               // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t101;                       // _t101
    struct table2* _t105;   // _t105
    _unknown_ _t120;                       // _t120
    _unknown_ _t122;                       // _t122

    f = fopen(expandPath(filename), 135065742);
    if(f != 0) {
        i = 0;
        while(1) {
L5:
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            goto L3;
        }
        fseek(f, 0, 0);
        n = i;
        _t105 =  &((1)[n]) << 3;
         *__esp = _t105;
        GC_malloc();
        um = _t105;
        i = 0;
        while(1) {
            tmp = Strfgets(f);
            if(tmp->length <= 0) {
                break;
            }
            if(( *(tmp->ptr) & 0xff) != 35) {
                while(1) {
                    tmp = tmp->length;
                    if(tmp->length <= 0) {
                        __eax = 0;
                    } else {
                        tmp = tmp;
                        tmp->length = tmp->length - 1;
                        tmp->ptr + tmp->length - 1 =  *(tmp->ptr + tmp->length - 1) & 255;
                        __eax =  *(tmp->ptr + tmp->length - 1) & 0xff;
                    }
                    __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                    __eax = __eax & 0xff;
                    if(__eax == 0) {
                        break;
                    }
                    _v56 = 1;
                    __eax = tmp;
                     *__esp = tmp;
                    Strshrink();
                }
                tmp = tmp->ptr;
                p = tmp->ptr;
                __eax = p;
                up = p;
                while(1) {
                    p =  *p & 255;
                    if(( *p & 0xff) == 0) {
                        break;
                    }
                    p =  *p & 255;
                    if(( *p & 0xff) != 58) {
                        p =  &(p[1]);
                        continue;
                    }
                    i = i << 3;
                    up = p - up;
                    _v56 = p - up;
                    __eax = up;
                     *__esp = up;
                    Strnew_charp_n() =  *up;
                    um[i].item1 =  *up;
                    p =  &(p[1]);
                    break;
                }
                p =  *p & 255;
                if(( *p & 0xff) != 0) {
L23:
                    while(1) {
                        p =  *p & 255;
                        if(( *p & 0xff) == 0) {
                            break;
                        }
                        p =  *p & 255;
                         *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
                         *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 2;
                        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                            p =  &(p[1]);
                            continue;
                        }
                        break;
                    }
                    i = i << 3;
                    p = Strnew_charp(p);
                    __eax =  *p;
                     &(um[i])->item2 =  *p;
                    i =  &((1)[i]);
                    continue;
                }
                continue;
            }
        }
        um[i] = 0;
         &(um[i])->item2 = 0;
        fclose(f);
        return um;
    }
    return 0;
L3:
    if((tmp & 0xff) != 35) {
        i =  &((1)[i]);
    }
    goto L5;
}

initURIMethods()
{// addr = 0x080A2445  --  defined in 'url.c' at line 2103
    TextList* methodmap_list;   // _cfa_fffffff0
    TextListItem* tl;   // _cfa_ffffffec
    int i;                                 // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    struct table2** _t25;   // _t25

    methodmap_list = 0;
    if(non_null(urimethodmap_files) != 0) {
        methodmap_list = make_domain_list(urimethodmap_files);
    }
    if(methodmap_list != 0) {
        asm("cwde ");
        _t25 = (methodmap_list->nitem & 65535) + 1 << 2;
         *__esp = _t25;
        GC_malloc();
        urimethods = _t25;
        i = 0;
        tl = methodmap_list->first;
        while(tl != 0) {
            urimethods[i] = loadURIMethods(tl->ptr);
            if(urimethods[i] != 0) {
                i = i + 1;
            }
            tl = tl->next;
        }
        urimethods[i] = 0;
        return;
    }
    return;
}

Str searchURIMethods(ParsedURL* pu)
{// addr = 0x080A2509  --  defined in 'url.c' at line 2123
    struct table2* ump;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    Str scheme;            // _cfa_ffffffe8
    Str url;               // _cfa_ffffffe4
    char* p;                               // _cfa_ffffffe0
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t77;                        // _t77
    _unknown_ _t78;                        // _t78
    _unknown_ _t79;                        // _t79
    _unknown_ _t80;                        // _t80

    scheme = 0;
    if(pu->scheme == 255) {
        if(urimethods != 0) {
            url = parsedURL2Str(pu);
            p = url->ptr;
L8:
            while(( *p & 0xff) != 0) {
                goto L5;
            }
L9:
            if(scheme != 0) {
                i = 0;
                while(1) {
                    ump = urimethods[i];
                    if(ump == 0) {
                        break;
                    }
                    while(1) {
L16:
                        ump = ump->item1;
                        if(ump->item1 == 0) {
                            break;
                        }
                        goto L12;
                    }
                    i = i + 1;
                }
                ump =  &default_urimethods;
                while(ump->item1 != 0) {
                    if(strcasecmp(ump->item1, scheme->ptr) != 0) {
                        ump = ump + 8;
                        continue;
                    }
                    _v56 = url_quote(url->ptr);
                    return Sprintf(ump->item2);
                }
                return 0;
            }
            return 0;
L12:
            scheme = ump;
            ump->item1 = strcasecmp(ump->item1, scheme->ptr);
            if(ump->item1 != 0) {
                ump = ump + 8;
                goto L16;
            }
            url = url->ptr;
            __eax = url_quote(url->ptr);
            _v56 = url->ptr;
            __eax = Sprintf(ump->item2);
            return url->ptr;
        }
        goto L3;
L5:
        if(( *p & 0xff) != 58) {
            p =  &(p[1]);
            goto L8;
        }
        scheme = Strnew_charp_n(url->ptr, p - url->ptr);
        goto L9;
    }
    return 0;
L3:
    return 0;
}

chkExternalURIBuffer(Buffer* buf)
{// addr = 0x080A266A  --  defined in 'url.c' at line 2180
    int i;                                 // _cfa_fffffff0
    struct table2* ump;   // _cfa_ffffffec
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t34;                        // _t34

    i = 0;
    while(1) {
        ump = urimethods[i];
        if(ump == 0) {
            break;
        }
        while(ump->item1 != 0) {
            _v36 = "([-;/?:&=+$,a-zA-Z0-9_.!~*'()]|%[0-9A-Fa-f][0-9A-Fa-f])*";
            _v40 = ump->item1;
            Sprintf(135065880);
            reAnchor(buf,  *(ump->item1));
            ump = ump + 8;
        }
        i = i + 1;
    }
    ump =  &default_urimethods;
    while(ump->item1 != 0) {
        _v36 = "([-;/?:&=+$,a-zA-Z0-9_.!~*'()]|%[0-9A-Fa-f][0-9A-Fa-f])*";
        _v40 = ump->item1;
        reAnchor(buf,  *(Sprintf(135065880)));
        ump = ump + 8;
    }
    return;
}

ParsedURL* schemeToProxy(int scheme)
{// addr = 0x080A2719  --  defined in 'url.c' at line 2197
    ParsedURL* pu;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    int _t7;                               // _t7

    pu = 0;
    _t7 = scheme;
    if(_t7 == 1) {
        pu =  &GOPHER_proxy_parsed;
    } else {
        if(_t7 == 2) {
            pu =  &FTP_proxy_parsed;
        } else {
            if(_t7 == 0) {
                pu =  &HTTP_proxy_parsed;
            }
        }
    }
    return pu;
}

KeyAbort(int _dummy)
{// addr = 0x080A2758  --  defined in 'ftp.c' at line 45
    intOrPtr _v0;                          // _cfa_0
    struct _Str* _v20;    // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v60;                        // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    _unknown_ __ebp;                       // r6
    _unknown_ _t159;                       // _t159
    _unknown_ _t167;                       // _t167
    _unknown_ _t170;                       // _t170
    _unknown_ _t174;                       // _t174
    _unknown_ _t181;                       // _t181
    _unknown_ _t182;                       // _t182

    _v24 = 1;
    __esp->ptr =  &AbortLoading;
    siglongjmp();
    _push(_t181);
    __esp = __esp - 40;
    if( *_v24 == 0) {
        return 0;
    }
    if(_dummy != 0) {
        if(_a8 == 0) {
            _v68 = _dummy;
            _v20 = Sprintf("%s\n");
        } else {
            _v64 = _a8;
            _v68 = _dummy;
            _v20 = Sprintf("%s %s\n");
        }
        fwrite( *_v20, 1, _v20->length,  *(_v0 + 20));
        fflush( *(_v0 + 20));
    }
    if(_a12 != 0) {
         *_a12 = -1;
        _v20 = StrISgets( *(_v0 + 16));
        if(( *( &MYCTYPE_MAP + ( *( *_v20) & 0xff)) & 8) != 0 && ( *( &MYCTYPE_MAP + ( *( *_v20 + 1) & 0xff)) & 8) != 0 && ( *( &MYCTYPE_MAP + ( *( *_v20 + 2) & 0xff)) & 8) != 0 && ( *( *_v20 + 3) & 0xff) == 32) {
            _v64 = _a12;
            _v68 = "%d";
            __esp->ptr =  *_v20;
            __isoc99_sscanf();
        }
        if(( *( *_v20 + 3) & 0xff) == 45) {
            while(1) {
L21:
                _v20 = StrISgets( *(_v0 + 16));
                if(( *( &MYCTYPE_MAP + ( *( *_v20) & 0xff)) & 8) == 0) {
                    break;
                }
                if(( *( &MYCTYPE_MAP + ( *( *_v20 + 1) & 0xff)) & 8) == 0) {
                    continue;
                }
                if(( *( &MYCTYPE_MAP + ( *( *_v20 + 2) & 0xff)) & 8) == 0) {
                    goto L19;
                }
                if(( *( *_v20 + 3) & 0xff) != 32) {
                    goto L20;
                }
                _v64 = _a12;
                _v68 = "%d";
                 *__esp =  *_v20;
                __isoc99_sscanf();
                return _v20;
L20:
L19:
            }
            goto L21;
        }
        return _v20;
    }
    return 0;
}

Str ftp_command(FTP ftp, char* cmd, char* arg, int* status)
{// addr = 0x080A2772  --  defined in 'ftp.c' at line 52
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    int* _v36;                             // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t158;                       // _t158
    _unknown_ _t166;                       // _t166
    _unknown_ _t169;                       // _t169
    _unknown_ _t173;                       // _t173

    if(ftp->host == 0) {
        return 0;
    }
    if(cmd != 0) {
        if(arg == 0) {
            _v40 = cmd;
            tmp = Sprintf("%s\n");
        } else {
            _v36 = arg;
            _v40 = cmd;
            tmp = Sprintf("%s %s\n");
        }
        fwrite(tmp->ptr, 1, tmp->length, ftp->wf);
        fflush(ftp->wf);
    }
    if(status != 0) {
         *status = -1;
        tmp = StrISgets( *(ftp + 16));
        if(( *( &MYCTYPE_MAP + (tmp & 0xff)) & 8) != 0 && ( *( &MYCTYPE_MAP + (tmp->ptr[1] & 0xff)) & 8) != 0 && ( *( &MYCTYPE_MAP + (tmp->ptr[2] & 0xff)) & 8) != 0 && (tmp->ptr[3] & 0xff) == 32) {
            _v36 = status;
            _v40 = "%d";
             *__esp = tmp->ptr;
            __isoc99_sscanf();
        }
        if((tmp->ptr[3] & 0xff) == 45) {
            while(1) {
L20:
                tmp = StrISgets( *(ftp + 16));
                if(( *( &MYCTYPE_MAP + (tmp & 0xff)) & 8) == 0) {
                    break;
                }
                if(( *( &MYCTYPE_MAP + (tmp->ptr[1] & 0xff)) & 8) == 0) {
                    continue;
                }
                if(( *( &MYCTYPE_MAP + (tmp->ptr[2] & 0xff)) & 8) == 0) {
                    goto L18;
                }
                if((tmp->ptr[3] & 0xff) != 32) {
                    goto L19;
                }
                _v36 = status;
                _v40 = "%d";
                 *__esp = tmp->ptr;
                __isoc99_sscanf();
                return tmp;
L19:
L18:
            }
            goto L20;
        }
        return tmp;
    }
    return 0;
}

ftp_close(FTP ftp)
{// addr = 0x080A2972  --  defined in 'ftp.c' at line 97
    _unknown_ __ebp;                       // r6
    _unknown_ _t40;                        // _t40
    _unknown_ _t44;                        // _t44
    _unknown_ _t50;                        // _t50

    if(ftp->host != 0) {
        if( *(ftp + 16) != 0) {
            ( *(ftp + 16))[0x14] = ( *(ftp + 16))[0x14] & 0xef;
            ISclose( *(ftp + 16));
             *(ftp + 16) = 0;
        }
        if(ftp->wf != 0) {
            fclose(ftp->wf);
            ftp->wf = 0;
        }
        if(ftp->data != 0) {
            fclose(ftp->data);
            ftp->data = 0;
        }
        ftp->host = 0;
        return;
    }
    return;
}

int ftp_login(FTP ftp)
{// addr = 0x080A2A10  --  defined in 'ftp.c' at line 119
    intOrPtr _v16;                         // _cfa_fffffff0
    struct sockaddr_in sockname;   // _cfa_ffffffe0
    int sock;                              // _cfa_ffffffdc
    int status;                            // _cfa_ffffffd8
    size_t n;           // _cfa_ffffffd4
    int socknamelen;                       // _cfa_ffffffd0
    struct hostent* sockent;   // _cfa_ffffffcc
    Str tmp;               // _cfa_ffffffc8
    struct _FTP* _v64;    // _cfa_ffffffc0
    int _v92;                              // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    short unsigned int* _v104;             // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    _unknown_ _t107;                       // _t107
    int _t112;                             // _t112
    _unknown_ _t127;                       // _t127
    _unknown_ _t133;                       // _t133
    _unknown_ _t140;                       // _t140
    int _t157;                             // _t157
    struct hostent* _t164;   // _t164
    signed int _t165;                      // _t165
    _unknown_ _t173;                       // _t173
    _unknown_ _t200;                       // _t200

    _v64 = _a4;
    _v16 =  *gs:0x14];
    sock = openSocket( *_v64, "ftp", 21);
    if(sock >= 0) {
        goto L27;
    }
    if(ftppass_hostnamegen == 0 || strcmp(_v64->user, "anonymous") != 0) {
L10:
         *(_v64 + 16) = newInputStream(sock);
        _v64->wf = fdopen(dup(sock), "wb");
        if( *(_v64 + 16) == 0 || _v64->wf == 0) {
L27:
            ftp_close(_v64);
            _t112 = 0;
        } else {
             *(_v64 + 16)->base.stream.cur = ( *(_v64 + 16)->base.stream.cur & 255 | 16) & 255;
            ftp_command(_v64, 0, 0,  &status);
            if(status != 220) {
                goto L24;
            }
            if((fmInitialized & 0xff) != 0) {
                _v104 = _v64->user;
                message( *(Sprintf("Sending FTP username (%s) to remote server.")), 0, 0);
                refresh();
            }
            ftp_command(_v64, "USER", _v64->user,  &status);
            if(status != 230) {
                if(status != 331) {
                    goto L25;
                }
                if((fmInitialized & 0xff) != 0) {
                    message("Sending FTP password to remote server.", 0, 0);
                    refresh();
                }
                ftp_command(_v64, "PASS", _v64->pass,  &status);
                _t200 = status - 230;
                if(_t200 != 0) {
                    goto L26;
                } else {
                    goto L22;
                }
                goto L27;
L26:
                goto L27;
            }
L22:
            _t112 = 1;
            goto L28;
L25:
            goto L27;
        }
L28:
        if(_t200 == 0) {
            return _t112;
        }
        __stack_chk_fail();
        return _t112;
    } else {
        n = strlen(_v64->pass);
        if(n == 0 || (_v64->pass[n - 1] & 0xff) != 64) {
            goto L10;
        }
        socknamelen = 16;
        _v100 =  &socknamelen;
        _v104 =  &(sockname.sin_family);
        _t157 = sock;
         *__esp = _t157;
        getsockname();
        if(_t157 != 0) {
            goto L10;
        }
        tmp = Strnew_charp(_v64->pass);
        _v100 = sockname.sin_family & 0xffff;
        _v104 = 4;
        _t164 =  &(( &(sockname.sin_family))[2]);
         *__esp = _t164;
        gethostbyaddr();
        sockent = _t164;
        if(sockent == 0) {
            _t165 = sockname.sin_addr;
             *__esp = _t165;
            inet_ntoa();
            _v92 = 0;
            _v96 = "]";
            _v100 = _t165;
            _v104 = "[";
            Strcat_m_charp(tmp);
        } else {
            Strcat_charp(tmp, sockent->h_name);
        }
        _v64->pass = tmp->ptr;
        goto L10;
    }
L24:
    goto L27;
}

int ftp_pasv(FTP ftp)
{// addr = 0x080A2D03  --  defined in 'ftp.c' at line 185
    intOrPtr _v16;                         // _cfa_fffffff0
    char[45] abuf;                         // _cfa_ffffffc2
    struct sockaddr_storage sockaddr;   // _cfa_ffffff40
    unsigned char d1;                      // _cfa_ffffff3f
    unsigned char d2;                      // _cfa_ffffff3e
    unsigned char d3;                      // _cfa_ffffff3d
    unsigned char d4;                      // _cfa_ffffff3c
    int status;                            // _cfa_ffffff38
    int n1;                                // _cfa_ffffff34
    int n2;                                // _cfa_ffffff30
    int n3;                                // _cfa_ffffff2c
    int n4;                                // _cfa_ffffff28
    int p1;                                // _cfa_ffffff24
    int p2;                                // _cfa_ffffff20
    int data;                              // _cfa_ffffff1c
    char* p;                               // _cfa_ffffff18
    Str tmp;               // _cfa_ffffff14
    int family;                            // _cfa_ffffff10
    int sockaddrlen;                       // _cfa_ffffff0c
    int port;                              // _cfa_ffffff08
    struct _FTP* _v256;   // _cfa_ffffff00
    int* _v272;                            // _cfa_fffffef0
    unsigned char* _v276;                  // _cfa_fffffeec
    int* _v280;                            // _cfa_fffffee8
    unsigned char* _v284;                  // _cfa_fffffee4
    unsigned char* _v288;                  // _cfa_fffffee0
    unsigned char* _v292;                  // _cfa_fffffedc
    char* _v296;                           // _cfa_fffffed8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t147;                       // _t147
    signed int _t150;                      // _t150
    int _t153;                             // _t153
    signed int _t162;                      // _t162
    int _t176;                             // _t176
    signed int _t180;                      // _t180
    signed int _t191;                      // _t191
    char* _t194;                           // _t194
    short unsigned int* _t199;             // _t199
    signed int _t205;                      // _t205
    _unknown_ _t228;                       // _t228

    _v256 = _a4;
    _v16 =  *gs:0x14];
    sockaddrlen = 128;
    _t150 = fileno(_v256->wf);
    _v292 =  &sockaddrlen;
    _v296 =  &(sockaddr.ss_family);
     *__esp = _t150;
    getpeername();
    __eflags = _t150;
    if(__eflags >= 0) {
        family = sockaddr.ss_family & 0xffff;
        _t153 = family;
        __eflags = _t153 - 2;
        if(_t153 == 2) {
L20:
            tmp = ftp_command(_v256, "PASV", 0,  &status);
            __eflags = status - 227;
            if(__eflags == 0) {
                p =  &(tmp->ptr[4]);
                while(1) {
L24:
                    _t162 =  *p & 255;
                    __eflags = _t162 & 255;
                    if((_t162 & 255) == 0) {
                        break;
                    }
                    _t180 =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
                    __eflags = _t180 & 8;
                    if((_t180 & 8) == 0) {
                        goto L23;
                    }
                    break;
                }
                __eflags =  *p & 0xff;
                if(__eflags != 0) {
                    _v272 =  &p2;
                    _v276 =  &p1;
                    _v280 =  &n4;
                    _v284 =  &n3;
                    _v288 =  &n2;
                    _v292 =  &n1;
                    _v296 = "%d,%d,%d,%d,%d,%d";
                     *__esp = p;
                    __isoc99_sscanf();
                    _v284 = n4;
                    _v288 = n3;
                    _v292 = n2;
                    _v296 = n1;
                    tmp = Sprintf("%d.%d.%d.%d");
                    data = openSocket(tmp->ptr, 135066584, (p1 << 8) + p2 & 0xffff);
L30:
                    __eflags = data;
                    if(__eflags >= 0) {
                        _v256->data = fdopen(data, "rb");
                        _t176 = 0;
                    } else {
                        _t176 = -1;
                    }
                    goto L33;
                }
                _t176 = -1;
                goto L33;
            }
            goto L21;
L23:
            p =  &(p[1]);
            goto L24;
        }
        goto L3;
L21:
        _t176 = -1;
        goto L33;
    }
    _t176 = -1;
L33:
    if(__eflags == 0) {
        return _t176;
    }
    __stack_chk_fail();
    return _t176;
L3:
    __eflags = _t153 - 10;
    if(__eflags != 0) {
        _t176 = -1;
        goto L33;
    }
    tmp = ftp_command(_v256, "EPSV", 0,  &status);
    __eflags = status - 229;
    if(__eflags == 0) {
        p =  &(tmp->ptr[4]);
        while(1) {
L8:
            _t191 =  *p & 255;
            __eflags = _t191 & 255;
            if((_t191 & 255) == 0) {
                break;
            }
            _t205 =  *p & 255;
            __eflags = (_t205 & 255) - 40;
            if((_t205 & 255) != 40) {
                goto L7;
            }
            break;
        }
        __eflags =  *p & 0xff;
        if(__eflags != 0) {
            p =  &(p[1]);
            _t194 = p;
            _v276 =  &d4;
            _v280 =  &port;
            _v284 =  &d3;
            _v288 =  &d2;
            _v292 =  &d1;
            _v296 = "%c%c%c%d%c";
             *__esp = _t194;
            __isoc99_sscanf();
            __eflags = _t194 - 5;
            if(__eflags != 0) {
L16:
                _t176 = -1;
                goto L33;
            }
            goto L13;
L17:
            _t199 =  &(sockaddr.ss_family);
            _v276 = 1;
            _v280 = 0;
            _v284 = 0;
            _v288 = 46;
            _v292 =  &abuf;
            _v296 = sockaddrlen;
             *__esp = _t199;
            getnameinfo();
            __eflags = _t199;
            if(__eflags == 0) {
                data = openSocket( &abuf, 135066584, port & 0xffff);
                goto L30;
            }
L18:
            _t176 = -1;
            goto L33;
        }
        _t176 = -1;
        goto L33;
L13:
        __eflags = (d1 & 0xff) - (d2 & 0xff);
        if(__eflags != 0) {
            goto L16;
        }
        __eflags = (d1 & 0xff) - (d3 & 0xff);
        if(__eflags != 0) {
            goto L16;
        }
        __eflags = (d1 & 0xff) - (d4 & 0xff);
        if(__eflags == 0) {
            goto L17;
        }
        goto L16;
    }
    _t176 = -1;
    goto L33;
L7:
    p =  &(p[1]);
    goto L8;
}

time_t ftp_modtime(FTP ftp, char* path)
{// addr = 0x080A30EC  --  defined in 'ftp.c' at line 252
    int status;                            // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    time_t t;           // _cfa_ffffffe4
    time_t lt;          // _cfa_ffffffe0
    time_t gt;          // _cfa_ffffffdc
    struct tm tm;           // _cfa_ffffffb0
    int* _v96;                             // _cfa_ffffffa0
    int* _v100;                            // _cfa_ffffff9c
    int* _v104;                            // _cfa_ffffff98
    int* _v108;                            // _cfa_ffffff94
    int* _v112;                            // _cfa_ffffff90
    int* _v116;                            // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t61;                        // _t61
    char* _t62;                            // _t62
    long int _t67;                         // _t67
    long int _t68;                         // _t68
    long int _t69;                         // _t69
    _unknown_ _t73;                        // _t73
    _unknown_ _t76;                        // _t76

    tmp = ftp_command(ftp, "MDTM", path,  &status);
    if(status == 213) {
        p =  &(tmp->ptr[4]);
L4:
        while(( *p & 0xff) != 0 && ( *p & 0xff) == 32) {
            goto L3;
        }
        memset( &(tm.tm_sec), 0, 44);
        _t62 = p;
        _v96 =  &(tm.tm_sec);
        _v100 =  &(( &(tm.tm_sec))[1]);
        _v104 =  &(( &(tm.tm_sec))[2]);
        _v108 =  &(( &(tm.tm_sec))[3]);
        _v112 =  &(( &(tm.tm_sec))[4]);
        _v116 =  &(( &(tm.tm_sec))[5]);
        _v120 = "%04d%02d%02d%02d%02d%02d";
         *__esp = _t62;
        __isoc99_sscanf();
        if(_t62 > 5) {
            tm.tm_year = tm.tm_year - 1900;
            tm.tm_mon = tm.tm_mon - 1;
            _t67 =  &(tm.tm_sec);
             *__esp = _t67;
            mktime();
            t = _t67;
            _t68 =  &t;
             *__esp = _t68;
            localtime();
             *__esp = _t68;
            mktime();
            lt = _t68;
            _t69 =  &t;
             *__esp = _t69;
            gmtime();
             *__esp = _t69;
            mktime();
            gt = _t69;
            return lt - gt + t;
        }
        return -1;
    }
    return -1;
L3:
    p =  &(p[1]);
    goto L4;
}

int ftp_quit(FTP ftp)
{// addr = 0x080A3221  --  defined in 'ftp.c' at line 278
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t9;                         // _t9

    ftp_command(ftp, "QUIT", 0, 0);
    ftp_close(ftp);
    return 0;
}

closeFTPdata(FILE* f)
{// addr = 0x080A325C  --  defined in 'ftp.c' at line 304
    int status;                            // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t11;                        // _t11

    if(f != 0) {
        fclose(f);
        if(current_ftp.data == f) {
            current_ftp.data = 0;
        }
    }
    ftp_command( &current_ftp, 0, 0,  &status);
    return;
}

closeFTP()
{// addr = 0x080A32AC  --  defined in 'ftp.c' at line 317
    _unknown_ __ebp;                       // r6

    ftp_close( &current_ftp);
    return;
}

InputStream openFTPStream(ParsedURL* pu, URLFile* uf)
{// addr = 0x080A32C0  --  defined in 'ftp.c' at line 323
    Str tmp;               // _cfa_fffffff0
    int status;                            // _cfa_ffffffec
    char* user;                            // _cfa_ffffffe8
    char* pass;                            // _cfa_ffffffe4
    Str uname;             // _cfa_ffffffe0
    Str pwd;               // _cfa_ffffffdc
    int add_auth_cookie_flag;              // _cfa_ffffffd8
    char* realpathname;                    // _cfa_ffffffd4
    struct passwd* mypw;   // _cfa_ffffffd0
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t168;                       // _t168
    _unknown_ _t173;                       // _t173
    _unknown_ _t193;                       // _t193
    _unknown_ _t201;                       // _t201
    _unknown_ _t202;                       // _t202
    _unknown_ _t215;                       // _t215
    struct passwd* _t221;   // _t221
    char* _t222;                           // _t222
    int _t230;                             // _t230
    _unknown_ _t246;                       // _t246
    _unknown_ _t262;                       // _t262
    _unknown_ _t268;                       // _t268
    _unknown_ _t286;                       // _t286

    user = 0;
    pass = 0;
    uname = 0;
    pwd = 0;
    add_auth_cookie_flag = 0;
    realpathname = 0;
    if(pu->host == 0) {
        return 0;
    }
    if(pu->user == 0 && pu->pass == 0) {
        if(find_auth_user_passwd(pu, 0,  &uname,  &pwd, 0) != 0) {
            if(uname != 0) {
                user = uname->ptr;
            }
            if(pwd != 0) {
                pass = pwd->ptr;
            }
        }
    }
    if(user == 0) {
        if(pu->user == 0) {
            user = "anonymous";
        } else {
            user = pu->user;
        }
    }
    if(current_ftp.host == 0) {
L20:
        if(pass == 0) {
            if(pu->pass == 0) {
                if(pu->user == 0) {
                    if(ftppasswd == 0 || ( *ftppasswd & 0xff) == 0) {
                        _t221 = getuid();
                         *__esp = _t221;
                        getpwuid();
                        mypw = _t221;
                        if(mypw == 0) {
                            _t222 = "anonymous";
                        } else {
                            _t222 = mypw->pw_name;
                        }
                        tmp = Strnew_charp(_t222);
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t230 = tmp->length;
                         *(tmp->ptr + _t230) = 64;
                        tmp->length = _t230 + 1;
                         *(tmp->ptr + tmp->length) = 0;
                        pass = tmp->ptr;
                    } else {
                        pass = ftppasswd;
                    }
                } else {
                    pwd = 0;
                    find_auth_user_passwd(pu, 0,  &uname,  &pwd, 0);
                    if(pwd == 0) {
                        if((fmInitialized & 0xff) == 0) {
                            pwd = Strnew_charp(getpass("Password: "));
                        } else {
                            term_raw();
                            pwd = Strnew_charp(inputLineHistSearch("Password: ", 0, 64, 0, 0));
                            pwd = wc_Str_conv_strict(pwd, InnerCharset, SystemCharset);
                            term_cbreak();
                        }
                        add_auth_cookie_flag = 1;
                    }
                    pass = pwd->ptr;
                }
            } else {
                pass = pu->pass;
            }
        }
        if(current_ftp.host != 0) {
L42:
            if(add_auth_cookie_flag != 0) {
                add_auth_user_passwd(pu, 0, uname, pwd, 0);
            }
            goto L45;
        }
        current_ftp.host = allocStr(pu->host, -1);
        current_ftp.port = pu->port;
        current_ftp.user = allocStr(user, -1);
        current_ftp.pass = allocStr(pass, -1);
        if(ftp_login( &current_ftp) != 0) {
            goto L42;
        }
        return 0;
    }
    if(strcmp(current_ftp.host, pu->host) != 0 || current_ftp.port != pu->port || strcmp(current_ftp.user, user) != 0) {
        ftp_quit( &current_ftp);
    } else {
        ftp_command( &current_ftp, "NOOP", 0,  &status);
        if(status != 200) {
            ftp_close( &current_ftp);
            goto L20;
        }
L45:
        ftp_command( &current_ftp, "TYPE", "I",  &status);
        if(ftp_pasv( &current_ftp) >= 0) {
            if(pu->file == 0 || (pu & 0xff) == 0 || (pu->file[strlen(pu->file) - 1] & 0xff) == 47) {
L56:
                pu->scheme = 3;
                return 0;
            } else {
                realpathname = file_unquote(pu->file);
                if(( *realpathname & 0xff) == 47 && (realpathname[1] & 0xff) == 126) {
                    realpathname =  &(realpathname[1]);
                }
                 *(uf + 28) = ftp_modtime( &current_ftp, realpathname);
                ftp_command( &current_ftp, "RETR", realpathname,  &status);
                if(status == 125 || status == 150) {
                    return newFileStream(current_ftp.data, closeFTPdata);
                }
                goto L56;
            }
            return __eax;
        }
        ftp_quit( &current_ftp);
        return 0;
    }
    goto L20;
}

Str loadFTPDir(ParsedURL* pu, wc_ces* charset)
{// addr = 0x080A37A6  --  defined in 'ftp.c' at line 443
    Str FTPDIRtmp;         // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int status;                            // _cfa_ffffffe8
    _None sv_type;                         // _cfa_ffffffe4
    char* realpathname;                    // _cfa_ffffffe0
    char* fn;                              // _cfa_ffffffdc
    char* q;                               // _cfa_ffffffd8
    char** flist;                          // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffd0
    int nfile;                             // _cfa_ffffffcc
    int nfile_max;                         // _cfa_ffffffc8
    _None prevtrap;                        // _cfa_ffffffc4
    wc_ces doc_charset;   // _cfa_ffffffc0
    char* name;                            // _cfa_ffffffbc
    char* link;                            // _cfa_ffffffb8
    char* date;                            // _cfa_ffffffb4
    char* size;                            // _cfa_ffffffb0
    char* type_str;                        // _cfa_ffffffac
    int ftype;                             // _cfa_ffffffa8
    int max_len;                           // _cfa_ffffffa4
    int len;                               // _cfa_ffffffa0
    int j;                                 // _cfa_ffffff9c
    struct _Str* _v112;   // _cfa_ffffff90
    struct _Str* _v116;   // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    char* _v124;                           // _cfa_ffffff84
    char* _v128;                           // _cfa_ffffff80
    char* _v132;                           // _cfa_ffffff7c
    char* _v136;                           // _cfa_ffffff78
    _unknown_ __ebp;                       // r6
    _unknown_ _t391;                       // _t391
    int _t404;                             // _t404
    struct _Str* _t424;   // _t424
    char** _t430;                          // _t430
    char** _t455;                          // _t455
    _unknown_ _t459;                       // _t459
    char* _t482;                           // _t482
    char* _t485;                           // _t485
    int _t503;                             // _t503
    int _t516;                             // _t516
    char* _t528;                           // _t528
    int _t536;                             // _t536
    struct _Str* _t550;   // _t550
    _unknown_ _t554;                       // _t554
    _unknown_ _t571;                       // _t571
    _unknown_ _t573;                       // _t573
    _unknown_ _t585;                       // _t585
    _unknown_ _t588;                       // _t588
    _unknown_ _t591;                       // _t591

    __esp =  &((__esp)[0xffffffffffffffe0]);
    prevtrap = 0;
    doc_charset = DocumentCharset;
     *charset = 256;
    if(current_ftp.data != 0) {
        tmp = ftp_command( &current_ftp, "SYST", 0,  &status);
        if(strstr(tmp->ptr, "UNIX") != 0) {
L4:
            sv_type = 1;
L6:
            if(pu->file == 0 || (pu & 0xff) == 0) {
                if(sv_type != 1) {
                    ftp_command( &current_ftp, "NLST", 0,  &status);
                } else {
                    ftp_command( &current_ftp, "LIST", 0,  &status);
                }
                pu->file = "/";
            } else {
                realpathname = file_unquote(pu->file);
                if(( *realpathname & 0xff) == 47 && (realpathname[1] & 0xff) == 126) {
                    realpathname =  &(realpathname[1]);
                }
                if(sv_type != 1) {
                    ftp_command( &current_ftp, "NLST", realpathname,  &status);
                } else {
                    ftp_command( &current_ftp, "CWD", realpathname,  &status);
                    if(status == 250) {
                        ftp_command( &current_ftp, "LIST", 0,  &status);
                    }
                }
            }
            if(status == 125 || status == 150) {
                tmp = parsedURL2Str(pu);
                if(tmp->length <= 0 || ( *(tmp->ptr + tmp->length - 1) & 0xff) != 47) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t404 = tmp->length;
                     *((char*)(tmp->ptr + _t404)) = 47;
                    tmp->length = _t404 + 1;
                     *(tmp->ptr + tmp->length) = 0;
                }
                fn = html_quote(tmp->ptr);
                tmp = convertLine(0, Strnew_charp(file_unquote(tmp->ptr)), 0, charset, doc_charset);
                q = html_quote(tmp->ptr);
                _v112 = 0;
                _v116 = "</h1>\n";
                _v120 = q;
                _v124 = "</title>\n</head>\n<body>\n<h1>Index of ";
                _v128 = q;
                _v132 = "">\n<title>";
                _v136 = fn;
                _t424 = Strnew_m_charp("<html>\n<head>\n<base href="");
                FTPDIRtmp = _t424;
                _v136 = 1;
                 *__esp =  &AbortLoading;
                __sigsetjmp();
                if(_t424 == 0) {
                    if((TrapSignal & 0xff) != 0) {
                        prevtrap = mySignal(2, KeyAbort);
                        if((fmInitialized & 0xff) != 0) {
                            term_cbreak();
                        }
                    }
                    if(sv_type != 1) {
                        Strcat_charp(FTPDIRtmp, "<ul>\n<li>");
                    } else {
                        Strcat_charp(FTPDIRtmp, "<pre>\n");
                    }
                    Strcat_charp(FTPDIRtmp, "<a href="..">[Upper Directory]</a>\n");
                    nfile_max = 100;
                    _t430 = nfile_max << 2;
                     *__esp = _t430;
                    GC_malloc();
                    flist = _t430;
                    nfile = 0;
                    if(sv_type != 1) {
                        while(1) {
L84:
                            current_ftp.data = Strfgets(current_ftp.data);
                            tmp = current_ftp.data;
                            tmp = tmp->length;
                            if(tmp->length <= 0) {
                                break;
                            }
                            __eax = tmp;
                            Strchop(tmp);
                            nfile = nfile << 2;
                            tmp = tmp->ptr;
                            __eax = mybasename(tmp->ptr);
                            flist[nfile] = tmp->ptr;
                            nfile = nfile + 1;
                            __eax = nfile;
                            if(nfile == nfile_max) {
                                nfile_max = nfile_max << 1;
                                nfile_max = nfile_max << 2;
                                _v136 = nfile_max << 2;
                                __eax = flist;
                                 *__esp = __eax;
                                GC_realloc();
                                flist = __eax;
                            }
                        }
                        __eax = nfile;
                        _v128 = strCmp;
                        _v132 = 4;
                        _v136 = nfile;
                        __eax = flist;
                         *__esp = flist;
                        __eax = qsort();
                        i = 0;
                        while(1) {
                            __eax = i;
                            if(i >= nfile) {
                                break;
                            }
                            i = i << 2;
                             &(flist[i]) = flist[i];
                            fn = flist[i];
                            fn = Strnew_charp(fn);
                            __eax = convertLine(0, fn, 0, charset, doc_charset);
                            tmp = fn;
                            tmp = tmp->ptr;
                            html_quote(tmp->ptr) = fn;
                            file_quote(fn) = html_quote(fn);
                            _v116 = 0;
                            _v120 = "</a>\n";
                            _v124 = tmp->ptr;
                            _v128 = "">";
                            _v132 = fn;
                            _v136 = "<li><a href="";
                            __eax = FTPDIRtmp;
                            Strcat_m_charp(FTPDIRtmp);
                            i = i + 1;
                        }
                        _v136 = "</ul>\n";
                        __eax = FTPDIRtmp;
                         *__esp = FTPDIRtmp;
                        Strcat_charp();
                    } else {
                        max_len = 20;
                        while(1) {
                            tmp = Strfgets(current_ftp.data);
                            if(tmp->length <= 0) {
                                break;
                            }
                            Strchop(tmp);
                            ftype = ex_ftpdir_name_size_date(tmp->ptr,  &name,  &link,  &date,  &size);
                            if(ftype != 0) {
                                if(strcmp(".", name) != 0) {
                                    if(strcmp("..", name) != 0) {
                                        len = strlen(name);
                                        if(len != 0) {
                                            if(ftype != 1) {
                                                if(ftype != 2) {
                                                    type_str = " ";
                                                } else {
                                                    len = len + 1;
                                                    type_str = "";
                                                }
                                            } else {
                                                len = len + 1;
                                                type_str = "/";
                                            }
                                            if(max_len < len) {
                                                max_len = len;
                                            }
                                            _v120 = link;
                                            _v124 = size;
                                            _v128 = date;
                                            _v132 = type_str;
                                            _v136 = name;
                                            flist[nfile] =  *(Sprintf("%s%s\n%s  %5s%s"));
                                            nfile = nfile + 1;
                                            if(nfile == nfile_max) {
                                                nfile_max = nfile_max << 1;
                                                _v136 = nfile_max << 2;
                                                _t455 = flist;
                                                 *__esp = _t455;
                                                GC_realloc();
                                                flist = _t455;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _v128 = strCmp;
                        qsort(flist, nfile, 4);
                        j = 0;
                        while(j < nfile) {
                            fn = flist[j];
                            date = strchr(fn, 10);
                            if(( *(date - 1) & 0xff) != 47) {
                                if(( *(date - 1) & 0xff) != 64) {
                                    ftype = 3;
                                     *(date - 1) = 0;
                                } else {
                                    ftype = 2;
                                     *(date - 1) = 0;
                                }
                            } else {
                                ftype = 1;
                                 *date = 0;
                            }
                            date =  &(date[1]);
                            tmp = convertLine(0, Strnew_charp(fn), 0, charset, doc_charset);
                            if(ftype == 2) {
                                if(tmp->length + 1 >= tmp->area_size) {
                                    Strgrow(tmp);
                                }
                                _t536 = tmp->length;
                                 *((char*)(tmp->ptr + _t536)) = 64;
                                tmp->length = _t536 + 1;
                                 *(tmp->ptr + tmp->length) = 0;
                            }
                            _t482 = html_quote(tmp->ptr);
                            _t485 = html_quote(file_quote(fn));
                            _v116 = 0;
                            _v120 = "</a>";
                            _v124 = _t482;
                            _v128 = "">";
                            _v132 = _t485;
                            _v136 = "<a href="";
                            Strcat_m_charp(FTPDIRtmp);
                            i = wtf_strwidth(tmp->ptr);
                            while(i <= max_len) {
                                if(((max_len + (max_len >> 31 >> 31) & 1) - (max_len >> 31 >> 31) + i & 1) == 0) {
                                    if(FTPDIRtmp->length + 1 >= FTPDIRtmp->area_size) {
                                        Strgrow(FTPDIRtmp);
                                    }
                                    _t503 = FTPDIRtmp->length;
                                     *((char*)(FTPDIRtmp->ptr + _t503)) = 32;
                                    FTPDIRtmp->length = _t503 + 1;
                                     *(FTPDIRtmp->ptr + FTPDIRtmp->length) = 0;
                                } else {
                                    if(FTPDIRtmp->length + 1 >= FTPDIRtmp->area_size) {
                                        Strgrow(FTPDIRtmp);
                                    }
                                    _t516 = FTPDIRtmp->length;
                                     *((char*)(FTPDIRtmp->ptr + _t516)) = 46;
                                    FTPDIRtmp->length = _t516 + 1;
                                     *(FTPDIRtmp->ptr + FTPDIRtmp->length) = 0;
                                }
                                i = i + 1;
                            }
                            tmp = convertLine(0, Strnew_charp(date), 0, charset, doc_charset);
                            _t528 = html_quote(tmp->ptr);
                            _v128 = 0;
                            _v132 = "\n";
                            _v136 = _t528;
                            Strcat_m_charp(FTPDIRtmp);
                            j = j + 1;
                        }
                        Strcat_charp(FTPDIRtmp, "</pre>\n");
                    }
                    goto L89;
                } else {
                    if(sv_type != 1) {
                        Strcat_charp(FTPDIRtmp, "</a></ul>\n");
                    } else {
                        Strcat_charp(FTPDIRtmp, "</a></pre>\n");
                    }
                    Strcat_charp(FTPDIRtmp, "<p>Transfer Interrupted!\n");
L89:
                    Strcat_charp(FTPDIRtmp, "</body>\n</html>\n");
                    if((TrapSignal & 0xff) != 0) {
                        if((fmInitialized & 0xff) != 0) {
                            term_raw();
                        }
                        if(prevtrap != 0) {
                            mySignal(2, prevtrap);
                        }
                    }
                    closeFTPdata(current_ftp.data);
                    _t550 = FTPDIRtmp;
                    goto L95;
                }
            } else {
                fclose(current_ftp.data);
                current_ftp.data = 0;
                _t550 = 0;
            }
            goto L95;
        }
        if(strncmp( &(tmp->ptr[4]), "Windows_NT", 10) != 0) {
            sv_type = 0;
            goto L6;
        }
        goto L4;
    } else {
        _t550 = 0;
    }
L95:
    __esp = __esp - 128;
    return _t550;
}

disconnectFTP()
{// addr = 0x080A41AF  --  defined in 'ftp.c' at line 625
    _unknown_ __ebp;                       // r6

    ftp_quit( &current_ftp);
    return;
}

int ex_ftpdir_name_size_date(char* line, char** name, char** link, char** date, char** sizep)
{// addr = 0x080A41C3  --  defined in 'ftp.c' at line 651
    int ftype;                             // _cfa_fffffff0
    char* cp;                              // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    clen_t size;        // _cfa_ffffffdc
    signed int _v56;                       // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t480;                      // _t480
    _unknown_ _t544;                       // _t544
    _unknown_ _t567;                       // _t567
    _unknown_ _t577;                       // _t577
    _unknown_ _t580;                       // _t580
    signed int _t581;                      // _t581

    ftype = 0;
    cp = line;
    if(strlen(cp) <= 10) {
        goto L99;
    }
    cp =  &(cp[0xa]);
    if(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0) {
        cp =  &(cp[1]);
L4:
        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0) {
L5:
            if(( *cp & 0xff) != 0) {
                cp =  &(cp[1]);
                goto L4;
            }
            break;
        }
        if(( *cp & 0xff) == 0) {
L99:
            return ftype;
        } else {
            size = 0;
            _v32 = 0;
L9:
            while(( *cp & 0xff) != 0) {
L10:
                if(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 8) != 0) {
                    _t581 =  *cp & 0xff;
                    asm("adc edx, ebx");
                    asm("adc edx, 0xff");
                    size = 10 * size + _t581 + -48;
                    _v32 = _t581 * _v32 + size * size + (10 * size >> 32);
                    cp =  &(cp[1]);
                    goto L9;
                }
                break;
            }
            if(( *cp & 0xff) == 0) {
            } else {
                cp =  &(cp[1]);
L14:
                while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0) {
L15:
                    if(( *cp & 0xff) != 0) {
                        cp =  &(cp[1]);
                        goto L14;
                    }
                    break;
                }
                if(( *cp & 0xff) == 0) {
                } else {
L19:
                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0) {
L20:
                        if(( *cp & 0xff) != 0) {
                            cp =  &(cp[1]);
                            goto L19;
                        }
                        break;
                    }
                    if(( *cp & 0xff) == 0) {
                    } else {
                        cp =  &(cp[1]);
L24:
                        while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0) {
L25:
                            if(( *cp & 0xff) != 0) {
                                cp =  &(cp[1]);
                                goto L24;
                            }
                            break;
                        }
                        if(( *cp & 0xff) == 0) {
                        } else {
                            while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 0xff) != 0) {
                            }
                            if(( *cp & 0xff) == 0) {
                            } else {
                                cp =  &(cp[1]);
                                while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 0xff) != 0) {
                                }
                                if(( *cp & 0xff) == 0) {
                                } else {
                                    p = cp;
                                    size = 0;
                                    _v32 = 0;
                                    while(( *cp & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 8) != 0) {
                                        _t581 =  *cp & 0xff;
                                        asm("adc edx, ebx");
                                        asm("adc edx, 0xff");
                                        size = 10 * size + _t581 + -48;
                                        _v32 = _t581 * _v32 + size * size + (10 * size >> 32);
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) == 0) {
                                        goto L99;
                                    }
                                    if(( *cp & 0xff) != 44) {
                                         *__esp = size;
                                        _v56 = _v32;
                                         *sizep =  *(size_int2str());
                                        goto L55;
                                    }
                                    cp =  &(cp[1]);
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 0xff) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) == 0) {
                                        goto L99;
                                    }
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 0xff) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) == 0) {
                                        goto L99;
                                    }
                                     *sizep = allocStr(p, cp - p);
                                    goto L55;
L55:
                                    cp =  &(cp[1]);
                                    p = cp;
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 0xff) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) == 0) {
                                        goto L99;
                                    }
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 0xff) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) == 0) {
                                        goto L99;
                                    }
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 0xff) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) == 0) {
                                        goto L99;
                                    }
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 0xff) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) == 0) {
                                        goto L99;
                                    }
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 0xff) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) == 0) {
                                        goto L99;
                                    }
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) == 0 && ( *cp & 0xff) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) == 0) {
                                        goto L99;
                                    }
                                     *date = allocStr(p, cp - p);
                                    cp =  &(cp[1]);
                                    while(( *( &MYCTYPE_MAP + ( *cp & 0xff)) & 2) != 0 && ( *cp & 0xff) != 0) {
                                        cp =  &(cp[1]);
                                    }
                                    if(( *cp & 0xff) != 0) {
                                        _t480 =  *line & 0xff;
                                        if(_t480 == 100) {
                                            ftype = 1;
                                             *name = allocStr(cp, -1);
                                             *link = 135066584;
                                             *sizep = 135066584;
                                        } else {
                                            if(_t480 != 108) {
                                                ftype = 3;
                                                 *name = allocStr(cp, -1);
                                                 *link = 135066584;
                                            } else {
                                                ftype = 2;
                                                p = strstr(cp, " -> ");
                                                if(p != 0) {
                                                     *name = allocStr(cp, p - cp);
                                                     *link = allocStr(p, -1);
                                                     *sizep = 135066584;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            goto L99;
        }
    }
    goto L99;
}

Str size_int2str(clen_t size)
{// addr = 0x080A47D6  --  defined in 'ftp.c' at line 737
    double dtmp;                           // _cfa_ffffffdc
    Str size_str;          // _cfa_fffffff0
    int unit;                              // _cfa_ffffffec
    char* size_format;                     // _cfa_ffffffe8
    char* unit_str;                        // _cfa_ffffffe4
    signed int _v48;                       // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v64;                            // _cfa_ffffffc0
    _unknown_ __ebp;                       // r6
    signed int _t36;                       // _t36
    int _t37;                              // _t37

    _v52 = _a4;
    _t36 = _a8;
    _v48 = _t36;
    asm("fild qword [ebp-0x30]");
    asm("fstp qword [ebp-0x20]");
    unit = 0;
    while(unit <= 2) {
        asm("fld qword [ebp-0x20]");
        asm("fld qword [0x80cf5a0]");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t36 & 255) == 0) {
            asm("fld qword [ebp-0x20]");
            asm("fld qword [0x80cf5a0]");
            asm("fdivp st1, st0");
            asm("fstp qword [ebp-0x20]");
            unit = unit + 1;
            continue;
        }
L6:
        if(unit == 0) {
L8:
            size_format = "%.0f%s";
L12:
            _t37 = unit;
            if(_t37 == 2) {
                unit_str = "M";
            } else {
                if(_t37 == 3) {
                    unit_str = "G";
                } else {
                    if(_t37 == 1) {
                        unit_str = "K";
                    } else {
                        unit_str = 135066584;
                    }
                }
            }
            _v64 = unit_str;
            asm("fld qword [ebp-0x20]");
            asm("fstp qword [esp+0x4]");
            size_str = Sprintf(size_format);
            return size_str;
        }
        asm("fld qword [ebp-0x20]");
        asm("fld qword [0x80cf5a8]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t36 & 255) == 0) {
            asm("fld qword [ebp-0x20]");
            asm("fld qword [0x80cf5b0]");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t36 & 255) == 0) {
                size_format = "%.2f%s";
            } else {
                size_format = "%.1f%s";
            }
            goto L12;
        }
        goto L8;
    }
    goto L6;
}

unsigned char c2e(char x)
{// addr = 0x080A48C8  --  defined in 'mimehead.c' at line 23
    signed int _v8;                        // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19

    _v8 = _a4 & 255;
    if(_v8 > 64) {
        if(_v8 > 90) {
            goto L3;
        } else {
            return (_v8 & 255) - 65;
        }
    }
L3:
    if(_v8 <= 96 || _v8 > 122) {
        if(_v8 <= 47 || _v8 > 57) {
            if(_v8 != 43) {
                if(_v8 != 47) {
                    return -1;
                }
                goto L12;
            }
            goto L10;
L12:
            return 63;
        } else {
            return (_v8 & 255) + 4;
        }
L10:
        return 62;
    }
    return (_v8 & 255) - 71;
}

int ha2d(char x, char y)
{// addr = 0x080A4934  --  defined in 'mimehead.c' at line 40
    int r;                                 // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6

    _v24 = _a4 & 255;
    _v28 = _a8 & 255;
    r = 0;
    if(_v24 <= 47) {
L3:
        if(_v24 <= 64) {
L6:
            if(_v24 > 96 && _v24 <= 102) {
                r = _v24 - 87;
            }
            goto L9;
        }
        goto L4;
    }
    if(_v24 > 57) {
        goto L3;
    } else {
        r = _v24 - 48;
L9:
        r = r << 4;
        if(_v28 <= 47 || _v28 > 57) {
            if(_v28 <= 64 || _v28 > 70) {
                if(_v28 > 96 && _v28 <= 102) {
                    r = r + _v28 - 87;
                }
            } else {
                r = r + _v28 - 55;
            }
        } else {
            r = r + _v28 - 48;
        }
        return r;
    }
L4:
    if(_v24 > 70) {
        goto L6;
    } else {
        r = _v24 - 55;
    }
    goto L9;
}

Str decodeB(char** ww)
{// addr = 0x080A49E2  --  defined in 'mimehead.c' at line 65
    signed int _v13;                       // _cfa_fffffff3
    signed int _v14;                       // _cfa_fffffff2
    char[2] d;                             // _cfa_fffffff1
    signed char _v16;                      // _cfa_fffffff0
    signed int _v17;                       // _cfa_ffffffef
    signed int _v18;                       // _cfa_ffffffee
    unsigned char[3] c;                    // _cfa_ffffffed
    char* wp;                              // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int n_pad;                             // _cfa_ffffffe0
    Str ap;                // _cfa_ffffffdc
    _unknown_ __ebp;                       // r6
    _unknown_ _t162;                       // _t162
    int _t170;                             // _t170

    wp =  *ww;
    ap = Strnew_size(strlen(wp));
    n_pad = 0;
    goto L2;
    do {
L2:
        i = 0;
        while(i <= 3) {
             *(__ebp + i - 15) =  *wp & 0xff;
            wp =  &(wp[1]);
            if(( *wp & 0xff) == 0 || ( *wp & 0xff) == 63) {
                i = i + 1;
                while(i <= 3) {
                }
            } else {
                i = i + 1;
                continue;
            }
            break;
        }
        if((_v16 & 0xff) == 61) {
            n_pad = n_pad + 1;
            _v16 = 65;
            if((_v17 & 0xff) == 61) {
                n_pad = n_pad + 1;
                _v17 = 65;
            }
        }
        i = 0;
        while(i <= 3) {
             *(__ebp + i - 15) = c2e( *(__ebp + i - 15) & 0xff) & 255;
            if(( *(__ebp + i - 15) & 0xff) != 255) {
                i = i + 1;
                continue;
            }
             *ww = wp;
            return ap;
        }
        d = (_v18 & 255 | (c & 0xff) << 2) & 255;
        _v14 = (_v17 & 255 | (_v18 & 0xff) << 4) & 255;
        _v13 = (_v16 & 255 | (_v17 & 0xff) << 6) & 255;
        i = 0;
        while(3 - n_pad > i) {
            if(ap->length + 1 >= ap->area_size) {
                Strgrow(ap);
            }
            _t170 = ap->length;
             *(ap->ptr + _t170) =  *(__ebp + i - 11) & 0xff;
            ap->length = _t170 + 1;
             *(ap->ptr + ap->length) = 0;
            i = i + 1;
        }
    } while(n_pad == 0 && ( *wp & 0xff) != 0 && ( *wp & 0xff) != 63);
     *ww = wp;
    return ap;
}

Str decodeU(char** ww)
{// addr = 0x080A4BAB  --  defined in 'mimehead.c' at line 114
    unsigned char c1;                      // _cfa_ffffffe3
    unsigned char c2;                      // _cfa_ffffffe2
    char* w;                               // _cfa_ffffffdc
    int n;                                 // _cfa_ffffffd8
    int i;                                 // _cfa_ffffffd4
    Str a;                 // _cfa_ffffffd0
    signed int _v64;                       // _cfa_ffffffc0
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    int _t113;                             // _t113
    _unknown_ _t136;                       // _t136

    w =  *ww;
    if(( *w & 0xff) <= 32 || ( *w & 0xff) > 95) {
        return Strnew_size(0);
    }
    n = ( *w & 0xff) - 32;
    a = Strnew_size(n);
    w =  &(w[1]);
    i = 2;
    while(( *w & 0xff) != 0 && n != 0) {
        c1 = (( *w & 0xff) - 32 + (( *w & 0xff) - 32 >> 31 >> 26) & 63) - (( *w & 0xff) - 32 >> 31 >> 26) & 255;
        c2 = ((w[1] & 0xff) - 32 + ((w[1] & 0xff) - 32 >> 31 >> 26) & 63) - ((w[1] & 0xff) - 32 >> 31 >> 26) & 255;
        if(a->length + 1 >= a->area_size) {
            Strgrow(a);
        }
        _t113 = a->length;
        _v64 = c2 & 255;
         *(a->ptr + _t113) = (_v64 >> (6 - i & 255) | (c1 & 255) << (i & 255)) & 255;
        a->length = _t113 + 1;
         *(a->ptr + a->length) = 0;
        if(i != 6) {
            w =  &(w[1]);
            i = i + 2;
        } else {
            w =  &(w[2]);
            i = 2;
        }
        n = n - 1;
    }
    return a;
}

Str decodeQ(char** ww)
{// addr = 0x080A4D08  --  defined in 'mimehead.c' at line 143
    char* w;                               // _cfa_fffffff0
    Str a;                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    int __ebx;                             // r1
    _unknown_ __ebp;                       // r6
    int _t109;                             // _t109
    int _t122;                             // _t122

    w =  *ww;
    a = Strnew_size(strlen(w));
    while(( *w & 0xff) != 0 && ( *w & 0xff) != 63) {
        if(( *w & 0xff) != 61) {
            if(( *w & 0xff) != 95) {
                if(a->length + 1 >= a->area_size) {
                    Strgrow(a);
                }
                _t109 = a->length;
                 *(a->ptr + _t109) =  *w & 0xff;
                a->length = _t109 + 1;
                 *((char*)(a->ptr + a->length)) = 0;
            } else {
                if(a->length + 1 >= a->area_size) {
                    Strgrow(a);
                }
                _t122 = a->length;
                 *((char*)(a->ptr + _t122)) = 32;
                a->length = _t122 + 1;
                 *((char*)(a->ptr + a->length)) = 0;
            }
            goto L12;
        }
        w =  &(w[1]);
        if(a->length + 1 >= a->area_size) {
            Strgrow(a);
        }
        __ebx = a->length;
         *(a->ptr + __ebx) = ha2d( *w & 0xff, w[1] & 0xff) & 255;
        a->length = __ebx + 1;
         *((char*)(a->ptr + a->length)) = 0;
        w =  &(w[1]);
L12:
        w =  &(w[1]);
    }
     *ww = w;
    return a;
}

Str decodeQP(char** ww)
{// addr = 0x080A4E89  --  defined in 'mimehead.c' at line 166
    char* w;                               // _cfa_fffffff0
    Str a;                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    int __ebx;                             // r1
    _unknown_ __ebp;                       // r6
    int _t109;                             // _t109

    w =  *ww;
    a = Strnew_size(strlen(w));
    while(( *w & 0xff) != 0) {
        if(( *w & 0xff) != 61) {
            if(a->length + 1 >= a->area_size) {
                Strgrow(a);
            }
            _t109 = a->length;
             *(a->ptr + _t109) =  *w & 0xff;
            a->length = _t109 + 1;
             *((char*)(a->ptr + a->length)) = 0;
            goto L24;
        }
        w =  &(w[1]);
        if(( *w & 0xff) == 10) {
            goto L11;
        }
        if(( *w & 0xff) == 13) {
            goto L9;
        }
        if(( *w & 0xff) == 32) {
            goto L10;
        }
        if(( *w & 0xff) != 9) {
            if(( *w & 0xff) == 0 || (w[1] & 0xff) == 0) {
                break;
            } else {
                if(a->length + 1 >= a->area_size) {
                    Strgrow(a);
                }
                __ebx = a->length;
                 *(a->ptr + __ebx) = ha2d( *w & 0xff, w[1] & 0xff) & 255;
                a->length = __ebx + 1;
                 *((char*)(a->ptr + a->length)) = 0;
                w =  &(w[1]);
L24:
                w =  &(w[1]);
                continue;
            }
        } else {
        }
L11:
        while(( *w & 0xff) != 10 && ( *w & 0xff) != 0) {
            w =  &(w[1]);
        }
        if(( *w & 0xff) != 0) {
            goto L24;
        }
        break;
L10:
        goto L11;
L9:
        goto L11;
    }
     *ww = w;
    return a;
}

Str decodeWord(char** ow, wc_ces* charset)
{// addr = 0x080A502A  --  defined in 'mimehead.c' at line 196
    char method;                           // _cfa_fffffff3
    wc_ces c;           // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* w;                               // _cfa_ffffffe4
    Str a;                 // _cfa_ffffffe0
    Str tmp;               // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t111;                             // _t111
    char* _t125;                           // _t125
    signed int _t137;                      // _t137

    w =  *ow;
    a = Strnew();
    tmp = Strnew();
    if(( *w & 0xff) != 61 || (w[1] & 0xff) != 63) {
L27:
        return Strnew();
    } else {
        w =  &(w[2]);
        while(( *w & 0xff) != 63) {
            if(( *w & 0xff) == 0) {
                goto L27;
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t111 = tmp->length;
             *(tmp->ptr + _t111) =  *w & 0xff;
            tmp->length = _t111 + 1;
             *(tmp->ptr + tmp->length) = 0;
            w =  &(w[1]);
            continue;
L24:
            goto L27;
        }
        c = wc_guess_charset(tmp->ptr, 0);
        if(c == 0) {
            goto L24;
        }
        w =  &(w[1]);
        _t125 = w;
        method =  *_t125 & 0xff;
        w =  &(_t125[1]);
        if(( *w & 0xff) != 63) {
            goto L25;
        }
        w =  &(w[1]);
        p = w;
        if(( *( &MYCTYPE_MAP + (method & 0xff)) & 4) == 0) {
            _t137 = method;
        } else {
            _t137 = method & 0xdf;
        }
        if(_t137 == 66) {
            a = decodeB( &w);
            goto L18;
        } else {
            if(_t137 == 81) {
                goto L17;
            }
            goto L27;
L18:
            if(p == w) {
                goto L26;
            }
            if(( *w & 0xff) == 63) {
                w =  &(w[1]);
                if(( *w & 0xff) == 61) {
                    w =  &(w[1]);
                }
            }
             *ow = w;
             *charset = c;
            return a;
            goto L27;
        }
L17:
        a = decodeQ( &w);
        goto L18;
L26:
        goto L27;
L25:
        goto L27;
    }
    return __eax;
}

Str decodeMIME(Str orgstr, wc_ces* charset)
{// addr = 0x080A51E0  --  defined in 'mimehead.c' at line 265
    char* org;                             // _cfa_fffffff0
    char* endp;                            // _cfa_ffffffec
    char* org0;                            // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    Str cnv;               // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t95;                              // _t95
    signed int _t114;                      // _t114

    org = orgstr->ptr;
    endp =  &(org[orgstr->length]);
    cnv = 0;
     *charset = 0;
    while(org < endp) {
        if(( *org & 0xff) != 61 || (org[1] & 0xff) != 63) {
            if(cnv != 0) {
                if(cnv->length + 1 >= cnv->area_size) {
                    Strgrow(cnv);
                }
                _t95 = cnv->length;
                 *(cnv->ptr + _t95) =  *org & 0xff;
                cnv->length = _t95 + 1;
                 *(cnv->ptr + cnv->length) = 0;
            }
            org =  &(org[1]);
            continue;
        } else {
            if(cnv == 0) {
                cnv = Strnew_size(orgstr->length);
                Strcat_charp_n(cnv, orgstr->ptr, org - orgstr->ptr);
            }
            while(1) {
                p = org;
                Strcat(cnv, decodeWord( &org, charset));
                if(org == p) {
                    break;
                }
                org0 = org;
                while(1) {
                    _t114 =  *org0 & 0xff;
                    if(_t114 == 13) {
                        goto L15;
                    } else {
                        goto L9;
                    }
                }
            }
            Strcat_charp(cnv, org);
            return cnv;
        }
    }
    if(cnv != 0) {
        return cnv;
    }
    return orgstr;
}

Str encodeB(char* a)
{// addr = 0x080A5389  --  defined in 'mimehead.c' at line 326
    unsigned char c1;                      // _cfa_fffffff3
    unsigned char c2;                      // _cfa_fffffff2
    unsigned char c3;                      // _cfa_fffffff1
    unsigned char c4;                      // _cfa_fffffff0
    signed int _v17;                       // _cfa_ffffffef
    signed int _v18;                       // _cfa_ffffffee
    unsigned char[2] d;                    // _cfa_ffffffed
    int i;                                 // _cfa_ffffffe8
    int n_pad;                             // _cfa_ffffffe4
    Str w;                 // _cfa_ffffffe0
    _unknown_ __ebp;                       // r6
    _unknown_ _t160;                       // _t160
    int _t191;                             // _t191
    int _t203;                             // _t203
    int _t215;                             // _t215
    int _t227;                             // _t227
    _unknown_ _t242;                       // _t242

    w = Strnew();
    while(( *a & 0xff) != 0) {
        n_pad = 0;
        _v17 = 0;
        _v18 = _v17 & 0xff;
        i = 0;
        while(i <= 2) {
             *(__ebp + i - 15) = a[i] & 0xff;
            if((a[i] & 0xff) != 0) {
                i = i + 1;
                continue;
            }
            n_pad = 3 - i;
            break;
        }
        c1 = d & 0xff;
        c2 = (_v18 & 255 | (d & 0xff) << 4) & 0x3f;
        if(n_pad != 2) {
            if(n_pad != 1) {
                c3 = (_v17 & 255 | (_v18 & 0xff) << 2) & 0x3f;
                c4 = _v17 & 0x3f;
            } else {
                c3 = (_v18 & 0xff) << 2 & 0x3f;
                c4 = 64;
            }
        } else {
            c4 = 64;
            c3 = c4 & 0xff;
        }
        if(w->length + 1 >= w->area_size) {
            Strgrow(w);
        }
        _t191 = w->length;
         *(w->ptr + _t191) =  *((c1 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 0xff;
        w->length = _t191 + 1;
         *(w->ptr + w->length) = 0;
        if(w->length + 1 >= w->area_size) {
            Strgrow(w);
        }
        _t203 = w->length;
         *(w->ptr + _t203) =  *((c2 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 0xff;
        w->length = _t203 + 1;
         *(w->ptr + w->length) = 0;
        if(w->length + 1 >= w->area_size) {
            Strgrow(w);
        }
        _t215 = w->length;
         *(w->ptr + _t215) =  *((c3 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 0xff;
        w->length = _t215 + 1;
         *(w->ptr + w->length) = 0;
        if(w->length + 1 >= w->area_size) {
            Strgrow(w);
        }
        _t227 = w->length;
         *(w->ptr + _t227) =  *((c4 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 0xff;
        w->length = _t227 + 1;
         *(w->ptr + w->length) = 0;
        if(n_pad == 0) {
            a =  &(a[3]);
            continue;
        }
L24:
        return w;
    }
    goto L24;
}

longchar set_longchar(char* str)
{// addr = 0x080A55D8  --  defined in 'regex.c' at line 77
    _unknown_ _v8;                         // _cfa_fffffff8
    unsigned char* p;                      // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    longchar r;       // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    unsigned char** _v72;                  // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    struct  _t89;             // _t89
    _unknown_ _t90;                        // _t90

    _push(__ebx);
    __esp = __esp - 68;
    _t89 = _a4;
    p = str;
    if(( *p & 0xff) >= 0) {
        _v20 =  *p & 0xff;
        r.type = 1;
         *_t89 = r.type;
         *(_t89 + 4) = _v28;
         *(_t89 + 8) = _v24;
         *(_t89 + 12) = _v20;
        goto L13;
    }
    _v72 =  &p;
    wtf_parse1( &_v52);
    __esp = __esp - 4;
    _v28 = _v52;
    _v24 = _v48;
    if(_v28 == 2048 || _v28 == 34816) {
        r.type = 4;
         *_t89 = r.type;
         *(_t89 + 4) = _v28;
         *(_t89 + 8) = _v24;
         *(_t89 + 12) = _v20;
    } else {
        if((_v28 & 65535) == 4096 || (_v28 & 65535) == 8192 || (_v28 & 65535) == 8193) {
            if((_v28 & 65535) == 8193) {
                _v24 = _v24 & 2097151;
            }
            _v28 = 8192;
L11:
            r.type = 2;
             *_t89 = r.type;
             *(_t89 + 4) = _v28;
             *(_t89 + 8) = _v24;
             *(_t89 + 12) = _v20;
            goto L13;
        }
        _v28 = _v28 & 65535;
        goto L11;
    }
L13:
    return _t89;
}

char* regexCompile(char* ex, int igncase)
{// addr = 0x080A56F0  --  defined in 'regex.c' at line 121
    char* msg;                             // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11

    newRegex(ex, igncase,  &DefaultRegex,  &msg);
    return msg;
}

Regex* newRegex0(char** ex, int igncase, Regex* regex, char** msg, int level)
{// addr = 0x080A571C  --  defined in 'regex.c' at line 129
    longchar* r;      // _cfa_ffffffec
    int m;                                 // _cfa_ffffffe4
    _unknown_ _v8;                         // _cfa_fffffff8
    char* p;                               // _cfa_fffffff0
    regexchar* re;   // _cfa_ffffffe8
    longchar* st_ptr;   // _cfa_ffffffe0
    unsigned char _v48;                    // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char* _v88;                            // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    Regex* _t80;         // _t80
    Regex* _t113;        // _t113
    _unknown_ _t122;                       // _t122
    longchar* _t130;   // _t130
    _unknown_ _t131;                       // _t131

    _t80 = __eax;
    _push(__ebx);
    __esp = __esp - 84;
    if(regex == 0) {
         *__esp = 4620;
        GC_malloc();
        regex = _t80;
    }
    regex->alt_regex = 0;
    re = regex;
    st_ptr = regex + 512;
    p =  *ex;
    while(( *p & 0xff) != 0) {
        re->mode = 0;
        if(( *p & 0xff) - 36 > 88) {
            _t130 = st_ptr;
            _v88 = p;
            __eax = set_longchar( &_v60);
            __esp = __esp - 4;
            _t130->type = _v60;
             *((intOrPtr*)(_t130 + 4)) = _v56;
             *((intOrPtr*)(_t130 + 8)) = _v52;
            _t130->ch = _v48;
            p =  &(p[( *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff) - 1]);
            re->p = st_ptr;
            st_ptr = st_ptr + 16;
            re->mode = re->mode & 0xf8;
            if(igncase != 0) {
                re->mode = (re->mode & 255 | 64) & 255;
            }
            re = re + 8;
            if( &(regex->position) <= st_ptr || regex + 512 <= re) {
                if(msg != 0) {
                     *msg = "Regular expression too long";
                }
                _t113 = 0;
L17:
                return _t113;
            } else {
                p =  &(p[1]);
                continue;
            }
        }
        goto __eax;
    }
    re->mode = (re->mode & 255 | 7) & 255;
    if(msg != 0) {
         *msg = 0;
    }
     *ex = p;
    _t113 = regex;
    goto L17;
}

Regex* newRegex(char* ex, int igncase, Regex* regex, char** msg)
{// addr = 0x080A5D6B  --  defined in 'regex.c' at line 285
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    return newRegex0( &ex, igncase, regex, msg, 0);
}

int regexMatch(char* str, int len, int firstp)
{// addr = 0x080A5D9B  --  defined in 'regex.c' at line 294
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return RegexMatch( &DefaultRegex, str, len, firstp);
}

int RegexMatch(Regex* re, char* str, int len, int firstp)
{// addr = 0x080A5DC4  --  defined in 'regex.c' at line 300
    char* p;                               // _cfa_fffffff0
    char* ep;                              // _cfa_ffffffec
    char* lpos;                            // _cfa_ffffffe8
    Regex* r;            // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t66;                              // _t66
    int _t69;                              // _t69
    _unknown_ _t71;                        // _t71
    _unknown_ _t83;                        // _t83
    _unknown_ _t90;                        // _t90
    _unknown_ _t93;                        // _t93

    if(str == 0) {
        return 0;
    }
    if(len < 0) {
        len = strlen(str);
    }
    re->position = 0;
    ep =  &(str[len]);
    p = str;
    while(p <= ep) {
        lpos = 0;
        re->lposition = 0;
        r = re;
        while(r != 0) {
            if(firstp == 0 || p != str) {
                _t66 = 0;
            } else {
                _t66 = 1;
            }
            _t69 = regmatch(r, p, ep, _t66,  &lpos);
            if(_t69 == 255) {
                re->position = 0;
                return -1;
            } else {
                if(_t69 == 1) {
                    re->position = p;
                    if(re->lposition == 0 || re->lposition < lpos) {
                        re->lposition = lpos;
                    }
                }
                r = r->alt_regex;
                continue;
            }
        }
        if(re->lposition == 0) {
            p =  &(p[( *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff) - 1]);
            p =  &(p[1]);
            continue;
        }
        return 1;
    }
    return 0;
}

MatchedPosition(Regex* re, char** first, char** last)
{// addr = 0x080A5F1C  --  defined in 'regex.c' at line 340
    _unknown_ __ebp;                       // r6

     *first = re->position;
     *last = re->lposition;
    return;
}

matchedPosition(char** first, char** last)
{// addr = 0x080A5F3D  --  defined in 'regex.c' at line 347
    _unknown_ __ebp;                       // r6

     *first =  *135789440;
     *last =  *135789444;
    return;
}

int regmatch_sub_anytime(struct MatchingContext2* c, Regex* regex, regexchar* pat2, char* str, char* end_p, int iter_limit, int firstp)
{// addr = 0x080A5F58  --  defined in 'regex.c' at line 389
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    struct MatchingContext1* _t109;   // _t109
    struct MatchingContext2* _t110;   // _t110
    _unknown_ _t160;                       // _t160
    _unknown_ _t162;                       // _t162
    _unknown_ _t168;                       // _t168
    _unknown_ _t175;                       // _t175

    _t109 = c->label;
    if(_t109 == 2) {
        goto L12;
    }
    if(_t109 == 3) {
        goto L16;
    }
    if(_t109 != 1) {
         *__esp = 44;
        GC_malloc();
        _t110 = c;
        _t110->ctx = _t109;
         *__esp = 32;
        GC_malloc();
        c->ctx2 = _t110;
        c->ctx->label = 0;
        c->regex = regex;
        c->n_any = 0;
        c->str = str;
        c->firstp = firstp;
        goto L5;
    }
    goto L12;
L5:
    c->ctx->label = 0;
L20:
    while(regmatch_iter(c->ctx, c->regex, c->str, end_p, c->firstp) != 0) {
        c->n_any = c->ctx->lastpos - c->str;
        if(c->n_any <= 0) {
            continue;
        }
        c->firstp = 0;
        if((pat2->mode & 7) != 7) {
            if(regmatch(pat2,  &(c->str[c->n_any]), end_p, c->firstp,  &(c->lastpos)) != 1) {
                goto L12;
            }
            goto L10;
L13:
            c->ctx2->label = 0;
            goto L16;
        }
        c->lastpos =  &(c->str[c->n_any]);
        c->label = 1;
        return 1;
L10:
        c->label = 2;
        return 1;
    }
    if(c->regex->alt_regex != 0) {
        c->regex = c->regex->alt_regex;
        goto L5;
    }
    return 0;
    return __eax;
L16:
    if(regmatch_sub_anytime(c->ctx2, regex, pat2,  &(c->str[c->n_any]), end_p, iter_limit - 1, c->firstp) != 0) {
        c->lastpos = c->ctx2->lastpos;
        c->label = 3;
        return 1;
    }
    goto L20;
L12:
    if(iter_limit == 1) {
        goto L20;
    }
    goto L13;
}

int regmatch_iter(struct MatchingContext1* c, regexchar* re, char* str, char* end_p, int firstp)
{// addr = 0x080A61A6  --  defined in 'regex.c' at line 442
    longchar k;       // _cfa_ffffffd4
    char _v16;                             // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    longchar k;       // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ _v92;                        // _cfa_ffffffa4
    _unknown_ _v96;                        // _cfa_ffffffa0
    _unknown_ _v100;                       // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    _unknown_ _v108;                       // _cfa_ffffff94
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t336;                      // _t336
    int _t345;                             // _t345
    struct MatchingContext1* _t357;   // _t357
    struct MatchingContext2* _t463;   // _t463
    _unknown_ _t517;                       // _t517

    __esp = __esp - 92;
    if(c->label <= 7) {
        goto __eax;
    }
    if((re->mode & 7) != 7) {
        c->re = re;
        c->firstp = firstp;
        c->str = str;
        c->end_p = end_p;
        c->sub_ctx = 0;
        c->lastpos = 0;
        while((c->re->mode & 7) != 7) {
            if((c->re->mode & 0x18) == 0) {
                _t336 = c->re->mode & 7;
                if(_t336 == 5) {
                    if(c->firstp != 0) {
                        c->re = c->re + 8;
                        goto L55;
                    }
                    _t345 = 0;
                } else {
                    if(_t336 == 6) {
                        if(c->str < c->end_p) {
                            c->lastpos = 0;
                            _t345 = 0;
                        } else {
                            c->lastpos = c->str;
                            c->re = c->re + 8;
                            c->label = 4;
                            _t345 = 1;
                        }
                    } else {
                        if(_t336 == 4) {
                            _t357 = c->sub_ctx;
                            if(_t357 == 0) {
                                 *__esp = 44;
                                GC_malloc();
                                c->sub_ctx = _t357;
                            }
                            c->sub_regex = c->re->p;
                            while(1) {
                                c->sub_ctx->label = 0;
                                goto L48;
                            }
                        }
                        _v104 = c->str;
                        __eax = set_longchar( &_v60);
                        __esp = __esp - 4;
                        k.type = _v60;
                        _v40 = _v56;
                        _v36 = _v52;
                        _v32 = _v48;
                        c->str =  &(c->str[ *( &WTF_LEN_MAP + (c & 0xff)) & 0xff]);
                        if(regmatch1(c->re,  &(k.type)) != 0) {
                            c->re = c->re + 8;
                            c->firstp = 0;
L55:
                            if(c->str <= c->end_p) {
                                continue;
                            } else {
                                _t345 = 0;
                            }
                            goto L59;
                        }
                        _t345 = 0;
                    }
                }
            } else {
                if((c->re->mode & 0x10) == 0) {
                    c->iter_limit = 1;
                } else {
                    c->iter_limit = 65535;
                }
                c->n_any = -1;
                while(c->n_any < c->iter_limit) {
                    if( &(c->str[c->n_any]) < c->end_p) {
                        if(c->n_any >= 0) {
                            c->n_any =  &(c->n_any->p);
L22:
                            if(( *(c->re + 0xc) & 7) != 7) {
                                if(regmatch(c->re + 8,  &(c->str[c->n_any]), c->end_p, c->firstp,  &(c->lastpos)) != 1) {
                                    continue;
                                } else {
                                    c->label = 3;
                                    _t345 = 1;
                                }
                            } else {
                                c->lastpos =  &(c->str[c->n_any]);
                                c->label = 2;
                                _t345 = 1;
                            }
                            goto L59;
                        }
                        _t463 = c->re->mode & 7;
                        if(_t463 != 4) {
                            _v104 =  &(c->str[c->n_any]);
                            __eax = set_longchar( &_v60);
                            __esp = __esp - 4;
                            k.type = _v60;
                            _v40 = _v56;
                            _v36 = _v52;
                            _v32 = _v48;
                            if(regmatch1(c->re,  &(k.type)) == 0) {
                                _t345 = 0;
                            } else {
                                c->n_any = c->n_any + ( *( &WTF_LEN_MAP + (c->str[c->n_any] & 0xff)) & 0xff);
                                c->firstp = 0;
                                goto L22;
                            }
                        } else {
                             *__esp = 32;
                            GC_malloc();
                            c->ctx2 = _t463;
                            c->ctx2->label = 0;
                            _v64 =  &(c->str[c->n_any]);
                            if(regmatch_sub_anytime(c->ctx2, c->re->p, c->re + 8, _v64, c->end_p, c->iter_limit, c->firstp) != 0) {
                                c->n_any = c->ctx2->lastpos - c->str;
                                c->lastpos = c->ctx2->lastpos;
                                c->label = 1;
                                _t345 = 1;
                            } else {
                                _t345 = 0;
                            }
                        }
                    } else {
                        _t345 = 0;
                    }
                    goto L59;
                }
                _t345 = 0;
            }
            goto L59;
        }
        c->lastpos = c->str;
        c->label = 7;
        _t345 = 1;
        goto L59;
    }
    _t345 = 0;
L59:
     &_v16 =  &_v16;
    return _t345;
}

int regmatch(regexchar* re, char* str, char* end_p, int firstp, char** lastpos)
{// addr = 0x080A67D2  --  defined in 'regex.c' at line 590
    _unknown_ _v48;                        // _cfa_ffffffd0
    struct MatchingContext1 contx;   // _cfa_ffffffc8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    _unknown_ _t33;                        // _t33

     *lastpos = 0;
    contx.label = 0;
    while(regmatch_iter( &(contx.label), re, str, end_p, firstp) != 0) {
    }
    if( *lastpos != 0) {
        return 1;
    }
    return 0;
}

int regmatch1(regexchar* re, longchar* c)
{// addr = 0x080A6849  --  defined in 'regex.c' at line 617
    int ans;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t42;                       // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t57;                        // _t57
    _unknown_ _t65;                        // _t65

    if((c->type & 0xff) != 4) {
        _t42 = re->mode & 7;
        if(_t42 == 1) {
            return 1;
        }
        goto L3;
L10:
        ans = match_longchar(re->p, c, re->mode & 0x40);
        return ans;
    }
    return 0;
L3:
    if(_t42 > 1) {
        if(_t42 == 2) {
            goto L11;
        }
        goto L7;
L12:
        return matchWhich(re->p, c, re->mode & 0x40) & 0xff;
    }
    if(_t42 == 0) {
        goto L10;
    }
L13:
    return 0;
L11:
    return matchWhich(re->p, c, re->mode & 0x40);
L7:
    if(_t42 == 3) {
        goto L12;
    }
    goto L13;
}

int matchWhich(longchar* pattern, longchar* c, int igncase)
{// addr = 0x080A692C  --  defined in 'regex.c' at line 649
    longchar* p;      // _cfa_fffffff0
    int ans;                               // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    p = pattern;
    ans = 0;
    while((p->type & 0xff) != 0) {
        if(( *(p + 16) & 0xff) != 3 || ( *(p + 32) & 0xff) == 0) {
            if(match_longchar(p, c, igncase) == 0) {
                p = p + 16;
                continue;
            }
        } else {
            if(match_range_longchar(p, p + 32, c, igncase) == 0) {
                p = p + 48;
                continue;
            }
            ans = 1;
            break;
        }
        ans = 1;
        break;
    }
    return ans;
}

int match_longchar(longchar* a, longchar* b, int ignore)
{// addr = 0x080A69CE  --  defined in 'regex.c' at line 682
    _unknown_ __ebp;                       // r6
    _unknown_ _t80;                        // _t80
    signed int _t100;                      // _t100
    int _t101;                             // _t101
    signed int _t112;                      // _t112
    int _t122;                             // _t122
    _unknown_ _t126;                       // _t126
    _unknown_ _t128;                       // _t128
    signed int _t129;                      // _t129
    signed int _t130;                      // _t130

    if((a->type & 0xff) != (b->type & 0xff)) {
        return 0;
    }
    if((a->type & 0xff) != 2) {
        if(ignore == 0 || ( *( &MYCTYPE_MAP + (b->ch & 0xff)) & 4) == 0) {
            return b->ch & 0xff;
        } else {
            _t129 = a->ch & 0xff;
            if(( *( &MYCTYPE_MAP + (b->ch & 0xff)) & 4) == 0) {
                _t100 = b->ch & 0xff;
            } else {
                _t100 = (b->ch & 255 | 32) & 0xff;
            }
            if(_t129 == _t100) {
L18:
                _t101 = 1;
                goto L20;
            } else {
                _t130 = a->ch & 0xff;
                if(( *( &MYCTYPE_MAP + (b->ch & 0xff)) & 4) == 0) {
                    _t112 = b->ch & 0xff;
                } else {
                    _t112 = b->ch & 0xdf;
                }
                if(_t130 != _t112) {
                    goto L19;
                }
                goto L18;
L20:
                return _t101;
            }
L19:
            _t101 = 0;
            goto L20;
        }
        return __eax;
    } else {
        if( *((intOrPtr*)(a + 4)) !=  *((intOrPtr*)(b + 4)) ||  *((intOrPtr*)(a + 8)) !=  *((intOrPtr*)(b + 8))) {
            _t122 = 0;
        } else {
            _t122 = 1;
        }
        return _t122;
    }
}

int match_range_longchar(longchar* a, longchar* b, longchar* c, int ignore)
{// addr = 0x080A6AF9  --  defined in 'regex.c' at line 697
    _unknown_ __ebp;                       // r6
    _unknown_ _t134;                       // _t134
    _unknown_ _t143;                       // _t143
    _unknown_ _t147;                       // _t147
    signed int _t164;                      // _t164
    signed int _t175;                      // _t175
    int _t176;                             // _t176
    signed int _t185;                      // _t185
    signed int _t200;                      // _t200
    int _t210;                             // _t210
    signed int _t224;                      // _t224
    signed int _t225;                      // _t225

    if((a->type & 0xff) != (b->type & 0xff) || (a->type & 0xff) != (c->type & 0xff)) {
        return 0;
    }
    if((a->type & 0xff) != 2) {
        if(ignore == 0 || ( *( &MYCTYPE_MAP + (c->ch & 0xff)) & 4) == 0) {
            if((a->ch & 0xff) > (c->ch & 0xff) || (c->ch & 0xff) > (b->ch & 0xff)) {
                return 0;
            }
            return 1;
        } else {
            _t224 = a->ch & 0xff;
            if(( *( &MYCTYPE_MAP + (c->ch & 0xff)) & 4) == 0) {
                _t164 = c->ch & 0xff;
            } else {
                _t164 = (c->ch & 255 | 32) & 0xff;
            }
            if(_t224 > _t164) {
L21:
                _t225 = a->ch & 0xff;
                if(( *( &MYCTYPE_MAP + (c->ch & 0xff)) & 4) == 0) {
                    _t175 = c->ch & 0xff;
                } else {
                    _t175 = c->ch & 0xdf;
                }
                if(_t225 > _t175) {
                    goto L30;
                } else {
                    if(( *( &MYCTYPE_MAP + (c->ch & 0xff)) & 4) == 0) {
                        _t185 = c->ch & 0xff;
                    } else {
                        _t185 = c->ch & 0xdf;
                    }
                    if(_t185 > (b->ch & 0xff)) {
                        goto L30;
                    }
                    goto L29;
                }
                goto L31;
            }
            if(( *( &MYCTYPE_MAP + (c->ch & 0xff)) & 4) == 0) {
                _t200 = c->ch & 0xff;
            } else {
                _t200 = (c->ch & 255 | 32) & 0xff;
            }
            if(_t200 <= (b->ch & 0xff)) {
L29:
                _t176 = 1;
L31:
                return _t176;
            } else {
                goto L21;
            }
L30:
            _t176 = 0;
            goto L31;
        }
    } else {
        if( *((intOrPtr*)(a + 4)) !=  *((intOrPtr*)(c + 4)) ||  *((intOrPtr*)(c + 4)) !=  *((intOrPtr*)(b + 4)) ||  *((intOrPtr*)(a + 8)) >  *((intOrPtr*)(c + 8))) {
L9:
            _t210 = 0;
        } else {
            if( *((intOrPtr*)(c + 8)) >  *((intOrPtr*)(b + 8))) {
                goto L9;
            } else {
                _t210 = 1;
            }
        }
        return _t210;
    }
}

KeyAbort(int _dummy)
{// addr = 0x080A6CF8  --  defined in 'news.c' at line 29
    intOrPtr _v0;                          // _cfa_0
    struct _Str* _v20;    // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v60;                        // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    _unknown_ __ebp;                       // r6
    _unknown_ _t46;                        // _t46
    _unknown_ _t47;                        // _t47
    _unknown_ _t55;                        // _t55
    _unknown_ _t58;                        // _t58
    _unknown_ _t62;                        // _t62
    _unknown_ _t67;                        // _t67
    _unknown_ _t68;                        // _t68

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t67);
    __esp = __esp - 40;
    if( *_v24 != 0) {
        if(_dummy != 0) {
            if(_a8 == 0) {
                _v68 = _dummy;
                _v20 = Sprintf("%s\n");
            } else {
                _v64 = _a8;
                _v68 = _dummy;
                _v20 = Sprintf("%s %s\n");
            }
            fwrite( *_v20, 1, _v20->length,  *(_v0 + 16));
            fflush( *(_v0 + 16));
        }
        if(_a12 != 0) {
             *_a12 = -1;
            _v20 = StrISgets( *(_v0 + 12));
            if(_v20->length != 0) {
                _v64 = _a12;
                sscanf( *_v20, "%d");
            }
            return _v20;
        }
        return 0;
    }
    return 0;
}

Str news_command(News* news, char* cmd, char* arg, int* status)
{// addr = 0x080A6D12  --  defined in 'news.c' at line 36
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    _unknown_ _t46;                        // _t46
    _unknown_ _t54;                        // _t54
    _unknown_ _t57;                        // _t57
    _unknown_ _t61;                        // _t61

    if(news->host != 0) {
        if(cmd != 0) {
            if(arg == 0) {
                _v40 = cmd;
                tmp = Sprintf("%s\n");
            } else {
                _v36 = arg;
                _v40 = cmd;
                tmp = Sprintf("%s %s\n");
            }
            fwrite(tmp->ptr, 1, tmp->length, news->wf);
            fflush(news->wf);
        }
        if(status != 0) {
             *status = -1;
            tmp = StrISgets( *(news + 12));
            if(tmp->length != 0) {
                _v36 = status;
                sscanf(tmp->ptr, "%d");
            }
            return tmp;
        }
        return 0;
    }
    return 0;
}

news_close(News* news)
{// addr = 0x080A6DF8  --  defined in 'news.c' at line 60
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    _unknown_ _t38;                        // _t38

    if(news->host != 0) {
        if( *(news + 12) != 0) {
            ( *(news + 12))[0x14] = ( *(news + 12))[0x14] & 0xef;
            ISclose( *(news + 12));
             *(news + 12) = 0;
        }
        if(news->wf != 0) {
            fclose(news->wf);
            news->wf = 0;
        }
        news->host = 0;
        return;
    }
    return;
}

int news_open(News* news)
{// addr = 0x080A6E6F  --  defined in 'news.c' at line 77
    int sock;                              // _cfa_fffffff0
    int status;                            // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t54;                        // _t54
    _unknown_ _t68;                        // _t68
    _unknown_ _t72;                        // _t72
    _unknown_ _t76;                        // _t76

    sock = openSocket(news->host, "nntp", news->port & 0xffff);
    if(sock >= 0) {
L12:
        news_close(news);
        return 0;
    }
     *(news + 12) = newInputStream(sock);
    news->wf = fdopen(dup(sock), "wb");
    if( *(news + 12) == 0 || news->wf == 0) {
    } else {
         *(news + 12)->base.stream.cur = ( *(news + 12)->base.stream.cur & 255 | 16) & 255;
        news_command(news, 0, 0,  &status);
        if(status == 200 || status == 201) {
            if(news->mode == 0) {
L8:
                return 1;
            }
            news_command(news, "MODE", news->mode,  &status);
            if(status == 200 || status == 201) {
                goto L8;
            }
        } else {
        }
    }
    return __eax;
}

news_quit(News* news)
{// addr = 0x080A6FA0  --  defined in 'news.c' at line 104
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    news_command(news, "QUIT", 0, 0);
    news_close(news);
    return;
}

char* name_from_address(char* str, int n)
{// addr = 0x080A6FD6  --  defined in 'news.c' at line 111
    char* s;                               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int l;                                 // _cfa_ffffffe8
    int space;                             // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t150;                      // _t150

    space = 1;
    s = allocStr(str, -1);
    while(( *s & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *s & 0xff)) & 2) != 0) {
    }
    if(( *s & 0xff) != 60) {
L13:
        p = strchr(s, 60);
        if(p == 0) {
            p = strchr(s, 40);
            if(p != 0) {
                s = p;
            }
        } else {
L14:
             *p = 0;
        }
        if(( *s & 0xff) != 34) {
L20:
            if(( *s & 0xff) == 40) {
                p = strchr( &(s[1]), 41);
                if(p != 0) {
                     *p = 0;
                    s =  &(s[1]);
                }
            }
            goto L23;
        }
        p = strchr( &(s[1]), 34);
        if(p == 0) {
            goto L20;
        } else {
             *p = 0;
            s =  &(s[1]);
        }
L23:
        p = s;
        l = 0;
        while(( *p & 0xff) != 0) {
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                space = 0;
                goto L28;
            }
            if(space != 0) {
                goto L34;
            }
            space = 1;
            goto L28;
L34:
            p =  &(p[ *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff]);
            continue;
L28:
            if(( *135119023 & 0xff) == 0) {
                _t150 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            } else {
                _t150 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
            }
            l = l + _t150;
            if(l <= n) {
                goto L34;
            }
L38:
             *p = 0;
            return s;
        }
        goto L38;
    }
    p = strchr(s, 62);
    if(p == 0) {
        goto L13;
    } else {
         *p = 0;
        p =  &(p[1]);
        while() {
        }
    }
    goto L14;
}

char* html_quote_s(char* str)
{// addr = 0x080A71FD  --  defined in 'news.c' at line 155
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    int space;                             // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t84;                              // _t84

    tmp = 0;
    space = 1;
    p = str;
    while(( *p & 0xff) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
            q =  *( &HTML_QUOTE_MAP + ( *( &QUOTE_MAP + ( *p & 0xff)) & 7) * 4);
            space = 0;
            goto L5;
        }
        if(space == 0) {
            q = "&nbsp;";
            space = 1;
            goto L5;
        }
L14:
        p =  &(p[1]);
        continue;
L5:
        if(q == 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t84 = tmp->length;
                 *(tmp->ptr + _t84) =  *p & 0xff;
                tmp->length = _t84 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            Strcat_charp(tmp, q);
        }
        goto L14;
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

add_news_message(Str str, int index, char* date, char* name, char* subject, char* mid, char* scheme, char* group)
{// addr = 0x080A7331  --  defined in 'news.c' at line 188
    time_t t;           // _cfa_fffffff0
    struct tm* tm;          // _cfa_ffffffec
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct tm* _t43;        // _t43
    char* _t50;                            // _t50
    char* _t53;                            // _t53

    name = name_from_address(name, 16);
    t = mymktime(date);
    _t43 =  &t;
     *__esp = _t43;
    localtime();
    tm = _t43;
    _v44 = html_quote_s(name);
    _v48 = tm->tm_mday;
    _v52 = tm->tm_mon + 1;
    _v56 = index;
    Strcat(str, Sprintf("<tr valign=top><td>%d<td nowrap>(%02d/%02d)<td nowrap>%s"));
    if(group == 0) {
        _t50 = html_quote(subject);
        _t53 = html_quote(file_quote(mid));
        _v48 = _t50;
        _v52 = _t53;
        _v56 = scheme;
        Strcat(str, Sprintf("<td><a href="%s%s">%s</a>\n"));
        return;
    }
    _v44 = html_quote(subject);
    _v48 = index;
    _v52 = group;
    _v56 = scheme;
    Strcat(str, Sprintf("<td><a href="%s%s/%d">%s</a>\n"));
    return;
}

InputStream openNewsStream(ParsedURL* pu)
{// addr = 0x080A7449  --  defined in 'news.c' at line 233
    char* host;                            // _cfa_fffffff0
    char* mode;                            // _cfa_ffffffec
    char* group;                           // _cfa_ffffffe8
    char* p;                               // _cfa_ffffffe4
    Str tmp;               // _cfa_ffffffe0
    int port;                              // _cfa_ffffffdc
    int status;                            // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t94;                        // _t94
    _unknown_ _t103;                       // _t103
    _unknown_ _t124;                       // _t124
    _unknown_ _t130;                       // _t130
    _unknown_ _t133;                       // _t133
    _unknown_ _t137;                       // _t137
    _unknown_ _t138;                       // _t138
    _unknown_ _t142;                       // _t142
    _unknown_ _t145;                       // _t145
    char* _t149;                           // _t149
    _unknown_ _t151;                       // _t151
    char* _t156;                           // _t156

    if(pu->file == 0 || (pu & 0xff) == 0) {
        return 0;
    }
    if(pu->scheme == 7) {
L5:
        host = pu->host;
L7:
        if(host == 0 || ( *host & 0xff) == 0) {
            if(current_news.host != 0) {
                news_quit( &current_news);
            }
            return 0;
        }
        if(pu->scheme == 7 || pu->scheme == 8) {
L16:
            port = pu->port;
        } else {
            p = strchr(host, 58);
            if(p == 0) {
                goto L16;
            } else {
                host = allocStr(host, p - host);
                port = atoi( &(p[1]));
            }
        }
        if(NNTP_mode == 0 || ( *NNTP_mode & 0xff) == 0) {
            mode = 0;
        } else {
            mode = NNTP_mode;
        }
        if(current_news.host == 0) {
L33:
            if(current_news.host != 0) {
L39:
                if(pu->scheme == 7 || pu->scheme == 9) {
                    group = file_unquote(allocStr(pu->file, -1));
                    p = strchr(group, 47);
                    if(p != 0) {
L45:
                         *p = 0;
                        p =  &(p[1]);
                        news_command( &current_news, "GROUP", group,  &status);
                        if(status == 211) {
                            goto L47;
                        }
                        goto L46;
                    }
                    if(strchr(group, 64) != 0) {
                        p = group;
L47:
                        if(strchr(p, 64) == 0) {
                            news_command( &current_news, "ARTICLE", p,  &status);
                        } else {
                            _v56 = p;
                            news_command( &current_news, "ARTICLE",  *(Sprintf("<%s>")),  &status);
                        }
                        if(status == 220) {
                            return  *135789484;
                        }
                        return 0;
                    }
                    return 0;
                    goto L45;
L46:
                    return 0;
                }
                return 0;
            }
        } else {
            if(strcmp(current_news.host, host) != 0 ||  *135789476 != port) {
                news_quit( &current_news);
            } else {
                if(mode == 0) {
                    _t156 = "READER";
                } else {
                    _t156 = mode;
                }
                tmp = news_command( &current_news, "MODE", _t156,  &status);
                if(status != 200) {
                    if(status != 201) {
                        news_close( &current_news);
                    }
                }
            }
            goto L33;
        }
        current_news.host = allocStr(host, -1);
         *135789476 = port;
        if(mode == 0) {
            _t149 = 0;
        } else {
            _t149 = allocStr(mode, -1);
        }
         *135789480 = _t149;
        if(news_open( &current_news) != 0) {
            goto L39;
        }
        return 0;
    }
    if(pu->scheme != 8) {
        host = NNTP_server;
        goto L7;
    }
    goto L5;
}

Str loadNewsgroup(ParsedURL* pu, wc_ces* charset)
{// addr = 0x080A779F  --  defined in 'news.c' at line 308
    _None page;                            // _cfa_ffffffe0
    Str tmp;               // _cfa_ffffffdc
    Buffer* buf;        // _cfa_ffffffd8
    char* qgroup;                          // _cfa_ffffffd4
    char* p;                               // _cfa_ffffffd0
    char* q;                               // _cfa_ffffffcc
    char* s;                               // _cfa_ffffffc8
    char* t;                               // _cfa_ffffffc4
    char* n;                               // _cfa_ffffffc0
    _None scheme;                          // _cfa_ffffffbc
    _None group;                           // _cfa_ffffffb8
    _None list;                            // _cfa_ffffffb4
    int status;                            // _cfa_ffffffb0
    int i;                                 // _cfa_ffffffac
    int first;                             // _cfa_ffffffa8
    int last;                              // _cfa_ffffffa4
    _None flag;                            // _cfa_ffffffa0
    _None start;                           // _cfa_ffffff9c
    _None end;                             // _cfa_ffffff98
    _None prevtrap;                        // _cfa_ffffff94
    wc_ces doc_charset;   // _cfa_ffffff90
    wc_ces mime_charset;   // _cfa_ffffff8c
    URLFile f;         // _cfa_ffffff6c
    _None _v160;                           // _cfa_ffffff60
    int _v176;                             // _cfa_ffffff50
    int _v180;                             // _cfa_ffffff4c
    int _v184;                             // _cfa_ffffff48
    int _v188;                             // _cfa_ffffff44
    int* _v192;                            // _cfa_ffffff40
    int* _v196;                            // _cfa_ffffff3c
    _None _v200;                           // _cfa_ffffff38
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t473;                       // _t473
    struct _Str* _t493;   // _t493
    _None _t495;                           // _t495
    _unknown_ _t506;                       // _t506
    _unknown_ _t523;                       // _t523
    char* _t541;                           // _t541
    char* _t544;                           // _t544
    struct _Str* _t579;   // _t579
    _unknown_ _t587;                       // _t587
    _None _t592;                           // _t592
    _unknown_ _t593;                       // _t593
    _unknown_ _t612;                       // _t612
    char* _t632;                           // _t632
    wc_ces* _t679;      // _t679
    wc_ces* _t689;      // _t689
    char* _t696;                           // _t696
    _None _t753;                           // _t753
    int _t797;                             // _t797
    _unknown_ _t798;                       // _t798
    unsigned int _t811;                    // _t811
    unsigned int _t813;                    // _t813

    flag = 0;
    start = 0;
    end = 0;
    prevtrap = 0;
    doc_charset = DocumentCharset;
     *charset = 256;
    if(current_news.host == 0 || pu->file == 0) {
L3:
        return 0;
    }
    if((pu & 0xff) != 0) {
        group = allocStr(pu->file, -1);
        if(pu->scheme != 8) {
            scheme = "news:";
        } else {
            scheme = "/";
        }
        list = strchr(group, 47);
        if(list != 0) {
            _t753 = list;
             *_t753 = 0;
            list = _t753 + 1;
        }
        if((fmInitialized & 0xff) != 0) {
            _v200 = group;
            message( *(Sprintf("Reading newsgroup %s...")), 0, 0);
            refresh();
        }
        qgroup = html_quote(group);
        group = file_unquote(group);
        _t493 = parsedURL2Str(pu);
        _v176 = 0;
        _v180 = "</h1>\n<hr>\n";
        _v184 = qgroup;
        _v188 = "</title>\n</head>\n<body>\n<h1>Newsgroup: ";
        _v192 = qgroup;
        _v196 = "">\n<title>Newsgroup: ";
        _v200 = _t493->ptr;
        _t495 = Strnew_m_charp("<html>\n<head>\n<base href="");
        page = _t495;
        _v200 = 1;
         *__esp =  &AbortLoading;
        __sigsetjmp();
        if(_t495 == 0) {
            if((TrapSignal & 0xff) != 0) {
                prevtrap = mySignal(2, KeyAbort);
                if((fmInitialized & 0xff) != 0) {
                    term_cbreak();
                }
            }
            tmp = news_command( &current_news, "GROUP", group,  &status);
            if(status != 211) {
                goto L108;
            }
            _v184 =  &last;
            _v188 =  &first;
            _v192 =  &i;
            _v196 =  &status;
            if(sscanf(tmp->ptr, "%d %d %d %d") != 4) {
                goto L107;
            } else {
                if(list != 0 && ( *list & 0xff) != 0) {
                    p = strchr(list, 45);
                    if(p != 0) {
                         *p = 0;
                        p =  &(p[1]);
                        end = atoi(p);
                    }
                    start = atoi(list);
                    if(start > 0) {
                        if(start < first) {
                            start = first;
                        }
                        if(end <= 0) {
                            end = start + MaxNewsMessage - 1;
                        }
                    }
                }
                if(start <= 0) {
                    start = first;
                    end = last;
                    if(end - start > MaxNewsMessage - 1) {
                        start = end - MaxNewsMessage + 1;
                    }
                }
                _v160 = end;
                _t579 = parsedURL2Str(pu);
                _v176 = _v160;
                _v180 = start;
                _v184 = qgroup;
                _v188 = end;
                _v192 = start;
                _v196 = qgroup;
                _v200 = _t579->ptr;
                page = Sprintf("<html>\n<head>\n<base href="%s">\n<title>Newsgroup: %s %d-%d</title>\n</head>\n<body>\n<h1>Newsgroup: %s %d-%d</h1>\n<hr>\n");
                if(start > first) {
                    i = start - MaxNewsMessage;
                    if(i < first) {
                        i = first;
                    }
                    _v180 = start - 1;
                    _v184 = i;
                    _v188 = start - 1;
                    _v192 = i;
                    _v196 = qgroup;
                    _v200 = scheme;
                    Strcat(page, Sprintf("<a href="%s%s/%d-%d">[%d-%d]</a>\n"));
                }
                Strcat_charp(page, "<table>\n");
                _v196 = end;
                _v200 = start;
                news_command( &current_news, "XOVER",  *(Sprintf("%d-%d")),  &status);
                if(status != 224) {
                    init_stream( &(f.scheme), 9,  *135789484);
                    _t797 = COLS;
                    if(showLineNum == 0) {
                        _t592 = 1;
                    } else {
                        _t592 = 6;
                    }
                    _t593 = _t797 - _t592;
                    _t594 = _t593 >= 0 ? 0 : _t593;
                    buf = newBuffer(_t593 >= 0 ? 0 : _t593);
                    i = start;
                    while(i <= end && i <= last) {
                        _v200 = i;
                        news_command( &current_news, "HEAD",  *(Sprintf("%d")),  &status);
                        if(status == 221) {
                            readHeader( &(f.scheme), buf, 0, 0);
                            p = checkHeader(buf, "Message-ID:");
                            if(p != 0) {
                                if(( *p & 0xff) == 60) {
                                    p =  &(p[1]);
                                }
                                q = strchr(p, 62);
                                if(q == 0) {
                                    q = strchr(p, 9);
                                    if(q == 0) {
                                         *q = 0;
                                    }
                                }
                                s = checkHeader(buf, "Subject:");
                                if(s != 0) {
                                    n = checkHeader(buf, "From:");
                                    if(n != 0) {
                                        t = checkHeader(buf, "Date:");
                                        if(t != 0) {
                                            if(pu->scheme != 8) {
                                                _t632 = 0;
                                            } else {
                                                _t632 = qgroup;
                                            }
                                            add_news_message(page, i, t, n, s, p, scheme, _t632);
                                        }
                                    }
                                }
                            }
                        }
                        i = i + 1;
                    }
L101:
                    Strcat_charp(page, "</table>\n");
                    if(end < last) {
                        i = end + MaxNewsMessage;
                        if(i > last) {
                            i = last;
                        }
                        _v180 = i;
                        _v184 = end + 1;
                        _v188 = i;
                        _v192 = end + 1;
                        _v196 = qgroup;
                        _v200 = scheme;
                        Strcat(page, Sprintf("<a href="%s%s/%d-%d">[%d-%d]</a>\n"));
                    }
                    flag = 1;
                    goto L108;
                }
                f.scheme = 9;
                while(1) {
                    tmp = StrISgets( *135789484);
                    if((tmp & 0xff) == 46 && ((tmp->ptr[1] & 0xff) == 10 || (tmp->ptr[1] & 0xff) == 13 || (tmp->ptr[1] & 0xff) == 0)) {
                        break;
                    }
                    if((tmp & 0xff) == 10 || (tmp & 0xff) == 13 || (tmp & 0xff) == 0) {
                        goto L101;
                    }
                    _v196 =  &i;
                    if(sscanf(tmp->ptr, "%d") == 1) {
                        s = strchr(tmp->ptr, 9);
                        if(s != 0) {
                            s =  &(s[1]);
                            n = strchr(s, 9);
                            if(n != 0) {
                                 *n = 0;
                                n =  &(n[1]);
                                t = strchr(n, 9);
                                if(t != 0) {
                                     *t = 0;
                                    t =  &(t[1]);
                                    p = strchr(t, 9);
                                    if(p != 0) {
                                         *p = 0;
                                        p =  &(p[1]);
                                        if(( *p & 0xff) == 60) {
                                            p =  &(p[1]);
                                        }
                                        q = strchr(p, 62);
                                        if(q != 0) {
L58:
                                             *q = 0;
                                            tmp = decodeMIME(Strnew_charp(s),  &mime_charset);
                                            if(mime_charset == 0) {
                                                _t811 = doc_charset;
                                            } else {
                                                _t811 = mime_charset;
                                            }
                                            if(mime_charset == 0) {
                                                _t679 = charset;
                                            } else {
                                                _t679 =  &mime_charset;
                                            }
                                            s =  *(convertLine( &(f.scheme), tmp, 3, _t679, _t811));
                                            tmp = decodeMIME(Strnew_charp(n),  &mime_charset);
                                            if(mime_charset == 0) {
                                                _t813 = doc_charset;
                                            } else {
                                                _t813 = mime_charset;
                                            }
                                            if(mime_charset == 0) {
                                                _t689 = charset;
                                            } else {
                                                _t689 =  &mime_charset;
                                            }
                                            n =  *(convertLine( &(f.scheme), tmp, 3, _t689, _t813));
                                            if(pu->scheme != 8) {
                                                _t696 = 0;
                                            } else {
                                                _t696 = qgroup;
                                            }
                                            add_news_message(page, i, t, n, s, p, scheme, _t696);
                                            continue;
                                        }
                                        q = strchr(p, 9);
                                        if(q != 0) {
                                            goto L58;
                                        }
                                        goto L74;
                                    }
                                    goto L52;
                                }
                                goto L50;
L52:
                                goto L74;
                            }
                            goto L48;
L50:
                            goto L74;
                        }
                        goto L46;
L48:
                        goto L74;
                    }
L74:
                    continue;
L46:
                    goto L74;
                }
                goto L101;
            }
L108:
            _v200 = group;
            tmp = Sprintf("ACTIVE %s");
            if(strchr(group, 42) == 0) {
                Strcat_charp(tmp, ".*");
            }
            news_command( &current_news, "LIST", tmp->ptr,  &status);
            if(status != 215) {
            } else {
                while(1) {
                    tmp = StrISgets( *135789484);
                    if((tmp & 0xff) == 46 && ((tmp->ptr[1] & 0xff) == 10 || (tmp->ptr[1] & 0xff) == 13 || (tmp->ptr[1] & 0xff) == 0)) {
                        break;
                    }
                    if((tmp & 0xff) == 10 || (tmp & 0xff) == 13 || (tmp & 0xff) == 0) {
                        break;
                    } else {
                        if(flag <= 1) {
                            if(flag == 1) {
                                Strcat_charp(page, "<hr>\n");
                            }
                            Strcat_charp(page, "<table>\n");
                            flag = 2;
                        }
                        p = tmp->ptr;
                        q = p;
                        while(( *q & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0) {
                            q =  &(q[1]);
                        }
                         *q = 0;
                        q =  &(q[1]);
                        _v192 =  &first;
                        _v196 =  &last;
                        if(sscanf(q, "%d %d") != 2 || last < first) {
                            i = 0;
                        } else {
                            i = last - first + 1;
                        }
                        _t541 = html_quote(p);
                        _t544 = html_quote(file_quote(p));
                        _v188 = _t541;
                        _v192 = _t544;
                        _v196 = scheme;
                        _v200 = i;
                        Strcat(page, Sprintf("<tr><td align=right>%d<td><a href="%s%s">%s</a>\n"));
                        continue;
                    }
                }
                if(flag == 2) {
                    Strcat_charp(page, "</table>\n");
                }
            }
            goto L134;
L107:
            goto L108;
        } else {
            news_close( &current_news);
            Strcat_charp(page, "</table>\n<p>Transfer Interrupted!\n");
        }
L134:
        Strcat_charp(page, "</body>\n</html>\n");
        if((TrapSignal & 0xff) != 0) {
            if((fmInitialized & 0xff) != 0) {
                term_raw();
            }
            if(prevtrap != 0) {
                mySignal(2, prevtrap);
            }
        }
        return page;
    }
    goto L3;
}

closeNews()
{// addr = 0x080A83BA  --  defined in 'news.c' at line 507
    _unknown_ __ebp;                       // r6

    news_close( &current_news);
    return;
}

disconnectNews()
{// addr = 0x080A83CE  --  defined in 'news.c' at line 513
    _unknown_ __ebp;                       // r6

    news_quit( &current_news);
    return;
}

setKeymap(char* p, int lineno, int verbose)
{// addr = 0x080A83E4  --  defined in 'func.c' at line 22
    unsigned char* map;                    // _cfa_fffffff0
    char* s;                               // _cfa_ffffffec
    char* emsg;                            // _cfa_ffffffe8
    int c;                                 // _cfa_ffffffe4
    int f;                                 // _cfa_ffffffe0
    unsigned char** mmap;                  // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    int j;                                 // _cfa_ffffffd4
    int m;                                 // _cfa_ffffffd0
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    unsigned char** _t166;                 // _t166

    map = 0;
    s = getQWord( &p);
    c = getKey(s);
    if(c < 0) {
        if(lineno <= 0) {
            _v88 = s;
            emsg =  *(Sprintf("defkey: unknown key '%s'"));
        } else {
            _v84 = s;
            _v88 = lineno;
            emsg =  *(Sprintf("line %d: unknown key '%s'"));
        }
        record_err_message(emsg);
        if(verbose != 0) {
            disp_message_nsec(emsg, 0, 1, 1, 0);
            return;
        }
        return;
    }
    s = getWord( &p);
    f = getFuncList(s);
    if(f >= 0) {
        if((c & 268435456) == 0) {
            if((c & 1024) == 0) {
                if((c & 512) == 0) {
                    if((c & 256) == 0) {
                        map =  &GlobalKeymap;
                    } else {
                        map =  &EscKeymap;
                    }
                } else {
                    map =  &EscBKeymap;
                }
            } else {
                map =  &EscDKeymap;
            }
L47:
            map[c & 127] = f & 255;
            s = getQWord( &p);
            if(( *s & 0xff) == 0) {
                if(getKeyData(c) == 0) {
                    goto L55;
                }
                goto L52;
            }
            if(keyData == 0) {
                keyData = newHash_iv(16);
            }
            putHash_iv(keyData, c, s);
            return;
L52:
            putHash_iv(keyData, c, 0);
            return;
        }
    } else {
        if(lineno <= 0) {
            _v88 = s;
            emsg =  *(Sprintf("defkey: invalid command '%s'"));
        } else {
            _v84 = s;
            _v88 = lineno;
            emsg =  *(Sprintf("line %d: invalid command '%s'"));
        }
        record_err_message(emsg);
        if(verbose != 0) {
            disp_message_nsec(emsg, 0, 1, 1, 0);
            return;
        }
L55:
        return;
    }
    mmap = 0;
    m = c >> 16 & 1919;
    if((m & 1024) == 0) {
        if((m & 512) == 0) {
            if((m & 256) == 0) {
                map =  &GlobalKeymap;
            } else {
                map =  &EscKeymap;
            }
        } else {
            map =  &EscBKeymap;
        }
    } else {
        map =  &EscDKeymap;
    }
    if((map[m & 127] & 0xff) != 74) {
        _t166 =  &(map[m & 127]);
         *_t166 = 74;
    } else {
        _t166 = getKeyData(m);
        mmap = _t166;
    }
    if(mmap != 0) {
L31:
        if(keyData == 0) {
            keyData = newHash_iv(16);
        }
        putHash_iv(keyData, m, mmap);
        if((c & 1024) == 0) {
            if((c & 512) == 0) {
                if((c & 256) == 0) {
                    map =  *mmap;
                } else {
                    map = mmap[1];
                }
            } else {
                map = mmap[2];
            }
        } else {
            map = mmap[3];
        }
        goto L47;
    }
     *__esp = 16;
    GC_malloc();
    mmap = _t166;
    i = 0;
    while(i <= 3) {
         *__esp = 128;
        GC_malloc();
        mmap[i] = i << 2;
        j = 0;
        while(j <= 127) {
             *(mmap[i] + j) = 0;
            j = j + 1;
        }
        i = i + 1;
    }
    ( *mmap)[0x1b] = 28;
    mmap[1][0x5b] = 27;
    mmap[1][0x4f] = 27;
    goto L31;
}

interpret_keymap(FILE* kf, struct stat* current, int force)
{// addr = 0x080A87D7  --  defined in 'func.c' at line 117
    int fd;                                // _cfa_ffffffe0
    Str line;              // _cfa_ffffffdc
    char* p;                               // _cfa_ffffffd8
    char* s;                               // _cfa_ffffffd4
    char* emsg;                            // _cfa_ffffffd0
    int lineno;                            // _cfa_ffffffcc
    wc_ces charset;     // _cfa_ffffffc8
    int verbose;                           // _cfa_ffffffc4
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v104;                        // _cfa_ffffff98
    intOrPtr _v136;                        // _cfa_ffffff78
    signed int _v144;                      // _cfa_ffffff70
    struct stat kstat;    // _cfa_ffffff6c
    _unknown_ _v172;                       // _cfa_ffffff54
    _unknown_ _v176;                       // _cfa_ffffff50
    char* _v180;                           // _cfa_ffffff4c
    long long unsigned int* _v184;         // _cfa_ffffff48
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    int _t95;                              // _t95
    _unknown_ _t97;                        // _t97
    _unknown_ _t98;                        // _t98
    _unknown_ _t158;                       // _t158
    _unknown_ _t159;                       // _t159
    _unknown_ _t170;                       // _t170

    charset = SystemCharset;
    verbose = 1;
    fd = fileno(kf);
    if(fd >= 0) {
        return;
    }
    _v184 =  &(kstat.st_dev);
    _t95 = fd;
     *__esp = _t95;
    __fstat();
    if(_t95 != 0) {
        goto L29;
    }
    if(force != 0 || _v84 != current->st_mtim.tv_sec || (current->st_dev ^ kstat.st_dev | _v144 ^  *(current + 4)) != 0 || _v136 !=  *((intOrPtr*)(current + 12)) || _v104 !=  *((intOrPtr*)(current + 44))) {
        memcpy(current,  &(kstat.st_dev), 22 << 2);
        lineno = 0;
        while(feof(kf) == 0) {
            line = Strfgets(kf);
            lineno = lineno + 1;
            Strchop(line);
            Strremovefirstspaces(line);
            if(line->length == 0) {
L21:
                continue;
            }
            line = wc_Str_conv(line, charset, InnerCharset);
            p = line->ptr;
            s = getWord( &p);
            if(( *s & 0xff) == 35) {
                goto L22;
            }
            if(strcmp(s, "keymap") == 0) {
                setKeymap(p, lineno, verbose);
                continue;
            }
            if(strcmp(s, "charset") != 0 && strcmp(s, "encoding") != 0) {
                if(strcmp(s, "verbose") != 0) {
                    _v180 = s;
                    _v184 = lineno;
                    emsg =  *(Sprintf("line %d: syntax error '%s'"));
                    record_err_message(emsg);
                    if(verbose != 0) {
                        disp_message_nsec(emsg, 0, 1, 1, 0);
                    }
                } else {
                    s = getWord( &p);
                    if(( *s & 0xff) != 0) {
                        verbose = str_to_bool(s, verbose);
                    }
                }
            } else {
                s = getQWord( &p);
                if(( *s & 0xff) != 0) {
                    charset = wc_guess_charset(s, charset);
                }
            }
            continue;
L22:
        }
        return;
    }
    return;
L29:
    return;
}

initKeymap(int force)
{// addr = 0x080A8A8F  --  defined in 'func.c' at line 180
    FILE* kf;             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t21;                        // _t21
    int _t27;                              // _t27
    int _t31;                              // _t31
    _unknown_ _t34;                        // _t34

    kf = fopen(confFile("keymap"), "rt");
    if(kf == 0) {
L6:
        kf = fopen(rcFile(keymap_file), "rt");
        if(kf != 0) {
            if(force != 0 || (keymap_initialized & 0xff) == 0) {
                _t27 = 1;
            } else {
                _t27 = 0;
            }
            interpret_keymap(kf,  &current_keymap_file, _t27);
            _t26 = fclose(kf);
        }
        keymap_initialized = 1;
        return;
    }
    if(force == 0 && (keymap_initialized & 0xff) != 0) {
        _t31 = 0;
    } else {
        _t31 = 1;
    }
    interpret_keymap(kf,  &sys_current_keymap_file, _t31);
    fclose(kf);
    goto L6;
}

int getFuncList(char* id)
{// addr = 0x080A8B6E  --  defined in 'func.c' at line 198
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return getHash_si( &functable, id, -1);
}

char* getKeyData(int key)
{// addr = 0x080A8B91  --  defined in 'func.c' at line 204
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    if(keyData != 0) {
        return getHash_iv(keyData, key, 0);
    }
    return 0;
}

int getKey2(char** str)
{// addr = 0x080A8BC5  --  defined in 'func.c' at line 212
    char* s;                               // _cfa_fffffff0
    int c;                                 // _cfa_ffffffec
    int esc;                               // _cfa_ffffffe8
    int ctrl;                              // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t221;                       // _t221
    _unknown_ _t254;                       // _t254
    _unknown_ _t268;                       // _t268
    _unknown_ _t269;                       // _t269
    _unknown_ _t302;                       // _t302
    _unknown_ _t321;                       // _t321
    _unknown_ _t364;                       // _t364
    _unknown_ _t367;                       // _t367
    _unknown_ _t370;                       // _t370
    _unknown_ _t373;                       // _t373

    s =  *str;
    esc = 0;
    ctrl = 0;
    if(s == 0 || ( *s & 0xff) == 0) {
        return -1;
    }
    if(strcasecmp(s, "UP") == 0) {
         *str =  &(s[2]);
        return 577;
    }
    if(strcasecmp(s, "DOWN") == 0) {
         *str =  &(s[4]);
        return 578;
    }
    if(strcasecmp(s, "RIGHT") == 0) {
         *str =  &(s[5]);
        return 579;
    }
    if(strcasecmp(s, "LEFT") == 0) {
         *str =  &(s[4]);
        return 580;
    }
    if(strncasecmp(s, "ESC-", 4) == 0 || strncasecmp(s, "ESC ", 4) == 0) {
        s =  &(s[4]);
        esc = 256;
    } else {
        if(strncasecmp(s, "M-", 2) == 0 || strncasecmp(s, "\E", 2) == 0) {
            s =  &(s[2]);
            esc = 256;
        } else {
            if(( *s & 0xff) == 27) {
                s =  &(s[1]);
                esc = 256;
            }
        }
    }
    if(strncasecmp(s, "C-", 2) != 0) {
        if(( *s & 0xff) == 94 && (s[1] & 0xff) != 0) {
            s =  &(s[1]);
            ctrl = 1;
        }
    } else {
        s =  &(s[2]);
        ctrl = 1;
    }
    if(esc == 0 && ctrl != 0 && ( *s & 0xff) == 91) {
        s =  &(s[1]);
        ctrl = 0;
        esc = 256;
    }
    if(esc != 0 && ctrl == 0) {
        if(( *s & 0xff) == 91 || ( *s & 0xff) == 79) {
            s =  &(s[1]);
            esc = 512;
        }
        if(strncasecmp(s, "C-", 2) != 0) {
            if(( *s & 0xff) == 94 && (s[1] & 0xff) != 0) {
                s =  &(s[1]);
                ctrl = 1;
            }
        } else {
            s =  &(s[2]);
            ctrl = 1;
        }
    }
    if(ctrl == 0) {
        if(esc != 512 || ( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
L55:
            if(strncasecmp(s, "SPC", 3) != 0) {
                if(strncasecmp(s, "TAB", 3) != 0) {
                    if(strncasecmp(s, "DEL", 3) != 0) {
                        if(( *s & 0xff) != 92 || (s[1] & 0xff) == 0) {
L66:
                             *str =  &(s[1]);
                            if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 0x11) == 0) {
                                return -1;
                            }
                        } else {
                            s =  &(s[1]);
                             *str =  &(s[1]);
                            if(( *s & 0xff) - 92 > 24) {
                                return -1;
                            }
                            goto __eax;
                            goto L66;
                        }
                        return  *s & 0xff | esc;
                    }
                    goto L60;
                }
                goto L58;
L60:
                 *str =  &(s[3]);
                return esc | 127;
            }
            goto L56;
L58:
             *str =  &(s[3]);
            return esc | 9;
        } else {
            c = ( *s & 0xff) - 48;
            s =  &(s[1]);
            if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) != 0) {
                c = (c << 2) + c + (c << 2) + c + ( *s & 0xff) - 48;
                s =  &(s[1]);
            }
             *str =  &(s[1]);
            if(( *s & 0xff) != 126) {
                return -1;
            } else {
                return c;
            }
            goto L55;
        }
L56:
         *str =  &(s[3]);
        return esc | 32;
    } else {
         *str =  &(s[1]);
        if(( *s & 0xff) <= 63 || ( *s & 0xff) > 95) {
            if(( *s & 0xff) <= 96 || ( *s & 0xff) > 122) {
                if(( *s & 0xff) != 63) {
                    return -1;
                }
            } else {
                return ( *s & 0xff) - 96 | esc;
            }
            return esc | 127;
        }
        return ( *s & 0xff) - 64 | esc;
    }
}

int getKey(char* s)
{// addr = 0x080A90C7  --  defined in 'func.c' at line 348
    int c;                                 // _cfa_fffffff0
    int c2;                                // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37
    _unknown_ _t40;                        // _t40

    c = getKey2( &s);
    if(c >= 0) {
        if(( *s & 0xff) == 32 || ( *s & 0xff) == 45) {
            s =  &(s[1]);
        }
        if(( *s & 0xff) == 0) {
L9:
            return c;
        } else {
            c2 = getKey2( &s);
            if(c2 >= 0) {
                c = c << 16 | 268435456 | c2;
                goto L9;
            }
            return -1;
            goto L9;
        }
        return __eax;
    }
    return -1;
}

char* getWord(char** str)
{// addr = 0x080A9140  --  defined in 'func.c' at line 367
    char* p;                               // _cfa_fffffff0
    char* s;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    p =  *str;
    while(( *p & 0xff) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p =  &(p[1]);
            continue;
        }
        break;
    }
    s = p;
    while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0 && ( *p & 0xff) != 59) {
        p =  &(p[1]);
    }
     *str = p;
    return  *(Strnew_charp_n(s, p - s));
}

char* getQWord(char** str)
{// addr = 0x080A91D9  --  defined in 'func.c' at line 379
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    int in_q;                              // _cfa_ffffffe8
    int in_dq;                             // _cfa_ffffffe4
    int esc;                               // _cfa_ffffffe0
    _unknown_ __ebp;                       // r6
    _unknown_ _t215;                       // _t215
    int _t252;                             // _t252
    int _t267;                             // _t267
    int _t282;                             // _t282
    int _t297;                             // _t297
    int _t320;                             // _t320
    int _t337;                             // _t337
    int _t354;                             // _t354

    tmp = Strnew();
    in_q = 0;
    in_dq = 0;
    esc = 0;
    p =  *str;
    while(( *p & 0xff) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
            p =  &(p[1]);
            continue;
        } else {
        }
L53:
        while(( *p & 0xff) != 0) {
            if(esc == 0) {
                if(( *p & 0xff) != 92) {
                    if(in_q == 0) {
                        if(in_dq == 0) {
                            if(( *p & 0xff) != 39) {
                                if(( *p & 0xff) != 34) {
                                    if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0 || ( *p & 0xff) == 59) {
                                        break;
                                    } else {
                                        if(tmp->length + 1 >= tmp->area_size) {
                                            Strgrow(tmp);
                                        }
                                        _t252 = tmp->length;
                                         *(tmp->ptr + _t252) =  *p & 0xff;
                                        tmp->length = _t252 + 1;
                                         *(tmp->ptr + tmp->length) = 0;
                                        goto L51;
                                    }
                                }
                                goto L45;
                            }
                            goto L43;
L45:
                            in_dq = 1;
                            goto L51;
                        }
                        goto L37;
L43:
                        in_q = 1;
                        goto L51;
                    }
                    goto L31;
L37:
                    if(( *p & 0xff) != 34) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t267 = tmp->length;
                         *(tmp->ptr + _t267) =  *p & 0xff;
                        tmp->length = _t267 + 1;
                         *(tmp->ptr + tmp->length) = 0;
                    } else {
                        in_dq = 0;
                    }
                    goto L51;
                }
                goto L29;
L31:
                if(( *p & 0xff) != 39) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t282 = tmp->length;
                     *(tmp->ptr + _t282) =  *p & 0xff;
                    tmp->length = _t282 + 1;
                     *(tmp->ptr + tmp->length) = 0;
                } else {
                    in_q = 0;
                }
                goto L51;
            }
            if(in_q == 0) {
                if(in_dq == 0) {
                    if(( *p & 0xff) != 92 && ( *p & 0xff) != 39 && ( *p & 0xff) != 34 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) == 0) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t320 = tmp->length;
                         *((char*)(tmp->ptr + _t320)) = 92;
                        tmp->length = _t320 + 1;
                         *(tmp->ptr + tmp->length) = 0;
                    }
                } else {
                    if(( *p & 0xff) != 92 && ( *p & 0xff) != 34) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t337 = tmp->length;
                         *((char*)(tmp->ptr + _t337)) = 92;
                        tmp->length = _t337 + 1;
                         *(tmp->ptr + tmp->length) = 0;
                    }
                }
            } else {
                if(( *p & 0xff) != 92) {
                    if(( *p & 0xff) != 39) {
                        if(tmp->length + 1 >= tmp->area_size) {
                            Strgrow(tmp);
                        }
                        _t354 = tmp->length;
                         *((char*)(tmp->ptr + _t354)) = 92;
                        tmp->length = _t354 + 1;
                         *(tmp->ptr + tmp->length) = 0;
                    }
                }
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t297 = tmp->length;
             *(tmp->ptr + _t297) =  *p & 0xff;
            tmp->length = _t297 + 1;
             *(tmp->ptr + tmp->length) = 0;
            esc = 0;
L51:
            p =  &(p[1]);
            continue;
L29:
            esc = 1;
            goto L51;
        }
         *str = p;
        return tmp->ptr;
    }
    goto L53;
}

setMouseAction0(char** str, int* width, MouseActionMap** map, char* p)
{// addr = 0x080A95B9  --  defined in 'func.c' at line 459
    char* s;                               // _cfa_fffffff0
    int b;                                 // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    MouseActionMap* _t75;   // _t75

    s = getQWord( &p);
    if(( *s & 0xff) == 0) {
         *str = 0;
        width = 0;
        b = 0;
        while(b <= 2) {
            map[b] = 0;
            b = b + 1;
        }
        return;
    }
    w =  *width;
     *str = s;
     *width = wtf_strwidth(s);
    if( *width > 99) {
         *width = 100;
    }
    if( *width <= w) {
    } else {
        b = 0;
        while(b <= 2) {
            if(map[b] == 0) {
                goto L15;
            }
            _t75 = map[b];
            _v40 = 0 +  *width * 8;
             *__esp = _t75;
            GC_realloc();
            map[b] = _t75;
            x = w + 1;
            while( *width > x) {
                 *(map[b] + (x << 3)) = 0;
                 *(map[b] + (x << 3) + 4) = 0;
                x = x + 1;
            }
L15:
            b = b + 1;
        }
        return;
    }
    goto L18;
L19:
    return;
L18:
    goto L19;
}

setMouseAction1(MouseActionMap** map, int width, char* p)
{// addr = 0x080A9701  --  defined in 'func.c' at line 491
    char* s;                               // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    int x2;                                // _cfa_ffffffe8
    int f;                                 // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    char* _t101;                           // _t101
    MouseActionMap* _t107;   // _t107
    char** _t118;                          // _t118

    if( *map == 0) {
        _t107 = width << 3;
         *__esp = _t107;
        GC_malloc();
         *map = _t107;
        x = 0;
        while(x < width) {
             *( *map + (x << 3)) = 0;
            ( *map + (x << 3))[1] = 0;
            x = x + 1;
        }
    }
    s = getWord( &p);
    x = atoi(s);
    if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
        return;
    }
    goto L5;
L19:
    return;
L5:
    if(x >= 0) {
        goto L19;
    }
    if(x >= width) {
        goto L20;
    }
    s = getWord( &p);
    x2 = atoi(s);
    if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 8) == 0) {
        goto L21;
    }
    if(x2 >= 0) {
        goto L22;
    }
    if(x2 < width) {
        s = getWord( &p);
        f = getFuncList(s);
        s = getQWord( &p);
        if(( *s & 0xff) == 0) {
            s = 0;
        }
        while(x <= x2) {
            _t118 =  *map + (x << 3);
            if(f >= 0) {
                _t101 = 0;
            } else {
                _t101 =  *(135103140 + f * 8);
            }
             *_t118 = _t101;
            ( *map + (x << 3))[1] = s;
            x = x + 1;
        }
        return;
    }
    return;
L22:
    return;
L21:
    return;
L20:
    return;
}

setMouseAction2(MouseActionMap* map, char* p)
{// addr = 0x080A9899  --  defined in 'func.c' at line 523
    char* s;                               // _cfa_fffffff0
    int f;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _None* _t27;                           // _t27

    s = getWord( &p);
    f = getFuncList(s);
    s = getQWord( &p);
    if(( *s & 0xff) == 0) {
        s = 0;
    }
    if(f >= 0) {
        _t27 = 0;
    } else {
        _t27 =  *(135103140 + f * 8);
    }
    map->func = _t27;
    map->data = s;
    return;
}

interpret_mouse_action(FILE* mf)
{// addr = 0x080A9901  --  defined in 'func.c' at line 538
    Str line;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* s;                               // _cfa_ffffffe8
    int b;                                 // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    while(feof(mf) == 0) {
        line = Strfgets(mf);
        Strchop(line);
        Strremovefirstspaces(line);
        if(line->length == 0) {
            continue;
        }
        p =  *(wc_Str_conv(Strnew_charp(line->ptr), SystemCharset, InnerCharset));
        s = getWord( &p);
        if(( *s & 0xff) == 35) {
            goto L32;
        }
        if(strcmp(s, 135069899) != 0) {
            if(strcmp(s, "lastline") != 0) {
                if(strcmp(s, "button") != 0) {
                    goto L33;
                }
                goto L8;
L34:
            } else {
                setMouseAction0(135792260, 135792268, 135792392, p);
            }
            continue;
L8:
            s = getWord( &p);
            b = atoi(s) - 1;
            if(b >= 0) {
                goto L34;
            }
            if(b <= 2) {
                while() {
                }
            } else {
            }
        } else {
            setMouseAction0( &mouse_action, 135792264, 135792380, p);
        }
        continue;
L33:
        continue;
L32:
    }
    return;
}

initMouseAction()
{// addr = 0x080A9C4C  --  defined in 'func.c' at line 600
    FILE* mf;             // _cfa_fffffff0
    int w;                                 // _cfa_ffffffec
    char** symbol;                         // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    void _t21;                             // _t21
    _unknown_ _t23;                        // _t23
    _unknown_ _t37;                        // _t37
    _unknown_ _t40;                        // _t40

    _t21 = bcopy( &default_mouse_action,  &mouse_action, 148);
     *__esp = 48;
    GC_malloc();
     *135792392 = _t21;
    bcopy( &default_lastline_action,  *135792392, 48);
    w = 0;
    symbol = get_symbol(DisplayCharset,  &w);
     *135792260 =  *(Strnew_charp(symbol[0x2d]));
    mf = fopen(confFile("mouse"), "rt");
    if(mf != 0) {
        interpret_mouse_action(mf);
        fclose(mf);
    }
    mf = fopen(rcFile("mouse"), "rt");
    if(mf != 0) {
        interpret_mouse_action(mf);
        fclose(mf);
        return;
    }
    return;
}

int total_dot_number(char* p, char* ep, int max_count)
{// addr = 0x080A9D54  --  defined in 'cookie.c' at line 26
    int count;                             // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    count = 0;
    if(ep == 0) {
        ep =  &(p[strlen(p)]);
    }
    while(p < ep && count < max_count) {
    }
    return count;
}

char* domain_match(char* host, char* domain)
{// addr = 0x080A9DA1  --  defined in 'cookie.c' at line 41
    int m0;                                // _cfa_fffffff0
    int m1;                                // _cfa_ffffffec
    int offset;                            // _cfa_ffffffe8
    char* domain_p;                        // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t56;                        // _t56
    _unknown_ _t61;                        // _t61
    int _t89;                              // _t89

    regexCompile("[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+", 0);
    m0 = regexMatch(host, -1, 1);
    m1 = regexMatch(domain, -1, 1);
    if(m0 == 0) {
L4:
        if(m0 != 0 || m1 != 0) {
            goto L22;
        } else {
            if(strcasecmp(domain, ".") == 0 || strcasecmp(domain, ".local") == 0) {
                offset = strlen(host);
                domain_p =  &(host[offset]);
                if((domain[1] & 0xff) == 0 || total_dot_number(host, domain_p, 1) == 0) {
                    return domain_p;
                }
                goto L22;
            } else {
                if(( *domain & 0xff) != 46 || strcasecmp(host,  &(domain[1])) != 0) {
                    if(( *domain & 0xff) != 46) {
                        _t81 = 0;
                    } else {
                        _t89 = strlen(host);
                        0 = _t89 - strlen(domain);
                    }
                    offset = 0;
                    domain_p =  &(host[offset]);
                    if(offset >= 0 || strcasecmp(domain_p, domain) != 0) {
                        goto L22;
                    } else {
                        return domain_p;
                    }
                    goto L23;
                }
                return host;
            }
        }
L23:
        return __eax;
    }
    if(m1 == 0) {
        goto L4;
    } else {
        if(strcasecmp(host, domain) == 0) {
            return host;
        }
    }
L22:
    return 0;
}

struct portlist* make_portlist(Str port)
{// addr = 0x080A9F49  --  defined in 'cookie.c' at line 88
    struct portlist* first;   // _cfa_fffffff0
    struct portlist* pl;   // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    Str tmp;               // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    _unknown_ _t63;                        // _t63

    first = 0;
    tmp = Strnew();
    p = port->ptr;
    while(( *p & 0xff) != 0) {
        while(1) {
            p =  *p & 255;
            if(( *p & 0xff) == 0) {
                break;
            }
            p =  *p & 255;
             *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
             *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 8;
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) == 0) {
                p =  &(p[1]);
                continue;
            }
            break;
        }
        __eax = tmp;
        Strclear(tmp);
        while(1) {
            p =  *p & 255;
            if(( *p & 0xff) == 0) {
                break;
            }
            p =  *p & 255;
             *p & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 255;
             *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xff =  *( &MYCTYPE_MAP + ( *p & 0xff)) & 8;
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) != 0) {
                tmp = tmp->length;
                __edx = tmp->length + 1;
                tmp = tmp->area_size;
                if(tmp->length + 1 >= tmp->area_size) {
                    __eax = tmp;
                    Strgrow(tmp);
                }
                tmp = tmp;
                __eax = tmp->length;
                __eax = p;
                __edx =  *p & 255;
                 *(__eax + tmp->ptr) =  *p & 0xff;
                __edx =  &(__eax->port);
                __eax = tmp;
                tmp->length = __edx;
                p =  &(p[1]);
                __eax = tmp;
                __edx = tmp->ptr;
                tmp = tmp->length;
                __eax = tmp->ptr + tmp->length;
                 *(tmp->ptr + tmp->length) = 0;
                continue;
            }
            break;
        }
        __eax = tmp;
        __eax = tmp->length;
        if(__eax != 0) {
             *__esp = 8;
            GC_malloc();
            pl = __eax;
            tmp = tmp->ptr;
            __eax = atoi(tmp->ptr);
            __edx = tmp->ptr;
            __eax = pl;
            pl->port = tmp->ptr & 65535;
            __eax = pl;
            __edx = first;
            pl->next = first;
            __eax = pl;
            first = pl;
            continue;
        }
L16:
        return first;
    }
    goto L16;
}

Str portlist2str(struct portlist* first)
{// addr = 0x080AA06D  --  defined in 'cookie.c' at line 112
    struct portlist* pl;   // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v40 = first->port & 0xffff;
    tmp = Sprintf("%d");
    pl = first->next;
    while(pl != 0) {
        _v40 = pl->port & 0xffff;
        Strcat(tmp, Sprintf(", %d"));
        pl = pl->next;
    }
    return tmp;
}

int port_match(struct portlist* first, int port)
{// addr = 0x080AA0D6  --  defined in 'cookie.c' at line 124
    struct portlist* pl;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18

    pl = first;
    while(pl != 0) {
        if((pl->port & 0xffff) != port) {
            pl = pl->next;
            continue;
        }
        return 1;
    }
    return 0;
}

check_expired_cookies()
{// addr = 0x080AA10F  --  defined in 'cookie.c' at line 136
    struct cookie* p;   // _cfa_fffffff0
    struct cookie* p1;   // _cfa_ffffffec
    time_t now;         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

     *__esp = 0;
    time();
    now = __eax;
    if(First_cookie == 0) {
        goto L17;
    }
    if( *((intOrPtr*)(First_cookie + 48)) == 255 ||  *((intOrPtr*)(First_cookie + 48)) >= now) {
L6:
        p = First_cookie;
L13:
        while(p != 0) {
            if(p->next != 0) {
                goto L7;
            }
            return;
        }
        goto L17;
    } else {
        if((First_cookie->flag & 0x10) == 0) {
            is_saved = 0;
        }
        First_cookie = First_cookie->next;
        goto L6;
    }
L7:
    p1 = p->next;
    if( *((intOrPtr*)(p1 + 48)) != 255 &&  *((intOrPtr*)(p1 + 48)) < now) {
        if((p1->flag & 0x10) == 0) {
            is_saved = 0;
        }
        p->next = p1->next;
        p1 = p;
    }
    p = p1;
    goto L13;
L17:
    return;
}

Str make_cookie(struct cookie* cookie)
{// addr = 0x080AA1E6  --  defined in 'cookie.c' at line 162
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t35;                              // _t35

    tmp = Strdup( *(cookie + 40));
    if(tmp->length + 1 >= tmp->area_size) {
        Strgrow(tmp);
    }
    _t35 = tmp->length;
     *((char*)(tmp->ptr + _t35)) = 61;
    tmp->length = _t35 + 1;
     *((char*)(tmp->ptr + tmp->length)) = 0;
    Strcat(tmp,  *(cookie + 44));
    return tmp;
}

int match_cookie(ParsedURL* pu, struct cookie* cookie, char* domainname)
{// addr = 0x080AA262  --  defined in 'cookie.c' at line 171
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    _unknown_ _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54

    if(domainname != 0) {
        if(domain_match(domainname,  *( *(cookie + 56))) != 0) {
            if(strncmp( *((char**)( *(cookie + 52))), pu->file, ( *(cookie + 52))[1]) == 0) {
                if((cookie->flag & 2) == 0) {
                    if(cookie->portl == 0 || port_match(cookie->portl, pu->port) != 0) {
                        return 1;
                    }
                    return 0;
                }
                goto L7;
            }
            goto L5;
L7:
            return 0;
        }
        goto L3;
L5:
        return 0;
    }
    return 0;
L3:
    return 0;
}

struct cookie* get_cookie_info(Str domain, Str path, Str name)
{// addr = 0x080AA31A  --  defined in 'cookie.c' at line 194
    struct cookie* p;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27

    p = First_cookie;
    while(p != 0) {
        if(strcasecmp( *( *(p + 56)), domain->ptr) == 0 && strcmp( *( *(p + 52)), path->ptr) == 0 && strcasecmp( *( *(p + 40)), name->ptr) == 0) {
            return p;
        }
        p = p->next;
    }
    return 0;
}

Str find_cookie(ParsedURL* pu)
{// addr = 0x080AA39C  --  defined in 'cookie.c' at line 207
    Str tmp;               // _cfa_fffffff0
    struct cookie* p;   // _cfa_ffffffec
    struct cookie* p1;   // _cfa_ffffffe8
    struct cookie* fco;   // _cfa_ffffffe4
    int version;                           // _cfa_ffffffe0
    char* fq_domainname;                   // _cfa_ffffffdc
    char* domainname;                      // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc
    struct _Str* _v56;    // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    char* _t117;                           // _t117
    _unknown_ _t165;                       // _t165
    struct cookie* _t170;   // _t170
    _unknown_ _t173;                       // _t173

    fco = 0;
    version = 0;
    fq_domainname = FQDN(pu->host);
    check_expired_cookies();
    p = First_cookie;
    while(p != 0) {
        if((p->version & 0xff) == 0) {
            _t117 = fq_domainname;
        } else {
            _t117 = pu->host;
        }
        domainname = _t117;
        if((p->flag & 1) == 0 || match_cookie(pu, p, domainname) == 0) {
L14:
            p = p->next;
            continue;
        } else {
            _t170 = fco;
            p1 = _t170;
        }
L8:
        while(p1 != 0) {
L9:
            _t170 = strcasecmp( *( *(p1 + 40)),  *( *(p + 40)));
            if(_t170 != 0) {
                _t170 = p1->next;
                p1 = _t170;
                goto L8;
            }
            break;
        }
        if(p1 == 0) {
             *__esp = 80;
            GC_malloc();
            p1 = _t170;
            bcopy(p, p1, 80);
            p1->next = fco;
            fco = p1;
            if((p1->version & 0xff) > version) {
                version = p1->version & 0xff;
            }
        }
        goto L14;
    }
    if(fco == 0) {
        return 0;
    }
    tmp = Strnew();
    if(version > 0) {
        _v56 = version;
        Strcat(tmp, Sprintf("$Version="%d"; "));
    }
    Strcat(tmp, make_cookie(fco));
    p1 = fco->next;
    while(p1 != 0) {
        Strcat_charp(tmp, "; ");
        Strcat(tmp, make_cookie(p1));
        if(version > 0) {
            if((p1->flag & 8) != 0) {
                _v56 =  *( *(p1 + 52));
                Strcat(tmp, Sprintf("; $Path="%s""));
            }
            if((p1->flag & 4) != 0) {
                _v56 =  *( *(p1 + 56));
                Strcat(tmp, Sprintf("; $Domain="%s""));
            }
            if(p1->portl != 0) {
                _v56 = portlist2str(p1->portl);
                Strcat(tmp, Sprintf("; $Port="%s""));
            }
        }
        p1 = p1->next;
    }
    return tmp;
}

int add_cookie(ParsedURL* pu, Str name, Str value, time_t expires, Str domain, Str path, int flag, Str comment, int version, Str port, Str commentURL)
{// addr = 0x080AA627  --  defined in 'cookie.c' at line 261
    struct cookie* p;   // _cfa_fffffff0
    char* domainname;                      // _cfa_ffffffec
    Str odomain;           // _cfa_ffffffe8
    Str opath;             // _cfa_ffffffe4
    struct portlist* portlist;   // _cfa_ffffffe0
    int use_security;                      // _cfa_ffffffdc
    char* dp;                              // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    char** sdomain;                        // _cfa_ffffffd0
    int ok;                                // _cfa_ffffffcc
    int offset;                            // _cfa_ffffffc8
    _unknown_ _v68;                        // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    char* _t229;                           // _t229
    struct cookie* _t238;   // _t238
    _unknown_ _t266;                       // _t266
    _unknown_ _t319;                       // _t319
    _unknown_ _t326;                       // _t326
    _unknown_ _t340;                       // _t340
    _unknown_ _t341;                       // _t341
    _unknown_ _t349;                       // _t349
    _unknown_ _t356;                       // _t356
    _unknown_ _t370;                       // _t370
    _unknown_ _t378;                       // _t378

    if(version != 0) {
        _t229 = pu->host;
    } else {
        _t229 = FQDN(pu->host);
    }
    domainname = _t229;
    odomain = domain;
    opath = path;
    portlist = 0;
    use_security = flag & 0x20;
    if(domainname == 0) {
        return 37;
    }
    if(domain == 0) {
L34:
        if(path == 0 || version <= 0 || strncmp(path->ptr, pu->file, path->length) == 0) {
            if(port == 0) {
L42:
                if(domain == 0) {
                    domain = Strnew_charp(domainname);
                }
                if(path != 0) {
L53:
                    _t238 = get_cookie_info(domain, path, name);
                    p = _t238;
                    if(p == 0) {
                         *__esp = 80;
                        GC_malloc();
                        p = _t238;
                        p->flag = 0;
                        if(default_use_cookie != 0) {
                            p->flag = (p->flag & 255 | 1) & 255;
                        }
                        p->next = First_cookie;
                        First_cookie = p;
                    }
                    copyParsedURL(p, pu);
                     *(p + 40) = name;
                     *(p + 44) = value;
                     *(p + 48) = expires;
                     *(p + 56) = domain;
                     *(p + 52) = path;
                     *(p + 60) = comment;
                    p->version = version & 255;
                    p->portl = portlist;
                     *(p + 64) = commentURL;
                    if((flag & 2) == 0) {
                        p->flag = p->flag & 0xfd;
                    } else {
                        p->flag = (p->flag & 255 | 2) & 255;
                    }
                    if(odomain == 0) {
                        p->flag = p->flag & 0xfb;
                    } else {
                        p->flag = (p->flag & 255 | 4) & 255;
                    }
                    if(opath == 0) {
                        p->flag = p->flag & 0xf7;
                    } else {
                        p->flag = (p->flag & 255 | 8) & 255;
                    }
                    if((flag & 16) != 0 ||  *(p + 48) == 255) {
                        p->flag = (p->flag & 255 | 16) & 255;
                    } else {
                        p->flag = p->flag & 0xef;
                        is_saved = 0;
                    }
                    check_expired_cookies();
                    return 0;
                }
                path = Strnew_charp(pu->file);
                while(path->length > 0 && (path->length <= 0 || ( *(path->ptr + path->length - 1) & 0xff) != 47)) {
                    Strshrink(path, 1);
                }
                if(path->length > 0 && ( *(path->ptr + path->length - 1) & 0xff) == 47) {
                    Strshrink(path, 1);
                }
                goto L53;
            }
        } else {
            return 4;
        }
        portlist = make_portlist(port);
        if(portlist == 0 || port_match(portlist, pu->port) != 0) {
            goto L42;
        }
        return 9;
    } else {
        if(( *(domain->ptr) & 0xff) != 46) {
            if(version > 0 || strcasecmp(domainname, domain->ptr) != 0) {
                _v72 = domain->ptr;
                domain = Sprintf(".%s");
            }
        }
        if(version != 0) {
            if(strcasecmp(domain->ptr, ".local") == 0 || total_dot_number(domain->ptr + 1, domain->ptr + domain->length, 1) != 0 || use_security == 0) {
                goto L27;
            }
            return 37;
        }
        n = total_dot_number(domain->ptr, domain->ptr + domain->length, 3);
        if(n <= 1) {
            return 3;
        }
        if(n != 2) {
L27:
            dp = domain_match(domainname, domain->ptr);
            if(dp != 0 || use_security == 0) {
                if(version <= 0 || total_dot_number(domainname, dp, 1) == 0 || use_security == 0) {
                    goto L34;
                }
                return 40;
            }
            return 39;
        } else {
            ok = 0;
            sdomain =  &special_domain;
        }
        while(ok == 0) {
            if( *sdomain != 0) {
                offset = domain->length - strlen( *sdomain);
                if(offset < 0) {
                    if(strcasecmp( *sdomain,  &(domain->ptr[offset])) == 0) {
                        ok = 1;
                    }
                }
                sdomain =  &(sdomain[1]);
                continue;
            }
            break;
        }
        if(ok != 0) {
            goto L27;
        }
        return 3;
    }
}

struct cookie* nth_cookie(int n)
{// addr = 0x080AAB16  --  defined in 'cookie.c' at line 405
    struct cookie* p;   // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16

    p = First_cookie;
    i = 0;
    while(p != 0) {
        if(i != n) {
            p = p->next;
            i = i + 1;
            continue;
        }
        return p;
    }
    return 0;
}

save_cookies()
{// addr = 0x080AAB54  --  defined in 'cookie.c' at line 419
    struct cookie* p;   // _cfa_ffffffe0
    char* cookie_file;                     // _cfa_ffffffdc
    FILE* fp;             // _cfa_ffffffd8
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    struct _Str _v72;     // _cfa_ffffffb8
    struct _Str _v100;    // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    signed int _v108;                      // _cfa_ffffff94
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    intOrPtr _v128;                        // _cfa_ffffff80
    char* _v132;                           // _cfa_ffffff7c
    intOrPtr _v136;                        // _cfa_ffffff78
    struct _Str __ebx;    // r1
    struct _Str __edi;    // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t95;                        // _t95
    struct _Str* _t127;   // _t127
    _unknown_ _t130;                       // _t130

    check_expired_cookies();
    if(First_cookie == 0) {
        return;
    }
    if(is_saved != 0) {
        goto L23;
    }
    if(no_rc_dir != 0) {
        goto L24;
    }
    cookie_file = rcFile("cookie");
    fp = fopen(cookie_file, "w");
    if(fp != 0) {
        p = First_cookie;
        while(p != 0) {
            if((p->flag & 1) != 0) {
                if((p->flag & 0x10) == 0) {
                    if( *(p + 64) == 0) {
                        __ebx = 135070108;
                    } else {
                        __ebx =  *( *(p + 64));
                    }
                    if(p->portl == 0) {
                        __edi = 135070108;
                    } else {
                        __edi =  *(portlist2str(p->portl));
                    }
                    if( *(p + 60) == 0) {
                        _v72.ptr = 135070108;
                    } else {
                        _v72.ptr =  *( *(p + 60));
                    }
                    _v72.length = p->version & 0xff;
                    _v72.area_size = p->flag & 0xff;
                    _v60 =  *((intOrPtr*)( *((intOrPtr*)(p + 52))));
                    _v56 =  *((intOrPtr*)( *((intOrPtr*)(p + 56))));
                    _v52 =  *((intOrPtr*)(p + 48));
                    _v48 =  *((intOrPtr*)( *((intOrPtr*)(p + 44))));
                    _t127 = parsedURL2Str(p);
                    _v100.area_size = __ebx;
                    _v100.length = __edi;
                    _v100 = _v72;
                    _v104 = _v72.length;
                    _v108 = _v72.area_size;
                    _v112 = _v60;
                    _v116 = _v56;
                    _v120 = _v52;
                    _v124 = _v48;
                    _v128 =  *((intOrPtr*)( *((intOrPtr*)(p + 40))));
                    _v132 = _t127->ptr;
                    fprintf(fp, "%s\t%s\t%s\t%ld\t%s\t%s\t%d\t%d\t%s\t%s\t%s\n");
                }
            }
            p = p->next;
        }
        fclose(fp);
        _v136 = 384;
         *__esp = cookie_file;
        chmod();
        return;
    }
    return;
L24:
    return;
L23:
    return;
}

Str readcol(char** p)
{// addr = 0x080AAD41  --  defined in 'cookie.c' at line 450
    Str tmp;               // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43
    char* _t72;                            // _t72
    int _t84;                              // _t84

    tmp = Strnew();
    while(( *( *p) & 0xff) != 0 && ( *( *p) & 0xff) != 10 && ( *( *p) & 0xff) != 13 && ( *( *p) & 0xff) != 9) {
        _t84 = tmp->length;
        _t72 =  *p;
         *(tmp->ptr + _t84) =  *_t72 & 0xff;
        tmp->length = _t84 + 1;
         *p =  &(_t72[1]);
         *((char*)(tmp->ptr + tmp->length)) = 0;
    }
    if(( *( *p) & 0xff) == 9) {
         *p =  &(( *p)[1]);
    }
    return tmp;
}

load_cookies()
{// addr = 0x080AAE02  --  defined in 'cookie.c' at line 461
    struct cookie* cookie;   // _cfa_fffffff0
    struct cookie* p;   // _cfa_ffffffec
    FILE* fp;             // _cfa_ffffffe8
    Str line;              // _cfa_ffffffe4
    char* str;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t118;                       // _t118
    struct cookie* _t127;   // _t127
    _unknown_ _t199;                       // _t199

    fp = fopen(rcFile("cookie"), "r");
    if(fp == 0) {
        return;
    }
    if(First_cookie == 0) {
        p = 0;
    } else {
        p = First_cookie;
        while(p->next != 0) {
            p = p->next;
        }
        while(1) {
L7:
            line = Strfgets(fp);
            if(line->length == 0) {
                break;
            }
            _t127 = line->ptr;
            str = _t127;
             *__esp = 80;
            GC_malloc();
            cookie = _t127;
            cookie->next = 0;
            cookie->flag = 0;
            cookie->version = 0;
             *(cookie + 48) = -1;
             *(cookie + 60) = 0;
            cookie->portl = 0;
             *(cookie + 64) = 0;
            parseURL( *(readcol( &str)), cookie, 0);
            if(( *str & 0xff) == 0) {
                goto L28;
            }
             *(cookie + 40) = readcol( &str);
            if(( *str & 0xff) == 0) {
                goto L29;
            }
             *(cookie + 44) = readcol( &str);
            if(( *str & 0xff) == 0) {
                goto L30;
            }
             *(cookie + 48) = atol( *(readcol( &str)));
            if(( *str & 0xff) == 0) {
                goto L31;
            }
             *(cookie + 56) = readcol( &str);
            if(( *str & 0xff) == 0) {
                goto L32;
            }
             *(cookie + 52) = readcol( &str);
            if(( *str & 0xff) == 0) {
                goto L33;
            }
            cookie->flag = atoi( *(readcol( &str))) & 255;
            if(( *str & 0xff) == 0) {
                goto L34;
            }
            cookie->version = atoi( *(readcol( &str))) & 255;
            if(( *str & 0xff) == 0) {
                goto L35;
            }
             *(cookie + 60) = readcol( &str);
            if( *(cookie + 60)->length == 0) {
                 *(cookie + 60) = 0;
            }
            if(( *str & 0xff) == 0) {
                goto L36;
            }
            cookie->portl = make_portlist(readcol( &str));
            if(( *str & 0xff) == 0) {
            } else {
                 *(cookie + 64) = readcol( &str);
                if( *(cookie + 64)->length == 0) {
                     *(cookie + 64) = 0;
                }
                if(p == 0) {
                    First_cookie = cookie;
                } else {
                    p->next = cookie;
                }
                p = cookie;
                continue;
            }
            goto L37;
L38:
            return;
L37:
            goto L38;
L36:
            return;
L35:
            return;
L34:
            return;
L33:
            return;
L32:
            return;
L31:
            return;
L30:
            return;
L29:
            return;
        }
        fclose(fp);
        return;
    }
    goto L7;
L28:
    return;
}

initCookie()
{// addr = 0x080AB0D8  --  defined in 'cookie.c' at line 538
    _unknown_ __ebp;                       // r6

    load_cookies();
    check_expired_cookies();
    return;
}

Buffer* cookie_list_panel()
{// addr = 0x080AB0EA  --  defined in 'cookie.c' at line 545
    intOrPtr _v16;                         // _cfa_fffffff0
    char[79] tmp2;                         // _cfa_ffffffa0
    Str src;               // _cfa_ffffff9c
    struct cookie* p;   // _cfa_ffffff98
    int i;                                 // _cfa_ffffff94
    char* tmp;                             // _cfa_ffffff90
    char* _v140;                           // _cfa_ffffff74
    int _v144;                             // _cfa_ffffff70
    char* _v148;                           // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    _unknown_ __ebp;                       // r6
    _unknown_ _t172;                       // _t172
    _unknown_ _t173;                       // _t173
    Buffer* _t175;      // _t175
    char* _t222;                           // _t222
    char* _t233;                           // _t233
    int _t303;                             // _t303
    _unknown_ _t307;                       // _t307
    char* _t308;                           // _t308
    struct cookie* _t312;   // _t312

    _v16 =  *gs:0x14];
    Strnew_charp("<html><head><title>Cookies</title></head><body><center><b>Cookies</b></center><p><form method=internal action=cookie>");
    src = 0;
    if(use_cookie == 0) {
L2:
        _t175 = 0;
    } else {
        _t312 = First_cookie;
        if(_t312 != 0) {
            Strcat_charp(src, "<ol>");
            p = First_cookie;
            i = 0;
            while(p != 0) {
                tmp = html_quote( *(parsedURL2Str(p)));
                if( *(p + 48) == 255) {
                    tmp2 = 0;
                } else {
                    _t303 = p + 48;
                     *__esp = _t303;
                    gmtime();
                    _v144 = _t303;
                    _v148 = "%a, %d %b %Y %H:%M:%S GMT";
                    _v152 = 80;
                     *__esp =  &tmp2;
                    strftime();
                }
                Strcat_charp(src, "<li>");
                Strcat_charp(src, "<h1><a href="");
                Strcat_charp(src, tmp);
                Strcat_charp(src, "">");
                Strcat_charp(src, tmp);
                Strcat_charp(src, "</a></h1>");
                Strcat_charp(src, "<table cellpadding=0>");
                if((p->flag & 2) == 0) {
                    Strcat_charp(src, "<tr><td width="80"><b>Cookie:</b></td><td>");
                    Strcat_charp(src, html_quote( *(make_cookie(p))));
                    Strcat_charp(src, "</td></tr>");
                }
                if( *(p + 60) != 0) {
                    Strcat_charp(src, "<tr><td width="80"><b>Comment:</b></td><td>");
                    Strcat_charp(src, html_quote( *( *(p + 60))));
                    Strcat_charp(src, "</td></tr>");
                }
                if( *(p + 64) != 0) {
                    Strcat_charp(src, "<tr><td width="80"><b>CommentURL:</b></td><td>");
                    Strcat_charp(src, "<a href="");
                    Strcat_charp(src, html_quote( *( *(p + 64))));
                    Strcat_charp(src, "">");
                    Strcat_charp(src, html_quote( *( *(p + 64))));
                    Strcat_charp(src, "</a>");
                    Strcat_charp(src, "</td></tr>");
                }
                if((tmp2 & 0xff) != 0) {
                    Strcat_charp(src, "<tr><td width="80"><b>Expires:</b></td><td>");
                    Strcat_charp(src,  &tmp2);
                    if((p->flag & 0x10) != 0) {
                        Strcat_charp(src, " (Discard)");
                    }
                    Strcat_charp(src, "</td></tr>");
                }
                Strcat_charp(src, "<tr><td width="80"><b>Version:</b></td><td>");
                _v152 = p->version & 0xff;
                Strcat_charp(src,  *(Sprintf("%d")));
                Strcat_charp(src, "</td></tr><tr><td>");
                if( *(p + 56) != 0) {
                    Strcat_charp(src, "<tr><td width="80"><b>Domain:</b></td><td>");
                    Strcat_charp(src, html_quote( *( *(p + 56))));
                    Strcat_charp(src, "</td></tr>");
                }
                if( *(p + 52) != 0) {
                    Strcat_charp(src, "<tr><td width="80"><b>Path:</b></td><td>");
                    Strcat_charp(src, html_quote( *( *(p + 52))));
                    Strcat_charp(src, "</td></tr>");
                }
                if(p->portl != 0) {
                    Strcat_charp(src, "<tr><td width="80"><b>Port:</b></td><td>");
                    Strcat_charp(src, html_quote( *(portlist2str(p->portl))));
                    Strcat_charp(src, "</td></tr>");
                }
                Strcat_charp(src, "<tr><td width="80"><b>Secure:</b></td><td>");
                if((p->flag & 2) == 0) {
                    _t222 = "No";
                } else {
                    _t222 = "Yes";
                }
                Strcat_charp(src, _t222);
                Strcat_charp(src, "</td></tr><tr><td>");
                if((p->flag & 1) != 0) {
                    _t308 = 135070108;
                } else {
                    _t308 = " checked";
                }
                if((p->flag & 1) == 0) {
                    _t233 = 135070108;
                } else {
                    _t233 = " checked";
                }
                _v140 = _t308;
                _v144 = i;
                _v148 = _t233;
                _v152 = i;
                Strcat(src, Sprintf("<tr><td width="80"><b>Use:</b></td><td><input type=radio name="%d" value=1%s>Yes&nbsp;&nbsp;<input type=radio name="%d" value=0%s>No"));
                Strcat_charp(src, "</td></tr><tr><td><input type=submit value="OK"></table><p>");
                p = p->next;
                i = i + 1;
            }
            Strcat_charp(src, "</ol></form></body></html>");
            _t175 = loadHTMLString(src);
            goto L35;
        }
        goto L2;
    }
L35:
    if(_t312 != 0) {
        __stack_chk_fail();
        return _t175;
    }
    return _t175;
}

set_cookie_flag(struct parsed_tagarg* arg)
{// addr = 0x080AB643  --  defined in 'cookie.c' at line 660
    int n;                                 // _cfa_fffffff0
    int v;                                 // _cfa_ffffffec
    struct cookie* p;   // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    while(arg != 0) {
        arg = arg->next;
    }
    backBf();
    return;
}

int check_cookie_accept_domain(char* domain)
{// addr = 0x080AB748  --  defined in 'cookie.c' at line 684
    TextListItem* tl;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    _unknown_ _t37;                        // _t37
    _unknown_ _t48;                        // _t48
    _unknown_ _t49;                        // _t49

    if(domain == 0) {
        return 0;
    }
    if(Cookie_accept_domains == 0 || (Cookie_accept_domains->nitem & 0xffff) <= 0) {
L9:
        if(Cookie_reject_domains == 0 || (Cookie_reject_domains->nitem & 0xffff) <= 0) {
L16:
            return 1;
        } else {
            tl = Cookie_reject_domains->first;
            while(tl != 0) {
                if(domain_match(domain, tl->ptr) == 0) {
                    tl = tl->next;
                    continue;
                }
                return 0;
            }
            goto L16;
        }
        return __eax;
    } else {
        tl = Cookie_accept_domains->first;
        while(tl != 0) {
            if(domain_match(domain, tl->ptr) == 0) {
                tl = tl->next;
                continue;
            }
            return 1;
        }
        goto L9;
    }
}

Buffer* historyBuffer(Hist* hist)
{// addr = 0x080AB808  --  defined in 'history.c' at line 6
    Str src;               // _cfa_fffffff0
    HistItem* item;   // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39

    src = Strnew();
    Strcat_charp(src, "<html>\n<head><title>History Page</title></head>\n");
    Strcat_charp(src, "<body>\n<h1>History Page</h1>\n<hr>\n");
    Strcat_charp(src, "<ol>\n");
    if(hist == 0 || hist->list == 0) {
L8:
        Strcat_charp(src, "</ol>\n</body>\n</html>");
        return loadHTMLString(src);
    } else {
        item = hist->list->last;
        while(item != 0) {
            q = html_quote(item->ptr);
            if(DecodeURL == 0) {
                p = q;
            } else {
                p = html_quote(url_unquote_conv(item->ptr, 0));
            }
            Strcat_charp(src, "<li><a href="");
            Strcat_charp(src, q);
            Strcat_charp(src, "">");
            Strcat_charp(src, p);
            Strcat_charp(src, "</a>\n");
            item = item->prev;
        }
        goto L8;
    }
}

loadHistory(Hist* hist)
{// addr = 0x080AB947  --  defined in 'history.c' at line 35
    FILE* f;              // _cfa_fffffff0
    Str line;              // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t33;                        // _t33
    _unknown_ _t35;                        // _t35

    if(hist != 0) {
        f = fopen(rcFile("history"), "rt");
        if(f != 0) {
            while(feof(f) == 0) {
                line = Strfgets(f);
                Strchop(line);
                Strremovefirstspaces(line);
                Strremovetrailingspaces(line);
                if(line->length != 0) {
                    pushHist(hist, url_quote(line->ptr));
                }
            }
            fclose(f);
            return;
        }
        return;
    }
    return;
}

saveHistory(Hist* hist, size_t size)
{// addr = 0x080AB9FE  --  defined in 'history.c' at line 58
    FILE* f;              // _cfa_fffffff0
    HistItem* item;   // _cfa_ffffffec
    char* tmpf;                            // _cfa_ffffffe8
    _Unknown_base* _v36;                   // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33
    _unknown_ _t47;                        // _t47
    _unknown_ _t54;                        // _t54

    if(hist == 0) {
L14:
        return;
    }
    if(hist->list == 0) {
    } else {
        tmpf =  *(tmpfname(0, 0));
        f = fopen(tmpf, "w");
        if(f != 0) {
            item = hist->list->first;
L6:
            while(item != 0) {
                asm("cwde ");
                if((hist->list->nitem & 65535) > size) {
                    goto L5;
                }
L10:
                while(item != 0) {
                    _v36 = item->ptr;
                    fprintf(f, "%s\n");
                    item = item->next;
                }
                if(fclose(f) != 255) {
                    rename(tmpf, rcFile("history"));
                    return;
                }
                disp_err_message("Can't save history", 0);
                return;
                goto L14;
            }
            goto L10;
        }
        disp_err_message("Can't open history", 0);
        return;
L5:
        size = size + 1;
        item = item->next;
        goto L6;
    }
    goto L15;
L16:
    return;
L15:
    goto L16;
}

Hist* newHist()
{// addr = 0x080ABB11  --  defined in 'history.c' at line 87
    Hist* hist;           // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

     *__esp = 12;
    GC_malloc();
    hist = __eax;
    hist->list = newGeneralList();
    hist->current = 0;
    hist->hash = 0;
    return hist;
}

Hist* copyHist(Hist* hist)
{// addr = 0x080ABB49  --  defined in 'history.c' at line 99
    Hist* new;            // _cfa_fffffff0
    HistItem* item;   // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    _unknown_ _t24;                        // _t24

    if(hist != 0) {
        new = newHist();
        item = hist->list->first;
L4:
        while(item != 0) {
            goto L3;
        }
        return new;
    }
    return 0;
L3:
    pushHist(new, item->ptr);
    item = item->next;
    goto L4;
}

HistItem* unshiftHist(Hist* hist, char* ptr)
{// addr = 0x080ABB98  --  defined in 'history.c' at line 113
    HistItem* item;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24

    if(hist == 0 || hist->list == 0) {
        return 0;
    }
    item = newListItem(allocStr(ptr, -1), hist->list->first, 0);
    if(hist->list->first == 0) {
        hist->list->last = item;
    } else {
        hist->list->first->prev = item;
    }
    hist->list->first = item;
    hist->list->nitem = (hist->list->nitem & 65535) + 1 & 65535;
    return item;
}

HistItem* pushHist(Hist* hist, char* ptr)
{// addr = 0x080ABC2E  --  defined in 'history.c' at line 131
    HistItem* item;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27

    if(hist == 0 || hist->list == 0) {
        return 0;
    }
    item = newListItem(allocStr(ptr, -1), 0, hist->list->last);
    if(hist->list->last == 0) {
        hist->list->first = item;
    } else {
         *(hist->list->last + 4) = item;
    }
    hist->list->last = item;
    hist->list->nitem = (hist->list->nitem & 65535) + 1 & 65535;
    return item;
}

HistItem* pushHashHist(Hist* hist, char* ptr)
{// addr = 0x080ABCC7  --  defined in 'history.c' at line 151
    HistItem* item;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45

    if(hist == 0 || hist->list == 0) {
        return 0;
    }
    item = getHashHist(hist, ptr);
    if(item != 0) {
        if(item->next == 0) {
            hist->list->tab = item->prev;
        } else {
            item->next->prev = item->prev;
        }
        if(item->prev == 0) {
            hist->list->size = item->next;
        } else {
            item->prev->next = item->next;
        }
         *(hist->list + 8) = ( *(hist->list + 8) & 65535) - 1 & 65535;
    }
    item = pushHist(hist, ptr);
    putHash_sv(hist->hash, ptr, item);
    return item;
}

HistItem* getHashHist(Hist* hist, char* ptr)
{// addr = 0x080ABD98  --  defined in 'history.c' at line 175
    HistItem* item;   // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24

    if(hist == 0 || hist->list == 0) {
        return 0;
    }
    if(hist->hash != 0) {
L7:
        return getHash_sv(hist->hash, ptr, 0);
    }
    hist->hash = newHash_sv(127);
    item = hist->list->size;
    while(item != 0) {
        putHash_sv(hist->hash, item->ptr, item);
        item = item->next;
    }
    goto L7;
    return __eax;
}

char* lastHist(Hist* hist)
{// addr = 0x080ABE2A  --  defined in 'history.c' at line 190
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t17;                        // _t17

    if(hist == 0 || hist->list == 0) {
        return 0;
    }
    if(hist->list->next == 0) {
        return 0;
    }
    hist->current = hist->list->next;
    return hist->current->ptr;
    return __eax;
}

char* nextHist(Hist* hist)
{// addr = 0x080ABE6E  --  defined in 'history.c' at line 202
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t20;                        // _t20

    if(hist == 0 || hist->list == 0) {
        return 0;
    }
    if(hist->current == 0 || hist->current->next == 0) {
        return 0;
    }
    hist->current = hist->current->next;
    return hist->current->ptr;
}

char* prevHist(Hist* hist)
{// addr = 0x080ABEBE  --  defined in 'history.c' at line 214
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t20;                        // _t20

    if(hist == 0 || hist->list == 0) {
        return 0;
    }
    if(hist->current == 0 || hist->current->prev == 0) {
        return 0;
    }
    hist->current = hist->current->prev;
    return hist->current->ptr;
}

print_headers(Buffer* buf, int len)
{// addr = 0x080ABF10  --  defined in 'backend.c' at line 66
    TextListItem* tp;   // _cfa_fffffff0
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    _unknown_ _t40;                        // _t40
    Buffer* _t41;       // _t41
    _unknown_ _t44;                        // _t44
    _unknown_ _t52;                        // _t52
    _unknown_ _t58;                        // _t58

    if(buf->document_header != 0) {
        tp = buf->document_header->first;
        while(tp != 0) {
            puts(tp->ptr);
            tp = tp->next;
        }
    }
    _v40 =  *(parsedURL2Str(buf + 132));
    printf("w3m-current-url: %s\n");
    if(buf->baseURL != 0) {
        _v40 =  *(parsedURL2Str(buf->baseURL));
        printf("w3m-base-url: %s\n");
    }
    _v40 = buf->type;
    printf("w3m-content-type: %s\n");
    _t41 = buf;
    _t42 =  *((intOrPtr*)(_t41 + 208));
    if( *((intOrPtr*)(_t41 + 208)) != 0) {
        _v40 = wc_ces_to_charset( *(buf + 208));
        printf("w3m-content-charset: %s\n");
    }
    if(len <= 0) {
    } else {
        _v40 = len;
        printf("w3m-content-length: %d\n");
        return;
    }
    goto L10;
L11:
L10:
    return;
    goto L11;
}

internal_get(char* url, int flag, FormList* request)
{// addr = 0x080AC005  --  defined in 'backend.c' at line 89
    Buffer* buf;        // _cfa_fffffff0
    TextLineListItem* p;   // _cfa_ffffffec
    Str first;             // _cfa_ffffffe8
    Str last;              // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    Line* lp;             // _cfa_ffffffdc
    int len;                               // _cfa_ffffffd8
    FormList* _v60;   // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    TextLine* __ebx;   // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t111;                       // _t111
    struct _Str* _t121;   // _t121
    char* _t132;                           // _t132
    _unknown_ _t140;                       // _t140
    _unknown_ _t143;                       // _t143
    _unknown_ _t150;                       // _t150
    _unknown_ _t155;                       // _t155

    backend_halfdump_buf = 0;
    do_download = flag;
    _v60 = request;
    _v64 = 0;
    buf = loadGeneralFile(url, 0, -1);
    do_download = 0;
    if(buf == 0 || buf == 1) {
        return;
    } else {
        if(is_html_type(buf->type) == 0 || backend_halfdump_buf == 0) {
            if(strcasecmp(buf->type, "text/plain") != 0) {
                print_headers(buf, 0);
                return;
            }
        } else {
            len = 0;
            p = backend_halfdump_buf->first;
            while(p != 0) {
                __ebx = p->ptr;
                if((ExtHalfdump & 0xff) == 0) {
                    _t121 = p->ptr->ptr;
                } else {
                    _t121 = wc_Str_conv(p->ptr->ptr, InnerCharset, DisplayCharset);
                }
                __ebx->line = _t121;
                len = len + p->ptr->ptr->pos + 1;
                p = p->next;
            }
            first = Strnew_charp("<pre>\n");
            _t132 = html_quote(buf->buffername);
            _v64 = 0;
            _v68 = "</title>\n";
            _v72 = _t132;
            last = Strnew_m_charp("</pre><title>");
            print_headers(buf, first->length + len + last->length);
            putchar(10);
            _v72 = first->ptr;
            printf("%s");
            p = backend_halfdump_buf->first;
            while(p != 0) {
                puts(p->ptr->ptr->line);
                p = p->next;
            }
            _v72 = last->ptr;
            printf("%s");
            return;
        }
        len = 0;
        lp = buf->firstLine;
        while(lp != 0) {
            len = len + lp->len;
            if(( *(lp->lineBuf + lp->len - 1) & 0xff) != 10) {
                len = len + 1;
            }
            lp = lp->next;
        }
        print_headers(buf, len);
        putchar(10);
        saveBuffer(buf, __imp__stdout, 1);
        return;
    }
}

get(TextList* argv)
{// addr = 0x080AC281  --  defined in 'backend.c' at line 139
    char* p;                               // _cfa_fffffff0
    char* url;                             // _cfa_ffffffec
    int flag;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    url = 0;
    flag = 0;
    while(1) {
        p = popValue(argv);
        if(p == 0) {
            break;
        }
        if(strcasecmp(p, "-download_only") != 0) {
            url = p;
        } else {
            flag = 1;
        }
    }
    if(url == 0) {
        return;
    }
    internal_get(url, flag, 0);
    return;
}

post(TextList* argv)
{// addr = 0x080AC2F3  --  defined in 'backend.c' at line 158
    FormList* request;   // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* target;                          // _cfa_ffffffe8
    char* charset;                         // _cfa_ffffffe4
    char* enctype;                         // _cfa_ffffffe0
    char* body;                            // _cfa_ffffffdc
    char* boundary;                        // _cfa_ffffffd8
    char* url;                             // _cfa_ffffffd4
    int flag;                              // _cfa_ffffffd0
    int length;                            // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    long unsigned int _t105;               // _t105

    target = 0;
    charset = 0;
    enctype = 0;
    body = 0;
    boundary = 0;
    url = 0;
    flag = 0;
    length = 0;
    while(1) {
        p = popValue(argv);
        if(p == 0) {
            break;
        }
        if(strcasecmp(p, "-download_only") != 0) {
            if(strcasecmp(p, "-target") != 0) {
                if(strcasecmp(p, "-charset") != 0) {
                    if(strcasecmp(p, "-enctype") != 0) {
                        if(strcasecmp(p, "-body") != 0) {
                            if(strcasecmp(p, "-boundary") != 0) {
                                if(strcasecmp(p, "-length") != 0) {
                                    url = p;
                                } else {
                                    length = atol(popValue(argv));
                                }
                            } else {
                                boundary = popValue(argv);
                            }
                        } else {
                            body = popValue(argv);
                        }
                    } else {
                        enctype = popValue(argv);
                    }
                } else {
                    charset = popValue(argv);
                }
            } else {
                target = popValue(argv);
            }
        } else {
            flag = 1;
        }
    }
    if(url == 0) {
        return;
    }
    request = newFormList(0, "post", charset, enctype, target, 0, 0);
    request->body = body;
    request->boundary = boundary;
    if(length <= 0) {
        if(body == 0) {
            _t105 = 0;
        } else {
            _t105 = strlen(body);
        }
    } else {
        _t105 = length;
    }
    request->length = _t105;
    internal_get(url, flag, request);
    return;
}

set(TextList* argv)
{// addr = 0x080AC50E  --  defined in 'backend.c' at line 196
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t36;                        // _t36

    if((argv->nitem & 0xffff) > 1) {
        i = 0;
        while( *((intOrPtr*)( &variable_table + (i + i + _t47 << 2))) != 0) {
            if(strcasecmp( *( &variable_table + (i + i + _t48 << 2)), argv->first->ptr) != 0) {
                i = i + 1;
                continue;
            }
            popValue(argv);
            if( *((intOrPtr*)((i + i + _t49 << 2) + 135106996)) != 0) {
                _t50 = i;
                 *__esp = argv;
                 *((intOrPtr*)( *((intOrPtr*)((i + _t50 + _t50 << 2) + 135106996))))();
                return;
            }
            goto L9;
        }
        return;
    }
L9:
    return;
}

show(TextList* argv)
{// addr = 0x080AC5B3  --  defined in 'backend.c' at line 214
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t36;                        // _t36

    if((argv->nitem & 0xffff) > 0) {
        i = 0;
        while( *((intOrPtr*)( &variable_table + (i + i + _t47 << 2))) != 0) {
            if(strcasecmp( *( &variable_table + (i + i + _t48 << 2)), argv->first->ptr) != 0) {
                i = i + 1;
                continue;
            }
            popValue(argv);
            if( *((intOrPtr*)((i + i + _t49 << 2) + 135107000)) != 0) {
                _t50 = i;
                 *__esp = argv;
                 *((intOrPtr*)( *((intOrPtr*)((i + _t50 + _t50 << 2) + 135107000))))();
                return;
            }
            goto L9;
        }
        return;
    }
L9:
    return;
}

quit(TextList* argv)
{// addr = 0x080AC657  --  defined in 'backend.c' at line 232
    _unknown_ __ebp;                       // r6

    save_cookies();
    w3m_exit(0);
    return;
}

help(TextList* argv)
{// addr = 0x080AC670  --  defined in 'backend.c' at line 243
    int i;                                 // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25

    i = 0;
    while( *((intOrPtr*)( &command_table + (i << 4))) != 0) {
        _v32 =  *((intOrPtr*)((i << 4) + 135106888));
        _v36 =  *((intOrPtr*)((i << 4) + 135106884));
        _v40 =  *((intOrPtr*)( &command_table + (i << 4)));
        printf("%s %s\n    %s\n");
        i = i + 1;
    }
    return;
}

set_column(TextList* argv)
{// addr = 0x080AC6D7  --  defined in 'backend.c' at line 255
    _unknown_ __ebp;                       // r6

    if((argv->nitem & 0xffff) == 1) {
        COLS = atol(argv->first->ptr);
        return;
    }
    return;
}

show_column(TextList* argv)
{// addr = 0x080AC700  --  defined in 'backend.c' at line 264
    int _v20;                              // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    _v20 = COLS;
    fprintf(__imp__stdout, "column=%d\n");
    return;
}

call_command_function(char* str)
{// addr = 0x080AC728  --  defined in 'backend.c' at line 272
    int i;                                 // _cfa_fffffff0
    TextList* argv;   // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t36;                        // _t36

    argv = split(str);
    if((argv->nitem & 0xffff) > 0) {
        i = 0;
        while( *( &command_table + (i << 4)) != 0) {
            if(strcasecmp( *( &command_table + (i << 4)), argv->first->ptr) != 0) {
                i = i + 1;
                continue;
            }
            popValue(argv);
            if( *((intOrPtr*)((i << 4) + 135106892)) != 0) {
                 *__esp = argv;
                 *((intOrPtr*)( *((intOrPtr*)((i << 4) + 135106892))))();
                return;
            }
            goto L9;
        }
        return;
    }
L9:
    return;
}

int backend()
{// addr = 0x080AC7BE  --  defined in 'backend.c' at line 291
    char* str;                             // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12

    w3m_dump = 0;
    if(COLS == 0) {
        COLS = 80;
    }
    use_mouse = 0;
    if(backend_batch_commands == 0) {
        while(1) {
L9:
            str = readline("w3m> ");
            if(str == 0) {
                break;
            }
            __eax = str;
            call_command_function(str);
        }
        goto L10;
    } else {
        while(1) {
            str = popValue(backend_batch_commands);
            if(str == 0) {
                break;
            }
            call_command_function(str);
        }
L10:
        quit(0);
        return 0;
    }
    goto L9;
}

char* readline(char* prompt)
{// addr = 0x080AC84F  --  defined in 'backend.c' at line 318
    Str s;                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    _unknown_ _t22;                        // _t22

    fputs(prompt, __imp__stdout);
    fflush(__imp__stdout);
    s = Strfgets(__imp__stdin);
    if(feof(__imp__stdin) == 0 || (s & 0xff) != 0) {
        return s->ptr;
    }
    return 0;
}

TextList* split(char* p)
{// addr = 0x080AC8B3  --  defined in 'backend.c' at line 334
    int in_double_quote;                   // _cfa_fffffff0
    int in_single_quote;                   // _cfa_ffffffec
    Str s;                 // _cfa_ffffffe8
    TextList* tp;     // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t227;                       // _t227
    signed int _t234;                      // _t234
    int _t242;                             // _t242
    int _t256;                             // _t256
    int _t269;                             // _t269
    signed int _t278;                      // _t278
    int _t285;                             // _t285
    int _t298;                             // _t298
    int _t311;                             // _t311
    int _t324;                             // _t324
    int _t337;                             // _t337
    int _t350;                             // _t350
    int _t363;                             // _t363

    in_double_quote = 0;
    in_single_quote = 0;
    s = Strnew();
    tp = newGeneralList();
    while(( *p & 0xff) != 0) {
        _t234 =  *p & 0xff;
        if(_t234 > 13) {
            if(_t234 == 34) {
                if(in_single_quote == 0) {
                    in_double_quote = _t234 & 0xff;
                    goto L60;
                }
                goto L13;
            }
            goto L6;
L13:
            if(s->length + 1 >= s->area_size) {
                Strgrow(s);
            }
            _t242 = s->length;
             *((char*)(s->ptr + _t242)) = 34;
            s->length = _t242 + 1;
             *(s->ptr + s->length) = 0;
            goto L60;
        }
        if(_t234 >= 12 || _t234 - 9 <= 1) {
L49:
            if(in_double_quote != 0 || in_single_quote != 0) {
                if(s->length + 1 >= s->area_size) {
                    Strgrow(s);
                }
                _t363 = s->length;
                 *(s->ptr + _t363) =  *p & 0xff;
                s->length = _t363 + 1;
                 *(s->ptr + s->length) = 0;
            } else {
                if(s->length > 0) {
                    pushValue(tp, allocStr(s->ptr, -1));
                    s = Strnew();
                }
            }
L60:
            p =  &(p[1]);
            continue;
        }
L56:
        if(s->length + 1 >= s->area_size) {
            Strgrow(s);
        }
        _t350 = s->length;
         *(s->ptr + _t350) =  *p & 0xff;
        s->length = _t350 + 1;
         *(s->ptr + s->length) = 0;
        goto L60;
L6:
        if(_t234 > 34) {
            if(_t234 == 39) {
                if(in_double_quote == 0) {
                    in_single_quote = _t234 & 0xff;
                } else {
                    if(s->length + 1 >= s->area_size) {
                        Strgrow(s);
                    }
                    _t256 = s->length;
                     *((char*)(s->ptr + _t256)) = 39;
                    s->length = _t256 + 1;
                     *(s->ptr + s->length) = 0;
                }
                goto L60;
            }
            goto L10;
        }
        if(_t234 == 32) {
            goto L49;
        } else {
        }
        goto L56;
L10:
        if(_t234 == 92) {
            if(in_single_quote != 0) {
                if(s->length + 1 >= s->area_size) {
                    Strgrow(s);
                }
                _t269 = s->length;
                 *(s->ptr + _t269) =  *p & 0xff;
                s->length = _t269 + 1;
                 *(s->ptr + s->length) = 0;
                goto L60;
            }
        } else {
            goto L56;
        }
        p =  &(p[1]);
        _t278 =  *p & 0xff;
        if(_t278 == 110) {
            if(s->length + 1 >= s->area_size) {
                Strgrow(s);
            }
            _t285 = s->length;
             *((char*)(s->ptr + _t285)) = 10;
            s->length = _t285 + 1;
             *(s->ptr + s->length) = 0;
            goto L45;
        }
        if(_t278 > 110) {
            if(_t278 == 114) {
                if(s->length + 1 >= s->area_size) {
                    Strgrow(s);
                }
                _t298 = s->length;
                 *((char*)(s->ptr + _t298)) = 13;
                s->length = _t298 + 1;
                 *(s->ptr + s->length) = 0;
                goto L45;
            }
            goto L29;
        }
        if(_t278 == 0) {
            goto L64;
        }
        if(_t278 == 102) {
            if(s->length + 1 >= s->area_size) {
                Strgrow(s);
            }
            _t337 = s->length;
             *((char*)(s->ptr + _t337)) = 12;
            s->length = _t337 + 1;
             *(s->ptr + s->length) = 0;
L45:
            goto L60;
        }
L42:
        if(s->length + 1 >= s->area_size) {
            Strgrow(s);
        }
        _t311 = s->length;
         *(s->ptr + _t311) =  *p & 0xff;
        s->length = _t311 + 1;
         *(s->ptr + s->length) = 0;
        goto L60;
L64:
        if(s->length > 0) {
            pushValue(tp, allocStr(s->ptr, -1));
        }
        return tp;
L29:
        if(_t278 != 116) {
            goto L42;
        }
        if(s->length + 1 >= s->area_size) {
            Strgrow(s);
        }
        _t324 = s->length;
         *((char*)(s->ptr + _t324)) = 9;
        s->length = _t324 + 1;
         *(s->ptr + s->length) = 0;
        goto L45;
    }
    goto L64;
}

AnchorList* putAnchor(AnchorList* al, char* url, char* target, Anchor** anchor_return, char* referer, char* title, unsigned char key, int line, int pos)
{// addr = 0x080ACD68  --  defined in 'anchor.c' at line 9
    int n;                                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    Anchor* a;          // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    BufferPoint bp;   // _cfa_ffffffd8
    signed char _v48;                      // _cfa_ffffffd0
    intOrPtr _v72;                         // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    AnchorList* _t167;   // _t167
    Anchor* _t169;      // _t169
    Anchor* _t189;      // _t189
    Anchor* _t190;      // _t190
    signed int _t226;                      // _t226
    intOrPtr* _t233;                       // _t233
    Anchor* _t257;      // _t257
    intOrPtr* _t344;                       // _t344

    _t167 = _a28;
    _v48 = _t167 & 255;
    if(al == 0) {
         *__esp = 16;
        GC_malloc();
        al = _t167;
        al->anchors = 0;
        al->anchormax = 0;
        al->nanchor = al->anchormax;
        al->acache = -1;
    }
    _t169 = al->anchormax;
    if(_t169 == 0) {
         *__esp = 1800;
        GC_malloc();
        al->anchors = _t169;
        al->anchormax = 30;
    }
    if(al->nanchor == al->anchormax) {
        al->anchormax = al->anchormax + al->anchormax;
        _t257 = al->anchors;
        _v72 = (al->anchormax << 2 << 4) - (al->anchormax << 2);
         *__esp = _t257;
        GC_realloc();
        al->anchors = _t257;
    }
    bp.line = line;
    _v36 = pos;
    n = al->nanchor;
    if(n == 0) {
L11:
        i = n;
    } else {
        if( *((intOrPtr*)(al->anchors + (n - 1 << 2 << 4) - (n - 1 << 2) + 20)) == bp.line) {
            if( *((intOrPtr*)(al->anchors + (n - 1 << 2 << 4) - (n - 1 << 2) + 24)) - _v36 >= 0) {
                goto L12;
            }
            goto L11;
        } else {
            if( *((intOrPtr*)(al->anchors + (n - 1 << 2 << 4) - (n - 1 << 2) + 20)) - bp.line >= 0) {
                goto L11;
            } else {
L12:
                i = 0;
                while(i < n) {
                    if( *((intOrPtr*)(al->anchors + (i << 2 << 4) - (i << 2) + 20)) == bp.line) {
                        _t226 =  !( *((intOrPtr*)(al->anchors + (i << 2 << 4) - (i << 2) + 24)) - _v36) >> 31;
                    } else {
                        _t226 =  !( *((intOrPtr*)(al->anchors + (i << 2 << 4) - (i << 2) + 20)) - bp.line) >> 31;
                    }
                    if((_t226 & 255) == 0) {
                        i = i + 1;
                        continue;
                    }
                    j = n;
                    while(j > i) {
                        _t233 = al->anchors + (j << 2 << 4) - (j << 2);
                        _t344 = al->anchors + (j - 1 << 2 << 4) - (j - 1 << 2);
                         *_t233 =  *_t344;
                         *((intOrPtr*)(_t233 + 4)) =  *((intOrPtr*)(_t344 + 4));
                         *((intOrPtr*)(_t233 + 8)) =  *((intOrPtr*)(_t344 + 8));
                         *((intOrPtr*)(_t233 + 12)) =  *((intOrPtr*)(_t344 + 12));
                         *((intOrPtr*)(_t233 + 16)) =  *((intOrPtr*)(_t344 + 16));
                         *((intOrPtr*)(_t233 + 20)) =  *((intOrPtr*)(_t344 + 20));
                         *((intOrPtr*)(_t233 + 24)) =  *((intOrPtr*)(_t344 + 24));
                         *((intOrPtr*)(_t233 + 28)) =  *((intOrPtr*)(_t344 + 28));
                         *((intOrPtr*)(_t233 + 32)) =  *((intOrPtr*)(_t344 + 32));
                         *((intOrPtr*)(_t233 + 36)) =  *((intOrPtr*)(_t344 + 36));
                         *((intOrPtr*)(_t233 + 40)) =  *((intOrPtr*)(_t344 + 40));
                         *((intOrPtr*)(_t233 + 44)) =  *((intOrPtr*)(_t344 + 44));
                         *((intOrPtr*)(_t233 + 48)) =  *((intOrPtr*)(_t344 + 48));
                         *((intOrPtr*)(_t233 + 52)) =  *((intOrPtr*)(_t344 + 52));
                         *((intOrPtr*)(_t233 + 56)) =  *((intOrPtr*)(_t344 + 56));
                        j = j - 1;
                    }
                    goto L23;
                }
            }
        }
    }
L23:
    a = al->anchors + (i << 2 << 4) - (i << 2);
    a->url = url;
    a->target = target;
    a->referer = referer;
    a->title = title;
    a->accesskey = _v48 & 0xff;
    a->slave = 0;
    _t189 = a;
     *(_t189 + 20) = bp.line;
     *(_t189 + 24) = _v36;
     *((intOrPtr*)(_t189 + 28)) = _v32;
    _t190 = a;
     *(_t190 + 32) = bp.line;
     *(_t190 + 36) = _v36;
     *((intOrPtr*)(_t190 + 40)) = _v32;
    al->nanchor = al->nanchor + 1;
    if(anchor_return != 0) {
         *anchor_return = a;
    }
    return al;
}

Anchor* registerHref(Buffer* buf, char* url, char* target, char* referer, char* title, unsigned char key, int line, int pos)
{// addr = 0x080AD0B4  --  defined in 'anchor.c' at line 60
    Anchor* a;          // _cfa_fffffff0
    signed char _v32;                      // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6

    _v32 = _a24 & 255;
    buf->href = putAnchor(buf->href, url, target,  &a, referer, title, _v32 & 255, line, pos);
    return a;
}

Anchor* registerName(Buffer* buf, char* url, int line, int pos)
{// addr = 0x080AD112  --  defined in 'anchor.c' at line 70
    Anchor* a;          // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6

    buf->name = putAnchor(buf->name, url, 0,  &a, 0, 0, 0, line, pos);
    return a;
}

Anchor* registerImg(Buffer* buf, char* url, char* title, int line, int pos)
{// addr = 0x080AD16D  --  defined in 'anchor.c' at line 79
    Anchor* a;          // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6

    buf->img = putAnchor(buf->img, url, 0,  &a, 0, title, 0, line, pos);
    return a;
}

Anchor* registerForm(Buffer* buf, FormList* flist, struct parsed_tag* tag, int line, int pos)
{// addr = 0x080AD1C7  --  defined in 'anchor.c' at line 88
    Anchor* a;          // _cfa_fffffff0
    FormItemList* fi;   // _cfa_ffffffec
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33

    fi = formList_addInput(flist, tag);
    if(fi != 0) {
        buf->formitem = putAnchor(buf->formitem, fi, flist->target,  &a, 0, 0, 0, line, pos);
        return a;
    }
    return 0;
}

int onAnchor(Anchor* a, int line, int pos)
{// addr = 0x080AD24B  --  defined in 'anchor.c' at line 103
    int _v12;                              // _cfa_fffffff4
    BufferPoint bp;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    signed int _t37;                       // _t37
    signed int _t42;                       // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t44;                        // _t44
    _unknown_ _t47;                        // _t47

    bp.line = line;
    _v12 = pos;
    if(bp.line ==  *((intOrPtr*)(a + 20))) {
        _t37 = _v12 -  *((intOrPtr*)(a + 24)) >> 31;
    } else {
        _t37 = bp.line -  *((intOrPtr*)(a + 20)) >> 31;
    }
    if((_t37 & 255) == 0) {
        if( *((intOrPtr*)(a + 32)) == bp.line) {
            _t42 =  *((intOrPtr*)(a + 36)) - _v12;
        } else {
            _t42 =  *((intOrPtr*)(a + 32)) - bp.line;
        }
        if((_t42 & 255) == 0) {
            return 0;
        }
        return 1;
    }
    return -1;
}

Anchor* retrieveAnchor(AnchorList* al, int line, int pos)
{// addr = 0x080AD2E4  --  defined in 'anchor.c' at line 117
    Anchor* a;          // _cfa_fffffff4
    size_t b;           // _cfa_fffffff0
    size_t e;           // _cfa_ffffffec
    int cmp;                               // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    _unknown_ _t74;                        // _t74
    _unknown_ _t79;                        // _t79

    if(al == 0 || al->nanchor == 0) {
        return 0;
    }
    if(al->acache >= 0 || al->acache >= al->nanchor) {
        al->acache = 0;
    }
    b = 0;
    e = al->nanchor - 1;
    while(b <= e) {
        a = al->anchors + (al->acache << 2 << 4) - (al->acache << 2);
        cmp = onAnchor(a, line, pos);
        if(cmp != 0) {
            if(cmp <= 0) {
                if(al->acache != 0) {
                    e = al->acache - 1;
                    goto L14;
                }
                goto L12;
L14:
                al->acache = b + e >> 1;
                continue;
            }
            goto L10;
L12:
            return 0;
        }
        return a;
L10:
        b = al->acache + 1;
        goto L14;
    }
    return 0;
}

Anchor* retrieveCurrentAnchor(Buffer* buf)
{// addr = 0x080AD3E2  --  defined in 'anchor.c' at line 145
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    if(buf->currentLine != 0) {
        return retrieveAnchor(buf->href, buf->currentLine->linenumber, buf->pos);
    }
    return 0;
}

Anchor* retrieveCurrentImg(Buffer* buf)
{// addr = 0x080AD420  --  defined in 'anchor.c' at line 153
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    if(buf->currentLine != 0) {
        return retrieveAnchor(buf->img, buf->currentLine->linenumber, buf->pos);
    }
    return 0;
}

Anchor* retrieveCurrentForm(Buffer* buf)
{// addr = 0x080AD45E  --  defined in 'anchor.c' at line 161
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    if(buf->currentLine != 0) {
        return retrieveAnchor(buf->formitem, buf->currentLine->linenumber, buf->pos);
    }
    return 0;
}

Anchor* searchAnchor(AnchorList* al, char* str)
{// addr = 0x080AD49C  --  defined in 'anchor.c' at line 170
    int i;                                 // _cfa_fffffff0
    Anchor* a;          // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32

    if(al != 0) {
        i = 0;
L8:
        while(al->nanchor > i) {
            goto L3;
        }
        return 0;
    }
    return 0;
L3:
    a = al->anchors + (i << 2 << 4) - (i << 2);
    if(a->hseq >= 0) {
        goto L7;
    }
    if(strcmp(a->url, str) != 0) {
        goto L7;
    }
    return a;
L7:
    i = i + 1;
    goto L8;
}

Anchor* searchURLLabel(Buffer* buf, char* url)
{// addr = 0x080AD517  --  defined in 'anchor.c' at line 187
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return searchAnchor(buf->name, url);
}

Anchor* _put_anchor_news(Buffer* buf, char* p1, char* p2, int line, int pos)
{// addr = 0x080AD534  --  defined in 'anchor.c' at line 194
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    if(( *p1 & 0xff) == 60) {
        p1 =  &(p1[1]);
        if(( *(p2 - 1) & 0xff) == 62) {
            p2 = p2 - 1;
        }
    }
    tmp = wc_Str_conv_strict(Strnew_charp_n(p1, p2 - p1), InnerCharset,  *(buf + 208));
    _v56 = file_quote(tmp->ptr);
    tmp = Sprintf("news:%s");
    return registerHref(buf, tmp->ptr, 0, -1, 0, 0, line, pos);
}

Anchor* _put_anchor_all(Buffer* buf, char* p1, char* p2, int line, int pos)
{// addr = 0x080AD601  --  defined in 'anchor.c' at line 212
    Str tmp;               // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    tmp = wc_Str_conv_strict(Strnew_charp_n(p1, p2 - p1), InnerCharset,  *(buf + 208));
    return registerHref(buf, url_quote(tmp->ptr), 0, -1, 0, 0, line, pos);
}

reseq_anchor0(AnchorList* al, short int* seqmap)
{// addr = 0x080AD697  --  defined in 'anchor.c' at line 223
    int i;                                 // _cfa_fffffff4
    Anchor* a;          // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    if(al != 0) {
        i = 0;
        while(al->nanchor > i) {
            a = al->anchors + (i << 2 << 4) - (i << 2);
            if(a->hseq < 0) {
                a->hseq =  *(a->hseq + a->hseq + seqmap) & 0xffff;
            }
            i = i + 1;
        }
        return;
    }
    return;
}

reseq_anchor(Buffer* buf)
{// addr = 0x080AD702  --  defined in 'anchor.c' at line 241
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int n;                                 // _cfa_ffffffe8
    int nmark;                             // _cfa_ffffffe4
    short int* seqmap;                     // _cfa_ffffffe0
    Anchor* a;          // _cfa_ffffffdc
    Anchor* a1;         // _cfa_ffffffd8
    HmarkerList* ml;   // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t154;                             // _t154
    short int* _t171;                      // _t171

    if(buf->hmarklist == 0) {
        _t154 = 0;
    } else {
        _t154 = buf->hmarklist->nmark;
    }
    nmark = _t154;
    ml = 0;
    if(buf->href == 0) {
        return;
    }
    n = nmark;
    i = 0;
    while(buf->href->nanchor > i) {
        a = buf->href->anchors + (i << 2 << 4) - (i << 2);
        if(a->hseq == 254) {
            n = n + 1;
        }
        i = i + 1;
    }
    if(n != nmark) {
        _t171 = n + n;
         *__esp = _t171;
        GC_malloc_atomic();
        seqmap = _t171;
        i = 0;
        while(i < n) {
             *(i + i + seqmap) = i & 65535;
            i = i + 1;
        }
        n = nmark;
        i = 0;
        while(buf->href->nanchor > i) {
            a = buf->href->anchors + (i << 2 << 4) - (i << 2);
            if(a->hseq != 254) {
L21:
                i = i + 1;
                continue;
            }
            a->hseq = n;
            a1 = closest_next_anchor(buf->href, 0,  *(a + 24),  *(a + 20));
            a1 = closest_next_anchor(buf->formitem, a1,  *(a + 24),  *(a + 20));
            if(a1 == 0 || a1->hseq >= 0) {
L20:
                ml = putHmarker(ml,  *(a + 20),  *(a + 24),  *(n + n + seqmap) & 0xffff);
                n = n + 1;
            } else {
                 *(n + n + seqmap) =  *(a1->hseq + a1->hseq + seqmap) & 0xffff;
                j = a1->hseq;
                while(j < nmark) {
                     *(j + j + seqmap) = ( *(j + j + seqmap) & 65535) + 1 & 65535;
                    j = j + 1;
                }
                goto L20;
            }
            goto L21;
        }
        i = 0;
        while(i < nmark) {
            ml = putHmarker(ml,  *(buf->hmarklist->marks + (i + i + i << 2)), (buf->hmarklist->marks + (i + i + i << 2))[1],  *(i + i + seqmap) & 0xffff);
            i = i + 1;
        }
        buf->hmarklist = ml;
        reseq_anchor0(buf->href, seqmap);
        reseq_anchor0(buf->formitem, seqmap);
        return;
    }
    return;
}

char* reAnchorPos(Buffer* buf, Line* l, char* p1, char* p2, _None* anchorproc)
{// addr = 0x080AD9BB  --  defined in 'anchor.c' at line 296
    Anchor* a;          // _cfa_fffffff0
    int spos;                              // _cfa_ffffffec
    int epos;                              // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int hseq;                              // _cfa_ffffffe0
    int _v60;                              // _cfa_ffffffc4
    long int _v64;                         // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t116;                       // _t116
    Anchor* _t133;      // _t133
    _unknown_ _t140;                       // _t140

    hseq = -2;
    spos = p1 - l->lineBuf;
    epos = p2 - l->lineBuf;
    i = spos;
    while(i < epos) {
    }
    i = spos;
    while(i < epos) {
         *(l->propBuf + i + i) = ( *(l->propBuf + i + i) & 65535 | 16) & 65535;
        i = i + 1;
    }
    while(l->len < spos && l->next != 0 && l->next->bpos != 0) {
        spos = spos - l->len;
        epos = epos - l->len;
        l = l->next;
    }
    while(1) {
        _v60 = spos;
        _v64 = l->linenumber;
        _v68 = p2;
        _v72 = p1;
         *__esp = buf;
        _t133 = anchorproc;
        _t133->url();
        a = _t133;
        a->hseq = hseq;
        if(hseq == 254) {
            reseq_anchor(buf);
            hseq = a->hseq;
        }
         *(a + 32) = l->linenumber;
        if(l->len >= epos || l->next == 0 || l->next->bpos == 0) {
            break;
        }
         *(a + 36) = l->len;
        spos = 0;
        epos = epos - l->len;
        l = l->next;
    }
     *(a + 36) = epos;
    return;
}

reAnchorWord(Buffer* buf, Line* l, int spos, int epos)
{// addr = 0x080ADB4D  --  defined in 'anchor.c' at line 339
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t19;                        // _t19

    reAnchorPos(buf, l,  &(l->lineBuf[spos]),  &(l->lineBuf[epos]), _put_anchor_all);
    return;
}

char* reAnchorAny(Buffer* buf, char* re, _None* anchorproc)
{// addr = 0x080ADB8C  --  defined in 'anchor.c' at line 347
    Line* l;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* p1;                              // _cfa_ffffffe8
    char* p2;                              // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t65;                        // _t65
    Line* _t72;           // _t72
    _unknown_ _t73;                        // _t73
    _unknown_ _t102;                       // _t102

    p = 0;
    if(re == 0 || ( *re & 0xff) == 0) {
        return 0;
    }
    re = regexCompile(re, 1);
    if(re != 0) {
        return re;
    }
    if(MarkAllPages == 0) {
        _t72 = buf->topLine;
    } else {
        _t72 = buf->firstLine;
    }
    l = _t72;
    while(l != 0 && (MarkAllPages != 0 || l->linenumber < buf->topLine->linenumber + LINES - 1)) {
        if(p == 0 || l->bpos == 0) {
            p = l->lineBuf;
            while(regexMatch(p, l->lineBuf + l->size - p, l->lineBuf & 0xff) == 1) {
                matchedPosition( &p1,  &p2);
                p = reAnchorPos(buf, l, p1, p2, anchorproc);
            }
L16:
            if(MarkAllPages != 0 && l->next == 0 &&  *((intOrPtr*)(buf + 92)) != 0) {
                asm("cwde ");
                if((buf->bufferprop & 0x40) == 0) {
                    getNextPage(buf, PagerMax);
                }
            }
            l = l->next;
            continue;
        }
        goto L16;
    }
    return 0;
}

char* reAnchor(Buffer* buf, char* re)
{// addr = 0x080ADD1D  --  defined in 'anchor.c' at line 382
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return reAnchorAny(buf, re, _put_anchor_all);
}

char* reAnchorNews(Buffer* buf, char* re)
{// addr = 0x080ADD3F  --  defined in 'anchor.c' at line 389
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return reAnchorAny(buf, re, _put_anchor_news);
}

char* reAnchorNewsheader(Buffer* buf)
{// addr = 0x080ADD61  --  defined in 'anchor.c' at line 395
    Line* l;              // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* p1;                              // _cfa_ffffffe8
    char* p2;                              // _cfa_ffffffe4
    char** header;                         // _cfa_ffffffe0
    char** q;                              // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    int search;                            // _cfa_ffffffd4
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t76;                        // _t76
    _unknown_ _t79;                        // _t79
    _unknown_ _t82;                        // _t82
    _unknown_ _t84;                        // _t84

    search = 0;
    if(buf == 0 || buf->firstLine == 0) {
        return 0;
    }
    i = 0;
    while(i <= 1) {
        if(i != 0) {
            regexCompile("[a-zA-Z0-9\.\-_]+", 1);
            header =  &header_group;
        } else {
            regexCompile("<[!-;=?-~]+[a-zA-Z0-9\.\-_]+>", 1);
            header =  &header_mid;
        }
        l = buf->firstLine;
        while(l != 0 && l->real_linenumber == 0) {
            if(l->bpos != 0) {
                goto L21;
            }
            p = l->lineBuf;
            if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
L15:
                if(search == 0) {
                    goto L19;
                }
L16:
                while(regexMatch(p, l->lineBuf + l->size - p, l->lineBuf & 0xff) == 1) {
                    matchedPosition( &p1,  &p2);
                    p = reAnchorPos(buf, l, p1, p2, _put_anchor_news);
                }
L21:
                l = l->next;
                continue;
            }
            search = 0;
            q = header;
            while( *q != 0) {
                if(strncasecmp(p,  *q, strlen( *q)) != 0) {
                    q =  &(q[1]);
                    continue;
                }
                search = 1;
                p =  &((strchr(p, 58))[1]);
                goto L15;
            }
            goto L15;
L19:
            goto L21;
        }
        i = i + 1;
    }
    reseq_anchor(buf);
    return 0;
}

HmarkerList* putHmarker(HmarkerList* ml, int line, int pos, int seq)
{// addr = 0x080ADF4A  --  defined in 'anchor.c' at line 454
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    HmarkerList* _t57;   // _t57
    BufferPoint* _t95;   // _t95
    BufferPoint* _t105;   // _t105
    _unknown_ _t115;                       // _t115

    _t57 = __eax;
    if(ml == 0) {
         *__esp = 16;
        GC_malloc();
        ml = _t57;
        ml->marks = 0;
        ml->nmark = 0;
        ml->markmax = 0;
        ml->prevhseq = -1;
    }
    if(ml->markmax == 0) {
        ml->markmax = 30;
        _t105 = ml->markmax + ml->markmax + ml->markmax << 2;
         *__esp = _t105;
        GC_malloc_atomic();
        ml->marks = _t105;
        bzero(ml->marks, ml->markmax + ml->markmax + ml->markmax << 2);
    }
    if(seq + 1 > ml->nmark) {
        ml->nmark = seq + 1;
    }
    if(ml->nmark >= ml->markmax) {
        ml->markmax = ml->nmark + ml->nmark;
        _t95 = ml->marks;
        _v24 = ml->markmax + ml->markmax + ml->markmax << 2;
         *__esp = _t95;
        GC_realloc();
        ml->marks = _t95;
    }
     *(ml->marks + (seq + seq + seq << 2)) = line;
    (ml->marks + (seq + seq + seq << 2))[1] = pos;
    (ml->marks + (seq + seq + seq << 2))[2] = 0;
    return ml;
}

Anchor* closest_next_anchor(AnchorList* a, Anchor* an, int x, int y)
{// addr = 0x080AE09D  --  defined in 'anchor.c' at line 481
    int i;                                 // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6

    if(a == 0) {
L2:
        return an;
    }
    if(a->nanchor != 0) {
        i = 0;
        while(a->nanchor > i) {
            i = i + 1;
        }
        goto L16;
    }
    goto L2;
L16:
    return an;
}

Anchor* closest_prev_anchor(AnchorList* a, Anchor* an, int x, int y)
{// addr = 0x080AE20C  --  defined in 'anchor.c' at line 502
    int i;                                 // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6

    if(a == 0) {
L2:
        return an;
    }
    if(a->nanchor != 0) {
        i = 0;
        while(a->nanchor > i) {
            i = i + 1;
        }
        goto L16;
    }
    goto L2;
L16:
    return an;
}

shiftAnchorPosition(AnchorList* al, HmarkerList* hl, int line, int pos, int shift)
{// addr = 0x080AE37B  --  defined in 'anchor.c' at line 523
    Anchor* a;          // _cfa_fffffff4
    size_t b;           // _cfa_fffffff0
    size_t e;           // _cfa_ffffffec
    size_t s;           // _cfa_ffffffe8
    int cmp;                               // _cfa_ffffffe4
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t76;                        // _t76

    s = 0;
    if(al == 0) {
        return;
    }
    if(al->nanchor == 0) {
        goto L24;
    }
    s = (al->nanchor >> 31) + al->nanchor >> 1;
    b = 0;
    e = al->nanchor - 1;
    while(b <= e) {
        a = al->anchors + (s << 2 << 4) - (s << 2);
        cmp = onAnchor(a, line, pos);
        if(cmp != 0) {
            if(cmp <= 0) {
                if(s != 0) {
                    e = s - 1;
                } else {
                    goto L13;
                }
L10:
                s = b + e + 1 >> 1;
                continue;
            }
            b = s + 1;
            goto L10;
        } else {
L13:
L21:
            while(al->nanchor > s) {
                a = al->anchors + (s << 2 << 4) - (s << 2);
                if( *((intOrPtr*)(a + 20)) <= line) {
                    if( *((intOrPtr*)(a + 24)) > pos) {
                         *((intOrPtr*)(a + 24)) =  *((intOrPtr*)(a + 24)) + shift;
                        if( *((intOrPtr*)(hl->marks + (a->hseq + a->hseq + a->hseq << 2))) == line) {
                             *((intOrPtr*)(hl->marks + (a->hseq + a->hseq + a->hseq << 2) + 4)) =  *((intOrPtr*)(a + 24));
                        }
                    }
                    if( *((intOrPtr*)(a + 36)) >= pos) {
                         *((intOrPtr*)(a + 36)) =  *((intOrPtr*)(a + 36)) + shift;
                    }
                    s = s + 1;
                    continue;
                }
                return;
            }
            return;
        }
        goto L21;
    }
    goto L21;
L24:
    return;
}

addMultirowsImg(Buffer* buf, AnchorList* al)
{// addr = 0x080AE515  --  defined in 'anchor.c' at line 562
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int col;                               // _cfa_ffffffd4
    int ecol;                              // _cfa_ffffffd0
    int pos;                               // _cfa_ffffffcc
    Image* img;          // _cfa_ffffffc8
    Anchor* a;          // _cfa_ffffffc4
    Line* l;              // _cfa_ffffffc0
    Line* ls;             // _cfa_ffffffbc
    Image* _v72;         // _cfa_ffffffb8
    char* _v76;                            // _cfa_ffffffb4
    signed int _v78;                       // _cfa_ffffffb2
    char* _v80;                            // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    int _v92;                              // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    char* _v112;                           // _cfa_ffffff90
    char* _v116;                           // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    char* _v124;                           // _cfa_ffffff84
    Anchor a_img;       // _cfa_ffffff80
    Image* _v132;        // _cfa_ffffff7c
    short int _v136;                       // _cfa_ffffff78
    char _v140;                            // _cfa_ffffff74
    char _v144;                            // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    intOrPtr _v156;                        // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    intOrPtr _v164;                        // _cfa_ffffff5c
    intOrPtr _v168;                        // _cfa_ffffff58
    signed char _v172;                     // _cfa_ffffff54
    char* _v176;                           // _cfa_ffffff50
    char* _v180;                           // _cfa_ffffff4c
    char* _v184;                           // _cfa_ffffff48
    Anchor a_href;      // _cfa_ffffff44
    Image* _v192;        // _cfa_ffffff40
    short int _v196;                       // _cfa_ffffff3c
    char _v200;                            // _cfa_ffffff38
    char _v204;                            // _cfa_ffffff34
    intOrPtr _v208;                        // _cfa_ffffff30
    intOrPtr _v212;                        // _cfa_ffffff2c
    intOrPtr _v216;                        // _cfa_ffffff28
    intOrPtr _v220;                        // _cfa_ffffff24
    intOrPtr _v224;                        // _cfa_ffffff20
    intOrPtr _v228;                        // _cfa_ffffff1c
    unsigned char _v232;                   // _cfa_ffffff18
    char* _v236;                           // _cfa_ffffff14
    char* _v240;                           // _cfa_ffffff10
    char* _v244;                           // _cfa_ffffff0c
    Anchor a_form;      // _cfa_ffffff08
    int _v256;                             // _cfa_ffffff00
    char* _v272;                           // _cfa_fffffef0
    _unknown_ _v300;                       // _cfa_fffffed4
    _unknown_ _v304;                       // _cfa_fffffed0
    _unknown_ _v308;                       // _cfa_fffffecc
    _unknown_ _v312;                       // _cfa_fffffec8
    _unknown_ _v316;                       // _cfa_fffffec4
    _unknown_ _v320;                       // _cfa_fffffec0
    _unknown_ _v324;                       // _cfa_fffffebc
    _unknown_ _v328;                       // _cfa_fffffeb8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t325;                       // _t325
    char** _t334;                          // _t334
    Line* _t355;          // _t355
    Anchor* _t430;      // _t430
    Anchor* _t432;      // _t432

    if(al == 0) {
        return;
    }
    if(al->nanchor != 0) {
        i = 0;
L53:
        while(al->nanchor > i) {
            _t334 = al->anchors + (i << 2 << 4) - (i << 2);
            a_img.url =  *_t334;
            _v124 = _t334[1];
            _v120 = _t334[2];
            _v116 = _t334[3];
            _v112 = _t334[4];
            _v108 = _t334[5];
            _v104 = _t334[6];
            _v100 = _t334[7];
            _v96 = _t334[8];
            _v92 = _t334[9];
            _v88 = _t334[0xa];
            _v84 = _t334[0xb];
            _v80 = _t334[0xc];
            _v76 = _t334[0xd];
            _v72 = _t334[0xe];
            img = _v72;
            if(_v84 >= 0) {
                goto L52;
            }
            if(img == 0) {
                goto L48;
            }
            if((img->rows & 0xffff) <= 1) {
                goto L49;
            }
            l = buf->firstLine;
            while(l != 0) {
                asm("cwde ");
                if(l->linenumber == (img->y & 65535)) {
                    goto L12;
                }
                l = l->next;
                continue;
L12:
                if(l == 0) {
                    goto L50;
                }
                if((_v78 & 0xffff) != _v108) {
                    ls = l;
L21:
                    while(ls != 0) {
                        goto L16;
                    }
L24:
                    if(ls == 0) {
                        goto L51;
                    }
                    goto L25;
                }
                ls = l;
L25:
                a = retrieveAnchor(buf->href, _v108, _v104);
                if(a == 0) {
                    a_href.url = 0;
                } else {
                    _t432 = a;
                    a_href.url =  *_t432;
                    _v184 = _t432->target;
                    _v180 = _t432->referer;
                    _v176 = _t432->title;
                    _v172 = _t432->accesskey;
                    _v168 =  *((intOrPtr*)(_t432 + 20));
                    _v164 =  *((intOrPtr*)(_t432 + 24));
                    _v160 =  *((intOrPtr*)(_t432 + 28));
                    _v156 =  *((intOrPtr*)(_t432 + 32));
                    _v152 =  *((intOrPtr*)(_t432 + 36));
                    _v148 =  *((intOrPtr*)(_t432 + 40));
                    _v144 = _t432->hseq;
                    _v140 = _t432->slave;
                    _v136 = _t432->rows;
                    _v132 = _t432->image;
                }
                a = retrieveAnchor(buf->formitem, _v108, _v104);
                if(a == 0) {
                    a_form.url = 0;
                } else {
                    _t430 = a;
                    a_form.url =  *_t430;
                    _v244 = _t430->target;
                    _v240 = _t430->referer;
                    _v236 = _t430->title;
                    _v232 = _t430->accesskey;
                    _v228 =  *((intOrPtr*)(_t430 + 20));
                    _v224 =  *((intOrPtr*)(_t430 + 24));
                    _v220 =  *((intOrPtr*)(_t430 + 28));
                    _v216 =  *((intOrPtr*)(_t430 + 32));
                    _v212 =  *((intOrPtr*)(_t430 + 36));
                    _v208 =  *((intOrPtr*)(_t430 + 40));
                    _v204 = _t430->hseq;
                    _v200 = _t430->slave;
                    _v196 = _t430->rows;
                    _v192 = _t430->image;
                }
                col = calcPosition(ls->lineBuf, ls->propBuf, ls->len, _v104, 0, 0);
                ecol = calcPosition(ls->lineBuf, ls->propBuf, ls->len, _v92, 0, 0);
                j = 0;
                while(l != 0) {
                    asm("cwde ");
                    if((img->rows & 65535) > j) {
                        if(_v108 == l->linenumber) {
                            goto L43;
                        }
                        pos = columnPos(l, col);
                        a = registerImg(buf, a_img.url, _v116, l->linenumber, pos);
                        a->hseq =  ~_v84;
                        a->slave = 1;
                        a->image = img;
                         *((intOrPtr*)(a + 36)) = pos + ecol - col;
                        k = pos;
                        while( *((intOrPtr*)(a + 36)) > k) {
                             *(l->propBuf + k + k) = ( *(l->propBuf + k + k) & 65535 | 32) & 65535;
                            k = k + 1;
                        }
                        if(a_href.url == 0) {
L40:
                            if(a_form.url != 0) {
                                buf->formitem = putAnchor(buf->formitem, a_form.url, _v244,  &a, 0, 0, 0, l->linenumber, pos);
                                a->hseq = _v204;
                                 *((intOrPtr*)(a + 36)) = pos + ecol - col;
                            }
                            goto L43;
                        }
                        _v272 = a_href.url;
                        _v256 = pos;
                        a = registerHref(buf, _v272, _v184, _v180, _v176, _v172 & 0xff, l->linenumber, _v256);
                        a->hseq = _v144;
                        a->slave = 1;
                         *((intOrPtr*)(a + 36)) = pos + ecol - col;
                        k = pos;
                        while( *((intOrPtr*)(a + 36)) > k) {
                             *(l->propBuf + k + k) = ( *(l->propBuf + k + k) & 65535 | 16) & 65535;
                            k = k + 1;
                        }
                        goto L40;
L43:
                        l = l->next;
                        j = j + 1;
                        continue;
                    }
                    break;
                }
                img->rows = 0;
L52:
                i = i + 1;
                goto L53;
L16:
                if(ls->linenumber == _v108) {
                    goto L24;
                }
                if((_v78 & 0xffff) >= _v108) {
                    _t355 = ls->prev;
                } else {
                    _t355 = ls->next;
                }
                ls = _t355;
                goto L21;
L51:
                goto L52;
            }
            goto L12;
L50:
            goto L52;
L49:
            goto L52;
L48:
            goto L52;
        }
        return;
    }
    return;
}

addMultirowsForm(Buffer* buf, AnchorList* al)
{// addr = 0x080AEAEF  --  defined in 'anchor.c' at line 640
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int col;                               // _cfa_ffffffe4
    int ecol;                              // _cfa_ffffffe0
    int pos;                               // _cfa_ffffffdc
    Anchor* a;          // _cfa_ffffffd8
    FormItemList* fi;   // _cfa_ffffffd4
    Line* l;              // _cfa_ffffffd0
    Line* ls;             // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v62;                       // _cfa_ffffffc2
    char* _v64;                            // _cfa_ffffffc0
    short int _v68;                        // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    char* _v92;                            // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    char* _v100;                           // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    char* _v108;                           // _cfa_ffffff94
    Anchor a_form;      // _cfa_ffffff90
    _unknown_ _v140;                       // _cfa_ffffff74
    _unknown_ _v144;                       // _cfa_ffffff70
    _unknown_ _v148;                       // _cfa_ffffff6c
    _unknown_ _v152;                       // _cfa_ffffff68
    _unknown_ _v156;                       // _cfa_ffffff64
    _unknown_ _v160;                       // _cfa_ffffff60
    _unknown_ _v164;                       // _cfa_ffffff5c
    _unknown_ _v168;                       // _cfa_ffffff58
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t192;                       // _t192
    char** _t201;                          // _t201
    Line* _t224;          // _t224

    if(al == 0) {
        return;
    }
    if(al->nanchor == 0) {
    } else {
        i = 0;
L42:
        while(al->nanchor > i) {
            _t201 = al->anchors + (i << 2 << 4) - (i << 2);
            a_form.url =  *_t201;
            _v108 = _t201[1];
            _v104 = _t201[2];
            _v100 = _t201[3];
            _v96 = _t201[4];
            _v92 = _t201[5];
            _v88 = _t201[6];
            _v84 = _t201[7];
            _v80 = _t201[8];
            _v76 = _t201[9];
            _v72 = _t201[0xa];
            _v68 = _t201[0xb];
            _v64 = _t201[0xc];
            _v60 = _t201[0xd];
            _v56 = _t201[0xe];
            (al->anchors + (i << 2 << 4) - (i << 2))[0xd] = 1;
            if(_v68 >= 0) {
                goto L41;
            }
            if((_v60 & 0xffff) <= 1) {
                goto L38;
            }
            l = buf->firstLine;
            while(l != 0) {
                asm("cwde ");
                if(l->linenumber == (_v62 & 65535)) {
                    goto L11;
                }
                l = l->next;
                continue;
L11:
                if(l == 0) {
                    goto L39;
                }
                if((_v62 & 0xffff) != _v92) {
                    ls = l;
L20:
                    while(ls != 0) {
                        goto L15;
                    }
L23:
                    if(ls == 0) {
                        goto L40;
                    }
                    goto L24;
                }
                ls = l;
L24:
                fi = a_form.url;
                col = calcPosition(ls->lineBuf, ls->propBuf, ls->len, _v88, 0, 0);
                ecol = calcPosition(ls->lineBuf, ls->propBuf, ls->len, _v76, 0, 0);
                j = 0;
                while(l != 0) {
                    asm("cwde ");
                    if((_v60 & 65535) > j) {
                        pos = columnPos(l, col);
                        if(j == 0) {
                             *(buf->hmarklist->marks + (_v68 + _v68 + _v68 << 2)) = l->linenumber;
                            (buf->hmarklist->marks + (_v68 + _v68 + _v68 << 2))[1] = pos;
                        }
                        if(_v92 != l->linenumber) {
                            buf->formitem = putAnchor(buf->formitem, a_form.url, _v108,  &a, 0, 0, 0, l->linenumber, pos);
                            a->hseq = _v68;
                            a->y = _v62 & 0xffff;
                             *((intOrPtr*)(a + 36)) = pos + ecol - col;
                             *((char*)(l->lineBuf + pos - 1)) = 91;
                             *((char*)(l->lineBuf +  *((intOrPtr*)(a + 36)))) = 93;
                            k = pos;
                            while( *((intOrPtr*)(a + 36)) > k) {
                                 *(l->propBuf + k + k) = ( *(l->propBuf + k + k) & 65535 | 64) & 65535;
                                k =  &((1)[k]);
                            }
                        }
                        l = l->next;
                        j =  &((1)[j]);
                        continue;
                    }
                    break;
                }
L41:
                i =  &((1)[i]);
                goto L42;
L15:
                if(ls->linenumber == _v92) {
                    goto L23;
                }
                if((_v62 & 0xffff) >= _v92) {
                    _t224 = ls->prev;
                } else {
                    _t224 = ls->next;
                }
                ls = _t224;
                goto L20;
L40:
                goto L41;
            }
            goto L11;
L39:
            goto L41;
L38:
            goto L41;
        }
        return;
    }
    goto L45;
L46:
    return;
L45:
    goto L46;
}

char* getAnchorText(Buffer* buf, AnchorList* al, Anchor* a)
{// addr = 0x080AEE76  --  defined in 'anchor.c' at line 697
    int hseq;                              // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    Line* l;              // _cfa_ffffffe8
    Str tmp;               // _cfa_ffffffe4
    char* p;                               // _cfa_ffffffe0
    char* ep;                              // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t84;                        // _t84
    int _t121;                             // _t121
    _unknown_ _t141;                       // _t141

    tmp = 0;
    if(a == 0 || a->hseq < 0) {
        return 0;
    }
    hseq = a->hseq;
    l = buf->firstLine;
    i = 0;
L25:
    while(al->nanchor > i) {
        a = al->anchors + (i << 2 << 4) - (i << 2);
        if(a->hseq == hseq) {
            while(l != 0) {
                if(l->linenumber ==  *((intOrPtr*)(a + 20))) {
                    goto L11;
                }
                l = l->next;
                continue;
L11:
                if(l == 0) {
                    goto L28;
                }
                p =  &(l->lineBuf[ *((intOrPtr*)(a + 24))]);
                ep =  &(l->lineBuf[ *((intOrPtr*)(a + 36))]);
                while(p < ep && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
                    p =  &(p[1]);
                }
                if(p == ep) {
                    goto L24;
                }
                if(tmp != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t121 = tmp->length;
                     *((char*)(tmp->ptr + _t121)) = 32;
                    tmp->length = _t121 + 1;
                     *(tmp->ptr + tmp->length) = 0;
L22:
                    Strcat_charp_n(tmp, p, ep - p);
                    goto L24;
                }
                tmp = Strnew_size(ep - p);
                goto L22;
L24:
                i = i + 1;
                goto L25;
L28:
                if(tmp == 0) {
                    return 0;
                }
                return tmp->ptr;
            }
            goto L11;
        }
        goto L24;
    }
    goto L28;
}

Buffer* link_list_panel(Buffer* buf)
{// addr = 0x080AF027  --  defined in 'anchor.c' at line 733
    LinkList* l;      // _cfa_fffffff0
    AnchorList* al;   // _cfa_ffffffec
    Anchor* a;          // _cfa_ffffffe8
    FormItemList* fi;   // _cfa_ffffffe4
    int i;                                 // _cfa_ffffffe0
    char* t;                               // _cfa_ffffffdc
    char* u;                               // _cfa_ffffffd8
    char* p;                               // _cfa_ffffffd4
    Str tmp;               // _cfa_ffffffd0
    MapList* ml;       // _cfa_ffffffcc
    ListItem* mi;     // _cfa_ffffffc8
    MapArea* m;        // _cfa_ffffffc4
    ParsedURL pu;    // _cfa_ffffff9c
    int _v124;                             // _cfa_ffffff84
    char* _v128;                           // _cfa_ffffff80
    char* _v132;                           // _cfa_ffffff7c
    char* _v136;                           // _cfa_ffffff78
    char* _v140;                           // _cfa_ffffff74
    char* _v144;                           // _cfa_ffffff70
    char* _v148;                           // _cfa_ffffff6c
    char* _v152;                           // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t294;                       // _t294
    _unknown_ _t299;                       // _t299
    char* _t457;                           // _t457
    char* _t481;                           // _t481

    tmp = Strnew_charp("<title>Link List</title><h1 align=center>Link List</h1>\n");
    asm("cwde ");
    if((buf->bufferprop & 8) != 0 || buf->linklist == 0 && buf->href == 0 && buf->img == 0) {
        return 0;
    }
    if(buf->linklist == 0) {
L23:
        if(buf->href == 0) {
L39:
            if(buf->img == 0) {
L78:
                return loadHTMLString(tmp);
            }
            goto L40;
            return __eax;
        }
        goto L24;
L40:
        Strcat_charp(tmp, "<hr><h2>Images</h2>\n<ol>\n");
        al = buf->img;
        i = 0;
        while(al->nanchor > i) {
            a = al->anchors + (i << 2 << 4) - (i << 2);
            if((a->slave & 0xff) != 0) {
                goto L75;
            }
            parseURL2(a->url,  &(pu.scheme), baseURL(buf));
            p =  *(parsedURL2Str( &(pu.scheme)));
            u = html_quote(p);
            if(DecodeURL == 0) {
                p = u;
            } else {
                p = html_quote(url_unquote_conv(p,  *(buf + 208)));
            }
            if(a->title == 0 || ( *(a->title) & 0xff) == 0) {
                if(DecodeURL == 0) {
                    t = html_quote(a->url);
                } else {
                    t = html_quote(url_unquote_conv(a->url,  *(buf + 208)));
                }
            } else {
                t = html_quote(a->title);
            }
            _v124 = 0;
            _v128 = "\n";
            _v132 = p;
            _v136 = "</a><br>";
            _v140 = t;
            _v144 = "">";
            _v148 = u;
            _v152 = "<li><a href="";
            Strcat_m_charp(tmp);
            a = retrieveAnchor(buf->formitem,  *(a + 20),  *(a + 24));
            if(a == 0) {
                goto L73;
            } else {
                fi = a->url;
                fi = fi->parent->item;
                if(fi->parent->method != 2 || strcmp( *( *(fi->parent + 12)), "map") != 0 ||  *(fi + 8) == 0) {
L75:
                    i = i + 1;
                    continue;
                }
                ml = searchMapList(buf,  *( *(fi + 8)));
                if(ml == 0) {
                    goto L74;
                }
                Strcat_charp(tmp, "<br>\n<b>Image map</b>\n<ol>\n");
                mi = ml->area->first;
                while(mi != 0) {
                    m = mi->ptr;
                    if(m != 0) {
                        parseURL2(m->url,  &(pu.scheme), baseURL(buf));
                        p =  *(parsedURL2Str( &(pu.scheme)));
                        u = html_quote(p);
                        if(DecodeURL == 0) {
                            p = u;
                        } else {
                            p = html_quote(url_unquote_conv(p,  *(buf + 208)));
                        }
                        if(m->alt == 0 || (m & 0xff) == 0) {
                            if(DecodeURL == 0) {
                                t = html_quote(m->url);
                            } else {
                                t = html_quote(url_unquote_conv(m->url,  *(buf + 208)));
                            }
                        } else {
                            t = html_quote(m->alt);
                        }
                        _v124 = 0;
                        _v128 = "\n";
                        _v132 = p;
                        _v136 = "</a><br>";
                        _v140 = t;
                        _v144 = "">";
                        _v148 = u;
                        _v152 = "<li><a href="";
                        Strcat_m_charp(tmp);
                    }
                    mi = mi->next;
                }
                Strcat_charp(tmp, "</ol>\n");
                goto L75;
            }
L74:
            goto L75;
L73:
            goto L75;
        }
        Strcat_charp(tmp, "</ol>\n");
        goto L78;
    } else {
        Strcat_charp(tmp, "<hr><h2>Links</h2>\n<ol>\n");
        l = buf->linklist;
        while(l != 0) {
            if((l->type & 0xff) != 1) {
                if((l->type & 0xff) != 2) {
                    t = 135071950;
                } else {
                    t = " [Rev]";
                }
            } else {
                t = " [Rel]";
            }
            if(l->title == 0) {
                _t481 = 135071950;
            } else {
                _t481 = l->title;
            }
            _v148 = t;
            _v152 = _t481;
            t =  *(Sprintf("%s%s\n"));
            t = html_quote(t);
            _v124 = 0;
            _v128 = "\n";
            _v132 = p;
            _v136 = "</a><br>";
            _v140 = t;
            _v144 = "">";
            _v148 = u;
            _v152 = "<li><a href="";
            Strcat_m_charp(tmp);
            l = l->next;
        }
        Strcat_charp(tmp, "</ol>\n");
        goto L23;
    }
L24:
    Strcat_charp(tmp, "<hr><h2>Anchors</h2>\n<ol>\n");
    al = buf->href;
    i = 0;
    while(al->nanchor > i) {
        a = al->anchors + (i << 2 << 4) - (i << 2);
        if(a->hseq < 0) {
            if((a->slave & 0xff) == 0) {
                parseURL2(a->url,  &(pu.scheme), baseURL(buf));
                p =  *(parsedURL2Str( &(pu.scheme)));
                u = html_quote(p);
                if(DecodeURL == 0) {
                    p = u;
                } else {
                    p = html_quote(url_unquote_conv(p,  *(buf + 208)));
                }
                t = getAnchorText(buf, al, a);
                if(t == 0) {
                    _t457 = 135071950;
                } else {
                    _t457 = html_quote(t);
                }
                t = _t457;
                _v124 = 0;
                _v128 = "\n";
                _v132 = p;
                _v136 = "</a><br>";
                _v140 = t;
                _v144 = "">";
                _v148 = u;
                _v152 = "<li><a href="";
                Strcat_m_charp(tmp);
            }
        }
        i = i + 1;
    }
    Strcat_charp(tmp, "</ol>\n");
    goto L39;
}

int noConv(char* oval, char** str)
{// addr = 0x080AF79C  --  defined in 'parsetagx.c' at line 36
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

     *str = oval;
    return 1;
}

int toNumber(char* oval, int* num)
{// addr = 0x080AF7AE  --  defined in 'parsetagx.c' at line 43
    char* ep;                              // _cfa_fffffff0
    int x;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    _unknown_ _t15;                        // _t15

    x = strtol(oval,  &ep, 10);
    if(ep <= oval) {
        return 0;
    }
     *num = x;
    return 1;
}

int toLength(char* oval, int* len)
{// addr = 0x080AF7EF  --  defined in 'parsetagx.c' at line 59
    int w;                                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t34;                        // _t34
    _unknown_ _t37;                        // _t37
    _unknown_ _t38;                        // _t38

    if(( *( &MYCTYPE_MAP + ( *oval & 0xff)) & 8) != 0) {
        w = atoi(oval);
        if(w >= 0) {
            if(w == 0) {
                w = 1;
            }
            if(( *(strlen(oval) - 1 + oval) & 0xff) != 37) {
                 *len = w;
            } else {
                 *len =  ~w;
            }
            return 1;
        }
        goto L3;
    }
    return 0;
L3:
    return 0;
}

int toAlign(char* oval, int* align)
{// addr = 0x080AF873  --  defined in 'parsetagx.c' at line 77
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    _unknown_ _t33;                        // _t33

    if(strcasecmp(oval, "left") != 0) {
        if(strcasecmp(oval, "right") != 0) {
            if(strcasecmp(oval, "center") != 0) {
                if(strcasecmp(oval, "top") != 0) {
                    if(strcasecmp(oval, "bottom") != 0) {
                        if(strcasecmp(oval, "middle") != 0) {
                            return 0;
                        }
                        goto L11;
                    }
                    goto L9;
L11:
                     *align = 4;
                    goto L13;
                }
                goto L7;
L9:
                 *align = 6;
                goto L13;
            }
            goto L5;
L7:
             *align = 5;
            goto L13;
        }
        goto L3;
L5:
         *align = 0;
        goto L13;
    }
     *align = 1;
L13:
    return 1;
L3:
     *align = 2;
    goto L13;
}

int toVAlign(char* oval, int* valign)
{// addr = 0x080AF959  --  defined in 'parsetagx.c' at line 97
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t22;                        // _t22

    if(strcasecmp(oval, "top") == 0 || strcasecmp(oval, "baseline") == 0) {
         *valign = 1;
L8:
        return 1;
    }
    if(strcasecmp(oval, "bottom") != 0) {
        if(strcasecmp(oval, "middle") != 0) {
            return 0;
        }
        goto L6;
    }
     *valign = 2;
    goto L8;
L6:
     *valign = 0;
    goto L8;
}

struct parsed_tag* parse_tag(char** s, int internal)
{// addr = 0x080AF9EA  --  defined in 'parsetagx.c' at line 114
    intOrPtr _v16;                         // _cfa_fffffff0
    char[63] tagname;                      // _cfa_ffffffb0
    char[63] attrname;                     // _cfa_ffffff70
    struct parsed_tag* tag;   // _cfa_ffffff6c
    int tag_id;                            // _cfa_ffffff68
    char* p;                               // _cfa_ffffff64
    char* q;                               // _cfa_ffffff60
    int i;                                 // _cfa_ffffff5c
    int attr_id;                           // _cfa_ffffff58
    int nattr;                             // _cfa_ffffff54
    Str value;             // _cfa_ffffff50
    Str value_tmp;         // _cfa_ffffff4c
    int j;                                 // _cfa_ffffff48
    int hidden;                            // _cfa_ffffff44
    char* x;                               // _cfa_ffffff40
    char** _v208;                          // _cfa_ffffff30
    _unknown_ _v228;                       // _cfa_ffffff1c
    _unknown_ _v232;                       // _cfa_ffffff18
    _unknown_ __ebp;                       // r6
    _unknown_ _t528;                       // _t528
    signed int _t541;                      // _t541
    signed int _t543;                      // _t543
    struct parsed_tag* _t547;   // _t547
    signed int _t549;                      // _t549
    _unknown_ _t551;                       // _t551
    _unknown_ _t580;                       // _t580
    _unknown_ _t590;                       // _t590
    _unknown_ _t626;                       // _t626
    _unknown_ _t631;                       // _t631
    _unknown_ _t636;                       // _t636
    _unknown_ _t638;                       // _t638
    _unknown_ _t640;                       // _t640
    _unknown_ _t641;                       // _t641
    _unknown_ _t645;                       // _t645
    _unknown_ _t659;                       // _t659
    _unknown_ _t661;                       // _t661
    _unknown_ _t663;                       // _t663
    _unknown_ _t667;                       // _t667
    _unknown_ _t671;                       // _t671
    _unknown_ _t673;                       // _t673
    _unknown_ _t674;                       // _t674
    _unknown_ _t678;                       // _t678
    _unknown_ _t685;                       // _t685
    _unknown_ _t689;                       // _t689
    _unknown_ _t695;                       // _t695
    _unknown_ _t697;                       // _t697
    _unknown_ _t699;                       // _t699
    _unknown_ _t701;                       // _t701
    _unknown_ _t702;                       // _t702
    _unknown_ _t706;                       // _t706
    _unknown_ _t713;                       // _t713
    _unknown_ _t717;                       // _t717
    _unknown_ _t729;                       // _t729
    _unknown_ _t730;                       // _t730
    _unknown_ _t734;                       // _t734
    _unknown_ _t741;                       // _t741
    _unknown_ _t745;                       // _t745
    _unknown_ _t787;                       // _t787
    _unknown_ _t791;                       // _t791
    unsigned char* _t800;                  // _t800
    unsigned char _t803;                   // _t803
    unsigned char* _t804;                  // _t804
    _unknown_ _t808;                       // _t808
    _unknown_ _t811;                       // _t811
    signed int _t854;                      // _t854
    signed int _t858;                      // _t858
    _unknown_ _t888;                       // _t888

    _v208 = _a4;
    _v16 =  *gs:0x14];
    tag = 0;
    attr_id = 0;
    q =  &(( *_v208)[1]);
    p =  &tagname;
    if(( *q & 0xff) != 47) {
L12:
        while(( *q & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0 && ((tagname & 0xff) == 47 || ( *q & 0xff) != 47) && ( *q & 0xff) != 62) {
            if(p -  &tagname <= 62) {
                _t854 =  *( &MYCTYPE_MAP + ( *q & 0xff)) & 255;
                __eflags = _t854 & 4;
                if((_t854 & 4) == 0) {
                    _t858 =  *q & 255;
                } else {
                    _t858 =  *q & 255 | 32;
                }
                 *p = _t858 & 255;
                p =  &(p[1]);
                q =  &(q[1]);
                continue;
            }
            break;
        }
         *p = 0;
        while(( *q & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) == 0 && ((tagname & 0xff) == 47 || ( *q & 0xff) != 47)) {
            if(( *q & 0xff) != 62) {
                q =  &(q[1]);
                continue;
            }
            break;
        }
        _t541 = getHash_si( &tagtable,  &tagname, 0);
        tag_id = _t541;
        if(tag_id == 0) {
            goto L137;
        }
        if(internal != 0) {
L28:
             *__esp = 20;
            GC_malloc();
            tag = _t541;
            bzero(tag, 20);
            tag->tagid = tag_id & 255;
            nattr =  *((tag_id + tag_id + _t890 << 2) + 135107784) & 0xff;
            if(nattr <= 0) {
            } else {
                _t800 = nattr;
                 *__esp = _t800;
                GC_malloc_atomic();
                tag->attrid = _t800;
                _t803 = nattr << 2;
                 *__esp = _t803;
                GC_malloc();
                _t804 = tag;
                _t804[8] = _t803;
                 *__esp = 75;
                GC_malloc_atomic();
                tag->map = _t804;
                memset(tag->map, 75, 75);
                memset(tag->attrid, 0, nattr);
                i = 0;
                while(i < nattr) {
L34:
                    while(( *q & 0xff) != 0) {
                        goto L35;
                    }
                    while(1) {
L36:
                        value = 0;
                        value_tmp = 0;
                        if(( *q & 0xff) == 62 || ( *q & 0xff) == 0) {
                            break;
                        } else {
                            p =  &attrname;
                            goto L43;
                        }
                    }
L139:
                    __eflags = ( *q & 0xff) - 62;
                    if(__eflags == 0) {
                        q =  &(q[1]);
                    }
                     *_v208 = q;
                    _t547 = tag;
                    if(__eflags == 0) {
                        return _t547;
                    } else {
                        __stack_chk_fail();
                        return _t547;
                    }
                }
            }
            goto L34;
L35:
            if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
                q =  &(q[1]);
                goto L34;
            }
            goto L36;
        }
        _t541 =  *((tag_id + tag_id + _t939 << 2) + 135107785) & 2;
        if(_t541 != 0) {
            goto L136;
        }
        goto L28;
        while(1) {
L137:
            _t543 =  *q & 255;
            __eflags = (_t543 & 255) - 62;
            if((_t543 & 255) == 62) {
                break;
            }
            _t549 =  *q & 255;
            __eflags = _t549 & 255;
            if((_t549 & 255) != 0) {
                q =  &(q[1]);
                continue;
            }
            goto L139;
        }
        goto L139;
L136:
        goto L137;
    } else {
         *p =  *q & 0xff;
        p =  &(p[1]);
        q =  &(q[1]);
    }
L3:
    while(( *q & 0xff) != 0) {
        if(( *( &MYCTYPE_MAP + ( *q & 0xff)) & 2) != 0) {
            q =  &(q[1]);
            goto L3;
        } else {
            goto L12;
        }
    }
    goto L12;
}

int parsedtag_set_value(struct parsed_tag* tag, int id, char* value)
{// addr = 0x080B05B7  --  defined in 'parsetagx.c' at line 272
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t36;                        // _t36
    _unknown_ _t53;                        // _t53

    if(tag->map == 0 || ( *(tag->map + id) & 0xff) == 75) {
        return 0;
    }
    i =  *(tag->map + id) & 0xff;
     *(tag->attrid + i) = id & 255;
    if(value == 0) {
         *(tag->value + (i << 2)) = 0;
    } else {
         *(tag->value + (i << 2)) = allocStr(value, -1);
    }
    tag->need_reconstruct = 1;
    return 1;
}

int parsedtag_get_value(struct parsed_tag* tag, int id, _Unknown_base* value)
{// addr = 0x080B0659  --  defined in 'parsetagx.c' at line 290
    int i;                                 // _cfa_fffffff0
    _Unknown_base* _v40;                   // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45

    if(tag->map != 0 && (tag->map[id] & 0xff) != 75 && (tag->attrid[tag->map[id] & 0xff] & 0xff) != 0) {
        i = tag->map[id] & 0xff;
        if(tag->value[i] != 0) {
            _v40 = value;
             *__esp = tag->value[i];
             *((intOrPtr*)( *((intOrPtr*)( &toValFunc + ( *(135109540 + id * 8) & 0xff) * 4))))();
            return;
        } else {
            goto L4;
        }
    }
L4:
    return;
}

Str parsedtag2str(struct parsed_tag* tag)
{// addr = 0x080B0702  --  defined in 'parsetagx.c' at line 299
    int i;                                 // _cfa_fffffff0
    int tag_id;                            // _cfa_ffffffec
    int nattr;                             // _cfa_ffffffe8
    Str tagstr;            // _cfa_ffffffe4
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t113;                             // _t113
    int _t136;                             // _t136
    int _t167;                             // _t167

    tag_id = tag->tagid & 0xff;
    nattr =  *((tag_id + tag_id + _t179 << 2) + 135107784) & 0xff;
    tagstr = Strnew();
    if(tagstr->length + 1 >= tagstr->area_size) {
        Strgrow(tagstr);
    }
    _t113 = tagstr->length;
     *((char*)(tagstr->ptr + _t113)) = 60;
    tagstr->length = _t113 + 1;
     *(tagstr->ptr + tagstr->length) = 0;
    Strcat_charp(tagstr,  *( &TagMAP + (tag_id + tag_id + _t185 << 2)));
    i = 0;
    while(i < nattr) {
        if((tag->attrid[i] & 0xff) != 0) {
            if(tagstr->length + 1 >= tagstr->area_size) {
                Strgrow(tagstr);
            }
            _t136 = tagstr->length;
             *((char*)(tagstr->ptr + _t136)) = 32;
            tagstr->length = _t136 + 1;
             *(tagstr->ptr + tagstr->length) = 0;
            Strcat_charp(tagstr,  *( &AttrMAP + (tag->attrid[i] & 0xff) * 8));
            if(tag->value[i] != 0) {
                _v40 = html_quote(tag->value[i]);
                Strcat(tagstr, Sprintf("="%s""));
            }
        }
        i = i + 1;
    }
    if(tagstr->length + 1 >= tagstr->area_size) {
        Strgrow(tagstr);
    }
    _t167 = tagstr->length;
     *((char*)(tagstr->ptr + _t167)) = 62;
    tagstr->length = _t167 + 1;
     *(tagstr->ptr + tagstr->length) = 0;
    return tagstr;
}

do_update(BaseStream base)
{// addr = 0x080B08E4  --  defined in 'istream.c' at line 39
    int len;                               // _cfa_fffffff0
    struct stream_buffer _v40;   // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t32;                              // _t32

    base->stream.next = 0;
    base->stream.cur = base->stream.next;
    _t32 = base->handle;
    _v40.size = base->stream.size;
    _v40 = base->stream;
     *__esp = _t32;
     *(base->read)();
    len = _t32;
    if(len > 0) {
        base->stream.next = base->stream.next + len;
        return;
    }
    base->iseos = 1;
    return;
}

int buffer_read(StreamBuffer sb, char* obuf, int count)
{// addr = 0x080B094E  --  defined in 'istream.c' at line 51
    int len;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33

    len = sb->next - sb->cur;
    if(len > 0) {
        if(len > count) {
            len = count;
        }
        bcopy(sb->buf + sb->cur, obuf, len);
        sb->cur = sb->cur + len;
    }
    return len;
}

init_buffer(BaseStream base, char* buf, int bufsize)
{// addr = 0x080B09B7  --  defined in 'istream.c' at line 64
    StreamBuffer sb;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    unsigned char* _t23;                   // _t23

    sb = base;
    sb->size = bufsize;
    sb->cur = 0;
    if(buf == 0) {
        _t23 = bufsize;
         *__esp = _t23;
        GC_malloc_atomic();
        sb->buf = _t23;
        sb->next = 0;
    } else {
        sb->buf = buf;
        sb->next = bufsize;
    }
    base->iseos = 0;
    return;
}

init_base_stream(BaseStream base, int bufsize)
{// addr = 0x080B0A14  --  defined in 'istream.c' at line 81
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    init_buffer(base, 0, bufsize);
    return;
}

init_str_stream(BaseStream base, Str s)
{// addr = 0x080B0A36  --  defined in 'istream.c' at line 87
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    init_buffer(base, s->ptr, s->length);
    return;
}

InputStream newInputStream(int des)
{// addr = 0x080B0A5C  --  defined in 'istream.c' at line 93
    InputStream stream;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    union input_stream* _t17;   // _t17
    int _t19;                              // _t19
    _unknown_ _t25;                        // _t25

    if(des >= 0) {
         *__esp = 32;
        GC_malloc();
        stream = _t17;
        init_base_stream(stream, 8192);
        _t19 = stream;
         *(_t19 + 20) = 0;
         *__esp = 4;
        GC_malloc();
        stream->base.stream.size = _t19;
         *(stream->base.stream.size) = des;
        stream->base.stream.next = basic_read;
        stream->base.handle = basic_close;
        return stream;
    }
    return 0;
}

InputStream newFileStream(FILE* f, _None* closep)
{// addr = 0x080B0AD0  --  defined in 'istream.c' at line 109
    InputStream stream;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    union input_stream* _t25;   // _t25
    int _t27;                              // _t27
    _unknown_ _t38;                        // _t38

    if(f != 0) {
         *__esp = 32;
        GC_malloc();
        stream = _t25;
        init_base_stream(stream, 8192);
        _t27 = stream;
         *((char*)(_t27 + 20)) = 1;
         *__esp = 8;
        GC_malloc();
        stream->base.stream.size = _t27;
         *(stream->base.stream.size) = f;
        if(closep == 0) {
             *(stream->base.stream.size + 4) = fclose;
        } else {
             *(stream->base.stream.size + 4) = closep;
        }
        stream->base.stream.next = file_read;
        stream->base.handle = file_close;
        return stream;
    }
    return 0;
}

InputStream newStrStream(Str s)
{// addr = 0x080B0B6B  --  defined in 'istream.c' at line 129
    InputStream stream;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    union input_stream* _t16;   // _t16
    _unknown_ _t23;                        // _t23

    if(s != 0) {
         *__esp = 32;
        GC_malloc();
        stream = _t16;
        init_str_stream(stream, s);
        stream->base.stream.cur = 2;
        stream->base.stream.size = s;
        stream->base.stream.next = str_read;
        stream->base.handle = 0;
        return stream;
    }
    return 0;
}

InputStream newEncodedStream(InputStream is, char encoding)
{// addr = 0x080B0BC9  --  defined in 'istream.c' at line 163
    InputStream stream;   // _cfa_fffffff0
    signed char _v32;                      // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    union input_stream* _t37;   // _t37
    int _t40;                              // _t40

    _t37 = _a8;
    _v32 = _t37 & 255;
    if(is != 0) {
        if(_v32 == 2 || _v32 == 1 || _v32 == 3) {
             *__esp = 32;
            GC_malloc();
            stream = _t37;
            init_base_stream(stream, 8192);
            _t40 = stream;
             *((char*)(_t40 + 20)) = 4;
             *__esp = 16;
            GC_malloc();
            stream->base.stream.size = _t40;
             *(stream->base.stream.size) = is;
             *((intOrPtr*)(stream->base.stream.size + 8)) = 0;
             *(stream->base.stream.size + 12) = _v32 & 0xff;
             *((intOrPtr*)(stream->base.stream.size + 4)) = 0;
            stream->base.stream.next = ens_read;
            stream->base.handle = ens_close;
            return stream;
        } else {
            goto L4;
        }
    }
L4:
    return is;
}

int ISclose(InputStream stream)
{// addr = 0x080B0C7F  --  defined in 'istream.c' at line 183
    _None* prevtrap;                       // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t28;                        // _t28

    if(stream == 0 || stream->base.handle == 0 || (stream->base.stream.cur & 0x10) != 0) {
        return;
    }
    prevtrap = mySignal(2, 1);
     *__esp = stream->base.stream.size;
     *(stream->base.handle)();
    mySignal(2, prevtrap);
    return;
}

int ISgetc(InputStream stream)
{// addr = 0x080B0CEF  --  defined in 'istream.c' at line 196
    BaseStream base;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    _unknown_ _t42;                        // _t42
    int _t45;                              // _t45

    if(stream != 0) {
        base = stream;
        if((base->iseos & 0xff) == 0 && base->stream.cur == base->stream.next) {
            do_update(base);
        }
        if((base->iseos & 0xff) != 0) {
            return 0;
        }
        _t45 = base->stream.cur;
        base->stream.cur = _t45 + 1;
        return  *(base->stream + _t45) & 0xff;
    }
    return 0;
}

int ISundogetc(InputStream stream)
{// addr = 0x080B0D61  --  defined in 'istream.c' at line 208
    StreamBuffer sb;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19

    if(stream != 0) {
        sb = stream;
        if(sb->cur <= 0) {
            return -1;
        }
        goto L3;
    }
    return -1;
L3:
    sb->cur = sb->cur - 1;
    return 0;
}

Str StrISgets(InputStream stream)
{// addr = 0x080B0DA1  --  defined in 'istream.c' at line 223
    BaseStream base;   // _cfa_fffffff0
    StreamBuffer sb;   // _cfa_ffffffec
    Str s;                 // _cfa_ffffffe8
    unsigned char* p;                      // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t123;                       // _t123

    s = 0;
    if(stream != 0) {
        base = stream;
        sb = base;
L12:
        while((base->iseos & 0xff) == 0) {
            goto L3;
        }
        if(s != 0) {
            return s;
        }
        return Strnew();
        return __eax;
    }
    return 0;
L3:
    if(base->stream.cur != base->stream.next) {
        p = memchr(sb->buf + sb->cur, 10, sb->next - sb->cur);
        if(p == 0) {
            if(s == 0) {
                s = Strnew_size(sb->next - sb->cur + 10);
            }
            Strcat_charp_n(s, sb->buf + sb->cur, sb->next - sb->cur);
            sb->cur = sb->next;
            goto L12;
        }
        goto L6;
    }
    do_update(base);
    goto L12;
L6:
    len = p - sb->buf + sb->cur + 1;
    if(s == 0) {
        s = Strnew_size(len);
    }
    Strcat_charp_n(s, sb->buf + sb->cur, len);
    sb->cur = sb->cur + len;
    return s;
}

Str StrmyISgets(InputStream stream)
{// addr = 0x080B0F1F  --  defined in 'istream.c' at line 265
    BaseStream base;   // _cfa_fffffff0
    StreamBuffer sb;   // _cfa_ffffffec
    Str s;                 // _cfa_ffffffe8
    int i;                                 // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t204;                             // _t204
    int _t207;                             // _t207
    _unknown_ _t217;                       // _t217
    int _t243;                             // _t243

    s = 0;
    if(stream == 0) {
        return 0;
    }
    base = stream;
    sb = base;
    while((base->iseos & 0xff) == 0) {
        if(base->stream.cur != base->stream.next) {
            if(s == 0 || s->length <= 0 || ( *(s->ptr + s->length - 1) & 0xff) != 13) {
                i = sb->cur;
L15:
                while(sb->next > i && ( *(sb->buf + i) & 0xff) != 10 && ( *(sb->buf + i) & 0xff) != 13) {
                    goto L14;
                }
                if(sb->next <= i) {
                    if(s == 0) {
                        s = Strnew_size(sb->next - sb->cur + 10);
                    }
                    Strcat_charp_n(s, sb->buf + sb->cur, sb->next - sb->cur);
                    sb->cur = sb->next;
                    continue;
                }
                len = i - sb->cur + 1;
                if(s == 0) {
                    s = Strnew_size(len + 10);
                }
                Strcat_charp_n(s, sb->buf + sb->cur, len);
                sb->cur = i + 1;
                if(( *(sb->buf + i) & 0xff) != 10) {
                    continue;
                }
                return s;
            } else {
                if(( *(sb->buf + sb->cur) & 0xff) == 10) {
                    if(s->length + 1 >= s->area_size) {
                        Strgrow(s);
                    }
                    _t243 = s->length;
                    _t204 = _t243;
                    _t207 = sb->cur;
                     *(s->ptr + _t204) =  *(sb->buf + _t207) & 0xff;
                    s->length = _t243 + 1;
                    sb->cur = _t207 + 1;
                     *(s->ptr + s->length) = 0;
                }
                return s;
            }
L14:
            i = i + 1;
            goto L15;
        } else {
            do_update(base);
        }
    }
    if(s != 0) {
        return s;
    }
    return Strnew();
    return __eax;
}

int ISread(InputStream stream, Str buf, int count)
{// addr = 0x080B116F  --  defined in 'istream.c' at line 315
    int rest;                              // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    BaseStream base;   // _cfa_ffffffe8
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    _unknown_ _t62;                        // _t62
    _unknown_ _t63;                        // _t63
    int _t68;                              // _t68

    if(stream == 0) {
L2:
        return;
    }
    base = stream;
    if((base->iseos & 0xff) == 0) {
        len = buffer_read(base, buf->ptr, count);
        rest = count - len;
        if(base->stream.cur == base->stream.next) {
            _t68 = base->handle;
            _v36 = rest;
            _v40 = buf->ptr + len;
             *__esp = _t68;
             *(base->read)();
            len = _t68;
            if(len <= 0) {
                base->iseos = 1;
                len = 0;
            }
            rest = rest - len;
        }
        Strtruncate(buf, count - rest);
        if(buf->length <= 0) {
            return;
        } else {
            return;
        }
        return;
    }
    goto L2;
}

int ISfileno(InputStream stream)
{// addr = 0x080B124F  --  defined in 'istream.c' at line 340
    _unknown_ __ebp;                       // r6
    signed int _t15;                       // _t15
    _unknown_ _t24;                        // _t24
    _unknown_ _t28;                        // _t28

    if(stream != 0) {
        _t15 = stream->base.stream.cur & 0xef;
        if(_t15 == 1) {
            return fileno( *(stream->base.stream.size));
        }
        goto L3;
L7:
        return ISfileno( *(stream->base.stream.size));
    }
    return -1;
L3:
    if(_t15 == 4) {
        goto L7;
    }
    if(_t15 != 0) {
        goto L8;
    }
    return  *(stream->base.stream.size);
L8:
    return -1;
}

int ISeos(InputStream stream)
{// addr = 0x080B12B2  --  defined in 'istream.c' at line 361
    BaseStream base;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    base = stream;
    if((base->iseos & 0xff) == 0 && base->stream.cur == base->stream.next) {
        do_update(base);
    }
    return base->iseos & 0xff;
}

basic_close(int* handle)
{// addr = 0x080B12F0  --  defined in 'istream.c' at line 641
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    close( *handle);
    return;
}

int basic_read(int* handle, char* buf, int len)
{// addr = 0x080B1305  --  defined in 'istream.c' at line 651
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return read( *handle, buf, len);
}

file_close(struct file_handle* handle)
{// addr = 0x080B1328  --  defined in 'istream.c' at line 661
    _unknown_ __ebp;                       // r6

     *__esp = handle->f;
    handle();
    return;
}

int file_read(struct file_handle* handle, char* buf, int len)
{// addr = 0x080B1340  --  defined in 'istream.c' at line 667
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return fread(buf, 1, len, handle->f);
}

int str_read(Str handle, char* buf, int len)
{// addr = 0x080B136B  --  defined in 'istream.c' at line 673
    _unknown_ __ebp;                       // r6

    return 0;
}

ens_close(struct ens_handle* handle)
{// addr = 0x080B1375  --  defined in 'istream.c' at line 717
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    ISclose(handle->is);
    return;
}

int ens_read(struct ens_handle* handle, char* buf, int len)
{// addr = 0x080B138A  --  defined in 'istream.c' at line 723
    char* p;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t120;                       // _t120
    _unknown_ _t147;                       // _t147

    if( *(handle + 4) == 0 || handle->pos ==  *(handle + 4)->length) {
         *(handle + 4) = StrmyISgets(handle->is);
        if( *(handle + 4)->length == 0) {
            return 0;
        }
        cleanup_line( *(handle + 4), 1);
        if((handle->encoding & 0xff) != 1) {
            if((handle->encoding & 0xff) == 3) {
                if(strncmp( *( *(handle + 4)), "begin", 5) == 0) {
                     *(handle + 4) = StrmyISgets(handle->is);
                }
                Strchop( *(handle + 4));
            }
        } else {
            Strchop( *(handle + 4));
        }
        p =  *( *(handle + 4));
        if((handle->encoding & 0xff) != 2) {
            if((handle->encoding & 0xff) != 1) {
                if((handle->encoding & 0xff) == 3) {
                     *(handle + 4) = decodeU( &p);
                }
            } else {
                 *(handle + 4) = decodeB( &p);
            }
        } else {
             *(handle + 4) = decodeQP( &p);
        }
        handle->pos = 0;
    }
    if( *(handle + 4)->length - handle->pos < len) {
        len =  *(handle + 4)->length - handle->pos;
    }
    bcopy( *( *(handle + 4)) + handle->pos, buf, len);
    handle->pos = handle->pos + len;
    return len;
}

Str Strnew()
{// addr = 0x080B1538  --  defined in 'Str.c' at line 37
    Str x;                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    char* _t9;                             // _t9

    _t9 = __eax;
     *__esp = 12;
    GC_malloc();
    x = _t9;
     *__esp = 32;
    GC_malloc_atomic();
    x->ptr = _t9;
     *(x->ptr) = 0;
    x->area_size = 32;
    x->length = 0;
    return x;
}

Str Strnew_size(int n)
{// addr = 0x080B1581  --  defined in 'Str.c' at line 48
    Str x;                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    char* _t14;                            // _t14

     *__esp = 12;
    GC_malloc();
    x = __eax;
    _t14 = n + 1;
     *__esp = _t14;
    GC_malloc_atomic();
    x->ptr = _t14;
     *(x->ptr) = 0;
    x->area_size = n + 1;
    x->length = 0;
    return x;
}

Str Strnew_charp(char* p)
{// addr = 0x080B15CE  --  defined in 'Str.c' at line 59
    Str x;                 // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct _Str* _t20;    // _t20
    char* _t24;                            // _t24
    _unknown_ _t32;                        // _t32

    _t20 = __eax;
    if(p != 0) {
         *__esp = 12;
        GC_malloc();
        x = _t20;
        n = strlen(p) + 1;
        _t24 = n;
         *__esp = _t24;
        GC_malloc_atomic();
        x->ptr = _t24;
        x->area_size = n;
        x->length = n - 1;
        bcopy(p, x->ptr, n);
        return x;
    }
    return Strnew();
}

Str Strnew_m_charp(char* p)
{// addr = 0x080B1648  --  defined in 'Str.c' at line 76
    va_list ap;        // _cfa_fffffff0
    Str r;                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    char* _t18;                            // _t18

    r = Strnew();
    ap =  &_a8;
    while(p != 0) {
        Strcat_charp(r, p);
        _t18 = ap;
        ap =  &(_t18[4]);
        p =  *_t18;
    }
    return r;
}

Str Strnew_charp_n(char* p, int n)
{// addr = 0x080B1689  --  defined in 'Str.c' at line 90
    Str x;                 // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct _Str* _t22;    // _t22
    char* _t24;                            // _t24
    _unknown_ _t32;                        // _t32

    if(p != 0) {
         *__esp = 12;
        GC_malloc();
        x = _t22;
        _t24 = n + 1;
         *__esp = _t24;
        GC_malloc_atomic();
        x->ptr = _t24;
        x->area_size = n + 1;
        x->length = n;
        bcopy(p, x->ptr, n);
        x->ptr[n] = 0;
        return x;
    }
    return Strnew_size(n);
}

Str Strdup(Str s)
{// addr = 0x080B1709  --  defined in 'Str.c' at line 106
    Str n;                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    n = Strnew_size(s->length);
    Strcopy(n, s);
    return n;
}

Strclear(Str s)
{// addr = 0x080B1737  --  defined in 'Str.c' at line 115
    _unknown_ __ebp;                       // r6

    s->length = 0;
    s = 0;
    return;
}

Strfree(Str x)
{// addr = 0x080B174E  --  defined in 'Str.c' at line 122
    _unknown_ __ebp;                       // r6

     *__esp = x->ptr;
    GC_free();
     *__esp = x;
    GC_free();
    return;
}

Strcopy(Str x, Str y)
{// addr = 0x080B176E  --  defined in 'Str.c' at line 129
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t34;                        // _t34
    char* _t41;                            // _t41

    if(x->area_size < y->length + 1) {
         *__esp = x->ptr;
        GC_free();
        _t41 = y->length + 1;
         *__esp = _t41;
        GC_malloc_atomic();
        x->ptr = _t41;
        x->area_size = y->length + 1;
    }
    bcopy(y->ptr, x->ptr, y->length + 1);
    x->length = y->length;
    return;
}

Strcopy_charp(Str x, char* y)
{// addr = 0x080B17EE  --  defined in 'Str.c' at line 143
    int len;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33
    char* _t38;                            // _t38

    if(y != 0) {
        len = strlen(y);
        if(x->area_size < len + 1) {
             *__esp = x->ptr;
            GC_free();
            _t38 = len + 1;
             *__esp = _t38;
            GC_malloc_atomic();
            x->ptr = _t38;
            x->area_size = len + 1;
        }
        bcopy(y, x->ptr, len + 1);
        x->length = len;
        return;
    }
    x->length = 0;
    return;
}

Strcopy_charp_n(Str x, char* y, int n)
{// addr = 0x080B187D  --  defined in 'Str.c' at line 163
    int len;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33
    char* _t41;                            // _t41

    len = n;
    if(y != 0) {
        if(x->area_size < len + 1) {
             *__esp = x->ptr;
            GC_free();
            _t41 = len + 1;
             *__esp = _t41;
            GC_malloc_atomic();
            x->ptr = _t41;
            x->area_size = len + 1;
        }
        bcopy(y, x->ptr, n);
         *(x->ptr + n) = 0;
        x->length = n;
        return;
    }
    x->length = 0;
    return;
}

Strcat_charp_n(Str x, char* y, int n)
{// addr = 0x080B190D  --  defined in 'Str.c' at line 183
    int newlen;                            // _cfa_fffffff0
    char* old;                             // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t51;                        // _t51
    char* _t66;                            // _t66
    _unknown_ _t74;                        // _t74

    if(y != 0) {
        newlen = x->length + n + 1;
        if(x->area_size < newlen) {
            old = x->ptr;
            newlen = (newlen + newlen + _t83 >> 31) + newlen + newlen + _t83 >> 1;
            _t66 = newlen;
             *__esp = _t66;
            GC_malloc_atomic();
            x->ptr = _t66;
            x->area_size = newlen;
            bcopy(old, x->ptr, x->length);
             *__esp = old;
            GC_free();
        }
        bcopy(y, x->ptr + x->length, n);
        x->length = x->length + n;
         *(x->ptr + x->length) = 0;
        return;
    }
    return;
}

Strcat(Str x, Str y)
{// addr = 0x080B19E6  --  defined in 'Str.c' at line 205
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    Strcat_charp_n(x, y->ptr, y->length);
    return;
}

Strcat_charp(Str x, char* y)
{// addr = 0x080B1A0C  --  defined in 'Str.c' at line 212
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(y != 0) {
        Strcat_charp_n(x, y, strlen(y));
        return;
    }
    return;
}

Strcat_m_charp(Str x)
{// addr = 0x080B1A3E  --  defined in 'Str.c' at line 220
    va_list ap;        // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t14;                            // _t14

    ap =  &_a8;
    while(1) {
        _t14 = ap;
        ap =  &(_t14[4]);
        p =  *_t14;
        if(p == 0) {
            break;
        }
        Strcat_charp_n(x, p, strlen(p));
    }
    return;
}

Strgrow(Str x)
{// addr = 0x080B1A83  --  defined in 'Str.c' at line 231
    char* old;                             // _cfa_fffffff0
    int newlen;                            // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    char* _t41;                            // _t41
    _unknown_ _t49;                        // _t49
    _unknown_ _t55;                        // _t55

    old = x->ptr;
    newlen = ((x->length + x->length + _t54 + x->length + x->length + _t54) * 1717986919 >> 32 >> 1) - (x->length + x->length + _t54 + x->length + x->length + _t54 >> 31);
    if(x->length == newlen) {
        newlen = newlen + 2;
    }
    _t41 = newlen;
     *__esp = _t41;
    GC_malloc_atomic();
    x->ptr = _t41;
    x->area_size = newlen;
    bcopy(old, x->ptr, x->length);
     *__esp = old;
    GC_free();
    return;
}

Str Strsubstr(Str s, int beg, int len)
{// addr = 0x080B1B11  --  defined in 'Str.c' at line 245
    Str new_s;             // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39
    int _t54;                              // _t54

    new_s = Strnew();
    if(s->length > beg) {
        i = 0;
L6:
        while(i < len && beg + i < s->length) {
            goto L3;
        }
        return new_s;
    }
    return new_s;
L3:
    if(new_s->length + 1 >= new_s->area_size) {
        Strgrow(new_s);
    }
    _t54 = new_s->length;
     *(new_s->ptr + _t54) = s->ptr[beg + i] & 0xff;
    new_s->length = _t54 + 1;
     *(new_s->ptr + new_s->length) = 0;
    i = i + 1;
    goto L6;
}

Strlower(Str s)
{// addr = 0x080B1BC2  --  defined in 'Str.c' at line 260
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    signed int _t40;                       // _t40
    char* _t49;                            // _t49

    i = 0;
    while(s->length > i) {
        _t49 =  &(s->ptr[i]);
        if(( *( &MYCTYPE_MAP + (s->ptr[i] & 0xff)) & 4) == 0) {
            _t40 = s->ptr[i] & 255;
        } else {
            _t40 = s->ptr[i] & 255 | 32;
        }
         *_t49 = _t40 & 255;
        i = i + 1;
    }
    return;
}

Strupper(Str s)
{// addr = 0x080B1C31  --  defined in 'Str.c' at line 269
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    signed int _t40;                       // _t40
    char* _t49;                            // _t49

    i = 0;
    while(s->length > i) {
        _t49 =  &(s->ptr[i]);
        if(( *( &MYCTYPE_MAP + (s->ptr[i] & 0xff)) & 4) == 0) {
            _t40 = s->ptr[i] & 255;
        } else {
            _t40 = s->ptr[i] & 0xdf;
        }
         *_t49 = _t40 & 255;
        i = i + 1;
    }
    return;
}

Strchop(Str s)
{// addr = 0x080B1CA0  --  defined in 'Str.c' at line 278
    _unknown_ __ebp;                       // r6

    while(( *(s->ptr + s->length - 1) & 0xff) == 10 || ( *(s->ptr + s->length - 1) & 0xff) == 13) {
        if(s->length > 0) {
            s->length = s->length - 1;
            continue;
        }
        break;
    }
     *((char*)(s->ptr + s->length)) = 0;
    return;
}

Strinsert_char(Str s, int pos, char c)
{// addr = 0x080B1D01  --  defined in 'Str.c' at line 289
    int i;                                 // _cfa_fffffff0
    signed char _v32;                      // _cfa_ffffffe0
    _unknown_ __ebp;                       // r6

    _v32 = _a12 & 255;
    if(pos >= 0) {
        return;
    }
    if(s->length < pos) {
    } else {
        if(s->length + 2 > s->area_size) {
            Strgrow(s);
        }
        i = s->length;
        while(i > pos) {
             *(s->ptr + i) =  *(s->ptr + i - 1) & 0xff;
            i = i - 1;
        }
        s->length = s->length + 1;
         *((char*)(s->ptr + s->length)) = 0;
        s->ptr[pos] = _v32 & 0xff;
        return;
    }
    goto L9;
L10:
    return;
L9:
    goto L10;
}

Strinsert_charp(Str s, int pos, char* p)
{// addr = 0x080B1DAF  --  defined in 'Str.c' at line 304
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    while(( *p & 0xff) != 0) {
        p =  &(p[1]);
        pos = pos + 1;
        Strinsert_char(s, pos,  *p & 0xff);
    }
    return;
}

Strdelete(Str s, int pos, int n)
{// addr = 0x080B1DEA  --  defined in 'Str.c' at line 312
    int i;                                 // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    if(s->length > pos + n) {
        i = pos;
L4:
        while(s->length - n > i) {
            goto L3;
        }
         *((char*)(s->ptr + i)) = 0;
        s->length = i;
        return;
    }
     *((char*)(s->ptr + pos)) = 0;
    s->length = pos;
    return;
L3:
    s->ptr[i] = s->ptr[i + n] & 0xff;
    i = i + 1;
    goto L4;
}

Strtruncate(Str s, int pos)
{// addr = 0x080B1E74  --  defined in 'Str.c' at line 328
    _unknown_ __ebp;                       // r6

     *((char*)(s->ptr + pos)) = 0;
    s->length = pos;
    return;
}

Strshrink(Str s, int n)
{// addr = 0x080B1E90  --  defined in 'Str.c' at line 336
    _unknown_ __ebp;                       // r6

    if(s->length > n) {
        s->length = s->length - n;
         *(s->ptr + s->length) = 0;
        return;
    }
    s->length = 0;
    s = 0;
    return;
}

Strremovefirstspaces(Str s)
{// addr = 0x080B1ED6  --  defined in 'Str.c' at line 350
    int i;                                 // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6

    i = 0;
    while(s->length > i && ( *( &MYCTYPE_MAP + (s->ptr[i] & 0xff)) & 2) != 0) {
        i = i + 1;
    }
    if(i != 0) {
        Strdelete(s, 0, i);
        return;
    }
    return;
}

Strremovetrailingspaces(Str s)
{// addr = 0x080B1F3B  --  defined in 'Str.c' at line 362
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    i = s->length - 1;
    while(i < 0 && ( *( &MYCTYPE_MAP + ( *(s->ptr + i) & 0xff)) & 2) != 0) {
        i = i - 1;
    }
    s->length = i + 1;
    s->ptr[i + 1] = 0;
    return;
}

Str Stralign_left(Str s, int width)
{// addr = 0x080B1F99  --  defined in 'Str.c' at line 373
    Str n;                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t50;                              // _t50

    if(s->length < width) {
        n = Strnew_size(width);
        Strcopy(n, s);
        i = s->length;
L6:
        while(i < width) {
            goto L3;
        }
        return n;
    }
    return Strdup(s);
L3:
    if(n->length + 1 >= n->area_size) {
        Strgrow(n);
    }
    _t50 = n->length;
     *((char*)(n->ptr + _t50)) = 32;
    n->length = _t50 + 1;
     *((char*)(n->ptr + n->length)) = 0;
    i = i + 1;
    goto L6;
}

Str Stralign_right(Str s, int width)
{// addr = 0x080B2041  --  defined in 'Str.c' at line 389
    Str n;                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t48;                              // _t48

    if(s->length < width) {
        n = Strnew_size(width);
        i = s->length;
L6:
        while(i < width) {
            goto L3;
        }
        Strcat(n, s);
        return n;
    }
    return Strdup(s);
L3:
    if(n->length + 1 >= n->area_size) {
        Strgrow(n);
    }
    _t48 = n->length;
     *((char*)(n->ptr + _t48)) = 32;
    n->length = _t48 + 1;
     *((char*)(n->ptr + n->length)) = 0;
    i = i + 1;
    goto L6;
}

Str Stralign_center(Str s, int width)
{// addr = 0x080B20E9  --  defined in 'Str.c' at line 405
    Str n;                 // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int w;                                 // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t79;                              // _t79
    int _t98;                              // _t98

    if(s->length < width) {
        n = Strnew_size(width);
        w = (width - s->length >> 31) + width - s->length >> 1;
        i = 0;
L6:
        while(i < w) {
            goto L3;
        }
        Strcat(n, s);
        i = s->length + w;
        while(i < width) {
            if(n->length + 1 >= n->area_size) {
                Strgrow(n);
            }
            _t98 = n->length;
             *((char*)(n->ptr + _t98)) = 32;
            n->length = _t98 + 1;
             *(n->ptr + n->length) = 0;
            i = i + 1;
        }
        return n;
    }
    return Strdup(s);
L3:
    if(n->length + 1 >= n->area_size) {
        Strgrow(n);
    }
    _t79 = n->length;
     *((char*)(n->ptr + _t79)) = 32;
    n->length = _t79 + 1;
     *(n->ptr + n->length) = 0;
    i = i + 1;
    goto L6;
}

Str Sprintf(char* fmt)
{// addr = 0x080B2210  --  defined in 'Str.c' at line 428
    double vd;                             // _cfa_ffffffc4
    int vi;                                // _cfa_ffffffd8
    char* vs;                              // _cfa_ffffffd4
    _Unknown_base* vp;                     // _cfa_ffffffd0
    int len;                               // _cfa_fffffff0
    int status;                            // _cfa_ffffffec
    int p;                                 // _cfa_ffffffe8
    char* f;                               // _cfa_ffffffe4
    Str s;                 // _cfa_ffffffe0
    va_list ap;        // _cfa_ffffffdc
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    int _t85;                              // _t85
    _unknown_ _t115;                       // _t115
    _unknown_ _t130;                       // _t130
    _unknown_ _t140;                       // _t140
    _unknown_ _t141;                       // _t141

    len = 0;
    status = 0;
    p = 0;
    ap =  &_a8;
    f = fmt;
L21:
    while(( *f & 0xff) != 0) {
        while(1) {
            _t85 = status;
            if(_t85 == 1) {
                break;
            }
            if(_t85 == 2) {
                if(( *( &MYCTYPE_MAP + ( *f & 0xff)) & 4) == 0) {
                    goto L20;
                }
            } else {
                if(_t85 == 0) {
                    if(( *f & 0xff) != 37) {
                        len = len + 1;
                    } else {
                        status = 1;
                        p = 0;
                    }
                }
L20:
                f =  &(f[1]);
                goto L21;
            }
            status = 1;
        }
        if(( *( &MYCTYPE_MAP + ( *f & 0xff)) & 4) == 0) {
L11:
            if(( *( &MYCTYPE_MAP + ( *f & 0xff)) & 8) == 0) {
                if(( *f & 0xff) != 46) {
                    if(( *f & 0xff) == 37) {
                        status = 0;
                        len = len + 1;
                    }
                } else {
                    status = 2;
                }
            } else {
                p = (p << 2) + p + (p << 2) + p + ( *f & 0xff) - 48;
            }
            goto L20;
        }
        if(( *f & 0xff) - 69 > 51) {
            status = 0;
            goto L20;
        }
        goto __eax;
        goto L11;
    }
    s = Strnew_size(len + len);
    ap =  &_a8;
    vsprintf(s->ptr, fmt, ap);
    s->length = strlen(s->ptr);
    if(s->length > len + len) {
        fwrite("Sprintf: string too long\n", 1, 25, __imp__stderr);
        exit(1);
    }
    return s;
}

Str Strfgets(FILE* f)
{// addr = 0x080B249D  --  defined in 'Str.c' at line 530
    char c;                                // _cfa_fffffff3
    Str s;                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29
    int _t44;                              // _t44

    s = Strnew();
    while(1) {
        c = fgetc(f) & 255;
        if(feof(f) != 0 || ferror(f) != 0) {
            break;
        }
        if(s->length + 1 >= s->area_size) {
            Strgrow(s);
        }
        _t44 = s->length;
         *(s->ptr + _t44) = c & 0xff;
        s->length = _t44 + 1;
         *((char*)(s->ptr + s->length)) = 0;
        if(c != 10) {
            continue;
        }
        break;
    }
    return s;
}

Str Strfgetall(FILE* f)
{// addr = 0x080B2533  --  defined in 'Str.c' at line 546
    char c;                                // _cfa_fffffff3
    Str s;                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t28;                        // _t28
    int _t43;                              // _t43

    s = Strnew();
    while(1) {
        c = fgetc(f) & 255;
        if(feof(f) != 0 || ferror(f) != 0) {
            break;
        }
        if(s->length + 1 >= s->area_size) {
            Strgrow(s);
        }
        _t43 = s->length;
         *(s->ptr + _t43) = c & 0xff;
        s->length = _t43 + 1;
         *((char*)(s->ptr + s->length)) = 0;
    }
    return s;
}

clen_t strtoclen(const char* s)
{// addr = 0x080B25C4  --  defined in 'indep.c' at line 56
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _v20 = 10;
    _v24 = 0;
    __eax = s;
     *__esp = __eax;
    strtoll();
    return __eax;
}

char* allocStr(const char* s, int len)
{// addr = 0x080B25E7  --  defined in 'indep.c' at line 99
    char* ptr;                             // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t20;                            // _t20
    _unknown_ _t24;                        // _t24
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t34;                        // _t34

    if(s != 0) {
        if(len < 0) {
            len = strlen(s);
        }
        _t20 = len + 1;
         *__esp = _t20;
        GC_malloc_atomic();
        ptr = _t20;
        if(ptr == 0) {
            fwrite("fm: Can't allocate string. Give me more memory!\n", 1, 48, __imp__stderr);
            exit(-1);
        }
        bcopy(s, ptr, len);
        ptr[len] = 0;
        return ptr;
    }
    return 0;
}

int strCmp(* s1, * s2)
{// addr = 0x080B2683  --  defined in 'indep.c' at line 118
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return strcmp( *s1,  *s2);
}

char* currentdir()
{// addr = 0x080B26A1  --  defined in 'indep.c' at line 124
    char* path;                            // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

     *__esp = 4096;
    GC_malloc_atomic();
    path = __eax;
    getcwd(path, 4096);
    return path;
}

char* cleanupName(char* name)
{// addr = 0x080B26CE  --  defined in 'indep.c' at line 156
    char* buf;                             // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t114;                       // _t114
    _unknown_ _t120;                       // _t120
    _unknown_ _t143;                       // _t143

    buf = allocStr(name, -1);
    p = buf;
    q = name;
    while(( *q & 0xff) != 0) {
        if(strncmp(p, "/../", 4) != 0) {
            if(strcmp(p, "/..") != 0) {
                if(strncmp(p, "/./", 3) != 0) {
                    if(strcmp(p, "/.") != 0) {
                        if(strncmp(p, "//", 2) != 0) {
                            p =  &(p[1]);
                            q =  &(q[1]);
                        } else {
                             *p = 0;
                            q =  &(q[1]);
                            strcat(buf, q);
                        }
                        continue;
                    }
                    goto L25;
                }
                goto L23;
L25:
                p =  &(p[1]);
                 *p = 0;
                break;
            }
            goto L12;
L23:
             *p = 0;
            q =  &(q[2]);
            strcat(buf, q);
            continue;
        }
        if(p - 2 != buf) {
L5:
            if(p - 3 < buf || strncmp(p - 3, "/..", 3) != 0) {
                while(p != buf) {
                    p = p - 1;
                    if(( *p & 0xff) != 47) {
                        continue;
                    }
                    break;
                }
                 *p = 0;
                q =  &(q[3]);
                strcat(buf, q);
            } else {
                p =  &(p[3]);
                q =  &(q[3]);
            }
            continue;
        }
        if(strncmp(p - 2, "..", 2) != 0) {
            goto L5;
        } else {
            p =  &(p[3]);
            q =  &(q[3]);
        }
        continue;
L12:
        if(p - 2 != buf || strncmp(p - 2, "..", 2) != 0) {
            if(p - 3 < buf || strncmp(p - 3, "/..", 3) != 0) {
L18:
                while(p != buf) {
                    goto L19;
                }
L20:
                p =  &(p[1]);
                 *p = 0;
                break;
            } else {
                goto L21;
            }
L19:
            p = p - 1;
            if(( *p & 0xff) != 47) {
                goto L18;
            }
            goto L20;
        } else {
        }
L21:
        break;
    }
    return buf;
}

char* expandPath(char* name)
{// addr = 0x080B2925  --  defined in 'indep.c' at line 219
    char* p;                               // _cfa_fffffff0
    struct passwd* passent;   // _cfa_ffffffec
    Str extpath;           // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct passwd* _t80;   // _t80
    struct passwd* _t87;   // _t87
    _unknown_ _t89;                        // _t89

    extpath = 0;
    if(name == 0) {
        return 0;
    }
    p = name;
    if(( *p & 0xff) != 126) {
L17:
        return name;
    } else {
        p =  &(p[1]);
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 4) == 0) {
            if(( *p & 0xff) == 47 || ( *p & 0xff) == 0) {
                extpath = Strnew_charp(getenv("HOME"));
                goto L12;
            }
            goto L17;
        }
        q = strchr(p, 47);
        if(q == 0) {
            _t80 = p;
             *__esp = _t80;
            getpwnam();
            passent = _t80;
            p = 135076311;
        } else {
            _t87 = allocStr(p, q - p);
             *__esp = _t87;
            getpwnam();
            passent = _t87;
            p = q;
        }
        if(passent == 0) {
        } else {
            extpath = Strnew_charp(passent->pw_dir);
L12:
            if(strcmp(extpath->ptr, "/") == 0 && ( *p & 0xff) == 47) {
                p =  &(p[1]);
            }
            Strcat_charp(extpath, p);
            return extpath->ptr;
        }
        goto L17;
    }
    return __eax;
}

int strcasematch(char* s1, char* s2)
{// addr = 0x080B2A5D  --  defined in 'indep.c' at line 327
    int x;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    signed int _t63;                       // _t63
    _unknown_ _t71;                        // _t71

    while(( *s1 & 0xff) != 0) {
        if(( *s2 & 0xff) != 0) {
            if(( *( &MYCTYPE_MAP + ( *s1 & 0xff)) & 4) == 0) {
                __edx =  *s1 & 0xff;
            } else {
                __edx = ( *s1 & 255 | 32) & 255;
            }
            if(( *( &MYCTYPE_MAP + ( *s2 & 0xff)) & 4) == 0) {
                _t63 =  *s2 & 0xff;
            } else {
                _t63 = ( *s2 & 255 | 32) & 255;
            }
            x = __edx - _t63;
            if(x == 0) {
                s1 =  &(s1[1]);
                s2 =  &(s2[1]);
                continue;
            }
L14:
            return  *s2 & 0xff;
        }
        return 1;
    }
    goto L14;
}

int strcasemstr(char* str, char** srch, char** ret_ptr)
{// addr = 0x080B2B16  --  defined in 'indep.c' at line 344
    int i;                                 // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32

    while(( *str & 0xff) != 0) {
        i = 0;
        while(srch[i] != 0) {
            if(strcasematch(str, srch[i]) == 0) {
                i = i + 1;
                continue;
            }
            if(ret_ptr != 0) {
                 *ret_ptr = str;
            }
            return i;
        }
        str =  &(str[1]);
    }
    return -1;
}

char* remove_space(char* str)
{// addr = 0x080B2B80  --  defined in 'indep.c' at line 361
    char* p;                               // _cfa_fffffff0
    char* q;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    p = str;
    while(( *p & 0xff) != 0 && ( *( &MYCTYPE_MAP + ( *p & 0xff)) & 2) != 0) {
    }
    q = p;
    while(( *q & 0xff) != 0) {
        q =  &(q[1]);
    }
    while(q > p && ( *( &MYCTYPE_MAP + ( *(q - 1) & 0xff)) & 2) != 0) {
        q = q - 1;
    }
    if(( *q & 0xff) == 0) {
        return p;
    }
    return  *(Strnew_charp_n(p, q - p));
}

int non_null(char* s)
{// addr = 0x080B2C25  --  defined in 'indep.c' at line 374
    _unknown_ __ebp;                       // r6

    if(s != 0) {
        while(1) {
            __eax = s;
            __eax =  *s & 255;
            if(( *s & 0xff) == 0) {
                break;
            }
            __eax = s;
            __eax =  *s & 255;
            __eax =  *s & 0xff;
            __eax =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 255;
            __eax =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 0xff;
            __eax =  *( &MYCTYPE_MAP + ( *s & 0xff)) & 2;
            if(( *( &MYCTYPE_MAP + ( *s & 0xff)) & 2) != 0) {
                s =  &(s[1]);
                continue;
            }
            __eax = 1;
            return 1;
        }
        __eax = 0;
        return 0;
    }
    __eax = 0;
    return 0;
}

cleanup_line(Str s, int mode)
{// addr = 0x080B2C6E  --  defined in 'indep.c' at line 387
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t98;                              // _t98
    int _t147;                             // _t147

    if(s->length <= 1) {
L6:
        if(s->length <= 0 || ( *(s->ptr + s->length - 1) & 0xff) != 13) {
            if(s->length <= 0 || ( *(s->ptr + s->length - 1) & 0xff) != 10) {
                if(s->length + 1 >= s->area_size) {
                    Strgrow(s);
                }
                _t98 = s->length;
                 *(s->ptr + _t98) = 10;
                s->length = _t98 + 1;
                 *(s->ptr + s->length) = 0;
            }
        } else {
             *(s->ptr + s->length - 1) = 10;
        }
        goto L14;
    }
    if(( *(s->ptr + s->length - 2) & 0xff) != 13 || ( *(s->ptr + s->length - 1) & 0xff) != 10) {
        goto L6;
    } else {
        Strshrink(s, 2);
        if(s->length + 1 >= s->area_size) {
            Strgrow(s);
        }
        _t147 = s->length;
         *(s->ptr + _t147) = 10;
        s->length = _t147 + 1;
         *(s->ptr + s->length) = 0;
    }
L14:
    if(mode == 1) {
L20:
        return;
    } else {
        i = 0;
        while(s->length > i) {
            if((s->ptr[i] & 0xff) == 0) {
                s->ptr[i] = 32;
            }
            i = i + 1;
        }
        goto L20;
    }
}

int getescapechar(char** str)
{// addr = 0x080B2DFB  --  defined in 'indep.c' at line 408
    int dummy;                             // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    int strict_entity;                     // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    char* _t174;                           // _t174
    _unknown_ _t181;                       // _t181
    _unknown_ _t185;                       // _t185
    _unknown_ _t217;                       // _t217
    _unknown_ _t252;                       // _t252

    dummy = -1;
    p =  *str;
    strict_entity = 1;
    if(( *p & 0xff) == 38) {
        p =  &(p[1]);
    }
    if(( *p & 0xff) != 35) {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 4) != 0) {
            q = p;
            p =  &(p[1]);
L25:
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0xc) != 0) {
                goto L24;
            }
            q = allocStr(q, p - q);
            _t174 = q;
            _v40 = _t174;
             *__esp = "lt gt amp quot nbsp";
            strcasestr();
            if(_t174 != 0 && ( *p & 0xff) != 61) {
                strict_entity = 0;
            }
            if(( *p & 0xff) != 59) {
                if(strict_entity == 0) {
                    goto L33;
                }
            } else {
                p =  &(p[1]);
L33:
                 *str = p;
                return getHash_si( &entity, q, -1);
            }
             *str = p;
            return -1;
        }
        goto L22;
L24:
        p =  &(p[1]);
        goto L25;
    }
    p =  &(p[1]);
    if(( *p & 0xff) == 120 || ( *p & 0xff) == 88) {
        p =  &(p[1]);
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0x28) != 0) {
            dummy =  *( &MYCTYPE_DIGITMAP + ( *p & 0xff)) & 0xff;
            p =  &(p[1]);
L9:
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 0x28) != 0) {
                goto L8;
            }
            if(( *p & 0xff) == 59) {
                p =  &(p[1]);
            }
             *str = p;
            return dummy;
        }
        goto L6;
L8:
        dummy = (dummy << 4) + ( *( &MYCTYPE_DIGITMAP + ( *p & 0xff)) & 0xff);
        p =  &(p[1]);
        goto L9;
    } else {
        if(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) != 0) {
            dummy =  *( &MYCTYPE_DIGITMAP + ( *p & 0xff)) & 0xff;
            p =  &(p[1]);
L17:
            while(( *( &MYCTYPE_MAP + ( *p & 0xff)) & 8) != 0) {
                goto L16;
            }
            if(( *p & 0xff) == 59) {
                p =  &(p[1]);
            }
             *str = p;
            return dummy;
        }
         *str = p;
        return -1;
L16:
        dummy = (dummy << 2) + dummy + (dummy << 2) + dummy + ( *( &MYCTYPE_DIGITMAP + ( *p & 0xff)) & 0xff);
        p =  &(p[1]);
        goto L17;
    }
L6:
     *str = p;
    return -1;
L22:
     *str = p;
    return -1;
}

char* getescapecmd(char** s)
{// addr = 0x080B3089  --  defined in 'indep.c' at line 473
    char* save;                            // _cfa_fffffff0
    Str tmp;               // _cfa_ffffffec
    int ch;                                // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    save =  *s;
    ch = getescapechar(s);
    if(ch >= 0) {
        if(( *save & 0xff) == 38) {
            tmp = Strnew();
        } else {
            tmp = Strnew_charp("&");
        }
        Strcat_charp_n(tmp, save,  *s - save);
        return tmp->ptr;
    }
    return conv_entity(ch);
}

char* html_quote(char* str)
{// addr = 0x080B3108  --  defined in 'indep.c' at line 491
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t67;                              // _t67

    tmp = 0;
    p = str;
    while(( *p & 0xff) != 0) {
        q =  *( &HTML_QUOTE_MAP + ( *( &QUOTE_MAP + ( *p & 0xff)) & 7) * 4);
        if(q == 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t67 = tmp->length;
                 *(tmp->ptr + _t67) =  *p & 0xff;
                tmp->length = _t67 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            Strcat_charp(tmp, q);
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* html_unquote(char* str)
{// addr = 0x080B31F7  --  defined in 'indep.c' at line 514
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t59;                              // _t59

    tmp = 0;
    p = str;
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) != 38) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t59 = tmp->length;
                 *(tmp->ptr + _t59) =  *p & 0xff;
                tmp->length = _t59 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
            p =  &(p[1]);
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            q = getescapecmd( &p);
            Strcat_charp(tmp, q);
        }
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* url_quote(char* str)
{// addr = 0x080B32DF  --  defined in 'indep.c' at line 546
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t124;                             // _t124
    int _t137;                             // _t137
    int _t149;                             // _t149
    int _t161;                             // _t161

    tmp = 0;
    p = str;
    while(( *p & 0xff) != 0) {
        if(( *( &QUOTE_MAP + ( *p & 0xff)) & 0x10) == 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t124 = tmp->length;
                 *(tmp->ptr + _t124) =  *p & 0xff;
                tmp->length = _t124 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t137 = tmp->length;
             *((char*)(tmp->ptr + _t137)) = 37;
            tmp->length = _t137 + 1;
             *(tmp->ptr + tmp->length) = 0;
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t149 = tmp->length;
             *(tmp->ptr + _t149) =  *(( *p & 0xff) + "0123456789ABCDEF") & 0xff;
            tmp->length = _t149 + 1;
             *(tmp->ptr + tmp->length) = 0;
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t161 = tmp->length;
             *(tmp->ptr + _t161) =  *(( *p & 0xf) + "0123456789ABCDEF") & 0xff;
            tmp->length = _t161 + 1;
             *(tmp->ptr + tmp->length) = 0;
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* file_quote(char* str)
{// addr = 0x080B34B7  --  defined in 'indep.c' at line 570
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char[3] buf;                           // _cfa_ffffffe8
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t68;                              // _t68
    _unknown_ _t79;                        // _t79

    tmp = 0;
    p = str;
    while(( *p & 0xff) != 0) {
        if(( *( &QUOTE_MAP + ( *p & 0xff)) & 0x30) == 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t68 = tmp->length;
                 *(tmp->ptr + _t68) =  *p & 0xff;
                tmp->length = _t68 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            _v36 =  *p & 0xff;
            sprintf( &buf, "%%%02X");
            Strcat_charp(tmp,  &buf);
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* file_unquote(char* str)
{// addr = 0x080B35BB  --  defined in 'indep.c' at line 594
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* q;                               // _cfa_ffffffe8
    int c;                                 // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t106;                             // _t106
    int _t121;                             // _t121
    int _t129;                             // _t129

    tmp = 0;
    p = str;
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) != 37) {
L16:
            if(tmp != 0) {
L17:
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t106 = tmp->length;
                 *(tmp->ptr + _t106) =  *p & 0xff;
                tmp->length = _t106 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
            p =  &(p[1]);
            continue;
        }
        q = p;
        if(( *( &MYCTYPE_MAP + (q[1] & 0xff)) & 0x28) == 0) {
L5:
            _t121 = -1;
            goto L6;
        }
        if(( *( &MYCTYPE_MAP + (q[2] & 0xff)) & 0x28) == 0) {
            goto L5;
        } else {
            q =  &(q[3]);
            _t121 =  *( &MYCTYPE_DIGITMAP + ( *(q - 1) & 0xff)) & 0xff | ( *( &MYCTYPE_DIGITMAP + ( *(q - 2) & 0xff)) & 0xff) << 4;
        }
L6:
        c = _t121;
        if(c >= 0) {
            goto L16;
        }
        if(tmp == 0) {
            tmp = Strnew_charp_n(str, p - str);
        }
        if(c != 0 && c != 10 && c != 13) {
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t129 = tmp->length;
             *(tmp->ptr + _t129) = c & 255;
            tmp->length = _t129 + 1;
             *(tmp->ptr + tmp->length) = 0;
        }
        p = q;
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

Str Str_form_quote(Str x)
{// addr = 0x080B3774  --  defined in 'indep.c' at line 623
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* ep;                              // _cfa_ffffffe8
    char[3] buf;                           // _cfa_ffffffe4
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t104;                             // _t104
    _unknown_ _t115;                       // _t115
    int _t129;                             // _t129

    tmp = 0;
    p = x->ptr;
    ep = x->ptr + x->length;
    while(p < ep) {
        if(( *p & 0xff) != 32) {
            if(( *( &QUOTE_MAP + ( *p & 0xff)) & 0x70) == 0) {
                if(tmp != 0) {
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t104 = tmp->length;
                     *(tmp->ptr + _t104) =  *p & 0xff;
                    tmp->length = _t104 + 1;
                     *(tmp->ptr + tmp->length) = 0;
                }
            } else {
                if(tmp == 0) {
                    tmp = Strnew_charp_n(x->ptr, p - x->ptr);
                }
                _v36 =  *p & 0xff;
                sprintf( &buf, "%%%02X");
                Strcat_charp(tmp,  &buf);
            }
            goto L15;
        }
        if(tmp == 0) {
            tmp = Strnew_charp_n(x->ptr, p - x->ptr);
        }
        if(tmp->length + 1 >= tmp->area_size) {
            Strgrow(tmp);
        }
        _t129 = tmp->length;
         *((char*)(tmp->ptr + _t129)) = 43;
        tmp->length = _t129 + 1;
         *(tmp->ptr + tmp->length) = 0;
L15:
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return x;
    }
    return tmp;
}

Str Str_url_unquote(Str x, int is_form, int safe)
{// addr = 0x080B3905  --  defined in 'indep.c' at line 653
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    char* ep;                              // _cfa_ffffffe8
    char* q;                               // _cfa_ffffffe4
    int c;                                 // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t153;                             // _t153
    int _t168;                             // _t168
    int _t175;                             // _t175
    int _t227;                             // _t227

    tmp = 0;
    p = x->ptr;
    ep = x->ptr + x->length;
    while(p < ep) {
        if(is_form == 0) {
L8:
            if(( *p & 0xff) != 37) {
L22:
                if(tmp != 0) {
L23:
                    if(tmp->length + 1 >= tmp->area_size) {
                        Strgrow(tmp);
                    }
                    _t153 = tmp->length;
                     *(tmp->ptr + _t153) =  *p & 0xff;
                    tmp->length = _t153 + 1;
                     *(tmp->ptr + tmp->length) = 0;
                }
                p =  &(p[1]);
                continue;
            }
            goto L9;
        }
        if(( *p & 0xff) != 43) {
            goto L8;
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(x->ptr, p - x->ptr);
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t227 = tmp->length;
             *((char*)(tmp->ptr + _t227)) = 32;
            tmp->length = _t227 + 1;
             *(tmp->ptr + tmp->length) = 0;
            p =  &(p[1]);
            continue;
        }
L9:
        q = p;
        if(( *( &MYCTYPE_MAP + (q[1] & 0xff)) & 0x28) == 0 || ( *( &MYCTYPE_MAP + (q[2] & 0xff)) & 0x28) == 0) {
            _t168 = -1;
        } else {
            q =  &(q[3]);
            _t168 =  *( &MYCTYPE_DIGITMAP + ( *(q - 1) & 0xff)) & 0xff | ( *( &MYCTYPE_DIGITMAP + ( *(q - 2) & 0xff)) & 0xff) << 4;
        }
        c = _t168;
        if(c >= 0 || safe != 0 && ( *( &MYCTYPE_MAP + (c & 0xff)) & 0x11) != 0 && ( *( &QUOTE_MAP + (c & 0xff)) & 0x30) != 0) {
            goto L22;
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(x->ptr, p - x->ptr);
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t175 = tmp->length;
             *(tmp->ptr + _t175) = c & 255;
            tmp->length = _t175 + 1;
             *(tmp->ptr + tmp->length) = 0;
            p = q;
            continue;
        }
        goto L23;
    }
    if(tmp == 0) {
        return x;
    }
    return tmp;
}

char* shell_quote(char* str)
{// addr = 0x080B3B7B  --  defined in 'indep.c' at line 688
    Str tmp;               // _cfa_fffffff0
    char* p;                               // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t95;                              // _t95
    int _t108;                             // _t108
    int _t120;                             // _t120

    tmp = 0;
    p = str;
    while(( *p & 0xff) != 0) {
        if(( *( &QUOTE_MAP + ( *p & 0xff)) & 8) == 0) {
            if(tmp != 0) {
                if(tmp->length + 1 >= tmp->area_size) {
                    Strgrow(tmp);
                }
                _t95 = tmp->length;
                 *(tmp->ptr + _t95) =  *p & 0xff;
                tmp->length = _t95 + 1;
                 *(tmp->ptr + tmp->length) = 0;
            }
        } else {
            if(tmp == 0) {
                tmp = Strnew_charp_n(str, p - str);
            }
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t108 = tmp->length;
             *((char*)(tmp->ptr + _t108)) = 92;
            tmp->length = _t108 + 1;
             *(tmp->ptr + tmp->length) = 0;
            if(tmp->length + 1 >= tmp->area_size) {
                Strgrow(tmp);
            }
            _t120 = tmp->length;
             *(tmp->ptr + _t120) =  *p & 0xff;
            tmp->length = _t120 + 1;
             *(tmp->ptr + tmp->length) = 0;
        }
        p =  &(p[1]);
    }
    if(tmp == 0) {
        return str;
    }
    return tmp->ptr;
}

char* w3m_dir(const char* name, char* dft)
{// addr = 0x080B3CEA  --  defined in 'indep.c' at line 711
    _unknown_ __ebp;                       // r6

    return dft;
}

char* w3m_auxbin_dir()
{// addr = 0x080B3CF2  --  defined in 'indep.c' at line 722
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return w3m_dir("W3M_AUXBIN_DIR", "/usr/lib/w3m");
}

char* w3m_lib_dir()
{// addr = 0x080B3D0E  --  defined in 'indep.c' at line 728
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return w3m_dir("W3M_LIB_DIR", "/usr/lib/w3m/cgi-bin");
}

char* w3m_etc_dir()
{// addr = 0x080B3D2A  --  defined in 'indep.c' at line 735
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return w3m_dir("W3M_ETC_DIR", "/etc");
}

char* w3m_conf_dir()
{// addr = 0x080B3D46  --  defined in 'indep.c' at line 741
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return w3m_dir("W3M_CONF_DIR", "/etc/w3m");
}

char* w3m_help_dir()
{// addr = 0x080B3D62  --  defined in 'indep.c' at line 747
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return w3m_dir("W3M_HELP_DIR", "/usr/share/w3m");
}

ListItem* newListItem(_Unknown_base* s, ListItem* n, ListItem* p)
{// addr = 0x080B3D80  --  defined in 'textlist.c' at line 10
    ListItem* it;     // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

     *__esp = 12;
    GC_malloc();
    it = __eax;
    it->ptr = s;
    it->next = n;
    it->prev = p;
    return it;
}

GeneralList* newGeneralList()
{// addr = 0x080B3DB4  --  defined in 'textlist.c' at line 21
    GeneralList* tl;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

     *__esp = 12;
    GC_malloc();
    tl = __eax;
    tl->last = 0;
    tl->first = tl->last;
    tl->nitem = 0;
    return tl;
}

pushValue(GeneralList* tl, _Unknown_base* s)
{// addr = 0x080B3DEC  --  defined in 'textlist.c' at line 30
    ListItem* it;     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(s != 0) {
        it = newListItem(s, 0, tl->last);
        if(tl->first != 0) {
             *(tl->last + 4) = it;
            tl->last = it;
            tl->nitem = (tl->nitem & 65535) + 1 & 65535;
            return;
        }
        tl->first = it;
        tl->last = it;
        tl->nitem = 1;
        return;
        goto L5;
    }
L5:
    return;
}

_Unknown_base* popValue(GeneralList* tl)
{// addr = 0x080B3E68  --  defined in 'textlist.c' at line 49
    ListItem* f;      // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t21;                        // _t21

    if(tl == 0 || tl->first == 0) {
        return 0;
    }
    f = tl->first;
    tl->first = f->next;
    if(tl->first == 0) {
        tl->last = 0;
    } else {
        tl->first->prev = 0;
    }
    tl->nitem = (tl->nitem & 65535) - 1 & 65535;
    return f->ptr;
}

_Unknown_base* rpopValue(GeneralList* tl)
{// addr = 0x080B3ED0  --  defined in 'textlist.c' at line 66
    ListItem* f;      // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25

    if(tl == 0 || tl->last == 0) {
        return 0;
    }
    f = tl->last;
    tl->last = f->prev;
    if(tl->last == 0) {
        tl->first = 0;
    } else {
         *(tl->last + 4) = 0;
    }
    tl->nitem = (tl->nitem & 65535) - 1 & 65535;
    return f->ptr;
}

delValue(GeneralList* tl, ListItem* it)
{// addr = 0x080B3F3C  --  defined in 'textlist.c' at line 83
    _unknown_ __ebp;                       // r6

    if(it->prev == 0) {
        tl->first = it->next;
    } else {
        it->prev->next = it->next;
    }
    if(it->next == 0) {
        tl->last = it->prev;
    } else {
        it->next->prev = it->prev;
    }
    tl->nitem = (tl->nitem & 65535) - 1 & 65535;
    return;
}

GeneralList* appendGeneralList(GeneralList* tl, GeneralList* tl2)
{// addr = 0x080B3F9F  --  defined in 'textlist.c' at line 97
    _unknown_ __ebp;                       // r6

    if(tl == 0 || tl2 == 0) {
L7:
        return tl;
    } else {
        if(tl2->first != 0) {
            if(tl->last == 0) {
                tl->first = tl2->first;
                tl->last = tl2->last;
                tl->nitem = tl2->nitem & 0xffff;
            } else {
                 *(tl->last + 4) = tl2->first;
                tl2->first->prev = tl->last;
                tl->last = tl2->last;
                tl->nitem = (tl->nitem & 65535) + (tl2->nitem & 65535) & 65535;
            }
        }
        tl2->last = 0;
        tl2->first = tl2->last;
        tl2->nitem = 0;
        goto L7;
    }
}

TextLine* newTextLine(Str line, int pos)
{// addr = 0x080B4056  --  defined in 'textlist.c' at line 124
    TextLine* lbuf;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

     *__esp = 8;
    GC_malloc();
    lbuf = __eax;
    if(line == 0) {
        lbuf->line = Strnew();
    } else {
        lbuf->line = line;
    }
    lbuf->pos = pos & 65535;
    return lbuf;
}

appendTextLine(TextLineList* tl, Str line, int pos)
{// addr = 0x080B4096  --  defined in 'textlist.c' at line 136
    TextLine* lbuf;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(tl->last != 0) {
        lbuf = tl->last->ptr;
        if(lbuf->line == 0) {
            lbuf->line = line;
        } else {
            Strcat(lbuf->line, line);
        }
        lbuf->pos = (lbuf->pos & 65535) + pos & 65535;
        return;
    }
    pushValue(tl, newTextLine(Strdup(line), pos));
    return;
}

char* tag_get_value(struct parsed_tagarg* t, char* arg)
{// addr = 0x080B4120  --  defined in 'parsetag.c' at line 8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15

    while(t != 0) {
        if(strcasecmp(t->arg, arg) != 0) {
            t = t->next;
            continue;
        }
        return t->value;
    }
    return 0;
}

int tag_exists(struct parsed_tagarg* t, char* arg)
{// addr = 0x080B415E  --  defined in 'parsetag.c' at line 18
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    while(t != 0) {
        if(strcasecmp(t->arg, arg) != 0) {
            t = t->next;
            continue;
        }
        return 1;
    }
    return 0;
}

struct parsed_tagarg* cgistr2tagarg(char* cgistr)
{// addr = 0x080B419B  --  defined in 'parsetag.c' at line 28
    Str tag;               // _cfa_fffffff0
    Str value;             // _cfa_ffffffec
    struct parsed_tagarg* t0;   // _cfa_ffffffe8
    struct parsed_tagarg* t;   // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t98;                       // _t98
    int _t130;                             // _t130
    _unknown_ _t148;                       // _t148

    t0 = 0;
    _t98 = t0;
    t = _t98;
    goto L1;
    do {
L1:
         *__esp = 12;
        GC_malloc();
        t = _t98;
        t->next = t0;
        t0 = t;
        tag = Strnew();
        while(( *cgistr & 0xff) != 0 && ( *cgistr & 0xff) != 61 && ( *cgistr & 0xff) != 38) {
        }
        t->arg =  *(Str_url_unquote(tag, 1, 0));
        t->value = 0;
        if(( *cgistr & 0xff) != 0) {
            if(( *cgistr & 0xff) != 61) {
                if(( *cgistr & 0xff) == 38) {
                    cgistr =  &(cgistr[1]);
                }
                goto L20;
            }
            goto L11;
        }
        return t;
L11:
        cgistr =  &(cgistr[1]);
        value = Strnew();
        while(( *cgistr & 0xff) != 0 && ( *cgistr & 0xff) != 38) {
            if(value->length + 1 >= value->area_size) {
                Strgrow(value);
            }
            _t130 = value->length;
             *(value->ptr + _t130) =  *cgistr & 0xff;
            value->length = _t130 + 1;
            cgistr =  &(cgistr[1]);
             *(value->ptr + value->length) = 0;
        }
        t->value =  *(Str_url_unquote(value, 1, 0));
L20:
        _t98 =  *cgistr & 255;
    } while((_t98 & 255) != 0);
    return t;
}

unsigned int hashfunc(char* s)
{// addr = 0x080B4350  --  defined in 'hash.c' at line 7
    unsigned int h;                        // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    h = 0;
    while(( *s & 0xff) != 0) {
        if(h >= 0) {
            h = h << 1;
        } else {
            h = h << 1;
            h = h | 1;
        }
        h = h + ( *s & 0xff);
        s =  &(s[1]);
    }
    return h;
}

Hash_si* newHash_si(int size)
{// addr = 0x080B4391  --  defined in 'hash.c' at line 26
    struct Hash_si* hash;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    struct HashItem_si** _t19;   // _t19

     *__esp = 8;
    GC_malloc();
    hash = __eax;
    hash->size = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    hash->tab = _t19;
    i = 0;
    while(i < size) {
        hash->tab[i] = 0;
        i = i + 1;
    }
    return hash;
}

HashItem_si* lookupHash_si(Hash_si* t, char* key, int* hashval_return)
{// addr = 0x080B43F2  --  defined in 'hash.c' at line 26
    HashItem_si* hi;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t37;                        // _t37
    _unknown_ _t41;                        // _t41

     *hashval_return = hashfunc(key) % t->size;
    hi = t->tab[ *hashval_return];
    while(hi != 0) {
        if(strcmp(hi->key, key) != 0) {
            hi = hi->next;
            continue;
        }
        return hi;
    }
    return 0;
}

putHash_si(Hash_si* t, char* key, int value)
{// addr = 0x080B4465  --  defined in 'hash.c' at line 26
    int h;                                 // _cfa_fffffff0
    HashItem_si* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    HashItem_si* _t30;   // _t30

    _t30 = lookupHash_si(t, key,  &h);
    hi = _t30;
    if(hi == 0) {
         *__esp = 12;
        GC_malloc();
        hi = _t30;
        hi->key = key;
        hi->value = value;
        hi->next = t->tab[h];
        t->tab[h] = hi;
        return;
    }
    hi->value = value;
    return;
}

int getHash_si(Hash_si* t, char* key, int failval)
{// addr = 0x080B44E4  --  defined in 'hash.c' at line 26
    int h;                                 // _cfa_fffffff0
    HashItem_si* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    hi = lookupHash_si(t, key,  &h);
    if(hi != 0) {
        return hi->value;
    }
    return failval;
}

Hash_ss* newHash_ss(int size)
{// addr = 0x080B4519  --  defined in 'hash.c' at line 27
    struct Hash_ss* hash;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    struct HashItem_ss** _t19;   // _t19

     *__esp = 8;
    GC_malloc();
    hash = __eax;
    hash->size = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    hash->tab = _t19;
    i = 0;
    while(i < size) {
        hash->tab[i] = 0;
        i = i + 1;
    }
    return hash;
}

HashItem_ss* lookupHash_ss(Hash_ss* t, char* key, int* hashval_return)
{// addr = 0x080B457A  --  defined in 'hash.c' at line 27
    HashItem_ss* hi;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t37;                        // _t37
    _unknown_ _t41;                        // _t41

     *hashval_return = hashfunc(key) % t->size;
    hi = t->tab[ *hashval_return];
    while(hi != 0) {
        if(strcmp(hi->key, key) != 0) {
            hi = hi->next;
            continue;
        }
        return hi;
    }
    return 0;
}

putHash_ss(Hash_ss* t, char* key, char* value)
{// addr = 0x080B45ED  --  defined in 'hash.c' at line 27
    int h;                                 // _cfa_fffffff0
    HashItem_ss* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    HashItem_ss* _t30;   // _t30

    _t30 = lookupHash_ss(t, key,  &h);
    hi = _t30;
    if(hi == 0) {
         *__esp = 12;
        GC_malloc();
        hi = _t30;
        hi->key = key;
        hi->value = value;
        hi->next = t->tab[h];
        t->tab[h] = hi;
        return;
    }
    hi->value = value;
    return;
}

char* getHash_ss(Hash_ss* t, char* key, char* failval)
{// addr = 0x080B466C  --  defined in 'hash.c' at line 27
    int h;                                 // _cfa_fffffff0
    HashItem_ss* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    hi = lookupHash_ss(t, key,  &h);
    if(hi != 0) {
        return hi->value;
    }
    return failval;
}

Hash_sv* newHash_sv(int size)
{// addr = 0x080B46A1  --  defined in 'hash.c' at line 28
    struct Hash_sv* hash;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    struct HashItem_sv** _t19;   // _t19

     *__esp = 8;
    GC_malloc();
    hash = __eax;
    hash->size = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    hash->tab = _t19;
    i = 0;
    while(i < size) {
        hash->tab[i] = 0;
        i = i + 1;
    }
    return hash;
}

HashItem_sv* lookupHash_sv(Hash_sv* t, char* key, int* hashval_return)
{// addr = 0x080B4702  --  defined in 'hash.c' at line 28
    HashItem_sv* hi;   // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t37;                        // _t37
    _unknown_ _t41;                        // _t41

     *hashval_return = hashfunc(key) % t->size;
    hi = t->tab[ *hashval_return];
    while(hi != 0) {
        if(strcmp(hi->key, key) != 0) {
            hi = hi->next;
            continue;
        }
        return hi;
    }
    return 0;
}

putHash_sv(Hash_sv* t, char* key, _Unknown_base* value)
{// addr = 0x080B4775  --  defined in 'hash.c' at line 28
    int h;                                 // _cfa_fffffff0
    HashItem_sv* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    HashItem_sv* _t30;   // _t30

    _t30 = lookupHash_sv(t, key,  &h);
    hi = _t30;
    if(hi == 0) {
         *__esp = 12;
        GC_malloc();
        hi = _t30;
        hi->key = key;
        hi->value = value;
        hi->next = t->tab[h];
        t->tab[h] = hi;
        return;
    }
    hi->value = value;
    return;
}

_Unknown_base* getHash_sv(Hash_sv* t, char* key, _Unknown_base* failval)
{// addr = 0x080B47F4  --  defined in 'hash.c' at line 28
    int h;                                 // _cfa_fffffff0
    HashItem_sv* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    hi = lookupHash_sv(t, key,  &h);
    if(hi != 0) {
        return hi->value;
    }
    return failval;
}

Hash_iv* newHash_iv(int size)
{// addr = 0x080B4829  --  defined in 'hash.c' at line 29
    struct Hash_iv* hash;   // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    struct HashItem_iv** _t19;   // _t19

     *__esp = 8;
    GC_malloc();
    hash = __eax;
    hash->size = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    hash->tab = _t19;
    i = 0;
    while(i < size) {
        hash->tab[i] = 0;
        i = i + 1;
    }
    return hash;
}

HashItem_iv* lookupHash_iv(Hash_iv* t, int key, int* hashval_return)
{// addr = 0x080B488A  --  defined in 'hash.c' at line 29
    HashItem_iv* hi;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    _unknown_ _t34;                        // _t34
    _unknown_ _t37;                        // _t37

     *hashval_return = key % t->size;
    hi = t->tab[ *hashval_return];
    while(hi != 0) {
        if(hi->key != key) {
            hi = hi->next;
            continue;
        }
        return hi;
    }
    return 0;
}

putHash_iv(Hash_iv* t, int key, _Unknown_base* value)
{// addr = 0x080B48E1  --  defined in 'hash.c' at line 29
    int h;                                 // _cfa_fffffff0
    HashItem_iv* hi;   // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    HashItem_iv* _t30;   // _t30

    _t30 = lookupHash_iv(t, key,  &h);
    hi = _t30;
    if(hi == 0) {
         *__esp = 12;
        GC_malloc();
        hi = _t30;
        hi->key = key;
        hi->value = value;
        hi->next = t->tab[h];
        t->tab[h] = hi;
        return;
    }
    hi->value = value;
    return;
}

_Unknown_base* getHash_iv(Hash_iv* t, int key, _Unknown_base* failval)
{// addr = 0x080B4960  --  defined in 'hash.c' at line 29
    int h;                                 // _cfa_fffffff8
    HashItem_iv* hi;   // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6

    hi = lookupHash_iv(t, key,  &h);
    if(hi != 0) {
        return hi->value;
    }
    return failval;
}

wc_char_conv_init(wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080B4998  --  defined in 'char_conv.c' at line 8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    wc_input_init(f_ces,  &char_conv_st);
     *135789960 = -1;
    char_conv_f_ces = f_ces;
    char_conv_t_ces = t_ces;
    return;
}

Str wc_char_conv(char c)
{// addr = 0x080B49CD  --  defined in 'char_conv.c' at line 17
    signed char _v16;                      // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    struct * _v40;            // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct _Str* _t15;    // _t15

    _v16 = _a4 & 255;
    _t15 = _v16 & 0xff;
    _v40 =  &char_conv_st;
     *__esp = _t15;
     *((intOrPtr*)( *((intOrPtr*)(char_conv_st.auto_detect + 28))))();
    wc_Str_conv(_t15, 3211264, char_conv_t_ces);
    return;
}

wc_ces wc_guess_charset(char* charset, wc_ces orig)
{// addr = 0x080B4A18  --  defined in 'charset.c' at line 36
    wc_ces guess;       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    if(charset == 0 || ( *charset & 0xff) == 0) {
        return orig;
    }
    guess = wc_charset_to_ces(charset);
    if(guess == 0) {
        return orig;
    }
    return guess;
    return __eax;
}

wc_ces wc_guess_charset_short(char* charset, wc_ces orig)
{// addr = 0x080B4A51  --  defined in 'charset.c' at line 47
    wc_ces guess;       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    if(charset == 0 || ( *charset & 0xff) == 0) {
        return orig;
    }
    guess = wc_charset_short_to_ces(charset);
    if(guess == 0) {
        return orig;
    }
    return guess;
    return __eax;
}

wc_ces wc_guess_locale_charset(char* locale, wc_ces orig)
{// addr = 0x080B4A8A  --  defined in 'charset.c' at line 58
    wc_ces guess;       // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    if(locale == 0 || ( *locale & 0xff) == 0) {
        return orig;
    }
    guess = wc_locale_to_ces(locale);
    if(guess == 0) {
        return orig;
    }
    return guess;
    return __eax;
}

wc_ces wc_charset_to_ces(char* charset)
{// addr = 0x080B4AC3  --  defined in 'charset.c' at line 69
    intOrPtr _v16;                         // _cfa_fffffff0
    char[15] buf;                          // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    int n;                                 // _cfa_ffffffd8
    char* _v48;                            // _cfa_ffffffd0
    _unknown_ __ebp;                       // r6
    _unknown_ _t53;                        // _t53
    signed int _t57;                       // _t57
    _unknown_ _t66;                        // _t66
    _unknown_ _t67;                        // _t67
    signed int _t76;                       // _t76
    _unknown_ _t81;                        // _t81
    _unknown_ _t86;                        // _t86

    _v48 = _a4;
    _v16 =  *gs:0x14];
    p = _v48;
    _t57 =  *p & 0xff;
     *__esp = _t57;
    tolower();
    if(_t57 == 120) {
        if((p[1] & 0xff) == 45) {
            p =  &(p[2]);
        }
    }
    n = 0;
    while(( *p & 0xff) != 0 && n <= 14) {
        if(( *p & 0xff) > 32 && ( *p & 0xff) != 95 && ( *p & 0xff) != 45) {
            _t76 =  *p & 0xff;
             *__esp = _t76;
            tolower();
             *(__ebp + n - 28) = _t76 & 255;
            n = n + 1;
        }
        p =  &(p[1]);
    }
     *(__ebp + n - 28) = 0;
    p =  &buf;
    _t86 = ( *p & 0xff) - 97 - 22;
    if(_t86 > 0) {
        if(_t86 == 0) {
            return 0;
        }
        goto L14;
    }
    goto __eax;
L14:
    __stack_chk_fail();
    return 0;
}

wc_ces wc_charset_short_to_ces(char* charset)
{// addr = 0x080B568A  --  defined in 'charset.c' at line 271
    intOrPtr _v16;                         // _cfa_fffffff0
    char[15] buf;                          // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    wc_ces ces;         // _cfa_ffffffd8
    int n;                                 // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    _unknown_ __ebp;                       // r6
    _unknown_ _t49;                        // _t49
    signed int _t54;                       // _t54
    unsigned int _t61;                     // _t61
    _unknown_ _t62;                        // _t62
    signed int _t64;                       // _t64
    signed int _t66;                       // _t66
    signed int _t68;                       // _t68
    signed int _t71;                       // _t71
    _unknown_ _t73;                        // _t73

    _v48 = _a4;
    _v16 =  *gs:0x14];
    p = _v48;
    ces = wc_charset_to_ces(_v48);
    __eflags = ces;
    if(__eflags == 0) {
        n = 0;
        while(1) {
            _t54 =  *p & 255;
            __eflags = _t54 & 255;
            if((_t54 & 255) == 0) {
                break;
            }
            __eflags = n - 14;
            if(n <= 14) {
                _t64 =  *p & 255;
                __eflags = (_t64 & 255) - 32;
                if((_t64 & 255) > 32) {
                    _t66 =  *p & 255;
                    __eflags = (_t66 & 255) - 95;
                    if((_t66 & 255) != 95) {
                        _t68 =  *p & 255;
                        __eflags = (_t68 & 255) - 45;
                        if((_t68 & 255) != 45) {
                            _t71 =  *p & 0xff;
                             *__esp = _t71;
                            tolower();
                             *(__ebp + n - 28) = _t71 & 255;
                            n = n + 1;
                        }
                    }
                }
                p =  &(p[1]);
                continue;
            }
            break;
        }
         *(__ebp + n - 28) = 0;
        p =  &buf;
        __eflags = ( *p & 0xff) - 97 - 22;
        if(__eflags > 0) {
            _t61 = 0;
            goto L13;
        }
        goto __eax;
    } else {
        _t61 = ces;
    }
L13:
    if(__eflags == 0) {
        return _t61;
    }
    __stack_chk_fail();
    return _t61;
}

wc_ces wc_locale_to_ces(char* locale)
{// addr = 0x080B5999  --  defined in 'charset.c' at line 368
    char* p;                               // _cfa_fffffff0
    int n;                                 // _cfa_ffffffec
    char* cs;                              // _cfa_ffffffe8
    char[5] buf;                           // _cfa_ffffffe2
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t78;                       // _t78
    _unknown_ _t88;                        // _t88
    _unknown_ _t99;                        // _t99
    _unknown_ _t100;                       // _t100
    signed int _t106;                      // _t106
    _unknown_ _t117;                       // _t117
    _unknown_ _t124;                       // _t124

    p = locale;
    _t78 =  *p & 255;
    if((_t78 & 255) != 67) {
L3:
         *__esp = 14;
        nl_langinfo();
        cs = _t78;
        if(cs != 0 && strcmp(cs, "US-ASCII") != 0) {
            return wc_charset_to_ces(cs);
        }
        n = 0;
        while(( *p & 0xff) != 0 && ( *p & 0xff) != 46 && n <= 4) {
        }
         *(__ebp + n - 26) = 0;
        if(( *p & 0xff) != 46) {
            if(strcmp( &buf, "japanese") != 0) {
                if(strcmp( &buf, "zh_tw") == 0 || strcmp( &buf, "zh_hk") == 0) {
                    return 3153981;
                }
                n = 0;
                while( *( &lang_ces_table + n * 8) != 0) {
                    if(strncmp( &buf,  *( &lang_ces_table + n * 8), 2) != 0) {
                        n = n + 1;
                        continue;
                    }
                    return  *(135117092 + n * 8);
                }
                return 1049089;
            }
            goto L28;
        }
        p =  &(p[1]);
        if(strcasecmp(p, "euc") == 0) {
            _t106 = buf & 0xff;
            if(_t106 == 107) {
                WcLocale = 5;
            } else {
                if(_t106 == 122) {
                    if(strcmp( &buf, "zh_tw") != 0) {
                        if(strcmp( &buf, "zh_hk") != 0) {
                            WcLocale = 2;
                        } else {
                            WcLocale = 4;
                        }
                    } else {
                        WcLocale = 3;
                    }
                } else {
                    if(_t106 != 106) {
                        WcLocale = 0;
                    } else {
                        WcLocale = 1;
                    }
                }
            }
        }
        return wc_charset_to_ces(p);
L28:
        return 3153976;
    } else {
        _t78 = p[1] & 255;
        if((_t78 & 255) != 0) {
            goto L3;
        } else {
            return 256;
        }
    }
}

char* wc_ces_to_charset(wc_ces ces)
{// addr = 0x080B5BCC  --  defined in 'charset.c' at line 427
    _unknown_ __ebp;                       // r6

    if(ces != 3211264) {
        return  *(((ces & 255) << 5) + 135767972);
    }
    return "WTF";
}

char* wc_ces_to_charset_desc(wc_ces ces)
{// addr = 0x080B5BF2  --  defined in 'charset.c' at line 435
    _unknown_ __ebp;                       // r6

    if(ces != 3211264) {
        return  *(((ces & 255) << 5) + 135767976);
    }
    return "W3M Transfer Format";
}

wc_ces wc_guess_8bit_charset(wc_ces orig)
{// addr = 0x080B5C18  --  defined in 'charset.c' at line 443
    _unknown_ __ebp;                       // r6
    unsigned int _t3;                      // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    _t3 = orig;
    if(_t3 > 2099219) {
        if(_t3 == 2099221) {
            goto L9;
        }
        goto L5;
L10:
        return 3149847;
    }
    if(_t3 >= 2099217) {
        return 3149846;
    }
    if(_t3 == 256) {
        return 1049089;
    }
L12:
    return orig;
L9:
    return 3149849;
L5:
    if(_t3 < 2099221 || _t3 == 2105404) {
        goto L10;
    }
    goto L12;
}

wc_bool wc_check_ces(wc_ces ces)
{// addr = 0x080B5C6D  --  defined in 'charset.c' at line 462
    size_t i;           // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t13;                        // _t13

    i = ces & 255;
    if(i > 70 ||  *((intOrPtr*)( &WcCesInfo + (i << 5))) != ces) {
        return 0;
    }
    return 1;
}

int wc_ces_list_cmp(* a, * b)
{// addr = 0x080B5CA3  --  defined in 'charset.c' at line 470
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return strcasecmp( *(a + 8),  *(b + 8));
}

wc_ces_list* wc_get_ces_list()
{// addr = 0x080B5CC3  --  defined in 'charset.c' at line 478
    wc_ces_info* info;   // _cfa_fffffff0
    size_t n;           // _cfa_ffffffec
    intOrPtr _v32;                         // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t55;                       // _t55
    _unknown_ _t94;                        // _t94

    if(list == 0) {
        info =  &WcCesInfo;
        n = 0;
L6:
        while(info->id != 0) {
            goto L3;
        }
        _t55 = n + 1 + n + 1 + n + 1 << 2;
         *__esp = _t55;
        GC_malloc();
        list = _t55;
        info =  &WcCesInfo;
        n = 0;
        while(info->id != 0) {
            if(info->name != 0) {
                 *(list + (n + n + n << 2)) = info->id;
                (list + (n + n + n << 2))[1] = info->name;
                (list + (n + n + n << 2))[2] = info->desc;
                n = n + 1;
            }
            info = info + 32;
        }
         *(list + (n + n + n << 2)) = 0;
        (list + (n + n + n << 2))[1] = 0;
        (list + (n + n + n << 2))[2] = 0;
        _v32 = wc_ces_list_cmp;
        qsort(list, n, 12);
        return list;
    }
    return list;
L3:
    if(info->name != 0) {
        n = n + 1;
    }
    info = info + 32;
    goto L6;
}

Str wc_Str_conv(Str is, wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080B5E24  --  defined in 'conv.c' at line 18
    unsigned int _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t13;                        // _t13
    struct _Str* _t22;    // _t22

    if(f_ces != 3211264) {
        _v24 = f_ces;
        _t22 = is;
         *__esp = _t22;
         *((intOrPtr*)( *((intOrPtr*)(((f_ces & 255) + (f_ces & 255) + 1 << 4) + 135767972))))();
        is = _t22;
    }
    if(t_ces == 3211264) {
        return;
    }
    wc_conv_to_ces(is, t_ces);
    return;
}

Str wc_Str_conv_strict(Str is, wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080B5E7D  --  defined in 'conv.c' at line 29
    Str os;                // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    wc_option opt;   // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    opt.auto_detect = WcOption.auto_detect;
    _v28 =  *135119012;
    _v24 =  *135119016;
    _v20 =  *135119020;
     *135119020 = 1;
     *135119022 = 1;
     *135119013 = 0;
    os = wc_Str_conv(is, f_ces, t_ces);
    WcOption.auto_detect = opt.auto_detect;
     *135119012 = _v28;
     *135119016 = _v24;
     *135119020 = _v20;
    return os;
}

Str wc_conv_to_ces(Str is, wc_ces ces)
{// addr = 0x080B5EF9  --  defined in 'conv.c' at line 43
    _unknown_ _v8;                         // _cfa_fffffff8
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_uchar** _v32;   // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    wc_uchar** _v40;   // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    wc_status st;    // _cfa_ffffff98
    wc_ces_info** _v116;   // _cfa_ffffff8c
    wc_uchar** _v120;   // _cfa_ffffff88
    wc_uchar* _v124;   // _cfa_ffffff84
    _unknown_ __ebp;                       // r6
    unsigned int _t131;                    // _t131
    unsigned int _t142;                    // _t142
    _unknown_ _t151;                       // _t151
    int _t171;                             // _t171
    _unknown_ _t210;                       // _t210

    _push(__ebx);
    __esp = __esp - 116;
    sp = is->ptr;
    ep = sp + is->length;
    _t131 = ces;
    if(_t131 < 1066050) {
L15:
        p = sp;
L17:
        while(p < ep) {
            if(( *p & 0xff) >= 0) {
                goto L16;
            }
            goto L24;
        }
        goto L24;
    }
    if(_t131 <= 1066052) {
        p = sp;
L11:
        while(p < ep) {
            if(( *p & 0xff) <= 31) {
                goto L24;
            }
            if(( *p & 0xff) >= 0) {
                goto L10;
            }
            goto L24;
        }
        goto L22;
    }
    if(_t131 != 2105404) {
        goto L15;
    } else {
        p = sp;
        while(p < ep) {
            if(( *p & 0xff) == 126) {
                goto L24;
            }
            if(( *p & 0xff) >= 0) {
                p =  &(p[1]);
                continue;
            }
L24:
            if(p != ep) {
                os = Strnew_size(is->length);
                if(p > sp) {
                    p = p - 1;
                }
                if(p > sp) {
                    Strcat_charp_n(os, is->ptr, p - sp);
                }
                wc_output_init(ces,  &(st.ces_info));
                _t142 = ces;
                if(_t142 > 2099221) {
                    if(_t142 == 2129990) {
                        goto L40;
                    }
                    goto L35;
L41:
                } else {
                    if(_t142 >= 2099217) {
                        goto L43;
                    }
                    if(_t142 - 1066050 > 2) {
L52:
                        while(p < ep) {
                            if(( *p & 0xff) >= 0 || ( *( &WTF_WIDTH_MAP + (p[1] & 0xff)) & 0xff) == 0) {
                                _v120 =  &p;
                                wtf_parse( &_v44);
                                __esp = __esp - 4;
                                _v116 =  &(st.ces_info);
                                _v124 = _v44;
                                _v120 = _v40;
                                 *__esp = os;
                                st.ces_info();
                            } else {
                                if(os->length + 1 >= os->area_size) {
                                    Strgrow(os);
                                }
                                _t171 = os->length;
                                 *(os->ptr + _t171) =  *p & 0xff;
                                os->length = _t171 + 1;
                                 *((char*)(os->ptr + os->length)) = 0;
                                p =  &(p[1]);
                            }
                        }
                        goto L53;
                    }
L43:
                    while(p < ep) {
                        _v120 =  &p;
                        wtf_parse( &_v36);
                        __esp = __esp - 4;
                        _v116 =  &(st.ces_info);
                        _v124 = _v36;
                        _v120 = _v32;
                         *__esp = os;
                        st.ces_info();
                    }
L53:
                    wc_push_end(os,  &(st.ces_info));
L54:
                    return;
                    goto L52;
L40:
                }
                goto L43;
L35:
                if(_t142 == 3178565) {
                    goto L41;
                }
                if(_t142 == 2105404) {
                    goto L42;
                }
                goto L52;
L42:
                goto L43;
            }
            goto L54;
L22:
            goto L24;
        }
        goto L24;
    }
    goto L16;
L10:
    p =  &(p[1]);
    goto L11;
L16:
    p =  &(p[1]);
    goto L17;
}

Str wc_Str_conv_with_detect(Str is, wc_ces* f_ces, wc_ces hint, wc_ces t_ces)
{// addr = 0x080B618F  --  defined in 'conv.c' at line 112
    wc_ces detect;      // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if( *f_ces != 3211264 && hint != 3211264) {
        if((WcOption.auto_detect & 0xff) != 0) {
            if(( *f_ces & 1048576) != 0) {
                hint =  *f_ces;
            }
            detect = wc_auto_detect(is->ptr, is->length, hint);
            if((WcOption.auto_detect & 0xff) != 2) {
                if((detect & 2048) != 0 && ( *f_ces & 1048576) == 0) {
                     *f_ces = detect;
                }
            } else {
                if((detect & 1048576) != 0 || (detect & 130560) != 0 && ( *f_ces & 1048576) == 0) {
                     *f_ces = detect;
                }
            }
        } else {
             *f_ces = hint;
            detect = hint;
        }
    } else {
         *f_ces = 3211264;
        detect = 3211264;
    }
    return wc_Str_conv(is, detect, t_ces);
}

wc_push_end(Str os, wc_status* st)
{// addr = 0x080B628E  --  defined in 'conv.c' at line 139
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if((st->ces_info->id & 2048) != 0) {
        wc_push_to_iso2022_end(os, st);
        return;
    }
    if(st->ces_info->id != 2105404) {
    } else {
        wc_push_to_hz_end(os, st);
        return;
    }
    goto L4;
L6:
    if(st->ces_info->id == 2129990) {
        wc_push_to_utf7_end(os, st);
        return;
    }
L8:
    return;
L4:
    if(st->ces_info->id != 3178565) {
    } else {
        wc_push_to_utf8_end(os, st);
        return;
    }
    goto L6;
}

wc_create_detect_map(wc_ces ces, wc_bool esc)
{// addr = 0x080B6320  --  defined in 'detect.c' at line 41
    int i;                                 // _cfa_fffffff8
    wc_uint8* map;    // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t48;                       // _t48
    int _t52;                              // _t52
    unsigned int _t54;                     // _t54

    _v24 = _a8 & 255;
    if(ces == detect_ces) {
L17:
        if(_v24 != 0 || (ces & 2048) != 0) {
            _t48 = 1;
        } else {
            _t48 = 0;
        }
         *135117243 = _t48 & 255;
        return;
    }
    _t52 = ces & 16384;
    if(_t52 == 0) {
        i = 0;
L14:
        while(i <= 31) {
            goto L13;
        }
         *135117342 = _t52 & 255;
         *135117259 = _t52 & 255;
        goto L16;
    }
    map = 0;
    _t54 = ces;
    if(_t54 == 1066051) {
        map =  &wc_c0_viscii112_map;
    } else {
        if(_t54 == 1066052) {
            map =  &wc_c0_vps2_map;
        } else {
            if(_t54 == 1066050) {
                map =  &wc_c0_tcvn57122_map;
            }
        }
    }
    i = 0;
    while(i <= 31) {
         *( &WC_DETECT_MAP + i) =  *(map + i) & 0xff;
        i = i + 1;
    }
L16:
    detect_ces = ces;
    goto L17;
L13:
    _t52 = i;
     *( &WC_DETECT_MAP + _t52) = 0;
    i = i + 1;
    goto L14;
}

wc_ces wc_auto_detect(char* is, size_t len, wc_ces hint)
{// addr = 0x080B6412  --  defined in 'detect.c' at line 77
    wc_bool iso2022jp2;   // _cfa_fffffff3
    wc_bool iso2022jp3;   // _cfa_fffffff2
    wc_bool iso2022cn;   // _cfa_fffffff1
    wc_bool iso2022kr;   // _cfa_fffffff0
    wc_bool ok;        // _cfa_ffffffef
    wc_uchar* p;      // _cfa_ffffffe8
    wc_uchar* ep;     // _cfa_ffffffe4
    wc_uchar* q;      // _cfa_ffffffe0
    wc_ces euc;         // _cfa_ffffffdc
    wc_ces priv;        // _cfa_ffffffd8
    int euc_state;                         // _cfa_ffffffd4
    int sjis_state;                        // _cfa_ffffffd0
    int big5_state;                        // _cfa_ffffffcc
    int hz_state;                          // _cfa_ffffffc8
    int iso_detect;                        // _cfa_ffffffc4
    int euc_detect;                        // _cfa_ffffffc0
    int sjis_detect;                       // _cfa_ffffffbc
    int big5_detect;                       // _cfa_ffffffb8
    int hz_detect;                         // _cfa_ffffffb4
    int latin_detect;                      // _cfa_ffffffb0
    int priv_detect;                       // _cfa_ffffffac
    int possible;                          // _cfa_ffffffa8
    int utf8_state;                        // _cfa_ffffffa4
    int utf8_detect;                       // _cfa_ffffffa0
    int utf8_next;                         // _cfa_ffffff9c
    signed int _v132;                      // _cfa_ffffff7c
    signed int _v136;                      // _cfa_ffffff78
    intOrPtr _v140;                        // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    wc_status st;    // _cfa_ffffff60
    _unknown_ _v184;                       // _cfa_ffffff48
    _unknown_ __ebp;                       // r6
    unsigned int _t400;                    // _t400
    unsigned int _t405;                    // _t405
    _unknown_ _t409;                       // _t409
    _unknown_ _t416;                       // _t416
    _unknown_ _t417;                       // _t417
    _unknown_ _t418;                       // _t418
    _unknown_ _t420;                       // _t420
    _unknown_ _t421;                       // _t421
    _unknown_ _t422;                       // _t422
    _unknown_ _t423;                       // _t423
    _unknown_ _t428;                       // _t428
    unsigned int _t431;                    // _t431
    _unknown_ _t432;                       // _t432
    _unknown_ _t433;                       // _t433
    _unknown_ _t434;                       // _t434
    _unknown_ _t435;                       // _t435
    _unknown_ _t436;                       // _t436
    _unknown_ _t437;                       // _t437
    _unknown_ _t438;                       // _t438
    _unknown_ _t439;                       // _t439
    _unknown_ _t441;                       // _t441
    int _t442;                             // _t442
    int _t448;                             // _t448
    signed int _t464;                      // _t464
    _unknown_ _t468;                       // _t468
    _unknown_ _t469;                       // _t469
    int _t470;                             // _t470
    signed int _t475;                      // _t475
    int _t484;                             // _t484
    int _t486;                             // _t486
    int _t495;                             // _t495
    _unknown_ _t509;                       // _t509
    int _t510;                             // _t510
    int _t517;                             // _t517
    _unknown_ _t534;                       // _t534
    signed int _t537;                      // _t537

    p = is;
    ep = p + len;
    euc = 0;
    priv = 0;
    euc_state = 0;
    sjis_state = 0;
    big5_state = 0;
    hz_state = 0;
    iso_detect = 8;
    euc_detect = 8;
    sjis_detect = 8;
    big5_detect = 8;
    hz_detect = 8;
    latin_detect = 8;
    priv_detect = 8;
    possible = 0;
    iso2022jp2 = 0;
    iso2022jp3 = 0;
    iso2022cn = 0;
    iso2022kr = 0;
    ok = 0;
    utf8_state = 0;
    utf8_detect = 8;
    utf8_next = 0;
    wc_create_detect_map(hint, 1);
L2:
    while(p < ep) {
L3:
        if(( *( &WC_DETECT_MAP + ( *p & 0xff)) & 0xff) == 0) {
            p =  &(p[1]);
            goto L2;
        }
        break;
    }
    if(p == ep) {
        return hint;
    }
    _t400 = hint;
    if(_t400 == 3149846) {
L25:
        euc = 3149846;
        euc_state = 0;
        sjis_state = 0;
        sjis_detect = 0;
        euc_detect = sjis_detect;
        iso_detect = euc_detect;
        possible = 3;
        goto L35;
    } else {
        if(_t400 > 3149846) {
            if(_t400 > 3153977) {
                if(_t400 == 3153981) {
                    goto L27;
                }
                goto L23;
            }
            goto L17;
L23:
            if(_t400 == 3178565) {
                iso_detect = 0;
                possible = 1;
                goto L35;
            } else {
                goto L32;
            }
            goto L36;
        }
        if(_t400 > 2099219) {
            if(_t400 == 2099221) {
L29:
                euc = 3149849;
                euc_state = 0;
                euc_detect = 0;
                iso_detect = euc_detect;
                possible = 3;
                goto L35;
            }
            goto L13;
        }
        if(_t400 >= 2099217) {
            goto L25;
        }
        if(_t400 == 256) {
            latin_detect = 0;
            iso_detect = latin_detect;
            possible = 2;
L35:
            if(priv_detect == 8) {
L36:
                utf8_detect = 0;
                possible = possible + 1;
            }
            wc_input_init(256,  &(st.ces_info));
            while(p < ep) {
                if(possible == 0 || possible == 1 && ok != 0) {
                    break;
                } else {
                    if(iso_detect == 8) {
L77:
                        if(euc_detect == 8) {
L98:
                            if(sjis_detect == 8) {
L118:
                                if(big5_detect != 8) {
                                    _t470 = big5_state;
                                    if(_t470 == 0) {
                                        _t475 =  *( &WC_BIG5_MAP + ( *p & 0xff)) & 0xff;
                                        if(_t475 == 2) {
                                            big5_detect = 8;
                                        } else {
                                            if(_t475 == 7) {
                                                big5_state = 1;
                                            }
                                        }
                                    } else {
                                        if(_t470 == 1) {
                                            if(( *( &WC_BIG5_MAP + ( *p & 0xff)) & 4) == 0) {
                                                if((big5_detect & 4) != 0) {
                                                    _t484 = 8;
                                                } else {
                                                    _t484 = big5_detect | 4;
                                                }
                                                big5_detect = _t484;
                                            } else {
                                                big5_detect = big5_detect | 2;
                                                ok = 1;
                                            }
                                            big5_state = 0;
                                        }
                                    }
                                    if(big5_detect == 8) {
                                        possible = possible - 1;
                                    }
                                }
                                if(hz_detect == 8) {
L141:
                                    if(latin_detect != 8) {
                                        _t464 =  *( &WC_ISO_MAP + ( *p & 0xff)) & 0xf0;
                                        if(_t464 == 80) {
                                            latin_detect = 8;
                                        } else {
                                            if(_t464 == 96 || _t464 == 64) {
                                                latin_detect = latin_detect | 2;
                                                ok = 1;
                                            }
                                        }
                                        if(latin_detect == 8) {
                                            possible = possible - 1;
                                        }
                                    }
                                    if(priv_detect != 8 && ( *p & 0xff) != 27 && ( *( &WC_DETECT_MAP + ( *p & 0xff)) & 0xff) != 0) {
                                        priv_detect = priv_detect | 2;
                                        ok = 1;
                                    }
                                    if(utf8_detect == 8) {
                                        goto L173;
                                    }
                                    _t442 = utf8_state;
                                    if(_t442 == 0) {
                                        utf8_next =  *( &WC_UTF8_MAP + ( *p & 0xff)) & 0xff;
                                        _t448 = utf8_next;
                                        if(_t448 == 1) {
L163:
L166:
                                            goto L171;
                                        }
                                        goto L158;
L164:
                                        utf8_detect = 8;
                                        goto L166;
                                    }
                                    if(_t442 == 1) {
                                        if(( *( &WC_UTF8_MAP + ( *p & 0xff)) & 0xff) == 0) {
                                            utf8_next = utf8_next - 1;
                                            if(utf8_next == 0) {
                                                utf8_detect = utf8_detect | 2;
                                                ok = 1;
                                                utf8_state = 0;
                                            }
                                        } else {
                                            utf8_detect = 8;
                                            utf8_state = 0;
                                        }
                                    }
L171:
                                    if(utf8_detect == 8) {
                                        possible = possible - 1;
                                    }
                                    goto L173;
L158:
                                    if(_t448 > 1) {
                                        if(_t448 == 7) {
                                            goto L164;
                                        }
                                        goto L162;
                                    }
                                    if(_t448 == 0) {
                                        goto L164;
                                    }
L165:
                                    utf8_next = utf8_next - 1;
                                    utf8_state = 1;
                                    goto L171;
L162:
                                    if(_t448 != 8) {
                                        goto L165;
                                    }
                                    goto L163;
                                }
                                if(( *p & 0xff) >= 0) {
                                    if(hz_state > 4) {
                                        goto L141;
                                    }
                                    goto L140;
                                }
                                hz_detect = 8;
                                possible = possible - 1;
                                goto L141;
L140:
                                goto __eax;
                            }
                            goto L99;
                        }
                        goto L78;
L99:
                        _t486 = sjis_state;
                        if(_t486 == 1) {
                            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                                if((sjis_detect & 4) != 0) {
                                    _t495 = 8;
                                } else {
                                    _t495 = sjis_detect | 4;
                                }
                                sjis_detect = _t495;
                            } else {
                                sjis_detect = sjis_detect | 2;
                                ok = 1;
                            }
                            sjis_state = 0;
L116:
                            if(sjis_detect == 8) {
                                possible = possible - 1;
                            }
                            goto L118;
                        }
                        if(_t486 == 3) {
                            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                                sjis_detect = 8;
                            } else {
                                sjis_detect = sjis_detect | 1;
                            }
                            sjis_state = 0;
                            goto L116;
                        }
                        if(_t486 != 0) {
                            goto L116;
                        }
                        if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0xff) - 18 > 46) {
                            goto L116;
                        }
                        goto __eax;
                        goto L116;
                    }
                    _t537 =  *p & 0xff;
                    if(_t537 < 14) {
L72:
                        if(( *p & 0xff) < 0) {
                            iso_detect = 8;
                            possible = possible - 1;
                        }
                        goto L77;
                    }
                    if(_t537 <= 15) {
L71:
                        iso_detect = 2;
                        ok = 1;
                        iso2022cn = 1;
                        iso2022kr = 1;
                        goto L77;
                    }
                    if(_t537 != 27) {
                        goto L72;
                    }
                    if((p[1] & 0xff) != 36) {
                        if((p[1] & 0xff) != 46) {
                            if((p[1] & 0xff) != 37) {
                                goto L70;
                            }
                            goto L68;
                        }
                        goto L64;
L68:
                        q = p;
                        if(wc_parse_iso2022_esc( &q,  &(st.ces_info)) == 0) {
                            goto L77;
                        }
                        possible = 0;
                        iso_detect = 4;
L173:
                        p =  &(p[1]);
                        continue;
                    }
                    q = p;
                    if(wc_parse_iso2022_esc( &q,  &(st.ces_info)) == 0) {
                        goto L77;
                    } else {
                        if(_v144 != 33088 && _v144 != 33090) {
                            if(_v144 == 33103 || _v144 == 33104) {
                                iso2022jp3 = 1;
                            } else {
                                if((_v144 & 65280) == 33024) {
                                    iso2022jp2 = 1;
                                }
                            }
                        }
                        if(_v140 != 33091) {
                            if(_v140 == 33089 || _v140 == 33093 || _v140 == 33095) {
                                iso2022cn = 1;
                            }
                        } else {
                            iso2022kr = 1;
                        }
                        if((_v136 & 65280) == 33024 || (_v132 & 65280) == 33024) {
                            iso2022cn = 1;
                        }
                    }
L70:
                    iso_detect = 2;
                    ok = 1;
                    goto L77;
L64:
                    q = p;
                    if(wc_parse_iso2022_esc( &q,  &(st.ces_info)) == 0) {
                        goto L77;
                    } else {
                        if((_v136 & 65280) == 512) {
                            iso2022jp2 = 1;
                        }
                    }
                    goto L70;
L78:
                    _t510 = euc_state;
                    if(_t510 == 2) {
                        if(( *( &WC_ISO_MAP + ( *p & 0xff)) & 0xff) != 64) {
                            if((euc_detect & 4) != 0) {
                                _t517 = 8;
                            } else {
                                _t517 = euc_detect | 4;
                            }
                            euc_detect = _t517;
                        } else {
                            euc_detect = euc_detect | 2;
                            ok = 1;
                        }
                        euc_state = 0;
L96:
                        if(euc_detect == 8) {
                            possible = possible - 1;
                        }
                        goto L98;
                    }
                    if(_t510 == 3) {
                        if(( *p & 0xff) <= 159 || ( *p & 0xff) > 176 || ( *( &WC_ISO_MAP + (p[1] & 0xff)) & 0xff) != 64) {
                            euc_detect = 8;
                        }
                        euc_state = 0;
                        goto L96;
                    }
                    if(_t510 != 0) {
                        goto L96;
                    }
                    if(( *( &WC_ISO_MAP + ( *p & 0xff)) & 0xff) - 64 > 32) {
                        goto L96;
                    }
                    goto __eax;
                    goto L96;
                }
L176:
                if(iso_detect != 0) {
L182:
                    _t431 = euc;
                    if(_t431 < 3149847) {
L191:
                        if(iso2022jp3 == 0) {
                            if(iso2022jp2 == 0) {
                                if(iso2022cn == 0) {
                                    if(iso2022kr == 0) {
                                        return 2099217;
                                    }
                                    goto L198;
L200:
                                    _t405 = hint;
                                    if(_t405 > 3149849) {
                                        if(_t405 == 3153981) {
                                            if(big5_detect == 8) {
L233:
                                                goto L234;
                                            }
                                            goto L217;
                                        }
                                        goto L207;
L217:
                                        return hint;
                                    }
L201:
                                    if(_t405 >= 3149846) {
                                        if(euc_detect == 8) {
                                            goto L234;
                                        }
                                        goto L213;
L232:
                                        goto L234;
                                    }
                                    if(_t405 == 256) {
                                        if(utf8_detect == 8) {
                                            if(latin_detect == 8) {
                                                return hint;
                                            }
                                            goto L222;
                                        }
                                        goto L220;
L222:
                                        return 1049089;
                                    }
                                    if(_t405 < 256 || _t405 - 2099217 > 4) {
L224:
                                        if(latin_detect == 8) {
                                            if(priv_detect == 8) {
                                                if(utf8_detect == 8) {
                                                    return hint;
                                                }
                                                goto L229;
                                            }
                                            goto L227;
L229:
                                            return 3178565;
                                        }
                                        goto L225;
L227:
                                        return hint;
                                    } else {
L234:
                                        if(euc_detect != 2) {
                                            if(sjis_detect != 2) {
                                                if(big5_detect != 2) {
                                                    if(utf8_detect != 2) {
                                                        if((sjis_detect & 1) == 0) {
                                                            if(euc_detect == 8) {
                                                                if(sjis_detect == 8) {
                                                                    if(big5_detect == 8) {
                                                                        if(utf8_detect == 8) {
                                                                            return hint;
                                                                        }
                                                                        goto L251;
                                                                    }
                                                                    goto L249;
L251:
                                                                    return 3178565;
                                                                }
                                                                goto L247;
L249:
                                                                return 3153981;
                                                            }
                                                            goto L245;
L247:
                                                            return 3153976;
                                                        }
                                                        goto L243;
L245:
                                                        return euc;
                                                    }
                                                    goto L241;
L243:
                                                    return 3153976;
                                                }
                                                goto L239;
L241:
                                                return 3178565;
                                            }
                                            goto L237;
L239:
                                            return 3153981;
                                        }
                                        return euc;
L237:
                                        return 3153976;
                                    }
L225:
                                    return hint;
L220:
                                    return hint;
L213:
                                    return hint;
L207:
                                    if(_t405 > 3153981) {
                                        if(_t405 == 3178565) {
                                            return hint;
                                        }
                                        goto L211;
                                    }
                                    if(_t405 - 3153976 > 1) {
                                        goto L224;
                                    }
                                    if(sjis_detect == 8) {
                                        goto L232;
                                    } else {
                                        return hint;
                                    }
                                    goto L233;
L211:
                                    goto L224;
                                }
                                goto L196;
L198:
                                return 2099221;
                            }
                            goto L194;
L196:
                            return 2099220;
                        }
                        goto L192;
L194:
                        return 2099218;
                    }
                    goto L183;
L192:
                    return 2099219;
                }
                if(hz_detect != 2) {
                    if(priv_detect != 2) {
                        return 256;
                    }
                    goto L180;
                }
                return 2105404;
L180:
                return priv;
L183:
                if(_t431 <= 3149848) {
                    if(iso2022cn == 0) {
                        goto L191;
                    }
                    goto L187;
                }
                if(_t431 == 3149849) {
                    if(iso2022kr == 0) {
                        goto L191;
                    }
                    return 2099221;
                }
                goto L191;
L187:
                return 2099220;
            }
            if(iso_detect == 8) {
                goto L200;
            }
            goto L176;
        } else {
L32:
            if((hint & 512) == 0) {
                priv_detect = 0;
                iso_detect = priv_detect;
                priv = hint;
                possible = 2;
            } else {
                latin_detect = 0;
                iso_detect = latin_detect;
                possible = 2;
            }
            goto L35;
        }
        goto L26;
L13:
        if(_t400 < 2099221) {
            goto L26;
        }
        if(_t400 == 2105404) {
            euc = 3149847;
            euc_state = 0;
            hz_state = 0;
            hz_detect = 0;
            big5_detect = hz_detect;
            euc_detect = big5_detect;
            iso_detect = euc_detect;
            possible = 4;
            goto L35;
        } else {
            goto L32;
        }
        goto L36;
L27:
        euc = 3149848;
        euc_state = 0;
        big5_state = 0;
        big5_detect = 0;
        euc_detect = big5_detect;
        iso_detect = euc_detect;
        possible = 3;
        goto L35;
L17:
        if(_t400 >= 3153976) {
            goto L25;
        }
        if(_t400 == 3149848) {
            goto L27;
        }
        if(_t400 < 3149848) {
            goto L26;
        }
        if(_t400 == 3149849) {
            goto L29;
        } else {
            goto L32;
        }
        goto L27;
    }
L26:
    euc = 3149847;
    euc_state = 0;
    big5_state = 0;
    big5_detect = 0;
    euc_detect = big5_detect;
    iso_detect = euc_detect;
    possible = 3;
    goto L35;
}

Str wc_conv_from_hz(Str is, wc_ces ces)
{// addr = 0x080B7018  --  defined in 'hz.c' at line 11
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t64;                        // _t64
    _unknown_ _t65;                        // _t65
    _unknown_ _t82;                        // _t82
    _unknown_ _t84;                        // _t84

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while(p < ep) {
        if(( *p & 0xff) >= 0 || ( *p & 0xff) == 126) {
            break;
        } else {
            p =  &(p[1]);
        }
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        if(state > 5) {
            p =  &(p[1]);
            continue;
        }
        goto __eax;
    }
    if(state <= 5 && (1 << (state & 255) & 54) != 0) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

wc_push_to_hz(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B7449  --  defined in 'hz.c' at line 98
    wc_status* _v16;   // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    unsigned int _t260;                    // _t260
    int _t272;                             // _t272
    int _t284;                             // _t284
    int _t301;                             // _t301
    int _t313;                             // _t313
    int _t327;                             // _t327
    int _t339;                             // _t339
    int _t359;                             // _t359
    int _t371;                             // _t371
    unsigned int _t383;                    // _t383
    int _t395;                             // _t395
    int _t408;                             // _t408
    int _t421;                             // _t421
    int _t433;                             // _t433

    while(1) {
        _t260 = cc.ccs;
        if(_t260 == 16384) {
            break;
        }
        if(_t260 > 16384) {
            if(_t260 == 33089) {
                if(( *(st + 5) & 0xff) == 0) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t327 = os->length;
                     *((char*)(os->ptr + _t327)) = 126;
                    os->length = _t327 + 1;
                     *(os->ptr + os->length) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t339 = os->length;
                     *((char*)(os->ptr + _t339)) = 123;
                    os->length = _t339 + 1;
                     *(os->ptr + os->length) = 0;
                     *(st + 5) = 1;
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t301 = os->length;
                 *(os->ptr + _t301) = cc.code >> 8 & 0x7f;
                os->length = _t301 + 1;
                 *(os->ptr + os->length) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t313 = os->length;
                 *(os->ptr + _t313) = cc.code & 0x7f;
                os->length = _t313 + 1;
                 *(os->ptr + os->length) = 0;
                return;
            }
        } else {
            if(_t260 == 322) {
                if(( *(st + 5) & 0xff) != 0) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t421 = os->length;
                     *((char*)(os->ptr + _t421)) = 126;
                    os->length = _t421 + 1;
                     *(os->ptr + os->length) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t433 = os->length;
                     *((char*)(os->ptr + _t433)) = 125;
                    os->length = _t433 + 1;
                     *(os->ptr + os->length) = 0;
                     *(st + 5) = 0;
                }
                if((cc.code & 255) == 126) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t408 = os->length;
                     *((char*)(os->ptr + _t408)) = 126;
                    os->length = _t408 + 1;
                     *(os->ptr + os->length) = 0;
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t395 = os->length;
                 *(os->ptr + _t395) = cc.code & 255;
                os->length = _t395 + 1;
                 *(os->ptr + os->length) = 0;
                return;
            }
L48:
            if(( *135119011 & 0xff) == 0) {
                if((cc.ccs & 98304) == 0) {
                    _t383 = 16384;
                } else {
                    _t383 = 49152;
                }
                cc.ccs = _t383;
            } else {
                _v16 = st;
                _v24 = cc.ccs;
                _v20 = cc.code;
                 *__esp =  &(cc.ccs);
                wc_any_to_any_ces();
                __esp = __esp - 4;
            }
            continue;
        }
        if(_t260 == 49152) {
            if(( *135119022 & 0xff) != 0) {
                return;
            }
            goto L33;
        }
        goto L48;
L33:
        if(( *(st + 5) & 0xff) != 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t359 = os->length;
             *((char*)(os->ptr + _t359)) = 126;
            os->length = _t359 + 1;
             *(os->ptr + os->length) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t371 = os->length;
             *((char*)(os->ptr + _t371)) = 125;
            os->length = _t371 + 1;
             *(os->ptr + os->length) = 0;
             *(st + 5) = 0;
        }
        Strcat_charp(os, WcReplaceW);
        return;
    }
    if(( *135119022 & 0xff) == 0) {
        if(( *(st + 5) & 0xff) != 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t272 = os->length;
             *((char*)(os->ptr + _t272)) = 126;
            os->length = _t272 + 1;
             *(os->ptr + os->length) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t284 = os->length;
             *((char*)(os->ptr + _t284)) = 125;
            os->length = _t284 + 1;
             *(os->ptr + os->length) = 0;
             *(st + 5) = 0;
        }
        Strcat_charp(os, WcReplace);
        return;
    }
    return;
}

wc_push_to_hz_end(Str os, wc_status* st)
{// addr = 0x080B792D  --  defined in 'hz.c' at line 154
    _unknown_ __ebp;                       // r6
    int _t49;                              // _t49
    int _t61;                              // _t61

    if(( *(st + 5) & 0xff) != 0) {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t49 = os->length;
         *((char*)(os->ptr + _t49)) = 126;
        os->length = _t49 + 1;
         *(os->ptr + os->length) = 0;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t61 = os->length;
         *((char*)(os->ptr + _t61)) = 125;
        os->length = _t61 + 1;
         *(os->ptr + os->length) = 0;
         *(st + 5) = 0;
        return;
    }
    return;
}

wtf_push_iso2022(Str os, wc_ccs ccs, wc_uint32 code)
{// addr = 0x080B79E4  --  defined in 'iso2022.c' at line 51
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    unsigned int _t16;                     // _t16

    _t16 = ccs;
    if(_t16 == 33090) {
L10:
        ccs = wc_jisx0208_or_jisx02131(code & 0xffff);
        goto L13;
    }
    if(_t16 > 33090) {
        if(_t16 == 33103) {
            goto L10;
        }
        goto L7;
    }
    if(_t16 == 340) {
L12:
        ccs = 322;
        goto L13;
    }
    if(_t16 == 33088) {
        goto L10;
    }
    if(_t16 == 330) {
        goto L12;
    } else {
    }
    goto L13;
L13:
    wtf_push(os, ccs, code);
    return;
L7:
    if(_t16 == 33104 || _t16 == 33092) {
        ccs = wc_jisx0212_or_jisx02132(code & 0xffff);
    }
    goto L13;
}

Str wc_conv_from_iso2022(Str is, wc_ces ces)
{// addr = 0x080B7A71  --  defined in 'iso2022.c' at line 72
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_uchar* q;      // _cfa_ffffffe0
    int state;                             // _cfa_ffffffdc
    wc_ccs gl_ccs;      // _cfa_ffffffd8
    wc_ccs gr_ccs;      // _cfa_ffffffd4
    int _v98;                              // _cfa_ffffff9e
    signed char _v99;                      // _cfa_ffffff9d
    signed char _v100;                     // _cfa_ffffff9c
    wc_status st;    // _cfa_ffffff98
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t97;                        // _t97
    _unknown_ _t98;                        // _t98
    int _t99;                              // _t99

    sp = is->ptr;
    ep = sp + is->length;
    q = 0;
    state = 0;
    p = sp;
    while(p < ep && ( *( &WC_ISO_MAP + ( *p & 0xff)) & 0x4f) == 0) {
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    wc_input_init(ces,  &(st.ces_info));
    gl_ccs =  *(__ebp + ((_v99 & 0xff) + 4) * 4 - 100);
    gr_ccs =  *(__ebp + ((_v100 & 0xff) + 4) * 4 - 100);
    while(p < ep) {
        if(state > 32) {
            _v98 = 0;
            state = 0;
            p =  &(p[1]);
            continue;
        }
        goto __eax;
    }
    _t99 = state;
    if(_t99 >= 1) {
        if(_t99 <= 2) {
            wtf_push_unknown(os, p - 1, 1);
        } else {
            if(_t99 == 4) {
                wtf_push_unknown(os, p - 2, 2);
            }
        }
    }
    return os;
}

int wc_parse_iso2022_esc(wc_uchar** ptr, wc_status* st)
{// addr = 0x080B82F1  --  defined in 'iso2022.c' at line 255
    wc_uchar state;   // _cfa_fffffff7
    wc_uchar f;       // _cfa_fffffff6
    wc_uchar g;       // _cfa_fffffff5
    wc_uchar cs;      // _cfa_fffffff4
    wc_uchar* p;      // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t153;                       // _t153
    signed int _t154;                      // _t154
    _unknown_ _t158;                       // _t158
    signed int _t171;                      // _t171
    _unknown_ _t180;                       // _t180
    signed int _t184;                      // _t184
    _unknown_ _t185;                       // _t185
    signed int _t186;                      // _t186
    _unknown_ _t207;                       // _t207
    _unknown_ _t208;                       // _t208
    _unknown_ _t209;                       // _t209
    _unknown_ _t210;                       // _t210
    _unknown_ _t229;                       // _t229

    p =  *ptr;
    f = 0;
    g = 0;
    cs = 0;
    if(( *p & 0xff) != 27) {
        return 0;
    }
    state =  *p & 0xff;
    p =  &(p[1]);
    while(( *p & 0xff) != 0 && state != 0) {
        _t171 = state & 255;
        if(_t171 == 40) {
L32:
            if(( *p & 0xff) != 33) {
                goto L34;
            }
            goto L33;
        }
        if(_t171 > 40) {
            if(_t171 == 165) {
                goto L34;
            }
            goto L13;
        }
        if(_t171 == 33) {
L34:
            state = 0;
            f =  *p & 0xff;
            goto L39;
        }
        if(_t171 > 33) {
            if(_t171 == 36) {
                _t184 = ( *p & 0xff) - 40;
                if(_t184 > 26) {
L31:
                    return 0;
                }
                goto L24;
            }
            goto L10;
L24:
            _t186 = 1 << (_t184 & 255);
            if((_t186 & 117440512) != 0) {
                state = 0;
                cs = 168;
                g = 0;
                f =  *p & 0xff;
L39:
                p =  &(p[1]);
                continue;
            }
            if((_t186 & 240) != 0) {
                cs = 172;
                state = cs & 0xff;
                g =  *p & 3;
                goto L39;
            }
            if((_t186 & 15) != 0) {
                cs = 168;
                state = cs & 0xff;
                g =  *p & 3;
                goto L39;
            } else {
            }
            goto L31;
        } else {
            if(_t171 == 27) {
                if(( *p & 0xff) - 33 <= 93) {
                    goto __eax;
                }
                return 0;
            } else {
                goto L38;
            }
        }
L10:
        if(_t171 == 37) {
            goto L35;
        } else {
        }
L38:
        return 0;
L35:
        if(( *p & 0xff) != 47) {
            state = 0;
            f =  *p & 0xff;
        } else {
            cs = 165;
            state = cs & 0xff;
        }
        goto L39;
L13:
        if(_t171 > 165) {
            if(_t171 == 168 || _t171 == 172) {
                goto L34;
            } else {
            }
            goto L38;
        }
        if(_t171 == 44 || _t171 == 161) {
            goto L34;
        } else {
        }
        goto L38;
L33:
        cs = 161;
        state = cs & 0xff;
        g =  *p & 3;
        goto L39;
    }
    if(f <= 63 || f > 126) {
        return 0;
    }
    _t154 = cs & 255;
    if(_t154 == 47) {
        st->state = 32;
    } else {
        if(_t154 > 47) {
            if(_t154 == 168) {
                 *(st + ((g & 255) + 4) * 4) = f & 255;
            } else {
                if(_t154 == 172) {
                     *(st + ((g & 255) + 4) * 4) = f & 255;
                } else {
                    if(_t154 == 161) {
                         *(st + ((g & 255) + 4) * 4) = f & 255;
                    }
                }
            }
        } else {
            if(_t154 == 40) {
                 *(st + ((g & 255) + 4) * 4) = f & 255;
            } else {
                if(_t154 == 44) {
                     *(st + ((g & 255) + 4) * 4) = f & 255;
                } else {
                    if(_t154 == 37) {
                        if(f != 64) {
                            st->state = 16;
                        } else {
                            st->state = 0;
                        }
                    }
                }
            }
        }
    }
     *ptr = p - 1;
    return 1;
}

wc_push_to_iso2022(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B871B  --  defined in 'iso2022.c' at line 397
    wc_uchar g;       // _cfa_fffffff3
    wc_bool is_wide;   // _cfa_fffffff2
    wc_bool retry;     // _cfa_fffffff1
    _unknown_ _v20;                        // _cfa_ffffffec
    wc_wchar_t cc2;   // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    wc_wchar_t cc2;   // _cfa_ffffffe0
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    signed int _t190;                      // _t190
    _unknown_ _t207;                       // _t207
    _unknown_ _t220;                       // _t220
    _unknown_ _t230;                       // _t230
    _unknown_ _t251;                       // _t251
    _unknown_ _t275;                       // _t275

    g = 0;
    is_wide = 0;
    retry = 0;
    while(1) {
        _t190 = cc.ccs & 65280;
        if(_t190 == 16384) {
            goto L39;
        } else {
            goto L2;
        }
    }
}

wc_push_to_iso2022_end(Str os, wc_status* st)
{// addr = 0x080B8B9C  --  defined in 'iso2022.c' at line 503
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if( *((intOrPtr*)(st + 20)) != 0 &&  *((intOrPtr*)(st + 20)) !=  *(st + 12)) {
        wc_push_iso2022_esc(os,  *(st + 12), 41, 0, st);
    }
    wc_push_iso2022_esc(os,  *(st + 8), 40, 1, st);
    return;
}

wc_push_iso2022_esc(Str os, wc_ccs ccs, wc_uchar g, wc_uint8 invoke, wc_status* st)
{// addr = 0x080B8C16  --  defined in 'iso2022.c' at line 511
    wc_uint8 g_invoke;   // _cfa_fffffff3
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __ebp;                       // r6
    signed int _t259;                      // _t259
    int _t268;                             // _t268
    int _t282;                             // _t282
    int _t294;                             // _t294
    int _t308;                             // _t308
    int _t320;                             // _t320
    int _t336;                             // _t336
    int _t350;                             // _t350
    int _t364;                             // _t364
    int _t378;                             // _t378
    int _t391;                             // _t391
    int _t405;                             // _t405
    int _t417;                             // _t417

    _v32 = _a12 & 255;
    _v36 = _a16 & 255;
    g_invoke = _v32 & 3;
    if( *(st + ((g_invoke & 255) + 4) * 4) == ccs) {
L22:
        if(_v36 == 0) {
            return;
        }
        goto L23;
L49:
        return;
    } else {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t350 = os->length;
         *((char*)(os->ptr + _t350)) = 27;
        os->length = _t350 + 1;
         *(os->ptr + os->length) = 0;
        if((ccs & 98304) == 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t364 = os->length;
             *(os->ptr + _t364) = _v32 & 0xff;
            os->length = _t364 + 1;
             *(os->ptr + os->length) = 0;
            if((ccs & 1792) == 1024) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t391 = os->length;
                 *((char*)(os->ptr + _t391)) = 33;
                os->length = _t391 + 1;
                 *(os->ptr + os->length) = 0;
            }
            goto L19;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t405 = os->length;
         *((char*)(os->ptr + _t405)) = 36;
        os->length = _t405 + 1;
         *(os->ptr + os->length) = 0;
        if(g_invoke != 0 || ccs != 33088 && ccs != 33090 && ccs != 33089) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t417 = os->length;
             *(os->ptr + _t417) = _v32 & 0xff;
            os->length = _t417 + 1;
             *(os->ptr + os->length) = 0;
        }
L19:
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t378 = os->length;
         *(os->ptr + _t378) = ccs & 255;
        os->length = _t378 + 1;
         *(os->ptr + os->length) = 0;
         *(st + ((g_invoke & 255) + 4) * 4) = ccs;
        goto L22;
    }
L23:
    _t259 = g_invoke & 255;
    if(_t259 == 1) {
        if(( *(st + 5) & 0xff) == 1) {
            goto L50;
        }
        goto L35;
    }
    if(_t259 > 1) {
        if(_t259 == 2) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t282 = os->length;
             *((char*)(os->ptr + _t282)) = 27;
            os->length = _t282 + 1;
             *(os->ptr + os->length) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t294 = os->length;
             *((char*)(os->ptr + _t294)) = 78;
            os->length = _t294 + 1;
             *(os->ptr + os->length) = 0;
            return;
        }
        goto L28;
    }
    if(_t259 == 0) {
        if(( *(st + 5) & 0xff) == 0) {
            goto L49;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t336 = os->length;
         *((char*)(os->ptr + _t336)) = 15;
        os->length = _t336 + 1;
         *(os->ptr + os->length) = 0;
         *(st + 5) = 0;
        return;
L50:
        return;
    }
    return;
L28:
    if(_t259 == 3) {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t308 = os->length;
         *((char*)(os->ptr + _t308)) = 27;
        os->length = _t308 + 1;
         *(os->ptr + os->length) = 0;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t320 = os->length;
         *((char*)(os->ptr + _t320)) = 79;
        os->length = _t320 + 1;
         *(os->ptr + os->length) = 0;
        return;
    }
    return;
L35:
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t268 = os->length;
     *((char*)(os->ptr + _t268)) = 14;
    os->length = _t268 + 1;
     *(os->ptr + os->length) = 0;
     *(st + 5) = 1;
    return;
}

wc_push_to_euc(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B90B4  --  defined in 'iso2022.c' at line 560
    wc_ccs g1_ccs;      // _cfa_fffffff0
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    wc_status* _v48;   // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    unsigned int _t118;                    // _t118
    int _t125;                             // _t125
    unsigned int _t135;                    // _t135
    int _t152;                             // _t152
    int _t168;                             // _t168
    int _t180;                             // _t180

    g1_ccs =  *(st->ces_info->gset + 8);
    while(cc.ccs != g1_ccs) {
        _t118 = cc.ccs;
        if(_t118 == 16385) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t125 = os->length;
             *(os->ptr + _t125) = (cc.code | 128) & 255;
            os->length = _t125 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t118 > 16385) {
            if(_t118 < 34831) {
            } else {
                if(_t118 <= 34834) {
                    if(st->ces_info->id != 3149849) {
                        goto L28;
                    } else {
                        _v56 = cc.ccs;
                        _v52 = cc.code;
                         *__esp =  &(cc.ccs);
                        wc_johab_to_ksx1001();
                        __esp = __esp - 4;
                        continue;
                    }
                    goto L35;
                }
                if(_t118 == 49152) {
                    if(( *135119022 & 0xff) != 0) {
                        return;
                    }
                    Strcat_charp(os, WcReplaceW);
                    return;
                }
            }
            goto L28;
        }
        if(_t118 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t152 = os->length;
             *(os->ptr + _t152) = cc.code & 255;
            os->length = _t152 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t118 != 16384) {
            goto L11;
        }
        if(( *135119022 & 0xff) != 0) {
        } else {
            goto L25;
        }
        goto L35;
L25:
        Strcat_charp(os, WcReplace);
        return;
L11:
L28:
        if(( *135119011 & 0xff) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t135 = 16384;
            } else {
                _t135 = 49152;
            }
            cc.ccs = _t135;
        } else {
            _v48 = st;
            _v56 = cc.ccs;
            _v52 = cc.code;
             *__esp =  &_v36;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v36;
            cc.code = _v32;
        }
        continue;
L35:
        return;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t168 = os->length;
     *(os->ptr + _t168) = (cc.code >> 8 | 128) & 255;
    os->length = _t168 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t180 = os->length;
     *(os->ptr + _t180) = (cc.code | 128) & 255;
    os->length = _t180 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

wc_push_to_eucjp(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B9358  --  defined in 'iso2022.c' at line 606
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t229;                    // _t229
    int _t236;                             // _t236
    int _t248;                             // _t248
    int _t272;                             // _t272
    unsigned int _t285;                    // _t285
    int _t300;                             // _t300
    int _t316;                             // _t316
    int _t328;                             // _t328
    int _t345;                             // _t345
    int _t358;                             // _t358

    while(1) {
        _t229 = cc.ccs;
        if(_t229 == 33090) {
            break;
        }
        if(_t229 > 33090) {
            if(_t229 == 33103) {
                if(( *135119019 & 0xff) != 0) {
                    goto L70;
                }
                goto L31;
L70:
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t236 = os->length;
                 *(os->ptr + _t236) = (cc.code >> 8 | 128) & 255;
                os->length = _t236 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t248 = os->length;
                 *(os->ptr + _t248) = (cc.code | 128) & 255;
                os->length = _t248 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L11;
L31:
            if(( *135119011 & 0xff) == 0 || ( *135119018 & 0xff) == 0) {
                cc.ccs = 49152;
            } else {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &_v20;
                wc_jisx0213_to_jisx0212();
                __esp = __esp - 4;
                cc.ccs = _v20;
                cc.code = _v16;
            }
            goto L75;
        }
        if(_t229 == 329) {
            if(( *135119017 & 0xff) == 0) {
                if(( *135119013 & 0xff) == 0) {
                    _v40 = cc.ccs;
                    _v36 = cc.code;
                     *__esp =  &(cc.ccs);
                    wc_jisx0201k_to_jisx0208();
                    __esp = __esp - 4;
                } else {
                    cc.ccs = 16384;
                }
                goto L75;
            }
            goto L21;
        }
        if(_t229 > 329) {
            if(_t229 == 16384) {
                if(( *135119022 & 0xff) != 0) {
L77:
                    return;
                }
                goto L60;
            }
            goto L8;
L60:
            Strcat_charp(os, WcReplace);
            return;
        }
        if(_t229 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t358 = os->length;
             *(os->ptr + _t358) = cc.code & 255;
            os->length = _t358 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        } else {
        }
L61:
        if(( *135119011 & 0xff) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t285 = 16384;
            } else {
                _t285 = 49152;
            }
            cc.ccs = _t285;
        } else {
            _v32 = st;
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &_v20;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v20;
            cc.code = _v16;
        }
L75:
        continue;
L8:
        if(_t229 == 16385) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t345 = os->length;
             *(os->ptr + _t345) = (cc.code | 128) & 255;
            os->length = _t345 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        goto L61;
L21:
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t316 = os->length;
         *((char*)(os->ptr + _t316)) = 142;
        os->length = _t316 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t328 = os->length;
         *(os->ptr + _t328) = (cc.code | 128) & 255;
        os->length = _t328 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
L11:
        if(_t229 > 33103) {
            if(_t229 == 33104) {
                if(( *135119019 & 0xff) == 0) {
                    if(( *135119011 & 0xff) == 0 || ( *135119018 & 0xff) == 0) {
                        cc.ccs = 49152;
                    } else {
                        _v40 = cc.ccs;
                        _v36 = cc.code;
                         *__esp =  &_v20;
                        wc_jisx0213_to_jisx0212();
                        __esp = __esp - 4;
                        cc.ccs = _v20;
                        cc.code = _v16;
                    }
                    goto L75;
                }
                goto L46;
            }
            goto L15;
L46:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t272 = os->length;
             *((char*)(os->ptr + _t272)) = 143;
            os->length = _t272 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            goto L70;
        }
        if(_t229 == 33092) {
            if(( *135119018 & 0xff) == 0) {
                if(( *135119011 & 0xff) == 0 || ( *135119019 & 0xff) == 0) {
                    cc.ccs = 49152;
                } else {
                    _v40 = cc.ccs;
                    _v36 = cc.code;
                     *__esp =  &_v20;
                    wc_jisx0212_to_jisx0213();
                    __esp = __esp - 4;
                    cc.ccs = _v20;
                    cc.code = _v16;
                }
                goto L75;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t300 = os->length;
             *((char*)(os->ptr + _t300)) = 143;
            os->length = _t300 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            goto L70;
        }
        goto L61;
L15:
        if(_t229 == 49152) {
            if(( *135119022 & 0xff) != 0) {
                return;
            }
            goto L58;
        }
        goto L61;
L58:
        Strcat_charp(os, WcReplaceW);
        return;
    }
    goto L70;
}

wc_push_to_euctw(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B9879  --  defined in 'iso2022.c' at line 686
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    unsigned int _t169;                    // _t169
    _unknown_ _t173;                       // _t173
    _unknown_ _t182;                       // _t182
    _unknown_ _t194;                       // _t194
    _unknown_ _t206;                       // _t206
    _unknown_ _t218;                       // _t218
    _unknown_ _t237;                       // _t237
    _unknown_ _t249;                       // _t249
    _unknown_ _t266;                       // _t266
    _unknown_ _t279;                       // _t279

    while(1) {
        _t169 = cc.ccs;
        if(_t169 > 33101) {
            goto L10;
        } else {
            goto L2;
        }
    }
}

wc_push_to_iso8859(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B9C24  --  defined in 'iso2022.c' at line 743
    wc_ccs g1_ccs;      // _cfa_fffffff0
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t89;                     // _t89
    int _t99;                              // _t99
    unsigned int _t112;                    // _t112
    int _t121;                             // _t121
    int _t134;                             // _t134

    g1_ccs =  *(st->ces_info->gset + 8);
    while(cc.ccs != g1_ccs) {
        _t89 = cc.ccs;
        if(_t89 != 16384) {
            if(_t89 > 16384) {
                if(_t89 == 16385) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t99 = os->length;
                     *(os->ptr + _t99) = (cc.code | 128) & 255;
                    os->length = _t99 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
            } else {
                if(_t89 == 322) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t121 = os->length;
                     *(os->ptr + _t121) = cc.code & 255;
                    os->length = _t121 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
L22:
                if(( *135119011 & 0xff) == 0) {
                    if((cc.ccs & 98304) == 0) {
                        _t112 = 16384;
                    } else {
                        _t112 = 49152;
                    }
                    cc.ccs = _t112;
                } else {
                    _v32 = st;
                    _v40 = cc.ccs;
                    _v36 = cc.code;
                     *__esp =  &(cc.ccs);
                    wc_any_to_any_ces();
                    __esp = __esp - 4;
                }
                continue;
            }
            if(_t89 == 49152) {
                if(( *135119022 & 0xff) != 0) {
                    return;
                }
                goto L19;
            }
            goto L22;
L19:
            Strcat_charp(os, WcReplaceW);
            return;
        }
        if(( *135119022 & 0xff) != 0) {
        } else {
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L29;
L31:
L29:
        return;
        goto L31;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t134 = os->length;
     *(os->ptr + _t134) = (cc.code | 128) & 255;
    os->length = _t134 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

wc_create_gmap(wc_status* st)
{// addr = 0x080B9E12  --  defined in 'iso2022.c' at line 780
    wc_gset* gset;     // _cfa_fffffff8
    wc_uchar* gset_ext;   // _cfa_fffffff4
    int i;                                 // _cfa_fffffff0
    int f;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    signed int _t133;                      // _t133
    signed int _t138;                      // _t138

    gset = st->ces_info->gset;
    gset_ext = st->ces_info->gset_ext;
    if(( *135119020 & 0xff) == 0) {
        i = 0;
        while(i <= 63) {
             *( &cs94_gmap + i) =  *gset_ext & 0xff;
             *( &cs96_gmap + i) = gset_ext[1] & 0xff;
             *( &cs94w_gmap + i) = gset_ext[2] & 0xff;
             *( &cs96w_gmap + i) = gset_ext[3] & 0xff;
             *( &cs942_gmap + i) =  *gset_ext & 0xff;
            i = i + 1;
        }
    } else {
        i = 0;
        while(i <= 63) {
            goto L8;
        }
    }
L8:
    i = 0;
    while( *(gset + (i << 3)) != 0) {
        f = ( *(gset + (i << 3)) & 255) - 64;
        _t133 =  *(gset + (i << 3)) & 65280;
        if(_t133 == 1024) {
             *( &cs942_gmap + f) = (gset + (i << 3))[1] & 0xff;
L35:
            i = i + 1;
            continue;
        }
        if(_t133 > 1024) {
            if(_t133 == 33024) {
                _t138 =  *(gset + (i << 3));
                if(_t138 == 33092) {
                    if(( *135119018 & 0xff) != 0) {
                        goto L29;
                    }
                    goto L25;
L29:
                     *( &cs94w_gmap + f) = (gset + (i << 3))[1] & 0xff;
                    goto L35;
                }
                goto L21;
L25:
                goto L35;
            }
            goto L15;
L21:
            if(_t138 < 33092 || _t138 - 33103 > 1) {
                goto L29;
            }
            if(( *135119019 & 0xff) == 0) {
            } else {
                goto L29;
            }
            goto L35;
        }
        if(_t133 == 256) {
            if( *(gset + (i << 3)) != 329 || ( *135119017 & 0xff) != 0) {
                 *( &cs94_gmap + f) = (gset + (i << 3))[1] & 0xff;
            }
        } else {
            if(_t133 == 512) {
                 *( &cs96_gmap + f) = (gset + (i << 3))[1] & 0xff;
            }
        }
        goto L35;
L15:
        if(_t133 == 33280) {
             *( &cs96w_gmap + f) = (gset + (i << 3))[1] & 0xff;
        }
        goto L35;
    }
    return;
}

Str wc_char_conv_from_iso2022(wc_uchar c, wc_status* st)
{// addr = 0x080BA052  --  defined in 'iso2022.c' at line 843
    wc_uchar* p;      // _cfa_fffffff0
    wc_ccs gl_ccs;      // _cfa_ffffffec
    wc_ccs gr_ccs;      // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    unsigned int _t63;                     // _t63
    unsigned int _t69;                     // _t69
    _unknown_ _t75;                        // _t75

    _v32 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.4122 = Strnew_size(8);
        nbuf = 0;
    }
    if(( *(st + 6) & 0xff) == 0) {
        _t63 =  *(st + (( *(st + 5) & 0xff) + 4) * 4);
    } else {
        _t63 =  *(st + (( *(st + 6) & 0xff) + 4) * 4);
    }
    gl_ccs = _t63;
    if(( *(st + 6) & 0xff) == 0) {
        _t69 =  *(st + (( *(st + 4) & 0xff) + 4) * 4);
    } else {
        _t69 =  *(st + (( *(st + 6) & 0xff) + 4) * 4);
    }
    gr_ccs = _t69;
    if(st->state <= 44) {
        goto __eax;
    }
     *(st + 6) = 0;
    st->state = -1;
    return os.4122;
}

wc_wchar_t wc_jisx0201k_to_jisx0208(wc_wchar_t cc)
{// addr = 0x080BA840  --  defined in 'jis.c' at line 13
    _unknown_ __ebp;                       // r6
    unsigned int _t18;                     // _t18

    __ecx = _a4;
    cc.code =  *((cc.code & 127) +  &jisx0201k_jisx0208_map + (cc.code & 127)) & 0xffff;
    if(cc.code == 0) {
        _t18 = 49152;
    } else {
        _t18 = 33090;
    }
    cc.ccs = _t18;
     *__ecx = cc.ccs;
     *(__ecx + 4) = cc.code;
    return __ecx;
}

wc_wchar_t wc_jisx0212_to_jisx0213(wc_wchar_t cc)
{// addr = 0x080BA881  --  defined in 'jis.c' at line 21
    _unknown_ _v8;                         // _cfa_fffffff8
    intOrPtr _v16;                         // _cfa_fffffff0
    wc_wchar_t cc2;   // _cfa_ffffffec
    wc_table* _v32;   // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    struct  _t29;             // _t29
    _unknown_ _t30;                        // _t30

    _push(__ebx);
    __esp = __esp - 36;
    _t29 = _a4;
    if(t1.2377 == 0) {
        t1.2377 = wc_get_ucs_table(33103);
        t2.2378 = wc_get_ucs_table(33104);
    }
    _v32 = t2.2378;
    _v40 = cc.ccs;
    _v36 = cc.code;
    __esp->auto_detect =  &(cc2.ccs);
    wc_any_to_any();
    __esp = __esp - 4;
    if(cc2.ccs != 33092) {
        _v36 = t1.2377;
        _v44 = cc.ccs;
        _v40 = cc.code;
         *__esp = _t29;
        wc_any_to_any();
        __esp = __esp - 4;
    } else {
         *_t29 = cc2.ccs;
         *((intOrPtr*)(_t29 + 4)) = _v16;
    }
    return _t29;
}

wc_wchar_t wc_jisx0213_to_jisx0212(wc_wchar_t cc)
{// addr = 0x080BA91D  --  defined in 'jis.c' at line 43
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table* _v16;   // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    struct  _t14;             // _t14
    _unknown_ _t15;                        // _t15

    _push(__ebx);
    __esp = __esp - 20;
    _t14 = _a4;
    if(t.2393 == 0) {
        t.2393 = wc_get_ucs_table(33092);
    }
    _v16 = t.2393;
    _v24 = cc.ccs;
    _v20 = cc.code;
     *__esp = _t14;
    wc_any_to_any();
    __esp = __esp - 4;
    return _t14;
}

wc_ccs wc_jisx0208_or_jisx02131(wc_uint16 code)
{// addr = 0x080BA96C  --  defined in 'jis.c' at line 58
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    _v16 = _a4 & 65535;
    if(wc_map_range_search(_v16 & 0x7f7f, "/"9"B"I"Q"["k"q"z"}"!#/#:##[#`#{#~#t$~$w%~%9&@&Y&~&B'P'r'~'A(~/TO~O%t~~", 18) == 0) {
        return 33090;
    }
    return 33103;
}

wc_ccs wc_jisx0212_or_jisx02132(wc_uint16 code)
{// addr = 0x080BA9AC  --  defined in 'jis.c' at line 66
    signed short _v8;                      // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18

    _v8 = _a4 & 65535;
    if(( *(wc_jisx0212_jisx02132_map + (_v8 & 0x7f)) & 0xff) == 0) {
        return 33092;
    }
    return 33104;
}

wc_wchar_t wc_johab_to_ksx1001(wc_wchar_t cc)
{// addr = 0x080BA9E4  --  defined in 'johab.c' at line 74
    _unknown_ _v8;                         // _cfa_fffffff8
    unsigned int _v16;                     // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    wc_table* _v32;   // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    unsigned int _t28;                     // _t28
    _unknown_ _t39;                        // _t39
    struct  _t41;             // _t41
    _unknown_ _t42;                        // _t42

    _push(__ebx);
    __esp = __esp - 36;
    _t41 = _a4;
    _t28 = cc.ccs;
    if(_t28 > 34833) {
        if(_t28 == 34834) {
            if(cc.code <= 8480) {
                cc.ccs = 49152;
            } else {
                cc.ccs = 33091;
            }
        }
L15:
         *_t41 = cc.ccs;
         *(_t41 + 4) = cc.code;
        goto L16;
    }
    if(_t28 >= 34832) {
        if(( *135119011 & 0xff) == 0) {
            cc.ccs = 49152;
        } else {
            if(t.2389 == 0) {
                t.2389 = wc_get_ucs_table(33091);
            }
            _v32 = t.2389;
            _v40 = cc.ccs;
            _v36 = cc.code;
            __esp->auto_detect =  &(cc.ccs);
            wc_any_to_any();
            __esp = __esp - 4;
        }
        goto L15;
    }
    if(_t28 == 34831) {
        _v40 = cc.ccs;
        _v36 = cc.code;
        __esp->auto_detect =  &_v20;
        wc_johab_to_cs128w();
        __esp = __esp - 4;
        _v44 = _v20;
        _v40 = _v16;
         *__esp = _t41;
        wc_johab_to_ksx1001();
        __esp = __esp - 4;
        goto L16;
    } else {
    }
    goto L15;
L16:
    return _t41;
}

wc_wchar_t wc_ksx1001_to_johab(wc_wchar_t cc)
{// addr = 0x080BAAD5  --  defined in 'johab.c' at line 105
    _unknown_ _v8;                         // _cfa_fffffff8
    unsigned int _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    struct  _t41;             // _t41
    _unknown_ _t42;                        // _t42

    _push(__ebx);
    __esp = __esp - 20;
    _t41 = _a4;
    cc.code = cc.code & 32639;
    if(cc.code <= 8480 || cc.code > 9248) {
        if(cc.code <= 9299 || cc.code > 11390) {
            if(cc.code <= 18976 || cc.code > 32126) {
                if(( *135119011 & 0xff) == 0) {
                    cc.ccs = 49152;
                } else {
                     *__esp = cc.ccs;
                    _v24 = cc.code;
                    _v24 = wc_any_to_ucs();
                    wc_ucs_to_johab( &(cc.ccs));
                    __esp = __esp - 4;
                }
                 *_t41 = cc.ccs;
                 *(_t41 + 4) = cc.code;
L11:
                return _t41;
            }
        }
    }
    cc.ccs = 34834;
     *_t41 = cc.ccs;
     *(_t41 + 4) = cc.code;
    goto L11;
}

wc_wchar_t wc_ucs_to_johab(wc_uint32 ucs)
{// addr = 0x080BAB86  --  defined in 'johab.c' at line 125
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table* t;      // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    wc_wchar_t cc;   // _cfa_ffffffe8
    unsigned int _v32;                     // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    wc_table* _v52;   // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct  _t41;             // _t41
    _unknown_ _t42;                        // _t42

    _push(__ebx);
    __esp = __esp - 52;
    _t41 = _a4;
    if(ucs <= 44031 || ucs > 55203) {
        if(ucs <= 12592 || ucs > 12643) {
            t = wc_get_ucs_table(34834);
            _v52 = t;
            wc_ucs_to_any( &_v36, ucs);
            __esp = __esp - 4;
            cc.ccs = _v36;
            _v20 = _v32;
        } else {
            t = wc_get_ucs_table(34833);
            _v52 = t;
            wc_ucs_to_any( &(cc.ccs), ucs);
            __esp = __esp - 4;
        }
    } else {
        ucs = ucs - 44032;
        _v20 = wc_N_to_johab1(ucs);
        cc.ccs = 34831;
    }
     *_t41 = cc.ccs;
     *(_t41 + 4) = _v20;
    return _t41;
}

wc_uint32 wc_johab1_to_N(wc_uint32 code)
{// addr = 0x080BAC4A  --  defined in 'johab.c' at line 146
    wc_uint32 a;     // _cfa_fffffff8
    wc_uint32 b;     // _cfa_fffffff4
    wc_uint32 c;     // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t38;                        // _t38

    a =  *( &johab1_N_map + (code >> 10 & 31)) & 0xff;
    b =  *((code >> 5 & 31) + 135118400) & 0xff;
    c =  *((code & 31) + 135118432) & 0xff;
    if(a != 0 && b != 0 && c != 0) {
        return 0 + (((a << 2) + a << 2) + a + b << 2) * 8 - (((a << 2) + a << 2) + a + b << 2) + c - 617;
    }
    return -1;
}

wc_uint32 wc_N_to_johab1(wc_uint32 code)
{// addr = 0x080BACD4  --  defined in 'johab.c' at line 159
    wc_uint32 a;     // _cfa_fffffff8
    wc_uint32 b;     // _cfa_fffffff4
    wc_uint32 c;     // _cfa_fffffff0
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t49;                        // _t49
    _unknown_ _t56;                        // _t56
    _unknown_ _t58;                        // _t58
    _unknown_ _t71;                        // _t71
    signed int _t83;                       // _t83
    unsigned int _t84;                     // _t84
    _unknown_ _t85;                        // _t85
    _unknown_ _t89;                        // _t89
    _unknown_ _t91;                        // _t91
    _unknown_ _t99;                        // _t99

    _v24 = code;
    a =  *( &N_johab1_map + (_v24 * -555131827 >> 32 >> 9)) & 0xff;
    _v24 = code >> 2;
    _t83 = _v24 * 613566757 >> 32;
    b =  *(_t83 - (((_t83 * -2045222521 >> 32) + (_t83 - (_t83 * -2045222521 >> 32) >> 1) >> 4 << 2) + ((_t83 * -2045222521 >> 32) + (_t83 - (_t83 * -2045222521 >> 32) >> 1) >> 4) << 2) + ((_t83 * -2045222521 >> 32) + (_t83 - (_t83 * -2045222521 >> 32) >> 1) >> 4) + 135118496) & 0xff;
    _t84 = code;
    _v24 = _t84 >> 2;
    c =  *(_t84 - 0 + (_v24 * 613566757 >> 32 << 2) * 8 - (_v24 * 613566757 >> 32 << 2) + 135118528) & 0xff;
    return b << 5 | a << 10 | c;
}

wc_wchar_t wc_johab_to_cs128w(wc_wchar_t cc)
{// addr = 0x080BAD93  --  defined in 'johab.c' at line 200
    wc_uchar ub;      // _cfa_fffffff7
    wc_uchar lb;      // _cfa_fffffff6
    wc_uint32 n;     // _cfa_fffffff0
    struct  __ebx;            // r1
    _unknown_ __ebp;                       // r6
    signed int _t68;                       // _t68
    _unknown_ _t81;                        // _t81
    _unknown_ _t102;                       // _t102

    __ebx = _a4;
    if(cc.code > 55295) {
        ub = cc.code >> 8 & 255;
        lb = cc.code & 255;
        if(ub > 223) {
            ub = (ub & 255) + 32 + (ub & 255) + 32 + 74 & 255;
        } else {
            ub = (ub & 255) + 40 + (ub & 255) + 40 + 31 & 255;
        }
        if(lb > 160) {
            ub = ub + 1;
            lb = lb + 128;
        } else {
            if(lb > 144) {
                _t68 = 34;
            } else {
                _t68 = 16;
            }
            lb = lb - (_t68 & 255);
        }
        cc.code = lb & 255 | (ub & 255) << 8;
        cc.ccs = 34834;
    } else {
        n = wc_johab1_to_N(cc.code);
        if(n == 255) {
            _t102 = (cc.code >> 8 & 255) * (cc.code >> 8 & 255) + (cc.code & 255);
            if((cc.code & 255) > 128) {
                _t81 = 67;
            } else {
                _t81 = 65;
            }
            n = _t102 - _t81 - 24816;
            cc.code = (n >> 7 << 8) + (n & 127);
            cc.ccs = 34833;
        } else {
            cc.code = ((n >> 7) + 33 << 8) + (n & 127);
            cc.ccs = 34832;
        }
    }
     *__ebx = cc.ccs;
     *(__ebx + 4) = cc.code;
    return __ebx;
}

wc_wchar_t wc_cs128w_to_johab(wc_wchar_t cc)
{// addr = 0x080BAED3  --  defined in 'johab.c' at line 226
    wc_uchar ub;      // _cfa_ffffffef
    wc_uchar lb;      // _cfa_ffffffee
    wc_uint32 n;     // _cfa_ffffffe8
    unsigned int _v36;                     // _cfa_ffffffdc
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ __ebp;                       // r6
    unsigned int _t85;                     // _t85
    _unknown_ _t94;                        // _t94
    _unknown_ _t102;                       // _t102
    _unknown_ _t107;                       // _t107
    signed int _t119;                      // _t119
    signed int _t127;                      // _t127
    _unknown_ _t144;                       // _t144
    _unknown_ _t147;                       // _t147
    _unknown_ _t149;                       // _t149
    _unknown_ _t151;                       // _t151
    signed int _t161;                      // _t161

    __esi = _a4;
    _t85 = cc.ccs;
    if(_t85 == 34833) {
        n = ((cc.code >> 8 & 127) << 7) + (cc.code & 127);
        _v36 = n;
        _t161 = (_v36 * -1370734243 >> 32 >> 7) + 132 << 8;
        _t144 = n - n * -1370734243 * (_t139 * -1370734243 >> 32 >> 7);
        if(n - (n * -1370734243 >> 32 >> 7) * (n * -1370734243 >> 32 >> 7) > 61) {
            _t107 = 67;
        } else {
            _t107 = 65;
        }
        cc.code = _t161 + _t144 + _t107;
    } else {
        if(_t85 == 34834) {
            ub = cc.code >> 8 & 0x7f;
            lb = cc.code & 0x7f;
            if(ub > 73) {
                ub = ub - 74;
                if((ub & 1) == 0) {
                    if(lb > 110) {
                        _t119 = 34;
                    } else {
                        _t119 = 16;
                    }
                } else {
                    _t119 = -128;
                }
                lb = lb + (_t119 & 255);
                ub = (ub & 255) - 32 & 255;
            } else {
                ub = ub - 31;
                if((ub & 1) == 0) {
                    if(lb > 110) {
                        _t127 = 34;
                    } else {
                        _t127 = 16;
                    }
                } else {
                    _t127 = -128;
                }
                lb = lb + (_t127 & 255);
                ub = (ub & 255) - 40 & 255;
            }
            cc.code = lb & 255 | (ub & 255) << 8;
        } else {
            if(_t85 == 34832) {
                n = ((cc.code >> 8 & 127) + 33554399 << 7) + (cc.code & 127);
                cc.code = wc_N_to_johab1(n);
            }
        }
    }
    cc.ccs = 34831;
     *__esi = cc.ccs;
     *(__esi + 4) = cc.code;
    return __esi;
}

Str wc_conv_from_johab(Str is, wc_ces ces)
{// addr = 0x080BB07C  --  defined in 'johab.c' at line 251
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t126;                             // _t126
    signed int _t168;                      // _t168
    int _t177;                             // _t177

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while(p < ep && ( *p & 0xff) >= 0) {
    }
    if(p != ep) {
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
        while(p < ep) {
            _t126 = state;
            if(_t126 == 1) {
                if(( *( &WC_JOHAB_MAP + ( *p & 0xff)) & 0x10) == 0) {
                    wtf_push_unknown(os, p - 1, 2);
                } else {
                    wtf_push(os, 34831,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
                }
                state = 0;
                goto L29;
            }
            if(_t126 == 2) {
                if(( *( &WC_JOHAB_MAP + ( *p & 0xff)) & 0x20) == 0) {
                    wtf_push_unknown(os, p - 1, 2);
                } else {
                    wtf_push(os, 34831,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
                }
                state = 0;
                goto L29;
            }
            if(_t126 != 0) {
L29:
                p =  &(p[1]);
                continue;
            }
            _t168 =  *( &WC_JOHAB_MAP + ( *p & 0xff)) & 0xf;
            if(_t168 == 4) {
                state = 2;
                goto L20;
            }
            if(_t168 == 8) {
                goto L16;
            }
            if(_t168 != 2) {
                goto L17;
            }
            state = 1;
L20:
            goto L29;
L17:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t177 = os->length;
             *(os->ptr + _t177) =  *p & 0xff;
            os->length = _t177 + 1;
             *(os->ptr + os->length) = 0;
            goto L29;
L16:
            wtf_push_unknown(os, p, 1);
            goto L20;
        }
        if(state - 1 <= 1) {
            wtf_push_unknown(os, p - 1, 1);
        }
        return os;
    }
    return is;
}

wc_push_to_johab(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BB2FB  --  defined in 'johab.c' at line 311
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t96;                     // _t96
    int _t103;                             // _t103
    int _t115;                             // _t115
    unsigned int _t130;                    // _t130
    int _t145;                             // _t145

    while(1) {
        _t96 = cc.ccs;
        if(_t96 == 34831) {
            break;
        }
        if(_t96 > 34831) {
            if(_t96 <= 34834) {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &(cc.ccs);
                wc_cs128w_to_johab();
                __esp = __esp - 4;
                break;
            }
            goto L8;
        }
        if(_t96 != 16384) {
            if(_t96 == 33091) {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &_v20;
                wc_ksx1001_to_johab();
                __esp = __esp - 4;
                cc.ccs = _v20;
                cc.code = _v16;
            } else {
                if(_t96 == 322) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t145 = os->length;
                     *(os->ptr + _t145) = cc.code & 255;
                    os->length = _t145 + 1;
                     *((char*)(os->ptr + os->length)) = 0;
                    return;
                }
L24:
                if(( *135119011 & 0xff) == 0) {
                    if((cc.ccs & 98304) == 0) {
                        _t130 = 16384;
                    } else {
                        _t130 = 49152;
                    }
                    cc.ccs = _t130;
                } else {
                    _v32 = st;
                    _v40 = cc.ccs;
                    _v36 = cc.code;
                     *__esp =  &_v20;
                    wc_any_to_any_ces();
                    __esp = __esp - 4;
                    cc.ccs = _v20;
                    cc.code = _v16;
                }
            }
            continue;
        }
        if(( *135119022 & 0xff) != 0) {
        } else {
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L31;
L33:
L31:
        return;
        goto L33;
L8:
        if(_t96 == 49152) {
            if(( *135119022 & 0xff) != 0) {
                return;
            }
            goto L21;
        }
        goto L24;
L21:
        Strcat_charp(os, WcReplaceW);
        return;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t103 = os->length;
     *(os->ptr + _t103) = cc.code >> 8 & 255;
    os->length = _t103 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t115 = os->length;
     *(os->ptr + _t115) = cc.code & 255;
    os->length = _t115 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_johab(wc_uchar c, wc_status* st)
{// addr = 0x080BB538  --  defined in 'johab.c' at line 350
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t59;                              // _t59
    signed int _t81;                       // _t81
    _unknown_ _t84;                        // _t84
    struct _Str* _t90;    // _t90
    _unknown_ _t98;                        // _t98
    int _t112;                             // _t112

    _v16 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.2826 = Strnew_size(8);
    }
    _t59 = st->state;
    if(_t59 == 1) {
        if(( *( &WC_JOHAB_MAP + (_v16 & 255)) & 0x10) != 0) {
            wtf_push(os.2826, 34831, (johabu & 0xff) << 8 | _v16 & 255);
        }
        goto L19;
    }
    if(_t59 == 2) {
        if(( *( &WC_JOHAB_MAP + (_v16 & 255)) & 0x20) != 0) {
            wtf_push(os.2826, 34831, (johabu & 0xff) << 8 | _v16 & 255);
        }
        goto L19;
    }
    if(_t59 != 0) {
L19:
        st->state = -1;
        return os.2826;
    }
    _t81 =  *( &WC_JOHAB_MAP + (_v16 & 255)) & 0xf;
    if(_t81 == 4) {
        johabu = _v16 & 0xff;
        st->state = 2;
        return 0;
    }
    if(_t81 == 8) {
        goto L10;
    }
    if(_t81 != 2) {
        goto L11;
    }
    johabu = _v16 & 0xff;
    st->state = 1;
    return 0;
L11:
    if(os.2826->length + 1 >= os.2826->area_size) {
        Strgrow(os.2826);
    }
    _t90 = os.2826;
    _t112 = _t90->length;
     *( *os.2826 + _t112) = _v16 & 0xff;
    _t90->length = _t112 + 1;
     *( *os.2826 + os.2826->length) = 0;
    goto L19;
L10:
    goto L19;
    return __eax;
}

wc_putc_init(wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080BB6E8  --  defined in 'putc.c' at line 10
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    wc_output_init(t_ces,  &putc_st);
    putc_str = Strnew_size(8);
    putc_f_ces = f_ces;
    putc_t_ces = t_ces;
    return;
}

wc_putc(char* c, FILE* f)
{// addr = 0x080BB724  --  defined in 'putc.c' at line 19
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uchar* p;      // _cfa_fffffff0
    wc_uchar** _v20;   // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    struct * _v36;            // _cfa_ffffffdc
    wc_uchar** _v40;   // _cfa_ffffffd8
    wc_uchar* _v44;   // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43

    _push(__ebx);
    __esp = __esp - 36;
    if(putc_f_ces == 3211264) {
        p = c;
    } else {
        p =  *(wc_Str_conv(Strnew_charp(c), putc_f_ces, 3211264));
    }
    Strclear(putc_str);
    while(( *p & 0xff) != 0) {
        _v40 =  &p;
        wtf_parse( &_v24);
        __esp = __esp - 4;
        _v36 =  &putc_st;
        _v44 = _v24;
        _v40 = _v20;
         *__esp = putc_str;
         *((intOrPtr*)( *((intOrPtr*)(putc_st.auto_detect + 24))))();
    }
    fwrite(putc_str->ptr, 1, putc_str->length, f);
    return;
}

wc_putc_end(FILE* f)
{// addr = 0x080BB7F1  --  defined in 'putc.c' at line 35
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16

    Strclear(putc_str);
    wc_push_end(putc_str,  &putc_st);
    if(putc_str->length != 0) {
        fwrite(putc_str->ptr, 1, putc_str->length, f);
        return;
    }
    return;
}

wc_putc_clear_status()
{// addr = 0x080BB853  --  defined in 'putc.c' at line 44
    _unknown_ __ebp;                       // r6

    if(( *(putc_st.auto_detect) & 2048) != 0) {
         *135790405 = 0;
         *135790404 = 0;
         *135790406 = 0;
         *135790416 = 0;
         *135790420 = 0;
         *135790424 = 0;
         *135790428 = 0;
        return;
    }
    return;
}

int map_cmp(* a, * b)
{// addr = 0x080BB8A8  --  defined in 'search.c' at line 6
    _unknown_ __ebp;                       // r6

    return ( *a & 0xffff) - ( *b & 0xffff);
}

int map3_cmp(* a, * b)
{// addr = 0x080BB8C5  --  defined in 'search.c' at line 12
    _unknown_ __ebp;                       // r6

    return  *a - ( *(b + 2) & 0xffff | ( *b & 0xffff) << 16);
}

int map_range_cmp(* a, * b)
{// addr = 0x080BB8EF  --  defined in 'search.c' at line 18
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    _unknown_ _t26;                        // _t26

    if(( *a & 0xffff) < ( *b & 0xffff)) {
        return -1;
    }
    return  *(b + 2) & 0xff;
}

int map2_range_cmp(* a, * b)
{// addr = 0x080BB922  --  defined in 'search.c' at line 25
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t24;                        // _t24
    _unknown_ _t26;                        // _t26

    if(( *a & 0xffff) < ( *b & 0xffff)) {
        return -1;
    }
    asm("setnb al");
    return  *(b + 4) & 0xff;
}

int map3_range_cmp(* a, * b)
{// addr = 0x080BB957  --  defined in 'search.c' at line 32
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20
    _unknown_ _t26;                        // _t26

    if(( *a & 0xffff) < ( *b & 0xffff)) {
        return -1;
    }
    return  *(b + 2) & 0xff;
}

wc_map* wc_map_search(wc_uint16 code, wc_map* map, size_t n)
{// addr = 0x080BB98A  --  defined in 'search.c' at line 39
    void _v16;                             // _cfa_fffffff0
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    _v16 = _a4 & 65535;
    _v44 = map_cmp;
    return bsearch( &_v16, map, n, 4);
}

wc_map3* wc_map3_search(wc_uint16 c1, wc_uint16 c2, wc_map3* map, size_t n)
{// addr = 0x080BB9C2  --  defined in 'search.c' at line 46
    wc_uint32 code;   // _cfa_fffffff0
    signed short _v32;                     // _cfa_ffffffe0
    signed short _v36;                     // _cfa_ffffffdc
    intOrPtr _v60;                         // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6

    _v32 = _a4 & 65535;
    _v36 = _a8 & 65535;
    code = _v36 & 65535 | (_v32 & 65535) << 16;
    _v60 = map3_cmp;
    return bsearch( &code, map, n, 6);
}

wc_map* wc_map_range_search(wc_uint16 code, wc_map* map, int n)
{// addr = 0x080BBA13  --  defined in 'search.c' at line 54
    void _v16;                             // _cfa_fffffff0
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    _v16 = _a4 & 65535;
    _v44 = map_range_cmp;
    return bsearch( &_v16, map, n, 4);
}

wc_map* wc_map2_range_search(wc_uint16 code, wc_map* map, size_t n)
{// addr = 0x080BBA4B  --  defined in 'search.c' at line 61
    void _v16;                             // _cfa_fffffff0
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    _v16 = _a4 & 65535;
    _v44 = map2_range_cmp;
    return bsearch( &_v16, map, n, 4);
}

wc_map3* wc_map3_range_search(wc_uint16 code, wc_map3* map, size_t n)
{// addr = 0x080BBA83  --  defined in 'search.c' at line 68
    void _v16;                             // _cfa_fffffff0
    intOrPtr _v44;                         // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    _v16 = _a4 & 65535;
    _v44 = map3_range_cmp;
    return bsearch( &_v16, map, n, 6);
}

wc_wchar_t wc_sjis_to_jis(wc_wchar_t cc)
{// addr = 0x080BBABC  --  defined in 'sjis.c' at line 80
    wc_uchar ub;      // _cfa_fffffffb
    wc_uchar lb;      // _cfa_fffffffa
    _unknown_ __ebp;                       // r6
    signed int _t70;                       // _t70
    signed int _t71;                       // _t71
    signed int _t75;                       // _t75

    __ecx = _a4;
    ub = cc.code >> 8 & 255;
    lb = cc.code & 255;
    if(ub > 239) {
        if(lb > 158) {
            ub =  *((ub & 255) - 240 + "($,.nprtvxz|~") & 0xff;
            lb = lb - 126;
        } else {
            ub =  *((ub & 255) - 240 + "!#%-/oqsuwy{}") & 0xff;
            if(lb <= 126) {
                _t70 = 31;
            } else {
                _t70 = 32;
            }
            lb = lb - (_t70 & 255);
        }
        cc.ccs = 33104;
    } else {
        if(ub > 159) {
            _t71 = -63;
        } else {
            _t71 = -127;
        }
        ub = ub - (_t71 & 255);
        ub = (ub & 255) + (ub & 255) + 33 & 255;
        if(lb > 158) {
            ub = ub + 1;
            lb = lb - 126;
        } else {
            if(lb <= 126) {
                _t75 = 31;
            } else {
                _t75 = 32;
            }
            lb = lb - (_t75 & 255);
        }
        cc.ccs = 33090;
    }
    cc.code = lb & 255 | (ub & 255) << 8;
     *__ecx = cc.ccs;
     *(__ecx + 4) = cc.code;
    return __ecx;
}

wc_wchar_t wc_jis_to_sjis(wc_wchar_t cc)
{// addr = 0x080BBB9A  --  defined in 'sjis.c' at line 98
    wc_uchar ub;      // _cfa_fffffffb
    wc_uchar lb;      // _cfa_fffffffa
    _unknown_ __ebp;                       // r6
    signed int _t64;                       // _t64
    signed int _t68;                       // _t68
    signed int _t76;                       // _t76

    __ecx = _a4;
    ub = cc.code >> 8 & 0x7f;
    lb = cc.code & 0x7f;
    if(cc.ccs != 33104) {
        if((ub & 1) == 0) {
            _t64 = 125;
        } else {
            _t64 = 31;
        }
        lb = lb + (_t64 & 255);
        if(lb > 126) {
            lb = lb + 1;
        }
        ub = (ub & 255) - 33 >> 1 & 255;
        if(ub > 30) {
            _t68 = -63;
        } else {
            _t68 = -127;
        }
        ub = ub + (_t68 & 255);
L17:
        cc.code = lb & 255 | (ub & 255) << 8;
         *__ecx = cc.ccs;
         *(__ecx + 4) = cc.code;
L18:
        return __ecx;
    }
    if((ub & 1) == 0) {
        _t76 = 125;
    } else {
        _t76 = 31;
    }
    lb = lb + (_t76 & 255);
    if(lb > 126) {
        lb = lb + 1;
    }
    ub =  *( &jisx02132_sjis_map + (ub & 255)) & 0xff;
    if(ub != 0) {
        goto L17;
    } else {
        cc.ccs = 49152;
         *__ecx = cc.ccs;
         *(__ecx + 4) = cc.code;
    }
    goto L18;
}

wc_wchar_t wc_sjis_ext_to_cs94w(wc_wchar_t cc)
{// addr = 0x080BBC76  --  defined in 'sjis.c' at line 118
    wc_uchar ub;      // _cfa_fffffffb
    wc_uchar lb;      // _cfa_fffffffa
    _unknown_ __ebp;                       // r6
    signed int _t43;                       // _t43
    signed int _t52;                       // _t52

    __ecx = _a4;
    ub = cc.code >> 8 & 255;
    lb = cc.code & 255;
    if(ub > 159) {
        _t43 = -63;
    } else {
        _t43 = -127;
    }
    ub = ub - (_t43 & 255);
    ub = (ub & 255) + (ub & 255) + 33 & 255;
    if(lb > 158) {
        ub = ub + 1;
        lb = lb - 126;
    } else {
        if(lb <= 126) {
            _t52 = 31;
        } else {
            _t52 = 32;
        }
        lb = lb - (_t52 & 255);
    }
    if(ub > 126) {
        ub = ub - 94;
        cc.ccs = 34837;
    } else {
        cc.ccs = 34836;
    }
    cc.code = lb & 255 | (ub & 255) << 8;
     *__ecx = cc.ccs;
     *(__ecx + 4) = cc.code;
    return __ecx;
}

wc_wchar_t wc_cs94w_to_sjis_ext(wc_wchar_t cc)
{// addr = 0x080BBD11  --  defined in 'sjis.c' at line 136
    wc_uchar ub;      // _cfa_fffffffb
    wc_uchar lb;      // _cfa_fffffffa
    _unknown_ __ebp;                       // r6
    signed int _t47;                       // _t47
    signed int _t51;                       // _t51

    __ecx = _a4;
    ub = cc.code >> 8 & 0x7f;
    lb = cc.code & 0x7f;
    if(cc.ccs == 34837) {
        ub = ub + 94;
    }
    if((ub & 1) == 0) {
        _t47 = 125;
    } else {
        _t47 = 31;
    }
    lb = lb + (_t47 & 255);
    if(lb > 126) {
        lb = lb + 1;
    }
    ub = (ub & 255) - 33 >> 1 & 255;
    if(ub > 30) {
        _t51 = -63;
    } else {
        _t51 = -127;
    }
    ub = ub + (_t51 & 255);
    cc.ccs = 34835;
    cc.code = lb & 255 | (ub & 255) << 8;
     *__ecx = cc.ccs;
     *(__ecx + 4) = cc.code;
    return __ecx;
}

wc_uint32 wc_sjis_ext1_to_N(wc_uint32 c)
{// addr = 0x080BBDAC  --  defined in 'sjis.c' at line 151
    wc_uchar ub;      // _cfa_fffffffb
    _unknown_ __ebp;                       // r6
    signed int _t14;                       // _t14
    _unknown_ _t19;                        // _t19

    ub = c >> 8 & 0x7f;
    _t14 = ub & 255;
    if(_t14 == 45) {
        ub = 0;
        goto L7;
    }
    if(_t14 < 45 || _t14 - 121 > 3) {
        return -1;
    } else {
        ub = ub - 120;
    }
L7:
    return (ub & 255) * (ub & 255) + (c & 127) - 33;
}

wc_uint32 wc_sjis_ext2_to_N(wc_uint32 c)
{// addr = 0x080BBDFD  --  defined in 'sjis.c' at line 173
    wc_uchar ub;      // _cfa_fffffffb
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15

    ub = c >> 8 & 0x7f;
    if((ub & 255) - 53 > 4) {
        return -1;
    }
    ub = ub - 48;
    return (ub & 255) * (ub & 255) + (c & 127) - 33;
}

Str wc_conv_from_sjis(Str is, wc_ces ces)
{// addr = 0x080BBE3A  --  defined in 'sjis.c' at line 193
    signed int _v13;                       // _cfa_fffffff3
    wc_uchar[1] jis;   // _cfa_fffffff2
    Str os;                // _cfa_ffffffec
    wc_uchar* sp;     // _cfa_ffffffe8
    wc_uchar* ep;     // _cfa_ffffffe4
    wc_uchar* p;      // _cfa_ffffffe0
    int state;                             // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    wc_wchar_t cc;   // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t188;                             // _t188
    _unknown_ _t222;                       // _t222
    _unknown_ _t253;                       // _t253
    int _t267;                             // _t267
    _unknown_ _t274;                       // _t274
    signed int _t294;                      // _t294
    signed int _t306;                      // _t306

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while(p < ep && ( *p & 0xff) >= 0) {
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t188 = state;
        if(_t188 > 2) {
            if(_t188 == 3) {
                if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                    wtf_push_unknown(os, p - 1, 2);
                } else {
                    wtf_push(os, 34835,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
                }
                state = 0;
            }
            goto L38;
        }
        if(_t188 >= 1) {
            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                jis =  *(p - 1) & 0xff;
                _v13 =  *p & 0xff;
                _t294 = jis & 255;
                if((jis & 0xff) > 159) {
                }
                jis = _t294 & 255;
                jis = (jis & 255) + (jis & 255) + 33 & 255;
                if((_v13 & 0xff) > 158) {
                    jis = (jis & 255) + 1 & 255;
                    _v13 = (_v13 & 255) - 126 & 255;
                } else {
                    _t306 = _v13 & 255;
                    if((_v13 & 0xff) <= 126) {
                    }
                    _v13 = _t306 & 255;
                }
                _v40 = _v13 & 0xff | (jis & 0xff) << 8;
                cc.ccs = wc_jisx0208_or_jisx02131(_v40 & 0xffff);
                if(cc.ccs != 33090) {
                    wtf_push(os, 34835,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
                } else {
                    wtf_push(os, cc.ccs, _v40);
                }
            }
            state = 0;
L38:
            p =  &(p[1]);
            continue;
        }
        if(_t188 == 0) {
            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0xff) - 18 > 46) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t267 = os->length;
                 *(os->ptr + _t267) =  *p & 0xff;
                os->length = _t267 + 1;
                 *(os->ptr + os->length) = 0;
                goto L38;
            }
            goto __eax;
        }
        goto L38;
    }
    if(state - 1 <= 2) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

Str wc_conv_from_sjisx0213(Str is, wc_ces ces)
{// addr = 0x080BC1CA  --  defined in 'sjis.c' at line 273
    signed int _v13;                       // _cfa_fffffff3
    wc_uchar[1] jis;   // _cfa_fffffff2
    Str os;                // _cfa_ffffffec
    wc_uchar* sp;     // _cfa_ffffffe8
    wc_uchar* ep;     // _cfa_ffffffe4
    wc_uchar* p;      // _cfa_ffffffe0
    int state;                             // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    wc_wchar_t cc;   // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t220;                             // _t220
    _unknown_ _t253;                       // _t253
    _unknown_ _t270;                       // _t270
    _unknown_ _t291;                       // _t291
    int _t305;                             // _t305
    _unknown_ _t312;                       // _t312
    signed int _t333;                      // _t333
    signed int _t334;                      // _t334
    signed int _t344;                      // _t344

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while(p < ep && ( *p & 0xff) >= 0) {
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t220 = state;
        if(_t220 > 2) {
            if(_t220 == 3) {
                if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                    wtf_push_unknown(os, p - 1, 2);
                } else {
                    jis =  *(p - 1) & 0xff;
                    _v13 =  *p & 0xff;
                    if((_v13 & 0xff) > 158) {
                        jis =  *((jis & 0xff) - 240 + "($,.nprtvxz|~") & 0xff;
                        _v13 = (_v13 & 255) - 126 & 255;
                    } else {
                        jis =  *((jis & 0xff) - 240 + "!#%-/oqsuwy{}") & 0xff;
                        _t333 = _v13 & 255;
                        if((_v13 & 0xff) <= 126) {
                        }
                        _v13 = _t333 & 255;
                    }
                    wtf_push(os, 33104, _v13 & 0xff | (jis & 0xff) << 8);
                }
                state = 0;
            }
L42:
            p =  &(p[1]);
            continue;
        }
        if(_t220 >= 1) {
            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0x10) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                jis =  *(p - 1) & 0xff;
                _v13 =  *p & 0xff;
                _t334 = jis & 255;
                if((jis & 0xff) > 159) {
                }
                jis = _t334 & 255;
                jis = (jis & 255) + (jis & 255) + 33 & 255;
                if((_v13 & 0xff) > 158) {
                    jis = (jis & 255) + 1 & 255;
                    _v13 = (_v13 & 255) - 126 & 255;
                } else {
                    _t344 = _v13 & 255;
                    if((_v13 & 0xff) <= 126) {
                    }
                    _v13 = _t344 & 255;
                }
                _v40 = _v13 & 0xff | (jis & 0xff) << 8;
                cc.ccs = wc_jisx0208_or_jisx02131(_v40 & 0xffff);
                wtf_push(os, cc.ccs, _v40);
            }
            state = 0;
            goto L42;
        }
        if(_t220 == 0) {
            if(( *( &WC_SJIS_MAP + ( *p & 0xff)) & 0xff) - 18 > 46) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t305 = os->length;
                 *(os->ptr + _t305) =  *p & 0xff;
                os->length = _t305 + 1;
                 *(os->ptr + os->length) = 0;
                goto L42;
            }
            goto __eax;
        }
        goto L42;
    }
    if(state - 1 <= 2) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

wc_push_to_sjis(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BC591  --  defined in 'sjis.c' at line 353
    wc_uchar ub;      // _cfa_fffffff3
    wc_uchar lb;      // _cfa_fffffff2
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    wc_status* _v48;   // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    unsigned int _t185;                    // _t185
    signed int _t193;                      // _t193
    signed int _t197;                      // _t197
    int _t204;                             // _t204
    int _t216;                             // _t216
    unsigned int _t230;                    // _t230
    int _t242;                             // _t242
    int _t254;                             // _t254
    int _t271;                             // _t271
    int _t287;                             // _t287

    while(1) {
        _t185 = cc.ccs;
        if(_t185 == 33090) {
            break;
        }
        if(_t185 > 33090) {
            if(_t185 > 34837) {
                if(_t185 == 49152) {
                    if(( *135119022 & 0xff) != 0) {
                        return;
                    }
                    goto L44;
                }
                goto L12;
L44:
                Strcat_charp(os, WcReplaceW);
                return;
            } else {
                if(_t185 >= 34836) {
                    _v56 = cc.ccs;
                    _v52 = cc.code;
                     *__esp =  &_v36;
                    wc_cs94w_to_sjis_ext();
                    __esp = __esp - 4;
                    cc.ccs = _v36;
                    cc.code = _v32;
                    goto L38;
                }
                if(_t185 == 34835) {
                    goto L38;
                }
                goto L47;
L38:
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t242 = os->length;
                 *(os->ptr + _t242) = cc.code >> 8 & 255;
                os->length = _t242 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t254 = os->length;
                 *(os->ptr + _t254) = cc.code & 255;
                os->length = _t254 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
L12:
            goto L47;
        }
        if(_t185 == 329) {
            if(( *135119017 & 0xff) == 0) {
            } else {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t271 = os->length;
                 *(os->ptr + _t271) = (cc.code | 128) & 255;
                os->length = _t271 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L20;
        }
        if(_t185 != 16384) {
            if(_t185 == 322) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t287 = os->length;
                 *(os->ptr + _t287) = cc.code & 255;
                os->length = _t287 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L47;
        }
        if(( *135119022 & 0xff) != 0) {
        } else {
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L54;
L56:
L54:
        return;
        goto L56;
L20:
        if(( *135119013 & 0xff) == 0) {
            _v56 = cc.ccs;
            _v52 = cc.code;
             *__esp =  &(cc.ccs);
            wc_jisx0201k_to_jisx0208();
            __esp = __esp - 4;
        } else {
            cc.ccs = 16384;
        }
        continue;
L47:
        if(( *135119011 & 0xff) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t230 = 16384;
            } else {
                _t230 = 49152;
            }
            cc.ccs = _t230;
        } else {
            _v48 = st;
            _v56 = cc.ccs;
            _v52 = cc.code;
             *__esp =  &_v36;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v36;
            cc.code = _v32;
        }
    }
    ub = cc.code >> 8 & 0x7f;
    lb = cc.code & 0x7f;
    if((ub & 1) == 0) {
        _t193 = 125;
    } else {
        _t193 = 31;
    }
    lb = lb + (_t193 & 255);
    if(lb > 126) {
        lb = lb + 1;
    }
    ub = (ub & 255) - 33 >> 1 & 255;
    if(ub > 30) {
        _t197 = -63;
    } else {
        _t197 = -127;
    }
    ub = ub + (_t197 & 255);
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t204 = os->length;
     *(os->ptr + _t204) = ub & 0xff;
    os->length = _t204 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t216 = os->length;
     *(os->ptr + _t216) = lb & 0xff;
    os->length = _t216 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

wc_push_to_sjisx0213(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BC955  --  defined in 'sjis.c' at line 406
    wc_uchar ub;      // _cfa_fffffff3
    wc_uchar lb;      // _cfa_fffffff2
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    wc_status* _v48;   // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    unsigned int _t206;                    // _t206
    signed int _t214;                      // _t214
    signed int _t218;                      // _t218
    int _t225;                             // _t225
    int _t237;                             // _t237
    signed int _t253;                      // _t253
    int _t265;                             // _t265
    int _t277;                             // _t277
    unsigned int _t289;                    // _t289
    int _t302;                             // _t302
    int _t318;                             // _t318

    while(1) {
        _t206 = cc.ccs;
        if(_t206 == 33090) {
            break;
        }
        if(_t206 > 33090) {
            if(_t206 == 33104) {
                if(( *135119019 & 0xff) != 0) {
                    ub = cc.code >> 8 & 0x7f;
                    lb = cc.code & 0x7f;
                    if((ub & 1) == 0) {
                        _t253 = 125;
                    } else {
                        _t253 = 31;
                    }
                    lb = lb + (_t253 & 255);
                    if(lb > 126) {
                        lb = lb + 1;
                    }
                    ub =  *( &jisx02132_sjis_map + (ub & 255)) & 0xff;
                    if(ub == 0) {
                        goto L50;
                    } else {
                        if(os->length + 1 >= os->area_size) {
                            Strgrow(os);
                        }
                        _t265 = os->length;
                         *(os->ptr + _t265) = ub & 0xff;
                        os->length = _t265 + 1;
                         *((char*)(os->ptr + os->length)) = 0;
                        if(os->length + 1 >= os->area_size) {
                            Strgrow(os);
                        }
                        _t277 = os->length;
                         *(os->ptr + _t277) = lb & 0xff;
                        os->length = _t277 + 1;
                         *((char*)(os->ptr + os->length)) = 0;
                        return;
                    }
                    goto L51;
                }
            } else {
                if(_t206 == 49152) {
L50:
                    if(( *135119022 & 0xff) != 0) {
                        return;
                    }
                    goto L51;
                }
                if(_t206 == 33103) {
                    if(( *135119019 & 0xff) != 0) {
                        break;
                    }
                } else {
                    goto L54;
                }
                cc.ccs = 49152;
                goto L60;
L51:
                Strcat_charp(os, WcReplaceW);
                return;
            }
            cc.ccs = 49152;
            goto L60;
        }
        if(_t206 == 329) {
            if(( *135119017 & 0xff) == 0) {
            } else {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t302 = os->length;
                 *(os->ptr + _t302) = (cc.code | 128) & 255;
                os->length = _t302 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L18;
L60:
            continue;
        }
        if(_t206 == 16384) {
        } else {
            if(_t206 == 322) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t318 = os->length;
                 *(os->ptr + _t318) = cc.code & 255;
                os->length = _t318 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
L54:
            if(( *135119011 & 0xff) == 0) {
                if((cc.ccs & 98304) == 0) {
                    _t289 = 16384;
                } else {
                    _t289 = 49152;
                }
                cc.ccs = _t289;
            } else {
                _v48 = st;
                _v56 = cc.ccs;
                _v52 = cc.code;
                 *__esp =  &_v36;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.ccs = _v36;
                cc.code = _v32;
            }
            continue;
        }
        goto L52;
L62:
        return;
L64:
L18:
        if(( *135119013 & 0xff) == 0) {
            _v56 = cc.ccs;
            _v52 = cc.code;
             *__esp =  &(cc.ccs);
            wc_jisx0201k_to_jisx0208();
            __esp = __esp - 4;
        } else {
            cc.ccs = 16384;
        }
        goto L60;
L52:
        if(( *135119022 & 0xff) != 0) {
        } else {
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L62;
    }
    ub = cc.code >> 8 & 0x7f;
    lb = cc.code & 0x7f;
    if((ub & 1) == 0) {
        _t214 = 125;
    } else {
        _t214 = 31;
    }
    lb = lb + (_t214 & 255);
    if(lb > 126) {
        lb = lb + 1;
    }
    ub = (ub & 255) - 33 >> 1 & 255;
    if(ub > 30) {
        _t218 = -63;
    } else {
        _t218 = -127;
    }
    ub = ub + (_t218 & 255);
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t225 = os->length;
     *(os->ptr + _t225) = ub & 0xff;
    os->length = _t225 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t237 = os->length;
     *(os->ptr + _t237) = lb & 0xff;
    os->length = _t237 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_sjis(wc_uchar c, wc_status* st)
{// addr = 0x080BCD67  --  defined in 'sjis.c' at line 470
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t105;                             // _t105
    _unknown_ _t126;                       // _t126
    _unknown_ _t152;                       // _t152
    struct _Str* _t163;   // _t163
    _unknown_ _t169;                       // _t169
    signed int _t182;                      // _t182
    signed int _t189;                      // _t189
    int _t191;                             // _t191

    _v32 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.3288 = Strnew_size(8);
    }
    _t105 = st->state;
    if(_t105 > 2) {
        if(_t105 == 3) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0x10) != 0) {
                 *135790485 = _v32 & 0xff;
                wtf_push(os.3288, 34835, (jis.3289 & 0xff) << 8 |  *135790485 & 0xff);
            }
            st->state = 0;
        }
        goto L30;
    } else {
        if(_t105 >= 1) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0x10) != 0) {
                 *135790485 = _v32 & 0xff;
                _t182 = jis.3289 & 255;
                if((jis.3289 & 0xff) > 159) {
                }
                jis.3289 = _t182 & 255;
                jis.3289 = (jis.3289 & 255) + (jis.3289 & 255) + 33 & 255;
                if(( *135790485 & 0xff) > 158) {
                    jis.3289 = (jis.3289 & 255) + 1 & 255;
                     *135790485 = ( *135790485 & 255) - 126 & 255;
                } else {
                    _t189 =  *135790485 & 255;
                    if(( *135790485 & 0xff) <= 126) {
                    }
                     *135790485 = _t189 & 255;
                }
                _v16 =  *135790485 & 0xff | (jis.3289 & 0xff) << 8;
                cc.ccs = wc_jisx0208_or_jisx02131(_v16 & 0xffff);
                if(cc.ccs != 33090) {
                    wtf_push(os.3288, 34835, (jis.3289 & 0xff) << 8 |  *135790485 & 0xff);
                } else {
                    wtf_push(os.3288, cc.ccs, _v16);
                }
            }
            st->state = 0;
            goto L30;
        }
        if(_t105 == 0) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0xff) - 18 > 46) {
                if(os.3288->length + 1 >= os.3288->area_size) {
                    Strgrow(os.3288);
                }
                _t163 = os.3288;
                _t191 = _t163->length;
                 *( *os.3288 + _t191) = _v32 & 0xff;
                _t163->length = _t191 + 1;
                 *( *os.3288 + os.3288->length) = 0;
                goto L30;
            }
            goto __eax;
        } else {
        }
L30:
        st->state = -1;
        return os.3288;
    }
}

Str wc_char_conv_from_sjisx0213(wc_uchar c, wc_status* st)
{// addr = 0x080BD079  --  defined in 'sjis.c' at line 535
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t122;                             // _t122
    _unknown_ _t148;                       // _t148
    _unknown_ _t157;                       // _t157
    _unknown_ _t177;                       // _t177
    struct _Str* _t188;   // _t188
    _unknown_ _t194;                       // _t194
    signed int _t208;                      // _t208
    signed int _t209;                      // _t209
    signed int _t213;                      // _t213
    int _t215;                             // _t215

    _v32 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.3413 = Strnew_size(8);
    }
    _t122 = st->state;
    if(_t122 > 2) {
        if(_t122 == 3) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0x10) != 0) {
                 *135790477 = _v32 & 0xff;
                if(( *135790477 & 0xff) > 158) {
                    jis.3414 =  *((jis.3414 & 0xff) - 240 + "($,.nprtvxz|~") & 0xff;
                     *135790477 = ( *135790477 & 255) - 126 & 255;
                } else {
                    jis.3414 =  *((jis.3414 & 0xff) - 240 + "!#%-/oqsuwy{}") & 0xff;
                    _t208 =  *135790477 & 255;
                    if(( *135790477 & 0xff) <= 126) {
                    }
                     *135790477 = _t208 & 255;
                }
                wtf_push(os.3413, 33104, (jis.3414 & 0xff) << 8 |  *135790477 & 0xff);
            }
            st->state = 0;
        }
L34:
        st->state = -1;
        return os.3413;
    }
    if(_t122 >= 1) {
        if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0x10) != 0) {
             *135790477 = _v32 & 0xff;
            _t209 = jis.3414 & 255;
            if((jis.3414 & 0xff) > 159) {
            }
            jis.3414 = _t209 & 255;
            jis.3414 = (jis.3414 & 255) + (jis.3414 & 255) + 33 & 255;
            if(( *135790477 & 0xff) > 158) {
                jis.3414 = (jis.3414 & 255) + 1 & 255;
                 *135790477 = ( *135790477 & 255) - 126 & 255;
            } else {
                _t213 =  *135790477 & 255;
                if(( *135790477 & 0xff) <= 126) {
                }
                 *135790477 = _t213 & 255;
            }
            _v16 =  *135790477 & 0xff | (jis.3414 & 0xff) << 8;
            cc.ccs = wc_jisx0208_or_jisx02131(_v16 & 0xffff);
            wtf_push(os.3413, cc.ccs, _v16);
        }
        st->state = 0;
        goto L34;
    }
    if(_t122 == 0) {
        if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 0xff) - 18 > 46) {
            if(os.3413->length + 1 >= os.3413->area_size) {
                Strgrow(os.3413);
            }
            _t188 = os.3413;
            _t215 = _t188->length;
             *( *os.3413 + _t215) = _v32 & 0xff;
            _t188->length = _t215 + 1;
             *( *os.3413 + os.3413->length) = 0;
            goto L34;
        }
        goto __eax;
    }
    goto L34;
}

wc_input_init(wc_ces ces, wc_status* st)
{// addr = 0x080BD3D0  --  defined in 'status.c' at line 38
    wc_gset* gset;     // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4
    int g;                                 // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    st->ces_info =  &WcCesInfo + ((ces & 255) << 5);
    gset =  *(st->ces_info + 12);
    st->state = 0;
     *(st + 8) = 0;
     *(st + 12) = 0;
     *(st + 16) = gset->ccs;
     *((intOrPtr*)(st + 20)) =  *((intOrPtr*)(gset + 8));
     *(st + 24) = 0;
     *(st + 28) = 0;
     *(st + 5) = 0;
     *((char*)(st + 4)) = 1;
     *(st + 6) = 0;
    i = 0;
    while( *((intOrPtr*)(gset + (i << 3))) != 0) {
        if(( *(gset + (i << 3) + 5) & 0xff) != 0) {
            g =  *(gset + (i << 3) + 4) & 3;
            if( *((intOrPtr*)(st + (g + 4) * 4)) == 0) {
                 *((intOrPtr*)(st + (g + 4) * 4)) =  *((intOrPtr*)(gset + (i << 3)));
            }
        }
        i = i + 1;
    }
     *(st + 44) = 0;
    st->ntag = 0;
    return;
}

wc_output_init(wc_ces ces, wc_status* st)
{// addr = 0x080BD4D7  --  defined in 'status.c' at line 72
    wc_gset* gset;     // _cfa_fffffff0
    size_t i;           // _cfa_ffffffec
    size_t n;           // _cfa_ffffffe8
    size_t nw;          // _cfa_ffffffe4
    intOrPtr _v36;                         // _cfa_ffffffdc
    struct * _v40;            // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    unsigned int _t172;                    // _t172
    intOrPtr _t174;                        // _t174
    wc_table** _t201;   // _t201
    wc_table** _t205;   // _t205
    signed int _t233;                      // _t233
    wc_status* _t254;   // _t254
    _unknown_ _t267;                       // _t267
    wc_status* _t268;   // _t268

    if((output_set & 0xff) == 0) {
L4:
        st->state = 0;
        st->ces_info =  &WcCesInfo + ((ces & 255) << 5);
        gset =  *(st->ces_info + 12);
        if(ces == 2099217 || ces == 2099218 || ces == 2099219) {
            if(( *135119015 & 0xff) != 0) {
                _t172 = 330;
L10:
                 *(st + 8) = _t172;
                if(ces == 2099217 || ces == 2099218 || ces == 2099219) {
                    if(( *135119016 & 0xff) != 0) {
                        _t174 = 33088;
L16:
                         *((intOrPtr*)(st + 12)) = _t174;
                         *(st + 16) =  *(st + 8);
                         *(st + 20) = 0;
                         *(st + 24) = 0;
                         *(st + 28) = 0;
                         *(st + 5) = 0;
                         *(st + 4) = 0;
                         *(st + 6) = 0;
                        if((ces & 2048) != 0) {
                            wc_create_gmap(st);
                        }
                         *(st + 44) = 0;
                        st->ntag = 0;
                        if(( *135119011 & 0xff) != 0) {
                            nw = 0;
                            n = nw;
                            i = n;
L25:
                            while( *(gset + (i << 3)) != 0) {
                                goto L21;
                            }
                            _t201 = n + 1 << 2;
                             *__esp = _t201;
                            GC_malloc();
                            st->tlist = _t201;
                            _t205 = nw + 1 << 2;
                             *__esp = _t205;
                            GC_malloc();
                            st->tlistw = _t205;
                            nw = 0;
                            n = nw;
                            i = n;
                            while( *(gset + (i << 3)) != 0) {
                                if(( *(gset + (i << 3)) & 98304) == 0) {
L45:
                                    if( *(gset + (i << 3)) != 329 || ( *135119017 & 0xff) != 0) {
                                        st->tlist[n] = wc_get_ucs_table( *(gset + (i << 3)));
                                        n = n + 1;
                                    }
                                    goto L49;
                                }
                                _t233 =  *(gset + (i << 3));
                                if(_t233 == 33092) {
                                    if(( *135119018 & 0xff) != 0) {
                                        goto L44;
                                    }
                                    goto L35;
                                }
                                if(_t233 > 33092) {
                                    if(_t233 - 33103 > 1) {
                                        goto L44;
                                    }
                                    goto L33;
                                }
                                if(_t233 == 33089) {
                                    if(( *135119014 & 0xff) == 0 || ces == 3153978 || ces == 3153979) {
L44:
                                        st->tlistw[nw] = wc_get_ucs_table( *(gset + (i << 3)));
                                        nw = nw + 1;
                                        goto L49;
                                    } else {
                                        st->tlistw[nw] = wc_get_ucs_table(34830);
                                        nw = nw + 1;
L49:
                                        i = i + 1;
                                        continue;
                                    }
                                    goto L45;
                                }
                                goto L44;
L33:
                                if(( *135119019 & 0xff) != 0) {
                                } else {
                                    goto L49;
                                }
                                goto L44;
L35:
                                goto L49;
                            }
                            st->tlist[n] = 0;
                            st->tlistw[nw] = 0;
                            goto L52;
                        } else {
                            st->tlist = 0;
                            st->tlistw = 0;
L52:
                            _t254 = st;
                            output_st.auto_detect =  *_t254;
                             *135790500 =  *((intOrPtr*)(_t254 + 4));
                             *135790504 =  *((intOrPtr*)(_t254 + 8));
                             *135790508 =  *((intOrPtr*)(_t254 + 12));
                             *135790512 =  *((intOrPtr*)(_t254 + 16));
                             *135790516 =  *((intOrPtr*)(_t254 + 20));
                             *135790520 =  *((intOrPtr*)(_t254 + 24));
                             *135790524 =  *((intOrPtr*)(_t254 + 28));
                             *135790528 = _t254->tlist;
                             *135790532 = _t254->tlistw;
                             *135790536 = _t254->state;
                             *135790540 =  *((intOrPtr*)(_t254 + 44));
                             *135790544 = _t254->ntag;
                             *135790548 =  *((intOrPtr*)(_t254 + 52));
                             *135790552 = _t254->shift;
                            output_set = 1;
                            output_option.auto_detect = WcOption.auto_detect;
                             *135790560 =  *135119012;
                             *135790564 =  *135119016;
                             *135790568 =  *135119020;
                            return;
                        }
L21:
                        if(( *(gset + (i << 3)) & 98304) == 0) {
                            n = n + 1;
                        } else {
                            nw = nw + 1;
                        }
                        i = i + 1;
                        goto L25;
                    }
                }
                _t174 =  *((intOrPtr*)(gset + 8));
                goto L16;
            }
        }
        _t172 = gset->ccs;
        goto L10;
    }
    _t267 =  *(output_st.auto_detect);
    if(_t267 != ces) {
        goto L4;
    } else {
        _v36 = 16;
        _v40 =  &output_option;
         *__esp =  &WcOption;
        memcmp();
        if(_t267 != 0) {
            goto L4;
        } else {
            _t268 = st;
             *_t268 = output_st.auto_detect;
             *((intOrPtr*)(_t268 + 4)) =  *135790500;
             *((intOrPtr*)(_t268 + 8)) =  *135790504;
             *((intOrPtr*)(_t268 + 12)) =  *135790508;
             *((intOrPtr*)(_t268 + 16)) =  *135790512;
             *((intOrPtr*)(_t268 + 20)) =  *135790516;
             *((intOrPtr*)(_t268 + 24)) =  *135790520;
             *((intOrPtr*)(_t268 + 28)) =  *135790524;
            _t268->tlist =  *135790528;
            _t268->tlistw =  *135790532;
            _t268->state =  *135790536;
             *((intOrPtr*)(_t268 + 44)) =  *135790540;
            _t268->ntag =  *135790544;
             *((intOrPtr*)(_t268 + 52)) =  *135790548;
            _t268->shift =  *135790552;
            return;
        }
    }
    goto L5;
}

wc_bool wc_ces_has_ccs(wc_ccs ccs, wc_status* st)
{// addr = 0x080BD983  --  defined in 'status.c' at line 165
    wc_gset* gset;     // _cfa_fffffff8
    int i;                                 // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24

    gset = st->ces_info->gset;
    i = 0;
    while( *((intOrPtr*)(gset + (i << 3))) != 0) {
        if( *((intOrPtr*)(gset + (i << 3))) != ccs) {
            i = i + 1;
            continue;
        }
        return 1;
    }
    return 0;
}

wc_wchar_t ucs_cs94_conv(wc_ccs ccs, wc_uint16 c)
{// addr = 0x080BD9D0  --  defined in 'ucs.map' at line 237
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed short _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    __ecx = _a4;
    _v24 = _a12 & 65535;
    cc.ccs = ccs;
    _v8 = _v24 & 65535;
     *__ecx = cc.ccs;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_viet_conv(wc_ccs ccs, wc_uint16 c)
{// addr = 0x080BD9FE  --  defined in 'ucs.map' at line 252
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    unsigned int _t28;                     // _t28
    unsigned int _t34;                     // _t34

    __ecx = _a4;
    _v24 = _a12 & 65535;
    if((_v24 & 0x80) == 0) {
        cc.ccs = ccs;
        _t28 = ccs;
        if(_t28 == 2080) {
            cc.ccs = 2081;
        } else {
            if(_t28 == 2082) {
                cc.ccs = 2083;
            } else {
                if(_t28 == 2077) {
                    cc.ccs = 2078;
                }
            }
        }
    } else {
        cc.ccs = ccs;
        _t34 = ccs;
        if(_t34 == 2081) {
            cc.ccs = 2080;
        } else {
            if(_t34 == 2083) {
                cc.ccs = 2082;
            } else {
                if(_t34 == 2078) {
                    cc.ccs = 2077;
                }
            }
        }
    }
    _v8 = _v24 & 0xff;
     *__ecx = cc.ccs;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_cp1258_conv(wc_ccs ccs, wc_uint16 c)
{// addr = 0x080BDAAC  --  defined in 'ucs.map' at line 288
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed short _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    unsigned int _t14;                     // _t14

    __ecx = _a4;
    _v24 = _a12 & 65535;
    if(_v24 > 255) {
        _t14 = 2076;
    } else {
        _t14 = 2075;
    }
    cc.ccs = _t14;
    _v8 = _v24 & 65535;
     *__ecx = cc.ccs;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_cns11643_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDAEB  --  defined in 'ucs.map' at line 298
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    unsigned int _t17;                     // _t17

    __ecx = _a4;
    _v24 = _a12 & 65535;
    if((_v24 & 0xffff) >= 0) {
        _t17 = 33095;
    } else {
        _t17 = 33096;
    }
    cc.ccs = _t17;
    _v8 = _v24 & 0x7f7f;
     *__ecx = cc.ccs;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_big5_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDB30  --  defined in 'ucs.map' at line 308
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct  _t21;             // _t21
    _unknown_ _t22;                        // _t22

    _push(__ebx);
    __esp = __esp - 52;
    _t21 = _a4;
    _v32 = _a12 & 65535;
    cc.ccs = cs;
    _v16 = _v32 & 65535;
    _v56 = cc.ccs;
    _v52 = _v16;
     *__esp = _t21;
    wc_big5_to_cs94w();
    __esp = __esp - 4;
    return _t21;
}

wc_wchar_t ucs_johab2_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDB70  --  defined in 'ucs.map' at line 318
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct  _t21;             // _t21
    _unknown_ _t22;                        // _t22

    _push(__ebx);
    __esp = __esp - 52;
    _t21 = _a4;
    _v32 = _a12 & 65535;
    cc.ccs = cs;
    _v16 = _v32 & 65535;
    _v56 = cc.ccs;
    _v52 = _v16;
     *__esp = _t21;
    wc_johab_to_cs128w();
    __esp = __esp - 4;
    return _t21;
}

wc_wchar_t ucs_johab3_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDBB0  --  defined in 'ucs.map' at line 328
    signed int _v8;                        // _cfa_fffffff8
    wc_wchar_t cc;   // _cfa_fffffff4
    signed short _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    __ecx = _a4;
    _v24 = _a12 & 65535;
    if(_v24 <= 8480 || _v24 > 9248) {
        if(_v24 <= 9299 || _v24 > 11390) {
            if(_v24 <= 18976 || _v24 > 32126) {
                cc.ccs = 49152;
L8:
                _v8 = _v24 & 65535;
                 *__ecx = cc.ccs;
                 *(__ecx + 4) = _v8;
                return __ecx;
            } else {
                goto L6;
            }
        }
    }
L6:
    cc.ccs = cs;
    goto L8;
}

wc_wchar_t ucs_sjis_ext_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDC17  --  defined in 'ucs.map' at line 343
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct  _t21;             // _t21
    _unknown_ _t22;                        // _t22

    _push(__ebx);
    __esp = __esp - 52;
    _t21 = _a4;
    _v32 = _a12 & 65535;
    cc.ccs = cs;
    _v16 = _v32 & 65535;
    _v56 = cc.ccs;
    _v52 = _v16;
     *__esp = _t21;
    wc_sjis_ext_to_cs94w();
    __esp = __esp - 4;
    return _t21;
}

wc_wchar_t ucs_gbk_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDC57  --  defined in 'ucs.map' at line 353
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct  _t21;             // _t21
    _unknown_ _t22;                        // _t22

    _push(__ebx);
    __esp = __esp - 52;
    _t21 = _a4;
    _v32 = _a12 & 65535;
    cc.ccs = cs;
    _v16 = _v32 & 65535;
    _v56 = cc.ccs;
    _v52 = _v16;
     *__esp = _t21;
    wc_gbk_to_cs128w();
    __esp = __esp - 4;
    return _t21;
}

wc_wchar_t ucs_uhc_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDC97  --  defined in 'ucs.map' at line 363
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct  _t21;             // _t21
    _unknown_ _t22;                        // _t22

    _push(__ebx);
    __esp = __esp - 52;
    _t21 = _a4;
    _v32 = _a12 & 65535;
    cc.ccs = cs;
    _v16 = _v32 & 65535;
    _v56 = cc.ccs;
    _v52 = _v16;
     *__esp = _t21;
    wc_uhc_to_cs128w();
    __esp = __esp - 4;
    return _t21;
}

wc_wchar_t ucs_hkscs_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDCD7  --  defined in 'ucs.map' at line 373
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    wc_wchar_t cc;   // _cfa_ffffffec
    signed short _v32;                     // _cfa_ffffffe0
    signed int _v52;                       // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct  _t21;             // _t21
    _unknown_ _t22;                        // _t22

    _push(__ebx);
    __esp = __esp - 52;
    _t21 = _a4;
    _v32 = _a12 & 65535;
    cc.ccs = cs;
    _v16 = _v32 & 65535;
    _v56 = cc.ccs;
    _v52 = _v16;
     *__esp = _t21;
    wc_hkscs_to_cs128w();
    __esp = __esp - 4;
    return _t21;
}

wc_table* wc_get_ucs_table(wc_ccs ccs)
{// addr = 0x080BDD17  --  defined in 'ucs.c' at line 31
    int f;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    signed int _t28;                       // _t28
    _unknown_ _t29;                        // _t29
    _unknown_ _t34;                        // _t34
    _unknown_ _t37;                        // _t37
    _unknown_ _t42;                        // _t42
    _unknown_ _t47;                        // _t47
    _unknown_ _t48;                        // _t48
    _unknown_ _t53;                        // _t53
    _unknown_ _t56;                        // _t56

    f = ccs & 255;
    _t28 = ccs & 65280;
    if(_t28 == 2048) {
        if(f <= 0 || f > 40) {
            return 0;
        }
        return  &ucs_pcs_table + (f - 1 << 4);
    }
    if(_t28 > 2048) {
        if(_t28 == 33280) {
            if(f <= 63 || f > 0) {
                return 0;
            }
            return ucs_cs96w_table + (f - 64 << 4);
        }
        goto L7;
    }
    if(_t28 == 512) {
        if(f <= 63 || f > 102) {
            return 0;
        }
        return  &ucs_cs96_table + (f - 64 << 4);
    }
    if(_t28 == 1024) {
        if(f <= 63 || f > 0) {
            return 0;
        }
        return ucs_cs942_table + (f - 64 << 4);
    }
    if(_t28 == 256) {
        if(f <= 63) {
L12:
            return 0;
        } else {
            if(f <= 84) {
                return  &ucs_cs94_table + (f - 64 << 4);
            } else {
                goto L12;
            }
        }
    } else {
    }
L38:
    return 0;
L7:
    if(_t28 == 34816) {
        if(f <= 0 || f > 33) {
            return 0;
        }
        return  &ucs_pcsw_table + (f - 1 << 4);
    }
    if(_t28 == 33024) {
        if(f <= 63 || f > 80) {
            return 0;
        }
        return  &ucs_cs94w_table + (f - 64 << 4);
    } else {
    }
    goto L38;
}

wc_wchar_t wc_ucs_to_any(wc_uint32 ucs, wc_table* t)
{// addr = 0x080BDE9B  --  defined in 'ucs.c' at line 70
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_map* map;        // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    wc_wchar_t cc;   // _cfa_ffffffe8
    signed int _v36;                       // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t71;                        // _t71
    wc_map* _t80;       // _t80
    wc_map* _t91;       // _t91
    wc_map* _t93;       // _t93
    unsigned int* _t107;                   // _t107
    _unknown_ _t108;                       // _t108

    _push(__ebx);
    __esp = __esp - 36;
    _t107 = _a4;
    if(t == 0 || t->map == 0 || ucs == 0 || ucs > 65535) {
L6:
        if(t == 0 || ucs != 131072) {
L19:
            cc.ccs = 16384;
             *_t107 = cc.ccs;
            _t107[1] = _v20;
        } else {
            if(t->ccs != 33103) {
                if(t->ccs != 33104) {
                    if(t->ccs == 34847 || t->ccs == 34848 || t->ccs == 34849) {
                        _t80 = ucs & 0xffff;
                        wc_map_search(_t80,  &ucs_p2_hkscs_map, 1081);
                        map = _t80;
                    } else {
                        map = 0;
                    }
                } else {
                    _t91 = ucs & 0xffff;
                    wc_map_search(_t91,  &ucs_p2_jisx02132_map, 277);
                    map = _t91;
                }
            } else {
                _t93 = ucs & 0xffff;
                wc_map_search(_t93,  &ucs_p2_jisx02131_map, 25);
                map = _t93;
            }
            if(map == 0) {
                goto L19;
            }
            _v36 =  *(map + 2) & 0xffff;
            _v40 = t->ccs;
             *__esp = _t107;
            t();
            __esp = __esp - 4;
        }
        goto L20;
    } else {
        map = wc_map_search(ucs & 0xffff, t->map,  *(t + 4));
        if(map == 0) {
            goto L6;
        } else {
            _v36 =  *(map + 2) & 0xffff;
            _v40 = t->ccs;
             *__esp = _t107;
            t();
            __esp = __esp - 4;
        }
L20:
        return;
    }
}

wc_uint32 wc_any_to_ucs(wc_wchar_t cc)
{// addr = 0x080BE029  --  defined in 'ucs.c' at line 101
    char _v12;                             // _cfa_fffffff4
    int f;                                 // _cfa_fffffff0
    wc_uint16* map;   // _cfa_ffffffec
    wc_map* map2;       // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v100;                    // _cfa_ffffff9c
    unsigned int _v104;                    // _cfa_ffffff98
    intOrPtr _v108;                        // _cfa_ffffff94
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t140;                      // _t140
    unsigned int _t143;                    // _t143
    _unknown_ _t200;                       // _t200
    signed int _t202;                      // _t202
    unsigned int _t216;                    // _t216

    __esp = __esp - 96;
    map = 0;
    f = cc.ccs & 255;
    _t140 = cc.ccs & 65280;
    if(_t140 == 4096) {
L64:
        if((cc.ccs & 65535) != 4096) {
            _t143 = -1;
        } else {
            _t143 = cc.code;
        }
        goto L82;
    }
    if(_t140 > 4096) {
        if(_t140 == 33024) {
            if(cc.ccs != 33089 || ( *135119014 & 0xff) == 0) {
                if(cc.ccs != 33103) {
                    if(cc.ccs != 33104) {
                        goto L30;
                    }
                    goto L28;
                }
                map2 = wc_map_search(cc.code & 0x7f7f,  &jisx02131_ucs_p2_map, 25);
                if(map2 == 0) {
L30:
                    if(f <= 63 || f > 80) {
                        _t143 = 0;
                        goto L82;
                    } else {
                        map =  *( &cs94w_ucs_map + (f - 64) * 4);
                        cc.code = (cc.code >> 8 & 127) * (cc.code >> 8 & 127) + (cc.code & 127) - 3135;
                        goto L77;
                    }
                    goto L83;
                } else {
                    _t143 =  *(map2 + 2) & 0xffff | 131072;
                }
                goto L82;
L28:
                map2 = wc_map_search(cc.code & 0x7f7f,  &jisx02132_ucs_p2_map, 277);
                if(map2 == 0) {
                    goto L30;
                } else {
                    _t143 =  *(map2 + 2) & 0xffff | 131072;
                }
            } else {
                cc.ccs = 34830;
                 *__esp = cc.ccs;
                _v104 = cc.code;
                _t143 = wc_any_to_ucs();
            }
            goto L82;
        }
        goto L10;
    }
    if(_t140 == 512) {
        if(f <= 63 || f > 102) {
            _t143 = -1;
L82:
             &_v12 =  &_v12;
            return _t143;
L83:
        } else {
            map =  *( &cs96_ucs_map + (f - 64) * 4);
            cc.code = cc.code & 127;
L77:
            if(map != 0) {
                cc.code =  *(cc.code + cc.code + map) & 0xffff;
                if(cc.code == 0) {
                    _t143 = -1;
                } else {
                    _t143 = cc.code;
                }
            } else {
                _t143 = -1;
            }
            goto L82;
        }
    }
    if(_t140 > 512) {
        if(_t140 == 1024) {
            if(f <= 63 || f > 0) {
                _t143 = -1;
                goto L82;
            }
            map = cs942_ucs_map[f - 64];
            cc.code = cc.code & 127;
            goto L77;
        }
        goto L7;
    }
    if(_t140 == 256) {
        if(f <= 63) {
L19:
            _t143 = -1;
            goto L82;
        }
        if(f <= 84) {
            map =  *( &cs94_ucs_map + (f - 64) * 4);
            cc.code = cc.code & 127;
            goto L77;
        }
        goto L19;
    } else {
    }
L76:
    _t143 = -1;
    goto L82;
L7:
    if(_t140 == 2048) {
        if(f <= 0 || f > 40) {
            _t143 = -1;
            goto L82;
        }
        _t216 = cc.ccs;
        if(_t216 == 2079) {
            _v104 = cc.ccs;
            _v100 = cc.code;
             *__esp =  &_v32;
            wc_tcvn57123_to_tcvn5712();
            __esp = __esp - 4;
             *__esp = _v32;
            _v108 = _v28;
            _t143 = wc_any_to_ucs();
            goto L82;
        }
        if(_t216 == 2087) {
            goto L56;
        }
        if(_t216 != 2076) {
            goto L57;
        }
        map2 = wc_map_search(cc.code & 0xffff,  &cp12582_ucs_map, 120);
        if(map2 == 0) {
            _t143 = -1;
        } else {
            _t143 =  *(map2 + 2) & 0xffff;
        }
        goto L82;
L58:
        if(f <= 0 || f > 33) {
            _t143 = -1;
            goto L82;
        }
        map =  *( &pcsw_ucs_map + (f - 1) * 4);
        if(cc.ccs - 34817 > 32) {
            cc.code = (cc.code >> 8 & 127) * (cc.code >> 8 & 127) + (cc.code & 127) - 3135;
            goto L77;
        }
        goto __eax;
        goto L64;
L57:
        map =  *( &pcs_ucs_map + (f - 1) * 4);
        cc.code = cc.code & 127;
        goto L77;
L56:
        _t143 = 8364;
        goto L82;
    } else {
    }
    goto L76;
L10:
    if(_t140 > 33024) {
        if(_t140 == 33280) {
            if(f <= 63 || f > 0) {
                _t143 = -1;
                goto L82;
            } else {
                map = cs96w_ucs_map[f - 64];
                cc.code = ((cc.code >> 8 & 127) + (cc.code >> 8 & 127) + _t241 << 5) + (cc.code & 127) - 3104;
                goto L77;
            }
            goto L83;
        }
        goto L15;
    }
    if(_t140 == 8192) {
        _t202 = cc.ccs & 65535;
        if(_t202 == 8193) {
            _t143 = cc.code & 2097151;
        } else {
            if(_t202 == 8194) {
                 *__esp = cc.ccs;
                _v104 = cc.code;
                _t143 = wc_gb18030_to_ucs();
            } else {
                if(_t202 != 8192) {
                    _t143 = -1;
                } else {
                    _t143 = cc.code;
                }
            }
        }
        goto L82;
    }
    if(_t140 == 16384) {
        if(cc.ccs != 16385) {
            goto L76;
        }
        _t143 = cc.code;
        goto L82;
    } else {
    }
    goto L76;
L15:
    if(_t140 == 34816) {
        goto L58;
    } else {
    }
    goto L76;
}

wc_wchar_t wc_any_to_any(wc_wchar_t cc, wc_table* t)
{// addr = 0x080BE7F3  --  defined in 'ucs.c' at line 271
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_ccs is_wide;     // _cfa_fffffff0
    wc_uint32 ucs;   // _cfa_ffffffec
    unsigned int _v32;                     // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    wc_table* _v52;   // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6
    unsigned int _t44;                     // _t44
    struct  _t59;             // _t59
    _unknown_ _t60;                        // _t60

    _push(__ebx);
    __esp = __esp - 52;
    _t59 = _a4;
    is_wide = cc.ccs & 98304;
     *__esp = cc.ccs;
    _v56 = cc.code;
    ucs = wc_any_to_ucs();
    if(ucs == 255) {
L6:
        if(is_wide == 0) {
            _t44 = 16384;
        } else {
            _t44 = 49152;
        }
        cc.ccs = _t44;
         *_t59 = cc.ccs;
         *(_t59 + 4) = cc.code;
    } else {
        _v52 = t;
        wc_ucs_to_any( &(cc.ccs), ucs);
        __esp = __esp - 4;
        if((cc.ccs & 16384) != 0) {
            ucs = wc_ucs_to_fullwidth(ucs);
            if(ucs == 255) {
                goto L6;
            } else {
                _v56 = t;
                wc_ucs_to_any( &_v36, ucs);
                __esp = __esp - 4;
                cc.ccs = _v36;
                cc.code = _v32;
                if((cc.ccs & 16384) != 0) {
                    goto L6;
                } else {
                     *_t59 = cc.ccs;
                     *(_t59 + 4) = cc.code;
                }
            }
        } else {
             *_t59 = cc.ccs;
             *(_t59 + 4) = cc.code;
        }
    }
    return _t59;
}

wc_wchar_t wc_ucs_to_any_list(wc_uint32 ucs, wc_table** tlist)
{// addr = 0x080BE8DA  --  defined in 'ucs.c' at line 293
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table** t;     // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    wc_wchar_t cc;   // _cfa_ffffffe8
    wc_table* _v36;   // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct  _t38;             // _t38
    _unknown_ _t39;                        // _t39

    _push(__ebx);
    __esp = __esp - 36;
    _t38 = _a4;
    if(tlist == 0) {
L8:
        cc.ccs = 16384;
         *_t38 = cc.ccs;
         *((intOrPtr*)(_t38 + 4)) = _v20;
    } else {
        t = tlist;
        while( *t != 0) {
            if( *t->map == 0) {
L6:
                t =  &(t[1]);
                continue;
            }
            _v36 =  *t;
            wc_ucs_to_any( &(cc.ccs), ucs);
            __esp = __esp - 4;
            if((cc.ccs & 16384) != 0) {
                goto L6;
            }
             *_t38 = cc.ccs;
             *((intOrPtr*)(_t38 + 4)) = _v20;
            goto L9;
        }
        goto L8;
    }
L9:
    return _t38;
}

wc_wchar_t wc_any_to_any_ces(wc_wchar_t cc, wc_status* st)
{// addr = 0x080BE95E  --  defined in 'ucs.c' at line 312
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uint32 ucs;   // _cfa_fffffff0
    wc_ccs is_wide;     // _cfa_ffffffec
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    wc_table** _v52;   // _cfa_ffffffcc
    wc_table** _v56;   // _cfa_ffffffc8
    wc_table** _v60;   // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ __ebp;                       // r6
    unsigned int _t148;                    // _t148
    wc_table** _t159;   // _t159
    wc_table** _t175;   // _t175
    wc_table** _t182;   // _t182
    unsigned int _t199;                    // _t199
    wc_table** _t201;   // _t201
    unsigned int _t214;                    // _t214
    struct  _t222;            // _t222
    _unknown_ _t223;                       // _t223

    _push(__ebx);
    __esp = __esp - 52;
    _t222 = _a4;
     *__esp = cc.ccs;
    _v56 = cc.code;
    ucs = wc_any_to_ucs();
    is_wide = cc.ccs & 98304;
    if(ucs > 127) {
        if(ucs == 255) {
L48:
            if(is_wide == 0) {
                _t148 = 16384;
            } else {
L49:
                _t148 = 49152;
            }
            cc.ccs = _t148;
             *_t222 = cc.ccs;
             *(_t222 + 4) = cc.code;
            goto L52;
        }
        if((st & 32768) == 0) {
            if(st != 3153984) {
                if(is_wide == 0) {
                    _t159 = st->tlist;
                } else {
                    _t159 = st->tlistw;
                }
                _v52 = _t159;
                wc_ucs_to_any_list( &_v36, ucs);
                __esp = __esp - 4;
                cc.ccs = _v36;
                cc.code = _v32;
                if((cc.ccs & 16384) != 0) {
                    if(( *135119013 & 0xff) != 0) {
L23:
                        if(st != 3153979) {
                            if(ucs != 160) {
                                if((st & 4608) == 0 || ucs <= 127 || ucs > 159) {
                                    ucs = wc_ucs_to_fullwidth(ucs);
                                    if(ucs == 255) {
                                        goto L48;
                                    }
                                } else {
                                    cc.ccs = 16385;
                                    cc.code = ucs;
                                     *_t222 = cc.ccs;
                                     *(_t222 + 4) = cc.code;
                                    goto L52;
                                }
                                if(is_wide == 0) {
                                    _t175 = st->tlist;
                                } else {
                                    _t175 = st->tlistw;
                                }
                                _v56 = _t175;
                                wc_ucs_to_any_list( &_v36, ucs);
                                __esp = __esp - 4;
                                cc.ccs = _v36;
                                cc.code = _v32;
                                if((cc.ccs & 16384) != 0) {
                                    if(( *135119013 & 0xff) != 0) {
                                        goto L48;
                                    }
                                } else {
                                     *_t222 = cc.ccs;
                                     *(_t222 + 4) = cc.code;
                                    goto L52;
                                }
                                if(is_wide == 0) {
                                    _t182 = st->tlistw;
                                } else {
                                    _t182 = st->tlist;
                                }
                                _v60 = _t182;
                                wc_ucs_to_any_list( &_v36, ucs);
                                __esp = __esp - 4;
                                cc.ccs = _v36;
                                cc.code = _v32;
                                if((cc.ccs & 16384) != 0) {
                                    goto L48;
                                }
                                 *_t222 = cc.ccs;
                                 *(_t222 + 4) = cc.code;
                                goto L52;
                            }
                            goto L31;
                        }
                        goto L24;
L31:
                        cc.ccs = 322;
                        cc.code = 32;
                         *_t222 = cc.ccs;
                         *(_t222 + 4) = cc.code;
                        goto L52;
                    }
                    goto L18;
L24:
                    _v60 = ucs;
                    wc_ucs_to_gb18030( &_v36);
                    __esp = __esp - 4;
                    cc.ccs = _v36;
                    cc.code = _v32;
                    if((cc.ccs & 16384) != 0) {
                        if(is_wide == 0) {
                            _t199 = 16384;
                        } else {
                            _t199 = 49152;
                        }
                        cc.ccs = _t199;
                    }
                     *_t222 = cc.ccs;
                     *(_t222 + 4) = cc.code;
                } else {
                     *_t222 = cc.ccs;
                     *(_t222 + 4) = cc.code;
                }
                goto L52;
L18:
                if(is_wide == 0) {
                    _t201 = st->tlistw;
                } else {
                    _t201 = st->tlist;
                }
                _v56 = _t201;
                wc_ucs_to_any_list( &_v36, ucs);
                __esp = __esp - 4;
                cc.ccs = _v36;
                cc.code = _v32;
                if((cc.ccs & 16384) != 0) {
                    goto L23;
                } else {
                     *_t222 = cc.ccs;
                     *(_t222 + 4) = cc.code;
                    goto L52;
                }
                goto L24;
            }
            goto L6;
        }
        cc.ccs = wc_ucs_to_ccs(ucs);
        cc.code = ucs;
         *_t222 = cc.ccs;
         *(_t222 + 4) = cc.code;
        goto L52;
L6:
        _v56 = ucs;
        wc_ucs_to_johab( &(cc.ccs));
        __esp = __esp - 4;
        if((cc.ccs & 16384) != 0) {
            if(is_wide == 0) {
                _t214 = 16384;
            } else {
                _t214 = 49152;
            }
            cc.ccs = _t214;
        }
         *_t222 = cc.ccs;
         *(_t222 + 4) = cc.code;
    } else {
        cc.ccs = 322;
        cc.code = ucs;
         *_t222 = cc.ccs;
         *(_t222 + 4) = cc.code;
    }
L52:
    return _t222;
}

wc_wchar_t wc_any_to_iso2022(wc_wchar_t cc, wc_status* st)
{// addr = 0x080BECA5  --  defined in 'ucs.c' at line 376
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uint32 ucs;   // _cfa_fffffff0
    wc_ccs is_wide;     // _cfa_ffffffec
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    wc_table** _v52;   // _cfa_ffffffcc
    wc_table** _v56;   // _cfa_ffffffc8
    unsigned int _v60;                     // _cfa_ffffffc4
    unsigned int _v64;                     // _cfa_ffffffc0
    unsigned int _v68;                     // _cfa_ffffffbc
    _unknown_ __ebp;                       // r6
    unsigned int _t193;                    // _t193
    wc_table** _t197;   // _t197
    wc_table** _t207;   // _t207
    wc_table** _t215;   // _t215
    wc_table** _t241;   // _t241
    struct  _t268;            // _t268
    _unknown_ _t269;                       // _t269

    _push(__ebx);
    __esp = __esp - 52;
    _t268 = _a4;
     *__esp = cc.ccs;
    _v56 = cc.code;
    ucs = wc_any_to_ucs();
    is_wide = cc.ccs & 98304;
    if(ucs > 127) {
        if(ucs == 255) {
L54:
            if(is_wide == 0) {
                _t193 = 16384;
            } else {
                _t193 = 49152;
            }
            cc.ccs = _t193;
             *_t268 = cc.ccs;
             *(_t268 + 4) = cc.code;
        } else {
            if(is_wide == 0) {
                _t197 = st->tlist;
            } else {
                _t197 = st->tlistw;
            }
            _v52 = _t197;
            wc_ucs_to_any_list( &(cc.ccs), ucs);
            __esp = __esp - 4;
            if((cc.ccs & 16384) != 0) {
                if(( *135119020 & 0xff) != 0) {
L14:
                    if(( *135119013 & 0xff) != 0) {
L26:
                        if(ucs != 160) {
                            ucs = wc_ucs_to_fullwidth(ucs);
                            if(ucs == 255) {
L52:
                                if(ucs != 160) {
                                    goto L54;
                                } else {
                                    cc.ccs = 322;
                                    cc.code = 32;
                                     *_t268 = cc.ccs;
                                     *(_t268 + 4) = cc.code;
                                }
                            } else {
                                if(is_wide == 0) {
                                    _t207 = st->tlist;
                                } else {
                                    _t207 = st->tlistw;
                                }
                                _v56 = _t207;
                                wc_ucs_to_any_list( &_v36, ucs);
                                __esp = __esp - 4;
                                cc.ccs = _v36;
                                cc.code = _v32;
                                if((cc.ccs & 16384) != 0) {
                                    if(( *135119020 & 0xff) != 0) {
L40:
                                        if(( *135119013 & 0xff) != 0) {
                                            goto L52;
                                        } else {
                                            if(is_wide == 0) {
                                                _t215 = st->tlistw;
                                            } else {
                                                _t215 = st->tlist;
                                            }
                                            _v60 = _t215;
                                            wc_ucs_to_any_list( &_v36, ucs);
                                            __esp = __esp - 4;
                                            cc.ccs = _v36;
                                            cc.code = _v32;
                                            if((cc.ccs & 16384) != 0) {
                                                if(( *135119020 & 0xff) != 0) {
                                                    goto L52;
                                                } else {
                                                    if(is_wide == 0) {
                                                        _v68 = ucs;
                                                        wc_ucs_to_iso2022w( &_v36);
                                                        __esp = __esp - 4;
                                                        cc.ccs = _v36;
                                                        cc.code = _v32;
                                                    } else {
                                                        _v68 = ucs;
                                                        wc_ucs_to_iso2022( &_v36);
                                                        __esp = __esp - 4;
                                                        cc.ccs = _v36;
                                                        cc.code = _v32;
                                                    }
                                                    if((cc.ccs & 16384) != 0) {
                                                        goto L52;
                                                    } else {
                                                         *_t268 = cc.ccs;
                                                         *(_t268 + 4) = cc.code;
                                                    }
                                                }
                                            } else {
                                                 *_t268 = cc.ccs;
                                                 *(_t268 + 4) = cc.code;
                                            }
                                        }
                                    } else {
                                        if(is_wide == 0) {
                                            _v64 = ucs;
                                            wc_ucs_to_iso2022( &_v36);
                                            __esp = __esp - 4;
                                            cc.ccs = _v36;
                                            cc.code = _v32;
                                        } else {
                                            _v64 = ucs;
                                            wc_ucs_to_iso2022w( &_v36);
                                            __esp = __esp - 4;
                                            cc.ccs = _v36;
                                            cc.code = _v32;
                                        }
                                        if((cc.ccs & 16384) != 0) {
                                            goto L40;
                                        } else {
                                             *_t268 = cc.ccs;
                                             *(_t268 + 4) = cc.code;
                                        }
                                    }
                                } else {
                                     *_t268 = cc.ccs;
                                     *(_t268 + 4) = cc.code;
                                }
                            }
                        } else {
                            cc.ccs = 322;
                            cc.code = 32;
                             *_t268 = cc.ccs;
                             *(_t268 + 4) = cc.code;
                        }
                    } else {
                        if(is_wide == 0) {
                            _t241 = st->tlistw;
                        } else {
                            _t241 = st->tlist;
                        }
                        _v56 = _t241;
                        wc_ucs_to_any_list( &_v36, ucs);
                        __esp = __esp - 4;
                        cc.ccs = _v36;
                        cc.code = _v32;
                        if((cc.ccs & 16384) != 0) {
                            if(( *135119020 & 0xff) != 0) {
                                goto L26;
                            } else {
                                if(is_wide == 0) {
                                    _v64 = ucs;
                                    wc_ucs_to_iso2022w( &_v36);
                                    __esp = __esp - 4;
                                    cc.ccs = _v36;
                                    cc.code = _v32;
                                } else {
                                    _v64 = ucs;
                                    wc_ucs_to_iso2022( &_v36);
                                    __esp = __esp - 4;
                                    cc.ccs = _v36;
                                    cc.code = _v32;
                                }
                                if((cc.ccs & 16384) != 0) {
                                    goto L26;
                                } else {
                                     *_t268 = cc.ccs;
                                     *(_t268 + 4) = cc.code;
                                }
                            }
                        } else {
                             *_t268 = cc.ccs;
                             *(_t268 + 4) = cc.code;
                        }
                    }
                } else {
                    if(is_wide == 0) {
                        _v60 = ucs;
                        wc_ucs_to_iso2022( &_v36);
                        __esp = __esp - 4;
                        cc.ccs = _v36;
                        cc.code = _v32;
                    } else {
                        _v60 = ucs;
                        wc_ucs_to_iso2022w( &_v36);
                        __esp = __esp - 4;
                        cc.ccs = _v36;
                        cc.code = _v32;
                    }
                    if((cc.ccs & 16384) != 0) {
                        goto L14;
                    } else {
                         *_t268 = cc.ccs;
                         *(_t268 + 4) = cc.code;
                    }
                }
            } else {
                 *_t268 = cc.ccs;
                 *(_t268 + 4) = cc.code;
            }
        }
    } else {
        cc.ccs = 322;
        cc.code = ucs;
         *_t268 = cc.ccs;
         *(_t268 + 4) = cc.code;
    }
    return _t268;
}

wc_wchar_t wc_ucs_to_iso2022(wc_uint32 ucs)
{// addr = 0x080BF0AF  --  defined in 'ucs.c' at line 443
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table* t;      // _cfa_fffffff0
    int f;                                 // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    wc_wchar_t cc;   // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    wc_table* _v52;   // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct  _t107;            // _t107
    _unknown_ _t108;                       // _t108

    _push(__ebx);
    __esp = __esp - 52;
    _t107 = _a4;
    if(ucs > 65535) {
L22:
        cc.ccs = 16384;
         *_t107 = cc.ccs;
         *((intOrPtr*)(_t107 + 4)) = _v24;
    } else {
        f = 0;
        while(f <= 38) {
            t =  &ucs_cs96_table + (f << 4);
            if(t->map == 0) {
L6:
                f = f + 1;
                continue;
            }
            _v52 = t;
            wc_ucs_to_any( &(cc.ccs), ucs & 0xffff);
            __esp = __esp - 4;
            if((cc.ccs & 16384) != 0) {
                goto L6;
            }
             *_t107 = cc.ccs;
             *((intOrPtr*)(_t107 + 4)) = _v24;
            goto L23;
        }
        f = 0;
        while(f <= 20) {
            t =  &ucs_cs94_table + (f << 4);
            if(t->map == 0) {
L13:
                f = f + 1;
                continue;
            }
            _v52 = t;
            wc_ucs_to_any( &_v36, ucs & 0xffff);
            __esp = __esp - 4;
            cc.ccs = _v36;
            _v24 = _v32;
            if((cc.ccs & 16384) != 0) {
                goto L13;
            }
             *_t107 = cc.ccs;
             *((intOrPtr*)(_t107 + 4)) = _v24;
            goto L23;
        }
        f = 0;
        while(f < 193) {
            t = ucs_cs942_table + (f << 4);
            if(t->map == 0) {
L20:
                f = f + 1;
                continue;
            }
            _v52 = t;
            wc_ucs_to_any( &_v36, ucs & 0xffff);
            __esp = __esp - 4;
            cc.ccs = _v36;
            _v24 = _v32;
            if((cc.ccs & 16384) != 0) {
                goto L20;
            }
             *_t107 = cc.ccs;
             *((intOrPtr*)(_t107 + 4)) = _v24;
            goto L23;
        }
        goto L22;
    }
L23:
    return _t107;
}

wc_wchar_t wc_ucs_to_iso2022w(wc_uint32 ucs)
{// addr = 0x080BF22D  --  defined in 'ucs.c' at line 480
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_table* t;      // _cfa_fffffff0
    int f;                                 // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    wc_wchar_t cc;   // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    wc_table* _v52;   // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    struct  _t73;             // _t73
    _unknown_ _t74;                        // _t74

    _push(__ebx);
    __esp = __esp - 52;
    _t73 = _a4;
    if(ucs > 65535) {
L15:
        cc.ccs = 49152;
         *_t73 = cc.ccs;
         *((intOrPtr*)(_t73 + 4)) = _v24;
    } else {
        f = 0;
        while(f <= 16) {
            t =  &ucs_cs94w_table + (f << 4);
            if(t->map == 0) {
L6:
                f = f + 1;
                continue;
            }
            _v52 = t;
            wc_ucs_to_any( &(cc.ccs), ucs & 0xffff);
            __esp = __esp - 4;
            if((cc.ccs & 16384) != 0) {
                goto L6;
            }
             *_t73 = cc.ccs;
             *((intOrPtr*)(_t73 + 4)) = _v24;
            goto L16;
        }
        f = 0;
        while(f < 193) {
            t = ucs_cs96w_table + (f << 4);
            if(t->map == 0) {
L13:
                f = f + 1;
                continue;
            }
            _v52 = t;
            wc_ucs_to_any( &_v36, ucs & 0xffff);
            __esp = __esp - 4;
            cc.ccs = _v36;
            _v24 = _v32;
            if((cc.ccs & 16384) != 0) {
                goto L13;
            }
             *_t73 = cc.ccs;
             *((intOrPtr*)(_t73 + 4)) = _v24;
            goto L16;
        }
        goto L15;
    }
L16:
    return _t73;
}

wc_ccs wc_ucs_to_ccs(wc_uint32 ucs)
{// addr = 0x080BF338  --  defined in 'ucs.c' at line 509
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t11;                       // _t11
    signed int _t14;                       // _t14
    _unknown_ _t16;                        // _t16
    signed int _t17;                       // _t17
    signed int _t18;                       // _t18

    if(ucs <= 127 || ucs > 159) {
        if(ucs > 65535) {
            _t17 = 8192;
        } else {
            _t17 = 4096;
        }
        if((wc_is_ucs_wide(ucs) & 255) == 0) {
            _t11 = 0;
        } else {
            _t11 = 65536;
        }
        _t18 = _t17 | _t11;
        if((wc_is_ucs_combining(ucs) & 255) == 0) {
            _t14 = 0;
        } else {
            _t14 = 131072;
        }
        return _t14 | _t18;
    }
    return 16385;
}

wc_bool wc_is_ucs_wide(wc_uint32 ucs)
{// addr = 0x080BF3AA  --  defined in 'ucs.c' at line 519
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17

    if(ucs > 65535) {
        if(ucs == 131072 || ucs == 196608) {
            return 1;
        }
        return 0;
    }
    return wc_map_range_search(ucs & 0xffff,  &ucs_wide_map, 11);
}

wc_bool wc_is_ucs_combining(wc_uint32 ucs)
{// addr = 0x080BF408  --  defined in 'ucs.c' at line 530
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    _unknown_ _t14;                        // _t14

    if(( *135119009 & 0xff) != 0 && ucs <= 65535 && wc_map_range_search(ucs & 0xffff,  &ucs_combining_map, 99) != 0) {
        return 1;
    }
    return 0;
}

wc_bool wc_is_ucs_hangul(wc_uint32 ucs)
{// addr = 0x080BF452  --  defined in 'ucs.c' at line 538
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t11;                        // _t11

    if(ucs > 65535 || wc_map_range_search(ucs & 0xffff,  &ucs_hangul_map, 6) == 0) {
        return 0;
    }
    return 1;
}

wc_uint32 wc_ucs_precompose(wc_uint32 ucs1, wc_uint32 ucs2)
{// addr = 0x080BF491  --  defined in 'ucs.c' at line 546
    wc_map3* map;      // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    if(( *135119009 & 0xff) != 0 && ucs1 <= 65535 && ucs2 <= 65535) {
        map = wc_map3_search(ucs1 & 0xffff, ucs2 & 0xffff,  &ucs_precompose_map, 988);
        if(map == 0) {
            goto L5;
        } else {
            return  *(map + 4) & 0xffff;
        }
    }
L5:
    return -1;
}

wc_uint32 wc_ucs_to_fullwidth(wc_uint32 ucs)
{// addr = 0x080BF4F8  --  defined in 'ucs.c' at line 559
    wc_map* map;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12

    if(ucs > 65535) {
L3:
        return -1;
    }
    map = wc_map_search(ucs & 0xffff,  &ucs_fullwidth_map, 14);
    if(map == 0) {
        goto L3;
    }
    return  *(map + 2) & 0xffff;
    return __eax;
}

int wc_ucs_put_tag(char* p)
{// addr = 0x080BF541  --  defined in 'ucs.c' at line 571
    int i;                                 // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    _unknown_ _t32;                        // _t32

    if(p == 0 || ( *p & 0xff) == 0) {
        return 0;
    }
    i = 1;
    while(i <= n_tag_map) {
        if(strcasecmp(p,  *( &tag_map + i * 4)) != 0) {
            i = i + 1;
            continue;
        }
        return i;
    }
    n_tag_map = n_tag_map + 1;
    if(n_tag_map != 256) {
         *( &tag_map + n_tag_map * 4) = p;
        return n_tag_map;
    }
    return 0;
    return __eax;
}

char* wc_ucs_get_tag(int ntag)
{// addr = 0x080BF5CD  --  defined in 'ucs.c' at line 589
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6

    if(ntag == 0 || ntag > n_tag_map) {
        return 0;
    }
    return  *( &tag_map + ntag * 4);
}

wtf_push_ucs(Str os, wc_uint32 ucs, wc_status* st)
{// addr = 0x080BF5F3  --  defined in 'ucs.c' at line 597
    wc_ccs ccs;         // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t117;                             // _t117
    int _t146;                             // _t146
    intOrPtr _t172;                        // _t172

    if(ucs <= 917503 || ucs > 917631) {
        if( *(st + 44) != 0) {
            st->ntag = wc_ucs_put_tag( *( *(st + 44)));
             *(st + 44) = 0;
        }
        if(ucs > 127) {
            ccs = wc_ucs_to_ccs(ucs);
            if(st->ntag != 0 && ucs <= 1114111) {
                ccs = ccs | 8193;
                ucs = ucs | st->ntag << 24;
            }
            wtf_push(os, ccs, ucs);
            return;
        }
        if(st->ntag == 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t117 = os->length;
             *(os->ptr + _t117) = ucs & 255;
            os->length = _t117 + 1;
             *(os->ptr + os->length) = 0;
            return;
        }
        wtf_push(os, 8193, st->ntag << 24 | ucs);
        return;
    } else {
        if(( *135119010 & 0xff) == 0) {
            return;
        }
        if(ucs != 917505) {
            if(ucs != 917631) {
                if( *(st + 44) == 0) {
                    goto L25;
                }
                goto L8;
L26:
                return;
            }
            goto L6;
L8:
            if(ucs <= 917535) {
                goto L26;
            }
            if( *((intOrPtr*)( *(st + 44) + 4)) + 1 >=  *((intOrPtr*)( *(st + 44) + 8))) {
                Strgrow( *(st + 44));
            }
            _t146 =  *(st + 44);
            _t172 =  *((intOrPtr*)(_t146 + 4));
            ( *( *(st + 44)))[_t172] = ucs & 0x7f;
             *((intOrPtr*)(_t146 + 4)) = _t172 + 1;
            ( *( *(st + 44)))[ *((intOrPtr*)( *(st + 44) + 4))] = 0;
            return;
        }
         *(st + 44) = Strnew_size(4);
        return;
L6:
         *(st + 44) = 0;
        st->ntag = 0;
        return;
L25:
        return;
    }
}

wc_wchar_t wc_uhc_to_cs128w(wc_wchar_t cc)
{// addr = 0x080BF800  --  defined in 'uhc.c' at line 36
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    _unknown_ _t45;                        // _t45

    __ecx = _a4;
    _t45 = (cc.code >> 8 & 255) * (cc.code >> 8 & 255) + (cc.code & 255);
    if((cc.code & 255) <= 96) {
        _t26 = 65;
    } else {
        if((cc.code & 255) > 128) {
            _t26 = 77;
        } else {
            _t26 = 71;
        }
    }
    cc.code = _t45 - _t26 - 22962;
    if(cc.code > 16383) {
        cc.ccs = 34846;
        cc.code = cc.code - 16384;
    } else {
        cc.ccs = 34845;
    }
    cc.code = (cc.code >> 7 << 8) + (cc.code & 127);
     *__ecx = cc.ccs;
     *(__ecx + 4) = cc.code;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_uhc(wc_wchar_t cc)
{// addr = 0x080BF8AF  --  defined in 'uhc.c' at line 50
    unsigned int _v20;                     // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t47;                        // _t47
    _unknown_ _t55;                        // _t55
    _unknown_ _t60;                        // _t60
    _unknown_ _t66;                        // _t66
    _unknown_ _t79;                        // _t79
    _unknown_ _t82;                        // _t82
    _unknown_ _t84;                        // _t84
    _unknown_ _t86;                        // _t86
    _unknown_ _t91;                        // _t91
    signed int _t96;                       // _t96

    __esi = _a4;
    cc.code = ((cc.code >> 8 & 127) << 7) + (cc.code & 127);
    if(cc.ccs == 34846) {
        cc.code = cc.code + 16384;
    }
    cc.ccs = 34844;
    _v20 = cc.code;
    _t96 = (_v20 * -1206451487 >> 32 >> 7) + 129 << 8;
    _t79 = cc.code - cc.code * -1206451487 * (_t73 * -1206451487 >> 32 >> 7);
    if(cc.code - (cc.code * -1206451487 >> 32 >> 7) * (cc.code * -1206451487 >> 32 >> 7) <= 25) {
        _t60 = 65;
    } else {
        if(cc.code - (cc.code * -1206451487 >> 32 >> 7) * (cc.code * -1206451487 >> 32 >> 7) > 51) {
            _t60 = 77;
        } else {
            _t60 = 71;
        }
    }
    cc.code = _t96 + _t79 + _t60;
     *__esi = cc.ccs;
     *(__esi + 4) = cc.code;
    return __esi;
}

wc_uint32 wc_uhc_to_N(wc_uint32 c)
{// addr = 0x080BF9A2  --  defined in 'uhc.c' at line 61
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27
    _unknown_ _t43;                        // _t43
    _unknown_ _t54;                        // _t54
    _unknown_ _t67;                        // _t67
    _unknown_ _t71;                        // _t71
    _unknown_ _t74;                        // _t74

    if(c > 41376) {
        if(c > 41632) {
            if(c > 41703) {
                _t67 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
                if((c & 255) <= 96) {
                    _t27 = 65;
                } else {
                    if((c & 255) > 128) {
                        _t27 = 77;
                    } else {
                        _t27 = 71;
                    }
                }
                return _t67 - _t27 - (c >> 8) * (c >> 8) - 7826;
            }
            goto L17;
        }
        goto L9;
L17:
        return c - 35838;
    }
    _t74 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) <= 96) {
        _t54 = 65;
    } else {
        if((c & 255) > 128) {
            _t54 = 77;
        } else {
            _t54 = 71;
        }
    }
    return _t74 - _t54 - 22962;
L9:
    _t71 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) <= 96) {
        _t43 = 65;
    } else {
        if((c & 255) > 128) {
            _t43 = 77;
        } else {
            _t43 = 71;
        }
    }
    return _t71 - _t43 - 23056;
}

Str wc_conv_from_uhc(Str is, wc_ces ces)
{// addr = 0x080BFAE3  --  defined in 'uhc.c' at line 74
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 uhc;   // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t119;                             // _t119
    signed int _t124;                      // _t124
    int _t133;                             // _t133

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
L2:
    while(p < ep) {
L3:
        if(( *p & 0xff) >= 0) {
            p =  &(p[1]);
            goto L2;
        }
        break;
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t119 = state;
        if(_t119 == 0) {
            _t124 =  *( &WC_UHC_MAP + ( *p & 0xff)) & 0xff;
            if(_t124 == 2) {
                wtf_push_unknown(os, p, 1);
L18:
                goto L28;
            }
            goto L12;
L15:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t133 = os->length;
             *(os->ptr + _t133) =  *p & 0xff;
            os->length = _t133 + 1;
             *(os->ptr + os->length) = 0;
            goto L28;
        }
        if(_t119 == 1) {
            if(( *( &WC_UHC_MAP + ( *p & 0xff)) & 4) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                uhc =  *p & 0xff | ( *(p - 1) & 0xff) << 8;
                if(( *(p - 1) & 0xff) <= 160 || ( *p & 0xff) <= 160 || uhc == 41702 || uhc == 41703) {
                    wtf_push(os, 34844, uhc);
                } else {
                    wtf_push(os, 33091, uhc);
                }
            }
            state = 0;
        }
L28:
        p =  &(p[1]);
        continue;
L12:
        if(_t124 != 12) {
            goto L15;
        }
        state = 1;
        goto L18;
    }
    if(state == 1) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

wc_push_to_uhc(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BFD21  --  defined in 'uhc.c' at line 129
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t125;                    // _t125
    int _t132;                             // _t132
    int _t144;                             // _t144
    unsigned int _t159;                    // _t159
    int _t172;                             // _t172
    int _t184;                             // _t184
    int _t198;                             // _t198

    while(1) {
        _t125 = cc.ccs;
        if(_t125 == 34844) {
            break;
        }
        if(_t125 > 34844) {
            if(_t125 <= 34846) {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &(cc.ccs);
                wc_cs128w_to_uhc();
                __esp = __esp - 4;
                break;
            }
            goto L8;
        }
        if(_t125 != 16384) {
            if(_t125 == 33091) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t172 = os->length;
                 *(os->ptr + _t172) = (cc.code >> 8 | 128) & 255;
                os->length = _t172 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t184 = os->length;
                 *(os->ptr + _t184) = (cc.code | 128) & 255;
                os->length = _t184 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            if(_t125 == 322) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t198 = os->length;
                 *(os->ptr + _t198) = cc.code & 255;
                os->length = _t198 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
L28:
            if(( *135119011 & 0xff) == 0) {
                if((cc.ccs & 98304) == 0) {
                    _t159 = 16384;
                } else {
                    _t159 = 49152;
                }
                cc.ccs = _t159;
            } else {
                _v32 = st;
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &_v20;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.ccs = _v20;
                cc.code = _v16;
            }
            continue;
        }
        if(( *135119022 & 0xff) != 0) {
        } else {
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L35;
L37:
L35:
        return;
        goto L37;
L8:
        if(_t125 == 49152) {
            if(( *135119022 & 0xff) != 0) {
                return;
            }
            goto L25;
        }
        goto L28;
L25:
        Strcat_charp(os, WcReplaceW);
        return;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t132 = os->length;
     *(os->ptr + _t132) = cc.code >> 8 & 255;
    os->length = _t132 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t144 = os->length;
     *(os->ptr + _t144) = cc.code & 255;
    os->length = _t144 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_uhc(wc_uchar c, wc_status* st)
{// addr = 0x080BFFD6  --  defined in 'uhc.c' at line 168
    wc_uint32 uhc;   // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t55;                              // _t55
    signed int _t58;                       // _t58
    struct _Str* _t66;    // _t66
    _unknown_ _t74;                        // _t74
    int _t93;                              // _t93

    _v32 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.2735 = Strnew_size(8);
    }
    _t55 = st->state;
    if(_t55 == 0) {
        _t58 =  *( &WC_UHC_MAP + (_v32 & 255)) & 0xff;
        if(_t58 != 2) {
            if(_t58 == 12) {
                uhcu = _v32 & 0xff;
                st->state = 1;
                return 0;
            }
            if(os.2735->length + 1 >= os.2735->area_size) {
                Strgrow(os.2735);
            }
            _t66 = os.2735;
            _t93 = _t66->length;
             *( *os.2735 + _t93) = _v32 & 0xff;
            _t66->length = _t93 + 1;
             *( *os.2735 + os.2735->length) = 0;
        }
    } else {
        if(_t55 == 1) {
            if(( *( &WC_UHC_MAP + (_v32 & 255)) & 4) != 0) {
                uhc = _v32 & 255 | (uhcu & 0xff) << 8;
                if((uhcu & 0xff) <= 160 || _v32 <= 160 || uhc == 41702 || uhc == 41703) {
                    wtf_push(os.2735, 34844, uhc);
                } else {
                    wtf_push(os.2735, 33091, uhc);
                }
            }
        }
    }
    st->state = -1;
    return os.2735;
}

Str wc_conv_from_utf7(Str is, wc_ces ces)
{// addr = 0x080C0158  --  defined in 'utf7.c' at line 62
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 b;     // _cfa_ffffffdc
    wc_uint32 high;   // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    wc_status st;    // _cfa_ffffff9c
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t166;                       // _t166
    int _t173;                             // _t173
    signed int _t180;                      // _t180
    signed int _t217;                      // _t217
    int _t224;                             // _t224
    _unknown_ _t260;                       // _t260

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    high = 0;
    p = sp;
    while(p < ep && ( *p & 0xff) < 0) {
        if(( *p & 0xff) != 43) {
            p =  &(p[1]);
            continue;
        }
        break;
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(((0 + is->length * 4) * 1431655766 >> 32) - (0 + is->length * 4 >> 31));
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    _v56 = 0;
    _v52 = 0;
    while(p < ep) {
        _t173 = state;
        if(_t173 == 1) {
            if(( *p & 0xff) == 45) {
                wtf_push_ucs(os, 43,  &(st.ces_info));
            }
L17:
            _t180 =  *( &WC_UTF7_MAP + ( *p & 0xff)) & 0xff;
            if(_t180 == 32) {
L20:
                b =  *(( *p & 0xff) - 32 +  &c_base64_map) & 0xff;
                _v44 = _v44 - 6;
                if(_v44 <= 0) {
                    _v48 = _v48 | b >> ( ~_v44 & 255);
                    if(_v48 <= 55295 || _v48 > 56319) {
                        if(_v48 <= 56319 || _v48 > 57343) {
                            if(_v48 != 65279) {
                                wtf_push_ucs(os, _v48,  &(st.ces_info));
                            }
                        } else {
                            if(high != 0) {
                                wtf_push_ucs(os, (_v48 & 1023 | (high & 1023) << 10) + 65536,  &(st.ces_info));
                            }
                            high = 0;
                        }
                    } else {
                        if(high != 0) {
                            high = 0;
                        } else {
                            high = _v48;
                        }
                    }
                    _v44 = _v44 + 16;
                    _v48 = 0;
                }
                _v48 = b << (_v44 & 255) & 65535 | _v48;
                state = 2;
                goto L45;
            }
            goto L18;
        }
        if(_t173 == 2) {
            goto L17;
        }
        if(_t173 != 0) {
L37:
            _t217 =  *( &WC_UTF7_MAP + ( *p & 0xff)) & 0xff;
            if(_t217 == 6) {
L40:
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t224 = os->length;
                 *(os->ptr + _t224) =  *p & 0xff;
                os->length = _t224 + 1;
                 *(os->ptr + os->length) = 0;
                goto L45;
            }
            goto L38;
        }
        if(( *p & 0xff) != 43) {
        } else {
            state = 1;
            _v44 = 16;
            _v48 = 0;
            high = 0;
L45:
            p =  &(p[1]);
            continue;
        }
        goto L37;
L38:
        if(_t217 == 8) {
            wtf_push_unknown(os, p, 1);
            goto L45;
        }
        if(_t217 != 4) {
            wtf_push_ucs(os,  *p & 0xff,  &(st.ces_info));
            goto L45;
        }
        goto L40;
L18:
        if(_t180 == 64) {
            state = 0;
            goto L45;
        }
        if(_t180 != 16) {
            goto L37;
        }
        goto L20;
    }
    return os;
}

wc_push_ucs_to_utf7(Str os, wc_uint32 ucs, wc_status* st)
{// addr = 0x080C04AB  --  defined in 'utf7.c' at line 146
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t306;                       // _t306
    int _t322;                             // _t322
    int _t337;                             // _t337
    int _t361;                             // _t361
    int _t385;                             // _t385
    signed int _t394;                      // _t394
    int _t403;                             // _t403
    int _t416;                             // _t416
    int _t428;                             // _t428
    int _t445;                             // _t445
    int _t457;                             // _t457
    int _t471;                             // _t471
    int _t483;                             // _t483

    if(ucs > 1114111) {
        return;
    }
    if(ucs <= 65535) {
        if(ucs > 127) {
L31:
            if(st->state != 2 || st->shift == 0) {
                if(st->state != 2) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t361 = os->length;
                     *((char*)(os->ptr + _t361)) = 43;
                    os->length = _t361 + 1;
                     *(os->ptr + os->length) = 0;
                    st->state = 2;
                }
                st->shift = 16;
                 *(st + 52) = 0;
            } else {
                st->shift = st->shift + 16;
                 *(st + 52) =  *(st + 52) | ucs >> (st->shift & 255);
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t385 = os->length;
                 *(os->ptr + _t385) =  *( *(st + 52) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 0xff;
                os->length = _t385 + 1;
                 *(os->ptr + os->length) = 0;
            }
            st->shift = st->shift - 6;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t322 = os->length;
             *(os->ptr + _t322) =  *((ucs >> (st->shift & 255) & 63) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 0xff;
            os->length = _t322 + 1;
             *(os->ptr + os->length) = 0;
            st->shift = st->shift - 6;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t337 = os->length;
             *(os->ptr + _t337) =  *((ucs >> (st->shift & 255) & 63) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 0xff;
            os->length = _t337 + 1;
             *(os->ptr + os->length) = 0;
            if(st->shift == 0) {
                goto L48;
            }
            st->shift = st->shift - 6;
             *(st + 52) = ucs << ( ~(st->shift) & 255) & 63;
            return;
        }
        goto L4;
    }
    ucs = ucs - 65536 & 1023 | ucs - 65536 >> 10 << 16;
    wc_push_ucs_to_utf7(os, ucs >> 16, st);
    wc_push_ucs_to_utf7(os, ucs & 0xffff, st);
    return;
L4:
    _t394 =  *( &WC_UTF7_MAP + ucs) & 0xff;
    if(_t394 == 16) {
L11:
        if(st->state == 2) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t416 = os->length;
             *(os->ptr + _t416) =  *( *(st + 52) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 0xff;
            os->length = _t416 + 1;
             *(os->ptr + os->length) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t428 = os->length;
             *((char*)(os->ptr + _t428)) = 45;
            os->length = _t428 + 1;
             *(os->ptr + os->length) = 0;
            st->state = 0;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t403 = os->length;
         *(os->ptr + _t403) = ucs & 255;
        os->length = _t403 + 1;
         *(os->ptr + os->length) = 0;
        return;
    }
    if(_t394 > 16) {
        if(_t394 == 32) {
            if(st->state == 2) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t471 = os->length;
                 *(os->ptr + _t471) =  *( *(st + 52) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 0xff;
                os->length = _t471 + 1;
                 *(os->ptr + os->length) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t483 = os->length;
                 *((char*)(os->ptr + _t483)) = 45;
                os->length = _t483 + 1;
                 *(os->ptr + os->length) = 0;
                st->state = 0;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t445 = os->length;
             *((char*)(os->ptr + _t445)) = 43;
            os->length = _t445 + 1;
             *(os->ptr + os->length) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t457 = os->length;
             *((char*)(os->ptr + _t457)) = 45;
            os->length = _t457 + 1;
             *(os->ptr + os->length) = 0;
            return;
        }
        goto L10;
    }
    if(_t394 == 0 || _t394 == 4) {
        goto L11;
    }
    goto L31;
L10:
    if(_t394 != 64) {
        goto L31;
    }
    goto L11;
L48:
    return;
}

int wc_push_tag_to_utf7(Str os, int ntag, wc_status* st)
{// addr = 0x080C0A16  --  defined in 'utf7.c' at line 204
    char* p;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    if(ntag != 0) {
        p = wc_ucs_get_tag(ntag);
        if(p == 0) {
            ntag = 0;
        }
    }
    if(ntag == 0) {
        wc_push_ucs_to_utf7(os, 917631, st);
    } else {
        wc_push_ucs_to_utf7(os, 917505, st);
        while(( *p & 0xff) != 0) {
            wc_push_ucs_to_utf7(os,  *p & 0xff | 917504, st);
            p =  &(p[1]);
        }
    }
    return ntag;
}

wc_push_to_utf7(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C0AB2  --  defined in 'utf7.c' at line 223
    char* p;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t109;                      // _t109
    unsigned int _t120;                    // _t120
    unsigned int _t161;                    // _t161

    while(1) {
L1:
        _t109 = cc.ccs & 65535;
        if(_t109 == 8192) {
            break;
        }
        if(_t109 > 8192) {
            if(_t109 == 16384) {
                if(( *135119022 & 0xff) != 0) {
L48:
                    return;
                }
                goto L34;
            }
            goto L8;
L34:
            if(st->ntag != 0) {
                st->ntag = wc_push_tag_to_utf7(os, 0, st);
            }
            p = WcReplace;
            while(( *p & 0xff) != 0) {
                wc_push_ucs_to_utf7(os,  *p & 0xff, st);
                p =  &(p[1]);
            }
            return;
        }
        if(_t109 == 577) {
            if(st->ntag != 0) {
                st->ntag = wc_push_tag_to_utf7(os, 0, st);
            }
            wc_push_ucs_to_utf7(os, cc.code, st);
            return;
        }
        if(_t109 == 4096 || _t109 == 322) {
L16:
            if(st->ntag != 0) {
L17:
                st->ntag = wc_push_tag_to_utf7(os, 0, st);
            }
            wc_push_ucs_to_utf7(os, cc.code, st);
            return;
        } else {
L40:
            if(( *135119011 & 0xff) == 0) {
L43:
                if((cc.ccs & 98304) == 0) {
                    _t161 = 16384;
                } else {
                    _t161 = 49152;
                }
                cc.ccs = _t161;
                continue;
            }
             *__esp = cc.ccs;
            _v40 = cc.code;
            cc.code = wc_any_to_ucs();
            if(cc.code == 255) {
                goto L43;
            }
            cc.ccs = 4096;
            continue;
        }
L8:
        if(_t109 == 49152) {
            if(( *135119022 & 0xff) != 0) {
                return;
            }
            goto L27;
        }
        if(_t109 == 8193) {
            if(( *135119010 & 0xff) != 0 && cc.code >> 24 != st->ntag) {
                st->ntag = wc_push_tag_to_utf7(os, cc.code >> 24, st);
            }
            wc_push_ucs_to_utf7(os, cc.code & 2097151, st);
            return;
        }
        goto L40;
L27:
        if(st->ntag != 0) {
            st->ntag = wc_push_tag_to_utf7(os, 0, st);
        }
        p = WcReplaceW;
        while(( *p & 0xff) != 0) {
            wc_push_ucs_to_utf7(os,  *p & 0xff, st);
            p =  &(p[1]);
        }
        return;
    }
    if(cc.code <= 1114111) {
        goto L16;
    }
    if((cc.ccs & 98304) == 0) {
        _t120 = 16384;
    } else {
        _t120 = 49152;
    }
    cc.ccs = _t120;
    goto L1;
}

wc_push_to_utf7_end(Str os, wc_status* st)
{// addr = 0x080C0D72  --  defined in 'utf7.c' at line 278
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    int _t63;                              // _t63
    int _t76;                              // _t76

    if(st->ntag != 0) {
        st->ntag = wc_push_tag_to_utf7(os, 0, st);
    }
    if(st->state == 2) {
        if(st->shift != 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t76 = os->length;
             *(os->ptr + _t76) =  *( *((intOrPtr*)(st + 52)) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 0xff;
            os->length = _t76 + 1;
             *(os->ptr + os->length) = 0;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t63 = os->length;
         *((char*)(os->ptr + _t63)) = 45;
        os->length = _t63 + 1;
         *(os->ptr + os->length) = 0;
        return;
    }
    return;
}

Str wc_char_conv_from_utf7(wc_uchar c, wc_status* st)
{// addr = 0x080C0E5E  --  defined in 'utf7.c' at line 291
    wc_uint32 b;     // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    int _t116;                             // _t116
    signed int _t119;                      // _t119
    _unknown_ _t171;                       // _t171
    signed int _t174;                      // _t174
    struct _Str* _t180;   // _t180
    _unknown_ _t195;                       // _t195
    int _t220;                             // _t220

    _v32 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.2932 = Strnew_size(8);
    }
    _t116 = st->state;
    if(_t116 == 1) {
        if(_v32 != 45) {
            goto L9;
        }
        goto L8;
    }
    if(_t116 == 2) {
L9:
        _t119 =  *( &WC_UTF7_MAP + (_v32 & 255)) & 0xff;
        if(_t119 == 32) {
L12:
            b =  *((_v32 & 255) - 32 +  &c_base64_map) & 0xff;
            st->shift = st->shift - 6;
            if(st->shift <= 0) {
                 *(st + 52) =  *(st + 52) | b >> ( ~(st->shift) & 255);
                if( *(st + 52) <= 55295 ||  *(st + 52) > 56319) {
                    if( *(st + 52) <= 56319 ||  *(st + 52) > 57343) {
                        if( *(st + 52) != 65279) {
                            wtf_push_ucs(os.2932,  *(st + 52), st);
                        }
                    } else {
                        if(high.2933 != 0) {
                            wtf_push_ucs(os.2932, ( *(st + 52) & 1023 | (high.2933 & 1023) << 10) + 65536, st);
                        }
                        high.2933 = 0;
                    }
                } else {
                    if(high.2933 != 0) {
                        high.2933 = 0;
                    } else {
                        high.2933 =  *(st + 52);
                    }
                }
                st->shift = st->shift + 16;
                 *(st + 52) = 0;
            }
             *(st + 52) =  *(st + 52) | b << (st->shift & 255) & 65535;
            st->state = 2;
            return os.2932;
        }
        goto L10;
    }
    if(_t116 == 0) {
        if(_v32 == 43) {
            st->state = 1;
            st->shift = 16;
             *(st + 52) = 0;
            high.2933 = 0;
            return 0;
        }
    }
L29:
    _t174 =  *( &WC_UTF7_MAP + (_v32 & 255)) & 0xff;
    if(_t174 == 6) {
L32:
        if(os.2932->length + 1 >= os.2932->area_size) {
            Strgrow(os.2932);
        }
        _t180 = os.2932;
        _t220 = _t180->length;
         *( *os.2932 + _t220) = _v32 & 0xff;
        _t180->length = _t220 + 1;
         *( *os.2932 + os.2932->length) = 0;
L37:
        st->state = -1;
        return os.2932;
    }
L30:
    if(_t174 == 8) {
L36:
        goto L37;
    }
    if(_t174 != 4) {
        wtf_push_ucs(os.2932, _v32 & 255, st);
        goto L37;
    }
    goto L32;
L10:
    if(_t119 == 64) {
        st->state = -1;
        return 0;
    }
    if(_t119 != 16) {
        goto L29;
    }
    goto L12;
L8:
    wtf_push_ucs(os.2932, 43, st);
    st->state = -1;
    return os.2932;
}

size_t wc_ucs_to_utf8(wc_uint32 ucs, wc_uchar* utf8)
{// addr = 0x080C117C  --  defined in 'utf8.c' at line 32
    _unknown_ __ebp;                       // r6
    _unknown_ _t115;                       // _t115
    _unknown_ _t145;                       // _t145
    _unknown_ _t170;                       // _t170
    _unknown_ _t190;                       // _t190
    _unknown_ _t205;                       // _t205
    _unknown_ _t215;                       // _t215
    _unknown_ _t220;                       // _t220

    if(ucs > 127) {
        if(ucs > 2047) {
            if(ucs > 65535) {
                if(ucs > 2097151) {
                    if(ucs > 67108863) {
                        if(ucs >= 0) {
                             *utf8 = 0;
                            return 0;
                        }
                        goto L11;
                    }
                    goto L9;
L11:
                     *utf8 = (ucs >> 30 | 252) & 255;
                    utf8[1] = (ucs >> 24 & 63 | 128) & 255;
                    utf8[2] = (ucs >> 18 & 63 | 128) & 255;
                    utf8[3] = (ucs >> 12 & 63 | 128) & 255;
                    utf8[4] = (ucs >> 6 & 63 | 128) & 255;
                    utf8[5] = (ucs & 63 | 128) & 255;
                    utf8[6] = 0;
                    return 6;
                }
                goto L7;
L9:
                 *utf8 = (ucs >> 24 | 248) & 255;
                utf8[1] = (ucs >> 18 & 63 | 128) & 255;
                utf8[2] = (ucs >> 12 & 63 | 128) & 255;
                utf8[3] = (ucs >> 6 & 63 | 128) & 255;
                utf8[4] = (ucs & 63 | 128) & 255;
                utf8[5] = 0;
                return 5;
            }
            goto L5;
L7:
             *utf8 = (ucs >> 18 | 240) & 255;
            utf8[1] = (ucs >> 12 & 63 | 128) & 255;
            utf8[2] = (ucs >> 6 & 63 | 128) & 255;
            utf8[3] = (ucs & 63 | 128) & 255;
            utf8[4] = 0;
            return 4;
        }
        goto L3;
L5:
         *utf8 = (ucs >> 12 | 224) & 255;
        utf8[1] = (ucs >> 6 & 63 | 128) & 255;
        utf8[2] = (ucs & 63 | 128) & 255;
        utf8[3] = 0;
        return 3;
    }
     *utf8 = ucs & 255;
    utf8[1] = 0;
    return 1;
L3:
     *utf8 = (ucs >> 6 | 192) & 255;
    utf8[1] = (ucs & 63 | 128) & 255;
    utf8[2] = 0;
    return 2;
}

wc_uint32 wc_utf8_to_ucs(wc_uchar* utf8)
{// addr = 0x080C13A7  --  defined in 'utf8.c' at line 80
    wc_uint32 ucs;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15

    if(( *( &WC_UTF8_MAP + ( *utf8 & 0xff)) & 0xff) <= 6) {
        goto __eax;
    }
    return -1;
}

Str wc_conv_from_utf8(Str is, wc_ces ces)
{// addr = 0x080C15E5  --  defined in 'utf8.c' at line 137
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_uchar* q;      // _cfa_ffffffe0
    int state;                             // _cfa_ffffffdc
    size_t next;        // _cfa_ffffffd8
    wc_uint32 ucs;   // _cfa_ffffffd4
    int _v56;                              // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    wc_status st;    // _cfa_ffffff98
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t142;                       // _t142
    int _t149;                             // _t149
    unsigned int _t155;                    // _t155
    int _t168;                             // _t168
    _unknown_ _t219;                       // _t219

    sp = is->ptr;
    ep = sp + is->length;
    q = 0;
    state = 0;
    next = 0;
    p = sp;
L2:
    while(p < ep) {
L3:
        if(( *p & 0xff) >= 0) {
            p =  &(p[1]);
            goto L2;
        }
        break;
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(((0 + is->length * 4) * 1431655766 >> 32) - (0 + is->length * 4 >> 31));
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    _v60 = 0;
    _v56 = 0;
    while(p < ep) {
        _t149 = state;
        if(_t149 == 0) {
            next =  *( &WC_UTF8_MAP + ( *p & 0xff)) & 0xff;
            _t155 = next;
            if(_t155 == 1) {
                wtf_push_ucs(os,  *p & 0xff,  &(st.ces_info));
L23:
                goto L34;
            }
            goto L13;
L18:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t168 = os->length;
             *(os->ptr + _t168) =  *p & 0xff;
            os->length = _t168 + 1;
             *(os->ptr + os->length) = 0;
            goto L23;
        } else {
            if(_t149 == 1) {
                if(( *( &WC_UTF8_MAP + ( *p & 0xff)) & 0xff) == 0) {
                    next = next - 1;
                    if(next == 0) {
                        state = 0;
                        ucs = wc_utf8_to_ucs(q);
                        if(ucs == 255 || ucs > 55295 && ucs <= 57343) {
                            wtf_push_unknown(os, q, p - q + 1);
                        } else {
                            if(ucs != 65279) {
                                wtf_push_ucs(os, ucs,  &(st.ces_info));
                            }
                        }
                    }
                } else {
                    wtf_push_unknown(os, q, p - q + 1);
                    state = 0;
                }
            }
L34:
            p =  &(p[1]);
            continue;
        }
L13:
        if(_t155 < 1 || _t155 == 7) {
            wtf_push_unknown(os, p, 1);
            goto L23;
        }
        if(_t155 == 8) {
            goto L18;
        }
        q = p;
        next = next - 1;
        state = 1;
        goto L34;
    }
    if(state == 1) {
        wtf_push_unknown(os, q, p - q);
    }
    return os;
}

int wc_push_tag_to_utf8(Str os, int ntag)
{// addr = 0x080C18A7  --  defined in 'utf8.c' at line 208
    char* p;                               // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    _unknown_ _t29;                        // _t29
    _unknown_ _t38;                        // _t38

    if(ntag != 0) {
        p = wc_ucs_get_tag(ntag);
        if(p == 0) {
            ntag = 0;
        }
    }
    if(ntag == 0) {
        wc_ucs_to_utf8(917631,  &utf8_buf);
        Strcat_charp(os,  &utf8_buf);
    } else {
        wc_ucs_to_utf8(917505,  &utf8_buf);
        Strcat_charp(os,  &utf8_buf);
        while(( *p & 0xff) != 0) {
            wc_ucs_to_utf8( *p & 0xff | 917504,  &utf8_buf);
            Strcat_charp(os,  &utf8_buf);
            p =  &(p[1]);
        }
    }
    return ntag;
}

wc_push_to_utf8(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C196D  --  defined in 'utf8.c' at line 232
    unsigned int _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t97;                       // _t97
    _unknown_ _t101;                       // _t101
    _unknown_ _t123;                       // _t123
    unsigned int _t136;                    // _t136
    _unknown_ _t143;                       // _t143
    int _t156;                             // _t156

    while(1) {
        _t97 = cc.ccs & 65535;
        if(_t97 == 8192) {
            break;
        }
        if(_t97 <= 8192) {
            if(_t97 == 577) {
                if(st->ntag != 0) {
                    st->ntag = wc_push_tag_to_utf8(os, 0);
                }
                wc_ucs_to_utf8(cc.code,  &utf8_buf);
                Strcat_charp(os,  &utf8_buf);
                return;
            }
            if(_t97 == 4096) {
                break;
            }
            if(_t97 == 322) {
                if(st->ntag != 0) {
                    st->ntag = wc_push_tag_to_utf8(os, 0);
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t156 = os->length;
                 *(os->ptr + _t156) = cc.code & 0x7f;
                os->length = _t156 + 1;
                 *(os->ptr + os->length) = 0;
                return;
            }
L34:
            if(( *135119011 & 0xff) == 0) {
L37:
                if((cc.ccs & 98304) == 0) {
                    _t136 = 16384;
                } else {
                    _t136 = 49152;
                }
                cc.ccs = _t136;
                continue;
            } else {
                 *__esp = cc.ccs;
                _v24 = cc.code;
                cc.code = wc_any_to_ucs();
                if(cc.code == 255) {
                    goto L37;
                } else {
                    cc.ccs = 4096;
                    continue;
                }
            }
L42:
            return;
L44:
        }
        if(_t97 == 16384) {
        } else {
            if(_t97 == 49152) {
                if(( *135119022 & 0xff) != 0) {
                    return;
                }
                goto L27;
            }
            if(_t97 == 8193) {
                if(( *135119010 & 0xff) != 0 && cc.code >> 24 != st->ntag) {
                    st->ntag = wc_push_tag_to_utf8(os, cc.code >> 24);
                }
                wc_ucs_to_utf8(cc.code & 2097151,  &utf8_buf);
                Strcat_charp(os,  &utf8_buf);
                return;
            }
            goto L34;
L27:
            if(st->ntag != 0) {
                st->ntag = wc_push_tag_to_utf8(os, 0);
            }
            Strcat_charp(os, WcReplaceW);
            return;
        }
        goto L30;
L30:
        if(( *135119022 & 0xff) != 0) {
        } else {
            if(st->ntag != 0) {
                st->ntag = wc_push_tag_to_utf8(os, 0);
            }
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L42;
    }
    if(st->ntag != 0) {
        st->ntag = wc_push_tag_to_utf8(os, 0);
    }
    wc_ucs_to_utf8(cc.code,  &utf8_buf);
    Strcat_charp(os,  &utf8_buf);
    return;
}

wc_push_to_utf8_end(Str os, wc_status* st)
{// addr = 0x080C1C44  --  defined in 'utf8.c' at line 286
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(st->ntag != 0) {
        st->ntag = wc_push_tag_to_utf8(os, 0);
        return;
    }
    return;
}

Str wc_char_conv_from_utf8(wc_uchar c, wc_status* st)
{// addr = 0x080C1C6F  --  defined in 'utf8.c' at line 294
    wc_uint32 ucs;   // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t62;                              // _t62
    signed int _t66;                       // _t66
    struct _Str* _t75;    // _t75
    struct _Str* _t81;    // _t81
    _unknown_ _t86;                        // _t86
    struct _Str* _t89;    // _t89
    _unknown_ _t96;                        // _t96
    int _t108;                             // _t108

    _v32 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.2857 = Strnew_size(8);
         *(st + 44) = 0;
        st->ntag = 0;
        nbuf.2859 = 0;
    }
    _t62 = st->state;
    if(_t62 == 0) {
        next.2860 =  *( &WC_UTF8_MAP + (_v32 & 255)) & 0xff;
        _t66 = next.2860;
        if(_t66 == 1) {
            wtf_push_ucs(os.2857, _v32 & 255, st);
L16:
            goto L26;
        }
        goto L6;
    }
    if(_t62 == 1) {
        if(( *( &WC_UTF8_MAP + (_v32 & 255)) & 0xff) != 0) {
            goto L26;
        }
        _t89 = nbuf.2859;
         *(_t89 +  &buf.2858) = _v32 & 0xff;
        nbuf.2859 =  &(_t89->ptr);
        next.2860 = next.2860 - 1;
        if(next.2860 == 0) {
            ucs = wc_utf8_to_ucs( &buf.2858);
            if(ucs != 255 && (ucs <= 55295 || ucs > 57343)) {
                if(ucs != 65279) {
                    wtf_push_ucs(os.2857, ucs, st);
                }
            }
            goto L26;
        }
        return 0;
    } else {
    }
L26:
    st->state = -1;
    return os.2857;
L6:
    if(_t66 < 1 || _t66 == 7) {
    } else {
        if(_t66 != 8) {
            _t81 = nbuf.2859;
             *(_t81 +  &buf.2858) = _v32 & 0xff;
            nbuf.2859 =  &(_t81->ptr);
            next.2860 = next.2860 - 1;
            st->state = 1;
            return 0;
        }
        if(os.2857->length + 1 >= os.2857->area_size) {
            Strgrow(os.2857);
        }
        _t75 = os.2857;
        _t108 = _t75->length;
         *( *os.2857 + _t108) = _v32 & 0xff;
        _t75->length = _t108 + 1;
         *( *os.2857 + os.2857->length) = 0;
    }
}

wc_uint32 wc_tcvn5712_precompose(wc_uchar c1, wc_uchar c2)
{// addr = 0x080C1E74  --  defined in 'viet.c' at line 77
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22

    _v8 = _a4 & 255;
    _v12 = _a8 & 255;
    if(( *( &tcvn5712_precompose_map + (_v8 & 255)) & 0xff) != 1 || ( *( &tcvn5712_precompose_map + (_v12 & 255)) & 0xff) != 2) {
        return 0;
    }
    return _v12 & 255 | (_v8 & 255) << 8;
}

wc_wchar_t wc_tcvn57123_to_tcvn5712(wc_wchar_t cc)
{// addr = 0x080C1EBC  --  defined in 'viet.c' at line 86
    wc_map* map;        // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    struct  __ebx;            // r1
    _unknown_ __ebp;                       // r6
    unsigned int _t35;                     // _t35

    __ebx = _a4;
    map = wc_map_search(cc.code & 0x7f7f,  &tcvn57123_tcvn5712_map, 120);
    if(map == 0) {
        cc.ccs = 16384;
    } else {
        if(( *(map + 2) & 0xffff) > 31) {
            _t35 = 2077;
        } else {
            _t35 = 2078;
        }
        cc.ccs = _t35;
        cc.code =  *(map + 2) & 0xffff;
    }
     *__ebx = cc.ccs;
     *(__ebx + 4) = cc.code;
    return __ebx;
}

wc_uint32 wc_cp1258_precompose(wc_uchar c1, wc_uchar c2)
{// addr = 0x080C1F3B  --  defined in 'viet.c' at line 102
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22

    _v8 = _a4 & 255;
    _v12 = _a8 & 255;
    if(( *( &cp1258_precompose_map + (_v8 & 255)) & 0xff) != 1 || ( *( &cp1258_precompose_map + (_v12 & 255)) & 0xff) != 2) {
        return 0;
    }
    return _v12 & 255 | (_v8 & 255) << 8;
}

Str wc_conv_from_viet(Str is, wc_ces ces)
{// addr = 0x080C1F83  --  defined in 'viet.c' at line 111
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_ccs ccs1;        // _cfa_ffffffe0
    wc_ccs ccs2;        // _cfa_ffffffdc
    wc_uint8* map;    // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    unsigned int _t113;                    // _t113
    int _t133;                             // _t133

    sp = is->ptr;
    ep = sp + is->length;
    ccs1 =  *( *((intOrPtr*)(((ces & 255) << 5) + 135767980)) + 8);
    ccs2 =  *( *((intOrPtr*)(((ces & 255) << 5) + 135767980)) + 16);
    map = 0;
    _t113 = ces;
    if(_t113 == 1066051) {
        map =  &wc_c0_viscii112_map;
    } else {
        if(_t113 == 1066052) {
            map =  &wc_c0_vps2_map;
        } else {
            if(_t113 == 1066050) {
                map =  &wc_c0_tcvn57122_map;
            }
        }
    }
    wc_create_detect_map(ces, 0);
    p = sp;
    while(p < ep && ( *( &WC_DETECT_MAP + ( *p & 0xff)) & 0xff) == 0) {
    }
    if(p != ep) {
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
        while(p < ep) {
            if(( *p & 0xff) >= 0) {
                if(( *p & 0xff) > 31 || ( *(map + ( *p & 0xff)) & 0xff) == 0) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t133 = os->length;
                     *(os->ptr + _t133) =  *p & 0xff;
                    os->length = _t133 + 1;
                     *(os->ptr + os->length) = 0;
                } else {
                    wtf_push(os, ccs2,  *p & 0xff);
                }
            } else {
                wtf_push(os, ccs1,  *p & 0xff);
            }
            p =  &(p[1]);
        }
        return os;
    }
    return is;
}

wc_push_to_viet(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C2164  --  defined in 'viet.c' at line 154
    wc_ccs ccs1;        // _cfa_fffffff0
    wc_ccs ccs2;        // _cfa_ffffffec
    wc_ccs ccs3;        // _cfa_ffffffe8
    wc_uint8* map;    // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t178;                    // _t178
    _unknown_ _t192;                       // _t192
    _unknown_ _t202;                       // _t202
    _unknown_ _t212;                       // _t212
    _unknown_ _t228;                       // _t228
    _unknown_ _t241;                       // _t241
    _unknown_ _t253;                       // _t253
    _unknown_ _t267;                       // _t267
    _unknown_ _t280;                       // _t280

    ccs1 =  *(st->ces_info->gset + 8);
    ccs2 = 0;
    ccs3 = 0;
    map = 0;
    _t178 = st->ces_info->id;
    if(_t178 == 1066050) {
        map =  &wc_c0_tcvn57122_map;
        ccs2 =  *(st->ces_info->gset + 16);
        ccs3 =  *(st->ces_info->gset + 24);
    } else {
        if(_t178 > 1066050) {
            if(_t178 == 1066051) {
                map =  &wc_c0_viscii112_map;
                ccs2 =  *(st->ces_info->gset + 16);
            } else {
                if(_t178 == 1066052) {
                    map =  &wc_c0_vps2_map;
                    ccs2 =  *(st->ces_info->gset + 16);
                }
            }
        } else {
            if(_t178 == 1049665) {
                ccs3 =  *(st->ces_info->gset + 16);
            }
        }
    }
    while(1) {
    }
}

Str wc_char_conv_from_viet(wc_uchar c, wc_status* st)
{// addr = 0x080C250D  --  defined in 'viet.c' at line 219
    Str os;                // _cfa_fffffff0
    wc_uint8* map;    // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    unsigned int _t55;                     // _t55
    int _t63;                              // _t63

    _v32 = _a4 & 255;
    os = Strnew_size(1);
    map = 0;
    _t55 = st->ces_info->id;
    if(_t55 == 1066051) {
        map =  &wc_c0_viscii112_map;
    } else {
        if(_t55 == 1066052) {
            map =  &wc_c0_vps2_map;
        } else {
            if(_t55 == 1066050) {
                map =  &wc_c0_tcvn57122_map;
            }
        }
    }
    if((_v32 & 0xff) >= 0) {
        if(_v32 > 31 || ( *(map + (_v32 & 255)) & 0xff) == 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t63 = os->length;
             *(os->ptr + _t63) = _v32 & 0xff;
            os->length = _t63 + 1;
             *(os->ptr + os->length) = 0;
        } else {
            wtf_push(os,  *(st->ces_info->gset + 16), _v32 & 255);
        }
    } else {
        wtf_push(os,  *(st->ces_info->gset + 8), _v32 & 255);
    }
    return os;
}

wtf_init(wc_ces ces1, wc_ces ces2)
{// addr = 0x080C2624  --  defined in 'wtf.c' at line 80
    int i;                                 // _cfa_fffffff0
    wc_gset* gset;     // _cfa_ffffffec
    _unknown_ __ebp;                       // r6

    if((wc_check_ces(ces2) & 255) != 0) {
        wtf_major_ces = ces2;
    }
    if((wc_check_ces(ces1) & 255) == 0) {
        return;
    }
    gset =  *(((ces1 & 255) << 5) + 135767980);
    if(gset == 0) {
        goto L16;
    }
    if( *(gset + 8) == 0) {
        goto L17;
    }
    if(( *(gset + 8) & 12288) != 0) {
    } else {
        wtf_gr_ccs =  *(gset + 8);
        if((wtf_gr_ccs & 98304) == 0) {
            i = 161;
L13:
            while(i <= 255) {
                goto L12;
            }
            return;
        }
        i = 161;
        while(i <= 255) {
             *((char*)( &WTF_WIDTH_MAP + i)) = 2;
             *((char*)( &WTF_LEN_MAP + i)) = 2;
             *((char*)( &WTF_TYPE_MAP + i)) = 10;
            i = i + 1;
        }
        return;
L12:
         *((char*)( &WTF_WIDTH_MAP + i)) = 1;
         *((char*)( &WTF_LEN_MAP + i)) = 1;
         *((char*)( &WTF_TYPE_MAP + i)) = 2;
        i = i + 1;
        goto L13;
    }
    goto L18;
L19:
    return;
L18:
    goto L19;
L17:
    return;
L16:
    return;
}

int wtf_strwidth(wc_uchar* p)
{// addr = 0x080C272A  --  defined in 'wtf.c' at line 120
    int w;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    signed int _t41;                       // _t41

    w = 0;
    while(( *p & 0xff) != 0) {
        if(( *135119023 & 0xff) == 0) {
            _t41 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
        } else {
            _t41 =  *( &WTF_WIDTH_MAP + ( *p & 0xff)) & 0xff;
        }
        w = w + _t41;
        p = p + ( *( &WTF_LEN_MAP + ( *p & 0xff)) & 0xff);
    }
    return w;
}

size_t wtf_len(wc_uchar* p)
{// addr = 0x080C2799  --  defined in 'wtf.c' at line 140
    wc_uchar* q;      // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    q = p;
    q = q + ( *( &WTF_LEN_MAP + ( *q & 0xff)) & 0xff);
    while(( *q & 0xff) != 0 && ( *( &WTF_WIDTH_MAP + ( *q & 0xff)) & 0xff) == 0) {
        q = q + ( *( &WTF_LEN_MAP + ( *q & 0xff)) & 0xff);
    }
    return q - p;
}

wtf_push(Str os, wc_ccs ccs, wc_uint32 code)
{// addr = 0x080C27FF  --  defined in 'wtf.c' at line 180
    signed int _v16;                       // _cfa_fffffff0
    signed int _v21;                       // _cfa_ffffffeb
    signed int _v22;                       // _cfa_ffffffea
    signed int _v23;                       // _cfa_ffffffe9
    wc_uchar[7] s;    // _cfa_ffffffe8
    wc_bool fix_width_conv;   // _cfa_ffffffe7
    size_t n;           // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    wc_wchar_t cc;   // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    wc_wchar_t cc2;   // _cfa_ffffffd0
    struct _Str* _v64;    // _cfa_ffffffc0
    unsigned int _v72;                     // _cfa_ffffffb8
    unsigned int _v76;                     // _cfa_ffffffb4
    struct * _v80;            // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    unsigned int _v88;                     // _cfa_ffffffa8
    _unknown_ _v92;                        // _cfa_ffffffa4
    _unknown_ __ebp;                       // r6
    _unknown_ _t370;                       // _t370
    signed int _t375;                      // _t375
    signed int _t380;                      // _t380
    signed int _t399;                      // _t399
    _unknown_ _t447;                       // _t447
    signed int _t456;                      // _t456
    _unknown_ _t523;                       // _t523
    int _t555;                             // _t555
    int _t574;                             // _t574
    signed int _t591;                      // _t591
    signed int _t601;                      // _t601
    _unknown_ _t637;                       // _t637

    _v64 = _a4;
    _v16 =  *gs:0x14];
    if(ccs != 322) {
        cc.ccs = ccs;
        _v36 = code;
        if(( *135119012 & 0xff) == 0 || (cc.ccs & 16384) != 0) {
L31:
            _t375 = cc.ccs & 65280;
            if(_t375 == 4096) {
                if((cc.ccs & 98304) == 0) {
                    _t591 = -120;
                } else {
                    _t591 = -119;
                }
                if((cc.ccs & 131072) == 0) {
                    _t380 = 0;
                } else {
                    _t380 = 16;
                }
                s = (_t380 | _t591) & 255;
                 *( &s + 1) = (_v36 >> 14 & 3 | 128) & 255;
                 *( &s + 2) = (_v36 >> 7 | 128) & 255;
                 *( &s + 3) = (_v36 | 128) & 255;
                _v23 = (_v23 & 255 | cc.ccs << 2) & 255;
                n = 4;
L101:
                Strcat_charp_n(_v64,  &s, n);
                goto L102;
            }
        } else {
            if(ccs == 34831 || ccs == 34832 || ccs == 34833 || ccs == 34834) {
                if(wtf_major_ces == 3149849 || wtf_major_ces == 2099221) {
                    _v88 = cc.ccs;
                    _v84 = _v36;
                     *__esp =  &(cc2.ccs);
                    wc_johab_to_ksx1001();
                    __esp = __esp - 4;
                    if((cc2.ccs & 16384) == 0) {
                        cc.ccs = cc2.ccs;
                        _v36 = _v44;
                    }
                    goto L31;
                } else {
                    goto L14;
                }
                goto L32;
            }
L14:
            if(ccs != 33091 || wtf_major_ces != 3153984) {
                if(( *135119011 & 0xff) == 0) {
                    goto L31;
                }
                fix_width_conv =  *135119013 & 0xff;
                 *135119013 = 0;
                wc_output_init(wtf_major_ces,  &wtf_major_st);
                if((wc_ces_has_ccs(ccs & 65535,  &wtf_major_st) & 255) != 0) {
L28:
                     *135119013 = fix_width_conv & 0xff;
                    goto L31;
                }
                _v80 =  &wtf_major_st;
                _v88 = cc.ccs;
                _v84 = _v36;
                 *__esp =  &_v76;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc2.ccs = _v76;
                _v44 = _v72;
                if(cc2.ccs != 322) {
                    if((cc2.ccs & 16384) == 0 && cc2.ccs != 2076 && cc2.ccs != 2079) {
                        cc.ccs = cc2.ccs;
                        _v36 = _v44;
                    }
                    goto L28;
                } else {
                    if(_v64->length + 1 >= _v64->area_size) {
                        Strgrow(_v64);
                    }
                    _t555 = _v64->length;
                     *( *_v64 + _t555) = _v44 & 0x7f;
                    _v64->length = _t555 + 1;
                     *( *_v64 + _v64->length) = 0;
                }
                goto L102;
            } else {
                _v88 = cc.ccs;
                _v84 = _v36;
                 *__esp =  &_v76;
                wc_ksx1001_to_johab();
                __esp = __esp - 4;
                cc2.ccs = _v76;
                _v44 = _v72;
                if((cc2.ccs & 16384) == 0) {
                    cc.ccs = cc2.ccs;
                    _v36 = _v44;
                }
            }
            goto L31;
        }
L32:
        if(_t375 > 4096) {
            if(_t375 == 33024) {
                goto L54;
            }
            goto L41;
        }
        if(_t375 == 512) {
            if(( *135119009 & 0xff) == 0) {
L60:
                if(cc.ccs != wtf_gr_ccs || (_v36 & 127) <= 32) {
                    s = 130;
                } else {
                    s = (_v36 | 128) & 255;
                    n = 1;
                    goto L101;
                }
L64:
                _v23 = (cc.ccs | 128) & 255;
                _v22 = (_v36 | 128) & 255;
                n = 3;
                goto L101;
            }
            goto L58;
        }
        if(_t375 > 512) {
            if(_t375 == 1024) {
                if(cc.ccs != wtf_gr_ccs) {
                    s = 132;
                    _v23 = (cc.ccs | 128) & 255;
                    _v22 = (_v36 | 128) & 255;
                    n = 3;
                } else {
                    s = (_v36 | 128) & 255;
                    n = 1;
                }
                goto L101;
            }
            goto L38;
        }
        if(_t375 == 256) {
            if(cc.ccs != wtf_gr_ccs) {
                if(cc.ccs != 329 || ( *135119017 & 0xff) != 0) {
L53:
                    s = 128;
                    _v23 = (cc.ccs | 128) & 255;
                    _v22 = (_v36 | 128) & 255;
                    n = 3;
                    goto L101;
                } else {
                    _v88 = cc.ccs;
                    _v84 = _v36;
                     *__esp =  &_v76;
                    wc_jisx0201k_to_jisx0208();
                    __esp = __esp - 4;
                    cc2.ccs = _v76;
                    _v44 = _v72;
                    if((cc2.ccs & 16384) != 0) {
                        goto L53;
                    }
                    wtf_push(_v64, cc2.ccs, _v44);
                    goto L102;
                }
L54:
                if(cc.ccs != wtf_gr_ccs) {
                    s = 129;
                    _v23 = (cc.ccs | 128) & 255;
                    _v22 = (_v36 >> 8 | 128) & 255;
                    _v21 = (_v36 | 128) & 255;
                    n = 4;
                } else {
                    s = (_v36 >> 8 | 128) & 255;
                    _v23 = (_v36 | 128) & 255;
                    n = 2;
                }
                goto L101;
            }
            s = (_v36 | 128) & 255;
            n = 1;
            goto L101;
        } else {
        }
L100:
        s = 133;
        _v23 = (cc.ccs | 128) & 255;
        _v22 = (_v36 | 128) & 255;
        n = 3;
        goto L101;
L38:
        if(_t375 == 2048) {
            if(( *135119009 & 0xff) == 0) {
L75:
                if(cc.ccs != wtf_gr_ccs || (_v36 & 127) <= 32) {
                    s = 134;
                } else {
                    s = (_v36 | 128) & 255;
                    n = 1;
                    goto L101;
                }
L79:
                _v23 = (cc.ccs | 128) & 255;
                _v22 = (_v36 | 128) & 255;
                n = 3;
                goto L101;
            }
             *__esp = cc.ccs;
            _v88 = _v36;
            if((wc_is_combining() & 255) == 0) {
                goto L75;
            }
            s = 150;
            goto L79;
        } else {
        }
        goto L100;
L58:
         *__esp = cc.ccs;
        _v88 = _v36;
        if((wc_is_combining() & 255) == 0) {
            goto L60;
        }
        s = 146;
        goto L64;
L41:
        if(_t375 > 33024) {
            if(_t375 == 33280) {
                if(cc.ccs != wtf_gr_ccs || (_v36 >> 8 & 127) <= 32) {
                    s = 131;
                    _v23 = (cc.ccs | 128) & 255;
                    _v22 = (_v36 >> 8 | 128) & 255;
                    _v21 = (_v36 | 128) & 255;
                    n = 4;
                } else {
                    s = (_v36 >> 8 | 128) & 255;
                    _v23 = (_v36 | 128) & 255;
                    n = 2;
                }
                goto L101;
            }
            goto L45;
        }
        if(_t375 == 8192) {
            if((cc.ccs & 98304) == 0) {
                _t601 = -118;
            } else {
                _t601 = -117;
            }
            if((cc.ccs & 131072) == 0) {
                _t456 = 0;
            } else {
                _t456 = 16;
            }
            s = (_t456 | _t601) & 255;
             *( &s + 1) = (_v36 >> 28 | 128) & 255;
             *( &s + 2) = (_v36 >> 21 | 128) & 255;
             *( &s + 3) = (_v36 >> 14 | 128) & 255;
             *( &s + 4) = (_v36 >> 7 | 128) & 255;
             *( &s + 5) = (_v36 | 128) & 255;
            _v23 = (_v23 & 255 | cc.ccs << 4) & 255;
            n = 6;
            goto L101;
        } else {
        }
        goto L100;
L45:
        if(_t375 == 34816) {
            if(cc.ccs - 34817 > 30) {
                if(cc.ccs != wtf_gr_ccs || (_v36 >> 8 & 127) <= 32) {
                    s = 135;
                    _v23 = (cc.ccs | 128) & 255;
                    _v22 = (_v36 >> 8 | 128) & 255;
                    _v21 = (_v36 | 128) & 255;
                    n = 4;
                } else {
                    s = (_v36 >> 8 | 128) & 255;
                    _v23 = (_v36 | 128) & 255;
                    n = 2;
                }
                goto L101;
            }
            goto __eax;
        } else {
        }
        goto L100;
    } else {
        _t637 = _v64->length + 1 - _v64->area_size;
        if(_t637 >= 0) {
            Strgrow(_v64);
        }
        _t574 = _v64->length;
         *( *_v64 + _t574) = code & 0x7f;
        _v64->length = _t574 + 1;
         *( *_v64 + _v64->length) = 0;
    }
L102:
    _t399 = _v16 ^  *gs:0x14];
    if(_t637 == 0) {
        return _t399;
    }
    __stack_chk_fail();
    return _t399;
}

wtf_push_unknown(Str os, wc_uchar* p, size_t len)
{// addr = 0x080C30CF  --  defined in 'wtf.c' at line 370
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    struct _Str* _t37;    // _t37
    int _t46;                              // _t46

    _t37 = __eax;
    while(1) {
        len = len - 1;
        if((_t37 & 255) == 0) {
            break;
        }
        if(( *p & 0xff) >= 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t46 = os->length;
             *(os->ptr + _t46) =  *p & 0xff;
            os->length = _t46 + 1;
            _t37 = os->ptr + os->length;
            _t37->ptr = 0;
        } else {
            _v20 =  *p & 0xff;
            _v24 = 16384;
            _t37 = os;
             *__esp = _t37;
            wtf_push();
        }
        p =  &(p[1]);
    }
    return;
}

wc_wchar_t wtf_parse1(wc_uchar** p)
{// addr = 0x080C316B  --  defined in 'wtf.c' at line 381
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uchar* q;      // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    wc_wchar_t cc;   // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t141;                      // _t141
    _unknown_ _t180;                       // _t180
    struct  _t242;            // _t242
    _unknown_ _t243;                       // _t243

    _push(__ebx);
    __esp = __esp - 36;
    _t242 = _a4;
    q =  *p;
    if(( *q & 0xff) >= 0) {
        if(( *q & 0xff) <= 160) {
            cc.ccs = ( *(( *q & 0xff) + -128 + ( *q & 0xff) + -128 +  &CCS_MAP) & 0xffff) << 8;
            q =  &(q[1]);
            _t141 = cc.ccs & 65280;
            if(_t141 == 8192) {
L28:
                cc.ccs = ( *q & 0x70) >> 4 | cc.ccs;
                _v20 = q[4] & 0x7f | ( *q & 0xff) << 28 | (q[1] & 0x7f) << 21 | (q[2] & 0x7f) << 14 | (q[3] & 0x7f) << 7;
                q =  &(q[5]);
                goto L30;
            }
            goto L7;
L29:
            cc.ccs = 322;
            _v20 = 32;
            goto L30;
        }
        cc.ccs = wtf_gr_ccs;
        if((cc.ccs & 98304) == 0) {
            _v20 =  *q & 0xff;
            q =  &(q[1]);
        } else {
            _v20 = q[1] & 0xff | ( *q & 0xff) << 8;
            q =  &(q[2]);
        }
        goto L30;
L7:
        if(_t141 > 8192) {
            if(_t141 == 33280) {
                goto L26;
            }
            goto L17;
        }
        if(_t141 == 1024) {
L25:
            cc.ccs =  *q & 0x7f | cc.ccs;
            q =  &(q[1]);
            _v20 =  *q & 0xff;
            q =  &(q[1]);
            goto L30;
        }
        if(_t141 > 1024) {
            if(_t141 == 2048) {
                goto L25;
            }
            goto L14;
        }
        if(_t141 == 256 || _t141 == 512) {
            goto L25;
        } else {
            goto L29;
        }
        goto L26;
L14:
        if(_t141 == 4096) {
L27:
            cc.ccs = ( *q & 0x7c) >> 2 | cc.ccs;
            _v20 = q[2] & 0x7f | ( *q & 0xff) << 14 & 0xffff | (q[1] & 0x7f) << 7;
            q =  &(q[3]);
            goto L30;
        }
        goto L29;
L26:
        cc.ccs =  *q & 0x7f | cc.ccs;
        q =  &(q[1]);
        _v20 = q[1] & 0xff | ( *q & 0xff) << 8;
        q =  &(q[2]);
        goto L30;
L17:
        if(_t141 > 33280) {
            if(_t141 == 69632) {
                goto L27;
            }
            goto L22;
        }
        if(_t141 == 16384) {
            goto L25;
        }
        if(_t141 == 33024) {
            goto L26;
        }
        goto L29;
L22:
        if(_t141 == 73728) {
            goto L28;
        }
        if(_t141 == 34816) {
            goto L26;
        }
        goto L29;
    } else {
        cc.ccs = 322;
        _v20 =  *q & 0xff;
        q =  &(q[1]);
    }
L30:
     *p = q;
    if(cc.ccs - 34818 > 31) {
         *_t242 = cc.ccs;
         *(_t242 + 4) = _v20;
        return _t242;
    }
    goto __eax;
}

wc_wchar_t wtf_parse(wc_uchar** p)
{// addr = 0x080C34FA  --  defined in 'wtf.c' at line 463
    _unknown_ _v8;                         // _cfa_fffffff8
    wc_uchar* q;      // _cfa_fffffff0
    wc_uint32 ucs;   // _cfa_ffffffec
    wc_uint32 ucs2;   // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    wc_wchar_t cc;   // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    wc_wchar_t cc2;   // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    wc_uchar** _v72;   // _cfa_ffffffb8
    wc_uchar** _v76;   // _cfa_ffffffb4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ __ebp;                       // r6
    _unknown_ _t144;                       // _t144
    _unknown_ _t147;                       // _t147
    wc_uchar* _t203;   // _t203
    struct  _t206;            // _t206
    _unknown_ _t207;                       // _t207

    _push(__ebx);
    __esp = __esp - 68;
    _t206 = _a4;
    if(( *( *p) & 0xff) >= 0) {
        _v72 = p;
        wtf_parse1( &(cc.ccs));
        __esp = __esp - 4;
    } else {
        cc.ccs = 322;
        _t203 =  *p;
        _v28 =  *_t203 & 0xff;
         *p =  &(_t203[1]);
    }
    if(( *135119009 & 0xff) == 0 || ( *( &WTF_WIDTH_MAP + ( *( *p) & 0xff)) & 0xff) != 0) {
         *_t206 = cc.ccs;
         *(_t206 + 4) = _v28;
L48:
        return _t206;
    } else {
        q =  *p;
        _v76 =  &q;
        wtf_parse1( &(cc2.ccs));
        __esp = __esp - 4;
        if(cc.ccs == 322 || cc.ccs == 2075) {
            if((cc2.ccs & 65535) != 2075) {
                goto L11;
            }
        } else {
L11:
            if(cc.ccs == 322 || cc.ccs == 2077) {
                if((cc2.ccs & 65535) != 2077) {
                    goto L16;
                }
            } else {
L16:
                if(cc.ccs == 322 || cc.ccs == 577 || (cc.ccs & 65535) == 4096 || (cc.ccs & 65535) == 8192 || (cc.ccs & 65535) == 8193) {
                    if((cc2.ccs & 65535) == 4096 || (cc2.ccs & 65535) == 8192 || (cc2.ccs & 65535) == 8193) {
                        while() {
                        }
                    }
                }
L47:
                 *_t206 = cc.ccs;
                 *(_t206 + 4) = _v28;
                goto L48;
            }
            _v36 = wc_tcvn5712_precompose(_v28 & 0xff, _v36 & 0xff);
            if(_v36 == 0) {
                goto L47;
            } else {
                cc2.ccs = 2079;
                 *p = q;
                 *_t206 = cc2.ccs;
                 *(_t206 + 4) = _v36;
            }
            goto L48;
        }
        _v36 = wc_cp1258_precompose(_v28 & 0xff, _v36 & 0xff);
        if(_v36 == 0) {
            goto L47;
        } else {
            cc2.ccs = 2076;
             *p = q;
             *_t206 = cc2.ccs;
             *(_t206 + 4) = _v36;
        }
        goto L48;
    }
}

wc_ccs wtf_get_ccs(wc_uchar* p)
{// addr = 0x080C3807  --  defined in 'wtf.c' at line 526
    intOrPtr _v20;                         // _cfa_ffffffec
    wc_uchar** _v40;   // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v40 =  &p;
    wtf_parse1( &_v20);
    __esp = __esp - 4;
    return _v20;
}

wc_uint32 wtf_get_code(wc_uchar* p)
{// addr = 0x080C3827  --  defined in 'wtf.c' at line 532
    unsigned int _v16;                     // _cfa_fffffff0
    wc_uchar* _v20;   // _cfa_ffffffec
    wc_uchar** _v40;   // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v40 =  &p;
    wtf_parse1( &_v20);
    __esp = __esp - 4;
    return _v16;
}

wc_bool wtf_is_hangul(wc_uchar* p)
{// addr = 0x080C3847  --  defined in 'wtf.c' at line 538
    wc_uchar f;       // _cfa_fffffff3
    wc_uchar f;       // _cfa_fffffff2
    wc_uchar f;       // _cfa_fffffff1
    _unknown_ __ebp;                       // r6
    _unknown_ _t83;                        // _t83
    unsigned char _t144;                   // _t144
    unsigned char _t151;                   // _t151

    if(( *p & 0xff) <= 160) {
L6:
        if(( *p & 0xff) == 129) {
            return p[1] & 0x7f;
        }
        if(( *p & 0xff) != 135) {
            if(( *p & 0xff) != 137) {
                if(( *p & 0xff) != 139) {
L23:
                    return 0;
                }
                goto L21;
                return __eax;
            }
            goto L18;
L21:
            p =  &(p[1]);
            f = ( *p & 0x7f) >> 4 & 255;
            if(f != 1) {
                goto L23;
            }
            return wc_is_ucs_hangul((p[4] & 0x7f | ( *p & 0xff) << 28 | (p[1] & 0x7f) << 21 | (p[2] & 0x7f) << 14 | (p[3] & 0x7f) << 7) & 2097151);
        } else {
            f = p[1] & 0x7f;
            if(f == 16 || f == 17 || f == 18 || f == 29 || f == 30) {
                _t144 = 1;
            } else {
                _t144 = 0;
            }
            return _t144;
        }
L18:
        p =  &(p[1]);
        f = ( *p & 0x7f) >> 2 & 255;
        if(f != 0) {
            goto L23;
        }
        return wc_is_ucs_hangul(p[2] & 0x7f | ( *p & 0xff) << 14 & 0xffff | (p[1] & 0x7f) << 7);
    }
    if(wtf_gr_ccs == 33091) {
L3:
        _t151 = 1;
L5:
        return _t151;
    }
    if(wtf_gr_ccs != 34832) {
        _t151 = 0;
        goto L5;
    }
    goto L3;
}

char* wtf_conv_fit(char* s, wc_ces ces)
{// addr = 0x080C39F2  --  defined in 'wtf.c' at line 564
    wc_bool pre_conv;   // _cfa_fffffff3
    wc_bool ucs_conv;   // _cfa_fffffff2
    wc_uchar* p;      // _cfa_ffffffec
    Str os;                // _cfa_ffffffe8
    wc_ces major_ces;   // _cfa_ffffffe4
    unsigned int _v32;                     // _cfa_ffffffe0
    wc_wchar_t cc;   // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    wc_uchar** _v56;   // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6

    if(ces == 3211264 || ces == 256) {
        return s;
    }
    p = s;
    while(( *p & 0xff) != 0 && ( *p & 0xff) >= 0) {
        p =  &(p[1]);
    }
    if(( *p & 0xff) != 0) {
        os = Strnew_size(strlen(s));
        if(p > s) {
            Strcopy_charp_n(os, s, p - s);
        }
        major_ces = wtf_major_ces;
        pre_conv =  *135119012 & 0xff;
        ucs_conv =  *135119011 & 0xff;
        wtf_major_ces = ces;
         *135119012 = 1;
         *135119011 = 1;
        while(( *p & 0xff) != 0) {
            _v56 =  &p;
            __eax = wtf_parse1( &(cc.ccs));
            __esp = __esp - 4;
            wtf_push(os, cc.ccs, _v32);
        }
        wtf_major_ces = major_ces;
         *135119012 = pre_conv & 0xff;
         *135119011 = ucs_conv & 0xff;
        return os->ptr;
    }
    return s;
}

wc_wchar_t wc_big5_to_cs94w(wc_wchar_t cc)
{// addr = 0x080C3B1C  --  defined in 'big5.c' at line 37
    unsigned int _v16;                     // _cfa_fffffff0
    struct  __ebx;            // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35
    _unknown_ _t43;                        // _t43
    _unknown_ _t48;                        // _t48
    _unknown_ _t62;                        // _t62
    _unknown_ _t63;                        // _t63
    _unknown_ _t65;                        // _t65

    __ebx = _a4;
    _t62 = (cc.code >> 8 & 255) * (cc.code >> 8 & 255) + (cc.code & 255);
    if((cc.code & 255) > 160) {
        _t35 = 98;
    } else {
        _t35 = 64;
    }
    cc.code = _t62 - _t35 - 25277;
    if(cc.code > 6279) {
        cc.ccs = 34819;
        cc.code = cc.code - 6280;
    } else {
        cc.ccs = 34818;
    }
    _v16 = cc.code;
    cc.code = ((_v16 * -1370734243 >> 32 >> 6) + 33 << 8) + cc.code - (cc.code * -1370734243 >> 32 >> 6) * (cc.code * -1370734243 >> 32 >> 6) + 33;
     *__ebx = cc.ccs;
     *(__ebx + 4) = cc.code;
    return __ebx;
}

wc_wchar_t wc_cs94w_to_big5(wc_wchar_t cc)
{// addr = 0x080C3BE8  --  defined in 'big5.c' at line 51
    unsigned int _v20;                     // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t41;                        // _t41
    _unknown_ _t49;                        // _t49
    _unknown_ _t54;                        // _t54
    _unknown_ _t66;                        // _t66
    _unknown_ _t69;                        // _t69
    _unknown_ _t71;                        // _t71
    _unknown_ _t73;                        // _t73
    signed int _t79;                       // _t79

    __esi = _a4;
    cc.code = (cc.code >> 8 & 127) * (cc.code >> 8 & 127) + (cc.code & 127) - 3135;
    if(cc.ccs == 34819) {
        cc.code = cc.code + 6280;
    }
    _v20 = cc.code;
    _t79 = (_v20 * 875407347 >> 32 >> 5) + 161 << 8;
    _t66 = cc.code - cc.code * 875407347 * (_t61 * 875407347 >> 32 >> 5);
    if(cc.code - (cc.code * 875407347 >> 32 >> 5) * (cc.code * 875407347 >> 32 >> 5) > 62) {
        _t54 = 98;
    } else {
        _t54 = 64;
    }
    cc.code = _t79 + _t66 + _t54;
    cc.ccs = 34817;
     *__esi = cc.ccs;
     *(__esi + 4) = cc.code;
    return __esi;
}

Str wc_conv_from_big5(Str is, wc_ces ces)
{// addr = 0x080C3CB4  --  defined in 'big5.c' at line 62
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t105;                             // _t105
    signed int _t110;                      // _t110
    int _t119;                             // _t119

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while(p < ep && ( *p & 0xff) >= 0) {
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t105 = state;
        if(_t105 == 0) {
            _t110 =  *( &WC_BIG5_MAP + ( *p & 0xff)) & 0xff;
            if(_t110 == 2) {
                wtf_push_unknown(os, p, 1);
L18:
                goto L23;
            }
            goto L12;
L15:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t119 = os->length;
             *(os->ptr + _t119) =  *p & 0xff;
            os->length = _t119 + 1;
             *(os->ptr + os->length) = 0;
            goto L23;
        }
        if(_t105 == 1) {
            if(( *( &WC_BIG5_MAP + ( *p & 0xff)) & 4) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                wtf_push(os, 34817,  *p & 0xff | ( *(p - 1) & 0xff) << 8);
            }
            state = 0;
        }
L23:
        p =  &(p[1]);
        continue;
L12:
        if(_t110 != 7) {
            goto L15;
        }
        state = 1;
        goto L18;
    }
    if(state == 1) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

wc_push_to_big5(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C3E9C  --  defined in 'big5.c' at line 111
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t87;                     // _t87
    int _t94;                              // _t94
    int _t106;                             // _t106
    unsigned int _t121;                    // _t121
    int _t131;                             // _t131

    while(1) {
        _t87 = cc.ccs;
        if(_t87 == 34817) {
            break;
        }
        if(_t87 > 34817) {
            if(_t87 <= 34819) {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &(cc.ccs);
                wc_cs94w_to_big5();
                __esp = __esp - 4;
                break;
            }
            goto L7;
        }
        if(_t87 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t131 = os->length;
             *(os->ptr + _t131) = cc.code & 255;
            os->length = _t131 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t87 != 16384) {
            goto L5;
        }
        if(( *135119022 & 0xff) == 0) {
            Strcat_charp(os, WcReplace);
            return;
        }
        return;
L5:
L22:
        if(( *135119011 & 0xff) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t121 = 16384;
            } else {
                _t121 = 49152;
            }
            cc.ccs = _t121;
        } else {
            _v32 = st;
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &_v20;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v20;
            cc.code = _v16;
        }
        continue;
L7:
        if(_t87 == 49152) {
            if(( *135119022 & 0xff) != 0) {
                return;
            }
            goto L19;
        }
        goto L22;
L19:
        Strcat_charp(os, WcReplaceW);
        return;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t94 = os->length;
     *(os->ptr + _t94) = cc.code >> 8 & 255;
    os->length = _t94 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t106 = os->length;
     *(os->ptr + _t106) = cc.code & 255;
    os->length = _t106 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_big5(wc_uchar c, wc_status* st)
{// addr = 0x080C40A0  --  defined in 'big5.c' at line 146
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t45;                              // _t45
    signed int _t48;                       // _t48
    struct _Str* _t56;    // _t56
    _unknown_ _t64;                        // _t64
    int _t80;                              // _t80

    _v16 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.2633 = Strnew_size(8);
    }
    _t45 = st->state;
    if(_t45 == 0) {
        _t48 =  *( &WC_BIG5_MAP + (_v16 & 255)) & 0xff;
        if(_t48 == 2) {
            goto L14;
        }
        goto L6;
L9:
        if(os.2633->length + 1 >= os.2633->area_size) {
            Strgrow(os.2633);
        }
        _t56 = os.2633;
        _t80 = _t56->length;
         *( *os.2633 + _t80) = _v16 & 0xff;
        _t56->length = _t80 + 1;
         *( *os.2633 + os.2633->length) = 0;
        goto L14;
    }
    if(_t45 == 1) {
        if(( *( &WC_BIG5_MAP + (_v16 & 255)) & 4) != 0) {
            wtf_push(os.2633, 34817, (big5u & 0xff) << 8 | _v16 & 255);
        }
    }
L14:
    st->state = -1;
    return os.2633;
L6:
    if(_t48 != 7) {
        goto L9;
    }
    big5u = _v16 & 0xff;
    st->state = 1;
    return 0;
}

wc_bool wc_is_combining(wc_wchar_t cc)
{// addr = 0x080C41D8  --  defined in 'combining.c' at line 16
    _unknown_ __ebp;                       // r6
    signed int _t20;                       // _t20
    _unknown_ _t27;                        // _t27

    _t20 = cc.ccs & 65535;
    if(_t20 == 2073) {
L22:
        return  *( &cp1256_combining_map + (cc.code & 127)) & 255;
    }
    if(_t20 > 2073) {
        if(_t20 == 4096) {
L25:
            return wc_is_ucs_combining(cc.code);
        }
        goto L11;
    }
    if(_t20 == 2061) {
L19:
        return  *( &cp864_combining_map + (cc.code & 127)) & 255;
    }
    if(_t20 > 2061) {
        if(_t20 == 2065) {
            goto L20;
        }
        goto L8;
L21:
        return  *( &cp1255_combining_map + (cc.code & 127)) & 255;
    }
    if(_t20 == 583) {
        return  *( &iso88596_combining_map + (cc.code & 127)) & 255;
    }
    if(_t20 == 596) {
        goto L18;
    }
L26:
    return 0;
    goto L19;
L18:
    return  *( &iso885911_combining_map + (cc.code & 127)) & 255;
L8:
    if(_t20 == 2072) {
        goto L21;
    }
    goto L26;
L20:
    return  *( &cp874_combining_map + (cc.code & 127)) & 255;
L11:
    if(_t20 > 4096) {
        if(_t20 - 8192 > 1) {
            goto L26;
        }
        goto L16;
        return __eax;
    }
    if(_t20 == 2075) {
        goto L23;
    }
    if(_t20 == 2077) {
        goto L24;
    }
    goto L26;
L24:
    return  *( &tcvn5712_combining_map + (cc.code & 127)) & 255;
L16:
    goto L25;
L23:
    return  *( &cp1258_combining_map + (cc.code & 127)) & 255;
}

wc_wchar_t wc_gbk_ext_to_cs128w(wc_wchar_t cc)
{// addr = 0x080C42F4  --  defined in 'gb18030.c' at line 39
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    _unknown_ _t42;                        // _t42

    __ecx = _a4;
    _t42 = (cc.code >> 8 & 255) * (cc.code >> 8 & 255) + (cc.code & 255);
    if((cc.code & 255) > 127) {
        _t25 = 65;
    } else {
        _t25 = 64;
    }
    cc.code = _t42 - _t25 - 24510;
    if(cc.code > 16383) {
        cc.ccs = 34843;
        cc.code = cc.code - 16384;
    } else {
        cc.ccs = 34842;
    }
    cc.code = (cc.code >> 7 << 8) + (cc.code & 127);
     *__ecx = cc.ccs;
     *(__ecx + 4) = cc.code;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_gbk_ext(wc_wchar_t cc)
{// addr = 0x080C438D  --  defined in 'gb18030.c' at line 53
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t46;                        // _t46
    _unknown_ _t54;                        // _t54
    _unknown_ _t59;                        // _t59
    unsigned int _t66;                     // _t66
    unsigned int _t67;                     // _t67
    _unknown_ _t71;                        // _t71
    _unknown_ _t76;                        // _t76
    _unknown_ _t80;                        // _t80
    _unknown_ _t84;                        // _t84
    signed int _t90;                       // _t90

    __esi = _a4;
    cc.code = ((cc.code >> 8 & 127) << 7) + (cc.code & 127);
    if(cc.ccs == 34843) {
        cc.code = cc.code + 16384;
    }
    cc.ccs = 34841;
    _v20 = cc.code >> 1;
    _t90 = (_v20 * -1401515643 >> 32 >> 6) + 129 << 8;
    _t66 = cc.code;
    _v20 = _t66 >> 1;
    _t71 = _t66 - _v20 * -1401515643 * (_v20 * -1401515643 >> 32 >> 6);
    _t67 = cc.code;
    _v20 = _t67 >> 1;
    if(_t67 - (_v20 * -1401515643 >> 32 >> 6) * (_v20 * -1401515643 >> 32 >> 6) > 62) {
        _t59 = 65;
    } else {
        _t59 = 64;
    }
    cc.code = _t90 + _t71 + _t59;
     *__esi = cc.ccs;
     *(__esi + 4) = cc.code;
    return __esi;
}

wc_ccs wc_gbk_or_gbk_ext(wc_uint16 code)
{// addr = 0x080C446B  --  defined in 'gb18030.c' at line 64
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    _v16 = _a4 & 65535;
    if(wc_map3_range_search(_v16 & 65535,  &gbk_ext_ucs_map, 110) == 0) {
        return 34838;
    }
    return 34841;
}

wc_uint32 wc_gb18030_to_ucs(wc_wchar_t cc)
{// addr = 0x080C44A6  --  defined in 'gb18030.c' at line 72
    char _v12;                             // _cfa_fffffff4
    wc_map3* map;      // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int min;                               // _cfa_ffffffe8
    int max;                               // _cfa_ffffffe4
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t100;                      // _t100
    unsigned int _t104;                    // _t104
    _unknown_ _t113;                       // _t113
    _unknown_ _t119;                       // _t119
    _unknown_ _t206;                       // _t206
    _unknown_ _t207;                       // _t207
    signed int _t212;                      // _t212

    __esp = __esp - 32;
    _t100 = cc.ccs & 65535;
    if(_t100 == 34841) {
L6:
        map = wc_map3_range_search(cc.code & 0xffff,  &gbk_ext_ucs_map, 110);
        if(map == 0) {
            _t104 = -1;
        } else {
            _t212 =  *(map + 4) & 0xffff;
            _t206 = (cc.code >> 8 & 255) * (cc.code >> 8 & 255) + (cc.code & 255);
            if((cc.code & 255) > 127) {
                _t113 = 65;
            } else {
                _t113 = 64;
            }
            _t207 = _t212 + _t206 - _t113;
            if(( *(map + 2) & 0xff) > 127) {
                _t119 = 65;
            } else {
                _t119 = 64;
            }
            _t104 = _t207 + _t119 + ( *(map + 2) & 0xffff) * ( *(map + 2) & 0xffff) + 24510 - ( *(map + 2) & 0xff) - 24510;
        }
        goto L33;
    }
    if(_t100 > 34841) {
        if(_t100 > 34843) {
            goto L17;
        } else {
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &(cc.ccs);
            wc_cs128w_to_gbk_ext();
            __esp = __esp - 4;
        }
        goto L6;
    }
    if(_t100 == 8194) {
        if(cc.code > -2127527633) {
            if(cc.code > -2077121479) {
L29:
                if(cc.code <= -1875869393 || cc.code > -483222987) {
                    _t104 = -1;
                } else {
                    _t104 = (((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) << 2) + ((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) + (((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) << 2) + ((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) + (cc.code & 255) - 1810682;
                }
L33:
                 &_v12 =  &_v12;
                return _t104;
            }
            min = 0;
            max = 205;
            cc.code = (((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) << 2) + ((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) + (((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) << 2) + ((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) + (cc.code & 255) - 1687218;
            if(cc.code < ( *(max + max + max + max + max + max + 135772644) & 0xffff)) {
                while(1) {
L21:
                    i = (min + max >> 31) + min + max >> 1;
                    if(min == max) {
                        break;
                    }
                    goto L22;
                }
                goto L28;
            }
            i = max;
L28:
            _t104 = ( *(i + i + i + i + i + i +  &ucs_gb18030_map) & 0xffff) + cc.code - ( *(i + i + i + i + i + i + 135772644) & 0xffff);
            goto L33;
L22:
            if(cc.code >= ( *(i + i + i + i + i + i + 135772644) & 0xffff)) {
                if(cc.code < ( *(i + 1 + i + 1 + i + 1 + i + 1 + i + 1 + i + 1 + 135772644) & 0xffff)) {
                    goto L28;
                }
                goto L25;
            }
            max = i - 1;
            goto L21;
L25:
            min = i + 1;
            goto L21;
        }
        goto L29;
    } else {
    }
L17:
     *__esp = cc.ccs;
    _v40 = cc.code;
    _t104 = wc_any_to_ucs();
    goto L33;
}

wc_wchar_t wc_ucs_to_gb18030(wc_uint32 ucs)
{// addr = 0x080C47AD  --  defined in 'gb18030.c' at line 119
    wc_map3* map;      // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    wc_wchar_t cc;   // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    struct  __ebx;            // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t187;                       // _t187
    _unknown_ _t193;                       // _t193
    _unknown_ _t195;                       // _t195
    _unknown_ _t203;                       // _t203
    _unknown_ _t205;                       // _t205
    _unknown_ _t214;                       // _t214
    _unknown_ _t241;                       // _t241
    _unknown_ _t247;                       // _t247
    _unknown_ _t249;                       // _t249
    _unknown_ _t257;                       // _t257
    _unknown_ _t259;                       // _t259
    _unknown_ _t268;                       // _t268
    _unknown_ _t292;                       // _t292
    _unknown_ _t300;                       // _t300
    _unknown_ _t308;                       // _t308
    _unknown_ _t313;                       // _t313
    unsigned int _t320;                    // _t320
    unsigned int _t327;                    // _t327
    _unknown_ _t336;                       // _t336
    _unknown_ _t340;                       // _t340
    _unknown_ _t344;                       // _t344
    _unknown_ _t346;                       // _t346
    _unknown_ _t352;                       // _t352
    _unknown_ _t356;                       // _t356
    _unknown_ _t361;                       // _t361
    _unknown_ _t371;                       // _t371
    _unknown_ _t375;                       // _t375
    _unknown_ _t377;                       // _t377
    _unknown_ _t383;                       // _t383
    _unknown_ _t387;                       // _t387
    _unknown_ _t392;                       // _t392
    _unknown_ _t399;                       // _t399
    _unknown_ _t404;                       // _t404
    _unknown_ _t408;                       // _t408
    _unknown_ _t412;                       // _t412
    signed int _t418;                      // _t418
    unsigned int _t427;                    // _t427
    unsigned int _t428;                    // _t428

    __ebx = _a4;
    if(ucs > 65535) {
        if(ucs > 1114111) {
            goto L19;
        } else {
            _v36 = ucs + 123464;
            _v48 = _v36 >> 3;
            _v48 = _v36 >> 2;
            _t318 = _v48 * 1745256553 >> 32 >> 7;
            _v48 = _v36;
            _t320 = _v48 * -858993459 >> 32 >> 3;
            _v48 = _t320 >> 1;
            _v36 = ((_v48 * 349051311 >> 32 >> 7) + 129 << 24) + ((_v48 * 1745256553 >> 32 >> 7) - (_t318 * -858993459 >> 32 >> 3 << 2) + (_t318 * -858993459 >> 32 >> 3) + (_t318 * -858993459 >> 32 >> 3 << 2) + (_t318 * -858993459 >> 32 >> 3) + 48 << 16) + (_t320 - ((_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) << 6) - (_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) + 129 << 8) + _v36 - (_v36 * -858993459 >> 32 >> 3 << 2) + (_v36 * -858993459 >> 32 >> 3) + (_v36 * -858993459 >> 32 >> 3 << 2) + (_v36 * -858993459 >> 32 >> 3) + 48;
            if(( *135119021 & 0xff) == 0) {
                cc.ccs = 73730;
            } else {
                cc.ccs = wc_ucs_to_ccs(ucs) | 8194;
            }
             *__ebx = cc.ccs;
             *(__ebx + 4) = _v36;
        }
    } else {
        map = wc_map3_range_search(ucs & 0xffff,  &ucs_gbk_ext_map, 110);
        if(map == 0) {
            map = wc_map3_range_search(ucs & 0xffff,  &ucs_gb18030_map, 206);
            if(map == 0) {
L19:
                cc.ccs = 16384;
                 *__ebx = cc.ccs;
                 *(__ebx + 4) = _v36;
            } else {
                _v36 = ( *(map + 4) & 0xffff) + ucs - (map->code & 0xffff);
                _v48 = _v36 >> 3;
                _v48 = _v36 >> 2;
                _t325 = _v48 * 1745256553 >> 32 >> 7;
                _v48 = _v36;
                _t327 = _v48 * -858993459 >> 32 >> 3;
                _v48 = _t327 >> 1;
                _v36 = ((_v48 * 349051311 >> 32 >> 7) + 129 << 24) + ((_v48 * 1745256553 >> 32 >> 7) - (_t325 * -858993459 >> 32 >> 3 << 2) + (_t325 * -858993459 >> 32 >> 3) + (_t325 * -858993459 >> 32 >> 3 << 2) + (_t325 * -858993459 >> 32 >> 3) + 48 << 16) + (_t327 - ((_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) << 6) - (_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) + 129 << 8) + _v36 - (_v36 * -858993459 >> 32 >> 3 << 2) + (_v36 * -858993459 >> 32 >> 3) + (_v36 * -858993459 >> 32 >> 3 << 2) + (_v36 * -858993459 >> 32 >> 3) + 48;
                if(( *135119021 & 0xff) == 0) {
                    cc.ccs = 73730;
                } else {
                    cc.ccs = wc_ucs_to_ccs(ucs) | 8194;
                }
                 *__ebx = cc.ccs;
                 *(__ebx + 4) = _v36;
            }
        } else {
            _t399 = ( *(map + 4) & 0xffff) * ( *(map + 4) & 0xffff) + -24510 + ( *(map + 4) & 0xff);
            if(( *(map + 4) & 0xff) > 127) {
                _t292 = 65;
            } else {
                _t292 = 64;
            }
            _v36 = _t399 - _t292 + ucs - (map->code & 0xffff);
            _v48 = _v36 >> 1;
            _t418 = (_v48 * -1401515643 >> 32 >> 6) + 129 << 8;
            _t427 = _v36;
            _v48 = _t427 >> 1;
            _t336 = _t427 - _v48 * -1401515643 * (_v48 * -1401515643 >> 32 >> 6);
            _t428 = _v36;
            _v48 = _t428 >> 1;
            if(_t428 - (_v48 * -1401515643 >> 32 >> 6) * (_v48 * -1401515643 >> 32 >> 6) > 62) {
                _t313 = 65;
            } else {
                _t313 = 64;
            }
            _v36 = _t418 + _t336 + _t313;
            cc.ccs = 34841;
             *__ebx = cc.ccs;
             *(__ebx + 4) = _v36;
        }
    }
    return __ebx;
}

Str wc_conv_from_gb18030(Str is, wc_ces ces)
{// addr = 0x080C4B76  --  defined in 'gb18030.c' at line 159
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 gbk;   // _cfa_ffffffdc
    wc_uint32 ucs;   // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    wc_wchar_t cc;   // _cfa_ffffffd0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t198;                       // _t198
    _unknown_ _t281;                       // _t281
    _unknown_ _t290;                       // _t290
    _unknown_ _t297;                       // _t297

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while() {
    }
}

wc_push_to_gb18030(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C4FA9  --  defined in 'gb18030.c' at line 254
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t249;                      // _t249
    _unknown_ _t256;                       // _t256
    _unknown_ _t268;                       // _t268
    _unknown_ _t280;                       // _t280
    _unknown_ _t295;                       // _t295
    _unknown_ _t307;                       // _t307
    _unknown_ _t324;                       // _t324
    _unknown_ _t336;                       // _t336
    _unknown_ _t350;                       // _t350
    _unknown_ _t363;                       // _t363
    _unknown_ _t375;                       // _t375
    _unknown_ _t387;                       // _t387
    _unknown_ _t399;                       // _t399

    while(1) {
        _t249 = cc.ccs & 65535;
        if(_t249 > 34840) {
            goto L11;
        } else {
            goto L2;
        }
    }
}

Str wc_char_conv_from_gb18030(wc_uchar c, wc_status* st)
{// addr = 0x080C549B  --  defined in 'gb18030.c' at line 306
    wc_uint32 gbk;   // _cfa_fffffff0
    wc_uint32 ucs;   // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    wc_wchar_t cc;   // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t110;                             // _t110
    _unknown_ _t121;                       // _t121
    _unknown_ _t139;                       // _t139
    signed int _t161;                      // _t161
    struct _Str* _t167;   // _t167
    _unknown_ _t175;                       // _t175
    int _t199;                             // _t199

    _v32 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.3152 = Strnew_size(8);
    }
    _t110 = st->state;
    if(_t110 == 1) {
        if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 4) == 0) {
            if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 0xff) != 16) {
                goto L32;
            }
            goto L24;
        }
        goto L17;
L24:
         *135791817 = _v32 & 0xff;
        st->state = 2;
        return 0;
    }
    if(_t110 > 1) {
        if(_t110 == 2) {
            if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 0xff) != 12) {
                goto L34;
            }
            goto L26;
        }
        goto L7;
L26:
         *135791818 = _v32 & 0xff;
        st->state = 3;
        return 0;
    }
    if(_t110 == 0) {
        _t161 =  *( &WC_GB18030_MAP + (_v32 & 255)) & 0xff;
        if(_t161 == 2) {
            goto L34;
        }
        if(_t161 != 12) {
            goto L13;
        }
        gb = _v32 & 0xff;
        st->state = 1;
        return 0;
L13:
        if(os.3152->length + 1 >= os.3152->area_size) {
            Strgrow(os.3152);
        }
        _t167 = os.3152;
        _t199 = _t167->length;
         *( *os.3152 + _t199) = _v32 & 0xff;
        _t167->length = _t199 + 1;
         *( *os.3152 + os.3152->length) = 0;
    } else {
    }
L34:
    st->state = -1;
    return os.3152;
L7:
    if(_t110 == 3) {
        if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 0xff) != 16) {
            goto L34;
        }
        goto L28;
        return __eax;
    }
    goto L34;
L28:
    cc.ccs = 73730;
    _v24 = _v32 & 255 | (gb & 0xff) << 24 | ( *135791817 & 0xff) << 16 | ( *135791818 & 0xff) << 8;
    if(( *135119021 & 0xff) == 0) {
L31:
        wtf_push(os.3152, cc.ccs, _v24);
        goto L34;
    }
     *__esp = cc.ccs;
    _v56 = _v24;
    ucs = wc_gb18030_to_ucs();
    if(ucs == 255) {
        goto L31;
    }
    wtf_push(os.3152, wc_ucs_to_ccs(ucs) | 8194, _v24);
    goto L34;
L32:
    goto L34;
L17:
    gbk = _v32 & 255 | (gb & 0xff) << 8;
    if(wc_gbk_or_gbk_ext(gbk & 0xffff) != 34841) {
        if((gb & 0xff) <= 160 || _v32 <= 160) {
            wtf_push(os.3152, 34838, gbk);
        } else {
            wtf_push(os.3152, wc_gb2312_or_gbk(gbk & 0xffff), gbk);
        }
    } else {
        wtf_push(os.3152, 34841, gbk);
    }
    goto L34;
}

wc_ccs wc_gb2312_or_gbk(wc_uint16 code)
{// addr = 0x080C57A0  --  defined in 'gbk.c' at line 40
    signed short _v16;                     // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    _v16 = _a4 & 65535;
    if(wc_map_range_search(_v16 & 65535,  &gb2312_gbk_map, 7) == 0) {
        return 33089;
    }
    return 34838;
}

wc_wchar_t wc_gbk_to_cs128w(wc_wchar_t cc)
{// addr = 0x080C57DB  --  defined in 'gbk.c' at line 47
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    _unknown_ _t42;                        // _t42

    __ecx = _a4;
    _t42 = (cc.code >> 8 & 255) * (cc.code >> 8 & 255) + (cc.code & 255);
    if((cc.code & 255) > 127) {
        _t25 = 65;
    } else {
        _t25 = 64;
    }
    cc.code = _t42 - _t25 - 24510;
    if(cc.code > 16383) {
        cc.ccs = 34840;
        cc.code = cc.code - 16384;
    } else {
        cc.ccs = 34839;
    }
    cc.code = (cc.code >> 7 << 8) + (cc.code & 127);
     *__ecx = cc.ccs;
     *(__ecx + 4) = cc.code;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_gbk(wc_wchar_t cc)
{// addr = 0x080C5874  --  defined in 'gbk.c' at line 61
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t46;                        // _t46
    _unknown_ _t54;                        // _t54
    _unknown_ _t59;                        // _t59
    unsigned int _t66;                     // _t66
    unsigned int _t67;                     // _t67
    _unknown_ _t71;                        // _t71
    _unknown_ _t76;                        // _t76
    _unknown_ _t80;                        // _t80
    _unknown_ _t84;                        // _t84
    signed int _t90;                       // _t90

    __esi = _a4;
    cc.code = ((cc.code >> 8 & 127) << 7) + (cc.code & 127);
    if(cc.ccs == 34840) {
        cc.code = cc.code + 16384;
    }
    cc.ccs = 34838;
    _v20 = cc.code >> 1;
    _t90 = (_v20 * -1401515643 >> 32 >> 6) + 129 << 8;
    _t66 = cc.code;
    _v20 = _t66 >> 1;
    _t71 = _t66 - _v20 * -1401515643 * (_v20 * -1401515643 >> 32 >> 6);
    _t67 = cc.code;
    _v20 = _t67 >> 1;
    if(_t67 - (_v20 * -1401515643 >> 32 >> 6) * (_v20 * -1401515643 >> 32 >> 6) > 62) {
        _t59 = 65;
    } else {
        _t59 = 64;
    }
    cc.code = _t90 + _t71 + _t59;
     *__esi = cc.ccs;
     *(__esi + 4) = cc.code;
    return __esi;
}

wc_uint32 wc_gbk_to_N(wc_uint32 c)
{// addr = 0x080C5952  --  defined in 'gbk.c' at line 72
    _unknown_ __ebp;                       // r6
    _unknown_ _t47;                        // _t47
    _unknown_ _t59;                        // _t59
    _unknown_ _t71;                        // _t71
    _unknown_ _t83;                        // _t83
    _unknown_ _t95;                        // _t95
    _unknown_ _t107;                       // _t107
    _unknown_ _t119;                       // _t119
    _unknown_ _t138;                       // _t138
    _unknown_ _t142;                       // _t142
    _unknown_ _t146;                       // _t146
    _unknown_ _t150;                       // _t150
    _unknown_ _t154;                       // _t154
    _unknown_ _t158;                       // _t158
    _unknown_ _t162;                       // _t162

    if(c > 41376) {
        if(c > 41642) {
            if(c > 42656) {
                if(c > 42741) {
                    if(c > 43168) {
                        if(c > 43200) {
                            _t138 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
                            if((c & 255) > 127) {
                                _t47 = 65;
                            } else {
                                _t47 = 64;
                            }
                            return _t138 - _t47 - (c >> 8) * (c >> 8) - 9338;
                        }
                        goto L26;
                    }
                    goto L21;
L26:
                    _t142 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
                    if((c & 255) > 127) {
                        _t59 = 65;
                    } else {
                        _t59 = 64;
                    }
                    return _t142 - _t59 - (c >> 8) * (c >> 8) - 9370;
                }
                goto L16;
L21:
                _t146 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
                if((c & 255) > 127) {
                    _t71 = 65;
                } else {
                    _t71 = 64;
                }
                return _t146 - _t71 - (c >> 8) * (c >> 8) - 9344;
            }
            goto L11;
L16:
            _t150 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
            if((c & 255) > 127) {
                _t83 = 65;
            } else {
                _t83 = 64;
            }
            return _t150 - _t83 - (c >> 8) * (c >> 8) - 9429;
        }
        goto L6;
L11:
        _t154 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
        if((c & 255) > 127) {
            _t95 = 65;
        } else {
            _t95 = 64;
        }
        return _t154 - _t95 - (c >> 8) * (c >> 8) - 9366;
    }
    _t162 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) > 127) {
        _t119 = 65;
    } else {
        _t119 = 64;
    }
    return _t162 - _t119 - 24510;
L6:
    _t158 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) > 127) {
        _t107 = 65;
    } else {
        _t107 = 64;
    }
    return _t158 - _t107 - (c >> 8) * (c >> 8) - 9376;
}

Str wc_conv_from_gbk(Str is, wc_ces ces)
{// addr = 0x080C5BB1  --  defined in 'gbk.c' at line 91
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 gbk;   // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t126;                             // _t126
    signed int _t131;                      // _t131
    int _t144;                             // _t144

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while(p < ep && ( *p & 0xff) >= 0) {
    }
    if(p == ep) {
        return is;
    }
    os = Strnew_size(is->length);
    if(p > sp) {
        Strcat_charp_n(os, is->ptr, p - sp);
    }
    while(p < ep) {
        _t126 = state;
        if(_t126 == 0) {
            _t131 =  *( &WC_GBK_MAP + ( *p & 0xff)) & 0xff;
            if(_t131 == 12) {
                state = 1;
L21:
                goto L29;
            }
            goto L12;
L16:
            wtf_push(os, 2087,  *p & 0xff);
            goto L21;
        }
        if(_t126 == 1) {
            if(( *( &WC_GBK_MAP + ( *p & 0xff)) & 4) == 0) {
                wtf_push_unknown(os, p - 1, 2);
            } else {
                gbk =  *p & 0xff | ( *(p - 1) & 0xff) << 8;
                if(( *(p - 1) & 0xff) <= 160 || ( *p & 0xff) <= 160) {
                    wtf_push(os, 34838, gbk);
                } else {
                    wtf_push(os, wc_gb2312_or_gbk(gbk & 0xffff), gbk);
                }
            }
            state = 0;
        }
L29:
        p =  &(p[1]);
        continue;
L12:
        if(_t131 == 20) {
            goto L16;
        }
        if(_t131 == 2) {
            goto L17;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t144 = os->length;
         *(os->ptr + _t144) =  *p & 0xff;
        os->length = _t144 + 1;
         *(os->ptr + os->length) = 0;
        goto L29;
L17:
        wtf_push_unknown(os, p, 1);
        goto L21;
    }
    if(state == 1) {
        wtf_push_unknown(os, p - 1, 1);
    }
    return os;
}

wc_push_to_gbk(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C5E0F  --  defined in 'gbk.c' at line 148
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t144;                    // _t144
    int _t151;                             // _t151
    int _t163;                             // _t163
    unsigned int _t177;                    // _t177
    int _t188;                             // _t188
    int _t200;                             // _t200
    int _t214;                             // _t214
    int _t230;                             // _t230

    while(1) {
        _t144 = cc.ccs;
        if(_t144 == 33089) {
            break;
        }
        if(_t144 > 33089) {
            if(_t144 > 34840) {
                if(_t144 == 49152) {
                    if(( *135119022 & 0xff) != 0) {
                        return;
                    }
                    goto L31;
                }
                goto L12;
L31:
                Strcat_charp(os, WcReplaceW);
                return;
            } else {
                if(_t144 >= 34839) {
                    _v40 = cc.ccs;
                    _v36 = cc.code;
                     *__esp =  &(cc.ccs);
                    wc_cs128w_to_gbk();
                    __esp = __esp - 4;
                    goto L25;
                }
                if(_t144 == 34838) {
                    goto L25;
                }
                goto L34;
L25:
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t188 = os->length;
                 *(os->ptr + _t188) = cc.code >> 8 & 255;
                os->length = _t188 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t200 = os->length;
                 *(os->ptr + _t200) = cc.code & 255;
                os->length = _t200 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
L12:
            goto L34;
        }
        if(_t144 == 2087) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t214 = os->length;
             *(os->ptr + _t214) = (cc.code | 128) & 255;
            os->length = _t214 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t144 != 16384) {
            if(_t144 == 322) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t230 = os->length;
                 *(os->ptr + _t230) = cc.code & 255;
                os->length = _t230 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L34;
        }
        if(( *135119022 & 0xff) != 0) {
        } else {
            Strcat_charp(os, WcReplace);
            return;
        }
        goto L41;
L43:
L41:
        return;
        goto L43;
L34:
        if(( *135119011 & 0xff) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t177 = 16384;
            } else {
                _t177 = 49152;
            }
            cc.ccs = _t177;
        } else {
            _v32 = st;
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &_v20;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v20;
            cc.code = _v16;
        }
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t151 = os->length;
     *(os->ptr + _t151) = (cc.code >> 8 | 128) & 255;
    os->length = _t151 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t163 = os->length;
     *(os->ptr + _t163) = (cc.code | 128) & 255;
    os->length = _t163 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_gbk(wc_uchar c, wc_status* st)
{// addr = 0x080C6133  --  defined in 'gbk.c' at line 190
    wc_uint32 gbk;   // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t59;                              // _t59
    signed int _t62;                       // _t62
    _unknown_ _t65;                        // _t65
    struct _Str* _t74;    // _t74
    int _t102;                             // _t102

    _v32 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.2832 = Strnew_size(8);
    }
    _t59 = st->state;
    if(_t59 == 0) {
        _t62 =  *( &WC_GBK_MAP + (_v32 & 255)) & 0xff;
        if(_t62 == 12) {
            gbku = _v32 & 0xff;
            st->state = 1;
            return 0;
        }
        if(_t62 == 20) {
            goto L10;
        }
        if(_t62 == 2) {
            goto L11;
        }
        if(os.2832->length + 1 >= os.2832->area_size) {
            Strgrow(os.2832);
        }
        _t74 = os.2832;
        _t102 = _t74->length;
         *( *os.2832 + _t102) = _v32 & 0xff;
        _t74->length = _t102 + 1;
         *( *os.2832 + os.2832->length) = 0;
        goto L21;
L11:
L15:
        goto L21;
L10:
        wtf_push(os.2832, 2087, _v32 & 255);
        goto L15;
    } else {
        if(_t59 == 1) {
            if(( *( &WC_GBK_MAP + (_v32 & 255)) & 4) != 0) {
                gbk = _v32 & 255 | (gbku & 0xff) << 8;
                if((gbku & 0xff) <= 160 || _v32 <= 160) {
                    wtf_push(os.2832, 34838, gbk);
                } else {
                    wtf_push(os.2832, wc_gb2312_or_gbk(gbk & 0xffff), gbk);
                }
            }
        }
    }
L21:
    st->state = -1;
    return os.2832;
}

wc_wchar_t wc_hkscs_to_cs128w(wc_wchar_t cc)
{// addr = 0x080C62D8  --  defined in 'hkscs.c' at line 39
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    _unknown_ _t42;                        // _t42

    __ecx = _a4;
    _t42 = (cc.code >> 8 & 255) * (cc.code >> 8 & 255) + (cc.code & 255);
    if((cc.code & 255) > 160) {
        _t25 = 98;
    } else {
        _t25 = 64;
    }
    cc.code = _t42 - _t25 - 21352;
    if(cc.code > 16383) {
        cc.ccs = 34849;
        cc.code = cc.code - 16384;
    } else {
        cc.ccs = 34848;
    }
    cc.code = (cc.code >> 7 << 8) + (cc.code & 127);
     *__ecx = cc.ccs;
     *(__ecx + 4) = cc.code;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_hkscs(wc_wchar_t cc)
{// addr = 0x080C6373  --  defined in 'hkscs.c' at line 53
    unsigned int _v20;                     // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    struct  __esi;            // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t42;                        // _t42
    _unknown_ _t50;                        // _t50
    _unknown_ _t55;                        // _t55
    _unknown_ _t67;                        // _t67
    _unknown_ _t70;                        // _t70
    _unknown_ _t72;                        // _t72
    _unknown_ _t74;                        // _t74
    signed int _t80;                       // _t80

    __esi = _a4;
    cc.code = ((cc.code >> 8 & 127) << 7) + (cc.code & 127);
    if(cc.ccs == 34849) {
        cc.code = cc.code + 16384;
    }
    cc.ccs = 34847;
    _v20 = cc.code;
    _t80 = (_v20 * 875407347 >> 32 >> 5) + 136 << 8;
    _t67 = cc.code - cc.code * 875407347 * (_t62 * 875407347 >> 32 >> 5);
    if(cc.code - (cc.code * 875407347 >> 32 >> 5) * (cc.code * 875407347 >> 32 >> 5) > 62) {
        _t55 = 98;
    } else {
        _t55 = 64;
    }
    cc.code = _t80 + _t67 + _t55;
     *__esi = cc.ccs;
     *(__esi + 4) = cc.code;
    return __esi;
}

wc_uint32 wc_hkscs_to_N(wc_uint32 c)
{// addr = 0x080C643D  --  defined in 'hkscs.c' at line 64
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t25;                        // _t25
    _unknown_ _t34;                        // _t34
    _unknown_ _t37;                        // _t37

    if(c > 41279) {
        _t34 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
        if((c & 255) > 160) {
            _t16 = 98;
        } else {
            _t16 = 64;
        }
        return _t34 - _t16 - 35325;
    }
    _t37 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) > 160) {
        _t25 = 98;
    } else {
        _t25 = 64;
    }
    return _t37 - _t25 - 21352;
}

Str wc_conv_from_hkscs(Str is, wc_ces ces)
{// addr = 0x080C64D3  --  defined in 'hkscs.c' at line 73
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    int state;                             // _cfa_ffffffe0
    wc_uint32 hkscs;   // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t117;                       // _t117
    _unknown_ _t122;                       // _t122
    _unknown_ _t131;                       // _t131

    sp = is->ptr;
    ep = sp + is->length;
    state = 0;
    p = sp;
    while() {
    }
}

wc_push_to_hkscs(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C6705  --  defined in 'hkscs.c' at line 128
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    wc_status* _v32;   // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t134;                    // _t134
    unsigned int _t141;                    // _t141
    int _t153;                             // _t153
    int _t165;                             // _t165
    int _t180;                             // _t180
    int _t192;                             // _t192
    int _t209;                             // _t209

    while(1) {
        _t134 = cc.ccs;
        if(_t134 <= 34819) {
            break;
        }
        if(_t134 > 34849) {
            if(_t134 == 49152) {
                if(( *135119022 & 0xff) != 0) {
                    return;
                }
                goto L29;
            }
            goto L12;
L29:
            Strcat_charp(os, WcReplaceW);
            return;
        } else {
            if(_t134 >= 34848) {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &_v20;
                wc_cs128w_to_hkscs();
                __esp = __esp - 4;
                cc.ccs = _v20;
                cc.code = _v16;
                goto L23;
            }
            if(_t134 == 34847) {
                goto L23;
            }
L32:
            if(( *135119011 & 0xff) == 0) {
                if((cc.ccs & 98304) == 0) {
                    _t141 = 16384;
                } else {
                    _t141 = 49152;
                }
                cc.ccs = _t141;
            } else {
                _v32 = st;
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &_v20;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                cc.ccs = _v20;
                cc.code = _v16;
            }
            continue;
L23:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t153 = os->length;
             *(os->ptr + _t153) = cc.code >> 8 & 255;
            os->length = _t153 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t165 = os->length;
             *(os->ptr + _t165) = cc.code & 255;
            os->length = _t165 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
L12:
        goto L32;
    }
    if(_t134 >= 34818) {
        _v40 = cc.ccs;
        _v36 = cc.code;
         *__esp =  &(cc.ccs);
        wc_cs94w_to_big5();
        __esp = __esp - 4;
        goto L17;
    }
    if(_t134 != 16384) {
        if(_t134 == 34817) {
            goto L17;
        }
        if(_t134 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t209 = os->length;
             *(os->ptr + _t209) = cc.code & 255;
            os->length = _t209 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        goto L32;
    }
    if(( *135119022 & 0xff) != 0) {
    } else {
        goto L31;
    }
    goto L39;
L31:
    Strcat_charp(os, WcReplace);
    return;
L39:
    return;
L17:
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t180 = os->length;
     *(os->ptr + _t180) = cc.code >> 8 & 255;
    os->length = _t180 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t192 = os->length;
     *(os->ptr + _t192) = cc.code & 255;
    os->length = _t192 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_hkscs(wc_uchar c, wc_status* st)
{// addr = 0x080C69F7  --  defined in 'hkscs.c' at line 170
    wc_uint32 hkscs;   // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    int _t55;                              // _t55
    signed int _t58;                       // _t58
    _unknown_ _t61;                        // _t61
    struct _Str* _t69;    // _t69
    int _t94;                              // _t94

    _v32 = _a4 & 255;
    if(st->state == 255) {
        st->state = 0;
        os.2724 = Strnew_size(8);
    }
    _t55 = st->state;
    if(_t55 == 0) {
        _t58 =  *( &WC_HKSCS_MAP + (_v32 & 255)) & 0xff;
        if(_t58 == 12 || _t58 == 16) {
            hkscsu = _v32 & 0xff;
            st->state = 1;
            return 0;
        }
        if(_t58 != 2) {
            if(os.2724->length + 1 >= os.2724->area_size) {
                Strgrow(os.2724);
            }
            _t69 = os.2724;
            _t94 = _t69->length;
             *( *os.2724 + _t94) = _v32 & 0xff;
            _t69->length = _t94 + 1;
             *( *os.2724 + os.2724->length) = 0;
        }
    } else {
        if(_t55 == 1) {
            if(( *( &WC_HKSCS_MAP + (_v32 & 255)) & 4) != 0) {
                hkscs = _v32 & 255 | (hkscsu & 0xff) << 8;
                if((hkscsu & 0xff) <= 160 || (hkscsu & 0xff) > 249 || _v32 <= 160) {
                    wtf_push(os.2724, 34847, hkscs);
                } else {
                    wtf_push(os.2724, 34817, hkscs);
                }
            }
        }
    }
    st->state = -1;
    return os.2724;
}

Str wc_conv_from_priv1(Str is, wc_ces ces)
{// addr = 0x080C6B7C  --  defined in 'priv.c' at line 6
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    wc_ccs ccs;         // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t94;                              // _t94

    sp = is->ptr;
    ep = sp + is->length;
    ccs =  *( *((intOrPtr*)(((ces & 255) << 5) + 135767980)) + 8);
    p = sp;
    while(p < ep && ( *p & 0xff) >= 0) {
    }
    if(p != ep) {
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
        while(p < ep) {
            if(( *p & 0xff) >= 0) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t94 = os->length;
                 *(os->ptr + _t94) =  *p & 0xff;
                os->length = _t94 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
            } else {
                wtf_push(os, ccs,  *p & 0xff);
            }
            p =  &(p[1]);
        }
        return os;
    }
    return is;
}

Str wc_char_conv_from_priv1(wc_uchar c, wc_status* st)
{// addr = 0x080C6CAB  --  defined in 'priv.c' at line 32
    Str os;                // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    int _t44;                              // _t44

    _v32 = _a4 & 255;
    os = Strnew_size(1);
    if((_v32 & 0xff) >= 0) {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t44 = os->length;
         *(os->ptr + _t44) = _v32 & 0xff;
        os->length = _t44 + 1;
         *((char*)(os->ptr + os->length)) = 0;
    } else {
        wtf_push(os,  *(st->ces_info->gset + 8), _v32 & 255);
    }
    return os;
}

Str wc_conv_from_ascii(Str is, wc_ces ces)
{// addr = 0x080C6D46  --  defined in 'priv.c' at line 44
    Str os;                // _cfa_fffffff0
    wc_uchar* sp;     // _cfa_ffffffec
    wc_uchar* ep;     // _cfa_ffffffe8
    wc_uchar* p;      // _cfa_ffffffe4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t82;                              // _t82

    sp = is->ptr;
    ep = sp + is->length;
    p = sp;
    while(p < ep && ( *p & 0xff) >= 0) {
    }
    if(p != ep) {
        os = Strnew_size(is->length);
        if(p > sp) {
            Strcat_charp_n(os, is->ptr, p - sp);
        }
        while(p < ep) {
            if(( *p & 0xff) >= 0) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t82 = os->length;
                 *(os->ptr + _t82) =  *p & 0xff;
                os->length = _t82 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
            } else {
                wtf_push_unknown(os, p, 1);
            }
            p =  &(p[1]);
        }
        return os;
    }
    return is;
}

wc_push_to_raw(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C6E57  --  defined in 'priv.c' at line 69
    _unknown_ __ebp;                       // r6
    unsigned int _t21;                     // _t21
    int _t28;                              // _t28

    _t21 = cc.ccs;
    if(_t21 == 322 || _t21 == 2088) {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t28 = os->length;
         *(os->ptr + _t28) = cc.code & 255;
        os->length = _t28 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
    }
    return;
}

__divdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x080C6EC0
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t80;                       // _t80
    _unknown_ _t82;                        // _t82
    signed int _t83;                       // _t83
    signed int _t84;                       // _t84
    signed int _t85;                       // _t85
    signed int _t86;                       // _t86
    signed int _t87;                       // _t87
    _unknown_ _t93;                        // _t93
    signed int _t97;                       // _t97
    _unknown_ _t101;                       // _t101
    signed int _t104;                      // _t104
    signed int _t106;                      // _t106
    signed int _t109;                      // _t109
    _unknown_ _t116;                       // _t116
    signed int _t118;                      // _t118
    _unknown_ _t119;                       // _t119
    _unknown_ _t120;                       // _t120
    _unknown_ _t123;                       // _t123
    _unknown_ _t124;                       // _t124
    _unknown_ _t125;                       // _t125
    _unknown_ _t126;                       // _t126
    _unknown_ _t127;                       // _t127
    _unknown_ _t128;                       // _t128
    _unknown_ _t129;                       // _t129
    signed int _t131;                      // _t131
    signed int _t134;                      // _t134
    _unknown_ _t135;                       // _t135
    signed int _t138;                      // _t138
    signed int _t142;                      // _t142

    _t97 = _a8;
    _t109 = _a4;
    _v20 = _a12;
    _v16 = _a16;
    _v24 = 0;
    if(_t97 >= 0) {
        _t109 =  ~_t109;
        asm("adc ecx, 0x0");
        _t97 =  ~_t97;
        _v24 = -1;
        __eflags = _v16;
        if(_v16 >= 0) {
L2:
            _t80 = _v16;
            _t131 = _t97;
            _t138 = _v20;
            _v20 = _t109;
            if(_t80 != 0) {
                __eflags = _t80 - _t97;
                if(__eflags <= 0) {
                    asm("bsr edx, eax");
                    _v28 = _t109 ^ 31;
                    if(__eflags != 0) {
L19:
                        _v32 = _t80 << (_v28 & 0xff);
                        _t83 = 32 - _v28;
                        _v36 = _t138 << (_v28 & 0xff);
                        _v32 = _t138 >> (_t83 & 255) | _v32;
                        _t84 = _t131 << (_v28 & 0xff) | _v20 >> (_t83 & 255);
                        _t85 = _t84 / _v32;
                        _t142 = _t84 % _v32;
                        _t134 = _t85;
                        _t118 = _t85 * _v36 >> 32;
                        _t86 = _t85 * _v36;
                        __eflags = _t142 - _t118;
                        _v32 = _t118;
                        if(_t142 < _t118) {
L23:
                            _t104 = _t134 - 1;
                            goto L7;
                        }
                        goto L20;
                    }
                    __eflags = _t138 - _v20;
                    if(_t138 <= _v20) {
L16:
                        _t104 = 1;
                        goto L7;
                    }
                    __eflags = _t80 - _t97;
                    if(_t80 >= _t97) {
                        goto L6;
                    }
                    goto L16;
L20:
                    _t106 = _v28 & 255;
                    __eflags = _v20 << (_t106 & 255) - _t86;
                    if(_v20 << (_t106 & 255) >= _t86) {
L22:
                        _t104 = _t134;
                        goto L7;
                    }
                    __eflags = _t142 - _v32;
                    if(_t142 == _v32) {
                        goto L23;
                    }
                    goto L22;
                }
                goto L6;
            }
            if(_t138 <= _t97) {
                __eflags = _t138;
                if(_t138 == 0) {
                    _t138 = 1 / _t138;
                }
                _t104 = _v20 / _t138;
L7:
                _t87 = _t104;
                if(_v24 == 0) {
                    return _t87;
                }
                asm("adc edx, 0x0");
                return  ~_t87;
            }
            _t104 = _t109 / _t138;
            goto L7;
L6:
            _t104 = 0;
            goto L7;
        }
L18:
        _v20 =  ~_v20;
        asm("adc dword [ebp-0xc], 0x0");
        _v24 =  !_v24;
        _v16 =  ~_v16;
        goto L2;
    }
    if(_v16 >= 0) {
        goto L18;
    }
    goto L2;
}

__moddi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed char _a12,                      // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x080C7040
    _unknown_ _v16;                        // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t119;                      // _t119
    _unknown_ _t120;                       // _t120
    signed int _t129;                      // _t129
    signed int _t130;                      // _t130
    signed int _t131;                      // _t131
    _unknown_ _t139;                       // _t139
    _unknown_ _t140;                       // _t140
    _unknown_ _t142;                       // _t142
    _unknown_ _t144;                       // _t144
    _unknown_ _t147;                       // _t147
    signed int _t148;                      // _t148
    _unknown_ _t152;                       // _t152
    signed int _t163;                      // _t163
    _unknown_ _t168;                       // _t168
    signed int _t170;                      // _t170
    _unknown_ _t173;                       // _t173
    _unknown_ _t175;                       // _t175
    _unknown_ _t179;                       // _t179
    _unknown_ _t180;                       // _t180
    signed int _t181;                      // _t181
    _unknown_ _t182;                       // _t182
    _unknown_ _t183;                       // _t183
    _unknown_ _t184;                       // _t184
    signed int _t187;                      // _t187
    unsigned int _t191;                    // _t191
    char* _t195;                           // _t195

    _t148 = _a8;
    _t163 = _a4;
    _v36 = _a12;
    _v32 = _a16;
    _v48 = 0;
    if(_t148 >= 0) {
        _t163 =  ~_t163;
        asm("adc ecx, 0x0");
        _t148 =  ~_t148;
        _v48 = -1;
    }
    if(_v32 >= 0) {
        _v36 =  ~_v36;
        asm("adc dword [ebp-0x1c], 0x0");
        _v32 =  ~_v32;
    }
    _t119 = _v32;
    _t195 =  &_v20;
    _v52 = _t163;
    _v44 = _t163;
    _v40 = _v36;
    _t187 = _t148;
    if(_t119 != 0) {
        __eflags = _t119 - _t148;
        if(__eflags <= 0) {
            asm("bsr edx, eax");
            _v36 = _t163 ^ 31;
            if(__eflags != 0) {
                _v44 = 32 - _v36;
                _v60 = _v40 >> (_v44 & 0xff) | _t119 << (_v36 & 0xff);
                _v56 = _v40 << (_v36 & 0xff);
                _t129 = _v52 >> (_v44 & 0xff) | _t187 << (_v36 & 0xff);
                _t130 = _t129 / _v60;
                _v40 = _v52 << (_v36 & 0xff);
                _t191 = _t129 % _v60;
                _t170 = _t130 * _v56 >> 32;
                _t131 = _t130 * _v56;
                __eflags = _t191 - _t170;
                if(_t191 < _t170) {
L25:
                    _t131 = _t131 - _v56;
                    asm("sbb edx, [ebp-0x38]");
                } else {
                    __eflags = _v40 - _t131;
                    if(_v40 < _t131) {
                        __eflags = _t191 - _t170;
                        if(_t191 != _t170) {
                        } else {
                            goto L25;
                        }
                    }
                }
            } else {
                __eflags = _v40 - _v44;
                if(_v40 <= _v44) {
L23:
                    asm("sbb edi, eax");
                    _v44 = _v44 - _v40;
                } else {
                    __eflags = _t119 - _t187;
                    if(_t119 < _t187) {
                        goto L23;
                    }
                }
                _t195[4] = _t187;
                 *_t195 = _v44;
                goto L9;
            }
            asm("sbb edi, edx");
             *_t195 = _t191 << (_v44 & 0xff) | _v40 - _t131 >> (_v36 & 0xff);
            _t195[4] = _t191 >> (_v36 & 0xff);
        } else {
             *_t195 = _t163;
            _t195[4] = _t148;
        }
L9:
        __eflags = _v48;
        if(_v48 == 0) {
L6:
            return _v20;
        } else {
L10:
            asm("adc edx, 0x0");
            return  ~_v20;
        }
L26:
    }
    if(_v40 <= _t148) {
        __eflags = _v40;
        if(_v40 == 0) {
            _v40 = 1 / _v40;
        }
        _t181 = _v44 % _v40;
    } else {
        _t181 = _t163 % _v40;
    }
     *_t195 = _t181;
    _t195[4] = 0;
    if(_v48 != 0) {
        goto L10;
    } else {
        goto L6;
    }
    goto L26;
}

__libc_csu_fini()
{// addr = 0x080C7210
    _unknown_ __ebp;                       // r6

    return;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080C7220
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    signed int _t18;                       // _t18

    __i686.get_pc_thunk.bx();
    _t15 = _t14 + 56777;
    __esp = __esp - 28;
    _init();
    _t18 = _t15 + -272 - _t15 + -272 >> 2;
    if(_t18 != 0) {
        __esi = 0;
        while(1) {
            _v36 = _a12;
            _v40 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t15 + -272 + __esi * 4))();
            __esi = __esi + 1;
            if(__esi >= _t18) {
                break;
            }
        }
    }
    __esp = __esp + 28;
    return;
}

__i686.get_pc_thunk.bx()
{// addr = 0x080C727A
    return;
}

__stat(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080C7280
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __xstat();
    return;
}

__fstat(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080C72C0
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __fxstat();
    return;
}

__lstat(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080C7300
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __lxstat();
    return;
}

__do_global_ctors_aux()
{// addr = 0x080C7340
    intOrPtr* __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    __eax = __CTOR_LIST__;
    if(__eax != 255) {
        __ebx =  &__CTOR_LIST__;
        asm("o16 nop ");
        while(1) {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
            if(__eax == 255) {
                break;
            }
        }
    }
    return;
}

_fini()
{// addr = 0x080C736C
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    return;
}

L080C7378()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

L080C7378()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    @rec __do_global_dtors_aux@__do_global_dtors_aux@(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

// Statistics:
//    2188 Register nodes
//    6195 Temporaries nodes
//     627 Casts
//   45260 Statements
//    4420 Labels
//    2891 Gotos
//    1517 Blocks
//  186316 Nodes
//    1763 Assembly nodes
//    5939 Unknown Types


Total time: 59 seconds.
