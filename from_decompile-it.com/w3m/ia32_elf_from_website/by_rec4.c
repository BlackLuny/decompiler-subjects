_init()
{// addr = 0x08049BFC
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t2;

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 570348 + -4)) != 0) {
        __gmon_start__();
    }
    L0804A6B0();
    L080C7340();
    _pop(__eax);
    return;
}

L08049C08()
{
    _unknown_ _t2;

    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 570348 + -4)) != 0) {
        __gmon_start__();
    }
    L0804A6B0();
    L080C7340();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

int fileno(struct _IO_FILE* fp)
{// addr = 0x08049C3C
    goto __imp__fileno;
}

int fputs(char* str, struct _IO_FILE* fp)
{// addr = 0x08049C4C
    goto __imp__fputs;
}

void abort()
{// addr = 0x08049C5C
    goto __imp__abort;
}

int* __errno_location()
{// addr = 0x08049C6C
    goto __imp____errno_location;
}

sigemptyset()
{// addr = 0x08049C7C
    goto __imp__sigemptyset;
}

inet_ntop()
{// addr = 0x08049C8C
    goto __imp__inet_ntop;
}

int sprintf(char* dst, char* format)
{// addr = 0x08049C9C
    goto __imp__sprintf;
}

struct _IO_FILE* popen(char* name, char* mode)
{// addr = 0x08049CAC
    goto __imp__popen;
}

int open()
{// addr = 0x08049CBC
    goto __imp__open;
}

connect()
{// addr = 0x08049CCC
    goto __imp__connect;
}

int getpid()
{// addr = 0x08049CDC
    goto __imp__getpid;
}

mkdir()
{// addr = 0x08049CEC
    goto __imp__mkdir;
}

void srand48(long __seedval)
{// addr = 0x08049CFC
    goto __imp__srand48;
}

char* strerror(int __errnum)
{// addr = 0x08049D0C
    goto __imp__strerror;
}

getsockname()
{// addr = 0x08049D1C
    goto __imp__getsockname;
}

memcmp()
{// addr = 0x08049D2C
    goto __imp__memcmp;
}

void qsort(void* __base, int __nmemb, int __size, __compar_fn_t __compar)
{// addr = 0x08049D3C
    goto __imp__qsort;
}

inet_ntoa()
{// addr = 0x08049D4C
    goto __imp__inet_ntoa;
}

freeaddrinfo()
{// addr = 0x08049D5C
    goto __imp__freeaddrinfo;
}

void* bsearch(void* __key, void* __base, int __nmemb, int __size, __compar_fn_t __compar)
{// addr = 0x08049D6C
    goto __imp__bsearch;
}

tgetflag()
{// addr = 0x08049D7C
    goto __imp__tgetflag;
}

__xstat()
{// addr = 0x08049D8C
    goto __imp____xstat;
}

__gmon_start__()
{// addr = 0x08049D9C
    goto __imp____gmon_start__;
}

__lxstat()
{// addr = 0x08049DAC
    goto __imp____lxstat;
}

__isoc99_sscanf()
{// addr = 0x08049DBC
    goto __imp____isoc99_sscanf;
}

int vsprintf(char* string, char* format, _G_va_list vals)
{// addr = 0x08049DCC
    goto __imp__vsprintf;
}

localtime()
{// addr = 0x08049DDC
    goto __imp__localtime;
}

__caddr_t getpass(char* __prompt)
{// addr = 0x08049DEC
    goto __imp__getpass;
}

char* strchr(char* __s, int __c)
{// addr = 0x08049DFC
    goto __imp__strchr;
}

char* getenv(char* __name)
{// addr = 0x08049E0C
    goto __imp__getenv;
}

int system(char* __command)
{// addr = 0x08049E1C
    goto __imp__system;
}

char* strncpy(char* __dest, char* __src, int __n)
{// addr = 0x08049E2C
    goto __imp__strncpy;
}

int putchar(int ch)
{// addr = 0x08049E3C
    goto __imp__putchar;
}

__caddr_t ttyname(int __fd)
{// addr = 0x08049E4C
    goto __imp__ttyname;
}

int write(int __fd, void* __buf, int __n)
{// addr = 0x08049E5C
    goto __imp__write;
}

GC_realloc()
{// addr = 0x08049E6C
    goto __imp__GC_realloc;
}

int rename(char* _old, char* _new)
{// addr = 0x08049E7C
    goto __imp__rename;
}

void* memset(void* __s, int __c, int __n)
{// addr = 0x08049E8C
    goto __imp__memset;
}

__libc_start_main()
{// addr = 0x08049E9C
    goto __imp____libc_start_main;
}

int execl(char* __path, char* __arg)
{// addr = 0x08049EAC
    goto __imp__execl;
}

_IO_getc()
{// addr = 0x08049EBC
    goto __imp___IO_getc;
}

floor()
{// addr = 0x08049ECC
    goto __imp__floor;
}

tcgetattr()
{// addr = 0x08049EEC
    goto __imp__tcgetattr;
}

chmod()
{// addr = 0x08049EFC
    goto __imp__chmod;
}

GC_set_warn_proc()
{// addr = 0x08049F0C
    goto __imp__GC_set_warn_proc;
}

__builtin_va_list bindtextdomain(char* __domainname, char* __dirname)
{// addr = 0x08049F1C
    goto __imp__bindtextdomain;
}

GC_malloc()
{// addr = 0x08049F2C
    goto __imp__GC_malloc;
}

int read(int __fd, void* __buf, int __nbytes)
{// addr = 0x08049F3C
    goto __imp__read;
}

strtoll()
{// addr = 0x08049F4C
    goto __imp__strtoll;
}

__builtin_va_list gettext(char* __msgid)
{// addr = 0x08049F5C
    goto __imp__gettext;
}

int ungetc(int c, struct _IO_FILE* fp)
{// addr = 0x08049F6C
    goto __imp__ungetc;
}

readdir()
{// addr = 0x08049F7C
    goto __imp__readdir;
}

long strtol(char* __nptr, char** __endptr, int __base)
{// addr = 0x08049F8C
    goto __imp__strtol;
}

struct _IO_FILE* fdopen(int fd, char* name)
{// addr = 0x08049F9C
    goto __imp__fdopen;
}

siglongjmp()
{// addr = 0x08049FAC
    goto __imp__siglongjmp;
}

tgetent()
{// addr = 0x08049FBC
    goto __imp__tgetent;
}

sigaction()
{// addr = 0x08049FCC
    goto __imp__sigaction;
}

int fflush(struct _IO_FILE* fp)
{// addr = 0x08049FDC
    goto __imp__fflush;
}

sqrt()
{// addr = 0x08049FEC
    goto __imp__sqrt;
}

opendir()
{// addr = 0x08049FFC
    goto __imp__opendir;
}

int symlink(char* __from, char* __to)
{// addr = 0x0804A00C
    goto __imp__symlink;
}

ioctl()
{// addr = 0x0804A01C
    goto __imp__ioctl;
}

socket()
{// addr = 0x0804A02C
    goto __imp__socket;
}

int dup2(int __fd, int __fd2)
{// addr = 0x0804A03C
    goto __imp__dup2;
}

int fseek(struct _IO_FILE* fp, long offset, int whence)
{// addr = 0x0804A04C
    goto __imp__fseek;
}

int execlp(char* __file, char* arg)
{// addr = 0x0804A05C
    goto __imp__execlp;
}

int isatty(int __fd)
{// addr = 0x0804A06C
    goto __imp__isatty;
}

getaddrinfo()
{// addr = 0x0804A07C
    goto __imp__getaddrinfo;
}

int fclose(struct _IO_FILE* fp)
{// addr = 0x0804A08C
    goto __imp__fclose;
}

void bcopy(void* __src, void* __dest, int __n)
{// addr = 0x0804A09C
    goto __imp__bcopy;
}

int dup(int __fd)
{// addr = 0x0804A0AC
    goto __imp__dup;
}

mktime()
{// addr = 0x0804A0BC
    goto __imp__mktime;
}

void* memcpy(void* __dest, void* __src, int __n)
{// addr = 0x0804A0CC
    goto __imp__memcpy;
}

utime()
{// addr = 0x0804A0DC
    goto __imp__utime;
}

int strlen(char* __s)
{// addr = 0x0804A0EC
    goto __imp__strlen;
}

struct _IO_FILE* fopen(char* name, char* mode)
{// addr = 0x0804A0FC
    goto __imp__fopen;
}

int alarm(int __seconds)
{// addr = 0x0804A10C
    goto __imp__alarm;
}

int unlink(char* __name)
{// addr = 0x0804A11C
    goto __imp__unlink;
}

getpwuid()
{// addr = 0x0804A12C
    goto __imp__getpwuid;
}

struct _IO_FILE* freopen(char* name, char* mode, struct _IO_FILE* fp)
{// addr = 0x0804A13C
    goto __imp__freopen;
}

__builtin_va_list setlocale(int __category, char* __locale)
{// addr = 0x0804A14C
    goto __imp__setlocale;
}

waitpid()
{// addr = 0x0804A15C
    goto __imp__waitpid;
}

int fgetc(struct _IO_FILE* fp)
{// addr = 0x0804A16C
    goto __imp__fgetc;
}

int feof(struct _IO_FILE* fp)
{// addr = 0x0804A17C
    goto __imp__feof;
}

char* strcpy(char* __dest, char* __src)
{// addr = 0x0804A18C
    goto __imp__strcpy;
}

short getegid()
{// addr = 0x0804A19C
    goto __imp__getegid;
}

int printf(char* format)
{// addr = 0x0804A1AC
    goto __imp__printf;
}

int chdir(char* __path)
{// addr = 0x0804A1BC
    goto __imp__chdir;
}

ctime()
{// addr = 0x0804A1CC
    goto __imp__ctime;
}

tputs()
{// addr = 0x0804A1DC
    goto __imp__tputs;
}

short getuid()
{// addr = 0x0804A1EC
    goto __imp__getuid;
}

long atol(char* __nptr)
{// addr = 0x0804A1FC
    goto __imp__atol;
}

long lrand48()
{// addr = 0x0804A20C
    goto __imp__lrand48;
}

gethostbyaddr()
{// addr = 0x0804A21C
    goto __imp__gethostbyaddr;
}

int atoi(char* __nptr)
{// addr = 0x0804A22C
    goto __imp__atoi;
}

int strcasecmp(char* __s1, char* __s2)
{// addr = 0x0804A23C
    goto __imp__strcasecmp;
}

double atof(char* __nptr)
{// addr = 0x0804A24C
    goto __imp__atof;
}

GC_free()
{// addr = 0x0804A25C
    goto __imp__GC_free;
}

select()
{// addr = 0x0804A26C
    goto __imp__select;
}

closedir()
{// addr = 0x0804A27C
    goto __imp__closedir;
}

Gpm_Wgetch()
{// addr = 0x0804A28C
    goto __imp__Gpm_Wgetch;
}

int close(int __fd)
{// addr = 0x0804A29C
    goto __imp__close;
}

int fwrite(void* src, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x0804A2AC
    goto __imp__fwrite;
}

int fprintf(struct _IO_FILE* fp, char* format)
{// addr = 0x0804A2BC
    goto __imp__fprintf;
}

char* strstr(char* __haystack, char* __needle)
{// addr = 0x0804A2CC
    goto __imp__strstr;
}

time()
{// addr = 0x0804A2DC
    goto __imp__time;
}

nl_langinfo()
{// addr = 0x0804A2EC
    goto __imp__nl_langinfo;
}

__stack_chk_fail()
{// addr = 0x0804A2FC
    goto __imp____stack_chk_fail;
}

Gpm_Close()
{// addr = 0x0804A30C
    goto __imp__Gpm_Close;
}

int gethostname(__caddr_t __name, int __len)
{// addr = 0x0804A31C
    goto __imp__gethostname;
}

atan2()
{// addr = 0x0804A32C
    goto __imp__atan2;
}

int fputc(int ch, struct _IO_FILE* fp)
{// addr = 0x0804A33C
    goto __imp__fputc;
}

char* strtok(char* __s, char* __delim)
{// addr = 0x0804A34C
    goto __imp__strtok;
}

tgoto()
{// addr = 0x0804A35C
    goto __imp__tgoto;
}

strcasestr()
{// addr = 0x0804A36C
    goto __imp__strcasestr;
}

int sleep(int __seconds)
{// addr = 0x0804A37C
    goto __imp__sleep;
}

tgetnum()
{// addr = 0x0804A38C
    goto __imp__tgetnum;
}

int readlink(char* __path, __caddr_t __buf, int __len)
{// addr = 0x0804A39C
    goto __imp__readlink;
}

int strncasecmp(char* __s1, char* __s2, int __n)
{// addr = 0x0804A3AC
    goto __imp__strncasecmp;
}

getnameinfo()
{// addr = 0x0804A3BC
    goto __imp__getnameinfo;
}

char* strcat(char* __dest, char* __src)
{// addr = 0x0804A3CC
    goto __imp__strcat;
}

__caddr_t getcwd(__caddr_t __buf, int __size)
{// addr = 0x0804A3DC
    goto __imp__getcwd;
}

log()
{// addr = 0x0804A3EC
    goto __imp__log;
}

int puts(char* str)
{// addr = 0x0804A3FC
    goto __imp__puts;
}

int fork()
{// addr = 0x0804A40C
    goto __imp__fork;
}

int setpgrp()
{// addr = 0x0804A41C
    goto __imp__setpgrp;
}

__builtin_va_list textdomain(char* __domainname)
{// addr = 0x0804A42C
    goto __imp__textdomain;
}

tcsetattr()
{// addr = 0x0804A43C
    goto __imp__tcsetattr;
}

void bzero(void* __s, int __n)
{// addr = 0x0804A44C
    goto __imp__bzero;
}

int strspn(char* __s, char* __accept)
{// addr = 0x0804A45C
    goto __imp__strspn;
}

int sscanf(char* string, char* format)
{// addr = 0x0804A46C
    goto __imp__sscanf;
}

__fxstat()
{// addr = 0x0804A47C
    goto __imp____fxstat;
}

gmtime()
{// addr = 0x0804A48C
    goto __imp__gmtime;
}

int fscanf(struct _IO_FILE* fp, char* format)
{// addr = 0x0804A49C
    goto __imp__fscanf;
}

void* memchr(void* __s, int __c, int __n)
{// addr = 0x0804A4AC
    goto __imp__memchr;
}

int strncmp(char* __s1, char* __s2, int __n)
{// addr = 0x0804A4BC
    goto __imp__strncmp;
}

_IO_putc()
{// addr = 0x0804A4CC
    goto __imp___IO_putc;
}

int pipe(int* __pipedes)
{// addr = 0x0804A4DC
    goto __imp__pipe;
}

Gpm_Open()
{// addr = 0x0804A4EC
    goto __imp__Gpm_Open;
}

int fread(_G_va_list dst, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x0804A4FC
    goto __imp__fread;
}

strftime()
{// addr = 0x0804A50C
    goto __imp__strftime;
}

GC_malloc_atomic()
{// addr = 0x0804A51C
    goto __imp__GC_malloc_atomic;
}

tgetstr()
{// addr = 0x0804A52C
    goto __imp__tgetstr;
}

kill()
{// addr = 0x0804A53C
    goto __imp__kill;
}

int strcspn(char* __s, char* __reject)
{// addr = 0x0804A54C
    goto __imp__strcspn;
}

char* strdup(char* __s)
{// addr = 0x0804A55C
    goto __imp__strdup;
}

getpeername()
{// addr = 0x0804A56C
    goto __imp__getpeername;
}

int ferror(struct _IO_FILE* fp)
{// addr = 0x0804A57C
    goto __imp__ferror;
}

getpwnam()
{// addr = 0x0804A58C
    goto __imp__getpwnam;
}

tolower()
{// addr = 0x0804A59C
    goto __imp__tolower;
}

int strcmp(char* __s1, char* __s2)
{// addr = 0x0804A5AC
    goto __imp__strcmp;
}

__sigsetjmp()
{// addr = 0x0804A5BC
    goto __imp____sigsetjmp;
}

int setenv(char* __name, char* __value, int __overwrite)
{// addr = 0x0804A5CC
    goto __imp__setenv;
}

void exit(int __status)
{// addr = 0x0804A5DC
    goto __imp__exit;
}

int pclose(struct _IO_FILE* fp)
{// addr = 0x0804A5EC
    goto __imp__pclose;
}

ceil()
{// addr = 0x0804A5FC
    goto __imp__ceil;
}

short geteuid()
{// addr = 0x0804A60C
    goto __imp__geteuid;
}

L0804A650(_unknown_ __esi)
{
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t4;
    signed int _t5;
    signed int _t6;
    _unknown_ _t7;
    _unknown_ _t10;
    _unknown_ _t11;
    _unknown_ _t12;

    if( *135774756 != 0) {
        return ;
    }
    _t5 =  *135774760;
    _t10 = (4 >> 2) - 1;
    if(_t5 >= _t10) {
L4:
         *135774756 = 1;
        return;
    } else {
        while(1) {
L3:
            _t6 = _t5 + 1;
             *135774760 = _t6;
             *((intOrPtr*)(135089900 + _t6 * 4))();
            _t5 =  *135774760;
            if(_t5 >= _t10) {
                break;
            }
        }
        goto L4;
    }
    return;
}

L0804A6B0()
{
    _unknown_ __ebp;

    __eax =  *135089908;
    if( *135089908 == 0) {
        return ;
    }
    __eax = 0;
    if(__eax == 0) {
        return ;
    }
     *__esp = 135089908;
     *__eax();
    return;
}

fversion(FILE* f)
{// addr = 0x0804A6D4
    char* _v16;
    char* _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t7;

    _v16 = "lang=en,m17n,image,color,ansi-color,mouse,gpm,menu,cookie,external-uri-loader,w3mmailer,nntp,gopher,ipv6,alarm,mark,migemo";
    _v20 = w3m_version;
    fprintf(f, "w3m version %s, options %s\n");
    return;
}

fusage(FILE* f, int err)
{// addr = 0x0804A702
    char* _v0;
    _unknown_ _v16;
    signed int _v20;
    _unknown_ _v24;
    FILE* _v64;
    FILE* _v68;
    _unknown_ __ebp;
    _unknown_ _t218;
    _unknown_ _t220;
    _unknown_ _t222;
    _unknown_ _t224;
    _unknown_ _t226;
    _unknown_ _t228;
    _unknown_ _t230;
    _unknown_ _t232;
    _unknown_ _t234;
    _unknown_ _t236;
    _unknown_ _t238;
    _unknown_ _t240;
    _unknown_ _t242;
    _unknown_ _t244;
    _unknown_ _t246;
    _unknown_ _t248;
    _unknown_ _t250;
    _unknown_ _t252;
    _unknown_ _t254;
    _unknown_ _t256;
    _unknown_ _t258;
    _unknown_ _t260;
    _unknown_ _t262;
    _unknown_ _t264;
    _unknown_ _t266;
    _unknown_ _t268;
    _unknown_ _t270;
    _unknown_ _t272;
    _unknown_ _t274;
    _unknown_ _t276;
    _unknown_ _t278;
    _unknown_ _t280;
    _unknown_ _t282;
    _unknown_ _t284;
    _unknown_ _t286;
    _unknown_ _t288;
    _unknown_ _t290;
    _unknown_ _t292;
    _unknown_ _t294;
    _unknown_ _t296;
    _unknown_ _t298;
    _unknown_ _t300;
    _unknown_ _t302;
    _unknown_ _t304;
    _unknown_ _t306;
    _unknown_ _t309;
    _unknown_ _t318;
    _unknown_ _t332;
    _unknown_ _t341;
    _unknown_ _t342;
    _unknown_ _t401;
    _unknown_ _t408;
    _unknown_ _t414;
    _unknown_ _t415;

    fversion(f);
    fwrite("usage: w3m [options] [URL or filename]\noptions:\n", 1, 48, f);
    fwrite("    -t tab           set tab width\n", 1, 35, f);
    fwrite("    -r               ignore backspace effect\n", 1, 45, f);
    fwrite("    -l line          # of preserved line (default 10000)\n", 1, 57, f);
    fwrite("    -I charset       document charset\n", 1, 38, f);
    fwrite("    -O charset       display/output charset\n", 1, 44, f);
    fwrite("    -B               load bookmark\n", 1, 35, f);
    fwrite("    -bookmark file   specify bookmark file\n", 1, 43, f);
    fwrite("    -T type          specify content-type\n", 1, 42, f);
    fwrite("    -m               internet message mode\n", 1, 43, f);
    fwrite("    -v               visual startup mode\n", 1, 41, f);
    fwrite("    -M               monochrome display\n", 1, 40, f);
    fwrite("    -N               open URL of command line on each new tab\n", 1, 62, f);
    fwrite("    -F               automatically render frame\n", 1, 48, f);
    fwrite("    -cols width      specify column width (used with -dump)\n", 1, 60, f);
    fwrite("    -ppc count       specify the number of pixels per character (4.0...32.0)\n", 1, 77, f);
    fwrite("    -ppl count       specify the number of pixels per line (4.0...64.0)\n", 1, 72, f);
    fwrite("    -dump            dump formatted page into stdout\n", 1, 53, f);
    fwrite("    -dump_head       dump response of HEAD request into stdout\n", 1, 63, f);
    fwrite("    -dump_source     dump page source into stdout\n", 1, 50, f);
    fwrite("    -dump_both       dump HEAD and source into stdout\n", 1, 54, f);
    fwrite("    -dump_extra      dump HEAD, source, and extra information into stdout\n", 1, 74, f);
    fwrite("    -post file       use POST method with file content\n", 1, 55, f);
    fwrite("    -header string   insert string as a header\n", 1, 47, f);
    fwrite("    +<num>           goto <num> line\n", 1, 37, f);
    fwrite("    -num             show line number\n", 1, 38, f);
    fwrite("    -no-proxy        don't use proxy\n", 1, 37, f);
    fwrite("    -4               IPv4 only (-o dns_order=4)\n", 1, 48, f);
    fwrite("    -6               IPv6 only (-o dns_order=6)\n", 1, 48, f);
    fwrite("    -no-mouse        don't use mouse\n", 1, 37, f);
    fwrite("    -cookie          use cookie (-no-cookie: don't use cookie)\n", 1, 63, f);
    fwrite("    -pauth user:pass proxy authentication\n", 1, 42, f);
    fwrite("    -graph           use graphic character\n", 1, 43, f);
    fwrite("    -no-graph        don't use graphic character\n", 1, 49, f);
    fwrite("    -s               squeeze multiple blank lines\n", 1, 50, f);
    fwrite("    -W               toggle wrap search mode\n", 1, 45, f);
    fwrite("    -X               don't use termcap init/deinit\n", 1, 51, f);
    fwrite("    -title[=TERM]    set buffer name to terminal title string\n", 1, 62, f);
    fwrite("    -o opt=value     assign value to config option\n", 1, 51, f);
    fwrite("    -show-option     print all config options\n", 1, 46, f);
    fwrite("    -config file     specify config file\n", 1, 41, f);
    fwrite("    -help            print this usage message\n", 1, 46, f);
    fwrite("    -version         print w3m version\n", 1, 39, f);
    fwrite("    -reqlog          write request logfile\n", 1, 43, f);
    fwrite("    -debug           DO NOT USE\n", 1, 32, f);
    if(show_params_p != 0) {
        show_params(f);
    }
    exit(err);
    _push(_t414);
    __esp = __esp - 40;
    if((fmInitialized & 255 & 4294967295) == 0) {
        if(orig_GC_warn_proc == 0) {
            _v64 = f;
            fprintf(__imp__stderr, _v0);
            return;
        }
    } else {
        _v20 = i + n - (((i + n) * -858993459 >> 32 >> 4 << 2) + ((i + n) * -858993459 >> 32 >> 4) << 2);
         *( &msg_ring + _v20 * 8) = _v0;
         *(135775524 + _v20 * 8) = f;
        if(n > 19) {
            i = i + 1;
        } else {
            n = n + 1;
        }
        if(lock != 0) {
            return ;
        }
        lock = 1;
        while(n > 0) {
            i = i - ((i * -858993459 >> 32 >> 4 << 2) + (i * -858993459 >> 32 >> 4) << 2);
            _v68 =  *(135775524 + i * 8);
            printf( *( &msg_ring + i * 8));
            sleep_till_anykey(1, 1);
            n = n - 1;
            i = i + 1;
        }
    }
L13:
    _v68 = f;
     *__esp = _v0;
     *orig_GC_warn_proc();
    return;
}

wrap_GC_warn_proc(char* msg, GC_word arg)
{// addr = 0x0804AD86
    int j;
    signed int _v16;
    long unsigned int _v36;
    long unsigned int _v40;
    _unknown_ __ebp;
    _unknown_ _t41;
    _unknown_ _t55;
    _unknown_ _t64;
    _unknown_ _t65;
    _unknown_ _t78;
    _unknown_ _t85;

    if((fmInitialized & 255 & 4294967295) == 0) {
        if(orig_GC_warn_proc == 0) {
            _v36 = arg;
            fprintf(__imp__stderr, msg);
            return;
        }
        goto L10;
    }
    _v16 = i + n - (((i + n) * -858993459 >> 32 >> 4 << 2) + ((i + n) * -858993459 >> 32 >> 4) << 2);
     *( &msg_ring + _v16 * 8) = msg;
     *(135775524 + _v16 * 8) = arg;
    if(n > 19) {
        i = i + 1;
    } else {
        n = n + 1;
    }
    if(lock != 0) {
        return ;
    }
    lock = 1;
    while(n > 0) {
        i = i - ((i * -858993459 >> 32 >> 4 << 2) + (i * -858993459 >> 32 >> 4) << 2);
        _v40 =  *(135775524 + i * 8);
        printf( *( &msg_ring + i * 8));
        sleep_till_anykey(1, 1);
        n = n - 1;
        i = i + 1;
    }
L10:
    _v40 = arg;
     *__esp = msg;
     *orig_GC_warn_proc();
    return;
}

sig_chld(int signo)
{// addr = 0x0804AEF1
    int p_stat;
    pid_t pid;
    char _v16;
    intOrPtr _v20;
    intOrPtr _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    char* _t7;
    _unknown_ _t8;

    while(1) {
L1:
        _v36 = 1;
        _t7 =  &_v16;
        _v40 = _t7;
         *__esp = -1;
        waitpid();
        _v20 = _t7;
        if(_v20 <= 0) {
            break;
        }
    }
    mySignal(17, sig_chld);
    return;
}

Str make_optional_header_string(char* s)
{// addr = 0x0804AF31
    char* p;
    Str hs;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t49;
    _unknown_ _t57;

    if(strchr(s, 10) != 0) {
        return 0;
    }
    if(strchr(s, 13) != 0) {
        return 0;
    }
    _v16 = s;
    while(( *_v16 & 255 & 4294967295) != 0 && ( *_v16 & 255 & 4294967295) != 58) {
    }
}

int main(int argc, char** argv, char** envp)
{// addr = 0x0804B07E
    Buffer* newbuf;
    char* p;
    char c;
    int i;
    InputStream redin;
    char* line_str;
    char** load_argv;
    FormList* request;
    int load_argc;
    int load_bookmark;
    int visual_start;
    int open_new_tab;
    char search_header;
    char* default_type;
    char* post_file;
    Str err_msg;
    char* Locale;
    wc_uint8 auto_detect;
    Str tmp;
    double ppc;
    double ppc;
    Str hs;
    Str s_page;
    FILE* fp;
    Str body;
    Anchor* a;
    _unknown_ _v21;
    char* _v22;
    _unknown_ _v23;
    char* _v28;
    _unknown_ _v32;
    intOrPtr _v36;
    _unknown_ _v40;
    char* _v44;
    signed int _v48;
    _unknown_ _v52;
    char* _v56;
    char* _v60;
    char* _v64;
    char* _v68;
    char* _v72;
    char* _v76;
    _unknown_ _v80;
    char* _v84;
    _unknown_ _v88;
    _unknown_ _v92;
    _unknown_ _v96;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ _v108;
    _unknown_ _v140;
    _unknown_ _v144;
    _unknown_ _v148;
    _unknown_ _v152;
    _unknown_ _v156;
    _unknown_ _v160;
    _unknown_ _t778;
    _unknown_ _t779;
    _unknown_ _t780;
    signed int _t785;
    _unknown_ _t816;
    _unknown_ _t1053;
    _unknown_ _t1120;
    _unknown_ _t1130;
    _unknown_ _t1171;
    _unknown_ _t1220;
    _unknown_ _t1227;
    _unknown_ _t1266;
    _unknown_ _t1367;
    _unknown_ _t1368;
    _unknown_ _t1395;
    _unknown_ _t1408;
    _unknown_ _t1415;
    _unknown_ _t1420;
    _unknown_ _t1428;
    _unknown_ _t1450;
    _unknown_ _t1489;
    _unknown_ _t1571;
    _unknown_ _t1573;
    _unknown_ _t1583;
    _unknown_ _t1584;
    _unknown_ _t1603;
    _unknown_ _t1612;
    _unknown_ _t1619;
    _unknown_ _t1645;
    _unknown_ _t1646;
    _unknown_ _t1647;
    _unknown_ _t1651;
    _unknown_ _t1691;
    _unknown_ _t1692;
    _unknown_ _t1725;
    _unknown_ _t1726;
    _unknown_ _t1749;
    _unknown_ _t1750;

    __esp = __esp & 240;
    _push(_t1749);
    _push(_t1691);
    __esp = __esp - 152;
    _v28 = 0;
    _v44 = 0;
    _v56 = 0;
    _v60 = 0;
    _v64 = 0;
    _v68 = 0;
    _v22 = 0;
    _v72 = 0;
    _v76 = 0;
    _v84 = 0;
    setlocale(6, 135036496);
    bindtextdomain("w3m", "/usr/share/locale");
    textdomain("w3m");
    NO_proxy_domains = newGeneralList();
    fileToDelete = newGeneralList();
    _t785 = argc - 1 << 2;
     *__esp = _t785;
    GC_malloc();
    _v48 = _t785;
    _v56 = 0;
    CurrentDir = currentdir();
    CurrentPid = getpid();
    BookmarkFile = 0;
    config_file = 0;
    _v36 = 1;
    while(_v36 < argc) {
    }
}

keyPressEventProc(int c)
{// addr = 0x0804D821
    _unknown_ __ebp;

    CurrentKey = c;
     *((intOrPtr*)( *((intOrPtr*)(135103140 + ( *( &GlobalKeymap + c) & 255 & 4294967295 & ) * 8))))();
    return;
}

pushEvent(int cmd, _Unknown_base* data)
{// addr = 0x0804D847
    Event* event;
    struct _Event* _v16;
    _unknown_ __ebp;

     *__esp = 12;
    GC_malloc();
    _v16 = __eax;
     *_v16 = cmd;
    _v16->data = data;
    _v16->next = 0;
    if(CurrentEvent == 0) {
        CurrentEvent = _v16;
    } else {
        LastEvent->next = _v16;
    }
    LastEvent = _v16;
    return;
}

dump_source(Buffer* buf)
{// addr = 0x0804D89F
    FILE* f;
    char c;
    signed int _v13;
    struct _IO_FILE* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(buf->sourcefile == 0) {
        return ;
    }
    _v20 = fopen(buf->sourcefile, "r");
    if(_v20 == 0) {
        return ;
    }
    while(1) {
        fgetc(_v20);
        _v13 = _v20 & 4294967295;
        feof(_v20);
        if(_v20 != 0) {
            break;
        }
        putchar(_v13);
    }
    fclose(_v20);
    return;
}

dump_head(Buffer* buf)
{// addr = 0x0804D913
    TextListItem* ti;
    struct _textlistitem* _v16;
    _unknown_ _v36;
    struct _Str _v40;
    _unknown_ __ebp;
    _unknown_ _t27;
    _unknown_ _t30;
    _unknown_ _t33;

    if(buf->document_header != 0) {
        _v16 = buf->document_header->first;
L5:
        while(_v16 != 0) {
            goto L4;
        }
    }
    if((w3m_dump & 8) == 0) {
        return ;
    }
    putchar(10);
    return;
L4:
    _v40 =  *(wc_Str_conv_strict(Strnew_charp( *_v16), InnerCharset,  *(buf + 208)));
    printf("%s");
    _v16 = _v16->next;
    goto L5;
}

dump_extra(Buffer* buf)
{// addr = 0x0804D9B6
    struct _Str _v24;
    _unknown_ __ebp;
    _unknown_ _t15;
    _unknown_ _t21;
    _unknown_ _t26;

    _v24 =  *(parsedURL2Str(buf + 132));
    printf("W3m-current-url: %s\n");
    if(buf->baseURL != 0) {
        _v24 =  *(parsedURL2Str(buf->baseURL));
        printf("W3m-base-url: %s\n");
    }
    _v24 = wc_ces_to_charset( *(buf + 208));
    printf("W3m-document-charset: %s\n");
    return;
}

do_dump(Buffer* buf)
{// addr = 0x0804DA34
    _None prevtrap;
    _None* _v16;
    _unknown_ _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    _unknown_ _t15;
    _None* _t16;
    _unknown_ _t25;
    _unknown_ _t32;

    _v16 = 0;
    _t16 = mySignal(2, intTrap);
    _v16 = _t16;
    _v40 = 1;
     *__esp =  &IntReturn;
    __sigsetjmp();
    if(_t16 == 0) {
        if((w3m_dump & 8) != 0) {
            dump_extra(buf);
        }
        if((w3m_dump & 2) != 0) {
            dump_head(buf);
        }
        if((w3m_dump & 4) != 0) {
            dump_source(buf);
        }
        if(w3m_dump == 1) {
            saveBuffer(buf, __imp__stdout, 0);
        }
        mySignal(2, _v16);
        return;
    }
    mySignal(2, _v16);
    return;
}

nulcmd()
{// addr = 0x0804DB05
    _unknown_ __ebp;

    return;
}

pcmap()
{// addr = 0x0804DB0A
    _unknown_ __ebp;

    return;
}

escKeyProc(int c, int esc, unsigned char* map)
{// addr = 0x0804DB0F
    unsigned char** mmap;
    char* _v16;
    _unknown_ __ebp;
    int _t36;

    if(CurrentKey < 0 && (CurrentKey & 268435456) != 0) {
        _v16 = getKeyData(CurrentKey >> 16 & 1919);
        if(_v16 == 0) {
            return ;
        }
        _t36 = esc;
        if(_t36 == 512) {
            map = _v16[8];
        } else {
            if(_t36 == 1024) {
                map = _v16[0xc];
            } else {
                if(_t36 == 256) {
                    map = _v16[4];
                } else {
                    map =  *_v16;
                }
            }
        }
        esc = esc | CurrentKey;
    }
    CurrentKey = c | esc;
     *((intOrPtr*)( *((intOrPtr*)(135103140 + (map[c] & 255 & 4294967295 & ) * 8))))();
    return;
}

escmap()
{// addr = 0x0804DBCA
    char c;
    signed int _v13;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t10;

    _v13 = do_getch() & 4294967295;
    if(( *( &MYCTYPE_MAP + (_v13 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 17) == 0) {
        return ;
    }
    escKeyProc(_v13, 256,  &EscKeymap);
    return;
}

escbmap()
{// addr = 0x0804DC0E
    char c;
    int _v13;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t15;

    _v13 = do_getch() & 4294967295;
    if(( *( &MYCTYPE_MAP + (_v13 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
        if(( *( &MYCTYPE_MAP + (_v13 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 17) == 0) {
            return ;
        }
        escKeyProc(_v13, 512,  &EscBKeymap);
        return;
    }
    escdmap(_v13);
    return;
}

escdmap(char c)
{// addr = 0x0804DC78
    int d;
    signed int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    signed int _t28;

    _v32 = c & 4294967295;
    _v16 = _v32 - 48;
    _v32 = do_getch() & 4294967295;
    _t28 =  *( &MYCTYPE_MAP + (_v32 & 255 & 4294967295 & )) & 255;
    _t30 = _t28 & 4294967295 &  & 8;
    if((_t28 & 4294967295 &  & 8) != 0) {
        _v16 = (_v16 << 2) + _v16 + (_v16 << 2) + _v16 + _v32 - 48;
        _v32 = do_getch() & 4294967295;
    }
    if(_v32 != 126) {
        return ;
    }
    escKeyProc(_v16, 1024,  &EscDKeymap);
    return;
}

multimap()
{// addr = 0x0804DCF4
    char c;
    signed int _v13;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t11;

    _v13 = do_getch() & 4294967295;
    if(( *( &MYCTYPE_MAP + (_v13 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 17) == 0) {
        return ;
    }
    CurrentKey = _v13 | CurrentKey << 16 | 268435456;
    escKeyProc(_v13, 0, 0);
    return;
}

tmpClearBuffer(Buffer* buf)
{// addr = 0x0804DD53
    _unknown_ __ebp;
    Buffer* _t12;

    _t12 = buf;
    _t13 =  *((intOrPtr*)(_t12 + 92));
    if( *((intOrPtr*)(_t12 + 92)) != 0) {
        return ;
    }
    if(writeBufferCache(buf) != 0) {
        return ;
    }
    buf->firstLine = 0;
    buf->topLine = 0;
    buf->currentLine = 0;
    buf->lastLine = 0;
    return;
}

pushBuffer(Buffer* buf)
{// addr = 0x0804DD9C
    Buffer* b;
    Buffer* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    TabBuffer* _t41;

    deleteImage(CurrentTab->currentBuffer);
    if(clear_buffer != 0) {
        tmpClearBuffer(CurrentTab->currentBuffer);
    }
    if(CurrentTab->firstBuffer != CurrentTab->currentBuffer) {
        _v16 = prevBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer);
        if(_v16 == 0) {
            return ;
        }
        _v16->nextBuffer = buf;
        buf->nextBuffer = CurrentTab->currentBuffer;
        CurrentTab->currentBuffer = buf;
        return;
    }
    buf->nextBuffer = CurrentTab->firstBuffer;
    _t41 = CurrentTab;
    _t41->currentBuffer = buf;
    CurrentTab->firstBuffer = _t41->currentBuffer;
    return;
}

delBuffer(Buffer* buf)
{// addr = 0x0804DE4F
    _unknown_ _v24;
    _unknown_ __ebp;

    if(buf == 0) {
        return ;
    }
    if(CurrentTab->currentBuffer == buf) {
        CurrentTab->currentBuffer = buf->nextBuffer;
    }
    CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
    if(CurrentTab->currentBuffer != 0) {
        return ;
    }
    CurrentTab->currentBuffer = CurrentTab->firstBuffer;
    return;
}

repBuffer(Buffer* oldbuf, Buffer* buf)
{// addr = 0x0804DEBD
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    CurrentTab->firstBuffer = replaceBuffer(CurrentTab->firstBuffer, oldbuf, buf);
    CurrentTab->currentBuffer = buf;
    return;
}

intTrap(int _dummy)
{// addr = 0x0804DEFC
    intOrPtr _v24;
    _unknown_ _v52;
    _unknown_ __ebp;
    _unknown_ _t3;
    _unknown_ _t4;

    _v24 = 0;
     *__esp =  &IntReturn;
    siglongjmp();
    _push(_t3);
    __esp = __esp - 24;
    need_resize_screen = 1;
    mySignal(28, resize_hook);
    return;
}

resize_hook(int _dummy)
{// addr = 0x0804DF16
    _unknown_ _v24;
    _unknown_ __ebp;

    need_resize_screen = 1;
    mySignal(28, resize_hook);
    return;
}

resize_screen()
{// addr = 0x0804DF3C
    _unknown_ _v24;
    _unknown_ __ebp;

    need_resize_screen = 0;
    setlinescols();
    setupscreen();
    if(CurrentTab == 0) {
        return ;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

SigPipe(int _dummy)
{// addr = 0x0804DF79
    _unknown_ _v24;
    _unknown_ __ebp;

    init_migemo();
    mySignal(13, SigPipe);
    return;
}

nscroll(int n, int mode)
{// addr = 0x0804DF9A
    Buffer* buf;
    Line* top;
    Line* cur;
    int lnum;
    int tlnum;
    int llnum;
    int diff_n;
    Buffer* _v16;
    Line* _v20;
    Line* _v24;
    long int _v28;
    long int _v32;
    intOrPtr _v36;
    int _v40;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = CurrentTab->currentBuffer;
    _v20 = _v16->topLine;
    _v24 = _v16->currentLine;
    if(_v16->firstLine == 0) {
        return ;
    }
    _v28 = _v24->linenumber;
    _v16->topLine = lineSkip(_v16, _v20, n, 0);
    if(_v16->topLine != _v20) {
        _v32 = _v16->topLine->linenumber;
        asm("cwde ");
        _v36 = _v16->topLine->linenumber + (_v16->LINES & 65535) - 1;
        if(nextpage_topline == 0) {
            _v40 = _v20->linenumber - _v32 + n;
        } else {
            _v40 = 0;
        }
        if(_v28 < _v32) {
            _v28 = _v32 + _v40;
        }
        if(_v28 > _v36) {
            _v28 = _v36 + _v40;
        }
    } else {
        _v28 = _v28 + n;
        if(_v16->topLine->linenumber <= _v28) {
            if(_v16->lastLine->linenumber < _v28) {
                _v28 = _v16->lastLine->linenumber;
            }
        } else {
            _v28 = _v16->topLine->linenumber;
        }
    }
    gotoLine(_v16, _v28);
    arrangeLine(_v16);
    if(n <= 0) {
        if(_v16->currentLine->bwidth + _v16->currentLine->width >= _v16->currentColumn + _v16->visualpos) {
            while(_v16->currentLine->prev != 0 && _v16->currentLine->bpos != 0 && _v16->currentLine->bwidth >= _v16->currentColumn + _v16->visualpos) {
                cursorUp0(_v16, 1);
            }
        }
    } else {
        if(_v16->currentLine->bpos == 0) {
L20:
            while(_v16->currentLine->next != 0 && _v16->currentLine->next->bpos != 0) {
                if(_v16->currentLine->bwidth + _v16->currentLine->width < _v16->currentColumn + _v16->visualpos) {
                    cursorDown0(_v16, 1);
                    continue;
                }
                goto L31;
            }
        }
        if(_v16->currentLine->bwidth < _v16->currentColumn + _v16->visualpos) {
            goto L19;
        }
        cursorDown(_v16, 1);
L31:
        displayBuffer(_v16, mode);
        return;
L19:
        goto L20;
    }
L25:
    cursorUp(_v16, 1);
    goto L31;
}

pgFore()
{// addr = 0x0804E22A
    _unknown_ _v24;
    int __ebx;
    _unknown_ __ebp;
    int _t13;

    if(vi_prec_num == 0) {
        if(prec_num == 0) {
            __ebx = 0;
        } else {
            __ebx = 3;
        }
        if(prec_num == 0) {
            _t13 = searchKeyNum() * ((CurrentTab->currentBuffer->LINES & 65535 & 4294967295) - 1);
        } else {
            _t13 = searchKeyNum();
        }
        nscroll(_t13, __ebx);
        return;
    }
    nscroll(searchKeyNum() * ((CurrentTab->currentBuffer->LINES & 65535 & 4294967295) - 1), 0);
    return;
}

pgBack()
{// addr = 0x0804E2B9
    _unknown_ _v24;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    int _t13;
    int _t17;
    _unknown_ _t18;
    _unknown_ _t20;
    _unknown_ _t21;
    _unknown_ _t32;

    if(vi_prec_num == 0) {
        if(prec_num == 0) {
            _t17 = 0;
        } else {
            _t17 = 3;
        }
        if(prec_num == 0) {
            _t13 = searchKeyNum() * (1 - (CurrentTab->currentBuffer->LINES & 65535 & 4294967295));
        } else {
            _t13 =  ~(searchKeyNum());
        }
        nscroll(_t13, _t17);
        return;
    }
    nscroll(searchKeyNum() * (1 - (CurrentTab->currentBuffer->LINES & 65535 & 4294967295)), 0);
    return;
}

lup1()
{// addr = 0x0804E35C
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t2;

    nscroll(searchKeyNum(), 3);
    return;
}

ldown1()
{// addr = 0x0804E379
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t2;

    nscroll( ~(searchKeyNum()), 3);
    return;
}

ctrCsrV()
{// addr = 0x0804E398
    int offsety;
    signed int _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _t32 = CurrentTab->currentBuffer->LINES & 65535;
    asm("cwde ");
    _v16 = ((CurrentTab->currentBuffer->LINES & 65535) + _t32 & 4294967295) - (CurrentTab->currentBuffer->cursorY & 65535);
    if(_v16 == 0) {
        return ;
    }
    CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->topLine,  ~_v16, 0);
    arrangeLine(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

ctrCsrH()
{// addr = 0x0804E457
    int offsetx;
    int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t34;

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _t29 = CurrentTab->currentBuffer->COLS & 65535;
    asm("cwde ");
    _v16 = (CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) - (CurrentTab->currentBuffer->COLS & 65535) + _t29;
    if(_v16 == 0) {
        return ;
    }
    columnSkip(CurrentTab->currentBuffer, _v16);
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

rdrwSc()
{// addr = 0x0804E4E7
    _unknown_ _v24;
    _unknown_ __ebp;

    clear();
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

clear_mark(Line* l)
{// addr = 0x0804E51C
    int pos;
    intOrPtr _v8;
    _unknown_ __ebp;

    if(l == 0) {
        return ;
    }
    _v8 = 0;
    while(l->size > _v8) {
         *(l->propBuf + _v8 + _v8) =  *(l->propBuf + _v8 + _v8) & 65535 & 254 & 4294967295;
        _v8 = _v8 + 1;
    }
}

int srchcore(_None str, _None* func)
{// addr = 0x0804E569
    _None* prevtrap;
    _None i;
    _None result;
    _None* _v16;
    intOrPtr _v20;
    int _v24;
    intOrPtr _v40;
    _unknown_ __ebp;
    _unknown_ _t30;
    _None* _t35;
    _unknown_ _t37;
    _unknown_ _t39;
    _unknown_ _t42;
    _unknown_ _t44;

    _v24 = 2;
    if(str != 0 && str != SearchString) {
        SearchString = str;
    }
    if(SearchString == 0) {
        return ;
    }
    if(( *SearchString & 255 & 4294967295) == 0) {
        return ;
    }
    str = conv_search_string(SearchString, DisplayCharset);
    _t35 = mySignal(2, intTrap);
    _v16 = _t35;
    crmode();
    _v40 = 1;
     *__esp =  &IntReturn;
    __sigsetjmp();
    if(_t35 != 0) {
        mySignal(2, _v16);
        term_raw();
        return;
    } else {
        _v20 = 0;
        while() {
        }
    }
    return;
}

disp_srchresult(int result, char* prompt, char* str)
{// addr = 0x0804E6A3
    char* _v20;
    char* _v24;
    _unknown_ __ebp;

    if(str == 0) {
        str = 135036496;
    }
    if((result & 2) == 0) {
        if((result & 4) == 0) {
            if(show_srch_str == 0) {
                return ;
            }
            _v20 = str;
            _v24 = prompt;
            disp_message( *(Sprintf("%s%s")), 1);
            return;
        }
    } else {
        _v24 = str;
        disp_message( *(Sprintf("Not found: %s")), 1);
        return;
    }
L5:
    _v24 = str;
    disp_message( *(Sprintf("Search wrapped: %s")), 1);
    return;
}

int dispincsrch(int ch, Str buf, Lineprop* prop)
{// addr = 0x0804E74F
    char* str;
    int do_next_search;
    _None _v16;
    int _v20;
    _None* _v40;
    _unknown_ __ebp;
    int _t123;
    _unknown_ _t136;
    _unknown_ _t155;
    _unknown_ _t166;
    _unknown_ _t199;
    _unknown_ _t252;

    _v20 = 0;
    if(ch != 0) {
L3:
        _v16 = buf->ptr;
        _t123 = ch;
        if(_t123 == 19) {
            searchRoutine = forwardSearch;
            _v20 = 1;
L11:
            if(_v20 == 0) {
                if(( *_v16 & 255 & 4294967295) != 0) {
                    CurrentTab->currentBuffer->topLine =  *135775244;
                    CurrentTab->currentBuffer->currentLine =  *135775248;
                    CurrentTab->currentBuffer->pos =  *135775308;
                    CurrentTab->currentBuffer->cursorX =  *135775304 & 65535 & 4294967295;
                    CurrentTab->currentBuffer->cursorY =  *135775306 & 65535 & 4294967295;
                    CurrentTab->currentBuffer->visualpos =  *135775312;
                    CurrentTab->currentBuffer->currentColumn =  *135775300;
                    arrangeCursor(CurrentTab->currentBuffer);
                    _v40 = searchRoutine;
                    srchcore(_v16);
                    arrangeCursor(CurrentTab->currentBuffer);
                    currentLine = CurrentTab->currentBuffer->currentLine;
                     *135775496 = CurrentTab->currentBuffer->pos;
                }
                displayBuffer(CurrentTab->currentBuffer, 1);
                clear_mark(CurrentTab->currentBuffer->currentLine);
                while(1) {
L26:
                    _v16 = _v16 + 1;
                    if(( *_v16 & 255 & 4294967295) == 0) {
                        break;
                    }
                    if(migemo_active <= 0) {
                         *prop =  *prop & 65535 & 253 & 4294967295;
                        prop =  &(prop[1]);
                    } else {
                         *prop = ( *prop & 65535 | 2) & 4294967295;
                        prop =  &(prop[1]);
                    }
                }
                return -1;
            }
            if(( *_v16 & 255 & 4294967295) == 0) {
                return 16;
            }
            if(searchRoutine == forwardSearch) {
                CurrentTab->currentBuffer->pos =  &(CurrentTab->currentBuffer->pos->lineBuf);
            }
             *135775244 = CurrentTab->currentBuffer->topLine;
             *135775248 = CurrentTab->currentBuffer->currentLine;
             *135775308 = CurrentTab->currentBuffer->pos;
             *135775304 = CurrentTab->currentBuffer->cursorX & 65535 & 4294967295;
             *135775306 = CurrentTab->currentBuffer->cursorY & 65535 & 4294967295;
             *135775312 = CurrentTab->currentBuffer->visualpos;
             *135775300 = CurrentTab->currentBuffer->currentColumn;
            _v40 = searchRoutine;
            if(srchcore(_v16) == 2 && searchRoutine == forwardSearch) {
                CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos - 1;
                 *135775244 = CurrentTab->currentBuffer->topLine;
                 *135775248 = CurrentTab->currentBuffer->currentLine;
                 *135775308 = CurrentTab->currentBuffer->pos;
                 *135775304 = CurrentTab->currentBuffer->cursorX & 65535 & 4294967295;
                 *135775306 = CurrentTab->currentBuffer->cursorY & 65535 & 4294967295;
                 *135775312 = CurrentTab->currentBuffer->visualpos;
                 *135775300 = CurrentTab->currentBuffer->currentColumn;
            }
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 1);
            clear_mark(CurrentTab->currentBuffer->currentLine);
            return -1;
        }
        goto L4;
L8:
        migemo_active =  ~migemo_active;
        goto L26;
    } else {
        if(buf != 0) {
            goto L3;
        } else {
             *135775244 = CurrentTab->currentBuffer->topLine;
             *135775248 = CurrentTab->currentBuffer->currentLine;
             *135775308 = CurrentTab->currentBuffer->pos;
             *135775304 = CurrentTab->currentBuffer->cursorX & 65535 & 4294967295;
             *135775306 = CurrentTab->currentBuffer->cursorY & 65535 & 4294967295;
             *135775312 = CurrentTab->currentBuffer->visualpos;
             *135775300 = CurrentTab->currentBuffer->currentColumn;
            currentLine =  *135775248;
             *135775496 =  *135775308;
            return -1;
        }
    }
L4:
    if(_t123 == 28) {
        goto L8;
    } else {
        if(_t123 != 18) {
            if(ch < 0) {
                return ch;
            }
        } else {
            searchRoutine = backwardSearch;
            _v20 = 1;
        }
    }
    goto L11;
}

isrch(_None* func, char* prompt)
{// addr = 0x0804EB6D
    char* str;
    Buffer sbuf;
    char* _v16;
    int _v196;
    int _v200;
    signed short _v202;
    signed short _v204;
    int _v208;
    Line* _v260;
    Line* _v264;
    _unknown_ _v300;
    _unknown_ _v304;
    _unknown_ _v308;
    _unknown_ _v312;
    _unknown_ __ebp;
    _unknown_ _t80;

    _v264 = CurrentTab->currentBuffer->topLine;
    _v260 = CurrentTab->currentBuffer->currentLine;
    _v200 = CurrentTab->currentBuffer->pos;
    _v204 = CurrentTab->currentBuffer->cursorX & 65535 & 4294967295;
    _v202 = CurrentTab->currentBuffer->cursorY & 65535 & 4294967295;
    _v196 = CurrentTab->currentBuffer->visualpos;
    _v208 = CurrentTab->currentBuffer->currentColumn;
    dispincsrch(0, 0, 0);
    searchRoutine = func;
    _v16 = inputLineHistSearch(prompt, 0, 16, TextHist, dispincsrch);
    if(_v16 == 0) {
        CurrentTab->currentBuffer->topLine = _v264;
        CurrentTab->currentBuffer->currentLine = _v260;
        CurrentTab->currentBuffer->pos = _v200;
        CurrentTab->currentBuffer->cursorX = _v204 & 65535 & 4294967295;
        CurrentTab->currentBuffer->cursorY = _v202 & 65535 & 4294967295;
        CurrentTab->currentBuffer->visualpos = _v196;
        CurrentTab->currentBuffer->currentColumn = _v208;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

srch(_None* func, char* prompt)
{// addr = 0x0804ECDF
    char* str;
    int result;
    int disp;
    int pos;
    _None _v16;
    signed int _v20;
    int _v24;
    int _v28;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _None* _v56;
    _unknown_ __ebp;
    _unknown_ _t48;

    _v24 = 0;
    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
        _v16 = inputLineHistSearch(prompt, 0, 16, TextHist, 0);
        if(_v16 != 0 && ( *_v16 & 255 & 4294967295) == 0) {
            _v16 = SearchString;
        }
        if(_v16 != 0) {
            _v24 = 1;
            goto L8;
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
L8:
    _v28 = CurrentTab->currentBuffer->pos;
    if(func == forwardSearch) {
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
    }
    _v56 = func;
    _v20 = srchcore(_v16);
    if((_v20 & 1 & 4294967295) == 0) {
        CurrentTab->currentBuffer->pos = _v28;
    } else {
        clear_mark(CurrentTab->currentBuffer->currentLine);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    if(_v24 != 0) {
        disp_srchresult(_v20, prompt, _v16);
    }
    searchRoutine = func;
    return;
}

srchfor()
{// addr = 0x0804EE29
    _unknown_ _v24;
    _unknown_ __ebp;

    srch(forwardSearch, "Forward: ");
    return;
}

isrchfor()
{// addr = 0x0804EE45
    _unknown_ _v24;
    _unknown_ __ebp;

    isrch(forwardSearch, "I-search: ");
    return;
}

srchbak()
{// addr = 0x0804EE61
    _unknown_ _v24;
    _unknown_ __ebp;

    srch(backwardSearch, "Backward: ");
    return;
}

isrchbak()
{// addr = 0x0804EE7D
    _unknown_ _v24;
    _unknown_ __ebp;

    isrch(backwardSearch, "I-search backward: ");
    return;
}

srch_nxtprv(int reverse)
{// addr = 0x0804EE99
    int result;
    signed int _v16;
    _unknown_ _v36;
    _None*[1] _v40;
    _unknown_ __ebp;
    char* _t35;
    char* _t43;

    if(searchRoutine != 0) {
        if(reverse != 0) {
            reverse = 1;
        }
        if(searchRoutine == backwardSearch) {
            reverse = reverse ^ 1;
        }
        if(reverse == 0) {
            CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
        }
        _v40 = ( &routine)[reverse];
        _v16 = srchcore(SearchString);
        if((_v16 & 1 & 4294967295) != 0) {
            clear_mark(CurrentTab->currentBuffer->currentLine);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        _t43 = SearchString;
        if(reverse == 0) {
            _t35 = "Forward: ";
        } else {
            _t35 = "Backward: ";
        }
        disp_srchresult(_v16, _t35, _t43);
        return;
    }
    disp_message("No previous regular expression", 1);
    return;
}

srchnxt()
{// addr = 0x0804EF7E
    _unknown_ __ebp;

    srch_nxtprv(0);
    return;
}

srchprv()
{// addr = 0x0804EF92
    _unknown_ __ebp;

    srch_nxtprv(1);
    return;
}

shiftvisualpos(Buffer* buf, int shift)
{// addr = 0x0804EFA6
    Line* l;
    Line* _v16;
    _unknown_ __ebp;

    _v16 = buf->currentLine;
    buf->visualpos = buf->visualpos - shift;
    asm("cwde ");
    if(buf->visualpos - _v16->bwidth < (buf->COLS & 65535)) {
        if(buf->visualpos - _v16->bwidth < 0) {
            buf->visualpos = _v16->bwidth;
        }
    } else {
        asm("cwde ");
        buf->visualpos = _v16->bwidth + (buf->COLS & 65535) - 1;
    }
    arrangeLine(buf);
    if(buf->visualpos - _v16->bwidth !=  ~shift) {
        return ;
    }
    if((buf->cursorX & 65535 & 4294967295) != 0) {
        return ;
    }
    buf->visualpos = _v16->bwidth;
    return;
}

shiftl()
{// addr = 0x0804F05A
    int column;
    int _v16;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t29;

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = CurrentTab->currentBuffer->currentColumn;
    columnSkip(CurrentTab->currentBuffer, searchKeyNum() * (1 - (CurrentTab->currentBuffer->COLS & 65535 & 4294967295)) + 1);
    shiftvisualpos(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentColumn - _v16);
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

shiftr()
{// addr = 0x0804F101
    int column;
    int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t29;

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = CurrentTab->currentBuffer->currentColumn;
    columnSkip(CurrentTab->currentBuffer, searchKeyNum() * ((CurrentTab->currentBuffer->COLS & 65535 & 4294967295) - 1) - 1);
    shiftvisualpos(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentColumn - _v16);
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

col1R()
{// addr = 0x0804F197
    Buffer* buf;
    Line* l;
    int j;
    int column;
    int n;
    Buffer* _v16;
    Line* _v20;
    int _v24;
    int _v28;
    int _v32;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t35;

    _v16 = CurrentTab->currentBuffer;
    _v20 = _v16->currentLine;
    _v32 = searchKeyNum();
    if(_v20 == 0) {
        return ;
    }
    _v24 = 0;
    while(_v24 < _v32) {
        _v28 = _v16->currentColumn;
        columnSkip(CurrentTab->currentBuffer, 1);
        if(_v16->currentColumn == _v28) {
            goto L7;
        }
        shiftvisualpos(CurrentTab->currentBuffer, 1);
        _v24 = _v24 + 1;
        continue;
L7:
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

col1L()
{// addr = 0x0804F238
    Buffer* buf;
    Line* l;
    int j;
    int n;
    Buffer* _v16;
    Line* _v20;
    int _v24;
    int _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t31;

    _v16 = CurrentTab->currentBuffer;
    _v20 = _v16->currentLine;
    _v28 = searchKeyNum();
    if(_v20 == 0) {
        return ;
    }
    _v24 = 0;
    while(_v24 < _v28) {
        if(_v16->currentColumn == 0) {
            goto L7;
        }
        columnSkip(CurrentTab->currentBuffer, -1);
        shiftvisualpos(CurrentTab->currentBuffer, -1);
        _v24 = _v24 + 1;
        continue;
L7:
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

setEnv()
{// addr = 0x0804F2CF
    char* env;
    char* var;
    char* value;
    const char* _v16;
    char* _v20;
    char* _v24;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    const char* _v56;
    _unknown_ __ebp;
    _unknown_ _t42;

    CurrentKeyData = 0;
    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0 || strchr(_v16, 61) == 0) {
        if(_v16 != 0) {
            if(( *_v16 & 255 & 4294967295) != 0) {
                _v56 = _v16;
                _v16 =  *(Sprintf("%s="));
            }
        }
        _v16 = inputLineHistSearch("Set environ: ", _v16, 16, TextHist, 0);
        if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
L9:
    _v24 = strchr(_v16, 61);
    if(_v24 != 0 && _v24 > _v16) {
        _v20 = allocStr(_v16, _v24 - _v16);
        _v24 =  &(_v24[1]);
        set_environ(_v20, _v24);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

pipeBuf()
{// addr = 0x0804F405
    Buffer* buf;
    char* cmd;
    char* tmpf;
    FILE* f;
    Buffer* _v16;
    char* _v20;
    char* _v24;
    FILE* _v28;
    _unknown_ _v44;
    _unknown_ _v48;
    struct _Str _v52;
    char* _v56;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t64;
    _unknown_ _t79;

    CurrentKeyData = 0;
    _v20 = searchKeyData();
    if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
        _v20 = inputLineHistSearch("Pipe buffer to: ", 135036496, 128, ShellHist, 0);
    }
    if(_v20 != 0) {
        _v20 =  *(wc_Str_conv_strict(Strnew_charp(_v20), InnerCharset, SystemCharset));
    }
    if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    _v24 =  *(tmpfname(0, 0));
    _v28 = fopen(_v24, "w");
    if(_v28 != 0) {
        saveBuffer(CurrentTab->currentBuffer, _v28, 1);
        fclose(_v28);
        _v16 = getpipe( *(myExtCommand(_v20, shell_quote(_v24), 1)));
        if(_v16 != 0) {
             *_v16 = _v20;
            _v52 =  *(wc_Str_conv(Strnew_charp(_v20), SystemCharset, InnerCharset));
            _v56 = "*stream*";
            _v16->buffername =  *(Sprintf("%s %s"));
            _v16->bufferprop = (_v16->bufferprop & 65535 | 24) & 4294967295;
            if(_v16->type == 0) {
                _v16->type = "text/plain";
            }
             *(_v16 + 152) = "-";
            pushBuffer(_v16);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        goto L11;
    }
    _v56 = _v20;
    disp_message( *(Sprintf("Can't save buffer to %s")), 1);
    return;
L11:
    disp_message("Execution failed", 1);
    return;
}

pipesh()
{// addr = 0x0804F645
    Buffer* buf;
    char* cmd;
    Buffer* _v16;
    char* _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t36;

    CurrentKeyData = 0;
    _v20 = searchKeyData();
    if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
        _v20 = inputLineHistSearch("(read shell[pipe])!", 135036496, 128, ShellHist, 0);
    }
    if(_v20 != 0) {
        _v20 =  *(wc_Str_conv_strict(Strnew_charp(_v20), InnerCharset, SystemCharset));
    }
    if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    _v16 = getpipe(_v20);
    if(_v16 != 0) {
        _v16->bufferprop = (_v16->bufferprop & 65535 | 24) & 4294967295;
        if(_v16->type == 0) {
            _v16->type = "text/plain";
        }
        pushBuffer(_v16);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    disp_message("Execution failed", 1);
    return;
}

readsh()
{// addr = 0x0804F776
    Buffer* buf;
    _None* prevtrap;
    char* cmd;
    Buffer* _v16;
    _None* _v20;
    char* _v24;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t40;
    _unknown_ _t52;

    CurrentKeyData = 0;
    _v24 = searchKeyData();
    if(_v24 == 0 || ( *_v24 & 255 & 4294967295) == 0) {
        _v24 = inputLineHistSearch("(read shell)!", 135036496, 128, ShellHist, 0);
    }
    if(_v24 != 0) {
        _v24 =  *(wc_Str_conv_strict(Strnew_charp(_v24), InnerCharset, SystemCharset));
    }
    if(_v24 == 0 || ( *_v24 & 255 & 4294967295) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    _v20 = mySignal(2, intTrap);
    crmode();
    _v16 = getshell(_v24);
    mySignal(2, _v20);
    term_raw();
    if(_v16 != 0) {
        _v16->bufferprop = (_v16->bufferprop & 65535 | 24) & 4294967295;
        if(_v16->type == 0) {
            _v16->type = "text/plain";
        }
        pushBuffer(_v16);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    disp_message("Execution failed", 1);
    return;
}

execsh()
{// addr = 0x0804F8DE
    char* cmd;
    char* _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t21;
    _unknown_ _t29;
    _unknown_ _t31;
    _unknown_ _t33;
    _unknown_ _t35;
    _unknown_ _t36;

    CurrentKeyData = 0;
    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
        _v16 = inputLineHistSearch("(exec shell)!", 135036496, 128, ShellHist, 0);
    }
    if(_v16 != 0) {
        _v16 =  *(wc_Str_conv_strict(Strnew_charp(_v16), InnerCharset, SystemCharset));
    }
    if(_v16 != 0 && ( *_v16 & 255 & 4294967295) != 0) {
        fmTerm();
        putchar(10);
        system(_v16);
        printf("\n[Hit any key]");
        fflush(__imp__stdout);
        fmInit();
        do_getch();
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

ldfile()
{// addr = 0x0804F9D9
    char* fn;
    char* _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t21;

    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
        _v16 = inputLineHistSearch("(Load)Filename? ", 0, 32, LoadHist, 0);
    }
    if(_v16 != 0) {
        _v16 =  *(wc_Str_conv_strict(Strnew_charp(_v16), InnerCharset, SystemCharset));
    }
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    cmd_loadfile(_v16);
    return;
}

ldhelp()
{// addr = 0x0804FA97
    char* lang;
    int n;
    Str tmp;
    char* _v16;
    int _v20;
    struct _Str* _v24;
    _unknown_ _v32;
    char* _v36;
    char* _v40;
    _unknown_ __ebp;
    struct _Str* _t21;
    struct _Str* _t24;

    _v16 = AcceptLang;
    _v20 = strcspn(_v16, ";, \t");
    _t21 = Str_form_quote(Strnew_charp_n(_v16, _v20));
    _t24 = Str_form_quote(Strnew_charp(w3m_version));
    _v36 = _t21->ptr;
    _v40 = _t24->ptr;
    _v24 = Sprintf("file:///$LIB/w3mhelp.cgi?version=%s&lang=%s");
    cmd_loadURL( *_v24, 0, -1, 0);
    return;
}

cmd_loadfile(char* fn)
{// addr = 0x0804FB31
    Buffer* buf;
    char* emsg;
    struct _Str _v20;
    int _v44;
    _unknown_ _v52;
    struct _Str _v56;
    _unknown_ __ebp;
    char* _t23;

    _t23 = file_to_url(fn);
    _v44 = 0;
    _v56.area_size = 0;
    _v20.length = loadGeneralFile(_t23, 0, -1);
    if(_v16 != 0) {
        if(_v16 != 1) {
            pushBuffer(_v20.length);
            if((RenderFrame & 255 & 4294967295) != 0 && CurrentTab->currentBuffer->frameset != 0) {
                rFrame();
            }
        }
    } else {
        _v56 =  *(wc_Str_conv(Strnew_charp(fn), SystemCharset, InnerCharset));
        _v20 =  *(Sprintf("%s not found"));
        disp_err_message(_v20, 0);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

_movL(int n)
{// addr = 0x0804FC1A
    int i;
    int m;
    intOrPtr _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t14;

    _v20 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = 0;
    while(_v16 < _v20) {
        cursorLeft(CurrentTab->currentBuffer, n);
        _v16 = _v16 + 1;
    }
}

movL()
{// addr = 0x0804FC80
    _unknown_ __ebp;

    _t10 = CurrentTab->currentBuffer->COLS & 65535;
    asm("cwde ");
    _movL((CurrentTab->currentBuffer->COLS & 65535) + _t10);
    return;
}

movL1()
{// addr = 0x0804FCA9
    _unknown_ __ebp;

    _movL(1);
    return;
}

_movD(int n)
{// addr = 0x0804FCBD
    int i;
    int m;
    intOrPtr _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t14;

    _v20 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = 0;
    while(_v16 < _v20) {
        cursorDown(CurrentTab->currentBuffer, n);
        _v16 = _v16 + 1;
    }
}

movD()
{// addr = 0x0804FD23
    _unknown_ __ebp;

    asm("cwde ");
    _movD(((CurrentTab->currentBuffer->LINES & 65535) + 1 >> 31) + (CurrentTab->currentBuffer->LINES & 65535) + 1 >> 1);
    return;
}

movD1()
{// addr = 0x0804FD4D
    _unknown_ __ebp;

    _movD(1);
    return;
}

_movU(int n)
{// addr = 0x0804FD61
    int i;
    int m;
    intOrPtr _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t14;

    _v20 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = 0;
    while(_v16 < _v20) {
        cursorUp(CurrentTab->currentBuffer, n);
        _v16 = _v16 + 1;
    }
}

movU()
{// addr = 0x0804FDC7
    _unknown_ __ebp;

    asm("cwde ");
    _movU(((CurrentTab->currentBuffer->LINES & 65535) + 1 >> 31) + (CurrentTab->currentBuffer->LINES & 65535) + 1 >> 1);
    return;
}

movU1()
{// addr = 0x0804FDF1
    _unknown_ __ebp;

    _movU(1);
    return;
}

_movR(int n)
{// addr = 0x0804FE05
    int i;
    int m;
    intOrPtr _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t14;

    _v20 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = 0;
    while(_v16 < _v20) {
        cursorRight(CurrentTab->currentBuffer, n);
        _v16 = _v16 + 1;
    }
}

movR()
{// addr = 0x0804FE6B
    _unknown_ __ebp;

    _t10 = CurrentTab->currentBuffer->COLS & 65535;
    asm("cwde ");
    _movR((CurrentTab->currentBuffer->COLS & 65535) + _t10);
    return;
}

movR1()
{// addr = 0x0804FE94
    _unknown_ __ebp;

    _movR(1);
    return;
}

int prev_nonnull_line(Line* line)
{// addr = 0x0804FEA8
    Line* l;
    Line* _v8;
    _unknown_ __ebp;
    _unknown_ _t23;
    _unknown_ _t29;

    _v8 = line;
    while(_v8 != 0 && _v8->len == 0) {
    }
}

movLW()
{// addr = 0x0804FF1D
    char* lb;
    Lineprop* pb;
    Line* pline;
    int ppos;
    int i;
    int n;
    char* _v16;
    Lineprop* _v20;
    Line* _v24;
    int _v28;
    int _v32;
    int _v36;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t80;

    _v36 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v32 = 0;
    while(_v32 < _v36) {
        _v24 = CurrentTab->currentBuffer->currentLine;
        _v28 = CurrentTab->currentBuffer->pos;
        if(prev_nonnull_line(CurrentTab->currentBuffer->currentLine) >= 0) {
            goto L21;
        } else {
            goto L3;
        }
        while(1) {
L3:
            _v16 = CurrentTab->currentBuffer->currentLine->lineBuf;
            _v20 = CurrentTab->currentBuffer->currentLine->propBuf;
            goto L5;
        }
L21:
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

int next_nonnull_line(Line* line)
{// addr = 0x08050144
    Line* l;
    Line* _v8;
    _unknown_ __ebp;
    _unknown_ _t20;
    _unknown_ _t26;

    _v8 = line;
    while(_v8 != 0 && _v8->len == 0) {
    }
}

movRW()
{// addr = 0x080501AE
    char* lb;
    Lineprop* pb;
    Line* pline;
    int ppos;
    int i;
    int n;
    char* _v16;
    Lineprop* _v20;
    Line* _v24;
    int _v28;
    int _v32;
    int _v36;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t83;

    _v36 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v32 = 0;
L20:
    while(_v32 < _v36) {
        _v24 = CurrentTab->currentBuffer->currentLine;
        _v28 = CurrentTab->currentBuffer->pos;
        if(next_nonnull_line(CurrentTab->currentBuffer->currentLine) < 0) {
            _v16 = CurrentTab->currentBuffer->currentLine->lineBuf;
            _v20 = CurrentTab->currentBuffer->currentLine->propBuf;
            while((_v16[CurrentTab->currentBuffer->pos] & 255 & 4294967295) != 0) {
                if(( *( &MYCTYPE_MAP + (_v16[CurrentTab->currentBuffer->pos] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 12) == 0) {
                    goto L12;
                }
                if(( *(CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos + _v20) & 65535 & 4294967295 &  & 16128) == 0) {
                    CurrentTab->currentBuffer->pos =  &(CurrentTab->currentBuffer->pos->lineBuf);
                    continue;
                }
L12:
                while((_v16[CurrentTab->currentBuffer->pos] & 255 & 4294967295) == 0 || ( *( &MYCTYPE_MAP + (_v16[CurrentTab->currentBuffer->pos] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 12) != 0 && ( *(CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos + _v20) & 65535 & 4294967295 &  & 16128) == 0) {
                    if((_v16[CurrentTab->currentBuffer->pos] & 255 & 4294967295) == 0) {
                        if(next_nonnull_line(CurrentTab->currentBuffer->currentLine->next) >= 0) {
                            CurrentTab->currentBuffer->pos = 0;
                            _v16 = CurrentTab->currentBuffer->currentLine->lineBuf;
                            _v20 = CurrentTab->currentBuffer->currentLine->propBuf;
                            continue;
                        }
                        goto L18;
                    }
                    _v32 = _v32 + 1;
                    goto L20;
L18:
                    CurrentTab->currentBuffer->currentLine = _v24;
                    CurrentTab->currentBuffer->pos = _v28;
                    goto L23;
                }
                goto L12;
            }
        }
L23:
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
}

_quitfm(int confirm)
{// addr = 0x080503D6
    char* ans;
    char* _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t25;

    _v16 = "y";
    if(checkDownloadList() == 0) {
        if(confirm != 0) {
            _v16 = inputLineHistSearch("Do you want to exit w3m? (y/n)", 135036496, 512, 0, 0);
        }
    } else {
        _v16 = inputLineHistSearch("Download process retains. Do you want to exit w3m? (y/n)", 135036496, 512, 0, 0);
    }
    if(_v16 == 0) {
L9:
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            if(( *_v16 & 255 & 4294967295) == 121) {
                goto L10;
            }
            goto L9;
        }
        if((( *_v16 & 255 | 32) & 4294967295) != 121) {
            goto L9;
        }
        goto L10;
    }
L10:
    term_title(135036496);
    if(activeImage != 0) {
        termImage();
    }
    fmTerm();
    save_cookies();
    if(UseHistory != 0 && SaveURLHist != 0) {
        saveHistory(URLHist, URLHistSize);
    }
    w3m_exit(0);
    return;
}

quitfm()
{// addr = 0x08050501
    _unknown_ __ebp;

    _quitfm(0);
    return;
}

qquitfm()
{// addr = 0x08050515
    _unknown_ __ebp;

    _quitfm(confirm_on_quit);
    return;
}

selBuf()
{// addr = 0x0805052A
    Buffer* buf;
    int ok;
    char cmd;
    char _v13;
    struct _Buffer* _v20;
    intOrPtr _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    signed int _t37;

    _v24 = 0;
    goto L1;
    do {
L1:
        _v20 = selectBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer,  &_v13);
        _t37 = _v13 & 255 & 4294967295;
        if(_t37 == 68) {
            delBuffer(_v20);
            if(CurrentTab->firstBuffer == 0) {
                CurrentTab->firstBuffer = nullBuffer();
                CurrentTab->currentBuffer = CurrentTab->firstBuffer;
            }
            goto L18;
        }
        if(_t37 <= 68) {
            if(_t37 == 66) {
                _v24 = 1;
            } else {
                if(_t37 <= 66 && (_t37 == 10 || _t37 == 32)) {
                    CurrentTab->currentBuffer = _v20;
                    _v24 = 1;
                }
            }
        } else {
            if(_t37 == 81) {
                quitfm();
            } else {
                if(_t37 == 113) {
                    qquitfm();
                }
            }
        }
L18:
    } while(_v24 == 0);
    _v20 = CurrentTab->firstBuffer;
    while(_v20 != 0) {
        if(CurrentTab->currentBuffer != _v20) {
            deleteImage(_v20);
            if(clear_buffer != 0) {
                tmpClearBuffer(_v20);
            }
        }
        _v20 = _v20->nextBuffer;
    }
}

susp()
{// addr = 0x08050668
    intOrPtr _v24;
    _unknown_ __ebp;

    move(LINES - 1, 0);
    clrtoeolx();
    refresh();
    fmTerm();
    _v24 = 19;
     *__esp = 0;
    kill();
    fmInit();
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

_goLine(char* l)
{// addr = 0x080506C8
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    Buffer* _t86;

    if(l == 0 || ( *l & 255 & 4294967295) == 0 || CurrentTab->currentBuffer->currentLine == 0) {
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    CurrentTab->currentBuffer->pos = 0;
    if(( *l & 255 & 4294967295) == 94 || ( *l & 255 & 4294967295) == 36) {
        if(prec_num == 0) {
            goto L8;
        } else {
            gotoRealLine(CurrentTab->currentBuffer, prec_num);
        }
L13:
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
L8:
    if(( *l & 255 & 4294967295) != 94) {
        if(( *l & 255 & 4294967295) != 36) {
            gotoRealLine(CurrentTab->currentBuffer, atoi(l));
        } else {
            asm("cwde ");
            CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->lastLine, ( !(CurrentTab->currentBuffer->LINES & 65535) >> 31) +  !(CurrentTab->currentBuffer->LINES & 65535) >> 1, 1);
            CurrentTab->currentBuffer->currentLine = CurrentTab->currentBuffer->lastLine;
        }
    } else {
        _t86 = CurrentTab->currentBuffer;
        _t86->currentLine = CurrentTab->currentBuffer->firstLine;
        CurrentTab->currentBuffer->topLine = _t86->currentLine;
    }
    goto L13;
}

goLine()
{// addr = 0x0805084C
    char* str;
    char* _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t8;

    _v16 = searchKeyData();
    if(prec_num == 0) {
        if(_v16 == 0) {
            _goLine(inputLineHistSearch("Goto line: ", 135036496, 16, 0, 0));
            return;
        }
        goto L3;
    }
    _goLine("^");
    return;
L3:
    _goLine(_v16);
    return;
}

goLineF()
{// addr = 0x080508BA
    _unknown_ __ebp;

    _goLine("^");
    return;
}

goLineL()
{// addr = 0x080508CE
    _unknown_ __ebp;

    _goLine("$");
    return;
}

linbeg()
{// addr = 0x080508E2
    _unknown_ _v24;
    _unknown_ __ebp;

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    while(CurrentTab->currentBuffer->currentLine->prev != 0 && CurrentTab->currentBuffer->currentLine->bpos != 0) {
        cursorUp0(CurrentTab->currentBuffer, 1);
    }
}

linend()
{// addr = 0x08050971
    _unknown_ _v24;
    _unknown_ __ebp;

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    while(CurrentTab->currentBuffer->currentLine->next != 0 && CurrentTab->currentBuffer->currentLine->next->bpos != 0) {
        cursorDown0(CurrentTab->currentBuffer, 1);
    }
}

int cur_real_linenumber(Buffer* buf)
{// addr = 0x08050A14
    Line* l;
    Line* cur;
    int n;
    struct _Line* _v8;
    Line* _v12;
    long int _v16;
    _unknown_ __ebp;
    long int _t30;
    _unknown_ _t42;

    _v12 = buf->currentLine;
    if(_v12 == 0) {
        return 1;
    }
    if(_v12->real_linenumber == 0) {
        _t30 = 1;
    } else {
        _t30 = _v12->real_linenumber;
    }
    _v16 = _t30;
    _v8 = buf->firstLine;
    while(_v8 != 0) {
        if(_v8 == _v12) {
            return _v16;
        }
        if(_v8->real_linenumber != 0) {
            return _v16;
        }
        if(_v8->bpos == 0) {
            _v16 = _v16 + 1;
        }
        _v8 = _v8->next;
    }
}

editBf()
{// addr = 0x08050A89
    char* fn;
    Str cmd;
    char* _v16;
    struct _Str* _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    TabBuffer* _t40;
    Buffer* _t44;
    Buffer* _t49;
    Buffer* _t54;
    int _t61;
    _unknown_ _t67;
    Buffer* _t76;

    _t40 = CurrentTab;
    _t42 = _t40->currentBuffer->filename;
    _v16 = _t40->currentBuffer->filename;
    if(_v16 == 0) {
L7:
        disp_err_message("Can't edit other than local file", 1);
        return;
    }
    _t44 = CurrentTab->currentBuffer;
    _t42 =  *(_t44 + 92);
    if( *(_t44 + 92) != 0) {
        goto L7;
    }
    if(CurrentTab->currentBuffer->type != 0) {
L4:
        _t49 = CurrentTab->currentBuffer;
        _t42 = _t49->real_scheme;
        if(_t49->real_scheme != 4 || strcmp( *(CurrentTab->currentBuffer + 152), "-") == 0) {
            goto L7;
        }
        _t54 = CurrentTab->currentBuffer;
        asm("cwde ");
        _t42 = _t54->bufferprop & 65535 & 2;
        if((_t54->bufferprop & 65535 & 2) == 0) {
            goto L8;
        }
        goto L7;
    }
    _t76 = CurrentTab->currentBuffer;
    _t42 = _t76->edit;
    if(_t76->edit == 0) {
        goto L7;
    }
    goto L4;
L8:
    if(CurrentTab->currentBuffer->edit == 0) {
        _t61 = cur_real_linenumber(CurrentTab->currentBuffer);
        _v20 = myEditor(Editor, shell_quote(_v16), _t61);
    } else {
        _v20 = unquote_mailcap(CurrentTab->currentBuffer->edit, CurrentTab->currentBuffer->real_type, _v16, checkHeader(CurrentTab->currentBuffer, "Content-Type:"), 0);
    }
    fmTerm();
    system( *_v20);
    fmInit();
    displayBuffer(CurrentTab->currentBuffer, 1);
    reload();
    return;
}

editScr()
{// addr = 0x08050C0E
    char* tmpf;
    FILE* f;
    char* _v16;
    FILE* _v20;
    _unknown_ _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t22;
    _unknown_ _t30;
    int _t33;
    _unknown_ _t38;
    _unknown_ _t40;

    _v16 =  *(tmpfname(0, 0));
    _v20 = fopen(_v16, "w");
    if(_v20 != 0) {
        saveBuffer(CurrentTab->currentBuffer, _v20, 1);
        fclose(_v20);
        fmTerm();
        _t33 = cur_real_linenumber(CurrentTab->currentBuffer);
        system( *(myEditor(Editor, shell_quote(_v16), _t33)));
        fmInit();
        unlink(_v16);
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    _v40 = _v16;
    disp_err_message( *(Sprintf("Can't open %s")), 1);
    return;
}

_mark()
{// addr = 0x08050D0F
    Line* l;
    Line* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(use_mark == 0) {
        return ;
    }
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = CurrentTab->currentBuffer->currentLine;
     *((intOrPtr*)(_v16->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos)) = ( *(_v16->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 65535 ^ 1) & 4294967295;
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

nextMk()
{// addr = 0x08050D8F
    Line* l;
    int i;
    struct _Line* _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(use_mark == 0) {
        return ;
    }
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v20 =  &(CurrentTab->currentBuffer->pos->lineBuf);
    _v16 = CurrentTab->currentBuffer->currentLine;
    if(_v16->len <= _v20) {
        _v20 = 0;
        _v16 = _v16->next;
    }
    while(_v16 != 0) {
        while(_v16->len > _v20) {
            if(( *(_v16->propBuf + _v20 + _v20) & 65535 & 4294967295 &  & 1 & 4294967295) != 0) {
                CurrentTab->currentBuffer->currentLine = _v16;
                CurrentTab->currentBuffer->pos = _v20;
                arrangeCursor(CurrentTab->currentBuffer);
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            _v20 = _v20 + 1;
        }
    }
}

prevMk()
{// addr = 0x08050E9C
    Line* l;
    int i;
    struct _Line* _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(use_mark == 0) {
        return ;
    }
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v20 = CurrentTab->currentBuffer->pos - 1;
    _v16 = CurrentTab->currentBuffer->currentLine;
    if(_v20 < 0) {
        _v16 = _v16->prev;
        if(_v16 != 0) {
            _v20 = _v16->len - 1;
        }
    }
    while(_v16 != 0) {
        while(_v20 >= 0) {
            if(( *(_v16->propBuf + _v20 + _v20) & 65535 & 4294967295 &  & 1 & 4294967295) != 0) {
                CurrentTab->currentBuffer->currentLine = _v16;
                CurrentTab->currentBuffer->pos = _v20;
                arrangeCursor(CurrentTab->currentBuffer);
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            }
            _v20 = _v20 - 1;
        }
    }
}

reMark()
{// addr = 0x08050FB6
    Line* l;
    char* str;
    char* p;
    char* p1;
    char* p2;
    Line* _v16;
    char* _v20;
    char* _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;

    if(use_mark == 0) {
        return ;
    }
    _v20 = searchKeyData();
    if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
        _v20 = inputLineHistSearch("(Mark)Regexp: ", MarkString, 16, TextHist, 0);
        if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            goto L6;
        }
    } else {
L6:
        _v20 = conv_search_string(_v20, DisplayCharset);
        _v20 = regexCompile(_v20, 1);
        if(_v20 == 0) {
            MarkString = _v20;
            _v16 = CurrentTab->currentBuffer->firstLine;
            while(_v16 != 0) {
                goto L9;
            }
        }
        goto L7;
L9:
        _v24 =  *_v16;
        while(regexMatch(_v24,  *_v16 + _v16->len - _v24,  *_v16 & 4294967295 & ) == 1) {
            matchedPosition( &_v28,  &_v32);
             *(_v16->propBuf + _v28 -  *_v16 + _v28 -  *_v16) = ( *(_v16->propBuf + _v28 -  *_v16 + _v28 -  *_v16) & 65535 | 1) & 4294967295;
            _v24 = _v32;
        }
    }
L7:
    disp_message(_v20, 1);
    return;
}

Buffer* loadNormalBuf(Buffer* buf, int renderframe)
{// addr = 0x0805117F
    _unknown_ __ebp;

    pushBuffer(buf);
    if(renderframe == 0) {
        return buf;
    }
    if((RenderFrame & 255 & 4294967295) == 0) {
        return buf;
    }
    if(CurrentTab->currentBuffer->frameset == 0) {
        return buf;
    }
    rFrame();
    return buf;
}

Buffer* loadLink(char* url, char* target, char* referer, FormList* request)
{// addr = 0x080511BD
    Buffer* buf;
    Buffer* nfbuf;
    union frameset_element* f_element;
    int flag;
    ParsedURL* base;
    ParsedURL pu;
    char* emsg;
    Anchor* al;
    char* label;
    Buffer* _v16;
    struct _Buffer* _v20;
    union frameset_element* _v24;
    Buffer* _v28;
    ParsedURL* _v32;
    struct _Str _v44;
    struct _ParsedURL _v84;
    FormList* _v108;
    Buffer* _v112;
    Buffer* _v116;
    char* _v120;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _None _t137;
    _unknown_ _t146;
    _unknown_ _t221;
    _unknown_ _t226;

    _v24 = 0;
    _v28 = 0;
    _v120 = url;
    message( *(Sprintf("loading %s")), 0, 0);
    refresh();
    _v32 = baseURL(CurrentTab->currentBuffer);
    if(_v32 == 0 ||  *_v32 == 4 ||  *_v32 == 5) {
        referer = -1;
    }
    if(referer == 0) {
        referer =  *(parsedURL2Str(CurrentTab->currentBuffer + 132));
    }
    _t137 = baseURL(CurrentTab->currentBuffer);
    _v108 = request;
    _v112 = _v28;
    _v16 = loadGeneralFile(url, _t137, referer);
    if(_v16 != 0) {
        parseURL2(url,  &_v84, _v32);
        pushHashHist(URLHist,  *(parsedURL2Str( &_v84)));
        if(_v16 == 1) {
            return 0;
        }
        if(on_target == 0) {
            return loadNormalBuf(_v16, 1);
        }
        if(do_download != 0) {
            return loadNormalBuf(_v16, 0);
        }
        if(target == 0) {
            return loadNormalBuf(_v16, 1);
        }
        if(strcmp(target, "_top") == 0) {
            return loadNormalBuf(_v16, 1);
        }
        asm("cwde ");
        if((CurrentTab->currentBuffer->bufferprop & 65535 & 2) == 0) {
            return loadNormalBuf(_v16, 1);
        }
        _v20 = CurrentTab->currentBuffer->linkBuffer[1];
        if(_v20 == 0) {
            return loadNormalBuf(_v16, 1);
        }
        _v24 = search_frame(_v20->frameset, target);
        if(_v24 == 0) {
            return loadNormalBuf(_v16, 1);
        }
        pushFrameTree( &(_v20->frameQ), copyFrameSet(_v20->frameset), CurrentTab->currentBuffer);
        delBuffer(CurrentTab->currentBuffer);
        CurrentTab->currentBuffer = _v20;
        resetFrameElement(_v24, _v16, referer, request);
        discardBuffer(_v16);
        rFrame();
        _v44.length = 0;
        _v44 = _v84.label;
        if(_v44 != 0 && ( *( *_v24) & 255 & 4294967295) == 1) {
            _v44.length = searchAnchor( *( *_v24 + 28), _v44);
        }
        if(_v40 == 0) {
            _v116 = 0;
            _v120 = target;
            _v44 =  *(Strnew_m_charp("_"));
            _v44.length = searchURLLabel(CurrentTab->currentBuffer, _v44);
        }
        if(_v40 != 0) {
            gotoLine(CurrentTab->currentBuffer,  *(_v44.length + 20));
            if(label_topline != 0) {
                CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->topLine, CurrentTab->currentBuffer->currentLine->linenumber - CurrentTab->currentBuffer->topLine->linenumber, 0);
            }
            CurrentTab->currentBuffer->pos =  *(_v44.length + 24);
            arrangeCursor(CurrentTab->currentBuffer);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return _v16;
    }
    _v120 = url;
    _v44.area_size =  *(Sprintf("Can't load %s"));
    disp_err_message(_v44.area_size, 0);
    return 0;
}

gotoLabel(char* label)
{// addr = 0x080515BC
    Buffer* buf;
    Anchor* al;
    int i;
    Buffer* _v16;
    Anchor* _v20;
    intOrPtr _v24;
    _unknown_ _v32;
    _unknown_ _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t75;

    _v20 = searchURLLabel(CurrentTab->currentBuffer, label);
    if(_v20 != 0) {
        asm("cwde ");
        _v16 = newBuffer(CurrentTab->currentBuffer->width & 65535);
        copyBuffer(_v16, CurrentTab->currentBuffer);
        _v24 = 0;
L4:
        while(_v24 <= 4) {
            goto L3;
        }
    }
    _v40 = label;
    disp_message( *(Sprintf("%s is not found")), 1);
    return;
L3:
     *((intOrPtr*)(_v16 + 12 + (_v24 + 4) * 4)) = 0;
    _v24 = _v24 + 1;
    goto L4;
}

followA()
{// addr = 0x08051773
    Line* l;
    Anchor* a;
    ParsedURL u;
    int x;
    int y;
    int map;
    char* url;
    Str to;
    Buffer* buf;
    Line* _v16;
    Anchor* _v20;
    int _v24;
    int _v28;
    int _v32;
    char* _v36;
    struct _Str* _v40;
    Buffer* _v44;
    struct _anchor _v104;
    _unknown_ __ebp;
    struct _Str* _t127;
    _unknown_ _t142;
    _unknown_ _t157;
    _unknown_ _t161;
    _unknown_ _t187;
    _unknown_ _t192;
    _unknown_ _t205;

    _v24 = 0;
    _v28 = 0;
    _v32 = 0;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = CurrentTab->currentBuffer->currentLine;
    _v20 = retrieveCurrentImg(CurrentTab->currentBuffer);
    if(_v20 == 0) {
L5:
        if(_v20 != 0) {
L6:
            if(_v20->image != 0) {
                if((_v20->image->ismap & 255 & 4294967295) != 0) {
                    getMapXY(CurrentTab->currentBuffer, _v20,  &_v24,  &_v28);
                    _v32 = 1;
                }
            }
        }
        _v20 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
        if(_v20 == 0) {
            _followForm(0);
            return;
        }
        if(( *( *_v20) & 255 & 4294967295) != 35) {
            parseURL2( *_v20,  &(_v104.start), baseURL(CurrentTab->currentBuffer));
            _t127 = parsedURL2Str(CurrentTab->currentBuffer + 132);
            if(strcmp( *(parsedURL2Str( &_v84)),  *_t127) != 0 || _v52 == 0) {
                if(strncasecmp( *_v20, "mailto:", 7) != 0 || non_null(Mailer) == 0 || strchr( *_v20, 63) != 0) {
                    _v36 =  *_v20;
                    if(_v32 != 0) {
                        _v104.referer = _v28;
                        _v104.target = _v24;
                        _v104 =  *_v20;
                        _v36 =  *(Sprintf("%s?%d,%d"));
                    }
                    if(check_target == 0 || open_tab_blank == 0 || _v20->target == 0 || strcasecmp(_v20->target, "_new") != 0 && strcasecmp(_v20->target, "_blank") != 0) {
                        loadLink(_v36, _v20->target, _v20->referer, 0);
                        displayBuffer(CurrentTab->currentBuffer, 0);
                        return;
                    } else {
                        _newT();
                        _v44 = CurrentTab->currentBuffer;
                        loadLink(_v36, _v20->target, _v20->referer, 0);
                        if(CurrentTab->currentBuffer == _v44) {
                            deleteTab(CurrentTab);
                        } else {
                            delBuffer(_v44);
                        }
                        displayBuffer(CurrentTab->currentBuffer, 1);
                        return;
                    }
                    return ;
                }
                _v40 = Strnew_charp( &(( *_v20)[7]));
                fmTerm();
                system( *(myExtCommand(Mailer, shell_quote(file_unquote( *_v40)), 0)));
                fmInit();
                displayBuffer(CurrentTab->currentBuffer, 1);
                pushHashHist(URLHist,  *_v20);
                return;
            }
            gotoLabel(_v104.rows);
            return;
        }
        gotoLabel( &(( *_v20)[1]));
        return;
    } else {
        if(_v20->image == 0) {
            goto L5;
        } else {
            if(_v20->image->map == 0) {
                goto L5;
            } else {
                _followForm(0);
                return;
            }
        }
        goto L6;
    }
}

bufferA()
{// addr = 0x08051B2B
    _unknown_ __ebp;

    on_target = 0;
    followA();
    on_target = 1;
    return;
}

followI()
{// addr = 0x08051B4C
    Line* l;
    Anchor* a;
    Buffer* buf;
    char* emsg;
    Line* _v16;
    struct _Str _v28;
    _unknown_ _v52;
    struct _anchor _v56;
    _unknown_ __ebp;
    _None _t45;

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = CurrentTab->currentBuffer->currentLine;
    _v28.area_size = retrieveCurrentImg(CurrentTab->currentBuffer);
    if(_v20 == 0) {
        return ;
    }
    _v56 =  *(_v28.area_size);
    message( *(Sprintf("loading %s")), 0, 0);
    refresh();
    _t45 = baseURL(CurrentTab->currentBuffer);
    _v56.title = 0;
    _v56.referer = 0;
    _v56.end = loadGeneralFile( *(_v28.area_size), _t45, 0);
    if(_v24 != 0) {
        if(_v24 != 1) {
            pushBuffer(_v56.end);
        }
    } else {
        _v56 =  *(_v28.area_size);
        _v28 =  *(Sprintf("Can't load %s"));
        disp_err_message(_v28, 0);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

FormItemList* save_submit_formlist(FormItemList* src)
{// addr = 0x08051C66
    FormList* list;
    FormList* srclist;
    FormItemList* srcitem;
    FormItemList* item;
    FormItemList* ret;
    FormSelectOptionItem* opt;
    FormSelectOptionItem* curopt;
    FormSelectOptionItem* srcopt;
    struct form_list _v28;
    struct _Str** _v32;
    struct _Str* _v36;
    struct _Str** _v40;
    struct _Str* _v44;
    _unknown_ __ebp;
    struct form_list* _t151;
    struct form_list _t170;
    struct _Str* _t195;
    _unknown_ _t233;

    _v32 = 0;
    if(src == 0) {
        return 0;
    }
    _t151 = src->parent;
    _v28.method = _t151;
     *__esp = 52;
    GC_malloc();
    _v28.action = _t151;
    _v28.action->method = _v28.method->method;
     *(_v28.action + 12) = Strdup( *(_v28.method + 12));
     *((intOrPtr*)(_v28.action + 24)) =  *((intOrPtr*)(_v28.method + 24));
    _v28.action->enctype = _v28.method->enctype;
    _v28.action->nitems = _v28.method->nitems;
    _v28.action->body = _v28.method->body;
    _v28.action->boundary = _v28.method->boundary;
    _v28.action->length = _v28.method->length;
    _t170 =  *(_v28.method);
    _v28.lastitem.item = _t170;
    while(_v24.item != 0) {
         *__esp = 72;
        GC_malloc();
        _v28.item = _t170;
        _v28.item->type = _v28.lastitem.item->type;
         *(_v28.item + 4) = Strdup( *(_v28.lastitem.item + 4));
         *(_v28.item + 8) = Strdup( *(_v28.lastitem.item + 8));
        _v28.item->checked = _v28.lastitem.item->checked;
        _v28.item->accept = _v28.lastitem.item->accept;
        _v28.item->size = _v28.lastitem.item->size;
        _v28.item->rows = _v28.lastitem.item->rows;
        _v28.item->maxlength = _v28.lastitem.item->maxlength;
        _v28.item->readonly = _v28.lastitem.item->readonly;
        _v40 = 0;
        _v36 = _v40;
        _v44 =  *(_v28.lastitem + 44);
        while(_v44 != 0) {
            _t195 = _v44[2];
            if(_t195 != 0) {
                 *__esp = 16;
                GC_malloc();
                _v36 = _t195;
                 *_v36 = Strdup( *_v44);
                _v36[1] = Strdup(_v44[1]);
                _v36[2] = _v44[2];
                if(_v28.item->select_option != 0) {
                    _v40[3] = _v36;
                    _v40 = _v40[3];
                } else {
                    _v40 = _v36;
                     *(_v28 + 44) = _v40;
                }
            }
            _v44 = _v44[3];
        }
    }
}

Str conv_form_encoding(Str val, FormItemList* fi, Buffer* buf)
{// addr = 0x08051ED7
    wc_ces charset;
    unsigned int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = SystemCharset;
    if( *(fi->parent + 24) == 0) {
        if( *(buf + 208) == 0) {
            return wc_Str_conv_strict(val, InnerCharset, _v16);
        }
        goto L3;
    }
    _v16 =  *(fi->parent + 24);
    return wc_Str_conv_strict(val, InnerCharset, _v16);
L3:
    if( *(buf + 208) == 256) {
        return wc_Str_conv_strict(val, InnerCharset, _v16);
    }
    _v16 =  *(buf + 208);
    return wc_Str_conv_strict(val, InnerCharset, _v16);
}

query_from_followform(Str* query, FormItemList* fi, int multipart)
{// addr = 0x08051F46
    FormItemList* f2;
    FILE* body;
    int x;
    int y;
    int x;
    int y;
    struct form_item_list* _v16;
    FILE* _v20;
    int _v24;
    int _v28;
    char* _v44;
    char* _v48;
    struct form_list* _v52;
    int _v56;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t256;
    _unknown_ _t269;
    _unknown_ _t271;
    struct _Str* _t294;
    struct _Str* _t331;
    _unknown_ _t343;
    struct _Str* _t385;
    _unknown_ _t399;
    _unknown_ _t430;
    int _t469;
    int _t483;

    _v20 = 0;
    if(multipart != 0) {
         *query = tmpfname(0, 0);
        _v20 = fopen( *( *query), "w");
        if(_v20 == 0) {
            return ;
        }
        fi->parent->body =  *( *query);
        _v44 = fi->parent->boundary;
        _v48 = fi->parent->body;
        _v52 = fi->parent;
        _v56 = CurrentPid;
        fi->parent->boundary =  *(Sprintf("------------------------------%d%ld%ld%ld"));
    }
     *query = Strnew();
    _v16 = fi->parent->item;
    while(_v16 != 0) {
        if( *(_v16 + 4) == 0) {
L37:
            _v16 = _v16->next;
            continue;
        }
        if( *(_v16 + 4)->length != 0) {
L8:
            if( *_v16 <= 7) {
                goto __eax;
            }
            if(multipart == 0) {
                if( *_v16 != 7) {
                    if( *(_v16 + 4) != 0 &&  *(_v16 + 4)->length > 0) {
                        Strcat( *query, Str_form_quote(conv_form_encoding( *(_v16 + 4), fi, CurrentTab->currentBuffer)));
                        if( *query->length + 1 >=  *query->area_size) {
                            Strgrow( *query);
                        }
                        _t331 =  *query;
                        _t483 = _t331->length;
                         *((char*)( *( *query) + _t483)) = 61;
                        _t331->length = _t483 + 1;
                         *( *( *query) +  *query->length) = 0;
                    }
                    if( *(_v16 + 8) != 0) {
                        if(fi->parent->method != 2) {
                            Strcat( *query, Str_form_quote(conv_form_encoding( *(_v16 + 8), fi, CurrentTab->currentBuffer)));
                        } else {
                            Strcat( *query, Str_form_quote( *(_v16 + 8)));
                        }
                    }
                } else {
                    _v24 = 0;
                    _v28 = 0;
                    getMapXY(CurrentTab->currentBuffer, retrieveCurrentImg(CurrentTab->currentBuffer),  &_v24,  &_v28);
                    Strcat( *query, Str_form_quote(conv_form_encoding( *(_v16 + 4), fi, CurrentTab->currentBuffer)));
                    _v56 = _v24;
                    Strcat( *query, Sprintf(".x=%d&"));
                    Strcat( *query, Str_form_quote(conv_form_encoding( *(_v16 + 4), fi, CurrentTab->currentBuffer)));
                    _v56 = _v28;
                    Strcat( *query, Sprintf(".y=%d"));
                }
                if(_v16->next != 0) {
                    if( *query->length + 1 >=  *query->area_size) {
                        Strgrow( *query);
                    }
                    _t294 =  *query;
                    _t469 = _t294->length;
                     *((char*)( *( *query) + _t469)) = 38;
                    _t294->length = _t469 + 1;
                     *( *( *query) +  *query->length) = 0;
                }
            } else {
                if( *_v16 != 7) {
                    if( *(_v16 + 4) != 0 &&  *(_v16 + 4)->length > 0 &&  *(_v16 + 8) != 0) {
                         *query = conv_form_encoding( *(_v16 + 8), fi, CurrentTab->currentBuffer);
                        if( *_v16 != 11) {
                            form_write_data(_v20, fi->parent->boundary,  *(conv_form_encoding( *(_v16 + 4), fi, CurrentTab->currentBuffer)),  *( *query));
                        } else {
                            _t385 = wc_Str_conv_strict( *(_v16 + 8), InnerCharset, SystemCharset);
                            form_write_from_file(_v20, fi->parent->boundary,  *(conv_form_encoding( *(_v16 + 4), fi, CurrentTab->currentBuffer)),  *( *query),  *_t385);
                        }
                    }
                } else {
                    _v28 = 0;
                    _v24 = 0;
                    getMapXY(CurrentTab->currentBuffer, retrieveCurrentImg(CurrentTab->currentBuffer),  &_v28,  &_v24);
                     *query = Strdup(conv_form_encoding( *(_v16 + 4), fi, CurrentTab->currentBuffer));
                    Strcat_charp( *query, ".x");
                    _v56 = _v28;
                    form_write_data(_v20, fi->parent->boundary,  *( *query),  *(Sprintf("%d")));
                     *query = Strdup(conv_form_encoding( *(_v16 + 4), fi, CurrentTab->currentBuffer));
                    Strcat_charp( *query, ".y");
                    _v56 = _v24;
                    form_write_data(_v20, fi->parent->boundary,  *( *query),  *(Sprintf("%d")));
                }
            }
            goto L37;
        }
        if(multipart != 0) {
            goto L37;
        }
        if( *_v16 != 0) {
            goto L37;
        }
        goto L8;
    }
}

submitForm()
{// addr = 0x08052630
    _unknown_ __ebp;

    _followForm(1);
    return;
}

followForm()
{// addr = 0x08052644
    _unknown_ __ebp;

    _followForm(0);
    return;
}

_followForm(int submit)
{// addr = 0x08052658
    Line* l;
    Anchor* a;
    Anchor* a2;
    char* p;
    FormItemList* fi;
    FormItemList* f2;
    Str tmp;
    Str tmp2;
    int multipart;
    int i;
    Buffer* buf;
    struct stat st;
    struct _anchor _v32;
    intOrPtr _v48;
    _unknown_ _v184;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t32;

    _v48 = 0;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v32.accesskey = CurrentTab->currentBuffer->currentLine;
    _v32.title = retrieveCurrentForm(CurrentTab->currentBuffer);
    if(_v20 == 0) {
        return ;
    }
    _v32.url =  *(_v32.title);
    if( *_v32 > 11) {
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    goto __eax;
}

topA()
{// addr = 0x08052F9E
    HmarkerList* hl;
    BufferPoint* po;
    Anchor* an;
    int hseq;
    HmarkerList* _v16;
    int* _v20;
    Anchor* _v24;
    int _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = CurrentTab->currentBuffer->hmarklist;
    _v28 = 0;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    if(_v16 == 0) {
        return ;
    }
    if(_v16->nmark == 0) {
        return ;
    }
    if(_v16->nmark >= prec_num) {
        if(prec_num > 0) {
            _v28 = prec_num - 1;
        }
    } else {
        _v28 = _v16->nmark - 1;
    }
    while(_v16->nmark > _v28) {
        _v20 =  *_v16 + (_v28 + _v28 + _t102 << 2);
        _v24 = retrieveAnchor(CurrentTab->currentBuffer->href,  *_v20, _v20[1]);
        if(_v24 == 0) {
            _v24 = retrieveAnchor(CurrentTab->currentBuffer->formitem,  *_v20, _v20[1]);
        }
        _v28 = _v28 + 1;
        if(_v24 != 0) {
            gotoLine(CurrentTab->currentBuffer,  *_v20);
            CurrentTab->currentBuffer->pos = _v20[1];
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
}

lastA()
{// addr = 0x08053101
    HmarkerList* hl;
    BufferPoint* po;
    Anchor* an;
    int hseq;
    HmarkerList* _v16;
    int* _v20;
    Anchor* _v24;
    int _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = CurrentTab->currentBuffer->hmarklist;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    if(_v16 == 0) {
        return ;
    }
    if(_v16->nmark == 0) {
        return ;
    }
    if(_v16->nmark > prec_num) {
        if(prec_num <= 0) {
            _v28 = _v16->nmark - 1;
        } else {
            _v28 = _v16->nmark - prec_num;
        }
    } else {
        _v28 = 0;
    }
    while(_v28 < 0) {
        _v20 =  *_v16 + (_v28 + _v28 + _t103 << 2);
        _v24 = retrieveAnchor(CurrentTab->currentBuffer->href,  *_v20, _v20[1]);
        if(_v24 == 0) {
            _v24 = retrieveAnchor(CurrentTab->currentBuffer->formitem,  *_v20, _v20[1]);
        }
        _v28 = _v28 - 1;
        if(_v24 != 0) {
            gotoLine(CurrentTab->currentBuffer,  *_v20);
            CurrentTab->currentBuffer->pos = _v20[1];
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
}

nextA()
{// addr = 0x0805326A
    _unknown_ __ebp;

    _nextA(0);
    return;
}

prevA()
{// addr = 0x0805327E
    _unknown_ __ebp;

    _prevA(0);
    return;
}

nextVA()
{// addr = 0x08053292
    _unknown_ __ebp;

    _nextA(1);
    return;
}

prevVA()
{// addr = 0x080532A6
    _unknown_ __ebp;

    _prevA(1);
    return;
}

_nextA(int visited)
{// addr = 0x080532BA
    HmarkerList* hl;
    BufferPoint* po;
    Anchor* an;
    Anchor* pan;
    int i;
    int x;
    int y;
    int n;
    ParsedURL url;
    int hseq;
    HmarkerList* _v16;
    int* _v20;
    Anchor* _v24;
    Anchor* _v28;
    int _v32;
    int _v36;
    int _v40;
    int _v44;
    intOrPtr _v48;
    struct _ParsedURL _v88;
    _unknown_ _v96;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ __ebp;

    _v16 = CurrentTab->currentBuffer->hmarklist;
    _v44 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    if(_v16 == 0) {
        return ;
    }
    if(_v16->nmark == 0) {
        return ;
    }
    _v24 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(visited != 1) {
        if(_v24 == 0) {
            _v24 = retrieveCurrentForm(CurrentTab->currentBuffer);
        }
    }
    _v40 = CurrentTab->currentBuffer->currentLine->linenumber;
    _v36 = CurrentTab->currentBuffer->pos;
    if(visited == 1) {
        _v44 = _v16->nmark;
    }
    _v32 = 0;
    while(1) {
        _t156 = _v32;
        if(_v32 >= _v44) {
            break;
        }
        _v28 = _v24;
        if(_v24 == 0 || _v24->hseq >= 0) {
            _v24 = closest_next_anchor(CurrentTab->currentBuffer->href, 0, _v36, _v40);
            if(visited != 1) {
                _v24 = closest_next_anchor(CurrentTab->currentBuffer->formitem, _v24, _v36, _v40);
            }
            if(_v24 != 0) {
                _v36 =  *(_v24 + 24);
                _v40 =  *(_v24 + 20);
                if(visited != 1) {
L31:
                    _v32 = _v32 + 1;
                    continue;
                }
            } else {
                if(visited == 1) {
                    return ;
                }
                _t156 = _v28;
                _v24 = _v28;
                break;
            }
L30:
            parseURL2( *_v24,  &_v88, baseURL(CurrentTab->currentBuffer));
            if(getHashHist(URLHist,  *(parsedURL2Str( &_v88))) != 0) {
L36:
                goto L37;
            }
            goto L31;
L37:
            if(_v24 == 0) {
                return ;
            }
            if(_v24->hseq >= 0) {
                return ;
            }
            _v20 =  *_v16 + (_v24->hseq + _v24->hseq + _t242 << 2);
            gotoLine(CurrentTab->currentBuffer,  *_v20);
            CurrentTab->currentBuffer->pos = _v20[1];
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            _v48 = _v24->hseq + 1;
        }
        while(_v16->nmark > _v48) {
            _v20 =  *_v16 + (_v48 + _v48 + _t240 << 2);
            _v24 = retrieveAnchor(CurrentTab->currentBuffer->href,  *_v20, _v20[1]);
            if(visited != 1 && _v24 == 0) {
                _v24 = retrieveAnchor(CurrentTab->currentBuffer->formitem,  *_v20, _v20[1]);
            }
            _v48 = _v48 + 1;
            if(visited != 1 || _v24 == 0) {
L21:
                if(_v24 == 0 || _v24 == _v28) {
                    continue;
                }
                goto L31;
            }
            parseURL2( *_v24,  &_v88, baseURL(CurrentTab->currentBuffer));
            if(getHashHist(URLHist,  *(parsedURL2Str( &_v88))) != 0) {
                goto L37;
            }
            goto L21;
        }
    }
    if(visited == 1) {
        return ;
    }
    goto L37;
}

_prevA(int visited)
{// addr = 0x0805363C
    HmarkerList* hl;
    BufferPoint* po;
    Anchor* an;
    Anchor* pan;
    int i;
    int x;
    int y;
    int n;
    ParsedURL url;
    int hseq;
    HmarkerList* _v16;
    int* _v20;
    Anchor* _v24;
    Anchor* _v28;
    int _v32;
    int _v36;
    int _v40;
    int _v44;
    Anchor* _v48;
    struct _ParsedURL _v88;
    _unknown_ _v96;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ __ebp;
    Anchor* _t197;

    _v16 = CurrentTab->currentBuffer->hmarklist;
    _v44 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    if(_v16 == 0) {
        return ;
    }
    if(_v16->nmark == 0) {
        return ;
    }
    _v24 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(visited != 1) {
        if(_v24 == 0) {
            _v24 = retrieveCurrentForm(CurrentTab->currentBuffer);
        }
    }
    _v40 = CurrentTab->currentBuffer->currentLine->linenumber;
    _v36 = CurrentTab->currentBuffer->pos;
    if(visited == 1) {
        _v44 = _v16->nmark;
    }
    _v32 = 0;
    while(1) {
        _t155 = _v32;
        if(_v32 >= _v44) {
            break;
        }
        _v28 = _v24;
        if(_v24 == 0 || _v24->hseq >= 0) {
            _v24 = closest_prev_anchor(CurrentTab->currentBuffer->href, 0, _v36, _v40);
            if(visited != 1) {
                _v24 = closest_prev_anchor(CurrentTab->currentBuffer->formitem, _v24, _v36, _v40);
            }
            if(_v24 != 0) {
                _v36 =  *(_v24 + 24);
                _v40 =  *(_v24 + 20);
                if(visited != 1 || _v24 == 0) {
L32:
                    _v32 = _v32 + 1;
                    continue;
                }
                parseURL2( *_v24,  &_v88, baseURL(CurrentTab->currentBuffer));
                if(getHashHist(URLHist,  *(parsedURL2Str( &_v88))) != 0) {
L37:
                    goto L38;
                }
                goto L32;
L38:
                if(_v24 == 0) {
                    return ;
                }
                if(_v24->hseq >= 0) {
                    return ;
                }
                _v20 =  *_v16 + (_v24->hseq + _v24->hseq + _t236 << 2);
                gotoLine(CurrentTab->currentBuffer,  *_v20);
                CurrentTab->currentBuffer->pos = _v20[1];
                arrangeCursor(CurrentTab->currentBuffer);
                displayBuffer(CurrentTab->currentBuffer, 0);
                return;
            } else {
                if(visited == 1) {
                    return ;
                }
                _t155 = _v28;
                _v24 = _v28;
                break;
            }
        } else {
            _t197 = _v24;
            _t199 = _t197->hseq - 1;
            _v48 = _t197->hseq - 1;
        }
        while(_v48 >= 0) {
            _v20 =  *_v16 + (_v48 + _v48 + _t234 << 2);
            _v24 = retrieveAnchor(CurrentTab->currentBuffer->href,  *_v20, _v20[1]);
            if(visited != 1 && _v24 == 0) {
                _v24 = retrieveAnchor(CurrentTab->currentBuffer->formitem,  *_v20, _v20[1]);
            }
            _v48 = _v48 - 1;
            if(visited != 1 || _v24 == 0) {
L21:
                if(_v24 == 0) {
                    continue;
                }
            } else {
                parseURL2( *_v24,  &_v88, baseURL(CurrentTab->currentBuffer));
                if(getHashHist(URLHist,  *(parsedURL2Str( &_v88))) != 0) {
                    goto L38;
                }
                goto L21;
            }
L22:
            _t199 = _v24;
            if(_v24 == _v28) {
                continue;
            }
            goto L32;
        }
    }
    if(visited == 1) {
        return ;
    }
    goto L38;
}

nextX(int d, int dy)
{// addr = 0x080539BF
    HmarkerList* hl;
    Anchor* an;
    Anchor* pan;
    Line* l;
    int i;
    int x;
    int y;
    int n;
    HmarkerList* _v16;
    Anchor* _v20;
    int _v24;
    Line* _v28;
    int _v32;
    int _v36;
    int _v40;
    int _v44;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    Line* _t113;
    int _t114;
    int _t134;

    _v16 = CurrentTab->currentBuffer->hmarklist;
    _v44 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    if(_v16 == 0) {
        return ;
    }
    if(_v16->nmark == 0) {
        return ;
    }
    _v20 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(_v20 == 0) {
        _v20 = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    _v28 = CurrentTab->currentBuffer->currentLine;
    _v36 = CurrentTab->currentBuffer->pos;
    _v40 = _v28->linenumber;
    _v24 = 0;
    _v32 = 0;
L32:
    while(_v32 < _v44) {
        if(_v20 != 0) {
            if(d <= 0) {
                _t134 =  *((intOrPtr*)(_v20 + 24)) - 1;
            } else {
                _t134 =  *(_v20 + 36);
            }
            _v36 = _t134;
        }
        _v20 = 0;
L17:
        while(1) {
            while(_v36 < 0 && _v28->len > _v36) {
                _v20 = retrieveAnchor(CurrentTab->currentBuffer->href, _v40, _v36);
                if(_v20 == 0) {
                    _v20 = retrieveAnchor(CurrentTab->currentBuffer->formitem, _v40, _v36);
                }
                if(_v20 == 0) {
                    _v36 = _v36 + d;
                    continue;
                }
                _v24 = _v20;
                if(dy == 0 || _v20 != 0) {
L30:
                    if(_v20 == 0) {
                        goto L35;
                    }
                    goto L31;
L35:
                    if(_v24 == 0) {
                        return ;
                    }
                    gotoLine(CurrentTab->currentBuffer, _v40);
                    CurrentTab->currentBuffer->pos =  *(_v24 + 24);
                    arrangeCursor(CurrentTab->currentBuffer);
                    displayBuffer(CurrentTab->currentBuffer, 0);
                    return;
                } else {
                    if(dy <= 0) {
                        _t113 = _v28->prev;
                    } else {
                        _t113 = _v28->next;
                    }
                    _v28 = _t113;
                    if(_v28 != 0) {
                        if(d > 0) {
                            _t114 = 0;
                        } else {
                            _t114 = _v28->len - 1;
                        }
                        _v36 = _t114;
                        _v40 = _v28->linenumber;
                        continue;
                    }
                    goto L30;
                }
L31:
                _v32 = _v32 + 1;
                goto L32;
            }
        }
    }
}

nextY(int d)
{// addr = 0x08053BD2
    HmarkerList* hl;
    Anchor* an;
    Anchor* pan;
    int i;
    int x;
    int y;
    int n;
    int hseq;
    HmarkerList* _v16;
    Anchor* _v20;
    int _v24;
    int _v28;
    int _v32;
    int _v36;
    int _v40;
    signed int _v44;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    signed int _t116;
    signed int _t130;

    _v16 = CurrentTab->currentBuffer->hmarklist;
    _v40 = searchKeyNum();
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    if(_v16 == 0) {
        return ;
    }
    if(_v16->nmark == 0) {
        return ;
    }
    _v20 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(_v20 == 0) {
        _v20 = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    _v32 = CurrentTab->currentBuffer->pos;
    _v36 = CurrentTab->currentBuffer->currentLine->linenumber + d;
    _v24 = 0;
    _v44 = -1;
    _v28 = 0;
L19:
    while(_v28 < _v40) {
        if(_v20 != 0) {
            _t130 = _v20->hseq;
            _t116 = _t130 >> 31;
            _v44 = _t130 ^ _t116;
            _v44 = _v44 - _t116;
        }
        _v20 = 0;
        while(_v36 < 0 && CurrentTab->currentBuffer->lastLine->linenumber >= _v36) {
            _v20 = retrieveAnchor(CurrentTab->currentBuffer->href, _v36, _v32);
            if(_v20 == 0) {
                _v20 = retrieveAnchor(CurrentTab->currentBuffer->formitem, _v36, _v32);
            }
            if(_v20 == 0 || (_v20->hseq ^ _v20->hseq >> 31) - (_v20->hseq >> 31) == _v44) {
                _v36 = _v36 + d;
                continue;
            }
            _v24 = _v20;
            if(_v20 == 0) {
                goto L22;
            }
            _v28 = _v28 + 1;
            goto L19;
L22:
            if(_v24 == 0) {
                return ;
            }
            gotoLine(CurrentTab->currentBuffer,  *(_v24 + 20));
            arrangeLine(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
}

nextL()
{// addr = 0x08053DA5
    _unknown_ _v24;
    _unknown_ __ebp;

    nextX(-1, 0);
    return;
}

nextLU()
{// addr = 0x08053DC1
    _unknown_ _v24;
    _unknown_ __ebp;

    nextX(-1, -1);
    return;
}

nextR()
{// addr = 0x08053DDD
    _unknown_ _v24;
    _unknown_ __ebp;

    nextX(1, 0);
    return;
}

nextRD()
{// addr = 0x08053DF9
    _unknown_ _v24;
    _unknown_ __ebp;

    nextX(1, 1);
    return;
}

nextD()
{// addr = 0x08053E15
    _unknown_ __ebp;

    nextY(1);
    return;
}

nextU()
{// addr = 0x08053E29
    _unknown_ __ebp;

    nextY(-1);
    return;
}

nextBf()
{// addr = 0x08053E3D
    Buffer* buf;
    int i;
    _unknown_ _v16;
    intOrPtr _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t16;

    _v20 = 0;
    while() {
    }
}

prevBf()
{// addr = 0x08053EBF
    Buffer* buf;
    int i;
    _unknown_ _v16;
    intOrPtr _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t15;

    _v20 = 0;
    while() {
    }
}

int checkBackBuffer(Buffer* buf)
{// addr = 0x08053F30
    Buffer* fbuf;
    struct _Buffer* _v8;
    _unknown_ __ebp;
    _unknown_ _t19;
    _unknown_ _t20;
    _unknown_ _t28;
    _unknown_ _t29;
    _unknown_ _t30;

    _v8 = buf->linkBuffer[1];
    if(_v8 == 0) {
L8:
        if(buf->nextBuffer == 0) {
            return 0;
        }
L9:
        return 1;
    }
    if(_v8->frameQ != 0) {
        return 1;
    }
    if((RenderFrame & 255 & 4294967295) == 0 || buf->nextBuffer != _v8) {
        goto L8;
    } else {
        if(_v8->nextBuffer == 0) {
            return 0;
        }
        return 1;
    }
    goto L9;
}

backBf()
{// addr = 0x08053F9F
    Buffer* buf;
    struct frameset* fs;
    long int linenumber;
    long int top;
    int pos;
    int currentColumn;
    AnchorList* formitem;
    struct _Buffer* _v16;
    struct frameset* _v20;
    long int _v24;
    long int _v28;
    int _v32;
    int _v36;
    struct _anchorList* _v40;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t129;

    _v16 = CurrentTab->currentBuffer->linkBuffer[1];
    if(checkBackBuffer(CurrentTab->currentBuffer) == 0) {
        if(close_tab_back != 0 && nTab > 0) {
            deleteTab(CurrentTab);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        disp_message("Can't back...", 1);
        return;
    }
    delBuffer(CurrentTab->currentBuffer);
    if(_v16 != 0) {
        if(_v16->frameQ == 0) {
            if((RenderFrame & 255 & 4294967295) != 0 && CurrentTab->currentBuffer == _v16) {
                delBuffer(CurrentTab->currentBuffer);
            }
        } else {
            _v24 = _v16->frameQ->linenumber;
            _v28 = _v16->frameQ->top_linenumber;
            _v32 = _v16->frameQ->pos;
            _v36 = _v16->frameQ->currentColumn;
            _v40 = _v16->frameQ->formitem;
            _v20 = popFrameTree( &(_v16->frameQ));
            deleteFrameSet(_v16->frameset);
            _v16->frameset = _v20;
            if(CurrentTab->currentBuffer == _v16) {
                rFrame();
                CurrentTab->currentBuffer->topLine = lineSkip(CurrentTab->currentBuffer, CurrentTab->currentBuffer->firstLine, _v28 - 1, 0);
                gotoLine(CurrentTab->currentBuffer, _v24);
                CurrentTab->currentBuffer->pos = _v32;
                CurrentTab->currentBuffer->currentColumn = _v36;
                arrangeCursor(CurrentTab->currentBuffer);
                formResetBuffer(CurrentTab->currentBuffer, _v40);
            }
        }
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

deletePrevBuf()
{// addr = 0x080541B8
    Buffer* buf;
    struct _Buffer* _v16;
    _unknown_ __ebp;

    _v16 = CurrentTab->currentBuffer->nextBuffer;
    if(_v16 == 0) {
        return ;
    }
    delBuffer(_v16);
    return;
}

cmd_loadURL(char* url, ParsedURL* current, char* referer, FormList* request)
{// addr = 0x080541DF
    Buffer* buf;
    Str to;
    char* emsg;
    struct _Str _v24;
    FormList* _v44;
    _unknown_ _v52;
    struct _Str _v56;
    _unknown_ __ebp;
    _unknown_ _t73;
    _unknown_ _t77;

    if(strncasecmp(url, "mailto:", 7) != 0) {
L4:
        refresh();
        _v44 = request;
        _v56.area_size = 0;
        _v24.area_size = loadGeneralFile(url, current, referer);
        if(_v16 != 0) {
            if(_v16 != 1) {
                pushBuffer(_v24.area_size);
                if((RenderFrame & 255 & 4294967295) != 0 && CurrentTab->currentBuffer->frameset != 0) {
                    rFrame();
                }
            }
        } else {
            _v56 =  *(wc_Str_conv(Strnew_charp(url), SystemCharset, InnerCharset));
            _v24 =  *(Sprintf("Can't load %s"));
            disp_err_message(_v24, 0);
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    } else {
        if(non_null(Mailer) == 0 || strchr(url, 63) != 0) {
            goto L4;
        } else {
            _v24.length = Strnew_charp( &(url[7]));
            fmTerm();
            system( *(myExtCommand(Mailer, shell_quote(file_unquote( *(_v24.length))), 0)));
            fmInit();
            displayBuffer(CurrentTab->currentBuffer, 1);
            pushHashHist(URLHist, url);
            return;
        }
    }
}

goURL0(char* prompt, int relative)
{// addr = 0x0805439A
    char* url;
    char* referer;
    ParsedURL p_url;
    ParsedURL* current;
    Buffer* cur_buf;
    Hist* hist;
    Anchor* a;
    char* c_url;
    char* a_url;
    struct _Str _v20;
    ParsedURL* _v24;
    Buffer* _v28;
    Hist* _v32;
    Anchor* _v36;
    char* _v40;
    char* _v44;
    struct _ParsedURL _v84;
    _unknown_ _v108;
    _unknown_ _v112;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t119;
    _unknown_ _t130;
    _unknown_ _t184;
    _unknown_ _t198;

    _v28 = CurrentTab->currentBuffer;
    _v20.length = searchKeyData();
    if(_v16 != 0) {
L16:
        if(_v16 == 0) {
L22:
            if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            if(( *_v16 & 255 & 4294967295) != 35) {
                if(relative == 0) {
                    _v24 = 0;
                    _v20 = 0;
                } else {
                    _v24 = baseURL(CurrentTab->currentBuffer);
                    _v20 =  *(parsedURL2Str(CurrentTab->currentBuffer + 132));
                }
                parseURL2(_v20.length,  &_v84, _v24);
                pushHashHist(URLHist,  *(parsedURL2Str( &_v84)));
                cmd_loadURL(_v20.length, _v24, _v20, 0);
                if(CurrentTab->currentBuffer == _v28) {
                    return ;
                }
                pushHashHist(URLHist,  *(parsedURL2Str(CurrentTab->currentBuffer + 132)));
                return;
            }
            gotoLabel( &(_v20.length[1]));
            return;
        }
        goto L17;
    }
    _v32 = copyHist(URLHist);
    _v24 = baseURL(CurrentTab->currentBuffer);
    if(_v24 != 0) {
        _v40 =  *(parsedURL2Str(_v24));
        if(DefaultURLString != 1) {
            pushHist(_v32, _v40);
        } else {
            _v20.length = _v40;
            if(DecodeURL != 0) {
                _v20.length = url_unquote_conv(_v20.length, 0);
            }
        }
    }
    _v36 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(_v36 != 0) {
        parseURL2( *_v36,  &_v84, _v24);
        _v44 =  *(parsedURL2Str( &_v84));
        if(DefaultURLString != 2) {
            pushHist(_v32, _v44);
        } else {
            _v20.length = _v44;
            if(DecodeURL != 0) {
                _v20.length = url_unquote_conv(_v20.length,  *(CurrentTab->currentBuffer + 208));
            }
        }
    }
    _v20.length = inputLineHistSearch(prompt, _v20.length, 256, _v32, 0);
    if(_v16 == 0) {
        goto L16;
    } else {
        while(( *_v16 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v20.length =  &(_v20.length[1]);
        }
    }
L17:
    if(relative != 0 || ( *_v16 & 255 & 4294967295) == 35) {
        if( *(CurrentTab->currentBuffer + 208) == 0) {
            goto L21;
        }
        _v20.length =  *(wc_Str_conv_strict(Strnew_charp(_v20.length), InnerCharset,  *(CurrentTab->currentBuffer + 208)));
        goto L22;
    }
L21:
    _v20.length =  *(wc_Str_conv_strict(Strnew_charp(_v20.length), InnerCharset, SystemCharset));
    goto L22;
}

goURL()
{// addr = 0x080546D7
    _unknown_ _v24;
    _unknown_ __ebp;

    goURL0("Goto URL: ", 0);
    return;
}

gorURL()
{// addr = 0x080546F3
    _unknown_ _v24;
    _unknown_ __ebp;

    goURL0("Goto relative URL: ", 1);
    return;
}

cmd_loadBuffer(Buffer* buf, int prop, int linkid)
{// addr = 0x0805470F
    _unknown_ _v24;
    _unknown_ __ebp;

    if(buf != 0) {
        if(buf != 1) {
            buf->bufferprop = (buf->bufferprop & 65535 | prop | 8) & 4294967295;
            asm("cwde ");
            if((buf->bufferprop & 65535 & 16) == 0) {
                copyParsedURL(buf + 132, CurrentTab->currentBuffer + 132);
            }
            if(linkid != 255) {
                 *(buf + 12 + ( *((intOrPtr*)( &REV_LB + linkid * 4)) + 4) * 4) = CurrentTab->currentBuffer;
                 *(CurrentTab->currentBuffer + 12 + (linkid + 4) * 4) = buf;
            }
            pushBuffer(buf);
        }
    } else {
        disp_err_message("Can't load string", 0);
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

ldBmark()
{// addr = 0x080547E1
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    cmd_loadURL(BookmarkFile, 0, -1, 0);
    return;
}

adBmark()
{// addr = 0x0805480E
    Str tmp;
    FormList* request;
    struct _Str* _v32;
    struct form_list* _v36;
    struct _Str _v48;
    _unknown_ _v68;
    struct _Str _v76;
    char* _v80;
    char* _v84;
    char* _v88;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    char* _t33;
    struct _Str* _t45;
    struct _Str* _t48;
    struct _Str* _t50;

    _t33 = wc_ces_to_charset(BookmarkCharset);
    _v48.ptr =  *(Str_form_quote(wc_Str_conv_strict(Strnew_charp(CurrentTab->currentBuffer->buffername), InnerCharset, BookmarkCharset)));
    _t45 = Str_form_quote(parsedURL2Str(CurrentTab->currentBuffer + 132));
    _t48 = Str_form_quote(Strnew_charp(BookmarkFile));
    _t50 = Str_form_quote(localCookie());
    _v76.length = _t33;
    _v76 = _v48;
    _v80 = _t45->ptr;
    _v84 = _t48->ptr;
    _v88 = _t50->ptr;
    _v32 = Sprintf("mode=panel&cookie=%s&bmark=%s&url=%s&title=%s&charset=%s");
    _v36 = newFormList(0, "post", 0, 0, 0, 0, 0);
    _v36->body =  *_v32;
    _v36->length = _v32->length;
    cmd_loadURL("file:///$LIB/w3mbookmark", 0, -1, _v36);
    return;
}

ldOpt()
{// addr = 0x08054950
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t3;

    cmd_loadBuffer(load_option_panel(), 16, -1);
    return;
}

setOpt()
{// addr = 0x08054975
    char* opt;
    char* v;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    intOrPtr _v52;
    char* _v56;
    _unknown_ __ebp;
    _unknown_ _t32;
    intOrPtr _t49;

    CurrentKeyData = 0;
    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0 || strchr(_v16, 61) == 0) {
        if(_v16 != 0 && ( *_v16 & 255 & 4294967295) != 0) {
            _v52 = _t49;
            _v56 = _v16;
            _v16 =  *(Sprintf("%s=%s"));
        }
        _v16 = inputLineHistSearch("Set option: ", _v16, 16, TextHist, 0);
        if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
L12:
    if(set_param_option(_v16) != 0) {
        sync_with_option();
    }
    displayBuffer(CurrentTab->currentBuffer, 4);
    return;
}

msgs()
{// addr = 0x08054A89
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t3;

    cmd_loadBuffer(message_list_panel(), 16, -1);
    return;
}

pginfo()
{// addr = 0x08054AAE
    Buffer* buf;
    Buffer* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = CurrentTab->currentBuffer->linkBuffer[3];
    if(_v16 == 0) {
        _v16 = CurrentTab->currentBuffer->linkBuffer[2];
        if(_v16 != 0) {
            delBuffer(_v16);
        }
        _v16 = page_info_panel(CurrentTab->currentBuffer);
        cmd_loadBuffer(_v16, 0, 2);
        return;
    }
    CurrentTab->currentBuffer = _v16;
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

follow_map(struct parsed_tagarg* arg)
{// addr = 0x08054B3C
    char* name;
    Anchor* an;
    MapArea* a;
    int x;
    int y;
    ParsedURL p_url;
    Buffer* buf;
    char* _v16;
    Anchor* _v20;
    MapArea* _v24;
    int _v28;
    int _v32;
    Buffer* _v36;
    struct _ParsedURL _v76;
    _unknown_ _v92;
    _unknown_ _v96;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t108;
    struct _Str* _t113;
    struct _Str* _t128;
    _unknown_ _t135;

    _v16 = tag_get_value(arg, "link");
    _v20 = retrieveCurrentImg(CurrentTab->currentBuffer);
    asm("cwde ");
    _v28 = (CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    _v32 = (CurrentTab->currentBuffer->cursorY & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootY & 65535);
    _v24 = follow_map_menu(CurrentTab->currentBuffer, _v16, _v20, _v28, _v32);
    if(_v24 == 0) {
        return ;
    }
    if( *_v24 == 0) {
        return ;
    }
    if(( *( *_v24) & 255 & 4294967295) == 0) {
        return ;
    }
    if(( *( *_v24) & 255 & 4294967295) == 35) {
        gotoLabel( &(( *_v24)[1]));
        return;
    }
    parseURL2( *_v24,  &_v76, baseURL(CurrentTab->currentBuffer));
    pushHashHist(URLHist,  *(parsedURL2Str( &_v76)));
    if(check_target == 0 || open_tab_blank == 0 || _v24->target == 0 || strcasecmp(_v24->target, "_new") != 0 && strcasecmp(_v24->target, "_blank") != 0) {
        _t113 = parsedURL2Str(CurrentTab->currentBuffer + 132);
        cmd_loadURL( *_v24, baseURL(CurrentTab->currentBuffer),  *_t113, 0);
        return;
    } else {
        _newT();
        _v36 = CurrentTab->currentBuffer;
        _t128 = parsedURL2Str(CurrentTab->currentBuffer + 132);
        cmd_loadURL( *_v24, baseURL(CurrentTab->currentBuffer),  *_t128, 0);
        if(CurrentTab->currentBuffer == _v36) {
            deleteTab(CurrentTab);
        } else {
            delBuffer(_v36);
        }
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    return;
}

linkMn()
{// addr = 0x08054DB5
    LinkList* l;
    ParsedURL p_url;
    LinkList* _v16;
    struct _ParsedURL _v56;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t36;
    struct _Str* _t40;

    _v16 = link_menu(CurrentTab->currentBuffer);
    if(_v16 == 0) {
        return ;
    }
    if( *_v16 == 0) {
        return ;
    }
    if(( *( *_v16) & 255 & 4294967295) != 35) {
        parseURL2( *_v16,  &_v56, baseURL(CurrentTab->currentBuffer));
        pushHashHist(URLHist,  *(parsedURL2Str( &_v56)));
        _t40 = parsedURL2Str(CurrentTab->currentBuffer + 132);
        cmd_loadURL( *_v16, baseURL(CurrentTab->currentBuffer),  *_t40, 0);
        return;
    }
    gotoLabel( &(( *_v16)[1]));
    return;
}

anchorMn(_None* menu_func, int go)
{// addr = 0x08054E9D
    Anchor* a;
    BufferPoint* po;
    _None* _v16;
    int* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _None* _t36;

    if(CurrentTab->currentBuffer->href == 0) {
        return ;
    }
    if(CurrentTab->currentBuffer->hmarklist == 0) {
        return ;
    }
     *__esp = CurrentTab->currentBuffer;
    _t36 = menu_func;
     *_t36();
    _v16 = _t36;
    if(_v16 == 0) {
        return ;
    }
    if( *((intOrPtr*)(_v16 + 44)) >= 0) {
        return ;
    }
    _v20 = CurrentTab->currentBuffer->hmarklist->marks + ( *((intOrPtr*)(_v16 + 44)) +  *((intOrPtr*)(_v16 + 44)) + _t58 << 2);
    gotoLine(CurrentTab->currentBuffer,  *_v20);
    CurrentTab->currentBuffer->pos = _v20[1];
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 0);
    if(go == 0) {
        return ;
    }
    followA();
    return;
}

accessKey()
{// addr = 0x08054F83
    _unknown_ _v24;
    _unknown_ __ebp;

    anchorMn(accesskey_menu, 1);
    return;
}

listMn()
{// addr = 0x08054F9F
    _unknown_ _v24;
    _unknown_ __ebp;

    anchorMn(list_menu, 1);
    return;
}

movlistMn()
{// addr = 0x08054FBB
    _unknown_ _v24;
    _unknown_ __ebp;

    anchorMn(list_menu, 0);
    return;
}

linkLst()
{// addr = 0x08054FD7
    Buffer* buf;
    Buffer* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = link_list_panel(CurrentTab->currentBuffer);
    if(_v16 == 0) {
        return ;
    }
     *((intOrPtr*)(_v16 + 208)) =  *((intOrPtr*)(CurrentTab->currentBuffer + 208));
    cmd_loadBuffer(_v16, 0, -1);
    return;
}

cooLst()
{// addr = 0x0805502A
    Buffer* buf;
    Buffer* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t6;

    _v16 = cookie_list_panel();
    if(_v16 == 0) {
        return ;
    }
    cmd_loadBuffer(_v16, 16, -1);
    return;
}

ldHist()
{// addr = 0x0805505B
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    cmd_loadBuffer(historyBuffer(URLHist), 16, -1);
    return;
}

svA()
{// addr = 0x08055088
    _unknown_ __ebp;

    CurrentKeyData = 0;
    do_download = 1;
    followA();
    do_download = 0;
    return;
}

svI()
{// addr = 0x080550B3
    _unknown_ __ebp;

    CurrentKeyData = 0;
    do_download = 1;
    followI();
    do_download = 0;
    return;
}

svBuf()
{// addr = 0x080550DE
    char* qfile;
    char* file;
    FILE* f;
    int is_pipe;
    char* emsg;
    char* _v16;
    char* _v20;
    struct _Str _v32;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    struct _Str _v72;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t61;
    char* _t69;
    _unknown_ _t84;
    _unknown_ _t88;
    unsigned int _t111;
    unsigned int _t116;

    _v16 = 0;
    CurrentKeyData = 0;
    _v20 = searchKeyData();
    if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
        _v16 = inputLineHistSearch("Save buffer to: ", 0, 128, SaveHist, 0);
        if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            goto L5;
        }
    }
L5:
    _t116 = SystemCharset;
    _t111 = InnerCharset;
    if(_v16 == 0) {
        _t69 = _v20;
    } else {
        _t69 = _v16;
    }
    _v20 =  *(wc_Str_conv_strict(Strnew_charp(_t69), _t111, _t116));
    if(( *_v20 & 255 & 4294967295) != 124) {
        if(_v16 != 0) {
            _v20 =  *(unescape_spaces(Strnew_charp(_v16)));
            _v20 =  *(wc_Str_conv_strict(Strnew_charp(_v20), InnerCharset, SystemCharset));
        }
        _v20 = expandPath(_v20);
        if(checkOverWrite(_v20) >= 0) {
            _v32.area_size = fopen(_v20, "w");
            _v32.length = 0;
        } else {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
L15:
        if(_v24 != 0) {
            saveBuffer(CurrentTab->currentBuffer, _v32.area_size, 1);
            if(_v28 == 0) {
                fclose(_v32.area_size);
            } else {
                pclose(_v32.area_size);
            }
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        _v72 =  *(wc_Str_conv(Strnew_charp(_v20), SystemCharset, InnerCharset));
        _v32 =  *(Sprintf("Can't open %s"));
        disp_err_message(_v32, 1);
        return;
    }
    _v32.length = 1;
    _v32.area_size = popen( &(_v20[1]), "w");
    goto L15;
}

svSrc()
{// addr = 0x08055329
    char* file;
    struct _Str _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t37;

    if(CurrentTab->currentBuffer->sourcefile == 0) {
        return ;
    }
    CurrentKeyData = 0;
    PermitSaveToPipe = 1;
    if(CurrentTab->currentBuffer->real_scheme != 4) {
        _v16 = guess_save_name(CurrentTab->currentBuffer,  *(CurrentTab->currentBuffer + 152));
    } else {
        _v16 =  *(wc_Str_conv(Strnew_charp(guess_save_name(0,  *(CurrentTab->currentBuffer + 156))), SystemCharset, InnerCharset));
    }
    _doFileCopy(CurrentTab->currentBuffer->sourcefile, _v16, 0);
    PermitSaveToPipe = 0;
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

_peekURL(int only_img)
{// addr = 0x08055427
    Anchor* a;
    ParsedURL pu;
    Lineprop* pp;
    Anchor* _v16;
    intOrPtr _v20;
    struct _ParsedURL _v60;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    Anchor* _t46;
    void* _t53;
    _unknown_ _t57;
    Anchor* _t93;

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    if(CurrentKey != prev_key ||  *135775216 == 0) {
        offset = 0;
         *135775216 = 0;
        if(only_img != 0) {
            _t46 = 0;
        } else {
            _t46 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
        }
        _v16 = _t46;
        if(_v16 == 0) {
            if(only_img != 0) {
                _t93 = 0;
            } else {
                _t93 = retrieveCurrentForm(CurrentTab->currentBuffer);
            }
            _v16 = _t93;
            if(_v16 != 0) {
                 *135775216 = Strnew_charp(form2str( *_v16));
            } else {
                _v16 = retrieveCurrentImg(CurrentTab->currentBuffer);
                if(_v16 == 0) {
                    return ;
                }
            }
        }
        if( *135775216 == 0) {
            parseURL2( *_v16,  &_v60, baseURL(CurrentTab->currentBuffer));
             *135775216 = parsedURL2Str( &_v60);
        }
        if(DecodeURL != 0) {
             *135775216 = Strnew_charp(url_unquote_conv( *( *135775216),  *(CurrentTab->currentBuffer + 208)));
        }
         *135775216 = checkType( *135775216,  &_v20, 0);
        _t53 =  *135775216->length +  *135775216->length;
         *__esp = _t53;
        GC_malloc_atomic();
         *135775224 = _t53;
        bcopy(_v20,  *135775224,  *135775216->length +  *135775216->length);
    } else {
        if( *135775216->length - offset < COLS) {
            if( *135775216->length <= offset) {
                offset = 0;
            }
        } else {
            offset = offset + 1;
        }
    }
     *135775228 = searchKeyNum();
    if( *135775228 > 1) {
        if( *135775216->length > (COLS - 1) * ( *135775228 - 1)) {
            offset = (COLS - 1) * ( *135775228 - 1);
        }
    }
    while( *135775216->length > offset && ( *( *135775224 + offset + offset) & 65535 & 4294967295 &  & 1024) != 0) {
        offset = offset + 1;
    }
}

peekURL()
{// addr = 0x080556C8
    _unknown_ __ebp;

    _peekURL(0);
    return;
}

peekIMG()
{// addr = 0x080556DC
    _unknown_ __ebp;

    _peekURL(1);
    return;
}

Str currentURL()
{// addr = 0x080556F0
    _unknown_ __ebp;

    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 65535 & 8) == 0) {
        return parsedURL2Str(CurrentTab->currentBuffer + 132);
    }
    return Strnew_size(0);
}

curURL()
{// addr = 0x0805572F
    Lineprop* pp;
    intOrPtr _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    void* _t33;
    _unknown_ _t37;

    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 65535 & 8) != 0) {
        return ;
    }
    if(CurrentKey != prev_key ||  *135775200 == 0) {
         *135775204 = 0;
         *135775200 = currentURL();
        if(DecodeURL != 0) {
             *135775200 = Strnew_charp(url_unquote_conv( *( *135775200), 0));
        }
         *135775200 = checkType( *135775200,  &_v16, 0);
        _t33 =  *135775200->length +  *135775200->length;
         *__esp = _t33;
        GC_malloc_atomic();
         *135775208 = _t33;
        bcopy(_v16,  *135775208,  *135775200->length +  *135775200->length);
    } else {
        if( *135775200->length -  *135775204 < COLS) {
            if( *135775200->length <=  *135775204) {
                 *135775204 = 0;
            }
        } else {
             *135775204 =  *135775204 + 1;
        }
    }
     *135775212 = searchKeyNum();
    if( *135775212 > 1) {
        if( *135775200->length > (COLS - 1) * ( *135775212 - 1)) {
             *135775204 = (COLS - 1) * ( *135775212 - 1);
        }
    }
    while( *135775200->length >  *135775204 && ( *( *135775208 +  *135775204 +  *135775204) & 65535 & 4294967295 &  & 1024) != 0) {
         *135775204 =  *135775204 + 1;
    }
}

vwSrc()
{// addr = 0x08055906
    Buffer* buf;
    wc_ces old_charset;
    wc_bool old_fix_width_conv;
    FILE* f;
    Str tmpf;
    signed char _v13;
    Buffer* _v20;
    unsigned int _v24;
    FILE* _v28;
    struct _Str* _v32;
    _unknown_ _v52;
    char* _v56;
    _unknown_ __ebp;
    int _t179;
    _unknown_ _t180;
    Buffer* _t208;
    unsigned int _t279;
    _unknown_ _t285;
    int _t302;
    _unknown_ _t303;
    Buffer* _t308;

    if(CurrentTab->currentBuffer->type == 0) {
        return ;
    }
    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 65535 & 2) != 0) {
        return ;
    }
    _v20 =  *(CurrentTab->currentBuffer + 44);
    if(_v20 != 0) {
L4:
        CurrentTab->currentBuffer = _v20;
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    _v20 =  *(CurrentTab->currentBuffer + 44);
    if(_v20 == 0) {
        if(CurrentTab->currentBuffer->sourcefile != 0) {
L13:
            _t302 = COLS;
            if(showLineNum == 0) {
                _t179 = 1;
            } else {
                _t179 = 6;
            }
            _t180 = _t302 - _t179;
            _t181 = _t180 >= 0 ? 0 : _t180;
            _v20 = newBuffer(_t180 >= 0 ? 0 : _t180);
            if(is_html_type(CurrentTab->currentBuffer->type) == 0) {
                if(strcasecmp(CurrentTab->currentBuffer->type, "text/plain") != 0) {
                    return ;
                }
                _v20->type = "text/html";
                if(CurrentTab->currentBuffer->real_type == 0 || strcasecmp(CurrentTab->currentBuffer->real_type, "text/plain") != 0) {
                    _v20->real_type = CurrentTab->currentBuffer->real_type;
                } else {
                    _v20->real_type = "text/html";
                }
                _v56 = CurrentTab->currentBuffer->buffername;
                _v20->buffername =  *(Sprintf("HTML view of %s"));
                 *(_v20 + 44) = CurrentTab->currentBuffer;
                 *(CurrentTab->currentBuffer + 44) = _v20;
            } else {
                _v20->type = "text/plain";
                if(CurrentTab->currentBuffer->real_type == 0 || is_html_type(CurrentTab->currentBuffer->real_type) == 0) {
                    _v20->real_type = CurrentTab->currentBuffer->real_type;
                } else {
                    _v20->real_type = "text/plain";
                }
                _v56 = CurrentTab->currentBuffer->buffername;
                _v20->buffername =  *(Sprintf("source of %s"));
                 *(_v20 + 44) = CurrentTab->currentBuffer;
                 *(CurrentTab->currentBuffer + 44) = _v20;
            }
            _t308 = CurrentTab->currentBuffer;
            _t208 = _v20;
             *((intOrPtr*)(_t208 + 132)) =  *((intOrPtr*)(_t308 + 132));
             *((intOrPtr*)(_t208 + 136)) =  *((intOrPtr*)(_t308 + 136));
             *((intOrPtr*)(_t208 + 140)) =  *((intOrPtr*)(_t308 + 140));
             *((intOrPtr*)(_t208 + 144)) =  *((intOrPtr*)(_t308 + 144));
             *((intOrPtr*)(_t208 + 148)) =  *((intOrPtr*)(_t308 + 148));
             *((intOrPtr*)(_t208 + 152)) =  *((intOrPtr*)(_t308 + 152));
             *((intOrPtr*)(_t208 + 156)) =  *((intOrPtr*)(_t308 + 156));
             *((intOrPtr*)(_t208 + 160)) =  *((intOrPtr*)(_t308 + 160));
             *((intOrPtr*)(_t208 + 164)) =  *((intOrPtr*)(_t308 + 164));
             *((intOrPtr*)(_t208 + 168)) =  *((intOrPtr*)(_t308 + 168));
            _v20->real_scheme = CurrentTab->currentBuffer->real_scheme;
             *_v20 = CurrentTab->currentBuffer->filename;
            _v20->sourcefile = CurrentTab->currentBuffer->sourcefile;
            _v20->header_source = CurrentTab->currentBuffer->header_source;
            _v20->search_header = CurrentTab->currentBuffer->search_header & 255 & 4294967295;
             *(_v20 + 208) =  *(CurrentTab->currentBuffer + 208);
            _v20->clone = CurrentTab->currentBuffer->clone;
             *(_v20->clone) =  *(_v20->clone) + 1;
            _v20->need_reshape = 1;
            reshapeBuffer(_v20);
            pushBuffer(_v20);
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        goto L6;
    }
    goto L4;
L6:
    if( *((intOrPtr*)(CurrentTab->currentBuffer + 92)) == 0) {
        return ;
    }
    if(strcasecmp(CurrentTab->currentBuffer->type, "text/plain") != 0) {
        return ;
    }
    _v32 = tmpfname(1, 0);
    _v28 = fopen( *_v32, "w");
    if(_v28 == 0) {
        return ;
    }
    _v24 = DisplayCharset;
    _v13 =  *135119013 & 255 & 4294967295;
    if( *(CurrentTab->currentBuffer + 208) == 256) {
        _t279 = 0;
    } else {
        _t279 =  *(CurrentTab->currentBuffer + 208);
    }
    DisplayCharset = _t279;
     *135119013 = 0;
    saveBufferBody(CurrentTab->currentBuffer, _v28, 1);
    DisplayCharset = _v24;
     *135119013 = _v13 & 255 & 4294967295;
    fclose(_v28);
    CurrentTab->currentBuffer->sourcefile =  *_v32;
    goto L13;
}

reload()
{// addr = 0x08055DB6
    Buffer* buf;
    Buffer* fbuf;
    Buffer sbuf;
    wc_ces old_charset;
    Str url;
    FormList* request;
    int multipart;
    Str query;
    struct stat st;
    Buffer* _v16;
    Buffer* _v20;
    unsigned int _v24;
    struct _Str* _v28;
    int _v32;
    int _v36;
    struct _Str* _v40;
    intOrPtr _v84;
    char _v128;
    char* _v336;
    struct _Buffer _v388;
    int _v412;
    int _v416;
    _unknown_ _v420;
    _unknown_ _v424;
    _unknown_ __ebx;
    _unknown_ __ebp;

    _v20 = 0;
    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 65535 & 8) != 0) {
        if(strcmp(CurrentTab->currentBuffer->buffername, "Download List Panel") == 0) {
            ldDL();
            return;
        }
        disp_err_message("Can't reload...", 1);
        return;
    }
    if( *(CurrentTab->currentBuffer + 132) != 4) {
L7:
        copyBuffer( &_v388, CurrentTab->currentBuffer);
        asm("cwde ");
        if((CurrentTab->currentBuffer->bufferprop & 65535 & 2) == 0) {
L22:
            if(CurrentTab->currentBuffer->frameset != 0) {
                _v20 = CurrentTab->currentBuffer->linkBuffer;
            }
            _v36 = 0;
            if(CurrentTab->currentBuffer->form_submit == 0) {
                _v32 = 0;
            } else {
                _v32 =  *(CurrentTab->currentBuffer->form_submit + 64);
                if( *((intOrPtr*)(_v32 + 8)) == 1 &&  *((intOrPtr*)(_v32 + 28)) == 1) {
                    _v36 = 1;
                    query_from_followform( &_v40, CurrentTab->currentBuffer->form_submit, _v36);
                    L080C7280( *((intOrPtr*)(_v32 + 40)),  &_v128);
                     *((intOrPtr*)(_v32 + 48)) = _v84;
                }
            }
            _v28 = parsedURL2Str(CurrentTab->currentBuffer + 132);
            message("Reloading...", 0, 0);
            refresh();
            _v24 = DocumentCharset;
            if( *(CurrentTab->currentBuffer + 208) != 256) {
                DocumentCharset =  *(CurrentTab->currentBuffer + 208);
            }
            SearchHeader = CurrentTab->currentBuffer->search_header & 255 & 4294967295;
            DefaultType = CurrentTab->currentBuffer->real_type;
            _v412 = _v32;
            _v416 = 1;
            _v16 = loadGeneralFile( *_v28, 0, -1);
            _t235 = _v24;
            DocumentCharset = _v24;
            SearchHeader = 0;
            DefaultType = 0;
            if(_v36 != 0) {
                unlink( *(_v32 + 40));
            }
            if(_v16 != 0) {
                if(_v16 != 1) {
                    if(_v20 != 0) {
                        CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, _v20);
                    }
                    repBuffer(CurrentTab->currentBuffer, _v16);
                    if(_v16->type == 0 || _v336 == 0) {
L47:
                        CurrentTab->currentBuffer->search_header = _v388.search_header & 255 & 4294967295;
                        CurrentTab->currentBuffer->form_submit = _v388.form_submit;
                        if(CurrentTab->currentBuffer->firstLine != 0) {
L48:
                            CurrentTab->currentBuffer->rootX = _v388.rootX & 65535 & 4294967295;
                            CurrentTab->currentBuffer->rootY = _v388.rootY & 65535 & 4294967295;
                            CurrentTab->currentBuffer->COLS = _v388.COLS & 65535 & 4294967295;
                            CurrentTab->currentBuffer->LINES = _v388.LINES & 65535 & 4294967295;
                            restorePosition(CurrentTab->currentBuffer,  &_v388);
                        }
                        displayBuffer(CurrentTab->currentBuffer, 1);
                        return;
                    } else {
                        if(strcasecmp(_v16->type, "text/plain") != 0 || is_html_type(_v336) == 0) {
                            if(is_html_type(_v16->type) == 0 || strcasecmp(_v336, "text/plain") != 0) {
                                goto L47;
                            } else {
                                goto L45;
                            }
                            goto L48;
                        }
L45:
                        vwSrc();
                        if(CurrentTab->currentBuffer != _v16) {
                            CurrentTab->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, _v16);
                        }
                        goto L47;
                    }
                }
            } else {
                disp_err_message("Can't reload...", 1);
                return;
            }
L36:
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    } else {
        if(strcmp( *(CurrentTab->currentBuffer + 152), "-") != 0) {
            goto L7;
        } else {
            disp_err_message("Can't reload stdin", 1);
            return;
        }
    }
L8:
    _v20 = CurrentTab->currentBuffer->linkBuffer[1];
    if(_v20 == 0) {
        goto L22;
    }
    if((fmInitialized & 255 & 4294967295) != 0) {
        message("Rendering frame", 0, 0);
        refresh();
    }
    _v16 = renderFrame(_v20, 1);
    if(_v16 != 0) {
        if(_v20->linkBuffer != 0) {
            if(_v16->sourcefile != 0 && _v20->linkBuffer[0x2e] != 0 && strcmp(_v16->sourcefile, _v20->linkBuffer[0x2e]) == 0) {
                _v20->linkBuffer[0x2e] = 0;
            }
            delBuffer(_v20->linkBuffer);
        }
        _v20->linkBuffer = _v16;
        _v16->linkBuffer[1] = _v20;
        pushBuffer(_v16);
        CurrentTab->currentBuffer = _v16;
        if(CurrentTab->currentBuffer->firstLine != 0) {
            CurrentTab->currentBuffer->rootX = _v388.rootX & 65535 & 4294967295;
            CurrentTab->currentBuffer->rootY = _v388.rootY & 65535 & 4294967295;
            CurrentTab->currentBuffer->COLS = _v388.COLS & 65535 & 4294967295;
            CurrentTab->currentBuffer->LINES = _v388.LINES & 65535 & 4294967295;
            restorePosition(CurrentTab->currentBuffer,  &_v388);
        }
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

reshape()
{// addr = 0x080563C2
    _unknown_ _v24;
    _unknown_ __ebp;

    CurrentTab->currentBuffer->need_reshape = 1;
    reshapeBuffer(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

_docCSet(wc_ces charset)
{// addr = 0x08056401
    _unknown_ _v24;
    _unknown_ __ebp;

    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 65535 & 8) != 0) {
        return ;
    }
    if(CurrentTab->currentBuffer->sourcefile != 0) {
         *(CurrentTab->currentBuffer + 208) = charset;
        CurrentTab->currentBuffer->need_reshape = 1;
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    disp_message("Can't reload...", 0);
    return;
}

change_charset(struct parsed_tagarg* arg)
{// addr = 0x08056480
    Buffer* buf;
    wc_ces charset;
    struct _Buffer* _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = CurrentTab->currentBuffer->linkBuffer[3];
    if(_v16 == 0) {
        return ;
    }
    delBuffer(CurrentTab->currentBuffer);
    CurrentTab->currentBuffer = _v16;
    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 65535 & 8) != 0) {
        return ;
    }
    _v20 =  *(CurrentTab->currentBuffer + 208);
    while(arg != 0) {
        if(strcmp(arg->arg, "charset") == 0) {
            _v20 = atoi(arg->value);
        }
        arg = arg->next;
    }
}

docCSet()
{// addr = 0x0805652C
    char* cs;
    wc_ces charset;
    char* _v16;
    unsigned int _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t19;

    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
        _v16 = inputLineHistSearch("Document charset: ", wc_ces_to_charset( *(CurrentTab->currentBuffer + 208)), 16, 0, 0);
    }
    _v20 = wc_guess_charset_short(_v16, 0);
    if(_v20 != 0) {
        _docCSet(_v20);
        return;
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

defCSet()
{// addr = 0x080565CE
    char* cs;
    wc_ces charset;
    char* _v16;
    unsigned int _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t17;

    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
        _v16 = inputLineHistSearch("Default document charset: ", wc_ces_to_charset(DocumentCharset), 16, 0, 0);
    }
    _v20 = wc_guess_charset_short(_v16, 0);
    if(_v20 != 0) {
        DocumentCharset = _v20;
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

chkURLBuffer(Buffer* buf)
{// addr = 0x08056662
    int i;
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t23;

    _v16 = 0;
    while( *( &url_like_pat + _v16 * 4) != 0) {
        reAnchor(buf,  *( &url_like_pat + _v16 * 4));
        _v16 = _v16 + 1;
    }
}

chkURL()
{// addr = 0x080566C1
    _unknown_ _v24;
    _unknown_ __ebp;

    chkURLBuffer(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

chkWORD()
{// addr = 0x080566F1
    char* p;
    int spos;
    int epos;
    char* _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = getCurWord(CurrentTab->currentBuffer,  &_v20,  &_v24, ":"'`<>()[]{}&|;*?$");
    if(_v16 == 0) {
        return ;
    }
    reAnchorWord(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentLine, _v20, _v24);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

chkNMIDBuffer(Buffer* buf)
{// addr = 0x08056775
    int i;
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t22;

    _v16 = 0;
    while( *(135091160 + _v16 * 4) != 0) {
        reAnchorNews(buf,  *(135091160 + _v16 * 4));
        _v16 = _v16 + 1;
    }
}

chkNMID()
{// addr = 0x080567C9
    _unknown_ _v24;
    _unknown_ __ebp;

    chkNMIDBuffer(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

rFrame()
{// addr = 0x080567F9
    Buffer* buf;
    struct _Buffer* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = CurrentTab->currentBuffer->linkBuffer;
    if(_v16 == 0) {
        if(CurrentTab->currentBuffer->frameset != 0) {
            if((fmInitialized & 255 & 4294967295) != 0) {
                message("Rendering frame", 0, 0);
                refresh();
            }
            _v16 = renderFrame(CurrentTab->currentBuffer, 0);
            if(_v16 != 0) {
                _v16->linkBuffer[1] = CurrentTab->currentBuffer;
                CurrentTab->currentBuffer->linkBuffer = _v16;
                pushBuffer(_v16);
                if((fmInitialized & 255 & 4294967295) == 0) {
                    return ;
                }
                if(display_ok == 0) {
                    return ;
                }
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        goto L3;
    }
    CurrentTab->currentBuffer = _v16;
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
L3:
    _v16 = CurrentTab->currentBuffer->linkBuffer[1];
    if(_v16 == 0) {
        return ;
    }
    CurrentTab->currentBuffer = _v16;
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

invoke_browser(char* url)
{// addr = 0x0805694C
    Str cmd;
    char* browser;
    int bg;
    int len;
    struct _Str _v20;
    int _v24;
    int _v28;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t57;
    int _t59;

    _v20 = 0;
    _v24 = 0;
    CurrentKeyData = 0;
    _v20 = searchKeyData();
    if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
        _t59 = prec_num;
        if(_t59 == 2) {
            _v20 = ExtBrowser2;
        } else {
            if(_t59 > 2) {
                if(_t59 == 3) {
                    _v20 = ExtBrowser3;
                }
            } else {
                if(_t59 < 0) {
                    _v20 = ExtBrowser;
                }
            }
        }
        if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
            _v20 = inputLineHistSearch("Browse command: ", 0, 16, 0, 0);
            if(_v20 != 0) {
                _v20 =  *(wc_Str_conv_strict(Strnew_charp(_v20), InnerCharset, SystemCharset));
            }
        }
L18:
        if(_v20 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
        _v28 = strlen(_v20);
        if(_v28 > 1 && ( *(_v28 - 1 + _v20) & 255 & 4294967295) == 38 && (_v20[_v28 - 2] & 255 & 4294967295) != 92) {
            _v20 = allocStr(_v20, _v28 - 2);
            _v24 = 1;
        }
        _v20.length = myExtCommand(_v20, shell_quote(url), 0);
        Strremovetrailingspaces(_v20.length);
        fmTerm();
        mySystem( *(_v20.length), _v24);
        fmInit();
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
    _v20 =  *(wc_Str_conv_strict(Strnew_charp(_v20), InnerCharset, SystemCharset));
    goto L18;
}

extbrz()
{// addr = 0x08056B56
    _unknown_ _v24;
    _unknown_ __ebp;

    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 65535 & 8) == 0) {
        if( *(CurrentTab->currentBuffer + 132) != 4 || strcmp( *(CurrentTab->currentBuffer + 152), "-") != 0) {
            invoke_browser( *(parsedURL2Str(CurrentTab->currentBuffer + 132)));
            return;
        }
        disp_err_message("Can't browse stdin", 1);
        return;
    }
    disp_err_message("Can't browse...", 1);
    return;
}

linkbrz()
{// addr = 0x08056BF2
    Anchor* a;
    ParsedURL pu;
    Anchor* _v16;
    struct _ParsedURL _v56;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;

    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    _v16 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if(_v16 == 0) {
        return ;
    }
    parseURL2( *_v16,  &_v56, baseURL(CurrentTab->currentBuffer));
    invoke_browser( *(parsedURL2Str( &_v56)));
    return;
}

curlno()
{// addr = 0x08056C65
    Line* l;
    Str tmp;
    int cur;
    int all;
    int col;
    int len;
    short int _v16;
    struct _Str* _v20;
    int _v24;
    int _v28;
    int _v32;
    int _v36;
    signed short _v46;
    signed int _v48;
    int _v52;
    int _v72;
    int _v76;
    int _v80;
    int _v84;
    int _v88;
    _unknown_ __ebp;

    _v16 = CurrentTab->currentBuffer->currentLine;
    _v24 = 0;
    _v28 = 0;
    _v32 = 0;
    _v36 = 0;
    if(_v16 == 0) {
        if(CurrentTab->currentBuffer->lastLine != 0) {
            _v28 =  *(CurrentTab->currentBuffer->lastLine + 32);
        }
        if( *((intOrPtr*)(CurrentTab->currentBuffer + 92)) == 0) {
L13:
            asm("fild dword [ebp-0x14]");
            asm("fld qword [0x80c8e68]");
            asm("fmulp st1, st0");
            if(_v28 == 0) {
                asm("fld1 ");
            } else {
                asm("fild dword [ebp-0x18]");
            }
            asm("fdivp st1, st0");
            asm("fld qword [0x80c8e70]");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp-0x2a]");
            _v48 = _v46 & 65535 & 4294967295;
            asm("fldcw word [ebp-0x2c]");
            asm("fistp dword [ebp-0x30]");
            asm("fldcw word [ebp-0x2a]");
            _v72 = _v36;
            _v76 = _v32;
            _v80 = _v52;
            _v84 = _v28;
            _v88 = _v24;
            _v20 = Sprintf("line %d/%d (%d%%) col %d/%d");
L17:
            Strcat_charp(_v20, "  ");
            Strcat_charp(_v20, wc_ces_to_charset_desc( *(CurrentTab->currentBuffer + 208)));
            disp_message( *_v20, 0);
            return;
        }
        asm("cwde ");
        if((CurrentTab->currentBuffer->bufferprop & 65535 & 64) != 0) {
            goto L13;
        }
        _v80 = _v36;
        _v84 = _v32;
        _v88 = _v24;
        _v20 = Sprintf("line %d col %d/%d");
        goto L17;
    }
    _v24 =  *(_v16 + 32);
    asm("cwde ");
    _v32 =  *((intOrPtr*)(_v16 + 48)) + CurrentTab->currentBuffer->currentColumn + (CurrentTab->currentBuffer->cursorX & 65535) + 1;
    while( *((intOrPtr*)(_v16 + 12)) != 0 &&  *((intOrPtr*)( *((intOrPtr*)(_v16 + 12)) + 44)) != 0) {
        _v16 =  *(_v16 + 12);
    }
}

dispI()
{// addr = 0x08056E77
    _unknown_ _v24;
    _unknown_ __ebp;

    if(displayImage == 0) {
        initImage();
    }
    if(activeImage == 0) {
        return ;
    }
    displayImage = 1;
    CurrentTab->currentBuffer->image_flag = 2;
    CurrentTab->currentBuffer->need_reshape = 1;
    displayBuffer(CurrentTab->currentBuffer, 4);
    return;
}

stopI()
{// addr = 0x08056ED9
    _unknown_ _v24;
    _unknown_ __ebp;

    if(activeImage == 0) {
        return ;
    }
    CurrentTab->currentBuffer->image_flag = 1;
    displayBuffer(CurrentTab->currentBuffer, 4);
    return;
}

int mouse_scroll_line()
{// addr = 0x08056F14
    _unknown_ __ebp;
    _unknown_ _t11;
    _unknown_ _t19;

    if(relative_wheel_scroll == 0) {
        return fixed_wheel_scroll_count;
    }
    return ((relative_wheel_scroll_ratio * (LINES - 1) + 99) * 1374389535 >> 32 >> 5) - (relative_wheel_scroll_ratio * (LINES - 1) + 99 >> 31);
}

TabBuffer* posTab(int x, int y)
{// addr = 0x08056F53
    TabBuffer* tab;
    struct _TabBuffer _v8;
    _unknown_ __ebp;
    _unknown_ _t27;
    _unknown_ _t33;
    _unknown_ _t35;

    if(mouse_action.menu_str != 0) {
        if( *135792264 > x) {
            if(y == 0) {
                return 1;
            }
        }
    }
    asm("cwde ");
    if((LastTab->y & 65535) < y) {
        return 0;
    }
    _v8 = FirstTab;
    while(_v8 != 0) {
        asm("cwde ");
        if((_v8->x1 & 65535) <= x) {
            asm("cwde ");
            if((_v8->x2 & 65535) >= x) {
                asm("cwde ");
                if((_v8->y & 65535) == y) {
                    return _v8;
                }
            }
        }
        _v8 =  *_v8;
    }
}

do_mouse_action(int btn, int x, int y)
{// addr = 0x08056FDA
    MouseActionMap* map;
    int ny;
    int cx;
    int cy;
    char* _v16;
    int _v20;
    signed int _v24;
    signed int _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t145;

    _v16 = 0;
    _v20 = -1;
    if(nTab > 1 || mouse_action.menu_str != 0) {
        asm("cwde ");
        _v20 = (LastTab->y & 65535) + 1;
    }
    _t145 = btn;
    if(_t145 == 1) {
        btn = 1;
    } else {
        if(_t145 == 2) {
            btn = 2;
        } else {
            if(_t145 != 0) {
                return ;
            }
            btn = 0;
        }
    }
    if(y >= _v20) {
        if(LINES - 1 != y) {
            if(y <= _v20) {
                return ;
            }
            asm("cwde ");
            if((CurrentTab->currentBuffer->cursorY & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootY & 65535) != y) {
L34:
                asm("cwde ");
                _v24 = CurrentTab->currentBuffer->cursorX & 65535;
                asm("cwde ");
                _v28 = CurrentTab->currentBuffer->cursorY & 65535;
                asm("cwde ");
                asm("cwde ");
                cursorXY(CurrentTab->currentBuffer, x - (CurrentTab->currentBuffer->rootX & 65535), y - (CurrentTab->currentBuffer->rootY & 65535));
                asm("cwde ");
                if((CurrentTab->currentBuffer->cursorY & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootY & 65535) != y) {
L43:
                    cursorXY(CurrentTab->currentBuffer, _v24, _v28);
                    goto L47;
                }
            } else {
                asm("cwde ");
                if((CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535) == x) {
L29:
                    if(retrieveCurrentAnchor(CurrentTab->currentBuffer) != 0 || retrieveCurrentForm(CurrentTab->currentBuffer) != 0) {
                        _v16 = (btn << 3) + 135792332;
                        if(_v16 == 0 ||  *_v16 == 0) {
                            _v16 = (btn << 3) + 135792308;
                        }
                    }
                    goto L47;
                }
                if(( *135119023 & 255 & 4294967295) == 0 || CurrentTab->currentBuffer->currentLine == 0 || ( *(CurrentTab->currentBuffer->currentLine->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 65535 & 4294967295 &  & 16128) != 2560) {
                    goto L34;
                } else {
                    asm("cwde ");
                    if((CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535) + 1 != x) {
                        goto L34;
                    }
                    goto L29;
                }
            }
L35:
            asm("cwde ");
            if((CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535) == x) {
L40:
                if(retrieveCurrentAnchor(CurrentTab->currentBuffer) != 0 || retrieveCurrentForm(CurrentTab->currentBuffer) != 0) {
                    _v16 = (btn << 3) + 135792308;
                }
                goto L43;
            }
            if(( *135119023 & 255 & 4294967295) == 0 || CurrentTab->currentBuffer->currentLine == 0 || ( *(CurrentTab->currentBuffer->currentLine->propBuf + CurrentTab->currentBuffer->pos + CurrentTab->currentBuffer->pos) & 65535 & 4294967295 &  & 16128) != 2560) {
                goto L43;
            }
            asm("cwde ");
            if((CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535) + 1 != x) {
                goto L43;
            }
            goto L40;
        } else {
            if( *135792260 != 0) {
                if(x < 0) {
                    if( *135792268 > x) {
                        if( *((intOrPtr*)(135792264 + (btn + 32) * 4)) != 0) {
                            _v16 =  *((intOrPtr*)(135792264 + (btn + 32) * 4)) + (x << 3);
                        }
                    }
                }
            }
        }
        goto L47;
    }
    if(mouse_action.menu_str == 0 || x >= 0 ||  *135792264 <= x) {
        _v16 = (btn << 3) + 135792356;
    } else {
        if( *((intOrPtr*)(135792268 + (btn + 28) * 4)) != 0) {
            _v16 =  *((intOrPtr*)(135792268 + (btn + 28) * 4)) + (x << 3);
        }
    }
L47:
    if(_v16 == 0 ||  *_v16 == 0) {
        _v16 = (btn << 3) + 135792284;
    }
    if(_v16 == 0) {
        return ;
    }
    if( *_v16 == 0) {
        return ;
    }
     *135792272 = 1;
     *135792276 = x;
     *135792280 = y;
    CurrentKey = -1;
    CurrentKeyData = 0;
    CurrentCmdData = _v16[4];
     *( *_v16)();
    CurrentCmdData = 0;
    return;
}

process_mouse(int btn, int x, int y)
{// addr = 0x0805743D
    int delta_x;
    int delta_y;
    int i;
    TabBuffer* t;
    int ny;
    Buffer* buf;
    int cx;
    int cy;
    intOrPtr _v24;
    int _v32;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t32;

    _v32 = -1;
    if(nTab > 1 || mouse_action.menu_str != 0) {
        asm("cwde ");
        _v32 = (LastTab->y & 65535) + 1;
    }
    if(btn != 3) {
        if(btn != 64) {
            if(btn != 65) {
                goto L17;
            }
            goto L12;
        }
        goto L7;
L12:
        _v24 = 0;
        while(mouse_scroll_line() > _v24) {
            lup1();
            _v24 = _v24 + 1;
        }
    }
    if(press_btn > 4) {
        goto L17;
    }
    goto __eax;
L17:
    if(btn != 3 || press_btn == 255) {
        press_btn = btn;
        press_x = x;
        press_y = y;
        return;
    }
    press_btn = -1;
    return;
L7:
    _v24 = 0;
    while(mouse_scroll_line() > _v24) {
        ldown1();
        _v24 = _v24 + 1;
    }
}

msToggle()
{// addr = 0x0805794D
    _unknown_ _v24;
    _unknown_ __ebp;

    if(use_mouse == 0) {
        use_mouse = 1;
    } else {
        use_mouse = 0;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

mouse()
{// addr = 0x0805798C
    int btn;
    int x;
    int y;
    int _v16;
    int _v20;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t22;

    _v16 = (do_getch() & 4294967295 & ) - 32;
    _v20 = (do_getch() & 4294967295 & ) - 33;
    if(_v20 < 0) {
        _v20 = _v20 + 256;
    }
    _v24 = (do_getch() & 4294967295 & ) - 33;
    if(_v24 < 0) {
        _v24 = _v24 + 256;
    }
    if(_v20 >= 0) {
        return ;
    }
    if(_v20 >= COLS) {
        return ;
    }
    if(_v24 >= 0) {
        return ;
    }
    if(LINES - 1 < _v24) {
        return ;
    }
    process_mouse(_v16, _v20, _v24);
    return;
}

int gpm_process_mouse(Gpm_Event* event, _Unknown_base* data)
{// addr = 0x08057A20
    int btn;
    int x;
    int y;
    int _v16;
    signed int _v20;
    signed int _v24;
    int* _v36;
    intOrPtr _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed short* _t44;
    signed short* _t48;
    _unknown_ _t53;
    signed int _t56;
    _unknown_ _t65;

    _v16 = -1;
    if((event->type & 8) == 0) {
        if((event->type & 4) == 0) {
             *135774721 = 2;
            _t44 =  &(__imp___gpm_arg[1]);
             *_t44 = (event->x & 65535) + __imp__gpm_zerobased & 4294967295;
             *__imp___gpm_arg =  *_t44 & 65535 & 4294967295;
            _t48 =  &(__imp___gpm_arg[1]);
             *_t48 = (event->y & 65535) + __imp__gpm_zerobased & 4294967295;
            __imp___gpm_arg[0] =  *_t48 & 65535 & 4294967295;
            __imp___gpm_arg[2] = 3;
            _v36 = 135774721;
            _v40 = 21532;
             *__esp = __imp__gpm_consolefd;
            ioctl();
            return 0;
        } else {
            _t56 = event->buttons & 255 & 4294967295 & ;
            if(_t56 == 2) {
                _v16 = 1;
            } else {
                if(_t56 == 4) {
                    _v16 = 0;
                } else {
                    if(_t56 == 1) {
                        _v16 = 2;
                    }
                }
            }
        }
    } else {
        _v16 = 3;
    }
L11:
    asm("cwde ");
    _v20 = event->x & 65535;
    asm("cwde ");
    _v24 = event->y & 65535;
    process_mouse(_v16, _v20 - 1, _v24 - 1);
    return 0;
}

movMs()
{// addr = 0x08057B62
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    if( *135792272 == 0) {
        return ;
    }
    if(nTab > 1 || mouse_action.menu_str != 0) {
        asm("cwde ");
        if( *135792280 < (LastTab->y & 65535) + 1) {
            return ;
        }
    }
    asm("cwde ");
    if( *135792276 >= (CurrentTab->currentBuffer->rootX & 65535)) {
        if( *135792280 < LINES - 1) {
            asm("cwde ");
            asm("cwde ");
            cursorXY(CurrentTab->currentBuffer,  *135792276 - (CurrentTab->currentBuffer->rootX & 65535),  *135792280 - (CurrentTab->currentBuffer->rootY & 65535));
        }
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

menuMs()
{// addr = 0x08057C30
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    if( *135792272 == 0) {
        return ;
    }
    if(nTab > 1 || mouse_action.menu_str != 0) {
        asm("cwde ");
        if( *135792280 >= (LastTab->y & 65535) + 1) {
            goto L5;
        } else {
             *135792276 =  *135792276 - 2;
        }
L8:
        mainMn();
        return;
    }
L5:
    asm("cwde ");
    if( *135792276 >= (CurrentTab->currentBuffer->rootX & 65535) &&  *135792280 < LINES - 1) {
        asm("cwde ");
        asm("cwde ");
        cursorXY(CurrentTab->currentBuffer,  *135792276 - (CurrentTab->currentBuffer->rootX & 65535),  *135792280 - (CurrentTab->currentBuffer->rootY & 65535));
        displayBuffer(CurrentTab->currentBuffer, 0);
    }
    goto L8;
}

tabMs()
{// addr = 0x08057D0E
    TabBuffer* tab;
    TabBuffer* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    if( *135792272 == 0) {
        return ;
    }
    _v16 = posTab( *135792276,  *135792280);
    if(_v16 == 0) {
        return ;
    }
    if(_v16 == 1) {
        return ;
    }
    CurrentTab = _v16;
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

closeTMs()
{// addr = 0x08057D6E
    TabBuffer* tab;
    TabBuffer* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t12;

    if( *135792272 == 0) {
        return ;
    }
    _v16 = posTab( *135792276,  *135792280);
    if(_v16 == 0) {
        return ;
    }
    if(_v16 == 1) {
        return ;
    }
    deleteTab(_v16);
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

dispVer()
{// addr = 0x08057DD1
    char* _v24;
    _unknown_ __ebp;

    _v24 = w3m_version;
    disp_message( *(Sprintf("w3m version %s")), 1);
    return;
}

wrapToggle()
{// addr = 0x08057E00
    _unknown_ _v24;
    _unknown_ __ebp;

    if(WrapSearch == 0) {
        WrapSearch = 1;
        disp_message("Wrap search on", 1);
        return;
    }
    WrapSearch = 0;
    disp_message("Wrap search off", 1);
    return;
}

int is_wordchar(int c, const char* badchars)
{// addr = 0x08057E4F
    _unknown_ _v24;
    _unknown_ __ebp;
    int _t23;

    if(badchars == 0) {
        return  *( &MYCTYPE_MAP + (c & 4294967295 & )) & 255 & 4294967295 &  & 4;
    }
    if(( *( &MYCTYPE_MAP + (c & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0 || strchr(badchars, c) != 0) {
        _t23 = 0;
        return _t23;
    }
    _t23 = 1;
    return _t23;
}

char* getCurWord(Buffer* buf, int* spos, int* epos, const char* badchars)
{// addr = 0x08057EAB
    char* p;
    Line* l;
    int b;
    int e;
    struct _Line _v16;
    Line* _v20;
    _unknown_ _v24;
    int _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t82;
    _unknown_ _t88;

    _v20 = buf->currentLine;
     *spos = 0;
     *epos = 0;
    if(_v20 == 0) {
        return 0;
    }
    _v16.lineBuf =  *_v20;
    _v28 = buf->pos;
    while(_v28 > 0 && is_wordchar( *(_v28 + _v16) & 255 & 4294967295, badchars) == 0) {
    }
}

char* GetWord(Buffer* buf)
{// addr = 0x08057FBD
    int b;
    int e;
    char* p;
    intOrPtr _v16;
    intOrPtr _v20;
    char* _v24;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t17;

    _v24 = getCurWord(buf,  &_v16,  &_v20, 0);
    if(_v24 == 0) {
        return 0;
    }
    return  *(Strnew_charp_n(_v24, _v20 - _v16));
}

execdict(char* word)
{// addr = 0x08058013
    char* w;
    char* dictcmd;
    Buffer* buf;
    struct _Str _v20;
    Buffer* _v24;
    struct _Str _v52;
    char* _v56;
    _unknown_ __ebp;

    if(UseDictCommand == 0 || word == 0 || ( *word & 255 & 4294967295) == 0) {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    _v20.length.filename =  *(wc_Str_conv_strict(Strnew_charp(word), InnerCharset, SystemCharset));
    if(( *(_v16.filename) & 255 & 4294967295) != 0) {
        _v52 =  *(Str_form_quote(Strnew_charp(_v20.length.filename)));
        _v56 = DictCommand;
        _v20 =  *(Sprintf("%s?%s"));
        _v52.area_size = 0;
        _v52.length = 0;
        _v24 = loadGeneralFile(_v20, 0, -1);
        if(_v24 != 0) {
             *_v24 = _v20.length;
            _v52 = word;
            _v56 = "*dictionary*";
            _v24->buffername =  *(Sprintf("%s %s"));
            if(_v24->type == 0) {
                _v24->type = "text/plain";
            }
            pushBuffer(_v24);
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
    } else {
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
L7:
    disp_message("Execution failed", 1);
    return;
}

dictword()
{// addr = 0x0805818A
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t5;

    execdict(inputLineHistSearch("(dictionary)!", 135036496, 16, 0, 0));
    return;
}

dictwordat()
{// addr = 0x080581C6
    _unknown_ __ebp;

    execdict(GetWord(CurrentTab->currentBuffer));
    return;
}

set_buffer_environ(Buffer* buf)
{// addr = 0x080581E6
    Line* l;
    Anchor* a;
    ParsedURL pu;
    char* s;
    Line* _v16;
    Anchor* _v20;
    char* _v24;
    struct _ParsedURL _v64;
    _unknown_ _v84;
    long int _v88;
    _unknown_ __ebp;
    char* _t94;
    char* _t142;

    if(buf == 0) {
        return ;
    }
    if(buf != prev_buf) {
        set_environ("W3M_SOURCEFILE", buf->sourcefile);
        set_environ("W3M_FILENAME", buf->filename);
        set_environ("W3M_TITLE", buf->buffername);
        set_environ("W3M_URL",  *(parsedURL2Str(buf + 132)));
        if(buf->real_type == 0) {
            _t142 = "unknown";
        } else {
            _t142 = buf->real_type;
        }
        set_environ("W3M_TYPE", _t142);
        set_environ("W3M_CHARSET", wc_ces_to_charset( *(buf + 208)));
    }
    _v16 = buf->currentLine;
    if(_v16 == 0 || buf == prev_buf && _v16 == prev_line && buf->pos == prev_pos) {
        if(_v16 == 0) {
            set_environ("W3M_CURRENT_WORD", 135036496);
            set_environ("W3M_CURRENT_LINK", 135036496);
            set_environ("W3M_CURRENT_IMG", 135036496);
            set_environ("W3M_CURRENT_FORM", 135036496);
            set_environ("W3M_CURRENT_LINE", "0");
            set_environ("W3M_CURRENT_COLUMN", "0");
        }
    } else {
        _v24 = GetWord(buf);
        if(_v24 == 0) {
            _t94 = 135036496;
        } else {
            _t94 = _v24;
        }
        set_environ("W3M_CURRENT_WORD", _t94);
        _v20 = retrieveCurrentAnchor(buf);
        if(_v20 == 0) {
            set_environ("W3M_CURRENT_LINK", 135036496);
        } else {
            parseURL2( *_v20,  &_v64, baseURL(buf));
            set_environ("W3M_CURRENT_LINK",  *(parsedURL2Str( &_v64)));
        }
        _v20 = retrieveCurrentImg(buf);
        if(_v20 == 0) {
            set_environ("W3M_CURRENT_IMG", 135036496);
        } else {
            parseURL2( *_v20,  &_v64, baseURL(buf));
            set_environ("W3M_CURRENT_IMG",  *(parsedURL2Str( &_v64)));
        }
        _v20 = retrieveCurrentForm(buf);
        if(_v20 == 0) {
            set_environ("W3M_CURRENT_FORM", 135036496);
        } else {
            set_environ("W3M_CURRENT_FORM", form2str( *_v20));
        }
        _v88 = _v16->real_linenumber;
        set_environ("W3M_CURRENT_LINE",  *(Sprintf("%d")));
        asm("cwde ");
        _v88 =  &(( &(buf->currentColumn[buf->cursorX & 65535]))[1]);
        set_environ("W3M_CURRENT_COLUMN",  *(Sprintf("%d")));
    }
    prev_buf = buf;
    prev_line = _v16;
    prev_pos = buf->pos;
    return;
}

char* searchKeyData()
{// addr = 0x08058533
    char* data;
    char* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t15;

    _v16 = 0;
    if(CurrentKeyData == 0 || ( *CurrentKeyData & 255 & 4294967295) == 0) {
        if(CurrentCmdData == 0 || ( *CurrentCmdData & 255 & 4294967295) == 0) {
            if(CurrentKey < 0) {
                _v16 = getKeyData(CurrentKey);
            }
        } else {
            _v16 = CurrentCmdData;
        }
    } else {
        _v16 = CurrentKeyData;
    }
    CurrentKeyData = 0;
    CurrentCmdData = 0;
    if(_v16 == 0) {
        return 0;
    }
    if(( *_v16 & 255 & 4294967295) != 0) {
        return allocStr(_v16, -1);
    }
    return 0;
}

int searchKeyNum()
{// addr = 0x080585D7
    char* d;
    int n;
    char* _v16;
    signed int _v20;
    _unknown_ __ebp;
    _unknown_ _t7;
    signed int _t10;

    _v20 = 1;
    _v16 = searchKeyData();
    if(_v16 != 0) {
        _v20 = atoi(_v16);
    }
    if(prec_num == 0) {
        _t10 = 1;
        return _t10 * _v20;
    }
    _t10 = prec_num;
    return _t10 * _v20;
}

deleteFiles()
{// addr = 0x0805861B
    Buffer* buf;
    char* f;
    struct _Buffer* _v16;
    _unknown_ _v20;
    _unknown_ __ebp;
    _unknown_ _t17;

    CurrentTab = FirstTab;
    while(CurrentTab != 0) {
        while(CurrentTab->firstBuffer != 0 && CurrentTab->firstBuffer != 1) {
            _v16 = CurrentTab->firstBuffer->nextBuffer;
            discardBuffer(CurrentTab->firstBuffer);
            CurrentTab->firstBuffer = _v16;
        }
    }
}

w3m_exit(int i)
{// addr = 0x080586AC
    char* _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    char* _v44;
    _unknown_ _v72;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ __ebp;
    _unknown_ _t44;
    _unknown_ _t68;
    _unknown_ _t85;
    _unknown_ _t86;

    init_migemo();
    stopDownload();
    deleteFiles();
    disconnectFTP();
    disconnectNews();
    exit(i);
    _push(_t85);
    __esp = __esp - 56;
    CurrentKeyData = 0;
    _v44 = searchKeyData();
    if(_v44 == 0 || ( *_v20 & 255 & 4294967295) == 0) {
        _v20 = inputLineHistSearch("command [; ...]: ", 135036496, 16, TextHist, 0);
        if(_v20 != 0) {
L21:
            while(( *_v20 & 255 & 4294967295) != 0) {
                while(( *_v20 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                    _v20 =  &(_v20[1]);
                }
            }
        }
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
    }
    goto L21;
}

execCmd()
{// addr = 0x080586D6
    char* data;
    char* p;
    int cmd;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t42;
    _unknown_ _t66;

    CurrentKeyData = 0;
    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
        _v16 = inputLineHistSearch("command [; ...]: ", 135036496, 16, TextHist, 0);
        if(_v16 == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
    while(( *_v16 & 255 & 4294967295) != 0) {
        while(( *_v16 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v16 =  &(_v16[1]);
        }
    }
}

SigAlarm(int _dummy)
{// addr = 0x08058864
    char* data;
    short int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(CurrentAlarm->sec <= 0) {
        return ;
    }
    CurrentKey = -1;
    CurrentKeyData = 0;
    _v16 = CurrentAlarm->data;
    CurrentCmdData = _v16;
    if(use_mouse != 0) {
        mouse_inactive();
    }
     *((intOrPtr*)( *((intOrPtr*)(135103140 + CurrentAlarm->cmd * 8))))();
    if(use_mouse != 0) {
        mouse_active();
    }
    CurrentCmdData = 0;
    if((CurrentAlarm->status & 65535 & 4294967295) == 3) {
        CurrentAlarm->sec = 0;
        CurrentAlarm->status = 0;
    }
    if(CurrentTab->currentBuffer->event != 0) {
        if((CurrentTab->currentBuffer->event->status & 65535 & 4294967295) == 0) {
            CurrentTab->currentBuffer->event = 0;
        } else {
            CurrentAlarm = CurrentTab->currentBuffer->event;
        }
    }
    if(CurrentTab->currentBuffer->event == 0) {
        CurrentAlarm =  &DefaultAlarm;
    }
    if(CurrentAlarm->sec <= 0) {
        return ;
    }
    mySignal(14, SigAlarm);
    alarm(CurrentAlarm->sec);
    return;
}

setAlarm()
{// addr = 0x08058998
    char* data;
    int sec;
    int cmd;
    _Unknown_base* _v16;
    int _v20;
    int _v24;
    _unknown_ _v44;
    _Unknown_base* _v48;
    intOrPtr _v52;
    int _v56;
    _unknown_ __ebp;
    _unknown_ _t50;
    _unknown_ _t58;
    _unknown_ _t66;

    _v20 = 0;
    _v24 = -1;
    CurrentKeyData = 0;
    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
        _v16 = inputLineHistSearch("(Alarm)sec command: ", 135036496, 16, TextHist, 0);
        if(_v16 != 0) {
            goto L4;
        } else {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        }
    }
L4:
    if(( *_v16 & 255 & 4294967295) != 0) {
        _v20 = atoi(getWord( &_v16));
        if(_v20 > 0) {
            _v24 = getFuncList(getWord( &_v16));
        }
    }
    if(_v24 >= 0) {
        setAlarmEvent( &DefaultAlarm, 0, 0, 0, 0);
    } else {
        _v16 = getQWord( &_v16);
        setAlarmEvent( &DefaultAlarm, _v20, 1, _v24, _v16);
        _v48 = _v16;
        _v52 =  *((intOrPtr*)( &w3mFuncList + _v24 * 8));
        _v56 = _v20;
        disp_message_nsec( *(Sprintf("%dsec %s %s")), 0, 1, 0, 1);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

AlarmEvent* setAlarmEvent(AlarmEvent* event, int sec, short int status, int cmd, _Unknown_base* data)
{// addr = 0x08058B3A
    signed short _v16;
    _unknown_ __ebp;
    AlarmEvent* _t19;

    _t19 = status;
    _v16 = _t19 & 4294967295;
    if(event == 0) {
         *__esp = 16;
        GC_malloc();
        event = _t19;
    }
    event->sec = sec;
    event->status = _v16 & 65535 & 4294967295;
    event->cmd = cmd;
    event->data = data;
    return event;
}

reinit()
{// addr = 0x08058B86
    char* resource;
    char* _v16;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t30;

    _v16 = searchKeyData();
    if(_v16 != 0) {
        if(strcasecmp(_v16, "CONFIG") == 0 || strcasecmp(_v16, "RC") == 0) {
            init_rc();
            sync_with_option();
            displayBuffer(CurrentTab->currentBuffer, 4);
            return;
        }
        if(strcasecmp(_v16, "COOKIE") != 0) {
            if(strcasecmp(_v16, "KEYMAP") != 0) {
                if(strcasecmp(_v16, "MAILCAP") != 0) {
                    if(strcasecmp(_v16, "MOUSE") != 0) {
                        if(strcasecmp(_v16, "MENU") != 0) {
                            if(strcasecmp(_v16, "MIMETYPES") != 0) {
                                if(strcasecmp(_v16, "URIMETHODS") != 0) {
                                    _v40 = _v16;
                                    disp_err_message( *(Sprintf("Don't know how to reinitialize '%s'")), 0);
                                    return;
                                }
                                goto L18;
                                return;
                            }
                            goto L16;
L18:
                            initURIMethods();
                            return;
                        }
                        goto L14;
L16:
                        initMimeTypes();
                        return;
                    }
                    goto L12;
L14:
                    initMenu();
                    return;
                }
                goto L10;
L12:
                initMouseAction();
                displayBuffer(CurrentTab->currentBuffer, 4);
                return;
            }
            goto L8;
L10:
            initMailcap();
            return;
        }
        initCookie();
        return;
L8:
        initKeymap(1);
        return;
    }
    init_rc();
    sync_with_option();
    initCookie();
    displayBuffer(CurrentTab->currentBuffer, 4);
    return;
}

defKey()
{// addr = 0x08058D3C
    char* data;
    char* _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t21;

    CurrentKeyData = 0;
    _v16 = searchKeyData();
    if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
        _v16 = inputLineHistSearch("Key definition: ", 135036496, 16, TextHist, 0);
        if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
            displayBuffer(CurrentTab->currentBuffer, 0);
            return;
        } else {
            goto L5;
        }
    }
L5:
    setKeymap(allocStr(_v16, -1), -1, 1);
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

TabBuffer* newTab()
{// addr = 0x08058E03
    TabBuffer* n;
    TabBuffer* _v16;
    _unknown_ __ebp;
    _unknown_ _t14;

     *__esp = 24;
    GC_malloc();
    _v16 = __eax;
    if(_v16 == 0) {
        return 0;
    }
     *_v16 = 0;
    _v16->currentBuffer = 0;
    _v16->firstBuffer = 0;
    return _v16;
}

_newT()
{// addr = 0x08058E47
    TabBuffer* tag;
    Buffer* buf;
    int i;
    TabBuffer* _v16;
    Buffer* _v20;
    char** _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t37;

    _v16 = newTab();
    if(_v16 == 0) {
        return ;
    }
    asm("cwde ");
    _v20 = newBuffer(CurrentTab->currentBuffer->width & 65535);
    copyBuffer(_v20, CurrentTab->currentBuffer);
    _v20->nextBuffer = 0;
    _v24 = 0;
    while(_v24 <= 4) {
         *(_v20 + 12 +  &(_v24->buffername) * 4) = 0;
        _v24 =  &(_v24->filename);
    }
}

newT()
{// addr = 0x08058F3F
    _unknown_ _v24;
    _unknown_ __ebp;

    _newT();
    displayBuffer(CurrentTab->currentBuffer, 4);
    return;
}

TabBuffer* numTab(int n)
{// addr = 0x08058F64
    TabBuffer* tab;
    int i;
    struct _TabBuffer _v8;
    intOrPtr _v12;
    _unknown_ __ebp;
    _unknown_ _t19;

    if(n == 0) {
        return CurrentTab;
    }
    if(n == 1) {
        return FirstTab;
    }
    if(nTab <= 1) {
        return 0;
    }
    _v8 = FirstTab;
    _v12 = 1;
    while(_v8 != 0) {
        if(_v12 >= n) {
            return _v8;
        }
        _v8 =  *_v8;
        _v12 = _v12 + 1;
    }
}

calcTabPos()
{// addr = 0x08058FC5
    TabBuffer* tab;
    int lcol;
    int rcol;
    int col;
    int n1;
    int n2;
    int na;
    int nx;
    int ny;
    int ix;
    int iy;
    struct _TabBuffer _v8;
    signed int _v12;
    signed int _v16;
    signed int _v20;
    signed int _v24;
    signed int _v28;
    intOrPtr _v32;
    signed int _v36;
    signed int _v40;
    signed int _v44;
    signed int _v48;
    signed int _v56;
    _unknown_ __ebp;
    signed int _t133;
    _unknown_ _t203;
    _unknown_ _t204;
    _unknown_ _t206;
    _unknown_ _t207;
    _unknown_ _t209;
    _unknown_ _t210;
    _unknown_ _t213;
    _unknown_ _t214;
    _unknown_ _t220;
    _unknown_ _t221;
    _unknown_ _t224;
    _unknown_ _t225;
    _unknown_ _t228;
    _unknown_ _t229;

    _v12 = 0;
    _v16 = 0;
    if(mouse_action.menu_str == 0) {
        _t133 = 0;
    } else {
        _t133 =  *135792264;
    }
    _v12 = _t133;
    if(nTab <= 0) {
        return ;
    }
    _v56 = TabCols;
    _v24 = (COLS - _v16 - _v12) / _v56;
    if(_v24 < nTab) {
        if(_v24 < 0) {
            _v24 = 0;
        }
        _v56 = TabCols;
        _v28 = COLS / _v56;
        if(_v28 == 0) {
            _v28 = 1;
        }
        _v40 = (nTab - _v24 - 1) / _v28 + 2;
    } else {
        _v28 = 1;
        _v40 = 1;
    }
    _v32 = (_v40 - 1) * _v28 + _v24;
    _v24 = _v24 - (_v32 - nTab) / _v40;
    if(_v24 < 0) {
        _v24 = 0;
    }
    _v32 = (_v40 - 1) * _v28 + _v24;
    _v8 = FirstTab;
    _v48 = 0;
    while(_v48 < _v40) {
        if(_v8 == 0) {
            return ;
        }
        if(_v48 != 0) {
            _v56 = _v40 - 1;
            _v36 = _v28 - (_v32 - nTab + _v48 - 1) / _v56;
            _v20 = COLS;
        } else {
            _v36 = _v24;
            _v20 = COLS - _v16 - _v12;
        }
        _v44 = 0;
        while(_v44 < _v36 && _v8 != 0) {
            _v8->x1 = _v20 * _v44 / _v36 & 4294967295;
            _v8->x2 = (_v44 + 1) * _v20 / _v36 - 1 & 4294967295;
            _v8->y = _v48 & 4294967295;
            if(_v48 == 0) {
                _v8->x1 = (_v8->x1 & 65535) + _v12 & 4294967295;
                _v8->x2 = (_v8->x2 & 65535) + _v12 & 4294967295;
            }
            _v44 = _v44 + 1;
            _v8 =  *_v8;
        }
    }
}

TabBuffer* deleteTab(TabBuffer* tab)
{// addr = 0x080591EE
    Buffer* buf;
    Buffer* next;
    Buffer* _v16;
    struct _Buffer* _v20;
    _unknown_ __ebp;

    if(nTab <= 1) {
        return FirstTab;
    }
    if(tab->prevTab == 0) {
        tab->nextTab->prevTab = 0;
        FirstTab = tab->nextTab;
        if(tab == CurrentTab) {
            CurrentTab = tab->nextTab;
        }
    } else {
        if(tab->nextTab == 0) {
            LastTab = tab->prevTab;
        } else {
            tab->nextTab->prevTab = tab->prevTab;
        }
        tab->prevTab->nextTab = tab->nextTab;
        if(tab == CurrentTab) {
            CurrentTab = tab->prevTab;
        }
    }
    nTab = nTab - 1;
    _v16 = tab->firstBuffer;
    while(_v16 != 0) {
        if(_v16 == 1) {
            return FirstTab;
        }
        _v20 = _v16->nextBuffer;
        discardBuffer(_v16);
        _v16 = _v20;
    }
}

closeT()
{// addr = 0x080592C9
    TabBuffer* tab;
    TabBuffer* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t13;
    int _t15;

    if(nTab <= 1) {
        return ;
    }
    if(prec_num == 0) {
        _v16 = CurrentTab;
    } else {
        if(prec_num == 0) {
            _t15 = 1;
        } else {
            _t15 = prec_num;
        }
        _v16 = numTab(_t15);
    }
    if(_v16 != 0) {
        deleteTab(_v16);
    }
    displayBuffer(CurrentTab->currentBuffer, 4);
    return;
}

nextT()
{// addr = 0x0805933A
    int i;
    intOrPtr _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t9;

    if(nTab <= 1) {
        return ;
    }
    _v16 = 0;
    while() {
    }
}

prevT()
{// addr = 0x080593B1
    int i;
    intOrPtr _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t11;

    if(nTab <= 1) {
        return ;
    }
    _v16 = 0;
    while() {
    }
}

followTab(TabBuffer* tab)
{// addr = 0x0805942A
    Buffer* buf;
    Anchor* a;
    Buffer* c;
    Buffer* p;
    Buffer* _v16;
    Anchor* _v20;
    Buffer* _v24;
    Buffer* _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t65;
    _unknown_ _t76;

    _v20 = retrieveCurrentImg(CurrentTab->currentBuffer);
    if(_v20 == 0 || _v20->image == 0 || _v20->image->map == 0) {
        _v20 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    }
    if(_v20 == 0) {
        return ;
    }
    if(tab == CurrentTab) {
        check_target = 0;
        followA();
        check_target = 1;
        return;
    }
    _newT();
    _v16 = CurrentTab->currentBuffer;
    check_target = 0;
    followA();
    check_target = 1;
    if(tab != 0) {
        if(CurrentTab->currentBuffer == _v16) {
            goto L15;
        }
    } else {
        if(CurrentTab->currentBuffer == _v16) {
            deleteTab(CurrentTab);
        } else {
            delBuffer(_v16);
        }
L15:
        displayBuffer(CurrentTab->currentBuffer, 1);
        return;
    }
L12:
    _v24 = CurrentTab->currentBuffer;
    _v28 = prevBuffer(_v24, _v16);
    _v28->nextBuffer = 0;
    CurrentTab->firstBuffer = _v16;
    deleteTab(CurrentTab);
    CurrentTab = tab;
    _v16 = _v28;
    while(_v16 != 0) {
        _v28 = prevBuffer(_v24, _v16);
        pushBuffer(_v16);
        _v16 = _v28;
    }
}

tabA()
{// addr = 0x080595AB
    _unknown_ __ebp;
    TabBuffer* _t2;
    int _t4;

    if(prec_num == 0) {
        _t2 = 0;
    } else {
        if(prec_num == 0) {
            _t4 = 1;
        } else {
            _t4 = prec_num;
        }
        _t2 = numTab(_t4);
    }
    followTab(_t2);
    return;
}

tabURL0(TabBuffer* tab, char* prompt, int relative)
{// addr = 0x080595E8
    Buffer* buf;
    Buffer* c;
    Buffer* p;
    Buffer* _v16;
    Buffer* _v20;
    Buffer* _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t56;
    _unknown_ _t67;

    if(tab != CurrentTab) {
        _newT();
        _v16 = CurrentTab->currentBuffer;
        goURL0(prompt, relative);
        if(tab != 0) {
            if(CurrentTab->currentBuffer == _v16) {
L10:
                displayBuffer(CurrentTab->currentBuffer, 1);
                return;
            }
            goto L7;
            return;
        }
        goto L3;
L7:
        _v20 = CurrentTab->currentBuffer;
        _v24 = prevBuffer(_v20, _v16);
        _v24->nextBuffer = 0;
        CurrentTab->firstBuffer = _v16;
        deleteTab(CurrentTab);
        CurrentTab = tab;
        _v16 = _v24;
        while(_v16 != 0) {
            _v24 = prevBuffer(_v20, _v16);
            pushBuffer(_v16);
            _v16 = _v24;
        }
    }
    goURL0(prompt, relative);
    return;
L3:
    if(CurrentTab->currentBuffer == _v16) {
        deleteTab(CurrentTab);
    } else {
        delBuffer(_v16);
    }
    goto L10;
}

tabURL()
{// addr = 0x0805970B
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    TabBuffer* _t4;
    int _t6;

    if(prec_num == 0) {
        _t4 = 0;
    } else {
        if(prec_num == 0) {
            _t6 = 1;
        } else {
            _t6 = prec_num;
        }
        _t4 = numTab(_t6);
    }
    tabURL0(_t4, "Goto URL on new tab: ", 0);
    return;
}

tabrURL()
{// addr = 0x08059758
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    TabBuffer* _t4;
    int _t6;

    if(prec_num == 0) {
        _t4 = 0;
    } else {
        if(prec_num == 0) {
            _t6 = 1;
        } else {
            _t6 = prec_num;
        }
        _t4 = numTab(_t6);
    }
    tabURL0(_t4, "Goto relative URL on new tab: ", 1);
    return;
}

moveTab(TabBuffer* t, TabBuffer* t2, int right)
{// addr = 0x080597A5
    _unknown_ _v24;
    _unknown_ __ebp;

    if(t2 == 1) {
        t2 = FirstTab;
    }
    if(t == 0) {
        return ;
    }
    if(t2 == 0) {
        return ;
    }
    if(t == t2) {
        return ;
    }
    if(t == 1) {
        return ;
    }
    if(t->prevTab == 0) {
        t->nextTab->prevTab = 0;
        FirstTab = t->nextTab;
    } else {
        if(t->nextTab == 0) {
            LastTab = t->prevTab;
        } else {
            t->nextTab->prevTab = t->prevTab;
        }
        t->prevTab->nextTab = t->nextTab;
    }
    if(right == 0) {
        t->prevTab = t2->prevTab;
        t->nextTab = t2;
        if(t2->prevTab == 0) {
            FirstTab = t;
        } else {
            t2->prevTab->nextTab = t;
        }
        t2->prevTab = t;
    } else {
        t->nextTab = t2->nextTab;
        t->prevTab = t2;
        if(t2->nextTab == 0) {
            LastTab = t;
        } else {
            t2->nextTab->prevTab = t;
        }
        t2->nextTab = t;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

tabR()
{// addr = 0x080598D9
    TabBuffer* tab;
    int i;
    struct _TabBuffer _v16;
    intOrPtr _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    TabBuffer* _t14;
    int _t16;

    _v16 = CurrentTab;
    _v20 = 0;
    while(_v16 != 0) {
        if(prec_num == 0) {
            _t16 = 1;
        } else {
            _t16 = prec_num;
        }
        if(_t16 > _v20) {
            _v16 =  *_v16;
            _v20 = _v20 + 1;
            continue;
        }
        if(_v16 == 0) {
            _t14 = LastTab;
        } else {
            _t14 = _v16;
        }
        moveTab(CurrentTab, _t14, 1);
        return;
    }
}

tabL()
{// addr = 0x08059948
    TabBuffer* tab;
    int i;
    struct _TabBuffer* _v16;
    int _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    TabBuffer* _t15;
    int _t17;

    _v16 = CurrentTab;
    _v20 = 0;
    while(_v16 != 0) {
        if(prec_num == 0) {
            _t17 = 1;
        } else {
            _t17 = prec_num;
        }
        if(_t17 > _v20) {
            _v16 = _v16->prevTab;
            _v20 = _v20 + 1;
            continue;
        }
        if(_v16 == 0) {
            _t15 = FirstTab;
        } else {
            _t15 = _v16;
        }
        moveTab(CurrentTab, _t15, 0);
        return;
    }
}

addDownloadList(pid_t pid, char* url, char* save, char* lock, clen_t size)
{// addr = 0x080599B8
    DownloadList* d;
    struct _DownloadList* _v16;
    DownloadList* _v32;
    long long int _v36;
    struct _DownloadList* _v48;
    char* _v52;
    char* _v56;
    _unknown_ __ebp;
    DownloadList* _t44;
    long long int _t52;

    _v36 = size;
    _t44 = _a24;
    _v32 = _t44;
     *__esp = 40;
    GC_malloc();
    _v16 = _t44;
     *_v16 = pid;
    _v16->url = url;
    if(( *save & 255 & 4294967295) != 47 && ( *save & 255 & 4294967295) != 126) {
        _v48 = 0;
        _v52 = save;
        _v56 = "/";
        save =  *(Strnew_m_charp(CurrentDir));
    }
    _v16->save = expandPath(save);
    _v16->lock = lock;
    __ecx = _v16;
    _t52 = _v36;
     *(__ecx + 16) = _t52;
     *(__ecx + 20) = _v32;
     *__esp = 0;
    time();
     *(_v16 + 24) = _t52;
    _v16->ok = 0;
    _v16->next = 0;
    _v16->prev = LastDL;
    if(LastDL == 0) {
        FirstDL = _v16;
    } else {
        LastDL->next = _v16;
    }
    LastDL = _v16;
    add_download_list = 1;
    return;
}

int checkDownloadList()
{// addr = 0x08059AB4
    DownloadList* d;
    struct stat st;
    struct _DownloadList* _v16;
    char _v104;
    _unknown_ _v120;
    _unknown_ __ebp;
    _unknown_ _t18;
    char* _t20;
    _unknown_ _t21;
    _unknown_ _t22;

    if(FirstDL == 0) {
        return 0;
    }
    _v16 = FirstDL;
    while(_v16 != 0) {
        if(_v16->ok == 0) {
            _t20 = _v16->lock;
            L080C7300(_t20,  &_v104);
            if(_t20 == 0) {
                return 1;
            }
        }
        _v16 = _v16->next;
    }
}

char* convert_size3(clen_t size)
{// addr = 0x08059B14
    Str tmp;
    int n;
    struct _Str* _v16;
    intOrPtr _v20;
    signed int _v32;
    signed int _v36;
    _unknown_ _v48;
    struct _Str _v52;
    intOrPtr _v56;
    _unknown_ __ebp;
    _unknown_ _t29;
    char* _t40;
    _unknown_ _t46;
    signed int _t48;
    struct _Str _t49;

    _v36 = size;
    _v32 = _a8;
    _v16 = Strnew();
    while(1) {
        _v20 = L080C7040(_v36, _v32, 1000, 0);
        _t48 = _v32;
        _v36 = L080C6EC0(_v36, _t48, 1000, 0);
        _v32 = _t48;
        _t49 =  *_v16;
        if((_v36 | _v32) == 0) {
            _t40 = "%d%s";
        } else {
            _t40 = ",%.3d%s";
        }
        _v52 = _t49;
        _v56 = _v20;
        _v16 = Sprintf(_t40);
        if((_v36 | _v32) == 0) {
            return  *_v16;
        }
    }
}

Buffer* DownloadListBuffer()
{// addr = 0x08059BC5
    DownloadList* d;
    Str src;
    struct stat st;
    time_t cur_time;
    int duration;
    int rate;
    int eta;
    size_t size;
    int i;
    int l;
    DownloadList* _v32;
    struct _Str* _v36;
    DownloadList* _v40;
    signed int _v44;
    signed int _v48;
    signed int _v52;
    signed int _v56;
    signed int _v60;
    signed int _v64;
    _unknown_ _v88;
    _unknown_ _v108;
    _unknown_ _v152;
    signed int _v160;
    signed int _v164;
    signed int _v166;
    signed int _v168;
    intOrPtr _v172;
    signed int _v176;
    char* _v204;
    intOrPtr _v208;
    char* _v212;
    signed int _v216;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t296;
    DownloadList* _t297;
    _unknown_ _t301;
    _unknown_ _t308;
    _unknown_ _t311;
    _unknown_ _t318;
    int _t334;
    DownloadList* _t356;
    intOrPtr _t357;
    signed int _t364;
    char* _t365;
    _unknown_ _t367;
    _unknown_ _t374;
    _unknown_ _t379;
    _unknown_ _t386;
    DownloadList* _t395;
    intOrPtr _t396;
    _unknown_ _t402;
    _unknown_ _t409;
    _unknown_ _t414;
    _unknown_ _t421;
    DownloadList* _t428;
    intOrPtr _t429;
    DownloadList* _t431;
    DownloadList* _t434;
    char* _t436;
    char* _t438;
    DownloadList* _t443;
    intOrPtr _t444;
    signed int _t446;
    int _t453;
    int _t465;
    int _t477;
    DownloadList* _t485;
    _unknown_ _t496;
    _unknown_ _t499;
    _unknown_ _t504;
    _unknown_ _t505;
    _unknown_ _t512;
    _unknown_ _t514;
    signed int _t518;
    signed int _t526;
    signed int _t536;
    signed int _t537;
    _unknown_ _t541;
    _unknown_ _t548;
    intOrPtr _t554;
    _unknown_ _t555;
    _unknown_ _t556;
    _unknown_ _t559;
    _unknown_ _t566;
    _unknown_ _t570;
    _unknown_ _t577;
    intOrPtr _t581;
    _unknown_ _t583;
    _unknown_ _t590;
    _unknown_ _t594;
    _unknown_ _t601;
    intOrPtr _t605;
    _unknown_ _t606;
    _unknown_ _t609;
    intOrPtr _t610;
    _unknown_ _t626;
    _unknown_ _t628;

    _v36 = 0;
    _t297 = FirstDL;
    if(_t297 == 0) {
        return 0;
    }
     *__esp = 0;
    time();
    _v40 = _t297;
    _v36 = Strnew_charp("<html><head><title>Download List Panel</title></head>\n<body><h1 align=center>Download List Panel</h1>\n<form method=internal action=download><hr>\n");
    _v32 = LastDL;
    while(_v32 != 0) {
        if(( *(_v32 + 16) |  *(_v32 + 20)) == 0) {
L28:
            if(_v32->ok != 0) {
L33:
                 *__esp = _v56;
                _v216 = 0;
                _v216 = convert_size3();
                Strcat(_v36, Sprintf("  %s bytes loaded"));
                goto L34;
            }
            goto L29;
L34:
            if(_v44 > 0) {
                _v176 = _v44;
                _v48 = _v56 / _v176;
                _t364 = _v48;
                _v212 = 1;
                 *__esp = _t364;
                _v216 = _t364 >> 31;
                _t365 = convert_size();
                _t519 = _v44;
                _t520 = _v44;
                _t522 = ((_v44 * -2004318071 >> 32) + _v44 >> 5) - (_t520 >> 31);
                _v204 = _t365;
                _v208 = _v44 - (((_v44 * -2004318071 >> 32) + _v44 >> 5) - (_t519 >> 31) << 2 << 4) - (((_v44 * -2004318071 >> 32) + _v44 >> 5) - (_t519 >> 31) << 2);
                _v212 = ((_v44 * -2004318071 >> 32) + _v44 >> 5) - (_t520 >> 31) - ((((((_v44 * -2004318071 >> 32) + _v44 >> 5) - (_t520 >> 31)) * -2004318071 >> 32) + ((_v44 * -2004318071 >> 32) + _v44 >> 5) - (_t520 >> 31) >> 5) - (_t522 >> 31) << 2 << 4) - ((((((_v44 * -2004318071 >> 32) + _v44 >> 5) - (_t520 >> 31)) * -2004318071 >> 32) + ((_v44 * -2004318071 >> 32) + _v44 >> 5) - (_t520 >> 31) >> 5) - (_t522 >> 31) << 2);
                _v216 = ((_v44 * -1851608123 >> 32) + _v44 >> 11) - (_v44 >> 31);
                Strcat(_v36, Sprintf("  %02d:%02d:%02d  rate %s/sec"));
                if(_v32->ok == 0) {
                    _t526 = _v56;
                    _t395 = _v32;
                    _t581 =  *((intOrPtr*)(_t395 + 20));
                    _t396 =  *((intOrPtr*)(_t395 + 16));
                    if(0 <= _t581 && (0 < _t581 || _t526 < _t396) && _v48 != 0) {
                        asm("sbb edx, ebx");
                        _v52 = L080C6EC0( *(_v32 + 16) - _v56,  *(_v32 + 20), _v48, _v48 >> 31);
                        _t529 = _v52;
                        _t530 = _v52;
                        _t532 = ((_v52 * -2004318071 >> 32) + _v52 >> 5) - (_t530 >> 31);
                        _v208 = _v52 - (((_v52 * -2004318071 >> 32) + _v52 >> 5) - (_t529 >> 31) << 2 << 4) - (((_v52 * -2004318071 >> 32) + _v52 >> 5) - (_t529 >> 31) << 2);
                        _v212 = ((_v52 * -2004318071 >> 32) + _v52 >> 5) - (_t530 >> 31) - ((((((_v52 * -2004318071 >> 32) + _v52 >> 5) - (_t530 >> 31)) * -2004318071 >> 32) + ((_v52 * -2004318071 >> 32) + _v52 >> 5) - (_t530 >> 31) >> 5) - (_t532 >> 31) << 2 << 4) - ((((((_v52 * -2004318071 >> 32) + _v52 >> 5) - (_t530 >> 31)) * -2004318071 >> 32) + ((_v52 * -2004318071 >> 32) + _v52 >> 5) - (_t530 >> 31) >> 5) - (_t532 >> 31) << 2);
                        _v216 = ((_v52 * -1851608123 >> 32) + _v52 >> 11) - (_v52 >> 31);
                        Strcat(_v36, Sprintf("  eta %02d:%02d:%02d"));
                    }
                }
            }
            if( &((1)[_v36->length]) >= _v36->area_size) {
                Strgrow(_v36);
            }
            _t334 = _v36->length;
             *((char*)( *_v36 + _t334)) = 10;
            _v36->length =  &((1)[_t334]);
             *( *_v36 + _v36->length) = 0;
            if(_v32->ok == 0) {
                _v216 =  *_v32;
                Strcat(_v36, Sprintf("<input type=submit name=stop%d value=STOP>"));
            } else {
                _v216 =  *_v32;
                Strcat(_v36, Sprintf("<input type=submit name=ok%d value=OK>"));
                _t518 = _v56;
                _t356 = _v32;
                _t554 =  *((intOrPtr*)(_t356 + 20));
                _t357 =  *((intOrPtr*)(_t356 + 16));
                if(0 > _t554 || 0 >= _t554 && _t518 >= _t357) {
                    Strcat_charp(_v36, " Download completed");
                } else {
                    Strcat_charp(_v36, " Download incompleted");
                }
            }
            Strcat_charp(_v36, "\n</pre><hr>\n");
            _v32 = _v32->prev;
            continue;
        } else {
            _v64 = COLS - 6;
            _t537 = _v56;
            _t443 = _v32;
            _t610 =  *((intOrPtr*)(_t443 + 20));
            _t444 =  *((intOrPtr*)(_t443 + 16));
            if(0 > _t610 || 0 >= _t610 && _t537 >= _t444) {
                _v60 = _v64;
            } else {
                asm("fild dword [ebp-0x3c]");
                _v164 = _v56;
                _v160 = 0;
                asm("fild qword [ebp+0xffffff60]");
                asm("fmulp st1, st0");
                _t485 = _v32;
                _v164 =  *(_t485 + 16);
                _v160 =  *(_t485 + 20);
                asm("fild qword [ebp+0xffffff60]");
                asm("fdivp st1, st0");
                asm("fnstcw word [ebp+0xffffff5e]");
                _v168 = _v166 & 65535 & 4294967295;
                asm("fldcw word [ebp+0xffffff5c]");
                asm("fistp dword [ebp-0x38]");
                asm("fldcw word [ebp+0xffffff5e]");
            }
            _t446 = _v60;
            _v64 = _v64 - _t446;
            while(1) {
                _v60 = _v60 - 1;
                if((_t446 & 4294967295) == 0) {
                    break;
                }
                if( &((1)[_v36->length]) >= _v36->area_size) {
                    Strgrow(_v36);
                }
                _t453 = _v36->length;
                 *((char*)( *_v36 + _t453)) = 35;
                _v36->length =  &((1)[_t453]);
                _t446 =  *_v36 + _v36->length;
                 *_t446 = 0;
            }
            while(1) {
                _v64 = _v64 - 1;
                if((_t446 & 4294967295) == 0) {
                    break;
                }
                if( &((1)[_v36->length]) >= _v36->area_size) {
                    Strgrow(_v36);
                }
                _t465 = _v36->length;
                 *((char*)( *_v36 + _t465)) = 95;
                _v36->length =  &((1)[_t465]);
                _t446 =  *_v36 + _v36->length;
                 *_t446 = 0;
            }
            if( &((1)[_v36->length]) >= _v36->area_size) {
                Strgrow(_v36);
            }
            _t477 = _v36->length;
             *((char*)( *_v36 + _t477)) = 10;
            _v36->length =  &((1)[_t477]);
             *( *_v36 + _v36->length) = 0;
            goto L28;
        }
L29:
        _t536 = _v56;
        _t428 = _v32;
        _t605 =  *((intOrPtr*)(_t428 + 20));
        _t429 =  *((intOrPtr*)(_t428 + 16));
        if(0 > _t605 || 0 >= _t605 && _t536 >= _t429) {
            goto L33;
        } else {
            _v164 = _v56;
            _v160 = 0;
            asm("fild qword [ebp+0xffffff60]");
            asm("fld qword [0x80c8e68]");
            asm("fmulp st1, st0");
            _t431 = _v32;
            _v164 =  *(_t431 + 16);
            _v160 =  *(_t431 + 20);
            asm("fild qword [ebp+0xffffff60]");
            asm("fdivp st1, st0");
            asm("fnstcw word [ebp+0xffffff5e]");
            _v168 = _v166 & 65535 & 4294967295;
            asm("fldcw word [ebp+0xffffff5c]");
            asm("fistp dword [ebp+0xffffff58]");
            asm("fldcw word [ebp+0xffffff5e]");
            _t434 = _v32;
             *__esp =  *(_t434 + 16);
            _v216 =  *(_t434 + 20);
            _t436 = convert_size3();
             *__esp = _v56;
            _v216 = 0;
            _t438 = convert_size3();
            _v208 = _v172;
            _v212 = _t436;
            _v216 = _t438;
            Strcat(_v36, Sprintf("  %s / %s bytes (%d%%)"));
        }
        goto L34;
    }
}

download_action(struct parsed_tagarg* arg)
{// addr = 0x0805A352
    DownloadList* d;
    pid_t pid;
    struct _DownloadList* _v16;
    int _v20;
    _unknown_ _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    _unknown_ _t63;

L18:
    while(arg != 0) {
        if(strncmp(arg->arg, "stop", 4) != 0) {
            if(strncmp(arg->arg, "ok", 2) != 0) {
                goto L17;
            }
            goto L4;
        }
        _v20 = atoi( &(arg->arg->value));
        _v40 = 9;
         *__esp = _v20;
        kill();
L5:
        _v16 = FirstDL;
        while(_v16 != 0) {
            if( *_v16 != _v20) {
                _v16 = _v16->next;
                continue;
            }
            unlink(_v16->lock);
            if(_v16->prev == 0) {
                FirstDL = _v16->next;
            } else {
                _v16->prev->next = _v16->next;
            }
            if(_v16->next == 0) {
                LastDL = _v16->prev;
            } else {
                _v16->next->prev = _v16->prev;
            }
L17:
            arg = arg->next;
            goto L18;
        }
L4:
        _v20 = atoi( &(arg->arg[2]));
        goto L5;
    }
}

stopDownload()
{// addr = 0x0805A47A
    DownloadList* d;
    struct _DownloadList* _v16;
    intOrPtr _v40;
    _unknown_ __ebp;
    _unknown_ _t20;

    if(FirstDL == 0) {
        return ;
    }
    _v16 = FirstDL;
    while(_v16 != 0) {
        if(_v16->ok == 0) {
            _v40 = 9;
             *__esp =  *_v16;
            kill();
            unlink(_v16->lock);
        }
        _v16 = _v16->next;
    }
}

ldDL()
{// addr = 0x0805A4D7
    Buffer* buf;
    int replace;
    int new_tab;
    int reload;
    Buffer* _v16;
    int _v20;
    int _v24;
    int _v28;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t115;

    _v20 = 0;
    _v24 = 0;
    asm("cwde ");
    if((CurrentTab->currentBuffer->bufferprop & 65535 & 8) != 0) {
        if(strcmp(CurrentTab->currentBuffer->buffername, "Download List Panel") == 0) {
            _v20 = 1;
        }
    }
    if(FirstDL != 0) {
        _v28 = checkDownloadList();
        _v16 = DownloadListBuffer();
        if(_v16 != 0) {
            _v16->bufferprop = (_v16->bufferprop & 65535 | 24) & 4294967295;
            if(_v20 != 0) {
                _v16->rootX = CurrentTab->currentBuffer->rootX & 65535 & 4294967295;
                _v16->rootY = CurrentTab->currentBuffer->rootY & 65535 & 4294967295;
                _v16->COLS = CurrentTab->currentBuffer->COLS & 65535 & 4294967295;
                _v16->LINES = CurrentTab->currentBuffer->LINES & 65535 & 4294967295;
                restorePosition(_v16, CurrentTab->currentBuffer);
            }
            if(_v20 == 0 && open_tab_dl_list != 0) {
                _newT();
                _v24 = 1;
            }
            pushBuffer(_v16);
            if(_v20 != 0 || _v24 != 0) {
                deletePrevBuf();
            }
            if(_v28 != 0) {
                CurrentTab->currentBuffer->event = setAlarmEvent(CurrentTab->currentBuffer->event, 1, 2, 112, 0);
            }
            displayBuffer(CurrentTab->currentBuffer, 1);
            return;
        }
        goto L13;
    }
    if(_v20 == 0) {
        return ;
    }
    if(CurrentTab->currentBuffer != CurrentTab->firstBuffer || CurrentTab->currentBuffer->nextBuffer != 0) {
        delBuffer(CurrentTab->currentBuffer);
    } else {
        if(nTab > 1) {
            deleteTab(CurrentTab);
        }
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
L13:
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

save_buffer_position(Buffer* buf)
{// addr = 0x0805A6F6
    BufferPos* b;
    struct _BufferPos* _v16;
    _unknown_ __ebp;
    int _t75;
    struct _BufferPos _t78;
    long int _t81;
    int _t88;
    struct _BufferPos _t125;
    long int _t126;

    _v16 = buf->undo;
    _t75 = buf->firstLine;
    if(_t75 == 0) {
        return ;
    }
    if(_v16 != 0) {
        _t125 =  *_v16;
        if(buf->topLine == 0) {
            _t75 = 1;
        } else {
            _t75 = buf->topLine->linenumber;
        }
        if(_t125 == _t75) {
            _t126 = _v16->cur_linenumber;
            if(buf->currentLine == 0) {
                _t75 = 1;
            } else {
                _t75 = buf->currentLine->linenumber;
            }
            if(_t126 == _t75) {
                _t75 = buf->currentColumn;
                if(_v16->currentColumn == _t75) {
                    _t75 = buf->pos;
                    if(_v16->pos == _t75) {
                        return ;
                    }
                }
            }
        }
    }
     *__esp = 28;
    GC_malloc();
    _v16 = _t75;
    if(buf->topLine == 0) {
        _t78 = 1;
    } else {
        _t78 = buf->topLine->linenumber;
    }
     *_v16 = _t78;
    if(buf->currentLine == 0) {
        _t81 = 1;
    } else {
        _t81 = buf->currentLine->linenumber;
    }
    _v16->cur_linenumber = _t81;
    _v16->currentColumn = buf->currentColumn;
    _v16->pos = buf->pos;
    if(buf->currentLine == 0) {
        _t88 = 0;
    } else {
        _t88 = buf->currentLine->bpos;
    }
    _v16->bpos = _t88;
    _v16->next = 0;
    _v16->prev = buf->undo;
    if(buf->undo != 0) {
        buf->undo->next = _v16;
    }
    buf->undo = _v16;
    return;
}

resetPos(BufferPos* b)
{// addr = 0x0805A856
    Buffer buf;
    Line top;
    Line cur;
    long int _v36;
    char _v64;
    int _v72;
    long int _v88;
    char _v116;
    struct _Buffer _v376;
    _unknown_ _v392;
    _unknown_ __ebp;

    _v36 = b->top_linenumber;
    _v88 = b->cur_linenumber;
    _v72 = b->bpos;
    _v376.topLine =  &_v64;
    _v376.currentLine =  &_v116;
    _v376.pos = b->pos;
    _v376.currentColumn = b->currentColumn;
    restorePosition(CurrentTab->currentBuffer,  &_v376);
    CurrentTab->currentBuffer->undo = b;
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
}

undoPos()
{// addr = 0x0805A8E8
    BufferPos* b;
    int i;
    struct _BufferPos* _v16;
    intOrPtr _v20;
    _unknown_ __ebp;
    _unknown_ _t28;

    _v16 = CurrentTab->currentBuffer->undo;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    if(_v16 == 0) {
        return ;
    }
    if(_v16->prev == 0) {
        return ;
    }
    _v20 = 0;
    while() {
    }
}

redoPos()
{// addr = 0x0805A96E
    BufferPos* b;
    int i;
    struct _BufferPos* _v16;
    intOrPtr _v20;
    _unknown_ __ebp;
    _unknown_ _t28;

    _v16 = CurrentTab->currentBuffer->undo;
    if(CurrentTab->currentBuffer->firstLine == 0) {
        return ;
    }
    if(_v16 == 0) {
        return ;
    }
    if(_v16->next == 0) {
        return ;
    }
    _v20 = 0;
    while() {
    }
}

KeyAbort(int _dummy)
{// addr = 0x0805A9F4
    intOrPtr _v0;
    signed char* _v24;
    _unknown_ __ebp;
    signed int _t12;
    _unknown_ _t17;
    _unknown_ _t19;
    _unknown_ _t20;

    _v24 = 1;
     *__esp =  &AbortLoading;
    siglongjmp();
    _push(_t19);
    __esp = __esp - 24;
    _t12 =  *_v24 & 255 & 4294967295 & ;
    if(_t12 == 7 || _t12 == 9) {
        closeNews();
        return;
    } else {
        if(_t12 != 2) {
            goto L6;
        }
        closeFTP();
        return;
    }
L6:
    if(ISclose( *(_v0 + 4)) != 0) {
        return ;
    }
     *(_v0 + 4) = 0;
    return;
}

UFhalfclose(URLFile* f)
{// addr = 0x0805AA0E
    _unknown_ __ebp;
    signed int _t11;
    _unknown_ _t16;

    _t11 = f->scheme & 255 & 4294967295 & ;
    if(_t11 == 7 || _t11 == 9) {
        closeNews();
        return;
    } else {
        if(_t11 != 2) {
            goto L5;
        }
        closeFTP();
        return;
    }
L5:
    if(ISclose( *(f + 4)) != 0) {
        return ;
    }
     *(f + 4) = 0;
    return;
}

int currentLn(Buffer* buf)
{// addr = 0x0805AA60
    _unknown_ __ebp;
    _unknown_ _t8;

    if(buf->currentLine == 0) {
        return 1;
    }
    return buf->currentLine->linenumber + 1;
}

Buffer* loadSomething(URLFile* f, char* path, _None* loadproc, Buffer* defaultbuf)
{// addr = 0x0805AA82
    Buffer* buf;
    URLFile* _v16;
    _unknown_ _v36;
    Buffer* _v40;
    _unknown_ __ebp;
    _None* _t45;
    URLFile* _t49;
    _unknown_ _t59;
    struct _Str* _t66;
    _unknown_ _t71;

    _v40 = defaultbuf;
     *__esp = f;
    _t45 = loadproc;
     *_t45();
    _v16 = _t45;
    if(_v16 == 0) {
        return ;
    }
     *_v16 = path;
    if( *(_v16 + 4) == 0 || ( *( *(_v16 + 4)) & 255 & 4294967295) == 0) {
        _v40 = "Subject:";
        _t49 = _v16;
         *__esp = _t49;
        checkHeader();
         *(_v16 + 4) = _t49;
        if( *(_v16 + 4) == 0) {
            _t66 = path;
            lastFileName(_t66);
            Strnew_charp(_t66);
            wc_Str_conv(_t66, SystemCharset, InnerCharset);
             *(_v16 + 4) = _t66->ptr;
        }
    }
    if( *(_v16 + 132) == 255) {
         *(_v16 + 132) = f->scheme & 255 & 4294967295 & ;
    }
     *(_v16 + 180) = f->scheme & 255 & 4294967295 & ;
    if((f->scheme & 255 & 4294967295) != 4) {
        return ;
    }
    if( *(_v16 + 184) != 0) {
        return ;
    }
     *(_v16 + 184) = path;
    return ;
}

int dir_exist(char* path)
{// addr = 0x0805AB89
    struct stat stbuf;
    signed int _v84;
    char _v100;
    _unknown_ _v120;
    _unknown_ __ebp;
    _unknown_ _t10;
    char* _t13;
    _unknown_ _t17;

    if(path == 0) {
        return 0;
    }
    if(( *path & 255 & 4294967295) == 0) {
        return 0;
    }
    _t13 = path;
    L080C7280(_t13,  &_v100);
    if(_t13 != 255) {
        return _v84 & 61440 & 4294967295 & ;
    }
    return 0;
}

int is_dump_text_type(char* type)
{// addr = 0x0805ABD9
    struct mailcap* mcap;
    struct mailcap* _v16;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t13;

    if(type == 0) {
        return 0;
    }
    _v16 = searchExtViewer(type);
    if(_v16 == 0) {
        return 0;
    }
    if((_v16->flags & 6) == 0) {
        return 0;
    }
    return 1;
}

int is_text_type(char* type)
{// addr = 0x0805AC14
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t10;
    _unknown_ _t17;

    if(type == 0) {
        return 1;
    }
    if(( *type & 255 & 4294967295) == 0) {
        return 1;
    }
    if(strncasecmp(type, "text/", 5) == 0) {
        return 1;
    }
    if(strncasecmp(type, "message/", 8) != 0) {
        return 0;
    }
    return 1;
}

int is_plain_text_type(char* type)
{// addr = 0x0805AC76
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t8;
    _unknown_ _t11;

    if(type != 0) {
        if(strcasecmp(type, "text/plain") == 0) {
            return 1;
        }
    }
    if(is_text_type(type) == 0) {
        return 0;
    }
    if(is_dump_text_type(type) != 0) {
        return 0;
    }
    return 1;
}

int is_html_type(char* type)
{// addr = 0x0805ACC5
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t6;
    _unknown_ _t9;

    if(type == 0) {
        return 0;
    }
    if(strcasecmp(type, "text/html") == 0) {
        return 1;
    }
    if(strcasecmp(type, "application/xhtml+xml") != 0) {
        return 0;
    }
    return 1;
}

check_compression(char* path, URLFile* uf)
{// addr = 0x0805AD0D
    int len;
    struct compression_decoder* d;
    int elen;
    int _v16;
    struct compression_decoder[4]* _v20;
    int _v24;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;

    if(path == 0) {
        return ;
    }
    _v16 = strlen(path);
    uf->compression = 0;
    _v20 =  &compression_decoders;
    while( *_v20 != 0) {
        if( *(_v20 + 4) != 0) {
            _v24 = strlen( *(_v20 + 4));
            if(_v16 <= _v24 || strcasecmp(_v16 - _v24 + path,  *(_v20 + 4)) != 0) {
                goto L7;
            } else {
                uf->compression =  *_v20;
                uf->guess_type =  *(_v20 + 8);
                return;
            }
        }
L7:
        _v20 = _v20 + 44;
    }
}

char* compress_application_type(int compression)
{// addr = 0x0805ADB7
    struct compression_decoder* d;
    struct compression_decoder[4]* _v8;
    _unknown_ __ebp;
    _unknown_ _t15;

    _v8 =  &compression_decoders;
    while( *_v8 != 0) {
        if( *_v8 == compression) {
            return  *((intOrPtr*)(_v8 + 8));
        }
        _v8 = _v8 + 44;
    }
}

char* uncompressed_file_type(char* path, char** ext)
{// addr = 0x0805ADEC
    int len;
    int slen;
    Str fn;
    char* t0;
    struct compression_decoder* d;
    int _v16;
    int _v20;
    struct _Str* _v24;
    char* _v28;
    struct compression_decoder[4]* _v32;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t65;
    _unknown_ _t66;

    if(path == 0) {
        return 0;
    }
    _v20 = 0;
    _v16 = strlen(path);
    _v32 =  &compression_decoders;
    while( *_v32 != 0) {
        if( *(_v32 + 4) == 0) {
            goto L8;
        }
        _v20 = strlen( *(_v32 + 4));
        if(_v16 <= _v20) {
            goto L8;
        }
        if(strcasecmp(_v16 - _v20 + path,  *(_v32 + 4)) == 0) {
            if( *_v32 == 0) {
                return 0;
            }
            _v24 = Strnew_charp(path);
            Strshrink(_v24, _v20);
            if(ext != 0) {
                 *ext = filename_extension( *_v24, 0);
            }
            _v28 = guessContentType( *_v24);
            if(_v28 != 0) {
                return _v28;
            }
            _v28 = "text/plain";
            return _v28;
        }
L8:
        _v32 = _v32 + 44;
    }
}

int setModtime(char* path, time_t modtime)
{// addr = 0x0805AEF2
    struct utimbuf t;
    struct stat st;
    long int _v16;
    char _v20;
    char* _v52;
    char _v108;
    char* _v120;
    _unknown_ __ebp;
    char* _t12;
    int _t15;

    _t12 = path;
    L080C7280(_t12,  &_v108);
    if(_t12 != 0) {
         *__esp = 0;
        time();
        _v20 = _t12;
    } else {
        _v20 = _v52;
    }
    _v16 = modtime;
    _v120 =  &_v20;
    _t15 = path;
     *__esp = _t15;
    utime();
    return _t15;
}

examineFile(char* path, URLFile* uf)
{// addr = 0x0805AF3F
    struct stat stbuf;
    FILE* fp;
    char* ext;
    char* t0;
    FILE* _v16;
    char* _v20;
    char* _v24;
    signed int _v96;
    char _v112;
    char** _v136;
    _unknown_ __ebp;
    char* _t64;
    _unknown_ _t101;

    uf->guess_type = 0;
    if(path == 0 || ( *path & 255 & 4294967295) == 0) {
L4:
         *(uf + 4) = 0;
        return;
    } else {
        _t64 = path;
        L080C7280(_t64,  &_v112);
        if(_t64 == 255 || (_v96 & 61440) != 32768) {
            goto L4;
        }
    }
L5:
    _v136 = 0;
     *__esp = path;
     *(uf + 4) = newInputStream(open());
    if(do_download != 0) {
        return ;
    }
    if(use_lessopen == 0 || getenv("LESSOPEN") == 0) {
L15:
        check_compression(path, uf);
        if(uf->compression == 0) {
            return ;
        }
L16:
        _v20 = uf->ext;
        _v24 = uncompressed_file_type(path,  &_v20);
        uf->guess_type = _v24;
        uf->ext = _v20;
        uncompress_stream(uf, 0);
        return;
    } else {
        uf->guess_type = guessContentType(path);
        if(uf->guess_type == 0) {
            uf->guess_type = "text/plain";
        }
        if(is_html_type(uf->guess_type) != 0) {
            return ;
        }
        _v16 = lessopen_stream(path);
        if(_v16 == 0) {
            goto L15;
        } else {
            if(ISclose( *(uf + 4)) == 0) {
                 *(uf + 4) = 0;
            }
             *(uf + 4) = newFileStream(_v16, pclose);
            uf->guess_type = "text/plain";
            return;
        }
        goto L16;
    }
}

int check_command(char* cmd, int auxbin_p)
{// addr = 0x0805B0E4
    Str dirs;
    char* p;
    char* np;
    Str pathname;
    struct stat st;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    struct _Str* _v28;
    signed int _v100;
    char _v116;
    _unknown_ _v136;
    _unknown_ __ebp;
    int _t61;
    struct _Str _t70;
    _unknown_ _t72;
    _unknown_ _t77;

    if( *135776672 == 0) {
         *135776672 = getenv("PATH");
    }
    if(auxbin_p == 0) {
        _v16 = Strnew_charp( *135776672);
    } else {
        _v16 = Strnew_charp(w3m_auxbin_dir());
    }
    _v20 =  *_v16;
    while(_v20 != 0) {
        _v24 = strchr(_v20, 58);
        if(_v24 != 0) {
             *_v24 = 0;
            _v24 =  &(_v24[1]);
        }
        _v28 = Strnew();
        Strcat_charp(_v28, _v20);
        if(_v28->length + 1 >= _v28->area_size) {
            Strgrow(_v28);
        }
        _t61 = _v28->length;
         *((char*)( *_v28 + _t61)) = 47;
        _v28->length = _t61 + 1;
         *( *_v28 + _v28->length) = 0;
        Strcat_charp(_v28, cmd);
        _t70 =  *_v28;
        L080C7280(_t70,  &_v116);
        if(_t70 == 0 && (_v100 & 61440) == 32768) {
            if((_v100 & 73) != 0) {
                return 1;
            }
        }
        _v20 = _v24;
    }
}

char* acceptableEncoding()
{// addr = 0x0805B228
    struct compression_decoder* d;
    TextList* l;
    char* p;
    struct compression_decoder[4]* _v16;
    GeneralList* _v20;
    _unknown_ _v24;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(encodings != 0) {
        return encodings->ptr;
    }
    _v20 = newGeneralList();
    _v16 =  &compression_decoders;
    while( *_v16 != 0) {
        if(check_command( *(_v16 + 16),  *(_v16 + 12)) != 0) {
            pushValue(_v20, allocStr( *(_v16 + 24), -1));
        }
        _v16 = _v16 + 44;
    }
}

Str convertLine(URLFile* uf, Str line, int mode, wc_ces* charset, wc_ces doc_charset)
{// addr = 0x0805B300
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    line = wc_Str_conv_with_detect(line, charset, doc_charset, InnerCharset);
    if(mode != 0) {
        cleanup_line(line, mode);
    }
    if(uf == 0) {
        return line;
    }
    if((uf->scheme & 255 & 4294967295) != 9) {
        return line;
    }
    Strchop(line);
    return line;
}

Buffer* loadFile(char* path)
{// addr = 0x0805B363
    Buffer* buf;
    URLFile uf;
    Buffer* _v16;
    struct  _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t26;
    _unknown_ _t27;
    _unknown_ _t38;
    int _t41;
    _unknown_ _t42;

    init_stream( &_v48, 4, 0);
    examineFile(path,  &_v48);
    if(_v44 == 0) {
        return 0;
    }
    _t41 = COLS;
    if(showLineNum == 0) {
        _t26 = 1;
    } else {
        _t26 = 6;
    }
    _t27 = _t41 - _t26;
    _t28 = _t27 >= 0 ? 0 : _t27;
    _v16 = newBuffer(_t27 >= 0 ? 0 : _t27);
    current_content_length = 0;
     *135776436 = 0;
    content_charset = 0;
    _v16 = loadSomething( &_v48, path, loadBuffer, _v16);
    if(ISclose(_v44) != 0) {
        return _v16;
    }
    _v48.stream = 0;
    return _v16;
}

int matchattr(char* p, char* attr, int len, Str* value)
{// addr = 0x0805B43F
    int quoted;
    char* q;
    signed int _v16;
    signed int _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t90;
    _unknown_ _t96;
    _unknown_ _t106;
    signed int _t126;
    struct _Str* _t136;
    int _t172;

    _v20 = 0;
    if(strncasecmp(p, attr, len) != 0) {
        return 0;
    }
    p =  &(p[len]);
L3:
    while(( *p & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            p =  &(p[1]);
            goto L3;
        }
        if(value == 0) {
            if(( *p & 255 & 4294967295) == 0) {
                return 1;
            }
            if(( *p & 255 & 4294967295) == 13) {
                return 1;
            }
            if(( *p & 255 & 4294967295) == 10) {
                return 1;
            }
            if(( *p & 255 & 4294967295) != 59) {
                return 0;
            }
            return 1;
        } else {
             *value = Strnew();
            if(( *p & 255 & 4294967295) != 61) {
                return 1;
            }
            p =  &(p[1]);
            while(( *p & 255 & 4294967295) != 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                    p =  &(p[1]);
                    continue;
                }
                _v16 = 0;
                while(( *p & 255 & 4294967295) != 0 && ( *p & 255 & 4294967295) != 13 && ( *p & 255 & 4294967295) != 10 && (_v16 != 0 || ( *p & 255 & 4294967295) != 59)) {
                    if(( *( &MYCTYPE_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                        _v20 = p;
                    }
                    _t126 =  *p & 255;
                    if((_t126 & 4294967295) != 34) {
                        if( *value->length + 1 >=  *value->area_size) {
                            Strgrow( *value);
                        }
                        _t136 =  *value;
                        _t172 = _t136->length;
                         *( *( *value) + _t172) =  *p & 255 & 4294967295;
                        _t136->length = _t172 + 1;
                         *( *( *value) +  *value->length) = 0;
                    } else {
                        _v16 = _t126 & 4294967295 & ;
                    }
                    p =  &(p[1]);
                }
            }
        }
    }
}

char* xface2xpm(char* xface)
{// addr = 0x0805B62E
    Image image;
    ImageCache* cache;
    FILE* f;
    struct stat st;
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v46;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v100;
    _unknown_ _v144;
    _unknown_ _v164;
    _unknown_ _v168;
    _unknown_ __ebp;
    _unknown_ _t65;
    _unknown_ _t67;
    _unknown_ _t72;
    _unknown_ _t74;
    _unknown_ _t76;
    _unknown_ _t77;
    _unknown_ _t83;
    _unknown_ _t85;

    while(( *xface & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *xface & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
    }
}

readHeader(URLFile* uf, Buffer* newBuf, int thru, ParsedURL* pu)
{// addr = 0x0805B7A0
    char* p;
    char* q;
    char* emsg;
    char c;
    Str lineBuf2;
    Str tmp;
    TextList* headerlist;
    wc_ces charset;
    wc_ces mime_charset;
    char* tmpf;
    FILE* src;
    Lineprop* propBuffer;
    FILE* ff;
    Str src;
    URLFile f;
    Line* l;
    wc_ces old_charset;
    struct compression_decoder* d;
    char** e;
    Str name;
    Str value;
    Str domain;
    Str path;
    Str comment;
    Str commentURL;
    Str port;
    Str tmp2;
    int version;
    int quoted;
    int flag;
    time_t expires;
    int err;
    char* ans;
    Str msg;
    Str funcname;
    int f;
    _unknown_ _v13;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    Linecolor* _v32;
    struct _Str* _v36;
    TextList* _v40;
    intOrPtr _v44;
    _unknown_ _v48;
    char* _v52;
    struct _IO_FILE* _v56;
    Lineprop* _v60;
    struct _IO_FILE* _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ _v92;
    _unknown_ _v96;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ _v108;
    _unknown_ _v112;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ _v124;
    _unknown_ _v128;
    _unknown_ _v132;
    _unknown_ _v136;
    _unknown_ _v140;
    _unknown_ _v144;
    _unknown_ _v148;
    _unknown_ _v152;
    _unknown_ _v184;
    _unknown_ _v196;
    _unknown_ _v200;
    _unknown_ _v204;
    _unknown_ _v208;
    _unknown_ _v212;
    _unknown_ _v216;
    _unknown_ _v220;
    _unknown_ _v224;
    _unknown_ _v228;
    _unknown_ _v232;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t714;
    _unknown_ _t733;
    _unknown_ _t803;
    _unknown_ _t848;
    _unknown_ _t878;
    _unknown_ _t919;
    _unknown_ _t963;
    _unknown_ _t1004;
    _unknown_ _t1011;
    _unknown_ _t1042;
    _unknown_ _t1133;
    _unknown_ _t1139;
    _unknown_ _t1160;
    _unknown_ _t1170;
    _unknown_ _t1171;
    _unknown_ _t1206;
    _unknown_ _t1214;
    _unknown_ _t1228;
    _unknown_ _t1235;
    _unknown_ _t1237;
    _unknown_ _t1250;
    _unknown_ _t1258;
    _unknown_ _t1302;
    _unknown_ _t1312;
    _unknown_ _t1313;

    _v32 = 0;
    _v44 = 256;
    _v56 = 0;
    newBuf->document_header = newGeneralList();
    _v40 = newBuf->document_header;
    if((uf->scheme & 255 & 4294967295) != 0) {
        http_response_code = 0;
    } else {
        http_response_code = -1;
    }
    if(thru != 0) {
        if(newBuf->header_source == 0) {
            if(image_source == 0) {
                _v52 =  *(tmpfname(0, 0));
                _v56 = fopen(_v52, "w");
                if(_v56 != 0) {
                    newBuf->header_source = _v52;
                }
            }
        }
    }
    while(1) {
        _v36 = StrmyISgets( *(uf + 4));
        if(_v36->length == 0) {
            break;
        } else {
            if((uf->scheme & 255 & 4294967295) == 9) {
                if(( *( *_v36) & 255 & 4294967295) == 46) {
                    Strdelete(_v36, 0, 1);
                }
            }
            if(w3m_reqlog != 0) {
                _v64 = fopen(w3m_reqlog, "a");
                fwrite( *_v36, 1, _v36->length, _v64);
                fclose(_v64);
            }
            if(_v56 != 0) {
                fwrite( *_v36, 1, _v36->length, _v56);
            }
            goto L15;
        }
    }
    if(thru != 0) {
        addnewline(newBuf, 135041709, _v60, 0, 0, -1, -1);
    }
    if(_v56 == 0) {
        return ;
    }
    fclose(_v56);
    return;
}

char* checkHeader(Buffer* buf, char* field)
{// addr = 0x0805CB59
    int len;
    TextListItem* i;
    char* p;
    int _v16;
    struct _textlistitem* _v20;
    char* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t24;
    _unknown_ _t37;

    if(buf == 0) {
        return 0;
    }
    if(field == 0) {
        return 0;
    }
    if(buf->document_header == 0) {
        return 0;
    }
    _v16 = strlen(field);
    _v20 = buf->document_header->first;
    while(_v20 != 0) {
        if(strncasecmp( *_v20, field, _v16) != 0) {
            _v20 = _v20->next;
            continue;
        }
        _v24 =  &(( *_v20)[_v16]);
        return remove_space(_v24);
    }
}

char* checkContentType(Buffer* buf)
{// addr = 0x0805CBED
    char* p;
    Str r;
    char* _v16;
    struct _Str* _v20;
    char* _v40;
    _unknown_ __ebp;
    char* _t72;
    int _t111;
    _unknown_ _t118;

    _v16 = checkHeader(buf, "Content-Type:");
    if(_v16 == 0) {
        return 0;
    }
    _v20 = Strnew();
    while(( *_v16 & 255 & 4294967295) != 0 && ( *_v16 & 255 & 4294967295) != 59) {
        if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
            if(_v20->length + 1 >= _v20->area_size) {
                Strgrow(_v20);
            }
            _t111 = _v20->length;
             *( *_v20 + _t111) =  *_v16 & 255 & 4294967295;
            _v20->length = _t111 + 1;
            _v16 =  &(_v16[1]);
             *((char*)( *_v20 + _v20->length)) = 0;
            continue;
        }
        _v40 = "charset";
        _t72 = _v16;
         *__esp = _t72;
        strcasestr();
        _v16 = _t72;
        if(_v16 == 0) {
            return  *_v20;
        }
        _v16 =  &(_v16[7]);
        while(( *_v16 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v16 =  &(_v16[1]);
        }
    }
}

int skip_auth_token(char** pp)
{// addr = 0x0805CD5B
    char* p;
    int first;
    int typ;
    char* _v8;
    int _v12;
    int _v16;
    _unknown_ __ebp;
    _unknown_ _t33;

    _v12 = 0;
    _v8 =  *pp;
    while(( *_v8 & 255 & 4294967295) > 127) {
        if(( *_v8 & 255 & 4294967295) <= 31) {
            _v16 = 1;
        } else {
            _v16 = 2;
        }
        if(_v12 == 0) {
            _v12 = _v16;
L9:
            _v8 =  &(_v8[1]);
            continue;
        }
        if(_v12 == _v16) {
            goto L9;
        }
        goto L10;
L11:
L10:
         *pp = _v8;
        return _v12;
        goto L11;
    }
}

Str extract_auth_val(char** q)
{// addr = 0x0805CDCE
    unsigned char* qq;
    int quoted;
    Str val;
    char* _v16;
    char _v20;
    struct _Str* _v24;
    _unknown_ __ebp;
    int _t131;
    int _t145;
    int _t160;
    _unknown_ _t177;
    int _t186;

    _v16 =  *q;
    _v20 = 0;
    _v24 = Strnew();
L2:
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v16 =  &(_v16[1]);
            goto L2;
        }
        if(( *_v16 & 255 & 4294967295) == 34) {
            _v20 = 1;
            if(_v24->length + 1 >= _v24->area_size) {
                Strgrow(_v24);
            }
            _t131 = _v24->length;
             *( *_v24 + _t131) =  *_v16 & 255 & 4294967295;
            _v24->length = _t131 + 1;
            _v16 =  &(_v16[1]);
             *((char*)( *_v24 + _v24->length)) = 0;
        }
        while(( *_v16 & 255 & 4294967295) != 0) {
            if(_v20 == 0 || ( *_v16 & 255 & 4294967295) != 34) {
                if(_v20 != 0) {
L19:
                    if(_v20 != 0 && ( *_v16 & 255 & 4294967295) == 92) {
                        if(_v24->length + 1 >= _v24->area_size) {
                            Strgrow(_v24);
                        }
                        _t160 = _v24->length;
                         *( *_v24 + _t160) =  *_v16 & 255 & 4294967295;
                        _v24->length = _t160 + 1;
                        _v16 =  &(_v16[1]);
                         *((char*)( *_v24 + _v24->length)) = 0;
                    }
L24:
                    if(_v24->length + 1 >= _v24->area_size) {
                        Strgrow(_v24);
                    }
                    _t145 = _v24->length;
                     *( *_v24 + _t145) =  *_v16 & 255 & 4294967295;
                    _v24->length = _t145 + 1;
                    _v16 =  &(_v16[1]);
                     *((char*)( *_v24 + _v24->length)) = 0;
                    continue;
                }
            } else {
                if(_v24->length + 1 >= _v24->area_size) {
                    Strgrow(_v24);
                }
                _t186 = _v24->length;
                 *( *_v24 + _t186) =  *_v16 & 255 & 4294967295;
                _v24->length = _t186 + 1;
                _v16 =  &(_v16[1]);
                 *((char*)( *_v24 + _v24->length)) = 0;
L30:
                 *q = _v16;
                return _v24;
            }
L14:
            if(( *_v16 & 255 & 4294967295 & ) - 9 > 84) {
                if(( *_v16 & 255 & 4294967295) <= 31 || ( *_v16 & 255 & 4294967295) == 127) {
                    _v16 =  &(_v16[1]);
                    goto L30;
                } else {
                    goto L24;
                }
                goto L19;
            }
            goto __eax;
        }
    }
}

Str qstr_unquote(Str s)
{// addr = 0x0805D007
    char* p;
    Str tmp;
    char* _v16;
    struct _Str* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t62;
    _unknown_ _t79;

    if(s == 0) {
        return 0;
    }
    _v16 = s->ptr;
    if(( *_v16 & 255 & 4294967295) != 34) {
        return s;
    }
    _v20 = Strnew();
    _v16 =  &(_v16[1]);
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *_v16 & 255 & 4294967295) == 92) {
            _v16 =  &(_v16[1]);
        }
        if(_v20->length + 1 >= _v20->area_size) {
            Strgrow(_v20);
        }
        _t62 = _v20->length;
         *( *_v20 + _t62) =  *_v16 & 255 & 4294967295;
        _v20->length = _t62 + 1;
         *((char*)( *_v20 + _v20->length)) = 0;
        _v16 =  &(_v16[1]);
    }
}

char* extract_auth_param(char* q, struct auth_param* auth)
{// addr = 0x0805D0EB
    struct auth_param* ap;
    char* p;
    size_t len;
    int token_type;
    struct auth_param* _v16;
    char* _v20;
    int _v24;
    _unknown_ _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t168;

    _v16 = auth;
    while( *_v16 != 0) {
        while(( *q & 255 & 4294967295) != 0) {
            while(( *q & 255 & 4294967295) != 0) {
                if(( *( &MYCTYPE_MAP + ( *q & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                    q =  &(q[1]);
                    continue;
                }
                _v16 = auth;
                while( *_v16 != 0) {
                    _v24 = strlen( *_v16);
                    if(strncasecmp(q,  *_v16, _v24) != 0 || ( *( &MYCTYPE_MAP + (q[_v24] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0 && (q[_v24] & 255 & 4294967295) != 61) {
                        _v16 = _v16 + 8;
                    } else {
                        _v20 =  &(q[_v24]);
                        while(( *_v20 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                        }
                    }
                }
            }
        }
    }
}

Str get_auth_param(struct auth_param* auth, char* name)
{// addr = 0x0805D322
    struct auth_param* ap;
    struct auth_param* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t20;

    _v16 = auth;
    while( *_v16 != 0) {
        if(strcasecmp(name,  *_v16) == 0) {
            return  *((intOrPtr*)(_v16 + 4));
        }
        _v16 = _v16 + 8;
    }
}

Str AuthBasicCred(struct http_auth* ha, Str uname, Str pw, ParsedURL* pu, HRequest* hr, FormList* request)
{// addr = 0x0805D364
    Str s;
    struct _Str* _v16;
    char _v36;
    char* _v40;
    _unknown_ __ebp;
    int _t34;
    struct _Str* _t44;

    _v16 = Strdup(uname);
    if(_v16->length + 1 >= _v16->area_size) {
        Strgrow(_v16);
    }
    _t34 = _v16->length;
    ( *_v16)[_t34] = 58;
    _v16->length = _t34 + 1;
    ( *_v16)[_v16->length] = 0;
    Strcat(_v16, pw);
    _t44 = encodeB( *_v16);
    _v36 = 0;
    _v40 = _t44->ptr;
    return Strnew_m_charp("Basic ");
}

struct http_auth* findAuthentication(struct http_auth* hauth, Buffer* buf, char* auth_field)
{// addr = 0x0805D3FE
    struct http_auth* ha;
    int len;
    int slen;
    TextListItem* i;
    char* p0;
    char* p;
    int token_type;
    struct http_auth[1]* _v16;
    int _v20;
    int _v24;
    struct _textlistitem* _v28;
    char* _v32;
    char* _v36;
    _unknown_ _v40;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t104;
    _unknown_ _t115;
    _unknown_ _t143;
    _unknown_ _t194;

    _v20 = strlen(auth_field);
    bzero(hauth, 16);
    _v28 = buf->document_header->first;
    while(_v28 != 0) {
        if(strncasecmp( *_v28, auth_field, _v20) != 0) {
            _v28 = _v28->next;
        } else {
            _v36 =  &(( *_v28)[_v20]);
            while(_v36 != 0 && ( *_v36 & 255 & 4294967295) != 0) {
                while(( *_v36 & 255 & 4294967295) != 0) {
                    if(( *( &MYCTYPE_MAP + ( *_v36 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                        _v36 =  &(_v36[1]);
                        continue;
                    }
                    _v32 = _v36;
                    _v16 =  &www_auth;
                    while( *(_v16 + 4) != 0) {
                        _v24 = strlen( *(_v16 + 4));
                        if(strncasecmp(_v36,  *(_v16 + 4), _v24) != 0) {
                            _v16 = _v16 + 16;
                        } else {
                            _v36 =  &(_v36[_v24]);
                            while(( *_v36 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v36 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                                _v36 =  &(_v36[1]);
                            }
                        }
                    }
                }
            }
        }
    }
}

getAuthCookie(struct http_auth* hauth, char* auth_header, TextList* extra_header, ParsedURL* pu, HRequest* hr, FormList* request, _None* uname, _None* pwd)
{// addr = 0x0805D642
    Str ss;
    Str tmp;
    TextListItem* i;
    int a_found;
    int auth_header_len;
    char* realm;
    int proxy;
    char* pp;
    struct http_auth* _v16;
    struct _Str* _v20;
    struct _listitem* _v24;
    int _v28;
    int _v32;
    _None _v36;
    int _v40;
    char* _v44;
    FormList* _v56;
    HRequest* _v60;
    ParsedURL* _v64;
    _None _v68;
    _None _v72;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t144;
    _unknown_ _t149;
    _unknown_ _t150;
    char* _t151;
    _unknown_ _t152;
    _unknown_ _t154;
    char* _t159;
    struct http_auth* _t166;
    char* _t169;
    _Unknown_base* _t174;
    _unknown_ _t201;
    _unknown_ _t202;
    struct _Str* _t212;

    _v16 = 0;
    _v32 = strlen(auth_header);
    _v36 = 0;
    if(hauth != 0) {
        _t212 = qstr_unquote(get_auth_param(hauth->param, "realm"));
        _t129 = _t212->ptr;
        _v36 = _t212->ptr;
    }
    if(_v36 == 0) {
        return ;
    }
    _v28 = 0;
    _v24 = extra_header->first;
    while(_v24 != 0) {
        if(strncasecmp( *_v24, auth_header, _v32) != 0) {
            _v24 = _v24->next;
        } else {
            _v28 = 1;
            _v40 = strncasecmp("Proxy-Authorization:", auth_header, _v32) & 4294967295 & ;
            if(_v28 != 0) {
                if((fmInitialized & 255 & 4294967295) == 0) {
                    fwrite("Wrong username or password\n", 1, 27, __imp__stderr);
                } else {
                    message("Wrong username or password", 0, 0);
                    refresh();
                }
                sleep(1);
                delValue(extra_header, _v24);
                invalidate_auth_user_passwd(pu, _v36,  *uname,  *pwd, _v40);
            }
             *uname = 0;
             *pwd = 0;
            if(_v28 != 0 || find_auth_user_passwd(pu, _v36, uname, pwd, _v40) == 0) {
                if((QuietMessage & 255 & 4294967295) != 0) {
                    return ;
                }
                sleep(2);
                if((fmInitialized & 255 & 4294967295) == 0) {
L21:
                    if(feof(__imp__stdin) != 0 || ferror(__imp__stdin) != 0) {
                        _v68 = _v36;
                        fprintf(__imp__stderr, "w3m: Authorization required for %s\n");
                        exit(1);
                    }
                    if(_v40 == 0) {
                        _t151 = "Username for %s: ";
                    } else {
                        _t151 = "Proxy Username for %s: ";
                    }
                    _v72 = _v36;
                    printf(_t151);
                    fflush(__imp__stdout);
                     *uname = Strfgets(__imp__stdin);
                    Strchop( *uname);
                    if(_v40 == 0) {
                        _t159 = "Password: ";
                    } else {
                        _t159 = "Proxy Password: ";
                    }
                     *pwd = Strnew_charp(getpass(_t159));
                    goto L31;
                } else {
                    term_raw();
                    _v72 = _v36;
                    _v44 = inputLineHistSearch( *(Sprintf("Username for %s: ")), 0, 16, 0, 0);
                    if(_v44 == 0) {
                        return ;
                    }
                     *uname = wc_Str_conv_strict(Strnew_charp(_v44), InnerCharset, SystemCharset);
                    _v72 = _v36;
                    _v44 = inputLineHistSearch( *(Sprintf("Password for %s: ")), 0, 64, 0, 0);
                    if(_v44 != 0) {
                         *pwd = wc_Str_conv_strict(Strnew_charp(_v44), InnerCharset, SystemCharset);
                        term_cbreak();
                        goto L31;
                    } else {
                         *uname = 0;
                        return;
                    }
                    goto L21;
                }
            }
L31:
            _v56 = request;
            _v60 = hr;
            _v64 = pu;
            _v68 =  *pwd;
            _v72 =  *uname;
            _t166 = hauth;
             *__esp = _t166;
            hauth();
            _v16 = _t166;
            if(_v16 == 0) {
                 *uname = 0;
                 *pwd = 0;
                return;
            }
            _t169 = auth_header;
            Strnew_charp(_t169);
            _v20 = _t169;
            _v60 = 0;
            _v64 = "\n";
            _v68 =  *_v16;
            _v72 = " ";
            Strcat_m_charp(_v20);
            _t174 =  *_v20;
            allocStr(_t174, -1);
            pushValue(extra_header, _t174);
            return;
        }
    }
}

int same_url_p(ParsedURL* pu1, ParsedURL* pu2)
{// addr = 0x0805DAA4
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t28;
    _unknown_ _t36;

    if(pu1->scheme != pu2->scheme) {
        return 0;
    }
    if(pu1->port != pu2->port) {
        return 0;
    }
    if(pu1->host != 0) {
        if(pu2->host == 0) {
            return 0;
        }
        if(strcasecmp(pu1->host, pu2->host) != 0) {
            return 0;
        }
    }
    if(pu1->file == 0) {
        return 1;
    }
    if(pu2->file == 0) {
        return 0;
    }
    if(strcmp(pu1->file, pu2->file) != 0) {
        return 0;
    }
    return 1;
}

int checkRedirection(ParsedURL* pu)
{// addr = 0x0805DB36
    Str tmp;
    struct _Str* _v16;
    signed int _v32;
    struct _Str _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t46;
    _unknown_ _t55;
    ParsedURL* _t64;
    _unknown_ _t71;
    _unknown_ _t75;
    _unknown_ _t90;
    _unknown_ _t96;
    _unknown_ _t111;
    _unknown_ _t112;
    _unknown_ _t120;
    _unknown_ _t130;
    _unknown_ _t136;

    if(pu == 0) {
        nredir = 0;
        nredir_size = 0;
        puv = 0;
        return 1;
    }
    if(nredir < FollowRedirection) {
        if(nredir_size <= 0) {
L9:
            if(puv == 0) {
                nredir_size = ((FollowRedirection >> 31) + FollowRedirection >> 1) + 1;
                _t64 = (nredir_size << 2) + nredir_size << 3;
                 *__esp = _t64;
                GC_malloc();
                puv = _t64;
                memset(puv, 0, (nredir_size << 2) + nredir_size << 3);
            }
            copyParsedURL(puv + ((nredir % nredir_size << 2) + nredir % nredir_size << 3), pu);
            nredir = nredir + 1;
            return 1;
        }
    } else {
        _v56.length =  *(parsedURL2Str(pu));
        _v56.ptr = FollowRedirection;
        _v16 = Sprintf("Number of redirections exceeded %d at %s");
        disp_err_message( *_v16, 0);
        return 0;
    }
L5:
    _v32 = nredir_size;
    if(same_url_p(pu, puv + (((nredir - 1) % _v32 << 2) + (nredir - 1) % _v32 << 3)) != 0 || (nredir & 1) == 0 && same_url_p(pu, puv + ((((nredir >> 31) + nredir >> 1) % nredir_size << 2) + ((nredir >> 31) + nredir >> 1) % nredir_size << 3)) != 0) {
        _v56 =  *(parsedURL2Str(pu));
        _v16 = Sprintf("Redirection loop detected (%s)");
        disp_err_message( *_v16, 0);
        return 0;
    }
    goto L9;
}

Buffer* loadGeneralFile(char* path, _None current, char* referer, int flag, _None request)
{// addr = 0x0805DD60
    URLFile f;
    _None of;
    ParsedURL pu;
    Buffer* b;
    _None proc;
    _None tpath;
    _None t;
    char* p;
    _None real_type;
    _None t_buf;
    _None searchHeader;
    _None searchHeader_through;
    _None prevtrap;
    TextList* extra_header;
    _None uname;
    _None pwd;
    _None realm;
    _None add_auth_cookie_flag;
    unsigned char status;
    URLOption url_option;
    Str tmp;
    _None page;
    wc_ces charset;
    HRequest hr;
    _None auth_pu;
    struct stat st;
    Str cmd;
    struct http_auth hauth;
    struct http_auth hauth;
    char* t1;
    FILE* src;
    Str s;
    char* file;
    char* file;
    struct stat st;
    Buffer* b;
    Str s;
    Anchor* a;
    int l;
    char _v16;
    Buffer* _v29;
    Buffer* _v36;
    Buffer* _v40;
    _None* _v44;
    ParsedURL* _v48;
    char* _v52;
    char* _v56;
    char* _v60;
    Buffer* _v64;
    int _v68;
    Buffer* _v72;
    _None* _v76;
    URLFile* _v80;
    struct _Str* _v84;
    Buffer* _v88;
    struct _Str* _v92;
    Buffer* _v96;
    struct _Str* _v100;
    struct _Str* _v104;
    unsigned int _v108;
    struct form_list _v160;
    struct http_request _v172;
    long int _v176;
    intOrPtr _v180;
    char* _v184;
    _None _v188;
    Buffer* _v192;
    char* _v196;
    union input_stream* _v200;
    signed int _v202;
    signed int _v203;
    signed int _v204;
    char* _v212;
    char* _v220;
    struct _Str _v232;
    int _v244;
    long int _v268;
    signed int _v316;
    struct auth_param* _v324;
    char _v332;
    long int _v336;
    intOrPtr _v340;
    char* _v344;
    _None _v348;
    Buffer* _v352;
    char* _v356;
    union input_stream* _v360;
    intOrPtr _v364;
    Buffer* _v372;
    Buffer** _v376;
    char* _v380;
    char* _v384;
    long int _v388;
    intOrPtr _v392;
    char* _v396;
    _None _v400;
    struct _Str _v412;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t821;
    signed int _t835;
    char* _t882;
    _unknown_ _t891;
    int _t894;
    _unknown_ _t898;
    int _t944;
    _unknown_ _t945;
    _unknown_ _t981;
    _unknown_ _t986;
    char* _t988;
    _unknown_ _t1005;
    _unknown_ _t1047;
    int _t1050;
    _unknown_ _t1051;
    _unknown_ _t1070;
    int _t1072;
    _unknown_ _t1073;
    char* _t1111;
    _unknown_ _t1121;
    _unknown_ _t1146;
    _unknown_ _t1159;
    _unknown_ _t1161;
    _unknown_ _t1183;
    _unknown_ _t1203;
    _unknown_ _t1228;
    _unknown_ _t1231;
    _unknown_ _t1232;
    int _t1238;
    _unknown_ _t1239;
    int _t1255;
    _unknown_ _t1256;
    _None _t1290;
    int _t1293;
    _unknown_ _t1294;
    int _t1299;
    _unknown_ _t1300;
    signed int _t1318;
    _unknown_ _t1327;
    _unknown_ _t1346;
    _unknown_ _t1354;
    signed int _t1356;
    char* _t1357;
    _unknown_ _t1400;
    Buffer* _t1411;
    Buffer* _t1416;
    ParsedURL* _t1444;
    _None* _t1445;
    int _t1461;
    _unknown_ _t1462;
    char* _t1466;
    int _t1471;
    _unknown_ _t1472;
    int _t1478;
    _unknown_ _t1479;
    _unknown_ _t1498;
    _unknown_ _t1499;
    int _t1502;
    _unknown_ _t1503;
    int _t1505;
    _unknown_ _t1506;
    int _t1509;
    _unknown_ _t1510;
    int _t1513;
    _unknown_ _t1514;

    __esp = __esp - 396;
    _v36 = 0;
    _v40 = 0;
    _v44 = loadBuffer;
    _v52 = "text/plain";
    _v60 = 0;
    _v64 = 0;
    _v68 = SearchHeader & 255 & 4294967295;
    _v72 = 1;
    _v76 = 0;
    _v80 = newGeneralList();
    _v84 = 0;
    _v88 = 0;
    _v92 = 0;
    _v29 = 0;
    _v104 = 0;
    _v108 = 256;
    _v48 = path;
    _v76 = 0;
    _v96 = 0;
    checkRedirection(0);
L1:
    while(1) {
L1:
        while(1) {
            do {
L105:
                _v160.length =  &_v244;
                getAuthCookie( &_v332, "Authorization:", _v80, _v160.length,  &_v172, request,  &_v84,  &_v88);
                if(_v84 != 0) {
                    if(ISclose(_v200) == 0) {
                        _v200 = 0;
                    }
                    _v96 = 1;
                    _v29 = 0;
L1:
                    while(1) {
                        do {
                            if((TrapSignal & 255 & 4294967295) != 0) {
                                if((fmInitialized & 255 & 4294967295) != 0) {
                                    term_raw();
                                }
                                if(_v76 != 0) {
                                    mySignal(2, _v76);
                                }
                            }
                            _v160 = referer;
                            _v160.lastitem = flag;
                            _v376 =  &_v29;
                            openURL( &_v364, _v48,  &_v244, current,  &_v160, request, _v80, _v36,  &_v172);
                            __esp = __esp - 4;
                            _v204 = _v364;
                            _v200 = _v360;
                            _v196 = _v356;
                            _v192 = _v352;
                            _v188 = _v348;
                            _v184 = _v344;
                            _v180 = _v340;
                            _v176 = _v336;
                            _v36 = 0;
                            content_charset = 0;
                            if(_v200 != 0) {
                                _t835 = _v29 & 255;
                                if((_t835 & 4294967295) != 254) {
                                    _v412.ptr = 1;
                                    __esp->marks =  &AbortLoading;
                                    __sigsetjmp();
                                    if(_t835 == 0) {
                                        _v40 = 0;
                                        if((_v203 & 255 & 4294967295) != 0) {
                                            _v68 = 1;
                                            _v72 = 0;
                                        }
                                        if(header_string != 0) {
                                            header_string = 0;
                                        }
                                        if((TrapSignal & 255 & 4294967295) != 0) {
                                            _v76 = mySignal(2, KeyAbort);
                                            if((fmInitialized & 255 & 4294967295) != 0) {
                                                term_cbreak();
                                            }
                                        }
                                        if(_v244 == 0) {
L69:
                                            if((fmInitialized & 255 & 4294967295) != 0) {
                                                term_cbreak();
                                                _v412.ptr = _v232;
                                                message( *(Sprintf("%s contacted. Waiting for reply...")), 0, 0);
                                                refresh();
                                            }
                                            if(_v64 == 0) {
                                                _t1502 = COLS;
                                                if(showLineNum == 0) {
                                                    _t1238 = 1;
                                                } else {
                                                    _t1238 = 6;
                                                }
                                                _t1239 = _t1502 - _t1238;
                                                _t1240 = _t1239 >= 0 ? 0 : _t1239;
                                                _v64 = newBuffer(_t1239 >= 0 ? 0 : _t1239);
                                            }
                                            readHeader( &_v204, _v64, 0,  &_v244);
                                            if(http_response_code <= 300 || http_response_code > 303) {
                                                if(http_response_code != 307) {
                                                    break;
                                                }
                                            }
                                            goto L79;
                                        }
                                        if(_v244 != 1 || non_null(GOPHER_proxy) == 0) {
                                            if(_v244 != 2 || non_null(FTP_proxy) == 0) {
L130:
                                                if(_v244 == 9 || _v244 == 7) {
                                                    if(_v64 == 0) {
                                                        _t1505 = COLS;
                                                        if(showLineNum == 0) {
                                                            _t1255 = 1;
                                                        } else {
                                                            _t1255 = 6;
                                                        }
                                                        _t1256 = _t1505 - _t1255;
                                                        _t1257 = _t1256 >= 0 ? 0 : _t1256;
                                                        _v64 = newBuffer(_t1256 >= 0 ? 0 : _t1256);
                                                    }
                                                    readHeader( &_v204, _v64, 1,  &_v244);
                                                    _v52 = checkContentType(_v64);
                                                    if(_v52 == 0) {
                                                        _v52 = "text/plain";
                                                    }
L192:
                                                    _v184 = _v52;
                                                    goto L200;
                                                }
                                                if(_v244 != 1) {
                                                    if(_v244 != 2) {
                                                        if(_v244 != 11) {
                                                            if(_v68 == 0) {
                                                                if(DefaultType == 0) {
                                                                    _v52 = guessContentType(_v232.area_size);
                                                                    if(_v52 == 0) {
                                                                        _v52 = "text/plain";
                                                                    }
                                                                    _v60 = _v52;
                                                                    if(_v184 != 0) {
                                                                        _v52 = _v184;
                                                                    }
                                                                } else {
                                                                    _v52 = DefaultType;
                                                                    DefaultType = 0;
                                                                }
                                                                goto L192;
                                                            }
                                                            goto L169;
                                                        }
                                                        goto L167;
L169:
                                                        SearchHeader = 0;
                                                        _v68 = 0;
                                                        if(_v64 == 0) {
                                                            _t1513 = COLS;
                                                            if(showLineNum == 0) {
                                                                _t1299 = 1;
                                                            } else {
                                                                _t1299 = 6;
                                                            }
                                                            _t1300 = _t1513 - _t1299;
                                                            _t1301 = _t1300 >= 0 ? 0 : _t1300;
                                                            _v64 = newBuffer(_t1300 >= 0 ? 0 : _t1300);
                                                        }
                                                        readHeader( &_v204, _v64, _v72,  &_v244);
                                                        if((_v203 & 255 & 4294967295) == 0) {
L183:
                                                            _v52 = checkContentType(_v64);
                                                            if(_v52 == 0) {
L184:
                                                                _v52 = "text/plain";
                                                            }
                                                            goto L192;
                                                        } else {
                                                            _v56 = checkHeader(_v64, "Location:");
                                                            if(_v56 == 0 || checkRedirection( &_v244) == 0) {
                                                                goto L183;
                                                            } else {
                                                                _v48 = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(_v56)), InnerCharset, DocumentCharset)));
                                                                request = 0;
                                                                _t1290 = ISclose(_v200);
                                                                if(_t1290 == 0) {
                                                                    _v200 = 0;
                                                                    _t1290 = _v200;
                                                                }
                                                                _v96 = 0;
                                                                __esp->marks = 40;
                                                                GC_malloc();
                                                                current = _t1290;
                                                                copyParsedURL(current,  &_v244);
                                                                _t1509 = COLS;
                                                                if(showLineNum == 0) {
                                                                    _t1293 = 1;
                                                                } else {
                                                                    _t1293 = 6;
                                                                }
                                                                _t1294 = _t1509 - _t1293;
                                                                _t1295 = _t1294 >= 0 ? 0 : _t1294;
                                                                _v64 = newBuffer(_t1294 >= 0 ? 0 : _t1294);
                                                                _v64->bufferprop = (_v64->bufferprop & 65535 | 32) & 4294967295;
                                                                _v29 = 0;
                                                                continue;
                                                            }
                                                            goto L184;
                                                        }
                                                    }
                                                    goto L159;
L167:
                                                    _v52 = _v184;
                                                    goto L192;
                                                }
                                                _t1318 =  *(_v232.area_size) & 255 & 4294967295;
                                                if(_t1318 == 103) {
                                                    _v52 = "image/gif";
                                                    goto L192;
                                                }
                                                if(_t1318 > 103) {
                                                    if(_t1318 == 109) {
                                                        goto L150;
                                                    }
                                                    goto L146;
                                                }
                                                if(_t1318 == 48) {
                                                    _v52 = "text/plain";
                                                    goto L192;
                                                }
                                                if(_t1318 == 49) {
                                                    goto L150;
                                                }
                                                goto L192;
L150:
                                                _v104 = loadGopherDir( &_v204,  &_v244,  &_v108);
                                                _v52 = "gopher:directory";
                                                if((TrapSignal & 255 & 4294967295) != 0) {
                                                    if((fmInitialized & 255 & 4294967295) != 0) {
                                                        term_raw();
                                                    }
                                                    if(_v76 != 0) {
                                                        mySignal(2, _v76);
                                                    }
                                                }
                                                goto L200;
L146:
                                                if(_t1318 == 115) {
                                                    _v52 = "audio/basic";
                                                } else {
                                                    if(_t1318 == 104) {
                                                        _v52 = "text/html";
                                                    }
                                                }
                                                goto L192;
L159:
                                                check_compression(path,  &_v204);
                                                if(_v192 == 0) {
                                                    _v60 = guessContentType(_v232.area_size);
                                                    if(_v60 == 0) {
                                                        _v60 = "text/plain";
                                                    }
                                                    _v52 = _v60;
                                                } else {
                                                    _v160.body = uncompressed_file_type(_v232.area_size, 0);
                                                    _v60 = _v184;
                                                    if(_v120 == 0) {
                                                        _v52 = _v60;
                                                    } else {
                                                        _v52 = _v160.body;
                                                    }
                                                }
                                                goto L192;
                                            } else {
                                                goto L67;
                                            }
                                        }
L67:
                                        if((use_proxy & 255 & 4294967295) == 0 || check_no_proxy(_v232) != 0) {
                                            goto L130;
                                        }
                                        goto L69;
                                    } else {
                                        if((TrapSignal & 255 & 4294967295) != 0) {
                                            if((fmInitialized & 255 & 4294967295) != 0) {
                                                term_raw();
                                            }
                                            if(_v76 != 0) {
                                                mySignal(2, _v76);
                                            }
                                        }
                                        if(_v40 != 0) {
                                            discardBuffer(_v40);
                                        }
                                        if(ISclose(_v200) == 0) {
                                            _v200 = 0;
                                        }
                                        _t894 = 0;
                                    }
                                } else {
                                    if((TrapSignal & 255 & 4294967295) != 0) {
                                        if((fmInitialized & 255 & 4294967295) != 0) {
                                            term_raw();
                                        }
                                        if(_v76 != 0) {
                                            mySignal(2, _v76);
                                        }
                                    }
                                    if(ISclose(_v200) == 0) {
                                        _v200 = 0;
                                    }
                                    _t894 = 0;
                                }
L365:
                                 &_v16 =  &_v16;
                                return _t894;
                            }
                            _t1356 = _v204 & 255 & 4294967295 & ;
                            if(_t1356 == 4) {
                                _t1357 = _v220;
                                L080C7280(_t1357,  &_v332);
                                if(_t1357 >= 0) {
                                    if((_v316 & 61440) != 16384) {
                                        goto L32;
                                    }
                                    if(UseExternalDirBuffer == 0) {
                                        _v104 = loadLocalDir(_v220);
                                        _v52 = "local:directory";
                                        _v108 = SystemCharset;
                                        goto L32;
                                    } else {
                                        _v412.length = _v232.area_size;
                                        _v412.ptr = DirBufferCommand;
                                        _v160.boundary = Sprintf("%s?dir=%s#current");
                                        _v400 = 0;
                                        _v412.area_size = 0;
                                        _v40 = loadGeneralFile( *(_v160.boundary), 0, -1);
                                        if(_v40 != 0) {
                                            if(_v40 != 1) {
                                                copyParsedURL(_v40 + 132,  &_v244);
                                                 *_v40 =  *(_v40 + 156);
                                            }
                                        }
                                        _t894 = _v40;
                                    }
                                } else {
                                    _t894 = 0;
                                }
                                goto L365;
                            }
                            if(_t1356 > 4) {
                                if(_t1356 == 10) {
                                    _v104 = loadNewsgroup( &_v244,  &_v108);
                                    _v52 = "news:group";
                                    goto L32;
                                }
                            } else {
                                if(_t1356 == 3) {
                                    _v104 = loadFTPDir( &_v244,  &_v108);
                                    _v52 = "ftp:directory";
                                }
L32:
                                if(_v104 == 0 || _v104->length <= 0) {
                                    _t894 = 0;
                                    goto L365;
                                } else {
                                    goto L200;
                                }
                            }
L12:
                            if(_t1356 == 255) {
                                _v100 = searchURIMethods( &_v244);
                                if(_v100 == 0) {
                                    _v412.ptr =  *(parsedURL2Str( &_v244));
                                    disp_err_message( *(Sprintf("Unknown URI: %s")), 0);
                                    goto L32;
                                } else {
                                    _v400 = request;
                                    _v412.area_size = flag;
                                    _v40 = loadGeneralFile( *_v100, current, referer);
                                    if(_v40 != 0) {
                                        if(_v40 != 1) {
                                            copyParsedURL(_v40 + 132,  &_v244);
                                        }
                                    }
                                    _t894 = _v40;
                                }
                                goto L365;
                            } else {
                            }
                            goto L32;
L79:
                            _v56 = checkHeader(_v64, "Location:");
                        } while(_v56 != 0 && checkRedirection( &_v244) != 0);
                        _v52 = checkContentType(_v64);
                        if(_v52 == 0 && _v224 != 0 && (http_response_code <= 399 || http_response_code > 407) && (http_response_code <= 499 || http_response_code > 505)) {
                            _v52 = guessContentType(_v232.area_size);
                        }
                        if(_v52 == 0) {
                            _v52 = "text/plain";
                        }
                        if(_v96 != 0 && _v92 != 0 && _v84 != 0 && _v88 != 0) {
                            add_auth_user_passwd( &_v244,  *(qstr_unquote(_v92)), _v84, _v88, 0);
                            _v96 = 0;
                        }
                        _v56 = checkHeader(_v64, "WWW-Authenticate:");
                        if(_v56 == 0 || http_response_code != 401 || findAuthentication( &_v332, _v64, "WWW-Authenticate:") == 0) {
L114:
                            _v56 = checkHeader(_v64, "Proxy-Authenticate:");
                            if(_v56 == 0 || http_response_code != 407 || findAuthentication( &_v332, _v64, "Proxy-Authenticate:") == 0) {
L127:
                                if((_v29 & 255 & 4294967295) != 1) {
                                    _v176 = mymktime(checkHeader(_v64, "Last-Modified:"));
                                    goto L192;
                                }
                            } else {
                                _v92 = get_auth_param(_v324, "realm");
                                if(_v92 == 0) {
                                    goto L127;
                                }
                                _v160.length = schemeToProxy(_v244);
                                getAuthCookie( &_v332, "Proxy-Authorization:", _v80, _v160.length,  &_v172, request,  &_v84,  &_v88);
                                if(_v84 != 0) {
                                    if(ISclose(_v200) == 0) {
                                        _v200 = 0;
                                    }
                                    _v96 = 1;
                                    _v29 = 0;
                                    continue;
                                } else {
                                    if((TrapSignal & 255 & 4294967295) != 0) {
                                        if((fmInitialized & 255 & 4294967295) != 0) {
                                            term_raw();
                                        }
                                        if(_v76 != 0) {
                                            mySignal(2, _v76);
                                        }
                                    }
                                }
                                goto L200;
                            }
L128:
                            _v36 =  &_v204;
                            continue;
                        }
                        _v92 = get_auth_param(_v324, "realm");
                        if(_v92 == 0) {
                            goto L114;
                        }
                        goto L105;
                    }
                } else {
                    if((TrapSignal & 255 & 4294967295) != 0) {
                        if((fmInitialized & 255 & 4294967295) != 0) {
                            term_raw();
                        }
                        if(_v76 != 0) {
                            mySignal(2, _v76);
                        }
                    }
                }
                break;
            } while();
L200:
            if(_v104 == 0) {
                if(_v60 == 0) {
                    _v60 = _v52;
                }
                _v44 = loadBuffer;
                __esp->marks = 40;
                GC_malloc();
                cur_baseURL = loadBuffer;
                _t1444 =  &_v244;
                copyParsedURL(cur_baseURL, _t1444);
                current_content_length = 0;
                 *135776436 = 0;
                _v56 = checkHeader(_v64, "Content-Length:");
                if(_v56 != 0) {
                    current_content_length = strtoclen(_v56);
                     *135776436 = _t1444;
                }
                if(do_download == 0) {
                    if(_v188 == 0 || (AutoUncompress & 255 & 4294967295) == 0 || (w3m_dump & 8) != 0) {
                        if(_v192 != 0) {
                            if((w3m_dump & 4) != 0 || (w3m_dump & 223) == 0 && is_text_type(_v52) == 0 && searchExtViewer(_v52) == 0) {
                                _v52 = compress_application_type(_v192);
                                _v192 = 0;
                            } else {
                                if(_v64 == 0) {
                                    _t1478 = COLS;
                                    if(showLineNum == 0) {
                                        _t1072 = 1;
                                    } else {
                                        _t1072 = 6;
                                    }
                                    _t1073 = _t1478 - _t1072;
                                    _t1074 = _t1073 >= 0 ? 0 : _t1073;
                                    _v64 = newBuffer(_t1073 >= 0 ? 0 : _t1073);
                                }
                                uncompress_stream( &_v204,  &(_v64->sourcefile));
                                uncompressed_file_type(_v232.area_size,  &( &_v204->ext));
                            }
                        }
                    } else {
                        uncompress_stream( &_v204,  &( &_v244->real_file));
                    }
                    if(image_source == 0) {
                        if(is_html_type(_v52) == 0) {
                            if(is_plain_text_type(_v52) == 0) {
                                if(activeImage == 0 || displayImage == 0 || useExtImageViewer != 0 || (w3m_dump & 223) != 0 || strncasecmp(_v52, "image/", 6) != 0) {
                                    if(w3m_backend != 0) {
                                        goto L324;
                                    }
                                } else {
                                    _v44 = loadImageBuffer;
L324:
                                    if((flag & 2) != 0) {
                                        if(_v64 == 0) {
                                            _t1461 = COLS;
                                            if(showLineNum == 0) {
                                                _t944 = 1;
                                            } else {
                                                _t944 = 6;
                                            }
                                            _t945 = _t1461 - _t944;
                                            _t946 = _t945 >= 0 ? 0 : _t945;
                                            _v64 = newBuffer(_t945 >= 0 ? 0 : _t945);
                                        }
                                        _v64->bufferprop = (_v64->bufferprop & 65535 | 2) & 4294967295;
                                    }
                                    frame_source = flag & 4;
                                    _t1411 = _v64;
                                    _t1445 = _v44;
                                    if(_v220 == 0) {
                                        _t882 = _v232.area_size;
                                    } else {
                                        _t882 = _v220;
                                    }
                                    _v40 = loadSomething( &_v204, _t882, _t1445, _t1411);
                                    if(ISclose(_v200) == 0) {
                                        _v200 = 0;
                                    }
                                    frame_source = 0;
                                    if(_v40 != 0) {
                                        _v40->real_scheme = _v204 & 255 & 4294967295 & ;
                                        _v40->real_type = _v60;
                                        if( *((intOrPtr*)(_v40 + 144)) == 0 &&  *((intOrPtr*)(_v40 + 152)) == 0) {
                                            copyParsedURL(_v40 + 132,  &_v244);
                                        }
                                        if(is_html_type(_v52) == 0) {
                                            if(w3m_backend == 0) {
                                                if(_v44 != loadImageBuffer) {
                                                    _v40->type = "text/plain";
                                                } else {
                                                    _v40->type = "text/html";
                                                }
                                            } else {
                                                _v160.target = Strnew_charp(_v52);
                                                _v40->type =  *(_v160.target);
                                            }
                                        } else {
                                            _v40->type = "text/html";
                                        }
                                        if(_v212 != 0) {
                                            if(_v44 != loadHTMLBuffer) {
                                                _v160.method = atoi(_v212);
                                                gotoRealLine(_v40, _v160.method);
                                                _v40->pos = 0;
                                                arrangeCursor(_v40);
                                            } else {
                                                _v160.action = searchURLLabel(_v40, _v212);
                                                if(_v148 != 0) {
                                                    gotoLine(_v40,  *(_v160.action + 20));
                                                    if(label_topline != 0) {
                                                        _v40->topLine = lineSkip(_v40, _v40->topLine, _v40->currentLine->linenumber - _v40->topLine->linenumber, 0);
                                                    }
                                                    _v40->pos =  *(_v160.action + 24);
                                                    arrangeCursor(_v40);
                                                }
                                            }
                                        }
                                    }
                                    if(header_string != 0) {
                                        header_string = 0;
                                    }
                                    if((_v204 & 255 & 4294967295) == 7 || (_v204 & 255 & 4294967295) == 9) {
                                        reAnchorNewsheader(_v40);
                                    }
                                    preFormUpdateBuffer(_v40);
                                    if((TrapSignal & 255 & 4294967295) != 0) {
                                        if((fmInitialized & 255 & 4294967295) != 0) {
                                            term_raw();
                                        }
                                        if(_v76 != 0) {
                                            mySignal(2, _v76);
                                        }
                                    }
                                    _t894 = _v40;
                                    goto L365;
                                }
L285:
                                if((w3m_dump & 223) == 0 || is_dump_text_type(_v52) != 0) {
                                    if(do_download != 0) {
L305:
                                        if((TrapSignal & 255 & 4294967295) != 0) {
L306:
                                            if((fmInitialized & 255 & 4294967295) != 0) {
                                                term_raw();
                                            }
                                            if(_v76 != 0) {
                                                mySignal(2, _v76);
                                            }
                                        }
                                        if(_v244 != 4) {
                                            if((DecodeCTE & 255 & 4294967295) != 0 && (_v200->base.stream.cur & 255 & 4294967295) != 4) {
                                                _v200 = newEncodedStream(_v200, _v202 & 255 & 4294967295);
                                            }
                                            _v384 = guess_save_name(_v64, _v232.area_size);
                                            __esp->marks = _v204;
                                            _v412.ptr = _v200;
                                            _v412.length = _v196;
                                            _v412.area_size = _v192;
                                            _v400 = _v188;
                                            _v396 = _v184;
                                            _v392 = _v180;
                                            _v388 = _v176;
                                            if(doFileSave() != 0) {
                                                if(ISclose(_v200) == 0) {
                                                    _v200 = 0;
                                                }
                                            } else {
                                                UFhalfclose( &_v204);
                                            }
                                        } else {
                                            if(ISclose(_v200) == 0) {
                                                _v200 = 0;
                                            }
                                            _doFileCopy(_v220,  *(wc_Str_conv(Strnew_charp(guess_save_name(0, _v220)), SystemCharset, InnerCharset)), 1);
                                        }
                                        _t894 = 1;
                                        goto L365;
                                    }
                                } else {
                                    if((w3m_dump & 32) == 0) {
                                        goto L324;
                                    }
                                    _t894 = 0;
                                    goto L365;
                                }
L288:
                                _t1416 = _v64;
                                _t1466 = _v52;
                                if(_v220 == 0) {
                                    _t988 = _v232.area_size;
                                } else {
                                    _t988 = _v220;
                                }
                                _v372 = _t1416;
                                _v376 =  &_v40;
                                _v380 = _t1466;
                                _v384 = _t988;
                                __esp->marks = _v204;
                                _v412.ptr = _v200;
                                _v412.length = _v196;
                                _v412.area_size = _v192;
                                _v400 = _v188;
                                _v396 = _v184;
                                _v392 = _v180;
                                _v388 = _v176;
                                if(doExternal() == 0) {
                                    goto L305;
                                } else {
                                    if(_v40 != 0 && _v40 != 1) {
                                        _v40->real_scheme = _v204 & 255 & 4294967295 & ;
                                        _v40->real_type = _v60;
                                        if( *((intOrPtr*)(_v40 + 144)) == 0 &&  *((intOrPtr*)(_v40 + 152)) == 0) {
                                            copyParsedURL(_v40 + 132,  &_v244);
                                        }
                                    }
                                    if(ISclose(_v200) == 0) {
                                        _v200 = 0;
                                    }
                                    if((TrapSignal & 255 & 4294967295) != 0) {
                                        if((fmInitialized & 255 & 4294967295) != 0) {
                                            term_raw();
                                        }
                                        if(_v76 != 0) {
                                            mySignal(2, _v76);
                                        }
                                    }
                                    _t894 = _v40;
                                    goto L365;
                                }
                                goto L306;
                            }
                            goto L277;
                        }
                        goto L275;
L277:
                        _v44 = loadBuffer;
                        goto L324;
                    } else {
                        _v160.name = 0;
                        if((_v200->base.stream.cur & 255 & 4294967295) != 4) {
                            _v200 = newEncodedStream(_v200, _v202 & 255 & 4294967295);
                        }
                        _v384 = image_source;
                        __esp->marks = _v204;
                        _v412.ptr = _v200;
                        _v412.length = _v196;
                        _v412.area_size = _v192;
                        _v400 = _v188;
                        _v396 = _v184;
                        _v392 = _v180;
                        _v388 = _v176;
                        if(save2tmp() == 0) {
                            _t1471 = COLS;
                            if(showLineNum == 0) {
                                _t1050 = 1;
                            } else {
                                _t1050 = 6;
                            }
                            _t1051 = _t1471 - _t1050;
                            _t1052 = _t1051 >= 0 ? 0 : _t1051;
                            _v160.name = newBuffer(_t1051 >= 0 ? 0 : _t1051);
                            _v160.name->sourcefile = image_source;
                            _v160.name->real_type = _v52;
                        }
                        if(ISclose(_v200) == 0) {
                            _v200 = 0;
                        }
                        if((TrapSignal & 255 & 4294967295) != 0) {
                            if((fmInitialized & 255 & 4294967295) != 0) {
                                term_raw();
                            }
                            if(_v76 != 0) {
                                mySignal(2, _v76);
                            }
                        }
                        _t894 = _v160.name;
                        goto L365;
                    }
L275:
                    _v44 = loadHTMLBuffer;
                    goto L324;
                } else {
                    if((TrapSignal & 255 & 4294967295) != 0) {
                        if((fmInitialized & 255 & 4294967295) != 0) {
                            term_raw();
                        }
                        if(_v76 != 0) {
                            mySignal(2, _v76);
                        }
                    }
                    if((DecodeCTE & 255 & 4294967295) != 0 && (_v200->base.stream.cur & 255 & 4294967295) != 4) {
                        _v200 = newEncodedStream(_v200, _v202 & 255 & 4294967295);
                    }
                    if(_v244 != 4) {
                        _v160.charset.ptr = guess_save_name(_v64, _v232.area_size);
                    } else {
                        if((PreserveTimestamp & 255 & 4294967295) != 0) {
                            _t1111 = _v220;
                            L080C7280(_t1111,  &_v332);
                            if(_t1111 == 0) {
                                _v176 = _v268;
                            }
                        }
                        _v160.charset.ptr =  *(wc_Str_conv(Strnew_charp(guess_save_name(0, _v220)), SystemCharset, InnerCharset));
                    }
                    _v384 = _v160.charset;
                     *__esp = _v204;
                    _v412.ptr = _v200;
                    _v412.length = _v196;
                    _v412.area_size = _v192;
                    _v400 = _v188;
                    _v396 = _v184;
                    _v392 = _v180;
                    _v388 = _v176;
                    if(doFileSave() != 0) {
                        if(ISclose(_v200) == 0) {
                            _v200 = 0;
                        }
                    } else {
                        UFhalfclose( &_v204);
                    }
                    _t894 = 1;
                    goto L365;
                }
            }
            if(image_source == 0) {
                _v100 = tmpfname(1, ".html");
                _v160.nitems = fopen( *_v100, "w");
                if(_v124 != 0) {
                    _v160.next = wc_Str_conv_strict(_v104, InnerCharset, _v108);
                    fwrite( *(_v160.next), 1, _v160.next->length, _v160.nitems);
                    fclose(_v160.nitems);
                }
                if(do_download == 0) {
                    _v40 = loadHTMLString(_v104);
                    if(_v40 != 0) {
                        copyParsedURL(_v40 + 132,  &_v244);
                        _v40->real_scheme = _v244;
                        _v40->real_type = _v52;
                        if(_v124 != 0) {
                            _v40->sourcefile =  *_v100;
                        }
                         *(_v40 + 208) = _v108;
                    }
                    _t894 = _v40;
                } else {
                    if(_v124 != 0) {
                        _v160.enctype = guess_filename(_v232.area_size);
                        if((_v204 & 255 & 4294967295) == 1) {
                            _v412.ptr = _v160.enctype;
                            _v160.enctype =  *(Sprintf("%s.html"));
                        }
                        if((_v204 & 255 & 4294967295) == 10) {
                            _v412 = _v160.enctype;
                            _v160.enctype =  *(Sprintf("%s.html"));
                        }
                        doFileMove( *_v100, _v160.enctype);
                        _t894 = 1;
                    } else {
                        _t894 = 0;
                    }
                }
            } else {
                _t894 = 0;
            }
            goto L365;
        }
    }
}

char* has_hidden_link(struct readbuffer* obuf, int cmd)
{// addr = 0x0805FA4E
    Str line;
    struct link_stack* p;
    struct _Str* _v8;
    short int _v12;
    _unknown_ __ebp;
    _unknown_ _t32;
    _unknown_ _t47;
    _unknown_ _t52;

    _v8 = obuf->line;
    if(_v8->length <= 0) {
        return 0;
    }
    if(( *( *_v8 + _v8->length - 1) & 255 & 4294967295) != 62) {
        return 0;
    }
    _v12 = link_stack;
    while(_v12 != 0) {
        if( *_v12 == cmd) {
            goto L9;
        }
        _v12 = _v12->next;
        continue;
L9:
        if(_v12 == 0) {
            return 0;
        }
        if((obuf->pos & 65535 & 4294967295) != (_v12->pos & 65535 & 4294967295)) {
            return 0;
        }
        asm("cwde ");
        return  *_v8 + (_v12->offset & 65535);
    }
}

push_link(int cmd, int offset, int pos)
{// addr = 0x0805FAE4
    struct link_stack* p;
    struct link_stack* _v16;
    _unknown_ __ebp;

     *__esp = 12;
    GC_malloc();
    _v16 = __eax;
     *_v16 = cmd;
    _v16->offset = offset & 4294967295;
    _v16->pos = pos & 4294967295;
    _v16->next = link_stack;
    link_stack = _v16;
    return;
}

int is_period_char(unsigned char* ch)
{// addr = 0x0805FB2F
    _unknown_ __ebp;
    _unknown_ _t9;
    _unknown_ _t10;

    if(( *ch & 255 & 4294967295 & ) - 33 > 92) {
        return 0;
    }
    goto __eax;
}

int is_beginning_char(unsigned char* ch)
{// addr = 0x0805FB5A
    _unknown_ __ebp;
    signed int _t5;
    _unknown_ _t6;
    _unknown_ _t7;

    _t5 =  *ch & 255 & 4294967295 & ;
    if(_t5 == 91) {
        return 1;
    }
    if(_t5 > 91) {
        if(_t5 == 96) {
            return 1;
        }
        if(_t5 != 123) {
            return 0;
        }
        return 1;
    } else {
        if(_t5 == 40) {
            return 1;
        }
        if(_t5 == 60) {
            return 1;
        }
        return 0;
    }
}

int is_word_char(unsigned char* ch)
{// addr = 0x0805FB94
    Lineprop ctype;
    signed int _v6;
    _unknown_ __ebp;
    _unknown_ _t41;
    _unknown_ _t42;
    _unknown_ _t43;
    _unknown_ _t44;
    _unknown_ _t45;
    _unknown_ _t46;

    _v6 = ( *( &WTF_TYPE_MAP + ( *ch & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 8 & 4294967295;
    if((_v6 & 65535 & 6400) != 0) {
        return 0;
    }
    if((_v6 & 65535 & 1536) != 0) {
        return 1;
    }
    if(( *( &MYCTYPE_MAP + ( *ch & 255 & 4294967295 & )) & 255 & 4294967295 &  & 12) != 0) {
        return 1;
    }
    if(( *ch & 255 & 4294967295 & ) - 34 > 92) {
        if(( *ch & 255 & 4294967295) != 160) {
            return 0;
        }
        return 1;
    }
    goto __eax;
}

int is_combining_char(unsigned char* ch)
{// addr = 0x0805FC36
    Lineprop ctype;
    signed short _v6;
    _unknown_ __ebp;
    _unknown_ _t16;
    _unknown_ _t17;

    _v6 = ( *( &WTF_TYPE_MAP + ( *ch & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 8 & 4294967295;
    if((_v6 & 65535 & 1024) == 0) {
        return 0;
    }
    return 1;
}

int is_boundary(unsigned char* ch1, unsigned char* ch2)
{// addr = 0x0805FC71
    _unknown_ __ebp;
    _unknown_ _t20;
    _unknown_ _t33;
    _unknown_ _t36;
    _unknown_ _t37;
    _unknown_ _t40;
    _unknown_ _t43;
    _unknown_ _t46;

    if(( *ch1 & 255 & 4294967295) == 0) {
        return 1;
    }
    if(( *ch2 & 255 & 4294967295) == 0) {
        return 1;
    }
    if(( *ch1 & 255 & 4294967295) == 32) {
        if(( *ch2 & 255 & 4294967295) != 32) {
            goto L6;
        } else {
            return 0;
        }
    }
L6:
    if(( *ch1 & 255 & 4294967295) != 32) {
        if(is_period_char(ch2) != 0) {
            return 0;
        }
    }
    if(( *ch2 & 255 & 4294967295) != 32) {
        if(is_beginning_char(ch1) != 0) {
            return 0;
        }
    }
    if(is_combining_char(ch2) != 0) {
        return 0;
    }
    if(is_word_char(ch1) == 0) {
        return 1;
    }
    if(is_word_char(ch2) == 0) {
        return 1;
    }
    return 0;
}

set_breakpoint(struct readbuffer* obuf, int tag_length)
{// addr = 0x0805FD35
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t94;

     *((intOrPtr*)(obuf + 192)) = obuf->line->length;
     *(obuf + 188) = obuf->pos & 65535 & 4294967295;
     *(obuf + 196) = tag_length;
     *(obuf + 200) = obuf->flag;
     *(obuf + 282) = obuf->top_margin & 65535 & 4294967295;
     *(obuf + 284) = obuf->bottom_margin & 65535 & 4294967295;
    if(( *(obuf + 280) & 255 & 4294967295) == 0) {
        return ;
    }
    bcopy(obuf + 72, obuf + 204, 60);
     *((intOrPtr*)(obuf + 264)) =  *((intOrPtr*)(obuf + 132));
     *(obuf + 268) = obuf->fontstat & 255 & 4294967295;
     *(obuf + 270) = obuf->fontstat[2] & 255 & 4294967295;
     *(obuf + 269) = obuf->fontstat[1] & 255 & 4294967295;
     *(obuf + 271) = obuf->fontstat[3] & 255 & 4294967295;
     *(obuf + 272) = obuf->fontstat[4] & 255 & 4294967295;
     *(obuf + 276) = obuf->nobr_level & 65535 & 4294967295;
     *(obuf + 278) =  *(obuf + 184) & 65535 & 4294967295;
     *(obuf + 280) = 0;
    return;
}

back_to_breakpoint(struct readbuffer* obuf)
{// addr = 0x0805FE7C
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t71;

    obuf->flag =  *(obuf + 200);
    bcopy(obuf + 204, obuf + 72, 60);
     *((intOrPtr*)(obuf + 132)) =  *((intOrPtr*)(obuf + 264));
    obuf->fontstat =  *(obuf + 268) & 255 & 4294967295;
    obuf->fontstat[2] =  *(obuf + 270) & 255 & 4294967295;
    obuf->fontstat[1] =  *(obuf + 269) & 255 & 4294967295;
    obuf->fontstat[3] =  *(obuf + 271) & 255 & 4294967295;
    obuf->fontstat[4] =  *(obuf + 272) & 255 & 4294967295;
     *(obuf + 184) =  *(obuf + 278) & 65535 & 4294967295;
    obuf->pos =  *(obuf + 188) & 4294967295;
    obuf->top_margin =  *(obuf + 282) & 65535 & 4294967295;
    obuf->bottom_margin =  *(obuf + 284) & 65535 & 4294967295;
    if((obuf->flag & 128) == 0) {
        return ;
    }
    obuf->nobr_level =  *(obuf + 276) & 65535 & 4294967295;
    return;
}

append_tags(struct readbuffer* obuf)
{// addr = 0x0805FF94
    int i;
    int len;
    int set_bp;
    intOrPtr _v16;
    int _v20;
    intOrPtr _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t58;
    int _t72;

    _v20 =  *(obuf->line + 4);
    _v24 = 0;
    _v16 = 0;
    while(obuf->tag_sp > _v16) {
        _t58 = ( *(obuf + (_v16 + 72) * 4))[1];
        if(_t58 == 65) {
L9:
            push_link(( *(obuf + (_v16 + 72) * 4))[1],  *(obuf->line + 4), obuf->pos & 65535 & 4294967295);
            goto L10;
        }
        if(_t58 > 65) {
            if(_t58 == 109 || _t58 == 136 || _t58 == 105) {
                goto L9;
            }
            goto L10;
        }
        if(_t58 == 1 || _t58 == 7) {
            goto L9;
        }
L10:
        Strcat_charp(obuf->line,  *((char**)( *(obuf + (_v16 + 72) * 4))));
        _t72 = ( *(obuf + (_v16 + 72) * 4))[1];
        if(_t72 == 50) {
            if((obuf->nobr_level & 65535 & 4294967295) > 1) {
                goto L15;
            }
            goto L14;
        }
        if(_t72 == 69) {
            goto L14;
        } else {
L16:
            _v16 = _v16 + 1;
            continue;
        }
L15:
        goto L16;
L14:
        _v24 = 1;
        goto L16;
    }
}

push_tag(struct readbuffer* obuf, char* cmdname, int cmd)
{// addr = 0x080600BA
    _unknown_ _v24;
    _unknown_ __ebx;
    _unknown_ __ebp;

    _t31 = obuf;
     *__esp = 8;
    GC_malloc();
     *(obuf + (_t31->tag_sp + 72) * 4) = obuf;
     *((char**)( *(obuf + (obuf->tag_sp + 72) * 4))) = allocStr(cmdname, -1);
    ( *(obuf + (obuf->tag_sp + 72) * 4))[1] = cmd;
    obuf->tag_sp = obuf->tag_sp + 1;
    if(obuf->tag_sp <= 9) {
        if((obuf->flag & 527) == 0) {
            return ;
        }
    }
    append_tags(obuf);
    return;
}

push_nchars(struct readbuffer* obuf, int width, char* str, int len, Lineprop mode)
{// addr = 0x08060163
    signed short _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = mode & 4294967295;
    append_tags(obuf);
    Strcat_charp_n(obuf->line, str, len);
    obuf->pos = (obuf->pos & 65535) + width & 4294967295;
    if(width > 0) {
        Strcopy_charp_n( *(obuf + 8), str, len);
         *(obuf + 184) = _v16 & 65535 & 4294967295;
    }
    obuf->flag = obuf->flag;
    return;
}

check_breakpoint(struct readbuffer* obuf, int pre_mode, char* ch)
{// addr = 0x080601F1
    int tlen;
    int len;
    int _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v20 = obuf->line->length;
    append_tags(obuf);
    if(pre_mode != 0) {
        return ;
    }
    _v16 = obuf->line->length - _v20;
    if(_v16 <= 0) {
        if(is_boundary( *( *(obuf + 8)), ch) == 0) {
            return ;
        }
    }
    set_breakpoint(obuf, _v16);
    return;
}

push_char(struct readbuffer* obuf, int pre_mode, char ch)
{// addr = 0x08060259
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    struct _Str* _t59;
    int _t83;

    _v16 = ch & 4294967295;
    check_breakpoint(obuf, pre_mode,  &_v16);
    if(obuf->line->length + 1 >= obuf->line->area_size) {
        Strgrow(obuf->line);
    }
    _t59 = obuf->line;
    _t83 = _t59->length;
     *( *(obuf->line) + _t83) = _v16 & 255 & 4294967295;
    _t59->length = _t83 + 1;
     *((char*)( *(obuf->line) + obuf->line->length)) = 0;
    obuf->pos = (obuf->pos & 65535) + 1 & 4294967295;
    Strcopy_charp_n( *(obuf + 8),  &_v16, 1);
    if((_v16 & 255 & 4294967295) != 32) {
         *((short*)(obuf + 184)) = 0;
    }
    obuf->flag = obuf->flag;
    return;
}

push_spaces(struct readbuffer* obuf, int pre_mode, int width)
{// addr = 0x08060330
    int i;
    char _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    struct _Str* _t55;
    int _t77;

    if(width <= 0) {
        return ;
    }
    check_breakpoint(obuf, pre_mode, " ");
    _v16 = 0;
    while(_v16 < width) {
        if(obuf->line->length + 1 >= obuf->line->area_size) {
            Strgrow(obuf->line);
        }
        _t55 = obuf->line;
        _t77 = _t55->length;
         *((char*)(obuf->line->ptr + _t77)) = 32;
        _t55->length = _t77 + 1;
         *((char*)(obuf->line->ptr + obuf->line->length)) = 0;
        _v16 = _v16 + 1;
    }
}

proc_mchar(struct readbuffer* obuf, int pre_mode, int width, char** str, Lineprop mode)
{// addr = 0x08060416
    signed short _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = mode & 4294967295;
    check_breakpoint(obuf, pre_mode,  *str);
    obuf->pos = (obuf->pos & 65535) + width & 4294967295;
    Strcat_charp_n(obuf->line,  *str,  *( &WTF_LEN_MAP + ( *( *str) & 255 & 4294967295 & )) & 255 & 4294967295 & );
    if(width > 0) {
        Strcopy_charp_n( *(obuf + 8),  *str, 1);
        if(( *( *str) & 255 & 4294967295) != 32) {
             *(obuf + 184) = _v16 & 65535 & 4294967295;
        }
    }
     *str =  &(( *str)[ *( &WTF_LEN_MAP + ( *( *str) & 255 & 4294967295 & )) & 255 & 4294967295 & ]);
    obuf->flag = obuf->flag;
    return;
}

push_render_image(Str str, int width, int limit, struct html_feed_environ* h_env)
{// addr = 0x080604F8
    struct readbuffer* obuf;
    int indent;
    struct readbuffer* _v16;
    signed int _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = h_env->obuf;
    _v20 =  &(h_env->envs[h_env->envc])->indent & 255 & 4294967295;
    push_spaces(_v16, 1, (limit - width >> 31) + limit - width >> 1);
    push_nchars(_v16, width, str->ptr, str->length, 0);
    push_spaces(_v16, 1, (limit - width + 1 >> 31) + limit - width + 1 >> 1);
    if(width <= 0) {
        return ;
    }
    flushline(h_env, _v16, _v20, 0, h_env->limit);
    return;
}

int sloppy_parse_line(char** str)
{// addr = 0x080605DF
    _unknown_ __ebp;
    _unknown_ _t31;

    if(( *( *str) & 255 & 4294967295) != 60) {
        while(1) {
L10:
            str =  *str;
            __eax =  *( *str) & 255;
            if(( *( *str) & 255 & 4294967295) == 0) {
                break;
            }
            str =  *str;
            __eax =  *( *str) & 255;
            if(( *( *str) & 255 & 4294967295) != 60) {
                str =  *str;
                __eax = str;
                 *str =  &(( *str)[1]);
                continue;
            }
            break;
        }
L12:
        __eax = 0;
        return 0;
    } else {
        while(( *( *str) & 255 & 4294967295) != 0 && ( *( *str) & 255 & 4294967295) != 62) {
             *str =  &(( *str)[1]);
        }
    }
    goto L10;
}

passthrough(struct readbuffer* obuf, char* str, int back)
{// addr = 0x08060664
    int cmd;
    Str tok;
    char* str_bak;
    Str str_save;
    char* q;
    struct link_stack* p;
    int _v16;
    struct _Str* _v20;
    char* _v24;
    struct _Str* _v28;
    char* _v32;
    struct link_stack* _v36;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t57;

    _v20 = Strnew();
    if(back != 0) {
        _v28 = Strnew_charp(str);
        Strshrink(obuf->line, obuf->line->ptr + obuf->line->length - str);
        str =  *_v28;
    }
L13:
    while(( *str & 255 & 4294967295) != 0) {
        _v24 = str;
        if(sloppy_parse_line( &str) == 0) {
L11:
            push_nchars(obuf, 0, _v24, str - _v24,  *(obuf + 184) & 65535 & 4294967295 & );
            continue;
        }
        _v32 = _v24;
        _v16 = gethtmlcmd( &_v32);
        if(back == 0) {
            Strcat_charp_n(_v20, _v24, str - _v24);
            push_tag(obuf,  *_v20, _v16);
            Strclear(_v20);
            continue;
        }
        _v36 = link_stack;
        while(_v36 != 0) {
            if( *_v36 != _v16) {
                _v36 = _v36->next;
                continue;
            }
            link_stack = _v36->next;
            back = 0;
            goto L13;
        }
        goto L11;
    }
}

fillline(struct readbuffer* obuf, int indent)
{// addr = 0x080607D1
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    asm("cwde ");
    push_spaces(obuf, 1, indent - (obuf->pos & 65535));
    obuf->flag = obuf->flag;
    return;
}

flushline(struct html_feed_environ* h_env, struct readbuffer* obuf, int indent, int force, int width)
{// addr = 0x08060812
    TextLineList* buf;
    FILE* f;
    Str line;
    Str pass;
    char* hidden_anchor;
    char* hidden_img;
    char* hidden_bold;
    char* hidden_under;
    char* hidden_italic;
    char* hidden_strike;
    char* hidden_ins;
    char* hidden;
    char* tp;
    char* ep;
    int i;
    struct html_feed_environ h;
    struct readbuffer o;
    struct environment[0] e;
    TextLine* lbuf;
    char* p;
    char* q;
    Str tmp;
    Str tmp2;
    int i;
    struct html_feed_environ h;
    struct readbuffer o;
    struct environment[0] e;
    Str tmp;
    char* c;
    Str tmp;
    GeneralList* _v16;
    struct _IO_FILE* _v20;
    struct _Str* _v24;
    struct _Str* _v28;
    char* _v32;
    char* _v36;
    char* _v40;
    char* _v44;
    char* _v48;
    char* _v52;
    char* _v56;
    char* _v60;
    void* _v64;
    char* _v68;
    TextLineListItem** _v72;
    TextLine* _v76;
    char* _v80;
    char* _v84;
    struct _Str* _v88;
    struct _Str* _v92;
    TextLineListItem** _v96;
    struct _Str* _v100;
    char* _v104;
    struct _Str* _v108;
    struct environment _v124;
    struct html_feed_environ _v172;
    struct readbuffer _v508;
    _unknown_ _v516;
    _unknown_ _v520;
    _unknown_ _v524;
    _unknown_ _v528;
    _unknown_ _v532;
    signed int _v536;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t766;
    struct readbuffer _t814;
    struct _Str* _t836;
    struct _Str* _t840;
    _unknown_ _t842;
    _unknown_ _t844;
    _unknown_ _t886;
    _unknown_ _t896;
    struct readbuffer _t918;
    _unknown_ _t964;
    int _t1020;
    intOrPtr _t1053;
    intOrPtr _t1066;

    _v16 = h_env->buf;
    _v20 = h_env->f;
    _v24 = obuf->line;
    _v28 = 0;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v44 = 0;
    _v48 = 0;
    _v52 = 0;
    _v56 = 0;
    _v60 = 0;
    if((obuf->flag & 527) == 0) {
        if(_v24->length > 0) {
            if((( *_v24)[_v24->length - 1] & 255 & 4294967295) == 32) {
                Strshrink(_v24, 1);
                obuf->pos = (obuf->pos & 65535) - 1 & 4294967295;
            }
        }
    }
    append_tags(obuf);
    if( *(obuf + 72) != 0) {
        _v32 = has_hidden_link(obuf, 1);
        _v60 = _v32;
    }
    if( *(obuf + 132) != 0) {
        _v36 = has_hidden_link(obuf, 136);
        if(_v36 != 0) {
            if(_v60 == 0 || _v36 < _v60) {
                _v60 = _v36;
            }
        }
    }
    if((obuf->fontstat & 255 & 4294967295) != 0) {
        _v40 = has_hidden_link(obuf, 7);
        if(_v40 != 0) {
            if(_v60 == 0 || _v40 < _v60) {
                _v60 = _v40;
            }
        }
    }
    if((obuf->fontstat[2] & 255 & 4294967295) != 0) {
        _v48 = has_hidden_link(obuf, 109);
        if(_v48 != 0) {
            if(_v60 == 0 || _v48 < _v60) {
                _v60 = _v48;
            }
        }
    }
    if((obuf->fontstat[1] & 255 & 4294967295) != 0) {
        _v44 = has_hidden_link(obuf, 65);
        if(_v44 != 0) {
            if(_v60 == 0 || _v44 < _v60) {
                _v60 = _v44;
            }
        }
    }
    if((obuf->fontstat[3] & 255 & 4294967295) != 0) {
        _v52 = has_hidden_link(obuf, 105);
        if(_v52 != 0) {
            if(_v60 == 0 || _v52 < _v60) {
                _v60 = _v52;
            }
        }
    }
    if((obuf->fontstat[4] & 255 & 4294967295) != 0) {
        _v56 = has_hidden_link(obuf, 63);
        if(_v56 != 0) {
            if(_v60 == 0 || _v56 < _v60) {
                _v60 = _v56;
            }
        }
    }
    if(_v60 != 0) {
        _v28 = Strnew_charp(_v60);
        Strshrink(_v24,  &(( *_v24)[_v24->length]) - _v60);
    }
    if((obuf->flag & 527) == 0) {
        asm("cwde ");
        if((obuf->pos & 65535) > width) {
            _v64 =  &(( *_v24)[ *((intOrPtr*)(obuf + 192)) -  *((intOrPtr*)(obuf + 196))]);
            _v68 =  &(( *_v24)[_v24->length]);
            asm("cwde ");
            if( *((intOrPtr*)(obuf + 188)) == (obuf->pos & 65535)) {
                if(_v64 <= _v68) {
                    if( *_v24 < _v64) {
                        if(( *(_v64 - 1) & 255 & 4294967295) == 32) {
                            bcopy(_v64, _v64 - 1, _v68 - _v64 + 1);
                            _v24->length = _v24->length - 1;
                            obuf->pos = (obuf->pos & 65535) - 1 & 4294967295;
                        }
                    }
                }
            }
        }
    }
    if( *(obuf + 72) != 0) {
        if(_v32 == 0) {
            Strcat_charp(_v24, 135043896);
        }
    }
    if( *(obuf + 132) != 0) {
        if(_v36 == 0) {
            Strcat_charp(_v24, "</img_alt>");
        }
    }
    if((obuf->fontstat & 255 & 4294967295) != 0 && _v40 == 0) {
        Strcat_charp(_v24, "</b>");
    }
    if((obuf->fontstat[2] & 255 & 4294967295) != 0 && _v48 == 0) {
        Strcat_charp(_v24, "</i>");
    }
    if((obuf->fontstat[1] & 255 & 4294967295) != 0 && _v44 == 0) {
        Strcat_charp(_v24, "</u>");
    }
    if((obuf->fontstat[3] & 255 & 4294967295) != 0 && _v52 == 0) {
        Strcat_charp(_v24, "</s>");
    }
    if((obuf->fontstat[4] & 255 & 4294967295) != 0 && _v56 == 0) {
        Strcat_charp(_v24, "</ins>");
    }
    if((obuf->top_margin & 65535 & 4294967295) <= 0) {
L75:
        if(force == 1 || (obuf->flag & 32768) != 0) {
            asm("cwde ");
            _v76 = newTextLine(_v24, obuf->pos & 65535);
            if((obuf->flag & 112) != 32) {
                if((obuf->flag & 112) != 64) {
                    if((obuf->flag & 112) == 16 && (obuf->flag & 131072) != 0) {
                        align(_v76, width, 1);
                    }
                } else {
                    align(_v76, width, 2);
                }
            } else {
                align(_v76, width, 0);
            }
            if((_v76->pos & 65535 & 4294967295) > h_env->maxlimit) {
                h_env->maxlimit = _v76->pos & 65535 & 4294967295;
            }
            if(_v16 == 0) {
                if(_v20 != 0) {
                    if((ExtHalfdump & 255 & 4294967295) == 0) {
                        _t836 =  *_v76;
                    } else {
                        _t836 = wc_Str_conv( *_v76, InnerCharset, DisplayCharset);
                    }
                    _t1020 = _t836->length;
                    if((ExtHalfdump & 255 & 4294967295) == 0) {
                        _t840 =  *_v76;
                    } else {
                        _t840 = wc_Str_conv( *_v76, InnerCharset, DisplayCharset);
                    }
                    fwrite( *_t840, 1, _t1020, _v20);
                    fputc(10, _v20);
                }
            } else {
                pushValue(_v16, _v76);
            }
            if((obuf->flag & 655) != 0 || (obuf->flag & 32768) != 0) {
                h_env->blank_lines = 0;
            } else {
                h_env->blank_lines =  &(h_env->blank_lines->first);
            }
            if((obuf->bottom_margin & 65535 & 4294967295) <= 0) {
L129:
                if((obuf->top_margin & 65535 & 4294967295) >= 0) {
                    return ;
                }
                if((obuf->bottom_margin & 65535 & 4294967295) >= 0) {
                    return ;
                }
                obuf->line = Strnew_size(256);
                obuf->pos = 0;
                obuf->top_margin = 0;
                obuf->bottom_margin = 0;
                Strcopy_charp_n( *(obuf + 8), " ", 1);
                 *(obuf + 280) = 1;
                obuf->flag = obuf->flag;
                set_breakpoint(obuf, 0);
                 *(obuf + 184) = 0;
                link_stack = 0;
                fillline(obuf, indent);
                if(_v28 != 0) {
                    passthrough(obuf,  *_v28, 0);
                }
                if(_v32 == 0 &&  *(obuf + 72) != 0) {
                    if( *(obuf + 116) > 0) {
                         *(obuf + 116) =  ~( *(obuf + 116));
                    }
                    _v536 =  *(obuf + 116);
                    _v100 = Sprintf("<A HSEQ="%d" HREF="");
                    Strcat_charp(_v100, html_quote( *(obuf + 72)));
                    if( *(obuf + 76) != 0) {
                        Strcat_charp(_v100, "" TARGET="");
                        Strcat_charp(_v100, html_quote( *(obuf + 76)));
                    }
                    if( *(obuf + 80) != 0) {
                        Strcat_charp(_v100, "" REFERER="");
                        Strcat_charp(_v100, html_quote( *(obuf + 80)));
                    }
                    if( *(obuf + 84) != 0) {
                        Strcat_charp(_v100, "" TITLE="");
                        Strcat_charp(_v100, html_quote( *(obuf + 84)));
                    }
                    if(( *(obuf + 88) & 255 & 4294967295) != 0) {
                        _v104 =  *( &HTML_QUOTE_MAP + ( *( &QUOTE_MAP + ( *(obuf + 88) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 7) * 4);
                        Strcat_charp(_v100, "" ACCESSKEY="");
                        if(_v104 == 0) {
                            if(_v100->length + 1 >= _v100->area_size) {
                                Strgrow(_v100);
                            }
                            _t766 = _v100->length;
                            ( *_v100)[_t766] =  *(obuf + 88) & 255 & 4294967295;
                            _v100->length = _t766 + 1;
                            ( *_v100)[_v100->length] = 0;
                        } else {
                            Strcat_charp(_v100, _v104);
                        }
                    }
                    Strcat_charp(_v100, "">");
                    push_tag(obuf,  *_v100, 1);
                }
                if(_v36 == 0 &&  *(obuf + 132) != 0) {
                    _v108 = Strnew_charp("<IMG_ALT SRC="");
                    Strcat_charp(_v108, html_quote( *( *(obuf + 132))));
                    Strcat_charp(_v108, "">");
                    push_tag(obuf,  *_v108, 136);
                }
                if(_v40 == 0 && (obuf->fontstat & 255 & 4294967295) != 0) {
                    push_tag(obuf, "<B>", 7);
                }
                if(_v48 == 0 && (obuf->fontstat[2] & 255 & 4294967295) != 0) {
                    push_tag(obuf, "<I>", 109);
                }
                if(_v44 == 0 && (obuf->fontstat[1] & 255 & 4294967295) != 0) {
                    push_tag(obuf, "<U>", 65);
                }
                if(_v52 == 0 && (obuf->fontstat[3] & 255 & 4294967295) != 0) {
                    push_tag(obuf, "<S>", 105);
                }
                if(_v56 != 0) {
                    return ;
                }
                if((obuf->fontstat[4] & 255 & 4294967295) == 0) {
                    return ;
                }
                push_tag(obuf, "<INS>", 63);
                return;
            }
            init_henv( &_v172,  &_v508,  &_v124, 1, 0, width, indent);
            _v508.line = Strnew_size(width + 20);
            _v508.pos = obuf->pos & 65535 & 4294967295;
            _v508.flag = obuf->flag;
            _v508.top_margin = 65535;
            _v508.bottom_margin = 65535;
            Strcat_charp(_v508.line, "<pre_int>");
            _v96 = 0;
            while(1) {
                asm("cwde ");
                if((_v502 & 65535) <= _v96) {
                    break;
                }
                if(_v508.line->length + 1 >= _v508.line->area_size) {
                    Strgrow(_v508.line);
                }
                _t814 = _v508.line;
                _t1053 =  *((intOrPtr*)(_t814 + 4));
                 *((char*)(_v508.line->ptr + _t1053)) = 32;
                 *((intOrPtr*)(_t814 + 4)) = _t1053 + 1;
                 *(_v508.line->ptr + _v508.line->length) = 0;
                _v96 =  &(_v96->first);
            }
            Strcat_charp(_v508.line, "</pre_int>");
            _v96 = 0;
            while(1) {
                asm("cwde ");
                if((obuf->bottom_margin & 65535) <= _v96) {
                    break;
                }
                flushline(h_env,  &_v508, indent, force, width);
                _v96 =  &(_v96->first);
            }
            goto L129;
        }
        _v80 =  *_v24;
        _v88 = Strnew();
        _v92 = Strnew();
        while(( *_v80 & 255 & 4294967295) != 0) {
            _v84 = _v80;
            if(sloppy_parse_line( &_v80) != 0) {
                Strcat_charp_n(_v88, _v84, _v80 - _v84);
                if(force != 2) {
                    Strcat(_v92, _v88);
                } else {
                    if(_v16 == 0) {
                        if(_v20 != 0) {
                            fwrite( *_v88, 1, _v88->length, _v20);
                        }
                    } else {
                        appendTextLine(_v16, _v88, 0);
                    }
                }
                Strclear(_v88);
            }
        }
    }
    init_henv( &_v172,  &_v508,  &_v124, 1, 0, width, indent);
    _v508.line = Strnew_size(width + 20);
    _v508.pos = obuf->pos & 65535 & 4294967295;
    _v508.flag = obuf->flag;
    _v508.top_margin = 65535;
    _v508.bottom_margin = 65535;
    Strcat_charp(_v508.line, "<pre_int>");
    _v72 = 0;
    while(1) {
        asm("cwde ");
        if((_v502 & 65535) <= _v72) {
            break;
        }
        if(_v508.line->length + 1 >= _v508.line->area_size) {
            Strgrow(_v508.line);
        }
        _t918 = _v508.line;
        _t1066 =  *((intOrPtr*)(_t918 + 4));
         *((char*)(_v508.line->ptr + _t1066)) = 32;
         *((intOrPtr*)(_t918 + 4)) = _t1066 + 1;
         *(_v508.line->ptr + _v508.line->length) = 0;
        _v72 =  &(_v72->first);
    }
    Strcat_charp(_v508, "</pre_int>");
    _v72 = 0;
    while(1) {
        asm("cwde ");
        if((obuf->top_margin & 65535) <= _v72) {
            break;
        }
        flushline(h_env,  &_v508, indent, force, width);
        _v72 =  &(_v72->first);
    }
    goto L75;
}

do_blankline(struct html_feed_environ* h_env, struct readbuffer* obuf, int indent, int indent_incr, int width)
{// addr = 0x08061711
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(h_env->blank_lines != 0) {
        return ;
    }
    flushline(h_env, obuf, indent, 1, width);
    return;
}

purgeline(struct html_feed_environ* h_env)
{// addr = 0x0806174B
    char* p;
    char* q;
    Str tmp;
    signed char* _v16;
    _unknown_ _v20;
    struct _Str* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(h_env->buf == 0) {
        return ;
    }
    if(h_env->blank_lines == 0) {
        return ;
    }
    _v16 =  *( *(rpopValue(h_env->buf)));
    _v24 = Strnew();
    while(( *_v16 & 255 & 4294967295) != 0) {
    }
}

int close_effect0(struct readbuffer* obuf, int cmd)
{// addr = 0x08061803
    int i;
    char* p;
    signed int _v16;
    char* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t51;
    _unknown_ _t54;
    _unknown_ _t69;
    _unknown_ _t70;

    _v16 = obuf->tag_sp - 1;
    while(_v16 >= 0) {
        if( *((intOrPtr*)( *((intOrPtr*)(obuf + (_v16 + 72) * 4)) + 4)) == cmd) {
            goto L6;
        }
        _v16 = _v16 - 1;
        continue;
L6:
        if(_v16 >= 0) {
            _v20 = has_hidden_link(obuf, cmd);
            if(_v20 == 0) {
                return 0;
            }
            passthrough(obuf, _v20, 1);
            return 1;
        }
        obuf->tag_sp = obuf->tag_sp - 1;
        bcopy( &(( &(obuf->tag_stack))[_v16 + 1]),  &(( &(obuf->tag_stack))[_v16]), 0 + (obuf->tag_sp - _v16) * 4);
        return 1;
    }
}

close_anchor(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x080618EE
    int i;
    char* p;
    int is_erased;
    signed int _v16;
    char* _v20;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t107;
    _unknown_ _t120;
    _unknown_ _t135;
    struct _Str* _t149;
    int _t192;

    if( *(obuf + 72) == 0) {
L25:
        bzero(obuf + 72, 60);
        return;
    } else {
        _v20 = 0;
        _v24 = 0;
        _v16 = obuf->tag_sp - 1;
        while(_v16 >= 0) {
            if( *((intOrPtr*)( *((intOrPtr*)(obuf + (_v16 + 72) * 4)) + 4)) != 1) {
                _v16 = _v16 - 1;
                continue;
            }
            if(_v16 < 0 &&  *((intOrPtr*)(obuf + 116)) > 0 && obuf->line->length > 0 && ( *( *(obuf->line) + obuf->line->length - 1) & 255 & 4294967295) == 32) {
                Strshrink(obuf->line, 1);
                obuf->pos = (obuf->pos & 65535) - 1 & 4294967295;
                _v24 = 1;
            }
            if(_v16 >= 0) {
L14:
                if( *((intOrPtr*)(obuf + 116)) <= 0) {
                    if(_v16 >= 0) {
                        passthrough(obuf, _v20, 1);
                    } else {
                        obuf->tag_sp = obuf->tag_sp - 1;
                        bcopy( &(obuf->tag_stack) + (_v16 + 1 << 2),  &(obuf->tag_stack) + (_v16 << 2), 0 + (obuf->tag_sp - _v16) * 4);
                    }
                    bzero(obuf + 72, 60);
                    return;
                }
            } else {
                _v20 = has_hidden_link(obuf, 1);
                if(_v20 == 0) {
L20:
                    if(_v24 != 0) {
                        if(obuf->line->length + 1 >= obuf->line->area_size) {
                            Strgrow(obuf->line);
                        }
                        _t149 = obuf->line;
                        _t192 = _t149->length;
                         *((char*)( *(obuf->line) + _t192)) = 32;
                        _t149->length = _t192 + 1;
                         *( *(obuf->line) + obuf->line->length) = 0;
                        obuf->pos = (obuf->pos & 65535) + 1 & 4294967295;
                    }
                    push_tag(obuf, 135043896, 2);
                    goto L25;
                }
                goto L14;
            }
L15:
            HTMLlineproc0(135044067, h_env, 1);
            Strcopy_charp_n( *(obuf + 8), " ", 1);
            _v24 = 0;
            goto L20;
        }
    }
    return;
}

save_fonteffect(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x08061B5C
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t65;
    _unknown_ _t79;

    if(obuf->fontstat_sp <= 4) {
        bcopy( &(obuf->fontstat),  &(obuf->fontstat_stack) + (obuf->fontstat_sp << 3) - obuf->fontstat_sp, 7);
    }
    obuf->fontstat_sp = obuf->fontstat_sp + 1;
    if((obuf->fontstat & 255 & 4294967295) != 0) {
        push_tag(obuf, "</b>", 8);
    }
    if((obuf->fontstat[2] & 255 & 4294967295) != 0) {
        push_tag(obuf, "</i>", 110);
    }
    if((obuf->fontstat[1] & 255 & 4294967295) != 0) {
        push_tag(obuf, "</u>", 66);
    }
    if((obuf->fontstat[3] & 255 & 4294967295) != 0) {
        push_tag(obuf, "</s>", 106);
    }
    if((obuf->fontstat[4] & 255 & 4294967295) != 0) {
        push_tag(obuf, "</ins>", 64);
    }
    bzero( &(obuf->fontstat), 7);
    return;
}

restore_fonteffect(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x08061CA6
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t76;

    if(obuf->fontstat_sp > 0) {
        obuf->fontstat_sp = obuf->fontstat_sp - 1;
    }
    if(obuf->fontstat_sp <= 4) {
        bcopy( &(obuf->fontstat_stack) + (obuf->fontstat_sp << 3) - obuf->fontstat_sp,  &(obuf->fontstat), 7);
    }
    if((obuf->fontstat & 255 & 4294967295) != 0) {
        push_tag(obuf, 135044069, 7);
    }
    if((obuf->fontstat[2] & 255 & 4294967295) != 0) {
        push_tag(obuf, 135044073, 109);
    }
    if((obuf->fontstat[1] & 255 & 4294967295) != 0) {
        push_tag(obuf, 135044077, 65);
    }
    if((obuf->fontstat[3] & 255 & 4294967295) != 0) {
        push_tag(obuf, 135044081, 105);
    }
    if((obuf->fontstat[4] & 255 & 4294967295) == 0) {
        return ;
    }
    push_tag(obuf, 135044085, 63);
    return;
}

Str process_title(struct parsed_tag* tag)
{// addr = 0x08061DEB
    _unknown_ __ebp;
    _unknown_ _t1;
    _unknown_ _t3;

    cur_title = Strnew();
    return 0;
}

Str process_n_title(struct parsed_tag* tag)
{// addr = 0x08061E02
    Str tmp;
    struct _Str* _v16;
    struct _Str* _v32;
    char* _v36;
    char* _v40;
    _unknown_ __ebp;
    char* _t11;
    _unknown_ _t14;

    if(cur_title == 0) {
        return 0;
    }
    Strremovefirstspaces(cur_title);
    Strremovetrailingspaces(cur_title);
    _t11 = html_quote(cur_title->ptr);
    _v32 = 0;
    _v36 = "">";
    _v40 = _t11;
    _v16 = Strnew_m_charp("<title_alt title="");
    cur_title = 0;
    return _v16;
}

feed_title(char* str)
{// addr = 0x08061E73
    _unknown_ _v24;
    _unknown_ __ebp;

    __eax = cur_title;
    if(cur_title == 0) {
        return ;
    }
    while(1) {
        str =  *str & 255;
        if(( *str & 255 & 4294967295) == 0) {
            break;
        }
        str =  *str & 255;
        if(( *str & 255 & 4294967295) != 38) {
            str =  *str & 255;
            if(( *str & 255 & 4294967295) == 10) {
L6:
                cur_title = cur_title->length;
                __edx = cur_title->length + 1;
                cur_title = cur_title->area_size;
                if(cur_title->length + 1 >= cur_title->area_size) {
                    __eax = cur_title;
                    Strgrow(cur_title);
                }
                __eax = cur_title;
                __eax = cur_title;
                __edx = __eax->length;
                __edx = __edx + cur_title->ptr;
                 *(__edx + cur_title->ptr) = 32;
                __eax->length = __edx;
                __eax = cur_title;
                __edx = cur_title->ptr;
                cur_title = cur_title->length;
                __eax = cur_title->ptr + cur_title->length;
                 *(cur_title->ptr + cur_title->length) = 0;
                str =  &(str[1]);
                str =  &(str[1]);
            } else {
                str =  *str & 255;
                if(( *str & 255 & 4294967295) != 13) {
                    cur_title = cur_title->length;
                    __edx = cur_title->length + 1;
                    cur_title = cur_title->area_size;
                    if(cur_title->length + 1 >= cur_title->area_size) {
                        __eax = cur_title;
                        Strgrow(cur_title);
                    }
                    __eax = cur_title;
                    __eax = cur_title;
                    __ecx = __eax->length;
                    __edx = __ecx;
                    __edx = str;
                     *(cur_title->ptr + __ecx) = __edx->ptr & 255 & 4294967295;
                    __eax->length = __ecx;
                    __eax =  &(__edx->ptr);
                    str =  &(__edx->ptr);
                    __eax = cur_title;
                    __edx = cur_title->ptr;
                    cur_title = cur_title->length;
                    __eax = cur_title->ptr + cur_title->length;
                     *(cur_title->ptr + cur_title->length) = 0;
                } else {
                    goto L6;
                }
            }
        } else {
             &str = getescapecmd( &str);
            __edx = cur_title;
            Strcat_charp(cur_title,  &str);
        }
    }
    return;
}

Str process_img(struct parsed_tag* tag, int width)
{// addr = 0x08061FA7
    char* p;
    char* q;
    char* r;
    char* r2;
    char* s;
    char* t;
    int w;
    int i;
    int nw;
    int ni;
    int n;
    int w0;
    int i0;
    int align;
    int xoffset;
    int yoffset;
    int top;
    int bottom;
    int ismap;
    int use_image;
    int pre_int;
    int ext_pre_int;
    Str tmp;
    Str tmp2;
    Image image;
    ParsedURL u;
    char* r;
    char* _v32;
    char* _v36;
    char* _v40;
    char* _v44;
    char* _v48;
    char* _v52;
    signed int _v56;
    signed int _v60;
    int _v64;
    unsigned int _v68;
    int _v72;
    signed int _v76;
    signed int _v80;
    int _v84;
    char* _v88;
    int _v92;
    signed int _v96;
    int _v100;
    int _v104;
    int _v108;
    int _v112;
    int _v116;
    struct _Str* _v120;
    struct _Str* _v124;
    signed char* _v128;
    struct _image _v164;
    struct _ParsedURL _v204;
    signed int _v208;
    signed int _v210;
    signed int _v212;
    _unknown_ _v224;
    int _v228;
    signed int _v232;
    _unknown_ __ebp;
    int _t616;
    _unknown_ _t625;
    _unknown_ _t629;
    _unknown_ _t635;
    _unknown_ _t638;
    int _t645;
    _unknown_ _t671;
    _unknown_ _t692;
    _unknown_ _t713;
    _unknown_ _t726;
    int _t735;
    char* _t765;
    char* _t767;
    signed int _t790;
    signed int _t802;
    int _t820;
    char* _t828;
    signed int _t865;
    int _t906;
    int _t908;
    int _t909;
    int _t942;
    char* _t945;
    int _t949;
    int _t959;
    _unknown_ _t980;
    int _t1054;

    _v44 = 0;
    _v68 = 1;
    _v76 = -1;
    _v80 = -1;
    _v104 = 0;
    if(activeImage == 0) {
L3:
        _t616 = 0;
        goto L4;
    }
    if(displayImage == 0) {
        goto L3;
    } else {
        _t616 = 1;
    }
L4:
    _v108 = _t616;
    _v112 = 0;
    _v116 = 0;
    _v120 = Strnew();
    if(parsedtag_get_value(tag, 31,  &_v32) == 0) {
        return _v120;
    }
    _v32 = remove_space(_v32);
    _v36 = 0;
    parsedtag_get_value(tag, 5,  &_v36);
    _v52 = _v36;
    parsedtag_get_value(tag, 49,  &_v52);
    _v56 = -1;
    if(parsedtag_get_value(tag, 38,  &_v56) != 0) {
        if(_v56 < 0) {
            if(width <= 0) {
                _v56 = -1;
            } else {
                _v208 =  ~width;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53a0]");
                asm("fmulp st1, st0");
                _v208 = _v56;
                asm("fild dword [ebp+0xffffff34]");
                asm("fmulp st1, st0");
                asm("fld qword [0x80cab78]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80cab80]");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 65535 & 4294967295;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                _v56 = _v208;
            }
        }
        if(_v108 != 0) {
            if(_v56 > 0) {
                _v208 = _v56;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53b0]");
                asm("fmulp st1, st0");
                asm("fld qword [0x80cab78]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80cab80]");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 65535 & 4294967295;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                _v56 = _v208;
                if(_v56 != 0) {
                    if(_v56 > 2048) {
                        _v56 = 2048;
                    }
                } else {
                    _v56 = 1;
                }
            }
        }
    }
    if(_v108 == 0) {
        parsedtag_get_value(tag, 17,  &_v60);
    } else {
        _v60 = -1;
        if(parsedtag_get_value(tag, 17,  &_v60) != 0) {
            if(_v60 <= 0) {
                _v60 = -1;
            } else {
                _v208 = _v60;
                asm("fild dword [ebp+0xffffff34]");
                asm("fld qword [0x80d53b0]");
                asm("fmulp st1, st0");
                asm("fld qword [0x80cab78]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80cab80]");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 65535 & 4294967295;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                _v60 = _v208;
                if(_v60 != 0) {
                    if(_v60 > 2048) {
                        _v60 = 2048;
                    }
                } else {
                    _v60 = 1;
                }
            }
        }
        _v84 = -1;
        parsedtag_get_value(tag, 4,  &_v84);
        _v104 = 0;
        if(tag->map != 0 && (tag->map[0x2e] & 255 & 4294967295) != 75 && (tag->attrid[tag->map[0x2e] & 255 & 4294967295 & ] & 255 & 4294967295) != 0) {
            _v104 = 1;
        }
    }
    _v40 = 0;
    parsedtag_get_value(tag, 34,  &_v40);
    if(tag->map != 0 && (tag->map[0x4a] & 255 & 4294967295) != 75 && (tag->attrid[tag->map[0x4a] & 255 & 4294967295 & ] & 255 & 4294967295) != 0) {
        _v116 = 1;
    }
    _v120 = Strnew_size(128);
    if(_v108 != 0) {
        _t959 = _v84;
        if(_t959 == 1) {
            Strcat_charp(_v120, "<div_int align=left>");
        } else {
            if(_t959 == 2) {
                Strcat_charp(_v120, "<div_int align=right>");
            } else {
                if(_t959 == 0) {
                    Strcat_charp(_v120, "<div_int align=center>");
                }
            }
        }
    }
    if(_v40 != 0) {
        _v44 = strchr(_v40, 35);
        _v48 = "<form_int method=internal action=map>";
        _v124 = process_form(parse_tag( &_v48, 1));
        if(_v124 != 0) {
            Strcat(_v120, _v124);
        }
        if(form_sp >= 0) {
            _t942 = -1;
        } else {
            _t942 = form_stack[form_sp];
        }
        _v232 = _t942;
        Strcat(_v120, Sprintf("<input_alt fid="%d" type=hidden name=link value=""));
        if(_v44 == 0) {
            _t945 = _v40;
        } else {
            _t945 =  &(_v44[1]);
        }
        Strcat_charp(_v120, html_quote(_t945));
        if(form_sp >= 0) {
            _t949 = -1;
        } else {
            _t949 = form_stack[form_sp];
        }
        _t1054 = cur_hseq;
        cur_hseq = _t1054 + 1;
        _v228 = _t949;
        _v232 = _t1054;
        Strcat(_v120, Sprintf(""><input_alt hseq="%d" fid="%d" type=submit no_effect=true>"));
    }
    if(_v108 == 0) {
        if(_v56 < 0) {
            asm("fld qword [0x80d53a0]");
            asm("fld qword [0x80cab90]");
            asm("fmulp st1, st0");
            asm("fnstcw word [ebp+0xffffff32]");
            _v212 = _v210 & 65535 & 4294967295;
            asm("fldcw word [ebp+0xffffff30]");
            asm("fistp dword [ebp+0xffffff34]");
            asm("fldcw word [ebp+0xffffff32]");
            _v56 = _v208;
        }
        if(_v56 == 0) {
            _t645 = 1;
        } else {
            _v208 = _v56 - 1;
            asm("fild dword [ebp+0xffffff34]");
            asm("fld qword [0x80d53a0]");
            asm("fdivp st1, st0");
            asm("fld1 ");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp+0xffffff32]");
            _v212 = _v210 & 65535 & 4294967295;
            asm("fldcw word [ebp+0xffffff30]");
            asm("fistp dword [ebp+0xffffff34]");
            asm("fldcw word [ebp+0xffffff32]");
            _t645 = _v208;
        }
        _v64 = _t645;
        if(_v40 != 0) {
            Strcat_charp(_v120, "<pre_int>");
            _v112 = 1;
        }
        Strcat_charp(_v120, "<img_alt src="");
    } else {
        _v76 = _v56;
        _v80 = _v60;
        if(_v56 >= 0 || _v60 < 0) {
            parseURL2( *(wc_Str_conv(Strnew_charp(_v32), InnerCharset, cur_document_charset & 255 & 4294967295)),  &_v204, cur_baseURL);
            _v164 =  *(parsedURL2Str( &_v204));
            if(uncompressed_file_type(_v184,  &( &_v164->ext)) == 0) {
                _v164.ext = filename_extension(_v204.file, 1);
            }
            _v164.cache = 0;
            _v164.width = _v56 & 4294967295;
            _v164.height = _v60 & 4294967295;
            _v164.cache = getImage( &_v164, cur_baseURL, 1);
            if(_v132 != 0 && (_v132->width & 65535 & 4294967295) > 0 && (_v132->height & 65535 & 4294967295) > 0) {
                asm("cwde ");
                _v76 = _v164.cache->width & 65535;
                _v56 = _v76;
                asm("cwde ");
                _v80 = _v164.cache->height & 65535;
                _v60 = _v80;
            }
            if(_v56 < 0) {
                asm("fld qword [0x80d53a0]");
                asm("fld qword [0x80cab88]");
                asm("fmulp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 65535 & 4294967295;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                _v56 = _v208;
            }
            if(_v60 < 0) {
                asm("fld qword [0x80d53a8]");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 65535 & 4294967295;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp+0xffffff34]");
                asm("fldcw word [ebp+0xffffff32]");
                _v60 = _v208;
            }
        }
        if(_v56 <= 3) {
            _t906 = 1;
        } else {
            _v208 = _v56 - 3;
            asm("fild dword [ebp+0xffffff34]");
            asm("fld qword [0x80d53a0]");
            asm("fdivp st1, st0");
            asm("fld1 ");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp+0xffffff32]");
            _v212 = _v210 & 65535 & 4294967295;
            asm("fldcw word [ebp+0xffffff30]");
            asm("fistp dword [ebp+0xffffff34]");
            asm("fldcw word [ebp+0xffffff32]");
            _t906 = _v208;
        }
        _v64 = _t906;
        if(_v60 <= 3) {
            _t908 = 1;
        } else {
            _v208 = _v60 - 3;
            asm("fild dword [ebp+0xffffff34]");
            asm("fld qword [0x80d53a8]");
            asm("fdivp st1, st0");
            asm("fld1 ");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp+0xffffff32]");
            _v212 = _v210 & 65535 & 4294967295;
            asm("fldcw word [ebp+0xffffff30]");
            asm("fistp dword [ebp+0xffffff34]");
            asm("fldcw word [ebp+0xffffff32]");
            _t908 = _v208;
        }
        _v68 = _t908;
        _t909 = cur_iseq;
        cur_iseq = _t909 + 1;
        _v232 = _t909;
        Strcat(_v120, Sprintf("<pre_int><img_alt hseq="%d" src=""));
        _v112 = 1;
    }
    Strcat_charp(_v120, html_quote(_v32));
    Strcat_charp(_v120, """);
    if(_v52 != 0) {
        Strcat_charp(_v120, " title="");
        Strcat_charp(_v120, html_quote(_v52));
        Strcat_charp(_v120, """);
    }
    if(_v108 == 0) {
L119:
        Strcat_charp(_v120, ">");
        if(_v36 != 0 && ( *_v36 & 255 & 4294967295) == 0 && ignore_null_img_alt != 0) {
            _v36 = 0;
        }
        if(_v36 == 0) {
L141:
            if(_v56 <= 0 || _v60 <= 0) {
L160:
                _v36 = _v32;
L162:
                while(( *_v36 & 255 & 4294967295) != 0) {
                    goto L161;
                }
            } else {
                if(_v56 > 31 || _v60 > 47) {
                    if(_v56 <= 200 || _v60 > 12) {
                        goto L160;
                    } else {
                        if(_v112 == 0) {
                            Strcat_charp(_v120, "<pre_int>");
                            _v112 = 1;
                        }
                        _v208 = _v56;
                        asm("fild dword [ebp+0xffffff34]");
                        asm("fld qword [0x80d53a0]");
                        asm("fdivp st1, st0");
                        _v208 = symbol_width;
                        asm("fild dword [ebp+0xffffff34]");
                        asm("fdivp st1, st0");
                        asm("fnstcw word [ebp+0xffffff32]");
                        _v212 = _v210 & 65535 & 4294967295;
                        asm("fldcw word [ebp+0xffffff30]");
                        asm("fistp dword [ebp+0xffffff34]");
                        asm("fldcw word [ebp+0xffffff32]");
                        _v56 = _v208;
                        if(_v56 <= 0) {
                            _v56 = 1;
                        }
                        push_symbol(_v120, 26, symbol_width, _v56);
                        _v72 = symbol_width * _v56;
L186:
                        if(_v108 == 0) {
                            Strcat_charp(_v120, "</img_alt>");
                            if(_v112 != 0 && _v116 == 0) {
                                Strcat_charp(_v120, "</pre_int>");
                            }
                            if(_v40 != 0) {
                                Strcat_charp(_v120, "</input_alt>");
                                process_n_form();
                            }
                            if(_v108 == 0) {
                                return _v120;
                            }
                            if(_v84 > 2) {
                                return _v120;
                            }
                            Strcat_charp(_v120, "</div_int>");
                            return _v120;
                        }
                        while(_v72 < _v64) {
                            if(_v120->length + 1 >= _v120->area_size) {
                                Strgrow(_v120);
                            }
                            _t735 = _v120->length;
                             *((char*)( *_v120 + _t735)) = 32;
                            _v120->length = _t735 + 1;
                             *( *_v120 + _v120->length) = 0;
                            _v72 = _v72 + 1;
                        }
                    }
                    goto L161;
                }
                _v72 = 1;
                _t765 = _v32;
                _v232 = "space";
                 *__esp = _t765;
                strcasestr();
                if(_t765 != 0) {
L147:
                    Strcat_charp(_v120, "_");
                    goto L186;
                }
                _t767 = _v32;
                _v232 = "blank";
                 *__esp = _t767;
                strcasestr();
                if(_t767 == 0) {
                    if(_v60 * _v56 > 127) {
                        if(_v112 == 0) {
                            Strcat_charp(_v120, "<pre_int>");
                            _v112 = 1;
                        }
                        push_symbol(_v120, 44, symbol_width, 1);
                        _v72 = symbol_width;
                    } else {
                        Strcat_charp(_v120, "*");
                    }
                    goto L186;
                }
                goto L147;
            }
L161:
            _v36 =  &(_v36[1]);
            goto L162;
        }
        _v72 = wtf_strwidth(_v36);
        if(_v108 == 0) {
L140:
            Strcat_charp(_v120, html_quote(_v36));
            goto L186;
        }
        if(_v72 <= _v64) {
            Strcat_charp(_v120, html_quote(_v36));
            goto L186;
        }
        _v128 = _v36;
        _v72 = 0;
        while(_v128 != 0) {
            if(( *135119023 & 255 & 4294967295) == 0) {
                _t790 =  *( &WTF_WIDTH_MAP + ( *_v128 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            } else {
                _t790 =  *( &WTF_WIDTH_MAP + ( *_v128 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            }
            if(_t790 + _v72 <= _v64) {
                _v128 =  &(_v128[ *( &WTF_LEN_MAP + ( *_v128 & 255 & 4294967295 & )) & 255 & 4294967295 & ]);
                if(( *135119023 & 255 & 4294967295) == 0) {
                    _t802 =  *( &WTF_WIDTH_MAP + ( *_v128 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                } else {
                    _t802 =  *( &WTF_WIDTH_MAP + ( *_v128 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                }
                _v72 = _v72 + _t802;
                continue;
            }
            Strcat_charp(_v120, html_quote( *(Strnew_charp_n(_v36, _v128 - _v36))));
            goto L186;
        }
        goto L140;
    } else {
        if(_v76 < 0) {
            _v232 = _v76;
            Strcat(_v120, Sprintf(" width=%d"));
        }
        if(_v80 < 0) {
            _v232 = _v80;
            Strcat(_v120, Sprintf(" height=%d"));
        }
        _t820 = _v84;
        if(_t820 == 5) {
            _v96 = 0;
            _v100 = _v68 - 1;
            _v92 = 0;
            asm("fnstcw word [ebp+0xffffff32]");
            _v212 = _v210 & 65535 & 4294967295;
        } else {
            if(_t820 == 6) {
                _v96 = _v68 - 1;
                _v100 = 0;
                asm("fild dword [ebp-0x40]");
                asm("fld qword [0x80d53a8]");
                asm("fmulp st1, st0");
                _v208 = _v60;
                asm("fild dword [ebp+0xffffff34]");
                asm("fsubp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 65535 & 4294967295;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp-0x58]");
                asm("fldcw word [ebp+0xffffff32]");
L104:
                asm("fild dword [ebp-0x3c]");
                asm("fld qword [0x80d53a0]");
                asm("fmulp st1, st0");
                _v208 = _v56;
                asm("fild dword [ebp+0xffffff34]");
                asm("fsubp st1, st0");
                asm("fld qword [0x80cab98]");
                asm("fdivp st1, st0");
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp-0x54]");
                asm("fldcw word [ebp+0xffffff32]");
                if(_v88 != 0) {
                    _v232 = _v88;
                    Strcat(_v120, Sprintf(" xoffset=%d"));
                }
                if(_v92 != 0) {
                    _v232 = _v92;
                    Strcat(_v120, Sprintf(" yoffset=%d"));
                }
                if(_v96 != 0) {
                    _v232 = _v96;
                    Strcat(_v120, Sprintf(" top_margin=%d"));
                }
                if(_v100 != 0) {
                    _v232 = _v100;
                    Strcat(_v120, Sprintf(" bottom_margin=%d"));
                }
                if(_v40 != 0) {
                    Strcat_charp(_v120, " usemap="");
                    if(_v44 == 0) {
                        _t828 = _v40;
                    } else {
                        _t828 =  &(_v44[1]);
                    }
                    Strcat_charp(_v120, html_quote(_t828));
                    Strcat_charp(_v120, """);
                }
                if(_v104 != 0) {
                    Strcat_charp(_v120, " ismap");
                }
                goto L119;
            }
            if(_t820 == 4) {
                goto L95;
            }
            _v96 = _v68 - 1;
            _v100 = 0;
            if(_v68 != 1) {
L102:
                asm("fild dword [ebp-0x40]");
                asm("fld qword [0x80d53a8]");
                asm("fmulp st1, st0");
                _v208 = _v60;
                asm("fild dword [ebp+0xffffff34]");
                asm("fsubp st1, st0");
                asm("fnstcw word [ebp+0xffffff32]");
                _v212 = _v210 & 65535 & 4294967295;
                asm("fldcw word [ebp+0xffffff30]");
                asm("fistp dword [ebp-0x58]");
                asm("fldcw word [ebp+0xffffff32]");
                if(_v92 < 255) {
                    _v92 = _v92 + 1;
                }
                goto L104;
            }
            asm("fild dword [ebp-0x40]");
            asm("fld qword [0x80d53a8]");
            asm("fmulp st1, st0");
            _t865 = _v60;
            _v208 = _t865;
            asm("fild dword [ebp+0xffffff34]");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t865 & 4294967295) == 0) {
                goto L102;
            }
            _v92 = 0;
            asm("fnstcw word [ebp+0xffffff32]");
            _v212 = _v210 & 65535 & 4294967295;
        }
        goto L104;
L95:
        _v96 = (_v68 >> 31) + _v68 >> 1;
        _v100 = _v96;
        if(_v96 + _v96 != _v68) {
            asm("fild dword [ebp-0x40]");
            asm("fld qword [0x80d53a8]");
            asm("fmulp st1, st0");
            _v208 = _v60;
            asm("fild dword [ebp+0xffffff34]");
            asm("fsubp st1, st0");
            asm("fld qword [0x80cab98]");
            asm("fdivp st1, st0");
            asm("fnstcw word [ebp+0xffffff32]");
            _v212 = _v210 & 65535 & 4294967295;
            asm("fldcw word [ebp+0xffffff30]");
            asm("fistp dword [ebp-0x58]");
            asm("fldcw word [ebp+0xffffff32]");
        } else {
            _v208 = _v68 + 1;
            asm("fild dword [ebp+0xffffff34]");
            asm("fld qword [0x80d53a8]");
            asm("fmulp st1, st0");
            _v208 = _v60;
            asm("fild dword [ebp+0xffffff34]");
            asm("fsubp st1, st0");
            asm("fld qword [0x80cab98]");
            asm("fdivp st1, st0");
            asm("fnstcw word [ebp+0xffffff32]");
            _v212 = _v210 & 65535 & 4294967295;
            asm("fldcw word [ebp+0xffffff30]");
            asm("fistp dword [ebp-0x58]");
            asm("fldcw word [ebp+0xffffff32]");
        }
        goto L104;
    }
}

Str process_anchor(struct parsed_tag* tag, char* tagbuf)
{// addr = 0x08063264
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v36;
    int _v40;
    _unknown_ __ebp;
    int _t17;
    int _t24;
    _unknown_ _t29;

    if((tag->need_reconstruct & 255 & 4294967295) == 0) {
        _t17 = cur_hseq;
        cur_hseq = _t17 + 1;
        _v40 = _t17;
        _v16 = Sprintf("<a hseq="%d"");
        Strcat_charp(_v16,  &(tagbuf[2]));
        return _v16;
    }
    _t24 = cur_hseq;
    cur_hseq = _t24 + 1;
    _v40 = _t24;
    parsedtag_set_value(tag, 69,  *(Sprintf("%d")));
    return parsedtag2str(tag);
}

Str process_input(struct parsed_tag* tag)
{// addr = 0x080632F6
    int i;
    int w;
    int v;
    int x;
    int y;
    int z;
    int iw;
    int ih;
    char* q;
    char* p;
    char* r;
    char* p2;
    char* s;
    Str tmp;
    char* qq;
    int qlen;
    char* s;
    intOrPtr _v32;
    intOrPtr _v36;
    signed int _v40;
    int _v44;
    int _v48;
    int _v52;
    intOrPtr _v56;
    intOrPtr _v60;
    char* _v64;
    char* _v68;
    intOrPtr _v72;
    char* _v76;
    intOrPtr _v80;
    struct _Str* _v84;
    char* _v88;
    char* _v92;
    char* _v96;
    intOrPtr _v112;
    char* _v128;
    intOrPtr _v132;
    intOrPtr _v136;
    char* _v140;
    char* _v144;
    int _v148;
    char* _v152;
    _unknown_ __ebx;
    intOrPtr __edi;
    char* __esi;
    _unknown_ __ebp;
    _unknown_ _t274;
    _unknown_ _t277;
    _unknown_ _t280;
    _unknown_ _t283;
    _unknown_ _t286;
    _unknown_ _t289;
    int _t292;
    int _t295;
    int _t298;
    signed int _t304;
    int _t311;
    int _t321;
    int _t333;
    signed int _t340;
    int _t347;
    int _t362;
    signed int _t370;
    _unknown_ _t375;
    _unknown_ _t376;
    signed int _t378;
    _unknown_ _t384;
    int _t424;
    _unknown_ _t436;
    _unknown_ _t437;
    _unknown_ _t438;
    _unknown_ _t480;
    _unknown_ _t482;
    char* _t485;
    int _t497;
    _unknown_ _t513;
    _unknown_ _t516;

    _v84 = 0;
    _v88 = 135041709;
    _v92 = 0;
    if(form_sp >= 0 || form_stack[form_sp] < 0) {
        _v96 = "<form_int method=internal action=none>";
        _v84 = process_form(parse_tag( &_v96, 1));
    }
    if(_v84 == 0) {
        _v84 = Strnew();
    }
    _v68 = "text";
    parsedtag_get_value(tag, 33,  &_v68);
    _v64 = 0;
    parsedtag_get_value(tag, 36,  &_v64);
    _v72 = 135041709;
    parsedtag_get_value(tag, 25,  &_v72);
    _v36 = 20;
    parsedtag_get_value(tag, 30,  &_v36);
    _v32 = 20;
    parsedtag_get_value(tag, 22,  &_v32);
    _v76 = 0;
    parsedtag_get_value(tag, 5,  &_v76);
    if(tag->map == 0 || (tag->map[0xc] & 255 & 4294967295) == 75) {
L9:
        _t292 = 0;
    } else {
        if((tag->attrid[tag->map[0xc] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
            goto L9;
        } else {
            _t292 = 1;
        }
    }
L10:
    _v44 = _t292;
    if(tag->map == 0) {
L14:
        _t295 = 0;
        goto L15;
    }
    if((tag->map[1] & 255 & 4294967295) == 75 || (tag->attrid[tag->map[1] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
        goto L14;
    } else {
        _t295 = 1;
    }
L15:
    _v48 = _t295;
    if(tag->map == 0 || (tag->map[0x2b] & 255 & 4294967295) == 75 || (tag->attrid[tag->map[0x2b] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
        _t298 = 0;
    } else {
        _t298 = 1;
    }
    _v52 = _t298;
    _v40 = formtype(_v68);
    if(_v40 == 255) {
        return 0;
    }
    if(_v64 == 0 && _v40 <= 10) {
        goto __eax;
    }
    if(_v40 == 11) {
        _v64 = 0;
    }
    if(_v64 != 0) {
        _v88 = html_quote(_v64);
        _v92 = wtf_strwidth(_v64);
    }
    Strcat_charp(_v84, "<pre_int>");
    _t304 = _v40;
    if(_t304 == 3) {
        if(_v84->length + 1 >= _v84->area_size) {
            Strgrow(_v84);
        }
        _t311 = _v84->length;
         *((char*)( *_v84 + _t311)) = 40;
        _v84->length = _t311 + 1;
         *( *_v84 + _v84->length) = 0;
L40:
        _v112 = _v32;
        __edi = _v36;
        _t485 = html_quote(_v72);
        __esi = _v68;
        if(form_sp >= 0) {
            _t497 = -1;
        } else {
            _t497 = form_stack[form_sp];
        }
        _t321 = cur_hseq;
        cur_hseq = _t321 + 1;
        _v128 = _v88;
        _v132 = _v112;
        _v136 = __edi;
        _v140 = _t485;
        _v144 = __esi;
        _v148 = _t497;
        _v152 = _t321;
        Strcat(_v84, Sprintf("<input_alt hseq="%d" fid="%d" type=%s name="%s" width=%d maxlength=%d value="%s""));
        if(_v44 != 0) {
            Strcat_charp(_v84, " checked");
        }
        if(_v48 != 0) {
            Strcat_charp(_v84, " accept");
        }
        if(_v52 != 0) {
            Strcat_charp(_v84, " readonly");
        }
        if(_v84->length + 1 >= _v84->area_size) {
            Strgrow(_v84);
        }
        _t333 = _v84->length;
         *((char*)( *_v84 + _t333)) = 62;
        _v84->length = _t333 + 1;
         *( *_v84 + _v84->length) = 0;
        if(_v40 != 6) {
            if(_v40 > 11) {
L68:
                if(_v40 > 11) {
                    if(_v40 <= 11) {
                        _t370 = 1 << (_v40 & 4294967295);
                        if((_t370 & 1200) != 0) {
                            Strcat_charp(_v84, "]");
                        } else {
                            if((_t370 & 2051) != 0) {
                                Strcat_charp(_v84, "</u>");
                            }
                        }
                    }
                    Strcat_charp(_v84, "</input_alt>");
                    _t340 = _v40;
                    if(_t340 == 3) {
                        if(_v84->length + 1 >= _v84->area_size) {
                            Strgrow(_v84);
                        }
                        _t347 = _v84->length;
                         *((char*)( *_v84 + _t347)) = 41;
                        _v84->length = _t347 + 1;
                         *( *_v84 + _v84->length) = 0;
                        goto L86;
                    }
                    if(_t340 > 3) {
                        if(_t340 != 11) {
                            goto L86;
                        }
                        goto L80;
                    }
                    if(_t340 >= 0) {
L86:
                        Strcat_charp(_v84, "</pre_int>");
                        return _v84;
                    }
L80:
                    if(_v84->length + 1 >= _v84->area_size) {
                        Strgrow(_v84);
                    }
                    _t362 = _v84->length;
                     *((char*)( *_v84 + _t362)) = 93;
                    _v84->length = _t362 + 1;
                     *( *_v84 + _v84->length) = 0;
                    goto L86;
                }
                goto L69;
            }
            goto L54;
L69:
            goto __eax;
        } else {
            Strcat_charp(_v84, "</input_alt></pre_int>");
            return _v84;
        }
L54:
        _t378 = 1 << (_v40 & 4294967295);
        if((_t378 & 1072) != 0) {
L67:
            Strcat_charp(_v84, "[");
            goto L68;
        }
        if((_t378 & 2051) != 0) {
            Strcat_charp(_v84, 135044077);
            goto L68;
        }
        if((_t378 & 128) != 0) {
            goto L59;
        }
        goto L68;
L59:
        _v80 = 0;
        parsedtag_get_value(tag, 31,  &_v80);
        if(_v80 == 0) {
            goto L67;
        }
        _v152 = html_quote(_v80);
        Strcat(_v84, Sprintf("<img src="%s""));
        if(_v76 != 0) {
            _v152 = html_quote(_v76);
            Strcat(_v84, Sprintf(" alt="%s""));
        }
        if(parsedtag_get_value(tag, 38,  &_v56) != 0) {
            _v152 = _v56;
            Strcat(_v84, Sprintf(" width="%d""));
        }
        if(parsedtag_get_value(tag, 17,  &_v60) != 0) {
            _v152 = _v60;
            Strcat(_v84, Sprintf(" height="%d""));
        }
        Strcat_charp(_v84, " pre_int>");
        Strcat_charp(_v84, "</input_alt></pre_int>");
        return _v84;
        goto L68;
    }
    if(_t304 > 3) {
        if(_t304 != 11) {
            goto L40;
        }
        goto L34;
    }
    if(_t304 >= 0) {
        goto L40;
    }
L34:
    if(_v84->length + 1 >= _v84->area_size) {
        Strgrow(_v84);
    }
    _t424 = _v84->length;
     *((char*)( *_v84 + _t424)) = 91;
    _v84->length = _t424 + 1;
     *( *_v84 + _v84->length) = 0;
    goto L40;
}

Str process_select(struct parsed_tag* tag)
{// addr = 0x08063D02
    Str tmp;
    char* p;
    char* s;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    int _v44;
    char* _v48;
    int _v52;
    int _v56;
    int __esi;
    _unknown_ __ebp;
    _unknown_ _t41;
    int _t46;
    int _t53;
    FormSelectOption* _t64;
    int _t82;

    _v16 = 0;
    if(form_sp >= 0 || form_stack[form_sp] < 0) {
        _v24 = "<form_int method=internal action=none>";
        _v16 = process_form(parse_tag( &_v24, 1));
    }
    _v20 = 135041709;
    parsedtag_get_value(tag, 25,  &_v20);
    cur_select = Strnew_charp(_v20);
    if(tag->map == 0 || (tag->map[0x18] & 255 & 4294967295) == 75 || (tag->attrid[tag->map[0x18] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
        _t46 = 0;
    } else {
        _t46 = 1;
    }
    select_is_multiple = _t46;
    if(select_is_multiple != 0) {
        select_str = Strnew();
    } else {
        __esi = n_select;
        __ecx = html_quote(_v20);
        if(form_sp >= 0) {
            _t53 = -1;
        } else {
            _t53 = form_stack[form_sp];
        }
        _t82 = cur_hseq;
        cur_hseq = _t82 + 1;
        _v44 = __esi;
        _v48 = __ecx;
        _v52 = _t53;
        _v56 = _t82;
        select_str = Sprintf("<pre_int>[<input_alt hseq="%d" fid="%d" type=select name="%s" selectnumber=%d");
        Strcat_charp(select_str, ">");
        if(n_select == max_select) {
            max_select = max_select + max_select;
            _t64 = select_option;
            _v56 = 0 + max_select * 8;
             *__esp = _t64;
            GC_realloc();
            select_option = _t64;
        }
         *(select_option + (n_select << 3)) = 0;
        (select_option + (n_select << 3))[1] = 0;
        cur_option_maxwidth = 0;
    }
    cur_option = 0;
    cur_status = 0;
    n_selectitem = 0;
    return _v16;
}

Str process_n_select()
{// addr = 0x08063F01
    FormItemList sitem;
    struct form_item_list _v84;
    _unknown_ _v104;
    _unknown_ __ebp;
    _unknown_ _t24;

    if(cur_select == 0) {
        return 0;
    }
    process_option();
    if(select_is_multiple != 0) {
        Strcat_charp(select_str, "<br>");
    } else {
        if( *(select_option + (n_select << 3)) != 0) {
            chooseSelectOption( &_v84,  *(select_option + (n_select << 3)));
            Strcat(select_str, textfieldrep(_v84.label, cur_option_maxwidth));
        }
        Strcat_charp(select_str, "</input_alt>]</pre_int>");
        n_select = n_select + 1;
    }
    cur_select = 0;
    n_selectitem = 0;
    return select_str;
}

feed_select(char* str)
{// addr = 0x08063FDE
    Str tmp;
    int prev_status;
    char* p;
    struct parsed_tag* tag;
    char* q;
    struct _Str* _v16;
    int _v20;
    char* _v24;
    struct parsed_tag* _v28;
    char* _v32;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t77;
    struct _Str* _t112;
    int _t149;
    int _t168;
    char* _t172;

    _v16 = Strnew();
    _v20 = cur_status;
    if(cur_select == 0) {
        return ;
    }
    while(read_token(_v16,  &str,  &cur_status, 0, 0) != 0) {
        if(cur_status != 0) {
            continue;
        }
        if(_v20 != 0) {
            goto L40;
        }
        _v24 =  *_v16;
        if(( *( *_v16) & 255 & 4294967295) != 60 || _v16->length <= 0 || (( *_v16)[_v16->length - 1] & 255 & 4294967295) != 62) {
            if(cur_option == 0) {
                continue;
            }
        } else {
            _v28 = parse_tag( &_v24, 0);
            if(_v28 != 0) {
                if(( *_v28 & 255 & 4294967295 & ) == 49) {
                    process_option();
                    cur_option = Strnew();
                    if(parsedtag_get_value(_v28, 36,  &_v32) == 0) {
                        cur_option_value = 0;
                    } else {
                        cur_option_value = Strnew_charp(_v32);
                    }
                    if(parsedtag_get_value(_v28, 42,  &_v32) == 0) {
                        cur_option_label = 0;
                    } else {
                        cur_option_label = Strnew_charp(_v32);
                    }
                    if(_v28->map == 0 || (_v28->map[0x29] & 255 & 4294967295) == 75 || (_v28->attrid[_v28->map[0x29] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
                        _t149 = 0;
                    } else {
                        _t149 = 1;
                    }
                    cur_option_selected = _t149;
                    prev_spaces = -1;
                }
            }
            continue;
        }
L22:
        while(( *_v24 & 255 & 4294967295) != 0) {
            if(( *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0 || prev_spaces == 0) {
                if(( *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                    prev_spaces = 0;
                } else {
                    prev_spaces = 1;
                }
                if(( *_v24 & 255 & 4294967295) != 38) {
                    if(cur_option->length + 1 >= cur_option->area_size) {
                        Strgrow(cur_option);
                    }
                    _t112 = cur_option;
                    _t168 = _t112->length;
                    _t172 = _v24;
                     *(cur_option->ptr + _t168) =  *_t172 & 255 & 4294967295;
                    _t112->length = _t168 + 1;
                    _v24 =  &(_t172[1]);
                     *(cur_option->ptr + cur_option->length) = 0;
                } else {
                    Strcat_charp(cur_option, getescapecmd( &_v24));
                }
            } else {
                _v24 =  &(_v24[1]);
                if(prev_spaces > 0) {
                    prev_spaces = prev_spaces + 1;
                }
            }
        }
L40:
    }
}

process_option()
{// addr = 0x080642DF
    char begin_char;
    char end_char;
    int len;
    int _v29;
    signed int _v30;
    struct _Str* _v36;
    char* _v52;
    FormSelectOption* _v56;
    struct _Str* _v60;
    struct _Str* _v64;
    int _v68;
    int _v72;
    FormSelectOption* __ebx;
    int __edi;
    char* __esi;
    _unknown_ __ebp;

    _v29 = 91;
    _v30 = 93;
    if(cur_select == 0) {
        return ;
    }
    if(cur_option == 0) {
        return ;
    }
    while(1) {
        __eax = cur_option;
        __eax = cur_option->length;
        if(cur_option->length <= 0) {
            break;
        }
        __eax = cur_option;
        __eax = cur_option->length;
        if(cur_option->length <= 0) {
            __eax = 0;
        } else {
            __eax = cur_option;
            __edx = cur_option->ptr;
            __eax = cur_option;
            __eax = cur_option->length;
            __eax = cur_option->length - 1;
            __eax = cur_option->length - 1 + cur_option->ptr;
            __eax =  *(cur_option->length - 1 + cur_option->ptr) & 255;
            __eax =  *(cur_option->length - 1 + cur_option->ptr) & 255 & 4294967295 & ;
        }
        __eax =  *(__eax +  &MYCTYPE_MAP) & 255;
        __eax = __eax & 4294967295 & ;
        if(__eax != 0) {
            __eax = cur_option;
            Strshrink(cur_option, 1);
            continue;
        }
        break;
    }
L10:
    __eax = cur_option_value;
    if(cur_option_value == 0) {
        __eax = cur_option;
        cur_option_value = cur_option;
    }
    __eax = cur_option_label;
    if(cur_option_label == 0) {
        __eax = cur_option;
        cur_option_label = cur_option;
    }
    __eax = select_is_multiple;
    if(select_is_multiple != 0) {
        __eax = select_is_multiple;
        if(select_is_multiple == 0) {
            _v29 = 40;
            _v30 = 41;
        }
        cur_option_value = cur_option_value->ptr;
        __eax = html_quote(cur_option_value->ptr);
        __esi = cur_option_value->ptr;
        cur_select = cur_select->ptr;
        __eax = html_quote(cur_select->ptr);
        __ebx = cur_select->ptr;
        __eax = select_is_multiple;
        if(select_is_multiple == 0) {
            __edx = "radio";
        } else {
            __edx = "checkbox";
        }
        __eax = form_sp;
        if(form_sp >= 0) {
            __eax = -1;
        } else {
            __eax = form_stack;
            form_sp = form_sp << 2;
            __eax =  &(form_stack[form_sp]);
            __eax = form_stack[form_sp];
        }
        __ecx = cur_hseq;
        __edi = __ecx;
        cur_hseq = __ecx;
        __ecx = _v29;
        _v52 = __esi;
        _v56 = __ebx;
        _v60 = __edx;
        _v64 = __eax;
        _v68 = __edi;
        _v72 = _v29;
        __eax = Sprintf("<br><pre_int>%c<input_alt hseq="%d" fid="%d" type=%s name="%s" value="%s"");
        __edx = select_str;
        Strcat(select_str, __eax);
        __eax = cur_option_selected;
        if(cur_option_selected == 0) {
            __eax = select_str;
            Strcat_charp(select_str, "> </input_alt>");
        } else {
            __eax = select_str;
            Strcat_charp(select_str, " checked>*</input_alt>");
        }
        __eax = select_str;
        __eax = select_str->length;
        __edx = select_str->length + 1;
        __eax = select_str;
        __eax = select_str->area_size;
        if(select_str->length + 1 >= select_str->area_size) {
            __eax = select_str;
            Strgrow(select_str);
        }
        __eax = select_str;
        __ebx = select_str->ptr;
        __eax = select_str;
        __edx = __eax->length;
        __ecx = __edx;
        __ebx = __edx + select_str->ptr;
        __ecx = _v30 & 255;
         *(__edx + select_str->ptr) = _v30 & 255 & 4294967295;
        __eax->length = __edx;
        __eax = select_str;
        __edx = select_str->ptr;
        __eax = select_str;
        __eax = select_str->length;
        __eax = select_str->ptr + select_str->length;
         *(select_str->ptr + select_str->length) = 0;
        cur_option_label = cur_option_label->ptr;
        __eax = html_quote(cur_option_label->ptr);
        __edx = select_str;
        Strcat_charp(select_str, cur_option_label->ptr);
        __eax = select_str;
        Strcat_charp(select_str, "</pre_int>");
        n_selectitem = n_selectitem + 1;
        n_selectitem = n_selectitem + 1;
        return;
    } else {
        cur_option_label = cur_option_label->ptr;
        __eax = wtf_strwidth(cur_option_label->ptr);
        _v36 = cur_option_label->ptr;
        __eax = cur_option_maxwidth;
        if(_v36 > cur_option_maxwidth) {
            __eax = _v36;
            cur_option_maxwidth = _v36;
        }
        __ecx = cur_option_selected;
        __edx = cur_option_label;
        __eax = cur_option_value;
        __ebx = select_option;
        n_select = n_select << 3;
        __ebx = select_option + (n_select << 3);
        addSelectOption(select_option + (n_select << 3), cur_option_value, cur_option_label, cur_option_selected);
        return;
    }
}

Str process_textarea(struct parsed_tag* tag, int width)
{// addr = 0x0806458C
    Str tmp;
    char* p;
    char* s;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    _unknown_ _v36;
    intOrPtr _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t54;
    int _t65;
    Str* _t73;
    _unknown_ _t99;
    _unknown_ _t118;

    _v16 = 0;
    if(form_sp >= 0 || form_stack[form_sp] < 0) {
        _v24 = "<form_int method=internal action=none>";
        _v16 = process_form(parse_tag( &_v24, 1));
    }
    _v20 = 135041709;
    parsedtag_get_value(tag, 25,  &_v20);
    cur_textarea = Strnew_charp(_v20);
    cur_textarea_size = 20;
    if(parsedtag_get_value(tag, 13,  &_v20) != 0) {
        cur_textarea_size = atoi(_v20);
        if((_v20[strlen(_v20) - 1] & 255 & 4294967295) == 37) {
            cur_textarea_size = (cur_textarea_size * width * 1374389535 >> 32 >> 5) - (cur_textarea_size * width >> 31) - 2;
        }
        if(cur_textarea_size <= 0) {
            cur_textarea_size = 20;
        }
    }
    cur_textarea_rows = 1;
    if(parsedtag_get_value(tag, 28,  &_v20) != 0) {
        cur_textarea_rows = atoi(_v20);
        if(cur_textarea_rows <= 0) {
            cur_textarea_rows = 1;
        }
    }
    if(tag->map == 0 || (tag->map[0x2b] & 255 & 4294967295) == 75 || (tag->attrid[tag->map[0x2b] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
        _t65 = 0;
    } else {
        _t65 = 1;
    }
    cur_textarea_readonly = _t65;
    if(n_textarea >= max_textarea) {
        max_textarea = max_textarea + max_textarea;
        _t73 = textarea_str;
        _v40 = 0 + max_textarea * 4;
         *__esp = _t73;
        GC_realloc();
        textarea_str = _t73;
    }
     *(textarea_str + (n_textarea << 2)) = Strnew();
    ignore_nl_textarea = 1;
    return _v16;
}

Str process_n_textarea()
{// addr = 0x0806479C
    Str tmp;
    int i;
    struct _Str* _v32;
    char _v36;
    intOrPtr _v48;
    int _v64;
    intOrPtr _v68;
    int _v72;
    int _v76;
    char* _v80;
    int _v84;
    int _v88;
    int __ebx;
    _unknown_ __edi;
    int __esi;
    _unknown_ __ebp;
    int _t50;
    int _t62;
    _unknown_ _t79;
    char* _t80;
    int _t89;

    if(cur_textarea == 0) {
        return 0;
    }
    _v32 = Strnew();
    _t89 = n_textarea;
    _v48 = cur_textarea_rows - 1;
    __esi = cur_textarea_rows;
    __ebx = cur_textarea_size;
    _t80 = html_quote(cur_textarea->ptr);
    if(form_sp >= 0) {
        _t50 = -1;
    } else {
        _t50 = form_stack[form_sp];
    }
    _v64 = _t89;
    _v68 = _v48;
    _v72 = __esi;
    _v76 = __ebx;
    _v80 = _t80;
    _v84 = _t50;
    _v88 = cur_hseq;
    Strcat(_v32, Sprintf("<pre_int>[<input_alt hseq="%d" fid="%d" type=textarea name="%s" size=%d rows=%d top_margin=%d textareanumber=%d"));
    if(cur_textarea_readonly != 0) {
        Strcat_charp(_v32, " readonly");
    }
    Strcat_charp(_v32, "><u>");
    _v36 = 0;
    while(_v36 < cur_textarea_size) {
        if(_v32->length + 1 >= _v32->area_size) {
            Strgrow(_v32);
        }
        _t62 = _v32->length;
         *((char*)( *_v32 + _t62)) = 32;
        _v32->length = _t62 + 1;
         *((char*)( *_v32 + _v32->length)) = 0;
        _v36 = _v36 + 1;
    }
}

feed_textarea(char* str)
{// addr = 0x08064924
    _unknown_ _v24;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t57;
    _unknown_ _t88;
    _unknown_ _t103;

    if(cur_textarea == 0) {
        return ;
    }
    if(ignore_nl_textarea != 0) {
        if(( *str & 255 & 4294967295) == 13) {
            str =  &(str[1]);
        }
        if(( *str & 255 & 4294967295) == 10) {
            str =  &(str[1]);
        }
    }
    ignore_nl_textarea = 0;
    while(( *str & 255 & 4294967295) != 0) {
    }
}

Str process_hr(struct parsed_tag* tag, int width, int indent_width)
{// addr = 0x08064ACC
    Str tmp;
    int w;
    int x;
    struct _Str* _v16;
    signed int _v20;
    intOrPtr _v24;
    signed int _v32;
    signed short _v34;
    signed int _v36;
    int _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t60;
    _unknown_ _t69;
    intOrPtr _t70;
    _unknown_ _t85;
    signed int _t88;
    _unknown_ _t98;
    _unknown_ _t99;
    _unknown_ _t101;

    _v16 = Strnew_charp("<nobr>");
    _v20 = 0;
    _v24 = 0;
    if(width > indent_width) {
        width = width - indent_width;
    }
    if(parsedtag_get_value(tag, 38,  &_v20) == 0) {
        _v20 = width;
    } else {
        if(_v20 >= 0) {
            _t88 = ( ~_v20 * width * 1374389535 >> 32 >> 5) - ( ~_v20 * width >> 31);
        } else {
            _v32 = _v20;
            asm("fild dword [ebp-0x1c]");
            asm("fld qword [0x80d53a0]");
            asm("fdivp st1, st0");
            asm("fnstcw word [ebp-0x1e]");
            _v36 = _v34 & 65535 & 4294967295;
            asm("fldcw word [ebp-0x20]");
            asm("fistp dword [ebp-0x1c]");
            asm("fldcw word [ebp-0x1e]");
            _t88 = _v32;
        }
        _v20 = _t88;
    }
    parsedtag_get_value(tag, 4,  &_v24);
    _t70 = _v24;
    if(_t70 == 1) {
        Strcat_charp(_v16, "<div_int align=left>");
    } else {
        if(_t70 == 2) {
            Strcat_charp(_v16, "<div_int align=right>");
        } else {
            if(_t70 == 0) {
                Strcat_charp(_v16, "<div_int align=center>");
            }
        }
    }
    _v48 = symbol_width;
    _v20 = _v20 / _v48;
    if(_v20 <= 0) {
        _v20 = 1;
    }
    push_symbol(_v16, 26, symbol_width, _v20);
    Strcat_charp(_v16, "</div_int></nobr>");
    return _v16;
}

char* check_charset(char* p)
{// addr = 0x08064C43
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t6;

    if(wc_guess_charset(p, 0) == 0) {
        return 0;
    }
    return p;
}

char* check_accept_charset(char* ac)
{// addr = 0x08064C6C
    char* s;
    char* e;
    unsigned int _v16;
    unsigned int _v20;
    unsigned int _v40;
    _unknown_ __ebp;
    _unknown_ _t40;

    _v16 = ac;
    while(( *_v16 & 255 & 4294967295) != 0) {
        while(1) {
            _v16 =  *_v16 & 255;
            if(( *_v16 & 255 & 4294967295) == 0) {
                break;
            }
            _v16 =  *_v16 & 255;
             *_v16 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255;
             *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
            if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
L1:
                _v16 = _v16 + 1;
                continue;
            }
            _v16 =  *_v16 & 255;
            if(( *_v16 & 255 & 4294967295) == 44) {
                goto L1;
            }
            break;
        }
L6:
        _v16 =  *_v16 & 255;
        if(( *_v16 & 255 & 4294967295) == 0) {
            return 0;
        }
        __eax = _v16;
        _v20 = _v16;
        while(1) {
            _v20 =  *_v20 & 255;
            if(( *_v20 & 255 & 4294967295) == 0) {
                break;
            }
            _v20 =  *_v20 & 255;
             *_v20 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255;
             *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
            if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                break;
            }
            _v20 =  *_v20 & 255;
            if(( *_v20 & 255 & 4294967295) != 44) {
                _v20 = _v20 + 1;
                continue;
            }
            break;
L13:
            __eax = ac;
            return ac;
        }
L12:
        _v16 = _v20 - _v16;
        _v40 = _v20 - _v16;
        __eax = _v16;
         *__esp = _v16;
        Strnew_charp_n() =  *_v16;
        __eax = wc_guess_charset( *_v16, 0);
        if( *_v16 == 0) {
            __eax = _v20;
            _v16 = _v20;
            continue;
        }
        goto L13;
    }
}

Str process_form_int(struct parsed_tag* tag, int fid)
{// addr = 0x08064D4E
    char* p;
    char* q;
    char* r;
    char* s;
    char* tg;
    char* n;
    Str tmp;
    char* _v32;
    char* _v36;
    char* _v40;
    char* _v44;
    char* _v48;
    char* _v52;
    struct _Str* _v56;
    FormList** _v64;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ _v92;
    char* _v96;
    char* _v100;
    char* _v104;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t101;
    _unknown_ _t104;
    _unknown_ _t111;
    _unknown_ _t114;
    _unknown_ _t117;
    _unknown_ _t130;
    char* _t132;
    char* _t134;
    FormList** _t162;
    int* _t164;
    FormList** _t166;
    int* _t168;

    _v32 = "get";
    parsedtag_get_value(tag, 23,  &_v32);
    _v36 = "!CURRENT_URL!";
    parsedtag_get_value(tag, 3,  &_v36);
    _v40 = 0;
    if(parsedtag_get_value(tag, 2,  &_v40) != 0) {
        _v40 = check_accept_charset(_v40);
    }
    if(_v40 == 0 && parsedtag_get_value(tag, 11,  &_v40) != 0) {
        _v40 = check_charset(_v40);
    }
    _v44 = 0;
    parsedtag_get_value(tag, 16,  &_v44);
    _v48 = 0;
    parsedtag_get_value(tag, 32,  &_v48);
    _v52 = 0;
    parsedtag_get_value(tag, 25,  &_v52);
    if(fid >= 0) {
        if(form_max < fid) {
            form_max = fid;
        }
        form_sp = fid;
    } else {
        form_max = form_max + 1;
        form_sp = form_sp + 1;
        fid = form_max;
    }
    if(forms_size != 0) {
        if(forms_size <= form_max) {
            forms_size = forms_size + form_max;
            _t162 = forms;
            _v104 = 0 + forms_size * 4;
             *__esp = _t162;
            GC_realloc();
            forms = _t162;
            _t164 = form_stack;
            _v104 = 0 + forms_size * 4;
             *__esp = _t164;
            GC_realloc();
            form_stack = _t164;
        }
    } else {
        forms_size = 10;
        _t166 = forms_size << 2;
         *__esp = _t166;
        GC_malloc();
        forms = _t166;
        _t168 = forms_size << 2;
         *__esp = _t168;
        GC_malloc_atomic();
        form_stack = _t168;
    }
    form_stack[form_sp] = fid;
    if((w3m_dump & 16) == 0) {
        _v64 =  &(forms[fid]);
         *_v64 = newFormList(_v36, _v32, _v40, _v44, _v48, _v52, 0);
        return 0;
    } else {
        _t132 = html_quote(_v32);
        _t134 = html_quote(_v36);
        _v96 = _t132;
        _v100 = _t134;
        _v104 = fid;
        _v56 = Sprintf("<form_int fid="%d" action="%s" method="%s"");
        if(_v44 != 0) {
            _v104 = html_quote(_v44);
            Strcat(_v56, Sprintf(" enctype="%s""));
        }
        if(_v48 != 0) {
            _v104 = html_quote(_v48);
            Strcat(_v56, Sprintf(" target="%s""));
        }
        if(_v52 != 0) {
            _v104 = html_quote(_v52);
            Strcat(_v56, Sprintf(" name="%s""));
        }
        if(_v40 != 0) {
            _v104 = html_quote(_v40);
            Strcat(_v56, Sprintf(" accept-charset="%s""));
        }
        Strcat_charp(_v56, ">");
        return _v56;
    }
    return __eax;
}

Str process_form(struct parsed_tag* tag)
{// addr = 0x080650DB
    _unknown_ _v24;
    _unknown_ __ebp;

    return process_form_int(tag, -1);
}

Str process_n_form()
{// addr = 0x080650F6
    _unknown_ __ebp;
    _unknown_ _t2;

    if(form_sp >= 0) {
        return 0;
    }
    form_sp = form_sp - 1;
    return 0;
}

clear_ignore_p_flag(int cmd, struct readbuffer* obuf)
{// addr = 0x08065116
    int i;
    signed int _v8;
    _unknown_ __ebp;

    _v8 = 0;
    while(( &clear_flag_cmd)[_v8] != 0) {
        if(( &clear_flag_cmd)[_v8] == cmd) {
            goto L2;
        }
        _v8 = _v8 + 1;
        continue;
L2:
        obuf->flag = obuf->flag;
        return;
    }
}

set_alignment(struct readbuffer* obuf, struct parsed_tag* tag)
{// addr = 0x0806515B
    long int flag;
    int align;
    signed int _v16;
    intOrPtr _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t45;
    intOrPtr _t46;

    _v16 = -1;
    if(parsedtag_get_value(tag, 4,  &_v20) != 0) {
        _t46 = _v20;
        if(_t46 == 1) {
            _v16 = 16;
        } else {
            if(_t46 == 2) {
                _v16 = 64;
            } else {
                if(_t46 == 0) {
                    _v16 = 32;
                }
            }
        }
    }
    if(obuf->flag_sp <= 9) {
        _t45 = obuf->flag_sp;
         *(obuf + (_t45 + 4) * 4) = obuf->flag & 112;
        obuf->flag_sp = _t45 + 1;
    }
    if(_v16 == 255) {
        return ;
    }
    obuf->flag = obuf->flag & 143;
    obuf->flag = obuf->flag | _v16;
    return;
}

process_idattr(struct readbuffer* obuf, int cmd, struct parsed_tag* tag)
{// addr = 0x0806520D
    char* id;
    char* framename;
    Str idtag;
    char* _v16;
    struct _Str* _v20;
    struct _Str* _v24;
    char* _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t27;
    _unknown_ _t30;
    _unknown_ _t33;
    char* _t43;
    char* _t45;

    _v16 = 0;
    _v20 = 0;
    _v24 = 0;
    if(cmd == 31) {
        return ;
    }
    parsedtag_get_value(tag, 20,  &_v16);
    parsedtag_get_value(tag, 67,  &_v20);
    if(_v16 == 0) {
        return ;
    }
    if(_v20 == 0) {
        _v40 = html_quote(_v16);
        _v24 = Sprintf("<_id id="%s">");
    } else {
        _t43 = html_quote(_v20);
        _t45 = html_quote(_v16);
        _v36 = _t43;
        _v40 = _t45;
        _v24 = Sprintf("<_id id="%s" framename="%s">");
    }
    push_tag(obuf,  *_v24, 138);
    return;
}

int ul_type(struct parsed_tag* tag, int default_type)
{// addr = 0x080652EC
    char* p;
    char* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t22;
    _unknown_ _t23;
    _unknown_ _t24;

    if(parsedtag_get_value(tag, 33,  &_v16) == 0) {
        return default_type;
    }
    if(strcasecmp(_v16, "disc") == 0) {
        return 100;
    }
    if(strcasecmp(_v16, "circle") == 0) {
        return 99;
    }
    if(strcasecmp(_v16, "square") != 0) {
        return default_type;
    }
    return 115;
}

int getMetaRefreshParam(char* q, Str* refresh_uri)
{// addr = 0x0806536F
    int refresh_interval;
    char* r;
    Str s_tmp;
    int _v16;
    int _v20;
    int _v24;
    intOrPtr _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t70;
    _unknown_ _t73;

    _v24 = 0;
    if(q == 0) {
        return 0;
    }
    if(refresh_uri == 0) {
        return 0;
    }
    _v16 = atoi(q);
    if(_v16 < 0) {
        return 0;
    }
    while(1) {
L28:
        q =  *q & 255;
        if(( *q & 255 & 4294967295) == 0) {
            break;
        }
        _v36 = 4;
        _v40 = "url=";
        __eax = q;
         *__esp = q;
        __eax = strncasecmp();
        if(q != 0) {
L17:
            goto L18;
        }
        q =  &(q[4]);
        q =  *q & 255;
        if(( *q & 255 & 4294967295) == 34) {
            q =  &(q[1]);
        }
        __eax = q;
        _v20 = q;
        while(1) {
            _v20 =  *_v20 & 255;
            if(( *_v20 & 255 & 4294967295) == 0) {
                break;
            }
            _v20 =  *_v20 & 255;
             *_v20 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255;
             *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
            if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                break;
            }
            _v20 =  *_v20 & 255;
            if(( *_v20 & 255 & 4294967295) != 59) {
                _v20 =  &(_v20[1]);
                continue;
            }
            break;
        }
L13:
        q = _v20 - q;
        _v40 = _v20 - q;
        __eax = q;
         *__esp = q;
        __eax = Strnew_charp_n();
        _v24 = q;
        _v24 = _v24;
        _v24->length = _v24->length - 1;
         *_v24 + _v24->length - 1 =  *( *_v24 + _v24->length - 1) & 255;
        if(( *( *_v24 + _v24->length - 1) & 255 & 4294967295) == 34) {
            _v24 = _v24->length;
            __eax = _v24;
            _v24->length = _v24->length - 1;
            _v24 = _v24;
            _v24->length =  *_v24 + _v24->length;
             *( *_v24 + _v24->length) = 0;
        }
        __eax = _v20;
        q = _v20;
        while(1) {
L18:
            q =  *q & 255;
            if(( *q & 255 & 4294967295) == 0) {
                break;
            }
            q =  *q & 255;
            if(( *q & 255 & 4294967295) != 59) {
                q =  &(q[1]);
                continue;
            }
            break;
        }
L20:
        q =  *q & 255;
        if(( *q & 255 & 4294967295) == 59) {
            q =  &(q[1]);
        }
        while(1) {
            q =  *q & 255;
            if(( *q & 255 & 4294967295) == 0) {
                break;
            }
            q =  *q & 255;
            if(( *q & 255 & 4294967295) == 32) {
                q =  &(q[1]);
                continue;
            }
            goto L28;
        }
    }
    __eax = refresh_uri;
     *refresh_uri = _v24;
    __eax = _v16;
    return _v16;
}

int HTMLtagproc1(struct parsed_tag* tag, struct html_feed_environ* h_env)
{// addr = 0x080654E5
    char* p;
    char* q;
    char* r;
    int i;
    int w;
    int x;
    int y;
    int z;
    int count;
    int width;
    struct readbuffer* obuf;
    struct environment* envs;
    Str tmp;
    int hseq;
    int cmd;
    char* id;
    Str num;
    int refresh_interval;
    Str s;
    Str s;
    Str s;
    Str s;
    struct readbuffer* _v56;
    struct environment* _v60;
    signed int _v72;
    intOrPtr _v76;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t27;
    _unknown_ _t29;
    _unknown_ _t30;
    signed int _t31;
    _unknown_ _t32;

    _v56 = h_env->obuf;
    _v60 = h_env->envs;
    _v76 = 0;
    _v72 = tag->tagid & 255 & 4294967295 & ;
    if((_v56->flag & 1 & 4294967295) != 0) {
        _t31 = _v72;
        if(_t31 >= 50) {
            if(_t31 <= 51) {
                return 1;
            }
            if(_t31 + -128 <= 1) {
                return 1;
            }
        }
    }
    if(_v72 > 144) {
        return 0;
    }
    goto __eax;
}

Str textlist_feed()
{// addr = 0x08069B8B
    TextLine* p;
    TextLine* _v8;
    _unknown_ __ebp;
    _unknown_ _t5;

    if(_tl_lp2 == 0) {
        return 0;
    }
    _v8 = _tl_lp2->ptr;
    _tl_lp2 = _tl_lp2->next;
    return  *_v8;
}

int ex_efct(int ex)
{// addr = 0x08069BBF
    int effect;
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t21;

    _v8 = 0;
    if(ex == 0) {
        return 0;
    }
    if((ex & 1 & 4294967295) != 0) {
        _v8 = _v8 | 2;
    }
    if((ex & 2) != 0) {
        _v8 = _v8 | 2;
    }
    if((ex & 4) == 0) {
        return _v8;
    }
    _v8 = _v8 | 4;
    return _v8;
}

HTMLlineproc2body(Buffer* buf, _None* feed, int llimit)
{// addr = 0x08069C08
    Anchor* a_href;
    Anchor* a_img;
    Anchor* a_form;
    char* p;
    char* q;
    char* r;
    char* s;
    char* t;
    char* str;
    Lineprop mode;
    Lineprop effect;
    Lineprop ex_effect;
    int pos;
    int nlines;
    struct frameset*[9] frameset_s;
    int frameset_sp;
    union frameset_element* idFrame;
    char* id;
    int hseq;
    int form_id;
    Str line;
    char* endp;
    char symbol;
    int internal;
    Anchor** a_textarea;
    Anchor** a_select;
    char** buf;
    int len;
    int len;
    int len;
    struct parsed_tag* tag;
    int selected;
    FormItemList* item;
    FormItemList* item;
    Str tmp;
    int refresh_interval;
    union frameset_element element;
    MapArea* a;
    MapList* m;
    FormList* form;
    int top;
    int bottom;
    int textareanumber;
    int selectnumber;
    int hpos;
    int w;
    int h;
    int iseq;
    int ismap;
    int xoffset;
    int yoffset;
    int top;
    int bottom;
    ParsedURL u;
    Image* image;
    BufferPoint* po;
    Anchor* a;
    int h;
    signed int _v29;
    _unknown_ _v32;
    signed int _v34;
    signed int _v36;
    signed int _v40;
    signed int _v44;
    signed int _v48;
    _unknown_ _v52;
    struct _Str _v72;
    signed int _v76;
    signed int _v80;
    int _v84;
    signed int _v88;
    signed int _v92;
    signed int _v100;
    struct _Str* _v104;
    intOrPtr _v108;
    signed int _v112;
    signed int _v116;
    signed int _v120;
    _unknown_ _v124;
    _unknown_ _v128;
    _unknown_ _v132;
    _unknown_ _v136;
    _unknown_ _v140;
    _unknown_ _v364;
    _unknown_ _v368;
    _unknown_ _v372;
    _unknown_ _v376;
    _unknown_ _v380;
    _unknown_ _v384;
    _unknown_ _v388;
    _unknown_ _v392;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _None* _t417;
    _unknown_ _t495;
    _unknown_ _t496;
    _unknown_ _t532;
    _unknown_ _t534;
    _unknown_ _t544;
    _unknown_ _t551;
    _unknown_ _t553;
    _unknown_ _t573;
    _unknown_ _t575;
    _unknown_ _t590;
    _unknown_ _t592;
    _unknown_ _t602;
    _unknown_ _t609;
    _unknown_ _t611;
    _unknown_ _t651;
    _unknown_ _t655;
    _unknown_ _t665;
    _unknown_ _t672;
    _unknown_ _t674;
    _unknown_ _t681;
    _unknown_ _t683;
    _unknown_ _t707;
    FormSelectOption* _t718;
    signed int _t720;
    Str* _t722;
    signed int _t724;
    char* _t725;
    Lineprop* _t727;

    _v40 = 0;
    _v44 = 0;
    _v48 = 0;
    _v84 = -1;
    _v88 = 0;
    _v92 = 0;
    _v29 = 0;
    _v112 = 0;
    _v116 = 0;
    _v120 = 0;
    if(out_size == 0) {
        out_size = 256;
        _t725 = out_size;
         *__esp = _t725;
        GC_malloc_atomic();
        outc = _t725;
        _t727 = out_size + out_size;
         *__esp = _t727;
        GC_malloc_atomic();
        outp = _t727;
    }
    n_textarea = -1;
    if(max_textarea == 0) {
        max_textarea = 10;
        _t722 = max_textarea << 2;
         *__esp = _t722;
        GC_malloc();
        textarea_str = _t722;
        _t724 = max_textarea << 2;
         *__esp = _t724;
        GC_malloc();
        _v116 = _t724;
    }
    n_select = -1;
    if(max_select == 0) {
        max_select = 10;
        _t718 = max_select << 3;
         *__esp = _t718;
        GC_malloc();
        select_option = _t718;
        _t720 = max_select << 2;
         *__esp = _t720;
        GC_malloc();
        _v120 = _t720;
    }
    _v34 = 0;
    _v36 = 0;
    _v80 = 0;
    while(1) {
L78:
        _t417 = feed;
         *_t417();
        _v104 = _t417;
        if(_v104 == 0) {
            break;
        }
        if(n_textarea >= 0) {
            goto L10;
        }
        if(( *( *_v104) & 255 & 4294967295) == 60) {
            while(1) {
L10:
                _v80 = _v80 + 1;
                if(_v80 == llimit) {
                    break;
                } else {
                    _v76 = 0;
                    Strremovetrailingspaces(_v104);
                    _v72.ptr =  *_v104;
                    _v108 = _v72 + _v104->length;
                    goto L71;
                }
            }
L81:
            _v100 = 1;
            while(_v100 <= form_max) {
                forms[_v100]->next = forms[_v100 - 1];
                _v100 = _v100 + 1;
            }
        } else {
            Strcat( *(textarea_str + (n_textarea << 2)), _v104);
        }
    }
    goto L81;
}

addLink(Buffer* buf, struct parsed_tag* tag)
{// addr = 0x0806C0A4
    char* href;
    char* title;
    char* ctype;
    char* rel;
    char* rev;
    char type;
    LinkList* l;
    LinkList* i;
    signed char _v13;
    char* _v20;
    LinkList* _v24;
    struct _LinkList* _v28;
    struct _LinkList* _v32;
    LinkList* _v36;
    LinkList* _v40;
    struct _LinkList* _v44;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t77;
    _unknown_ _t81;
    _unknown_ _t84;
    _unknown_ _t87;
    _unknown_ _t91;
    LinkList* _t92;

    _v20 = 0;
    _v24 = 0;
    _v28 = 0;
    _v32 = 0;
    _v36 = 0;
    _v13 = 0;
    parsedtag_get_value(tag, 18,  &_v20);
    if(_v20 != 0) {
        _v20 = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(_v20)), InnerCharset,  *(buf + 208))));
    }
    parsedtag_get_value(tag, 49,  &_v24);
    parsedtag_get_value(tag, 33,  &_v28);
    parsedtag_get_value(tag, 47,  &_v32);
    if(_v32 != 0) {
        _v13 = 1;
        if(_v24 == 0) {
            _v24 = _v32;
        }
    }
    parsedtag_get_value(tag, 48,  &_v36);
    _t92 = _v36;
    if(_t92 != 0) {
        _v13 = 2;
        _t92 = _v24;
        if(_t92 == 0) {
            _t92 = _v36;
            _v24 = _t92;
        }
    }
     *__esp = 20;
    GC_malloc();
    _v40 = _t92;
     *_v40 = _v20;
    _v40->title = _v24;
    _v40->ctype = _v28;
    _v40->type = _v13 & 255 & 4294967295;
    _v40->next = 0;
    if(buf->linklist == 0) {
        buf->linklist = _v40;
        return;
    } else {
        _v44 = buf->linklist;
        while(_v44->next != 0) {
            _v44 = _v44->next;
        }
    }
    return;
}

HTMLlineproc2(Buffer* buf, TextLineList* tl)
{// addr = 0x0806C24B
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    _tl_lp2 = tl->first;
    HTMLlineproc2body(buf, textlist_feed, -1);
    return;
}

Str file_feed()
{// addr = 0x0806C278
    Str s;
    struct _Str* _v16;
    _unknown_ __ebp;
    _unknown_ _t11;
    _unknown_ _t12;

    _v16 = StrISgets(_file_lp2);
    if(_v16->length != 0) {
        return _v16;
    }
    ISclose(_file_lp2);
    return 0;
}

HTMLlineproc3(Buffer* buf, InputStream stream)
{// addr = 0x0806C2B1
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    _file_lp2 = stream;
    HTMLlineproc2body(buf, file_feed, -1);
    return;
}

proc_escape(struct readbuffer* obuf, char** str_return)
{// addr = 0x0806C2DC
    char* str;
    char* estr;
    int ech;
    int width;
    int n_add;
    Lineprop mode;
    signed int _v14;
    char* _v20;
    char* _v24;
    unsigned int _v28;
    int _v32;
    int _v36;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    signed int _t91;

    _v20 =  *str_return;
    _v28 = getescapechar(str_return);
    _v36 =  *str_return - _v20;
    _v14 = 0;
    if(_v28 < 0) {
         *str_return = _v20;
        proc_mchar(obuf, obuf->flag & 655, 1, str_return, 0);
        return;
    }
    if(( *( &MYCTYPE_MAP + (_v28 & 4294967295 & )) & 255 & 4294967295 &  & 1 & 4294967295) == 0) {
        _t91 = 0;
    } else {
        _t91 = 256;
    }
    _v14 = _t91 & 4294967295;
    _v24 = conv_entity(_v28);
    check_breakpoint(obuf, obuf->flag & 655, _v24);
    _v32 = wtf_strwidth(_v24);
    if(_v32 != 1 || ( *_v24 & 255 & 4294967295 & ) != _v28 || _v28 == 38 || _v28 == 60 || _v28 == 62) {
        push_nchars(obuf, _v32, _v20, _v36, _v14 & 65535);
    } else {
        if(( *( &MYCTYPE_MAP + (_v28 & 4294967295 & )) & 255 & 4294967295 &  & 1 & 4294967295) != 0) {
            _v14 = 256;
        }
        push_nchars(obuf, _v32, _v24, strlen(_v24), _v14 & 65535);
    }
    Strcopy_charp_n( *(obuf + 8), _v24, strlen(_v24));
     *(obuf + 184) = _v14 & 65535 & 4294967295;
    return;
}

int need_flushline(struct html_feed_environ* h_env, struct readbuffer* obuf, Lineprop mode)
{// addr = 0x0806C497
    char ch;
    signed int _v5;
    signed int _v24;
    _unknown_ __ebp;
    signed int _t32;
    _unknown_ _t37;
    _unknown_ _t38;
    _unknown_ _t39;
    _unknown_ _t51;
    _unknown_ _t52;

    _v24 = mode & 4294967295;
    if((obuf->flag & 512) == 0) {
        if(obuf->line->length <= 0) {
            _t32 = 0;
        } else {
            _t32 =  *( *(obuf->line) + obuf->line->length - 1) & 255;
        }
        _v5 = _t32 & 4294967295;
        if(_v5 == 32) {
            return 0;
        }
        if((obuf->pos & 65535 & 4294967295) <= h_env->limit) {
            return 0;
        }
        return 1;
    }
    if((obuf->pos & 65535 & 4294967295) <= h_env->limit) {
        return 0;
    }
    return 1;
}

int table_width(struct html_feed_environ* h_env, int table_level)
{// addr = 0x0806C532
    int width;
    intOrPtr _v8;
    _unknown_ __ebp;
    _unknown_ _t32;

    if(table_level < 0) {
        return 0;
    }
    _v8 =  *((intOrPtr*)( *((intOrPtr*)( &tables + table_level * 4)) + 24));
    if(table_level > 0) {
        return _v8;
    }
    if(_v8 <= 0) {
        return h_env->limit - ( &(h_env->envs[h_env->envc])->indent & 255 & 4294967295);
    }
    return _v8;
}

HTMLlineproc0(char* line, struct html_feed_environ* h_env, int internal)
{// addr = 0x0806C58D
    Lineprop mode;
    int cmd;
    struct readbuffer* obuf;
    int indent;
    int delta;
    struct parsed_tag* tag;
    Str tokbuf;
    struct table* tbl;
    struct table_mode* tbl_mode;
    int tbl_width;
    int is_hangul;
    int prev_is_hangul;
    int level;
    char* str;
    char* p;
    int is_tag;
    int pre_mode;
    int end_tag;
    struct table* tbl0;
    int indent;
    int indent;
    char ch;
    char* p;
    int ech;
    char* p;
    char* bp;
    char* tp;
    int i;
    Str line;
    char* tp;
    int i;
    _unknown_ _v13;
    _unknown_ _v16;
    _unknown_ _v20;
    struct readbuffer* _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    struct _Str* _v40;
    intOrPtr _v44;
    intOrPtr _v48;
    intOrPtr _v52;
    _unknown_ _v56;
    intOrPtr _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ _v92;
    _unknown_ _v96;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ _v108;
    _unknown_ _v112;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ _v124;
    _unknown_ _v128;
    _unknown_ _v132;
    _unknown_ _v144;
    _unknown_ _v172;
    _unknown_ _v176;
    _unknown_ _v180;
    _unknown_ _v184;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t723;
    _unknown_ _t728;
    _unknown_ _t739;
    _unknown_ _t782;
    _unknown_ _t865;
    _unknown_ _t951;
    _unknown_ _t1001;
    _unknown_ _t1026;

    _v24 = h_env->obuf;
    _v44 = 0;
    _v48 = 0;
    _v52 = 0;
    _v60 = 0;
    _v40 = Strnew();
    while(1) {
    }
}

addnewline2(Buffer* buf, char* line, Lineprop* prop, Linecolor* color, int pos, int nlines)
{// addr = 0x0806D554
    Line* l;
    Line* _v16;
    _unknown_ __ebp;

     *__esp = 52;
    GC_malloc();
    _v16 = __eax;
    _v16->next = 0;
     *_v16 = line;
    _v16->propBuf = prop;
    _v16->colorBuf = color;
    _v16->len = pos;
    _v16->width = -1;
    _v16->size = pos;
    _v16->bpos = 0;
    _v16->bwidth = 0;
    _v16->prev = buf->currentLine;
    if(buf->currentLine == 0) {
        _v16->next = 0;
    } else {
        _v16->next = buf->currentLine->next;
        buf->currentLine->next = _v16;
    }
    if(buf->lastLine == 0 || buf->lastLine == buf->currentLine) {
        buf->lastLine = _v16;
    }
    buf->currentLine = _v16;
    if(buf->firstLine == 0) {
        buf->firstLine = _v16;
    }
    buf->allLine =  &(buf->allLine->lineBuf);
    _v16->linenumber = buf->allLine;
    if(nlines >= 0) {
        _v16->real_linenumber = nlines;
    } else {
        _v16->real_linenumber = 0;
    }
    _v16 = 0;
    return;
}

addnewline(Buffer* buf, char* line, Lineprop* prop, Linecolor* color, int pos, int width, int nlines)
{// addr = 0x0806D678
    char* s;
    Lineprop* p;
    Linecolor* c;
    Line* l;
    int i;
    int bpos;
    int bwidth;
    char* _v16;
    void* _v20;
    void* _v24;
    Line* _v28;
    int _v32;
    int _v36;
    int _v40;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    int _t160;
    _unknown_ _t164;
    Lineprop* _t169;
    _unknown_ _t174;

    if(pos <= 0) {
        _v16 = NullLine;
        _v20 =  &NullProp;
    } else {
        _v16 = allocStr(line, pos);
        _t169 = pos + pos;
         *__esp = _t169;
        GC_malloc_atomic();
        _v20 = _t169;
        bcopy(prop, _v20, pos + pos);
    }
    if(pos <= 0 || color == 0) {
        _v24 = 0;
    } else {
        _t160 = pos;
         *__esp = _t160;
        GC_malloc_atomic();
        _v24 = _t160;
        bcopy(color, _v24, pos);
    }
    addnewline2(buf, _v16, _v20, _v24, pos, nlines);
    if(pos <= 0) {
        return ;
    }
    if(width <= 0) {
        return ;
    }
    _v36 = 0;
    _v40 = 0;
    while(1) {
        _v28 = buf->currentLine;
        _v28->bpos = _v36;
        _v28->bwidth = _v40;
        _v32 = columnLen(_v28, width);
        if(_v32 != 0) {
            goto L15;
        } else {
            goto L11;
        }
    }
}

Buffer* loadHTMLBuffer(URLFile* f, Buffer* newBuf)
{// addr = 0x0806D888
    FILE* src;
    Str tmp;
    FILE* _v16;
    struct _Str* _v20;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t64;
    _unknown_ _t79;
    _unknown_ _t80;
    _unknown_ _t90;
    _unknown_ _t91;

    _v16 = 0;
    if(newBuf == 0) {
        _t80 = _t90 - _t79;
        _t81 = _t80 >= 0 ? 0 : _t80;
        newBuf = newBuffer(_t80 >= 0 ? 0 : _t80);
    }
    if(newBuf->sourcefile == 0 && ((f->scheme & 255 & 4294967295) != 4 || newBuf->mailcap != 0)) {
        _v20 = tmpfname(1, ".html");
        _v16 = fopen( *_v20, "w");
        if(_v16 != 0) {
            newBuf->sourcefile =  *_v20;
        }
    }
    asm("cwde ");
    loadHTMLstream(f, newBuf, _v16, newBuf->bufferprop & 65535 & 2);
    newBuf->topLine = newBuf->firstLine;
    newBuf->lastLine = newBuf->currentLine;
    newBuf->currentLine = newBuf->firstLine;
    if(n_textarea != 0) {
        formResetBuffer(newBuf, newBuf->formitem);
    }
    if(_v16 == 0) {
        return newBuf;
    }
    fclose(_v16);
    return newBuf;
}

char* convert_size(clen_t size, int usefloat)
{// addr = 0x0806D9B9
    float csize;
    int sizepos;
    char** sizes;
    signed int _v20;
    char*[10]* _v24;
    signed int _v32;
    long long int _v36;
    intOrPtr _v48;
    intOrPtr __ebx;
    _unknown_ __ebp;
    signed int _t17;
    char* _t21;

    _v36 = size;
    _t17 = usefloat;
    _v32 = _t17;
    _v20 = 0;
    _v24 =  &_size_unit;
    asm("fild qword [ebp-0x20]");
    asm("fstp dword [ebp-0xc]");
    while(1) {
        asm("fld dword [ebp-0xc]");
        asm("fld qword [0x80caba8]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t17 & 4294967295) == 0) {
            break;
        }
        _t17 =  *(_v24 + (_v20 + 1 << 2));
        if(_t17 != 0) {
            asm("fld dword [ebp-0xc]");
            asm("fld dword [0x80caba0]");
            asm("fdivp st1, st0");
            asm("fstp dword [ebp-0xc]");
            _v20 = _v20 + 1;
            continue;
        }
        break;
    }
L4:
    __ebx =  *((intOrPtr*)(_v24 + (_v20 << 2)));
    asm("fld dword [ebp-0xc]");
    asm("fld qword [0x80cab78]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80cab80]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fld qword [0x80cab78]");
    asm("fdivp st1, st0");
    if(_a12 == 0) {
        _t21 = "%.0f%s";
    } else {
        _t21 = "%.3g%s";
    }
    _v48 = __ebx;
    asm("fstp qword [esp+0x4]");
    return  *(Sprintf(_t21));
}

char* convert_size2(clen_t size1, clen_t size2, int usefloat)
{// addr = 0x0806DA74
    char** sizes;
    float csize;
    float factor;
    int sizepos;
    char*[10]* _v16;
    intOrPtr _v24;
    signed int _v28;
    long long int _v32;
    long long int _v36;
    long long int _v40;
    int _v44;
    long long int _v48;
    signed int _v52;
    intOrPtr _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t31;
    signed int _t32;
    char* _t36;
    long long int _t43;
    intOrPtr _t44;

    _v36 = size1;
    _v32 = size2;
    _v44 = usefloat;
    _v40 = _a16;
    _v16 =  &_size_unit;
    _v24 = 1065353216;
    _v28 = 0;
    __ecx = _v36;
    _t43 = _v32;
    _t32 = _v44;
    __edx = _v40;
    if(__edx <= _t43 && (__edx < _t43 || _t32 < __ecx)) {
        _t32 = __ecx;
        __edx = _t43;
    }
    _v52 = _t32;
    _v48 = __edx;
    asm("fild qword [ebp-0x30]");
    asm("fstp dword [ebp-0x10]");
    while(1) {
        asm("fld dword [ebp-0x10]");
        asm("fdiv dword [ebp-0x14]");
        asm("fld qword [0x80caba8]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t32 & 4294967295) == 0) {
            break;
        }
        _t32 =  *(_v16 + (_v28 + 1 << 2));
        if(_t32 != 0) {
            asm("fld dword [ebp-0x14]");
            asm("fld dword [0x80caba0]");
            asm("fmulp st1, st0");
            asm("fstp dword [ebp-0x14]");
            _v28 = _v28 + 1;
            continue;
        }
        break;
    }
L8:
    _t44 =  *((intOrPtr*)(_v16 + (_v28 << 2)));
    asm("fild qword [ebp-0x28]");
    asm("fdiv dword [ebp-0x14]");
    asm("fld qword [0x80cab78]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80cab80]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fld qword [0x80cab78]");
    asm("fdivp st1, st0");
    asm("fstp qword [ebp-0x38]");
    asm("fild qword [ebp-0x20]");
    asm("fdiv dword [ebp-0x14]");
    asm("fld qword [0x80cab78]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80cab80]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fld qword [0x80cab78]");
    asm("fdivp st1, st0");
    if(_a20 == 0) {
        _t36 = "%.0f/%.0f%s";
    } else {
        _t36 = "%.3g/%.3g%s";
    }
    _v72 = _t44;
    asm("fld qword [ebp-0x38]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    return  *(Sprintf(_t36));
}

showProgress(clen_t* linelen, clen_t* trbyte)
{// addr = 0x0806DB9B
    int i;
    int j;
    int rate;
    int duration;
    int eta;
    int pos;
    time_t cur_time;
    Str messages;
    char* fmtrbyte;
    char* fmrate;
    double ratio;
    intOrPtr _v32;
    intOrPtr _v36;
    signed int _v40;
    signed int _v44;
    signed int _v48;
    int _v52;
    long int _v56;
    struct _Str* _v60;
    signed int _v64;
    char* _v68;
    long long int _v80;
    long long int _v84;
    intOrPtr _v96;
    intOrPtr _v100;
    intOrPtr _v104;
    long long int _v108;
    long long int _v112;
    long long int _v116;
    signed int _v120;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t157;
    clen_t* _t159;
    long long int _t160;
    long long int _t161;
    clen_t* _t166;
    clen_t* _t169;
    clen_t* _t174;
    signed int _t185;
    clen_t* _t197;
    clen_t* _t200;
    clen_t* _t205;
    clen_t* _t208;
    signed int _t234;
    signed int _t236;
    _unknown_ _t238;
    _unknown_ _t245;
    _unknown_ _t250;
    _unknown_ _t257;
    _unknown_ _t270;
    _unknown_ _t273;
    _unknown_ _t284;
    clen_t* _t288;
    clen_t* _t293;
    _unknown_ _t310;
    long long int _t311;
    long long int _t312;
    long long int _t317;
    _unknown_ _t332;
    _unknown_ _t339;
    _unknown_ _t343;
    _unknown_ _t350;

    if((fmInitialized & 255 & 4294967295) == 0) {
        return ;
    }
    _t159 = linelen;
    _t311 = _t159[0];
    _t160 =  *_t159;
    if(_t311 <= 0) {
        if(_t311 >= 0) {
            return ;
        }
        if(_t160 <= 1023) {
            return ;
        }
    }
    _t161 = current_content_length;
    _t312 =  *135776436;
    if(_t312 >= 0 || _t312 <= 0 && _t161 <= 0) {
         *__esp = 0;
        time();
        _v56 = _t161;
        if(( *trbyte | trbyte[0]) == 0) {
            move(LINES - 1, 0);
            clrtoeolx();
            start_time = _v56;
        }
        _t166 = linelen;
        asm("adc edx, ebx");
        _t288 = trbyte;
         *_t288 =  *_t166 +  *trbyte;
        _t288[0] = _t166[0];
        _t169 = linelen;
         *_t169 = 0;
        _t169[0] = 0;
        if(_v56 == last_time) {
            return ;
        }
        last_time = _v56;
        move(LINES - 1, 0);
        _t174 = trbyte;
        _v116 = 1;
         *__esp =  *_t174;
        _v120 = _t174[0];
        _v64 = convert_size();
        _v44 = _v56 - start_time;
        if(_v44 == 0) {
            _v120 = _v64;
            _v60 = Sprintf("%7s loaded");
        } else {
            _t317 = trbyte[0];
            _t185 = L080C6EC0( *trbyte, _t317, _v44, _v44 >> 31);
            _v116 = 1;
             *__esp = _t185;
            _v120 = _t317;
            _v68 = convert_size();
            _v116 = _v68;
            _v120 = _v64;
            _v60 = Sprintf("%7s loaded %7s/s");
        }
        message( *_v60, 0, 0);
        refresh();
        return;
    } else {
         *__esp = 0;
        time();
        _v56 = _t161;
        if(( *trbyte | trbyte[0]) == 0) {
            move(LINES - 1, 0);
            clrtoeolx();
            start_time = _v56;
        }
        _t197 = linelen;
        asm("adc edx, ebx");
        _t293 = trbyte;
         *_t293 =  *_t197 +  *trbyte;
        _t293[0] = _t197[0];
        _t200 = linelen;
         *_t200 = 0;
        _t200[0] = 0;
        if(_v56 == last_time) {
            return ;
        }
        last_time = _v56;
        move(LINES - 1, 0);
        _t205 = trbyte;
        _v84 =  *_t205;
        _v80 = _t205[0];
        asm("fild qword [ebp-0x50]");
        asm("fld qword [0x80cab78]");
        asm("fmulp st1, st0");
        _v84 = current_content_length;
        _v80 =  *135776436;
        asm("fild qword [ebp-0x50]");
        asm("fdivp st1, st0");
        asm("fstp qword [ebp-0x48]");
        _t208 = trbyte;
        _v108 = 1;
        _v116 = current_content_length;
        _v112 =  *135776436;
         *__esp =  *_t208;
        _v120 = _t208[0];
        _v64 = convert_size2();
        _v44 = _v56 - start_time;
        if(_v44 == 0) {
            asm("fld qword [ebp-0x48]");
            asm("fstp qword [esp+0x8]");
            _v120 = _v64;
            _v60 = Sprintf("%11s %3.0f%%                          ");
        } else {
            _v40 = L080C6EC0( *trbyte, trbyte[0], _v44, _v44 >> 31);
            _t234 = _v40;
            _v116 = 1;
             *__esp = _t234;
            _v120 = _t234 >> 31;
            _v68 = convert_size();
            if(_v40 == 0) {
                _t236 = -1;
            } else {
                asm("sbb edx, ebx");
                _t236 = L080C6EC0(current_content_length -  *trbyte,  *135776436, _v40, _v40 >> 31);
            }
            _v48 = _t236;
            _t300 = _v48;
            _t301 = _v48;
            _t303 = ((_v48 * -2004318071 >> 32) + _v48 >> 5) - (_t301 >> 31);
            _v96 = _v48 - (((_v48 * -2004318071 >> 32) + _v48 >> 5) - (_t300 >> 31) << 2 << 4) - (((_v48 * -2004318071 >> 32) + _v48 >> 5) - (_t300 >> 31) << 2);
            _v100 = ((_v48 * -2004318071 >> 32) + _v48 >> 5) - (_t301 >> 31) - ((((((_v48 * -2004318071 >> 32) + _v48 >> 5) - (_t301 >> 31)) * -2004318071 >> 32) + ((_v48 * -2004318071 >> 32) + _v48 >> 5) - (_t301 >> 31) >> 5) - (_t303 >> 31) << 2 << 4) - ((((((_v48 * -2004318071 >> 32) + _v48 >> 5) - (_t301 >> 31)) * -2004318071 >> 32) + ((_v48 * -2004318071 >> 32) + _v48 >> 5) - (_t301 >> 31) >> 5) - (_t303 >> 31) << 2);
            _v104 = ((_v48 * -1851608123 >> 32) + _v48 >> 11) - (_v48 >> 31);
            _v108 = _v68;
            asm("fld qword [ebp-0x48]");
            asm("fstp qword [esp+0x8]");
            _v120 = _v64;
            _v60 = Sprintf("%11s %3.0f%% %7s/s eta %02d:%02d:%02d     ");
        }
        addstr( *_v60);
        _v52 = 42;
        _v32 = L080C6EC0( *trbyte * (COLS - _v52 - 1), (COLS - _v52 - 1 >> 31) *  *trbyte + trbyte[0] * (COLS - _v52 - 1) + ( *trbyte * (COLS - _v52 - 1) >> 32), current_content_length,  *135776436) + _v52;
        move(LINES - 1, _v52);
        standout();
        addch(32);
        _v36 = _v52 + 1;
        while(_v36 <= _v32) {
            addch(124);
            _v36 = _v36 + 1;
        }
    }
}

init_henv(struct html_feed_environ* h_env, struct readbuffer* obuf, struct environment* envs, int nenv, TextLineList* buf, int limit, int indent)
{// addr = 0x0806E0B9
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t97;

    envs->indent = indent & 4294967295;
    obuf->line = Strnew();
     *(obuf + 4) = 0;
    obuf->pos = 0;
     *(obuf + 8) = Strnew_size(8);
    Strcopy_charp_n( *(obuf + 8), " ", 1);
    obuf->flag = 8192;
    obuf->flag_sp = 0;
    obuf->status = 0;
    obuf->table_level = 65535;
    obuf->nobr_level = 0;
    bzero(obuf + 72, 60);
     *(obuf + 132) = 0;
    obuf->fontstat = 0;
    obuf->fontstat[2] = 0;
    obuf->fontstat[1] = 0;
    obuf->fontstat[3] = 0;
    obuf->fontstat[4] = 0;
     *(obuf + 184) = 0;
    obuf->tag_sp = 0;
    obuf->fontstat_sp = 0;
    obuf->top_margin = 0;
    obuf->bottom_margin = 0;
     *(obuf + 280) = 1;
    set_breakpoint(obuf, 0);
    h_env->buf = buf;
    h_env->f = 0;
    h_env->obuf = obuf;
     *(h_env + 12) = Strnew();
    h_env->limit = limit;
    h_env->maxlimit = 0;
    h_env->envs = envs;
    h_env->nenv = nenv;
    h_env->envc = 0;
    h_env->envc_real = 0;
    h_env->title = 0;
    h_env->blank_lines = 0;
    return;
}

completeHTMLstream(struct html_feed_environ* h_env, struct readbuffer* obuf)
{// addr = 0x0806E26B
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    close_anchor(h_env, obuf);
    if( *(obuf + 132) != 0) {
        push_tag(obuf, "</img_alt>", 137);
         *(obuf + 132) = 0;
    }
    if((obuf->fontstat & 255 & 4294967295) != 0) {
        push_tag(obuf, "</b>", 8);
        obuf->fontstat = 0;
    }
    if((obuf->fontstat[2] & 255 & 4294967295) != 0) {
        push_tag(obuf, "</i>", 110);
        obuf->fontstat[2] = 0;
    }
    if((obuf->fontstat[1] & 255 & 4294967295) != 0) {
        push_tag(obuf, "</u>", 66);
        obuf->fontstat[1] = 0;
    }
    if((obuf->fontstat[3] & 255 & 4294967295) != 0) {
        push_tag(obuf, "</s>", 106);
        obuf->fontstat[3] = 0;
    }
    if((obuf->fontstat[4] & 255 & 4294967295) != 0) {
        push_tag(obuf, "</ins>", 64);
        obuf->fontstat[4] = 0;
    }
    if((obuf->flag & 2048) != 0) {
        HTMLlineproc0("</textarea>", h_env, 1);
    }
    if((obuf->flag & 4096) != 0) {
        HTMLlineproc0("</select>", h_env, 1);
    }
    if((obuf->flag & 16384) != 0) {
        HTMLlineproc0("</title>", h_env, 1);
    }
    if((obuf->table_level & 65535 & 4294967295) > 19) {
        obuf->table_level = 19;
    }
    while((obuf->table_level & 65535 & 4294967295) >= 0) {
        asm("cwde ");
         *( &table_mode + ((obuf->table_level & 65535 & 4294967295) << 4)) =  *( &table_mode + ((obuf->table_level & 65535) << 4)) & 241;
        HTMLlineproc0("</table>", h_env, 1);
    }
}

print_internal_information(struct html_feed_environ* henv)
{// addr = 0x0806E4A4
    int i;
    Str s;
    TextLineList* tl;
    FormSelectOptionItem* ip;
    TextLineListItem* p;
    signed int _v16;
    struct _Str* _v20;
    struct _generallist _v32;
    int _v48;
    char* _v52;
    char* _v56;
    char* __ebx;
    char* __esi;
    _unknown_ __ebp;
    _unknown_ _t104;
    struct _Str* _t124;
    _unknown_ _t127;
    _unknown_ _t134;
    char* _t167;
    char* _t168;
    char* _t181;

    _v32.nitem = newGeneralList();
    _v20 = Strnew_charp("<internal>");
    pushValue(_v32.nitem, newTextLine(_v20, 0));
    if(henv->title != 0) {
        _t181 = html_quote(henv->title);
        _v48 = 0;
        _v52 = "">";
        _v56 = _t181;
        _v20 = Strnew_m_charp("<title_alt title="");
        pushValue(_v32.nitem, newTextLine(_v20, 0));
    }
    if(n_select > 0) {
        _v16 = 0;
        while(_v16 < n_select) {
            _v56 = _v16;
            _v20 = Sprintf("<select_int selectnumber=%d>");
            pushValue(_v32.nitem, newTextLine(_v20, 0));
            _v32.last =  *(select_option + (_v16 << 3));
            while(_v28 != 0) {
                if(_v28[2] == 0) {
                    __ebx = 135041709;
                } else {
                    __ebx = " selected";
                }
                __esi = html_quote( *(_v32.last[1]));
                if( *_v28 == 0) {
                    _t167 =  *(_v32.last[1]);
                } else {
                    _t167 =  *( *(_v32.last));
                }
                _t168 = html_quote(_t167);
                _v48 = __ebx;
                _v52 = __esi;
                _v56 = _t168;
                _v20 = Sprintf("<option_int value="%s" label="%s"%s>");
                pushValue(_v32.nitem, newTextLine(_v20, 0));
                _v32.last = _v32.last[3];
            }
        }
    }
    if(n_textarea > 0) {
        _v16 = 0;
        while(_v16 < n_textarea) {
            _v56 = _v16;
            _v20 = Sprintf("<textarea_int textareanumber=%d>");
            pushValue(_v32.nitem, newTextLine(_v20, 0));
            _v20 = Strnew_charp(html_quote( *( *(textarea_str + (_v16 << 2)))));
            Strcat_charp(_v20, "</textarea_int>");
            pushValue(_v32.nitem, newTextLine(_v20, 0));
            _v16 = _v16 + 1;
        }
    }
    goto L19;
L21:
    if(henv->f == 0) {
        return ;
    }
    _v32.first =  *(_v32.nitem);
L27:
    while(_v32.first != 0) {
        if((ExtHalfdump & 255 & 4294967295) == 0) {
            _t124 =  *(_v32.first->ptr);
        } else {
            _t124 = wc_Str_conv( *((struct _Str**)(_v32.first->ptr)), InnerCharset, DisplayCharset);
        }
        _v52 = _t124->ptr;
        fprintf(henv->f, "%s\n");
        _v32.first =  *(_v32 + 4);
    }
L19:
    _v20 = Strnew_charp("</internal>");
    pushValue(_v32.nitem, newTextLine(_v20, 0));
    if(henv->buf != 0) {
        appendGeneralList(henv->buf, _v32.nitem);
        return;
    }
    goto L21;
}

loadHTMLstream(URLFile* f, Buffer* newBuf, FILE* src, int internal)
{// addr = 0x0806E813
    struct environment[19] envs;
    clen_t linelen;
    clen_t trbyte;
    Str lineBuf2;
    wc_ces charset;
    _None doc_charset;
    struct html_feed_environ htmlenv1;
    struct readbuffer obuf;
    _None image_flag;
    _None prevtrap;
    struct _Str* _v16;
    signed int _v20;
    unsigned int _v24;
    signed int _v28;
    _None* _v32;
    int _v40;
    long long int _v44;
    int _v48;
    int _v52;
    struct html_feed_environ _v100;
    struct environment _v420;
    struct readbuffer _v756;
    _unknown_ _v772;
    _unknown_ _v776;
    int _v780;
    intOrPtr _v784;
    long long int _v788;
    int _v792;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t203;
    _unknown_ _t208;
    int _t210;
    Str* _t212;
    FormSelectOption* _t214;
    FILE* _t228;
    _unknown_ _t267;
    _unknown_ _t272;
    _unknown_ _t305;
    _unknown_ _t312;
    _unknown_ _t318;
    _unknown_ _t365;
    _unknown_ _t375;
    _unknown_ _t376;

    _v44 = 0;
    _v40 = 0;
    _v52 = 0;
    _v48 = 0;
    _v16 = Strnew();
    _v20 = 256;
    _v24 = DocumentCharset;
    _v32 = 0;
    if((fmInitialized & 255 & 4294967295) == 0) {
L3:
        symbol_width0 = 0;
        get_symbol(DisplayCharset,  &symbol_width0);
        if(( *135119023 & 255 & 4294967295) == 0) {
            _t210 = 1;
        } else {
            _t210 = symbol_width0;
        }
        symbol_width = _t210;
        goto L7;
    }
    if(graph_ok() == 0) {
        goto L3;
    } else {
        symbol_width0 = 1;
        symbol_width = symbol_width0;
    }
L7:
    cur_title = 0;
    n_textarea = 0;
    cur_textarea = 0;
    max_textarea = 10;
    _t212 = max_textarea << 2;
     *__esp = _t212;
    GC_malloc();
    textarea_str = _t212;
    n_select = 0;
    max_select = 10;
    _t214 = max_select << 3;
     *__esp = _t214;
    GC_malloc();
    select_option = _t214;
    cur_select = 0;
    form_sp = -1;
    form_max = -1;
    forms_size = 0;
    forms = 0;
    cur_hseq = 1;
    cur_iseq = 1;
    if((newBuf->image_flag & 255 & 4294967295) == 0) {
        if(activeImage == 0 || displayImage == 0) {
L13:
            _v28 = 1;
        } else {
            if(autoImage == 0) {
                goto L13;
            } else {
                _v28 = 2;
            }
        }
    } else {
        _v28 = newBuf->image_flag & 255 & 4294967295;
    }
L14:
    if( *((intOrPtr*)(newBuf + 152)) != 0) {
        cur_baseURL = baseURL(newBuf);
    }
    if(w3m_halfload != 0) {
        newBuf->buffername = "---";
         *(newBuf + 208) = InnerCharset;
        max_textarea = 0;
        max_select = 0;
        HTMLlineproc3(newBuf,  *(f + 4));
        w3m_halfload = 0;
        return;
    }
    asm("cwde ");
    init_henv( &_v100,  &_v756,  &_v420, 20, 0, newBuf->width & 65535, 0);
    if((w3m_dump & 16) == 0) {
        _t228 = newGeneralList();
        _v100.buf = _t228;
    } else {
        _t228 = __imp__stdout;
        _v100.f = _t228;
    }
    _v792 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t228 == 0) {
        if((TrapSignal & 255 & 4294967295) != 0) {
            _v32 = mySignal(2, KeyAbort);
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_cbreak();
            }
        }
        if(newBuf != 0) {
            asm("cwde ");
            if((newBuf->bufferprop & 65535 & 2) == 0) {
                if( *(newBuf + 208) != 0) {
                    _v24 =  *(newBuf + 208);
                    _v20 = _v24;
                }
            } else {
                _v20 = InnerCharset;
            }
        }
        if(content_charset == 0 || (UseContentCharset & 255 & 4294967295) == 0) {
            if(f->guess_type != 0 && strcasecmp(f->guess_type, "application/xhtml+xml") == 0) {
                _v24 = 3178565;
            }
        } else {
            _v24 = content_charset;
        }
        meta_charset = 0;
        if(( *(f + 4)->base.stream.cur & 255 & 4294967295) != 4) {
             *(f + 4) = newEncodedStream( *(f + 4), f->encoding & 255 & 4294967295);
        }
        while(1) {
            _v16 = StrmyISgets( *(f + 4));
            if(_v16->length == 0) {
                break;
            }
            if((f->scheme & 255 & 4294967295) != 9 || ( *( *_v16) & 255 & 4294967295) != 46) {
L44:
                if(src != 0) {
                    fwrite( *_v16, 1, _v16->length, src);
                }
                asm("adc edx, ebx");
                _v44 = _v44 + _v16->length;
                _v40 = _v40;
                if((w3m_dump & 8) != 0) {
                    _v780 = 1;
                    _v788 = current_content_length;
                    _v784 =  *135776436;
                     *__esp = _v44;
                    _v792 = _v40;
                    _v792 = convert_size2();
                    printf("W3m-in-progress: %s\n");
                }
                if((w3m_dump & 4) == 0) {
                    showProgress( &_v44,  &_v52);
                    if(meta_charset != 0) {
                        if(content_charset == 0 && (UseContentCharset & 255 & 4294967295) != 0) {
                            _v24 = meta_charset;
                            _v20 = 256;
                        }
                        meta_charset = 0;
                    }
                    _v16 = convertLine(f, _v16, 2,  &_v20, _v24);
                    cur_document_charset = _v20 & 4294967295;
                    HTMLlineproc0( *_v16,  &_v100, internal);
                }
                continue;
            } else {
                Strdelete(_v16, 0, 1);
                if(( *( *_v16) & 255 & 4294967295) == 10 || ( *( *_v16) & 255 & 4294967295) == 13 || ( *( *_v16) & 255 & 4294967295) == 0) {
                    break;
                }
                goto L44;
            }
        }
        if(_v696 != 0) {
            _v756.status = 7;
            HTMLlineproc0("\n",  &_v100, internal);
        }
        _v756.status = 0;
        completeHTMLstream( &_v100,  &_v756);
        flushline( &_v100,  &_v756, 0, 2, _v100.limit);
        if(_v60 != 0) {
            newBuf->buffername = _v100.title;
        }
        if((w3m_dump & 16) == 0) {
            if(w3m_backend == 0) {
                goto L76;
            }
        } else {
            if((TrapSignal & 255 & 4294967295) != 0) {
                if((fmInitialized & 255 & 4294967295) != 0) {
                    term_raw();
                }
                if(_v32 != 0) {
                    mySignal(2, _v32);
                }
            }
            print_internal_information( &_v100);
            return;
        }
L70:
        if((TrapSignal & 255 & 4294967295) != 0) {
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_raw();
            }
            if(_v32 != 0) {
                mySignal(2, _v32);
            }
        }
        print_internal_information( &_v100);
        backend_halfdump_buf = _v100.buf;
        return;
    } else {
        HTMLlineproc0("<br>Transfer Interrupted!<br>",  &_v100, 1);
    }
L76:
     *((intOrPtr*)(newBuf + 200)) = _v52 + _v44;
    if((TrapSignal & 255 & 4294967295) != 0) {
        if((fmInitialized & 255 & 4294967295) != 0) {
            term_raw();
        }
        if(_v32 != 0) {
            mySignal(2, _v32);
        }
    }
    asm("cwde ");
    if((newBuf->bufferprop & 65535 & 2) == 0) {
         *(newBuf + 208) = _v20;
    }
    newBuf->image_flag = _v28 & 4294967295;
    HTMLlineproc2(newBuf, _v100.buf);
    return;
}

Buffer* loadHTMLString(Str page)
{// addr = 0x0806EF44
    URLFile f;
    _None prevtrap;
    Buffer* newBuf;
    _None* _v16;
    Buffer* _v20;
    struct  _v52;
    _unknown_ _v64;
    _unknown_ _v68;
    int _v72;
    _unknown_ __ebp;
    int _t57;
    _unknown_ _t58;
    Buffer* _t60;
    _unknown_ _t87;
    _unknown_ _t92;
    _unknown_ _t96;
    int _t99;
    _unknown_ _t100;

    _v16 = 0;
    _t99 = COLS;
    if(showLineNum == 0) {
        _t57 = 1;
    } else {
        _t57 = 6;
    }
    _t58 = _t99 - _t57;
    _t59 = _t58 >= 0 ? 0 : _t58;
    _t60 = newBuffer(_t58 >= 0 ? 0 : _t58);
    _v20 = _t60;
    _v72 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t60 == 0) {
        if((TrapSignal & 255 & 4294967295) != 0) {
            _v16 = mySignal(2, KeyAbort);
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_cbreak();
            }
        }
        init_stream( &_v52, 4, newStrStream(page));
         *(_v20 + 208) = InnerCharset;
        loadHTMLstream( &_v52, _v20, 0, 1);
         *(_v20 + 208) = 256;
        if((TrapSignal & 255 & 4294967295) != 0) {
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_raw();
            }
            if(_v16 != 0) {
                mySignal(2, _v16);
            }
        }
        _v20->topLine = _v20->firstLine;
        _v20->lastLine = _v20->currentLine;
        _v20->currentLine = _v20->firstLine;
        _v20->type = "text/html";
        _v20->real_type = _v20->type;
        if(n_textarea == 0) {
            return _v20;
        }
        formResetBuffer(_v20, _v20->formitem);
        return _v20;
    } else {
        if((TrapSignal & 255 & 4294967295) != 0) {
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_raw();
            }
            if(_v16 != 0) {
                mySignal(2, _v16);
            }
        }
        discardBuffer(_v20);
        return 0;
    }
}

Str loadGopherDir(URLFile* uf, ParsedURL* pu, wc_ces* charset)
{// addr = 0x0806F10D
    _None tmp;
    Str lbuf;
    Str name;
    Str file;
    Str host;
    Str port;
    _None p;
    _None q;
    _None prevtrap;
    wc_ces doc_charset;
    struct _Str* _v32;
    struct _Str* _v36;
    struct _Str* _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    char* _v56;
    char* _v60;
    _None* _v64;
    unsigned int _v68;
    _unknown_ _v80;
    URLFile* _v96;
    char* _v100;
    char* _v104;
    char* _v108;
    char* _v112;
    char* _v116;
    char* _v120;
    _unknown_ __ebp;
    struct _Str* _t181;
    _unknown_ _t188;
    _unknown_ _t248;
    _unknown_ _t258;
    _unknown_ _t266;

    _v64 = 0;
    _v68 = DocumentCharset;
    _v32 = parsedURL2Str(pu);
    _v56 = html_quote( *_v32);
    _v32 = convertLine(0, Strnew_charp(file_unquote( *_v32)), 0, charset, _v68);
    _v60 = html_quote( *_v32);
    _v96 = 0;
    _v100 = "</h1>\n<table>\n";
    _v104 = _v60;
    _v108 = "</title>\n</head>\n<body>\n<h1>Index of ";
    _v112 = _v60;
    _v116 = "">\n<title>";
    _v120 = _v56;
    _t181 = Strnew_m_charp("<html>\n<head>\n<base href="");
    _v32 = _t181;
    _v120 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t181 != 0) {
        goto L52;
    } else {
        if((TrapSignal & 255 & 4294967295) != 0) {
            _v64 = mySignal(2, KeyAbort);
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_cbreak();
            }
        }
        while(1) {
L4:
            _v36 = StrISgets( *(uf + 4));
            if(_v36->length == 0) {
                break;
            }
            if(( *( *_v36) & 255 & 4294967295) != 46 || ((1)[ *_v36] & 255 & 4294967295) != 10 && ((1)[ *_v36] & 255 & 4294967295) != 13) {
                _v36 = convertLine(uf, _v36, 2, charset, _v68);
                _v56 =  *_v36;
                _v60 = _v56;
                while(( *_v60 & 255 & 4294967295) != 0) {
                    if(( *_v60 & 255 & 4294967295) != 9) {
                        _v60 =  &(_v60[1]);
                        continue;
                    }
                    _v40 = Strnew_charp_n(_v56, _v60 - _v56);
                    if(( *_v60 & 255 & 4294967295) != 0) {
                        _v56 =  &(_v60[1]);
                        _v60 = _v56;
                        while(( *_v60 & 255 & 4294967295) != 0 && ( *_v60 & 255 & 4294967295) != 9) {
                            _v60 =  &(_v60[1]);
                        }
                    }
                    goto L4;
                }
            }
L52:
            if((TrapSignal & 255 & 4294967295) != 0) {
                if((fmInitialized & 255 & 4294967295) != 0) {
                    term_raw();
                }
                if(_v64 != 0) {
                    mySignal(2, _v64);
                }
            }
            Strcat_charp(_v32, "</table>\n</body>\n</html>\n");
            return _v32;
        }
    }
    goto L52;
}

Buffer* loadBuffer(URLFile* uf, _None newBuf)
{// addr = 0x0806F5A5
    _None src;
    wc_ces charset;
    _None doc_charset;
    Str lineBuf2;
    _None pre_lbuf;
    int nlines;
    Str tmpf;
    clen_t linelen;
    clen_t trbyte;
    Lineprop* propBuffer;
    Linecolor* colorBuffer;
    _None prevtrap;
    signed int _v29;
    struct _IO_FILE* _v36;
    unsigned int _v40;
    unsigned int _v44;
    struct _Str* _v48;
    int _v52;
    struct _Str* _v56;
    int _v60;
    int _v64;
    _None* _v68;
    int _v72;
    long long int _v76;
    int _v80;
    int _v84;
    _unknown_ _v100;
    _unknown_ _v104;
    int _v108;
    intOrPtr _v112;
    long long int _v116;
    int _v120;
    _unknown_ __ebx;
    _unknown_ __ebp;
    struct _Str* _t172;
    int _t212;
    int _t215;
    _unknown_ _t216;
    _unknown_ _t227;
    _unknown_ _t232;
    _unknown_ _t251;
    _unknown_ _t255;
    int _t285;
    _unknown_ _t286;
    _unknown_ _t290;
    _unknown_ _t311;
    _unknown_ _t312;
    int _t317;
    _unknown_ _t318;
    int _t326;
    _unknown_ _t327;

    _v36 = 0;
    _v40 = 256;
    _v44 = DocumentCharset;
    _v29 = 0;
    _v76 = 0;
    _v72 = 0;
    _v84 = 0;
    _v80 = 0;
    _v60 = 0;
    _v64 = 0;
    _v68 = 0;
    if(newBuf == 0) {
        _t326 = COLS;
        if(showLineNum == 0) {
            _t285 = 1;
        } else {
            _t285 = 6;
        }
        _t286 = _t326 - _t285;
        _t287 = _t286 >= 0 ? 0 : _t286;
        newBuf = newBuffer(_t286 >= 0 ? 0 : _t286);
    }
    _t172 = Strnew();
    _v48 = _t172;
    _v120 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t172 == 0) {
        if((TrapSignal & 255 & 4294967295) != 0) {
            _v68 = mySignal(2, KeyAbort);
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_cbreak();
            }
        }
        if( *(newBuf + 184) == 0 && ((uf->scheme & 255 & 4294967295) != 4 ||  *((intOrPtr*)(newBuf + 232)) != 0)) {
            _v56 = tmpfname(1, 0);
            _v36 = fopen( *_v56, "w");
            if(_v36 != 0) {
                 *(newBuf + 184) =  *_v56;
            }
        }
        if( *(newBuf + 208) != 0) {
            _v44 =  *(newBuf + 208);
            _v40 = _v44;
        }
        if(content_charset != 0 && (UseContentCharset & 255 & 4294967295) != 0) {
            _v44 = content_charset;
        }
        _v52 = 0;
        if(( *(uf + 4)->base.stream.cur & 255 & 4294967295) != 4) {
             *(uf + 4) = newEncodedStream( *(uf + 4), uf->encoding & 255 & 4294967295);
        }
        while(1) {
            _v48 = StrmyISgets( *(uf + 4));
            if(_v48->length == 0) {
                break;
            }
            if((uf->scheme & 255 & 4294967295) != 9 || ( *( *_v48) & 255 & 4294967295) != 46) {
L26:
                if(_v36 != 0) {
                    fwrite( *_v48, 1, _v48->length, _v36);
                }
                asm("adc edx, ebx");
                _v76 = _v76 + _v48->length;
                _v72 = _v72;
                if((w3m_dump & 8) != 0) {
                    _v108 = 1;
                    _v116 = current_content_length;
                    _v112 =  *135776436;
                     *__esp = _v76;
                    _v120 = _v72;
                    _v120 = convert_size2();
                    printf("W3m-in-progress: %s\n");
                }
                if((w3m_dump & 4) != 0) {
                    continue;
                } else {
                    showProgress( &_v76,  &_v84);
                    if(frame_source != 0) {
                        goto L46;
                    }
                    _v48 = convertLine(uf, _v48, 1,  &_v40, _v44);
                    if(squeezeBlankLine == 0) {
L37:
                        _v52 = _v52 + 1;
                        Strchop(_v48);
                        _v48 = checkType(_v48,  &_v60, 0);
                        if(FoldLine == 0) {
                            _t212 = -1;
                        } else {
                            _t317 = COLS;
                            if(showLineNum == 0) {
                                _t215 = 1;
                            } else {
                                _t215 = 6;
                            }
                            _t216 = _t317 - _t215;
                            _t217 = _t216 >= 0 ? 0 : _t216;
                            _t212 = (_t216 >= 0 ? 0 : _t216) + 1;
                        }
                        addnewline(newBuf,  *_v48, _v60, _v64, _v48->length, _t212, _v52);
                        continue;
                    }
                    if(( *( *_v48) & 255 & 4294967295) != 10 || (_v29 & 255 & 4294967295) != 10) {
                        _v29 =  *( *_v48) & 255 & 4294967295;
                    } else {
                        _v52 = _v52 + 1;
                        continue;
                    }
                    goto L37;
                }
L46:
                continue;
            } else {
                Strdelete(_v48, 0, 1);
                if(( *( *_v48) & 255 & 4294967295) == 10 || ( *( *_v48) & 255 & 4294967295) == 13 || ( *( *_v48) & 255 & 4294967295) == 0) {
                    goto L50;
                } else {
                    goto L26;
                }
            }
        }
    }
L50:
    if((TrapSignal & 255 & 4294967295) != 0) {
        if((fmInitialized & 255 & 4294967295) != 0) {
            term_raw();
        }
        if(_v68 != 0) {
            mySignal(2, _v68);
        }
    }
     *((intOrPtr*)(newBuf + 12)) =  *((intOrPtr*)(newBuf + 8));
     *((intOrPtr*)(newBuf + 20)) =  *((intOrPtr*)(newBuf + 16));
     *((intOrPtr*)(newBuf + 16)) =  *((intOrPtr*)(newBuf + 8));
     *((intOrPtr*)(newBuf + 200)) = _v84 + _v76;
     *(newBuf + 208) = _v40;
    if(_v36 == 0) {
        return newBuf;
    }
    fclose(_v36);
    return newBuf;
}

Buffer* loadImageBuffer(URLFile* uf, Buffer* newBuf)
{// addr = 0x0806FA5B
    Image image;
    ImageCache* cache;
    Str tmp;
    Str tmpf;
    FILE* src;
    URLFile f;
    _None prevtrap;
    struct stat st;
    ImageCache* _v16;
    struct _Str* _v20;
    struct _Str* _v24;
    FILE* _v28;
    _None* _v32;
    struct  _v64;
    union input_stream* _v68;
    short _v90;
    short _v92;
    char _v96;
    char _v100;
    char _v188;
    char* _v204;
    intOrPtr _v208;
    char* _v212;
    char* _v216;
    int _v220;
    int _v224;
    char* _v228;
    char* _v232;
    _unknown_ __ebp;
    URLFile* _t157;
    _unknown_ _t195;
    int _t201;
    _unknown_ _t202;
    _unknown_ _t208;
    _unknown_ _t210;
    _unknown_ _t216;
    _unknown_ _t220;
    _unknown_ _t222;
    char _t236;
    int _t254;
    _unknown_ _t255;
    _unknown_ _t267;

    _v28 = 0;
    _v32 = 0;
    loadImage(newBuf, 1);
    _v100 = uf->url;
    _v96 = uf->ext;
    _v92 = 65535;
    _v90 = 65535;
    _v68 = 0;
    _v16 = getImage( &_v100, cur_baseURL, 2);
    if(cur_baseURL->is_nocache != 0 || (_v16->loaded & 255 & 4294967295 & 1 & 4294967295) == 0) {
L3:
        if((TrapSignal & 255 & 4294967295) != 0) {
            _v32 = mySignal(2, KeyAbort);
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_cbreak();
            }
        }
        if(( *(uf + 4)->base.stream.cur & 255 & 4294967295) != 4) {
             *(uf + 4) = newEncodedStream( *(uf + 4), uf->encoding & 255 & 4294967295);
        }
        _v204 = _v16->file;
        _t157 = uf;
         *__esp = _t157->scheme;
        _v232 =  *(_t157 + 4);
        _v228 = _t157->ext;
        _v224 = _t157->compression;
        _v220 = _t157->content_encoding;
        _v216 = _t157->guess_type;
        _v212 = _t157->url;
        _v208 =  *((intOrPtr*)(_t157 + 28));
        if(save2tmp() >= 0) {
            if(ISclose( *(uf + 4)) == 0) {
                 *(uf + 4) = 0;
            }
            if((TrapSignal & 255 & 4294967295) != 0) {
                if((fmInitialized & 255 & 4294967295) != 0) {
                    term_raw();
                }
                if(_v32 != 0) {
                    mySignal(2, _v32);
                }
            }
            _v16->loaded = 1;
            _v16->index = 0;
L26:
            if(newBuf == 0) {
                _t254 = COLS;
                if(showLineNum == 0) {
                    _t201 = 1;
                } else {
                    _t201 = 6;
                }
                _t202 = _t254 - _t201;
                _t203 = _t202 >= 0 ? 0 : _t202;
                newBuf = newBuffer(_t202 >= 0 ? 0 : _t202);
            }
            _v16->loaded = (_v16->loaded & 255 | 4) & 4294967295;
            if(newBuf->sourcefile == 0 && (uf->scheme & 255 & 4294967295) != 4) {
                newBuf->sourcefile = _v16->file;
            }
            _v232 = html_quote(_v100);
            _v20 = Sprintf("<img src="%s"><br><br>");
            _v24 = tmpfname(1, ".html");
            _v28 = fopen( *_v24, "w");
            newBuf->mailcap_source =  *_v24;
            init_stream( &_v64, 4, newStrStream(_v20));
            loadHTMLstream( &_v64, newBuf, _v28, 1);
            if(_v28 != 0) {
                fclose(_v28);
            }
            newBuf->topLine = newBuf->firstLine;
            newBuf->lastLine = newBuf->currentLine;
            newBuf->currentLine = newBuf->firstLine;
            newBuf->image_flag = 2;
            return newBuf;
        }
        if(ISclose( *(uf + 4)) == 0) {
             *(uf + 4) = 0;
        }
        if((TrapSignal & 255 & 4294967295) == 0) {
            return 0;
        }
        if((fmInitialized & 255 & 4294967295) != 0) {
            term_raw();
        }
        if(_v32 == 0) {
            return 0;
        }
        mySignal(2, _v32);
        return 0;
    }
    _t236 = _v16->file;
    L080C7280(_t236,  &_v188);
    if(_t236 == 0) {
        goto L26;
    }
    goto L3;
}

Str conv_symbol(Line* l)
{// addr = 0x0806FDDB
    Str tmp;
    char* p;
    char* ep;
    Lineprop* pr;
    int w;
    char** symbol;
    char c;
    int len;
    signed char _v13;
    struct _Str* _v20;
    unsigned char* _v24;
    unsigned char* _v28;
    short unsigned int* _v32;
    int _v36;
    char** _v40;
    signed int _v44;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    int _t95;
    int _t133;

    _v20 = 0;
    _v24 = l->lineBuf;
    _v28 =  &(_v24[l->len]);
    _v32 = l->propBuf;
    _v40 = 0;
    while(_v24 < _v28) {
        if(( *_v32 & 65535 & 4294967295) >= 0) {
            if(_v20 != 0) {
                if(_v20->length + 1 >= _v20->area_size) {
                    Strgrow(_v20);
                }
                _t95 = _v20->length;
                 *( *_v20 + _t95) =  *_v24 & 255 & 4294967295;
                _v20->length = _t95 + 1;
                 *( *_v20 + _v20->length) = 0;
            }
        } else {
            _v13 = (wtf_get_code(_v24) & 127) - 32 & 4294967295;
            _v44 =  *( &WTF_LEN_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            if(_v20 == 0) {
                _v20 = Strnew_size(l->len);
                Strcopy_charp_n(_v20, l->lineBuf, _v24 - l->lineBuf);
                if(( *_v32 & 65535 & 4294967295 &  & 2048) == 0) {
                    _t133 = 1;
                } else {
                    _t133 = 2;
                }
                _v36 = _t133;
                _v40 = get_symbol(DisplayCharset,  &_v36);
            }
            Strcat_charp(_v20, _v40[_v13]);
            _v24 =  &(_v24[_v44 - 1]);
            _v32 = _v32 + _v44 - 1 + _v44 - 1;
        }
        _v24 =  &(_v24[1]);
        _v32 =  &(_v32[1]);
    }
}

_saveBuffer(Buffer* buf, Line* l, FILE* f, int cont)
{// addr = 0x0806FF79
    Str tmp;
    int is_html;
    int set_charset;
    wc_ces charset;
    struct _Str* _v16;
    int _v20;
    signed int _v24;
    unsigned int _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    FILE* _v40;
    _unknown_ __ebp;
    unsigned int _t62;
    _unknown_ _t77;

    _v20 = 0;
    _v24 = DisplayCharset & 4294967295 & ;
    if(DisplayCharset == 0) {
        _t62 = 256;
    } else {
        _t62 = DisplayCharset;
    }
    _v28 = _t62;
    _v20 = is_html_type(buf->type);
    while(l != 0) {
        if(_v20 == 0) {
            _v16 = Strnew_charp_n(l->lineBuf, l->len);
        } else {
            _v16 = conv_symbol(l);
        }
        _v16 = wc_Str_conv(_v16, InnerCharset, _v28);
        fwrite( *_v16, 1, _v16->length, f);
        if(_v16->length <= 0 || ( *( *_v16 + _v16->length - 1) & 255 & 4294967295) != 10) {
            if(cont == 0 || l->next == 0 || l->next->bpos == 0) {
                _v40 = f;
                 *__esp = 10;
                _IO_putc();
            }
        }
        l = l->next;
    }
}

saveBuffer(Buffer* buf, FILE* f, int cont)
{// addr = 0x080700E6
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    _saveBuffer(buf, buf->firstLine, f, cont);
    return;
}

saveBufferBody(Buffer* buf, FILE* f, int cont)
{// addr = 0x08070111
    Line* l;
    struct _Line* _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = buf->firstLine;
    while(_v16 != 0 && _v16->real_linenumber == 0) {
        _v16 = _v16->next;
    }
}

Buffer* loadcmdout(char* cmd, _None* loadproc, Buffer* defaultbuf)
{// addr = 0x0807015D
    FILE* f;
    Buffer* buf;
    URLFile uf;
    union input_stream* _v16;
    _None* _v20;
    union input_stream* _v48;
    char _v52;
    _unknown_ _v68;
    Buffer* _v72;
    _unknown_ __ebp;
    _unknown_ _t22;
    _None* _t33;
    union input_stream* _t34;
    _unknown_ _t35;
    _unknown_ _t37;

    if(cmd == 0) {
        return ;
    }
    if(( *cmd & 255 & 4294967295) == 0) {
        return ;
    }
    _v16 = popen(cmd, "r");
    __eflags = _v16;
    if(__eflags == 0) {
        return ;
    }
    init_stream( &_v52, 255, newFileStream(_v16, pclose));
    _v72 = defaultbuf;
     *__esp =  &_v52;
    _t33 = loadproc;
     *_t33();
    _v20 = _t33;
    _t34 = _v48;
    ISclose(_t34);
    __eflags = _t34;
    if(__eflags != 0) {
        return ;
    }
    _v48 = 0;
    __eflags = _v48;
    return ;
}

Buffer* getshell(char* cmd)
{// addr = 0x08070200
    Buffer* buf;
    Buffer* _v16;
    struct _Str _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t27;

    _v16 = loadcmdout(cmd, loadBuffer, 0);
    if(_v16 == 0) {
        return 0;
    }
     *_v16 = cmd;
    _v36 =  *(wc_Str_conv(Strnew_charp(cmd), SystemCharset, InnerCharset));
    _v40 = "*Shellout*";
    _v16->buffername =  *(Sprintf("%s %s"));
    return _v16;
}

Buffer* getpipe(char* cmd)
{// addr = 0x0807028F
    FILE* f;
    Buffer* buf;
    struct _IO_FILE* _v16;
    Buffer* _v20;
    struct _Str _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t31;
    _unknown_ _t37;
    _unknown_ _t38;
    _unknown_ _t56;
    int _t59;
    _unknown_ _t60;

    if(cmd == 0) {
        return 0;
    }
    if(( *cmd & 255 & 4294967295) == 0) {
        return 0;
    }
    _v16 = popen(cmd, "r");
    if(_v16 == 0) {
        return 0;
    }
    _t59 = COLS;
    if(showLineNum == 0) {
        _t37 = 1;
    } else {
        _t37 = 6;
    }
    _t38 = _t59 - _t37;
    _t39 = _t38 >= 0 ? 0 : _t38;
    _v20 = newBuffer(_t38 >= 0 ? 0 : _t38);
     *(_v20 + 92) = newFileStream(_v16, pclose);
     *_v20 = cmd;
    _v36 =  *(wc_Str_conv(Strnew_charp(cmd), SystemCharset, InnerCharset));
    _v40 = "*stream*";
    _v20->buffername =  *(Sprintf("%s %s"));
    _v20->bufferprop = (_v20->bufferprop & 65535 | 1) & 4294967295;
     *((intOrPtr*)(_v20 + 208)) = 256;
    return _v20;
}

Buffer* openPagerBuffer(InputStream stream, Buffer* buf)
{// addr = 0x080703A2
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t55;
    _unknown_ _t56;
    int _t68;
    _unknown_ _t69;

    if(buf == 0) {
        _t68 = COLS;
        if(showLineNum == 0) {
            _t55 = 1;
        } else {
            _t55 = 6;
        }
        _t56 = _t68 - _t55;
        _t57 = _t56 >= 0 ? 0 : _t56;
        buf = newBuffer(_t56 >= 0 ? 0 : _t56);
    }
     *(buf + 92) = stream;
    buf->buffername = getenv("MAN_PN");
    if(buf->buffername != 0) {
        buf->buffername =  *(wc_Str_conv(Strnew_charp(buf->buffername), SystemCharset, InnerCharset));
    } else {
        buf->buffername = "*stream*";
    }
    buf->bufferprop = (buf->bufferprop & 65535 | 1) & 4294967295;
    if(content_charset == 0 || (UseContentCharset & 255 & 4294967295) == 0) {
         *(buf + 208) = 256;
    } else {
         *(buf + 208) = content_charset;
    }
    buf->currentLine = buf->firstLine;
    return buf;
}

Buffer* openGeneralPagerBuffer(InputStream stream)
{// addr = 0x080704A4
    Buffer* buf;
    char* t;
    Buffer* t_buf;
    URLFile uf;
    Buffer* _v16;
    char* _v20;
    Buffer* _v24;
    struct  _v56;
    Buffer* _v64;
    char* _v68;
    char* _v72;
    char* _v76;
    intOrPtr _v80;
    intOrPtr _v84;
    intOrPtr _v88;
    intOrPtr _v92;
    intOrPtr _v96;
    intOrPtr _v100;
    ParsedURL* _v104;
    _unknown_ __ebp;
    ParsedURL* _t158;
    int _t180;
    _unknown_ _t181;
    int _t195;
    _unknown_ _t196;

    _v20 = "text/plain";
    _v24 = 0;
    init_stream( &_v56, 255, stream);
    content_charset = 0;
    if((SearchHeader & 255 & 4294967295) == 0) {
        if(DefaultType != 0) {
            _v20 = DefaultType;
            DefaultType = 0;
        }
    } else {
        _t195 = COLS;
        if(showLineNum == 0) {
            _t180 = 1;
        } else {
            _t180 = 6;
        }
        _t181 = _t195 - _t180;
        _t182 = _t181 >= 0 ? 0 : _t181;
        _v24 = newBuffer(_t181 >= 0 ? 0 : _t181);
        readHeader( &_v56, _v24, 1, 0);
        _v20 = checkContentType(_v24);
        if(_v20 == 0) {
            _v20 = "text/plain";
        }
        if(_v24 != 0) {
            _v24->topLine = _v24->firstLine;
            _v24->currentLine = _v24->lastLine;
        }
        SearchHeader = 0;
    }
    if(is_html_type(_v20) == 0) {
        if(is_plain_text_type(_v20) == 0) {
            if(activeImage == 0 || displayImage == 0 || useExtImageViewer != 0 || (w3m_dump & 223) != 0) {
L23:
                _v64 = _v24;
                _v68 =  &_v16;
                _v72 = _v20;
                _v76 = "-";
                __esp->marks = _v56;
                _v104 = _v56.stream;
                _v100 = _v56.ext;
                _v96 = _v56.compression;
                _v92 = _v56.content_encoding;
                _v88 = _v56.guess_type;
                _v84 = _v56.url;
                _v80 = _v56.modtime;
                if(doExternal() == 0) {
                    if((stream->base.stream.cur & 255 & 4294967295) != 4) {
                        stream = newEncodedStream(stream, _v56.encoding & 255 & 4294967295);
                    }
                    _v16 = openPagerBuffer(stream, _v24);
                    _v16->type = "text/plain";
                } else {
                    if(ISclose(_v52) == 0) {
                        _v56.stream = 0;
                    }
                    if(_v16 == 0) {
                        return _v16;
                    }
                    if(_v16 == 1) {
                        return _v16;
                    }
                }
                goto L32;
            }
            _t158 = strncasecmp(_v20, "image/", 6);
            if(_t158 != 0) {
                goto L23;
            }
             *__esp = 40;
            GC_malloc();
            cur_baseURL = _t158;
            parseURL("-", cur_baseURL, 0);
            _v16 = loadImageBuffer( &_v56, _v24);
            _v16->type = "text/html";
            goto L32;
        }
    } else {
        _v16 = loadHTMLBuffer( &_v56, _v24);
        _v16->type = "text/html";
L32:
        _v16->real_type = _v20;
         *((intOrPtr*)(_v16 + 132)) = 4;
         *(_v16 + 152) = "-";
        return _v16;
    }
L14:
    if((stream->base.stream.cur & 255 & 4294967295) != 4) {
        stream = newEncodedStream(stream, _v56.encoding & 255 & 4294967295);
    }
    _v16 = openPagerBuffer(stream, _v24);
    _v16->type = "text/plain";
    goto L32;
}

Line* getNextPage(Buffer* buf, int plen)
{// addr = 0x080707C1
    _None top;
    _None last;
    _None cur;
    int i;
    _None nlines;
    clen_t linelen;
    clen_t trbyte;
    Str lineBuf2;
    _None pre_lbuf;
    URLFile uf;
    wc_ces charset;
    _None doc_charset;
    wc_uint8 old_auto_detect;
    _None squeeze_flag;
    Lineprop* propBuffer;
    Linecolor* colorBuffer;
    _None prevtrap;
    Line* l;
    signed int _v29;
    signed char _v30;
    Line* _v36;
    Line* _v40;
    Line* _v44;
    union input_stream* _v48;
    int _v52;
    struct _Str* _v56;
    unsigned int _v60;
    unsigned int _v64;
    int _v68;
    union input_stream* _v72;
    union input_stream* _v76;
    _None* _v80;
    Line* _v84;
    union input_stream* _v88;
    long long int _v92;
    union input_stream* _v96;
    long long int _v100;
    struct  _v132;
    _unknown_ _v148;
    _unknown_ _v152;
    _unknown_ _v156;
    _unknown_ _v160;
    struct _Str _v164;
    int _v168;
    _unknown_ __ebx;
    int __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t235;
    int _t264;
    int _t293;
    _unknown_ _t294;
    _unknown_ _t332;
    _unknown_ _t344;
    _unknown_ _t356;
    _unknown_ _t358;
    _unknown_ _t366;
    _unknown_ _t375;
    _unknown_ _t376;
    int _t383;
    _unknown_ _t384;

    _v36 = buf->topLine;
    _v40 = buf->lastLine;
    _v44 = buf->currentLine;
    _v52 = 0;
    _v92 = 0;
    _v88 = 0;
    _v100 =  *(buf + 200);
    _v96 = 0;
    _v29 = 0;
    _v64 = DocumentCharset;
    _v30 = WcOption.marks & 255 & 4294967295;
    _v68 = 0;
    _v72 = 0;
    _v76 = 0;
    _v80 = 0;
    if( *(buf + 92) == 0) {
        return 0;
    }
    if(_v40 != 0) {
        _v52 = _v40->real_linenumber;
        _v29 =  *( *_v40) & 255 & 4294967295;
        if((_v29 & 255 & 4294967295) == 0) {
            _v29 = 10;
        }
        buf->currentLine = _v40;
    }
    _v60 =  *(buf + 208);
    if( *(buf + 208) == 256) {
        if((UseContentCharset & 255 & 4294967295) != 0) {
            content_charset = 0;
            checkContentType(buf);
            if(content_charset != 0) {
                _v64 = content_charset;
            }
        }
    } else {
        _v64 =  *(buf + 208);
    }
    _t235 =  *(buf + 212) & 255;
    WcOption.marks = _t235 & 4294967295;
    _v168 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t235 != 0) {
        goto L50;
    }
    if((TrapSignal & 255 & 4294967295) != 0) {
        _v80 = mySignal(2, KeyAbort);
        if((fmInitialized & 255 & 4294967295) != 0) {
            term_cbreak();
        }
    }
    init_stream( &_v132, 255, 0);
    _v48 = 0;
    while(_v48 < plen) {
        _v56 = StrmyISgets( *(buf + 92));
        if(_v56->length != 0) {
            asm("adc edx, ebx");
            _v92 = _v92 + _v56->length;
            _v88 = _v88;
            showProgress( &_v92,  &_v100);
            _v56 = convertLine( &_v132, _v56, 1,  &_v60, _v64);
            if(squeezeBlankLine == 0) {
L27:
                _v52 = _v52 + 1;
                Strchop(_v56);
                _v56 = checkType(_v56,  &_v72,  &_v76);
                __edi = _v52;
                if(FoldLine == 0) {
                    _t264 = -1;
                } else {
                    _t383 = COLS;
                    if(showLineNum == 0) {
                        _t293 = 1;
                    } else {
                        _t293 = 6;
                    }
                    _t294 = _t383 - _t293;
                    _t295 = _t294 >= 0 ? 0 : _t294;
                    _t264 = (_t294 >= 0 ? 0 : _t294) + 1;
                }
                addnewline(buf,  *_v56, _v72, _v76, _v56->length, _t264, __edi);
                if(_v36 == 0) {
                    _v36 = buf->firstLine;
                    _v44 = _v36;
                }
                if(buf->lastLine->real_linenumber - buf->firstLine->real_linenumber < PagerMax) {
L46:
                    _v48 = _v48 + 1;
                    continue;
                }
                _v84 = buf->firstLine;
                while() {
                }
            }
            goto L23;
        }
        if(buf->filename == 0) {
            if(getenv("MAN_PN") == 0) {
                buf->buffername = "*stream(closed)*";
            }
        } else {
            _v164 =  *(wc_Str_conv(Strnew_charp(buf->filename), SystemCharset, InnerCharset));
            _v168 = "*stream(closed)*";
            buf->buffername =  *(Sprintf("%s %s"));
        }
        buf->bufferprop = (buf->bufferprop & 65535 | 64) & 4294967295;
        break;
L23:
        _v68 = 0;
        if(( *( *_v56) & 255 & 4294967295) != 10 || (_v29 & 255 & 4294967295) != 10) {
            _v29 =  *( *_v56) & 255 & 4294967295;
        } else {
            _v52 = _v52 + 1;
            _v48 = _v48 - 1;
            _v68 = 1;
            goto L46;
        }
        goto L27;
    }
L50:
    if((TrapSignal & 255 & 4294967295) != 0) {
        if((fmInitialized & 255 & 4294967295) != 0) {
            term_raw();
        }
        if(_v80 != 0) {
            mySignal(2, _v80);
        }
    }
     *(buf + 200) = _v100 + _v92;
     *(buf + 208) = _v60;
    WcOption.marks = _v30 & 255 & 4294967295;
    buf->topLine = _v36;
    buf->currentLine = _v44;
    if(_v40 != 0) {
        if(_v40 == 0) {
            return _v40;
        }
        if(_v40->next == 0) {
            if(_v68 != 0) {
                return _v40;
            }
        }
        _v40 = _v40->next;
        return _v40;
    }
    _v40 = buf->firstLine;
    return _v40;
}

int save2tmp(URLFile uf, char* tmpf)
{// addr = 0x08070CBA
    FILE* ff;
    int check;
    clen_t linelen;
    clen_t trbyte;
    _None prevtrap;
    char c;
    Str buf;
    signed int _v13;
    struct _IO_FILE* _v20;
    int _v24;
    _None* _v28;
    struct _Str* _v32;
    int _v40;
    long long int _v44;
    int _v48;
    long long int _v52;
    _unknown_ _v64;
    _unknown_ _v68;
    int _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    void _t81;
    _unknown_ _t91;
    _unknown_ _t98;
    _unknown_ _t101;
    _unknown_ _t102;
    _unknown_ _t106;
    _unknown_ _t118;
    _unknown_ _t120;

    _v44 = 0;
    _v40 = 0;
    _v52 = 0;
    _v48 = 0;
    _v28 = 0;
    _v20 = fopen(_a36, "wb");
    if(_v20 == 0) {
        return -1;
    }
    _t81 = bcopy( &AbortLoading,  &env_bak, 156);
    _v72 = 1;
     *__esp =  &AbortLoading;
    __sigsetjmp();
    if(_t81 == 0) {
        if((TrapSignal & 255 & 4294967295) != 0) {
            _v28 = mySignal(2, KeyAbort);
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_cbreak();
            }
        }
        _v24 = 0;
        if((uf.scheme & 255 & 4294967295) != 9) {
            _v32 = Strnew_size(1536);
L25:
            while(ISread(uf.stream, _v32, 1536) != 0) {
                goto L24;
            }
        } else {
            while(1) {
                _v13 = ISgetc(uf.stream) & 4294967295;
                if((uf.stream->base.stream.cur & 255 & 4294967295) != 0) {
                    break;
                }
                if(_v13 != 10) {
                    if(_v13 != 46 || _v24 != 1) {
                        if(_v13 != 13 || _v24 != 2) {
                            _v24 = 0;
                        } else {
                            _v24 = _v24 + 1;
                        }
                    } else {
                        _v24 = _v24 + 1;
                    }
L20:
                    _v72 = _v20;
                     *__esp = _v13;
                    _IO_putc();
                    asm("adc edx, 0x0");
                    _v44 = _v44 + 1;
                    _v40 = _v40;
                    showProgress( &_v44,  &_v52);
                    continue;
                }
                if(_v24 != 0) {
                    if(_v24 != 3) {
                        goto L20;
                    }
                    goto L12;
                }
                _v24 = _v24 + 1;
                goto L20;
L12:
                goto L28;
            }
            goto L28;
        }
L24:
        fwrite( *_v32, 1, _v32->length, _v20);
        asm("adc edx, ebx");
        _v44 = _v44 + _v32->length;
        _v40 = _v40;
        showProgress( &_v44,  &_v52);
        goto L25;
    }
L28:
    bcopy( &env_bak,  &AbortLoading, 156);
    if((TrapSignal & 255 & 4294967295) != 0) {
        if((fmInitialized & 255 & 4294967295) != 0) {
            term_raw();
        }
        if(_v28 != 0) {
            mySignal(2, _v28);
        }
    }
    fclose(_v20);
    current_content_length = 0;
     *135776436 = 0;
    return 0;
}

int doExternal(URLFile uf, char* path, char* type, Buffer** bufp, Buffer* defaultbuf)
{// addr = 0x08070F2F
    Str tmpf;
    Str command;
    struct mailcap* mcap;
    int mc_stat;
    Buffer* buf;
    char* header;
    char* src;
    char* ext;
    Str tmp;
    struct _Str* _v16;
    struct _Str* _v20;
    struct mailcap* _v24;
    intOrPtr _v28;
    Buffer* _v32;
    struct _Str _v44;
    struct _Str* _v48;
    struct _Str _v76;
    long int _v80;
    char* _v84;
    char* _v88;
    int _v92;
    int _v96;
    char* _v100;
    union input_stream* _v104;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    char* _t201;
    _unknown_ _t243;
    int _t288;
    _unknown_ _t289;
    _unknown_ _t293;
    _unknown_ _t300;
    _unknown_ _t319;
    _unknown_ _t342;
    int _t364;
    _unknown_ _t365;

    _v32 = 0;
    _v44.length = 0;
    _v44 = uf.ext;
    _v24 = searchExtViewer(_a40);
    if(_v24 == 0) {
        return 0;
    }
    if(_v24->nametemplate != 0) {
        _v16 = unquote_mailcap(_v24->nametemplate, 0, 135041709, 0, 0);
        if(( *( *_v16) & 255 & 4294967295) == 46) {
            _v44 =  *_v16;
        }
    }
    if(_v44 == 0) {
L8:
        _t201 = 0;
        goto L9;
    }
    if(( *_v44 & 255 & 4294967295) == 0) {
        goto L8;
    } else {
        _t201 = _v44;
    }
L9:
    _v16 = tmpfname(0, _t201);
    if((uf.stream->base.stream.cur & 255 & 4294967295) != 4) {
        uf.stream = newEncodedStream(uf.stream, uf.encoding & 255 & 4294967295);
    }
    _v44.area_size = checkHeader(_a48, "Content-Type:");
    if(_v36 != 0) {
        _v44.area_size =  *(wc_Str_conv_strict(Strnew_charp(_v44.area_size), InnerCharset, SystemCharset));
    }
    _v20 = unquote_mailcap(_v24->viewer, _a40,  *_v16, _v44.area_size,  &_v28);
    if((_v28 & 1) == 0) {
        _v100 = shell_quote( *_v16);
        _v104 =  *_v20;
        _v48 = Sprintf("(%s) < %s");
        _v20 = _v48;
    }
    if((_v24->flags & 6) != 0 || (_v24->flags & 1) != 0 || BackgroundExtViewer == 0) {
        _v76 =  *_v16;
         *__esp = uf.scheme;
        _v104 = uf.stream;
        _v100 = uf.ext;
        _v96 = uf.compression;
        _v92 = uf.content_encoding;
        _v88 = uf.guess_type;
        _v84 = uf.url;
        _v80 = uf.modtime;
        if(save2tmp() >= 0) {
            if((_v24->flags & 6) != 0) {
                if(_a48 == 0) {
                    _t364 = COLS;
                    if(showLineNum == 0) {
                        _t288 = 1;
                    } else {
                        _t288 = 6;
                    }
                    _t289 = _t364 - _t288;
                    _t290 = _t289 >= 0 ? 0 : _t289;
                    _a48 = newBuffer(_t289 >= 0 ? 0 : _t289);
                }
                if(_a48->sourcefile == 0) {
                    _v44.length =  *_v16;
                } else {
                    _v44.length = _a48->sourcefile;
                }
                _a48->sourcefile = 0;
                _a48->mailcap = _v24;
            }
            if((_v24->flags & 4) == 0) {
                if((_v24->flags & 2) == 0) {
                    if((_v24->flags & 1 & 4294967295) != 0 || BackgroundExtViewer == 0) {
                        fmTerm();
                        mySystem( *_v20, 0);
                        fmInit();
                        if(CurrentTab != 0) {
                            if(CurrentTab->currentBuffer != 0) {
                                displayBuffer(CurrentTab->currentBuffer, 1);
                            }
                        }
                    } else {
                        mySystem( *_v20, 1);
                    }
                    _v32 = 1;
                } else {
                    _v32 = loadcmdout( *_v20, loadBuffer, _a48);
                    if(_v32 != 0 && _v32 != 1) {
                        _v32->type = "text/plain";
                        _v32->mailcap_source = _v32->sourcefile;
                        _v32->sourcefile = _v44.length;
                    }
                }
            } else {
                _v32 = loadcmdout( *_v20, loadHTMLBuffer, _a48);
                if(_v32 != 0 && _v32 != 1) {
                    _v32->type = "text/html";
                    _v32->mailcap_source = _v32->sourcefile;
                    _v32->sourcefile = _v44.length;
                }
            }
            if(_v32 != 0 && _v32 != 1) {
                 *_v32 = _a36;
                if(_v32->buffername == 0 || ( *(_v32->buffername) & 255 & 4294967295) == 0) {
                    _v32->buffername =  *(wc_Str_conv(Strnew_charp(lastFileName(_a36)), SystemCharset, InnerCharset));
                }
                _v32->edit = _v24->edit;
                _v32->mailcap = _v24;
            }
             *_a44 = _v32;
            return 1;
        }
    } else {
        flush_tty();
        if(fork() == 0) {
            setup_child(0, 0, ISfileno(uf.stream));
            _v76 =  *_v16;
             *__esp = uf.scheme;
            _v104 = uf.stream;
            _v100 = uf.ext;
            _v96 = uf.compression;
            _v92 = uf.content_encoding;
            _v88 = uf.guess_type;
            _v84 = uf.url;
            _v80 = uf.modtime;
            if(save2tmp() < 0) {
                exit(1);
            }
            if(ISclose(uf.stream) == 0) {
                uf.stream = 0;
            }
            myExec( *_v20);
        }
         *_a44 = 1;
        return 1;
    }
L26:
     *_a44 = 0;
    return 1;
}

int _MoveFile(char* path1, char* path2)
{// addr = 0x08071480
    InputStream f1;
    FILE* f2;
    int is_pipe;
    clen_t linelen;
    clen_t trbyte;
    Str buf;
    union input_stream* _v16;
    struct _IO_FILE* _v20;
    long long int _v24;
    struct _Str* _v28;
    long long int _v32;
    long long int _v36;
    long long int _v40;
    long long int _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    long long int _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t62;
    _unknown_ _t70;
    _unknown_ _t72;
    _unknown_ _t73;
    _unknown_ _t75;
    _unknown_ _t77;
    _unknown_ _t78;
    _unknown_ _t83;
    _unknown_ _t85;

    _v36 = 0;
    _v32 = 0;
    _v44 = 0;
    _v40 = 0;
    _v56 = 0;
     *__esp = path1;
    _v16 = newInputStream(open());
    if(_v16 == 0) {
        return -1;
    }
    if(( *path2 & 255 & 4294967295) != 124 || (PermitSaveToPipe & 255 & 4294967295) == 0) {
        _v24 = 0;
        _v20 = fopen(path2, "wb");
    } else {
        _v24 = 1;
        _v20 = popen( &(path2[1]), "w");
    }
    if(_v20 != 0) {
        current_content_length = 0;
         *135776436 = 0;
        _v28 = Strnew_size(1536);
L10:
        while(ISread(_v16, _v28, 1536) != 0) {
            goto L9;
        }
    } else {
        ISclose(_v16);
        return -1;
    }
L9:
    fwrite( *_v28, 1, _v28->length, _v20);
    asm("adc edx, ebx");
    _v36 = _v36 + _v28->length;
    _v32 = _v32;
    showProgress( &_v36,  &_v44);
    goto L10;
}

int _doFileCopy(char* tmpf, char* defstr, int download)
{// addr = 0x0807160F
    Str msg;
    Str filen;
    char* p;
    char* q;
    pid_t pid;
    char* lock;
    struct stat st;
    clen_t size;
    int is_pipe;
    struct _Str* _v32;
    struct _Str* _v36;
    char* _v40;
    char* _v44;
    int _v48;
    char* _v52;
    int _v56;
    signed int _v64;
    signed int _v68;
    long int _v92;
    signed int _v112;
    char _v156;
    signed int _v168;
    signed int _v172;
    struct _Str _v184;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t155;
    _unknown_ _t157;
    _unknown_ _t192;
    _unknown_ _t193;
    _unknown_ _t196;
    _unknown_ _t198;
    _unknown_ _t199;
    _unknown_ _t201;
    _unknown_ _t202;
    _unknown_ _t203;
    _unknown_ _t205;
    _unknown_ _t206;
    _unknown_ _t213;
    _unknown_ _t233;
    char* _t235;
    struct _Str* _t238;
    signed int _t243;
    _unknown_ _t248;
    _unknown_ _t249;
    char* _t251;
    _unknown_ _t254;
    _unknown_ _t258;
    struct _Str* _t268;
    struct _Str* _t271;
    _unknown_ _t276;
    _unknown_ _t277;

    _v44 = 0;
    _v68 = 0;
    _v64 = 0;
    _v56 = 0;
    if((fmInitialized & 255 & 4294967295) == 0) {
        _v44 = searchKeyData();
        if(_v44 == 0 || ( *_v44 & 255 & 4294967295) == 0) {
            printf("(Download)Save file to: ");
            fflush(__imp__stdout);
            _v36 = Strfgets(__imp__stdin);
            if(_v36->length == 0) {
                return -1;
            }
            _v44 =  *_v36;
        }
        _v40 = strlen(_v44) - 1 + _v44;
        while(( *( &MYCTYPE_MAP + ( *_v40 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v40 = _v40 - 1;
        }
    } else {
        _v40 = searchKeyData();
        if(_v40 == 0 || ( *_v40 & 255 & 4294967295) == 0) {
            _v44 = inputLineHistSearch("(Download)Save file to: ", defstr, 128, SaveHist, 0);
            if(_v44 == 0) {
                return 0;
            }
            if(( *_v44 & 255 & 4294967295) == 0) {
                return 0;
            }
            _v40 =  *(wc_Str_conv_strict(Strnew_charp(_v44), InnerCharset, SystemCharset));
        }
    }
    if(( *_v40 & 255 & 4294967295) != 124) {
L10:
        if(_v44 != 0) {
            _v40 =  *(unescape_spaces(Strnew_charp(_v44)));
            _v40 =  *(wc_Str_conv_strict(Strnew_charp(_v44), InnerCharset, SystemCharset));
        }
        _v40 = expandPath(_v40);
        if(checkOverWrite(_v40) < 0) {
            return -1;
        }
        goto L14;
    }
    if((PermitSaveToPipe & 255 & 4294967295) == 0) {
        goto L10;
    } else {
        _v56 = 1;
    }
L14:
    if(checkCopyFile(tmpf, _v40) < 0) {
        _t268 = wc_Str_conv(Strnew_charp(_v40), SystemCharset, InnerCharset);
        _t271 = wc_Str_conv(Strnew_charp(tmpf), SystemCharset, InnerCharset);
        _v184.length = _t268->ptr;
        _v184.ptr = _t271->ptr;
        _v32 = Sprintf("Can't copy. %s and %s are identical.");
        disp_err_message( *_v32, 0);
        return -1;
    }
    if(download == 0) {
        if(_MoveFile(tmpf, _v40) >= 0) {
            return -1;
        }
        _v184.ptr =  *(wc_Str_conv(Strnew_charp(_v40), SystemCharset, InnerCharset));
        _v32 = Sprintf("Can't save to %s");
        disp_err_message( *_v32, 0);
        return -1;
    }
    _v52 =  *(tmpfname(0, ".lock"));
    symlink(_v40, _v52);
    flush_tty();
    _v48 = fork();
    if(_v48 == 0) {
        setup_child(0, 0, -1);
        if(_MoveFile(tmpf, _v40) == 0 && (PreserveTimestamp & 255 & 4294967295) != 0 && _v56 == 0) {
            _t251 = tmpf;
            L080C7280(_t251,  &_v156);
            if(_t251 == 0) {
                setModtime(_v40, _v92);
            }
        }
        unlink(_v52);
        exit(0);
    }
    _t235 = tmpf;
    L080C7280(_t235,  &_v156);
    if(_t235 == 0) {
        _t243 = _v112;
        _v68 = _t243;
        _v64 = _t243 >> 31;
    }
    _t238 = wc_Str_conv(Strnew_charp(tmpf), SystemCharset, InnerCharset);
    _v172 = _v68;
    _v168 = _v64;
    _v184.area_size = _v52;
    _v184.length = _v40;
    _v184 = _t238->ptr;
     *__esp = _v48;
    addDownloadList();
    return 0;
}

int doFileMove(char* tmpf, char* defstr)
{// addr = 0x08071B71
    int ret;
    int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t12;

    _v16 = _doFileCopy(tmpf, defstr, 0);
    unlink(tmpf);
    return _v16;
}

int doFileSave(URLFile uf, char* defstr)
{// addr = 0x08071BA4
    Str msg;
    Str filen;
    char* p;
    char* q;
    pid_t pid;
    char* lock;
    char* tmpf;
    struct _Str* _v16;
    struct _Str* _v20;
    char* _v24;
    char* _v28;
    int _v32;
    char* _v36;
    int _v40;
    char* _v60;
    long int _v64;
    char* _v68;
    char* _v72;
    long long int _v76;
    int _v80;
    char* _v84;
    char* _v88;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t146;
    _unknown_ _t148;
    _unknown_ _t187;
    _unknown_ _t191;
    _unknown_ _t193;
    _unknown_ _t194;
    _unknown_ _t200;
    _unknown_ _t202;
    _unknown_ _t203;
    _unknown_ _t204;
    _unknown_ _t205;
    _unknown_ _t206;
    _unknown_ _t213;
    _unknown_ _t228;
    _unknown_ _t250;
    _unknown_ _t251;
    _unknown_ _t257;
    _unknown_ _t263;
    _unknown_ _t271;
    _unknown_ _t272;

    _v40 = 0;
    if((fmInitialized & 255 & 4294967295) == 0) {
L24:
        _v28 = searchKeyData();
        if(_v28 == 0 || ( *_v28 & 255 & 4294967295) == 0) {
            printf("(Download)Save file to: ");
            fflush(__imp__stdout);
            _v20 = Strfgets(__imp__stdin);
            if(_v20->length == 0) {
                return -1;
            }
            _v28 =  *_v20;
        }
        _v24 = strlen(_v28) - 1 + _v28;
        while(( *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v24 = _v24 - 1;
        }
    } else {
        _v24 = searchKeyData();
        if(_v24 == 0 || ( *_v24 & 255 & 4294967295) == 0) {
            _v24 = inputLineHistSearch("(Download)Save file to: ", _a36, 32, SaveHist, 0);
            if(_v24 == 0) {
                return -1;
            }
            if(( *_v24 & 255 & 4294967295) == 0) {
                return -1;
            }
            _v24 =  *(wc_Str_conv_strict(Strnew_charp(_v24), InnerCharset, SystemCharset));
        }
        if(checkOverWrite(_v24) < 0) {
            return -1;
        }
        if(checkSaveFile(uf.stream, _v24) < 0) {
            _v88 =  *(wc_Str_conv(Strnew_charp(_v24), SystemCharset, InnerCharset));
            _v16 = Sprintf("Can't save. Load file and %s are identical.");
            disp_err_message( *_v16, 0);
            return -1;
        }
        _v36 =  *(tmpfname(0, ".lock"));
        symlink(_v24, _v36);
        flush_tty();
        _v32 = fork();
        if(_v32 != 0) {
L23:
            _v76 = current_content_length;
            _v72 =  *135776436;
            _v80 = _v36;
            _v84 = _v24;
            _v88 = uf.url;
             *__esp = _v32;
            addDownloadList();
            return 0;
        } else {
            if(uf.content_encoding != 0 && (AutoUncompress & 255 & 4294967295) != 0) {
                uncompress_stream( &(uf.scheme),  &_v40);
                if(_v40 != 0) {
                    unlink(_v40);
                }
            }
            setup_child(0, 0, ISfileno(uf.stream));
            _v60 = _v24;
             *__esp = uf.scheme;
            _v88 = uf.stream;
            _v84 = uf.ext;
            _v80 = uf.compression;
            _v76 = uf.content_encoding;
            _v72 = uf.guess_type;
            _v68 = uf.url;
            _v64 = uf.modtime;
            if(save2tmp() == 0 && (PreserveTimestamp & 255 & 4294967295) != 0 && uf.modtime != 255) {
                setModtime(_v24, uf.modtime);
            }
            if(ISclose(uf.stream) == 0) {
                uf.stream = 0;
            }
            unlink(_v36);
            exit(0);
            goto L23;
        }
        goto L24;
    }
}

int checkCopyFile(char* path1, char* path2)
{// addr = 0x0807201D
    struct stat st1;
    struct stat st2;
    intOrPtr _v88;
    char _v100;
    intOrPtr _v176;
    char _v188;
    _unknown_ _v200;
    _unknown_ __ebp;
    char* _t14;
    _unknown_ _t15;
    char* _t16;
    _unknown_ _t18;
    _unknown_ _t20;

    if(( *path2 & 255 & 4294967295) == 124) {
        if((PermitSaveToPipe & 255 & 4294967295) != 0) {
            return 0;
        }
    }
    _t14 = path1;
    L080C7280(_t14,  &_v100);
    if(_t14 != 0) {
        return 0;
    }
    _t16 = path2;
    L080C7280(_t16,  &_v188);
    if(_t16 != 0) {
        return 0;
    }
    if(_v88 != _v176) {
        return 0;
    }
    return -1;
}

int checkSaveFile(InputStream stream, char* path2)
{// addr = 0x0807208C
    struct stat st1;
    struct stat st2;
    int des;
    int _v16;
    intOrPtr _v92;
    char _v104;
    intOrPtr _v180;
    char _v192;
    char* _v216;
    _unknown_ __ebp;
    int _t20;
    _unknown_ _t21;
    char* _t22;
    _unknown_ _t24;
    _unknown_ _t26;
    _unknown_ _t27;

    _v16 = ISfileno(stream);
    if(_v16 < 0) {
        return 0;
    }
    if(( *path2 & 255 & 4294967295) == 124) {
        if((PermitSaveToPipe & 255 & 4294967295) != 0) {
            return 0;
        }
    }
    _v216 =  &_v104;
    _t20 = _v16;
     *__esp = _t20;
    L080C72C0();
    if(_t20 != 0) {
        return 0;
    }
    _t22 = path2;
    L080C7280(_t22,  &_v192);
    if(_t22 != 0) {
        return 0;
    }
    if(_v92 != _v180) {
        return 0;
    }
    return -1;
}

int checkOverWrite(char* path)
{// addr = 0x08072116
    struct stat st;
    char* ans;
    char* _v16;
    char _v104;
    _unknown_ _v120;
    _unknown_ __ebp;
    char* _t14;
    _unknown_ _t16;
    _unknown_ _t25;
    _unknown_ _t29;

    _t14 = path;
    L080C7280(_t14,  &_v104);
    if(_t14 < 0) {
        return 0;
    }
    _v16 = inputAnswer("File exists. Overwrite? (y/n)");
    if(_v16 == 0) {
        return -1;
    }
    if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
        if(( *_v16 & 255 & 4294967295) != 121) {
            return -1;
        }
        return 0;
    } else {
        if((( *_v16 & 255 | 32) & 4294967295) == 121) {
            return 0;
        }
        return -1;
    }
    return 0;
}

char* inputAnswer(char* prompt)
{// addr = 0x0807218F
    char* ans;
    char* _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    char* _v56;
    _unknown_ __ebp;
    _unknown_ _t16;
    _unknown_ _t18;

    if((QuietMessage & 255 & 4294967295) != 0) {
        return (char*)("n");
    }
    if((fmInitialized & 255 & 4294967295) == 0) {
        _v56 = prompt;
        printf("%s");
        fflush(__imp__stdout);
        _v16 =  *(Strfgets(__imp__stdin));
        return _v16;
    }
    term_raw();
    _v16 = inputLineHistSearch(prompt, 135041709, 512, 0, 0);
    return _v16;
}

uncompress_stream(URLFile* uf, char** src)
{// addr = 0x0807221F
    pid_t pid1;
    FILE* f1;
    char* expand_cmd;
    char* expand_name;
    char* tmpf;
    char* ext;
    struct compression_decoder* d;
    pid_t pid2;
    FILE* f2;
    Str buf;
    FILE* f;
    int _v16;
    intOrPtr _v20;
    char* _v24;
    char* _v28;
    char* _v32;
    char* _v36;
    struct compression_decoder[4]* _v40;
    int _v44;
    FILE* _v48;
    struct _Str* _v52;
    struct _IO_FILE* _v56;
    _unknown_ _v64;
    FILE** _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t153;
    _unknown_ _t156;
    _unknown_ _t157;
    _unknown_ _t172;
    _unknown_ _t177;
    _unknown_ _t181;
    _unknown_ _t183;
    _unknown_ _t185;
    _unknown_ _t190;
    _unknown_ _t192;
    _unknown_ _t198;
    _unknown_ _t231;

    _v24 = "gunzip";
    _v28 = "gunzip";
    _v32 = 0;
    _v36 = 0;
    if(( *(uf + 4)->base.stream.cur & 255 & 4294967295) != 4) {
         *(uf + 4) = newEncodedStream( *(uf + 4), uf->encoding & 255 & 4294967295);
        uf->encoding = 0;
    }
    _v40 =  &compression_decoders;
    while( *_v40 != 0) {
        if(uf->compression !=  *_v40) {
            _v40 = _v40 + 44;
            continue;
        } else {
            if( *((intOrPtr*)(_v40 + 12)) == 0) {
                _v24 =  *(_v40 + 16);
            } else {
                _v24 = auxbinFile( *(_v40 + 16));
            }
        }
        _v28 =  *(_v40 + 20);
        _v36 =  *(_v40 + 4);
        uf->compression = 0;
        if((uf->scheme & 255 & 4294967295) != 4 && image_source == 0) {
            _v32 =  *(tmpfname(0, _v36));
        }
        _v16 = open_pipe_rw( &_v20, 0);
        if(_v16 >= 0) {
            if(_v16 != 0) {
L34:
                if(_v32 != 0) {
                    if(src == 0) {
                        uf->scheme = 4;
                    } else {
                         *src = _v32;
                    }
                }
                UFhalfclose(uf);
                 *(uf + 4) = newFileStream(_v20, fclose);
                return;
            }
        } else {
            if(ISclose( *(uf + 4)) != 0) {
                return ;
            }
             *(uf + 4) = 0;
            return;
        }
L17:
        _v48 = __imp__stdin;
        _v44 = open_pipe_rw( &_v48, 0);
        if(_v44 < 0) {
            if(ISclose( *(uf + 4)) == 0) {
                 *(uf + 4) = 0;
            }
            exit(1);
        }
        if(_v44 != 0) {
            dup2(1, 2);
            setup_child(1, -1, -1);
            _v68 = 0;
            execlp(_v24, _v28);
            exit(1);
        } else {
            _v52 = Strnew_size(1536);
            _v56 = 0;
            setup_child(1, 2, ISfileno( *(uf + 4)));
            if(_v32 != 0) {
                _v56 = fopen(_v32, "wb");
            }
            while(ISread( *(uf + 4), _v52, 1536) != 0) {
                fwrite( *_v52, 1, _v52->length, __imp__stdout);
                if(_v56 != 0) {
                    fwrite( *_v52, 1, _v52->length, _v56);
                }
            }
        }
        goto L34;
    }
}

FILE* lessopen_stream(char* path)
{// addr = 0x08072573
    char* lessopen;
    FILE* fp;
    Str tmpf;
    int c;
    char* _v16;
    FILE* _v20;
    struct _Str* _v24;
    int _v28;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t26;
    int _t40;
    _unknown_ _t43;
    _unknown_ _t45;
    _unknown_ _t46;
    _unknown_ _t47;
    _unknown_ _t48;
    _unknown_ _t49;

    _v16 = getenv("LESSOPEN");
    if(_v16 == 0) {
        return 0;
    }
    if(( *_v16 & 255 & 4294967295) == 0) {
        return 0;
    }
    if(( *_v16 & 255 & 4294967295) != 124) {
L10:
        _v20 = 0;
        return _v20;
    } else {
        _v16 =  &(_v16[1]);
        _v40 = shell_quote(path);
        _v24 = Sprintf(_v16);
        _v20 = popen( *_v24, "r");
        if(_v20 == 0) {
            return 0;
        }
        _t40 = _v20;
         *__esp = _t40;
        _IO_getc();
        _v28 = _t40;
        if(_v28 != 255) {
            ungetc(_v28, _v20);
            return _v20;
        } else {
            fclose(_v20);
            return 0;
        }
        goto L10;
    }
}

char* guess_filename(char* file)
{// addr = 0x08072646
    char* p;
    char* s;
    char* _v16;
    char* _v20;
    _unknown_ __ebp;

    _v16 = 0;
    if(file != 0) {
        _v16 = mybasename(file);
    }
    if(_v16 == 0) {
        return (char*)("index.html");
    }
    if(( *_v16 & 255 & 4294967295) == 0) {
        return (char*)("index.html");
    }
    _v20 = _v16;
    if(( *_v16 & 255 & 4294967295) == 35) {
        _v16 =  &(_v16[1]);
    }
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *_v16 & 255 & 4294967295) != 35 || (_v16[1] & 255 & 4294967295) == 0) {
            if(( *_v16 & 255 & 4294967295) != 63) {
                _v16 =  &(_v16[1]);
                continue;
            }
            goto L10;
            return _v20;
        }
L10:
         *_v16 = 0;
        return _v20;
    }
}

char* guess_save_name(Buffer* buf, char* path)
{// addr = 0x080726D3
    Str name;
    char* p;
    char* q;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    _unknown_ _v32;
    _unknown_ _v36;
    char* _v40;
    _unknown_ __ebp;
    char* _t60;
    char* _t77;

    if(buf == 0) {
        return guess_filename(path);
    }
    if(buf->document_header == 0) {
        return guess_filename(path);
    }
    _v16 = 0;
    _v20 = checkHeader(buf, "Content-Disposition:");
    if(_v20 != 0) {
        _v40 = "filename";
        _t77 = _v20;
         *__esp = _t77;
        strcasestr();
        _v24 = _t77;
        if(_v24 != 0) {
            if(_v24 == _v20 || ( *( &MYCTYPE_MAP + ( *(_v24 - 1) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0 || ( *(_v24 - 1) & 255 & 4294967295) == 59) {
                if(matchattr(_v24, "filename", 8,  &_v16) != 0) {
                    path =  *_v16;
                    return guess_filename(path);
                }
            }
        }
    }
    _v20 = checkHeader(buf, "Content-Type:");
    if(_v20 == 0) {
        return guess_filename(path);
    }
    _v40 = "name";
    _t60 = _v20;
     *__esp = _t60;
    strcasestr();
    _v24 = _t60;
    if(_v24 == 0) {
        return guess_filename(path);
    }
    if(_v24 != _v20) {
        if(( *( &MYCTYPE_MAP + ( *(_v24 - 1) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
            if(( *(_v24 - 1) & 255 & 4294967295) != 59) {
                return guess_filename(path);
            }
        }
    }
    if(matchattr(_v24, "name", 4,  &_v16) == 0) {
        return guess_filename(path);
    }
    path =  *_v16;
    return guess_filename(path);
}

Buffer* newBuffer(int width)
{// addr = 0x08072844
    Buffer* n;
    int* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t37;
    int* _t49;
    _unknown_ _t56;

     *__esp = 260;
    GC_malloc();
    _v16 = __eax;
    if(_v16 == 0) {
        return 0;
    }
    bzero(_v16, 260);
    _v16->width = width & 4294967295;
    _v16->COLS = COLS & 4294967295;
    _v16->LINES = LINES - 1 & 4294967295;
    _v16[0x21] = 255;
    _v16->baseURL = 0;
    _v16->baseTarget = 0;
    _v16->buffername = 135048112;
    _t49 = _v16;
    _t49[0x10] = 0;
     *__esp = 4;
    GC_malloc();
    _v16->clone = _t49;
    _v16 = 1;
    _v16[0x32] = 0;
    _v16[0x35] = WcOption.marks & 255 & 4294967295;
    return _v16;
}

Buffer* nullBuffer()
{// addr = 0x08072929
    Buffer* b;
    Buffer* _v16;
    _unknown_ __ebp;

    _v16 = newBuffer(COLS);
    _v16->buffername = "*Null*";
    return _v16;
}

clearBuffer(Buffer* buf)
{// addr = 0x0807294E
    _unknown_ __ebp;

    buf->lastLine = 0;
    buf->currentLine = buf->lastLine;
    buf->topLine = buf->currentLine;
    buf->firstLine = buf->topLine;
    buf->allLine = 0;
    return;
}

discardBuffer(Buffer* buf)
{// addr = 0x0807298B
    int i;
    Buffer* b;
    intOrPtr _v16;
    _unknown_ _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t69;
    _unknown_ _t81;
    _unknown_ _t91;
    _unknown_ _t98;
    _unknown_ _t107;
    _unknown_ _t110;

    deleteImage(buf);
    clearBuffer(buf);
    _v16 = 0;
    while(_v16 <= 4) {
        _v16 = _v16 + 1;
    }
}

Buffer* namedBuffer(Buffer* first, char* name)
{// addr = 0x08072B1F
    Buffer* buf;
    struct _Buffer* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t34;

    if(strcmp(first->buffername, name) == 0) {
        return first;
    }
    _v16 = first;
    while(_v16->nextBuffer != 0) {
        if(strcmp(_v16->nextBuffer->buffername, name) == 0) {
            return _v16->nextBuffer;
        }
        _v16 = _v16->nextBuffer;
    }
}

Buffer* deleteBuffer(Buffer* first, Buffer* delbuf)
{// addr = 0x08072B89
    Buffer* buf;
    Buffer* b;
    Buffer* _v16;
    struct _Buffer* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(first == delbuf && first->nextBuffer != 0) {
        _v16 = first->nextBuffer;
        discardBuffer(first);
        return _v16;
    }
    _v16 = prevBuffer(first, delbuf);
    if(_v16 == 0) {
        return first;
    }
    _v20 = _v16->nextBuffer;
    _v16->nextBuffer = _v20->nextBuffer;
    discardBuffer(_v20);
    return first;
}

Buffer* replaceBuffer(Buffer* first, Buffer* delbuf, Buffer* newbuf)
{// addr = 0x08072BFA
    Buffer* buf;
    Buffer* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(delbuf != 0) {
        if(first != delbuf) {
            if(delbuf == 0) {
L7:
                newbuf->nextBuffer = first;
                return newbuf;
            }
            goto L5;
            return __eax;
        }
        goto L3;
L5:
        _v16 = prevBuffer(first, delbuf);
        if(_v16 == 0) {
            goto L7;
        }
        _v16->nextBuffer = newbuf;
        newbuf->nextBuffer = delbuf->nextBuffer;
        discardBuffer(delbuf);
        return first;
    }
    newbuf->nextBuffer = first;
    return newbuf;
L3:
    newbuf->nextBuffer = delbuf->nextBuffer;
    discardBuffer(delbuf);
    return newbuf;
}

Buffer* nthBuffer(Buffer* firstbuf, int n)
{// addr = 0x08072C8C
    int i;
    Buffer* buf;
    intOrPtr _v8;
    struct _Buffer* _v12;
    _unknown_ __ebp;
    _unknown_ _t19;

    _v12 = firstbuf;
    if(n < 0) {
        return firstbuf;
    }
    _v8 = 0;
    while(_v8 < n) {
        if(_v12 == 0) {
            return 0;
        }
        _v12 = _v12->nextBuffer;
        _v8 = _v8 + 1;
    }
}

writeBufferName(Buffer* buf, int n)
{// addr = 0x08072CD3
    Str msg;
    int all;
    struct _Str* _v16;
    long int _v20;
    long int _v36;
    char* _v40;
    _unknown_ __ebp;
    struct _ParsedURL _t83;
    int _t90;
    int _t110;

    _v20 = buf->allLine;
    if(_v20 == 0 && buf->lastLine != 0) {
        _v20 = buf->lastLine->linenumber;
    }
    move(n, 0);
    _v36 = _v20;
    _v40 = buf->buffername;
    _v16 = Sprintf("<%s> [%d lines]");
    if(buf->filename == 0) {
L16:
        addnstr_sup( *_v16, COLS - 1);
        return;
    }
    _t83 =  *(buf + 132);
    if(_t83 < 4) {
L12:
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t90 = _v16->length;
         *((char*)( *_v16 + _t90)) = 32;
        _v16->length = _t90 + 1;
         *( *_v16 + _v16->length) = 0;
        Strcat(_v16, parsedURL2Str(buf + 132));
        goto L16;
    }
    if(_t83 <= 5) {
        if(strcmp( *(buf + 152), "-") != 0) {
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t110 = _v16->length;
             *((char*)( *_v16 + _t110)) = 32;
            _v16->length = _t110 + 1;
             *( *_v16 + _v16->length) = 0;
            Strcat_charp(_v16,  *(wc_Str_conv(Strnew_charp( *(buf + 156)), SystemCharset, InnerCharset)));
        }
        goto L16;
    }
    if(_t83 - 254 > 1) {
        goto L12;
    }
    goto L16;
}

gotoLine(Buffer* buf, int n)
{// addr = 0x08072EA3
    char[31] msg;
    Line* l;
    signed int _v16;
    char _v48;
    Line* _v52;
    Buffer* _v64;
    _unknown_ _v80;
    long int _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    _unknown_ _t105;
    signed int _t109;
    _unknown_ _t144;
    _unknown_ _t156;
    _unknown_ _t177;
    _unknown_ _t187;
    _unknown_ _t200;

    _v64 = buf;
    _v16 =  *gs:0x14];
    _v52 = _v64->firstLine;
    if(_v52 == 0) {
        goto L20;
    }
    if( *((intOrPtr*)(_v64 + 92)) == 0) {
L7:
        _t200 = _v52->linenumber - n;
        if(_t200 <= 0) {
            if(_v64->lastLine->linenumber >= n) {
                while(_v52 != 0) {
                    if(_v52->linenumber < n) {
                        _v52 = _v52->next;
                        continue;
                    }
                    _v64->currentLine = _v52;
                    if(_v64->topLine->linenumber > n) {
L14:
                        asm("cwde ");
                        _v64->topLine = lineSkip(_v64, _v52, ( !(_v64->LINES & 65535) >> 31) +  !(_v64->LINES & 65535) >> 1, 0);
                        goto L20;
                    }
                    asm("cwde ");
                    if(_v64->topLine->linenumber + (_v64->LINES & 65535) > n) {
                        goto L19;
                    }
                    goto L14;
L20:
                    _t109 = _v16 ^  *gs:0x14];
                    if(_t200 == 0) {
                        return _t109;
                    }
                    __stack_chk_fail();
                    return _t109;
                }
            }
            goto L10;
        }
        goto L8;
L10:
        _v52 = _v64->lastLine;
        _v84 = _v64->lastLine->linenumber;
        sprintf( &_v48, "Last line is #%ld");
        set_delayed_message( &_v48);
        _v64->currentLine = _v52;
        asm("cwde ");
        _v64->topLine = lineSkip(_v64, _v64->currentLine, 1 - (_v64->LINES & 65535), 0);
        goto L20;
    }
    asm("cwde ");
    if((_v64->bufferprop & 65535 & 64) != 0) {
        goto L7;
    } else {
        if(_v64->lastLine->linenumber < n) {
            getNextPage(_v64, n - _v64->lastLine->linenumber);
        }
        while(_v64->lastLine->linenumber < n && getNextPage(_v64, 1) != 0) {
        }
    }
L8:
    _v84 = _v52->linenumber;
    sprintf( &_v48, "First line is #%ld");
    set_delayed_message( &_v48);
    _v64->currentLine = _v52;
    _v64->topLine = _v64->currentLine;
    goto L20;
L19:
    goto L20;
}

gotoRealLine(Buffer* buf, int n)
{// addr = 0x080730B4
    char[31] msg;
    Line* l;
    signed int _v16;
    char _v48;
    Line* _v52;
    Buffer* _v64;
    _unknown_ _v80;
    long int _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    _unknown_ _t105;
    signed int _t109;
    _unknown_ _t144;
    _unknown_ _t156;
    _unknown_ _t177;
    _unknown_ _t187;
    _unknown_ _t200;

    _v64 = buf;
    _v16 =  *gs:0x14];
    _v52 = _v64->firstLine;
    if(_v52 == 0) {
        goto L20;
    }
    if( *((intOrPtr*)(_v64 + 92)) == 0) {
L7:
        _t200 = _v52->real_linenumber - n;
        if(_t200 <= 0) {
            if(_v64->lastLine->real_linenumber >= n) {
                while(_v52 != 0) {
                    if(_v52->real_linenumber < n) {
                        _v52 = _v52->next;
                        continue;
                    }
                    _v64->currentLine = _v52;
                    if(_v64->topLine->real_linenumber > n) {
L14:
                        asm("cwde ");
                        _v64->topLine = lineSkip(_v64, _v52, ( !(_v64->LINES & 65535) >> 31) +  !(_v64->LINES & 65535) >> 1, 0);
                        goto L20;
                    }
                    asm("cwde ");
                    if(_v64->topLine->real_linenumber + (_v64->LINES & 65535) > n) {
                        goto L19;
                    }
                    goto L14;
L20:
                    _t109 = _v16 ^  *gs:0x14];
                    if(_t200 == 0) {
                        return _t109;
                    }
                    __stack_chk_fail();
                    return _t109;
                }
            }
            goto L10;
        }
        goto L8;
L10:
        _v52 = _v64->lastLine;
        _v84 = _v64->lastLine->real_linenumber;
        sprintf( &_v48, "Last line is #%ld");
        set_delayed_message( &_v48);
        _v64->currentLine = _v52;
        asm("cwde ");
        _v64->topLine = lineSkip(_v64, _v64->currentLine, 1 - (_v64->LINES & 65535), 0);
        goto L20;
    }
    asm("cwde ");
    if((_v64->bufferprop & 65535 & 64) != 0) {
        goto L7;
    } else {
        if(_v64->lastLine->real_linenumber < n) {
            getNextPage(_v64, n - _v64->lastLine->real_linenumber);
        }
        while(_v64->lastLine->real_linenumber < n && getNextPage(_v64, 1) != 0) {
        }
    }
L8:
    _v84 = _v52->real_linenumber;
    sprintf( &_v48, "First line is #%ld");
    set_delayed_message( &_v48);
    _v64->currentLine = _v52;
    _v64->topLine = _v64->currentLine;
    goto L20;
L19:
    goto L20;
}

Buffer* listBuffer(Buffer* top, Buffer* current)
{// addr = 0x080732C5
    int i;
    int c;
    Buffer* buf;
    int _v16;
    int _v20;
    struct _Buffer* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v20 = 0;
    _v24 = top;
    move(0, 0);
    if(useColor != 0) {
        setfcolor(basic_color);
        setbcolor(bg_color);
    }
    clrtobotx();
    _v16 = 0;
    while(LINES - 1 > _v16) {
        if(_v24 == current) {
            _v20 = _v16;
            standout();
        }
        writeBufferName(_v24, _v16);
        if(_v24 != current) {
            clrtoeolx();
        } else {
            standend();
            clrtoeolx();
            move(_v16, 0);
            toggle_stand();
        }
        if(_v24->nextBuffer != 0) {
            _v24 = _v24->nextBuffer;
            _v16 = _v16 + 1;
            continue;
        }
        move(_v16 + 1, 0);
        clrtobotx();
        standout();
        message("Buffer selection mode: SPC for select / D for delete buffer", 0, 0);
        standend();
        move(_v20, 0);
        refresh();
        return _v24->nextBuffer;
    }
}

Buffer* selectBuffer(Buffer* firstbuf, Buffer* currentbuf, char* selectchar)
{// addr = 0x08073401
    int i;
    int cpoint;
    int spoint;
    int maxbuf;
    int sclimit;
    Buffer* buf;
    Buffer* topbuf;
    char c;
    _unknown_ _v13;
    intOrPtr _v20;
    intOrPtr _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    intOrPtr _v36;
    Buffer* _v40;
    _unknown_ _v44;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t141;
    _unknown_ _t143;
    _unknown_ _t156;
    _unknown_ _t175;
    _unknown_ _t189;

    _v36 = LINES - 1;
    _v24 = 0;
    _v20 = _v24;
    _v40 = firstbuf;
    while() {
    }
}

reshapeBuffer(Buffer* buf)
{// addr = 0x080736FB
    URLFile f;
    Buffer sbuf;
    wc_uint8 old_auto_detect;
    URLFile h;
    Line* cur;
    int n;
    signed int _v13;
    _unknown_ _v20;
    _unknown_ _v24;
    intOrPtr _v52;
    struct  _v56;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ _v240;
    _unknown_ _v272;
    _unknown_ _v280;
    _unknown_ _v332;
    _unknown_ _v336;
    _unknown_ _v340;
    struct _Buffer _v348;
    _unknown_ _v352;
    _unknown_ _v356;
    _unknown_ _v360;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t206;
    _unknown_ _t207;
    char* _t216;
    _unknown_ _t246;
    _unknown_ _t265;
    _unknown_ _t328;
    int _t360;
    _unknown_ _t361;
    _unknown_ _t391;
    _unknown_ _t394;

    _v13 = WcOption.marks & 255 & 4294967295;
    if((buf->need_reshape & 255 & 4294967295) == 0) {
        return ;
    }
    buf->need_reshape = 0;
    _t360 = COLS;
    if(showLineNum == 0) {
        _t206 = 1;
    } else {
        _t206 = 6;
    }
    _t207 = _t360 - _t206;
    _t208 = _t207 >= 0 ? 0 : _t207;
    _t362 = _t207 >= 0 ? 0 : _t207;
    buf->width = (_t207 >= 0 ? 0 : _t207) & 4294967295;
    if(buf->sourcefile == 0) {
        return ;
    }
    init_stream( &_v56, 4, 0);
    if(buf->mailcap_source == 0) {
        _t216 = buf->sourcefile;
    } else {
        _t216 = buf->mailcap_source;
    }
    examineFile(_t216,  &_v56);
    if(_v52 == 0) {
        return ;
    }
    copyBuffer( &_v348, buf);
    clearBuffer(buf);
    while() {
    }
}

copyBuffer(Buffer* a, Buffer* b)
{// addr = 0x08073C16
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t10;

    readBufferCache(b);
    bcopy(b, a, 260);
    return;
}

Buffer* prevBuffer(Buffer* first, Buffer* buf)
{// addr = 0x08073C43
    Buffer* b;
    struct _Buffer* _v8;
    _unknown_ __ebp;

    _v8 = first;
    while(_v8 != 0) {
        if(_v8->nextBuffer == buf) {
            return _v8;
        }
        _v8 = _v8->nextBuffer;
    }
}

int writeBufferCache(Buffer* buf)
{// addr = 0x08073C70
    Str tmp;
    FILE* cache;
    Line* l;
    int colorflag;
    struct _Str* _v16;
    struct _IO_FILE* _v20;
    Line* _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t134;
    _unknown_ _t146;
    _unknown_ _t149;
    _unknown_ _t189;
    _unknown_ _t190;
    _unknown_ _t208;

    _v20 = 0;
    if(buf->savecache != 0) {
        return -1;
    }
    if(buf->firstLine == 0) {
L27:
L29:
        buf->savecache = 0;
        return -1;
    } else {
        _v16 = tmpfname(3, 0);
        buf->savecache =  *_v16;
        _v20 = fopen(buf->savecache, "w");
        if(_v20 == 0) {
            goto L29;
        }
        if(fwrite( &(buf->currentLine->linenumber), 4, 1, _v20) == 0) {
L26:
            fclose(_v20);
            unlink(buf->savecache);
            goto L29;
        }
        if(fwrite( &(buf->topLine->linenumber), 4, 1, _v20) == 0) {
            goto L26;
        } else {
            _v24 = buf->firstLine;
            while() {
            }
        }
        goto L27;
    }
    return __eax;
}

int readBufferCache(Buffer* buf)
{// addr = 0x08073FE8
    FILE* cache;
    Line* l;
    Line* prevl;
    Line* basel;
    long int lnum;
    long int clnum;
    long int tlnum;
    int colorflag;
    int _v16;
    int _v20;
    int _v24;
    int _v28;
    int _v32;
    int _v36;
    int _v40;
    int _v44;
    int _v48;
    int _v52;
    int _v56;
    _unknown_ __ebp;
    _unknown_ _t181;
    _unknown_ _t188;

    _v20 = 0;
    _v24 = 0;
    _v28 = 0;
    _v32 = 0;
    if(buf->savecache == 0) {
        return -1;
    }
    __edx = "r";
    _v16 = fopen(buf->savecache, "r");
    if(_v16 == 0 || fread( &_v36, 4, 1, _v16) == 0 || fread( &_v40, 4, 1, _v16) == 0) {
        buf->savecache = 0;
        return -1;
    }
    while(1) {
        _v16 = feof(_v16);
        if(_v16 != 0) {
            break;
        }
        _v32 = _v32 + 1;
        __eax = _v20;
        _v24 = __eax;
         *__esp = 52;
        GC_malloc();
        _v20 = __eax;
        __eax = _v20;
        __edx = _v24;
         *(_v20 + 16) = _v24;
        if(_v24 == 0) {
            __eax = buf;
            __edx = _v20;
            buf->firstLine = _v20;
        } else {
            __eax = _v24;
            __edx = _v20;
            _v24->next = _v20;
        }
        __eax = _v20;
        __edx = _v32;
         *(_v20 + 28) = _v32;
        __eax = _v36;
        if(_v32 == _v36) {
            __eax = buf;
            __edx = _v20;
            buf->currentLine = _v20;
        }
        __eax = _v40;
        if(_v32 == _v40) {
            __eax = buf;
            __edx = _v20;
            buf->topLine = _v20;
        }
        __eax = _v20;
        __edx = _v20 + 32;
        _v16 = fread(_v20 + 32, 4, 1, _v16);
        if(_v16 == 0) {
L35:
            __eax = buf;
            __edx = _v24;
            buf->lastLine = _v24;
            buf = buf->lastLine;
            buf->lastLine->next = 0;
            _v16 = fclose(_v16);
            buf = buf->savecache;
            unlink(buf->savecache) = buf;
            buf->savecache = 0;
            __eax = 0;
            return 0;
        } else {
            __eax = _v20;
            __edx = _v20 + 36;
            _v16 = fread(_v20 + 36, 2, 1, _v16);
            if(_v16 == 0) {
                goto L35;
            }
            __eax = _v20;
            __edx = _v20 + 24;
            _v16 = fread(_v20 + 24, 4, 1, _v16);
            if(_v16 == 0) {
                goto L35;
            }
            __eax = _v20;
            __edx = _v20 + 20;
            _v16 = fread(_v20 + 20, 4, 1, _v16);
            if(_v16 == 0) {
                goto L35;
            }
            __eax = _v20;
            __edx = _v20 + 40;
            _v16 = fread(_v20 + 40, 4, 1, _v16);
            if(_v16 == 0) {
                goto L35;
            }
            __eax = _v20;
            __edx = _v20 + 44;
            _v16 = fread(_v20 + 44, 4, 1, _v16);
            if(_v16 == 0) {
                goto L35;
            }
            __eax = _v20;
            __edx = _v20 + 48;
            _v16 = fread(_v20 + 48, 4, 1, _v16);
            if(_v16 == 0) {
                goto L35;
            }
            _v20 =  *(_v20 + 44);
            if( *(_v20 + 44) != 0) {
                if(_v28 == 0) {
                    goto L35;
                }
                goto L23;
            }
            __eax = _v20;
            _v28 = _v20;
            _v20 =  *(_v20 + 40);
            __eax =  *(_v20 + 40) + 1;
             *__esp = __eax;
            GC_malloc_atomic();
            __edx = __eax;
            __eax = _v20;
             *_v20 = __edx;
            _v20 =  *(_v20 + 40);
            __edx =  *(_v20 + 40);
            _v20 =  *_v20;
            fread( *_v20, 1,  *(_v20 + 40), _v16) = _v20;
            __edx =  *_v20;
            _v20 =  *(_v20 + 40);
            __eax =  *_v20 +  *(_v20 + 40);
             *( *_v20 +  *(_v20 + 40)) = 0;
            __eax = _v20;
            __eax =  *(_v20 + 40);
            __eax =  *(_v20 + 40) +  *(_v20 + 40);
             *__esp = __eax;
            GC_malloc_atomic();
            __edx = __eax;
            __eax = _v20;
             *(_v20 + 4) = __edx;
            _v20 =  *(_v20 + 40);
            __edx =  *(_v20 + 40);
            _v20 =  *(_v20 + 4);
            __eax = fread( *(_v20 + 4), 2,  *(_v20 + 40), _v16);
L24:
            __eax = _v16;
            _v48 = _v16;
            _v52 = 1;
            _v56 = 4;
            __eax =  &_v44;
             *__esp =  &_v44;
            __eax = fread();
            if( &_v44 == 0) {
                goto L35;
            }
            __eax = _v44;
            if(_v44 == 0) {
                __eax = _v20;
                 *(_v20 + 8) = 0;
            } else {
                _v20 =  *(_v20 + 44);
                if( *(_v20 + 44) != 0) {
                    __eax = _v28;
                    __edx =  *(_v28 + 8);
                    _v20 =  *(_v20 + 44);
                    __edx =  *(_v28 + 8) +  *(_v20 + 44);
                    __eax = _v20;
                     *(_v20 + 8) =  *(_v28 + 8) +  *(_v20 + 44);
                } else {
                    __eax = _v20;
                    __eax =  *(_v20 + 40);
                     *__esp = __eax;
                    GC_malloc_atomic();
                    __edx = __eax;
                    __eax = _v20;
                     *(_v20 + 8) = __edx;
                    _v20 =  *(_v20 + 40);
                    __edx =  *(_v20 + 40);
                    _v20 =  *(_v20 + 8);
                    __eax = fread( *(_v20 + 8), 1,  *(_v20 + 40), _v16);
                }
            }
            continue;
L23:
            __eax = _v28;
            __edx =  *_v28;
            _v20 =  *(_v20 + 44);
            __edx =  *_v28 +  *(_v20 + 44);
            __eax = _v20;
             *_v20 =  *_v28 +  *(_v20 + 44);
            __eax = _v28;
            __edx =  *(_v28 + 4);
            __eax = _v20;
            __eax =  *(_v20 + 44);
            __eax =  *(_v20 + 44) +  *(_v20 + 44);
            __edx =  *(_v28 + 4) +  *(_v20 + 44) +  *(_v20 + 44);
            __eax = _v20;
             *(_v20 + 4) =  *(_v28 + 4) +  *(_v20 + 44) +  *(_v20 + 44);
            goto L24;
        }
        return __eax;
    }
    goto L35;
}

effect_anchor_start()
{// addr = 0x08074428
    _unknown_ __ebp;

    if(useColor == 0) {
        underline();
        return;
    }
    setfcolor(anchor_color);
    return;
}

effect_anchor_end()
{// addr = 0x0807444D
    _unknown_ __ebp;

    if(useColor == 0) {
        underlineend();
        return;
    }
    setfcolor(basic_color);
    return;
}

effect_image_start()
{// addr = 0x08074472
    _unknown_ __ebp;

    if(useColor == 0) {
        standout();
        return;
    }
    setfcolor(image_color);
    return;
}

effect_image_end()
{// addr = 0x08074497
    _unknown_ __ebp;

    if(useColor == 0) {
        standend();
        return;
    }
    setfcolor(basic_color);
    return;
}

effect_form_start()
{// addr = 0x080744BC
    _unknown_ __ebp;

    if(useColor == 0) {
        standout();
        return;
    }
    setfcolor(form_color);
    return;
}

effect_form_end()
{// addr = 0x080744E1
    _unknown_ __ebp;

    if(useColor == 0) {
        standend();
        return;
    }
    setfcolor(basic_color);
    return;
}

effect_mark_start()
{// addr = 0x08074506
    _unknown_ __ebp;

    if(useColor == 0) {
        standout();
        return;
    }
    setbcolor(mark_color);
    return;
}

effect_mark_end()
{// addr = 0x0807452B
    _unknown_ __ebp;

    if(useColor == 0) {
        standend();
        return;
    }
    setbcolor(bg_color);
    return;
}

effect_active_start()
{// addr = 0x08074550
    _unknown_ __ebp;

    if(useColor == 0) {
L4:
        bold();
        return;
    }
    if(useActiveColor == 0) {
        underline();
        return;
    }
    setfcolor(active_color);
    underline();
    return;
    goto L4;
    return;
}

effect_active_end()
{// addr = 0x0807458A
    _unknown_ __ebp;

    if(useColor == 0) {
L4:
        boldend();
        return;
    }
    if(useActiveColor == 0) {
        underlineend();
        return;
    }
    setfcolor(basic_color);
    underlineend();
    return;
    goto L4;
    return;
}

effect_visited_start()
{// addr = 0x080745C4
    _unknown_ __ebp;

    if(useVisitedColor == 0) {
        return ;
    }
    if(useColor == 0) {
        return ;
    }
    setfcolor(visited_color);
    return;
}

effect_visited_end()
{// addr = 0x080745EB
    _unknown_ __ebp;

    if(useVisitedColor == 0) {
        return ;
    }
    if(useColor == 0) {
        return ;
    }
    setfcolor(basic_color);
    return;
}

fmTerm()
{// addr = 0x08074612
    _unknown_ _v24;
    _unknown_ __ebp;

    if((fmInitialized & 255 & 4294967295) == 0) {
        return ;
    }
    move(LINES - 1, 0);
    clrtoeolx();
    refresh();
    if(activeImage != 0) {
        loadImage(0, 1);
    }
    if(use_mouse != 0) {
        mouse_end();
    }
    reset_tty();
    fmInitialized = 0;
    return;
}

fmInit()
{// addr = 0x0807467E
    _unknown_ __ebp;
    _unknown_ _t3;

    if((fmInitialized & 255 & 4294967295) == 0) {
        initscr();
        term_raw();
        term_noecho();
        if(displayImage != 0) {
            initImage();
        }
    }
    fmInitialized = 1;
    return;
}

Str make_lastline_link(Buffer* buf, char* title, char* url)
{// addr = 0x080746B5
    Str s;
    Str u;
    Lineprop* pr;
    ParsedURL pu;
    char* p;
    int l;
    int i;
    struct _Str* _v16;
    struct _Str _v28;
    intOrPtr _v32;
    signed int _v36;
    struct _ParsedURL _v76;
    Linecolor** _v80;
    char* _v84;
    char* _v88;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t128;

    _v16 = 0;
    _v32 = COLS - 1;
    if(title == 0) {
L12:
        if(url == 0) {
            return _v16;
        }
        parseURL2(url,  &_v76, baseURL(buf));
        _v28.area_size = parsedURL2Str( &_v76);
        if(DecodeURL != 0) {
            _v28.area_size = Strnew_charp(url_unquote_conv( *(_v28.area_size),  *(buf + 208)));
        }
        _v28.area_size = checkType(_v28.area_size,  &(_v28.length), 0);
        if(_v32 <= 4 || wtf_strwidth( *_v20) <= _v32) {
            if(_v16 == 0) {
                return _v20;
            }
            Strcat(_v16, _v28.area_size);
            return _v16;
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_size(COLS);
            }
            _v36 = (_v32 - 2 >> 31) + _v32 - 2 >> 1;
            while(_v36 != 0 && ( *(_v24 + _v36 + _v36) & 65535 & 4294967295 &  & 1024) != 0) {
                _v36 = _v36 - 1;
            }
        }
        return _v28.area_size;
    }
    if(( *title & 255 & 4294967295) == 0) {
        goto L12;
    } else {
        _v80 = 0;
        _v84 = "]";
        _v88 = title;
        _v16 = Strnew_m_charp("[");
        _v28 =  *_v16;
        while() {
        }
    }
    return _v16;
}

Str make_lastline_message(Buffer* buf)
{// addr = 0x0807495D
    Str msg;
    Str s;
    int sl;
    MapArea* a;
    Anchor* a;
    char* p;
    Anchor* a_img;
    int cl;
    int ll;
    int r;
    int l;
    char* p;
    struct _Str* _v16;
    struct _Str* _v20;
    int _v24;
    MapArea* _v28;
    Anchor* _v32;
    char* _v36;
    Anchor* _v40;
    long int _v44;
    long int _v48;
    intOrPtr _v52;
    int _v56;
    signed int _v60;
    signed short _v62;
    signed int _v64;
    intOrPtr _v80;
    long int _v84;
    long int _v88;
    _unknown_ __ebp;
    signed int _t157;
    char* _t197;

    _v20 = 0;
    _v24 = 0;
    if(displayLink == 0) {
L20:
        if(use_mouse == 0 ||  *135792260 == 0) {
            _v16 = Strnew();
        } else {
            _v16 = Strnew_charp( *135792260);
        }
        if(displayLineInfo == 0 || buf->currentLine == 0 || buf->lastLine == 0) {
            Strcat_charp(_v16, "Viewing");
        } else {
            _v44 = buf->currentLine->real_linenumber;
            _v48 = buf->lastLine->real_linenumber;
            asm("fild dword [ebp-0x28]");
            asm("fld qword [0x80cad58]");
            asm("fmulp st1, st0");
            if(_v48 == 0) {
                asm("fld1 ");
            } else {
                asm("fild dword [ebp-0x2c]");
            }
            asm("fdivp st1, st0");
            asm("fld qword [0x80cad60]");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp-0x3a]");
            _v64 = _v62 & 65535 & 4294967295;
            asm("fldcw word [ebp-0x3c]");
            asm("fistp dword [ebp-0x30]");
            asm("fldcw word [ebp-0x3a]");
            _v80 = _v52;
            _v84 = _v48;
            _v88 = _v44;
            Strcat(_v16, Sprintf("%d/%d (%d%%)"));
        }
        Strcat_charp(_v16, " <");
        Strcat_charp(_v16, buf->buffername);
        if(_v20 == 0) {
L45:
            Strcat_charp(_v16, ">");
            return _v16;
        } else {
            _v56 = COLS - 3 - _v24;
            if(wtf_strwidth( *_v16) <= _v56) {
L44:
                Strcat_charp(_v16, "> ");
                Strcat(_v16, _v20);
                return _v16;
            }
            _v60.ptr =  *_v16;
            while((_v60 & 255 & 4294967295) != 0) {
                if(( *135119023 & 255 & 4294967295) == 0) {
                    _t157 =  *( &WTF_WIDTH_MAP + (_v60 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                } else {
                    _t157 =  *( &WTF_WIDTH_MAP + (_v60 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                }
                _v56 = _v56 - _t157;
                if(_v56 < 0) {
                    _v60.ptr =  &(_v60.ptr[ *( &WTF_LEN_MAP + ( *(_v60.ptr) & 255 & 4294967295 & )) & 255 & 4294967295 & ]);
                    continue;
                }
                _v56 = _v60 -  *_v16;
                Strtruncate(_v16, _v56);
                goto L44;
            }
            goto L45;
        }
    }
    _v28 = retrieveCurrentMapArea(buf);
    if(_v28 == 0) {
        _v32 = retrieveCurrentAnchor(buf);
        _v36 = 0;
        if(_v32 == 0 || _v32->title == 0) {
L7:
            _v40 = retrieveCurrentImg(buf);
            if(_v40 != 0) {
                if(_v40->title != 0) {
                    if(( *(_v40->title) & 255 & 4294967295) != 0) {
                        _v36 = _v40->title;
                    }
                }
            }
            goto L11;
        } else {
            if(( *(_v32->title) & 255 & 4294967295) == 0) {
                goto L7;
            } else {
                _v36 = _v32->title;
            }
L11:
            if(_v36 != 0 || _v32 != 0) {
                if(_v32 == 0) {
                    _t197 = 0;
                } else {
                    _t197 =  *_v32;
                }
                _v20 = make_lastline_link(buf, _v36, _t197);
            }
            goto L17;
        }
    } else {
        _v20 = make_lastline_link(buf, _v28->alt,  *_v28);
    }
L17:
    if(_v20 != 0) {
        _v24 = wtf_strwidth( *_v20);
        if(COLS - 3 <= _v24) {
            return _v20;
        }
    }
    goto L20;
}

displayBuffer(Buffer* buf, int mode)
{// addr = 0x08074C9B
    Str msg;
    int ny;
    struct _Str* _v16;
    signed int _v20;
    long int _v32;
    signed short _v34;
    signed int _v36;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    char _t164;
    _unknown_ _t165;
    _unknown_ _t172;
    _unknown_ _t173;
    _unknown_ _t187;
    char _t281;
    _unknown_ _t282;
    int _t291;
    _unknown_ _t292;
    signed int _t297;
    int _t316;
    _unknown_ _t317;

    _v20 = 0;
    if(buf == 0) {
        return ;
    }
    if(buf->topLine == 0) {
        if(readBufferCache(buf) == 0) {
            mode = 1;
        }
    }
    if((buf->width & 65535 & 4294967295) == 0) {
        _t316 = COLS;
        if(showLineNum == 0) {
            _t281 = 1;
        } else {
            _t281 = 6;
        }
        _t282 = _t316 - _t281;
        _t283 = _t282 >= 0 ? 0 : _t282;
        _t318 = _t282 >= 0 ? 0 : _t282;
        buf->width = (_t282 >= 0 ? 0 : _t282) & 4294967295;
    }
    if((buf->height & 65535 & 4294967295) == 0) {
        buf->height = LINES & 4294967295;
    }
    _t297 = buf->width & 65535 & 4294967295;
    _t291 = COLS;
    if(showLineNum == 0) {
        _t164 = 1;
    } else {
        _t164 = 6;
    }
    _t165 = _t291 - _t164;
    _t166 = _t165 >= 0 ? 0 : _t165;
    _t328 = _t297 - (_t165 >= 0 ? 0 : _t165);
    if(_t297 == (_t165 >= 0 ? 0 : _t165) || is_html_type(buf->type) == 0 && FoldLine == 0) {
        if((buf->need_reshape & 255 & 4294967295) == 0) {
L19:
            if(showLineNum == 0) {
                buf->rootX = 0;
            } else {
                if(buf->lastLine != 0) {
                    if(buf->lastLine->real_linenumber > 0) {
                        _v32 = buf->lastLine->real_linenumber;
                        asm("fild dword [ebp-0x1c]");
                        asm("fld qword [0x80cad68]");
                        asm("faddp st1, st0");
                        asm("fstp qword [esp]");
                        log();
                        asm("fld qword [0x80cad70]");
                        asm("fdivp st1, st0");
                        asm("fnstcw word [ebp-0x1e]");
                        _v36 = _v34 & 65535 & 4294967295;
                        asm("fldcw word [ebp-0x20]");
                        asm("fistp dword [ebp-0x1c]");
                        asm("fldcw word [ebp-0x1e]");
                        buf->rootX = _v32 + 2 & 4294967295;
                    }
                }
                if((buf->rootX & 65535 & 4294967295) <= 4) {
                    buf->rootX = 5;
                }
                if((buf->rootX & 65535 & 4294967295) > COLS) {
                    buf->rootX = COLS & 4294967295;
                }
            }
            buf->COLS = COLS & 4294967295;
            if(nTab > 1 || mouse_action.menu_str != 0) {
                if(mode == 1 || mode == 4) {
                    calcTabPos();
                }
                asm("cwde ");
                _v20 = (LastTab->y & 65535) + 2;
                if(LINES - 1 < _v20) {
                    _v20 = LINES - 1;
                }
            }
            asm("cwde ");
            if((buf->rootY & 65535) != _v20 || (buf->LINES & 65535 & 4294967295) != LINES - 1 - _v20) {
                buf->rootY = _v20 & 4294967295;
                buf->LINES = LINES - 1 & 4294967295;
                arrangeCursor(buf);
                mode = 4;
            }
            if(mode == 1 || mode == 3 || mode == 4 || buf->topLine != cline || buf->currentColumn != ccolumn) {
                if(activeImage != 0 && (mode == 4 || buf->topLine != cline || buf->currentColumn != ccolumn)) {
                    if(draw_image_flag != 0) {
                        clear();
                    }
                    clearImage();
                    loadImage(buf, 1);
                    image_touch = image_touch + 1;
                    draw_image_flag = 0;
                }
                redrawNLine(buf, LINES - 1);
                cline = buf->topLine;
                ccolumn = buf->currentColumn;
            }
            if(buf->topLine == 0) {
                buf->topLine = buf->firstLine;
            }
            if((buf->need_reshape & 255 & 4294967295) == 0) {
                drawAnchorCursor(buf);
                _v16 = make_lastline_message(buf);
                if(buf->firstLine == 0) {
                    Strcat_charp(_v16, "\tNo Line");
                }
                if(delayed_msg != 0) {
                    disp_message(delayed_msg, 0);
                    delayed_msg = 0;
                    refresh();
                }
                standout();
                asm("cwde ");
                asm("cwde ");
                message( *_v16, (buf->cursorX & 65535 & 4294967295) + (buf->rootX & 65535), (buf->cursorY & 65535 & 4294967295) + (buf->rootY & 65535));
                standend();
                term_title( *(wc_Str_conv_strict(Strnew_charp(buf->buffername), InnerCharset, SystemCharset)));
                refresh();
                if(activeImage == 0) {
                    return ;
                }
                if(displayImage == 0) {
                    return ;
                }
                if(buf->img == 0) {
                    return ;
                }
                drawImage();
                return;
            }
            displayBuffer(buf, 1);
            return;
        }
    }
L18:
    buf->need_reshape = 1;
    reshapeBuffer(buf);
    goto L19;
}

drawAnchorCursor0(Buffer* buf, AnchorList* al, int hseq, int prevhseq, int tline, int eline, int active)
{// addr = 0x08075138
    int i;
    int j;
    Line* l;
    Anchor* an;
    int _v16;
    signed int _v20;
    Line* _v24;
    intOrPtr _v28;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t132;
    _unknown_ _t160;

    _v24 = buf->topLine;
    _v20 = 0;
    while(al->nanchor > _v20) {
        _v28 = al->anchors + (_v20 << 2 << 4) - (_v20 << 2);
        if( *((intOrPtr*)(_v28 + 20)) < tline) {
L24:
            _v20 = _v20 + 1;
            continue;
        } else {
            if( *((intOrPtr*)(_v28 + 20)) >= eline) {
                return ;
            }
        }
L3:
        while(_v24 != 0) {
L4:
            if(_v24->linenumber !=  *((intOrPtr*)(_v28 + 20))) {
                _v24 = _v24->next;
                goto L3;
            }
            if(hseq >= 0) {
                if( *((intOrPtr*)(_v28 + 44)) != hseq) {
                    goto L18;
                } else {
                    _v16 =  *(_v28 + 24);
                }
                while( *(_v28 + 36) > _v16) {
                    if(( *(_v24->propBuf + _v16 + _v16) & 65535 & 4294967295 &  & 112) != 0) {
                        if(active == 0) {
                             *(_v24->propBuf + _v16 + _v16) =  *(_v24->propBuf + _v16 + _v16) & 65535 & 4294967295;
                        } else {
                             *(_v24->propBuf + _v16 + _v16) =  *(_v24->propBuf + _v16 + _v16) & 65535 & 4294967295;
                        }
                    }
                    _v16 = _v16 + 1;
                }
            } else {
            }
L18:
            if(prevhseq < 0 &&  *((intOrPtr*)(_v28 + 44)) == prevhseq && active != 0) {
                redrawLineRegion(buf, _v24, _v24->linenumber - tline + (buf->rootY & 65535 & 4294967295),  *(_v28 + 24),  *(_v28 + 36));
            }
            goto L24;
        }
    }
}

drawAnchorCursor(Buffer* buf)
{// addr = 0x0807531B
    Anchor* an;
    int hseq;
    int prevhseq;
    int tline;
    int eline;
    Anchor* _v16;
    int _v20;
    int _v24;
    int _v28;
    int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;

    if(buf->firstLine == 0) {
        return ;
    }
    if(buf->hmarklist == 0) {
        return ;
    }
    if(buf->href == 0) {
        if(buf->formitem == 0) {
            return ;
        }
    }
    _v16 = retrieveCurrentAnchor(buf);
    if(_v16 == 0) {
        _v16 = retrieveCurrentMap(buf);
    }
    if(_v16 == 0) {
        _v20 = -1;
    } else {
        _v20 = _v16->hseq;
    }
    _v28 = buf->topLine->linenumber;
    asm("cwde ");
    _v32 = (buf->LINES & 65535) + _v28;
    _v24 = buf->hmarklist->prevhseq;
    if(buf->href != 0) {
        drawAnchorCursor0(buf, buf->href, _v20, _v24, _v28, _v32, 1);
        drawAnchorCursor0(buf, buf->href, _v20, -1, _v28, _v32, 0);
    }
    if(buf->formitem != 0) {
        drawAnchorCursor0(buf, buf->formitem, _v20, _v24, _v28, _v32, 1);
        drawAnchorCursor0(buf, buf->formitem, _v20, -1, _v28, _v32, 0);
    }
    buf->hmarklist->prevhseq = _v20;
    return;
}

redrawNLine(Buffer* buf, int n)
{// addr = 0x080754C6
    Line* l;
    int i;
    TabBuffer* t;
    int l;
    struct _TabBuffer _v24;
    unsigned int _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t216;

    if(useColor != 0) {
        setfcolor(basic_color);
        setbcolor(bg_color);
    }
    if(nTab > 1 || mouse_action.menu_str != 0) {
        move(0, 0);
        if(mouse_action.menu_str != 0) {
            addstr(mouse_action.menu_str);
        }
        clrtoeolx();
        _v24 = FirstTab;
        while(_v24 != 0) {
            asm("cwde ");
            move(_v24->y & 65535, _v24->x1 & 65535 & 4294967295);
            if(_v24 == CurrentTab) {
                bold();
            }
            addch(91);
            asm("cwde ");
            _v28 = (_v24->x2 & 65535 & 4294967295) - (_v24->x1 & 65535) - 1 - wtf_strwidth( *(_v24->currentBuffer + 4));
            if(_v28 < 0) {
                _v28 = 0;
            }
            if(_v28 > 1) {
                addnstr_sup(" ", (_v28 >> 31) + _v28 >> 1);
            }
            if(_v24 == CurrentTab) {
                effect_active_start();
            }
            asm("cwde ");
            addnstr( *(_v24->currentBuffer + 4), (_v24->x2 & 65535 & 4294967295) - (_v24->x1 & 65535) - _v28);
            if(_v24 == CurrentTab) {
                effect_active_end();
            }
            if(_v28 + 1 > 1) {
                addnstr_sup(" ", (_v28 + 1 >> 31) + _v28 + 1 >> 1);
            }
            asm("cwde ");
            move(_v24->y & 65535, _v24->x2 & 65535 & 4294967295);
            addch(93);
            if(_v24 == CurrentTab) {
                boldend();
            }
            _v24 =  *_v24;
        }
    }
    _v24.prevTab = 0;
    _v24.currentBuffer = buf->topLine;
    while(1) {
        asm("cwde ");
        if((buf->LINES & 65535) <= _v20) {
            break;
        }
        asm("cwde ");
        if((buf->LINES & 65535) - n <= _v20 ||  ~n > _v20) {
            asm("cwde ");
            _v24.currentBuffer = redrawLine(buf, _v24.currentBuffer, (buf->rootY & 65535) + _v24.prevTab);
        }
        if(_v16 != 0) {
            _v24.prevTab = _v24.prevTab + 1;
            _v24.currentBuffer = _v24.currentBuffer->next;
            continue;
        }
L35:
        if(n > 0) {
            asm("cwde ");
            move((buf->rootY & 65535) + _v24.prevTab, 0);
            clrtobotx();
        }
        if(activeImage == 0) {
            return ;
        }
        if(displayImage == 0) {
            return ;
        }
        if(buf->img == 0) {
            return ;
        }
        asm("cwde ");
        asm("cwde ");
        move((buf->cursorY & 65535 & 4294967295) + (buf->rootY & 65535), (buf->cursorX & 65535 & 4294967295) + (buf->rootX & 65535));
        _v24.prevTab = 0;
        _v24.currentBuffer = buf->topLine;
        while(1) {
            asm("cwde ");
            if((buf->LINES & 65535) <= _v20 || _v16 == 0) {
                break;
            }
            asm("cwde ");
            if((buf->LINES & 65535) - n <= _v20 ||  ~n > _v20) {
                asm("cwde ");
                redrawLineImage(buf, _v24.currentBuffer, (buf->rootY & 65535) + _v24.prevTab);
            }
            _v24.prevTab = _v24.prevTab + 1;
            _v24.currentBuffer = _v24.currentBuffer->next;
        }
        getAllImage(buf);
        return;
    }
    goto L35;
}

Line* redrawLine(Buffer* buf, Line* l, int i)
{// addr = 0x08075864
    int j;
    int pos;
    int rcol;
    int ncol;
    int delta;
    int column;
    char* p;
    Lineprop* pr;
    Linecolor* pc;
    Anchor* a;
    ParsedURL url;
    int k;
    int vpos;
    char[15] tmp;
    intOrPtr _v16;
    char _v32;
    unsigned char _v36;
    int _v40;
    int _v44;
    int _v48;
    unsigned int _v52;
    int _v56;
    intOrPtr _v60;
    intOrPtr _v64;
    unsigned char _v68;
    Anchor* _v72;
    intOrPtr _v76;
    intOrPtr _v80;
    struct _ParsedURL _v120;
    Buffer* _v128;
    Line* _v132;
    _unknown_ _v136;
    _unknown_ _v138;
    _unknown_ _v140;
    _unknown_ _v152;
    _unknown_ _v156;
    long int _v160;
    intOrPtr _v164;
    _unknown_ _v168;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t264;
    Line* _t276;
    _unknown_ _t398;
    _unknown_ _t407;
    _unknown_ _t417;
    _unknown_ _t418;
    _unknown_ _t458;
    Line* _t500;

    _v128 = buf;
    _v132 = l;
    _v16 =  *gs:0x14];
    _v52 = 1;
    _v56 = _v128->currentColumn;
    _v80 = -1;
    if(_v132 != 0) {
L5:
        move(i, 0);
        if(showLineNum != 0) {
            if((_v128->rootX & 65535 & 4294967295) == 0) {
                if((_v128->rootX & 65535 & 4294967295) <= 4) {
                    _v128->rootX = 5;
                }
                if((_v128->rootX & 65535 & 4294967295) > COLS) {
                    _v128->rootX = COLS & 4294967295;
                }
                _v128->COLS = COLS & 4294967295;
            }
            if(_v132->real_linenumber == 0 || _v132->bpos != 0) {
                asm("cwde ");
                _v160 = 135048306;
                _v164 = (_v128->rootX & 65535) - 1;
                sprintf( &_v32, "%*s ");
            } else {
                asm("cwde ");
                _v160 = _v132->real_linenumber;
                _v164 = (_v128->rootX & 65535) - 1;
                sprintf( &_v32, "%*ld:");
            }
            addstr( &_v32);
        }
        asm("cwde ");
        move(i, _v128->rootX & 65535);
        if(_v132->width < 0) {
            _v132->width = calcPosition( *_v132, _v132->propBuf, _v132->len, _v132->len, 0, 0);
        }
        if(_v132->len == 0 || _v132->width - 1 < _v56) {
            clrtoeolx();
            _t276 = _v132;
L85:
            if(_t500 == 0) {
                return _t276;
            }
            __stack_chk_fail();
            return _t276;
        }
        _v40 = columnPos(_v132, _v56);
        _v60 =  *_v132 + _v40;
        _v64 = _v132->propBuf + _v40 + _v40;
        if(useColor == 0 || _v132->colorBuf == 0) {
            _v68 = 0;
        } else {
            _v68 = _v132->colorBuf + _v40;
        }
        _v44 = calcPosition( *_v132, _v132->propBuf, _v132->len, _v40, 0, 0);
        _v36 = 0;
        while(1) {
            asm("cwde ");
            if(_v44 - _v56 >= (_v128->COLS & 65535)) {
                break;
            }
            if(_v40 + _v36 < _v132->len) {
                if(useVisitedColor == 0 || _v40 + _v36 < _v80 || ( *(_v36 + _v36 + _v64) & 65535 & 4294967295 &  & 16384) != 0) {
L38:
                    _v52 = wtf_len(_v60 + _v36);
                    _v48 = calcPosition( *_v132, _v132->propBuf, _v132->len, _v40 + _v36 + _v52, 0, 0);
                    asm("cwde ");
                    if(_v48 - _v56 > (_v128->COLS & 65535)) {
                        break;
                    }
                } else {
                    _v72 = retrieveAnchor(_v128->href, _v132->linenumber, _v40 + _v36);
                    if(_v72 == 0) {
                        goto L38;
                    }
                    parseURL2( *_v72,  &_v120, baseURL(_v128));
                    if(getHashHist(URLHist,  *(parsedURL2Str( &_v120))) == 0) {
                        _v80 =  *((intOrPtr*)(_v72 + 36));
                        goto L38;
                    }
                    _v76 =  *((intOrPtr*)(_v72 + 24));
                    while( *((intOrPtr*)(_v72 + 36)) > _v76) {
                         *(_v76 - _v40 + _v76 - _v40 + _v64) =  *(_v76 - _v40 + _v76 - _v40 + _v64) & 65535 & 4294967295;
                        _v76 = _v76 + 1;
                    }
                    goto L38;
                }
L39:
                if(_v68 != 0) {
                    do_color( *(_v36 + _v68) & 255 & 4294967295 & );
                }
                if(_v44 >= _v56) {
                    if(( *(_v36 + _v60) & 255 & 4294967295) != 9) {
                        addMChar(_v36 + _v60,  *(_v36 + _v36 + _v64) & 65535 & 4294967295 & , _v52);
                        goto L52;
                    }
                    goto L47;
L52:
                    _v44 = _v48;
                    _v36 = _v36 + _v52;
                    continue;
                } else {
                    _v44 = _v56;
                    while(_v44 < _v48) {
                        addChar(32, 0);
                        _v44 = _v44 + 1;
                    }
                }
L47:
                while(_v44 < _v48) {
                    addChar(32, 0);
                    _v44 = _v44 + 1;
                }
            }
            break;
        }
        if(somode != 0) {
            somode = 0;
            standend();
        }
        if(ulmode != 0) {
            ulmode = 0;
            underlineend();
        }
        if(bomode != 0) {
            bomode = 0;
            boldend();
        }
        if(emph_mode != 0) {
            emph_mode = 0;
            boldend();
        }
        if(anch_mode != 0) {
            anch_mode = 0;
            effect_anchor_end();
        }
        if(imag_mode != 0) {
            imag_mode = 0;
            effect_image_end();
        }
        if(form_mode != 0) {
            form_mode = 0;
            effect_form_end();
        }
        if(visited_mode != 0) {
            visited_mode = 0;
            effect_visited_end();
        }
        if(active_mode != 0) {
            active_mode = 0;
            effect_active_end();
        }
        if(mark_mode != 0) {
            mark_mode = 0;
            effect_mark_end();
        }
        if(graph_mode != 0) {
            graph_mode = 0;
            graphend();
        }
        if((color_mode & 255 & 4294967295) != 0) {
            do_color(0);
        }
        asm("cwde ");
        if(_v44 - _v56 < (_v128->COLS & 65535)) {
            clrtoeolx();
        }
        _t276 = _v132;
        goto L85;
    }
    if( *((intOrPtr*)(_v128 + 92)) == 0) {
        _t276 = 0;
        goto L85;
    }
    asm("cwde ");
    _v132 = getNextPage(_v128, (_v128->LINES & 65535 & 4294967295) + (_v128->rootY & 65535) - i);
    _t500 = _v132;
    if(_t500 != 0) {
        goto L5;
    } else {
        _t276 = 0;
    }
    goto L85;
}

Line* redrawLineImage(Buffer* buf, Line* l, int i)
{// addr = 0x08075F31
    int j;
    int pos;
    int rcol;
    int column;
    Anchor* a;
    int x;
    int y;
    int sx;
    int sy;
    int w;
    int h;
    Image* image;
    ImageCache* cache;
    int _v16;
    int _v20;
    int _v24;
    int _v28;
    Anchor* _v32;
    int _v36;
    int _v40;
    int _v44;
    int _v48;
    int _v52;
    int _v56;
    Image* _v60;
    ImageCache* _v64;
    intOrPtr _v80;
    signed int _v82;
    signed int _v84;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ _v108;
    _unknown_ _v112;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t394;

    _v28 = buf->currentColumn;
    if(l == 0) {
        return 0;
    }
    if(l->width < 0) {
        l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
    }
    if(l->len == 0) {
        return l;
    }
    if(l->width - 1 < _v28) {
        return l;
    }
    _v20 = columnPos(l, _v28);
    _v24 = calcPosition(l->lineBuf, l->propBuf, l->len, _v20, 0, 0);
    _v16 = 0;
    while(1) {
        asm("cwde ");
        if(_v24 - _v28 >= (buf->COLS & 65535)) {
            break;
        }
        if(_v20 + _v16 >= l->len) {
            return l;
        }
        if(_v24 - _v28 >= 0) {
            _v32 = retrieveAnchor(buf->img, l->linenumber, _v20 + _v16);
            if(_v32 == 0 || _v32->image == 0 || _v32->image->touch >= image_touch) {
L38:
                _v24 = calcPosition(l->lineBuf, l->propBuf, l->len, _v20 + _v16 + 1, 0, 0);
            } else {
                _v60 = _v32->image;
                _v60->cache = getImage(_v60, baseURL(buf), buf->image_flag & 255 & 4294967295);
                _v64 = _v60->cache;
                if(_v64 == 0) {
                    goto L38;
                }
                if((_v60->width & 65535 & 4294967295) >= 0 || (_v64->width & 65535 & 4294967295) <= 0) {
                    if((_v60->height & 65535 & 4294967295) >= 0 || (_v64->height & 65535 & 4294967295) <= 0) {
L19:
                        asm("cwde ");
                        _v80 = _v24 - _v28 + (buf->rootX & 65535);
                        asm("fild dword [ebp-0x4c]");
                        asm("fld qword [0x80d53a0]");
                        asm("fmulp st1, st0");
                        asm("fnstcw word [ebp-0x4e]");
                        _v84 = _v82 & 65535 & 4294967295;
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x20]");
                        asm("fldcw word [ebp-0x4e]");
                        asm("fild dword [ebp+0x10]");
                        asm("fld qword [0x80d53a8]");
                        asm("fmulp st1, st0");
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x24]");
                        asm("fldcw word [ebp-0x4e]");
                        _v80 = _v24 - calcPosition(l->lineBuf, l->propBuf, l->len,  *(_v32 + 24), 0, 0);
                        asm("fild dword [ebp-0x4c]");
                        asm("fld qword [0x80d53a0]");
                        asm("fmulp st1, st0");
                        asm("fnstcw word [ebp-0x4e]");
                        _v84 = _v82 & 65535 & 4294967295;
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x28]");
                        asm("fldcw word [ebp-0x4e]");
                        asm("cwde ");
                        _v80 = l->linenumber - (_v60->y & 65535);
                        asm("fild dword [ebp-0x4c]");
                        asm("fld qword [0x80d53a8]");
                        asm("fmulp st1, st0");
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x2c]");
                        asm("fldcw word [ebp-0x4e]");
                        if(_v44 != 0) {
L22:
                            asm("cwde ");
                            _v44 = _v44 - (_v60->xoffset & 65535);
                            goto L23;
                        }
                        goto L20;
L23:
                        if(_v48 != 0) {
L26:
                            asm("cwde ");
                            _v48 = _v48 - (_v60->yoffset & 65535);
                            goto L27;
                        }
                        asm("cwde ");
                        if((_v60->yoffset & 65535) + _v40 >= 0) {
                            goto L26;
                        }
                        asm("cwde ");
                        _v40 = _v40 + (_v60->yoffset & 65535);
L27:
                        if((_v60->width & 65535 & 4294967295) <= 0) {
                            asm("fld qword [0x80d53a0]");
                            asm("fld qword [0x80cad78]");
                            asm("fmulp st1, st0");
                            asm("fild dword [ebp-0x28]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x30]");
                            asm("fldcw word [ebp-0x4e]");
                        } else {
                            asm("cwde ");
                            _v52 = (_v60->width & 65535) - _v44;
                        }
                        if((_v60->height & 65535 & 4294967295) <= 0) {
                            asm("fld qword [0x80d53a8]");
                            asm("fild dword [ebp-0x2c]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x34]");
                            asm("fldcw word [ebp-0x4e]");
                        } else {
                            asm("cwde ");
                            _v56 = (_v60->height & 65535) - _v48;
                        }
                        asm("cwde ");
                        _v80 = (buf->rootX & 65535 & 4294967295) + (buf->COLS & 65535);
                        asm("fild dword [ebp-0x4c]");
                        asm("fld qword [0x80d53a0]");
                        asm("fmulp st1, st0");
                        asm("fild dword [ebp-0x20]");
                        asm("fsubp st1, st0");
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x4c]");
                        asm("fldcw word [ebp-0x4e]");
                        if(_v80 < _v52) {
                            asm("cwde ");
                            _v80 = (buf->rootX & 65535 & 4294967295) + (buf->COLS & 65535);
                            asm("fild dword [ebp-0x4c]");
                            asm("fld qword [0x80d53a0]");
                            asm("fmulp st1, st0");
                            asm("fild dword [ebp-0x20]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x30]");
                            asm("fldcw word [ebp-0x4e]");
                        }
                        _v80 = LINES - 1;
                        asm("fild dword [ebp-0x4c]");
                        asm("fld qword [0x80d53a8]");
                        asm("fmulp st1, st0");
                        asm("fild dword [ebp-0x24]");
                        asm("fsubp st1, st0");
                        asm("fldcw word [ebp-0x50]");
                        asm("fistp dword [ebp-0x4c]");
                        asm("fldcw word [ebp-0x4e]");
                        if(_v80 < _v56) {
                            _v80 = LINES - 1;
                            asm("fild dword [ebp-0x4c]");
                            asm("fld qword [0x80d53a8]");
                            asm("fmulp st1, st0");
                            asm("fild dword [ebp-0x24]");
                            asm("fsubp st1, st0");
                            asm("fldcw word [ebp-0x50]");
                            asm("fistp dword [ebp-0x34]");
                            asm("fldcw word [ebp-0x4e]");
                        }
                        addImage(_v64, _v36, _v40, _v44, _v48, _v52, _v56);
                        _v60->touch = image_touch;
                        draw_image_flag = 1;
                        goto L38;
                    } else {
                        goto L18;
                    }
L20:
                    asm("cwde ");
                    if((_v60->xoffset & 65535) + _v36 >= 0) {
                        goto L22;
                    } else {
                        asm("cwde ");
                        _v36 = _v36 + (_v60->xoffset & 65535);
                    }
                    goto L23;
                }
L18:
                _v60->width = _v64->width & 65535 & 4294967295;
                _v60->height = _v64->height & 65535 & 4294967295;
                buf->need_reshape = 1;
                goto L19;
            }
        } else {
            _v24 = calcPosition(l->lineBuf, l->propBuf, l->len, _v20 + _v16 + 1, 0, 0);
        }
        _v16 = _v16 + 1;
    }
    return l;
}

int redrawLineRegion(Buffer* buf, Line* l, int i, int bpos, int epos)
{// addr = 0x0807648A
    int j;
    int pos;
    int rcol;
    int ncol;
    int delta;
    int column;
    char* p;
    Lineprop* pr;
    Linecolor* pc;
    int bcol;
    int ecol;
    Anchor* a;
    ParsedURL url;
    int k;
    int vpos;
    unsigned char _v16;
    int _v20;
    int _v24;
    int _v28;
    unsigned int _v32;
    int _v36;
    intOrPtr _v40;
    intOrPtr _v44;
    unsigned char _v48;
    intOrPtr _v52;
    intOrPtr _v56;
    Anchor* _v60;
    intOrPtr _v64;
    intOrPtr _v68;
    struct _ParsedURL _v108;
    _unknown_ _v120;
    _unknown_ _v124;
    _unknown_ _v128;
    _unknown_ _v132;
    _unknown_ _v136;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t293;

    _v32 = 1;
    _v36 = buf->currentColumn;
    _v68 = -1;
    if(l == 0) {
        return 0;
    }
    _v20 = columnPos(l, _v36);
    _v40 = l->lineBuf + _v20;
    _v44 = l->propBuf + _v20 + _v20;
    if(useColor == 0) {
L5:
        _v48 = 0;
    } else {
        if(l->colorBuf == 0) {
            goto L5;
        } else {
            _v48 = l->colorBuf + _v20;
        }
    }
L6:
    _v24 = calcPosition(l->lineBuf, l->propBuf, l->len, _v20, 0, 0);
    _v52 = bpos - _v20;
    _v56 = epos - _v20;
    _v16 = 0;
    while(1) {
        asm("cwde ");
        if(_v24 - _v36 >= (buf->COLS & 65535)) {
            break;
        }
        if(_v20 + _v16 < l->len) {
            if(useVisitedColor == 0 || _v20 + _v16 < _v68 || ( *(_v16 + _v16 + _v44) & 65535 & 4294967295 &  & 16384) != 0) {
L16:
                _v32 = wtf_len(_v40 + _v16);
                _v28 = calcPosition(l->lineBuf, l->propBuf, l->len, _v20 + _v16 + _v32, 0, 0);
                asm("cwde ");
                if(_v28 - _v36 > (buf->COLS & 65535)) {
                    break;
                }
            } else {
                _v60 = retrieveAnchor(buf->href, l->linenumber, _v20 + _v16);
                if(_v60 == 0) {
                    goto L16;
                }
                parseURL2( *_v60,  &_v108, baseURL(buf));
                if(getHashHist(URLHist,  *(parsedURL2Str( &_v108))) == 0) {
                    _v68 =  *((intOrPtr*)(_v60 + 36));
                } else {
                    _v64 =  *((intOrPtr*)(_v60 + 24));
                    while( *((intOrPtr*)(_v60 + 36)) > _v64) {
                    }
                }
                goto L16;
            }
L17:
            if(_v48 != 0) {
                do_color( *(_v16 + _v48) & 255 & 4294967295 & );
            }
            if(_v16 < _v52 || _v16 >= _v56) {
L32:
                _v24 = _v28;
            } else {
                if(_v24 >= _v36) {
                    asm("cwde ");
                    move(i, _v24 - _v36 + (buf->rootX & 65535));
                    if(( *(_v16 + _v40) & 255 & 4294967295) != 9) {
                        addMChar(_v16 + _v40,  *(_v16 + _v16 + _v44) & 65535 & 4294967295 & , _v32);
                        goto L32;
                    }
                    goto L27;
                }
                asm("cwde ");
                move(i, buf->rootX & 65535);
                _v24 = _v36;
                while(_v24 < _v28) {
                    addChar(32, 0);
                    _v24 = _v24 + 1;
                }
L27:
                while(_v24 < _v28) {
                    addChar(32, 0);
                    _v24 = _v24 + 1;
                }
            }
            _v16 = _v16 + _v32;
            continue;
        }
        break;
    }
    if(somode != 0) {
        somode = 0;
        standend();
    }
    if(ulmode != 0) {
        ulmode = 0;
        underlineend();
    }
    if(bomode != 0) {
        bomode = 0;
        boldend();
    }
    if(emph_mode != 0) {
        emph_mode = 0;
        boldend();
    }
    if(anch_mode != 0) {
        anch_mode = 0;
        effect_anchor_end();
    }
    if(imag_mode != 0) {
        imag_mode = 0;
        effect_image_end();
    }
    if(form_mode != 0) {
        form_mode = 0;
        effect_form_end();
    }
    if(visited_mode != 0) {
        visited_mode = 0;
        effect_visited_end();
    }
    if(active_mode != 0) {
        active_mode = 0;
        effect_active_end();
    }
    if(mark_mode != 0) {
        mark_mode = 0;
        effect_mark_end();
    }
    if(graph_mode != 0) {
        graph_mode = 0;
        graphend();
    }
    if((color_mode & 255 & 4294967295) == 0) {
        return _v24 - _v36;
    }
    do_color(0);
    return _v24 - _v36;
}

do_effects(Lineprop m)
{// addr = 0x08076954
    signed int _v16;
    _unknown_ __ebp;

    _v16 = m & 4294967295;
    if(ulmode != 0) {
        underlineend();
        ulmode = 0;
    }
    if(somode != 0) {
        standend();
        somode = 0;
    }
    if(bomode != 0) {
        boldend();
        bomode = 0;
    }
    if(emph_mode != 0) {
        boldend();
        emph_mode = 0;
    }
    if(anch_mode != 0) {
        effect_anchor_end();
        anch_mode = 0;
    }
    if(imag_mode != 0) {
        effect_image_end();
        imag_mode = 0;
    }
    if(form_mode != 0) {
        effect_form_end();
        form_mode = 0;
    }
    if(visited_mode != 0) {
        effect_visited_end();
        visited_mode = 0;
    }
    if(active_mode != 0) {
        effect_active_end();
        active_mode = 0;
    }
    if(mark_mode != 0) {
        effect_mark_end();
        mark_mode = 0;
    }
    if(graph_mode != 0) {
        graphend();
        graph_mode = 0;
    }
    if((_v16 & 65535 & 2) != 0 && ulmode == 0) {
        underline();
        ulmode = 1;
    }
    if((_v16 & 65535 & 4) != 0 && somode == 0) {
        standout();
        somode = 1;
    }
    if((_v16 & 65535 & 8) != 0 && bomode == 0) {
        bold();
        bomode = 1;
    }
    if((_v16 & 65535 & 8) != 0 && emph_mode == 0) {
        bold();
        emph_mode = 1;
    }
    if((_v16 & 65535 & 16) != 0 && anch_mode == 0) {
        effect_anchor_start();
        anch_mode = 1;
    }
    if((_v16 & 65535 & 32) != 0 && imag_mode == 0) {
        effect_image_start();
        imag_mode = 1;
    }
    if((_v16 & 65535 & 64) != 0 && form_mode == 0) {
        effect_form_start();
        form_mode = 1;
    }
    if((_v16 & 65535 & 16384) != 0 && visited_mode == 0) {
        effect_visited_start();
        visited_mode = 1;
    }
    if((_v16 & 65535 & 128) != 0 && active_mode == 0) {
        effect_active_start();
        active_mode = 1;
    }
    if((_v16 & 65535 & 1 & 4294967295) == 0) {
        return ;
    }
    if(mark_mode != 0) {
        return ;
    }
    effect_mark_start();
    mark_mode = 1;
    return;
}

do_color(Linecolor c)
{// addr = 0x08076BCD
    signed int _v16;
    _unknown_ __ebp;

    _v16 = c & 4294967295;
    if((_v16 & 255 & 8) == 0) {
        if((color_mode & 255 & 4294967295 &  & 8) != 0) {
            setfcolor(basic_color);
        }
    } else {
        setfcolor(_v16 & 255 & 7);
    }
    if((_v16 & 255 & 4294967295) >= 0) {
        if((color_mode & 255 & 4294967295) < 0) {
            setbcolor(bg_color);
        }
    } else {
        setbcolor(_v16 & 255 & 4294967295 &  & 7);
    }
    color_mode = _v16 & 255 & 4294967295;
    return;
}

addChar(char c, Lineprop mode)
{// addr = 0x08076C55
    char _v16;
    signed short _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = c & 4294967295;
    _v20 = mode & 4294967295;
    addMChar( &_v16, _v20 & 65535, 1);
    return;
}

addMChar(char* p, Lineprop mode, size_t len)
{// addr = 0x08076C85
    Lineprop m;
    char c;
    char** symbol;
    int w;
    char[4] buf;
    signed int _v13;
    signed short _v16;
    char** _v20;
    int _v24;
    char _v29;
    signed int _v48;
    signed int _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t70;
    char _t72;
    int _t79;

    _v48 = mode & 4294967295;
    _v16 = _v48 & 65535 & 4294967295;
    _v13 =  *p & 255 & 4294967295;
    if((_v48 & 65535 & 1024) != 0) {
        return ;
    }
    do_effects(_v16 & 65535);
    if((_v48 & 65535 & 4294967295) >= 0) {
L14:
        if((_v48 & 65535 & 256) == 0) {
            if((_v48 & 65535 & 4096) == 0) {
                addmch(p, len);
                return;
            }
            goto L27;
        }
        goto L15;
L27:
        _v68 = (wtf_get_code(p) | 128) & 4294967295 & ;
        sprintf( &_v29, "[%.2X]");
        addstr( &_v29);
        return;
    } else {
        if((_v48 & 65535 & 2048) == 0) {
            _t79 = 1;
        } else {
            _t79 = 2;
        }
        _v24 = _t79;
        _v13 = (wtf_get_code(p) & 127) - 32 & 4294967295;
        if(graph_ok() == 0 || _v13 > 31) {
L13:
            _v20 = get_symbol(DisplayCharset,  &_v24);
            addstr(_v20[_v13]);
            return;
        } else {
            if(graph_mode == 0) {
                graphstart();
                graph_mode = 1;
            }
            if(_v24 != 2 || ( *135119023 & 255 & 4294967295) == 0) {
                addch( *( *( &graph_symbol + _v13 * 4)) & 255 & 4294967295);
                return;
            } else {
                addstr( *( &graph2_symbol + _v13 * 4));
                return;
            }
            goto L13;
        }
        goto L14;
    }
L15:
    _t72 = _v13;
    if(_t72 == 10) {
L23:
        addch(32);
        return;
    }
    if(_t72 > 10) {
        if(_t72 == 13) {
            return ;
        }
        if(_t72 == 127) {
            goto L24;
        } else {
        }
L25:
        addch(94);
        addch((_v13 & 255) + 64 & 4294967295);
        return;
    }
    if(_t72 == 9) {
        addch(_v13);
        return;
    }
    goto L25;
L24:
    addstr("^?");
    return;
}

record_err_message(char* s)
{// addr = 0x08076E82
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t15;

    if((fmInitialized & 255 & 4294967295) == 0) {
        return ;
    }
    if(message_list == 0) {
        message_list = newGeneralList();
    }
    if((message_list->nitem & 65535 & 4294967295) >= LINES) {
        popValue(message_list);
    }
    pushValue(message_list, allocStr(s, -1));
    return;
}

Buffer* message_list_panel()
{// addr = 0x08076EEF
    Str tmp;
    ListItem* p;
    struct _Str* _v16;
    struct _listitem* _v20;
    intOrPtr _v44;
    char* _v48;
    char* _v52;
    char* _v56;
    _unknown_ __ebp;
    char* _t34;

    _v16 = Strnew_size(COLS * LINES);
    Strcat_charp(_v16, "<html><head><title>List of error messages</title></head><body><h1>List of error messages</h1><table cellpadding=0>\n");
    if(message_list == 0) {
        Strcat_charp(_v16, "<tr><td>(no message recorded)</td></tr>\n");
    } else {
        _v20 = message_list->last;
        while(_v20 != 0) {
            _t34 = html_quote( *_v20);
            _v44 = 0;
            _v48 = "</pre></td></tr>\n";
            _v52 = _t34;
            _v56 = "<tr><td><pre>";
            Strcat_m_charp(_v16);
            _v20 = _v20->prev;
        }
    }
    Strcat_charp(_v16, "</table></body></html>");
    return loadHTMLString(_v16);
}

message(char* s, int return_x, int return_y)
{// addr = 0x08076FAF
    _unknown_ _v24;
    _unknown_ __ebp;

    if((fmInitialized & 255 & 4294967295) == 0) {
        return ;
    }
    move(LINES - 1, 0);
    addnstr(s, COLS - 1);
    clrtoeolx();
    move(return_y, return_x);
    return;
}

disp_err_message(char* s, int redraw_current)
{// addr = 0x0807700B
    _unknown_ _v24;
    _unknown_ __ebp;

    record_err_message(s);
    disp_message(s, redraw_current);
    return;
}

disp_message_nsec(char* s, int redraw_current, int sec, int purge, int mouse)
{// addr = 0x08077030
    struct _Str _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t43;
    _unknown_ _t70;

    if((QuietMessage & 255 & 4294967295) != 0) {
        return ;
    }
    if((fmInitialized & 255 & 4294967295) == 0) {
        _v20 =  *(wc_Str_conv_strict(Strnew_charp(s), InnerCharset, SystemCharset));
        fprintf(__imp__stderr, "%s\n");
        return;
    }
    if(CurrentTab == 0 || CurrentTab->currentBuffer == 0) {
        message(s, LINES - 1, 0);
    } else {
        asm("cwde ");
        asm("cwde ");
        message(s, (CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535), (CurrentTab->currentBuffer->cursorY & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootY & 65535));
    }
    refresh();
    if(mouse != 0 && use_mouse != 0) {
        mouse_active();
    }
    sleep_till_anykey(sec, purge);
    if(mouse != 0 && use_mouse != 0) {
        mouse_inactive();
    }
    if(CurrentTab == 0) {
        return ;
    }
    if(CurrentTab->currentBuffer == 0) {
        return ;
    }
    if(redraw_current == 0) {
        return ;
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
    return;
}

disp_message(char* s, int redraw_current)
{// addr = 0x0807719C
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    disp_message_nsec(s, redraw_current, 10, 0, 1);
    return;
}

disp_message_nomouse(char* s, int redraw_current)
{// addr = 0x080771CE
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    disp_message_nsec(s, redraw_current, 10, 0, 0);
    return;
}

set_delayed_message(char* s)
{// addr = 0x08077200
    _unknown_ _v24;
    _unknown_ __ebp;

    delayed_msg = allocStr(s, -1);
    return;
}

cursorUp0(Buffer* buf, int n)
{// addr = 0x08077220
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    if((buf->cursorY & 65535 & 4294967295) <= 0) {
        buf->topLine = lineSkip(buf, buf->topLine,  ~n, 0);
        if(buf->currentLine->prev != 0) {
            buf->currentLine = buf->currentLine->prev;
        }
        arrangeLine(buf);
        return;
    }
    cursorUpDown(buf, -1);
    return;
}

cursorUp(Buffer* buf, int n)
{// addr = 0x0807729E
    Line* l;
    Line* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = buf->currentLine;
    if(buf->firstLine == 0) {
        return ;
    }
    while(buf->currentLine->prev != 0 && buf->currentLine->bpos != 0) {
        cursorUp0(buf, n);
    }
}

cursorDown0(Buffer* buf, int n)
{// addr = 0x0807737B
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    asm("cwde ");
    if((buf->cursorY & 65535 & 4294967295) >= (buf->LINES & 65535) - 1) {
        buf->topLine = lineSkip(buf, buf->topLine, n, 0);
        if(buf->currentLine->next != 0) {
            buf->currentLine = buf->currentLine->next;
        }
        arrangeLine(buf);
        return;
    }
    cursorUpDown(buf, 1);
    return;
}

cursorDown(Buffer* buf, int n)
{// addr = 0x08077402
    Line* l;
    Line* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = buf->currentLine;
    if(buf->firstLine == 0) {
        return ;
    }
    while(buf->currentLine->next != 0 && buf->currentLine->next->bpos != 0) {
        cursorDown0(buf, n);
    }
}

cursorUpDown(Buffer* buf, int n)
{// addr = 0x080774F1
    Line* cl;
    Line* _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = buf->currentLine;
    if(buf->firstLine == 0) {
        return ;
    }
    buf->currentLine = currentLineSkip(buf, _v16, n, 0);
    if(buf->currentLine == _v16) {
        return ;
    }
    arrangeLine(buf);
    return;
}

cursorRight(Buffer* buf, int n)
{// addr = 0x0807754F
    int i;
    int delta;
    int cpos;
    int vpos2;
    Line* l;
    Lineprop* p;
    int _v16;
    int _v20;
    int _v24;
    _unknown_ _v28;
    Line* _v32;
    Lineprop* _v36;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t210;
    _unknown_ _t211;
    _unknown_ _t220;
    _unknown_ _t224;
    _unknown_ _t301;

    _v20 = 1;
    _v32 = buf->currentLine;
    if(buf->firstLine == 0) {
        return ;
    }
    if(buf->pos == _v32->len) {
        if(_v32->next == 0) {
            return ;
        }
        if(_v32->next->bpos == 0) {
            return ;
        }
    }
    _v16 = buf->pos;
    _v36 = _v32->propBuf;
L6:
    while(_v16 + _v20 < _v32->len) {
        if(( *(_v16 + _v20 + _v16 + _v20 + _v36) & 65535 & 4294967295 &  & 1024) != 0) {
            _v20 = _v20 + 1;
            goto L6;
        }
        if(_v16 + _v20 >= _v32->len) {
            if(_v32->len != 0) {
                if(_v32->next == 0 || _v32->next->bpos == 0) {
                    buf->pos = _v32->len - 1;
L17:
                    while(buf->pos != 0 && ( *(buf->pos + buf->pos + _v36) & 65535 & 4294967295 &  & 1024) != 0) {
                        goto L16;
                    }
                } else {
                    cursorDown0(buf, 1);
                    buf->pos = 0;
                    arrangeCursor(buf);
                    return;
                }
L16:
                buf->pos = buf->pos - 1;
                goto L17;
            } else {
                buf->pos = 0;
            }
        } else {
            buf->pos = _v16 + _v20;
        }
L19:
        _v24 = calcPosition( *_v32, _v32->propBuf, _v32->len, buf->pos, 0, 0);
        buf->visualpos = _v32->bwidth + _v24 - buf->currentColumn;
        _v20 = 1;
        while(buf->pos + _v20 < _v32->len && ( *(buf->pos + _v20 + buf->pos + _v20 + _v36) & 65535 & 4294967295 &  & 1024) != 0) {
            _v20 = _v20 + 1;
        }
    }
}

cursorLeft(Buffer* buf, int n)
{// addr = 0x08077833
    int i;
    int delta;
    int cpos;
    Line* l;
    Lineprop* p;
    int _v16;
    intOrPtr _v20;
    int _v24;
    Line* _v28;
    Lineprop* _v32;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t132;
    _unknown_ _t133;
    _unknown_ _t144;
    _unknown_ _t148;
    _unknown_ _t196;

    _v20 = 1;
    _v28 = buf->currentLine;
    if(buf->firstLine == 0) {
        return ;
    }
    _v16 = buf->pos;
    _v32 = _v28->propBuf;
    while(_v16 - _v20 > 0) {
        if(( *(_v16 - _v20 + _v16 - _v20 + _v32) & 65535 & 4294967295 &  & 1024) != 0) {
            _v20 = _v20 + 1;
            continue;
        }
        if(_v16 < _v20) {
            if(_v28->prev == 0 || _v28->bpos == 0) {
                buf->pos = 0;
            } else {
                cursorUp0(buf, -1);
                buf->pos = buf->currentLine->len - 1;
                arrangeCursor(buf);
                return;
            }
        } else {
            buf->pos = _v16 - _v20;
        }
        _v24 = calcPosition( *_v28, _v28->propBuf, _v28->len, buf->pos, 0, 0);
        buf->visualpos = _v28->bwidth + _v24 - buf->currentColumn;
        if(buf->visualpos - _v28->bwidth < 0 && n != 0) {
            columnSkip(buf, buf->visualpos - n - _v28->bwidth - (buf->visualpos - _v28->bwidth) % n);
            buf->visualpos = _v28->bwidth + _v24 - buf->currentColumn;
        }
        buf->cursorX = buf->visualpos & 4294967295;
        return;
    }
}

cursorHome(Buffer* buf)
{// addr = 0x08077A04
    _unknown_ __ebp;

    buf->visualpos = 0;
    buf->cursorY = 0;
    buf->cursorX = buf->cursorY & 65535 & 4294967295;
    return;
}

arrangeCursor(Buffer* buf)
{// addr = 0x08077A2A
    int col;
    int col2;
    int pos;
    int delta;
    _unknown_ _v16;
    _unknown_ _v20;
    int _v24;
    int _v28;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t216;
    _unknown_ _t274;
    _unknown_ _t275;
    _unknown_ _t276;
    _unknown_ _t295;
    _unknown_ _t296;
    _unknown_ _t297;
    _unknown_ _t302;

    _v28 = 1;
    if(buf == 0) {
        return ;
    }
    if(buf->currentLine == 0) {
        return ;
    }
    asm("cwde ");
    if(buf->currentLine->linenumber - buf->topLine->linenumber >= (buf->LINES & 65535) || buf->currentLine->linenumber >= buf->topLine->linenumber) {
L4:
        buf->topLine = lineSkip(buf, buf->currentLine, 0, 0);
L7:
        while(buf->pos < 0) {
            goto L8;
        }
    } else {
        goto L4;
    }
L8:
    if(buf->currentLine->prev == 0) {
        goto L14;
    }
    if(buf->currentLine->bpos != 0) {
        _v24 = buf->pos + buf->currentLine->prev->len;
        cursorUp0(buf, 1);
        buf->pos = _v24;
        goto L7;
    } else {
L14:
        while(buf->pos >= buf->currentLine->len && buf->currentLine->next != 0) {
            if(buf->currentLine->next->bpos != 0) {
                _v24 = buf->pos - buf->currentLine->len;
                cursorDown0(buf, 1);
                buf->pos = _v24;
                continue;
            }
            if(buf->currentLine->len != 0 && buf->pos >= 0) {
                if(buf->pos >= buf->currentLine->len) {
                    buf->pos = buf->currentLine->len - 1;
                }
L24:
                while(buf->pos > 0 && ( *(buf->currentLine->propBuf + buf->pos + buf->pos) & 65535 & 4294967295 &  & 1024) != 0) {
                    buf->pos = buf->pos - 1;
                }
            } else {
                buf->pos = 0;
            }
            goto L24;
        }
    }
    goto L8;
}

arrangeLine(Buffer* buf)
{// addr = 0x08077DD8
    int i;
    int cpos;
    int _v16;
    signed int _v20;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t70;
    _unknown_ _t71;
    _unknown_ _t72;

    if(buf->firstLine == 0) {
        return ;
    }
    buf->cursorY = buf->currentLine->linenumber & 4294967295;
    _v16 = columnPos(buf->currentLine, buf->currentColumn + buf->visualpos - buf->currentLine->bwidth);
    _v20 = calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len, _v16, 0, 0) - buf->currentColumn;
    if(_v20 >= 0) {
        if(buf->currentLine->len <= _v16) {
            buf->cursorX = 0;
            buf->pos = 0;
            return;
        }
    } else {
        buf->cursorX = _v20 & 4294967295;
        buf->pos = _v16;
        return;
    }
L4:
    buf->cursorX = 0;
    buf->pos = _v16 + 1;
    return;
}

cursorXY(Buffer* buf, int x, int y)
{// addr = 0x08077EE9
    int oldX;
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    asm("cwde ");
    cursorUpDown(buf, y - (buf->cursorY & 65535));
    asm("cwde ");
    if((buf->cursorX & 65535) <= x) {
        asm("cwde ");
        if((buf->cursorX & 65535) >= x) {
            return ;
        }
        while(1) {
L8:
            asm("cwde ");
            if((buf->cursorX & 65535) >= x) {
                break;
            }
            asm("cwde ");
            _v16 = buf->cursorX & 65535;
            asm("cwde ");
            cursorRight(buf, (buf->COLS & 65535) + (buf->COLS & 65535));
            asm("cwde ");
            if((buf->cursorX & 65535) == _v16) {
                goto L11;
            }
            continue;
L11:
            asm("cwde ");
            if((buf->cursorX & 65535) <= x) {
                return ;
            }
            asm("cwde ");
            cursorLeft(buf, (buf->COLS & 65535) + (buf->COLS & 65535));
            return;
        }
        goto L11;
    }
    while(1) {
        asm("cwde ");
        if((buf->cursorX & 65535) <= x) {
            break;
        }
        asm("cwde ");
        cursorLeft(buf, (buf->COLS & 65535) + (buf->COLS & 65535));
    }
    return;
}

restorePosition(Buffer* buf, Buffer* orig)
{// addr = 0x08077FDF
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t46;
    int _t51;

    if(orig->topLine == 0) {
        _t46 = 0;
    } else {
        _t46 = orig->topLine->linenumber - 1;
    }
    buf->topLine = lineSkip(buf, buf->firstLine, _t46, 0);
    if(orig->currentLine == 0) {
        _t51 = 1;
    } else {
        _t51 = orig->currentLine->linenumber;
    }
    gotoLine(buf, _t51);
    buf->pos = orig->pos;
    if(buf->currentLine != 0 && orig->currentLine != 0) {
        buf->pos = buf->pos + orig->currentLine->bpos - buf->currentLine->bpos;
    }
    buf->currentColumn = orig->currentColumn;
    arrangeCursor(buf);
    return;
}

int columnSkip(Buffer* buf, int offset)
{// addr = 0x080780B8
    int i;
    int maxColumn;
    int column;
    int nlines;
    Line* l;
    int _v16;
    int _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    struct _Line* _v32;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t75;
    _unknown_ _t76;
    _unknown_ _t94;
    _unknown_ _t97;

    _v24 = buf->currentColumn + offset;
    asm("cwde ");
    _v28 = (buf->LINES & 65535) + 1;
    _v20 = 0;
    _v16 = 0;
    _v32 = buf->topLine;
    while(_v16 < _v28 && _v32 != 0) {
        if(_v32->width < 0) {
            _v32->width = calcPosition( *_v32, _v32->propBuf, _v32->len, _v32->len, 0, 0);
        }
        if(_v32->width - 1 > _v20) {
            _v20 = _v32->width - 1;
        }
        _v16 = _v16 + 1;
        _v32 = _v32->next;
    }
}

int columnPos(Line* line, int column)
{// addr = 0x080781C9
    int i;
    int _v16;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = 1;
    while(line->len > _v16) {
        if(calcPosition(line->lineBuf, line->propBuf, line->len, _v16, 0, 0) <= column) {
            _v16 = _v16 + 1;
            continue;
        }
        _v16 = _v16 - 1;
        while(_v16 > 0) {
            if(( *(line->propBuf + _v16 + _v16) & 65535 & 4294967295 &  & 1024) == 0) {
                return _v16;
            }
            _v16 = _v16 - 1;
        }
    }
}

Line* lineSkip(Buffer* buf, Line* line, int offset, int last)
{// addr = 0x0807825D
    int i;
    Line* l;
    intOrPtr _v16;
    struct _Line* _v20;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;

    _v20 = currentLineSkip(buf, line, offset, last);
    if(nextpage_topline != 0) {
        return _v20;
    }
    asm("cwde ");
    _v16 = (buf->LINES & 65535) - 1 + _v20->linenumber - buf->lastLine->linenumber;
    while(_v16 > 0) {
        if(_v20->prev == 0) {
            return _v20;
        }
        _v16 = _v16 - 1;
        _v20 = _v20->prev;
    }
}

Line* currentLineSkip(Buffer* buf, Line* line, int offset, int last)
{// addr = 0x080782DE
    int i;
    int n;
    Line* l;
    intOrPtr _v16;
    intOrPtr _v20;
    Line* _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t98;

    _v24 = line;
    if( *((intOrPtr*)(buf + 92)) == 0) {
L9:
        if(offset == 0) {
            return _v24;
        }
        if(offset <= 0) {
            _v16 = 0;
            while( ~offset > _v16) {
                if(_v24->prev == 0) {
                    return _v24;
                }
                _v16 = _v16 + 1;
                _v24 = _v24->prev;
            }
        } else {
            _v16 = 0;
            while(_v16 < offset) {
                if(_v24->next == 0) {
                    return _v24;
                }
                _v16 = _v16 + 1;
                _v24 = _v24->next;
            }
        }
    }
    asm("cwde ");
    if((buf->bufferprop & 65535 & 64) != 0) {
        goto L9;
    } else {
        asm("cwde ");
        _v20 = line->linenumber + offset + (buf->LINES & 65535);
        if(buf->lastLine->linenumber < _v20) {
            getNextPage(buf, _v20 - buf->lastLine->linenumber);
        }
        while(last != 0 || buf->lastLine->linenumber < _v20) {
            if(getNextPage(buf, 1) != 0) {
                continue;
            }
            if(last != 0) {
                _v24 = buf->lastLine;
            }
            goto L9;
        }
    }
    return _v24;
}

int gethtmlcmd(char** s)
{// addr = 0x080783F7
    char[127] cmdstr;
    char* p;
    char* save;
    int cmd;
    intOrPtr _v16;
    char _v144;
    char* _v148;
    char* _v152;
    int _v156;
    char** _v160;
    _unknown_ _v180;
    _unknown_ _v184;
    _unknown_ __ebp;
    _unknown_ _t90;
    signed int _t113;
    signed int _t151;
    int _t169;
    _unknown_ _t206;
    _unknown_ _t218;

    _v160 = s;
    _v16 =  *gs:0x14];
    _v148 =  &_v144;
    _v152 =  *_v160;
     *_v160 =  &(( *_v160)[1]);
    if(( *( &MYCTYPE_MAP + ( *( *_v160) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 12) != 0 || ( *( *_v160) & 255 & 4294967295) == 95 || ( *( *_v160) & 255 & 4294967295) == 47) {
        if(( *( &MYCTYPE_MAP + ( *( *_v160) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            _t113 =  *( *_v160) & 255;
        } else {
            _t113 =  *( *_v160) & 255 | 32;
        }
         *_v148 = _t113 & 4294967295;
        _v148 =  &(_v148[1]);
         *_v160 =  &(( *_v160)[1]);
        if(( *(_v148 - 1) & 255 & 4294967295) == 47) {
            while(( *( *_v160) & 255 & 4294967295) != 0) {
                if(( *( &MYCTYPE_MAP + ( *( *_v160) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                     *_v160 =  &(( *_v160)[1]);
                    continue;
                }
L18:
                while(( *( &MYCTYPE_MAP + ( *( *_v160) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 12) != 0 || ( *( *_v160) & 255 & 4294967295) == 95) {
                    if(_v148 -  &_v144 <= 127) {
                        if(( *( &MYCTYPE_MAP + ( *( *_v160) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                            _t151 =  *( *_v160) & 255;
                        } else {
                            _t151 =  *( *_v160) & 255 | 32;
                        }
                         *_v148 = _t151 & 4294967295;
                        _v148 =  &(_v148[1]);
                         *_v160 =  &(( *_v160)[1]);
                        continue;
                    }
                    _t218 = _v148 -  &_v144 - 128;
                    if(_t218 != 0) {
                         *_v148 = 0;
                        _v156 = getHash_si( &tagtable,  &_v144, 0);
L25:
                        while(( *( *_v160) & 255 & 4294967295) != 0 && ( *( *_v160) & 255 & 4294967295) != 62) {
                            goto L24;
                        }
                    }
                     *_v160 =  &(_v152[1]);
                    _t169 = 0;
L30:
                    if(_t218 == 0) {
                        return _t169;
                    }
                    __stack_chk_fail();
                    return _t169;
L24:
                     *_v160 =  &(( *_v160)[1]);
                    goto L25;
                }
            }
        }
        goto L18;
    }
    _t169 = 0;
    goto L30;
}

int parse_ansi_color(char** str, Lineprop* effect, Linecolor* color)
{// addr = 0x080786B3
    char* p;
    char* q;
    Lineprop e;
    Linecolor c;
    int i;
    signed int _v13;
    signed int _v16;
    char* _v20;
    char* _v24;
    _unknown_ _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t96;
    _unknown_ _t123;
    _unknown_ _t136;
    _unknown_ _t150;

    _v20 =  *str;
    _v16 =  *effect & 65535 & 4294967295;
    _v13 =  *color & 255 & 4294967295;
    if(( *_v20 & 255 & 4294967295) != 27) {
        return 0;
    }
    if((_v20[1] & 255 & 4294967295) != 91) {
        return 0;
    }
    _v20 =  &(_v20[2]);
    _v24 = _v20;
    while(1) {
    }
}

Str checkType(Str s, Lineprop** oprop, Linecolor** ocolor)
{// addr = 0x080788C5
    Lineprop mode;
    Lineprop effect;
    Lineprop* prop;
    char* str;
    char* endp;
    char* bs;
    Lineprop ceffect;
    Linecolor cmode;
    int check_color;
    Linecolor* color;
    char* es;
    int do_copy;
    int i;
    int plen;
    int clen;
    char* sp;
    char* ep;
    int ok;
    signed int _v13;
    signed int _v16;
    signed int _v18;
    signed int _v20;
    short unsigned int* _v24;
    void* _v28;
    intOrPtr _v32;
    void* _v36;
    signed int _v40;
    unsigned char* _v44;
    void* _v48;
    signed int _v52;
    signed int _v56;
    int _v60;
    signed int _v64;
    void* _v68;
    intOrPtr _v72;
    int _v76;
    _unknown_ _v84;
    int _v88;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t436;
    int _t551;
    Linecolor* _t589;
    signed int _t603;
    intOrPtr _t614;
    signed int _t633;
    int _t650;
    Linecolor* _t653;
    int _t655;
    Lineprop* _t658;
    char* _t734;
    _unknown_ _t757;
    _unknown_ _t759;

    _v18 = 0;
    _v28 = s->ptr;
    _v32 = s->ptr + s->length;
    _v36 = 0;
    _v20 = 0;
    _v13 = 0;
    _v40 = 0;
    _v44 = 0;
    _v48 = 0;
    _v52 = 0;
    _v60 = 0;
    if(s->length > prop_size) {
        _t655 = s->length;
        _t656 = _t655 - 256 < 0 ? 256 : _t655;
        prop_size = _t655 - 256 < 0 ? 256 : _t655;
        _t658 = prop_buffer;
        _v88 = prop_size + prop_size;
         *__esp = _t658;
        GC_realloc();
        prop_buffer = _t658;
    }
    _v24 = prop_buffer;
    if(ShowEffect == 0) {
L27:
        if(_v52 != 0) {
L119:
            while(_v28 < _v32) {
                if(_v24 - prop_buffer >> 1 >= prop_size) {
                    goto L122;
                }
                if(_v36 == 0) {
L87:
                    if(_v48 == 0) {
L96:
                        _v60 =  *( &WTF_LEN_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                        _v16 = (_v18 & 65535 | ( *( &WTF_TYPE_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 8) & 4294967295;
                        if(_v44 != 0) {
                             *_v44 = _v13 & 255 & 4294967295;
                            _v44 =  &(_v44[1]);
                            _v16 = _v16 | _v20 & 65535 & 4294967295;
                        }
                         *_v24 = _v16 & 65535 & 4294967295;
                        _v24 =  &(_v24[1]);
                        if(_v60 <= 1) {
                            if(_v52 != 0) {
                                if(s->length + 1 >= s->area_size) {
                                    Strgrow(s);
                                }
                                _t436 = s->length;
                                 *(s->ptr + _t436) =  *_v28 & 255 & 4294967295;
                                s->length = _t436 + 1;
                                 *(s->ptr + s->length) = 0;
                            }
                            _v28 =  &(_v28[0]);
                            _v18 = 0;
                            continue;
                        }
                        _v16 = _v16 & 65535 & 4294967295;
                        _v56 = 1;
                        while(_v56 < _v60) {
                             *_v24 = _v16 & 65535 & 4294967295;
                            _v24 =  &(_v24[1]);
                            if(_v44 != 0) {
                                 *_v44 = _v13 & 255 & 4294967295;
                                _v44 =  &(_v44[1]);
                            }
                            _v56 = _v56 + 1;
                        }
                    }
                    goto L88;
                }
                if(_v36 - 2 != _v28 || strncmp(_v28, 135048576, 4) != 0) {
                    if(_v36 - 1 != _v28 || ( *_v28 & 255 & 4294967295) != 95) {
                        if(_v28 != _v36) {
                            if(_v28 > _v36) {
                                _v36 = memchr(_v28, 8, _v32 - _v28);
                            }
                            goto L87;
                        }
                    } else {
                        _v28 =  &(_v28[0]);
                        _v18 = 2;
                        if(_v28 < _v32) {
                            _v36 = memchr(_v28, 8, _v32 - _v28);
                        }
                        continue;
                    }
L47:
                    if((_v28[0] & 255 & 4294967295) != 95) {
L54:
                        if(strncmp( &(_v28[0]), 135048581, 3) != 0) {
L64:
                            if((_v28[0] & 255 & 4294967295) != 8) {
L74:
                                if(s->length == 0) {
L82:
                                    _v28 =  &(_v28[0]);
                                    goto L83;
                                }
                                goto L75;
                            }
                            goto L65;
L75:
                            _v64 =  *( &WTF_LEN_MAP + (_v28[0] & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                            if(_v60 != _v64 || strncmp(_v28 +  ~_v60,  &(_v28[0]), _v60) != 0) {
                                Strshrink(s, _v60);
                                _v24 = _v24 +  ~(_v60 + _v60);
                                _v28 =  &(_v28[0]);
                                goto L83;
                            } else {
                                _v56 = 1;
                                while(_v56 <= _v60) {
                                     *(_v24 +  ~(_v56 + _v56)) = ( *(_v24 +  ~(_v56 + _v56)) & 65535 | 8) & 4294967295;
                                    _v56 = _v56 + 1;
                                }
                            }
                            goto L82;
                        }
                        goto L55;
L65:
                        if(s->length == 0) {
L73:
                            _v28 =  &(_v28[0]);
                            goto L83;
                        }
                        _v64 =  *( &WTF_LEN_MAP + (_v28[0] & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                        if(_v60 != _v64 || strncmp(_v28 +  ~_v60,  &(_v28[0]), _v60) != 0) {
                            Strshrink(s, _v60);
                            _v24 = _v24 +  ~(_v60 + _v60);
                            _v28 =  &(_v28[0]);
                            goto L83;
                        } else {
                            _v56 = 1;
                            while(_v56 <= _v60) {
                                 *(_v24 +  ~(_v56 + _v56)) = ( *(_v24 +  ~(_v56 + _v56)) & 65535 | 8) & 4294967295;
                                _v56 = _v56 + 1;
                            }
                        }
                        goto L73;
                    }
                    if(s->length == 0) {
                        _v28 =  &(_v28[0]);
L83:
                        if(_v28 < _v32) {
                            _v36 = memchr(_v28, 8, _v32 - _v28);
                        }
                        continue;
                    }
                    _v28 =  &(_v28[0]);
                    _v56 = 1;
                    while(_v56 <= _v60) {
                         *(_v24 +  ~(_v56 + _v56)) = ( *(_v24 +  ~(_v56 + _v56)) & 65535 | 2) & 4294967295;
                        _v56 = _v56 + 1;
                    }
                    goto L54;
L55:
                    if(s->length == 0) {
                        _v28 =  &(_v28[0]);
                        goto L83;
                    }
                    _t734 = _v28;
                    if(_v60 != 1) {
                        _t551 = 4;
                    } else {
                        _t551 = 3;
                    }
                    _v28 =  &(_t734[_t551]);
                    _v56 = 1;
                    while(_v56 <= _v60) {
                         *(_v24 +  ~(_v56 + _v56)) = ( *(_v24 +  ~(_v56 + _v56)) & 65535 | 2) & 4294967295;
                        _v56 = _v56 + 1;
                    }
                    goto L64;
                } else {
                    _v28 =  &(_v28[1]);
                    _v18 = 2;
                    if(_v28 < _v32) {
                        _v36 = memchr(_v28, 8, _v32 - _v28);
                    }
                    continue;
                }
L88:
                if(_v28 != _v48) {
                    if(_v28 > _v48) {
                        _v48 = memchr(_v28, 27, _v32 - _v28);
                    }
                    goto L96;
                }
                _v76 = parse_ansi_color( &_v28,  &_v20,  &_v13);
                if(_v28 < _v32) {
                    _v48 = memchr(_v28, 27, _v32 - _v28);
                }
                if(_v76 == 0) {
                    goto L96;
                } else {
                    if((_v13 & 255 & 4294967295) != 0) {
                        _v40 = 1;
                    }
                    continue;
                }
L122:
                 *oprop = prop_buffer;
                if(ocolor == 0) {
                    return s;
                }
                if(_v40 == 0) {
                    _t589 = 0;
                } else {
                    _t589 = color_buffer;
                }
                 *ocolor = _t589;
                return s;
            }
        }
        goto L28;
        goto L119;
    } else {
        _v36 = memchr(_v28, 8, s->length);
        if(ocolor != 0) {
            _v48 = memchr(_v28, 27, s->length);
            if(_v48 != 0) {
                if(s->length > color_size) {
                    _t650 = s->length;
                    _t651 = _t650 - 256 < 0 ? 256 : _t650;
                    color_size = _t650 - 256 < 0 ? 256 : _t650;
                    _t653 = color_buffer;
                    _v88 = color_size;
                     *__esp = _t653;
                    GC_realloc();
                    color_buffer = _t653;
                }
                _v44 = color_buffer;
            }
        }
        if(_v36 != 0 || _v48 != 0) {
            _v68 = _v28;
            s = Strnew_size(s->length);
            _v52 = 1;
            if(_v36 == 0) {
                _t614 = _v32;
            } else {
                _t614 = _v36 - 2;
            }
            _v72 = _t614;
            if(_v48 != 0) {
                if(_v48 - 2 < _v72) {
                    _v72 = _v48 - 2;
                }
            }
            while(_v28 < _v72 && ( *( &MYCTYPE_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 17) != 0) {
                if(( *( &MYCTYPE_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 1 & 4294967295) == 0) {
                    _t633 = 0;
                } else {
                    _t633 = 256;
                }
                 *_v24 = _t633 & 4294967295;
                _v24 =  &(_v24[1]);
                if(_v44 != 0) {
                     *_v44 = 0;
                    _v44 =  &(_v44[1]);
                }
                _v28 =  &(_v28[0]);
            }
        }
        goto L27;
    }
L28:
    while(_v28 < _v32) {
        if(( *( &MYCTYPE_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 17) != 0) {
            if(( *( &MYCTYPE_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 1 & 4294967295) == 0) {
                _t603 = 0;
            } else {
                _t603 = 256;
            }
             *_v24 = _t603 & 4294967295;
            _v24 =  &(_v24[1]);
            _v28 =  &(_v28[0]);
            continue;
        }
        goto L119;
    }
}

int nextColumn(int n, char* p, Lineprop* pr)
{// addr = 0x080791C2
    int _v8;
    _unknown_ __ebp;
    signed int _t48;
    _unknown_ _t74;
    _unknown_ _t75;

    if(( *pr & 65535 & 4294967295 &  & 256) == 0) {
        if(( *pr & 65535 & 4294967295 &  & 4096) != 0) {
            return n + 4;
        }
        if(( *135119023 & 255 & 4294967295) == 0) {
            _t48 =  *( &WTF_WIDTH_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            return _t48 + n;
        }
        _t48 =  *( &WTF_WIDTH_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        return _t48 + n;
    }
    if(( *p & 255 & 4294967295) != 9) {
        if(( *p & 255 & 4294967295) == 10) {
            return n + 1;
        }
        if(( *p & 255 & 4294967295) == 13) {
            return n;
        }
        return n + 2;
    }
    _v8 = Tabstop;
    return Tabstop * (Tabstop + n) / _v8;
}

int calcPosition(char* l, Lineprop* pr, int len, int pos, int bpos, int mode)
{// addr = 0x08079289
    int i;
    int j;
    signed int _v16;
    int _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t121;
    int* _t124;
    _unknown_ _t146;

    if(l == 0) {
        return bpos;
    }
    if(len == 0) {
        return bpos;
    }
    if(l ==  *135776772) {
        if(mode == 0) {
            if(pos <= len) {
                return realColumn[pos];
            }
        }
    }
    if(len + 1 >  *135776780) {
        _t121 = len + 1;
        _t122 = _t121 - 256 < 0 ? 256 : _t121;
         *135776780 = _t121 - 256 < 0 ? 256 : _t121;
        _t124 =  *135776780 << 2;
         *__esp = _t124;
        GC_malloc();
        realColumn = _t124;
    }
     *135776772 = l;
    _v16 = 0;
    _v20 = bpos;
    if(( *(_v16 + _v16 + pr) & 65535 & 4294967295 &  & 1024) == 0) {
        while(1) {
L19:
            realColumn[_v16] = _v20;
            if(_v16 == len) {
                break;
            }
            _v20 = nextColumn(_v20,  &(l[_v16]), _v16 + _v16 + pr);
            _v16 = _v16 + 1;
            while(_v16 < len) {
                if(( *(_v16 + _v16 + pr) & 65535 & 4294967295 &  & 1024) != 0) {
                    realColumn[_v16] = realColumn[_v16 - 1];
                    _v16 = _v16 + 1;
                    continue;
                }
                goto L19;
            }
        }
    } else {
        while(_v16 < len && ( *(_v16 + _v16 + pr) & 65535 & 4294967295 &  & 1024) != 0) {
        }
    }
    if(pos >= _v16) {
        return _v20;
    }
    return realColumn[pos];
}

int columnLen(Line* line, int column)
{// addr = 0x08079452
    int i;
    int j;
    int _v8;
    int _v12;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ __ebp;

    _v8 = 0;
    _v12 = 0;
    while(line->len > _v8) {
        _v12 = nextColumn(_v12, line->lineBuf + _v8, line->propBuf + _v8 + _v8);
        if(_v12 > column) {
            return _v8;
        }
        _v8 = _v8 + 1;
        while(line->len > _v8 && ( *(line->propBuf + _v8 + _v8) & 65535 & 4294967295 &  & 1024) != 0) {
            _v8 = _v8 + 1;
        }
    }
}

char* lastFileName(char* path)
{// addr = 0x080794E8
    char* p;
    char* q;
    char* _v16;
    char* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v20 = path;
    _v16 = _v20;
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *_v16 & 255 & 4294967295) == 47) {
            _v20 =  &(_v16[1]);
        }
        _v16 =  &(_v16[1]);
    }
}

char* mybasename(char* s)
{// addr = 0x08079532
    char* p;
    char* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = s;
    while(( *_v16 & 255 & 4294967295) != 0) {
        _v16 =  &(_v16[1]);
    }
}

char* mydirname(char* s)
{// addr = 0x08079591
    char* p;
    char* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t45;
    _unknown_ _t54;

    _v16 = s;
    while(( *_v16 & 255 & 4294967295) != 0) {
    }
}

int next_status(char c, int* status)
{// addr = 0x08079647
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t10;
    _unknown_ _t11;

    _v8 = c & 4294967295;
    if( *status > 15) {
        return 0;
    }
    goto __eax;
}

int read_token(Str buf, char** instr, int* status, int pre, int append)
{// addr = 0x0807999A
    char* p;
    int prev_status;
    char* _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t34;
    _unknown_ _t37;
    _unknown_ _t39;
    _unknown_ _t40;

    if(append == 0) {
        Strclear(buf);
    }
    if(( *( *instr) & 255 & 4294967295) == 0) {
        return 0;
    }
    _v16 =  *instr;
    while(( *_v16 & 255 & 4294967295) != 0) {
        _v20 =  *status;
        next_status( *_v16 & 255 & 4294967295, status);
        if( *status > 15) {
            _v16 =  &(_v16[1]);
            continue;
        }
        goto __eax;
    }
}

Str correct_irrtag(int status)
{// addr = 0x08079E3B
    char c;
    Str tmp;
    struct _Str* _v20;
    _unknown_ __ebp;
    _unknown_ _t8;
    _unknown_ _t13;

    _v20 = Strnew();
    if(status == 0) {
        return _v20;
    }
    if(status > 15) {
        return _v20;
    }
    goto __eax;
}

add_auth_pass_entry(const struct auth_pass* ent, int netrc, int override)
{// addr = 0x08079EF2
    struct auth_pass* newent;
    struct auth_pass* ep;
    struct auth_pass* _v16;
    struct auth_pass* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    const struct auth_pass* _t35;
    const struct auth_pass* _t39;
    _unknown_ _t43;
    const struct auth_pass* _t57;

    _t35 = ent;
    _t36 =  *(_t35 + 8);
    if( *(_t35 + 8) == 0) {
        if(netrc == 0) {
            return ;
        }
    }
    if(ent->is_proxy == 0) {
        _t57 = ent;
        _t36 =  *(_t57 + 16);
        if( *(_t57 + 16) == 0) {
            if(netrc == 0) {
                return ;
            }
        }
    }
    _t39 = ent;
    _t36 =  *(_t39 + 20);
    if( *(_t39 + 20) == 0) {
        return ;
    }
    _t36 =  *(ent + 24);
    if(_t36 == 0) {
        return ;
    }
     *__esp = 32;
    GC_malloc();
    _v16 = _t36;
    memcpy(_v16, ent, 32);
    if(override == 0) {
        if(passwords != 0) {
            if(passwords->next != 0) {
                _v20 = passwords;
L15:
                while(_v20->next != 0) {
                    goto L14;
                }
            }
            goto L12;
L14:
            _v20 = _v20->next;
            goto L15;
        }
        goto L10;
L12:
        passwords->next = _v16;
        return;
    } else {
        _v16->next = passwords;
        passwords = _v16;
        return;
    }
L10:
    passwords = _v16;
    return;
}

struct auth_pass* find_auth_pass_entry(char* host, int port, char* realm, char* uname, int is_proxy)
{// addr = 0x08079FDF
    struct auth_pass* ent;
    struct auth_pass* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t41;

    _v16 = passwords;
    while(1) {
    }
}

int find_auth_user_passwd(ParsedURL* pu, char* realm, Str* uname, Str* pwd, int is_proxy)
{// addr = 0x0807A0BE
    struct auth_pass* ent;
    struct auth_pass* _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t38;
    _unknown_ _t43;
    _unknown_ _t52;

    if(pu->user == 0 || pu->pass == 0) {
        _v16 = find_auth_pass_entry(pu->host, pu->port, realm, pu->user, is_proxy);
        if(_v16 == 0) {
            return 0;
        }
         *uname =  *(_v16 + 20);
         *pwd =  *(_v16 + 24);
        return 1;
    }
     *uname = Strnew_charp(pu->user);
     *pwd = Strnew_charp(pu->pass);
    return 1;
}

add_auth_user_passwd(ParsedURL* pu, char* realm, Str uname, Str pwd, int is_proxy)
{// addr = 0x0807A167
    struct auth_pass ent;
    struct auth_pass _v44;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t22;

    memset( &_v44, 0, 32);
    _v44.is_proxy = is_proxy;
    _v44.host = Strnew_charp(pu->host);
    _v44.port = pu->port;
    _v44.realm = Strnew_charp(realm);
    _v44.uname = uname;
    _v44.pwd = pwd;
    add_auth_pass_entry( &_v44, 0, 1);
    return;
}

invalidate_auth_user_passwd(ParsedURL* pu, char* realm, Str uname, Str pwd, int is_proxy)
{// addr = 0x0807A1DF
    struct auth_pass* ent;
    struct auth_pass* _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = find_auth_pass_entry(pu->host, pu->port, realm, 0, is_proxy);
    if(_v16 == 0) {
        return ;
    }
     *_v16 = 1;
    return;
}

Str next_token(Str arg)
{// addr = 0x0807A227
    Str narg;
    char* p;
    char* q;
    signed char _v16;
    char* _v20;
    char* _v24;
    _unknown_ __ebp;
    _unknown_ _t35;

    _v16 = 0;
    if(arg == 0) {
        return 0;
    }
    if(arg->length == 0) {
        return 0;
    }
    _v20 = arg->ptr;
    _v24 = _v20;
L5:
    while(( *_v24 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
            _v24 =  &(_v24[1]);
            goto L5;
        }
        if(( *_v24 & 255 & 4294967295) == 0) {
            return _v16;
        }
         *_v24 = 0;
        _v24 =  &(_v24[1]);
        while(( *_v24 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v24 =  &(_v24[1]);
        }
    }
}

parsePasswd(FILE* fp, int netrc)
{// addr = 0x0807A2E1
    struct auth_pass ent;
    Str line;
    Str arg;
    char* p;
    struct _Str* _v16;
    struct _Str* _v20;
    _unknown_ _v24;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    void _v56;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t106;
    _unknown_ _t128;

    _v16 = 0;
    bzero( &_v56, 32);
    while(1) {
        _v20 = 0;
        if(_v16 == 0 || _v16->length == 0) {
            _v16 = Strfgets(fp);
        }
        goto L4;
    }
    _v20 = 0;
    if(_v16 == 0 || _v16->length == 0) {
        _v16 = Strfgets(fp);
    }
    goto L4;
L4:
    if( *((intOrPtr*)( *((intOrPtr*)((char*)( &_v16))) + 4)) != 0) {
        goto L6;
    } else {
L5:
        add_auth_pass_entry((char*)( &_v56),  *((intOrPtr*)((int*)( &netrc))), 0);
        return;
L50:
    }
L6:
    Strchop( *((intOrPtr*)((char*)( &_v16))));
    Strremovefirstspaces( *((intOrPtr*)((char*)( &_v16))));
     *((intOrPtr*)((char*)( &_v24))) =  *((intOrPtr*)( *((intOrPtr*)((char*)( &_v16)))));
    if(( *((char*)( *((intOrPtr*)((char*)( &_v24))))) & 255 & 4294967295) == 35 || ( *((char*)( *((intOrPtr*)((char*)( &_v24))))) & 255 & 4294967295) == 0) {
L8:
         *((intOrPtr*)((char*)( &_v16))) = 0;
        goto L49;
    } else {
        goto L9;
    }
L49:
    goto L1;
L9:
     *((intOrPtr*)((char*)( &_v20))) = next_token( *((intOrPtr*)((char*)( &_v16))));
    if(strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("machine")) == 0 || strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("host")) == 0 ||  *((intOrPtr*)((int*)( &netrc))) != 0 && strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("default")) == 0) {
L13:
        add_auth_pass_entry((char*)( &_v56),  *((intOrPtr*)((int*)( &netrc))), 0);
        bzero((char*)( &_v56), 32);
        if( *((intOrPtr*)((int*)( &netrc))) == 0) {
        } else {
L14:
             *((intOrPtr*)((char*)( &_v44))) = 21;
        }
        goto L15;
    } else {
        goto L19;
    }
L15:
    if(strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("default")) == 0) {
L17:
         *((intOrPtr*)((char*)( &_v16))) =  *((intOrPtr*)((char*)( &_v20)));
    } else {
L16:
         *((intOrPtr*)((char*)( &_v16))) = next_token( *((intOrPtr*)((char*)( &_v20))));
         *((intOrPtr*)((char*)( &_v48))) =  *((intOrPtr*)((char*)( &_v20)));
    }
    goto L18;
L18:
    goto L49;
L19:
    if( *((intOrPtr*)((int*)( &netrc))) != 0) {
        goto L23;
    } else {
        goto L20;
    }
L20:
    if(strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("port")) != 0 ||  *((intOrPtr*)((char*)( &_v20))) == 0) {
        goto L23;
    } else {
L22:
         *((intOrPtr*)((char*)( &_v16))) = next_token( *((intOrPtr*)((char*)( &_v20))));
         *((intOrPtr*)((char*)( &_v44))) = atoi( *((intOrPtr*)( *((intOrPtr*)((char*)( &_v20))))));
        goto L49;
    }
L23:
    if( *((intOrPtr*)((int*)( &netrc))) != 0 || strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("proxy")) != 0) {
        goto L26;
    } else {
L25:
         *((intOrPtr*)((char*)( &_v52))) = 1;
         *((intOrPtr*)((char*)( &_v16))) =  *((intOrPtr*)((char*)( &_v20)));
        goto L49;
    }
L26:
    if( *((intOrPtr*)((int*)( &netrc))) != 0 || strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("path")) != 0) {
        goto L29;
    } else {
L28:
         *((intOrPtr*)((char*)( &_v16))) = next_token( *((intOrPtr*)((char*)( &_v20))));
        goto L49;
    }
L29:
    if( *((intOrPtr*)((int*)( &netrc))) != 0 || strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("realm")) != 0) {
        goto L32;
    } else {
        goto L31;
    }
L31:
     *((intOrPtr*)((char*)( &_v16))) = 0;
     *((intOrPtr*)((char*)( &_v40))) =  *((intOrPtr*)((char*)( &_v20)));
    goto L49;
L32:
    if(strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("login")) != 0) {
        goto L34;
    } else {
        goto L33;
    }
L33:
     *((intOrPtr*)((char*)( &_v16))) = next_token( *((intOrPtr*)((char*)( &_v20))));
     *((intOrPtr*)((char*)( &_v36))) =  *((intOrPtr*)((char*)( &_v20)));
    goto L1;
L34:
    if(strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("password")) == 0 || strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("passwd")) == 0) {
        goto L36;
    } else {
        goto L37;
    }
L37:
    if( *((intOrPtr*)((int*)( &netrc))) == 0 || strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("machdef")) != 0) {
        goto L45;
    } else {
        goto L39;
    }
L39:
    goto L41;
L41:
     *((intOrPtr*)((char*)( &_v16))) = Strfgets( *((intOrPtr*)((FILE**)( &fp))));
    if( *((intOrPtr*)( *((intOrPtr*)((char*)( &_v16))) + 4)) != 0) {
        goto L40;
    } else {
        goto L42;
    }
L42:
    goto L44;
L44:
     *((intOrPtr*)((char*)( &_v16))) = 0;
    goto L49;
L40:
    if(( *((char*)( *((intOrPtr*)( *((intOrPtr*)((char*)( &_v16))))))) & 255 & 4294967295) == 10) {
        goto L43;
    } else {
        goto L41;
    }
L43:
    goto L44;
L45:
    if( *((intOrPtr*)((int*)( &netrc))) == 0 || strcmp( *((intOrPtr*)((char*)( &_v24))), (char*)("account")) != 0) {
        goto L48;
    } else {
        goto L47;
    }
L47:
     *((intOrPtr*)((char*)( &_v16))) = next_token( *((intOrPtr*)((char*)( &_v20))));
    goto L49;
L48:
     *((intOrPtr*)((char*)( &_v16))) = 0;
    goto L1;
L36:
     *((intOrPtr*)((char*)( &_v16))) = next_token( *((intOrPtr*)((char*)( &_v20))));
     *((intOrPtr*)((char*)( &_v32))) =  *((intOrPtr*)((char*)( &_v20)));
    goto L49;
}

FILE* openSecretFile(char* fname)
{// addr = 0x0807A631
    char* efname;
    struct stat st;
    char* _v16;
    signed int _v88;
    char _v104;
    _unknown_ _v116;
    char* _v120;
    _unknown_ __ebp;
    char* _t21;
    _unknown_ _t32;
    _unknown_ _t34;
    _unknown_ _t35;
    _unknown_ _t36;
    _unknown_ _t40;
    _unknown_ _t41;

    if(fname == 0) {
        return 0;
    }
    _v16 = expandPath(fname);
    _t21 = _v16;
    L080C7280(_t21,  &_v104);
    if(_t21 < 0) {
        return 0;
    }
    if(disable_secret_security_check != 0) {
        return fopen(_v16, "r");
    }
    if((_v88 & 63) == 0) {
        return fopen(_v16, "r");
    }
    if((fmInitialized & 255 & 4294967295) == 0) {
        _v120 = fname;
        fputs( *(Sprintf("SECURITY NOTE: file %s must not be accessible by others")), __imp__stderr);
        fputc(10, __imp__stderr);
    } else {
        _v120 = fname;
        message( *(Sprintf("SECURITY NOTE: file %s must not be accessible by others")), 0, 0);
        refresh();
    }
    sleep(2);
    return 0;
}

loadPasswd()
{// addr = 0x0807A73A
    FILE* fp;
    FILE* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t16;
    _unknown_ _t19;

    passwords = 0;
    _v16 = openSecretFile(passwd_file);
    if(_v16 != 0) {
        parsePasswd(_v16, 0);
        fclose(_v16);
    }
    _v16 = openSecretFile("~/.netrc");
    if(_v16 == 0) {
        return ;
    }
    parsePasswd(_v16, 1);
    fclose(_v16);
    return;
}

char* last_modified(Buffer* buf)
{// addr = 0x0807A7B3
    TextListItem* ti;
    struct stat st;
    struct _textlistitem* _v16;
    char _v104;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ __ebp;
    intOrPtr _t27;
    char* _t29;

    if(buf->document_header == 0) {
        if( *((intOrPtr*)(buf + 132)) != 4) {
            return (char*)("unknown");
        }
        _t27 =  *((intOrPtr*)(buf + 152));
        L080C7280(_t27,  &_v104);
        if(_t27 < 0) {
            return (char*)("unknown");
        }
        _t29 =  &_v104 + 64;
         *__esp = _t29;
        ctime();
        return _t29;
    }
    _v16 = buf->document_header->first;
    while(_v16 != 0) {
        if(strncasecmp( *_v16, "Last-modified: ", 15) == 0) {
            return  &(( *_v16)[0xf]);
        }
        _v16 = _v16->next;
    }
}

Str romanNum2(int l, int n)
{// addr = 0x0807A85F
    Str s;
    struct _Str* _v16;
    _unknown_ __ebp;
    _unknown_ _t6;
    _unknown_ _t10;
    _unknown_ _t11;

    _v16 = Strnew();
    if(n > 9) {
        return _v16;
    }
    goto __eax;
}

Str romanNumeral(int n)
{// addr = 0x0807AAFB
    Str r;
    struct _Str* _v16;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t49;
    _unknown_ _t52;
    _unknown_ _t59;
    _unknown_ _t64;
    _unknown_ _t71;
    _unknown_ _t76;
    _unknown_ _t83;
    _unknown_ _t114;
    _unknown_ _t117;
    _unknown_ _t120;
    _unknown_ _t123;
    _unknown_ _t126;
    _unknown_ _t129;

    _v16 = Strnew();
    if(n <= 0) {
        return _v16;
    }
    if(n <= 3999) {
        Strcat(_v16, romanNum2(3, (n * 274877907 >> 32 >> 6) - (n >> 31)));
        Strcat(_v16, romanNum2(2, ((n - (n >> 31) * ((_t96 * 274877907 >> 32 >> 6) - (n >> 31))) * 1374389535 >> 32 >> 5) - (n - (n >> 31) * ((_t96 * 274877907 >> 32 >> 6) - (n >> 31)) >> 31)));
        Strcat(_v16, romanNum2(1, ((n - (n >> 31) * ((_t97 * 1374389535 >> 32 >> 5) - (n >> 31))) * 1717986919 >> 32 >> 2) - (n - (n >> 31) * ((_t97 * 1374389535 >> 32 >> 5) - (n >> 31)) >> 31)));
        Strcat(_v16, romanNum2(0, n - ((n * 1717986919 >> 32 >> 2) - (_t113 >> 31) << 2) + (n * 1717986919 >> 32 >> 2) - (_t113 >> 31) + ((n * 1717986919 >> 32 >> 2) - (_t113 >> 31) << 2) + (n * 1717986919 >> 32 >> 2) - (_t113 >> 31)));
        return _v16;
    }
    Strcat_charp(_v16, 135048996);
    return _v16;
}

Str romanAlphabet(int n)
{// addr = 0x0807AC6D
    Str r;
    int l;
    char[13] buf;
    intOrPtr _v16;
    struct _Str* _v36;
    int _v40;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t54;
    _unknown_ _t55;
    _unknown_ _t58;
    _unknown_ _t67;
    int _t72;
    struct _Str* _t73;
    int _t77;
    struct _Str* _t83;
    _unknown_ _t91;
    _unknown_ _t96;
    _unknown_ _t108;

    _v16 =  *gs:0x14];
    Strnew();
    _v36 = 0;
    __eflags = n;
    if(__eflags > 0) {
        _v40 = 0;
        while(1) {
L4:
            __eflags = n;
            if(n == 0) {
                break;
            }
            goto L3;
        }
        _v40 = _v40 - 1;
        while(1) {
            __eflags = _v40;
            if(__eflags < 0) {
                break;
            }
            _t72 = _v36->length;
            _t73 = _v36;
            __eflags = _t72 + 1 - _t73->area_size;
            if(_t72 + 1 >= _t73->area_size) {
                Strgrow(_v36);
            }
            _t77 = _v36->length;
             *( *_v36 + _t77) =  *(__ebp + _v40 - 26) & 255 & 4294967295;
            _v36->length = _t77 + 1;
             *( *_v36 + _v36->length) = 0;
            _v40 = _v40 - 1;
        }
        _t83 = _v36;
        goto L11;
    }
    _t83 = _v36;
L11:
    if(__eflags == 0) {
        return _t83;
    }
    __stack_chk_fail();
    return _t83;
L3:
     *(__ebp + _v40 - 26) = n - 1 - (((n - 1) * 1321528399 >> 32 >> 3) - (n - 1 >> 31)) * (((n - 1) * 1321528399 >> 32 >> 3) - (n - 1 >> 31)) + 97 & 4294967295;
    _v40 = _v40 + 1;
    n = ((n - 1) * 1321528399 >> 32 >> 3) - (n - 1 >> 31);
    goto L4;
}

reset_signals()
{// addr = 0x0807AD75
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t11;
    _unknown_ _t12;
    _unknown_ _t13;
    _unknown_ _t14;
    _unknown_ _t15;
    _unknown_ _t16;
    _unknown_ _t17;
    _unknown_ _t18;
    _unknown_ _t19;
    _unknown_ _t20;

    mySignal(1, 0);
    mySignal(2, 0);
    mySignal(3, 0);
    mySignal(15, 0);
    mySignal(4, 0);
    mySignal(6, 0);
    mySignal(8, 0);
    mySignal(7, 0);
    mySignal(17, 1);
    mySignal(13, 1);
    return;
}

close_all_fds_except(int i, int f)
{// addr = 0x0807AE45
    int _v24;
    _unknown_ __ebp;
    int _t15;
    _unknown_ _t17;
    _unknown_ _t22;

    _t15 = i;
    if(_t15 == 1) {
L4:
        _v24 = 1;
         *__esp = "/dev/null";
        dup2(open(), 1);
L5:
        _v24 = 1;
         *__esp = "/dev/null";
        _t19 = dup2(open(), 2);
L6:
        i = 3;
L10:
        while(i <= 15) {
            _t19 = i;
            if(i != f) {
                close(i);
            }
            i = i + 1;
        }
    }
    if(_t15 == 2) {
        goto L5;
    } else {
        if(_t15 == 0) {
            _v24 = 0;
             *__esp = "/dev/null";
            dup2(open(), 0);
            goto L4;
        }
    }
    goto L6;
}

setup_child(int child, int i, int f)
{// addr = 0x0807AEF0
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t6;
    _unknown_ _t9;

    reset_signals();
    mySignal(2, 1);
    if(child == 0) {
        setpgrp();
    }
    close_tty();
    close_all_fds_except(i, f);
    QuietMessage = 1;
    fmInitialized = 0;
    TrapSignal = 0;
    return;
}

pid_t open_pipe_rw(FILE** fr, FILE** fw)
{// addr = 0x0807AF48
    int[1] fdr;
    int[1] fdw;
    pid_t pid;
    int _v16;
    int _v20;
    int _v24;
    int _v28;
    int _v32;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t40;
    _unknown_ _t42;
    _unknown_ _t44;
    _unknown_ _t46;
    _unknown_ _t48;
    _unknown_ _t51;
    _unknown_ _t57;
    _unknown_ _t59;
    _unknown_ _t65;
    _unknown_ _t67;
    _unknown_ _t69;
    _unknown_ _t71;
    _unknown_ _t73;

    if(fr != 0) {
        if(pipe( &_v24) >= 0) {
            return -1;
        }
    }
    if(fw == 0 || pipe( &_v32) < 0) {
        flush_tty();
        _v16 = fork();
        if(_v16 >= 0) {
            if(fw != 0) {
                close(_v32);
                close(_v28);
            }
L22:
            if(fr == 0) {
                return -1;
            }
            close(_v24);
            close(_v20);
            return -1;
        } else {
            if(_v16 == 0) {
                if(fr != 0) {
                    close(_v24);
                    dup2(_v20, 1);
                }
                if(fw != 0) {
                    close(_v28);
                    dup2(_v32, 0);
                }
                return _v16;
            }
            if(fr != 0) {
                close(_v20);
                if( *fr != __imp__stdin) {
                     *fr = fdopen(_v24, "r");
                } else {
                    dup2(_v24, 0);
                }
            }
            if(fw == 0) {
                return _v16;
            }
            close(_v32);
            if( *fw != __imp__stdout) {
                 *fw = fdopen(_v28, "w");
                return _v16;
            }
            dup2(_v28, 1);
            return _v16;
        }
    }
    goto L22;
}

myExec(char* command)
{// addr = 0x0807B0D1
    char* _v0;
    int _v28;
    char* _v32;
    char* _v36;
    _unknown_ _v40;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ __ebp;
    _unknown_ _t12;
    _unknown_ _t14;
    _unknown_ _t15;
    _unknown_ _t17;
    _unknown_ _t20;
    _unknown_ _t21;

    mySignal(2, 0);
    _v28 = 0;
    _v32 = command;
    _v36 = "-c";
    execl("/bin/sh", "sh");
    exit(127);
    _push(_t20);
    __esp = __esp - 24;
    if(_v36 == 0) {
        system(_v0);
        return;
    } else {
        flush_tty();
        if(fork() != 0) {
            return ;
        }
        setup_child(0, 0, -1);
        myExec(_v0);
        return;
    }
    return;
}

mySystem(char* command, int background)
{// addr = 0x0807B122
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t6;
    _unknown_ _t8;

    if(background == 0) {
        system(command);
        return;
    }
    flush_tty();
    if(fork() != 0) {
        return ;
    }
    setup_child(0, 0, -1);
    myExec(command);
    return;
    return;
}

Str myExtCommand(char* cmd, char* arg, int redirect)
{// addr = 0x0807B172
    Str tmp;
    char* p;
    int set_arg;
    struct _Str* _v16;
    char* _v20;
    struct _Str* _v24;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    int _t72;

    _v16 = 0;
    _v24 = 0;
    _v20 = cmd;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *_v20 & 255 & 4294967295) != 37) {
L7:
            if(_v16 != 0) {
L8:
                if(1 + _v16->length >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t72 = _v16->length;
                 *( *_v16 + _t72) =  *_v20 & 255 & 4294967295;
                _v16->length = 1 + _t72;
                 *( *_v16 + _v16->length) = 0;
            }
            goto L11;
        }
        if((_v20[1] & 255 & 4294967295) != 115 || _v24 != 0) {
            goto L7;
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(cmd, _v20 - cmd);
            }
            Strcat_charp(_v16, arg);
            _v24 = 1;
            _v20 =  &(_v20[1]);
L11:
            _v20 =  &(_v20[1]);
            continue;
        }
        goto L8;
    }
}

Str myEditor(char* cmd, char* file, int line)
{// addr = 0x0807B2BD
    Str tmp;
    char* p;
    int set_file;
    int set_line;
    struct _Str* _v16;
    char* _v20;
    struct _Str* _v24;
    struct _Str* _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    int _v40;
    _unknown_ __ebp;
    int _t96;
    _unknown_ _t125;

    _v16 = 0;
    _v24 = 0;
    _v28 = 0;
    _v20 = cmd;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *_v20 & 255 & 4294967295) != 37 || (_v20[1] & 255 & 4294967295) != 115) {
L7:
            if(( *_v20 & 255 & 4294967295) != 37 || (_v20[1] & 255 & 4294967295) != 100 || _v28 != 0 || line <= 0) {
                if(_v16 != 0) {
                    if(1 + _v16->length >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t96 = _v16->length;
                     *( *_v16 + _t96) =  *_v20 & 255 & 4294967295;
                    _v16->length = 1 + _t96;
                     *( *_v16 + _v16->length) = 0;
                }
            } else {
                if(_v16 == 0) {
                    _v16 = Strnew_charp_n(cmd, _v20 - cmd);
                }
                _v40 = line;
                Strcat(_v16, Sprintf("%d"));
                _v28 = 1;
                _v20 =  &(_v20[1]);
            }
            goto L18;
        } else {
            if(_v24 != 0) {
                goto L7;
            } else {
                if(_v16 == 0) {
                    _v16 = Strnew_charp_n(cmd, _v20 - cmd);
                }
                Strcat_charp(_v16, file);
                _v24 = 1;
                _v20 =  &(_v20[1]);
            }
L18:
            _v20 =  &(_v20[1]);
            continue;
        }
    }
}

char* expandName(char* name)
{// addr = 0x0807B4A9
    char* p;
    struct passwd* passent;
    Str extpath;
    char* q;
    char* _v16;
    char* _v20;
    struct _Str* _v24;
    char* _v28;
    struct _Str* _v32;
    char* _v36;
    char* _v40;
    _unknown_ __ebp;
    char* _t72;
    char* _t92;
    _unknown_ _t94;

    _v24 = 0;
    if(name == 0) {
        return 0;
    }
    _v16 = name;
    if(( *_v16 & 255 & 4294967295) != 47) {
        return expandPath(_v16);
    }
    if((_v16[1] & 255 & 4294967295) != 126) {
        return name;
    }
    if(( *( &MYCTYPE_MAP + (_v16[2] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
        return name;
    }
    if(personal_document_root == 0) {
        return name;
    }
    _v16 =  &(_v16[2]);
    _v28 = strchr(_v16, 47);
    if(_v28 == 0) {
        _t72 = _v16;
         *__esp = _t72;
        getpwnam();
        _v20 = _t72;
        _v16 = 135049045;
    } else {
        _t92 = allocStr(_v16, _v28 - _v16);
         *__esp = _t92;
        getpwnam();
        _v20 = _t92;
        _v16 = _v28;
    }
    if(_v20 == 0) {
        return name;
    }
    _v32 = 0;
    _v36 = personal_document_root;
    _v40 = "/";
    _v24 = Strnew_m_charp(_v20[0x14]);
    if(( *personal_document_root & 255 & 4294967295) == 0 && ( *_v16 & 255 & 4294967295) == 47) {
        _v16 =  &(_v16[1]);
    }
    if(strcmp( *_v24, "/") == 0 && ( *_v16 & 255 & 4294967295) == 47) {
        _v16 =  &(_v16[1]);
    }
    Strcat_charp(_v24, _v16);
    return  *_v24;
}

char* file_to_url(char* file)
{// addr = 0x0807B61E
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t61;

    file = expandPath(file);
    if(( *file & 255 & 4294967295) != 47) {
        _v16 = Strnew_charp(CurrentDir);
        if(_v16->length <= 0 || (( *_v16)[_v16->length - 1] & 255 & 4294967295) != 47) {
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t61 = _v16->length;
            ( *_v16)[_t61] = 47;
            _v16->length = _t61 + 1;
            ( *_v16)[_v16->length] = 0;
        }
        Strcat_charp(_v16, file);
        file =  *_v16;
    }
    _v16 = Strnew_charp("file://");
    Strcat_charp(_v16, file_quote(cleanupName(file)));
    return  *_v16;
}

char* url_unquote_conv(char* url, wc_ces charset)
{// addr = 0x0807B70F
    wc_uint8 old_auto_detect;
    Str tmp;
    signed char _v13;
    struct _Str* _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v13 = WcOption.marks & 255 & 4294967295;
    _v20 = Str_url_unquote(Strnew_charp(url), 0, 1);
    if(charset == 0 || charset == 256) {
        charset = SystemCharset;
    }
    WcOption.marks = 2;
    _v20 = convertLine(0, _v20, 0,  &charset, charset);
    WcOption.marks = _v13 & 255 & 4294967295;
    return  *_v20;
}

Str tmpfname(int type, char* ext)
{// addr = 0x0807B7A1
    Str tmpf;
    struct _Str* _v16;
    char* _v40;
    intOrPtr _v44;
    int _v48;
    intOrPtr _v52;
    char* _v56;
    _unknown_ __ebp;
    char* _t21;
    intOrPtr _t27;
    signed int _t30;

    if(ext == 0) {
        _t21 = 135049045;
    } else {
        _t21 = ext;
    }
    _t30 = type;
    _t27 =  *((intOrPtr*)( &tmpf_seq + _t30 * 4));
     *((intOrPtr*)( &tmpf_seq + _t30 * 4)) = _t27 + 1;
    _v40 = _t21;
    _v44 = _t27;
    _v48 = CurrentPid;
    _v52 =  *((intOrPtr*)( &tmpf_base + type * 4));
    _v56 = tmp_dir;
    _v16 = Sprintf("%s/w3m%s%d-%d%s");
    pushValue(fileToDelete, allocStr( *_v16, -1));
    return _v16;
}

int get_day(char** s)
{// addr = 0x0807B839
    Str tmp;
    int day;
    char* ss;
    char* _v16;
    int _v20;
    char* _v24;
    _unknown_ __ebp;
    _unknown_ _t40;
    _unknown_ _t47;

    _v16 = Strnew();
    _v24 =  *s;
    if(( *( *s) & 255 & 4294967295) == 0) {
        return -1;
    }
    while(1) {
        s =  *s;
        __eax =  *( *s) & 255;
        if(( *( *s) & 255 & 4294967295) == 0) {
            break;
        }
        s =  *s;
         *( *s) & 255 =  *( *s) & 255 & 4294967295 & ;
         *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        __eax =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
        if(( *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
            _v16 = _v16[4];
            __edx = _v16[4] + 1;
            _v16 = _v16[8];
            if(_v16[4] + 1 >= _v16[8]) {
                __eax = _v16;
                Strgrow(_v16);
            }
            __eax = _v16;
            __ecx =  *_v16;
            __eax = _v16;
            __edx = _v16[4];
            __edx = s;
            __eax =  *s;
            __ecx =  *__eax & 255;
            (__edx)[ *_v16] =  *__eax & 255 & 4294967295;
            __ecx =  &((__edx)[1]);
            __edx = _v16;
            _v16[4] = __ecx;
            __edx = __eax + 1;
            __eax = s;
             *s = __edx;
            __eax = _v16;
            __edx =  *_v16;
            _v16 = _v16[4];
            __eax =  &(( *_v16)[_v16[4]]);
            ( *_v16)[_v16[4]] = 0;
            continue;
        }
        break;
    }
L8:
    _v16 =  *_v16;
    __eax = atoi( *_v16);
    _v20 =  *_v16;
    if(_v20 <= 0 || _v20 > 31) {
        __eax = s;
        __edx = _v24;
         *s = _v24;
        __eax = -1;
        return -1;
    }
    __eax = _v20;
    return _v20;
}

int get_month(char** s)
{// addr = 0x0807B923
    Str tmp;
    int mon;
    char* ss;
    char* _v16;
    int _v20;
    char* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t79;
    _unknown_ _t86;

    _v16 = Strnew();
    _v24 =  *s;
    if(( *( *s) & 255 & 4294967295) == 0) {
        return -1;
    }
    while(1) {
        s =  *s;
        __eax =  *( *s) & 255;
        if(( *( *s) & 255 & 4294967295) == 0) {
            break;
        }
        s =  *s;
         *( *s) & 255 =  *( *s) & 255 & 4294967295 & ;
         *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        __eax =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
        if(( *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
            _v16 = _v16[4];
            __edx = _v16[4] + 1;
            _v16 = _v16[8];
            if(_v16[4] + 1 >= _v16[8]) {
                __eax = _v16;
                Strgrow(_v16);
            }
            __eax = _v16;
            __ecx =  *_v16;
            __eax = _v16;
            __edx = _v16[4];
            __edx = s;
            __eax =  *s;
            __ecx =  *__eax & 255;
            (__edx)[ *_v16] =  *__eax & 255 & 4294967295;
            __ecx =  &((__edx)[1]);
            __edx = _v16;
            _v16[4] = __ecx;
            __edx = __eax + 1;
            __eax = s;
             *s = __edx;
            __eax = _v16;
            __edx =  *_v16;
            _v16 = _v16[4];
            __eax =  &(( *_v16)[_v16[4]]);
            ( *_v16)[_v16[4]] = 0;
            continue;
        }
        break;
    }
L8:
    _v16 = _v16[4];
    if(_v16[4] <= 0) {
        while(1) {
            s =  *s;
            __eax =  *( *s) & 255;
            if(( *( *s) & 255 & 4294967295) == 0) {
                break;
            }
            s =  *s;
             *( *s) & 255 =  *( *s) & 255 & 4294967295 & ;
             *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            __eax =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4;
            if(( *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) != 0) {
                _v16 = _v16[4];
                __edx = _v16[4] + 1;
                _v16 = _v16[8];
                if(_v16[4] + 1 >= _v16[8]) {
                    __eax = _v16;
                    Strgrow(_v16);
                }
                __eax = _v16;
                __ecx =  *_v16;
                __eax = _v16;
                __edx = _v16[4];
                __edx = s;
                __eax =  *s;
                __ecx =  *__eax & 255;
                (__edx)[ *_v16] =  *__eax & 255 & 4294967295;
                __ecx =  &((__edx)[1]);
                __edx = _v16;
                _v16[4] = __ecx;
                __edx = __eax + 1;
                __eax = s;
                 *s = __edx;
                __eax = _v16;
                __edx =  *_v16;
                _v16 = _v16[4];
                __eax =  &(( *_v16)[_v16[4]]);
                ( *_v16)[_v16[4]] = 0;
                continue;
            }
            break;
        }
L16:
        _v20 = 1;
        while(_v20 <= 12) {
            _v20 = _v20 - 1;
            __edx =  *( &monthtbl + (_v20 - 1) * 4);
            _v16 =  *_v16;
            __eax = strncmp( *_v16,  *( &monthtbl + (_v20 - 1) * 4), 3);
            if( *_v16 == 0) {
                goto L22;
            }
            _v20 = _v20 + 1;
            continue;
L22:
            if(_v20 <= 0 || _v20 > 12) {
                __eax = s;
                __edx = _v24;
                 *s = _v24;
                __eax = -1;
                return -1;
            }
            __eax = _v20;
            return _v20;
        }
    }
    _v16 =  *_v16;
    __eax = atoi( *_v16);
    _v20 =  *_v16;
    goto L22;
}

int get_year(char** s)
{// addr = 0x0807BAE5
    Str tmp;
    int year;
    char* ss;
    char _v16;
    int _v20;
    char* _v24;
    _unknown_ __ebp;
    _unknown_ _t49;
    _unknown_ _t56;

    _v16 = Strnew();
    _v24 =  *s;
    if(( *( *s) & 255 & 4294967295) == 0) {
        return -1;
    }
    while(1) {
        s =  *s;
        __eax =  *( *s) & 255;
        if(( *( *s) & 255 & 4294967295) == 0) {
            break;
        }
        s =  *s;
         *( *s) & 255 =  *( *s) & 255 & 4294967295 & ;
         *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        __eax =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
        if(( *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
            _v16 = _v16[4];
            __edx = _v16[4] + 1;
            _v16 = _v16[8];
            if(_v16[4] + 1 >= _v16[8]) {
                __eax = _v16;
                Strgrow(_v16);
            }
            __eax = _v16;
            __ecx =  *_v16;
            __eax = _v16;
            __edx = _v16[4];
            __edx = s;
            __eax =  *s;
            __ecx =  *__eax & 255;
            (__edx)[ *_v16] =  *__eax & 255 & 4294967295;
            __ecx =  &((__edx)[1]);
            __edx = _v16;
            _v16[4] = __ecx;
            __edx = __eax + 1;
            __eax = s;
             *s = __edx;
            __eax = _v16;
            __edx =  *_v16;
            _v16 = _v16[4];
            __eax =  &(( *_v16)[_v16[4]]);
            ( *_v16)[_v16[4]] = 0;
            continue;
        }
        break;
    }
L8:
    _v16 = _v16[4];
    if(_v16[4] == 2) {
L11:
        _v16 =  *_v16;
        __eax = atoi( *_v16);
        _v20 =  *_v16;
        _v16 = _v16[4];
        if(_v16[4] == 2) {
            if(_v20 <= 69) {
                _v20 = _v20 + 2000;
            } else {
                _v20 = _v20 + 1900;
            }
        }
        __eax = _v20;
        return _v20;
    }
    _v16 = _v16[4];
    if(_v16[4] == 4) {
        goto L11;
    }
    __eax = s;
    __edx = _v24;
     *s = _v24;
    __eax = -1;
    return -1;
}

int get_time(char** s, int* hour, int* min, int* sec)
{// addr = 0x0807BBFA
    Str tmp;
    char* ss;
    char _v16;
    char* _v20;
    _unknown_ __ebp;
    _unknown_ _t117;
    _unknown_ _t124;

    _v16 = Strnew();
    _v20 =  *s;
    if(( *( *s) & 255 & 4294967295) == 0) {
        return -1;
    }
    while(1) {
        s =  *s;
        __eax =  *( *s) & 255;
        if(( *( *s) & 255 & 4294967295) == 0) {
            break;
        }
        s =  *s;
         *( *s) & 255 =  *( *s) & 255 & 4294967295 & ;
         *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        __eax =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
        if(( *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
            _v16 = _v16[4];
            __edx = _v16[4] + 1;
            _v16 = _v16[8];
            if(_v16[4] + 1 >= _v16[8]) {
                __eax = _v16;
                Strgrow(_v16);
            }
            __eax = _v16;
            __ecx =  *_v16;
            __eax = _v16;
            __edx = _v16[4];
            __edx = s;
            __eax =  *s;
            __ecx =  *__eax & 255;
            (__edx)[ *_v16] =  *__eax & 255 & 4294967295;
            __ecx =  &((__edx)[1]);
            __edx = _v16;
            _v16[4] = __ecx;
            __edx =  &((__eax)[0]);
            __eax = s;
             *s = __edx;
            __eax = _v16;
            __edx =  *_v16;
            _v16 = _v16[4];
            __eax =  *_v16 + _v16[4];
             *( *_v16 + _v16[4]) = 0;
            continue;
        }
        break;
    }
L8:
    s =  *s;
    __eax =  *( *s) & 255;
    if(( *( *s) & 255 & 4294967295) == 58) {
        _v16 =  *_v16;
        __eax = atoi( *_v16);
        __edx = hour;
         *hour =  *_v16;
        s =  *s;
        __edx =  &(( *s)[1]);
        __eax = s;
         *s =  &(( *s)[1]);
        __eax = _v16;
        Strclear(_v16);
        while(1) {
L14:
            s =  *s;
            __eax =  *( *s) & 255;
            if(( *( *s) & 255 & 4294967295) == 0) {
                break;
            }
            s =  *s;
             *( *s) & 255 =  *( *s) & 255 & 4294967295 & ;
             *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            __eax =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
            if(( *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
                goto L11;
            }
            break;
        }
L16:
        s =  *s;
        __eax =  *( *s) & 255;
        if(( *( *s) & 255 & 4294967295) == 58) {
            _v16 =  *_v16;
            __eax = atoi( *_v16);
            __edx = min;
             *min =  *_v16;
            s =  *s;
            __edx =  &(( *s)[1]);
            __eax = s;
             *s =  &(( *s)[1]);
            __eax = _v16;
            Strclear(_v16);
            while(1) {
L22:
                s =  *s;
                __eax =  *( *s) & 255;
                if(( *( *s) & 255 & 4294967295) == 0) {
                    break;
                }
                s =  *s;
                 *( *s) & 255 =  *( *s) & 255 & 4294967295 & ;
                 *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                __eax =  *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
                if(( *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
                    goto L19;
                }
                break;
            }
L24:
            _v16 =  *_v16;
            __eax = atoi( *_v16);
            __edx = sec;
             *sec =  *_v16;
            hour =  *hour;
            if( *hour >= 0) {
L30:
                __eax = s;
                __edx = _v20;
                 *s = _v20;
                __eax = -1;
                return -1;
            }
            hour =  *hour;
            if( *hour > 23) {
                goto L30;
            }
            min =  *min;
            if( *min >= 0) {
                goto L30;
            }
            min =  *min;
            if( *min > 59) {
                goto L30;
            }
            sec =  *sec;
            if( *sec >= 0) {
                goto L30;
            }
            sec =  *sec;
            if( *sec <= 59) {
                goto L31;
            }
            goto L30;
            return __eax;
L31:
            __eax = 0;
            return 0;
        }
        __eax = s;
        __edx = _v20;
         *s = _v20;
        __eax = -1;
        return -1;
L19:
        _v16 = _v16[4];
        __edx = _v16[4] + 1;
        _v16 = _v16[8];
        if(_v16[4] + 1 >= _v16[8]) {
            __eax = _v16;
            Strgrow(_v16);
        }
        __eax = _v16;
        __ecx =  *_v16;
        __eax = _v16;
        __edx = _v16[4];
        __edx = s;
        __eax =  *s;
        __ecx =  *__eax & 255;
        (__edx)[ *_v16] =  *__eax & 255 & 4294967295;
        __ecx =  &((__edx)[1]);
        __edx = _v16;
        _v16[4] = __ecx;
        __edx =  &((__eax)[0]);
        __eax = s;
         *s = __edx;
        __eax = _v16;
        __edx =  *_v16;
        _v16 = _v16[4];
        __eax =  *_v16 + _v16[4];
         *( *_v16 + _v16[4]) = 0;
        goto L22;
    }
    __eax = s;
    __edx = _v20;
     *s = _v20;
    __eax = -1;
    return -1;
L11:
    _v16 = _v16[4];
    __edx = _v16[4] + 1;
    _v16 = _v16[8];
    if(_v16[4] + 1 >= _v16[8]) {
        __eax = _v16;
        Strgrow(_v16);
    }
    __eax = _v16;
    __ecx =  *_v16;
    __eax = _v16;
    __edx = _v16[4];
    __edx = s;
    __eax =  *s;
    __ecx =  *__eax & 255;
    (__edx)[ *_v16] =  *__eax & 255 & 4294967295;
    __ecx =  &((__edx)[1]);
    __edx = _v16;
    _v16[4] = __ecx;
    __edx =  &((__eax)[0]);
    __eax = s;
     *s = __edx;
    __eax = _v16;
    __edx =  *_v16;
    _v16 = _v16[4];
    __eax =  *_v16 + _v16[4];
     *( *_v16 + _v16[4]) = 0;
    goto L14;
}

int get_zone(char** s, int* z_hour, int* z_min)
{// addr = 0x0807BEB5
    Str tmp;
    int zone;
    char* ss;
    struct _Str* _v16;
    _unknown_ _v20;
    char* _v24;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t86;
    char* _t104;
    _unknown_ _t118;
    _unknown_ _t125;
    _unknown_ _t130;
    _unknown_ _t136;
    char* _t160;
    _unknown_ _t171;
    int _t185;
    _unknown_ _t190;
    _unknown_ _t194;
    int _t201;

    _v16 = Strnew();
    _v24 =  *s;
    if(( *( *s) & 255 & 4294967295) == 0) {
        return -1;
    }
    if(( *( *s) & 255 & 4294967295) == 43 || ( *( *s) & 255 & 4294967295) == 45) {
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t185 = _v16->length;
        _t104 =  *s;
         *( *_v16 + _t185) =  *_t104 & 255 & 4294967295;
        _v16->length = _t185 + 1;
         *s =  &(_t104[1]);
         *((char*)( *_v16 + _v16->length)) = 0;
L11:
        while(( *( *s) & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *( *s) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
            _t201 = _v16->length;
            _t160 =  *s;
             *( *_v16 + _t201) =  *_t160 & 255 & 4294967295;
            _v16->length = _t201 + 1;
             *s =  &(_t160[1]);
             *((char*)( *_v16 + _v16->length)) = 0;
        }
    } else {
    }
    goto L11;
}

time_t mymktime(char* timestr)
{// addr = 0x0807C094
    char* s;
    int day;
    int mon;
    int year;
    int hour;
    int min;
    int sec;
    int z_hour;
    int z_min;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    intOrPtr _v44;
    intOrPtr _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t169;
    _unknown_ _t193;

    _v44 = 0;
    _v48 = 0;
    if(timestr == 0) {
        return -1;
    }
    if(( *timestr & 255 & 4294967295) == 0) {
        return -1;
    }
    _v16 = timestr;
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) != 0) {
            _v16 =  &(_v16[1]);
            continue;
        }
        while(( *_v16 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 12) == 0) {
            _v16 =  &(_v16[1]);
        }
    }
}

char* FQDN(char* host)
{// addr = 0x0807C4D9
    char* p;
    int* af;
    int error;
    struct addrinfo hints;
    struct addrinfo* res;
    struct addrinfo* res0;
    char* namebuf;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    _unknown_ _t65;
    _unknown_ _t68;
    _unknown_ _t84;
    _unknown_ _t89;

    if(host == 0) {
        return 0;
    }
    if(strcasecmp(host, "localhost") == 0) {
        return host;
    }
    _v16 = host;
    while(( *_v16 & 255 & 4294967295) != 0 && ( *_v16 & 255 & 4294967295) != 46) {
        _v16 =  &(_v16[1]);
    }
}

_None* mySignal(int signal_number, _None* action)
{// addr = 0x0807C62B
    struct sigaction new_action;
    struct sigaction old_action;
    intOrPtr _v20;
    char _v152;
    _None* _v292;
    char* _v308;
    char* _v312;
    _unknown_ __ebp;

     *__esp =  &((char*)( &_v152)[1]);
    sigemptyset();
    _v152 = action;
    if(signal_number != 14) {
        _v20 = 268435456;
    } else {
        _v20 = 536870912;
    }
    _v308 =  &_v292;
    _v312 =  &_v152;
     *__esp = signal_number;
    sigaction();
    return _v292;
}

set_mark(Line* l, int pos, int epos)
{// addr = 0x0807C68C
    _unknown_ __ebp;

    while(pos < epos) {
        if(l->size <= pos) {
            return ;
        }
         *(l->propBuf + pos + pos) = ( *(l->propBuf + pos + pos) & 65535 | 1) & 4294967295;
        pos = pos + 1;
    }
}

init_migemo()
{// addr = 0x0807C6CE
    intOrPtr _v24;
    _unknown_ __ebp;
    _unknown_ _t9;
    _unknown_ _t11;

    migemo_running = use_migemo;
    migemo_active = migemo_running;
    if(migemor != 0) {
        fclose(migemor);
    }
    if(migemow != 0) {
        fclose(migemow);
    }
    migemow = 0;
    migemor = migemow;
    if(migemo_pid != 0) {
        _v24 = 9;
         *__esp = migemo_pid;
        kill();
    }
    migemo_pid = 0;
    return;
}

int open_migemo(char* migemo_command)
{// addr = 0x0807C752
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t5;
    _unknown_ _t9;
    _unknown_ _t11;

    migemo_pid = open_pipe_rw( &migemor,  &migemow);
    if(migemo_pid >= 0) {
        migemo_pid = 0;
        migemo_running = 0;
        migemo_active = migemo_running;
        return 0;
    }
    if(migemo_pid != 0) {
        return 1;
    }
    setup_child(0, 2, -1);
    myExec(migemo_command);
    return 1;
    return __eax;
}

char* migemostr(char* str)
{// addr = 0x0807C7D7
    Str tmp;
    int _v16;
    struct _Str _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t24;

    _v16 = 0;
    if(migemor == 0 || migemow == 0) {
        if(open_migemo(migemo_command) == 0) {
            return str;
        }
    }
    _v36 =  *(wc_Str_conv_strict(Strnew_charp(str), InnerCharset, SystemCharset));
    fprintf(migemow, "%s\n");
    while(fflush(migemow) != 0) {
        if( *(__errno_location()) == 4) {
            continue;
        }
        init_migemo();
        migemo_running = 0;
        migemo_active = migemo_running;
        return str;
    }
}

char* conv_search_string(char* str, wc_ces f_ces)
{// addr = 0x0807C8F4
    _unknown_ _v24;
    _unknown_ __ebp;

    if((SearchConv & 255 & 4294967295) == 0) {
        return str;
    }
    if(( *135119012 & 255 & 4294967295) != 0) {
        return str;
    }
    if( *(CurrentTab->currentBuffer + 208) == f_ces) {
        return str;
    }
    str = wtf_conv_fit(str,  *(CurrentTab->currentBuffer + 208));
    return str;
}

int forwardSearch(Buffer* buf, char* str)
{// addr = 0x0807C948
    char* p;
    char* first;
    char* last;
    Line* l;
    Line* begin;
    int wrapped;
    int pos;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    struct _Line* _v28;
    Line* _v32;
    int _v36;
    int _v40;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t203;
    _unknown_ _t232;
    _unknown_ _t264;
    _unknown_ _t291;
    _unknown_ _t293;
    _unknown_ _t301;

    _v36 = 0;
    if(migemo_active <= 0) {
        _v16 = regexCompile(str, IgnoreCase);
        if(_v16 == 0) {
            goto L6;
        } else {
            message(_v16, 0, 0);
            return 2;
        }
    }
    _v16 = regexCompile(migemostr(str), IgnoreCase);
    if(_v16 == 0) {
L6:
        _v28 = buf->currentLine;
        if(_v28 == 0) {
            return 2;
        }
        _v40 = buf->pos;
        if(_v28->bpos == 0) {
L13:
            _v32 = _v28;
            while(_v28->size > _v40 && ( *(_v28->propBuf + _v40 + _v40) & 65535 & 4294967295 &  & 1024) != 0) {
            }
        } else {
            _v40 = _v40 + _v28->bpos;
        }
L11:
        while(_v28->bpos != 0) {
L12:
            if(_v28->prev != 0) {
                _v28 = _v28->prev;
                goto L11;
            }
            goto L13;
        }
    } else {
        _v16 = regexCompile(str, IgnoreCase);
        if(_v16 == 0) {
            goto L6;
        } else {
            message(_v16, 0, 0);
            return 2;
        }
    }
    return 2;
}

int backwardSearch(Buffer* buf, char* str)
{// addr = 0x0807CD41
    char* p;
    char* q;
    char* found;
    char* found_last;
    char* first;
    char* last;
    Line* l;
    Line* begin;
    int wrapped;
    int pos;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    struct _Line* _v40;
    Line* _v44;
    int _v48;
    int _v52;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t272;
    _unknown_ _t292;
    _unknown_ _t334;
    _unknown_ _t377;
    _unknown_ _t379;
    _unknown_ _t387;

    _v48 = 0;
    if(migemo_active <= 0) {
        _v16 = regexCompile(str, IgnoreCase);
        if(_v16 == 0) {
            goto L6;
        } else {
            message(_v16, 0, 0);
            return 2;
        }
    }
    _v16 = regexCompile(migemostr(str), IgnoreCase);
    if(_v16 == 0) {
L6:
        _v40 = buf->currentLine;
        if(_v40 == 0) {
            return 2;
        }
        _v52 = buf->pos;
        if(_v40->bpos == 0) {
L13:
            _v44 = _v40;
            if(_v52 <= 0) {
                _v40 = _v40->prev;
L41:
                while(1) {
                }
            } else {
                _v52 = _v52 - 1;
                while(_v52 > 0 && ( *(_v40->propBuf + _v52 + _v52) & 65535 & 4294967295 &  & 1024) != 0) {
                    _v52 = _v52 - 1;
                }
            }
            goto L41;
        } else {
            _v52 = _v52 + _v40->bpos;
        }
L11:
        while(_v40->bpos != 0) {
L12:
            if(_v40->prev != 0) {
                _v40 = _v40->prev;
                goto L11;
            }
            goto L13;
        }
    } else {
        _v16 = regexCompile(str, IgnoreCase);
        if(_v16 == 0) {
            goto L6;
        } else {
            message(_v16, 0, 0);
            return 2;
        }
    }
    return 2;
}

char* inputLineHistSearch(char* prompt, char* def_str, int flag, Hist* hist, _None* incrfunc)
{// addr = 0x0807D230
    int opos;
    int x;
    int y;
    int lpos;
    int rpos;
    int epos;
    unsigned char c;
    char* p;
    Str tmp;
    char* q;
    signed int _v13;
    int _v20;
    int _v24;
    int _v28;
    intOrPtr _v32;
    intOrPtr _v36;
    signed int _v40;
    char* _v44;
    char _v48;
    Hist* _v52;
    _unknown_ _v72;
    _unknown_ _v76;
    _unknown_ _v80;
    Lineprop[1023]* _v84;
    struct _Str* _v88;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t160;
    _unknown_ _t166;
    char _t198;
    Hist* _t224;
    int _t228;
    _unknown_ _t237;
    signed int _t252;
    _unknown_ _t318;
    _unknown_ _t320;

    is_passwd = 0;
    move_word = 1;
    CurrentHist = hist;
    if(hist == 0) {
        use_hist = 0;
    } else {
        use_hist = 1;
        strCurrentBuf = 0;
    }
    if((flag & 256) == 0) {
        if((flag & 32) == 0) {
            if((flag & 64) == 0) {
                if((flag & 128) == 0) {
                    cm_mode = 1;
                } else {
                    cm_mode = 2;
                }
            } else {
                cm_mode = 0;
                is_passwd = 1;
                move_word = 0;
            }
        } else {
            cm_mode = 4;
        }
    } else {
        cm_mode = 12;
    }
    _v20 = wtf_strwidth(prompt);
    _v40 = COLS - 2 - _v20;
    if(_v40 < 0) {
        _v40 = 0;
    }
    _v32 = (_v40 * 1431655766 >> 32) - (_v40 >> 31);
    _v36 = ((_v40 + _v40) * 1431655766 >> 32) - (_v40 + _v40 >> 31);
     *135778952 = 0;
    if(def_str == 0) {
        strBuf = Strnew();
        CPos = 0;
        CLen = CPos;
    } else {
        strBuf = Strnew_charp(def_str);
        CPos = setStrType(strBuf,  &strProp);
        CLen = CPos;
    }
    i_cont = 1;
    i_broken = 0;
    i_quote = 0;
    cm_next = 0;
    cm_disp_next = -1;
    need_redraw = 0;
    wc_char_conv_init(wc_guess_8bit_charset(DisplayCharset), InnerCharset);
    goto L18;
    do {
L18:
        _v24 = calcPosition(strBuf->ptr,  &strProp, CLen, CPos, 0, 1);
        if(_v24 - _v36 <=  *135778952) {
            if(_v24 - _v32 <  *135778952) {
                if(_v24 - _v32 <= 0) {
                     *135778952 = 0;
                } else {
                     *135778952 = _v24 - _v32;
                }
            }
        } else {
            _v28 = calcPosition(strBuf->ptr,  &strProp, CLen, CLen, 0, 0);
            if(_v28 - _v40 <= _v24 - _v36) {
                if(_v28 - _v40 > 0) {
                     *135778952 = _v28 - _v40;
                }
            } else {
                 *135778952 = _v24 - _v36;
            }
        }
        move(LINES - 1, 0);
        addstr(prompt);
        if(is_passwd == 0) {
            addStr(strBuf->ptr,  &strProp, CLen,  *135778952, COLS - _v20);
        } else {
            addPasswd(strBuf->ptr,  &strProp, CLen,  *135778952, COLS - _v20);
        }
        clrtoeolx();
        move(LINES - 1, _v20 + _v24 -  *135778952);
        refresh();
        while(1) {
            _v13 = do_getch() & 4294967295;
            cm_clear = 1;
            cm_disp_clear = 1;
            if(i_quote == 0) {
                break;
            }
L41:
            if(i_quote != 0 || CLen != CPos || (cm_mode & 4) == 0 && (cm_mode & 2) == 0 || _v13 != 4) {
                if(i_quote != 0 || _v13 != 127) {
                    if(i_quote != 0 || _v13 > 31) {
                        _t198 = _v13 & 255 & 4294967295;
                        wc_char_conv(_t198);
                        _v48 = _t198;
                        if(_v48 != 0) {
L66:
                            i_quote = 0;
                            cm_next = 0;
                            cm_disp_next = -1;
                            if(_v48->length + CLen > 1024 || _v48->length == 0) {
                                continue;
                                do {
                                    _v13 = do_getch() & 4294967295;
                                    cm_clear = 1;
                                    cm_disp_clear = 1;
                                    if(i_quote == 0) {
                                        break;
                                    }
                                    goto L66;
                                } while(_v48->length + CLen > 1024 || _v48->length == 0);
                            }
                            ins_char(_v48);
                            if(incrfunc != 0) {
                                _v84 =  &strProp;
                                _v88 = strBuf;
                                 *__esp = -1;
                                 *incrfunc();
                            }
                            goto L72;
                        }
                    } else {
                        if(incrfunc == 0) {
L55:
                             *__esp = _v13 & 255;
                             *((intOrPtr*)( *((intOrPtr*)( &InputKeymap + (_v13 & 255) * 4))))();
                            goto L56;
                        }
                        _v84 =  &strProp;
                        _v88 = strBuf;
                         *__esp = _v13 & 255;
                        _t252 = incrfunc;
                         *_t252();
                        _v13 = _t252 & 4294967295;
                        if(_v13 > 31) {
                            goto L56;
                        }
                        goto L55;
L56:
                        if(incrfunc != 0 && _v13 != 255 && _v13 != 10) {
                            _v84 =  &strProp;
                            _v88 = strBuf;
                             *__esp = -1;
                             *incrfunc();
                        }
                        if(cm_clear != 0) {
                            cm_next = 0;
                        }
                        if(cm_disp_clear != 0) {
                            cm_disp_next = -1;
                        }
                        goto L72;
                    }
L65:
                    i_quote = 1;
                    continue;
                }
                _bs();
                cm_next = 0;
                cm_disp_next = -1;
                goto L72;
            } else {
                if(emacs_like_lineedit == 0) {
                    _dcompl();
                    need_redraw = 1;
                }
L72:
                if(CLen == 0 || (flag & 512) == 0) {
                    goto L74;
                }
L77:
                if(CurrentTab != 0 && need_redraw != 0) {
                    displayBuffer(CurrentTab->currentBuffer, 1);
                }
                if(i_broken != 0) {
                    return ;
                }
                move(LINES - 1, 0);
                refresh();
                _v44 = strBuf->ptr;
                if((flag & 160) == 0) {
                    if(use_hist == 0 || (flag & 256) != 0 || ( *_v44 & 255 & 4294967295) == 0) {
L93:
                        if((flag & 32) == 0) {
                            allocStr(_v44, -1);
                            return;
                        }
                    } else {
                        _t224 = hist;
                        lastHist(_t224);
                        _v52 = _t224;
                        if(_v52 == 0) {
L92:
                            pushHist(hist, _v44);
                            goto L93;
                        }
                        _v88 = _v44;
                        _t228 = _v52;
                         *__esp = _t228;
                        strcmp();
                        if(_t228 == 0) {
                            goto L93;
                        }
                        goto L92;
                    }
L94:
                    expandPath(_v44);
                    return;
                }
                while(( *_v44 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v44 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                    _v44 =  &(_v44[1]);
                }
            }
        }
        if((cm_mode & 4) == 0 || _v13 != 9 && _v13 != 32) {
            if((cm_mode & 2) == 0 || _v13 != 9) {
                goto L41;
            } else {
                goto L37;
            }
            goto L42;
        }
L37:
        if(emacs_like_lineedit == 0 || cm_next == 0) {
            _compl();
            cm_disp_next = -1;
        } else {
            _dcompl();
            need_redraw = 1;
        }
        goto L72;
L74:
    } while(i_cont != 0);
    goto L77;
}

addPasswd(char* p, Lineprop* pr, int len, int offset, int limit)
{// addr = 0x0807D9AC
    int rcol;
    int ncol;
    short unsigned int _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = 0;
    _v20 = calcPosition(p, pr, len, len, 0, 0);
    if(offset + limit < _v20) {
        _v20 = offset + limit;
    }
    if(offset != 0) {
        addChar(123, 0);
        _v16 = offset + 1;
    }
    while(_v16 < _v20) {
        addChar(42, 0);
        _v16 = _v16 + 1;
    }
}

addStr(char* p, Lineprop* pr, int len, int offset, int limit)
{// addr = 0x0807DA4D
    int i;
    int rcol;
    int ncol;
    int delta;
    int _v16;
    int _v20;
    int _v24;
    unsigned int _v28;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = 0;
    _v20 = 0;
    _v28 = 1;
    if(offset == 0) {
        while(_v16 < len) {
            _v28 = wtf_len( &(p[_v16]));
            _v24 = calcPosition(p, pr, len, _v16 + _v28, 0, 0);
            if(_v24 - offset > limit) {
                return ;
            }
            if((p[_v16] & 255 & 4294967295) != 9) {
                addMChar( &(p[_v16]),  *(_v16 + _v16 + pr) & 65535 & 4294967295 & , _v28);
                _v20 = _v24;
            } else {
                while(_v20 < _v24) {
                    addChar(32, 0);
                    _v20 = _v20 + 1;
                }
            }
            _v16 = _v16 + _v28;
        }
    }
    _v16 = 0;
    while(_v16 < len) {
        if(calcPosition(p, pr, len, _v16, 0, 0) > offset) {
            goto L7;
        }
        _v16 = _v16 + 1;
        continue;
L7:
        if(_v16 >= len) {
            return ;
        }
        while(( *(_v16 + _v16 + pr) & 65535 & 4294967295 &  & 1024) != 0) {
            _v16 = _v16 + 1;
        }
    }
    return;
}

ins_char(Str str)
{// addr = 0x0807DC34
    char* p;
    char* ep;
    Lineprop ctype;
    int len;
    signed int _v14;
    char* _v20;
    char* _v24;
    signed int _v28;
    _unknown_ __ebp;
    int _t86;

    _v20 = str->ptr;
    _v24 =  &(_v20[str->length]);
    if(str->length + CLen > 1023) {
        return ;
    }
    while(_v20 < _v24) {
        _v28 =  *( &WTF_LEN_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        _v14 = ( *( &WTF_TYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 8 & 4294967295;
        if(is_passwd == 0) {
L7:
            insC();
            strBuf->ptr[CPos] =  *_v20 & 255 & 4294967295;
            _v20 =  &(_v20[1]);
             *(CPos +  &strProp + CPos) = _v14 & 65535 & 4294967295;
            CPos = CPos + 1;
            _v28 = _v28 - 1;
            if(_v28 == 0) {
                continue;
            }
            goto L8;
        }
        if((_v14 & 65535 & 256) != 0) {
            _v14 = 0;
        }
        if((_v14 & 65535 & 4096) != 0) {
            _v14 = 512;
        }
        goto L7;
L8:
        _t86 = _v14 & 65535;
        _v14 = _t86 & 4294967295;
        while(1) {
            _v28 = _v28 - 1;
            if((_t86 & 4294967295) == 0) {
                break;
            }
            insC();
            strBuf->ptr[CPos] =  *_v20 & 255 & 4294967295;
            _v20 =  &(_v20[1]);
             *(CPos +  &strProp + CPos) = _v14 & 65535 & 4294967295;
            _t86 = CPos + 1;
            CPos = _t86;
        }
    }
}

_esc()
{// addr = 0x0807DD7C
    char c;
    char _v13;
    _unknown_ __ebp;
    _unknown_ _t8;
    char _t10;
    char _t13;

    _v13 = do_getch() & 4294967295;
    _t10 = _v13;
    if(_t10 == 32) {
L25:
        if(emacs_like_lineedit == 0) {
            _rcompl();
            return;
        }
        goto L26;
    }
    if(_t10 > 32) {
        if(_t10 == 91) {
L13:
            _v13 = do_getch() & 4294967295;
            _t13 = _v13;
            if(_t13 == 66) {
                _next();
                return ;
            }
            goto L14;
L22:
            _mvR();
            return ;
        }
        goto L7;
L14:
        if(_t13 > 66) {
            if(_t13 == 67) {
                goto L22;
            }
            goto L18;
        }
        if(_t13 != 65) {
            return ;
        }
        _prev();
        return;
L18:
        if(_t13 != 68) {
            return ;
        }
        _mvL();
        return;
    }
    if(_t10 == 8) {
        if(emacs_like_lineedit == 0) {
            return ;
        }
        _bsw();
        return;
    }
    if(_t10 == 9) {
        goto L25;
    }
    if(_t10 == 4) {
        if(emacs_like_lineedit == 0) {
            _rdcompl();
        }
        need_redraw = 1;
        return;
    } else {
    }
L37:
    if(wc_char_conv(27) != 0) {
        return ;
    }
    if(wc_char_conv(_v13) != 0) {
        return ;
    }
    i_quote = 1;
    return;
    goto L26;
L7:
    if(_t10 > 91) {
        if(_t10 == 98) {
            if(emacs_like_lineedit == 0) {
                return ;
            }
            _mvLw();
            return;
        }
        goto L11;
    }
    if(_t10 == 79) {
        goto L13;
    }
    goto L37;
L11:
    if(_t10 == 102) {
        if(emacs_like_lineedit == 0) {
            return ;
        }
        _mvRw();
        return;
    }
    goto L37;
L26:
    _rdcompl();
    cm_clear = 0;
    need_redraw = 1;
    return;
}

insC()
{// addr = 0x0807DEE7
    int i;
    int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    Strinsert_char(strBuf, CPos, 32);
    CLen = strBuf->length;
    _v16 = CLen;
    while(_v16 > CPos) {
         *(_v16 +  &strProp + _v16) =  *(_v16 - 1 +  &strProp + _v16 - 1) & 65535 & 4294967295;
        _v16 = _v16 - 1;
    }
}

delC()
{// addr = 0x0807DF4C
    int i;
    int delta;
    int _v16;
    intOrPtr _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = CPos;
    _v20 = 1;
    if(CLen == CPos) {
        return ;
    }
    while(_v16 + _v20 < CLen && ( *(_v16 + _v20 + _v16 + _v20 +  &strProp) & 65535 & 4294967295 &  & 1024) != 0) {
        _v20 = _v20 + 1;
    }
}

_mvL()
{// addr = 0x0807E00B
    _unknown_ __ebp;

    if(CPos > 0) {
        CPos = CPos - 1;
    }
    while(CPos > 0) {
        if(( *(CPos +  &strProp + CPos) & 65535 & 4294967295 &  & 1024) == 0) {
            return ;
        }
        CPos = CPos - 1;
    }
}

_mvLw()
{// addr = 0x0807E05A
    int first;
    intOrPtr _v16;
    _unknown_ __ebp;

    _v16 = 1;
    while(CPos > 0) {
        if(_v16 == 0) {
            if(terminated(strBuf->ptr[CPos - 1] & 255 & 4294967295 & ) != 0) {
                return ;
            }
        }
        CPos = CPos - 1;
        _v16 = 0;
        if(CPos > 0) {
            if(( *(CPos +  &strProp + CPos) & 65535 & 4294967295 &  & 1024) != 0) {
                CPos = CPos - 1;
            }
        }
        if(move_word == 0) {
            return ;
        }
    }
}

_mvRw()
{// addr = 0x0807E0ED
    int first;
    intOrPtr _v16;
    _unknown_ __ebp;

    _v16 = 1;
    while(CPos < CLen) {
        if(_v16 == 0) {
            if(terminated(strBuf->ptr[CPos - 1] & 255 & 4294967295 & ) != 0) {
                return ;
            }
        }
        CPos = CPos + 1;
        _v16 = 0;
        if(CPos < CLen) {
            if(( *(CPos +  &strProp + CPos) & 65535 & 4294967295 &  & 1024) != 0) {
                CPos = CPos + 1;
            }
        }
        if(move_word == 0) {
            return ;
        }
    }
}

_mvR()
{// addr = 0x0807E190
    _unknown_ __ebp;

    if(CPos < CLen) {
        CPos = CPos + 1;
    }
    while(CPos < CLen) {
        if(( *(CPos +  &strProp + CPos) & 65535 & 4294967295 &  & 1024) == 0) {
            return ;
        }
        CPos = CPos + 1;
    }
}

_bs()
{// addr = 0x0807E1EB
    _unknown_ __ebp;

    if(CPos <= 0) {
        return ;
    }
    _mvL();
    delC();
    return;
}

_bsw()
{// addr = 0x0807E206
    int t;
    intOrPtr _v16;
    _unknown_ __ebp;
    intOrPtr _t7;

    _v16 = 0;
    while(CPos > 0) {
        if(_v16 != 0) {
            return ;
        }
        _mvL();
        if(move_word == 0 || terminated(strBuf->ptr[CPos - 1] & 255 & 4294967295 & ) == 0) {
            _t7 = 0;
        } else {
            _t7 = 1;
        }
        _v16 = _t7;
        delC();
    }
}

_enter()
{// addr = 0x0807E26C
    _unknown_ __ebp;

    i_cont = 0;
    return;
}

insertself(char c)
{// addr = 0x0807E27B
    signed char _v16;
    _unknown_ __ebp;
    signed int _t15;
    int _t20;

    _v16 = c & 4294967295;
    if(CLen > 1023) {
        return ;
    }
    insC();
    strBuf->ptr[CPos] = _v16 & 255 & 4294967295;
    _t20 = CPos;
    if(is_passwd == 0) {
        _t15 = 256;
    } else {
        _t15 = 0;
    }
     *(_t20 +  &strProp + _t20) = _t15 & 4294967295;
    CPos = CPos + 1;
    return;
}

_quo()
{// addr = 0x0807E2E1
    _unknown_ __ebp;

    i_quote = 1;
    return;
}

_mvB()
{// addr = 0x0807E2F0
    _unknown_ __ebp;

    CPos = 0;
    return;
}

_mvE()
{// addr = 0x0807E2FF
    _unknown_ __ebp;

    CPos = CLen;
    return;
}

killn()
{// addr = 0x0807E30E
    _unknown_ _v24;
    _unknown_ __ebp;

    CLen = CPos;
    Strtruncate(strBuf, CLen);
    return;
}

killb()
{// addr = 0x0807E337
    _unknown_ __ebp;

    while(CPos > 0) {
        _bs();
    }
}

_inbrk()
{// addr = 0x0807E34F
    _unknown_ __ebp;

    i_cont = 0;
    i_broken = 1;
    return;
}

_compl()
{// addr = 0x0807E368
    _unknown_ __ebp;

    next_compl(1);
    return;
}

_rcompl()
{// addr = 0x0807E37C
    _unknown_ __ebp;

    next_compl(-1);
    return;
}

_tcompl()
{// addr = 0x0807E390
    _unknown_ __ebp;

    if((cm_mode & 1 & 4294967295) == 0) {
        if((cm_mode & 2) == 0) {
            return ;
        }
        cm_mode = 1;
        return;
    }
    cm_mode = 2;
    return;
}

next_compl(int next)
{// addr = 0x0807E3C3
    int status;
    int b;
    int a;
    Str buf;
    Str s;
    int _v16;
    int _v20;
    int _v24;
    struct _Str* _v28;
    struct _Str* _v32;
    struct _Str _v56;
    _unknown_ __ebp;

    if(cm_mode == 0) {
        return ;
    }
    if((cm_mode & 1 & 4294967295) != 0) {
        return ;
    }
    cm_clear = 0;
    if(cm_next != 0) {
        _v32 = doComplete(strBuf,  &_v16, next);
L15:
        if(next == 0) {
            return ;
        }
        if(_v16 != 0 && _v16 != 3) {
            bell();
        }
        if(_v16 == 2) {
            return ;
        }
        _v56.area_size = 0;
        _v56.length = CAfterBuf->ptr;
        _v56 =  *_v32;
        strBuf = Strnew_m_charp(CBeforeBuf->ptr);
        CLen = setStrType(strBuf,  &strProp);
        CPos = CBeforeBuf->length + _v32->length;
        if(CPos <= CLen) {
            return ;
        }
        CPos = CLen;
        return;
    } else {
        if((cm_mode & 4) == 0) {
            _v20 = CPos - 1;
            while(_v20 >= 0) {
                if(( *(strBuf->ptr + _v20) & 255 & 4294967295) == 32 || ( *(strBuf->ptr + _v20) & 255 & 4294967295) == 9) {
                    if(_v20 <= 0 || ( *(strBuf->ptr + _v20 - 1) & 255 & 4294967295) != 92) {
                        goto L12;
                    } else {
                        goto L10;
                    }
                    goto L13;
                }
L10:
                _v20 = _v20 - 1;
            }
        } else {
            _v20 = 0;
L13:
            _v24 = CPos;
            CBeforeBuf = Strsubstr(strBuf, 0, _v20);
            _v28 = Strsubstr(strBuf, _v20, _v24 - _v20);
            CAfterBuf = Strsubstr(strBuf, _v24, strBuf->length - _v24);
            _v32 = doComplete(_v28,  &_v16, next);
            goto L15;
        }
L12:
        _v20 = _v20 + 1;
        goto L13;
    }
}

_dcompl()
{// addr = 0x0807E5D4
    _unknown_ __ebp;

    next_dcompl(1);
    return;
}

_rdcompl()
{// addr = 0x0807E5E8
    _unknown_ __ebp;

    next_dcompl(-1);
    return;
}

next_dcompl(int next)
{// addr = 0x0807E5FC
    int i;
    int j;
    int n;
    int y;
    Str f;
    char* p;
    struct stat st;
    int comment;
    int nline;
    signed int _v16;
    signed int _v20;
    signed int _v24;
    int _v28;
    struct _Str* _v32;
    char* _v36;
    int _v40;
    int _v44;
    signed int _v116;
    char _v132;
    signed int _v144;
    _unknown_ _v164;
    _unknown_ _v168;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    char* _t192;
    struct _Str* _t230;
    _unknown_ _t275;
    _unknown_ _t276;
    _unknown_ _t279;
    _unknown_ _t280;
    int _t291;
    _unknown_ _t299;
    _unknown_ _t300;

    if(cm_mode == 0) {
        return ;
    }
    if((cm_mode & 1 & 4294967295) != 0) {
        return ;
    }
    cm_disp_clear = 0;
    if(CurrentTab != 0) {
        displayBuffer(CurrentTab->currentBuffer, 1);
    }
    if(LINES - 1 <= 2) {
        if(LINES == 1) {
            return ;
        }
        _v40 = 0;
        _v44 = LINES - 1;
    } else {
        _v40 = 1;
        _v44 = LINES - 3;
    }
    if(cm_disp_next >= 0) {
        cm_next = 0;
        next_compl(0);
        if(NCFileBuf == 0) {
            return ;
        }
        cm_disp_next = 0;
         *135779020 = wc_Str_conv_strict(Strdup(CDirBuf), InnerCharset, SystemCharset);
        if( *135779020->length > 0 && ( *135779020->length <= 0 || ( *( *( *135779020) +  *135779020->length - 1) & 255 & 4294967295) != 47)) {
            if( *135779020->length + 1 >=  *135779020->area_size) {
                Strgrow( *135779020);
            }
            _t230 =  *135779020;
            _t291 = _t230->length;
             *((char*)( *( *135779020) + _t291)) = 47;
            _t230->length = _t291 + 1;
             *( *( *135779020) +  *135779020->length) = 0;
        }
        if((cm_mode & 8) != 0 && ( *( *( *135779020)) & 255 & 4294967295) == 102) {
            _v36 =  *( *135779020);
            if(strncmp(_v36, "file://localhost/", 17) != 0) {
                if(strncmp(_v36, "file:///", 8) != 0) {
                    if(strncmp(_v36, "file:/", 6) == 0 && (_v36[6] & 255 & 4294967295) != 47) {
                        _v36 =  &(_v36[5]);
                    }
                } else {
                    _v36 =  &(_v36[7]);
                }
            } else {
                _v36 =  &(_v36[0x10]);
            }
             *135779020 = Strnew_charp(_v36);
        }
         *135779024 = 0;
        _v16 = 0;
        while(_v16 < NCFileBuf) {
            _v24 = strlen(CFileBuf[_v16]) + 3;
            if( *135779024 < _v24) {
                 *135779024 = _v24;
            }
            _v16 = _v16 + 1;
        }
    } else {
        if(next != 1) {
            if(next == 255) {
                cm_disp_next = cm_disp_next -  *135779012 * _v44;
                if(cm_disp_next < 0) {
                    cm_disp_next = 0;
                }
            }
        } else {
            cm_disp_next =  *135779012 * _v44 + cm_disp_next;
            if(cm_disp_next >= NCFileBuf) {
                cm_disp_next = 0;
            }
        }
    }
    _v144 =  *135779012;
    row = (NCFileBuf - cm_disp_next +  *135779012 - 1) / _v144;
    if(_v40 == 0) {
        if(row < _v44) {
            _v28 = _v44 - row - 1;
        } else {
            row = _v44;
            _v28 = 0;
        }
    } else {
        if(row <= _v44) {
            _v28 = _v44 - row + 1;
        } else {
            row = _v44;
            _v28 = 0;
        }
    }
    if(_v28 != 0) {
        move(_v28 - 1, 0);
        clrtoeolx();
    }
    if(_v40 != 0) {
        move(_v28, 0);
        clrtoeolx();
        bold();
        addstr("----- Completion list -----");
        boldend();
        _v28 = _v28 + 1;
    }
    _v16 = 0;
L63:
    while(_v16 < row) {
        _v20 = 0;
        while(_v20 <  *135779012) {
            _v24 = row * _v20 + cm_disp_next + _v16;
            if(_v24 >= NCFileBuf) {
                goto L62;
            }
            move(_v28,  *135779024 * _v20);
            clrtoeolx();
            _v32 = Strdup( *135779020);
            Strcat_charp(_v32, CFileBuf[_v24]);
            addstr( *(wc_Str_conv(Strnew_charp(CFileBuf[_v24]), SystemCharset, InnerCharset)));
            _t192 = expandPath( *_v32);
            L080C7280(_t192,  &_v132);
            if(_t192 != 255 && (_v116 & 61440) == 16384) {
                addstr("/");
            }
            _v20 = _v20 + 1;
            continue;
L62:
            _v28 = _v28 + 1;
            _v16 = _v16 + 1;
            goto L63;
        }
    }
}

Str escape_spaces(Str s)
{// addr = 0x0807EBE9
    Str tmp;
    char* p;
    struct _Str* _v16;
    char* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t71;
    int _t83;

    _v16 = 0;
    if(s == 0) {
        return s;
    }
    _v20 = s->ptr;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *_v20 & 255 & 4294967295) == 32 || ( *_v20 & 255 & 4294967295) == 9) {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(s->ptr, _v20 - s->ptr);
            }
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t71 = _v16->length;
             *((char*)( *_v16 + _t71)) = 92;
            _v16->length = _t71 + 1;
             *( *_v16 + _v16->length) = 0;
        }
        if(_v16 != 0) {
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t83 = _v16->length;
             *( *_v16 + _t83) =  *_v20 & 255 & 4294967295;
            _v16->length = _t83 + 1;
             *( *_v16 + _v16->length) = 0;
        }
        _v20 =  &(_v20[1]);
    }
}

Str unescape_spaces(Str s)
{// addr = 0x0807ED0B
    Str tmp;
    char* p;
    struct _Str* _v16;
    char* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t56;

    _v16 = 0;
    if(s == 0) {
        return s;
    }
    _v20 = s->ptr;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *_v20 & 255 & 4294967295) != 92 || (_v20[1] & 255 & 4294967295) != 32 && (_v20[1] & 255 & 4294967295) != 9) {
            if(_v16 != 0) {
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t56 = _v16->length;
                 *( *_v16 + _t56) =  *_v20 & 255 & 4294967295;
                _v16->length = _t56 + 1;
                 *( *_v16 + _v16->length) = 0;
            }
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(s->ptr, _v20 - s->ptr);
            }
        }
        _v20 =  &(_v20[1]);
    }
}

Str doComplete(Str ifn, int* status, int next)
{// addr = 0x0807EDF7
    int fl;
    int i;
    char* fn;
    char* p;
    DIR* d;
    Directory* dir;
    struct stat st;
    int _v16;
    int _v20;
    char* _v24;
    char* _v28;
    char* _v32;
    char* _v36;
    signed int _v108;
    char _v124;
    int _v128;
    intOrPtr _v144;
    _unknown_ _v148;
    intOrPtr _v152;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t161;
    char* _t182;
    struct _Str* _t190;
    struct _Str* _t212;
    char* _t246;
    char* _t253;
    char** _t260;
    char* _t265;
    _unknown_ _t271;
    _unknown_ _t300;
    struct _Str* _t326;
    _unknown_ _t382;
    int _t388;
    int _t392;
    int _t411;

    if(cm_next != 0) {
        CFileName = Strnew_charp(CFileBuf[NCFileOffset]);
        _v128 = NCFileBuf;
        NCFileOffset = (NCFileOffset + next + NCFileBuf) % _v128;
         *status = 3;
    } else {
        NCFileBuf = 0;
        ifn = wc_Str_conv_strict(ifn, InnerCharset, SystemCharset);
        if((cm_mode & 2) != 0) {
            ifn = unescape_spaces(ifn);
        }
        CompleteBuf = Strdup(ifn);
        while(CompleteBuf->length <= 0 || ( *(CompleteBuf->ptr + CompleteBuf->length - 1) & 255 & 4294967295) != 47) {
            if(CompleteBuf->length > 0) {
                Strshrink(CompleteBuf, 1);
                continue;
            }
            CDirBuf = Strdup(CompleteBuf);
            if((cm_mode & 8) == 0) {
L17:
                if(CompleteBuf->length == 0) {
                    if(CompleteBuf->length + 1 >= CompleteBuf->area_size) {
                        Strgrow(CompleteBuf);
                    }
                    _t326 = CompleteBuf;
                    _t411 = _t326->length;
                     *((char*)(CompleteBuf->ptr + _t411)) = 46;
                    _t326->length = _t411 + 1;
                     *(CompleteBuf->ptr + CompleteBuf->length) = 0;
                }
                if(CompleteBuf->length > 0 && ( *(CompleteBuf->ptr + CompleteBuf->length - 1) & 255 & 4294967295) == 47 && CompleteBuf->length > 1) {
                    Strshrink(CompleteBuf, 1);
                }
                _t246 = expandPath(CompleteBuf->ptr);
                 *__esp = _t246;
                opendir();
                _v32 = _t246;
                if(_v32 == 0) {
                    CompleteBuf = Strdup(ifn);
                     *status = 2;
                    if((cm_mode & 2) == 0) {
                        return CompleteBuf;
                    }
                    CompleteBuf = escape_spaces(CompleteBuf);
                    return CompleteBuf;
                }
                _v24 = lastFileName(ifn->ptr);
                _v16 = strlen(_v24);
                CFileName = Strnew();
                while(1) {
                    _t253 = _v32;
                     *__esp = _t253;
                    readdir();
                    _v36 = _t253;
                    if(_v36 == 0) {
                        break;
                    }
                    if(_v16 != 0 || strcmp( &(_v36[0xb]), ".") != 0 && strcmp( &(_v36[0xb]), "..") != 0) {
                        if(strncmp( &(_v36[0xb]), _v24, _v16) != 0) {
                            continue;
                        }
                    } else {
                        continue;
                    }
L39:
                    NCFileBuf = NCFileBuf + 1;
                    _t260 = CFileBuf;
                    _v152 = 0 + NCFileBuf * 4;
                     *__esp = _t260;
                    GC_realloc();
                    CFileBuf = _t260;
                    _t265 = strlen( &(_v36[0xb])) + 1;
                     *__esp = _t265;
                    GC_malloc_atomic();
                    CFileBuf[NCFileBuf - 1] = _t265;
                    strcpy(CFileBuf[NCFileBuf - 1],  &(_v36[0xb]));
                    if(NCFileBuf != 1) {
                        _v20 = 0;
L43:
                        while((CFileName->ptr[_v20] & 255 & 4294967295) == (_v36[_v20 + 11] & 255 & 4294967295)) {
                            goto L42;
                        }
                    }
                    CFileName = Strnew_charp( &(_v36[0xb]));
                    continue;
L42:
                    _v20 = _v20 + 1;
                    goto L43;
                }
                 *__esp = _v32;
                closedir();
                if(NCFileBuf == 0) {
                    CompleteBuf = Strdup(ifn);
                     *status = 2;
                    if((cm_mode & 2) == 0) {
                        return CompleteBuf;
                    }
                    CompleteBuf = escape_spaces(CompleteBuf);
                    return CompleteBuf;
                } else {
                    _v144 = strCmp;
                    qsort(CFileBuf, NCFileBuf, 4);
                    NCFileOffset = 0;
                    if(NCFileBuf <= 1) {
                         *status = 0;
                    } else {
                        cm_next = 1;
                         *status = 1;
                    }
                }
                goto L52;
            }
            if(strncmp(CompleteBuf->ptr, "file://localhost/", 17) != 0) {
                if(strncmp(CompleteBuf->ptr, "file:///", 8) != 0) {
                    if(strncmp(CompleteBuf->ptr, "file:/", 6) != 0) {
L16:
                        CompleteBuf = Strdup(ifn);
                         *status = 2;
                        return wc_Str_conv_strict(CompleteBuf, InnerCharset, SystemCharset);
                    }
                } else {
                    Strdelete(CompleteBuf, 0, 7);
                    goto L17;
                }
L14:
                if(( *(CompleteBuf->ptr + 6) & 255 & 4294967295) == 47) {
                    goto L16;
                } else {
                    Strdelete(CompleteBuf, 0, 5);
                }
            } else {
                Strdelete(CompleteBuf, 0, 16);
            }
            goto L17;
        }
    }
L52:
    CompleteBuf = Strdup(CDirBuf);
    if(CompleteBuf->length != 0 && (CompleteBuf->length <= 0 || ( *(CompleteBuf->ptr + CompleteBuf->length - 1) & 255 & 4294967295) != 47)) {
        if(CompleteBuf->length + 1 >= CompleteBuf->area_size) {
            Strgrow(CompleteBuf);
        }
        _t212 = CompleteBuf;
        _t392 = _t212->length;
         *((char*)(CompleteBuf->ptr + _t392)) = 47;
        _t212->length = _t392 + 1;
         *(CompleteBuf->ptr + CompleteBuf->length) = 0;
    }
    Strcat(CompleteBuf, CFileName);
    if( *status != 1) {
        _v28 = CompleteBuf->ptr;
        if((cm_mode & 8) != 0) {
            if(strncmp(_v28, "file://localhost/", 17) != 0) {
                if(strncmp(_v28, "file:///", 8) != 0) {
                    if(strncmp(_v28, "file:/", 6) == 0 && (_v28[6] & 255 & 4294967295) != 47) {
                        _v28 =  &(_v28[5]);
                    }
                } else {
                    _v28 =  &(_v28[7]);
                }
            } else {
                _v28 =  &(_v28[0x10]);
            }
        }
        _t182 = expandPath(_v28);
        L080C7280(_t182,  &_v124);
        if(_t182 != 255 && (_v108 & 61440) == 16384) {
            if(CompleteBuf->length + 1 >= CompleteBuf->area_size) {
                Strgrow(CompleteBuf);
            }
            _t190 = CompleteBuf;
            _t388 = _t190->length;
             *((char*)(CompleteBuf->ptr + _t388)) = 47;
            _t190->length = _t388 + 1;
             *(CompleteBuf->ptr + CompleteBuf->length) = 0;
        }
    }
    if((cm_mode & 2) == 0) {
        return wc_Str_conv(CompleteBuf, SystemCharset, InnerCharset);
    }
    CompleteBuf = escape_spaces(CompleteBuf);
    return wc_Str_conv(CompleteBuf, SystemCharset, InnerCharset);
}

_prev()
{// addr = 0x0807F5AE
    Hist* hist;
    char* p;
    Hist* _v16;
    char* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = CurrentHist;
    if(use_hist == 0) {
        return ;
    }
    if(strCurrentBuf == 0) {
        _v20 = lastHist(_v16);
        if(_v20 == 0) {
            return ;
        }
        strCurrentBuf = strBuf;
    } else {
        _v20 = prevHist(_v16);
        if(_v20 == 0) {
            return ;
        }
    }
    if(DecodeURL != 0 && (cm_mode & 8) != 0) {
        _v20 = url_unquote_conv(_v20, 0);
    }
    strBuf = Strnew_charp(_v20);
    CPos = setStrType(strBuf,  &strProp);
    CLen = CPos;
     *135778952 = 0;
    return;
}

_next()
{// addr = 0x0807F67A
    Hist* hist;
    char* p;
    Hist* _v16;
    char* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = CurrentHist;
    if(use_hist == 0) {
        return ;
    }
    if(strCurrentBuf == 0) {
        return ;
    }
    _v20 = nextHist(_v16);
    if(_v20 == 0) {
        strBuf = strCurrentBuf;
        strCurrentBuf = 0;
    } else {
        if(DecodeURL != 0 && (cm_mode & 8) != 0) {
            _v20 = url_unquote_conv(_v20, 0);
        }
        strBuf = Strnew_charp(_v20);
    }
    CPos = setStrType(strBuf,  &strProp);
    CLen = CPos;
     *135778952 = 0;
    return;
}

int setStrType(Str str, Lineprop* prop)
{// addr = 0x0807F73D
    Lineprop ctype;
    char* p;
    char* ep;
    int i;
    int len;
    signed int _v6;
    char* _v12;
    char* _v16;
    signed short _v20;
    signed int _v24;
    _unknown_ __ebp;
    signed int _t84;

    _v12 = str->ptr;
    _v16 =  &(_v12[str->length]);
    _v24 = 1;
    _v20 = 0;
    while(_v12 < _v16) {
        _v24 =  *( &WTF_LEN_MAP + ( *_v12 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        if(_v20 + _v24 > 1024) {
            return _v20;
        }
        _v6 = ( *( &WTF_TYPE_MAP + ( *_v12 & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 8 & 4294967295;
        if(is_passwd != 0) {
            if((_v6 & 65535 & 256) != 0) {
                _v6 = 0;
            }
            if((_v6 & 65535 & 4096) != 0) {
                _v6 = 512;
            }
        }
         *(_v20 + _v20 + prop) = _v6 & 65535 & 4294967295;
        _v20 = _v20 + 1;
        _v12 =  &(_v12[_v24]);
        _v24 = _v24 - 1;
        if(_v24 == 0) {
            continue;
        }
        _t84 = _v6 & 65535;
        _v6 = _t84 & 4294967295;
        while(1) {
            _v24 = _v24 - 1;
            if((_t84 & 4294967295) == 0) {
                break;
            }
            _t84 = _v20 + _v20 + prop;
             *_t84 = _v6 & 65535 & 4294967295;
            _v20 = _v20 + 1;
        }
    }
}

int terminated(unsigned char c)
{// addr = 0x0807F846
    int[4] termchar;
    int* tp;
    intOrPtr* _v8;
    intOrPtr _v12;
    intOrPtr _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    char _v28;
    signed char _v40;
    _unknown_ __ebp;
    _unknown_ _t22;
    _unknown_ _t23;

    _v40 = c & 4294967295;
    _v28 = 47;
    _v24 = 38;
    _v20 = 63;
    _v16 = 32;
    _v12 = -1;
    _v8 =  &_v28;
    while( *_v8 > 0) {
        if((_v40 & 255) ==  *_v8) {
            return 1;
        }
        _v8 = _v8 + 4;
    }
}

_editor()
{// addr = 0x0807F8A5
    FormItemList fi;
    char* p;
    signed int _v16;
    struct form_item_list _v88;
    _unknown_ _v104;
    _unknown_ __ebx;
    _unknown_ __ebp;
    struct _Str* _t49;
    struct _Str* _t69;
    int _t91;
    int _t95;

    if(is_passwd != 0) {
        return ;
    }
    _v88.readonly = 0;
    _v88.value = Strdup(strBuf);
    if(_v80->length + 1 >= _v80->area_size) {
        Strgrow(_v88.value);
    }
    _t49 = _v88.value;
    _t91 = _t49->length;
     *((char*)( *(_v88.value) + _t91)) = 10;
    _t49->length = _t91 + 1;
     *((char*)( *(_v88.value) + _v88.value->length)) = 0;
    input_textarea( &_v88);
    strBuf = Strnew();
    _v16.ptr =  *(_v88.value);
    while((_v16 & 255 & 4294967295) != 0) {
        if((_v16 & 255 & 4294967295) != 13) {
            if(( *(_v16.ptr) & 255 & 4294967295) != 10) {
                if(strBuf->length + 1 >= strBuf->area_size) {
                    Strgrow(strBuf);
                }
                _t69 = strBuf;
                _t95 = _t69->length;
                 *(strBuf->ptr + _t95) =  *((signed char*)(_v16.ptr)) & 255 & 4294967295;
                _t69->length = _t95 + 1;
                 *((char*)(strBuf->ptr + strBuf->length)) = 0;
            }
        }
        _v16.ptr = _v16 + 1;
    }
}

int LUfactor(Matrix A, int* indexarray)
{// addr = 0x0807FA0C
    int dim;
    int i;
    int j;
    int k;
    int i_max;
    int k_max;
    Vector scale;
    double mx;
    double tmp;
    int tmp;
    double tmp;
    int _v16;
    signed int _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    struct vector* _v40;
    _unknown_ _v44;
    _unknown_ __ebp;
    _unknown_ _t180;
    _unknown_ _t188;
    _unknown_ _t197;
    _unknown_ _t201;
    _unknown_ _t202;
    _unknown_ _t212;
    _unknown_ _t216;
    _unknown_ _t217;
    _unknown_ _t222;
    _unknown_ _t228;
    _unknown_ _t232;
    _unknown_ _t233;
    _unknown_ _t235;
    _unknown_ _t239;
    _unknown_ _t240;
    _unknown_ _t253;
    _unknown_ _t257;
    _unknown_ _t258;
    _unknown_ _t260;
    _unknown_ _t266;
    _unknown_ _t270;
    _unknown_ _t271;
    _unknown_ _t273;
    _unknown_ _t277;
    _unknown_ _t278;
    _unknown_ _t280;
    _unknown_ _t284;
    _unknown_ _t285;
    _unknown_ _t286;
    _unknown_ _t287;
    _unknown_ _t288;
    _unknown_ _t289;
    _unknown_ _t290;
    _unknown_ _t291;
    _unknown_ _t299;
    _unknown_ _t301;
    _unknown_ _t305;
    _unknown_ _t306;
    _unknown_ _t308;
    _unknown_ _t312;
    _unknown_ _t313;
    _unknown_ _t315;
    _unknown_ _t321;
    _unknown_ _t323;
    _unknown_ _t324;
    _unknown_ _t325;
    _unknown_ _t326;

    _v16 = A->dim;
    _v40 = new_vector(_v16);
    _v20 = 0;
    while(_v20 < _v16) {
        indexarray[_v20] = _v20;
        _v20 = _v20 + 1;
    }
}

int LUsolve(Matrix A, int* indexarray, Vector b, Vector x)
{// addr = 0x0807FD68
    int i;
    int dim;
    intOrPtr _v16;
    int _v20;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t30;
    _unknown_ _t36;
    _unknown_ _t37;
    _unknown_ _t42;
    _unknown_ _t47;
    _unknown_ _t49;
    _unknown_ _t50;

    _v20 = A->dim;
    _v16 = 0;
    while(_v16 < _v20) {
    }
}

Matrix LUinverse(Matrix A, int* indexarray, Matrix out)
{// addr = 0x0807FE0A
    int i;
    int j;
    int dim;
    Vector tmp;
    Vector tmp2;
    intOrPtr _v16;
    intOrPtr _v20;
    int _v24;
    struct vector* _v28;
    struct vector* _v32;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t55;
    _unknown_ _t58;
    _unknown_ _t66;
    _unknown_ _t73;
    _unknown_ _t74;
    _unknown_ _t85;

    _v24 = A->dim;
    if(out == 0) {
        out = new_matrix(_v24);
    }
    _v28 = new_vector(_v24);
    _v32 = new_vector(_v24);
    _v16 = 0;
    while(_v16 < _v24) {
        _v20 = 0;
        while(_v20 < _v24) {
            asm("fldz ");
            asm("fstp qword [eax]");
            _v20 = _v20 + 1;
        }
    }
}

int Usolve(Matrix mat, Vector b, Vector out, double diag)
{// addr = 0x0807FF0A
    int i;
    int j;
    int i_lim;
    int dim;
    double sum;
    signed int _v8;
    intOrPtr _v12;
    signed int _v16;
    int _v20;
    intOrPtr _v40;
    double _v44;
    _unknown_ __ebp;
    _unknown_ _t62;
    _unknown_ _t65;
    _unknown_ _t69;
    _unknown_ _t74;
    _unknown_ _t78;
    _unknown_ _t79;
    _unknown_ _t82;
    _unknown_ _t85;
    _unknown_ _t86;
    signed int _t93;
    _unknown_ _t95;
    _unknown_ _t97;
    _unknown_ _t101;
    _unknown_ _t102;
    _unknown_ _t103;
    _unknown_ _t110;
    _unknown_ _t117;
    _unknown_ _t118;

    _v44 = diag;
    _v40 = _a20;
    _v20 = mat->dim;
    _v8 = _v20 - 1;
    while(_v8 >= 0) {
        asm("fld qword [eax]");
        asm("fldz ");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if(__eflags == 0 && __eflags == 0) {
            asm("fldz ");
            asm("fstp qword [eax]");
            _v8 = _v8 - 1;
            continue;
        }
        _v16 = _v8;
        while(_v8 >= 0) {
            asm("fld qword [eax]");
            asm("fstp qword [ebp-0x18]");
            _v12 = _v8 + 1;
            while(1) {
                __eflags = _v12 - _v16;
                if(__eflags > 0) {
                    break;
                }
                asm("fld qword [eax]");
                asm("fld qword [eax]");
                asm("fmulp st1, st0");
                asm("fld qword [ebp-0x18]");
                asm("fsubrp st1, st0");
                asm("fstp qword [ebp-0x18]");
                _v12 = _v12 + 1;
            }
            asm("fld qword [ebp-0x28]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if(__eflags != 0 || __eflags != 0) {
                asm("fld qword [ebp-0x18]");
                asm("fdiv qword [ebp-0x28]");
                asm("fstp qword [eax]");
            } else {
                _t93 = mat->me + (mat->dim + 1 << 3) * _v8;
                asm("fld qword [eax]");
                asm("fabs ");
                asm("fld qword [ebp-0x18]");
                asm("fabs ");
                asm("fld qword [0x80d56c0]");
                asm("fmulp st1, st0");
                asm("fucomip st0, st1");
                asm("fstp st0");
                asm("setnb al");
                __eflags = _t93 & 4294967295;
                if((_t93 & 4294967295) != 0) {
                    return -1;
                }
                asm("fld qword [eax]");
                asm("fld qword [ebp-0x18]");
                asm("fdivrp st1, st0");
                asm("fstp qword [edx]");
            }
            _v8 = _v8 - 1;
        }
    }
}

int Lsolve(Matrix mat, Vector b, Vector out, double diag)
{// addr = 0x08080075
    int i;
    int j;
    int i_lim;
    int dim;
    double sum;
    signed int _v8;
    signed int _v12;
    signed int _v16;
    int _v20;
    intOrPtr _v40;
    double _v44;
    _unknown_ __ebp;
    _unknown_ _t62;
    _unknown_ _t65;
    _unknown_ _t70;
    _unknown_ _t74;
    _unknown_ _t78;
    _unknown_ _t79;
    _unknown_ _t82;
    _unknown_ _t85;
    signed int _t92;
    _unknown_ _t94;
    _unknown_ _t96;
    _unknown_ _t100;
    _unknown_ _t101;
    _unknown_ _t102;
    _unknown_ _t103;
    _unknown_ _t110;
    _unknown_ _t117;
    _unknown_ _t118;

    _v44 = diag;
    _v40 = _a20;
    _v20 = mat->dim;
    _v8 = 0;
    while(_v8 < _v20) {
        asm("fld qword [eax]");
        asm("fldz ");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if(__eflags == 0 && __eflags == 0) {
            asm("fldz ");
            asm("fstp qword [eax]");
            _v8 = _v8 + 1;
            continue;
        }
        _v16 = _v8;
        while(_v8 < _v20) {
            asm("fld qword [eax]");
            asm("fstp qword [ebp-0x18]");
            _v12 = _v16;
            while(1) {
                __eflags = _v12 - _v8;
                if(__eflags >= 0) {
                    break;
                }
                asm("fld qword [eax]");
                asm("fld qword [eax]");
                asm("fmulp st1, st0");
                asm("fld qword [ebp-0x18]");
                asm("fsubrp st1, st0");
                asm("fstp qword [ebp-0x18]");
                _v12 = _v12 + 1;
            }
            asm("fld qword [ebp-0x28]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if(__eflags != 0 || __eflags != 0) {
                asm("fld qword [ebp-0x18]");
                asm("fdiv qword [ebp-0x28]");
                asm("fstp qword [eax]");
            } else {
                _t92 = mat->me + (mat->dim + 1 << 3) * _v8;
                asm("fld qword [eax]");
                asm("fabs ");
                asm("fld qword [ebp-0x18]");
                asm("fabs ");
                asm("fld qword [0x80d56c0]");
                asm("fmulp st1, st0");
                asm("fucomip st0, st1");
                asm("fstp st0");
                asm("setnb al");
                __eflags = _t92 & 4294967295;
                if((_t92 & 4294967295) != 0) {
                    return -1;
                }
                asm("fld qword [eax]");
                asm("fld qword [ebp-0x18]");
                asm("fdivrp st1, st0");
                asm("fstp qword [edx]");
            }
            _v8 = _v8 + 1;
        }
    }
}

Matrix new_matrix(int n)
{// addr = 0x080801DF
    Matrix mat;
    struct matrix* _v16;
    _unknown_ __ebp;
    struct matrix _t13;

    __esp->me = 8;
    GC_malloc();
    _v16 = __eax;
    _v16->dim = n;
    _t13 = n * n << 3;
     *__esp = _t13;
    GC_malloc_atomic();
     *_v16 = _t13;
    return _v16;
}

Vector new_vector(int n)
{// addr = 0x0808021B
    Vector vec;
    struct vector* _v16;
    _unknown_ __ebp;
    struct vector _t11;

    __esp->ve = 8;
    GC_malloc();
    _v16 = __eax;
    _v16->dim = n;
    _t11 = n << 3;
     *__esp = _t11;
    GC_malloc_atomic();
     *_v16 = _t11;
    return _v16;
}

double weight(int x)
{// addr = 0x08080253
    double _v16;
    _unknown_ __ebp;
    double _t4;
    double _t6;

    _t4 = COLS;
    if(x >= _t4) {
        _v16 = COLS;
        asm("fild dword [ebp-0xc]");
        asm("fstp qword [ebp-0x18]");
        asm("fild dword [ebp+0x8]");
        _t6 = COLS;
        _v16 = _t6;
        asm("fild dword [ebp-0xc]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        log();
        asm("fld1 ");
        asm("faddp st1, st0");
        asm("fmul qword [ebp-0x18]");
        return _t6;
    }
    asm("fild dword [ebp+0x8]");
    return _t4;
}

double weight2(int a)
{// addr = 0x08080297
    double _v8;
    _unknown_ __ebp;

    asm("fild dword [ebp+0x8]");
    __eax = COLS;
    _v8 = __eax;
    asm("fild dword [ebp-0x4]");
    asm("fdivp st1, st0");
    asm("fld qword [0x80cb5c0]");
    asm("fmulp st1, st0");
    asm("fld1 ");
    asm("faddp st1, st0");
    return __eax;
}

int bsearch_2short(short int e1, short int* ent1, short int e2, short int* ent2, int base, short int* indexarray, int nent)
{// addr = 0x080802BB
    int n;
    int k;
    int e;
    int nn;
    int idx;
    int ne;
    unsigned int _v8;
    intOrPtr _v12;
    intOrPtr _v16;
    signed int _v20;
    signed int _v24;
    intOrPtr _v28;
    signed short _v40;
    signed int _v44;
    _unknown_ __ebp;

    _v40 = e1 & 4294967295;
    _v44 = e2 & 4294967295;
    _v8 = nent;
    _v12 = 0;
    _v16 = _v40 * base + _v44;
    while(_v8 > 0) {
        _v20 = (_v8 >> 31) + _v8 >> 1;
        asm("cwde ");
        _v24 =  *(_v12 + _v20 + _v12 + _v20 + indexarray) & 65535;
        asm("cwde ");
        asm("cwde ");
        _v28 = ( *(_v24 + _v24 + ent1) & 65535) * base + ( *(_v24 + _v24 + ent2) & 65535);
        if(_v28 == _v16) {
            _v12 = _v12 + _v20;
            return _v12;
        }
        if(_v28 >= _v16) {
            _v8 = _v20;
        } else {
            _v8 = _v8 +  !_v20;
            _v12 = _v12 + _v20 + 1;
        }
    }
}

int bsearch_double(double e, double* ent, short int* indexarray, int nent)
{// addr = 0x08080377
    int n;
    int k;
    int nn;
    int idx;
    double ne;
    unsigned int _v8;
    int _v12;
    signed int _v16;
    signed int _v20;
    double* _v40;
    double _v44;
    _unknown_ __ebp;
    signed int _t46;

    _v44 = e;
    _v40 = ent;
    _v8 = _a20;
    _v12 = 0;
    while(1) {
        __eflags = _v8;
        if(__eflags <= 0) {
            break;
        }
        _v16 = (_v8 >> 31) + _v8 >> 1;
        asm("cwde ");
        _v20 =  *(_v12 + _v16 + _v12 + _v16 + nent) & 65535;
        _t46 = indexarray + (_v20 << 3);
        asm("fld qword [eax]");
        asm("fstp qword [ebp-0x18]");
        asm("fld qword [ebp-0x18]");
        asm("fld qword [ebp-0x28]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if(__eflags == 0 && __eflags == 0) {
            _v12 = _v12 + _v16;
            return _v12;
        }
        asm("fld qword [ebp-0x18]");
        asm("fld qword [ebp-0x28]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        __eflags = _t46 & 4294967295;
        if((_t46 & 4294967295) == 0) {
            _v8 = _v16;
        } else {
            _v8 = _v8 +  !_v16;
            _v12 = _v12 + _v16 + 1;
        }
    }
    return _v12;
}

int ceil_at_intervals(int x, int step)
{// addr = 0x0808041A
    int mo;
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t20;
    _unknown_ _t28;

    _v8 = x % step;
    if(_v8 <= 0) {
        if(_v8 >= 0) {
            return x;
        }
        goto L3;
    }
    x = x + step - _v8;
    return x;
L3:
    x = x - _v8;
    return x;
}

int floor_at_intervals(int x, int step)
{// addr = 0x08080456
    int mo;
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t20;
    _unknown_ _t28;

    _v8 = x % step;
    if(_v8 <= 0) {
        if(_v8 >= 0) {
            return x;
        }
        goto L3;
    }
    x = x - _v8;
    return x;
L3:
    x = x + step - _v8;
    return x;
}

int table_colspan(struct table* t, int row, int col)
{// addr = 0x08080492
    int i;
    intOrPtr _v8;
    _unknown_ __ebp;

    _v8 = col + 1;
    while(t->maxcol >= _v8) {
        if(( *(t->tabattr[row] + _v8 + _v8) & 65535 & 4294967295 &  & 1 & 4294967295) == 0) {
            return _v8 - col;
        }
        _v8 = _v8 + 1;
    }
}

int table_rowspan(struct table* t, int row, int col)
{// addr = 0x080804E4
    int i;
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t43;

    if(t->tabattr[row] == 0) {
        return 0;
    }
    _v8 = row + 1;
    while(t->maxrow >= _v8) {
        if(t->tabattr[_v8] == 0) {
            return _v8 - row;
        }
        if(( *(t->tabattr[_v8] + col + col) & 65535 & 4294967295 &  & 2) == 0) {
            return _v8 - row;
        }
        _v8 = _v8 + 1;
    }
}

int minimum_cellspacing(int border_mode)
{// addr = 0x08080565
    _unknown_ __ebp;
    int _t2;
    _unknown_ _t3;
    _unknown_ _t4;

    _t2 = border_mode;
    if(_t2 == 0) {
        return 1;
    }
    if(_t2 >= 0) {
        return 0;
    }
    if(_t2 > 3) {
        return 0;
    }
    return symbol_width;
}

int table_border_width(struct table* t)
{// addr = 0x0808058D
    _unknown_ __ebp;
    int _t16;
    _unknown_ _t21;

    _t16 = t->border_mode;
    if(_t16 > 2) {
        if(_t16 == 3) {
            return t->cellspacing * t->maxcol;
        }
        return 0;
    }
    if(_t16 >= 1) {
        return t->maxcol * t->cellspacing + t->cellpadding + symbol_width + t->cellpadding + symbol_width;
    }
    if(_t16 == 0) {
        return t->cellspacing * t->maxcol;
    }
    return 0;
}

struct table* newTable()
{// addr = 0x080805E9
    struct table* t;
    int i;
    int j;
    intOrPtr _v16;
    signed int _v20;
    _unknown_ _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    intOrPtr _t81;
    intOrPtr _t82;
    intOrPtr _t83;
    intOrPtr _t84;
    intOrPtr _t85;

     *__esp = 716;
    GC_malloc();
    _v16 = __eax;
    _t81 = _v16;
     *((intOrPtr*)(_t81 + 16)) = 50;
     *__esp = 200;
    GC_malloc();
    _t82 = _v16;
     *((intOrPtr*)(_t82 + 68)) = _t81;
     *__esp = 200;
    GC_malloc();
    _t83 = _v16;
     *((intOrPtr*)(_t83 + 72)) = _t82;
     *__esp = 100;
    GC_malloc_atomic();
    _t84 = _v16;
     *((intOrPtr*)(_t84 + 676)) = _t83;
     *__esp = 200;
    GC_malloc();
    _t85 = _v16;
     *((intOrPtr*)(_t85 + 80)) = _t84;
     *__esp = 200;
    GC_malloc();
     *((intOrPtr*)(_v16 + 84)) = _t85;
    _v20 = 0;
    while(_v20 <= 49) {
         *( *((intOrPtr*)(_v16 + 68)) + (_v20 << 2)) = 0;
         *( *((intOrPtr*)(_v16 + 72)) + (_v20 << 2)) = 0;
         *( *((intOrPtr*)(_v16 + 676)) + _v20 + _v20) = 0;
         *( *((intOrPtr*)(_v16 + 80)) + (_v20 << 2)) = 0;
         *( *((intOrPtr*)(_v16 + 84)) + (_v20 << 2)) = 0;
        _v20 = _v20 + 1;
    }
}

check_row(struct table* t, int row)
{// addr = 0x080807E9
    int i;
    int r;
    GeneralList*** tabdata;
    table_attr** tabattr;
    short int* tabheight;
    Str** tabidvalue;
    Str* tridvalue;
    signed int _v16;
    signed int _v20;
    signed int _v24;
    signed int _v28;
    signed int _v32;
    signed int _v36;
    signed int _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t143;
    signed int _t146;
    signed int _t148;
    signed int _t150;
    signed int _t152;
    signed int _t154;
    _unknown_ _t227;

    if(t->max_rowsize <= row) {
        _t227 = row + 1;
        _t143 = t->max_rowsize + t->max_rowsize;
        _t144 = _t227 - _t143 >= 0 ? _t227 : _t143;
        _v20 = _t227 - _t143 >= 0 ? _t227 : _t143;
        _t146 = _v20 << 2;
         *__esp = _t146;
        GC_malloc();
        _v24 = _t146;
        _t148 = _v20 << 2;
         *__esp = _t148;
        GC_malloc();
        _v28 = _t148;
        _t150 = _v20 + _v20;
         *__esp = _t150;
        GC_malloc_atomic();
        _v32 = _t150;
        _t152 = _v20 << 2;
         *__esp = _t152;
        GC_malloc();
        _v36 = _t152;
        _t154 = _v20 << 2;
         *__esp = _t154;
        GC_malloc();
        _v40 = _t154;
        _v16 = 0;
        while(t->max_rowsize > _v16) {
             *((_v16 << 2) + _v24) = t->tabdata[_v16];
             *((_v16 << 2) + _v28) = t->tabattr[_v16];
             *(_v16 + _v16 + _v32) =  *(t->tabheight + _v16 + _v16) & 65535 & 4294967295;
             *((_v16 << 2) + _v36) = t->tabidvalue[_v16];
             *((intOrPtr*)((_v16 << 2) + _v40)) =  *((intOrPtr*)(t->tridvalue + (_v16 << 2)));
            _v16 = _v16 + 1;
        }
    }
    if(t->tabdata[row] != 0) {
        return ;
    }
     *__esp = 200;
    GC_malloc();
    t->tabdata[row] = t->tabdata;
     *__esp = 100;
    GC_malloc_atomic();
    t->tabattr[row] = t->tabattr;
     *__esp = 200;
    GC_malloc();
    t->tabidvalue[row] = t->tabidvalue;
    _v16 = 0;
L11:
    while(_v16 <= 49) {
        t->tabdata[row][_v16] = 0;
         *(t->tabattr[row] + _v16 + _v16) = 0;
        t->tabidvalue[row][_v16] = 0;
        _v16 = _v16 + 1;
    }
    goto L11;
}

pushdata(struct table* t, int row, int col, char* data)
{// addr = 0x08080A82
    _unknown_ _v24;
    _unknown_ __ebp;
    const char* _t29;

    check_row(t, row);
    if(t->tabdata[row][col] == 0) {
        t->tabdata[row][col] = newGeneralList();
    }
    if(data == 0) {
        _t29 = 135049312;
    } else {
        _t29 = data;
    }
    pushValue(t->tabdata[row][col], allocStr(_t29, -1));
    return;
}

suspend_or_pushdata(struct table* tbl, char* line)
{// addr = 0x08080B25
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    const char* _t26;

    if((tbl->flag & 4) == 0) {
        if(tbl->suspended_data == 0) {
            tbl->suspended_data = newGeneralList();
        }
        if(line == 0) {
            _t26 = 135049312;
        } else {
            _t26 = line;
        }
        pushValue(tbl->suspended_data, allocStr(_t26, -1));
        return;
    }
    pushdata(tbl, tbl->row, tbl->col, line);
    return;
}

int visible_length(char* str)
{// addr = 0x08080BB3
    int len;
    int n;
    int max_len;
    int status;
    int prev_status;
    Str tagbuf;
    char* t;
    char* r2;
    int amp_len;
    intOrPtr _v16;
    int _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    struct _Str _v44;
    intOrPtr _v48;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t175;
    int _t187;
    _unknown_ _t210;
    _unknown_ _t221;
    _unknown_ _t232;
    _unknown_ _t240;

    _v16 = 0;
    _v24 = 0;
    _v28 = 0;
    _v32 = _v28;
    _v44.area_size = Strnew();
    _v48 = 0;
    _v44.length = str;
    while(( *str & 255 & 4294967295) != 0) {
        if(_v28 != 1) {
            if(_v28 == 2 || _v28 == 4 || _v28 == 3 || _v28 == 5 || _v28 == 15) {
                Strcat_charp_n(_v44.area_size, str, _v20);
            } else {
                if(_v28 != 6) {
                    if(_v28 != 0 || _v32 != 6) {
                        if(_v28 != 0 || _v32 != 2 && _v32 != 1 && _v32 != 5 && _v32 != 15) {
                            if(( *str & 255 & 4294967295) != 9) {
                                if(( *str & 255 & 4294967295) == 13 || ( *str & 255 & 4294967295) == 10) {
                                    _v16 = _v16 - 1;
                                    if(_v16 > _v24) {
                                        _v24 = _v16;
                                    }
                                    _v16 = 0;
                                }
                                goto L42;
                            } else {
                                _v16 = _v16 - 1;
                                goto L35;
                            }
                            while(1) {
L35:
                                _v16 = _v16 + 1;
                                if((visible_length_offset + _v16) % Tabstop == 0) {
                                    break;
                                }
                            }
                        }
                    } else {
                        Strcat_charp_n(_v44.area_size, str, _v20);
                        _v44 =  *(_v44.area_size);
                        _v44.length = getescapecmd( &_v44);
                        if(( *_v44 & 255 & 4294967295) != 0 || ( *_v40 & 255 & 4294967295) != 13 && ( *_v40 & 255 & 4294967295) != 10) {
                            _t187 = wtf_strwidth(_v44.length);
                            _v16 = _v16 + _t187 + wtf_strwidth(_v44);
                        } else {
                            if(_v16 > _v24) {
                                _v24 = _v16;
                            }
                            _v16 = 0;
                        }
                    }
                } else {
                    if(_v32 != 0) {
                        Strcat_charp_n(_v44.area_size, str, _v20);
                        _v48 = _v48 + 1;
                    } else {
                        Strclear(_v44.area_size);
                        _v16 = _v16 - 1;
                        _v48 = 0;
                    }
                }
            }
        } else {
            Strclear(_v44.area_size);
            Strcat_charp_n(_v44.area_size, str, _v20);
        }
L42:
        str =  &(str[_v20]);
    }
}

int visible_length_plain(char* str)
{// addr = 0x08080EB9
    int len;
    int max_len;
    intOrPtr _v8;
    intOrPtr _v12;
    _unknown_ __ebp;
    signed int _t65;
    _unknown_ _t77;
    _unknown_ _t79;
    _unknown_ _t82;

    _v8 = 0;
    _v12 = 0;
L13:
    while(( *str & 255 & 4294967295) != 0) {
        if(( *str & 255 & 4294967295) != 9) {
            if(( *str & 255 & 4294967295) == 13 || ( *str & 255 & 4294967295) == 10) {
                if(_v8 > _v12) {
                    _v12 = _v8;
                }
                _v8 = 0;
                str =  &(str[1]);
            } else {
                if(( *135119023 & 255 & 4294967295) == 0) {
                    _t65 =  *( &WTF_WIDTH_MAP + ( *str & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                } else {
                    _t65 =  *( &WTF_WIDTH_MAP + ( *str & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                }
                _v8 = _v8 + _t65;
                str =  &(str[ *( &WTF_LEN_MAP + ( *str & 255 & 4294967295 & )) & 255 & 4294967295 & ]);
            }
            continue;
        } else {
            goto L2;
        }
        while(1) {
L2:
            _v8 = _v8 + 1;
            if((visible_length_offset + _v8) % Tabstop != 0) {
                continue;
            } else {
                str =  &(str[1]);
                goto L13;
            }
        }
    }
}

int maximum_visible_length(char* str, int offset)
{// addr = 0x08080F9E
    _unknown_ __ebp;

    visible_length_offset = offset;
    return visible_length(str);
}

int maximum_visible_length_plain(char* str, int offset)
{// addr = 0x08080FB9
    _unknown_ __ebp;

    visible_length_offset = offset;
    return visible_length_plain(str);
}

align(TextLine* lbuf, int width, int mode)
{// addr = 0x08080FD4
    int i;
    int l;
    int l1;
    int l2;
    Str buf;
    Str line;
    char _v16;
    unsigned int _v20;
    signed int _v24;
    intOrPtr _v28;
    struct _Str* _v32;
    struct _Str* _v36;
    _unknown_ _v56;
    _unknown_ __ebp;
    int _t157;
    int _t167;
    int _t186;
    int _t207;
    _unknown_ _t223;
    int _t237;

    _v36 = lbuf->line;
    if(_v36->length != 0) {
        _v32 = Strnew();
        asm("cwde ");
        _v20 = width - (lbuf->pos & 65535);
        _t157 = mode;
        if(_t157 == 1) {
            Strcat(_v32, _v36);
            _v16 = 0;
L25:
            while(_v16 < _v20) {
                goto L22;
            }
        }
        goto L8;
L22:
        if(_v32->length + 1 >= _v32->area_size) {
            Strgrow(_v32);
        }
        _t167 = _v32->length;
         *((char*)( *_v32 + _t167)) = 32;
        _v32->length = _t167 + 1;
         *((char*)( *_v32 + _v32->length)) = 0;
        _v16 = _v16 + 1;
        goto L25;
    }
    _v16 = 0;
    while(_v16 < width) {
        if(_v36->length + 1 >= _v36->area_size) {
            Strgrow(_v36);
        }
        _t237 = _v36->length;
         *((char*)( *_v36 + _t237)) = 32;
        _v36->length = _t237 + 1;
         *((char*)( *_v36 + _v36->length)) = 0;
        _v16 = _v16 + 1;
    }
L8:
    if(_t157 == 2) {
        _v16 = 0;
L31:
        while(_v16 < _v20) {
            goto L28;
        }
    }
    if(_t157 != 0) {
        return ;
    }
    _v24 = (_v20 >> 31) + _v20 >> 1;
    _v28 = _v20 - _v24;
    _v16 = 0;
    while(_v16 < _v24) {
        if(_v32->length + 1 >= _v32->area_size) {
            Strgrow(_v32);
        }
        _t207 = _v32->length;
         *((char*)( *_v32 + _t207)) = 32;
        _v32->length = _t207 + 1;
         *((char*)( *_v32 + _v32->length)) = 0;
        _v16 = _v16 + 1;
    }
L28:
    if(_v32->length + 1 >= _v32->area_size) {
        Strgrow(_v32);
    }
    _t186 = _v32->length;
     *((char*)( *_v32 + _t186)) = 32;
    _v32->length = _t186 + 1;
     *((char*)( *_v32 + _v32->length)) = 0;
    _v16 = _v16 + 1;
    goto L31;
}

print_item(struct table* t, int row, int col, int width, Str buf)
{// addr = 0x08081299
    int alignment;
    TextLine* lbuf;
    int _v16;
    TextLine* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(t->tabdata[row] == 0) {
        _v20 = 0;
    } else {
        _v20 = popValue(t->tabdata[row][col]);
    }
    if(_v20 == 0) {
        _v20 = newTextLine(0, 0);
        align(_v20, width, 0);
        Strcat(buf,  *_v20);
        return;
    } else {
        check_row(t, row);
        _v16 = 0;
        if(( *(t->tabattr[row] + col + col) & 65535 & 4294967295 &  & 48) != 0) {
            if(( *(t->tabattr[row] + col + col) & 65535 & 4294967295 &  & 48) != 32) {
                if(( *(t->tabattr[row] + col + col) & 65535 & 4294967295 &  & 48) == 16) {
                    _v16 = 0;
                }
            } else {
                _v16 = 2;
            }
        } else {
            _v16 = 1;
        }
        align(_v20, width, _v16);
        Strcat(buf,  *_v20);
        return;
    }
    return;
}

print_sep(struct table* t, int row, int type, int maxcol, Str buf)
{// addr = 0x08081401
    int forbid;
    int rule_mode;
    int i;
    int k;
    int l;
    int m;
    int w;
    signed int _v16;
    int _v20;
    signed int _v24;
    signed int _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    signed int _v40;
    int _v48;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    char _t240;
    char _t276;
    _unknown_ _t355;
    char _t362;
    int _t374;
    _unknown_ _t393;
    int _t416;
    _unknown_ _t432;
    _unknown_ _t433;
    int _t434;

    if(row < 0) {
        check_row(t, row);
    }
    check_row(t, row + 1);
    if(type == 0 || type == 2) {
        if(t->border_mode != 2) {
            goto L6;
        } else {
            _v20 = 2;
        }
L7:
        _v16 = 1;
        if(type != 0) {
            if(type != 2) {
                if(( *(t->tabattr[row + 1]) & 65535 & 4294967295 &  & 2) != 0) {
                    _v16 = _v16 | 4;
                }
            } else {
                _v16 = _v16 | 8;
            }
        } else {
            _v16 = _v16 | 2;
        }
        if(t->border_mode != 3) {
            _t434 = symbol_width;
            if(t->border_mode != 2) {
                _t362 = _v16 & 4294967295;
            } else {
                _t362 = _v16 + 16 & 4294967295;
            }
            push_symbol(buf, _t362, _t434, 1);
        }
        _v24 = 0;
        while(_v24 <= maxcol) {
            _v16 = 10;
            if(type == 2 || ( *(t->tabattr[row + 1] + _v24 + _v24) & 65535 & 4294967295 &  & 2) == 0) {
                _v40 = ( *(t + 8 + (_v24 + 40) * 2) & 65535 & 4294967295) + t->cellpadding + t->cellpadding;
                if(symbol_width == 2) {
                    _v48 = symbol_width;
                    _v40 = (_v40 + 1) / _v48;
                }
                _t374 = symbol_width;
                if(_v20 != 2) {
                    _t240 = _v16 & 4294967295;
                } else {
                    _t240 = _v16 + 16 & 4294967295;
                }
                push_symbol(buf, _t240, _t374, _v40);
L39:
                if(_v24 < maxcol) {
                    _v16 = 0;
                    if(type != 0) {
                        if(( *(t->tabattr[row] + _v24 + 1 + _v24 + 1) & 65535 & 4294967295 &  & 1 & 4294967295) != 0) {
                            _v16 = _v16 | 2;
                        }
                    } else {
                        _v16 = _v16 | 2;
                    }
                    if(type != 2) {
                        if(( *(t->tabattr[row + 1] + _v24 + 1 + _v24 + 1) & 65535 & 4294967295 &  & 1 & 4294967295) != 0) {
                            _v16 = _v16 | 8;
                        }
                        if(( *(t->tabattr[row + 1] + _v24 + 1 + _v24 + 1) & 65535 & 4294967295 &  & 2) != 0) {
                            _v16 = _v16 | 4;
                        }
                        if(( *(t->tabattr[row + 1] + _v24 + _v24) & 65535 & 4294967295 &  & 2) != 0) {
                            _v16 = _v16 | 1;
                        }
                    } else {
                        _v16 = _v16 | 8;
                    }
                    if(_v16 != 15) {
                        _t416 = symbol_width;
                        if(_v20 != 2) {
                            _t276 = _v16 & 4294967295;
                        } else {
                            _t276 = _v16 + 16 & 4294967295;
                        }
                        push_symbol(buf, _t276, _t416, 1);
                    }
                }
                _v24 = _v24 + 1;
                continue;
            }
            if(( *(t->tabattr[row + 1] + _v24 + _v24) & 65535 & 4294967295 &  & 1 & 4294967295) != 0) {
                goto L39;
            }
            _v28 = row;
            while(_v28 < 0 && t->tabattr[_v28] != 0 && ( *(t->tabattr[_v28] + _v24 + _v24) & 65535 & 4294967295 &  & 2) != 0) {
                _v28 = _v28 - 1;
            }
            goto L39;
        }
    }
L6:
    _v20 = 1;
    goto L7;
}

int get_spec_cell_width(struct table* tbl, int row, int col)
{// addr = 0x08081881
    int i;
    int w;
    intOrPtr _v16;
    signed int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    asm("cwde ");
    _v20 =  *(tbl + 8 + (col + 40) * 2) & 65535;
    _v16 = col + 1;
    while(tbl->maxcol >= _v16) {
        check_row(tbl, row);
        if(( *(tbl->tabattr[row] + _v16 + _v16) & 65535 & 4294967295 &  & 1 & 4294967295) == 0) {
            return _v20;
        }
        _v20 = _v20 + ( *(tbl + 8 + (_v16 + 40) * 2) & 65535 & 4294967295) + tbl->cellspacing;
        _v16 = _v16 + 1;
    }
}

do_refill(struct table* tbl, int row, int col, int maxlimit)
{// addr = 0x0808190E
    TextList* orgdata;
    TextListItem* l;
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment[19] envs;
    int colspan;
    int icell;
    int id;
    char* p;
    struct parsed_tag* tag;
    int alignment;
    TextLineListItem* ti;
    struct table* t;
    int limit;
    int rowspan;
    struct table_cell* cell;
    int k;
    struct _generallist _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    signed int _v48;
    char* _v52;
    struct parsed_tag* _v56;
    int _v60;
    struct _textlinelistitem* _v64;
    struct table* _v68;
    intOrPtr _v72;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    struct html_feed_environ _v132;
    struct environment _v452;
    _unknown_ _v728;
    struct readbuffer _v788;
    _unknown_ _v804;
    _unknown_ _v808;
    _unknown_ _v812;
    _unknown_ _v816;
    _unknown_ _v820;
    _unknown_ _v824;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t432;
    _unknown_ _t460;

    if(tbl->tabdata[row] == 0) {
        return ;
    }
    if(tbl->tabdata[row][col] == 0) {
        return ;
    }
    _v36.last = tbl->tabdata[row][col];
    tbl->tabdata[row][col] = newGeneralList();
    init_henv( &_v132,  &_v788,  &_v452, 20, tbl->tabdata[row][col], get_spec_cell_width(tbl, row, col), 0);
    _v788.flag = _v788.flag | 131072;
    if(_v116 > maxlimit) {
        _v132.limit = maxlimit;
    }
    if(tbl->border_mode != 0) {
        if(tbl->vcellpadding > 0) {
            do_blankline( &_v132,  &_v788, 0, 0, _v132.limit);
        }
    }
    _v36.first =  *(_v36.last);
    while(_v36.first != 0) {
        if(strncasecmp(_v36.first->ptr, "<table_alt", 10) != 0 || (_v36.first->ptr[0xa] & 255 & 4294967295) != 62 && ( *( &MYCTYPE_MAP + (_v36.first->ptr[0xa] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
            HTMLlineproc0( *(_v36.first),  &_v132, 1);
        } else {
            _v48 = -1;
            _v52 =  *((char**)(_v36.first));
            _v56 = parse_tag( &_v52, 1);
            if(_v56 != 0) {
                parsedtag_get_value(_v56, 64,  &_v48);
            }
            if(_v48 >= 0) {
                goto L32;
            }
            if((tbl->ntable & 65535 & 4294967295) > _v48) {
                _v68 = tbl->tables[_v48].ptr;
                _v72 = ( &(tbl->tables[_v48])->indent & 65535 & 4294967295) + _v68->total_width;
                tbl->tables[_v48].ptr = 0;
                save_fonteffect( &_v132, _v132.obuf);
                flushline( &_v132,  &_v788, 0, 2, _v132.limit);
                if(_v68->vspace > 0 && (_v776 & 8192) == 0) {
                    do_blankline( &_v132,  &_v788, 0, 0, _v132.limit);
                }
                if((_v132.obuf->flag & 112) != 32) {
                    if((_v132.obuf->flag & 112) != 64) {
                        _v60 = 1;
                    } else {
                        _v60 = 2;
                    }
                } else {
                    _v60 = 0;
                }
                if(_v60 == 1) {
                    appendGeneralList(_v132.buf,  &(tbl->tables[_v48])->buf);
                    if(_v112 < _v72) {
                        _v132.maxlimit = _v72;
                    }
                    restore_fonteffect( &_v132, _v132);
                    _v788.flag = _v788.flag;
                    _v132.blank_lines = 0;
                    if(_v68->vspace > 0) {
                        do_blankline( &_v132,  &_v788, 0, 0, _v132.limit);
                        _v788.flag = _v788.flag;
                    }
L35:
                    _v36.first =  *(_v36 + 4);
                    continue;
                } else {
                    _v64 =  &(tbl->tables[_v48])->buf->first;
                }
                while(_v64 != 0) {
                    align( *_v64, _v132.limit, _v60);
                    _v64 = _v64->next;
                }
            }
        }
        goto L35;
L32:
        goto L35;
    }
}

int table_rule_width(struct table* t)
{// addr = 0x08081FAE
    _unknown_ __ebp;
    _unknown_ _t6;

    if(t->border_mode != 0) {
        return symbol_width;
    }
    return 1;
}

check_cell_width(short int* tabwidth, short int* cellwidth, short int* col, short int* colspan, short int maxcell, short int* indexarray, int space, int dir)
{// addr = 0x08081FC9
    int i;
    int j;
    int k;
    int bcol;
    int ecol;
    int swidth;
    int width;
    int w;
    int r;
    signed int _v12;
    signed int _v16;
    intOrPtr _v20;
    signed int _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    signed int _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t144;
    _unknown_ _t159;
    _unknown_ _t161;
    _unknown_ _t170;
    _unknown_ _t171;
    _unknown_ _t174;

    _v60 = maxcell & 4294967295;
    _v20 = 0;
    while(_v60 >= _v20) {
        asm("cwde ");
        _v16 =  *(_v20 + _v20 + indexarray) & 65535;
        if(( *(_v16 + _v16 + cellwidth) & 65535 & 4294967295) <= 0) {
            goto L17;
        }
        asm("cwde ");
        _v24 =  *(_v16 + _v16 + col) & 65535;
        asm("cwde ");
        _v28 = ( *(_v16 + _v16 + colspan) & 65535) + _v24;
        _v32 = 0;
        _v12 = _v24;
        while(_v12 < _v28) {
            asm("cwde ");
            _v32 = _v32 + ( *(_v12 + _v12 + tabwidth) & 65535);
            _v12 = _v12 + 1;
        }
L17:
        _v20 = _v20 + 1;
    }
}

check_minimum_width(struct table* t, short int* tabwidth)
{// addr = 0x0808216A
    int i;
    struct table_cell* cell;
    intOrPtr _v20;
    struct table_cell* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ __ebx;
    _unknown_ __ebp;

    _v24 =  &(t->cell);
    _v20 = 0;
    while(t->maxcol >= _v20) {
        if(( *(_v20 + _v20 + tabwidth) & 65535 & 4294967295) < ( *(t + 12 + (_v20 + 88) * 2) & 65535 & 4294967295)) {
             *(_v20 + _v20 + tabwidth) =  *(t + 12 + (_v20 + 88) * 2) & 65535 & 4294967295;
        }
        _v20 = _v20 + 1;
    }
}

check_maximum_width(struct table* t)
{// addr = 0x08082228
    struct table_cell* cell;
    int i;
    int j;
    int bcol;
    int ecol;
    int swidth;
    int width;
    struct table_cell* _v8;
    signed int _v12;
    signed int _v16;
    signed int _v20;
    intOrPtr _v24;
    signed int _v28;
    _unknown_ _v32;
    _unknown_ __ebp;
    _unknown_ _t101;

    _v8 =  &(t->cell);
    _v8->necell = 0;
    _v16 = 0;
    while(1) {
        asm("cwde ");
        if((_v8->maxcell & 65535) < _v16) {
            break;
        }
        asm("cwde ");
        _v20 =  *(_v8 + _v16 * 2) & 65535;
        asm("cwde ");
        _v24 = ( *(_v8 + 8 + (_v16 + 16) * 2) & 65535) + _v20;
        _v28 = 0;
        _v12 = _v20;
        while(_v12 < _v24) {
            asm("cwde ");
            _v28 = _v28 + ( *(t + 8 + (_v12 + 40) * 2) & 65535);
            _v12 = _v12 + 1;
        }
    }
    return;
}

set_integered_width(struct table* t, double* dwidth, short int* iwidth)
{// addr = 0x0808232A
    int i;
    int j;
    int k;
    int n;
    int bcol;
    int ecol;
    int step;
    short int* indexarray;
    char* fixed;
    double* mod;
    double sum;
    double x;
    struct table_cell* cell;
    int rulewidth;
    int ii;
    int nn;
    char* idx;
    double nsum;
    int ii;
    int ii;
    int kk;
    int w;
    int width;
    int m;
    int ii;
    int ii;
    int ii;
    intOrPtr _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    signed int _v44;
    _unknown_ _v48;
    signed int _v52;
    struct table_cell* _v56;
    int _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ _v92;
    _unknown_ _v96;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ _v108;
    _unknown_ _v144;
    _unknown_ _v146;
    _unknown_ _v148;
    _unknown_ _v150;
    _unknown_ _v172;
    _unknown_ _v176;
    _unknown_ _v180;
    _unknown_ _v184;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int _t351;
    signed int _t355;
    _unknown_ _t362;
    _unknown_ _t368;
    _unknown_ _t373;
    _unknown_ _t389;
    _unknown_ _t394;
    _unknown_ _t409;
    _unknown_ _t441;
    _unknown_ _t541;
    _unknown_ _t577;
    _unknown_ _t609;

    asm("fldz ");
    asm("fstp qword [ebp-0x70]");
    asm("fldz ");
    asm("fstp qword [ebp-0x78]");
    _v56 =  &(t->cell);
    _v60 = table_rule_width(t);
    _t351 = t->maxcol + 1 + t->maxcol + 1;
     *__esp = _t351;
    GC_malloc_atomic();
    _v44 = _t351;
    _t355 = t->maxcol + 1 << 3;
     *__esp = _t355;
    GC_malloc_atomic();
    _v52 = _t355;
    _v16 = 0;
    while() {
    }
}

double correlation_coefficient(double sxx, double syy, double sxy)
{// addr = 0x08082A0A
    double coe;
    double tmp;
    double _v32;
    double _v36;
    intOrPtr _v40;
    double _v44;
    double _v48;
    intOrPtr _v52;
    _unknown_ __ebp;
    double _t24;
    signed int _t26;

    _v36 = sxx;
    _v32 = syy;
    _v44 = sxy;
    _v40 = _a16;
    _v52 = _a20;
    _t24 = _a24;
    _v48 = _t24;
    asm("fld qword [ebp-0x20]");
    asm("fmul qword [ebp-0x28]");
    asm("fstp qword [ebp-0x18]");
    asm("fld qword [0x80d56c0]");
    asm("fld qword [ebp-0x18]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    _t26 = _t24 & 4294967295;
    if(_t26 != 0) {
        asm("fld qword [0x80d56c0]");
        asm("fstp qword [ebp-0x18]");
    }
    asm("fld qword [ebp-0x18]");
    asm("fsqrt ");
    asm("fucomi st0, st0");
    if(_t26 != 0) {
        asm("fstp st0");
    } else {
        if(_t26 == 0) {
L7:
            asm("fld qword [ebp-0x30]");
            asm("fdivrp st1, st0");
            asm("fstp qword [ebp-0x10]");
            asm("fld qword [ebp-0x10]");
            asm("fld1 ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t24 & 4294967295) == 0) {
                asm("fld qword [ebp-0x10]");
                asm("fld1 ");
                asm("fchs ");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t24 & 4294967295) == 0) {
                    asm("fld qword [ebp-0x10]");
                    return _t24;
                }
                goto L10;
            }
            goto L8;
L10:
            asm("fld1 ");
            asm("fchs ");
            return _t24;
        }
        asm("fstp st0");
        goto L6;
L8:
        asm("fld1 ");
        return _t24;
    }
L6:
    asm("fld qword [ebp-0x18]");
    asm("fstp qword [esp]");
    sqrt();
    goto L7;
}

double correlation_coefficient2(double sxx, double syy, double sxy)
{// addr = 0x08082AB3
    double coe;
    double tmp;
    double _v32;
    double _v36;
    intOrPtr _v40;
    double _v44;
    double _v48;
    intOrPtr _v52;
    _unknown_ __ebp;
    double _t24;

    _v36 = sxx;
    _v32 = syy;
    _v44 = sxy;
    _v40 = _a16;
    _v52 = _a20;
    _t24 = _a24;
    _v48 = _t24;
    asm("fld qword [ebp-0x28]");
    asm("fadd qword [ebp-0x20]");
    asm("fld qword [ebp-0x30]");
    asm("fld qword [0x80cb5d8]");
    asm("fmulp st1, st0");
    asm("faddp st1, st0");
    asm("fmul qword [ebp-0x20]");
    asm("fstp qword [ebp-0x18]");
    asm("fld qword [0x80d56c0]");
    asm("fld qword [ebp-0x18]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t24 & 4294967295) != 0) {
        asm("fld qword [0x80d56c0]");
        asm("fstp qword [ebp-0x18]");
    }
    asm("fld qword [ebp-0x20]");
    asm("fsub qword [ebp-0x30]");
    asm("fstp qword [ebp-0x38]");
    asm("fld qword [ebp-0x18]");
    asm("fstp qword [esp]");
    sqrt();
    asm("fdivr qword [ebp-0x38]");
    asm("fstp qword [ebp-0x10]");
    asm("fld qword [ebp-0x10]");
    asm("fld1 ");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t24 & 4294967295) == 0) {
        asm("fld qword [ebp-0x10]");
        asm("fld1 ");
        asm("fchs ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t24 & 4294967295) == 0) {
            asm("fld qword [ebp-0x10]");
            return _t24;
        }
    } else {
        asm("fld1 ");
        return _t24;
    }
L5:
    asm("fld1 ");
    asm("fchs ");
    return _t24;
}

double recalc_width(double old, double swidth, int cwidth, double sxx, double syy, double sxy, int is_inclusive)
{// addr = 0x08082B62
    double delta;
    double rat;
    double coe;
    double w;
    double ww;
    double wmin;
    double coe1;
    double wmin;
    double _v80;
    double _v84;
    double _v88;
    int _v92;
    int _v96;
    double _v100;
    intOrPtr _v104;
    intOrPtr _v108;
    signed int _v112;
    intOrPtr _v116;
    _unknown_ __ebp;
    signed int _t56;

    _v84 = old;
    _v80 = swidth;
    _v92 = cwidth;
    _v88 = sxx;
    _v100 = sxy;
    _v96 = is_inclusive;
    _v108 = _a32;
    _v104 = _a36;
    _v116 = _a40;
    _t56 = _a44;
    _v112 = _t56;
    asm("fild dword [ebp+0x18]");
    asm("fld qword [ebp-0x58]");
    asm("fsubrp st1, st0");
    asm("fstp qword [ebp-0x10]");
    asm("fld qword [ebp-0x70]");
    asm("fdiv qword [ebp-0x60]");
    asm("fstp qword [ebp-0x18]");
    asm("fld qword [ebp-0x70]");
    asm("fstp qword [esp+0x10]");
    asm("fld qword [ebp-0x68]");
    asm("fstp qword [esp+0x8]");
    asm("fld qword [ebp-0x60]");
    asm("fstp qword [esp]");
    correlation_coefficient();
    asm("fstp qword [ebp-0x20]");
    asm("fld qword [ebp-0x50]");
    asm("fldz ");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t56 & 4294967295) != 0) {
        asm("fldz ");
        asm("fstp qword [ebp-0x50]");
    }
    asm("fld qword [ebp-0x20]");
    asm("fabs ");
    asm("fld qword [0x80cb5e0]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t56 & 4294967295) == 0) {
        asm("fld qword [ebp-0x18]");
        asm("fmul qword [ebp-0x50]");
        asm("fstp qword [ebp-0x28]");
        asm("fld qword [ebp-0x10]");
        asm("fstp qword [ebp-0x30]");
        asm("fld qword [ebp-0x28]");
        asm("fldz ");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t56 & 4294967295) == 0) {
            asm("fld qword [ebp-0x68]");
            asm("fstp qword [esp]");
            sqrt();
            asm("fld qword [0x80cb5e8]");
            asm("fmulp st1, st0");
            asm("fld qword [ebp-0x20]");
            asm("fabs ");
            asm("fmulp st1, st0");
            asm("fstp qword [ebp-0x48]");
            asm("fld qword [ebp-0x18]");
            asm("fld qword [0x80cb608]");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t56 & 4294967295) == 0) {
                asm("fld qword [ebp-0x48]");
                asm("fld qword [0x80cb610]");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t56 & 4294967295) != 0) {
                    asm("fld qword [0x80cb610]");
                    asm("fstp qword [ebp-0x48]");
                }
                asm("fld qword [ebp-0x30]");
                asm("fldz ");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t56 & 4294967295) != 0) {
                    asm("fldz ");
                    asm("fstp qword [ebp-0x30]");
                }
                asm("fld qword [ebp-0x30]");
                asm("fsub qword [ebp-0x48]");
                asm("fstp qword [ebp-0x30]");
L23:
                asm("fld qword [ebp-0x28]");
                asm("fld qword [ebp-0x30]");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t56 & 4294967295) == 0) {
                    asm("fld qword [ebp-0x50]");
                    return _t56;
                }
                asm("fld qword [ebp-0x30]");
                asm("fdiv qword [ebp-0x18]");
                return _t56;
            }
            goto L17;
        }
        goto L5;
L17:
        asm("fld qword [ebp-0x50]");
        return _t56;
    }
    asm("fld qword [ebp-0x50]");
    return _t56;
L5:
    asm("fld qword [ebp-0x20]");
    asm("fmul qword [ebp-0x20]");
    asm("fld1 ");
    asm("fsubrp st1, st0");
    asm("fmul qword [ebp-0x68]");
    asm("fstp qword [esp]");
    sqrt();
    asm("fld qword [0x80cb5e8]");
    asm("fmulp st1, st0");
    asm("fstp qword [ebp-0x38]");
    asm("fld qword [ebp-0x58]");
    asm("fld qword [0x80cb5f0]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t56 & 4294967295) == 0 || syy <= 0 || _a48 == 0) {
L11:
        asm("fld qword [ebp-0x38]");
        asm("fld qword [0x80cb600]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t56 & 4294967295) != 0) {
            asm("fld qword [0x80cb600]");
            asm("fstp qword [ebp-0x38]");
        }
        asm("fld qword [ebp-0x30]");
        asm("fldz ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t56 & 4294967295) != 0) {
            asm("fldz ");
            asm("fstp qword [ebp-0x30]");
        }
        asm("fld qword [ebp-0x30]");
        asm("fadd qword [ebp-0x38]");
        asm("fstp qword [ebp-0x30]");
        goto L23;
    }
    asm("fld qword [ebp-0x70]");
    asm("fstp qword [esp+0x10]");
    asm("fld qword [ebp-0x68]");
    asm("fstp qword [esp+0x8]");
    asm("fld qword [ebp-0x60]");
    asm("fstp qword [esp]");
    correlation_coefficient2();
    asm("fstp qword [ebp-0x40]");
    asm("fld qword [ebp-0x20]");
    asm("fld qword [0x80cb5f8]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t56 & 4294967295) != 0) {
L10:
        asm("fldz ");
        return _t56;
    }
    asm("fld qword [ebp-0x40]");
    asm("fld qword [0x80cb5f8]");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t56 & 4294967295) == 0) {
        goto L11;
    }
    goto L10;
}

int check_compressible_cell(struct table* t, MAT* minv, double* newwidth, double* swidth, short int* cwidth, double totalwidth, double* Sxx, int icol, int icell, double sxx, int corr)
{// addr = 0x08082D94
    struct table_cell* cell;
    int i;
    int j;
    int k;
    int m;
    int bcol;
    int ecol;
    int span;
    double delta;
    double owidth;
    double dmax;
    double dmin;
    double sxy;
    int rulewidth;
    int bcol1;
    int ecol1;
    int is_inclusive;
    int is_inclusive;
    int nwidth;
    struct table_cell* _v16;
    int _v20;
    signed int _v24;
    int _v28;
    signed int _v32;
    int _v36;
    intOrPtr _v40;
    intOrPtr _v44;
    signed int _v48;
    signed int _v52;
    intOrPtr _v56;
    int _v60;
    int _v64;
    int _v68;
    double* _v112;
    double _v116;
    intOrPtr _v120;
    int _v124;
    signed short _v126;
    signed int _v128;
    int _v132;
    signed int _v134;
    _unknown_ _v144;
    _unknown_ _v172;
    int _v176;
    intOrPtr _v180;
    int _v184;
    _unknown_ __ebp;
    signed int _t228;
    signed int _t233;
    signed int _t238;
    signed int _t241;
    _unknown_ _t250;
    _unknown_ _t264;
    _unknown_ _t268;
    _unknown_ _t269;
    _unknown_ _t270;
    _unknown_ _t273;
    _unknown_ _t280;
    _unknown_ _t290;
    _unknown_ _t294;
    _unknown_ _t295;
    _unknown_ _t296;
    _unknown_ _t298;
    _unknown_ _t302;
    _unknown_ _t303;
    _unknown_ _t307;
    _unknown_ _t311;
    _unknown_ _t312;
    _unknown_ _t317;
    _unknown_ _t320;
    _unknown_ _t332;
    _unknown_ _t335;
    _unknown_ _t353;
    _unknown_ _t356;
    _unknown_ _t358;
    _unknown_ _t359;
    _unknown_ _t364;
    _unknown_ _t366;
    _unknown_ _t371;
    _unknown_ _t375;

    _v116 = totalwidth;
    _v112 = Sxx;
    _v124 = corr;
    _v120 = _a48;
    _v16 =  &(t->cell);
    _t228 = table_rule_width(t);
    _v48 = _t228;
    asm("fld qword [ebp-0x78]");
    asm("fld qword [0x80cb618]");
    asm("fucomip st0, st1");
    asm("fstp st0");
    if((_t228 & 4294967295) != 0) {
        return _a52;
    }
    if(icell >= 0) {
        if(sxx >= 0) {
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [ebp-0x50]");
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [ebp-0x48]");
            _v36 = 0;
            _v40 = t->maxcol + 1;
        } else {
            asm("fld qword [eax]");
            asm("fstp qword [ebp-0x50]");
            asm("fld qword [eax]");
            _v134 =  *(sxx + sxx + cwidth) & 65535 & 4294967295;
            asm("fild word [ebp+0xffffff7e]");
            asm("fsubp st1, st0");
            asm("fstp qword [ebp-0x48]");
            asm("cwde ");
            _v36 =  *(_v16 + sxx * 2) & 65535;
            asm("cwde ");
            _v40 = ( *(_v16 + 8 + (sxx + 16) * 2) & 65535) + _v36;
        }
    } else {
        asm("fld qword [eax]");
        asm("fstp qword [ebp-0x50]");
        asm("fld qword [eax]");
        _v134 =  *(t + 8 + (icell + 40) * 2) & 65535 & 4294967295;
        asm("fild word [ebp+0xffffff7e]");
        asm("fsubp st1, st0");
        asm("fstp qword [ebp-0x48]");
        _v36 = icell;
        _v40 = _v36 + 1;
    }
    asm("fld qword [ebp-0x48]");
    asm("fstp qword [ebp-0x60]");
    asm("fld1 ");
    asm("fchs ");
    asm("fstp qword [ebp-0x58]");
    _v28 = 0;
    while(1) {
        _t233 = _v16->maxcell & 65535;
        asm("cwde ");
        if(_t233 < _v28) {
            break;
        }
        _v60 = 0;
        asm("fld qword [ebp-0x60]");
        asm("fldz ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t233 & 4294967295) != 0) {
L43:
            asm("fld qword [ebp-0x58]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t233 & 4294967295) != 0) {
                asm("fld qword [ebp-0x60]");
                asm("fld qword [ebp-0x58]");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t233 & 4294967295) != 0) {
                    asm("fld qword [ebp-0x58]");
                    asm("fstp qword [ebp-0x60]");
                }
            }
            _v44 = _v40 - _v36;
            _t238 = t->maxcol + 1;
            if(_t238 != _v44) {
L48:
                _t241 = t->maxcol + 1;
                if(_t241 == _v44) {
                    return _a52;
                }
                asm("fild dword [ebp-0x2c]");
                asm("fld qword [0x80cb5c8]");
                asm("fmulp st1, st0");
                asm("fld qword [ebp-0x60]");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_t241 & 4294967295) == 0) {
                    return _a52;
                }
L50:
                asm("fld qword [ebp-0x50]");
                asm("fsub qword [ebp-0x60]");
                asm("fld qword [0x80cb5c8]");
                asm("faddp st1, st0");
                asm("fstp qword [esp]");
                floor();
                asm("fnstcw word [ebp-0x7a]");
                _v128 = _v126 & 65535 & 4294967295;
                asm("fldcw word [ebp-0x7c]");
                asm("fistp dword [ebp-0x80]");
                asm("fldcw word [ebp-0x7a]");
                _v68 = ceil_at_intervals(_v132, _v48);
                asm("fld1 ");
                asm("fstp qword [esp+0x10]");
                _v176 = _v68;
                _v180 = _v40 - _v36;
                _v184 = _v36;
                 *__esp = t;
                correct_table_matrix();
                _a52 = _a52 + 1;
                return _a52;
            }
            asm("fld qword [ebp-0x60]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            asm("setnb al");
            if((_t238 & 4294967295) != 0) {
                goto L50;
            }
            goto L48;
            return _a52;
        }
        asm("cwde ");
        _v24 =  *(_v16 + (_v28 + 40) * 2) & 65535;
        if(_v24 == sxx) {
            goto L23;
        }
        asm("cwde ");
        _v52 =  *(_v16 + _v24 * 2) & 65535;
        asm("cwde ");
        _v56 = ( *(_v16 + 8 + (_v24 + 16) * 2) & 65535) + _v52;
        asm("fldz ");
        asm("fstp qword [ebp-0x68]");
        _v32 = _v52;
        while(_v32 < _v56) {
            _v20 = _v36;
            while(_v20 < _v40) {
                asm("fld qword [eax]");
                asm("fld qword [ebp-0x68]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x68]");
                _v20 = _v20 + 1;
            }
        }
L23:
        _v28 = _v28 + 1;
    }
    _v32 = 0;
    while(1) {
        _t233 = t->maxcol;
        if(_t233 < _v32) {
            break;
        }
        _v64 = 0;
        asm("fld qword [ebp-0x60]");
        asm("fldz ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t233 & 4294967295) != 0) {
            goto L43;
        }
        if(_v32 == icell) {
            goto L38;
        }
        asm("fldz ");
        asm("fstp qword [ebp-0x68]");
        _v20 = _v36;
        while(_v20 < _v40) {
            asm("fld qword [eax]");
            asm("fld qword [ebp-0x68]");
            asm("faddp st1, st0");
            asm("fstp qword [ebp-0x68]");
            _v20 = _v20 + 1;
        }
L38:
        _v32 = _v32 + 1;
    }
    goto L43;
}

int check_table_width(struct table* t, double* newwidth, MAT* minv, int itr)
{// addr = 0x080832E2
    int i;
    int j;
    int k;
    int m;
    int bcol;
    int ecol;
    int corr;
    struct table_cell* cell;
    short int orgwidth;
    short int corwidth;
    short int cwidth;
    double swidth;
    double twidth;
    double sxy;
    double* Sxx;
    double stotal;
    double sx;
    double w;
    int nwidth;
    int mwidth;
    double sx;
    double w;
    _unknown_ _v16;
    intOrPtr _v32;
    intOrPtr _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    intOrPtr _v60;
    struct table_cell* _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ _v76;
    intOrPtr _v80;
    signed int _v84;
    intOrPtr _v88;
    signed int _v92;
    intOrPtr _v96;
    signed int _v100;
    intOrPtr _v104;
    signed int _v108;
    struct table* _v176;
    double* _v180;
    MAT* _v184;
    _unknown_ _v186;
    _unknown_ _v188;
    _unknown_ _v192;
    signed int _v200;
    signed int _v204;
    signed int _v208;
    signed int _v212;
    signed int _v216;
    signed int _v220;
    signed int _v224;
    signed int _v228;
    signed int _v232;
    signed int _v236;
    signed int _v240;
    signed int _v244;
    signed int _v248;
    signed int _v252;
    signed int _v256;
    signed int _v260;
    signed int _v264;
    signed int _v268;
    signed int _v272;
    signed int _v276;
    signed int _v280;
    signed int _v284;
    signed int _v288;
    signed int _v292;
    signed int _v296;
    signed int _v300;
    signed int _v304;
    signed int _v308;
    signed int _v312;
    signed int _v316;
    char _v328;
    _unknown_ _v332;
    _unknown_ _v344;
    _unknown_ _v348;
    _unknown_ _v352;
    _unknown_ _v364;
    _unknown_ _v368;
    _unknown_ _v372;
    _unknown_ _v376;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t531;
    _unknown_ _t541;
    _unknown_ _t545;
    _unknown_ _t562;
    _unknown_ _t566;
    _unknown_ _t583;
    _unknown_ _t587;
    _unknown_ _t604;
    _unknown_ _t608;
    _unknown_ _t623;
    _unknown_ _t625;
    _unknown_ _t629;
    _unknown_ _t630;
    _unknown_ _t633;
    _unknown_ _t637;
    _unknown_ _t638;
    _unknown_ _t642;
    _unknown_ _t652;
    _unknown_ _t655;
    _unknown_ _t658;
    _unknown_ _t659;
    _unknown_ _t672;
    _unknown_ _t677;
    _unknown_ _t683;
    _unknown_ _t695;
    _unknown_ _t704;
    _unknown_ _t708;
    _unknown_ _t709;
    _unknown_ _t715;
    _unknown_ _t720;
    _unknown_ _t742;
    _unknown_ _t744;
    _unknown_ _t747;
    _unknown_ _t751;
    _unknown_ _t752;
    _unknown_ _t757;
    _unknown_ _t783;
    _unknown_ _t785;
    _unknown_ _t790;
    _unknown_ _t794;
    _unknown_ _t795;
    _unknown_ _t801;
    _unknown_ _t820;
    _unknown_ _t822;
    signed int _t823;
    signed int _t824;
    signed int _t825;
    signed int _t826;
    _unknown_ _t827;
    _unknown_ _t832;
    _unknown_ _t845;
    _unknown_ _t849;
    _unknown_ _t850;
    _unknown_ _t852;
    _unknown_ _t853;
    _unknown_ _t855;
    _unknown_ _t856;
    _unknown_ _t858;
    _unknown_ _t859;
    _unknown_ _t861;
    _unknown_ _t862;
    _unknown_ _t864;
    _unknown_ _t865;
    _unknown_ _t867;
    _unknown_ _t868;
    _unknown_ _t870;
    _unknown_ _t871;
    _unknown_ _t873;
    _unknown_ _t874;
    _unknown_ _t875;
    _unknown_ _t881;
    _unknown_ _t882;
    _unknown_ _t886;
    _unknown_ _t888;
    _unknown_ _t892;
    _unknown_ _t893;
    _unknown_ _t898;
    _unknown_ _t914;
    _unknown_ _t916;
    _unknown_ _t917;
    _unknown_ _t923;
    _unknown_ _t928;
    _unknown_ _t930;
    _unknown_ _t934;
    _unknown_ _t935;
    _unknown_ _t936;
    _unknown_ _t940;
    _unknown_ _t944;
    _unknown_ _t948;
    _unknown_ _t952;
    _unknown_ _t956;
    _unknown_ _t960;
    _unknown_ _t964;
    _unknown_ _t968;
    _unknown_ _t974;

    __esp = __esp - 364;
    _v176 = t;
    _v180 = newwidth;
    _v184 = minv;
    _v32 =  *gs:0x14];
    __edi = __esp;
    _v60 = 0;
    _v64 =  &(_v176->cell);
    _t823 = _v176->maxcol + 1;
    _v80 = _t823 - 1;
    asm("shld edx, eax, 0x4");
    _v204 = _t823 << 4;
    _v200 = 0;
    _v212 = _t823;
    _v208 = 0;
    asm("shld edx, eax, 0x4");
    _v220 = _v212 << 4;
    _v216 = _v208 & 15;
    __esp = __esp - (_t823 + _t823 + 15 + 15 >> 4 << 4);
    _v84 =  &_v328 + 15 >> 4 << 4;
    _t824 = _v176->maxcol + 1;
    _v88 = _t824 - 1;
    _v228 = _t824;
    _v224 = 0;
    asm("shld edx, eax, 0x4");
    _v236 = _v228 << 4;
    _v232 = _v224 & 15;
    _v244 = _t824;
    _v240 = 0;
    asm("shld edx, eax, 0x4");
    _v252 = _v244 << 4;
    _v248 = _v240 & 15;
    __esp = __esp - (_t824 + _t824 + 15 + 15 >> 4 << 4);
    _v92 =  &_v328 + 15 >> 4 << 4;
    asm("cwde ");
    _t825 = (_v64->maxcell & 65535) + 1;
    _v96 = _t825 - 1;
    _v260 = _t825;
    _v256 = 0;
    asm("shld edx, eax, 0x4");
    _v268 = _v260 << 4;
    _v264 = _v256 & 15;
    _v276 = _t825;
    _v272 = 0;
    asm("shld edx, eax, 0x4");
    _v284 = _v276 << 4;
    _v280 = _v272 & 15;
    __esp = __esp - (_t825 + _t825 + 15 + 15 >> 4 << 4);
    _v100 =  &_v328 + 15 >> 4 << 4;
    asm("cwde ");
    _t826 = (_v64->maxcell & 65535) + 1;
    _v104 = _t826 - 1;
    _v292 = _t826;
    _v288 = 0;
    asm("shld edx, eax, 0x6");
    _v300 = _v292 << 6;
    _v296 = _v288 & 15;
    _v308 = _t826;
    _v304 = 0;
    asm("shld edx, eax, 0x6");
    _v316 = _v308 << 6;
    _v312 = _v304 & 15;
    __esp = __esp - ((_t826 << 3) + 15 + 15 >> 4 << 4);
    _v108 =  &_v328 + 15 >> 4 << 4;
    asm("fldz ");
    asm("fstp qword [ebp-0x70]");
    asm("fldz ");
    asm("fstp qword [ebp-0x80]");
    _v36 = 0;
    while() {
    }
}

check_table_height(struct table* t)
{// addr = 0x08083EF8
    int i;
    int j;
    int k;
    struct  cell;
    int space;
    int t_dep;
    int rowspan;
    int c;
    int ii;
    int idx;
    int _v32;
    signed int _v36;
    int _v40;
    signed int _v44;
    signed int _v48;
    short int _v52;
    signed int _v56;
    signed int _v60;
    signed int _v64;
    short int* _v68;
    signed int _v70;
    signed int _v72;
    short int* _v76;
    short int* _v80;
    short int* _v84;
    int _v96;
    _unknown_ _v100;
    _unknown_ _v112;
    _unknown_ _v128;
    _unknown_ _v132;
    _unknown_ _v136;
    _unknown_ _v140;
    _unknown_ _v144;
    _unknown_ _v148;
    intOrPtr _v152;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    short int* _t278;
    short int* _t280;
    short int* _t282;
    short int* _t284;
    short int* _t289;
    short int* _t291;
    short int* _t293;
    short int* _t295;
    _unknown_ _t307;
    _unknown_ _t368;

    _v44 = 0;
    _v70 = 0;
    _v72 = 65535;
    _v36 = 0;
    while(t->maxrow >= _v36) {
        if(t->tabattr[_v36] != 0) {
            _v32 = 0;
            while(t->maxcol >= _v32) {
                if(( *(t->tabattr[_v36] + _v32 + _v32) & 65535 & 4294967295 &  & 3) != 0) {
                    goto L30;
                } else {
                    if(t->tabdata[_v36][_v32] != 0) {
                        asm("cwde ");
                        _v48 = t->tabdata[_v36][_v32]->nitem & 65535;
                    } else {
                        _v48 = 0;
                    }
                    _v52 = table_rowspan(t, _v36, _v32);
                    if(_v52 <= 1) {
                        asm("cwde ");
                        if(( *(t->tabheight + _v36 + _v36) & 65535) < _v48) {
                             *(t->tabheight + _v36 + _v36) = _v48 & 4294967295;
                        }
                        goto L30;
                    } else {
                        asm("cwde ");
                        _v56 = (_v72 & 65535) + 1;
                        _v96 = t->maxrow + 1;
                        asm("cwde ");
                        _v40 = bsearch_2short(_v52, _v80, _v36 & 4294967295, _v84, _v96, _v76, _v56);
                        asm("cwde ");
                        if((_v72 & 65535) >= _v40) {
                            asm("cwde ");
                            _v60 =  *(_v76 + _v40 + _v40) & 65535;
                            asm("cwde ");
                            if(( *(_v84 + _v60 + _v60) & 65535) == _v36) {
                                asm("cwde ");
                                if(( *(_v80 + _v60 + _v60) & 65535) == _v52) {
                                    _v56 = _v60;
                                }
                            }
                        }
                        if(_v56 > 999) {
                            goto L28;
                        }
                        asm("cwde ");
                        if((_v70 & 65535) <= _v56) {
                            if((_v70 & 65535 & 4294967295) != 0) {
                                _t363 = _v56 + 1;
                                asm("cwde ");
                                _t275 = (_v70 & 65535) + 20;
                                _t276 = _v56 + 1 - (_v70 & 65535) + 20 >= 0 ? _t363 : _t275;
                                _v70 = (_v56 + 1 - (_v70 & 65535) + 20 >= 0 ? _t363 : _t275) & 4294967295;
                                asm("cwde ");
                                _t278 = _v84;
                                _v152 = (_v70 & 65535) + (_v70 & 65535);
                                 *__esp = _t278;
                                GC_realloc();
                                _v84 = _t278;
                                asm("cwde ");
                                _t280 = _v80;
                                _v152 = (_v70 & 65535) + (_v70 & 65535);
                                 *__esp = _t280;
                                GC_realloc();
                                _v80 = _t280;
                                asm("cwde ");
                                _t282 = _v76;
                                _v152 = (_v70 & 65535) + (_v70 & 65535);
                                 *__esp = _t282;
                                GC_realloc();
                                _v76 = _t282;
                                asm("cwde ");
                                _t284 = _v68;
                                _v152 = (_v70 & 65535) + (_v70 & 65535);
                                 *__esp = _t284;
                                GC_realloc();
                                _v68 = _t284;
                            } else {
                                _t286 = _v56 + 1;
                                _t287 = _v56 + 1 - 20 < 0 ? 20 : _t286;
                                _v70 = (_v56 + 1 - 20 < 0 ? 20 : _t286) & 4294967295;
                                asm("cwde ");
                                _t289 = (_v70 & 65535) + (_v70 & 65535);
                                 *__esp = _t289;
                                GC_malloc_atomic();
                                _v84 = _t289;
                                asm("cwde ");
                                _t291 = (_v70 & 65535) + (_v70 & 65535);
                                 *__esp = _t291;
                                GC_malloc_atomic();
                                _v80 = _t291;
                                asm("cwde ");
                                _t293 = (_v70 & 65535) + (_v70 & 65535);
                                 *__esp = _t293;
                                GC_malloc_atomic();
                                _v76 = _t293;
                                asm("cwde ");
                                _t295 = (_v70 & 65535) + (_v70 & 65535);
                                 *__esp = _t295;
                                GC_malloc_atomic();
                                _v68 = _t295;
                            }
                        }
                        asm("cwde ");
                        if((_v72 & 65535) >= _v56) {
L23:
                            asm("cwde ");
                            if(( *(_v68 + _v56 + _v56) & 65535) < _v48) {
                                 *(_v68 + _v56 + _v56) = _v48 & 4294967295;
                            }
L30:
                            _v32 = _v32 + 1;
                            continue;
                        } else {
                            _v72 = (_v72 & 65535) + 1 & 4294967295;
                             *(_v84 + (_v72 & 65535 & 4294967295) + (_v72 & 65535 & 4294967295)) = _v36 & 4294967295;
                             *(_v80 + (_v72 & 65535 & 4294967295) + (_v72 & 65535 & 4294967295)) = _v52 & 4294967295;
                             *(_v68 + (_v72 & 65535 & 4294967295) + (_v72 & 65535 & 4294967295)) = 0;
                            asm("cwde ");
                            if((_v72 & 65535) <= _v40) {
                                 *(_v76 + _v40 + _v40) = _v72 & 65535 & 4294967295;
                                goto L23;
                            }
                            asm("cwde ");
                            _v64 = _v72 & 65535;
                            while(_v64 > _v40) {
                                 *(_v76 + _v64 + _v64) =  *(_v76 + _v64 - 1 + _v64 - 1) & 65535 & 4294967295;
                                _v64 = _v64 - 1;
                            }
                            goto L23;
                        }
                    }
                }
L28:
                goto L30;
            }
        }
        _v36 = _v36 + 1;
    }
}

int get_table_width(struct table* t, short int* orgwidth, short int* cellwidth, int flag)
{// addr = 0x08084329
    short int newwidth;
    int i;
    int swidth;
    struct table_cell* cell;
    int rulewidth;
    short int ccellwidth;
    _unknown_ _v16;
    intOrPtr _v32;
    signed int _v36;
    _unknown_ _v40;
    struct table_cell* _v44;
    int _v48;
    intOrPtr _v52;
    signed int _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    struct table* _v80;
    short int* _v84;
    short int* _v88;
    intOrPtr _v92;
    _unknown_ _v96;
    _unknown_ _v100;
    signed int _v104;
    signed int _v108;
    signed int _v112;
    signed int _v116;
    signed int _v120;
    signed int _v124;
    _unknown_ _v128;
    _unknown_ _v132;
    _unknown_ _v136;
    _unknown_ _v140;
    _unknown_ _v144;
    _unknown_ _v148;
    _unknown_ _v152;
    char _v156;
    _unknown_ _v160;
    _unknown_ _v164;
    _unknown_ _v168;
    _unknown_ _v172;
    _unknown_ _v176;
    _unknown_ _v180;
    _unknown_ _v184;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t218;
    _unknown_ _t226;
    _unknown_ _t230;
    _unknown_ _t270;
    _unknown_ _t280;
    _unknown_ _t284;
    _unknown_ _t320;
    _unknown_ _t324;
    _unknown_ _t330;
    _unknown_ _t336;
    _unknown_ _t349;
    _unknown_ _t350;
    _unknown_ _t363;
    _unknown_ _t365;
    _unknown_ _t366;
    _unknown_ _t368;
    _unknown_ _t369;
    _unknown_ _t374;
    _unknown_ _t376;
    _unknown_ _t377;
    _unknown_ _t379;
    signed int _t391;
    _unknown_ _t399;

    __esp = __esp - 172;
    _v80 = t;
    _v84 = orgwidth;
    _v88 = cellwidth;
    _v32 =  *gs:0x14];
    _v92 = __esp;
    _t391 = _v80->maxcol.col + 1;
    _v52 = _t391 - 1;
    asm("shld edx, eax, 0x4");
    _v108 = _t391 << 4;
    _v104 = 0;
    _v116 = _t391;
    _v112 = 0;
    asm("shld edx, eax, 0x4");
    _v124 = _v116 << 4;
    _v120 = _v112 & 15;
    __esp = __esp - (_t391 + _t391 + 15 + 15 >> 4 << 4);
    _v56 =  &_v156 + 15 >> 4 << 4;
    _v44 =  &(_v80->cell);
    _v48 = table_rule_width(_v80);
    _v36 = 0;
    while(_v80->maxcol >= _v36) {
        _t250 =  *(_v36 + _v36 + _v84) & 65535;
        _t370 = ( *(_v36 + _v36 + _v84) & 65535 & 4294967295) >= 0 ? _t250 : 0;
         *(_v56 + _v36 * 2) = (( *(_v36 + _v36 + _v84) & 65535 & 4294967295) >= 0 ? _t250 : 0) & 4294967295;
        _v36 = _v36 + 1;
    }
}

renderCoTable(struct table* tbl, int maxlimit)
{// addr = 0x08084705
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment[19] envs;
    struct table* t;
    int i;
    int col;
    int row;
    int indent;
    int maxwidth;
    struct table* _v16;
    signed int _v20;
    signed int _v24;
    int _v28;
    int _v32;
    int _v36;
    struct html_feed_environ _v84;
    struct environment _v404;
    struct readbuffer _v740;
    _unknown_ _v756;
    _unknown_ _v760;
    _unknown_ _v764;
    _unknown_ _v768;
    _unknown_ _v772;
    _unknown_ _v776;
    _unknown_ __ebp;
    _unknown_ _t115;
    _unknown_ _t148;

    _v20 = 0;
    while(1) {
        asm("cwde ");
        if((tbl->ntable & 65535) <= _v20) {
            break;
        }
        _v16 = tbl->tables[_v20].ptr;
        asm("cwde ");
        _v24 =  &(tbl->tables[_v20])->col & 65535;
        asm("cwde ");
        _v28 =  &(tbl->tables[_v20])->row & 65535;
        asm("cwde ");
        _v32 =  &(tbl->tables[_v20])->indent & 65535;
        init_henv( &_v84,  &_v740,  &_v404, 20,  &(tbl->tables[_v20])->buf, get_spec_cell_width(tbl, _v28, _v24), _v32);
        check_row(tbl, _v28);
        if(_v68 > maxlimit) {
            _v84.limit = maxlimit;
        }
        if(_v16->total_width != 0) {
            if(_v16->total_width <= 0) {
                _v16->total_width = ( ~(_v16->total_width) * _v84.limit * 1374389535 >> 32 >> 5) - ( ~(_v16->total_width) * _v84.limit >> 31);
                _v36 = _v16->total_width;
            } else {
                _v36 = _v16->total_width;
            }
        } else {
            _v36 = _v84.limit - _v32;
        }
        renderTable(_v16, _v36,  &_v84);
        _v20 = _v20 + 1;
    }
    return;
}

make_caption(struct table* t, struct html_feed_environ* h_env)
{// addr = 0x0808488F
    struct html_feed_environ henv;
    struct readbuffer obuf;
    struct environment[19] envs;
    int limit;
    int _v16;
    struct html_feed_environ _v64;
    struct environment _v384;
    struct readbuffer _v720;
    _unknown_ _v740;
    _unknown_ _v744;
    _unknown_ _v748;
    _unknown_ _v752;
    _unknown_ _v756;
    _unknown_ _v760;
    _unknown_ __ebp;

    if(( *(t + 60))[1] <= 0) {
        return ;
    }
    if(t->total_width <= 0) {
        _v16 = h_env->limit;
    } else {
        _v16 = t->total_width;
    }
    init_henv( &_v64,  &_v720,  &_v384, 20, newGeneralList(), _v16,  &(h_env->envs[h_env->envc])->indent & 255 & 4294967295);
    HTMLlineproc0("<center>",  &_v64, 1);
    HTMLlineproc0( *( *(t + 60)),  &_v64, 0);
    HTMLlineproc0("</center>",  &_v64, 1);
    if(t->total_width < _v44) {
        t->total_width = _v64.maxlimit;
    }
    _v16 = h_env->limit;
    h_env->limit = t->total_width;
    HTMLlineproc0("<center>", h_env, 1);
    HTMLlineproc0( *( *(t + 60)), h_env, 0);
    HTMLlineproc0("</center>", h_env, 1);
    h_env->limit = _v16;
    return;
}

renderTable(struct table* t, int max_width, struct html_feed_environ* h_env)
{// addr = 0x08084A06
    int i;
    int j;
    int w;
    int r;
    int h;
    Str renderbuf;
    short int[49] new_tabwidth;
    int itr;
    VEC* newwidth;
    MAT* mat;
    MAT* minv;
    PERM* pivot;
    int width;
    int rulewidth;
    Str vrulea;
    Str vruleb;
    Str vrulec;
    Str idtag;
    TextLineList* l;
    int k;
    signed int _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    int _v40;
    struct vector* _v44;
    struct matrix* _v48;
    MAT* _v52;
    int* _v56;
    _unknown_ _v60;
    int _v64;
    VEC* _v68;
    VEC* _v72;
    VEC* _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    short int _v188;
    _unknown_ _v204;
    _unknown_ _v208;
    _unknown_ _v212;
    _unknown_ _v216;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int _t756;
    _unknown_ _t775;
    _unknown_ _t778;
    _unknown_ _t783;
    _unknown_ _t787;
    _unknown_ _t946;
    _unknown_ _t957;
    _unknown_ _t1143;
    _unknown_ _t1153;
    _unknown_ _t1165;
    _unknown_ _t1177;
    _unknown_ _t1188;
    _unknown_ _t1198;
    _unknown_ _t1351;
    _unknown_ _t1367;

    _v68 = 0;
    _v72 = 0;
    _v76 = 0;
    t->total_height = 0;
    if(t->maxcol < 0) {
        make_caption(t, h_env);
        return;
    }
    if(t->sloppy_width > max_width) {
        max_width = t->sloppy_width;
    }
    _v64 = table_rule_width(t);
    max_width = max_width - table_border_width(t);
    if(_v64 > 1) {
        max_width = floor_at_intervals(max_width, _v64);
    }
    if(max_width < _v64) {
        max_width = _v64;
    }
    check_maximum_width(t);
    if(t->maxcol != 0) {
        set_table_matrix(t, max_width);
        _v40 = 0;
        _v48 = new_matrix(t->maxcol + 1);
        _t756 = t->maxcol + 1 << 2;
         *__esp = _t756;
        GC_malloc();
        _v56 = _t756;
        _v44 = new_vector(t->maxcol + 1);
        _v52 = new_matrix(t->maxcol + 1);
        while(1) {
L18:
            bcopy(t->matrix->me,  *_v48, 0 + t->matrix->dim * t->matrix->dim * 8);
            LUfactor(_v48, _v56);
            LUsolve(_v48, _v56, t->vector, _v44);
            LUinverse(_v48, _v56, _v52);
            _v40 = _v40 + 1;
            if(check_table_width(t,  *_v44, _v52, _v40) == 0) {
                break;
            }
        }
        set_integered_width(t,  *_v44,  &_v188);
        check_minimum_width(t,  &_v188);
        _v44 = 0;
        _v56 = 0;
        _v48 = 0;
        _v52 = 0;
        t->matrix = 0;
        t->vector = 0;
        _v16 = 0;
        while(t->maxcol >= _v16) {
             *(t + 8 + (_v16 + 40) * 2) =  *(__ebp + -184 + _v16 * 2) & 65535 & 4294967295;
            _v16 = _v16 + 1;
        }
    } else {
        asm("cwde ");
        if((t->tabwidth & 65535) > max_width) {
            t->tabwidth = max_width & 4294967295;
        }
        if(t->total_width <= 0) {
            if((t->fixed_width & 65535 & 4294967295) > 0) {
                t->tabwidth = t->fixed_width & 65535 & 4294967295;
            }
        } else {
            t->tabwidth = max_width & 4294967295;
        }
        if((t->tabwidth & 65535 & 4294967295) < (t->minimum_width & 65535 & 4294967295)) {
            t->tabwidth = t->minimum_width & 65535 & 4294967295;
        }
        check_minimum_width(t,  &(t->tabwidth));
        _v16 = 0;
        while(t->maxcol >= _v16) {
            asm("cwde ");
             *(t + 8 + (_v16 + 40) * 2) = ceil_at_intervals( *(t + 8 + (_v16 + 40) * 2) & 65535, _v64) & 4294967295;
            _v16 = _v16 + 1;
        }
    }
    goto L18;
}

struct table* begin_table(int border, int spacing, int padding, int vspace)
{// addr = 0x0808594A
    struct table* t;
    int mincell;
    int rcellspacing;
    int mincell_pixels;
    int ppc;
    struct table* _v16;
    int _v20;
    unsigned int _v24;
    intOrPtr _v28;
    signed int _v32;
    signed int _v46;
    signed int _v48;
    _unknown_ __ebp;
    int _t116;
    int _t124;
    _unknown_ _t173;
    _unknown_ _t174;

    _v20 = minimum_cellspacing(border);
    asm("fild dword [ebp-0x10]");
    asm("fld qword [0x80d53a0]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80cb5c8]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = _v46 & 65535 & 4294967295;
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x18]");
    asm("fldcw word [ebp-0x2a]");
    asm("fld qword [0x80d53a0]");
    asm("fld qword [0x80cb5c8]");
    asm("faddp st1, st0");
    asm("fstp qword [esp]");
    floor();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = _v46 & 65535 & 4294967295;
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x1c]");
    asm("fldcw word [ebp-0x2a]");
    _v16 = newTable();
    _v16->col = -1;
     *_v16 = _v16->col;
    _v16->maxcol = -1;
    _v16->maxrow = -1;
    _v16->border_mode = border;
    _v16->flag = 0;
    if(border == 3) {
        _v16->flag = _v16->flag | 2;
    }
    _v24 = padding + padding + spacing;
    _t116 = border;
    if(_t116 == 0) {
        _v16->cellpadding = _v24 - _v28;
    } else {
        if(_t116 < 0) {
            if(_t116 <= 3) {
                _v16->cellpadding = padding - ((_v28 - 4 >> 31) + _v28 - 4 >> 1);
            }
        }
    }
    if(_v16->cellpadding < _v32) {
        if(_v16->cellpadding <= 0) {
            _v16->cellpadding = 0;
        } else {
            _v16->cellpadding = 1;
        }
    } else {
        _v16->cellpadding = _v16->cellpadding / _v32;
    }
    _t124 = border;
    if(_t124 == 0) {
        _v16->cellspacing = _v16->cellpadding + _v20;
    } else {
        if(_t124 < 0 && _t124 <= 3) {
            _v16->cellspacing = _v16->cellpadding + _v16->cellpadding + _v20;
        }
    }
    if(border != 0) {
        if(vspace >= _v32) {
            _v16->vspace = 1;
        } else {
            _v16->vspace = 0;
        }
    } else {
        if(((_v24 >> 31) + _v24 >> 1) + vspace > 1) {
            _v16->vspace = 1;
        } else {
            _v16->vspace = 0;
        }
    }
    if(border != 0) {
L28:
        if(_v32 - 1 + _v32 - 1 <= padding) {
            _v16->vcellpadding = 1;
            return _v16;
        }
    } else {
        if(_v24 > 4) {
            _v16->vcellpadding = 1;
            return _v16;
        }
        _v16->vcellpadding = 0;
        return _v16;
        goto L28;
    }
L29:
    _v16->vcellpadding = 0;
    return _v16;
}

end_table(struct table* tbl)
{// addr = 0x08085B72
    struct table_cell* cell;
    int i;
    int rulewidth;
    struct table_cell* _v16;
    intOrPtr _v20;
    int _v24;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;

    _v16 =  &(tbl->cell);
    _v24 = table_rule_width(tbl);
    if(_v24 <= 1) {
        tbl->sloppy_width = get_table_width(tbl,  &(tbl->fixed_width),  &(tbl->cell.fixed_width), 1);
        if(tbl->total_width <= tbl->sloppy_width) {
            return ;
        }
        tbl->sloppy_width = tbl->total_width;
        return;
    }
    if(tbl->total_width > 0) {
        tbl->total_width = ceil_at_intervals(tbl->total_width, _v24);
    }
    _v20 = 0;
    while(tbl->maxcol >= _v20) {
        asm("cwde ");
         *(tbl + 12 + (_v20 + 88) * 2) = ceil_at_intervals( *(tbl + 12 + (_v20 + 88) * 2) & 65535, _v24) & 4294967295;
        asm("cwde ");
         *(tbl + 8 + (_v20 + 40) * 2) = ceil_at_intervals( *(tbl + 8 + (_v20 + 40) * 2) & 65535, _v24) & 4294967295;
        if(( *(tbl + (_v20 + 144) * 2) & 65535 & 4294967295) > 0) {
            asm("cwde ");
             *(tbl + (_v20 + 144) * 2) = ceil_at_intervals( *(tbl + (_v20 + 144) * 2) & 65535, _v24) & 4294967295;
        }
        _v20 = _v20 + 1;
    }
}

check_minimum0(struct table* t, int min)
{// addr = 0x08085D9E
    int i;
    int w;
    int ww;
    struct table_cell* cell;
    int _v16;
    int _v20;
    int _v24;
    struct table_cell* _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(t->col >= 0) {
        return ;
    }
    if(( *(t + 8 + (t->col + 40) * 2) & 65535 & 4294967295) >= 0) {
        return ;
    }
    check_row(t, t->row);
    _v20 = table_colspan(t, t->row, t->col);
    min = min + t->indent;
    if(_v20 != 1) {
        _v28 =  &(t->cell);
        _v24 = 0;
        if((_v28->icell & 65535 & 4294967295) < 0) {
            asm("cwde ");
            if(( *(_v28 + 14 + ((_v28->icell & 65535 & 4294967295) + 96) * 2) & 65535) < min) {
                 *(_v28 + 14 + ((_v28->icell & 65535 & 4294967295) + 96) * 2) = min & 4294967295;
            }
        }
    } else {
        _v24 = min;
    }
    _v16 = t->col;
    while(t->maxcol >= _v16) {
    }
}

int setwidth0(struct table* t, struct table_mode* mode)
{// addr = 0x08085EE6
    int w;
    int width;
    struct table_cell* cell;
    int _v16;
    signed int _v20;
    struct table_cell* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t109;
    _unknown_ _t110;

    _v20 = t->tabcontentssize;
    _v24 =  &(t->cell);
    if(t->col < 0) {
        return -1;
    }
    if(( *(t + 8 + (t->col + 40) * 2) & 65535 & 4294967295) < 0) {
        return -1;
    }
    check_row(t, t->row);
    if((t->linfo.prev_spaces & 255 & 4294967295) > 0) {
        _v20 = _v20 - (t->linfo.prev_spaces & 255 & 4294967295);
    }
    _v16 = table_colspan(t, t->row, t->col);
    if(_v16 != 1) {
        if((_v24->icell & 65535 & 4294967295) >= 0) {
            return _v20;
        }
        asm("cwde ");
        if(( *(_v24 + 6 + ((_v24->icell & 65535 & 4294967295) + 80) * 2) & 65535) >= _v20) {
            return _v20;
        }
         *(_v24 + 6 + ((_v24->icell & 65535 & 4294967295) + 80) * 2) = _v20 & 4294967295;
        return _v20;
    }
    asm("cwde ");
    if(( *(t + 8 + (t->col + 40) * 2) & 65535) >= _v20) {
        return _v20;
    }
     *(t + 8 + (t->col + 40) * 2) = _v20 & 4294967295;
    return _v20;
}

setwidth(struct table* t, struct table_mode* mode)
{// addr = 0x08086002
    int width;
    int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = setwidth0(t, mode);
    if(_v16 >= 0) {
        return ;
    }
    if(( *(t->tabattr[t->row] + t->col + t->col) & 65535 & 4294967295 &  & 4) != 0) {
        check_minimum0(t, _v16);
    }
    if((mode->pre_mode & 641) == 0) {
        return ;
    }
    if((mode->nobr_offset & 65535 & 4294967295) >= 0) {
        return ;
    }
    asm("cwde ");
    check_minimum0(t, _v16 - (mode->nobr_offset & 65535));
    return;
}

addcontentssize(struct table* t, int width)
{// addr = 0x0808609F
    _unknown_ _v24;
    _unknown_ __ebp;

    if(t->col >= 0) {
        return ;
    }
    if(( *(t + 8 + (t->col + 40) * 2) & 65535 & 4294967295) >= 0) {
        return ;
    }
    check_row(t, t->row);
    t->tabcontentssize = t->tabcontentssize + width;
    return;
}

clearcontentssize(struct table* t, struct table_mode* mode)
{// addr = 0x080860F2
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    table_close_anchor0(t, mode);
    mode->nobr_offset = 0;
    t->linfo.prev_spaces = 255;
    Strcopy_charp_n(t->linfo, " ", 1);
    t->linfo = 0;
    t->linfo.length = 0;
    t->tabcontentssize = 0;
    return;
}

begin_cell(struct table* t, struct table_mode* mode)
{// addr = 0x08086162
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t82;

    clearcontentssize(t, mode);
    mode->indent_level = 0;
    mode->nobr_level = 0;
    mode->pre_mode = 0;
    t->indent = 0;
    t->flag = t->flag | 4;
    if(t->suspended_data == 0) {
        return ;
    }
    check_row(t, t->row);
    if(t->tabdata[t->row][t->col] == 0) {
        t->tabdata[t->row][t->col] = newGeneralList();
    }
    appendGeneralList(t->tabdata[t->row][t->col], t->suspended_data);
    t->suspended_data = 0;
    return;
}

check_rowcol(struct table* tbl, struct table_mode* mode)
{// addr = 0x08086268
    int row;
    int col;
    int _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = tbl->row;
    _v20 = tbl->col;
    if((tbl->flag & 1) == 0) {
        tbl->col = -1;
    }
    if(tbl->row == 255) {
        tbl->row = 0;
    }
    if(tbl->col == 255) {
        tbl->col = 0;
    }
    while(1) {
        check_row(tbl, tbl->row);
        goto L10;
    }
}

int skip_space(struct table* t, char* line, struct table_linfo* linfo, int checkminimum)
{// addr = 0x080863EA
    int skip;
    int s;
    Lineprop ctype;
    Lineprop prev_ctype;
    Str prevchar;
    int w;
    int min;
    char* save;
    char* c;
    int ec;
    int len;
    int wlen;
    int plen;
    _unknown_ _v14;
    signed int _v16;
    intOrPtr _v20;
    signed int _v24;
    intOrPtr _v28;
    signed int _v32;
    intOrPtr _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t178;
    _unknown_ _t254;

    _v20 = 0;
    _v24 = linfo->prev_spaces & 255 & 4294967295;
    _v16 = linfo->prev_ctype & 65535 & 4294967295;
    _v28 =  *((intOrPtr*)(linfo + 4));
    asm("cwde ");
    _v32 = linfo->length & 65535;
    _v36 = 1;
    if(( *line & 255 & 4294967295) == 60) {
        if((line[strlen(line) - 1] & 255 & 4294967295) == 62) {
            if(checkminimum == 0) {
                return 0;
            } else {
                check_minimum0(t, visible_length(line));
                return 0;
            }
        }
    }
    while(( *line & 255 & 4294967295) != 0) {
    }
}

feed_table_inline_tag(struct table* tbl, char* line, struct table_mode* mode, int width)
{// addr = 0x080866C5
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    check_rowcol(tbl, mode);
    pushdata(tbl, tbl->row, tbl->col, line);
    if(width >= 0) {
        return ;
    }
    check_minimum0(tbl, width);
    addcontentssize(tbl, width);
    setwidth(tbl, mode);
    return;
}

feed_table_block_tag(struct table* tbl, char* line, struct table_mode* mode, int indent, int cmd)
{// addr = 0x08086740
    int offset;
    int _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if((mode->indent_level & 255 & 4294967295) <= 0) {
        if(indent == 255) {
            return ;
        }
    }
    setwidth(tbl, mode);
    feed_table_inline_tag(tbl, line, mode, -1);
    clearcontentssize(tbl, mode);
    if(indent != 1) {
        if(indent == 255) {
            mode->indent_level = (mode->indent_level & 255) - 1 & 4294967295;
            if((mode->indent_level & 255 & 4294967295) <= 9) {
                tbl->indent = tbl->indent - IndentIncr;
            }
        }
    } else {
        mode->indent_level = (mode->indent_level & 255) + 1 & 4294967295;
        if((mode->indent_level & 255 & 4294967295) <= 10) {
            tbl->indent = tbl->indent + IndentIncr;
        }
    }
    _v16 = tbl->indent;
    if(cmd == 19 && (mode->indent_level & 255 & 4294967295) > 0 && (mode->indent_level & 255 & 4294967295) <= 10) {
        _v16 = _v16 - IndentIncr;
    }
    if(tbl->indent <= 0) {
        return ;
    }
    check_minimum0(tbl, 0);
    addcontentssize(tbl, _v16);
    return;
}

table_close_select(struct table* tbl, struct table_mode* mode, int width)
{// addr = 0x0808686B
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t15;

    _v16 = process_n_select();
    mode->pre_mode = mode->pre_mode;
    mode->end_tag = 0;
    feed_table1(tbl, _v16, mode, width);
    return;
}

table_close_textarea(struct table* tbl, struct table_mode* mode, int width)
{// addr = 0x080868B1
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t15;

    _v16 = process_n_textarea();
    mode->pre_mode = mode->pre_mode;
    mode->end_tag = 0;
    feed_table1(tbl, _v16, mode, width);
    return;
}

table_close_anchor0(struct table* tbl, struct table_mode* mode)
{// addr = 0x080868F7
    _unknown_ _v24;
    _unknown_ __ebp;

    if((mode->pre_mode & 16777216) == 0) {
        return ;
    }
    mode->pre_mode = mode->pre_mode & -16777217;
    asm("cwde ");
    if(tbl->tabcontentssize != (mode->anchor_offset & 65535)) {
        if((tbl->linfo.prev_spaces & 255 & 4294967295) <= 0) {
            return ;
        }
        asm("cwde ");
        if(tbl->tabcontentssize - 1 != (mode->anchor_offset & 65535)) {
            return ;
        }
        if((tbl->linfo.prev_spaces & 255 & 4294967295) <= 0) {
            return ;
        }
        tbl->linfo.prev_spaces = 255;
        return;
    }
    check_minimum0(tbl, 1);
    addcontentssize(tbl, 1);
    setwidth(tbl, mode);
    return;
}

int feed_table_tag(struct table* tbl, char* line, struct table_mode* mode, int width, struct parsed_tag* tag)
{// addr = 0x080869AD
    int cmd;
    char* p;
    struct table_cell* cell;
    int colspan;
    int rowspan;
    int col;
    int prev_col;
    int i;
    int j;
    int k;
    int v;
    int v0;
    int w;
    int id;
    Str tok;
    Str tmp;
    Str anchor;
    table_attr align;
    table_attr valign;
    int ii;
    Str tmp;
    struct table* tbl1;
    int _v36;
    struct table_cell* _v44;
    _unknown_ _v156;
    _unknown_ _v160;
    _unknown_ _v164;
    _unknown_ _v168;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t86;
    _unknown_ _t88;
    _unknown_ _t89;
    int _t90;
    _unknown_ _t91;
    _unknown_ _t95;
    _unknown_ _t96;
    _unknown_ _t99;
    _unknown_ _t100;
    _unknown_ _t104;
    _unknown_ _t109;
    _unknown_ _t113;
    _unknown_ _t118;
    _unknown_ _t121;
    _unknown_ _t122;
    _unknown_ _t126;
    _unknown_ _t135;

    _v44 =  &(tbl->cell);
    _v36 = tag->tagid & 255 & 4294967295 & ;
    if((mode->pre_mode & 8) != 0) {
        if((mode->end_tag & 255 & 4294967295 & ) != _v36) {
            return 4;
        }
        mode->pre_mode = mode->pre_mode & 247;
        mode->end_tag = 0;
        feed_table_block_tag(tbl, line, mode, 0, _v36);
        return 0;
    }
    if((mode->pre_mode & 2048) == 0) {
        if((mode->pre_mode & 2) == 0) {
            if((mode->pre_mode & 4) == 0) {
                if((mode->pre_mode & 4096) == 0) {
                    if((mode->caption & 255 & 4294967295) == 0) {
                        if((mode->pre_mode & 1 & 4294967295) != 0) {
                            _t90 = _v36;
                            if(_t90 >= 50) {
                                if(_t90 <= 51) {
                                    return 0;
                                }
                                if(_t90 + -128 <= 1) {
                                    return 0;
                                }
                            }
                        }
                        if(_v36 > 140) {
                            return 1;
                        }
                        goto __eax;
                    }
                    goto L21;
                }
                goto L17;
L21:
                if(_v36 - 31 > 59) {
                    return 1;
                }
                goto __eax;
            }
            goto L13;
L17:
            if(_v36 - 31 > 59) {
                return 1;
            }
            goto __eax;
        }
        goto L9;
L13:
        if((mode->end_tag & 255 & 4294967295 & ) != _v36) {
            return 4;
        }
        mode->pre_mode = mode->pre_mode & 251;
        mode->end_tag = 0;
        return 0;
    } else {
        if(_v36 - 31 > 59) {
            return 1;
        }
        goto __eax;
    }
L9:
    if((mode->end_tag & 255 & 4294967295 & ) != _v36) {
        return 4;
    }
    mode->pre_mode = mode->pre_mode & 253;
    mode->end_tag = 0;
    return 0;
}

int feed_table(struct table* tbl, char* line, struct table_mode* mode, int width, int internal)
{// addr = 0x0808822A
    int i;
    char* p;
    Str tmp;
    struct table_linfo* linfo;
    struct parsed_tag* tag;
    char* q;
    char* r;
    int ec;
    int nl;
    int _v16;
    char* _v20;
    struct _Str* _v24;
    struct table_linfo* _v28;
    struct parsed_tag* _v32;
    char* _v36;
    char* _v40;
    unsigned int _v44;
    char _v48;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    _unknown_ _t426;
    _unknown_ _t480;
    int _t503;
    int _t520;
    unsigned int _t536;
    int _t548;
    int _t568;
    int _t581;
    _unknown_ _t596;
    _unknown_ _t598;
    _unknown_ _t599;
    _unknown_ _t600;
    _unknown_ _t603;
    _unknown_ _t604;
    _unknown_ _t622;
    int _t628;
    _unknown_ _t629;
    _unknown_ _t630;
    _unknown_ _t636;

    _v28 =  &(tbl->linfo);
    if(( *line & 255 & 4294967295) != 60 || (line[1] & 255 & 4294967295) == 0 || ( *( &MYCTYPE_MAP + (line[1] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0 && (line[1] & 255 & 4294967295) != 47 && (line[1] & 255 & 4294967295) != 33 && (line[1] & 255 & 4294967295) != 63 && (line[1] & 255 & 4294967295) != 0 && (line[1] & 255 & 4294967295) != 95) {
        if((mode->pre_mode & 3145728) != 0) {
            return -1;
        }
L28:
        if((mode->caption & 255 & 4294967295) != 0) {
L29:
            Strcat_charp( *(tbl + 60), line);
            return -1;
        }
        if((mode->pre_mode & 2) != 0) {
            return -1;
        }
        if((mode->pre_mode & 4) != 0) {
            return -1;
        }
        if((mode->pre_mode & 2048) != 0) {
            feed_textarea(line);
            return -1;
        }
        if((mode->pre_mode & 4096) != 0) {
            feed_select(line);
            return -1;
        }
        if((mode->pre_mode & 8) != 0 || ( *line & 255 & 4294967295) == 60 && ( *(strlen(line) - 1 + line) & 255 & 4294967295) == 62) {
L78:
            if((mode->pre_mode & 527) != 0) {
                if((mode->pre_mode & 512) == 0) {
                    check_rowcol(tbl, mode);
L112:
                    while(( *line & 255 & 4294967295) != 0) {
                        goto L96;
                    }
                }
                goto L92;
L96:
                _v48 = 0;
                _v20 = strchr(line, 13);
                if(_v20 != 0) {
L98:
                    if(( *_v20 & 255 & 4294967295) == 13 && (_v20[1] & 255 & 4294967295) == 10) {
                        _v20 =  &(_v20[1]);
                    }
                    if((_v20[1] & 255 & 4294967295) == 0) {
                        _v20 = line;
                        line = 135049312;
                    } else {
                        _v20 =  &(_v20[1]);
                        _v24 = Strnew_charp_n(line, _v20 - line);
                        line = _v20;
                        _v20 =  *_v24;
                    }
                    _v48 = 1;
L106:
                    if((mode->pre_mode & 8) == 0) {
                        _v16 = maximum_visible_length(_v20, tbl->tabcontentssize);
                    } else {
                        _v16 = maximum_visible_length_plain(_v20, tbl->tabcontentssize);
                    }
                    addcontentssize(tbl, _v16);
                    setwidth(tbl, mode);
                    if(_v48 != 0) {
                        clearcontentssize(tbl, mode);
                    }
                    pushdata(tbl, tbl->row, tbl->col, _v20);
                    goto L112;
                }
                _v20 = strchr(line, 10);
                if(_v20 == 0) {
                    _v20 = line;
                    line = 135049312;
                    goto L106;
                }
                goto L98;
            }
            goto L79;
L92:
            check_rowcol(tbl, mode);
            if((mode->nobr_offset & 65535 & 4294967295) < 0) {
                mode->nobr_offset = tbl->tabcontentssize & 4294967295;
            }
            addcontentssize(tbl, maximum_visible_length(line, tbl->tabcontentssize));
            setwidth(tbl, mode);
            pushdata(tbl, tbl->row, tbl->col, line);
            return -1;
        } else {
            if(strchr(line, 38) == 0) {
                goto L78;
            } else {
                _v24 = Strnew();
                _v20 = line;
                while(( *_v20 & 255 & 4294967295) != 0) {
                    if(( *_v20 & 255 & 4294967295) != 38) {
                        if(_v24->length + 1 >= _v24->area_size) {
                            Strgrow(_v24);
                        }
                        _t503 = _v24->length;
                         *( *_v24 + _t503) =  *_v20 & 255 & 4294967295;
                        _v24->length = _t503 + 1;
                         *((char*)( *_v24 + _v24->length)) = 0;
                        _v20 =  &(_v20[1]);
                        continue;
                    }
                    if(strncasecmp(_v20, 135050668, 5) == 0 || strncasecmp(_v20, 135050674, 4) == 0 || strncasecmp(_v20, 135050679, 4) == 0) {
                        if(_v24->length + 1 >= _v24->area_size) {
                            Strgrow(_v24);
                        }
                        _t520 = _v24->length;
                         *( *_v24 + _t520) =  *_v20 & 255 & 4294967295;
                        _v24->length = _t520 + 1;
                         *((char*)( *_v24 + _v24->length)) = 0;
                        _v20 =  &(_v20[1]);
                        continue;
                    }
                    _v36 = _v20;
                    _v44 = getescapechar( &_v20);
                    _t536 = _v44;
                    if(_t536 == 38) {
                        Strcat_charp(_v24, 135050668);
                        continue;
                    }
                    if(_t536 > 38) {
                        if(_t536 == 60) {
                            Strcat_charp(_v24, 135050679);
                            continue;
                        }
                        goto L56;
L59:
                        Strcat_charp(_v24, 135050674);
                        continue;
                    }
                    if(_t536 == 255) {
L70:
                        if(_v24->length + 1 >= _v24->area_size) {
                            Strgrow(_v24);
                        }
                        _t548 = _v24->length;
                         *( *_v24 + _t548) =  *_v36 & 255 & 4294967295;
                        _v24->length = _t548 + 1;
                         *((char*)( *_v24 + _v24->length)) = 0;
                        _v20 =  &(_v36[1]);
                        continue;
                    }
                    if(_t536 == 13) {
                        goto L61;
                    }
L64:
                    _v40 = conv_entity(_v44);
                    if(_v40 == 0 || strlen(_v40) != 1 || ( *_v40 & 255 & 4294967295 & ) != _v44) {
                        goto L70;
                    } else {
                        if(_v24->length + 1 >= _v24->area_size) {
                            Strgrow(_v24);
                        }
                        _t568 = _v24->length;
                         *( *_v24 + _t568) =  *_v40 & 255 & 4294967295;
                        _v24->length = _t568 + 1;
                         *((char*)( *_v24 + _v24->length)) = 0;
                        continue;
                    }
L56:
                    if(_t536 == 62) {
                        goto L59;
                    }
                    goto L64;
L61:
                    if(_v24->length + 1 >= _v24->area_size) {
                        Strgrow(_v24);
                    }
                    _t581 = _v24->length;
                     *( *_v24 + _t581) = 10;
                    _v24->length = _t581 + 1;
                     *((char*)( *_v24 + _v24->length)) = 0;
                }
            }
        }
L79:
        if((tbl->flag & 4) == 0) {
            goto L84;
        }
        if((_v28->prev_spaces & 255 & 4294967295) == 0) {
            if(( *line & 255 & 4294967295) == 0) {
                return -1;
            }
            check_rowcol(tbl, mode);
            if((mode->pre_mode & 128) != 0 && (mode->nobr_offset & 65535 & 4294967295) < 0) {
                mode->nobr_offset = tbl->tabcontentssize & 4294967295;
            }
            _v16 = skip_space(tbl, line, _v28, mode->pre_mode & 128 & 4294967295 & );
            addcontentssize(tbl, visible_length(line) - _v16);
            setwidth(tbl, mode);
            pushdata(tbl, tbl->row, tbl->col, line);
            return -1;
        }
L84:
        while(( *( &MYCTYPE_MAP + ( *line & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            line =  &(line[1]);
        }
        goto L84;
    }
    _v20 = line;
    _v32 = parse_tag( &_v20, internal);
    if(_v32 == 0) {
        if((mode->pre_mode & 6158) == 0) {
            return -1;
        }
        goto L28;
    }
    _t628 = feed_table_tag(tbl, line, mode, width, _v32);
    if(_t628 == 2) {
        return 1;
    }
    if(_t628 > 2) {
        if(_t628 == 3) {
            return 0;
        }
        if(_t628 == 4) {
            goto L28;
        } else {
            goto L20;
        }
        goto L29;
    } else {
        if(_t628 == 0) {
            return -1;
        }
    }
L20:
    if((_v32->need_reconstruct & 255 & 4294967295) != 0) {
        line =  *(parsedtag2str(_v32));
    }
    goto L28;
}

feed_table1(struct table* tbl, Str tok, struct table_mode* mode, int width)
{// addr = 0x08088AE3
    Str tokbuf;
    int status;
    char* line;
    struct _Str* _v16;
    int _v20;
    char* _v24;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t22;
    _unknown_ _t36;

    if(tok == 0) {
        return ;
    }
    _v16 = Strnew();
    _v20 = 0;
    _v24 = tok->ptr;
    while(read_token(_v16,  &_v24,  &_v20, mode->pre_mode & 2575, 0) != 0) {
        feed_table(tbl,  *_v16, mode, width, 1);
    }
}

pushTable(struct table* tbl, struct table* tbl1)
{// addr = 0x08088B6A
    int col;
    int row;
    struct table_in* tmp;
    signed int _v16;
    int _v20;
    short int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    signed int _t164;
    _unknown_ _t172;

    _v16 = tbl->col;
    _v20 = tbl->row;
    if((tbl->ntable & 65535 & 4294967295) >= (tbl->tables_size & 65535 & 4294967295)) {
        tbl->tables_size = (tbl->tables_size & 65535) + 20 & 4294967295;
        asm("cwde ");
        _t164 = (tbl->tables_size & 65535) << 4;
         *__esp = _t164;
        GC_malloc();
        _v24 = _t164;
        if(tbl->tables != 0) {
            asm("cwde ");
            bcopy(tbl->tables, _v24, (tbl->ntable & 65535) << 4);
        }
        tbl->tables = _v24;
    }
    asm("cwde ");
     *(tbl->tables + ((tbl->ntable & 65535) << 4)) = tbl1;
    asm("cwde ");
    (tbl->tables + ((tbl->ntable & 65535) << 4))[1] = _v16 & 4294967295;
    asm("cwde ");
    (tbl->tables + ((tbl->ntable & 65535) << 4))[1] = _v20 & 4294967295;
    asm("cwde ");
    (tbl->tables + ((tbl->ntable & 65535) << 4))[2] = tbl->indent & 4294967295;
    asm("cwde ");
    (tbl->tables + ((tbl->ntable & 65535) << 4))[3] = newGeneralList();
    check_row(tbl, _v20);
    if(_v16 + 1 > tbl->maxcol || ( *( *((intOrPtr*)(tbl->tabattr + (_v20 << 2))) + _v16 + 1 + _v16 + 1) & 65535 & 4294967295 &  & 1 & 4294967295) == 0) {
        asm("cwde ");
        (tbl->tables + ((tbl->ntable & 65535) << 4))[2] = 65535;
    } else {
        asm("cwde ");
        (tbl->tables + ((tbl->ntable & 65535) << 4))[2] = tbl->cell.icell & 65535 & 4294967295;
    }
    tbl->ntable = (tbl->ntable & 65535) + 1 & 4294967295;
    return;
}

int correct_table_matrix(struct table* t, int col, int cspan, int a, double b)
{// addr = 0x08088D64
    int i;
    int j;
    int ecol;
    double w;
    int _v8;
    int _v12;
    intOrPtr _v16;
    intOrPtr _v40;
    double _v44;
    _unknown_ __ebp;
    _unknown_ _t65;
    _unknown_ _t67;
    _unknown_ _t68;
    _unknown_ _t71;
    _unknown_ _t74;
    _unknown_ _t76;
    _unknown_ _t77;
    _unknown_ _t82;
    _unknown_ _t84;
    _unknown_ _t85;
    _unknown_ _t89;
    _unknown_ _t90;
    _unknown_ _t91;
    _unknown_ _t93;
    _unknown_ _t94;
    _unknown_ _t99;
    _unknown_ _t101;
    _unknown_ _t102;
    _unknown_ _t106;
    _unknown_ _t107;
    _unknown_ _t111;
    _unknown_ _t112;
    _unknown_ _t115;
    _unknown_ _t116;
    _unknown_ _t118;
    _unknown_ _t120;

    _v44 = b;
    _v40 = _a24;
    _v16 = col + cspan;
    asm("fld qword [ebp-0x28]");
    asm("fmul qword [ebp-0x28]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fstp qword [ebp-0x18]");
    _v8 = col;
    while(_v8 < _v16) {
        asm("fld qword [eax]");
        asm("fild dword [ebp+0x14]");
        asm("fmul qword [ebp-0x18]");
        asm("faddp st1, st0");
        asm("fstp qword [edx]");
        _v12 = _v8;
        while(_v12 < _v16) {
            asm("fld qword [eax]");
            asm("fadd qword [ebp-0x18]");
            asm("fstp qword [edx]");
            asm("fld qword [eax]");
            asm("fstp qword [edx]");
            _v12 = _v12 + 1;
        }
    }
}

correct_table_matrix2(struct table* t, int col, int cspan, double s, double b)
{// addr = 0x08088E96
    int i;
    int j;
    int ecol;
    int size;
    double w;
    double ss;
    intOrPtr _v8;
    intOrPtr _v12;
    intOrPtr _v16;
    intOrPtr _v20;
    double _v40;
    double _v44;
    intOrPtr _v48;
    intOrPtr _v52;
    _unknown_ __ebp;
    _unknown_ _t73;
    _unknown_ _t75;
    _unknown_ _t76;
    _unknown_ _t77;
    _unknown_ _t78;
    _unknown_ _t81;
    _unknown_ _t83;
    _unknown_ _t84;
    _unknown_ _t86;
    _unknown_ _t88;
    _unknown_ _t89;
    _unknown_ _t96;
    _unknown_ _t97;

    _v44 = s;
    _v40 = b;
    _v52 = _a24;
    _v48 = _a28;
    _v16 = col + cspan;
    _v20 = t->maxcol + 1;
    asm("fld qword [ebp-0x30]");
    asm("fmul qword [ebp-0x30]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fstp qword [ebp-0x18]");
    _v8 = 0;
    while(_v8 < _v20) {
        while(_v12 < _v20) {
            if(_v8 < col || _v8 >= _v16) {
L7:
                if(_v8 < col || _v8 >= _v16) {
                    if(_v12 < col || _v12 >= _v16) {
                        asm("fld qword [ebp-0x28]");
                        asm("fmul qword [ebp-0x28]");
                        asm("fstp qword [ebp-0x20]");
                        goto L13;
                    }
                }
L11:
                asm("fld1 ");
                asm("fsub qword [ebp-0x28]");
                asm("fchs ");
                asm("fmul qword [ebp-0x28]");
                asm("fstp qword [ebp-0x20]");
                goto L13;
            } else {
                if(_v12 < col || _v12 >= _v16) {
                    goto L7;
                } else {
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fmulp st1, st0");
                    asm("fstp qword [ebp-0x20]");
L13:
                    asm("fld qword [eax]");
                    asm("fld qword [ebp-0x18]");
                    asm("fmul qword [ebp-0x20]");
                    asm("faddp st1, st0");
                    asm("fstp qword [edx]");
                    _v12 = _v12 + 1;
                    continue;
                }
                goto L8;
            }
        }
    }
}

correct_table_matrix3(struct table* t, int col, char* flags, double s, double b)
{// addr = 0x08088FCE
    int i;
    int j;
    double ss;
    int size;
    double w;
    int flg;
    intOrPtr _v8;
    intOrPtr _v12;
    intOrPtr _v16;
    signed int _v20;
    double _v40;
    double _v44;
    intOrPtr _v48;
    intOrPtr _v52;
    _unknown_ __ebp;
    _unknown_ _t90;
    _unknown_ _t92;
    _unknown_ _t93;
    _unknown_ _t98;
    _unknown_ _t100;
    _unknown_ _t101;
    _unknown_ _t105;
    _unknown_ _t106;
    _unknown_ _t116;

    _v44 = s;
    _v40 = b;
    _v52 = _a24;
    _v48 = _a28;
    _v16 = t->maxcol + 1;
    asm("fld qword [ebp-0x30]");
    asm("fmul qword [ebp-0x30]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fstp qword [ebp-0x20]");
    _v20 = flags[col] & 255 & 4294967295 & ;
    _v8 = 0;
    while(_v8 < _v16) {
        if(_v20 == 0 || ( *(_v8 + flags) & 255 & 4294967295) != 0) {
            if(_v20 != 0) {
                goto L25;
            }
            if(( *(_v8 + flags) & 255 & 4294967295) == 0) {
                goto L24;
            }
            goto L5;
L25:
            _v8 = _v8 + 1;
            continue;
L24:
            goto L25;
        }
L5:
        _v12 = _v8;
        while(_v12 < _v16) {
            if(_v20 == 0 || ( *(_v12 + flags) & 255 & 4294967295) != 0) {
                if(_v20 != 0) {
                    goto L20;
                }
            } else {
L10:
                if(_v8 != col || _v12 != col) {
                    if(_v8 == col || _v12 == col) {
                        asm("fld1 ");
                        asm("fsub qword [ebp-0x28]");
                        asm("fchs ");
                        asm("fmul qword [ebp-0x28]");
                        asm("fstp qword [ebp-0x18]");
                    } else {
                        asm("fld qword [ebp-0x28]");
                        asm("fmul qword [ebp-0x28]");
                        asm("fstp qword [ebp-0x18]");
                    }
                } else {
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fmulp st1, st0");
                    asm("fstp qword [ebp-0x18]");
                }
                asm("fld qword [eax]");
                asm("fld qword [ebp-0x20]");
                asm("fmul qword [ebp-0x18]");
                asm("faddp st1, st0");
                asm("fstp qword [edx]");
L20:
                _v12 = _v12 + 1;
                continue;
            }
L9:
            if(( *(_v12 + flags) & 255 & 4294967295) == 0) {
                goto L20;
            }
            goto L10;
        }
    }
}

correct_table_matrix4(struct table* t, int col, int cspan, char* flags, double s, double b)
{// addr = 0x08089156
    int i;
    int j;
    double ss;
    int ecol;
    int size;
    double w;
    intOrPtr _v8;
    intOrPtr _v12;
    intOrPtr _v16;
    intOrPtr _v20;
    double _v40;
    double _v44;
    intOrPtr _v48;
    intOrPtr _v52;
    _unknown_ __ebp;
    _unknown_ _t93;
    _unknown_ _t95;
    _unknown_ _t96;
    _unknown_ _t101;
    _unknown_ _t103;
    _unknown_ _t104;
    _unknown_ _t108;
    _unknown_ _t109;
    _unknown_ _t121;

    _v44 = s;
    _v40 = b;
    _v52 = _a28;
    _v48 = _a32;
    _v16 = col + cspan;
    _v20 = t->maxcol + 1;
    asm("fld qword [ebp-0x30]");
    asm("fmul qword [ebp-0x30]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fstp qword [ebp-0x20]");
    _v8 = 0;
    while(_v8 < _v20) {
        if(( *(_v8 + flags) & 255 & 4294967295) == 0) {
L4:
            _v12 = _v8;
L23:
            while(_v12 < _v20) {
                goto L5;
            }
        }
        if(_v8 < col) {
L27:
            _v8 = _v8 + 1;
            continue;
        }
        if(_v8 >= _v16) {
            goto L27;
        }
        goto L4;
L5:
        if(( *(_v12 + flags) & 255 & 4294967295) == 0) {
L8:
            if(_v8 < col || _v8 >= _v16 || _v12 < col) {
L13:
                if(_v8 < col || _v8 >= _v16) {
                    if(_v12 < col || _v12 >= _v16) {
                        asm("fld qword [ebp-0x28]");
                        asm("fmul qword [ebp-0x28]");
                        asm("fstp qword [ebp-0x18]");
                        goto L19;
                    }
                }
L17:
                asm("fld1 ");
                asm("fsub qword [ebp-0x28]");
                asm("fchs ");
                asm("fmul qword [ebp-0x28]");
                asm("fstp qword [ebp-0x18]");
                goto L19;
            } else {
                if(_v12 >= _v16) {
                    goto L13;
                } else {
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fld1 ");
                    asm("fsub qword [ebp-0x28]");
                    asm("fmulp st1, st0");
                    asm("fstp qword [ebp-0x18]");
L19:
                    asm("fld qword [eax]");
                    asm("fld qword [ebp-0x20]");
                    asm("fmul qword [ebp-0x18]");
                    asm("faddp st1, st0");
                    asm("fstp qword [edx]");
L22:
                    _v12 = _v12 + 1;
                    goto L23;
                }
                goto L14;
            }
        }
        if(_v12 < col) {
            goto L22;
        }
        if(_v12 >= _v16) {
            goto L22;
        }
        goto L8;
    }
}

set_table_matrix0(struct table* t, int maxwidth)
{// addr = 0x080892E4
    int size;
    int i;
    int j;
    int k;
    int bcol;
    int ecol;
    int width;
    double w0;
    double w1;
    double w;
    double s;
    double b;
    double we;
    char expand;
    struct table_cell* cell;
    char _v16;
    signed int _v32;
    int _v36;
    signed int _v40;
    signed int _v44;
    signed int _v48;
    signed int _v52;
    intOrPtr _v56;
    int _v60;
    struct table_cell* _v64;
    intOrPtr _v68;
    signed int _v72;
    intOrPtr _v76;
    void* _v80;
    struct table* _v128;
    signed int _v130;
    signed int _v132;
    int _v136;
    signed int _v138;
    struct table** _v144;
    int _v148;
    signed int _v152;
    signed int _v156;
    signed int _v160;
    signed int _v164;
    signed int _v168;
    signed int _v172;
    signed int _v176;
    signed int _v180;
    signed int _v184;
    signed int _v188;
    signed int _v192;
    signed int _v196;
    char _v204;
    void* _v224;
    void* _v228;
    signed int _v232;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t278;
    _unknown_ _t288;
    _unknown_ _t292;
    _unknown_ _t307;
    _unknown_ _t311;
    signed int _t323;
    _unknown_ _t326;
    _unknown_ _t327;
    _unknown_ _t331;
    _unknown_ _t361;
    signed int _t362;
    _unknown_ _t363;
    _unknown_ _t366;
    signed int _t400;
    _unknown_ _t402;
    _unknown_ _t407;
    _unknown_ _t412;
    _unknown_ _t418;
    _unknown_ _t423;
    _unknown_ _t425;
    _unknown_ _t426;
    signed int _t430;
    _unknown_ _t433;
    _unknown_ _t438;
    _unknown_ _t442;
    _unknown_ _t444;
    _unknown_ _t445;
    _unknown_ _t447;
    _unknown_ _t448;
    _unknown_ _t450;
    _unknown_ _t451;
    _unknown_ _t453;
    _unknown_ _t456;
    _unknown_ _t473;
    _unknown_ _t474;
    _unknown_ _t484;
    _unknown_ _t485;
    _unknown_ _t486;
    _unknown_ _t487;
    _unknown_ _t488;
    _unknown_ _t496;

    __esp = __esp - 220;
    _v128 = t;
    _v32 =  *gs:0x14];
    _v144 = __esp;
    _v36 = _v128->maxcol + 1;
    _v148 = _v36;
    _v68 = _v148 - 1;
    asm("shld edx, eax, 0x6");
    _v156 = _v148;
    _v152 = 0;
    asm("shld edx, eax, 0x6");
    _v164 = _v156 << 6;
    _v160 = _v152 & 15;
    __esp = __esp - ((_v148 << 3) + 15 + 15 >> 4 << 4);
    _v72 =  &_v204 + 15 >> 4 << 4;
    _t430 = _v36;
    _v76 = _t430 - 1;
    _v172 = _t430;
    _v168 = 0;
    asm("shld edx, eax, 0x3");
    _v180 = _v172 << 3;
    _v176 = _v168 & 15;
    _v188 = _t430;
    _v184 = 0;
    asm("shld edx, eax, 0x3");
    _v196 = _v188 << 3;
    _v192 = _v184 & 15;
    __esp = __esp - (_t430 + 15 + 15 >> 4 << 4);
    _v80 =  &_v204 + 15 >> 4 << 4;
    _v64 =  &(_v128->cell);
    asm("fldz ");
    asm("fstp qword [ebp-0x58]");
    _v40 = 0;
    while(1) {
        _t323 = _v40;
        if(_t323 >= _v36) {
            break;
        }
        asm("cwde ");
        weight( *(_v128 + 8 + (_v40 + 40) * 2) & 65535);
        asm("fstp qword [eax+ebx*8]");
        asm("fld qword [eax+edx*8]");
        asm("fld qword [ebp-0x58]");
        asm("faddp st1, st0");
        asm("fstp qword [ebp-0x58]");
        _v40 = _v40 + 1;
    }
    asm("fld qword [ebp-0x58]");
    asm("fldz ");
    asm("fucomip st0, st1");
    asm("fstp st0");
    asm("setnb al");
    if((_t323 & 4294967295) != 0) {
        asm("fld1 ");
        asm("fstp qword [ebp-0x58]");
    }
    if((_v64->necell & 65535 & 4294967295) != 0) {
        bzero(_v80, _v36);
        _v48 = 0;
        while(1) {
L20:
            asm("cwde ");
            if((_v64->necell & 65535) <= _v48) {
                break;
            }
            asm("cwde ");
            _v44 =  *(_v64 + 12 + (_v48 + 56) * 2) & 65535;
            asm("cwde ");
            _v52 =  *(_v64 + _v44 * 2) & 65535;
            asm("cwde ");
            _v56 = ( *(_v64 + 8 + (_v44 + 16) * 2) & 65535) + _v52;
            asm("cwde ");
            _v60 = ( *(_v64 + 6 + (_v44 + 80) * 2) & 65535 & 4294967295) + _v128->cellspacing * (1 - ( *(_v64 + 8 + (_v44 + 16) * 2) & 65535));
            asm("fldz ");
            asm("fstp qword [ebp-0x60]");
            _v40 = _v52;
            while(_v40 < _v56) {
                _v138 =  *(_v128 + 8 + (_v40 + 40) * 2) & 65535 & 4294967295;
                asm("fild word [ebp+0xffffff7a]");
                asm("fld qword [0x80cb620]");
                asm("faddp st1, st0");
                asm("fld qword [ebp-0x60]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x60]");
                 *(_v80 + _v40) = ( *(_v80 + _v40) & 255) + 1 & 4294967295;
                _v40 = _v40 + 1;
            }
        }
        asm("fldz ");
        asm("fstp qword [ebp-0x58]");
        asm("fldz ");
        asm("fstp qword [ebp-0x60]");
        _v40 = 0;
        while(1) {
            _t362 = _v40;
            if(_t362 >= _v36) {
                break;
            }
            asm("fld qword [eax+edx*8]");
            asm("fld qword [ebp-0x58]");
            asm("faddp st1, st0");
            asm("fstp qword [ebp-0x58]");
            if(( *(_v80 + _v40) & 255 & 4294967295) == 0) {
                asm("fld qword [eax+edx*8]");
                asm("fld qword [ebp-0x60]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x60]");
            }
            _v40 = _v40 + 1;
        }
        asm("fld qword [ebp-0x58]");
        asm("fldz ");
        asm("fucomip st0, st1");
        asm("fstp st0");
        asm("setnb al");
        if((_t362 & 4294967295) != 0) {
            asm("fld1 ");
            asm("fstp qword [ebp-0x58]");
        }
        _v48 = 0;
        while(1) {
            asm("cwde ");
            if((_v64->necell & 65535) <= _v48) {
                break;
            }
            asm("cwde ");
            _v44 =  *(_v64 + 12 + (_v48 + 56) * 2) & 65535;
            asm("cwde ");
            _v52 =  *(_v64 + _v44 * 2) & 65535;
            asm("cwde ");
            _v60 = ( *(_v64 + 6 + (_v44 + 80) * 2) & 65535 & 4294967295) + _v128->cellspacing * (1 - ( *(_v64 + 8 + (_v44 + 16) * 2) & 65535));
            weight(_v60);
            asm("fstp qword [ebp-0x68]");
            asm("fld qword [ebp-0x60]");
            asm("fadd qword [ebp-0x68]");
            asm("fld qword [ebp-0x68]");
            asm("fdivrp st1, st0");
            asm("fstp qword [ebp-0x70]");
            asm("fild dword [ebp+0xc]");
            asm("fmul qword [ebp-0x70]");
            asm("fnstcw word [ebp-0x7e]");
            _v132 = _v130 & 65535 & 4294967295;
            asm("fldcw word [ebp-0x80]");
            asm("fistp dword [ebp+0xffffff7c]");
            asm("fldcw word [ebp-0x7e]");
            weight2(_v136);
            asm("fld qword [0x80cb628]");
            asm("fmulp st1, st0");
            asm("fstp qword [ebp-0x78]");
            asm("cwde ");
            asm("fld qword [ebp-0x78]");
            asm("fstp qword [esp+0x18]");
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [esp+0x10]");
            _v224 = _v80;
            _v228 =  *(_v64 + 8 + (_v44 + 16) * 2) & 65535;
            _v232 = _v52;
             *__esp = _v128;
            correct_table_matrix4();
            _v48 = _v48 + 1;
        }
        _v40 = 0;
        while(_v40 < _v36) {
            if(( *(_v80 + _v40) & 255 & 4294967295) != 0) {
                asm("fld qword [eax+edx*8]");
                asm("fld qword [ebp-0x58]");
                asm("fsub qword [ebp-0x60]");
                asm("fld1 ");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_v72 & 4294967295) == 0) {
                    asm("fld1 ");
                } else {
                    asm("fld qword [ebp-0x58]");
                    asm("fsub qword [ebp-0x60]");
                }
                asm("fdivp st1, st0");
                asm("fstp qword [ebp-0x70]");
                weight2(maxwidth);
                asm("fld qword [0x80cb628]");
                asm("fmulp st1, st0");
                asm("fstp qword [ebp-0x78]");
            } else {
                asm("fld qword [eax+edx*8]");
                asm("fld qword [ebp-0x60]");
                asm("fld1 ");
                asm("fxch st0, st1");
                asm("fucomip st0, st1");
                asm("fstp st0");
                if((_v72 & 4294967295) == 0) {
                    asm("fld1 ");
                } else {
                    asm("fld qword [ebp-0x60]");
                }
                asm("fdivp st1, st0");
                asm("fstp qword [ebp-0x70]");
                asm("fild dword [ebp+0xc]");
                asm("fmul qword [ebp-0x70]");
                asm("fnstcw word [ebp-0x7e]");
                _v132 = _v130 & 65535 & 4294967295;
                asm("fldcw word [ebp-0x80]");
                asm("fistp dword [ebp+0xffffff7c]");
                asm("fldcw word [ebp-0x7e]");
                weight2(_v136);
                asm("fld qword [0x80cb628]");
                asm("fmulp st1, st0");
                asm("fstp qword [ebp-0x78]");
            }
            asm("fld qword [ebp-0x78]");
            asm("fstp qword [esp+0x14]");
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [esp+0xc]");
            _v228 = _v80;
            _v232 = _v40;
             *__esp = _v128;
            correct_table_matrix3();
            _v40 = _v40 + 1;
        }
    } else {
        _v40 = 0;
        while(1) {
            _t496 = _v40 - _v36;
            if(_t496 >= 0) {
                break;
            }
            asm("fld qword [eax+edx*8]");
            asm("fdiv qword [ebp-0x58]");
            asm("fstp qword [ebp-0x70]");
            asm("fild dword [ebp+0xc]");
            asm("fmul qword [ebp-0x70]");
            asm("fnstcw word [ebp-0x7e]");
            _v132 = _v130 & 65535 & 4294967295;
            asm("fldcw word [ebp-0x80]");
            asm("fistp dword [ebp+0xffffff7c]");
            asm("fldcw word [ebp-0x7e]");
            weight2(_v136);
            asm("fld qword [0x80cb628]");
            asm("fmulp st1, st0");
            asm("fstp qword [ebp-0x78]");
            asm("fld qword [ebp-0x78]");
            asm("fstp qword [esp+0x14]");
            asm("fld qword [ebp-0x70]");
            asm("fstp qword [esp+0xc]");
            _v228 = 1;
            _v232 = _v40;
             *__esp = _v128;
            correct_table_matrix2();
            _v40 = _v40 + 1;
        }
        __esp = _v144;
        _t400 = _v32 ^  *gs:0x14];
        if(_t496 != 0) {
            __stack_chk_fail();
        }
         &_v16 =  &_v16;
        return _t400;
    }
    goto L20;
}

check_relative_width(struct table* t, int maxwidth)
{// addr = 0x080899B4
    int i;
    double rel_total;
    int size;
    double* rcolwidth;
    struct table_cell* cell;
    int n_leftcol;
    double w;
    double r;
    int j;
    int k;
    int n_leftcell;
    double r;
    int j;
    int k;
    intOrPtr _v16;
    signed int _v20;
    signed int _v24;
    struct table_cell* _v28;
    intOrPtr _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v94;
    _unknown_ _v96;
    _unknown_ _v98;
    _unknown_ _v104;
    _unknown_ __ebp;
    signed int _t238;
    _unknown_ _t244;
    _unknown_ _t247;
    _unknown_ _t249;
    _unknown_ _t252;
    _unknown_ _t255;
    _unknown_ _t259;
    _unknown_ _t265;
    _unknown_ _t269;
    _unknown_ _t270;
    _unknown_ _t273;
    _unknown_ _t276;
    _unknown_ _t279;
    _unknown_ _t280;
    _unknown_ _t283;
    _unknown_ _t296;
    _unknown_ _t300;
    _unknown_ _t303;
    _unknown_ _t306;
    _unknown_ _t309;
    _unknown_ _t311;
    _unknown_ _t314;
    _unknown_ _t316;
    _unknown_ _t319;
    _unknown_ _t342;
    _unknown_ _t349;
    _unknown_ _t350;
    _unknown_ _t359;
    _unknown_ _t362;
    _unknown_ _t363;

    asm("fldz ");
    asm("fstp qword [ebp-0x38]");
    _v20 = t->maxcol.col + 1;
    _t238 = _v20 << 3;
     *__esp = _t238;
    GC_malloc();
    _v24 = _t238;
    _v28 =  &(t->cell);
    _v32 = 0;
    _v16 = 0;
    while() {
    }
}

set_table_matrix(struct table* t, int width)
{// addr = 0x08089E51
    int size;
    int i;
    int j;
    double b;
    double s;
    int a;
    struct table_cell* cell;
    int _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    _unknown_ _v28;
    struct table_cell* _v32;
    _unknown_ _v62;
    _unknown_ _v64;
    _unknown_ _v66;
    _unknown_ _v72;
    _unknown_ _v96;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ __ebp;
    _unknown_ _t186;
    _unknown_ _t188;
    _unknown_ _t189;
    _unknown_ _t193;
    _unknown_ _t194;
    _unknown_ _t195;
    _unknown_ _t198;
    _unknown_ _t214;
    _unknown_ _t220;
    _unknown_ _t238;
    _unknown_ _t246;
    _unknown_ _t255;
    _unknown_ _t266;
    _unknown_ _t284;
    _unknown_ _t292;

    _v16 = t->maxcol + 1;
    _v32 =  &(t->cell);
    if(_v16 <= 0) {
        return ;
    }
    t->matrix = new_matrix(_v16);
    t->vector = new_vector(_v16);
    _v20 = 0;
    while(_v20 < _v16) {
        while(_v24 < _v16) {
        }
    }
}

writeLocalCookie()
{// addr = 0x0808A210
    FILE* f;
    struct _IO_FILE* _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    _unknown_ _t20;
    _unknown_ _t25;
    _unknown_ _t27;

    if(no_rc_dir != 0) {
        return ;
    }
    if(Local_cookie_file != 0) {
        return ;
    }
    Local_cookie_file =  *(tmpfname(4, 0));
    set_environ("LOCAL_COOKIE_FILE", Local_cookie_file);
    _v16 = fopen(Local_cookie_file, "wb");
    if(_v16 == 0) {
        return ;
    }
    localCookie();
    fwrite(Local_cookie->ptr, 1, Local_cookie->length, _v16);
    fclose(_v16);
    _v40 = 384;
     *__esp = Local_cookie_file;
    chmod();
    return;
}

Str localCookie()
{// addr = 0x0808A2DB
    char[255] hostname;
    intOrPtr _v16;
    char _v272;
    char* _v292;
    long _v296;
    _unknown_ __ebp;
    _unknown_ _t10;
    int _t13;
    _unknown_ _t15;
    long _t16;
    struct _Str* _t18;
    _unknown_ _t21;

    _v16 =  *gs:0x14];
    __eflags = Local_cookie;
    if(__eflags == 0) {
        _t13 = gethostname( &_v272, 256);
         *__esp = 1;
        GC_malloc();
         *__esp = 0;
        time();
        srand48(_t13 + _t13);
        _t16 = lrand48();
        _v292 =  &_v272;
        _v296 = _t16;
        Local_cookie = Sprintf("%ld%s");
        _t18 = Local_cookie;
    } else {
        _t18 = Local_cookie;
    }
    if(__eflags == 0) {
        return _t18;
    }
    __stack_chk_fail();
    return _t18;
}

Str loadLocalDir(char* dname)
{// addr = 0x0808A37E
    Str tmp;
    DIR* d;
    Directory* dir;
    struct stat st;
    char** flist;
    char* p;
    char* qdir;
    Str fbuf;
    struct stat lst;
    char[1023] lbuf;
    int i;
    int l;
    int nrow;
    int n;
    int maxlen;
    int nfile;
    int nfile_max;
    Str dirname;
    intOrPtr _v16;
    char _v1040;
    struct _Str* _v1044;
    int _v1048;
    int _v1052;
    void* _v1056;
    char* _v1060;
    char* _v1064;
    struct _Str* _v1068;
    signed int _v1072;
    int _v1076;
    signed int _v1080;
    signed int _v1084;
    int _v1088;
    int _v1092;
    signed int _v1096;
    struct _Str* _v1100;
    signed int _v1172;
    char _v1188;
    signed int _v1260;
    char _v1276;
    int _v1280;
    char** _v1296;
    struct _Str* _v1312;
    char* _v1316;
    char* _v1320;
    char* _v1324;
    struct _Str* _v1328;
    char* _v1332;
    char* _v1336;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t273;
    _unknown_ _t274;
    int _t275;
    struct _Str* _t278;
    int _t281;
    struct _Str* _t282;
    int _t286;
    char* _t300;
    signed int _t303;
    int _t304;
    void* _t319;
    _unknown_ _t323;
    int _t330;
    struct _Str* _t333;
    int _t336;
    struct _Str* _t337;
    int _t341;
    int _t350;
    int _t352;
    char* _t361;
    char* _t369;
    char* _t386;
    int _t391;
    struct _Str* _t392;
    int _t396;
    signed int _t403;
    int _t407;
    struct _Str* _t408;
    int _t412;
    int _t420;
    struct _Str* _t421;
    int _t425;
    signed int _t441;
    struct _Str* _t444;
    signed int _t459;
    _unknown_ _t478;
    _unknown_ _t506;
    _unknown_ _t507;
    _unknown_ _t510;
    _unknown_ _t511;

    _v1280 = dname;
    _v16 =  *gs:0x14];
    Strnew();
    _v1068 = 0;
    _v1080 = 0;
    _v1084 = 0;
    _v1088 = 0;
    _v1096 = 100;
    _t275 = _v1280;
     *__esp = _t275;
    opendir();
    _v1048 = _t275;
    __eflags = _v1048;
    if(__eflags != 0) {
        _v1100 = Strnew_charp(_v1280);
        _t278 = _v1100;
        __eflags = _t278->length;
        if(_t278->length <= 0) {
L4:
            _t281 = _v1100->length;
            _t282 = _v1100;
            __eflags = _t281 + 1 - _t282->area_size;
            if(_t281 + 1 >= _t282->area_size) {
                Strgrow(_v1100);
            }
            _t286 = _v1100->length;
             *( *_v1100 + _t286) = 47;
            _v1100->length = _t286 + 1;
             *( *_v1100 + _v1100->length) = 0;
L7:
            _v1064 = html_quote( *(wc_Str_conv(_v1100, SystemCharset, InnerCharset)));
            _t300 = html_quote(file_quote( *_v1100));
            _v1312 = 0;
            _v1316 = "</H1>\n";
            _v1320 = _v1064;
            _v1324 = "</TITLE>\n</HEAD>\n<BODY>\n<H1>Directory list of ";
            _v1328 = _v1064;
            _v1332 = "">\n<TITLE>Directory list of ";
            _v1336 = _t300;
            _v1044 = Strnew_m_charp("<HTML>\n<HEAD>\n<BASE HREF="file://");
            _t303 = _v1096 << 2;
             *__esp = _t303;
            GC_malloc();
            _v1056 = _t303;
            _v1092 = 0;
            while(1) {
                _t304 = _v1048;
                 *__esp = _t304;
                readdir();
                _v1052 = _t304;
                __eflags = _v1052;
                if(_v1052 == 0) {
                    break;
                } else {
                    _v1056[_v1092] = allocStr(_v1052 + 11, -1);
                    _v1092 = _v1092 + 1;
                    __eflags = _v1092 - _v1096;
                    if(_v1092 == _v1096) {
                        _v1096 = _v1096 << 1;
                        _v1336 = _v1096 << 2;
                        _t319 = _v1056;
                         *__esp = _t319;
                        GC_realloc();
                        _v1056 = _t319;
                    }
                    __eflags = multicolList;
                    if(multicolList != 0) {
                        _v1076 = strlen(_v1052 + 11);
                        __eflags = _v1076 - _v1088;
                        if(_v1076 > _v1088) {
                            _v1088 = _v1076;
                        }
                        _v1084 = _v1084 + 1;
                    }
                    continue;
                }
            }
            __eflags = multicolList;
            if(multicolList != 0) {
                _v1296 =  &(_v1088->ptr);
                _v1076 = COLS / _v1296;
                __eflags = _v1076;
                if(_v1076 == 0) {
                    _v1076 = 1;
                }
                _v1080 = (_v1084 + _v1076 - 1) / _v1076;
                _v1084 = 1;
                Strcat_charp(_v1044, "<TABLE CELLPADDING=0>\n<TR VALIGN=TOP>\n");
            }
            _v1328 = strCmp;
            qsort(_v1056, _v1092, 4);
            _v1072 = 0;
            while(1) {
                __eflags = _v1072 - _v1092;
                if(_v1072 >= _v1092) {
                    break;
                }
                _v1060 = _v1056[_v1072];
                _t330 = strcmp(_v1060, ".");
                __eflags = _t330;
                if(_t330 == 0) {
L58:
                    _v1072 = _v1072 + 1;
                    continue;
                }
                Strcopy(_v1068, _v1100);
                _t333 = _v1068;
                __eflags = _t333->length;
                if(_t333->length <= 0) {
L23:
                    _t336 = _v1068->length;
                    _t337 = _v1068;
                    __eflags = _t336 + 1 - _t337->area_size;
                    if(_t336 + 1 >= _t337->area_size) {
                        Strgrow(_v1068);
                    }
                    _t341 = _v1068->length;
                    ( *_v1068)[_t341] = 47;
                    _v1068->length = _t341 + 1;
                    ( *_v1068)[_v1068->length] = 0;
L26:
                    Strcat_charp(_v1068, _v1060);
                    _t350 =  *_v1068;
                    L080C7300(_t350,  &_v1276);
                    __eflags = _t350;
                    if(_t350 < 0) {
                        _t352 =  *_v1068;
                        L080C7280(_t352,  &_v1188);
                        __eflags = _t352;
                        if(_t352 < 0) {
                            __eflags = multicolList;
                            if(multicolList == 0) {
                                __eflags = (_v1260 & 61440) - 40960;
                                if((_v1260 & 61440) != 40960) {
                                    __eflags = (_v1172 & 61440) - 16384;
                                    if((_v1172 & 61440) != 16384) {
                                        Strcat_charp(_v1044, "[FILE] ");
                                    } else {
                                        Strcat_charp(_v1044, "[DIR]&nbsp; ");
                                    }
                                } else {
                                    Strcat_charp(_v1044, "[LINK] ");
                                }
                            } else {
                                __eflags = _v1084 - 1;
                                if(_v1084 == 1) {
                                    Strcat_charp(_v1044, "<TD><NOBR>");
                                }
                            }
                            _t361 = html_quote(file_quote(_v1060));
                            _v1328 = 0;
                            _v1332 = _t361;
                            _v1336 = "<A HREF="";
                            Strcat_m_charp(_v1044);
                            __eflags = (_v1172 & 61440) - 16384;
                            if((_v1172 & 61440) == 16384) {
                                _t420 = _v1044->length;
                                _t421 = _v1044;
                                __eflags = _t420 + 1 - _t421->area_size;
                                if(_t420 + 1 >= _t421->area_size) {
                                    Strgrow(_v1044);
                                }
                                _t425 = _v1044->length;
                                 *( *_v1044 + _t425) = 47;
                                _v1044->length = _t425 + 1;
                                 *( *_v1044 + _v1044->length) = 0;
                            }
                            _t369 = html_quote( *(wc_Str_conv(Strnew_charp(_v1060), SystemCharset, InnerCharset)));
                            _v1328 = 0;
                            _v1332 = _t369;
                            _v1336 = "">";
                            Strcat_m_charp(_v1044);
                            __eflags = (_v1172 & 61440) - 16384;
                            if((_v1172 & 61440) == 16384) {
                                _t407 = _v1044->length;
                                _t408 = _v1044;
                                __eflags = _t407 + 1 - _t408->area_size;
                                if(_t407 + 1 >= _t408->area_size) {
                                    Strgrow(_v1044);
                                }
                                _t412 = _v1044->length;
                                 *( *_v1044 + _t412) = 47;
                                _v1044->length = _t412 + 1;
                                 *( *_v1044 + _v1044->length) = 0;
                            }
                            Strcat_charp(_v1044, "</A>");
                            __eflags = multicolList;
                            if(multicolList == 0) {
                                __eflags = (_v1260 & 61440) - 40960;
                                if((_v1260 & 61440) == 40960) {
                                    _v1076 = readlink( *_v1068,  &_v1040, 1024);
                                    __eflags = _v1076;
                                    if(_v1076 > 0) {
                                         *(__ebp + _v1076 + -1036) = 0;
                                        _t386 = html_quote( *(wc_Str_conv(Strnew_charp( &_v1040), SystemCharset, InnerCharset)));
                                        _v1328 = 0;
                                        _v1332 = _t386;
                                        _v1336 = " -> ";
                                        Strcat_m_charp(_v1044);
                                        __eflags = (_v1172 & 61440) - 16384;
                                        if((_v1172 & 61440) == 16384) {
                                            _t391 = _v1044->length;
                                            _t392 = _v1044;
                                            __eflags = _t391 + 1 - _t392->area_size;
                                            if(_t391 + 1 >= _t392->area_size) {
                                                Strgrow(_v1044);
                                            }
                                            _t396 = _v1044->length;
                                             *( *_v1044 + _t396) = 47;
                                            _v1044->length = _t396 + 1;
                                             *( *_v1044 + _v1044->length) = 0;
                                        }
                                    }
                                }
                                Strcat_charp(_v1044, "<br>\n");
                            } else {
                                _t403 = _v1084;
                                __eflags = _t403 - _v1080;
                                _v1084 = _v1084 + 1;
                                __eflags = _t403 & 4294967295;
                                if((_t403 & 4294967295) == 0) {
                                    Strcat_charp(_v1044, "<BR>\n");
                                } else {
                                    Strcat_charp(_v1044, "</NOBR></TD>\n");
                                    _v1084 = 1;
                                }
                            }
                        }
                    }
                    goto L58;
                }
                _t441 = ( *_v1068)[_v1068->length - 1] & 255;
                __eflags = (_t441 & 4294967295) - 47;
                if((_t441 & 4294967295) == 47) {
                    goto L26;
                }
                goto L23;
            }
            __eflags = multicolList;
            if(__eflags != 0) {
                Strcat_charp(_v1044, "</TR>\n</TABLE>\n");
            }
            Strcat_charp(_v1044, "</BODY>\n</HTML>\n");
            _t444 = _v1044;
            goto L63;
        }
    } else {
        _t444 = 0;
L63:
        if(__eflags == 0) {
            return _t444;
        }
        __stack_chk_fail();
        return _t444;
    }
L3:
    _t459 =  *( *_v1100 + _v1100->length - 1) & 255;
    __eflags = (_t459 & 4294967295) - 47;
    if((_t459 & 4294967295) == 47) {
        goto L7;
    }
    goto L4;
}

int check_local_cgi(char* file, int status)
{// addr = 0x0808AC49
    struct stat st;
    intOrPtr _v72;
    intOrPtr _v76;
    signed int _v84;
    char _v100;
    _unknown_ _v120;
    _unknown_ __ebx;
    _unknown_ __ebp;
    char* _t13;
    _unknown_ _t20;
    _unknown_ _t21;
    _unknown_ _t26;
    _unknown_ _t27;
    _unknown_ _t28;

    if(status != 1) {
        if(status == 2) {
            goto L3;
        } else {
            return -1;
        }
    }
L3:
    _t13 = file;
    L080C7280(_t13,  &_v100);
    if(_t13 < 0) {
        return -1;
    }
    if((_v84 & 61440) == 16384) {
        return -1;
    }
    if(_v76 == geteuid()) {
        if((_v84 & 64) != 0) {
            return 0;
        }
    }
    if(_v72 == getegid()) {
        if((_v84 & 8) != 0) {
            return 0;
        }
    }
    if((_v84 & 1 & 4294967295) == 0) {
        return -1;
    }
    return 0;
}

set_environ(char* var, char* value)
{// addr = 0x0808ACDE
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t10;

    if(var == 0) {
        return ;
    }
    if(value == 0) {
        return ;
    }
    setenv(var, value, 1);
    return;
}

set_cgi_environ(char* name, char* fn, char* req_uri)
{// addr = 0x0808AD0C
    _unknown_ _v24;
    _unknown_ __ebp;

    set_environ("SERVER_SOFTWARE", w3m_version);
    set_environ("SERVER_PROTOCOL", "HTTP/1.0");
    set_environ("SERVER_NAME", "localhost");
    set_environ("SERVER_PORT", "80");
    set_environ("REMOTE_HOST", "localhost");
    set_environ("REMOTE_ADDR", "127.0.0.1");
    set_environ("GATEWAY_INTERFACE", "CGI/1.1");
    set_environ("SCRIPT_NAME", name);
    set_environ("SCRIPT_FILENAME", fn);
    set_environ("REQUEST_URI", req_uri);
    return;
}

Str checkPath(char* fn, char* path)
{// addr = 0x0808ADDA
    char* p;
    Str tmp;
    struct stat st;
    char* _v16;
    struct _Str* _v20;
    char _v108;
    _unknown_ _v120;
    _unknown_ __ebp;
    char* _t55;
    int _t66;
    struct _Str _t75;
    _unknown_ _t91;

    while(( *path & 255 & 4294967295) != 0) {
        _v16 = strchr(path, 58);
        if(_v16 == 0) {
            _t55 = path;
        } else {
            _t55 = allocStr(path, _v16 - path);
        }
        _v20 = Strnew_charp(expandPath(_t55));
        if(_v20->length <= 0 || ( *( *_v20 + _v20->length - 1) & 255 & 4294967295) != 47) {
            if(_v20->length + 1 >= _v20->area_size) {
                Strgrow(_v20);
            }
            _t66 = _v20->length;
             *((char*)( *_v20 + _t66)) = 47;
            _v20->length = _t66 + 1;
             *((char*)( *_v20 + _v20->length)) = 0;
        }
        Strcat_charp(_v20, fn);
        _t75 =  *_v20;
        L080C7280(_t75,  &_v108);
        if(_t75 == 0) {
            return _v20;
        }
        if(_v16 == 0) {
            return 0;
        }
        path =  &(_v16[1]);
        while(( *path & 255 & 4294967295) == 58) {
            path =  &(path[1]);
        }
    }
}

int cgi_filename(char* uri, char** fn, char** name, char** path_info)
{// addr = 0x0808AF07
    Str tmp;
    int offset;
    Str tmp2;
    struct _Str* _v16;
    int _v20;
    struct _Str* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t140;
    _unknown_ _t156;
    int _t168;
    _unknown_ _t199;
    _unknown_ _t206;
    _unknown_ _t234;
    _unknown_ _t235;

     *fn = uri;
     *name = uri;
     *path_info = 0;
    if(cgi_bin != 0 && strncmp(uri, "/cgi-bin/", 9) == 0) {
        _v20 = 9;
         *path_info = strchr( &(uri[_v20]), 47);
        if( *path_info != 0) {
             *name = allocStr(uri,  *path_info - uri);
        }
        _v16 = checkPath( &(( *name)[_v20]), cgi_bin);
        if(_v16 == 0) {
            return 0;
        }
         *fn =  *_v16;
        return 2;
    }
    _v16 = Strnew_charp(w3m_lib_dir());
    if(_v16->length <= 0 || (( *_v16)[_v16->length - 1] & 255 & 4294967295) != 47) {
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t140 = _v16->length;
        ( *_v16)[_t140] = 47;
        _v16->length = _t140 + 1;
        ( *_v16)[_v16->length] = 0;
    }
    if(strncmp(uri, "/$LIB/", 6) != 0) {
        if(strncmp(uri,  *_v16, _v16->length) != 0) {
            if(( *uri & 255 & 4294967295) != 47) {
                return 0;
            }
            if(document_root == 0) {
                return 0;
            }
            _v24 = Strnew_charp(document_root);
            if(_v24->length <= 0 || (( *_v24)[_v24->length - 1] & 255 & 4294967295) != 47) {
                if(_v24->length + 1 >= _v24->area_size) {
                    Strgrow(_v24);
                }
                _t168 = _v24->length;
                ( *_v24)[_t168] = 47;
                _v24->length = _t168 + 1;
                ( *_v24)[_v24->length] = 0;
            }
            Strcat_charp(_v24,  &(uri[1]));
            if(strncmp( *_v24,  *_v16, _v16->length) != 0) {
                return 0;
            }
            uri =  *_v24;
             *name = uri;
            _v20 = _v16->length;
        } else {
            _v20 = _v16->length;
        }
    } else {
        _v20 = 6;
    }
     *path_info = strchr( &(uri[_v20]), 47);
    if( *path_info != 0) {
         *name = allocStr(uri,  *path_info - uri);
    }
    Strcat_charp(_v16,  &(( *name)[_v20]));
     *fn =  *_v16;
    return 1;
}

FILE* localcgi_post(char* uri, char* qstr, FormList* request, char* referer)
{// addr = 0x0808B234
    FILE* fr;
    FILE* fw;
    int status;
    pid_t pid;
    char* file;
    char* name;
    char* path_info;
    char* tmpf;
    FILE** _v16;
    struct _IO_FILE* _v20;
    int _v24;
    int _v28;
    char* _v32;
    char* _v36;
    FILE** _v40;
    char* _v44;
    char* _v60;
    FILE** _v64;
    FILE** _v68;
    long unsigned int _v72;
    _unknown_ __ebp;
    int _t120;
    char* _t123;
    _unknown_ _t126;
    _unknown_ _t129;
    char* _t131;
    _unknown_ _t132;
    char* _t135;
    char* _t137;
    _unknown_ _t138;
    _unknown_ _t149;
    _unknown_ _t151;
    _unknown_ _t154;
    _unknown_ _t162;
    _unknown_ _t173;
    _unknown_ _t174;
    _unknown_ _t181;
    _unknown_ _t182;

    _v16 = 0;
    _v20 = 0;
    _v32 = uri;
    _v36 = uri;
    _v40 = 0;
    _v44 = 0;
    _v24 = cgi_filename(uri,  &_v32,  &_v36,  &_v40);
    if(check_local_cgi(_v32, _v24) < 0) {
        return 0;
    }
    writeLocalCookie();
    if(request != 0 && request->enctype != 1) {
        _v44 =  *(tmpfname(0, 0));
        _v20 = fopen(_v44, "w");
        if(_v20 == 0) {
            return 0;
        }
    }
    _v28 = open_pipe_rw( &_v16, 0);
    if(_v28 < 0) {
        return 0;
    }
    if(_v28 != 0) {
        if(_v20 == 0) {
            return _v16;
        }
        fclose(_v20);
        return _v16;
    }
    if(_v20 == 0) {
        _t120 = -1;
    } else {
        _t120 = fileno(_v20);
    }
    setup_child(1, 2, _t120);
    if(qstr != 0) {
        _v64 = 0;
        _v68 = qstr;
        _v72 = "?";
        uri =  *(Strnew_m_charp(uri));
    }
    set_cgi_environ(_v36, _v32, uri);
    if(_v40 != 0) {
        set_environ("PATH_INFO", _v40);
    }
    if(referer != 0 && referer != 255) {
        set_environ("HTTP_REFERER", referer);
    }
    if(request == 0) {
        set_environ("REQUEST_METHOD", "GET");
        if(qstr == 0) {
            _t123 = 135051494;
        } else {
            _t123 = qstr;
        }
        set_environ("QUERY_STRING", _t123);
        freopen("/dev/null", "r", __imp__stdin);
    } else {
        set_environ("REQUEST_METHOD", "POST");
        if(qstr != 0) {
            set_environ("QUERY_STRING", qstr);
        }
        _v72 = request->length;
        set_environ("CONTENT_LENGTH",  *(Sprintf("%d")));
        if(request->enctype != 1) {
            set_environ("CONTENT_TYPE", "application/x-www-form-urlencoded");
            fwrite(request->body, 1, request->length, _v20);
            fclose(_v20);
            freopen(_v44, "r", __imp__stdin);
        } else {
            _v72 = request->boundary;
            set_environ("CONTENT_TYPE",  *(Sprintf("multipart/form-data; boundary=%s")));
            freopen(request->body, "r", __imp__stdin);
        }
    }
    chdir(mydirname(_v32));
    _t131 = mybasename(_v32);
    _v68 = 0;
    execl(_v32, _t131);
    _t135 = strerror( *(__errno_location()));
    _t137 = mybasename(_v32);
    _v60 = _t135;
    _v64 = _t137;
    _v68 = _v32;
    fprintf(__imp__stderr, "execl("%s", "%s", NULL): %s\n");
    return exit(1);
}

struct form_list* newFormList(char* action, char* method, char* charset, char* enctype, char* target, char* name, struct form_list* _next)
{// addr = 0x0808B5F0
    struct form_list* l;
    Str a;
    int m;
    int e;
    wc_ces c;
    int _v16;
    int _v20;
    int _v24;
    int _v28;
    int _v32;
    _unknown_ _v56;
    _unknown_ __ebp;
    int _t61;

    _t61 = Strnew_charp(action);
    _v20 = _t61;
    _v24 = 0;
    _v28 = 0;
    _v32 = 0;
    if(method == 0) {
L2:
        _v24 = 0;
L7:
        if(enctype != 0) {
            _t61 = strcasecmp(enctype, "multipart/form-data");
            if(_t61 == 0) {
                _v28 = 1;
                if(_v24 == 0) {
                    _v24 = 1;
                }
            }
        }
        if(charset != 0) {
            _t61 = wc_guess_charset(charset, 0);
            _v32 = _t61;
        }
         *__esp = 52;
        GC_malloc();
        _v16 = _t61;
        _v16->lastitem = 0;
         *_v16 = _v16->lastitem;
         *(_v16 + 12) = _v20;
        _v16->method = _v24;
         *(_v16 + 24) = _v32;
        _v16->enctype = _v28;
        _v16->target = target;
        _v16->name = name;
        _v16->next = _next;
        _v16->nitems = 0;
        _v16->body = 0;
        _v16->length = 0;
        return _v16;
    }
    _t61 = strcasecmp(method, "get");
    if(_t61 != 0) {
        _t61 = strcasecmp(method, "post");
        if(_t61 != 0) {
            _t61 = strcasecmp(method, "internal");
            if(_t61 == 0) {
                _v24 = 2;
            }
        } else {
            _v24 = 1;
        }
        goto L7;
    }
    goto L2;
}

struct form_item_list* formList_addInput(struct form_list* fl, struct parsed_tag* tag)
{// addr = 0x0808B750
    struct form_item_list* item;
    char* p;
    int i;
    struct form_item_list* _v16;
    char* _v20;
    signed int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    struct form_item_list* _t186;
    int _t210;
    int _t215;
    _unknown_ _t219;
    _unknown_ _t223;
    int _t226;
    _unknown_ _t255;
    _unknown_ _t264;
    _unknown_ _t274;
    _unknown_ _t338;

    if(fl == 0) {
        return 0;
    }
     *__esp = 72;
    GC_malloc();
    _v16 = _t186;
     *_v16 = -1;
    _v16->size = -1;
    _v16->rows = 0;
    _v16->init_checked = 0;
    _v16->checked = _v16->init_checked;
    _v16->accept = 0;
     *(_v16 + 4) = 0;
     *(_v16 + 12) = 0;
     *(_v16 + 8) =  *(_v16 + 12);
    _v16->readonly = 0;
    if(parsedtag_get_value(tag, 33,  &_v20) != 0) {
         *_v16 = formtype(_v20);
        if(_v16->size < 0) {
            if( *_v16 == 0 ||  *_v16 == 11 ||  *_v16 == 1) {
                _v16->size = 40;
            }
        }
    }
    if(parsedtag_get_value(tag, 25,  &_v20) != 0) {
         *(_v16 + 4) = Strnew_charp(_v20);
    }
    if(parsedtag_get_value(tag, 36,  &_v20) != 0) {
         *(_v16 + 12) = Strnew_charp(_v20);
         *(_v16 + 8) =  *(_v16 + 12);
    }
    if(tag->map == 0 || (tag->map[0xc] & 255 & 4294967295) == 75) {
L16:
        _t210 = 0;
    } else {
        if((tag->attrid[tag->map[0xc] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
            goto L16;
        } else {
            _t210 = 1;
        }
    }
L17:
    _v16->init_checked = _t210;
    _v16->checked = _v16->init_checked;
    if(tag->map == 0) {
L21:
        _t215 = 0;
        goto L22;
    }
    if((tag->map[1] & 255 & 4294967295) == 75 || (tag->attrid[tag->map[1] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
        goto L21;
    } else {
        _t215 = 1;
    }
L22:
    _v16->accept = _t215;
    parsedtag_get_value(tag, 30,  &(_v16->size));
    parsedtag_get_value(tag, 22,  &(_v16->maxlength));
    if(tag->map == 0 || (tag->map[0x2b] & 255 & 4294967295) == 75 || (tag->attrid[tag->map[0x2b] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
        _t226 = 0;
    } else {
        _t226 = 1;
    }
    _v16->readonly = _t226;
    if(parsedtag_get_value(tag, 73,  &_v24) != 0) {
         *(_v16 + 12) =  *(textarea_str + (_v24 << 2));
         *(_v16 + 8) =  *(_v16 + 12);
    }
    if(parsedtag_get_value(tag, 72,  &_v24) != 0) {
        _v16->select_option =  *(select_option + (_v24 << 3));
    }
    if(parsedtag_get_value(tag, 28,  &_v20) != 0) {
        _v16->rows = atoi(_v20);
    }
    if( *_v16 == 255) {
        return 0;
    }
    if( *_v16 == 8) {
        chooseSelectOption(_v16, _v16->select_option);
        _v16->init_selected = _v16->selected;
         *(_v16 + 12) =  *(_v16 + 8);
         *((intOrPtr*)(_v16 + 52)) =  *((intOrPtr*)(_v16 + 48));
    }
    if( *_v16 == 11 &&  *(_v16 + 8) != 0) {
        if( *(_v16 + 8)->length != 0) {
            return 0;
        }
    }
    _v16->parent = fl;
    _v16->next = 0;
    if(fl->item != 0) {
        fl->lastitem->next = _v16;
        fl->lastitem = _v16;
    } else {
        fl->lastitem = _v16;
        fl->item = fl->lastitem;
    }
    if( *_v16 == 6) {
        return 0;
    }
    fl->nitems =  &(fl->nitems->type);
    return _v16;
}

char* form2str(FormItemList* fi)
{// addr = 0x0808BB58
    Str tmp;
    struct _Str* _v16;
    intOrPtr _v36;
    char* _v40;
    intOrPtr _v44;
    char* _v48;
    intOrPtr _v52;
    char* _v56;
    _unknown_ __ebp;
    _unknown_ _t51;

    _v16 = Strnew();
    if(fi->type != 8) {
        if(fi->type != 9) {
            Strcat_charp(_v16, "input type=");
        }
    }
    Strcat_charp(_v16,  *( &_formtypetbl + fi->type * 4));
    if( *((intOrPtr*)(fi + 4)) != 0 &&  *((intOrPtr*)( *((intOrPtr*)(fi + 4)) + 4)) != 0) {
        _v44 = 0;
        _v48 = """;
        _v52 =  *((intOrPtr*)( *((intOrPtr*)(fi + 4))));
        _v56 = " name="";
        Strcat_m_charp(_v16);
    }
    if(fi->type == 3 || fi->type == 2 || fi->type == 8) {
        if( *((intOrPtr*)(fi + 8)) != 0) {
            _v44 = 0;
            _v48 = """;
            _v52 =  *((intOrPtr*)( *((intOrPtr*)(fi + 8))));
            _v56 = " value="";
            Strcat_m_charp(_v16);
        }
    }
    _v36 = 0;
    _v40 = ")";
    _v44 =  *((intOrPtr*)( *((intOrPtr*)(fi->parent + 12))));
    _v48 = " ";
    _v52 =  *((intOrPtr*)( &_formmethodtbl + fi->parent->method * 4));
    _v56 = " (";
    Strcat_m_charp(_v16);
    return  *_v16;
}

int formtype(char* typestr)
{// addr = 0x0808BC9A
    int i;
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t20;

    _v16 = 0;
    while( *( &_formtypetbl + _v16 * 4) != 0) {
        if(strcasecmp(typestr,  *( &_formtypetbl + _v16 * 4)) == 0) {
            return _v16;
        }
        _v16 = _v16 + 1;
    }
}

formRecheckRadio(Anchor* a, Buffer* buf, FormItemList* fi)
{// addr = 0x0808BCE4
    int i;
    Anchor* a2;
    FormItemList* f2;
    intOrPtr _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;

    _v16 = 0;
    while(buf->formitem->nanchor > _v16) {
        _v16 = _v16 + 1;
    }
}

formResetBuffer(Buffer* buf, AnchorList* formitem)
{// addr = 0x0808BDC2
    int i;
    Anchor* a;
    FormItemList* f1;
    FormItemList* f2;
    signed int _v16;
    Anchor* _v20;
    FormItemList* _v24;
    int* _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t93;
    AnchorList* _t97;
    char* _t125;
    signed int _t127;
    signed int _t128;
    _unknown_ _t163;
    char* _t174;
    _unknown_ _t175;

    if(buf == 0) {
        return ;
    }
    if(buf->formitem == 0) {
        return ;
    }
    if(formitem == 0) {
        return ;
    }
    _v16 = 0;
    while(1) {
        _t97 = buf->formitem;
        _t98 = _t97->nanchor;
        if(_t97->nanchor <= _v16) {
            break;
        }
        if(formitem->nanchor <= _v16) {
            return ;
        }
        _v20 = buf->formitem->anchors + (_v16 << 2 << 4) - (_v16 << 2);
        if((_v20->y & 65535 & 4294967295) !=  *((intOrPtr*)(_v20 + 20))) {
            goto L24;
        } else {
            _v24 =  *_v20;
            _v28 =  *(formitem->anchors + (_v16 << 2 << 4) - (_v16 << 2));
            _t98 =  *_v28;
            if( *_v24 !=  *_v28) {
                return ;
            }
            if(_v28[1] == 0) {
                _t174 = 135051758;
            } else {
                _t174 =  *(_v28[1]);
            }
            if( *(_v24 + 4) == 0) {
                _t125 = 135051758;
            } else {
                _t125 =  *( *(_v24 + 4));
            }
            if(strcmp(_t125, _t174) != 0) {
                return ;
            }
            _t127 =  *_v24;
            if(_t127 > 11) {
                goto L23;
            } else {
                _t128 = 1 << (_t127 & 4294967295);
                if((_t128 & 2563) != 0) {
                     *(_v24 + 8) = _v28[2];
                     *(_v24 + 12) = _v28[3];
                    goto L21;
                }
                if((_t128 & 256) != 0) {
                    _v24->select_option = _v28[0xb];
                     *(_v24 + 8) = _v28[2];
                     *(_v24 + 48) = _v28[0xc];
                    _v24->selected = _v28[0xe];
                     *(_v24 + 12) = _v28[3];
                     *(_v24 + 52) = _v28[0xd];
                    _v24->init_selected = _v28[0xf];
                    goto L21;
                }
                if((_t128 & 12) != 0) {
                    goto L19;
                }
                goto L24;
L21:
                formUpdateBuffer(_v20, buf, _v24);
                goto L24;
L19:
                _v24->checked = _v28[4];
                _v24->init_checked = _v28[5];
                goto L21;
            }
L24:
            _v16 = _v16 + 1;
            continue;
        }
L23:
        goto L24;
    }
    return;
}

int form_update_line(Line* line, char** str, int spos, int epos, int width, int newline, int password)
{// addr = 0x0808BFC3
    int c_len;
    int c_width;
    int w;
    int i;
    int len;
    int pos;
    char* p;
    char* buf;
    Lineprop c_type;
    Lineprop effect;
    Lineprop* prop;
    signed int _v14;
    signed int _v16;
    signed int _v20;
    signed int _v24;
    int _v28;
    int _v32;
    void* _v36;
    int _v40;
    char* _v44;
    void* _v48;
    void* _v52;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    void* _t307;
    void* _t309;
    _unknown_ _t312;
    _unknown_ _t316;
    _unknown_ _t338;
    _unknown_ _t345;
    signed int _t379;
    signed int _t414;
    signed int _t441;
    signed int* _t503;

    _v20 = 1;
    _v24 = 1;
    _v44 =  *str;
    _v28 = 0;
    _v40 = 0;
    while(( *_v44 & 255 & 4294967295) != 0) {
        if(_v28 < width) {
            _v14 = ( *( &WTF_TYPE_MAP + ( *_v44 & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 8 & 4294967295;
            _v20 =  *( &WTF_LEN_MAP + ( *_v44 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            if(( *135119023 & 255 & 4294967295) == 0) {
                _t441 =  *( &WTF_WIDTH_MAP + ( *_v44 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            } else {
                _t441 =  *( &WTF_WIDTH_MAP + ( *_v44 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            }
            _v24 = _t441;
            if(_v14 != 256) {
                if(password == 0) {
                    if((_v14 & 65535 & 4096) == 0) {
                        if(_v28 + _v24 > width) {
L22:
                            goto L23;
                        }
                        goto L15;
                    }
                    goto L13;
L15:
                    _v28 = _v28 + _v24;
                    _v40 = _v40 + _v20;
                    goto L16;
                }
                goto L10;
L13:
                _v28 = _v28 + 1;
                _v40 = _v40 + 1;
                goto L16;
            }
            if(newline == 0 || ( *_v44 & 255 & 4294967295) != 10) {
                if(( *_v44 & 255 & 4294967295) != 13) {
                    _v28 = _v28 + 1;
                    _v40 = _v40 + 1;
                }
L16:
                _v44 =  &(_v44[_v20]);
                continue;
            }
L23:
            _v40 = _v40 + width - _v28;
            _v36 = line->len + _v40 + spos - epos;
            _t307 = _v36;
             *__esp = _t307;
            GC_malloc();
            _v48 = _t307;
            _t309 = _v36 + _v36;
             *__esp = _t309;
            GC_malloc();
            _v52 = _t309;
            bcopy(line->lineBuf, _v48, spos);
            bcopy(line->propBuf, _v52, spos + spos);
            _v16 =  *(line->propBuf + spos + spos) & 65535 & 4294967295;
            _v44 =  *str;
            _v28 = 0;
            _v40 = spos;
            while(( *_v44 & 255 & 4294967295) != 0) {
                if(_v28 < width) {
                    _v14 = ( *( &WTF_TYPE_MAP + ( *_v44 & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 8 & 4294967295;
                    _v20 =  *( &WTF_LEN_MAP + ( *_v44 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                    if(( *135119023 & 255 & 4294967295) == 0) {
                        _t379 =  *( &WTF_WIDTH_MAP + ( *_v44 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                    } else {
                        _t379 =  *( &WTF_WIDTH_MAP + ( *_v44 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                    }
                    _v24 = _t379;
                    if(_v14 != 256) {
                        if(password == 0) {
                            if((_v14 & 65535 & 4096) == 0) {
                                if(_v28 + _v24 <= width) {
                                     *(_v48 + _v40) =  *_v44 & 255 & 4294967295;
                                     *((intOrPtr*)(_v40 + _v40 + _v52)) = (_v14 & 65535 | _v16 & 65535) & 4294967295;
                                    _v40 = _v40 + 1;
                                    _v14 = _v14 & 65535 & 4294967295;
                                    _v32 = 1;
L49:
                                    while(_v32 < _v20) {
                                        goto L48;
                                    }
                                }
                                goto L46;
L48:
                                 *(_v48 + _v40) = _v44[_v32] & 255 & 4294967295;
                                 *((intOrPtr*)(_v40 + _v40 + _v52)) = (_v14 & 65535 | _v16 & 65535) & 4294967295;
                                _v40 = _v40 + 1;
                                _v32 = _v32 + 1;
                                goto L49;
                            }
                            goto L44;
L46:
                            goto L55;
                        }
                        goto L37;
L44:
                         *(_v48 + _v40) = 32;
                         *((intOrPtr*)(_v40 + _v40 + _v52)) = _v16 & 65535 & 4294967295;
                        _v40 = _v40 + 1;
                        _v28 = _v28 + 1;
                        goto L51;
                    } else {
                        if(newline == 0 || ( *_v44 & 255 & 4294967295) != 10) {
                            if(( *_v44 & 255 & 4294967295) != 13) {
                                _t503 = _v48 + _v40;
                                if(password == 0) {
                                    _t414 = 32;
                                } else {
                                    _t414 = 42;
                                }
                                 *_t503 = _t414 & 4294967295;
                                 *((intOrPtr*)(_v40 + _v40 + _v52)) = _v16 & 65535 & 4294967295;
                                _v40 = _v40 + 1;
                                _v28 = _v28 + 1;
                            }
L51:
                            _v44 =  &(_v44[_v20]);
                            continue;
                        }
L55:
L57:
                        while(_v28 < width) {
                             *(_v48 + _v40) = 32;
                             *((intOrPtr*)(_v40 + _v40 + _v52)) = _v16 & 65535 & 4294967295;
                            _v40 = _v40 + 1;
                            _v28 = _v28 + 1;
                        }
                    }
L37:
                    if(_v28 + _v24 <= width) {
                        _v32 = 0;
L41:
                        while(_v32 < _v24) {
                            goto L40;
                        }
                    }
                    goto L55;
L40:
                     *(_v48 + _v40) = 42;
                     *(_v40 + _v40 + _v52) = _v16 & 65535 & 4294967295;
                    _v40 = _v40 + 1;
                    _v28 = _v28 + 1;
                    _v32 = _v32 + 1;
                    goto L41;
                }
                goto L57;
            }
L10:
            if(_v28 + _v24 > width) {
                goto L23;
            }
            _v28 = _v28 + _v24;
            _v40 = _v40 + _v24;
            goto L16;
        }
        goto L23;
    }
}

formUpdateBuffer(Anchor* a, Buffer* buf, FormItemList* form)
{// addr = 0x0808C4B8
    Buffer save;
    char* p;
    int spos;
    int epos;
    int rows;
    int c_rows;
    int pos;
    int col;
    Line* l;
    int n;
    char* _v32;
    int _v36;
    int _v40;
    int _v44;
    int _v48;
    int _v52;
    int _v56;
    struct _Line* _v60;
    intOrPtr _v64;
    struct _Buffer _v324;
    _unknown_ _v340;
    _unknown_ _v344;
    _unknown_ _v348;
    _unknown_ _v352;
    _unknown_ _v356;
    _unknown_ _v360;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int _t213;
    signed int _t221;
    signed int _t225;
    int _t237;
    _unknown_ _t326;
    _unknown_ _t342;
    _unknown_ _t355;
    _unknown_ _t372;

    _v56 = 0;
    copyBuffer( &_v324, buf);
    gotoLine(buf,  *(a + 20));
    _t213 = form->type;
    if(_t213 > 11 || (1 << (_t213 & 4294967295) & 2831) == 0) {
        _v36 =  *(a + 24) + 1;
        _v40 =  *(a + 36) - 1;
    } else {
        _v36 =  *(a + 24);
        _v40 =  *(a + 36);
    }
    _t221 = form->type;
    if(_t221 > 11) {
L40:
        copyBuffer(buf,  &_v324);
        arrangeLine(buf);
        return;
    } else {
        _t225 = 1 << (_t221 & 4294967295);
        if((_t225 & 2819) != 0) {
            if(form->type != 8) {
                _v32 =  *( *(form + 8));
            } else {
                _v32 =  *( *(form + 48));
                updateSelectOption(form, form->select_option);
            }
            _v60 = buf->currentLine;
            if(form->type != 9) {
L26:
                if(form->rows == 0) {
                    _t237 = 1;
                } else {
                    _t237 = form->rows;
                }
                _v44 = _t237;
                _v56 = calcPosition( *_v60, _v60->propBuf, _v60->len,  *(a + 24), 0, 0);
                _v48 = 0;
                while(_v48 < _v44) {
                    if(_v44 <= 1) {
L33:
                        _t246 = form->type;
                        _v52 = form_update_line(_v60,  &_v32, _v36, _v40, calcPosition( *_v60, _v60->propBuf, _v60->len, _v40, 0, 0) - _v56, form->type & 4294967295 & , _t246 & 4294967295 & );
                        if(_v52 != _v40) {
                            shiftAnchorPosition(buf->href, buf->hmarklist,  *(a + 20), _v36, _v52 - _v40);
                            shiftAnchorPosition(buf->name, buf->hmarklist,  *(a + 20), _v36, _v52 - _v40);
                            shiftAnchorPosition(buf->img, buf->hmarklist,  *(a + 20), _v36, _v52 - _v40);
                            shiftAnchorPosition(buf->formitem, buf->hmarklist,  *(a + 20), _v36, _v52 - _v40);
                        }
                        _v48 = _v48 + 1;
                        _v60 = _v60->next;
                        continue;
                    }
                    _v52 = columnPos(_v60, _v56);
                    a = retrieveAnchor(buf->formitem, _v60->linenumber, _v52);
                    if(a == 0) {
                        goto L39;
                    }
                    _v36 =  *(a + 24);
                    _v40 =  *(a + 36);
                    goto L33;
                }
            } else {
                _v64 = (a->y & 65535 & 4294967295) - buf->currentLine->linenumber;
                if(_v64 <= 0) {
                    if(_v64 >= 0) {
                        goto L25;
                    }
                    goto L21;
                }
                while(_v60 != 0) {
                    if(_v64 != 0) {
                        _v60 = _v60->prev;
                        _v64 = _v64 - 1;
                        continue;
                    }
L25:
                    if(_v60 == 0) {
                        goto L40;
                    }
                    goto L26;
L39:
                    goto L40;
                }
L21:
                while(_v60 != 0 && _v64 != 0) {
                    _v60 = _v60->prev;
                    _v64 = _v64 + 1;
                }
            }
        }
        if((_t225 & 12) != 0) {
            if(form->checked == 0) {
                buf->currentLine->lineBuf[_v36] = 32;
            } else {
                buf->currentLine->lineBuf[_v36] = 42;
            }
        }
        goto L40;
    }
}

Str textfieldrep(Str s, int width)
{// addr = 0x0808C8CE
    Lineprop c_type;
    Str n;
    int i;
    int j;
    int k;
    int c_len;
    signed short _v14;
    struct _Str* _v20;
    char _v24;
    char _v28;
    intOrPtr _v32;
    int _v36;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    signed int _t167;
    int _t199;
    int _t212;
    int _t226;

    _v20 = Strnew_size(width + 2);
    _v28 = 0;
    _v24 = 0;
    while(s->length > _v24) {
        _v14 = ( *( &WTF_TYPE_MAP + (s->ptr[_v24] & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 8 & 4294967295;
        _v36 =  *( &WTF_LEN_MAP + (s->ptr[_v24] & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        if((s->ptr[_v24] & 255 & 4294967295) != 13) {
            if(( *135119023 & 255 & 4294967295) == 0) {
                _t167 =  *( &WTF_WIDTH_MAP + (s->ptr[_v24] & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            } else {
                _t167 =  *( &WTF_WIDTH_MAP + (s->ptr[_v24] & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            }
            _v32 = _t167 + _v28;
            if(_v32 <= width) {
                if(_v14 != 256) {
                    if((_v14 & 65535 & 4096) == 0) {
                        if((s->ptr[_v24] & 255 & 4294967295) != 38) {
                            if((s->ptr[_v24] & 255 & 4294967295) != 60) {
                                if((s->ptr[_v24] & 255 & 4294967295) != 62) {
                                    Strcat_charp_n(_v20,  &(s->ptr[_v24]), _v36);
                                } else {
                                    Strcat_charp(_v20, "&gt;");
                                }
                            } else {
                                Strcat_charp(_v20, "&lt;");
                            }
                        } else {
                            Strcat_charp(_v20, "&amp;");
                        }
                    } else {
                        if(_v20->length + 1 >= _v20->area_size) {
                            Strgrow(_v20);
                        }
                        _t199 = _v20->length;
                         *((char*)( *_v20 + _t199)) = 32;
                        _v20->length = _t199 + 1;
                         *((char*)( *_v20 + _v20->length)) = 0;
                    }
                } else {
                    if(_v20->length + 1 >= _v20->area_size) {
                        Strgrow(_v20);
                    }
                    _t212 = _v20->length;
                     *((char*)( *_v20 + _t212)) = 32;
                    _v20->length = _t212 + 1;
                     *((char*)( *_v20 + _v20->length)) = 0;
                }
                _v28 = _v32;
                goto L24;
            }
            while(_v28 < width) {
                if(_v20->length + 1 >= _v20->area_size) {
                    Strgrow(_v20);
                }
                _t226 = _v20->length;
                 *((char*)( *_v20 + _t226)) = 32;
                _v20->length = _t226 + 1;
                 *((char*)( *_v20 + _v20->length)) = 0;
                _v28 = _v28 + 1;
            }
        }
L24:
        _v24 = _v24 + _v36;
    }
}

form_fputs_decode(Str s, FILE* f)
{// addr = 0x0808CB78
    char* p;
    Str z;
    char* _v16;
    struct _Str* _v20;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t43;
    int _t58;
    _unknown_ _t75;

    _v20 = Strnew();
    _v16 = s->ptr;
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *_v16 & 255 & 4294967295) == 13 && (_v16[1] & 255 & 4294967295) == 10) {
            _v16 =  &(_v16[1]);
        }
        if(_v20->length + 1 >= _v20->area_size) {
            Strgrow(_v20);
        }
        _t58 = _v20->length;
         *( *_v20 + _t58) =  *_v16 & 255 & 4294967295;
        _v20->length = _t58 + 1;
         *((char*)( *_v20 + _v20->length)) = 0;
        _v16 =  &(_v16[1]);
    }
}

input_textarea(FormItemList* fi)
{// addr = 0x0808CC57
    char* tmpf;
    Str tmp;
    FILE* f;
    wc_ces charset;
    wc_uint8 auto_detect;
    signed char _v13;
    char* _v20;
    struct _Str* _v24;
    FILE* _v28;
    unsigned int _v32;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t73;
    _unknown_ _t82;
    _unknown_ _t86;
    _unknown_ _t130;
    _unknown_ _t132;

    _v20 =  *(tmpfname(0, 0));
    _v32 = DisplayCharset;
    _v28 = fopen(_v20, "w");
    if(_v28 == 0) {
        disp_err_message("Can't open temporary file", 0);
        return;
    }
    if( *(fi + 8) != 0) {
        form_fputs_decode( *(fi + 8), _v28);
    }
    fclose(_v28);
    fmTerm();
    system( *(myEditor(Editor, _v20, 1)));
    fmInit();
    if(fi->readonly != 0) {
        goto L19;
    }
    _v28 = fopen(_v20, "r");
    if(_v28 != 0) {
         *(fi + 8) = Strnew();
        _v13 = WcOption.marks & 255 & 4294967295;
        WcOption.marks = 2;
        while(1) {
L16:
            _v24 = Strfgets(_v28);
            if(_v24->length <= 0) {
                break;
            }
            goto L8;
        }
        WcOption.marks = _v13 & 255 & 4294967295;
        fclose(_v28);
        goto L19;
    }
    disp_err_message("Can't open temporary file", 0);
    goto L19;
L8:
    if(_v24->length != 1 || ( *( *_v24 + _v24->length - 1) & 255 & 4294967295) != 10) {
        if(_v24->length > 1 && ( *( *_v24 + _v24->length - 1) & 255 & 4294967295) == 10 && ( *( *_v24 + _v24->length - 2) & 255 & 4294967295) != 13) {
            Strshrink(_v24, 1);
            Strcat_charp(_v24, "\n");
        }
    } else {
        _v24 = Strnew_charp("\n");
    }
    _v24 = convertLine(0, _v24, 0,  &_v32, DisplayCharset);
    Strcat( *(fi + 8), _v24);
    goto L16;
L19:
    unlink(_v20);
    return;
}

do_internal(char* action, char* data)
{// addr = 0x0808CE8B
    int i;
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = 0;
    while( *( &internal_action + _v16 * 8) != 0) {
        if(strcasecmp( *( &internal_action + _v16 * 8), action) != 0) {
            _v16 = _v16 + 1;
            continue;
        }
        if( *((intOrPtr*)(135091940 + _v16 * 8)) == 0) {
            return ;
        }
         *__esp = cgistr2tagarg(data);
         *((intOrPtr*)( *((intOrPtr*)(135091940 + _v16 * 8))))();
        return;
    }
}

addSelectOption(FormSelectOption* fso, Str value, Str label, int chk)
{// addr = 0x0808CEFD
    FormSelectOptionItem* o;
    FormSelectOptionItem* _v16;
    _unknown_ __ebp;

     *__esp = 16;
    GC_malloc();
    _v16 = __eax;
    if(value == 0) {
        value = label;
    }
     *_v16 = value;
    Strremovefirstspaces(label);
    Strremovetrailingspaces(label);
     *(_v16 + 4) = label;
    _v16->checked = chk;
    _v16->next = 0;
    if(fso->first != 0) {
        fso->last->next = _v16;
        fso->last = _v16;
        return;
    }
    fso->last = _v16;
    fso->first = fso->last;
    return;
}

chooseSelectOption(FormItemList* fi, FormSelectOptionItem* item)
{// addr = 0x0808CF8E
    FormSelectOptionItem* opt;
    int i;
    struct form_select_option_item* _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    fi->selected = 0;
    if(item != 0) {
         *(fi + 8) = item->value;
         *(fi + 48) =  *(item + 4);
        _v20 = 0;
        _v16 = item;
L6:
        while(_v16 != 0) {
            goto L3;
        }
    }
     *(fi + 8) = Strnew_size(0);
     *(fi + 48) = Strnew_size(0);
    return;
L3:
    if(_v16->checked == 0) {
        _v20 = _v20 + 1;
        _v16 = _v16->next;
        goto L6;
    }
     *(fi + 8) =  *_v16;
     *(fi + 48) =  *(_v16 + 4);
    fi->selected = _v20;
    updateSelectOption(fi, item);
    return;
}

updateSelectOption(FormItemList* fi, FormSelectOptionItem* item)
{// addr = 0x0808D043
    int i;
    int _v8;
    _unknown_ __ebp;

    if(fi == 0) {
        return ;
    }
    if(item == 0) {
        return ;
    }
    _v8 = 0;
    while(item != 0) {
        if(fi->selected != _v8) {
            item->checked = 0;
        } else {
            item->checked = 1;
        }
        _v8 = _v8 + 1;
        item = item->next;
    }
}

int formChooseOptionByMenu(struct form_item_list* fi, int x, int y)
{// addr = 0x0808D09A
    int i;
    int n;
    int selected;
    int init_select;
    FormSelectOptionItem* opt;
    char** label;
    _unknown_ _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    int _v28;
    struct form_select_option_item* _v32;
    _unknown_ _v36;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t78;
    _unknown_ _t103;
    _unknown_ _t109;

    _v24 = -1;
    _v28 = fi->selected;
    _v20 = 0;
    _v32 = fi->select_option;
    while(_v32 != 0) {
        _v20 = _v20 + 1;
        _v32 = _v32->next;
    }
}

form_write_data(FILE* f, char* boundary, char* name, char* value)
{// addr = 0x0808D1D8
    char* _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t15;
    _unknown_ _t18;
    _unknown_ _t21;

    _v20 = boundary;
    fprintf(f, "--%s\n");
    _v20 = name;
    fprintf(f, "Content-Disposition: form-data; name="%s"\n\n");
    _v20 = value;
    fprintf(f, "%s\n");
    return;
}

form_write_from_file(FILE* f, char* boundary, char* name, char* filename, char* file)
{// addr = 0x0808D231
    FILE* fd;
    struct stat st;
    int c;
    char* type;
    struct _IO_FILE* _v16;
    int _v20;
    char* _v24;
    signed int _v96;
    char _v112;
    char* _v128;
    char* _v132;
    _unknown_ _v136;
    _unknown_ __ebp;
    _unknown_ _t39;
    _unknown_ _t44;
    char* _t47;
    _unknown_ _t49;
    char* _t50;
    _unknown_ _t52;
    _unknown_ _t61;
    _unknown_ _t63;

    _v132 = boundary;
    fprintf(f, "--%s\n");
    _v128 = mybasename(filename);
    _v132 = name;
    fprintf(f, "Content-Disposition: form-data; name="%s"; filename="%s"\n");
    _v24 = guessContentType(file);
    if(_v24 == 0) {
        _t47 = "application/octet-stream";
    } else {
        _t47 = _v24;
    }
    _v132 = _t47;
    fprintf(f, "Content-Type: %s\n\n");
    _t50 = file;
    L080C7300(_t50,  &_v112);
    if(_t50 < 0) {
        if((_v96 & 61440) != 16384) {
            _v16 = fopen(file, "r");
            if(_v16 != 0) {
                while(1) {
                    _v20 = fgetc(_v16);
                    if(_v20 == 255) {
                        break;
                    }
                    fputc(_v20, f);
                }
                fclose(_v16);
            }
L13:
        }
    }
    fwrite("\n", 1, 2, f);
    return;
    goto L13;
}

struct pre_form* add_pre_form(struct pre_form* prev, char* url, char* name, char* action)
{// addr = 0x0808D356
    ParsedURL pu;
    struct pre_form* new;
    int l;
    struct pre_form* _v16;
    int _v20;
    struct _ParsedURL _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    struct pre_form* _t60;
    char* _t62;
    char* _t63;

    _t60 = __eax;
    if(prev == 0) {
         *__esp = 24;
        GC_malloc();
        PreForm = _t60;
        _v16 = PreForm;
    } else {
         *__esp = 24;
        GC_malloc();
        prev->next = _t60;
        _v16 = prev->next;
    }
    if(url == 0 || ( *url & 255 & 4294967295) != 47) {
        if(url != 0) {
            parseURL2(url,  &_v60, 0);
             *_v16 =  *(parsedURL2Str( &_v60));
            _v16->re_url = 0;
        }
    } else {
        _v20 = strlen(url);
        if(_v20 <= 1 || ( *(_v20 - 1 + url) & 255 & 4294967295) != 47) {
             *_v16 =  &(url[1]);
        } else {
             *_v16 = allocStr( &(url[1]), _v20 - 2);
        }
        _v16->re_url = newRegex( *_v16, 0, 0, 0);
        if(_v16->re_url == 0) {
             *_v16 = 0;
        }
    }
    if(name == 0 || ( *name & 255 & 4294967295) == 0) {
        _t62 = 0;
    } else {
        _t62 = name;
    }
    _v16->name = _t62;
    if(action == 0 || ( *action & 255 & 4294967295) == 0) {
        _t63 = 0;
    } else {
        _t63 = action;
    }
    _v16->action = _t63;
    _v16->item = 0;
    _v16->next = 0;
    return _v16;
}

struct pre_form_item* add_pre_form_item(struct pre_form* pf, struct pre_form_item* prev, int type, char* name, char* value, char* checked)
{// addr = 0x0808D4D8
    struct pre_form_item* new;
    struct pre_form_item* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    struct pre_form_item* _t37;
    _unknown_ _t59;

    if(pf == 0) {
        return 0;
    }
    if(prev == 0) {
         *__esp = 20;
        GC_malloc();
        pf->item = _t37;
        _v16 = pf->item;
    } else {
         *__esp = 20;
        GC_malloc();
        prev->next = _t37;
        _v16 = prev->next;
    }
     *_v16 = type;
    _v16->name = name;
    _v16->value = value;
    if(checked == 0 || ( *checked & 255 & 4294967295) == 0 || strcmp(checked, "0") != 0 && strcasecmp(checked, "off") == 0 && strcasecmp(checked, "no") != 0) {
        _v16->checked = 1;
    } else {
        _v16->checked = 0;
    }
    _v16->next = 0;
    return _v16;
}

loadPreForm()
{// addr = 0x0808D5C4
    FILE* fp;
    Str line;
    Str textarea;
    struct pre_form* pf;
    struct pre_form_item* pi;
    int type;
    char* name;
    char* p;
    char* s;
    char* arg;
    struct pre_form* prev;
    FILE* _v16;
    struct _Str* _v20;
    struct _Str* _v24;
    struct pre_form* _v28;
    struct _Str _v40;
    char* _v44;
    char* _v48;
    char* _v52;
    struct pre_form* _v56;
    _unknown_ _v72;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    char* _t239;
    _unknown_ _t279;

    _v20 = 0;
    _v24 = 0;
    _v28 = 0;
    _v40.area_size = 0;
    _v40.length = -1;
    _v40.ptr = 0;
    PreForm = 0;
    _v16 = openSecretFile(pre_form_file);
    if(_v16 == 0) {
        return ;
    }
    while(1) {
        _v20 = Strfgets(_v16);
        if(_v20->length == 0) {
            fclose(_v16);
            return;
        }
L3:
        if(_v24 != 0) {
            break;
        }
L7:
        Strchop(_v20);
        Strremovefirstspaces(_v20);
        _v44 =  *_v20;
        if(( *_v44 & 255 & 4294967295) == 35 || ( *_v44 & 255 & 4294967295) == 0) {
L57:
            continue;
        } else {
            _v48 = getWord( &_v44);
            _v52 = getWord( &_v44);
            if(strcmp(_v48, "url") != 0) {
                if(_v28 != 0) {
                    if(strcmp(_v48, "form") != 0) {
                        if(strcmp(_v48, "text") != 0) {
                            if(strcmp(_v48, "file") != 0) {
                                if(strcmp(_v48, "passwd") == 0 || strcmp(_v48, "password") == 0) {
                                    _v40.length = 1;
                                    goto L56;
                                }
                                if(strcmp(_v48, "checkbox") != 0) {
                                    if(strcmp(_v48, "radio") != 0) {
                                        if(strcmp(_v48, "submit") != 0) {
                                            if(strcmp(_v48, "image") != 0) {
                                                if(strcmp(_v48, "select") != 0) {
                                                    if(strcmp(_v48, "textarea") != 0) {
                                                        if(_v24 != 0 && _v40.ptr != 0 && strcmp(_v48, "/textarea") == 0) {
                                                            _v40.area_size = add_pre_form_item(_v28, _v40.area_size, _v40.length, _v40.ptr,  *_v24, 0);
                                                            _v24 = 0;
                                                            _v40.ptr = 0;
                                                        }
                                                    } else {
                                                        _v40.length = 9;
                                                        _v40 =  *(Strnew_charp(_v52));
                                                        _v24 = Strnew();
                                                    }
                                                    goto L57;
                                                }
                                                goto L48;
                                            }
                                            goto L46;
L48:
                                            _v40.length = 8;
                                            goto L56;
                                        }
                                        goto L44;
L46:
                                        _v40.length = 7;
                                        goto L56;
                                    }
                                    goto L42;
L44:
                                    _v40.length = 4;
                                    goto L56;
                                }
                                _v40.length = 2;
                                goto L56;
L42:
                                _v40.length = 3;
                                goto L56;
                            }
                            goto L35;
                        }
                        _v40.length = 0;
L56:
                        _v48 = getQWord( &_v44);
                        _v40.area_size = add_pre_form_item(_v28, _v40.area_size, _v40.length, _v52, _v48, getQWord( &_v44));
                        while(1) {
                            _v20 = Strfgets(_v16);
                            if(_v20->length == 0) {
                                fclose(_v16);
                                return;
                            }
L3:
                            if(_v24 != 0) {
                                break;
                            }
                        }
L35:
                        _v40.length = 11;
                        goto L56;
                    } else {
                        if(_v52 != 0 && ( *_v52 & 255 & 4294967295) != 0) {
                            if(_v28->item == 0) {
                                _v28->name = _v48;
                                if(_v44 == 0 || ( *_v44 & 255 & 4294967295) == 0) {
                                    _t239 = 0;
                                } else {
                                    _t239 = _v44;
                                }
                                _v28->action = _t239;
                            } else {
                                _v56 = _v28;
                                _v28 = add_pre_form(_v56, 135051758, _v48, _v44);
                                 *_v28 =  *_v56;
                                _v28->re_url = _v56->re_url;
                            }
                            _v40.area_size = _v28->item;
                        }
                    }
                }
                goto L57;
            }
            if(_v52 == 0) {
L13:
                goto L57;
            }
            if(( *_v52 & 255 & 4294967295) != 0) {
                _v44 = getQWord( &_v44);
                _v28 = add_pre_form(_v28, _v52, 0, _v44);
                _v40.area_size = _v28->item;
                goto L57;
            }
            goto L13;
        }
L58:
        return ;
    }
    if(strncmp( *_v20, "/textarea", 9) != 0 || ( *( &MYCTYPE_MAP + ( *( *_v20 + 9) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
        Strcat(_v24, _v20);
        goto L57;
    } else {
        goto L7;
    }
    goto L58;
}

preFormUpdateBuffer(Buffer* buf)
{// addr = 0x0808DA7C
    struct pre_form* pf;
    struct pre_form_item* pi;
    int i;
    Anchor* a;
    FormList* fl;
    FormItemList* fi;
    FormSelectOptionItem* opt;
    int j;
    Str url;
    struct _anchor _v36;
    struct _Str* _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t110;
    _unknown_ _t190;

    if(buf == 0) {
        return ;
    }
    if(buf->formitem == 0) {
        return ;
    }
    if(PreForm == 0) {
        return ;
    }
    _v36.start = PreForm;
    while(_v16 != 0) {
        if(_v16->re_url == 0) {
            if( *_v16 == 0) {
                goto L54;
            }
            goto L8;
L53:
            goto L54;
        }
        _v48 = parsedURL2Str(buf + 132);
        if(RegexMatch(_v16->re_url,  *_v48, _v48->length, 1) != 0) {
L9:
            _v36.title = 0;
L50:
            while(buf->formitem->nanchor > _v24) {
                goto L10;
            }
        } else {
L54:
            _v36.start = _v36.start->next;
            continue;
        }
L10:
        _v36.referer = buf->formitem->anchors + (_v36.title << 2 << 4) - (_v36.title << 2);
        _v36.url =  *(_v36.referer);
        _v36.target = _v36.url[0x40];
        if(_v16->name == 0) {
L13:
            if(_v16->action == 0) {
L16:
                _v36.accesskey = _v36.start->item;
L43:
                while(_v20 != 0) {
                    goto L17;
                }
            }
            goto L14;
L17:
            if( *_v20 !=  *(_v36.url)) {
                goto L42;
            }
            if( *_v20 == 4 ||  *_v20 == 7) {
                if(_v20->name == 0 || ( *(_v20->name) & 255 & 4294967295) == 0) {
L24:
                    if(_v20->value == 0 || ( *(_v20->value) & 255 & 4294967295) == 0) {
L28:
                        buf->submit = _v36.referer;
L42:
                        _v36.accesskey = _v36.accesskey->next;
                        goto L43;
                    }
                    if(_v36.url[8] == 0) {
L37:
                        goto L42;
                    }
                    if(strcmp( *((char**)(_v36.url[8])), _v20->value) != 0) {
                        goto L42;
                    }
                    goto L28;
L39:
                    goto L42;
                }
                if(_v36.url[4] == 0) {
                    goto L35;
                }
                if(strcmp( *(_v36.url[4]), _v20->name) != 0) {
                    goto L42;
                }
                goto L24;
            }
            if(_v20->name == 0) {
                goto L39;
            }
            if(_v36.url[4] == 0) {
                goto L40;
            }
            if(strcmp( *( *(_v36 + 4)), _v20->name) != 0) {
                goto L41;
            } else {
                if( *_v20 > 11) {
                    goto L42;
                } else {
                    goto __eax;
                }
            }
            goto L42;
L41:
            goto L42;
L40:
            goto L42;
L35:
            goto L42;
        }
        if( *(_v32 + 20) == 0) {
L49:
            _v36.title = _v36.title + 1;
            goto L50;
        }
        if(strcmp( *(_v32 + 20), _v16->name) != 0) {
            goto L49;
        }
        goto L13;
L47:
        goto L49;
L14:
        if( *((intOrPtr*)(_v32 + 12)) == 0) {
            goto L47;
        }
        if(strcmp( *( *(_v32 + 12)), _v16->action) != 0) {
            goto L49;
        }
        goto L16;
L8:
        if(strcmp( *(parsedURL2Str(buf + 132)),  *_v16) != 0) {
            goto L53;
        }
        goto L9;
    }
}

MapList* searchMapList(Buffer* buf, char* name)
{// addr = 0x0808DF40
    MapList* ml;
    struct _MapList* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t22;

    if(name == 0) {
        return 0;
    }
    _v16 = buf->maplist;
    while(_v16 != 0) {
        if(strcmp( *( *_v16), name) == 0) {
            return _v16;
        }
        _v16 = _v16->next;
    }
}

int inMapArea(MapArea* a, int x, int y)
{// addr = 0x0808DF8F
    int i;
    double r1;
    double r2;
    double s;
    double c;
    double t;
    int _v16;
    intOrPtr _v64;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t125;
    MapArea* _t126;
    _unknown_ _t129;
    MapArea* _t130;
    MapArea* _t134;
    MapArea* _t138;
    _unknown_ _t142;
    signed int _t159;
    signed int _t163;
    MapArea* _t164;
    _unknown_ _t169;
    signed int _t171;
    _unknown_ _t252;
    _unknown_ _t253;
    _unknown_ _t254;
    _unknown_ _t255;
    signed int _t290;

    __eflags = a;
    if(a == 0) {
        return 0;
    }
    _t125 = a->shape & 255 & 4294967295;
    __eflags = _t125 - 2;
    if(_t125 == 2) {
        _t126 = a;
        asm("cwde ");
        __eflags = (_t126 & 65535) - x;
        if((_t126 & 65535) > x) {
            return 0;
        }
        _t130 = a;
        asm("cwde ");
        __eflags = (_t130->coords[1] & 65535) - y;
        if((_t130->coords[1] & 65535) > y) {
            return 0;
        }
        _t134 = a;
        asm("cwde ");
        __eflags = (_t134->coords[2] & 65535) - x;
        if((_t134->coords[2] & 65535) >= x) {
            _t138 = a;
            asm("cwde ");
            __eflags = (_t138->coords[3] & 65535) - y;
            if((_t138->coords[3] & 65535) >= y) {
                return 1;
            }
            return 0;
        }
        return 0;
    } else {
        __eflags = _t125 - 2;
        if(_t125 > 2) {
            __eflags = _t125 - 3;
            if(_t125 == 3) {
                asm("cwde ");
                asm("cwde ");
                _t290 = (x - (a & 65535)) * (x - (a & 65535));
                asm("cwde ");
                asm("cwde ");
                _t159 = (y - (a->coords[1] & 65535)) * (y - (a->coords[1] & 65535));
                _t163 = a->coords[2] & 65535;
                _t164 = a;
                asm("cwde ");
                __eflags = _t290 + _t159 - (_t164->coords[2] & 65535) * (_t163 & 4294967295);
                if(_t290 + _t159 > (_t164->coords[2] & 65535) * (_t163 & 4294967295)) {
                    return 0;
                }
                return 1;
            }
            goto L7;
        }
        __eflags = _t125 - 1;
        if(_t125 == 1) {
            return 1;
        }
        return 0;
L7:
        __eflags = _t125 - 4;
        if(_t125 != 4) {
            return 0;
        }
        asm("fldz ");
        asm("fstp qword [ebp-0x38]");
        _v16 = 0;
        while(1) {
            _t171 = a->ncoords;
            __eflags = _t171 - _v16;
            if(__eflags <= 0) {
                break;
            }
            asm("cwde ");
            _v64 = x - ( *(a->coords + _v16 + _v16) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = x - ( *(a->coords + _v16 + _v16) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("cwde ");
            _v64 = y - ( *(a->coords + _v16 + 1 + _v16 + 1) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = y - ( *(a->coords + _v16 + 1 + _v16 + 1) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("faddp st1, st0");
            asm("fld st0, st0");
            asm("fsqrt ");
            asm("fucomi st0, st0");
            if(__eflags != 0) {
                asm("fstp st0");
                goto L21;
            }
            if(__eflags == 0) {
                asm("fstp st1");
                goto L23;
            }
            asm("fstp st0");
            goto L21;
L23:
            asm("fstp qword [ebp-0x18]");
            asm("cwde ");
            _v64 = x - ( *(a->coords + _v16 + 2 + _v16 + 2) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = x - ( *(a->coords + _v16 + 2 + _v16 + 2) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("cwde ");
            _v64 = y - ( *(a->coords + _v16 + 3 + _v16 + 3) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = y - ( *(a->coords + _v16 + 3 + _v16 + 3) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("faddp st1, st0");
            asm("fstp qword [esp]");
            sqrt();
            asm("fstp qword [ebp-0x20]");
            asm("fld qword [ebp-0x18]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if(__eflags == 0) {
                if(__eflags == 0) {
                    return 1;
                }
            }
            asm("fld qword [ebp-0x20]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if(__eflags == 0) {
                if(__eflags == 0) {
                    return 1;
                }
            }
            asm("cwde ");
            _v64 = x - ( *(a->coords + _v16 + _v16) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = y - ( *(a->coords + _v16 + 3 + _v16 + 3) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("cwde ");
            _v64 = x - ( *(a->coords + _v16 + 2 + _v16 + 2) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = y - ( *(a->coords + _v16 + 1 + _v16 + 1) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("fsubp st1, st0");
            asm("fdiv qword [ebp-0x18]");
            asm("fdiv qword [ebp-0x20]");
            asm("fstp qword [ebp-0x28]");
            asm("cwde ");
            _v64 = x - ( *(a->coords + _v16 + _v16) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = x - ( *(a->coords + _v16 + 2 + _v16 + 2) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("cwde ");
            _v64 = y - ( *(a->coords + _v16 + 1 + _v16 + 1) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("cwde ");
            _v64 = y - ( *(a->coords + _v16 + 3 + _v16 + 3) & 65535);
            asm("fild dword [ebp-0x3c]");
            asm("fmulp st1, st0");
            asm("faddp st1, st0");
            asm("fdiv qword [ebp-0x18]");
            asm("fdiv qword [ebp-0x20]");
            asm("fstp qword [ebp-0x30]");
            asm("fld qword [ebp-0x30]");
            asm("fstp qword [esp+0x8]");
            asm("fld qword [ebp-0x28]");
            asm("fstp qword [esp]");
            atan2();
            asm("fld qword [ebp-0x38]");
            asm("faddp st1, st0");
            asm("fstp qword [ebp-0x38]");
            _v16 = _v16 + 2;
            continue;
L21:
            asm("fstp qword [esp]");
            sqrt();
            goto L23;
        }
        asm("fld qword [ebp-0x38]");
        asm("fabs ");
        asm("fld qword [0x80cc020]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        __eflags = _t171 & 4294967295;
        if((_t171 & 4294967295) == 0) {
            return 0;
        }
        return 1;
    }
}

int nearestMapArea(MapList* ml, int x, int y)
{// addr = 0x0808E3E5
    ListItem* al;
    MapArea* a;
    int i;
    int l;
    int n;
    int min;
    int limit;
    struct _listitem* _v8;
    _unknown_ _v12;
    intOrPtr _v16;
    _unknown_ _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    _unknown_ _v32;
    signed short _v38;
    signed int _v40;
    _unknown_ __ebp;

    _v24 = -1;
    _v28 = -1;
    asm("fld qword [0x80d53a0]");
    asm("fld qword [0x80d53a0]");
    asm("fmulp st1, st0");
    asm("fld qword [0x80d53a8]");
    asm("fld qword [0x80d53a8]");
    asm("fmulp st1, st0");
    asm("faddp st1, st0");
    asm("fnstcw word [ebp-0x22]");
    _v40 = _v38 & 65535 & 4294967295;
    asm("fldcw word [ebp-0x24]");
    asm("fistp dword [ebp-0x1c]");
    asm("fldcw word [ebp-0x22]");
    if(ml == 0) {
        return _v24;
    }
    if(ml->area == 0) {
        return _v24;
    }
    _v16 = 0;
    _v8 = ml->area->first;
    while(_v8 != 0) {
        _v16 = _v16 + 1;
        _v8 = _v8->next;
    }
}

int searchMapArea(Buffer* buf, MapList* ml, Anchor* a_img)
{// addr = 0x0808E4DD
    ListItem* al;
    MapArea* a;
    int i;
    int n;
    int px;
    int py;
    struct _listitem* _v16;
    _unknown_ _v20;
    intOrPtr _v24;
    signed int _v28;
    int _v32;
    int _v36;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t61;
    _unknown_ _t105;

    if(ml == 0) {
        return -1;
    }
    if(ml->area == 0) {
        return -1;
    }
    if((ml->area->nitem & 65535 & 4294967295) == 0) {
        return -1;
    }
    if(getMapXY(buf, a_img,  &_v32,  &_v36) == 0) {
        return -1;
    }
    asm("cwde ");
    _v28 =  ~(ml->area->nitem & 65535);
    _v24 = 0;
    _v16 = ml->area->first;
    while(_v16 != 0) {
        _v24 = _v24 + 1;
        _v16 = _v16->next;
    }
}

MapArea* retrieveCurrentMapArea(Buffer* buf)
{// addr = 0x0808E611
    Anchor* a_img;
    Anchor* a_form;
    FormItemList* fi;
    MapList* ml;
    ListItem* al;
    MapArea* a;
    int i;
    int n;
    struct _anchor _v24;
    struct _listitem _v36;
    char* _v40;
    int _v44;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t56;
    _unknown_ _t64;
    _unknown_ _t69;
    char* _t80;
    _unknown_ _t94;
    _unknown_ _t97;
    _unknown_ _t98;

    _v24.referer = retrieveCurrentImg(buf);
    if(_v16 == 0) {
        return 0;
    }
    if(_v16->image == 0) {
        return 0;
    }
    if(_v16->image->map == 0) {
        return 0;
    }
    _v24.target = retrieveCurrentForm(buf);
    if(_v20 == 0) {
        return 0;
    }
    if( *_v20 == 0) {
        return 0;
    }
    _v24.url =  *(_v24.target);
    if(_v24.url == 0) {
        return 0;
    }
    if(_v24.url[0x40] == 0) {
        return 0;
    }
    if( *(_v24.url[0x40]) == 0) {
        return 0;
    }
    _v24.url =  *(_v24.url[0x40]);
    if(_v24.url[8] == 0) {
        _t80 = 0;
    } else {
        _t80 =  *( *(_v24 + 8));
    }
    _v36.prev = searchMapList(buf, _t80);
    if(_v28 == 0) {
        return 0;
    }
    _v44 = searchMapArea(buf, _v36.prev, _v24.referer);
    if(_v44 < 0) {
        return 0;
    }
    _v40 = 0;
    _v36.next = _v36.prev->area->first;
    while(_v32 != 0) {
        _v36.ptr =  *(_v36.next);
        if(_v36.ptr != 0) {
            if(_v40 == _v44) {
                return _v36;
            }
        }
        _v40 =  &(_v40[1]);
        _v36.next = _v36.next->next;
    }
}

int getMapXY(Buffer* buf, Anchor* a, int* x, int* y)
{// addr = 0x0808E756
    intOrPtr _v16;
    signed short _v18;
    signed int _v20;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t53;
    _unknown_ _t88;

    if(buf == 0) {
        return 0;
    }
    if(a == 0) {
        return 0;
    }
    if(a->image == 0) {
        return 0;
    }
    if(x == 0) {
        return 0;
    }
    if(y == 0) {
        return 0;
    }
    asm("cwde ");
    _v16 = buf->currentColumn + (buf->cursorX & 65535) - calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len,  *(a + 24), 0, 0);
    asm("fild dword [ebp-0xc]");
    asm("fld qword [0x80cc028]");
    asm("faddp st1, st0");
    asm("fld qword [0x80d53a0]");
    asm("fmulp st1, st0");
    asm("fnstcw word [ebp-0xe]");
    _v20 = _v18 & 65535 & 4294967295;
    asm("fldcw word [ebp-0x10]");
    asm("fistp dword [ebp-0xc]");
    asm("fldcw word [ebp-0xe]");
    asm("cwde ");
     *x = _v16 - (a->image->xoffset & 65535);
    asm("cwde ");
    _v16 = buf->currentLine->linenumber - (a->image->y & 65535);
    asm("fild dword [ebp-0xc]");
    asm("fld qword [0x80cc028]");
    asm("faddp st1, st0");
    asm("fld qword [0x80d53a8]");
    asm("fmulp st1, st0");
    asm("fldcw word [ebp-0x10]");
    asm("fistp dword [ebp-0xc]");
    asm("fldcw word [ebp-0xe]");
    asm("cwde ");
     *y = _v16 - (a->image->yoffset & 65535);
    if( *x <= 0) {
         *x = 1;
    }
    if( *y > 0) {
        return 1;
    }
     *y = 1;
    return 1;
}

Anchor* retrieveCurrentMap(Buffer* buf)
{// addr = 0x0808E8A4
    Anchor* a;
    FormItemList* fi;
    struct _anchor _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t17;
    _unknown_ _t25;

    _v20.target = retrieveCurrentForm(buf);
    if(_v16 == 0) {
        return 0;
    }
    if( *_v16 == 0) {
        return 0;
    }
    _v20.url =  *(_v20.target);
    if( *((intOrPtr*)(_v20.url[0x40] + 8)) != 2) {
        return 0;
    }
    if(strcmp( *( *( *((intOrPtr*)(_v20 + 64)) + 12)), 135052056) != 0) {
        return 0;
    }
    return _v20.target;
}

MapArea* follow_map_menu(Buffer* buf, char* name, Anchor* a_img, int x, int y)
{// addr = 0x0808E90F
    MapList* ml;
    ListItem* al;
    int i;
    int selected;
    int initial;
    MapArea* a;
    char** label;
    MapList* _v16;
    struct _listitem* _v20;
    signed int _v24;
    struct _listitem _v36;
    signed int _v40;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t83;
    signed int _t98;
    _unknown_ _t120;
    signed char* _t137;
    signed char** _t141;

    _v36.prev = -1;
    _v36.next = 0;
    _v16 = searchMapList(buf, name);
    if(_v16 == 0) {
        return 0;
    }
    if(_v16->area == 0) {
        return 0;
    }
    if((_v16->area->nitem & 65535 & 4294967295) == 0) {
        return 0;
    }
    _v36.next = searchMapArea(buf, _v16, a_img);
    if(_v32 >= 0) {
        if(image_map_list != 0) {
            goto L8;
        }
    } else {
        _v36.next = 0;
L8:
        asm("cwde ");
        _t98 = (_v16->area->nitem & 65535) + 1 << 2;
         *__esp = _t98;
        GC_malloc();
        _v40 = _t98;
        _v24 = 0;
        _v20 = _v16->area->first;
        while(_v20 != 0) {
            _v36.ptr =  *_v20;
            if(_v36.ptr == 0) {
                 *((intOrPtr*)((_v24 << 2) + _v40)) = 135052060;
            } else {
                _t141 = (_v24 << 2) + _v40;
                if(( *( *(_v36.ptr + 8)) & 255 & 4294967295) == 0) {
                    _t137 =  *(_v36.ptr);
                } else {
                    _t137 =  *(_v36 + 8);
                }
                 *_t141 = _t137;
            }
            _v24 = _v24 + 1;
            _v20 = _v20->next;
        }
    }
L7:
    _v36.prev = _v36.next;
    if(_v28 >= 0) {
        return 0;
    }
    _v24 = 0;
    _v20 = _v16->area->first;
    while(_v20 != 0) {
        if( *_v20 != 0) {
            if(_v24 == _v28) {
                return  *_v20;
            }
        }
        _v24 = _v24 + 1;
        _v20 = _v20->next;
    }
}

MapArea* newMapArea(char* url, char* target, char* alt, char* shape, char* coords)
{// addr = 0x0808EABC
    MapArea* a;
    char* p;
    int i;
    int max;
    MapArea* _v16;
    signed int _v20;
    signed int _v24;
    int _v28;
    _unknown_ _v36;
    int _v40;
    _unknown_ __ebp;
    char* _t258;
    short int* _t270;
    short int* _t272;
    _unknown_ _t404;
    _unknown_ _t405;
    _unknown_ _t408;
    _unknown_ _t409;

     *__esp = 28;
    GC_malloc();
    _v16 = __eax;
     *_v16 = url;
    _v16->target = target;
    if(alt == 0) {
        _t258 = 135052060;
    } else {
        _t258 = alt;
    }
    _v16->alt = _t258;
    _v16->shape = 2;
    if(shape != 0) {
        if(strcasecmp(shape, "default") != 0) {
            if(strncasecmp(shape, "rect", 4) != 0) {
                if(strncasecmp(shape, "circ", 4) != 0) {
                    if(strncasecmp(shape, "poly", 4) != 0) {
                        _v16->shape = 0;
                    } else {
                        _v16->shape = 4;
                    }
                } else {
                    _v16->shape = 3;
                }
            } else {
                _v16->shape = 2;
            }
        } else {
            _v16->shape = 1;
        }
    }
    _v16->coords = 0;
    _v16->ncoords = 0;
    _v16->center_x = 0;
    _v16->center_y = 0;
    if((_v16->shape & 255 & 4294967295) == 0) {
        return _v16;
    }
    if((_v16->shape & 255 & 4294967295) == 1) {
        return _v16;
    }
    if(coords == 0) {
        _v16->shape = 0;
        return _v16;
    }
    _t270 = _v16->shape & 255;
    if((_t270 & 4294967295) != 2) {
        _t272 = _v16->shape & 255;
        if((_t272 & 4294967295) == 3) {
             *__esp = 6;
            GC_malloc();
            _v16->coords = _t272;
            _v16->ncoords = 3;
        }
    } else {
         *__esp = 8;
        GC_malloc();
        _v16->coords = _t270;
        _v16->ncoords = 4;
    }
    _v28 = _v16->ncoords;
    _v24 = 0;
    _v20 = coords;
    while((_v16->shape & 255 & 4294967295) == 4 || _v16->ncoords > _v24) {
        if(( *_v20 & 255 & 4294967295) != 0) {
            while(1) {
                _v20 =  *_v20 & 255;
                 *_v20 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255;
                 *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
                if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                    break;
                }
                _v20 = 1 + _v20;
            }
            _v20 =  *_v20 & 255;
             *_v20 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255;
             *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
            if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
L29:
                _v16 = _v16->shape & 255;
                if((_v16->shape & 255 & 4294967295) == 4) {
                    __eax = _v28;
                    if(_v28 <= _v24) {
                        if(_v24 == 0) {
                            __eax = 6;
                        } else {
                            __eax = _v24;
                            __eax = _v24 + _v24;
                        }
                        _v28 = __eax;
                        _v28 = 2 + _v28;
                        __eax = 2 + _v28 + 2 + _v28;
                        __edx = 2 + _v28 + 2 + _v28;
                        __eax = _v16;
                        __eax = _v16->coords;
                        _v40 = 2 + _v28 + 2 + _v28;
                         *__esp = __eax;
                        GC_realloc();
                        __edx = __eax;
                        __eax = _v16;
                        _v16->coords = __edx;
                    }
                    _v16 = _v16->ncoords;
                    __edx = 1 + _v16->ncoords;
                    __eax = _v16;
                    _v16->ncoords = 1 + _v16->ncoords;
                }
                _v16 = _v16->coords;
                _v24 = _v24 + _v24;
                _v20 = atoi(_v20);
                 *(_v16->coords + _v24 + _v24) = _v20 & 4294967295;
                _v24 = 1 + _v24;
                _v20 =  *_v20 & 255;
                if(( *_v20 & 255 & 4294967295) == 45) {
L38:
                    _v20 = 1 + _v20;
                    goto L41;
                } else {
                    _v20 =  *_v20 & 255;
                    if(( *_v20 & 255 & 4294967295) != 43) {
                        while(1) {
L41:
                            _v20 =  *_v20 & 255;
                             *_v20 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255;
                             *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
                            if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
                                break;
                            }
                            goto L39;
                        }
                        _v20 =  *_v20 & 255;
                        if(( *_v20 & 255 & 4294967295) == 44) {
                            while(1) {
L48:
                                _v20 =  *_v20 & 255;
                                 *_v20 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255;
                                 *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
                                if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                                    break;
                                }
                                _v20 = 1 + _v20;
                            }
                            _v20 =  *_v20 & 255;
                            if(( *_v20 & 255 & 4294967295) == 44) {
                                _v20 = 1 + _v20;
                            }
                            continue;
                        }
                        _v20 =  *_v20 & 255;
                         *_v20 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255;
                         *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
                        if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                            goto L47;
                        }
L56:
                        if(_v16->ncoords != _v24 || (_v16->shape & 255 & 4294967295) == 4 && _v16->ncoords <= 5) {
                            _v16->shape = 0;
                            _v16->coords = 0;
                            _v16->ncoords = 0;
                            return _v16;
                        }
                        if((_v16->shape & 255 & 4294967295) == 4) {
                            _v16->ncoords = ((_v16->ncoords >> 31) + _v16->ncoords >> 1) + ((_v16->ncoords >> 31) + _v16->ncoords >> 1);
                             *(_v16->coords + _v16->ncoords + _v16->ncoords) = _v16 & 65535 & 4294967295;
                             *(_v16->coords + 1 + _v16->ncoords + 1 + _v16->ncoords) = _v16->coords[1] & 65535 & 4294967295;
                        }
                        if((_v16->shape & 255 & 4294967295) != 3) {
                            _v24 = 0;
L66:
                            while((_v16->ncoords >> 31) + _v16->ncoords >> 1 > _v24) {
                                goto L65;
                            }
                        } else {
                            _v16->center_x = _v16 & 65535 & 4294967295;
                            _v16->center_y = _v16->coords[1] & 65535 & 4294967295;
                            return _v16;
                        }
L65:
                        _v16->center_x = (_v16->center_x & 65535) + ( *(_v16->coords + (_v24 << 2)) & 65535) & 4294967295;
                        _v16->center_y = (_v16->center_y & 65535) + ( *(_v16->coords + 1 + _v24 + _v24 + 1 + _v24 + _v24) & 65535) & 4294967295;
                        _v24 = 1 + _v24;
                        goto L66;
L47:
                        goto L48;
                    }
                    goto L38;
                }
L39:
                _v20 = 1 + _v20;
                goto L41;
            }
            _v20 =  *_v20 & 255;
            if(( *_v20 & 255 & 4294967295) == 45) {
                goto L29;
            }
            _v20 =  *_v20 & 255;
            if(( *_v20 & 255 & 4294967295) != 43) {
                goto L56;
            }
            goto L29;
        }
        goto L56;
    }
}

append_map_info(Buffer* buf, Str tmp, FormItemList* fi)
{// addr = 0x0808EFA6
    MapList* ml;
    ListItem* al;
    MapArea* a;
    ParsedURL pu;
    char* p;
    char* q;
    MapList* _v16;
    struct _listitem* _v20;
    char** _v24;
    char* _v28;
    char* _v32;
    struct _ParsedURL _v72;
    char* _v92;
    char* _v96;
    char* _v100;
    char* _v104;
    char* _v108;
    char* _v112;
    char* _v116;
    char* _v120;
    _unknown_ __ebp;
    char* _t58;
    char* _t83;
    char* _t84;

    if( *(fi + 8) == 0) {
        _t58 = 0;
    } else {
        _t58 =  *( *(fi + 8));
    }
    _v16 = searchMapList(buf, _t58);
    if(_v16 == 0) {
        return ;
    }
    _v112 = 0;
    _v116 = "<tr valign=top><td colspan=2><table>";
    _v120 = "<tr valign=top><td colspan=2>Links of current image map";
    Strcat_m_charp(tmp);
    _v20 = _v16->area->first;
    while(_v20 != 0) {
        _v24 =  *_v20;
        if(_v24 != 0) {
            parseURL2( *_v24,  &_v72, baseURL(buf));
            _v32 = html_quote( *(parsedURL2Str( &_v72)));
            if(DecodeURL == 0) {
                _v28 = html_quote( *_v24);
            } else {
                _v28 = html_quote(url_unquote_conv( *_v24,  *(buf + 208)));
            }
            if(( *(_v24[2]) & 255 & 4294967295) == 0) {
                _t83 = mybasename( *_v24);
            } else {
                _t83 = _v24[2];
            }
            _t84 = html_quote(_t83);
            _v92 = 0;
            _v96 = "\n";
            _v100 = _v28;
            _v104 = "</a><td>";
            _v108 = _t84;
            _v112 = "">";
            _v116 = _v32;
            _v120 = "<tr valign=top><td>&nbsp;&nbsp;<td><a href="";
            Strcat_m_charp(tmp);
        }
        _v20 = _v20->next;
    }
}

append_link_info(Buffer* buf, Str html, LinkList* link)
{// addr = 0x0808F13E
    LinkList* l;
    ParsedURL pu;
    char* url;
    struct _LinkList* _v16;
    char* _v20;
    struct _ParsedURL _v60;
    char* _v68;
    char* _v72;
    char* _v76;
    char* _v80;
    char* _v84;
    char* _v88;
    _unknown_ __ebp;
    char* _t74;
    char* _t97;

    if(link == 0) {
        return ;
    }
    Strcat_charp(html, "<hr width=50%><h1>Link information</h1><table>\n");
    _v16 = link;
    while(_v16 != 0) {
        if( *_v16 == 0) {
            _v20 = "(empty)";
        } else {
            parseURL2( *_v16,  &_v60, baseURL(buf));
            _v20 = html_quote( *(parsedURL2Str( &_v60)));
        }
        if(_v16->title == 0) {
            _t74 = "(empty)";
        } else {
            _t74 = html_quote(_v16->title);
        }
        _v68 = 0;
        _v72 = "</a><td>";
        _v76 = _t74;
        _v80 = "">";
        _v84 = _v20;
        _v88 = "<tr valign=top><td><a href="";
        Strcat_m_charp(html);
        if((_v16->type & 255 & 4294967295) != 1) {
            if((_v16->type & 255 & 4294967295) == 2) {
                Strcat_charp(html, "[Rev]");
            }
        } else {
            Strcat_charp(html, "[Rel]");
        }
        if( *_v16 != 0) {
            if(DecodeURL == 0) {
                _v20 = html_quote( *_v16);
            } else {
                _v20 = html_quote(url_unquote_conv( *_v16,  *(buf + 208)));
            }
        } else {
            _v20 = "(empty)";
        }
        _v80 = 0;
        _v84 = _v20;
        _v88 = "<td>";
        Strcat_m_charp(html);
        if(_v16->ctype != 0) {
            _t97 = html_quote(_v16->ctype);
            _v76 = 0;
            _v80 = ")";
            _v84 = _t97;
            _v88 = " (";
            Strcat_m_charp(html);
        }
        Strcat_charp(html, "\n");
        _v16 = _v16->next;
    }
}

append_frame_info(Buffer* buf, Str html, struct frameset* set, int level)
{// addr = 0x0808F33D
    char* p;
    char* q;
    int i;
    int j;
    union frameset_element frame;
    _unknown_ _v16;
    _unknown_ _v20;
    signed int _v24;
    signed int _v28;
    union frameset_element _v32;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    signed int _t81;

    if(set == 0) {
        return ;
    }
    _v24 = 0;
    while(set->row * set->col > _v24) {
        _v32 = set->frame[_v24];
        if(_v32 == 0) {
L19:
            _v24 = _v24 + 1;
            continue;
        }
        _t81 =  *_v32 & 255 & 4294967295;
        if(_t81 >= 0) {
            goto L19;
        }
        if(_t81 <= 1) {
            if(_v32->currentURL == 0) {
                goto L19;
            }
        } else {
            if(_t81 == 2) {
                append_frame_info(buf, html, _v32, level + 1);
            }
            goto L19;
        }
L8:
        Strcat_charp(html, "<pre_int>");
        _v28 = 0;
        while(_v28 < level) {
            Strcat_charp(html, "   ");
            _v28 = _v28 + 1;
        }
    }
}

Buffer* page_info_panel(Buffer* buf)
{// addr = 0x0808F50B
    Str tmp;
    Anchor* a;
    ParsedURL pu;
    TextListItem* ti;
    struct frameset* f_set;
    int all;
    char* p;
    char* q;
    wc_ces_list* list;
    char[15] charset;
    Buffer* newbuf;
    FormItemList* fi;
    intOrPtr _v32;
    char _v48;
    struct _Str* _v52;
    Anchor* _v56;
    struct _textlistitem* _v60;
    struct frameset* _v64;
    long int _v68;
    char* _v72;
    char* _v76;
    wc_ces_list* _v80;
    Buffer* _v84;
    FormItemList* _v88;
    struct _ParsedURL _v128;
    Buffer* _v144;
    int _v164;
    char* _v168;
    char* _v172;
    char* _v176;
    int _v180;
    char* _v184;
    struct  _v196;
    char* _v200;
    _unknown_ __ebx;
    char* __edi;
    _unknown_ __ebp;
    _unknown_ _t240;
    _unknown_ _t241;
    char* _t257;
    char* _t260;
    struct _Str* _t266;
    struct _Str* _t268;
    Buffer* _t293;
    char* _t316;
    _unknown_ _t391;
    char* _t396;
    char* _t411;
    _unknown_ _t415;
    char* _t422;
    Buffer* _t442;

    _v144 = buf;
    _v32 =  *gs:0x14];
    Strnew_size(1024);
    _v52 = 0;
    _v64 = 0;
    Strcat_charp(_v52, "<html><head><title>Information about current page</title></head><body><h1>Information about current page</h1>\n");
    if(_v144 != 0) {
        _v68 = _v144->allLine;
        if(_v68 == 0) {
            if(_v144->lastLine != 0) {
                _v68 = _v144->lastLine->linenumber;
            }
        }
        Strcat_charp(_v52, "<form method=internal action=charset>");
        _v72 =  *(parsedURL2Str(_v144 + 132));
        if(DecodeURL != 0) {
            _v72 = url_unquote_conv(_v72, 0);
        }
        __edi = html_quote(last_modified(_v144));
        if(_v144->real_type == 0) {
            _t411 = "unknown";
        } else {
            _t411 = html_quote(_v144->real_type);
        }
        _t257 = html_quote(_v72);
        _t260 = html_quote(_v144->buffername);
        _v164 = 0;
        _v168 = __edi;
        _v172 = "<tr valign=top><td nowrap>Last Modified<td>";
        _v176 = _t411;
        _v180 = "<tr valign=top><td nowrap>Document Type<td>";
        _v184 = _t257;
        _v196.desc = "<tr valign=top><td nowrap>Current URL<td>";
        _v196.name = _t260;
        _v196 = "<tr valign=top><td nowrap>Title<td>";
        _v200 = "<table cellpadding=0>";
        Strcat_m_charp(_v52);
        if( *(_v144 + 208) == InnerCharset) {
            _v200 =  *(_v144 + 200);
            _t266 = Sprintf("%d");
            _v200 = _v68;
            _t268 = Sprintf("%d");
            _v184 = 0;
            _v196.desc = _t266->ptr;
            _v196.name = "<tr valign=top><td nowrap>Transferred bytes<td>";
            _v196 = _t268->ptr;
            _v200 = "<tr valign=top><td nowrap>Number of lines<td>";
            Strcat_m_charp(_v52);
            _v56 = retrieveCurrentAnchor(_v144);
            if(_v56 != 0) {
                parseURL2( *_v56,  &_v128, baseURL(_v144));
                _v72 =  *(parsedURL2Str( &_v128));
                _v76 = html_quote(_v72);
                if(DecodeURL == 0) {
                    _v72 = _v76;
                } else {
                    _v72 = html_quote(url_unquote_conv(_v72,  *(_v144 + 208)));
                }
                _v180 = 0;
                _v184 = "</a>";
                _v196.desc = _v72;
                _v196.name = "">";
                _v196 = _v76;
                _v200 = "<tr valign=top><td nowrap>URL of current anchor<td><a href="";
                Strcat_m_charp(_v52);
            }
            _v56 = retrieveCurrentImg(_v144);
            if(_v56 != 0) {
                parseURL2( *_v56,  &_v128, baseURL(_v144));
                _v72 =  *(parsedURL2Str( &_v128));
                _v76 = html_quote(_v72);
                if(DecodeURL == 0) {
                    _v72 = _v76;
                } else {
                    _v72 = html_quote(url_unquote_conv(_v72,  *(_v144 + 208)));
                }
                _v180 = 0;
                _v184 = "</a>";
                _v196.desc = _v72;
                _v196.name = "">";
                _v196 = _v76;
                _v200 = "<tr valign=top><td nowrap>URL of current image<td><a href="";
                Strcat_m_charp(_v52);
            }
            _v56 = retrieveCurrentForm(_v144);
            if(_v56 != 0) {
                _v88 =  *_v56;
                _v72 = form2str(_v88);
                if(DecodeURL == 0) {
                    _v72 = html_quote(_v72);
                } else {
                    _v72 = html_quote(url_unquote_conv(_v72,  *(_v144 + 208)));
                }
                _v196.name = 0;
                _v196 = _v72;
                _v200 = "<tr valign=top><td nowrap>Method/type of current form&nbsp;<td>";
                Strcat_m_charp(_v52);
                if(_v88->parent->method == 2 && strcmp( *( *(_v88->parent + 12)), 135052056) == 0) {
                    append_map_info(_v144, _v52,  *(_v88->parent));
                }
            }
            Strcat_charp(_v52, "</table>\n");
            Strcat_charp(_v52, "</form>");
            append_link_info(_v144, _v52, _v144->linklist);
            if(_v144->document_header == 0) {
                if(_v144->frameset == 0) {
                    asm("cwde ");
                    if((_v144->bufferprop & 65535 & 2) != 0 && _v144->nextBuffer != 0 && _v144->nextBuffer->frameset != 0) {
                        _v64 = _v144->nextBuffer->frameset;
                    }
                } else {
                    _v64 = _v144->frameset;
                }
                if(_v64 != 0) {
                    Strcat_charp(_v52, "<hr width=50%><h1>Frame information</h1>\n");
                    append_frame_info(_v144, _v52, _v64, 0);
                }
                goto L48;
            }
            Strcat_charp(_v52, "<hr width=50%><h1>Header information</h1><pre>\n");
            _v60 = _v144->document_header->first;
            while(_v60 != 0) {
                _t316 = html_quote( *_v60);
                _v196.desc = 0;
                _v196.name = "</pre_int>\n";
                _v196 = _t316;
                _v200 = "<pre_int>";
                Strcat_m_charp(_v52);
                _v60 = _v60->next;
            }
        }
        _v80 = wc_get_ces_list();
        Strcat_charp(_v52, "<tr><td nowrap>Document Charset<td><select name=charset>");
        while(_v80->name != 0) {
            _v196 =  *_v80;
            sprintf( &_v48, "%d");
            _t422 = _v80->desc;
            if( *(_v144 + 208) !=  *_v80) {
                _t396 = ">";
            } else {
                _t396 = " selected>";
            }
            _v184 = 0;
            _v196.desc = _t422;
            _v196.name = _t396;
            _v196 =  &_v48;
            _v200 = "<option value=";
            Strcat_m_charp(_v52);
            _v80 = _v80 + 12;
        }
    }
L48:
    Strcat_charp(_v52, "</body></html>");
    _v84 = loadHTMLString(_v52);
    _t442 = _v84;
    if(_t442 != 0) {
         *(_v84 + 208) =  *(_v144 + 208);
    }
    _t293 = _v84;
    if(_t442 == 0) {
        return _t293;
    }
    __stack_chk_fail();
    return _t293;
}

KeyAbort(int _dummy)
{// addr = 0x0808FC0C
    char* _v0;
    signed int _v20;
    long _v24;
    char* _v28;
    intOrPtr _v32;
    signed int _v36;
    long _v44;
    _unknown_ _v80;
    long _v84;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int _t61;
    signed int _t69;
    _unknown_ _t101;
    _unknown_ _t102;

    _v24 = 1;
     *__esp = 135779104;
    siglongjmp();
    _push(_t101);
    _push(_t96);
    __esp = __esp - 52;
    _v44 = 1;
    if(_v24 == 0) {
        _v0 = 135053360;
    } else {
        _v28 = _v0;
        while(1) {
            _v28 = strchr(_v28, 44);
            if(_v28 == 0) {
                break;
            }
            _v20 = _v20 + 1;
            _v28 =  &(_v28[1]);
        }
    }
    _t61 = _v20 << 2;
     *__esp = _t61;
    GC_malloc();
    _v36 = _t61;
    _v20 = 0;
    _v28 = _v0;
    while(( *_v28 & 255 & 4294967295) == 0 || ( *( &MYCTYPE_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
        _v24 = strtol(_v28,  &_v32, 10);
        _t69 =  *_v32 & 255 & 4294967295;
        if(_t69 == 37) {
            _t96 = (_v20 << 2) + _v36;
            _v84 = _v24;
             *((_v20 << 2) + _v36) =  *(Sprintf(135053362));
            _v20 = _v20 + 1;
        } else {
            if(_t69 == 42) {
                 *((_v20 << 2) + _v36) = 135053360;
                _v20 = _v20 + 1;
            } else {
                _t96 = (_v20 << 2) + _v36;
                _v84 = _v24;
                 *((_v20 << 2) + _v36) =  *(Sprintf(135053367));
                _v20 = _v20 + 1;
            }
        }
        _v28 = strchr(_v32, 44);
        if(_v28 != 0) {
            _v28 =  &(_v28[1]);
            continue;
        }
         *_dummy = _v36;
        __esp =  &((__esp)[0xd]);
        _pop(__ebx);
        return _v20;
    }
}

int parseFrameSetLength(char* s, char*** ret)
{// addr = 0x0808FC26
    int i;
    int len;
    char* p;
    char* q;
    char** lv;
    int _v16;
    long _v20;
    char* _v24;
    intOrPtr _v28;
    signed int _v32;
    _unknown_ _v52;
    long _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int _t60;
    signed int _t68;

    _v16 = 1;
    if(s == 0) {
        s = 135053360;
        goto L6;
    }
    _v24 = s;
    while(1) {
        _v24 = strchr(_v24, 44);
        if(_v24 == 0) {
            break;
        }
        _v16 = _v16 + 1;
        _v24 =  &(_v24[1]);
    }
L6:
    _t60 = _v16 << 2;
     *__esp = _t60;
    GC_malloc();
    _v32 = _t60;
    _v16 = 0;
    _v24 = s;
    while(( *_v24 & 255 & 4294967295) == 0 || ( *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
        _v20 = strtol(_v24,  &_v28, 10);
        _t68 =  *_v28 & 255 & 4294967295;
        if(_t68 == 37) {
            _v56 = _v20;
            _v32[_v16] =  *(Sprintf(135053362));
            _v16 = _v16 + 1;
        } else {
            if(_t68 == 42) {
                _v32[_v16] = 135053360;
                _v16 = _v16 + 1;
            } else {
                _v56 = _v20;
                _v32[_v16] =  *(Sprintf(135053367));
                _v16 = _v16 + 1;
            }
        }
        _v24 = strchr(_v28, 44);
        if(_v24 != 0) {
            _v24 =  &(_v24[1]);
            continue;
        }
         *ret = _v32;
        return _v16;
    }
}

struct frameset* newFrameSet(struct parsed_tag* tag)
{// addr = 0x0808FD83
    struct frameset* f;
    int i;
    char* cols;
    char* rows;
    struct frameset* _v16;
    signed int _v20;
    union frameset_element _v24;
    union frameset_element _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t52;
    _unknown_ _t55;
    union frameset_element* _t68;

    _v24 = 0;
    _v28 = 0;
     *__esp = 36;
    GC_malloc();
    _v16 = __eax;
     *_v16 = 2;
    _v16->name = 0;
    _v16->currentURL = 0;
    parsedtag_get_value(tag, 13,  &_v24);
    parsedtag_get_value(tag, 28,  &_v28);
    _v16->col = parseFrameSetLength(_v24,  &(_v16->width));
    _v16->row = parseFrameSetLength(_v28,  &(_v16->height));
    _v16->i = 0;
    _v20 = _v16->col * _v16->row;
    _t68 = _v20 << 2;
     *__esp = _t68;
    GC_malloc();
    _v16->frame = _t68;
    while(1) {
L1:
        _v20 = _v20 - 1;
        _v16->frame[_v20] = 0;
        if(_v20 == 0) {
            break;
        }
    }
    return _v16;
}

struct frame_body* newFrame(struct parsed_tag* tag, Buffer* buf)
{// addr = 0x0808FE7F
    struct frame_body* body;
    char* p;
    void* _v16;
    char* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t38;

     *__esp = 36;
    GC_malloc();
    _v16 = __eax;
    bzero(_v16, 36);
     *_v16 = 0;
    _v16[0] = 0;
    _v16[3] = baseURL(buf);
    if(tag == 0) {
        return _v16;
    }
    if(parsedtag_get_value(tag, 31,  &_v20) != 0) {
        _v16[2] = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(_v20)), InnerCharset,  *(buf + 208))));
    }
    if(parsedtag_get_value(tag, 25,  &_v20) == 0) {
        return _v16;
    }
    if(( *_v20 & 255 & 4294967295) == 95) {
        return _v16;
    }
    _v16[1] = url_quote( *(wc_Str_conv_strict(Strnew_charp(_v20), InnerCharset,  *(buf + 208))));
    return _v16;
}

unloadFrame(struct frame_body* b)
{// addr = 0x0808FF9D
    _unknown_ __ebp;

    b->attr = 0;
    return;
}

deleteFrame(struct frame_body* b)
{// addr = 0x0808FFA8
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t7;

    if(b == 0) {
        return ;
    }
    unloadFrame(b);
    bzero(b, 36);
    return;
}

addFrameSetElement(struct frameset* f, union frameset_element element)
{// addr = 0x0808FFD7
    int i;
    int _v8;
    _unknown_ __ebp;
    _unknown_ _t20;

    if(f == 0) {
        return ;
    }
    _v8 = f->i;
    if(f->row * f->col <= _v8) {
        return ;
    }
    f->frame[_v8] = element;
    f->i = f->i + 1;
    return;
}

deleteFrameSet(struct frameset* f)
{// addr = 0x0809002B
    int i;
    signed int _v16;
    _unknown_ __ebp;

    if(f == 0) {
        return ;
    }
    _v16 = 0;
    while(f->row * f->col > _v16) {
        deleteFrameSetElement(f->frame[_v16]);
        _v16 = _v16 + 1;
    }
}

deleteFrameSetElement(union frameset_element e)
{// addr = 0x0809008A
    _unknown_ __ebp;
    signed int _t9;

    if(e == 0) {
        return ;
    }
    _t9 =  *e & 255 & 4294967295;
    if(_t9 == 1) {
        deleteFrame(e);
        return;
    } else {
        if(_t9 == 2) {
            goto L6;
        }
        if(_t9 == 0) {
            return ;
        }
        return;
        return ;
    }
L6:
    deleteFrameSet(e);
    return;
}

struct frame_body* copyFrame(struct frame_body* ob)
{// addr = 0x080900D1
    struct frame_body* rb;
    void* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t10;

     *__esp = 36;
    GC_malloc();
    _v16 = __eax;
    bcopy(ob, _v16, 36);
    return _v16;
}

struct frameset* copyFrameSet(struct frameset* of)
{// addr = 0x08090105
    struct frameset* rf;
    int n;
    void* _v16;
    signed int _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t77;
    signed int _t80;
    _unknown_ _t87;
    signed int _t90;
    _unknown_ _t97;
    signed int _t99;
    signed int _t110;

     *__esp = 36;
    GC_malloc();
    _v16 = __eax;
    _v20 = of->row * of->col;
    bcopy(of, _v16, 36);
    _t80 = _v16[5] << 2;
     *__esp = _t80;
    GC_malloc();
    _v16[3] = _t80;
    bcopy(of->width, _v16[3], 0 + _v16[5] * 4);
    _t90 = _v16[6] << 2;
     *__esp = _t90;
    GC_malloc();
    _v16[4] = _t90;
    bcopy(of->height, _v16[4], 0 + _v16[6] * 4);
    _t99 = _v20 << 2;
     *__esp = _t99;
    GC_malloc();
    _v16[8] = _t99;
L10:
    while(_v20 != 0) {
        _v20 = _v20 - 1;
        if(of->frame[_v20] != 0) {
            _t110 =  *(of->frame[_v20]) & 255 & 4294967295;
            if(_t110 >= 0) {
                goto L9;
            } else {
                if(_t110 <= 1) {
                     *((intOrPtr*)(_v16[8] + (_v20 << 2))) = copyFrame(of->frame[_v20]);
                } else {
                    if(_t110 == 2) {
                         *((intOrPtr*)(_v16[8] + (_v20 << 2))) = copyFrameSet(of->frame[_v20]);
                        continue;
                    }
                    goto L9;
                }
            }
            continue;
        }
L9:
         *(_v16[8] + (_v20 << 2)) = 0;
    }
}

flushFrameSet(struct frameset* fs)
{// addr = 0x080902A2
    int n;
    int _v16;
    _unknown_ __ebp;
    struct frameset* _t21;

    _t21 = fs;
    _t22 = _t21->i;
    _v16 = _t21->i;
    while(_v16 != 0) {
    }
}

pushFrameTree(struct frameset_queue** fqpp, struct frameset* fs, Buffer* buf)
{// addr = 0x0809032D
    struct frameset_queue* rfq;
    struct frameset_queue* cfq;
    struct frameset_queue _v20;
    _unknown_ __ebp;
    struct frameset_queue* _t56;
    long int _t57;
    long int _t58;
    int _t59;
    int _t60;
    struct _anchorList* _t61;

    _t56 =  *fqpp;
    _v20.next = _t56;
    if(fs == 0) {
        return ;
    }
     *__esp = 32;
    GC_malloc();
    _v20.back = _t56;
    if(buf == 0) {
L4:
        _t57 = 1;
    } else {
        if(buf->currentLine == 0) {
            goto L4;
        } else {
            _t57 = buf->currentLine->linenumber;
        }
    }
L5:
    _v20.back->linenumber = _t57;
    if(buf == 0 || buf->topLine == 0) {
        _t58 = 1;
    } else {
        _t58 = buf->topLine->linenumber;
    }
    _v20.back->top_linenumber = _t58;
    if(buf == 0) {
        _t59 = 0;
    } else {
        _t59 = buf->pos;
    }
    _v20.back->pos = _t59;
    if(buf == 0) {
        _t60 = 0;
    } else {
        _t60 = buf->currentColumn;
    }
    _v20.back->currentColumn = _t60;
    if(buf == 0) {
        _t61 = 0;
    } else {
        _t61 = buf->formitem;
    }
    _v20.back->formitem = _t61;
    _v20.back->back = _v20.next;
    if(_v20.next == 0) {
         *(_v20.back) = _v20.next;
    } else {
         *(_v20.back) = _v20.next->next;
        if(_v20.next->next != 0) {
            _v20.next->next->back = _v20.back;
        }
         *_v20 = _v20.back;
    }
    _v20.back->frameset = fs;
     *fqpp = _v20.back;
    return;
}

struct frameset* popFrameTree(struct frameset_queue** fqpp)
{// addr = 0x08090441
    struct frameset_queue* rfq;
    struct frameset_queue* cfq;
    struct frameset* rfs;
    void _v16;
    struct frameset_queue* _v20;
    void _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t39;

    _v16 = 0;
    _v20 =  *fqpp;
    _v24 = 0;
    if(_v20 == 0) {
        return _v24;
    }
    _v24 = _v20[2];
    if( *_v20 != 0) {
        _v16 =  *_v20;
        _v16->back = _v20[1];
    }
    if(_v20[1] != 0) {
        _v16 = _v20[1];
         *_v16 =  *_v20;
    }
     *fqpp = _v16;
    bzero(_v20, 32);
    return _v24;
}

resetFrameElement(union frameset_element* f_element, Buffer* buf, char* referer, FormList* request)
{// addr = 0x080904CB
    char* f_name;
    struct frame_body* f_body;
    char* _v16;
    struct frame_body* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 =  *( *f_element + 4);
    if(buf->frameset == 0) {
        _v20 = newFrame(0, buf);
         *_v20 = 1;
        _v20->name = _v16;
        _v20->url =  *(parsedURL2Str(buf + 132));
        _v20->source = buf->sourcefile;
        buf->sourcefile = 0;
        if(buf->mailcap_source != 0) {
            _v20->source = buf->mailcap_source;
            buf->mailcap_source = 0;
        }
        _v20->type = buf->type;
        _v20->referer = referer;
        _v20->request = request;
        deleteFrameSetElement( *f_element);
         *f_element = _v20;
        return;
    }
    deleteFrameSetElement( *f_element);
     *f_element = buf->frameset;
    _t92 = f_element;
     *__esp = 40;
    GC_malloc();
     *( *_t92 + 8) = f_element;
    copyParsedURL( *( *f_element + 8), buf + 132);
    buf->frameset = popFrameTree( &(buf->frameQ));
     *( *f_element + 4) = _v16;
    return;
}

struct frameset* frame_download_source(struct frame_body* b, ParsedURL* currentURL, ParsedURL* baseURL, int flag)
{// addr = 0x0809061A
    Buffer* buf;
    struct frameset* ret_frameset;
    ParsedURL url;
    Buffer* _v16;
    ParsedURL* _v20;
    intOrPtr _v60;
    FormList* _v76;
    signed int _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    FormList* __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t89;
    _None _t105;
    _unknown_ _t111;
    ParsedURL* _t131;
    signed int _t148;
    signed int _t158;

    _v20 = 0;
    if(b == 0) {
        return 0;
    }
    if(b->url == 0) {
        return 0;
    }
    if((b & 255 & 4294967295) == 0) {
        return 0;
    }
    if(b->baseURL != 0) {
        baseURL = b->baseURL;
    }
    parseURL2(b->url,  &_v60, currentURL);
    if(_v60 == 4) {
        b->flags = 0;
    }
    is_redisplay = 1;
    w3m_dump = w3m_dump | 32;
    __ebx = b->request;
    _t158 = flag | 4;
    __ecx = b->referer;
    if(baseURL == 0) {
        _t105 = currentURL;
    } else {
        _t105 = baseURL;
    }
    _t148 = b->url;
    _v76 = __ebx;
    _v80 = _t158;
    _v16 = loadGeneralFile(_t148, _t105, __ecx);
    w3m_dump = w3m_dump & 223;
    is_redisplay = 0;
    if(_v16 == 0 || _v16 == 1) {
        b->source = 0;
        b->flags = _t148 & 4294967295;
        return 0;
    }
    b->url =  *(parsedURL2Str(_v16 + 132));
    b->type = _v16->type;
    b->source = _v16->sourcefile;
    _v16->sourcefile = 0;
    if(_v16->mailcap_source != 0) {
        b->source = _v16->mailcap_source;
        _v16->mailcap_source = 0;
    }
    b->attr = 1;
    if(_v16->frameset != 0) {
        _v20 = _v16->frameset;
        _t131 = _v20;
        _t131->user = b->name;
         *__esp = 40;
        GC_malloc();
        _v20->currentURL = _t131;
        copyParsedURL(_v20->currentURL, _v16 + 132);
        _v16->frameset = popFrameTree( &(_v16->frameQ));
    }
    discardBuffer(_v16);
    return _v20;
}

int createFrameFile(struct frameset* f, FILE* f1, Buffer* current, int level, int force_reload)
{// addr = 0x0809081D
    int r;
    int c;
    int t_stack;
    URLFile f2;
    wc_ces charset;
    wc_ces doc_charset;
    char* d_target;
    char* p_target;
    char* s_target;
    char* t_target;
    ParsedURL* currentURL;
    ParsedURL base;
    _None prevtrap;
    int flag;
    union frameset_element frame;
    struct frameset* f_frameset;
    int i;
    char* p;
    int status;
    Str tok;
    int pre_mode;
    int end_tag;
    Str tmp;
    int is_tag;
    char* q;
    struct parsed_tag* tag;
    Str tmp;
    char* q;
    int j;
    int a_target;
    ParsedURL url;
    wc_ces c;
    Str s_tmp;
    int refresh_interval;
    signed int _v32;
    signed int _v36;
    URLFile* _v40;
    unsigned int _v44;
    unsigned int _v48;
    char* _v52;
    char* _v56;
    char* _v60;
    char* _v64;
    ParsedURL* _v68;
    _None* _v72;
    signed int _v76;
    struct frameset* _v80;
    struct _Str _v92;
    URLFile* _v96;
    struct _Str* _v100;
    signed int _v104;
    URLFile* _v108;
    struct _Str* _v112;
    int _v116;
    char* _v120;
    struct parsed_tag* _v124;
    struct _Str* _v128;
    char* _v132;
    signed int _v136;
    signed int _v140;
    struct  _v184;
    struct _ParsedURL _v224;
    struct _ParsedURL _v264;
    _unknown_ _v284;
    intOrPtr _v288;
    signed int _v292;
    char* _v296;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t578;
    _unknown_ _t580;
    ParsedURL* _t584;
    _unknown_ _t588;
    _unknown_ _t602;
    _unknown_ _t606;
    signed int _t609;
    char* _t621;
    _unknown_ _t634;
    _unknown_ _t649;
    int _t662;
    _unknown_ _t668;
    _unknown_ _t679;
    _unknown_ _t687;
    _unknown_ _t691;
    signed int _t713;
    signed int _t714;
    _unknown_ _t746;
    _unknown_ _t755;
    _unknown_ _t762;
    _unknown_ _t780;
    _unknown_ _t783;
    _unknown_ _t790;
    _unknown_ _t795;
    _unknown_ _t796;
    _unknown_ _t811;
    _unknown_ _t818;
    _unknown_ _t846;
    _unknown_ _t899;
    _unknown_ _t911;
    _unknown_ _t913;
    char* _t928;
    _unknown_ _t930;
    _unknown_ _t937;
    _unknown_ _t942;
    _unknown_ _t944;
    _unknown_ _t951;
    _unknown_ _t961;
    char* _t979;
    _unknown_ _t981;
    _unknown_ _t990;
    _unknown_ _t995;
    _unknown_ _t997;
    _unknown_ _t999;
    _unknown_ _t1001;
    _unknown_ _t1002;
    _unknown_ _t1004;
    _unknown_ _t1009;
    _unknown_ _t1015;
    _unknown_ _t1017;
    _unknown_ _t1019;
    _unknown_ _t1020;
    _unknown_ _t1026;
    _unknown_ _t1030;
    _unknown_ _t1031;
    _unknown_ _t1032;
    _unknown_ _t1057;

    _v72 = 0;
    if(f == 0) {
        return -1;
    }
    if(level == 0) {
        _v296 = 1;
         *__esp = 135779104;
        __sigsetjmp();
        if(_t578 != 0) {
            if((TrapSignal & 255 & 4294967295) == 0) {
                return -1;
            }
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_raw();
            }
            if(_v72 == 0) {
                return -1;
            }
            mySignal(2, _v72);
            return -1;
        }
        if((TrapSignal & 255 & 4294967295) != 0) {
            _v72 = mySignal(2, KeyAbort);
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_cbreak();
            }
        }
        f->name = 135053370;
    }
    if(level > 7) {
        fwrite("Too many frameset tasked.\n", 1, 26, f1);
        return -1;
    }
    if(level != 0) {
        fwrite("<table hborder>\n", 1, 16, f1);
    } else {
        _v292 = html_quote(current->buffername);
        fprintf(f1, "<html><head><title>%s</title></head><body>\n");
        fwrite("<table hborder width="100%">\n", 1, 29, f1);
    }
    if(f->currentURL == 0) {
        _t584 = current + 132;
    } else {
        _t584 = f->currentURL;
    }
    _v68 = _t584;
    _v32 = 0;
    while(f->row > _v32) {
        while(f->col > _v36) {
            _v92.length = f->col * _v32 + _v36;
            _v92 = 135053512;
            _v96 = 0;
            _v100 = Strnew();
            _v104 = 0;
            _v108 = 0;
            _v80 = f->frame[_v92.length];
            if(_v80 != 0) {
                fwrite("<td", 1, 3, f1);
                if(_v80->name != 0) {
                    _v292 = html_quote(_v80->name);
                    fprintf(f1, " id="_%s"");
                }
                if(_v32 == 0) {
                    _v292 = f->width[_v36];
                    fprintf(f1, " width="%s"");
                }
                fwrite(">\n", 1, 2, f1);
                _v76 = 0;
                if(force_reload != 0) {
                    _v76 = _v76 | 1;
                    if(( *_v80 & 255 & 4294967295) == 1) {
                        unloadFrame(_v80);
                    }
                }
                _t609 =  *_v80 & 255 & 4294967295;
                if(_t609 == 1) {
L42:
                    init_stream( &_v184, 4, 0);
                    if(_v80->height != 0) {
                        fflush(f1);
                        examineFile(_v80->height,  &_v184);
                    }
                    if(_v180 != 0) {
                        parseURL2(_v80->currentURL,  &_v224, _v68);
                        _v56 = f->name;
                        _v60 = _v80->name;
                        _v64 = "_blank";
                        if((TargetSelf & 255 & 4294967295) == 0) {
                            _t621 = _v64;
                        } else {
                            _t621 = _v60;
                        }
                        _v52 = _t621;
                        _v44 = 256;
                        if( *(current + 208) == 256) {
                            _v48 = DocumentCharset;
                        } else {
                            _v48 =  *(current + 208);
                        }
                        _v40 = 0;
                        if(_v80->col == 0 || strcasecmp(_v80->col, "text/plain") != 0) {
                            goto L66;
                            do {
L66:
                                _v116 = 0;
                                goto L67;
                                do {
                                    goto L67;
L70:
                                    read_token(_v100,  &_v92,  &_v96, 1, _v96 & 4294967295 & );
                                } while(_v96 != 0);
L73:
                                if(_v100->length == 0) {
                                    goto L150;
                                }
                                if(( *( *_v100) & 255 & 4294967295) == 60) {
                                    if((( *_v100)[1] & 255 & 4294967295) == 0 || ( *( &MYCTYPE_MAP + (( *_v100)[1] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0 && (( *_v100)[1] & 255 & 4294967295) != 47 && (( *_v100)[1] & 255 & 4294967295) != 33 && (( *_v100)[1] & 255 & 4294967295) != 63 && (( *_v100)[1] & 255 & 4294967295) != 0 && (( *_v100)[1] & 255 & 4294967295) != 95) {
                                        if((_v104 & 2062) == 0) {
                                            _v292 = 0;
                                            _v296 = _v92;
                                            _v92 =  *(Strnew_m_charp( &(( *_v100)[1])));
                                            _v100 = Strnew_charp("&lt;");
                                        }
                                    } else {
                                        _v116 = 1;
                                    }
                                }
                                if(_v116 == 0) {
L106:
                                    if(_v116 == 0) {
                                        if((_v104 & 8) == 0) {
                                            if((_v104 & 2048) == 0) {
                                                fwrite( *_v100, 1, _v100->length, f1);
                                            } else {
                                                fputs(html_quote(html_unquote( *_v100)), f1);
                                            }
                                        } else {
                                            fputs(html_quote( *_v100), f1);
                                        }
                                        goto L148;
                                    }
                                } else {
                                    if((_v104 & 2062) == 0) {
                                        if((_v104 & 4096) == 0) {
                                            goto L106;
                                        }
                                        goto L97;
                                    }
                                    _v120 =  *_v100;
                                    _v124 = parse_tag( &_v120, 0);
                                    if(_v124 == 0 || ( *_v124 & 255 & 4294967295 & ) != _v108) {
                                        if(strncmp( *_v100, "<!--", 4) != 0) {
                                            _v120 = strchr( &(( *_v100)[1]), 60);
                                            if(_v120 != 0) {
                                                _v100 = Strnew_charp_n( *_v100, _v120 -  *_v100);
                                                _v292 = 0;
                                                _v296 = _v92;
                                                _v92 =  *(Strnew_m_charp(_v120));
                                                _v96 = 0;
                                            }
                                        }
                                        _v116 = 0;
                                        goto L106;
                                    }
                                    if((_v104 & 8) == 0) {
                                        _v104 = 0;
                                        _v108 = 0;
                                        goto L106;
                                    }
                                    fwrite("</PRE_PLAIN>", 1, 12, f1);
                                    _v104 = 0;
                                    _v108 = 0;
L148:
                                    Strclear(_v100);
                                    goto L150;
L97:
                                    _v120 =  *_v100;
                                    _v124 = parse_tag( &_v120, 0);
                                    if(_v124 == 0) {
                                        goto L106;
                                    }
                                    if(( *_v124 & 255 & 4294967295 & ) == _v108 || ( *_v124 & 255 & 4294967295) == 43) {
                                        if(( *_v124 & 255 & 4294967295) == 43) {
                                            fwrite("</SELECT>", 1, 9, f1);
                                        }
                                        _v104 = 0;
                                        _v108 = 0;
                                        goto L106;
                                    } else {
                                        if(_v40 == 0 || ( *_v124 & 255 & 4294967295 & ) - 31 > 59) {
                                            goto L106;
                                        } else {
                                            goto __eax;
                                        }
                                    }
                                }
L107:
                                _v132 =  *_v100;
                                _v140 = 0;
                                _v124 = parse_tag( &_v132, 0);
                                if(_v124 == 0) {
                                    goto L148;
                                }
                                if(( *_v124 & 255 & 4294967295 & ) - 14 > 83) {
                                    _v136 = 0;
L136:
                                    while(( *((( *_v124 & 255 & 4294967295 & ) + ( *_v124 & 255 & 4294967295 & ) + _t1055 << 2) + 135107784) & 255 & 4294967295 & ) > _v136) {
                                        goto L111;
                                    }
                                }
                                goto __eax;
L111:
                                _t713 = (_v124->attrid[_v136] & 255 & 4294967295 & ) - 3;
                                if(_t713 <= 29) {
                                    _t714 = 1 << (_t713 & 4294967295);
                                    if((_t714 & 268468225) != 0) {
                                        if(_v124->value[_v136] != 0) {
                                            _v124->value[_v136] = url_quote( *(wc_Str_conv_strict(Strnew_charp(remove_space(_v124->value[_v136])), InnerCharset, _v44)));
                                            _v124->need_reconstruct = 1;
                                            parseURL2(_v124->value[_v136],  &_v264,  &_v224);
                                            if(_v264.scheme != 255 && _v264 != 254) {
                                                _v140 = _v140 | 1;
                                                _v124->value[_v136] =  *(parsedURL2Str( &_v264));
                                                parsedtag_set_value(_v124, 71,  *(parsedURL2Str( &_v224)));
                                                if((_v124->attrid[_v136] & 255 & 4294967295) == 3) {
                                                    if(_v44 != 256) {
                                                        parsedtag_set_value(_v124, 11, wc_ces_to_charset(_v44));
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if((_t714 & 4325376) != 0) {
                                            if(_v124->value[_v136] != 0) {
                                                parsedtag_set_value(_v124, 67, _v60);
                                            }
                                        } else {
                                            if((_t714 & 536870912) != 0) {
                                                if(_v124->value[_v136] != 0) {
                                                    _v140 = _v140 | 2;
                                                    if(strcasecmp(_v124->value[_v136], "_self") != 0) {
                                                        if(strcasecmp(_v124->value[_v136], "_parent") == 0) {
                                                            parsedtag_set_value(_v124, 32, _v56);
                                                        }
                                                    } else {
                                                        parsedtag_set_value(_v124, 32, _v60);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                _v136 = _v136 + 1;
                                goto L136;
L150:
                            } while(( *_v92 & 255 & 4294967295) != 0 || (_v180->base.stream.cur & 255 & 4294967295) == 0);
                            if((_v104 & 8) == 0) {
                                if((_v104 & 2048) == 0) {
                                    if((_v104 & 4096) == 0) {
                                        _t662 = _v104 & 6;
                                        if(_t662 != 0) {
                                            if(_v96 != 0) {
                                                fputs( *(correct_irrtag(_v96)), f1);
                                            }
                                            if((_v104 & 2) == 0) {
                                                if((_v104 & 4) != 0) {
                                                    _t662 = fwrite("</STYLE>\n", 1, 9, f1);
                                                }
                                            } else {
                                                _t662 = fwrite("</SCRIPT>\n", 1, 10, f1);
                                            }
                                        }
                                    } else {
                                        _t662 = fwrite("</SELECT></FORM>\n", 1, 17, f1);
                                    }
                                } else {
                                    _t662 = fwrite("</TEXTAREA></FORM>\n", 1, 19, f1);
                                }
                            } else {
                                _t662 = fwrite("</PRE_PLAIN>\n", 1, 13, f1);
                            }
                            while(1) {
                                _v40 = _v40 - 1;
                                if((_t662 & 4294967295) == 0) {
                                    break;
                                }
                                _t662 = fwrite("</TABLE>\n", 1, 9, f1);
                            }
                            if(ISclose(_v180) == 0) {
                                _v184.stream = 0;
                            }
                        } else {
                            fwrite("<pre>\n", 1, 6, f1);
                            while(1) {
                                _v112 = StrmyISgets(_v184.stream);
                                if(_v112->length == 0) {
                                    break;
                                }
                                _v112 = convertLine(0, _v112, 2,  &_v44, _v48);
                                fputs(html_quote( *_v112), f1);
                            }
                            fwrite("</pre>\n", 1, 7, f1);
                            if(ISclose(_v180) == 0) {
                                _v184.stream = 0;
                            }
                        }
                        goto L177;
L67:
                        if(( *_v92 & 255 & 4294967295) != 0) {
                            goto L70;
                        }
                        _v128 = StrmyISgets(_v184.stream);
                        if(_v128->length == 0) {
                            goto L73;
                        }
                        _v128 = convertLine(0, _v128, 2,  &_v44, _v48);
                        _v92 =  *_v128;
                        goto L70;
                    } else {
                         *_v80 = 0;
                        if((_v80->dummy & 255 & 4294967295 & 1 & 4294967295) == 0) {
                            if(_v80->currentURL == 0) {
                                if(_v80->name == 0) {
                                    _t928 = "(no name)";
                                } else {
                                    _t928 = html_quote(_v80->name);
                                }
                                _v292 = _t928;
                                fprintf(f1, "This frame (%s) contains no src attribute");
                            } else {
                                _v292 = html_quote(_v80->currentURL);
                                fprintf(f1, "Can't open %s");
                            }
                        } else {
                            _v292 = html_quote(_v80->currentURL);
                            fprintf(f1, "Open %s with other method");
                        }
                    }
L177:
                    fwrite("</td>\n", 1, 6, f1);
                    goto L178;
                }
            } else {
                fwrite("<td>\n</td>\n", 1, 11, f1);
L178:
                _v36 = _v36 + 1;
                continue;
            }
L34:
            if(_t609 == 2) {
L171:
                if(_v80->name == 0 && f->name != 0) {
                    _v292 = _v92.length;
                    _v296 = f->name;
                    _v80->name =  *(Sprintf("%s_%d"));
                }
                createFrameFile(_v80, f1, current, level + 1, force_reload);
                goto L177;
            }
            if(_t609 == 0) {
                if(_v80->name == 0 && f->name != 0) {
                    _v292 = _v92.length;
                    _v296 = f->name;
                    _v80->name =  *(Sprintf("%s_%d"));
                }
                fflush(f1);
                _v92.area_size = frame_download_source(_v80, _v68, current->baseURL, _v76);
                if(_v84 == 0) {
                    goto L42;
                } else {
                    deleteFrame(_v80);
                    _v80 = _v92.area_size;
                    f->frame[_v92.length] = _v80;
                    goto L171;
                }
            } else {
                _t979 = html_quote(f->name);
                _v288 = _v92.length + 1;
                _v292 = _t979;
                fprintf(f1, "Frameset "%s" frame %d: type unrecognized");
            }
            goto L177;
        }
    }
}

Buffer* renderFrame(Buffer* Cbuf, int force_reload)
{// addr = 0x08091F71
    Str tmp;
    FILE* f;
    Buffer* buf;
    int flag;
    struct frameset* fset;
    wc_ces doc_charset;
    struct _Str* _v16;
    FILE* _v20;
    Buffer* _v24;
    signed int _v28;
    struct frameset* _v32;
    unsigned int _v36;
    struct frameset* _v60;
    signed int _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t58;
    _unknown_ _t65;
    _unknown_ _t76;
    _unknown_ _t86;
    _unknown_ _t87;

    _v36 = DocumentCharset;
    _v16 = tmpfname(2, 135054624);
    _v20 = fopen( *_v16, 135054630);
    if(_v20 == 0) {
        return 0;
    }
    _v32 = Cbuf->frameset;
    if(_v32 == 0) {
        return 0;
    }
    if(createFrameFile(_v32, _v20, Cbuf, 0, force_reload) < 0) {
        return 0;
    }
    fclose(_v20);
    _v28 = 2;
    if( *((intOrPtr*)(Cbuf + 168)) != 0) {
        _v28 = _v28 | 1;
    }
    renderFrameSet = Cbuf->frameset;
    flushFrameSet(renderFrameSet);
    DocumentCharset = InnerCharset;
    _v60 = 0;
    _v64 = _v28;
    _v24 = loadGeneralFile( *_v16, 0, 0);
    DocumentCharset = _v36;
    renderFrameSet = 0;
    if(_v24 == 0) {
        return 0;
    }
    if(_v24 == 1) {
        return 0;
    }
    _v24->sourcefile =  *_v16;
     *((intOrPtr*)(_v24 + 208)) =  *((intOrPtr*)(Cbuf + 208));
    copyParsedURL(_v24 + 132, Cbuf + 132);
    preFormUpdateBuffer(_v24);
    return _v24;
}

union frameset_element* search_frame(struct frameset* fset, char* name)
{// addr = 0x080920F0
    int i;
    union frameset_element* e;
    signed int _v16;
    union frameset_element* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t54;

    _v20 = 0;
    _v16 = 0;
    while(fset->row * fset->col > _v16) {
        _v20 =  &(fset->frame[_v16]);
        if( *_v20 != 0) {
            if(( *( *_v20) & 255 & 4294967295) == 2) {
                _v20 = search_frame( *_v20, name);
                if(_v20 != 0) {
                    return _v20;
                }
            }
        }
        _v16 = _v16 + 1;
    }
}

int compare_table(struct rc_search_table* a, struct rc_search_table* b)
{// addr = 0x080921A0
    _unknown_ _v24;
    _unknown_ __ebp;

    return strcmp(a->param->name, b->param->name);
}

create_option_search_table()
{// addr = 0x080921C2
    int i;
    int j;
    int k;
    int diff1;
    int diff2;
    char* p;
    char* q;
    intOrPtr _v16;
    signed int _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t96;
    _unknown_ _t115;

    RC_table_size = 0;
    _v20 = 0;
    while( *((intOrPtr*)( &sections + _v20 * 8)) != 0) {
        while( *((intOrPtr*)( *((intOrPtr*)(135096292 + _v20 * 8)) + (_v16 + _v16 + _t151 << 3))) != 0) {
            _v16 = _v16 + 1;
            RC_table_size = RC_table_size + 1;
        }
    }
}

struct param_ptr* search_param(char* name)
{// addr = 0x080923C2
    size_t b;
    size_t e;
    size_t i;
    int cmp;
    int len;
    struct param_ptr* _v16;
    intOrPtr _v20;
    signed int _v24;
    char* _v28;
    int _v32;
    _unknown_ _v52;
    char* _v56;
    _unknown_ __ebp;
    _unknown_ _t56;
    _unknown_ _t63;

    _v32 = strlen(name);
    _v16 = 0;
    _v20 = RC_table_size - 1;
    while(_v16 <= _v20) {
        _v24 = _v16 + _v20 >> 1;
        _v28 = strncmp(name, RC_search_table[_v24].param->name, _v32);
        if(_v28 != 0) {
            if(_v28 >= 0) {
                _v16 = _v24 + 1;
            } else {
                if(_v24 == 0) {
                    return 0;
                }
                _v20 = _v24 - 1;
            }
            continue;
        }
        asm("cwde ");
        if(( &(RC_search_table[_v24])->uniq_pos & 65535) <= _v32) {
            return RC_search_table[_v24].param;
        }
        while(1) {
            RC_search_table =  &(RC_search_table[_v24]);
            RC_search_table[_v24].param = RC_search_table[_v24].param->name;
            _v56 = RC_search_table[_v24].param->name;
            __eax = name;
             *__esp = name;
            __eax = strcmp();
            _v28 = name;
            if(_v28 > 0) {
                break;
            }
            if(_v28 != 0) {
                if(_v24 != 0) {
                    _v24 = _v24 - 1;
                    continue;
                }
                goto L7;
            }
            RC_search_table =  &(RC_search_table[_v24]);
            __eax = RC_search_table[_v24].param;
            return RC_search_table[_v24].param;
L7:
            __eax = 0;
            return 0;
        }
        __eax = 0;
        return 0;
    }
}

show_params(FILE* fp)
{// addr = 0x080924EF
    int i;
    int j;
    int l;
    char* t;
    char* cmt;
    signed int _v16;
    signed int _v20;
    struct _Str _v32;
    char* _v52;
    struct _Str _v64;
    signed int _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t91;
    _unknown_ _t102;
    int _t132;
    _unknown_ _t135;
    struct _Str* _t139;
    _unknown_ _t148;
    _unknown_ _t160;

    _v32.length = 0;
    OptionCharset = SystemCharset;
    fwrite("\nconfiguration parameters\n", 1, 26, fp);
    _v20 = 0;
    while( *( &sections + _v20 * 8) != 0) {
        if(OptionEncode != 0) {
            _v32 =  *( &sections + _v20 * 8);
        } else {
            _v32 =  *(wc_Str_conv(Strnew_charp(gettext( *( &sections + _v20 * 8))), OptionCharset, InnerCharset));
        }
        _v64.ptr =  *(wc_Str_conv_strict(Strnew_charp(_v32), InnerCharset, SystemCharset));
        _v68 = _v20;
        fprintf(fp, "  section[%d]: %s\n");
        _v16 = 0;
        while( *((intOrPtr*)( *((intOrPtr*)(135096292 + _v20 * 8)) + (_v16 + _v16 + _t184 << 3))) != 0) {
            if( *((intOrPtr*)( *((intOrPtr*)(135096292 + _v20 * 8)) + (_v16 + _v16 + _t185 << 3) + 4)) <= 10) {
                goto __eax;
            }
            if(OptionEncode != 0) {
                _v32 =  *( *((intOrPtr*)(135096292 + _v20 * 8)) + (_v16 + _v16 + _t186 << 3) + 16);
            } else {
                _v32 =  *(wc_Str_conv(Strnew_charp(gettext( *( *((intOrPtr*)(135096292 + _v20 * 8)) + (_v16 + _v16 + _t191 << 3) + 16))), OptionCharset, InnerCharset));
            }
            _t132 = strlen( *( *((intOrPtr*)(135096292 + _v20 * 8)) + (_v16 + _v16 + _t187 << 3)));
            _v32.area_size = 30 - _t132 + strlen(_v32.length);
            if(_v24 < 0) {
                _v32.area_size = 1;
            }
            _t139 = wc_Str_conv_strict(Strnew_charp(_v32), InnerCharset, SystemCharset);
            _t189 = _v16;
            _v52 = _t139->ptr;
            _v64.area_size = " ";
            _v64.length = _v32.area_size;
            _v64 = _v32.length;
            _v68 =  *( *((intOrPtr*)(135096292 + _v20 * 8)) + (_v16 + _t189 + _t189 << 3));
            fprintf(fp, "    -o %s=<%s>%*s%s\n");
            _v16 = _v16 + 1;
        }
    }
}

int str_to_bool(char* value, int old)
{// addr = 0x080927EA
    _unknown_ __ebp;
    signed int _t20;
    _unknown_ _t22;
    _unknown_ _t23;
    _unknown_ _t27;

    if(value == 0) {
        return 1;
    }
    if(( *( &MYCTYPE_MAP + ( *value & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
        _t20 =  *value & 255 & 4294967295;
    } else {
        _t20 = ( *value & 255 | 32) & 4294967295;
    }
    if(_t20 - 33 > 87) {
        return 1;
    }
    goto __eax;
}

int str_to_color(char* value)
{// addr = 0x08092905
    _unknown_ __ebp;
    signed int _t20;
    _unknown_ _t22;
    _unknown_ _t23;
    _unknown_ _t27;

    if(value == 0) {
        return 8;
    }
    if(( *( &MYCTYPE_MAP + ( *value & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
        _t20 =  *value & 255 & 4294967295;
    } else {
        _t20 = ( *value & 255 | 32) & 4294967295;
    }
    if(_t20 - 48 > 73) {
        return 8;
    }
    goto __eax;
}

int set_param(char* name, char* value)
{// addr = 0x080929D0
    struct param_ptr* p;
    double ppc;
    struct param_ptr* _v16;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t13;
    _unknown_ _t14;
    _unknown_ _t15;
    _unknown_ _t16;

    if(value == 0) {
        return 0;
    }
    _v16 = search_param(name);
    if(_v16 == 0) {
        return 0;
    }
    if(_v16->type > 10) {
        return 1;
    }
    goto __eax;
}

int set_param_option(char* option)
{// addr = 0x08092C20
    Str tmp;
    char* p;
    char* q;
    struct _Str* _v16;
    char* _v20;
    _unknown_ _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t75;
    _unknown_ _t88;
    _unknown_ _t96;
    _unknown_ _t99;
    int _t132;

    _v16 = Strnew();
    _v20 = option;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            goto L11;
        }
        if(( *_v20 & 255 & 4294967295) != 61) {
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t132 = _v16->length;
             *( *_v16 + _t132) =  *_v20 & 255 & 4294967295;
            _v16->length = _t132 + 1;
            _v20 =  &(_v20[1]);
             *((char*)( *_v16 + _v16->length)) = 0;
            continue;
        }
L11:
        while(( *_v20 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v20 =  &(_v20[1]);
        }
        goto L11;
    }
}

char* get_param_option(char* name)
{// addr = 0x08092DCD
    struct param_ptr* p;
    struct param_ptr* _v16;
    _unknown_ __ebp;
    _unknown_ _t7;

    _v16 = search_param(name);
    if(_v16 == 0) {
        return 0;
    }
    return  *(to_str(_v16));
}

interpret_rc(FILE* f)
{// addr = 0x08092DFD
    Str line;
    Str tmp;
    char* p;
    struct _Str* _v16;
    struct _Str* _v20;
    signed int _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t76;
    _unknown_ _t88;

    while(1) {
        _v16 = Strfgets(f);
        Strchop(_v16);
        if(_v16->length == 0) {
            break;
        }
        Strremovefirstspaces(_v16);
        if(( *( *_v16) & 255 & 4294967295) != 35) {
            _v20 = Strnew();
            _v24.ptr =  *_v16;
L8:
            while((_v24 & 255 & 4294967295) != 0) {
                if(( *( &MYCTYPE_MAP + (_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                    goto L5;
                }
                while((_v24 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *(_v24.ptr) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                    _v24.ptr =  &(_v24.ptr[1]);
                }
            }
        }
        continue;
L5:
        if(_v20->length + 1 >= _v20->area_size) {
            Strgrow(_v20);
        }
        _t76 = _v20->length;
         *( *_v20 + _t76) =  *((signed char*)(_v24.ptr)) & 255 & 4294967295;
        _v20->length = _t76 + 1;
        _v24.ptr = _v24 + 1;
         *((char*)( *_v20 + _v20->length)) = 0;
        goto L8;
    }
    return;
}

parse_proxy()
{// addr = 0x08092F21
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    if(non_null(HTTP_proxy) != 0) {
        parseURL(HTTP_proxy,  &HTTP_proxy_parsed, 0);
    }
    if(non_null(GOPHER_proxy) != 0) {
        parseURL(GOPHER_proxy,  &GOPHER_proxy_parsed, 0);
    }
    if(non_null(FTP_proxy) != 0) {
        parseURL(FTP_proxy,  &FTP_proxy_parsed, 0);
    }
    if(non_null(NO_proxy) == 0) {
        return ;
    }
    NO_proxy_domains = make_domain_list(NO_proxy);
    return;
}

parse_cookie()
{// addr = 0x08092FD6
    _unknown_ __ebp;

    if(non_null(cookie_reject_domains) != 0) {
        Cookie_reject_domains = make_domain_list(cookie_reject_domains);
    }
    if(non_null(cookie_accept_domains) == 0) {
        return ;
    }
    Cookie_accept_domains = make_domain_list(cookie_accept_domains);
    return;
}

sync_with_option()
{// addr = 0x08093024
    _unknown_ __ebp;

    if(PagerMax < LINES) {
        PagerMax = LINES;
    }
    WrapSearch = WrapDefault;
    parse_proxy();
    parse_cookie();
    initMailcap();
    initMimeTypes();
    initURIMethods();
    init_migemo();
    if((fmInitialized & 255 & 4294967295) != 0) {
        if(displayImage != 0) {
            initImage();
        }
    }
    loadPasswd();
    loadPreForm();
    if(AcceptLang == 0 || ( *AcceptLang & 255 & 4294967295) == 0) {
        AcceptLang = gettext("en;q=1.0");
    }
    if(AcceptEncoding == 0 || ( *AcceptEncoding & 255 & 4294967295) == 0) {
        AcceptEncoding = acceptableEncoding();
    }
    if(AcceptMedia == 0 || ( *AcceptMedia & 255 & 4294967295) == 0) {
        AcceptMedia = acceptableMimeTypes();
    }
    if((fmInitialized & 255 & 4294967295) == 0) {
        return ;
    }
    initKeymap(0);
    initMouseAction();
    initMenu();
    return;
}

init_rc()
{// addr = 0x08093115
    int i;
    struct stat st;
    FILE* f;
    int _v16;
    FILE* _v20;
    signed int _v92;
    char _v108;
    char* _v116;
    intOrPtr _v120;
    _unknown_ __ebx;
    _unknown_ __ebp;
    char* _t46;
    _unknown_ _t61;
    _unknown_ _t64;
    _unknown_ _t67;
    _unknown_ _t70;
    _unknown_ _t81;
    _unknown_ _t85;
    char* _t86;
    _unknown_ _t89;

    if(rc_dir == 0) {
        rc_dir = expandPath("~/.w3m");
        _v16 = strlen(rc_dir);
        if(_v16 > 1) {
            if((rc_dir[_v16 - 1] & 255 & 4294967295) == 47) {
                rc_dir[_v16 - 1] = 0;
            }
        }
        display_charset_str = wc_get_ces_list();
        document_charset_str = display_charset_str;
        system_charset_str = display_charset_str;
        _t46 = rc_dir;
        L080C7280(_t46,  &_v108);
        if(_t46 >= 0) {
L10:
            if((_v92 & 61440) == 16384) {
                if((_v92 & 128) != 0) {
                    no_rc_dir = 0;
                    tmp_dir = rc_dir;
                    if(config_file == 0) {
                        config_file = rcFile("config");
                    }
                    create_option_search_table();
                    goto L18;
                }
                goto L13;
            }
            goto L11;
L13:
            _v116 = rc_dir;
            fprintf(__imp__stderr, "%s is not writable!");
            goto L24;
        }
        if( *(__errno_location()) != 2) {
L9:
            _v116 = rc_dir;
            fprintf(__imp__stderr, "Can't open config directory (%s)!");
            goto L24;
        }
        _t86 = rc_dir;
        _v120 = 448;
         *__esp = _t86;
        mkdir();
        if(_t86 >= 0) {
            L080C7280(rc_dir,  &_v108);
            goto L10;
        }
        _v116 = rc_dir;
        fprintf(__imp__stderr, "Can't create config directory (%s)!");
L24:
        no_rc_dir = 1;
        tmp_dir = getenv("TMPDIR");
        if(tmp_dir != 0) {
            if(( *tmp_dir & 255 & 4294967295) != 0) {
                return ;
            }
        }
        tmp_dir = getenv("TMP");
        if(tmp_dir != 0) {
            if(( *tmp_dir & 255 & 4294967295) != 0) {
                return ;
            }
        }
        tmp_dir = getenv("TEMP");
        if(tmp_dir != 0) {
            if(( *tmp_dir & 255 & 4294967295) != 0) {
                return ;
            }
        }
        tmp_dir = "/tmp";
        return;
        goto L9;
L11:
        _v116 = rc_dir;
        fprintf(__imp__stderr, "%s is not a directory!");
        goto L24;
    }
L18:
    _v20 = fopen(etcFile("w3mconfig"), "rt");
    if(_v20 != 0) {
        interpret_rc(_v20);
        fclose(_v20);
    }
    _v20 = fopen(confFile("config"), "rt");
    if(_v20 != 0) {
        interpret_rc(_v20);
        fclose(_v20);
    }
    _v20 = fopen(config_file, "rt");
    if(_v20 == 0) {
        return ;
    }
    interpret_rc(_v20);
    fclose(_v20);
    return;
}

Str to_str(struct param_ptr* p)
{// addr = 0x08093413
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t8;

    if(p->type > 10) {
        return 0;
    }
    goto __eax;
}

Buffer* load_option_panel()
{// addr = 0x08093526
    Str src;
    struct param_ptr* p;
    struct sel_c* s;
    wc_ces_list* c;
    int x;
    int i;
    Str tmp;
    Buffer* buf;
    struct _Str* _v32;
    struct param_ptr* _v36;
    _Unknown_base* _v40;
    intOrPtr* _v44;
    int _v48;
    signed int _v52;
    struct _Str* _v56;
    _unknown_ _v60;
    signed short _v62;
    signed int _v64;
    char* _v68;
    char* _v84;
    char* _v88;
    char* _v92;
    struct param_ptr _v116;
    char* _v120;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    int _t273;
    char* _t279;
    int _t306;
    int _t352;
    char* _t367;
    char* _t418;
    char* _t421;
    struct param_ptr _t423;
    char* _t436;

    if(optionpanel_str == 0) {
        _t418 = gettext("External Viewer Setup");
        _t421 = html_quote( *(localCookie()));
        _v116.type = _t418;
        _v116.name = _t421;
        _v120 = w3m_version;
        optionpanel_str = Sprintf("<html><head><title>Option Setting Panel</title></head><body><h1 align=center>Option Setting Panel<br>(w3m version %s)</b></h1><form method=post action="file:///$LIB/w3mhelperpanel"><input type=hidden name=mode value=panel><input type=hidden name=cookie value="%s"><input type=submit value="%s"></form><br><form method=internal action=option>");
    }
    OptionCharset = SystemCharset;
    if(OptionEncode != 0) {
        _v32 = Strdup(optionpanel_str);
        Strcat_charp(_v32, "<table><tr><td>");
        _v52 = 0;
        while( *( &sections + _v52 * 8) != 0) {
            goto L19;
        }
    } else {
        optionpanel_str = wc_Str_conv(optionpanel_str, OptionCharset, InnerCharset);
        _v52 = 0;
        while( *( &sections + _v52 * 8) != 0) {
            while( *_v36 != 0) {
                _v36->comment =  *(wc_Str_conv(Strnew_charp(gettext(_v36->comment)), OptionCharset, InnerCharset));
                if(_v36->inputtype != 2 || _v36->select ==  &colorstr) {
                    _v36 = _v36 + 24;
                    continue;
                } else {
                    _v40 = _v36->select;
                }
                while( *(_v40 + 8) != 0) {
                     *(_v40 + 8) =  *(wc_Str_conv(Strnew_charp(gettext( *(_v40 + 8))), OptionCharset, InnerCharset));
                    _v40 = _v40 + 12;
                }
            }
        }
    }
L19:
    _v116.inputtype = 0;
    _v116.type = "</h1>";
    _v116.name =  *( &sections + _v52 * 8);
    _v120 = "<h1>";
    Strcat_m_charp(_v32);
    _v36 =  *(135096292 + _v52 * 8);
    Strcat_charp(_v32, "<table width=100% cellpadding=0>");
    while( *_v36 != 0) {
        _v116.type = 0;
        _v116.name = _v36->comment;
        _v120 = "<tr><td>";
        Strcat_m_charp(_v32);
        asm("fld qword [0x80d53a0]");
        asm("fld qword [0x80ce460]");
        asm("fmulp st1, st0");
        asm("fnstcw word [ebp-0x3a]");
        _v64 = _v62 & 65535 & 4294967295;
        asm("fldcw word [ebp-0x3c]");
        asm("fistp dword [ebp-0x40]");
        asm("fldcw word [ebp-0x3a]");
        _v120 = _v68;
        Strcat(_v32, Sprintf("</td><td width=%d>"));
        _t273 = _v36->inputtype;
        if(_t273 == 1) {
            _v48 = atoi( *(to_str(_v36)));
            if(_v48 == 0) {
                _t436 = " checked";
            } else {
                _t436 = 135062232;
            }
            _t423 =  *_v36;
            if(_v48 == 0) {
                _t279 = 135062232;
            } else {
                _t279 = " checked";
            }
            _v84 = 0;
            _v88 = ">NO";
            _v92 = _t436;
            _v116.select = " value=0";
            _v116.comment.name = _t423;
            _v116.varptr = ">YES&nbsp;&nbsp;<input type=radio name=";
            _v116.inputtype = _t279;
            _v116.type = " value=1";
            _v116.name =  *_v36;
            _v120 = "<input type=radio name=";
            Strcat_m_charp(_v32);
            goto L54;
        }
        if(_t273 > 1) {
            if(_t273 == 2) {
                _v56 = to_str(_v36);
                _v116.inputtype = 0;
                _v116.type = ">";
                _v116.name =  *_v36;
                _v120 = "<select name=";
                Strcat_m_charp(_v32);
                _v40 = _v36->select;
L44:
                while( *(_v40 + 8) != 0) {
                    goto L36;
                }
            }
            goto L25;
L36:
            Strcat_charp(_v32, "<option value=");
            _v120 =  *(_v40 + 4);
            Strcat(_v32, Sprintf("%s\n"));
            if(_v36->type == 3 ||  *_v40 != atoi( *_v56)) {
                if(_v36->type != 3 || ( *_v40 & 4294967295) != ( *( *_v56) & 255 & 4294967295)) {
L41:
                    if(_v32->length + 1 >= _v32->area_size) {
                        Strgrow(_v32);
                    }
                    _t306 = _v32->length;
                     *((char*)( *_v32 + _t306)) = 62;
                    _v32->length = _t306 + 1;
                     *( *_v32 + _v32->length) = 0;
                    Strcat_charp(_v32,  *(_v40 + 8));
                    _v40 = _v40 + 12;
                    goto L44;
                }
            }
L40:
            Strcat_charp(_v32, " selected");
            goto L41;
        }
        if(_t273 == 0) {
            _t367 = html_quote( *(to_str(_v36)));
            _v116.comment = 0;
            _v116.varptr = "">";
            _v116.inputtype = _t367;
            _v116.type = " value="";
            _v116.name =  *_v36;
            _v120 = "<input type=text name=";
            Strcat_m_charp(_v32);
        }
L54:
        Strcat_charp(_v32, "</td></tr>\n");
        _v36 = _v36 + 24;
        continue;
L25:
        if(_t273 == 3) {
            _v56 = to_str(_v36);
            _v116.inputtype = 0;
            _v116.type = ">";
            _v116 =  *_v36;
            _v120 = "<select name=";
            Strcat_m_charp(_v32);
            _v44 =  *(_v36->select);
L52:
            while( *(_v44 + 8) != 0) {
                goto L47;
            }
        }
        goto L54;
L47:
        Strcat_charp(_v32, "<option value=");
        _v120 =  *(_v44 + 4);
        Strcat(_v32, Sprintf("%s\n"));
        if( *_v44 == atoi( *_v56)) {
            Strcat_charp(_v32, " selected");
        }
        if(_v32->length + 1 >= _v32->area_size) {
            Strgrow(_v32);
        }
        _t352 = _v32->length;
         *((char*)( *_v32 + _t352)) = 62;
        _v32->length = _t352 + 1;
         *( *_v32 + _v32->length) = 0;
        Strcat_charp(_v32,  *(_v44 + 8));
        _v44 = _v44 + 12;
        goto L52;
    }
}

panel_set_option(struct parsed_tagarg* arg)
{// addr = 0x08093C71
    FILE* f;
    char* p;
    struct _IO_FILE* _v16;
    char* _v20;
    char* _v32;
    char* _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    struct parsed_tagarg* _t35;
    _unknown_ _t48;

    _v16 = 0;
    if(no_rc_dir == 0) {
        _v16 = fopen(config_file, "wt");
        if(_v16 == 0) {
            disp_message("Can't write option!", 0);
        }
    } else {
        disp_message("There's no ~/.w3m directory... config not saved", 0);
    }
    while(arg != 0) {
        if(arg->value != 0) {
            _v20 =  *(wc_Str_conv_strict(Strnew_charp(arg->value), InnerCharset, SystemCharset));
            if(set_param(arg->arg, _v20) != 0 && _v16 != 0) {
                _v32 = _v20;
                _v36 = arg->arg;
                fprintf(_v16, "%s %s\n");
            }
        }
        _t35 = arg;
        _t32 = _t35->next;
        arg = _t35->next;
    }
}

char* rcFile(char* base)
{// addr = 0x08093D8E
    intOrPtr _v16;
    char* _v20;
    char* _v24;
    _unknown_ __ebp;

    if(base == 0) {
L9:
        _v16 = 0;
        _v20 = base;
        _v24 = "/";
        return expandPath( *(Strnew_m_charp(rc_dir)));
    }
    if(( *base & 255 & 4294967295) == 47) {
        return expandPath(base);
    }
    if(( *base & 255 & 4294967295) == 46) {
        if((base[1] & 255 & 4294967295) == 47) {
            return expandPath(base);
        }
        if((base[1] & 255 & 4294967295) == 46) {
            if((base[2] & 255 & 4294967295) == 47) {
                return expandPath(base);
            }
        }
    }
    if(( *base & 255 & 4294967295) == 126) {
        if((base[1] & 255 & 4294967295) == 47) {
            return expandPath(base);
        }
    }
    goto L9;
    return __eax;
}

char* auxbinFile(char* base)
{// addr = 0x08093E29
    intOrPtr _v16;
    char* _v20;
    char* _v24;
    _unknown_ __ebp;
    _unknown_ _t5;
    char* _t6;

    _t6 = w3m_auxbin_dir();
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(_t6)));
}

char* etcFile(char* base)
{// addr = 0x08093E5F
    intOrPtr _v16;
    char* _v20;
    char* _v24;
    _unknown_ __ebp;
    _unknown_ _t5;
    char* _t6;

    _t6 = w3m_etc_dir();
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(_t6)));
}

char* confFile(char* base)
{// addr = 0x08093E95
    intOrPtr _v16;
    char* _v20;
    char* _v24;
    _unknown_ __ebp;
    _unknown_ _t5;
    char* _t6;

    _t6 = w3m_conf_dir();
    _v16 = 0;
    _v20 = base;
    _v24 = "/";
    return expandPath( *(Strnew_m_charp(_t6)));
}

new_menu(Menu* menu, MenuItem* item)
{// addr = 0x08093ECC
    int i;
    int l;
    char* p;
    signed int _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    menu->cursorX = 0;
    menu->cursorY = 0;
    menu->x = 0;
    menu->y = 0;
    menu->nitem = 0;
    menu->item = item;
    menu->initial = 0;
    menu->select = 0;
    menu->offset = 0;
    menu->active = 0;
    if(item == 0) {
        return ;
    }
    _v16 = 0;
    while( *((intOrPtr*)(item + (_v16 << 5))) != 0) {
        _v16 = _v16 + 1;
    }
}

geom_menu(Menu* menu, int x, int y, int mselect)
{// addr = 0x08094062
    int win_x;
    int win_y;
    int win_w;
    int win_h;
    intOrPtr _v12;
    intOrPtr _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    int _v28;
    _unknown_ __ebp;
    _unknown_ _t90;
    _unknown_ _t132;
    _unknown_ _t140;
    _unknown_ _t161;
    _unknown_ _t182;
    _unknown_ _t190;
    _unknown_ _t191;

    menu->select = mselect;
    if(menu->width % FRAME_WIDTH != 0) {
        _v28 = FRAME_WIDTH;
        menu->width = (menu->width / _v28 + 1) * FRAME_WIDTH;
    }
    _v12 = menu->x - FRAME_WIDTH;
    _v20 = menu->width + FRAME_WIDTH + FRAME_WIDTH;
    if(_v12 + _v20 > COLS) {
        _v12 = COLS - _v20;
    }
    if(_v12 < 0) {
        _v12 = 0;
        if(_v20 > COLS) {
            menu->width = 0 - FRAME_WIDTH + 0 - FRAME_WIDTH + COLS;
            menu->width = menu->width - menu->width % FRAME_WIDTH;
            _v20 = menu->width + FRAME_WIDTH + FRAME_WIDTH;
        }
    }
    menu->x = FRAME_WIDTH + _v12;
    _v16 = menu->y - mselect - 1;
    _v24 = menu->height + 2;
    if(_v16 + _v24 > LINES - 1) {
        _v16 = LINES - 1 - _v24;
    }
    if(_v16 < 0) {
        _v16 = 0;
        if(_v16 + _v24 > LINES - 1) {
            _v24 = LINES - 1 - _v16;
            menu->height = _v24 - 2;
            if(menu->height <= mselect) {
                menu->offset = mselect - menu->height + 1;
            }
        }
    }
    menu->y = _v16 + 1;
    return;
}

draw_all_menu(Menu* menu)
{// addr = 0x08094220
    _unknown_ __ebp;

    if(menu->parent != 0) {
        draw_all_menu(menu->parent);
    }
    draw_menu(menu);
    return;
}

draw_menu(Menu* menu)
{// addr = 0x08094249
    int x;
    int y;
    int w;
    int i;
    int j;
    int _v16;
    int _v20;
    intOrPtr _v24;
    int _v28;
    _unknown_ _v32;
    _unknown_ _v48;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t310;
    _unknown_ _t311;
    _unknown_ _t325;
    _unknown_ _t326;

    _v16 = menu->x - FRAME_WIDTH;
    _v24 = menu->width + FRAME_WIDTH + FRAME_WIDTH;
    _v20 = menu->y - 1;
    if(menu->offset != 0) {
        if( *135779308 != 0) {
            graphstart();
        }
        move(_v20, _v16);
        addstr(FRAME[5]);
        if( *135779308 != 0) {
            graphend();
        }
        _v28 = FRAME_WIDTH;
        while(_v24 - FRAME_WIDTH > _v28) {
            move(_v20, _v16 + _v28);
            addstr(135063018);
            _v28 = _v28 + 1;
        }
    }
    if( *135779308 != 0) {
        graphstart();
    }
    move(_v20, _v16);
    addstr(FRAME[3]);
    _v28 = FRAME_WIDTH;
    while(_v24 - FRAME_WIDTH > _v28) {
        move(_v20, _v16 + _v28);
        addstr(FRAME[0xa]);
        _v28 = _v28 + FRAME_WIDTH;
    }
}

draw_menu_item(Menu* menu, int mselect)
{// addr = 0x0809473B
    _unknown_ _v24;
    _unknown_ __ebx;
    _unknown_ __ebp;

    move(menu->y + mselect - menu->offset, menu->x);
    addnstr_sup( *(menu->item + (mselect << 5) + 4), menu->width);
    return;
}

int select_menu(Menu* menu, int mselect)
{// addr = 0x08094794
    _unknown_ _v24;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t58;

    if(mselect >= 0) {
        return -1;
    }
    if(menu->nitem <= mselect) {
        return -1;
    }
    if(menu->offset <= mselect) {
        if(menu->offset + menu->height <= mselect) {
            down_menu(menu, mselect - menu->offset - menu->height + 1);
        }
    } else {
        up_menu(menu, menu->offset - mselect);
    }
    if(menu->select >= menu->offset && menu->select < menu->offset + menu->height) {
        draw_menu_item(menu, menu->select);
    }
    menu->select = mselect;
    standout();
    draw_menu_item(menu, menu->select);
    standend();
    move(menu->y + mselect - menu->offset, menu->x);
    toggle_stand();
    refresh();
    return menu->select;
}

goto_menu(Menu* menu, int mselect, int down)
{// addr = 0x080948BD
    int select_in;
    int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t58;

    if(menu->nitem > mselect) {
        if(mselect < 0) {
            mselect = 0;
        }
    } else {
        mselect = menu->nitem - 1;
    }
    _v16 = mselect;
    while( *((intOrPtr*)(menu->item + (mselect << 5))) == 1) {
        if(down <= 0) {
            if(down >= 0) {
                return ;
            }
            mselect = mselect - 1;
            if(mselect >= 0) {
                continue;
            } else {
                up_menu(menu, menu->select - _v16);
                mselect = menu->select;
            }
L12:
            select_menu(menu, mselect);
            return;
        }
        mselect = mselect + 1;
        if(mselect < menu->nitem) {
            continue;
        }
        down_menu(menu, _v16 - menu->select);
        mselect = menu->select;
        goto L12;
    }
}

up_menu(Menu* menu, int n)
{// addr = 0x08094992
    _unknown_ __ebp;
    _unknown_ _t14;

    if(n >= 0) {
        return ;
    }
    if(menu->offset == 0) {
        return ;
    }
    menu->offset = menu->offset - n;
    if(menu->offset < 0) {
        menu->offset = 0;
    }
    draw_menu(menu);
    return;
}

down_menu(Menu* menu, int n)
{// addr = 0x080949E0
    _unknown_ __ebp;
    _unknown_ _t26;

    if(n >= 0) {
        return ;
    }
    if(menu->offset + menu->height == menu->nitem) {
        return ;
    }
    menu->offset = menu->offset + n;
    if(menu->offset + menu->height > menu->nitem) {
        menu->offset = menu->nitem - menu->height;
    }
    draw_menu(menu);
    return;
}

int action_menu(Menu* menu)
{// addr = 0x08094A54
    char c;
    int mselect;
    MenuItem item;
    _unknown_ _v13;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t73;
    _unknown_ _t83;
    _unknown_ _t84;
    _unknown_ _t93;
    _unknown_ _t110;
    _unknown_ _t114;

    if(menu->active == 0) {
        if(menu->parent != 0) {
            menu->parent->active = 0;
        }
        return ;
    }
    draw_all_menu(menu);
    select_menu(menu, menu->select);
L7:
    while(1) {
        while(1) {
        }
    }
}

popup_menu(Menu* parent, Menu* menu)
{// addr = 0x08094C1B
    int active;
    int _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = 1;
    if(menu->item == 0) {
        return ;
    }
    if(menu->nitem == 0) {
        return ;
    }
    if(menu->active != 0) {
        return ;
    }
    __imp__gpm_handler = gpm_process_menu_mouse;
    menu->parent = parent;
    menu->select = menu->initial;
    menu->offset = 0;
    menu->active = 1;
    if(parent != 0) {
        menu->cursorX = parent->cursorX;
        menu->cursorY = parent->cursorY;
        guess_menu_xy(parent, menu->width,  &(menu->x),  &(menu->y));
    }
    geom_menu(menu, menu->x, menu->y, menu->select);
    CurrentMenu = menu;
    while(_v16 != 0) {
        _v16 = action_menu(CurrentMenu);
        displayBuffer(CurrentTab->currentBuffer, 1);
    }
}

guess_menu_xy(Menu* parent, int width, int* x, int* y)
{// addr = 0x08094D5C
    _unknown_ __ebp;

     *x = parent->x + parent->width + FRAME_WIDTH - 1;
    if( *x + width + FRAME_WIDTH > COLS) {
         *x = COLS - width - FRAME_WIDTH;
        if(parent->x + ((parent->width >> 31) + parent->width >> 1) >  *x) {
            _t64 = parent->width;
            if(parent->x + ((parent->width >> 31) + _t64 >> 1) > (COLS >> 31) + COLS >> 1) {
                 *x = parent->x - width - FRAME_WIDTH + 1;
            }
        }
    }
     *y = parent->y + parent->select - parent->offset;
    return;
}

new_option_menu(Menu* menu, char** label, int* variable, _None* func)
{// addr = 0x08094E38
    int i;
    int nitem;
    char** p;
    MenuItem* item;
    intOrPtr _v16;
    _unknown_ _v20;
    char** _v24;
    _unknown_ _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t56;
    _unknown_ _t65;

    if(label == 0) {
        return ;
    }
    if( *label == 0) {
        return ;
    }
    _v16 = 0;
    _v24 = label;
    while( *_v24 != 0) {
        _v16 = _v16 + 1;
        _v24 =  &(_v24[1]);
    }
}

set_menu_frame()
{// addr = 0x08094F62
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t3;

    if(graph_ok() == 0) {
         *135779308 = 0;
        FRAME_WIDTH = 0;
        FRAME = get_symbol(DisplayCharset,  &FRAME_WIDTH);
        if(( *135119023 & 255 & 4294967295) != 0) {
            return ;
        }
        FRAME_WIDTH = 1;
        return;
    }
     *135779308 = 1;
    FRAME_WIDTH = 1;
    FRAME =  &graph_symbol;
    return;
}

int mEsc(char c)
{// addr = 0x08094FD6
    signed char _v16;
    _unknown_ __ebp;

    _v16 = c & 4294967295;
    _v16 = do_getch() & 4294967295;
     *__esp = _v16;
     *((intOrPtr*)( *((intOrPtr*)( &MenuEscKeymap + _v16 * 4))))();
    return;
}

int mEscB(char c)
{// addr = 0x08095000
    signed int _v16;
    _unknown_ __ebp;
    _unknown_ _t25;

    _v16 = c & 4294967295;
    _v16 = do_getch() & 4294967295;
    if(( *( &MYCTYPE_MAP + (_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
         *__esp = _v16;
         *((intOrPtr*)( *((intOrPtr*)( &MenuEscBKeymap + _v16 * 4))))();
        return;
    }
    mEscD(_v16);
    return;
}

int mEscD(char c)
{// addr = 0x08095050
    int d;
    signed int _v16;
    signed int _v32;
    _unknown_ __ebp;
    _unknown_ _t32;

    _v32 = c & 4294967295;
    _v16 = _v32 - 48;
    _v32 = do_getch() & 4294967295;
    if(( *( &MYCTYPE_MAP + (_v32 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
        _v16 = (_v16 << 2) + _v16 + (_v16 << 2) + _v16 + _v32 - 48;
        _v32 = do_getch() & 4294967295;
    }
    if(_v32 != 126) {
        return ;
    }
     *__esp = _v32;
     *((intOrPtr*)( *((intOrPtr*)( &MenuEscDKeymap + _v16 * 4))))();
    return;
}

int mNull(char c)
{// addr = 0x080950CB
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t5;

    _v8 = c & 4294967295;
    return -1;
}

int mSelect(char c)
{// addr = 0x080950DE
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t19;

    _v16 = c & 4294967295;
    if(( *( &MYCTYPE_MAP + (_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 17) == 0) {
        return -1;
    }
    return select_menu(CurrentMenu,  *(CurrentMenu + 4 + (_v16 + 140) * 4));
}

int mDown(char c)
{// addr = 0x0809512F
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t18;
    _unknown_ _t19;

    _v16 = c & 4294967295;
    if(CurrentMenu->select >= CurrentMenu->nitem - 1) {
        return -1;
    }
    goto_menu(CurrentMenu, CurrentMenu->select + 1, 1);
    return -1;
}

int mUp(char c)
{// addr = 0x08095184
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t15;
    _unknown_ _t16;

    _v16 = c & 4294967295;
    if(CurrentMenu->select <= 0) {
        return -1;
    }
    goto_menu(CurrentMenu, CurrentMenu->select - 1, -1);
    return -1;
}

int mLast(char c)
{// addr = 0x080951CE
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t12;

    _v16 = c & 4294967295;
    goto_menu(CurrentMenu, CurrentMenu->nitem - 1, -1);
    return -1;
}

int mTop(char c)
{// addr = 0x08095205
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t8;

    _v16 = c & 4294967295;
    goto_menu(CurrentMenu, 0, 1);
    return -1;
}

int mNext(char c)
{// addr = 0x08095235
    int mselect;
    int _v16;
    char _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t26;

    _v32 = c & 4294967295;
    _v16 = CurrentMenu->select + CurrentMenu->height;
    if(CurrentMenu->nitem <= _v16) {
        return mLast(_v32);
    }
    down_menu(CurrentMenu, CurrentMenu->height);
    goto_menu(CurrentMenu, _v16, -1);
    return -1;
}

int mPrev(char c)
{// addr = 0x080952AE
    int mselect;
    int _v16;
    char _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t22;

    _v32 = c & 4294967295;
    _v16 = CurrentMenu->select - CurrentMenu->height;
    if(_v16 < 0) {
        return mTop(_v32);
    }
    up_menu(CurrentMenu, CurrentMenu->height);
    goto_menu(CurrentMenu, _v16, 1);
    return -1;
}

int mFore(char c)
{// addr = 0x08095323
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t26;
    _unknown_ _t27;

    _v16 = c & 4294967295;
    if(CurrentMenu->select >= CurrentMenu->nitem - 1) {
        return -1;
    }
    goto_menu(CurrentMenu, CurrentMenu->select + CurrentMenu->height - 1, CurrentMenu->height + 1);
    return -1;
}

int mBack(char c)
{// addr = 0x0809538A
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t21;
    _unknown_ _t22;

    _v16 = c & 4294967295;
    if(CurrentMenu->select <= 0) {
        return -1;
    }
    goto_menu(CurrentMenu, CurrentMenu->select - CurrentMenu->height + 1,  !(CurrentMenu->height));
    return -1;
}

int mLineU(char c)
{// addr = 0x080953EF
    int mselect;
    int _v16;
    char _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t36;

    _v32 = c & 4294967295;
    _v16 = CurrentMenu->select;
    if(CurrentMenu->nitem <= _v16) {
        return mLast(_v32);
    }
    if(CurrentMenu->offset + CurrentMenu->height < CurrentMenu->nitem) {
        down_menu(CurrentMenu, 1);
        if(CurrentMenu->offset > _v16) {
            _v16 = _v16 + 1;
        }
    } else {
        _v16 = _v16 + 1;
    }
    goto_menu(CurrentMenu, _v16, 1);
    return -1;
}

int mLineD(char c)
{// addr = 0x0809548E
    int mselect;
    int _v16;
    char _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t32;

    _v32 = c & 4294967295;
    _v16 = CurrentMenu->select;
    if(_v16 <= 0) {
        return mTop(_v32);
    }
    if(CurrentMenu->offset > 0) {
        up_menu(CurrentMenu, 1);
        if(CurrentMenu->offset + CurrentMenu->height <= _v16) {
            _v16 = _v16 - 1;
        }
    } else {
        _v16 = _v16 - 1;
    }
    goto_menu(CurrentMenu, _v16, -1);
    return -1;
}

int mOk(char c)
{// addr = 0x0809551F
    int mselect;
    signed int _v8;
    signed int _v24;
    _unknown_ __ebp;
    _unknown_ _t17;

    _v24 = c & 4294967295;
    _v8 = CurrentMenu->select;
    if( *((intOrPtr*)(CurrentMenu->item + (_v8 << 5))) != 1) {
        return _v8;
    }
    return -1;
}

int mCancel(char c)
{// addr = 0x08095559
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t5;

    _v8 = c & 4294967295;
    return -2;
}

int mClose(char c)
{// addr = 0x0809556C
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t5;

    _v8 = c & 4294967295;
    return -3;
}

int mSusp(char c)
{// addr = 0x0809557F
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t10;
    _unknown_ _t11;

    _v16 = c & 4294967295;
    susp();
    draw_all_menu(CurrentMenu);
    select_menu(CurrentMenu, CurrentMenu->select);
    return -1;
}

int menuForwardSearch(Menu* menu, char* str, int from)
{// addr = 0x080955BD
    int i;
    char* p;
    signed int _v16;
    char* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t43;
    _unknown_ _t45;

    _v20 = regexCompile(str, IgnoreCase);
    if(_v20 == 0) {
        if(from < 0) {
            from = 0;
        }
        _v16 = from;
        while(menu->nitem > _v16) {
            if( *((intOrPtr*)(menu->item + (_v16 << 5))) != 1) {
                if(regexMatch( *(menu->item + (_v16 << 5) + 4), -1, 1) == 1) {
                    return _v16;
                }
            }
            _v16 = _v16 + 1;
        }
    }
    message(_v20, 0, 0);
    return -1;
}

int menu_search_forward(Menu* menu, int from)
{// addr = 0x08095675
    char* str;
    int found;
    char* _v16;
    int _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t34;
    _unknown_ _t47;

    _v16 = inputLineHistSearch("Forward: ", 0, 16, TextHist, 0);
    if(_v16 != 0 && ( *_v16 & 255 & 4294967295) == 0) {
        _v16 =  *135782592;
    }
    if(_v16 == 0) {
        return -1;
    }
    if(( *_v16 & 255 & 4294967295) == 0) {
        return -1;
    }
     *135782592 = _v16;
    _v16 = conv_search_string(_v16, DisplayCharset);
    menuSearchRoutine = menuForwardSearch;
    _v20 = menuForwardSearch(menu, _v16, from + 1);
    if(WrapSearch != 0 && _v20 == 255) {
        _v20 = menuForwardSearch(menu, _v16, 0);
    }
    if(_v20 < 0) {
        return _v20;
    }
    disp_message("Not found", 1);
    return -1;
}

int mSrchF(char c)
{// addr = 0x08095777
    int mselect;
    int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t15;

    _v32 = c & 4294967295;
    _v16 = menu_search_forward(CurrentMenu, CurrentMenu->select);
    if(_v16 >= 0) {
        return -1;
    }
    goto_menu(CurrentMenu, _v16, 1);
    return -1;
}

int menuBackwardSearch(Menu* menu, char* str, int from)
{// addr = 0x080957C8
    int i;
    char* p;
    signed int _v16;
    char* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t39;
    _unknown_ _t50;

    _v20 = regexCompile(str, IgnoreCase);
    if(_v20 == 0) {
        if(menu->nitem <= from) {
            from = menu->nitem - 1;
        }
        _v16 = from;
        while(_v16 >= 0) {
            if( *((intOrPtr*)(menu->item + (_v16 << 5))) != 1) {
                if(regexMatch( *(menu->item + (_v16 << 5) + 4), -1, 1) == 1) {
                    return _v16;
                }
            }
            _v16 = _v16 - 1;
        }
    }
    message(_v20, 0, 0);
    return -1;
}

int menu_search_backward(Menu* menu, int from)
{// addr = 0x08095885
    char* str;
    int found;
    char* _v16;
    int _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t36;
    _unknown_ _t49;

    _v16 = inputLineHistSearch("Backward: ", 0, 16, TextHist, 0);
    if(_v16 != 0 && ( *_v16 & 255 & 4294967295) == 0) {
        _v16 =  *135782592;
    }
    if(_v16 == 0) {
        return -1;
    }
    if(( *_v16 & 255 & 4294967295) == 0) {
        return -1;
    }
     *135782592 = _v16;
    _v16 = conv_search_string(_v16, DisplayCharset);
    menuSearchRoutine = menuBackwardSearch;
    _v20 = menuBackwardSearch(menu, _v16, from - 1);
    if(WrapSearch != 0 && _v20 == 255) {
        _v20 = menuBackwardSearch(menu, _v16, menu->nitem);
    }
    if(_v20 < 0) {
        return _v20;
    }
    disp_message("Not found", 1);
    return -1;
}

int mSrchB(char c)
{// addr = 0x08095989
    int mselect;
    int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t15;

    _v32 = c & 4294967295;
    _v16 = menu_search_backward(CurrentMenu, CurrentMenu->select);
    if(_v16 >= 0) {
        return -1;
    }
    goto_menu(CurrentMenu, _v16, -1);
    return -1;
}

int menu_search_next_previous(Menu* menu, int from, int reverse)
{// addr = 0x080959DA
    int found;
    char* str;
    Menu* _v16;
    char* _v20;
    int _v36;
    char* _v40;
    _unknown_ __ebp;
    int _t39;
    Menu* _t43;
    _unknown_ _t45;
    _unknown_ _t46;
    Menu* _t52;
    _unknown_ _t53;

    if(menuSearchRoutine != 0) {
        _v20 = conv_search_string( *135782592, DisplayCharset);
        if(reverse != 0) {
            reverse = 1;
        }
        if(menuSearchRoutine == menuBackwardSearch) {
            reverse = reverse ^ 1;
        }
        if(reverse == 0) {
            _t39 = 1;
        } else {
            _t39 = -1;
        }
        from = from + _t39;
        _v36 = from;
        _v40 = _v20;
        _t43 = menu;
         *__esp = _t43;
         *((intOrPtr*)( *((intOrPtr*)(135099568 + reverse * 4))))();
        _v16 = _t43;
        if(WrapSearch != 0 && _v16 == 255) {
            _v36 = menu->nitem * reverse;
            _v40 = _v20;
            _t52 = menu;
             *__esp = _t52;
             *((intOrPtr*)( *((intOrPtr*)(135099568 + reverse * 4))))();
            _v16 = _t52;
        }
        if(_v16 < 0) {
            return ;
        }
        disp_message("Not found", 1);
        return;
    }
    disp_message("No previous regular expression", 1);
    return;
}

int mSrchN(char c)
{// addr = 0x08095AD5
    int mselect;
    int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t16;

    _v32 = c & 4294967295;
    _v16 = menu_search_next_previous(CurrentMenu, CurrentMenu->select, 0);
    if(_v16 >= 0) {
        return -1;
    }
    goto_menu(CurrentMenu, _v16, 1);
    return -1;
}

int mSrchP(char c)
{// addr = 0x08095B2E
    int mselect;
    int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t16;

    _v32 = c & 4294967295;
    _v16 = menu_search_next_previous(CurrentMenu, CurrentMenu->select, 1);
    if(_v16 >= 0) {
        return -1;
    }
    goto_menu(CurrentMenu, _v16, -1);
    return -1;
}

int mMouse_scroll_line()
{// addr = 0x08095B87
    int i;
    int _v8;
    _unknown_ __ebp;
    _unknown_ _t14;
    _unknown_ _t20;
    _unknown_ _t28;

    _v8 = 0;
    if(relative_wheel_scroll == 0) {
        _v8 = fixed_wheel_scroll_count;
    } else {
        _v8 = ((relative_wheel_scroll_ratio * CurrentMenu->height + 99) * 1374389535 >> 32 >> 5) - (relative_wheel_scroll_ratio * CurrentMenu->height + 99 >> 31);
    }
    if(_v8 == 0) {
        return 1;
    }
    return _v8;
}

int process_mMouse(int btn, int x, int y)
{// addr = 0x08095BE6
    Menu* menu;
    int mselect;
    int i;
    char c;
    char _v13;
    Menu* _v20;
    signed int _v24;
    intOrPtr _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t109;
    _unknown_ _t116;
    _unknown_ _t120;
    _unknown_ _t123;
    int _t124;
    _unknown_ _t128;
    _unknown_ _t170;
    _unknown_ _t172;
    _unknown_ _t173;
    _unknown_ _t175;
    _unknown_ _t176;
    _unknown_ _t180;
    _unknown_ _t181;
    _unknown_ _t185;
    _unknown_ _t186;
    _unknown_ _t192;
    _unknown_ _t197;
    _unknown_ _t200;

    _v13 = 32;
    _v20 = CurrentMenu;
    if(x >= 0) {
        return -1;
    }
    if(x >= COLS) {
        return -1;
    }
    if(y >= 0) {
        return -1;
    }
    if(LINES - 1 < y) {
        return -1;
    }
    if(btn != 3) {
        if(btn != 64) {
            if(btn != 65) {
                goto L57;
            }
            goto L54;
        }
        goto L49;
L54:
        _v28 = 0;
        while(mMouse_scroll_line() > _v28) {
            mLineU(_v13);
            _v28 = _v28 + 1;
        }
    } else {
        _t124 =  *135099564;
        if(_t124 == 2) {
L13:
            if(_v20->x - FRAME_WIDTH > x) {
                return -2;
            }
            if(_v20->x + _v20->width + FRAME_WIDTH <= x) {
                return -2;
            }
            if(_v20->y - 1 > y) {
                return -2;
            }
            if(_v20->y + _v20->height + 1 <= y) {
                return -2;
            }
            if(_v20->x - FRAME_WIDTH <= x) {
                if(_v20->x > x) {
                    return -1;
                }
            }
            if(_v20->x + _v20->width <= x) {
                if(_v20->x + _v20->width + FRAME_WIDTH > x) {
                    return -1;
                }
            }
            if( *135782596 <= y) {
                if( *135782596 >= y) {
                    if(_v20->y - 1 != y) {
                        if(_v20->y + _v20->height != y) {
                            _v24 = y - _v20->y + _v20->offset;
                            if( *((intOrPtr*)(_v20->item + (_v24 << 5))) != 1) {
                                return select_menu(_v20, _v24);
                            }
                            return -1;
                        }
                        goto L36;
                    }
                    goto L34;
L36:
                    mNext(_v13);
                    return -1;
                }
                goto L29;
L34:
                mPrev(_v13);
                return -1;
            } else {
                _v28 = 0;
                while( *135782596 - y > _v28) {
                    mLineU(_v13);
                    _v28 = _v28 + 1;
                }
            }
L29:
            _v28 = 0;
            while(y -  *135782596 > _v28) {
                mLineD(_v13);
                _v28 = _v28 + 1;
            }
        }
        if(_t124 > 2) {
            if(_t124 == 3) {
                _v28 = 0;
L42:
                while(mMouse_scroll_line() > _v28) {
                    goto L41;
                }
            }
            goto L11;
L41:
            mLineD(_v13);
            _v28 = _v28 + 1;
            goto L42;
        }
        if(_t124 == 0) {
            goto L13;
        }
L57:
        if(btn != 3 ||  *135099564 == 255) {
             *135099564 = btn;
             *135782600 = x;
             *135782596 = y;
            return -1;
        }
         *135099564 = -1;
        return -1;
L11:
        if(_t124 == 4) {
            _v28 = 0;
            while(mMouse_scroll_line() > _v28) {
                mLineU(_v13);
                _v28 = _v28 + 1;
            }
        }
        goto L57;
    }
L49:
    _v28 = 0;
    while(mMouse_scroll_line() > _v28) {
        mLineD(_v13);
        _v28 = _v28 + 1;
    }
}

int mMouse(char c)
{// addr = 0x08095F06
    int btn;
    int x;
    int y;
    int _v16;
    int _v20;
    int _v24;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v32 = c & 4294967295;
    _v16 = (do_getch() & 4294967295 & ) - 32;
    _v20 = (do_getch() & 4294967295 & ) - 33;
    if(_v20 < 0) {
        _v20 = _v20 + 256;
    }
    _v24 = (do_getch() & 4294967295 & ) - 33;
    if(_v24 >= 0) {
        return process_mMouse(_v16, _v20, _v24);
    }
    _v24 = _v24 + 256;
    return process_mMouse(_v16, _v20, _v24);
}

int gpm_process_menu_mouse(Gpm_Event* event, _Unknown_base* data)
{// addr = 0x08095F71
    int btn;
    int x;
    int y;
    signed int _v16;
    signed int _v20;
    signed int _v24;
    int* _v36;
    intOrPtr _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int* _t44;
    signed int* _t48;
    _unknown_ _t53;
    signed int _t56;
    _unknown_ _t66;

    _v16 = -1;
    if((event->type & 8) == 0) {
        if((event->type & 4) == 0) {
             *135774721 = 2;
            _t44 =  &(__imp___gpm_arg[1]);
             *_t44 = (event->x & 65535) + __imp__gpm_zerobased & 4294967295;
             *__imp___gpm_arg =  *_t44 & 65535 & 4294967295;
            _t48 =  &(__imp___gpm_arg[1]);
             *_t48 = (event->y & 65535) + __imp__gpm_zerobased & 4294967295;
            __imp___gpm_arg[0] =  *_t48 & 65535 & 4294967295;
            __imp___gpm_arg[2] = 3;
            _v36 = 135774721;
            _v40 = 21532;
             *__esp = __imp__gpm_consolefd;
            ioctl();
            return 0;
        } else {
            _t56 = event->buttons & 255 & 4294967295 & ;
            if(_t56 == 2) {
                _v16 = 1;
            } else {
                if(_t56 == 4) {
                    _v16 = 0;
                } else {
                    if(_t56 == 1) {
                        _v16 = 2;
                    }
                }
            }
        }
    } else {
        _v16 = 3;
    }
L11:
    asm("cwde ");
    _v20 = event->x & 65535;
    asm("cwde ");
    _v24 = event->y & 65535;
    X_Mouse_Selection = process_mMouse(_v16, _v20 - 1, _v24 - 1);
    return -1;
}

popupMenu(int x, int y, Menu* menu)
{// addr = 0x080960B8
    _unknown_ _v24;
    _unknown_ __ebp;

    set_menu_frame();
    initSelectMenu();
    initSelTabMenu();
    asm("cwde ");
    menu->cursorX = (CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    menu->cursorY = (CurrentTab->currentBuffer->cursorY & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootY & 65535);
    menu->x = FRAME_WIDTH + x + 1;
    menu->y = y + 2;
    popup_menu(0, menu);
    return;
}

mainMenu(int x, int y)
{// addr = 0x08096147
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    popupMenu(x, y,  &MainMenu);
    return;
}

mainMn()
{// addr = 0x08096169
    Menu* menu;
    char* data;
    int n;
    int x;
    int y;
    Menu* _v16;
    char* _v20;
    int _v24;
    int _v28;
    int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 =  &MainMenu;
    asm("cwde ");
    _v28 = (CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    _v32 = (CurrentTab->currentBuffer->cursorY & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootY & 65535);
    _v20 = searchKeyData();
    if(_v20 != 0) {
        _v24 = getMenuN(w3mMenuList, _v20);
        if(_v24 >= 0) {
            return ;
        }
        _v16 =  *(w3mMenuList + (_v24 + _v24 + _t65 << 2) + 4);
    }
    if( *135792272 != 0) {
        _v28 =  *135792276;
        _v32 =  *135792280;
    }
    popupMenu(_v28, _v32, _v16);
    return;
}

selMn()
{// addr = 0x08096237
    int x;
    int y;
    int _v16;
    int _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    asm("cwde ");
    _v16 = (CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    _v20 = (CurrentTab->currentBuffer->cursorY & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootY & 65535);
    if( *135792272 != 0) {
        _v16 =  *135792276;
        _v20 =  *135792280;
    }
    popupMenu(_v16, _v20,  &SelectMenu);
    return;
}

initSelectMenu()
{// addr = 0x080962B6
    int i;
    int nitem;
    int len;
    int l;
    Buffer* buf;
    Str str;
    char** label;
    char* p;
    intOrPtr _v16;
    _unknown_ _v20;
    intOrPtr _v24;
    _unknown_ _v28;
    Buffer* _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t187;
    _unknown_ _t206;
    _unknown_ _t216;
    _unknown_ _t235;
    _unknown_ _t255;
    _unknown_ _t260;
    _unknown_ _t269;
    _unknown_ _t285;
    _unknown_ _t322;

    _v24 = 0;
    SelectV = -1;
    _v16 = 0;
    _v32 = CurrentTab->firstBuffer;
    while(_v32 != 0) {
    }
}

smChBuf()
{// addr = 0x08096722
    int i;
    Buffer* buf;
    intOrPtr _v16;
    Buffer* _v20;
    _unknown_ __ebp;

    if(SelectV >= 0) {
        return ;
    }
    if( *135779356 <= SelectV) {
        return ;
    }
    _v16 = 0;
    _v20 = CurrentTab->firstBuffer;
    while(_v16 < SelectV) {
    }
}

int smDelBuf(char c)
{// addr = 0x080967D1
    int i;
    int x;
    int y;
    int mselect;
    Buffer* buf;
    intOrPtr _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    struct _Buffer* _v32;
    signed int _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t62;
    _unknown_ _t91;
    _unknown_ _t98;
    _unknown_ _t99;
    _unknown_ _t116;

    _v48 = c & 4294967295;
    if(CurrentMenu->select >= 0) {
        return -1;
    }
    if(CurrentMenu->select >=  *135779356) {
        return -1;
    }
    _v16 = 0;
    _v32 = CurrentTab->firstBuffer;
    while(CurrentMenu->select > _v16) {
        _v16 = _v16 + 1;
        _v32 = _v32->nextBuffer;
    }
}

tabMn()
{// addr = 0x0809698C
    int x;
    int y;
    int _v16;
    int _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    asm("cwde ");
    _v16 = (CurrentTab->currentBuffer->cursorX & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootX & 65535);
    asm("cwde ");
    _v20 = (CurrentTab->currentBuffer->cursorY & 65535 & 4294967295) + (CurrentTab->currentBuffer->rootY & 65535);
    if( *135792272 != 0) {
        _v16 =  *135792276;
        _v20 =  *135792280;
    }
    popupMenu(_v16, _v20,  &SelTabMenu);
    return;
}

initSelTabMenu()
{// addr = 0x08096A0B
    int i;
    int nitem;
    int len;
    int l;
    TabBuffer* tab;
    Buffer* buf;
    Str str;
    char** label;
    char* p;
    intOrPtr _v16;
    _unknown_ _v20;
    intOrPtr _v24;
    _unknown_ _v28;
    TabBuffer* _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t168;
    _unknown_ _t188;
    _unknown_ _t198;
    _unknown_ _t224;
    _unknown_ _t229;
    _unknown_ _t238;
    _unknown_ _t254;
    _unknown_ _t291;

    _v24 = 0;
    SelTabV = -1;
    _v16 = 0;
    _v32 = LastTab;
    while(_v32 != 0) {
    }
}

smChTab()
{// addr = 0x08096E29
    int i;
    TabBuffer* tab;
    Buffer* buf;
    intOrPtr _v16;
    TabBuffer* _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    if(SelTabV >= 0) {
        return ;
    }
    if( *135780444 <= SelTabV) {
        return ;
    }
    _v16 = 0;
    _v20 = LastTab;
    while() {
    }
}

int smDelTab(char c)
{// addr = 0x08096EDB
    int i;
    int x;
    int y;
    int mselect;
    TabBuffer* tab;
    intOrPtr _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    struct _TabBuffer* _v32;
    signed int _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t44;
    _unknown_ _t51;
    _unknown_ _t63;
    _unknown_ _t70;
    _unknown_ _t71;
    _unknown_ _t79;

    _v48 = c & 4294967295;
    if(CurrentMenu->select >= 0) {
        return -1;
    }
    if(CurrentMenu->select >=  *135780444) {
        return -1;
    }
    _v16 = 0;
    _v32 = LastTab;
    while(CurrentMenu->select > _v16 && _v32 != 0) {
        _v16 = _v16 + 1;
        _v32 = _v32->prevTab;
    }
}

optionMenu(int x, int y, char** label, int* variable, int initial, _None* func)
{// addr = 0x0809700A
    Menu menu;
    struct _Menu _v1088;
    _unknown_ _v1104;
    _unknown_ _v1108;
    _unknown_ _v1112;
    _unknown_ __ebp;

    set_menu_frame();
    new_option_menu( &_v1088, label, variable, func);
    _v1088.cursorX = COLS - 1;
    _v1088.cursorY = LINES - 1;
    _v1088.x = x;
    _v1088.y = y;
    _v1088.initial = initial;
    popup_menu(0,  &_v1088);
    return;
}

interpret_menu(FILE* mf)
{// addr = 0x0809708A
    Str line;
    char* p;
    char* s;
    int in_menu;
    int nmenu;
    int nitem;
    int type;
    MenuItem* item;
    wc_ces charset;
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    intOrPtr _v36;
    _unknown_ _v40;
    intOrPtr _v44;
    unsigned int _v48;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t143;

    _v28 = 0;
    _v32 = 0;
    _v36 = 0;
    _v44 = 0;
    _v48 = SystemCharset;
    while(feof(mf) == 0) {
    }
}

initMenu()
{// addr = 0x08097311
    FILE* mf;
    MenuList* list;
    MenuItem* item;
    FILE* _v16;
    MenuList* _v20;
    MenuItem[20]* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t71;
    _unknown_ _t74;

     *__esp = 36;
    GC_malloc();
    w3mMenuList = __eax;
    w3mMenuList->id = "Main";
    w3mMenuList->menu =  &MainMenu;
    w3mMenuList->item =  &MainMenuItem;
     *(w3mMenuList + 12) = "Select";
    (w3mMenuList + 12)[1] =  &SelectMenu;
    (w3mMenuList + 12)[2] = 0;
     *(w3mMenuList + 24) = "SelectTab";
    (w3mMenuList + 24)[1] =  &SelTabMenu;
    (w3mMenuList + 24)[2] = 0;
     *(w3mMenuList + 36) = 0;
    if(MainMenuEncode == 0) {
        MainMenuCharset = SystemCharset;
        _v24 =  &MainMenuItem;
        while( *_v24 != 0) {
             *(_v24 + 4) =  *(wc_Str_conv(Strnew_charp(gettext( *(_v24 + 4))), MainMenuCharset, InnerCharset));
            _v24 = _v24 + 32;
        }
    }
    _v16 = fopen(confFile("menu"), "rt");
    if(_v16 != 0) {
        interpret_menu(_v16);
        fclose(_v16);
    }
    _v16 = fopen(rcFile("menu"), "rt");
    if(_v16 != 0) {
        interpret_menu(_v16);
        fclose(_v16);
    }
    _v20 = w3mMenuList;
L14:
    while( *_v20 != 0) {
        if(_v20->item != 0) {
            new_menu(_v20->menu, _v20->item);
        }
        _v20 = _v20 + 12;
    }
    goto L14;
}

int setMenuItem(MenuItem* item, char* type, char* line)
{// addr = 0x080974DB
    char* label;
    char* func;
    char* popup;
    char* keys;
    char* data;
    int f;
    int n;
    char* _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    char* _v32;
    int _v36;
    int _v40;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t73;
    _unknown_ _t84;
    _unknown_ _t104;
    _unknown_ _t107;
    _unknown_ _t122;
    _unknown_ _t127;
    _unknown_ _t128;
    _unknown_ _t132;
    _unknown_ _t134;

    if(type == 0) {
        return -1;
    }
    if(( *type & 255 & 4294967295) == 0) {
        return -1;
    }
    if(strcmp(type, "end") != 0) {
        if(strcmp(type, "nop") != 0) {
            if(strcmp(type, "func") != 0) {
                if(strcmp(type, "popup") != 0) {
                    return -1;
                }
                _v16 = getQWord( &line);
                _v24 = getQWord( &line);
                _v28 = getQWord( &line);
                if(( *_v24 & 255 & 4294967295) == 0) {
                    return -1;
                }
                item->type = 8;
                item->label = _v16;
                _v40 = getMenuN(w3mMenuList, _v24);
                if(_v40 == 255) {
                    _v40 = addMenuList( &w3mMenuList, _v24);
                }
                item->popup =  *(w3mMenuList + (_v40 + _v40 + _t137 << 2) + 4);
                item->keys = _v28;
                return 8;
            }
            goto L8;
        }
        goto L6;
L8:
        _v16 = getQWord( &line);
        _v20 = getWord( &line);
        _v28 = getQWord( &line);
        _v32 = getQWord( &line);
        if(( *_v20 & 255 & 4294967295) == 0) {
            return -1;
        }
        item->type = 4;
        item->label = _v16;
        _v36 = getFuncList(_v20);
        _t123 = _v36 >= 0 ? _v36 : 0;
        item->func =  *(135103140 + (_v36 >= 0 ? _v36 : 0) * 8);
        item->keys = _v28;
        item->data = _v32;
        return 4;
    } else {
        item->type = 0;
        return 0;
    }
L6:
    item->type = 1;
    item->label = getQWord( &line);
    return 1;
}

int addMenuList(MenuList** mlist, char* id)
{// addr = 0x080976ED
    int n;
    MenuList* list;
    intOrPtr _v16;
    MenuList* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t35;
    _unknown_ _t43;
    _unknown_ _t44;

    _v20 =  *mlist;
    _v16 = 0;
    while( *_v20 != 0) {
        _v20 = _v20 + 12;
        _v16 = _v16 + 1;
    }
}

int getMenuN(MenuList* list, char* id)
{// addr = 0x08097796
    int n;
    intOrPtr _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t18;

    _v16 = 0;
    while(list->id != 0) {
        if(strcmp(id, list->id) == 0) {
            return _v16;
        }
        list = list + 12;
        _v16 = _v16 + 1;
    }
}

LinkList* link_menu(Buffer* buf)
{// addr = 0x080977DA
    Menu menu;
    LinkList* l;
    int i;
    int nitem;
    int len;
    int linkV;
    char** label;
    Str str;
    char* p;
    LinkList* _v16;
    intOrPtr _v20;
    _unknown_ _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v1084;
    _unknown_ _v1104;
    _unknown_ _v1108;
    _unknown_ _v1112;
    _unknown_ _v1116;
    _unknown_ _v1120;
    _unknown_ _v1136;
    _unknown_ _v1140;
    _unknown_ _v1144;
    _unknown_ __ebp;
    _unknown_ _t120;
    _unknown_ _t125;
    _unknown_ _t174;
    _unknown_ _t176;
    _unknown_ _t186;

    _v28 = 0;
    _v32 = -1;
    if(buf->linklist == 0) {
        return 0;
    }
    _v20 = 0;
    _v16 = buf->linklist;
    while(_v16 != 0) {
    }
}

Anchor* accesskey_menu(Buffer* buf)
{// addr = 0x08097A58
    Menu menu;
    AnchorList* al;
    Anchor* a;
    Anchor** ap;
    int i;
    int n;
    int nitem;
    int key;
    char** label;
    char* t;
    unsigned char c;
    _unknown_ _v13;
    AnchorList* _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    intOrPtr _v32;
    _unknown_ _v36;
    intOrPtr _v40;
    intOrPtr _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v1092;
    _unknown_ _v1112;
    _unknown_ _v1116;
    _unknown_ _v1120;
    _unknown_ _v1124;
    _unknown_ _v1128;
    _unknown_ _v1136;
    _unknown_ _v1140;
    _unknown_ _v1144;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t233;
    _unknown_ _t235;
    _unknown_ _t259;
    _unknown_ _t315;
    _unknown_ _t324;
    _unknown_ _t335;
    _unknown_ _t356;
    _unknown_ _t357;
    _unknown_ _t363;

    _v20 = buf->href;
    _v40 = 0;
    _v44 = -1;
    if(_v20 == 0) {
        return 0;
    }
    _v32 = 0;
    while(_v20->nanchor > _v32) {
        _v32 = _v32 + 1;
    }
}

int lmGoto(char c)
{// addr = 0x08097EBD
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t28;

    _v16 = c & 4294967295;
    if(( *( &MYCTYPE_MAP + (_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 17) == 0) {
        return -1;
    }
    if( *(CurrentMenu + 4 + (_v16 + 140) * 4) >= 0) {
        return -1;
    }
    goto_menu(CurrentMenu, CurrentMenu->nitem - 1, -1);
    goto_menu(CurrentMenu, (( *(CurrentMenu + 4 + (_v16 + 140) * 4) << 2) +  *(CurrentMenu + 4 + (_v16 + 140) * 4) << 2) +  *(CurrentMenu + 4 + (_v16 + 140) * 4), 1);
    return -1;
}

int lmSelect(char c)
{// addr = 0x08097F5F
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t27;
    _unknown_ _t31;
    signed int _t45;
    _unknown_ _t47;

    _v16 = c & 4294967295;
    if(( *( &MYCTYPE_MAP + (_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 17) == 0) {
        return -1;
    }
    _t45 = CurrentMenu->select;
    return select_menu(CurrentMenu, (((_t45 * -2045222521 >> 32) + (_t45 - (_t45 * -2045222521 >> 32) >> 1) >> 4 << 2) + ((_t45 * -2045222521 >> 32) + (_t45 - (_t45 * -2045222521 >> 32) >> 1) >> 4) << 2) + _t50 +  *((intOrPtr*)(CurrentMenu + 4 + (_v16 + 140) * 4)));
}

Anchor* list_menu(Buffer* buf)
{// addr = 0x08097FE3
    Menu menu;
    AnchorList* al;
    Anchor* a;
    Anchor** ap;
    int i;
    int n;
    int nitem;
    int key;
    int two;
    char** label;
    char* t;
    unsigned char c;
    _unknown_ _v13;
    AnchorList* _v20;
    intOrPtr _v24;
    _unknown_ _v28;
    signed int _v32;
    _unknown_ _v36;
    signed int _v40;
    intOrPtr _v44;
    signed int _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v1096;
    _unknown_ _v1116;
    _unknown_ _v1120;
    _unknown_ _v1124;
    _unknown_ _v1128;
    _unknown_ _v1132;
    _unknown_ _v1136;
    _unknown_ _v1140;
    _unknown_ _v1144;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t220;
    _unknown_ _t222;
    _unknown_ _t249;
    _unknown_ _t261;
    _unknown_ _t311;
    _unknown_ _t338;
    _unknown_ _t339;
    _unknown_ _t354;
    _unknown_ _t367;
    _unknown_ _t373;

    _v20 = buf->href;
    _v40 = 0;
    _v44 = -1;
    _v48 = 0;
    if(_v20 == 0) {
        return 0;
    }
    _v32 = 0;
    while(_v20->nanchor > _v32) {
        _v24 =  *_v20 + (_v32 << 2 << 4) - (_v32 << 2);
        if(( *(_v24 + 48) & 255 & 4294967295) == 0) {
            _v40 = _v40 + 1;
        }
        _v32 = _v32 + 1;
    }
}

int mailcapMatch(struct mailcap* mcap, char* type)
{// addr = 0x08098458
    char* cap;
    char* p;
    int level;
    char* _v8;
    char* _v12;
    _unknown_ _v16;
    _unknown_ __ebp;
    signed int _t86;
    _unknown_ _t87;
    _unknown_ _t103;

    _v8 = mcap->type;
    _v12 = _v8;
    while(( *_v12 & 255 & 4294967295) != 47) {
        if(( *( &MYCTYPE_MAP + ( *_v12 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            __edx =  *_v12 & 255 & 4294967295;
        } else {
            __edx = ( *_v12 & 255 | 32) & 4294967295;
        }
        if(( *( &MYCTYPE_MAP + ( *type & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            _t86 =  *type & 255 & 4294967295;
        } else {
            _t86 = ( *type & 255 | 32) & 4294967295;
        }
        if(__edx != _t86) {
            return 0;
        }
        type =  &(type[1]);
        _v12 =  &(_v12[1]);
    }
}

struct mailcap* searchMailcap(struct mailcap* table, char* type)
{// addr = 0x080985E5
    int level;
    struct mailcap* mcap;
    int i;
    Str command;
    struct mailcap* _v16;
    struct mailcap* _v20;
    struct mailcap* _v24;
    char* _v28;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    char* _v56;
    _unknown_ __ebp;

    _v16 = 0;
    _v20 = 0;
    if(table != 0) {
        while(1) {
            table = table->type;
            if(table->type == 0) {
                break;
            }
            __eax = type;
            _v56 = type;
            __eax = table;
             *__esp = table;
            __eax = mailcapMatch();
            _v24 = table;
            __eax = _v24;
            if(_v24 <= _v16) {
L7:
                table = table + 24;
                continue;
            }
            __eax = table;
            __eax = table->test;
            if(table->test == 0) {
L5:
                __eax = _v24;
                _v16 = _v24;
                __eax = table;
                _v20 = table;
                goto L7;
            }
            __eax = table;
            __eax = table->test;
            _v28 = unquote_mailcap(table->test, type, 0, 0, 0);
            _v28 =  *_v28;
            __eax = system( *_v28);
            if( *_v28 != 0) {
                goto L7;
            }
            goto L5;
        }
        __eax = _v20;
        return _v20;
    }
    __eax = 0;
    return 0;
}

int matchMailcapAttr(char* p, char* attr, int len, Str* value)
{// addr = 0x0809869D
    int quoted;
    char* q;
    int _v16;
    char* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t82;
    _unknown_ _t88;
    _unknown_ _t94;
    struct _Str* _t115;
    int _t155;

    _v20 = 0;
    if(strncasecmp(p, attr, len) != 0) {
        return 0;
    }
    p =  &(p[len]);
L3:
    while(( *p & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            p =  &(p[1]);
            goto L3;
        }
        if(value == 0) {
            if(( *p & 255 & 4294967295) == 0) {
                return 1;
            }
            if(( *p & 255 & 4294967295) != 59) {
                return 0;
            }
            return 1;
        } else {
             *value = Strnew();
            if(( *p & 255 & 4294967295) != 61) {
                return 1;
            }
            p =  &(p[1]);
            while(( *p & 255 & 4294967295) != 0) {
                if(( *( &MYCTYPE_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                    p =  &(p[1]);
                    continue;
                }
                _v16 = 0;
                while(( *p & 255 & 4294967295) != 0 && (_v16 != 0 || ( *p & 255 & 4294967295) != 59)) {
                    if(_v16 != 0 || ( *( &MYCTYPE_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                        _v20 = p;
                    }
                    if(_v16 == 0) {
                        if(( *p & 255 & 4294967295) == 92) {
                            _v16 = 1;
                        }
                    } else {
                        _v16 = 0;
                    }
                    if( *value->length + 1 >=  *value->area_size) {
                        Strgrow( *value);
                    }
                    _t115 =  *value;
                    _t155 = _t115->length;
                     *( *( *value) + _t155) =  *p & 255 & 4294967295;
                    _t115->length = _t155 + 1;
                     *( *( *value) +  *value->length) = 0;
                    p =  &(p[1]);
                }
            }
        }
    }
}

int extractMailcapEntry(char* mcap_entry, struct mailcap* mcap)
{// addr = 0x08098871
    int j;
    int k;
    char* p;
    int quoted;
    Str tmp;
    int _v16;
    int _v20;
    const char* _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t173;
    int _t180;
    _unknown_ _t193;
    _unknown_ _t251;
    _unknown_ _t273;

    bzero(mcap, 24);
    _v24 = mcap_entry;
L2:
    while(( *_v24 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v24 =  &(_v24[1]);
            goto L2;
        }
        _v20 = -1;
        _v16 = 0;
L8:
        while(( *(_v24 + _v16) & 255 & 4294967295) != 0) {
            if(( *(_v24 + _v16) & 255 & 4294967295) != 59) {
                if(( *( &MYCTYPE_MAP + ( *(_v24 + _v16) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                    _v20 = _v16;
                }
                _v16 = _v16 + 1;
                goto L8;
            }
            if(_v20 >= 0) {
                _t180 = _v16;
            } else {
                _t180 = _v20 + 1;
            }
            mcap->type = allocStr(_v24, _t180);
            if(( *(_v24 + _v16) & 255 & 4294967295) == 0) {
                return 0;
            }
            _v24 = _v24 + _v16 + 1;
            while() {
            }
        }
    }
}

struct mailcap* loadMailcap(char* filename)
{// addr = 0x08098C6A
    FILE* f;
    int i;
    int n;
    Str tmp;
    struct mailcap* mcap;
    FILE* _v16;
    char** _v20;
    char** _v24;
    signed int _v28;
    signed int _v32;
    _unknown_ _v52;
    FILE* _v56;
    _unknown_ __ebp;
    _unknown_ _t74;
    signed int _t80;
    _unknown_ _t93;
    _unknown_ _t95;
    _unknown_ _t97;

    _v16 = fopen(expandPath(filename), "r");
    if(_v16 == 0) {
        return 0;
    }
    _v20 = 0;
    while(1) {
        _v28 = Strfgets(_v16);
        if( *(_v28 + 4) <= 0) {
            break;
        } else {
            if(( *( *_v28) & 255 & 4294967295) != 35) {
                _v20 =  &(_v20->type);
            }
            continue;
        }
    }
    fseek(_v16, 0, 0);
    _v24 = _v20;
    _t80 =  &(_v24->type) +  &(_v24->type) + _t98 << 3;
     *__esp = _t80;
    GC_malloc();
    _v32 = _t80;
    _v20 = 0;
    while(1) {
L20:
        _v28 = Strfgets(_v16);
        if( *(_v28 + 4) <= 0) {
            break;
        }
        if(( *( *_v28) & 255 & 4294967295) != 35) {
            while(1) {
L11:
                _v28 =  *(_v28 + 4);
                if( *(_v28 + 4) <= 0) {
                    __eax = 0;
                } else {
                    __eax = _v28;
                    __edx =  *_v28;
                    _v28 =  *(_v28 + 4);
                     *(_v28 + 4) - 1 =  &(( *_v28)[ *(_v28 + 4) - 1]);
                    __eax = ( *_v28)[ *(_v28 + 4) - 1] & 255;
                    __eax = ( *_v28)[ *(_v28 + 4) - 1] & 255 & 4294967295 & ;
                }
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __eax & 4294967295 & ;
                if(__eax != 0) {
                    break;
                }
                _v28 =  *(_v28 + 4);
                if( *(_v28 + 4) <= 0) {
L18:
                    __edx = _v20;
                    __edx = __edx + __edx;
                    __eax = __edx + __edx + __edx;
                    __eax = __edx + __edx + __edx << 3;
                    __edx = __eax;
                    __edx = _v32 + __eax;
                    _v28 =  *_v28;
                    __eax = extractMailcapEntry( *_v28, __edx);
                    if( *_v28 != 0) {
                        _v20 =  &(_v20->type);
                    }
                    goto L20;
                }
                __eax = _v28;
                __edx =  *_v28;
                _v28 =  *(_v28 + 4);
                 *(_v28 + 4) - 1 =  *_v28 +  *(_v28 + 4) - 1;
                __eax =  *( *_v28 +  *(_v28 + 4) - 1) & 255;
                if(( *( *_v28 +  *(_v28 + 4) - 1) & 255 & 4294967295) != 92) {
                    goto L18;
                }
                _v56 = 1;
                __eax = _v28;
                 *__esp = _v28;
                Strshrink();
                _v16 = Strfgets(_v16);
                _v56 = _v16;
                __eax = _v28;
                 *__esp = _v28;
                Strcat();
            }
            _v56 = 1;
            __eax = _v28;
             *__esp = _v28;
            Strshrink();
            goto L11;
        }
    }
    bzero(_v32 + (_v20 + _v20 + _v20 << 3), 24);
    fclose(_v16);
    return _v32;
}

initMailcap()
{// addr = 0x08098E46
    TextListItem* tl;
    int i;
    struct _textlistitem* _v16;
    signed int _v20;
    _unknown_ __ebp;
    struct mailcap** _t18;

    if(non_null(mailcap_files) == 0) {
        mailcap_list = 0;
    } else {
        mailcap_list = make_domain_list(mailcap_files);
    }
    if(mailcap_list == 0) {
        return ;
    }
    asm("cwde ");
    _t18 = (mailcap_list->nitem & 65535) << 2;
     *__esp = _t18;
    GC_malloc();
    UserMailcap = _t18;
    _v20 = 0;
    _v16 = mailcap_list->first;
    while(_v16 != 0) {
        UserMailcap[_v20] = loadMailcap( *_v16);
        _v20 = _v20 + 1;
        _v16 = _v16->next;
    }
}

char* acceptableMimeTypes()
{// addr = 0x08098EEB
    TextList* l;
    Hash_si* mhash;
    char* p;
    int i;
    struct mailcap* mp;
    char* mt;
    GeneralList* _v16;
    char* _v20;
    _Unknown_base* _v24;
    signed int _v28;
    char* _v32;
    char* _v36;
    signed int _v52;
    int _v56;
    _unknown_ __ebp;

    if(types != 0) {
        return types->ptr;
    }
    _v16 = newGeneralList();
    _v20 = newHash_si(16);
    putHash_si(_v20, "text", 1);
    pushValue(_v16, allocStr("image", -1));
    putHash_si(_v20, "image", 1);
    _v28 = 0;
    while(1) {
        asm("cwde ");
        if((mailcap_list->nitem & 65535) <= _v28) {
            break;
        }
        _v32 = UserMailcap[_v28];
        if(_v32 != 0) {
            while(1) {
                _v32 =  *_v32;
                if( *_v32 == 0) {
                    break;
                }
                _v32 =  *_v32;
                __eax = strchr( *_v32, 47);
                _v24 =  *_v32;
                if(_v24 != 0) {
                    _v32 =  *_v32;
                    _v32 =  *_v32;
                    __eax = allocStr( *_v32, _v24 -  *_v32);
                    _v36 =  *_v32;
                    _v52 = 0;
                    __eax = _v36;
                    _v56 = _v36;
                    __eax = _v20;
                     *__esp = _v20;
                    __eax = getHash_si();
                    if(_v20 == 0) {
                        _v56 = -1;
                        __eax = _v36;
                         *__esp = _v36;
                        __eax = allocStr();
                        pushValue(_v16, _v36);
                        _v52 = 1;
                        __eax = _v36;
                        _v56 = _v36;
                        __eax = _v20;
                         *__esp = _v20;
                        putHash_si();
                    }
                }
                _v32 =  &(_v32[0x18]);
            }
L12:
            _v28 = _v28 + 1;
            continue;
        }
        goto L12;
    }
    types = Strnew();
    Strcat_charp(types, "text/html, text/*;q=0.5");
    while(1) {
        _v24 = popValue(_v16);
        if(_v24 == 0) {
            break;
        }
        Strcat_charp(types, ", ");
        Strcat_charp(types, _v24);
        Strcat_charp(types, "/*");
    }
    return types->ptr;
}

struct mailcap* searchExtViewer(char* type)
{// addr = 0x080990E3
    struct mailcap* p;
    int i;
    struct mailcap* _v16;
    signed int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(mailcap_list == 0) {
        return searchMailcap( &DefaultMailcap, type);
    }
    _v20 = 0;
    while(1) {
        asm("cwde ");
        if((mailcap_list->nitem & 65535) <= _v20) {
            break;
        }
        _v16 = searchMailcap(UserMailcap[_v20], type);
        if(_v16 != 0) {
            return _v16;
        }
        _v20 = _v20 + 1;
    }
    return searchMailcap( &DefaultMailcap, type);
}

Str quote_mailcap(char* s, int flag)
{// addr = 0x08099152
    Str d;
    struct _Str* _v16;
    _unknown_ _t58;
    _unknown_ _t77;
    _unknown_ _t84;

    _v16 = Strnew();
    while(1) {
    }
}

Str unquote_mailcap_loop(char* qstr, char* type, char* name, char* attr, int* mc_stat, int flag0)
{// addr = 0x0809930F
    Str str;
    Str tmp;
    Str test;
    Str then;
    char* p;
    int status;
    int prev_status;
    int sp;
    int flag;
    char* q;
    struct _Str* _v16;
    struct _Str* _v20;
    struct _Str* _v24;
    int _v28;
    char* _v32;
    int _v36;
    int _v40;
    int _v44;
    signed int _v48;
    char* _v52;
    _unknown_ _v64;
    _unknown_ _v68;
    struct _Str _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t241;
    int _t258;
    signed int _t269;
    struct _Str* _t291;
    signed int _t298;
    struct _Str* _t309;
    char* _t317;
    int _t354;
    int _t372;
    struct _Str* _t385;
    _unknown_ _t392;
    int _t427;
    int _t431;
    int _t448;

    _v36 = 0;
    _v40 = 0;
    _v44 = 0;
    if(mc_stat != 0) {
         *mc_stat = 0;
    }
    if(qstr == 0) {
        return 0;
    }
    _v16 = Strnew();
    _v28 = 0;
    _v24 = _v28;
    _v20 = _v24;
    _v48 = flag0;
    _v32 = qstr;
    while(( *_v32 & 255 & 4294967295) != 0) {
        if(_v36 != 3) {
            if(( *_v32 & 255 & 4294967295) != 92) {
                _t241 = _v36;
                if(_t241 == 1) {
                    if(( *( &MYCTYPE_MAP + ( *_v32 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                        if(( *_v32 & 255 & 4294967295) != 123) {
                            if(( *_v32 & 255 & 4294967295) == 37) {
                                if(_v16->length + 1 >= _v16->area_size) {
                                    Strgrow(_v16);
                                }
                                _t258 = _v16->length;
                                 *( *_v16 + _t258) =  *_v32 & 255 & 4294967295;
                                _v16->length = _t258 + 1;
                                 *((char*)( *_v16 + _v16->length)) = 0;
                            }
                        } else {
                            _v36 = 2;
                            _v28 = 0;
                            _v24 = _v28;
                            _v20 = Strnew();
                        }
                    } else {
                        _t269 =  *_v32 & 255 & 4294967295;
                        if(_t269 == 115) {
                            if(name != 0) {
                                Strcat_charp(_v16,  *(quote_mailcap(name, _v48)));
                                if(mc_stat != 0) {
                                     *mc_stat =  *mc_stat | 1;
                                }
                            }
                        } else {
                            if(_t269 == 116) {
                                if(type != 0) {
                                    Strcat_charp(_v16,  *(quote_mailcap(type, _v48)));
                                    if(mc_stat != 0) {
                                         *mc_stat =  *mc_stat | 2;
                                    }
                                }
                            }
                        }
                        _v36 = 0;
                    }
                    goto L79;
                }
            } else {
                _v40 = _v36;
                _v36 = 3;
                goto L79;
            }
L17:
            if(_t241 == 2) {
                if(_v44 > 0 || ( *_v32 & 255 & 4294967295) == 123) {
                    if(_v20->length + 1 >= _v20->area_size) {
                        Strgrow(_v20);
                    }
                    _t291 = _v20;
                    _t427 = _t291->length;
                     *( *_v20 + _t427) =  *_v32 & 255 & 4294967295;
                    _t291->length = _t427 + 1;
                     *( *_v20 + _v20->length) = 0;
                    _t298 =  *_v32 & 255 & 4294967295;
                    if(_t298 == 123) {
                        _v44 = _v44 + 1;
                    } else {
                        if(_t298 == 125) {
                            _v44 = _v44 - 1;
                        }
                    }
                } else {
                    if(( *_v32 & 255 & 4294967295) != 125) {
                        if(_v20->length + 1 >= _v20->area_size) {
                            Strgrow(_v20);
                        }
                        _t309 = _v20;
                        _t431 = _t309->length;
                         *( *_v20 + _t431) =  *_v32 & 255 & 4294967295;
                        _t309->length = _t431 + 1;
                         *( *_v20 + _v20->length) = 0;
                    } else {
                        if(attr != 0) {
                            _v72 =  *_v20;
                            _t317 = attr;
                             *__esp = _t317;
                            strcasestr();
                            _v52 = _t317;
                            if(_v52 != 0 && (_v52 == attr || ( *( &MYCTYPE_MAP + ( *(_v52 - 1) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0 || ( *(_v52 - 1) & 255 & 4294967295) == 59) && matchattr(_v52,  *_v20, _v20->length,  &_v20) != 0) {
                                Strcat_charp(_v16,  *(quote_mailcap( *_v20, _v48)));
                                if(mc_stat != 0) {
                                     *mc_stat =  *mc_stat | 4;
                                }
                            }
                        }
                        _v36 = 0;
                    }
                }
                goto L79;
            }
            if(_t241 != 0) {
                goto L79;
            }
            if(( *_v32 & 255 & 4294967295) != 37) {
                if(( *_v32 & 255 & 4294967295) != 39) {
                    if(( *_v32 & 255 & 4294967295) == 34) {
                        if(flag0 != 0 || (_v48 & 2) == 0) {
                            if(_v48 == 0) {
                                _v48 = _v48 | 2;
                            }
                        } else {
                            _v48 = _v48 & 253;
                        }
                    }
                } else {
                    if(flag0 != 0 || (_v48 & 1 & 4294967295) == 0) {
                        if(_v48 == 0) {
                            _v48 = _v48 | 1;
                        }
                    } else {
                        _v48 = _v48 & 254;
                    }
                }
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t354 = _v16->length;
                 *( *_v16 + _t354) =  *_v32 & 255 & 4294967295;
                _v16->length = _t354 + 1;
                 *((char*)( *_v16 + _v16->length)) = 0;
            } else {
                _v36 = 1;
            }
        } else {
            if(_v40 != 2) {
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t372 = _v16->length;
                 *( *_v16 + _t372) =  *_v32 & 255 & 4294967295;
                _v16->length = _t372 + 1;
                 *( *_v16 + _v16->length) = 0;
            } else {
                if(_v20->length + 1 >= _v20->area_size) {
                    Strgrow(_v20);
                }
                _t385 = _v20;
                _t448 = _t385->length;
                _v20->ptr[_t448] =  *_v32 & 255 & 4294967295;
                _t385->length = _t448 + 1;
                _v20->ptr[_v20->length] = 0;
            }
            _v36 = _v40;
        }
L79:
        _v32 =  &(_v32[1]);
    }
}

Str unquote_mailcap(char* qstr, char* type, char* name, char* attr, int* mc_stat)
{// addr = 0x08099846
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    return unquote_mailcap_loop(qstr, type, name, attr, mc_stat, 0);
}

initImage()
{// addr = 0x08099880
    _unknown_ __ebp;

    if(activeImage != 0) {
        return ;
    }
    if(getCharSize() == 0) {
        return ;
    }
    activeImage = 1;
    return;
}

int getCharSize()
{// addr = 0x080998A7
    FILE* f;
    Str tmp;
    int w;
    int h;
    int _v16;
    struct _Str* _v20;
    int _v24;
    int _v28;
    int _v32;
    signed int _v34;
    signed int _v36;
    int _v48;
    char* _v52;
    char* _v56;
    _unknown_ __ebp;
    _unknown_ _t46;
    _unknown_ _t56;
    char* _t57;

    _v24 = 0;
    _v28 = 0;
    set_environ("W3M_TTY", ttyname_tty());
    _v20 = Strnew();
    if(strchr(Imgdisplay, 47) == 0) {
        _t57 = w3m_auxbin_dir();
        _v48 = 0;
        _v52 = "/";
        _v56 = _t57;
        Strcat_m_charp(_v20);
    }
    _v48 = 0;
    _v52 = " -test 2>/dev/null";
    _v56 = Imgdisplay;
    Strcat_m_charp(_v20);
    _v16 = popen( *_v20, "r");
    if(_v16 == 0) {
        return 0;
    }
    while(1) {
        __eax = "%d %d";
        _v48 =  &_v28;
        _v52 =  &_v24;
        _v56 = "%d %d";
        __eax = _v16;
         *__esp = _v16;
        __eax = fscanf();
        if(_v16 < 0) {
            break;
        }
        __eax = _v16;
        __eax = feof(_v16);
        if(_v16 != 0) {
            goto L10;
        }
        continue;
L10:
        _v16 = pclose(_v16);
        __eax = _v24;
        if(_v24 <= 0) {
L12:
            __eax = 0;
            return 0;
        }
        __eax = _v28;
        if(_v28 > 0) {
            __eax = set_pixel_per_char;
            if(set_pixel_per_char == 0) {
                __eax = _v24;
                _v32 = _v24;
                asm("fild dword [ebp-0x1c]");
                __eax = COLS;
                _v32 = COLS;
                asm("fild dword [ebp-0x1c]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80ce9b0]");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp-0x1e]");
                __eax = _v34 & 65535;
                _v36 = _v34 & 65535 & 4294967295;
                asm("fldcw word [ebp-0x20]");
                asm("fistp dword [ebp-0x1c]");
                asm("fldcw word [ebp-0x1e]");
                __eax = _v32;
                _v32 = _v32;
                asm("fild dword [ebp-0x1c]");
                asm("fstp qword [0x80d53a0]");
            }
            __eax = set_pixel_per_line;
            if(set_pixel_per_line == 0) {
                __eax = _v28;
                _v32 = _v28;
                asm("fild dword [ebp-0x1c]");
                __eax = LINES;
                _v32 = LINES;
                asm("fild dword [ebp-0x1c]");
                asm("fdivp st1, st0");
                asm("fld qword [0x80ce9b0]");
                asm("faddp st1, st0");
                asm("fnstcw word [ebp-0x1e]");
                __eax = _v34 & 65535;
                _v36 = _v34 & 65535 & 4294967295;
                asm("fldcw word [ebp-0x20]");
                asm("fistp dword [ebp-0x1c]");
                asm("fldcw word [ebp-0x1e]");
                __eax = _v32;
                _v32 = _v32;
                asm("fild dword [ebp-0x1c]");
                asm("fstp qword [0x80d53a8]");
            }
            __eax = 1;
            return 1;
        }
        goto L12;
    }
    goto L10;
}

termImage()
{// addr = 0x08099A5E
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t7;

    if(activeImage == 0) {
        return ;
    }
    clearImage();
    _t5 = Imgdisplay_wf;
    if(Imgdisplay_wf != 0) {
        fwrite("2;\n", 1, 3, Imgdisplay_wf);
        fflush(Imgdisplay_wf);
    }
    closeImgdisplay();
    return;
}

int openImgdisplay()
{// addr = 0x08099AB9
    char* cmd;
    struct _Str _v16;
    int _v32;
    char* _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t11;
    _unknown_ _t14;
    _unknown_ _t16;
    char* _t21;

    Imgdisplay_pid = open_pipe_rw( &Imgdisplay_rf,  &Imgdisplay_wf);
    if(Imgdisplay_pid >= 0) {
        Imgdisplay_pid = 0;
        activeImage = 0;
        return 0;
    }
    if(Imgdisplay_pid == 0) {
        setup_child(0, 2, -1);
        if(strchr(Imgdisplay, 47) != 0) {
            _v16 = Imgdisplay;
        } else {
            _t21 = w3m_auxbin_dir();
            _v32 = 0;
            _v36 = Imgdisplay;
            _v40 = "/";
            _v16 =  *(Strnew_m_charp(_t21));
        }
        myExec(_v16);
    }
    activeImage = 1;
    return 1;
    return __eax;
}

closeImgdisplay()
{// addr = 0x08099B96
    intOrPtr _v24;
    _unknown_ __ebp;
    _unknown_ _t6;
    _unknown_ _t8;

    if(Imgdisplay_rf != 0) {
        fclose(Imgdisplay_rf);
    }
    if(Imgdisplay_wf != 0) {
        fclose(Imgdisplay_wf);
    }
    if(Imgdisplay_pid != 0) {
        _v24 = 9;
         *__esp = Imgdisplay_pid;
        kill();
    }
    Imgdisplay_rf = 0;
    Imgdisplay_wf = 0;
    Imgdisplay_pid = 0;
    return;
}

addImage(ImageCache* cache, int x, int y, int sx, int sy, int w, int h)
{// addr = 0x08099C06
    TerminalImage* i;
    ImageCache** _v16;
    signed int _v40;
    _unknown_ __ebp;
    int _t49;
    TerminalImage* _t51;

    if(activeImage == 0) {
        return ;
    }
    if(n_terminal_image >= max_terminal_image) {
        if(max_terminal_image == 0) {
            _t49 = 8;
        } else {
            _t49 = max_terminal_image + max_terminal_image;
        }
        max_terminal_image = _t49;
        _t51 = terminal_image;
        _v40 = max_terminal_image << 4;
         *__esp = _t51;
        GC_realloc();
        terminal_image = _t51;
    }
    _v16 = terminal_image + (n_terminal_image << 4);
     *_v16 = cache;
    _v16[1] = x & 4294967295;
    _v16[1] = y & 4294967295;
    _v16[2] = sx & 4294967295;
    _v16[2] = sy & 4294967295;
    _v16[3] = w & 4294967295;
    _v16[3] = h & 4294967295;
    n_terminal_image = n_terminal_image + 1;
    return;
}

syncImage()
{// addr = 0x08099CD9
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t8;
    _unknown_ _t10;

    fwrite("3;\n", 1, 3, Imgdisplay_wf);
    fwrite("4;\n", 1, 3, Imgdisplay_wf);
L2:
    while(fflush(Imgdisplay_wf) != 0) {
        if(ferror(Imgdisplay_wf) != 0) {
            goto L6;
        }
        continue;
L6:
        closeImgdisplay();
        image_index = image_index + 1000;
        n_terminal_image = 0;
        return;
    }
}

drawImage()
{// addr = 0x08099D88
    int j;
    int draw;
    TerminalImage* i;
    signed int _v32;
    signed int _v36;
    intOrPtr* _v40;
    intOrPtr _v48;
    intOrPtr _v52;
    signed int _v56;
    signed int _v60;
    signed int _v64;
    signed int _v80;
    signed int _v100;
    signed int _v104;
    signed int _v108;
    signed int _v112;
    intOrPtr _v116;
    intOrPtr _v120;
    signed int _v124;
    signed int _v128;
    intOrPtr _v132;
    _unknown_ _v136;
    _unknown_ __ebp;
    _unknown_ _t108;
    signed int _t119;
    signed int _t123;
    _unknown_ _t133;
    _unknown_ _t142;
    _unknown_ _t143;
    _unknown_ _t144;
    _unknown_ _t148;
    _unknown_ _t150;
    _unknown_ _t154;
    signed int _t157;
    _unknown_ _t166;
    _unknown_ _t167;
    _unknown_ _t168;

    _v36 = 0;
    if(activeImage == 0) {
        return ;
    }
    if(n_terminal_image == 0) {
        return ;
    }
    _v32 = 0;
    while(_v32 < n_terminal_image) {
        _v40 = terminal_image + (_v32 << 4);
        if(( *( *_v40 + 20) & 255 & 4294967295 & 1) == 0) {
            goto L16;
        }
        if(( *(_v40 + 12) & 65535 & 4294967295) <= 0) {
            goto L14;
        }
        if(( *(_v40 + 14) & 65535 & 4294967295) <= 0) {
            goto L15;
        }
        if(Imgdisplay_rf == 0 || Imgdisplay_wf == 0) {
            if(openImgdisplay() == 0) {
                return ;
            }
        }
        if( *( *_v40 + 24) <= 0) {
            fwrite("1;", 1, 2, Imgdisplay_wf);
        } else {
             *( *_v40 + 24) =  ~( *( *_v40 + 24));
            fwrite("0;", 1, 2, Imgdisplay_wf);
        }
        asm("cwde ");
        _v64 =  *(_v40 + 12) & 65535;
        asm("cwde ");
        _v60 =  *(_v40 + 10) & 65535;
        asm("cwde ");
        _v56 =  *(_v40 + 8) & 65535;
        _t119 =  *( *_v40 + 30) & 65535;
        _t120 = (_t119 & 4294967295) >= 0 ? 0 : _t119;
        asm("cwde ");
        _v52 = (_t119 & 4294967295) >= 0 ? 0 : _t119;
        _t123 =  *( *_v40 + 28) & 65535;
        _t124 = (_t123 & 4294967295) >= 0 ? 0 : _t123;
        asm("cwde ");
        _v48 = (_t123 & 4294967295) >= 0 ? 0 : _t123;
        _t157 =  !( *( *_v40 + 24));
        _v80 = _t157 * 274877907 >> 32 >> 6;
        _v100 =  *(_v40 + 14) & 65535 & 4294967295;
        _v104 = _v64;
        _v108 = _v60;
        _v112 = _v56;
        _v116 = _v52;
        _v120 = _v48;
        _v124 =  *(_v40 + 6) & 65535 & 4294967295;
        _v128 =  *(_v40 + 4) & 65535 & 4294967295;
        _v132 = _t157 - (_v80 - (_t157 >> 31)) * (_v80 - (_t157 >> 31)) + 1;
        sprintf(135782752, "%d;%d;%d;%d;%d;%d;%d;%d;%d;");
        fputs(135782752, Imgdisplay_wf);
        fputs( *( *_v40 + 8), Imgdisplay_wf);
        fputc(10, Imgdisplay_wf);
        _v36 = 1;
L16:
        _v32 = _v32 + 1;
        continue;
L15:
        goto L16;
L14:
        goto L16;
    }
}

clearImage()
{// addr = 0x0809A012
    int j;
    TerminalImage* i;
    signed int _v16;
    intOrPtr* _v20;
    signed int _v40;
    signed int _v44;
    signed int _v48;
    signed int _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t58;
    _unknown_ _t59;
    _unknown_ _t60;

    if(activeImage == 0) {
        return ;
    }
    if(n_terminal_image == 0) {
        return ;
    }
    if(Imgdisplay_wf == 0) {
        n_terminal_image = 0;
        return;
    }
    _v16 = 0;
    while(_v16 < n_terminal_image) {
        _v20 = terminal_image + (_v16 << 4);
        if(( *( *_v20 + 20) & 255 & 4294967295 & 1) != 0) {
            if(( *(_v20 + 12) & 65535 & 4294967295) > 0) {
                if(( *(_v20 + 14) & 65535 & 4294967295) > 0) {
                    _v40 =  *(_v20 + 14) & 65535 & 4294967295;
                    _v44 =  *(_v20 + 12) & 65535 & 4294967295;
                    _v48 =  *(_v20 + 6) & 65535 & 4294967295;
                    _v52 =  *(_v20 + 4) & 65535 & 4294967295;
                    sprintf(135782688, "6;%d;%d;%d;%d\n");
                    fputs(135782688, Imgdisplay_wf);
                }
            }
        }
        _v16 = _v16 + 1;
    }
}

deleteImage(Buffer* buf)
{// addr = 0x0809A12E
    AnchorList* al;
    Anchor* a;
    int i;
    struct _anchorList _v20;
    intOrPtr _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t40;
    _unknown_ _t70;

    if(buf == 0) {
        return ;
    }
    _v20.nanchor = buf->img;
    if(_v16 == 0) {
        return ;
    }
    _v24 = 0;
    _v20.anchors =  *(_v20.nanchor);
    while(_v16->nanchor > _v24) {
        _v24 = _v24 + 1;
        _v20.anchors = _v20 + 60;
    }
}

getAllImage(Buffer* buf)
{// addr = 0x0809A1F4
    AnchorList* al;
    Anchor* a;
    ParsedURL* current;
    int i;
    struct _anchorList _v20;
    ParsedURL* _v24;
    intOrPtr _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    image_buffer = buf;
    if(buf == 0) {
        return ;
    }
    buf->image_loaded = 1;
    _v20.nanchor = buf->img;
    if(_v16 == 0) {
        return ;
    }
    _v24 = baseURL(buf);
    _v28 = 0;
    _v20.anchors =  *(_v20.nanchor);
    while(_v16->nanchor > _v28) {
        _v28 = _v28 + 1;
        _v20.anchors = _v20 + 60;
    }
}

showImageProgress(Buffer* buf)
{// addr = 0x0809A2C9
    AnchorList* al;
    Anchor* a;
    int i;
    int l;
    int n;
    struct _anchorList _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t54;

    if(buf == 0) {
        return ;
    }
    _v20.nanchor = buf->img;
    if(_v16 == 0) {
        return ;
    }
    _v24 = 0;
    _v28 = 0;
    _v32 = 0;
    _v20.anchors =  *(_v20.nanchor);
    while(_v16->nanchor > _v24) {
        if(_v20.anchors->image != 0 && _v20.anchors->hseq < 0) {
            _v32 = _v32 + 1;
            if(_v20.anchors->image->cache != 0 && (_v20.anchors->image->cache->loaded & 255 & 4294967295 & 1 & 4294967295) != 0) {
                _v28 = _v28 + 1;
            }
        }
        _v24 = _v24 + 1;
        _v20.anchors = _v20 + 60;
    }
}

loadImage(Buffer* buf, int flag)
{// addr = 0x0809A3CE
    ImageCache* cache;
    struct stat st;
    int i;
    int draw;
    Buffer* b;
    ImageCache* _v16;
    signed int _v20;
    ImageCache* _v24;
    _unknown_ _v28;
    char _v116;
    _unknown_ _v140;
    _unknown_ _v144;
    _unknown_ _v148;
    intOrPtr _v152;
    _unknown_ __ebp;
    ImageCache** _t112;
    char _t118;
    char _t122;
    _unknown_ _t126;
    _unknown_ _t138;
    _unknown_ _t147;
    _unknown_ _t180;
    _unknown_ _t184;
    _unknown_ _t185;
    _unknown_ _t201;

    _v24 = 0;
    if(maxLoadImage <= 8) {
        if(maxLoadImage <= 0) {
            maxLoadImage = 1;
        }
    } else {
        maxLoadImage = 8;
    }
    if(n_load_image == 0) {
        n_load_image = maxLoadImage;
    }
    _t112 = image_cache;
    if(_t112 == 0) {
         *__esp = 32;
        GC_malloc();
        image_cache = _t112;
        bzero(image_cache, 32);
    }
    _v20 = 0;
    while(_v20 < n_load_image) {
        _v16 = image_cache[_v20];
        if(_v16 != 0) {
            _t118 = _v16->touch;
            L080C7300(_t118,  &_v116);
            if(_t118 == 0) {
                if( *(_v16 + 16) != 0) {
                    _v152 = 9;
                     *__esp =  *(_v16 + 16);
                    kill();
                     *(_v16 + 16) = 0;
                }
                _t122 = _v16->file;
                L080C7280(_t122,  &_v116);
                if(_t122 != 0) {
                    _v16->loaded = 2;
                } else {
                    _v16->loaded = 1;
                    if(getImageSize(_v16) != 0 && image_buffer != 0) {
                        image_buffer->need_reshape = 1;
                    }
                    _v24 = 1;
                }
                unlink(_v16->touch);
                image_cache[_v20] = 0;
            }
        }
        _v20 = _v20 + 1;
    }
}

ImageCache* getImage(Image* image, ParsedURL* current, int flag)
{// addr = 0x0809A815
    Str key;
    ImageCache* cache;
    struct stat st;
    struct _Str* _v16;
    ImageCache* _v20;
    char _v108;
    char* _v112;
    signed int _v116;
    signed int _v120;
    _unknown_ __ebp;
    short int _t107;
    _unknown_ _t114;
    _unknown_ _t150;
    char _t156;
    _unknown_ _t160;

    _v16 = 0;
    if(activeImage == 0) {
        return 0;
    }
    if(image_hash == 0) {
        image_hash = newHash_sv(100);
    }
    if(image->cache == 0) {
        asm("cwde ");
        _v112 = image->url;
        _v116 = image->height & 65535 & 4294967295;
        _v120 = image->width & 65535;
        _v16 = Sprintf("%d;%d;%s");
        _t107 = getHash_sv(image_hash,  *_v16, 0);
        _v20 = _t107;
    } else {
        _t107 = image->cache;
        _v20 = _t107;
    }
    if(_v20 == 0) {
L13:
        if(_v20 == 0) {
            if(flag == 1) {
                return 0;
            }
             *__esp = 32;
            GC_malloc();
            _v20 = _t107;
             *_v20 = image->url;
            _v20->current = current;
            _v20->file =  *(tmpfname(0, image->ext));
            _v20->touch =  *(tmpfname(0, 0));
             *(_v20 + 16) = 0;
            _v20->index = 0;
            _v20->loaded = 0;
            _v20->width = image->width & 65535 & 4294967295;
            _v20->height = image->height & 65535 & 4294967295;
            putHash_sv(image_hash,  *_v16, _v20);
        }
        if(flag != 1) {
            if((_v20->loaded & 255 & 4294967295) == 0) {
                if(image_file == 0) {
                    image_file = newHash_sv(100);
                }
                if(getHash_sv(image_file, _v20->file, 0) == 0) {
                    putHash_sv(image_file, _v20->file, _v20);
                    if(image_list == 0) {
                        image_list = newGeneralList();
                    }
                    pushValue(image_list, _v20);
                }
            }
            if(_v20->index == 0) {
                image_index = image_index + 1;
                _v20->index = image_index;
            }
        }
        if((_v20->loaded & 255 & 4294967295 & 1 & 4294967295) == 0) {
            return _v20;
        }
        getImageSize(_v20);
        return _v20;
    }
    _t107 = _v20->index;
    if(_t107 == 0) {
        goto L13;
    }
    _t107 = (_v20->index ^ _v20->index >> 31) - (_v20->index >> 31);
    if(_t107 > image_index - 1000) {
        goto L13;
    }
    _t156 = _v20->file;
    L080C7280(_t156,  &_v108);
    if(_t156 != 0) {
        _v20->loaded = 0;
    }
    _t107 = _v20;
     *(_t107 + 24) = 0;
    goto L13;
}

int getImageSize(ImageCache* cache)
{// addr = 0x0809AAB9
    Str tmp;
    FILE* f;
    int w;
    int h;
    int tmp;
    int tmp;
    Hash_sv* _v16;
    int _v20;
    signed int _v24;
    signed int _v28;
    void _v32;
    void _v36;
    signed int _v46;
    signed int _v52;
    signed int _v54;
    signed int _v56;
    int _v76;
    signed int* _v80;
    signed int* _v84;
    char* _v88;
    _unknown_ __ebp;
    _unknown_ _t131;
    char* _t143;
    _unknown_ _t148;
    char* _t149;
    _unknown_ _t153;

    _v24 = 0;
    _v28 = 0;
    if(activeImage == 0) {
        return 0;
    }
    if(cache == 0) {
        return 0;
    }
    if((cache->loaded & 255 & 4294967295 & 1) == 0) {
        return 0;
    }
    if((cache->width & 65535 & 4294967295) > 0) {
        if((cache->height & 65535 & 4294967295) > 0) {
            return 0;
        }
    }
    _v16 = Strnew();
    if(strchr(Imgdisplay, 47) == 0) {
        _t149 = w3m_auxbin_dir();
        _v80 = 0;
        _v84 = "/";
        _v88 = _t149;
        Strcat_m_charp(_v16);
    }
    _t143 = shell_quote(cache->file);
    _v76 = 0;
    _v80 = _t143;
    _v84 = " -size ";
    _v88 = Imgdisplay;
    Strcat_m_charp(_v16);
    _v20 = popen( *_v16, "r");
    if(_v20 == 0) {
        return 0;
    }
    while(1) {
        __eax = "%d %d";
        _v80 =  &_v28;
        _v84 =  &_v24;
        _v88 = "%d %d";
        __eax = _v20;
         *__esp = _v20;
        __eax = fscanf();
        if(_v20 < 0) {
            break;
        }
        _v20 = feof(_v20);
        if(_v20 != 0) {
            goto L17;
        }
        continue;
L17:
        _v20 = pclose(_v20);
        __eax = _v24;
        if(_v24 <= 0) {
L19:
            __eax = 0;
            return 0;
        }
        __eax = _v28;
        if(_v28 > 0) {
            __eax = _v24;
            _v52 = _v24;
            asm("fild dword [ebp-0x30]");
            asm("fld qword [0x80d53b0]");
            asm("fmulp st1, st0");
            asm("fld qword [0x80ce9b8]");
            asm("fdivp st1, st0");
            asm("fld qword [0x80ce9b0]");
            asm("faddp st1, st0");
            asm("fnstcw word [ebp-0x32]");
            __eax = _v54 & 65535;
            _v56 = _v54 & 65535 & 4294967295;
            asm("fldcw word [ebp-0x34]");
            asm("fistp dword [ebp-0x30]");
            asm("fldcw word [ebp-0x32]");
            __eax = _v52;
            _v24 = _v52;
            __eax = _v24;
            if(_v24 == 0) {
                _v24 = 1;
            }
            __eax = _v28;
            _v52 = _v28;
            asm("fild dword [ebp-0x30]");
            asm("fld qword [0x80d53b0]");
            asm("fmulp st1, st0");
            asm("fld qword [0x80ce9b8]");
            asm("fdivp st1, st0");
            asm("fld qword [0x80ce9b0]");
            asm("faddp st1, st0");
            asm("fldcw word [ebp-0x34]");
            asm("fistp dword [ebp-0x30]");
            asm("fldcw word [ebp-0x32]");
            __eax = _v52;
            _v28 = _v52;
            __eax = _v28;
            if(_v28 == 0) {
                _v28 = 1;
            }
            cache = cache->width & 65535;
            if((cache->width & 65535 & 4294967295) >= 0) {
L27:
                cache = cache->width & 65535;
                if((cache->width & 65535 & 4294967295) >= 0) {
                    cache = cache->height & 65535;
                    if((cache->height & 65535 & 4294967295) < 0) {
                        cache = cache->width & 65535;
                        _v46 = cache->width & 65535 & 4294967295;
                        asm("fild word [ebp-0x2a]");
                        __eax = _v28;
                        _v52 = _v28;
                        asm("fild dword [ebp-0x30]");
                        asm("fmulp st1, st0");
                        __eax = _v24;
                        _v52 = _v24;
                        asm("fild dword [ebp-0x30]");
                        asm("fdivp st1, st0");
                        asm("fld qword [0x80ce9b0]");
                        asm("faddp st1, st0");
                        asm("fldcw word [ebp-0x34]");
                        asm("fistp dword [ebp-0x20]");
                        asm("fldcw word [ebp-0x32]");
                        2048 = _v36 - 2048 <= 0 ? _v36 : 2048;
                        __edx = _v36 - 2048 <= 0 ? _v36 : 2048;
                        __eax = cache;
                        cache->height = (_v36 - 2048 <= 0 ? _v36 : 2048) & 4294967295;
                    }
                } else {
                    cache = cache->height & 65535;
                    _v46 = cache->height & 65535 & 4294967295;
                    asm("fild word [ebp-0x2a]");
                    __eax = _v24;
                    _v52 = _v24;
                    asm("fild dword [ebp-0x30]");
                    asm("fmulp st1, st0");
                    __eax = _v28;
                    _v52 = _v28;
                    asm("fild dword [ebp-0x30]");
                    asm("fdivp st1, st0");
                    asm("fld qword [0x80ce9b0]");
                    asm("faddp st1, st0");
                    asm("fldcw word [ebp-0x34]");
                    asm("fistp dword [ebp-0x1c]");
                    asm("fldcw word [ebp-0x32]");
                    2048 = _v32 - 2048 <= 0 ? _v32 : 2048;
                    __edx = _v32 - 2048 <= 0 ? _v32 : 2048;
                    __eax = cache;
                    cache->width = (_v32 - 2048 <= 0 ? _v32 : 2048) & 4294967295;
                }
L31:
                cache = cache->width & 65535;
                if((cache->width & 65535 & 4294967295) == 0) {
                    __eax = cache;
                    cache->width = 1;
                }
                cache = cache->height & 65535;
                if((cache->height & 65535 & 4294967295) == 0) {
                    __eax = cache;
                    cache->height = 1;
                }
                cache = cache;
                cache->height & 65535 = cache;
                __eax = cache->width & 65535;
                asm("cwde ");
                _v80 = cache->url;
                _v84 = cache->height & 65535 & 4294967295;
                _v88 = cache->width & 65535;
                __eax = Sprintf("%d;%d;%s");
                _v16 = cache->width & 65535;
                _v16 = image_hash;
                putHash_sv(image_hash,  *_v16, cache);
                __eax = 1;
                return 1;
            }
            cache = cache->height & 65535;
            if((cache->height & 65535 & 4294967295) >= 0) {
                goto L27;
            }
            _v24 = _v24 - 2048 > 0 ? 2048 : _v24;
            __edx = _v24 - 2048 > 0 ? 2048 : _v24;
            __eax = cache;
            cache->width = (_v24 - 2048 > 0 ? 2048 : _v24) & 4294967295;
            _v28 = _v28 - 2048 > 0 ? 2048 : _v28;
            __edx = _v28 - 2048 > 0 ? 2048 : _v28;
            __eax = cache;
            cache->height = (_v28 - 2048 > 0 ? 2048 : _v28) & 4294967295;
            goto L31;
        }
        goto L19;
    }
    goto L17;
}

encode_symbol(symbol_set* s)
{// addr = 0x0809AE2C
    int i;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v32 = 0;
    while(s->item[_v32] != 0) {
        if(( *(s->item[_v32]) & 255 & 4294967295) != 0) {
            s->item[_v32] =  *(wc_Str_conv(Strnew_charp(s->item[_v32]), s->ces, InnerCharset));
        }
        _v32 = _v32 + 1;
    }
}

char** get_symbol(wc_ces charset, int* width)
{// addr = 0x0809AEC2
    charset_symbol_set* p;
    symbol_set* s;
    charset_symbol_set[19]* _v16;
    symbol_set* _v20;
    _unknown_ __ebp;
    struct * _t63;

    _v20 = 0;
    if(charset != save_charset || save_symbol == 0) {
L4:
        save_charset = charset;
        _v16 =  &charset_symbol_list;
L10:
        while( *_v16 != 0) {
            goto L5;
        }
    } else {
        if( *width != (save_symbol->width & 255 & 4294967295)) {
            goto L4;
        } else {
             *width = save_symbol->width & 255 & 4294967295;
            return save_symbol->item;
        }
    }
L5:
    if( *_v16 != charset ||  *width != 0 &&  *width != ( *((intOrPtr*)(_v16 + 4))->width & 255 & 4294967295)) {
        _v16 = _v16 + 8;
        goto L10;
    }
    _v20 =  *(_v16 + 4);
    if(_v20 == 0) {
        if( *width != 2) {
            _t63 =  &alt_symbol_set;
        } else {
            _t63 =  &alt2_symbol_set;
        }
        _v20 = _t63;
    }
    if(_v20 != save_symbol) {
        if((_v20->encode & 255 & 4294967295) == 0) {
            encode_symbol(_v20);
        }
        save_symbol = _v20;
    }
     *width = _v20->width & 255 & 4294967295;
    return _v20->item;
}

char** set_symbol(int width)
{// addr = 0x0809AFC5
    symbol_set* s;
    int i;
    Str tmp;
    struct * _v16;
    signed int _v20;
    struct _Str* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t53;

    _v16 =  &alt_symbol_set;
    if(width == save_width) {
        return symbol_buf;
    }
    if(symbol_buf != 0) {
        _v20 = 0;
L12:
        while( *((intOrPtr*)(_v16->markmax + (_v20 << 2))) != 0) {
            goto L8;
        }
    } else {
        _v20 = 0;
        while( *((intOrPtr*)(_v16->markmax + (_v20 << 2))) != 0) {
            _v20 = _v20 + 1;
        }
    }
L8:
    _v24 = Strnew_size(4);
    if(width != 2) {
        wtf_push(_v24, 2048, _v20 + 32);
    } else {
        wtf_push(_v24, 34816, _v20 + 32);
    }
    symbol_buf[_v20] =  *_v24;
    _v20 = _v20 + 1;
    goto L12;
}

push_symbol(Str str, char symbol, int width, int n)
{// addr = 0x0809B0B9
    char[1] buf;
    char* p;
    int i;
    _unknown_ _v14;
    signed char* _v20;
    intOrPtr _v24;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    signed int _t56;

    _v32 = symbol & 4294967295;
    if(width != 2) {
        _v20 =  *( &alt_symbol + _v32 * 4);
    } else {
        _v20 =  *( &alt2_symbol + _v32 * 4);
    }
    _v24 = 0;
    while(_v24 <= 1 && ( *_v20 & 255 & 4294967295) != 0) {
        __edx = _v24;
        if(( *_v20 & 255 & 4294967295) == 32) {
            _t56 = -96;
        } else {
            _t56 =  *_v20 & 255;
        }
         *(__ebp + __edx - 10) = _t56 & 4294967295;
        _v24 = _v24 + 1;
        _v20 =  &(_v20[1]);
    }
}

char* conv_entity(unsigned int c)
{// addr = 0x0809B188
    char b;
    wc_uchar[6] utf8;
    char _v13;
    char _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t28;
    _unknown_ _t31;
    _unknown_ _t44;
    _unknown_ _t45;
    _unknown_ _t49;

    _v13 = c & 4294967295;
    if(c <= 31) {
        return 135065021;
    }
    if(c <= 126) {
        return  *(Strnew_charp_n( &_v13, 1));
    }
    if(c <= 159) {
        return 135065021;
    }
    if(c == 160) {
        return 135064736;
    }
    if(c > 255) {
        if(c >= 0) {
            return 135064828;
        }
        wc_ucs_to_utf8(c,  &_v20);
        return  *(wc_Str_conv(Strnew_charp( &_v20), 3178565, InnerCharset));
    } else {
        if((UseAltEntity & 255 & 4294967295) == 0) {
            return  *(wc_Str_conv(Strnew_charp_n( &_v13, 1), 1049089, InnerCharset));
        }
        return  *( &alt_latin1 + (c - 160) * 4);
    }
}

writestr(char* s)
{// addr = 0x0809B290
    intOrPtr _v20;
    intOrPtr _v24;
    _unknown_ __ebp;

    _v20 = write1;
    _v24 = 1;
     *__esp = s;
    tputs();
    return;
}

int set_tty()
{// addr = 0x0809B2B3
    char* ttyn;
    struct w3m_term_info* p;
    char* term;
    struct w3m_term_info* p;
    char* _v16;
    struct w3m_term_info[6]* _v20;
    char* _v24;
    struct w3m_term_info[6]* _v28;
    _unknown_ _v36;
    int _v40;
    _unknown_ __ebp;
    _unknown_ _t30;
    _unknown_ _t40;

    if(isatty(0) == 0) {
        _v16 = "/dev/tty";
    } else {
        _v16 = ttyname(0);
    }
    _v40 = 2;
     *__esp = _v16;
    tty = open();
    if(tty < 0) {
        tty = 2;
    }
    ttyf = fdopen(tty, "w");
    _v40 =  &d_ioval;
     *__esp = tty;
    tcgetattr();
    if(displayTitleTerm == 0) {
L11:
        _v24 = getenv("TERM");
        if(_v24 == 0) {
            return 0;
        }
        _v28 =  &w3m_term_info_list;
        while( *_v28 != 0) {
            if(strncmp(_v24,  *_v28, strlen( *_v28)) != 0) {
                _v28 = _v28 + 12;
                continue;
            }
            is_xterm =  *(_v28 + 8);
            return 0;
        }
    } else {
        _v20 =  &w3m_term_info_list;
        while( *_v20 != 0) {
            if(strncmp(displayTitleTerm,  *_v20, strlen( *_v20)) != 0) {
                _v20 = _v20 + 12;
                continue;
            }
            title_str =  *(_v20 + 4);
            goto L11;
        }
    }
}

ttymode_set(int mode, int imode)
{// addr = 0x0809B3FC
    TerminalMode ioval;
    signed int _v16;
    signed int _v64;
    char _v76;
    char* _v84;
    int _v88;
    _unknown_ __ebp;
    _unknown_ _t18;
    int _t24;
    int* _t25;
    int* _t27;
    _unknown_ _t31;
    signed int _t33;

    _v16 =  *gs:0x14];
    _v88 =  &_v76;
     *__esp = tty;
    tcgetattr();
    _v64 = mode | _v64;
    _v76 = imode | _v76;
    while(1) {
        _t24 = tty;
        _v84 =  &_v76;
        _v88 = 0;
         *__esp = _t24;
        tcsetattr();
        __eflags = _t24 - 255;
        if(__eflags != 0) {
            break;
        } else {
            _t25 = __errno_location();
            __eflags =  *_t25 - 4;
            if( *_t25 != 4) {
                _t27 = __errno_location();
                __eflags =  *_t27 - 11;
                if( *_t27 != 11) {
                    _v84 =  *(__errno_location());
                    _v88 = mode;
                    printf("Error occured while set %x: errno=%d\n");
                    reset_exit(0);
                }
            }
            continue;
        }
    }
    _t33 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t33;
    }
    __stack_chk_fail();
    return _t33;
}

ttymode_reset(int mode, int imode)
{// addr = 0x0809B4B6
    TerminalMode ioval;
    signed int _v16;
    signed int _v64;
    char _v76;
    char* _v84;
    int _v88;
    _unknown_ __ebp;
    _unknown_ _t18;
    int _t26;
    int* _t27;
    int* _t29;
    _unknown_ _t33;
    signed int _t35;

    _v16 =  *gs:0x14];
    _v88 =  &_v76;
     *__esp = tty;
    tcgetattr();
    _v64 =  !mode & _v64;
    _v76 =  !imode & _v76;
    while(1) {
        _t26 = tty;
        _v84 =  &_v76;
        _v88 = 0;
         *__esp = _t26;
        tcsetattr();
        __eflags = _t26 - 255;
        if(__eflags != 0) {
            break;
        } else {
            _t27 = __errno_location();
            __eflags =  *_t27 - 4;
            if( *_t27 != 4) {
                _t29 = __errno_location();
                __eflags =  *_t29 - 11;
                if( *_t29 != 11) {
                    _v84 =  *(__errno_location());
                    _v88 = mode;
                    printf("Error occured while reset %x: errno=%d\n");
                    reset_exit(0);
                }
            }
            continue;
        }
    }
    _t35 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t35;
    }
    __stack_chk_fail();
    return _t35;
}

set_cc(int spec, int val)
{// addr = 0x0809B574
    TerminalMode ioval;
    signed int _v16;
    char _v76;
    char* _v84;
    int _v88;
    _unknown_ __ebp;
    _unknown_ _t15;
    int _t18;
    int* _t19;
    int* _t21;
    _unknown_ _t25;
    signed int _t27;

    _v16 =  *gs:0x14];
    _v88 =  &_v76;
     *__esp = tty;
    tcgetattr();
     *(__ebp + spec - 55) = val & 4294967295;
    while(1) {
        _t18 = tty;
        _v84 =  &_v76;
        _v88 = 0;
         *__esp = _t18;
        tcsetattr();
        __eflags = _t18 - 255;
        if(__eflags != 0) {
            break;
        } else {
            _t19 = __errno_location();
            __eflags =  *_t19 - 4;
            if( *_t19 != 4) {
                _t21 = __errno_location();
                __eflags =  *_t21 - 11;
                if( *_t21 != 11) {
                    _v88 =  *(__errno_location());
                    printf("Error occured: errno=%d\n");
                    reset_exit(0);
                }
            }
            continue;
        }
    }
    _t27 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t27;
    }
    __stack_chk_fail();
    return _t27;
}

close_tty()
{// addr = 0x0809B61B
    _unknown_ __ebp;
    _unknown_ _t3;

    if(tty <= 2) {
        return ;
    }
    close(tty);
    return;
}

char* ttyname_tty()
{// addr = 0x0809B63A
    _unknown_ __ebp;

    return ttyname(tty);
}

reset_tty()
{// addr = 0x0809B64F
    struct termios* _v20;
    intOrPtr _v24;
    _unknown_ __ebp;

    writestr(T_op);
    writestr(T_me);
    if(Do_not_use_ti_te == 0) {
        if(T_te == 0 || ( *T_te & 255 & 4294967295) == 0) {
            writestr(T_cl);
        } else {
            writestr(T_te);
        }
    }
    writestr(T_se);
    flush_tty();
    _v20 =  &d_ioval;
    _v24 = 0;
     *__esp = tty;
    tcsetattr();
    close_tty();
    return;
}

reset_exit(int _dummy)
{// addr = 0x0809B6DF
    _unknown_ __ebp;

    if(mouseActive != 0) {
        mouse_end();
    }
    reset_tty();
    w3m_exit(0);
    return;
}

error_dump(int _dummy)
{// addr = 0x0809B706
    _unknown_ _v24;
    _unknown_ _v52;
    _unknown_ __ebp;
    _unknown_ _t10;
    _unknown_ _t11;
    _unknown_ _t12;
    _unknown_ _t13;
    _unknown_ _t14;
    _unknown_ _t15;
    _unknown_ _t16;
    _unknown_ _t17;
    _unknown_ _t18;
    _unknown_ _t19;
    _unknown_ _t20;
    _unknown_ _t21;

    mySignal(6, 0);
    reset_tty();
    abort();
    _push(_t20);
    __esp = __esp - 24;
    mySignal(1, reset_exit);
    mySignal(2, reset_exit);
    mySignal(3, reset_exit);
    mySignal(15, reset_exit);
    mySignal(4, error_dump);
    mySignal(6, error_dump);
    mySignal(8, error_dump);
    mySignal(7, error_dump);
    return;
}

set_int()
{// addr = 0x0809B72A
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t9;
    _unknown_ _t10;
    _unknown_ _t11;
    _unknown_ _t12;
    _unknown_ _t13;
    _unknown_ _t14;
    _unknown_ _t15;
    _unknown_ _t16;

    mySignal(1, reset_exit);
    mySignal(2, reset_exit);
    mySignal(3, reset_exit);
    mySignal(15, reset_exit);
    mySignal(4, error_dump);
    mySignal(6, error_dump);
    mySignal(8, error_dump);
    mySignal(7, error_dump);
    return;
}

setgraphchar()
{// addr = 0x0809B7D2
    int c;
    int i;
    int n;
    intOrPtr _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    _v16 = 0;
    while(_v16 <= 95) {
    }
}

getTCstr()
{// addr = 0x0809B86E
    char* ent;
    char* suc;
    char* pt;
    int r;
    char* _v16;
    const char* _v20;
    char _v24;
    char* _v28;
    _unknown_ _v32;
    char* _v36;
    const char* _v40;
    _unknown_ __ebp;
    _unknown_ _t220;
    char* _t222;
    char* _t223;
    const char* _t225;
    const char* _t229;
    char* _t233;
    const char* _t236;
    const char* _t240;
    const char* _t244;
    const char* _t248;
    const char* _t252;
    const char* _t256;
    const char* _t260;
    const char* _t264;
    const char* _t268;
    const char* _t272;
    const char* _t276;
    const char* _t280;
    const char* _t284;
    const char* _t288;
    const char* _t292;
    const char* _t296;
    const char* _t300;
    const char* _t304;
    const char* _t308;
    const char* _t312;
    const char* _t316;
    const char* _t320;
    const char* _t324;
    const char* _t329;
    const char* _t333;
    _unknown_ _t339;
    _unknown_ _t342;

    _v24 =  &funcstr;
    if(getenv("TERM") == 0) {
        _t222 = 0;
    } else {
        _t222 = getenv("TERM");
    }
    _v16 = _t222;
    if(_v16 == 0) {
        fwrite("TERM is not set\n", 1, 16, __imp__stderr);
        reset_exit(0);
    }
    _t223 = _v16;
    _v40 = _t223;
     *__esp = 135782944;
    tgetent();
    _v28 = _t223;
    if(_v28 != 1) {
        _v36 = _v16;
        fprintf(__imp__stderr, "Can't find termcap entry %s\n");
        reset_exit(0);
    }
    T_ce = _v24;
    _t225 =  &_v24;
    _v40 = _t225;
     *__esp = "ce";
    tgetstr();
    _v20 = _t225;
    if(_v20 != 0) {
        T_ce = allocStr(_v20, -1);
    } else {
        T_ce = 135065234;
    }
    T_cd = _v24;
    _t229 =  &_v24;
    _v40 = _t229;
     *__esp = "cd";
    tgetstr();
    _v20 = _t229;
    if(_v20 != 0) {
        T_cd = allocStr(_v20, -1);
    } else {
        T_cd = 135065234;
    }
    T_kr = _v24;
    _t233 =  &_v24;
    _v40 = _t233;
     *__esp = "nd";
    tgetstr();
    _v20 = _t233;
    if(_v20 != 0) {
        _t233 = allocStr(_v20, -1);
        T_kr = _t233;
    } else {
        T_kr = 135065234;
    }
    if(_v20 == 0) {
        T_kr = _v24;
        _t233 =  &_v24;
        _v40 = _t233;
         *__esp = "kr";
        tgetstr();
        _v20 = _t233;
        if(_v20 != 0) {
            _t233 = allocStr(_v20, -1);
            T_kr = _t233;
        } else {
            T_kr = 135065234;
        }
    }
     *__esp = "bs";
    tgetflag();
    if(_t233 == 0) {
        T_kl = _v24;
        _t236 =  &_v24;
        _v40 = _t236;
         *__esp = 135065249;
        tgetstr();
        _v20 = _t236;
        if(_v20 != 0) {
            T_kl = allocStr(_v20, -1);
        } else {
            T_kl = 135065234;
        }
        if(_v20 == 0) {
            T_kl = _v24;
            _t333 =  &_v24;
            _v40 = _t333;
             *__esp = 135065252;
            tgetstr();
            _v20 = _t333;
            if(_v20 != 0) {
                T_kl = allocStr(_v20, -1);
            } else {
                T_kl = 135065234;
            }
        }
        if(_v20 == 0) {
            T_kl = _v24;
            _t329 =  &_v24;
            _v40 = _t329;
             *__esp = 135065255;
            tgetstr();
            _v20 = _t329;
            if(_v20 != 0) {
                T_kl = allocStr(_v20, -1);
            } else {
                T_kl = 135065234;
            }
        }
    } else {
        T_kl = 135065247;
    }
    T_cr = _v24;
    _t240 =  &_v24;
    _v40 = _t240;
     *__esp = 135065258;
    tgetstr();
    _v20 = _t240;
    if(_v20 != 0) {
        T_cr = allocStr(_v20, -1);
    } else {
        T_cr = 135065234;
    }
    T_ta = _v24;
    _t244 =  &_v24;
    _v40 = _t244;
     *__esp = 135065261;
    tgetstr();
    _v20 = _t244;
    if(_v20 != 0) {
        T_ta = allocStr(_v20, -1);
    } else {
        T_ta = 135065234;
    }
    T_sc = _v24;
    _t248 =  &_v24;
    _v40 = _t248;
     *__esp = 135065264;
    tgetstr();
    _v20 = _t248;
    if(_v20 != 0) {
        T_sc = allocStr(_v20, -1);
    } else {
        T_sc = 135065234;
    }
    T_rc = _v24;
    _t252 =  &_v24;
    _v40 = _t252;
     *__esp = 135065267;
    tgetstr();
    _v20 = _t252;
    if(_v20 != 0) {
        T_rc = allocStr(_v20, -1);
    } else {
        T_rc = 135065234;
    }
    T_so = _v24;
    _t256 =  &_v24;
    _v40 = _t256;
     *__esp = 135065270;
    tgetstr();
    _v20 = _t256;
    if(_v20 != 0) {
        T_so = allocStr(_v20, -1);
    } else {
        T_so = 135065234;
    }
    T_se = _v24;
    _t260 =  &_v24;
    _v40 = _t260;
     *__esp = 135065273;
    tgetstr();
    _v20 = _t260;
    if(_v20 != 0) {
        T_se = allocStr(_v20, -1);
    } else {
        T_se = 135065234;
    }
    T_us = _v24;
    _t264 =  &_v24;
    _v40 = _t264;
     *__esp = 135065276;
    tgetstr();
    _v20 = _t264;
    if(_v20 != 0) {
        T_us = allocStr(_v20, -1);
    } else {
        T_us = 135065234;
    }
    T_ue = _v24;
    _t268 =  &_v24;
    _v40 = _t268;
     *__esp = 135065279;
    tgetstr();
    _v20 = _t268;
    if(_v20 != 0) {
        T_ue = allocStr(_v20, -1);
    } else {
        T_ue = 135065234;
    }
    T_md = _v24;
    _t272 =  &_v24;
    _v40 = _t272;
     *__esp = 135065282;
    tgetstr();
    _v20 = _t272;
    if(_v20 != 0) {
        T_md = allocStr(_v20, -1);
    } else {
        T_md = 135065234;
    }
    T_me = _v24;
    _t276 =  &_v24;
    _v40 = _t276;
     *__esp = 135065285;
    tgetstr();
    _v20 = _t276;
    if(_v20 != 0) {
        T_me = allocStr(_v20, -1);
    } else {
        T_me = 135065234;
    }
    T_cl = _v24;
    _t280 =  &_v24;
    _v40 = _t280;
     *__esp = 135065288;
    tgetstr();
    _v20 = _t280;
    if(_v20 != 0) {
        T_cl = allocStr(_v20, -1);
    } else {
        T_cl = 135065234;
    }
    T_cm = _v24;
    _t284 =  &_v24;
    _v40 = _t284;
     *__esp = 135065291;
    tgetstr();
    _v20 = _t284;
    if(_v20 != 0) {
        T_cm = allocStr(_v20, -1);
    } else {
        T_cm = 135065234;
    }
    T_al = _v24;
    _t288 =  &_v24;
    _v40 = _t288;
     *__esp = 135065294;
    tgetstr();
    _v20 = _t288;
    if(_v20 != 0) {
        T_al = allocStr(_v20, -1);
    } else {
        T_al = 135065234;
    }
    T_sr = _v24;
    _t292 =  &_v24;
    _v40 = _t292;
     *__esp = 135065297;
    tgetstr();
    _v20 = _t292;
    if(_v20 != 0) {
        T_sr = allocStr(_v20, -1);
    } else {
        T_sr = 135065234;
    }
    T_ti = _v24;
    _t296 =  &_v24;
    _v40 = _t296;
     *__esp = 135065300;
    tgetstr();
    _v20 = _t296;
    if(_v20 != 0) {
        T_ti = allocStr(_v20, -1);
    } else {
        T_ti = 135065234;
    }
    T_te = _v24;
    _t300 =  &_v24;
    _v40 = _t300;
     *__esp = 135065303;
    tgetstr();
    _v20 = _t300;
    if(_v20 != 0) {
        T_te = allocStr(_v20, -1);
    } else {
        T_te = 135065234;
    }
    T_nd = _v24;
    _t304 =  &_v24;
    _v40 = _t304;
     *__esp = "nd";
    tgetstr();
    _v20 = _t304;
    if(_v20 != 0) {
        T_nd = allocStr(_v20, -1);
    } else {
        T_nd = 135065234;
    }
    T_eA = _v24;
    _t308 =  &_v24;
    _v40 = _t308;
     *__esp = 135065306;
    tgetstr();
    _v20 = _t308;
    if(_v20 != 0) {
        T_eA = allocStr(_v20, -1);
    } else {
        T_eA = 135065234;
    }
    T_as = _v24;
    _t312 =  &_v24;
    _v40 = _t312;
     *__esp = 135065309;
    tgetstr();
    _v20 = _t312;
    if(_v20 != 0) {
        T_as = allocStr(_v20, -1);
    } else {
        T_as = 135065234;
    }
    T_ae = _v24;
    _t316 =  &_v24;
    _v40 = _t316;
     *__esp = 135065312;
    tgetstr();
    _v20 = _t316;
    if(_v20 != 0) {
        T_ae = allocStr(_v20, -1);
    } else {
        T_ae = 135065234;
    }
    T_ac = _v24;
    _t320 =  &_v24;
    _v40 = _t320;
     *__esp = 135065315;
    tgetstr();
    _v20 = _t320;
    if(_v20 != 0) {
        T_ac = allocStr(_v20, -1);
    } else {
        T_ac = 135065234;
    }
    T_op = _v24;
    _t324 =  &_v24;
    _v40 = _t324;
     *__esp = 135065318;
    tgetstr();
    _v20 = _t324;
    if(_v20 != 0) {
        T_op = allocStr(_v20, -1);
    } else {
        T_op = 135065234;
    }
    COLS = 0;
    LINES = COLS;
    setlinescols();
    setgraphchar();
    return;
}

setlinescols()
{// addr = 0x0809C199
    char* p;
    int i;
    struct winsize wins;
    char* _v16;
    int _v20;
    signed int _v26;
    signed int _v28;
    char* _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    int _t26;
    int _t29;
    int _t30;

    _t26 = tty;
    _v36 =  &_v28;
    _v40 = 21523;
     *__esp = _t26;
    ioctl();
    _v20 = _t26;
    if(_v20 < 0 && (_v28 & 65535 & 4294967295) != 0 && (_v26 & 65535 & 4294967295) != 0) {
        LINES = _v28 & 65535 & 4294967295 & ;
        COLS = _v26 & 65535 & 4294967295 & ;
    }
    if(LINES <= 0) {
        _v16 = getenv(135065321);
        if(_v16 != 0) {
            _v20 = atoi(_v16);
            if(_v20 < 0) {
                LINES = _v20;
            }
        }
    }
    if(COLS <= 0) {
        _v16 = getenv("COLUMNS");
        if(_v16 != 0) {
            _v20 = atoi(_v16);
            if(_v20 < 0) {
                COLS = _v20;
            }
        }
    }
    _t29 = LINES;
    if(_t29 <= 0) {
         *__esp = "li";
        tgetnum();
        LINES = _t29;
    }
    _t30 = COLS;
    if(_t30 <= 0) {
         *__esp = "co";
        tgetnum();
        COLS = _t30;
    }
    if(COLS > 400) {
        COLS = 400;
    }
    if(LINES <= 200) {
        return ;
    }
    LINES = 200;
    return;
}

setupscreen()
{// addr = 0x0809C2C4
    int i;
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int _t67;
    _unknown_ _t75;
    Screen** _t81;
    Screen* _t88;
    Screen** _t90;

    if(LINES + 1 > max_LINES) {
        max_LINES = LINES + 1;
        max_COLS = 0;
        _t88 = max_LINES + max_LINES + _t113 << 2;
         *__esp = _t88;
        GC_malloc();
        ScreenElem = _t88;
        _t90 = max_LINES << 2;
         *__esp = _t90;
        GC_malloc();
        ScreenImage = _t90;
    }
    if(COLS + 1 > max_COLS) {
        max_COLS = COLS + 1;
        _v16 = 0;
        while(_v16 < max_LINES) {
            _t110 = _v16;
            _t67 = max_COLS << 2;
             *__esp = _t67;
            GC_malloc();
             *(ScreenElem + (_v16 + _t110 + _t110 << 2)) = _t67;
            bzero( *(ScreenElem + (_v16 + _v16 + _t111 << 2)), 0 + max_COLS * 4);
            _t112 = _v16;
            _t81 = max_COLS + max_COLS;
             *__esp = _t81;
            GC_malloc();
             *(ScreenElem + (_v16 + _t112 + _t112 << 2) + 4) = _t81;
            _v16 = _v16 + 1;
        }
    }
    _v16 = 0;
L8:
    while(_v16 < LINES) {
        ScreenImage[_v16] = ScreenElem + (_v16 + _v16 + _t104 << 2);
         *(ScreenImage[_v16]->lineprop) = 8;
        ScreenImage[_v16]->isdirty = 0;
        _v16 = _v16 + 1;
    }
    goto L8;
}

int initscr()
{// addr = 0x0809C480
    _unknown_ __ebp;
    _unknown_ _t1;
    _unknown_ _t4;
    _unknown_ _t7;

    if(set_tty() < 0) {
        return -1;
    }
    set_int();
    getTCstr();
    if(T_ti != 0 && Do_not_use_ti_te == 0) {
        writestr(T_ti);
    }
    setupscreen();
    return 0;
}

int write1(char c)
{// addr = 0x0809C4CB
    signed int _v16;
    FILE* _v40;
    _unknown_ __ebp;
    _unknown_ _t8;

    _v16 = c & 4294967295;
    _v40 = ttyf;
     *__esp = _v16;
    _IO_putc();
    return 0;
}

move(int line, int column)
{// addr = 0x0809C4F4
    _unknown_ __ebp;

    if(line < 0 && line < LINES) {
        CurLine = line;
    }
    if(column >= 0) {
        return ;
    }
    if(column >= COLS) {
        return ;
    }
    CurColumn = column;
    return;
}

int need_redraw(char* c1, l_prop pr1, char* c2, l_prop pr2)
{// addr = 0x0809C529
    signed int _v16;
    signed int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t21;
    _unknown_ _t31;
    _unknown_ _t32;

    _v16 = pr1 & 4294967295;
    _v20 = pr2 & 4294967295;
    if(c1 == 0) {
        return 1;
    }
    if(c2 == 0) {
        return 1;
    }
    if(strcmp(c1, c2) != 0) {
        return 1;
    }
    if(( *c1 & 255 & 4294967295) == 32) {
        return (_v20 & 65535 ^ _v16 & 65535) & 4294967295 &  & 65311;
    }
    if(((_v20 & 65535 ^ _v16 & 65535) & 4294967295 &  & 223) == 0) {
        return 0;
    }
    return 1;
}

addch(char c)
{// addr = 0x0809C5A6
    char _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = c & 4294967295;
    addmch( &_v16, 1);
    return;
}

addmch(char* pc, size_t len)
{// addr = 0x0809C5C7
    l_prop* pr;
    int dest;
    int i;
    short int* dirty;
    char** p;
    char c;
    int width;
    l_prop l;
    signed int _v13;
    signed int _v16;
    l_prop* _v20;
    int _v24;
    struct scline _v36;
    signed int _v40;
    int _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    intOrPtr _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int _t323;
    void* _t397;
    _unknown_ _t402;
    char* _t440;
    _unknown_ _t445;
    void* _t465;
    _unknown_ _t470;
    _unknown_ _t492;
    _unknown_ _t497;
    void* _t518;
    _unknown_ _t523;
    void* _t540;
    _unknown_ _t545;
    void* _t601;
    _unknown_ _t606;
    void* _t645;
    _unknown_ _t650;
    _unknown_ _t712;
    _unknown_ _t713;

    _v13 =  *pc & 255 & 4294967295;
    if(( *135119023 & 255 & 4294967295) == 0) {
        _t323 =  *( &WTF_WIDTH_MAP + ( *pc & 255 & 4294967295 & )) & 255 & 4294967295 & ;
    } else {
        _t323 =  *( &WTF_WIDTH_MAP + ( *pc & 255 & 4294967295 & )) & 255 & 4294967295 & ;
    }
    _v40 = _t323;
    if( *135784416 == 0) {
         *135784416 = Strnew();
    }
    Strcopy_charp_n( *135784416, pc, len);
    pc =  *( *135784416);
    if(CurColumn == COLS) {
        wrap();
    }
    if(CurColumn >= COLS) {
        return ;
    }
    _v36.lineimage =  *(ScreenImage[CurLine]);
    _v20 = ScreenImage[CurLine]->lineprop;
    _v36.lineprop =  &(ScreenImage[CurLine]->isdirty);
    if(( *(CurColumn + CurColumn + _v20) & 65535 & 4294967295 &  & 8) == 0) {
L16:
        if(_v13 != 9 && _v13 != 10 && _v13 != 13 && _v13 != 8) {
            if(len <= 1) {
                if(( *( &MYCTYPE_MAP + (_v13 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 1) != 0) {
                    return ;
                }
                CurrentMode = CurrentMode & 65535 & 4294967295;
            } else {
                CurrentMode = (CurrentMode & 65535 | 64) & 4294967295;
            }
        } else {
            CurrentMode = CurrentMode & 65535 & 4294967295;
        }
        _v36.isdirty = CurColumn + _v40 - 1;
        if(_v28 >= COLS) {
L37:
            if(CurColumn + _v40 <= COLS) {
                if(( *(CurColumn + CurColumn + _v20) & 65535 & 4294967295 &  & 192) != 128) {
L50:
                    if((CurrentMode & 65535 & 4294967295 &  & 192) == 192) {
L60:
                        if(_v13 != 9) {
                            if(_v13 != 10) {
                                if(_v13 != 13) {
                                    if(_v13 != 8) {
                                        return ;
                                    }
                                    if(CurColumn <= 0) {
                                        return ;
                                    }
                                    CurColumn = CurColumn - 1;
                                    while(CurColumn > 0) {
                                        if(( *(CurColumn + CurColumn + _v20) & 65535 & 4294967295 &  & 192) != 128) {
                                            return ;
                                        }
                                        CurColumn = CurColumn - 1;
                                    }
                                }
                                goto L72;
                            }
                            goto L70;
L72:
                            CurColumn = 0;
                            return;
                        }
                        goto L61;
L70:
                        wrap();
                        return;
                    }
                    goto L51;
L61:
                    _v48 = tab_step;
                    _v24 = tab_step * (CurColumn + tab_step) / _v48;
                    if(_v24 >= COLS) {
                        wrap();
                        touch_line();
                        _v24 = tab_step;
                        _v36.lineimage =  *(ScreenImage[CurLine]);
                        _v20 = ScreenImage[CurLine]->lineprop;
                    }
                    _v36.isdirty = CurColumn;
                    while(_v28 < _v24) {
                        if(need_redraw(_v36.lineimage[_v28],  *(_v28 + _v28 + _v20) & 65535 & 4294967295 & , " ", CurrentMode & 65535 & 4294967295 & ) != 0) {
                            _t397 = _v36.lineimage[_v36.isdirty];
                            _v72 = 2;
                             *__esp = _t397;
                            GC_realloc();
                            _v36.lineimage[_v36.isdirty] = _t397;
                            memcpy(_v36.lineimage[_v36.isdirty], " ", 1);
                            _v36.lineimage[_v36.isdirty][0] = 0;
                             *(_v36.isdirty + _v36.isdirty + _v20) = (CurrentMode & 65535 |  *(_v36.isdirty + _v36.isdirty + _v20) & 65535 & 32) & 4294967295;
                            touch_line();
                            touch_column(_v36.isdirty);
                        }
                        _v36.isdirty = _v36.isdirty + 1;
                    }
                }
                goto L44;
L51:
                if(need_redraw(_v36.lineimage[CurColumn],  *(CurColumn + CurColumn + _v20) & 65535 & 4294967295 & , pc, CurrentMode & 65535 & 4294967295 & ) == 0) {
                    CurColumn = CurColumn + _v40;
                    return;
                }
                _t440 = _v36.lineimage[CurColumn];
                _v72 = len + 1;
                 *__esp = _t440;
                GC_realloc();
                _v36.lineimage[CurColumn] = _t440;
                strncpy(_v36.lineimage[CurColumn], pc, len);
                _v36.lineimage[CurColumn][len] = 0;
                 *(CurColumn + CurColumn + _v20) = (CurrentMode & 65535 |  *(CurColumn + CurColumn + _v20) & 65535 & 32) & 4294967295;
                touch_line();
                touch_column(CurColumn);
                CurrentMode = CurrentMode & 65535 & 4294967295;
                _v36.isdirty = CurColumn + 1;
                while(CurColumn + _v40 > _v28) {
                    _t465 = _v36.lineimage[_v36.isdirty];
                    _v72 = 2;
                     *__esp = _t465;
                    GC_realloc();
                    _v36.lineimage[_v36.isdirty] = _t465;
                    memcpy(_v36.lineimage[_v36.isdirty], " ", 1);
                    _v36.lineimage[_v36.isdirty][0] = 0;
                     *(_v36.isdirty + _v36.isdirty + _v20) = ( *(CurColumn + CurColumn + _v20) & 65535 |  *(_v36.isdirty + _v36.isdirty + _v20) & 65535 & 32) & 4294967295;
                    touch_column(_v36.isdirty);
                    _v36.isdirty = _v36.isdirty + 1;
                }
                goto L60;
            }
            goto L38;
L44:
            touch_line();
            _v36.isdirty = CurColumn - 1;
            while(_v28 >= 0) {
                _v16 =  *(_v36.isdirty + _v36.isdirty + _v20) & 65535 & 4294967295;
                _t518 = _v36.lineimage[_v36.isdirty];
                _v72 = 2;
                 *__esp = _t518;
                GC_realloc();
                _v36.lineimage[_v36.isdirty] = _t518;
                memcpy(_v36.lineimage[_v36.isdirty], " ", 1);
                _v36.lineimage[_v36.isdirty][0] = 0;
                 *(_v36.isdirty + _v36.isdirty + _v20) =  *(_v36.isdirty + _v36.isdirty + _v20) & 65535 & 4294967295;
                touch_column(_v36.isdirty);
                if(_v16 != 128) {
                    goto L50;
                }
                _v36.isdirty = _v36.isdirty - 1;
            }
        }
        if(( *(_v28 + _v28 + _v20) & 65535 & 4294967295 &  & 4) == 0 || need_redraw(_v36.lineimage[_v28],  *(_v28 + _v28 + _v20) & 65535 & 4294967295 & , pc, CurrentMode & 65535 & 4294967295 & ) == 0) {
            if(( *(_v28 + _v28 + _v20) & 65535 & 4294967295 &  & 2) == 0 || (CurrentMode & 65535 & 4294967295 &  & 2) != 0) {
                goto L37;
            } else {
                goto L30;
            }
            goto L38;
        }
L30:
        touch_line();
        _v36.isdirty = _v36.isdirty + 1;
        if(_v28 >= COLS) {
            goto L37;
        }
        touch_column(_v36.isdirty);
        if(( *(_v28 + _v28 + _v20) & 65535 & 4294967295 &  & 8) == 0) {
            _v36.isdirty = _v36.isdirty + 1;
L35:
            while(_v28 < COLS && ( *(_v28 + _v28 + _v20) & 65535 & 4294967295 &  & 192) == 128) {
                goto L34;
            }
        }
        _t601 = _v36.lineimage[_v36.isdirty];
        _v72 = 2;
         *__esp = _t601;
        GC_realloc();
        _v36.lineimage[_v36.isdirty] = _t601;
        memcpy(_v36.lineimage[_v36.isdirty], " ", 1);
        _v36.lineimage[_v36.isdirty][0] = 0;
         *(_v36.isdirty + _v36.isdirty + _v20) =  *(_v36.isdirty + _v36.isdirty + _v20) & 65535 & 32 & 4294967295;
        goto L37;
L34:
        touch_column(_v36.isdirty);
        _v36.isdirty = _v36.isdirty + 1;
        goto L35;
L38:
        touch_line();
        _v36.isdirty = CurColumn;
        while(_v28 < COLS) {
            _t540 = _v36.lineimage[_v36.isdirty];
            _v72 = 2;
             *__esp = _t540;
            GC_realloc();
            _v36.lineimage[_v36.isdirty] = _t540;
            memcpy(_v36.lineimage[_v36.isdirty], " ", 1);
            _v36.lineimage[_v36.isdirty][0] = 0;
             *(_v36.isdirty + _v36.isdirty + _v20) =  *(_v36.isdirty + _v36.isdirty + _v20) & 65535 & 4294967295;
            touch_column(_v36.isdirty);
            _v36.isdirty = _v36.isdirty + 1;
        }
    } else {
        if(_v13 != 32) {
L12:
            _v36.isdirty = CurColumn;
            while(_v28 < 0) {
                if(( *(_v28 + _v28 + _v20) & 65535 & 4294967295 &  & 8) != 0) {
                    _t645 = _v36.lineimage[_v36.isdirty];
                    _v72 = 2;
                     *__esp = _t645;
                    GC_realloc();
                    _v36.lineimage[_v36.isdirty] = _t645;
                    memcpy(_v36.lineimage[_v36.isdirty], " ", 1);
                    ( *((_v36.isdirty << 2) + _v36))[0] = 0;
                     *(_v36.isdirty + _v36.isdirty + _v20) =  *(_v36.isdirty + _v36.isdirty + _v20) & 65535 & 32 & 4294967295;
                    _v36.isdirty = _v36.isdirty - 1;
                    continue;
                }
                goto L16;
            }
        } else {
            if((CurrentMode & 65535 & 4294967295 &  & 65311) != 0) {
                goto L12;
            } else {
                CurColumn = CurColumn + 1;
                return;
            }
        }
    }
}

wrap()
{// addr = 0x0809D009
    _unknown_ __ebp;

    if(LINES - 1 == CurLine) {
        return ;
    }
    CurLine = CurLine + 1;
    CurColumn = 0;
    return;
}

touch_column(int col)
{// addr = 0x0809D039
    _unknown_ __ebp;

    if(col >= 0) {
        return ;
    }
    if(col >= COLS) {
        return ;
    }
     *(ScreenImage[CurLine]->lineprop + col + col) = ( *(ScreenImage[CurLine]->lineprop + col + col) & 65535 | 32) & 4294967295;
    return;
}

touch_line()
{// addr = 0x0809D090
    int i;
    intOrPtr _v8;
    _unknown_ __ebp;

    asm("cwde ");
    if((ScreenImage[CurLine]->isdirty & 65535 & 1) != 0) {
        return ;
    }
    _v8 = 0;
    while(_v8 < COLS) {
         *(ScreenImage[CurLine]->lineprop + _v8 + _v8) =  *(ScreenImage[CurLine]->lineprop + _v8 + _v8) & 65535 & 223 & 4294967295;
        _v8 = _v8 + 1;
    }
}

standout()
{// addr = 0x0809D143
    _unknown_ __ebp;

    CurrentMode = (CurrentMode & 65535 | 1) & 4294967295;
    return;
}

standend()
{// addr = 0x0809D158
    _unknown_ __ebp;

    CurrentMode = CurrentMode & 65535 & 254 & 4294967295;
    return;
}

toggle_stand()
{// addr = 0x0809D16D
    int i;
    l_prop* pr;
    intOrPtr _v8;
    l_prop* _v12;
    _unknown_ __ebp;

    _v12 = ScreenImage[CurLine]->lineprop;
     *(CurColumn + CurColumn + _v12) = ( *(CurColumn + CurColumn + _v12) & 65535 ^ 1) & 4294967295;
    if(( *(CurColumn + CurColumn + _v12) & 65535 & 4294967295 &  & 192) == 128) {
        return ;
    }
    _v8 = CurColumn + 1;
    while(( *(_v8 + _v8 + _v12) & 65535 & 4294967295 &  & 192) == 128) {
         *(_v8 + _v8 + _v12) = ( *(_v8 + _v8 + _v12) & 65535 ^ 1) & 4294967295;
        _v8 = _v8 + 1;
    }
}

bold()
{// addr = 0x0809D20B
    _unknown_ __ebp;

    CurrentMode = (CurrentMode & 65535 | 4) & 4294967295;
    return;
}

boldend()
{// addr = 0x0809D220
    _unknown_ __ebp;

    CurrentMode = CurrentMode & 65535 & 251 & 4294967295;
    return;
}

underline()
{// addr = 0x0809D235
    _unknown_ __ebp;

    CurrentMode = (CurrentMode & 65535 | 2) & 4294967295;
    return;
}

underlineend()
{// addr = 0x0809D24A
    _unknown_ __ebp;

    CurrentMode = CurrentMode & 65535 & 253 & 4294967295;
    return;
}

graphstart()
{// addr = 0x0809D25F
    _unknown_ __ebp;

    CurrentMode = (CurrentMode & 65535 | 16) & 4294967295;
    return;
}

graphend()
{// addr = 0x0809D274
    _unknown_ __ebp;

    CurrentMode = CurrentMode & 65535 & 239 & 4294967295;
    return;
}

int graph_ok()
{// addr = 0x0809D289
    _unknown_ __ebp;
    _unknown_ _t8;
    _unknown_ _t13;
    _unknown_ _t14;

    if((UseGraphicChar & 255 & 4294967295) == 0) {
        return 0;
    }
    if(( *T_as & 255 & 4294967295) == 0) {
        return 0;
    }
    if(( *T_ae & 255 & 4294967295) == 0) {
        return 0;
    }
    if(( *T_ac & 255 & 4294967295) == 0) {
        return 0;
    }
    return 1;
}

setfcolor(int color)
{// addr = 0x0809D2D0
    _unknown_ __ebp;

    CurrentMode = CurrentMode & 65535 & 4294967295;
    if((color & 15) > 7) {
        return ;
    }
    CurrentMode = (CurrentMode & 65535 | (color & 7 | 8) << 8) & 4294967295;
    return;
}

char* color_seq(int colmode)
{// addr = 0x0809D30D
    intOrPtr _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t8;
    _unknown_ _t9;

    _v20 = (colmode >> 8 & 7) + 30;
    sprintf( &seqbuf, 135065343);
    return  &seqbuf;
}

setbcolor(int color)
{// addr = 0x0809D33F
    _unknown_ __ebp;

    CurrentMode = CurrentMode & 65535 & 4294967295;
    if((color & 15) > 7) {
        return ;
    }
    CurrentMode = (CurrentMode & 65535 | (color & 7 | 8) << 12) & 4294967295;
    return;
}

char* bcolor_seq(int colmode)
{// addr = 0x0809D37D
    intOrPtr _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t8;
    _unknown_ _t9;
    _unknown_ _t10;

    _v20 = (colmode >> 12 & 7) + 40;
    sprintf(135784352, 135065343);
    return 135784352;
}

refresh()
{// addr = 0x0809D3AF
    int line;
    int col;
    int pcol;
    int pline;
    int moved;
    char** pc;
    l_prop* pr;
    l_prop mode;
    l_prop color;
    l_prop bcolor;
    short int* dirty;
    signed short _v14;
    signed int _v16;
    signed int _v18;
    signed int _v24;
    signed int _v28;
    signed int _v32;
    struct scline _v44;
    short int _v48;
    short int* _v52;
    _unknown_ _v64;
    signed int _v68;
    short unsigned int _v72;
    _unknown_ __ebp;
    char* _t303;
    int _t360;
    char _t428;
    _unknown_ _t429;
    char* _t488;
    char* _t536;
    short unsigned int _t539;
    _unknown_ _t540;
    _unknown_ _t541;
    char* _t542;
    _unknown_ _t581;

    _v44.isdirty = CurLine;
    _v44.lineprop = 0;
    _v14 = 0;
    _v16 = 0;
    _v18 = 0;
    wc_putc_init(InnerCharset, DisplayCharset);
    _v24 = 0;
    while(LINES - 1 >= _v24) {
        _v52 =  &(ScreenImage[_v24]->isdirty);
        asm("cwde ");
        if(( *_v52 & 65535 & 1 & 4294967295) == 0) {
             *_v52 =  *_v52 & 65535 & 243 & 4294967295;
            if((_v14 & 65535 & 65303) != 0) {
                if((_v14 & 65535 & 65280) != 0) {
                    writestr(T_op);
                }
                if((_v14 & 65535 & 16) != 0) {
                    writestr(T_ae);
                    wc_putc_clear_status();
                }
                writestr(T_me);
                _v14 = _v14 & 232;
            }
            _v24 = _v24 + 1;
            continue;
        } else {
             *_v52 =  *_v52 & 65535 & 254 & 4294967295;
            _v44.lineimage =  *(ScreenImage[_v24]);
            _v48 = ScreenImage[_v24]->lineprop;
            _v28 = 0;
            while(_v28 < COLS && ( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 8) == 0) {
                asm("cwde ");
                if(( *_v52 & 65535 & 4) == 0) {
L7:
                    if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 32) != 0) {
L15:
                        asm("cwde ");
                        if(( *_v52 & 65535 & 12) == 0) {
                            _v32 = _v28;
                        } else {
                            asm("cwde ");
                            _v32 = ScreenImage[_v24]->eol & 65535;
                            if(_v32 >= COLS) {
                                 *_v52 =  *_v52 & 65535 & 243 & 4294967295;
                                _v32 = _v28;
                            }
                        }
                        if(LINES - 2 <= _v24 || _v24 - 1 != _v36 || _v32 != 0) {
                            _t303 = T_cm;
                            _v68 = _v24;
                            _v72 = _v32;
                             *__esp = _t303;
                            tgoto();
                            writestr(_t303);
                            _v44.lineprop = 1;
L31:
                            asm("cwde ");
                            if(( *_v52 & 65535 & 12) != 0) {
L32:
                                writestr(T_ce);
                                if(_v28 != _v32) {
                                    _t536 = T_cm;
                                    _v68 = _v24;
                                    _v72 = _v28;
                                     *__esp = _t536;
                                    tgoto();
                                    writestr(_t536);
                                }
                            }
                            _v44.isdirty = _v24;
                            _v32 = _v28;
                            while(_v28 < COLS) {
                                if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 8) != 0) {
                                    goto L96;
                                }
                                if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 1) != 0 || (_v14 & 65535 & 1 & 4294967295) == 0) {
                                    if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 2) != 0 || (_v14 & 65535 & 2) == 0) {
                                        if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 4) != 0 || (_v14 & 65535 & 4) == 0) {
                                            if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 3840) != 0 || (_v14 & 65535 & 3840) == 0) {
                                                if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 61440) != 0 || (_v14 & 65535 & 61440) == 0) {
                                                    if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 16) != 0 || (_v14 & 65535 & 16) == 0) {
L54:
                                                        asm("cwde ");
                                                        if(( *_v52 & 65535 & 4) == 0) {
L57:
                                                            _t360 =  *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 32;
                                                            goto L58;
                                                        }
                                                        goto L55;
L58:
                                                        if((_t360 & 4294967295) != 0) {
                                                            if(_v28 - 1 != _v32) {
                                                                if(_v32 != _v28) {
                                                                    _t488 = T_cm;
                                                                    _v68 = _v24;
                                                                    _v72 = _v28;
                                                                     *__esp = _t488;
                                                                    tgoto();
                                                                    writestr(_t488);
                                                                }
                                                            } else {
                                                                writestr(T_nd);
                                                            }
                                                            if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 1 & 4294967295) != 0 && (_v14 & 65535 & 1) == 0) {
                                                                writestr(T_so);
                                                                _v14 = _v14 | 1;
                                                            }
                                                            if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 2) != 0 && (_v14 & 65535 & 2) == 0) {
                                                                writestr(T_us);
                                                                _v14 = _v14 | 2;
                                                            }
                                                            if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 4) != 0 && (_v14 & 65535 & 4) == 0) {
                                                                writestr(T_md);
                                                                _v14 = _v14 | 4;
                                                            }
                                                            if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 3840) != 0 && ( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 3840) != 0) {
                                                                _v16 =  *(_v28 + _v28 + _v48) & 65535 & 4294967295;
                                                                _v14 = (_v16 & 65535 | _v14 & 65535) & 4294967295;
                                                                writestr(color_seq(_v16 & 65535));
                                                            }
                                                            if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 61440) != 0 && ( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 61440) != 0) {
                                                                _v18 =  *(_v28 + _v28 + _v48) & 65535 & 4294967295;
                                                                _v14 = (_v18 & 65535 | _v14 & 65535) & 4294967295;
                                                                writestr(bcolor_seq(_v18 & 65535));
                                                            }
                                                            if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 16) != 0 && (_v14 & 65535 & 16) == 0) {
                                                                wc_putc_end(ttyf);
                                                                if(graph_enabled == 0) {
                                                                    graph_enabled = 1;
                                                                    writestr(T_eA);
                                                                }
                                                                writestr(T_as);
                                                                _v14 = _v14 | 16;
                                                            }
                                                            if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 16) == 0) {
                                                                if(( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 192) != 128) {
                                                                    wc_putc(_v44.lineimage[_v28], ttyf);
                                                                }
                                                            } else {
                                                                if(( *(_v44.lineimage[_v28]) & 255 & 4294967295) <= 31 || ( *(_v44.lineimage[_v28]) & 255 & 4294967295) >= 0) {
                                                                    _t428 =  *(_v44.lineimage[_v28]) & 255 & 4294967295;
                                                                } else {
                                                                    _t428 =  *(( *(_v44.lineimage[_v28]) & 255 & 4294967295) - 32 +  &gcmap) & 255 & 4294967295;
                                                                }
                                                                write1(_t428);
                                                            }
                                                            _v32 = _v28 + 1;
                                                        }
                                                        _v28 = _v28 + 1;
                                                        continue;
                                                    } else {
                                                        goto L48;
                                                    }
L55:
                                                    asm("cwde ");
                                                    if((ScreenImage[_v24]->eol & 65535) > _v28) {
                                                        goto L57;
                                                    } else {
                                                        _t360 = need_redraw(_v44.lineimage[_v28],  *(_v28 + _v28 + _v48) & 65535 & 4294967295 & , " ", 0);
                                                    }
                                                    goto L58;
                                                }
                                            }
                                        }
                                    }
                                }
L48:
                                if((_v14 & 65535 & 3840) != 0 || (_v14 & 65535 & 61440) != 0) {
                                    writestr(T_op);
                                }
                                if((_v14 & 65535 & 16) != 0) {
                                    writestr(T_ae);
                                }
                                writestr(T_me);
                                _v14 = _v14 & 232;
                                goto L54;
L96:
                                if(_v28 == COLS) {
                                    _v44.lineprop = 0;
                                }
                                while(_v28 < COLS && ( *(_v28 + _v28 + _v48) & 65535 & 4294967295 &  & 8) == 0) {
                                     *(_v28 + _v28 + _v48) = ( *(_v28 + _v28 + _v48) & 65535 | 8) & 4294967295;
                                    _v28 = _v28 + 1;
                                }
                            }
                        }
                        _t539 = _v44.lineprop;
                        if(_t539 == 1) {
                            write1(10);
                            write1(13);
L28:
                            goto L31;
                        }
                        if(_t539 == 2) {
                            _v44.lineprop = 1;
                            goto L31;
                        }
                        if(_t539 != 0) {
                            goto L31;
                        } else {
                            _t542 = T_cm;
                            _v68 = _v24;
                            _v72 = 0;
                             *__esp = _t542;
                            tgoto();
                            writestr(_t542);
                            _v44.lineprop = 1;
                            goto L28;
                        }
                        goto L32;
                    }
L10:
                    _v28 = _v28 + 1;
                    continue;
                }
                asm("cwde ");
                if((ScreenImage[_v24]->eol & 65535) > _v28) {
                    goto L7;
                }
                if(need_redraw( *((_v28 << 2) + _v44),  *(_v28 + _v28 + _v48) & 65535 & 4294967295 & , " ", 0) == 0) {
                    goto L10;
                } else {
                    goto L15;
                }
            }
        }
    }
}

clear()
{// addr = 0x0809DBFF
    int i;
    int j;
    l_prop* p;
    signed int _v16;
    short unsigned int* _v20;
    l_prop* _v24;
    _unknown_ _v40;
    _unknown_ __ebp;

    writestr(T_cl);
    move(0, 0);
    _v16 = 0;
    while(_v16 < LINES) {
        ScreenImage[_v16]->isdirty = 0;
        _v24 = ScreenImage[_v16]->lineprop;
        _v20 = 0;
        while(_v20 < COLS) {
             *((short*)(_v20 + _v20 + _v24)) = 8;
            _v20 =  &(_v20[0]);
        }
    }
}

clrtoeol()
{// addr = 0x0809DC96
    int i;
    l_prop* lprop;
    int _v8;
    short int _v12;
    _unknown_ __ebp;

    _v12 = ScreenImage[CurLine]->lineprop;
    if(( *(CurColumn + CurColumn + _v12) & 65535 & 4294967295 &  & 8) != 0) {
        return ;
    }
    asm("cwde ");
    if((ScreenImage[CurLine]->isdirty & 65535 & 12) == 0 || (ScreenImage[CurLine]->eol & 65535 & 4294967295) > CurColumn) {
        ScreenImage[CurLine]->eol = CurColumn & 4294967295;
    }
    ScreenImage[CurLine]->isdirty = (ScreenImage[CurLine]->isdirty & 65535 | 8) & 4294967295;
    touch_line();
    _v8 = CurColumn;
    while(_v8 < COLS) {
        if(( *(_v8 + _v8 + _v12) & 65535 & 4294967295 &  & 8) != 0) {
            return ;
        }
         *(_v8 + _v8 + _v12) = 40;
        _v8 = _v8 + 1;
    }
}

clrtoeol_with_bcolor()
{// addr = 0x0809DD9F
    int i;
    int cli;
    int cco;
    l_prop pr;
    signed int _v14;
    int _v20;
    int _v24;
    int _v28;
    _unknown_ _v40;
    _unknown_ __ebp;

    if((CurrentMode & 65535 & 4294967295 &  & 61440) != 0) {
        _v24 = CurLine;
        _v28 = CurColumn;
        _v14 = CurrentMode & 65535 & 4294967295;
        CurrentMode = CurrentMode & 65535 & 4294967295;
        _v20 = CurColumn;
L4:
        while(_v20 < COLS) {
            goto L3;
        }
    }
    clrtoeol();
    return;
L3:
    addch(32);
    _v20 = _v20 + 1;
    goto L4;
}

clrtoeolx()
{// addr = 0x0809DE2D
    _unknown_ __ebp;

    clrtoeol_with_bcolor();
    return;
}

clrtobot_eol(_None* clrtoeol)
{// addr = 0x0809DE3A
    int l;
    int c;
    int _v16;
    int _v20;
    _unknown_ __ebp;

    _v16 = CurLine;
    _v20 = CurColumn;
     *clrtoeol();
    CurColumn = 0;
    CurLine = CurLine + 1;
    while(CurLine < LINES) {
         *clrtoeol();
        CurLine = CurLine + 1;
    }
}

clrtobot()
{// addr = 0x0809DEA1
    _unknown_ __ebp;

    clrtobot_eol(clrtoeol);
    return;
}

clrtobotx()
{// addr = 0x0809DEB6
    _unknown_ __ebp;

    clrtobot_eol(clrtoeolx);
    return;
}

addstr(char* s)
{// addr = 0x0809DECB
    int len;
    unsigned int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    while(( *s & 255 & 4294967295) != 0) {
        _v16 = wtf_len(s);
        addmch(s, _v16);
        s =  &(s[_v16]);
    }
}

addnstr(char* s, int n)
{// addr = 0x0809DF05
    int i;
    int len;
    int width;
    intOrPtr _v16;
    unsigned int _v20;
    signed int _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    signed int _t38;

    _v16 = 0;
    while(( *s & 255 & 4294967295) != 0) {
        if(( *135119023 & 255 & 4294967295) == 0) {
            _t38 =  *( &WTF_WIDTH_MAP + ( *s & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        } else {
            _t38 =  *( &WTF_WIDTH_MAP + ( *s & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        }
        _v24 = _t38;
        if(_v16 + _v24 > n) {
            return ;
        }
        _v20 = wtf_len(s);
        addmch(s, _v20);
        s =  &(s[_v20]);
        _v16 = _v16 + _v24;
    }
}

addnstr_sup(char* s, int n)
{// addr = 0x0809DF98
    int i;
    int len;
    int width;
    intOrPtr _v16;
    unsigned int _v20;
    signed int _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    signed int _t42;

    _v16 = 0;
    while(( *s & 255 & 4294967295) != 0) {
        if(( *135119023 & 255 & 4294967295) == 0) {
            _t42 =  *( &WTF_WIDTH_MAP + ( *s & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        } else {
            _t42 =  *( &WTF_WIDTH_MAP + ( *s & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        }
        _v24 = _t42;
        if(_v16 + _v24 <= n) {
            _v20 = wtf_len(s);
            addmch(s, _v20);
            s =  &(s[_v20]);
            _v16 = _v16 + _v24;
            continue;
        }
        while(_v16 < n) {
            addch(32);
            _v16 = _v16 + 1;
        }
    }
}

crmode()
{// addr = 0x0809E049
    _unknown_ _v24;
    _unknown_ __ebp;

    ttymode_reset(2, 1024);
    ttymode_set(1, 0);
    set_cc(6, 1);
    return;
}

nocrmode()
{// addr = 0x0809E08D
    _unknown_ _v24;
    _unknown_ __ebp;

    ttymode_set(2, 0);
    set_cc(6, 4);
    return;
}

term_echo()
{// addr = 0x0809E0BD
    _unknown_ _v24;
    _unknown_ __ebp;

    ttymode_set(8, 0);
    return;
}

term_noecho()
{// addr = 0x0809E0D9
    _unknown_ _v24;
    _unknown_ __ebp;

    ttymode_reset(8, 0);
    return;
}

term_raw()
{// addr = 0x0809E0F5
    _unknown_ _v24;
    _unknown_ __ebp;

    ttymode_reset(32779, 5120);
    set_cc(6, 1);
    return;
}

term_cooked()
{// addr = 0x0809E125
    _unknown_ _v24;
    _unknown_ __ebp;

    ttymode_set(32779, 0);
    set_cc(6, 4);
    return;
}

term_cbreak()
{// addr = 0x0809E155
    _unknown_ __ebp;

    term_cooked();
    term_noecho();
    return;
}

term_title(char* s)
{// addr = 0x0809E167
    char* _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t9;

    if((fmInitialized & 255 & 4294967295) == 0) {
        return ;
    }
    if(title_str == 0) {
        return ;
    }
    _v20 = s;
    fprintf(ttyf, title_str);
    return;
}

char getch()
{// addr = 0x0809E1A5
    char c;
    char _v13;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    while(read(tty,  &_v13, 1) <= 0) {
        if( *(__errno_location()) == 4) {
            continue;
        }
        if( *(__errno_location()) == 11) {
            goto L5;
        }
        quitfm();
        return _v13 & 255;
L5:
    }
}

char wgetch(_Unknown_base* p)
{// addr = 0x0809E1F6
    char c;
    char _v13;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    while(read(tty,  &_v13, 1) <= 0) {
        if( *(__errno_location()) == 4) {
            continue;
        }
        if( *(__errno_location()) == 11) {
            goto L5;
        }
        quitfm();
        return _v13 & 255;
L5:
    }
}

int do_getch()
{// addr = 0x0809E247
    _unknown_ __ebp;
    int _t2;

    _t2 = is_xterm;
    if(_t2 != 0) {
        return getch() & 4294967295;
    }
     *__esp = 0;
    Gpm_Wgetch();
    return _t2;
}

bell()
{// addr = 0x0809E26E
    _unknown_ __ebp;

    write1(7);
    return;
}

skip_escseq()
{// addr = 0x0809E282
    int c;
    signed int _v16;
    _unknown_ __ebp;
    _unknown_ _t14;
    _unknown_ _t26;
    _unknown_ _t27;
    _unknown_ _t28;

    _v16 = getch() & 4294967295;
    if(_v16 != 91) {
        if(_v16 != 79) {
            return ;
        }
    }
    _v16 = getch() & 4294967295;
    if(is_xterm == 0) {
L8:
        while(( *( &MYCTYPE_MAP + (_v16 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
            _v16 = getch() & 4294967295;
        }
    } else {
        if(_v16 != 77) {
            goto L7;
        }
        getch();
        getch();
        getch();
        return;
    }
L7:
    goto L8;
}

int sleep_till_anykey(int sec, int purge)
{// addr = 0x0809E2F4
    fd_set rfd;
    struct timeval tim;
    int er;
    int c;
    int ret;
    TerminalMode ioval;
    int __d0;
    int __d1;
    intOrPtr _v32;
    char _v92;
    int _v96;
    signed int _v100;
    int _v104;
    int _v108;
    void* _v112;
    int _v116;
    char _v120;
    char _v248;
    char* _v268;
    int _v272;
    int _v276;
    int _v280;
    _unknown_ __edi;
    _unknown_ __ebp;
    _unknown_ _t42;
    _unknown_ _t45;
    _unknown_ _t46;
    int _t47;
    int _t58;
    int _t59;
    int _t60;
    _unknown_ _t63;
    _unknown_ _t66;
    _unknown_ _t67;
    _unknown_ _t76;
    _unknown_ _t80;
    void* _t82;
    _unknown_ _t84;
    _unknown_ _t90;

    _v32 =  *gs:0x14];
    _v280 =  &_v92;
     *__esp = tty;
    tcgetattr();
    term_raw();
    _v120 = sec;
    _v116 = 0;
    _t82 =  &_v248;
    asm("cld ");
    memset(_t82, 0, 32 << 2);
    _v108 = 0;
    _v112 =  &(_t82[8]);
    _t47 = tty;
    _t48 = _t47 >= 0 ? _t47 + 31 : _t47;
    _t49 = (_t47 >= 0 ? _t47 + 31 : _t47) >> 5;
     *(__ebp + -244 + ((_t47 >= 0 ? _t47 + 31 : _t47) >> 5) * 4) = 1 << ((tty + (tty >> 31 >> 27) & 31) - (tty >> 31 >> 27) & 4294967295) |  *(__ebp + -244 + ((_t47 >= 0 ? _t47 + 31 : _t47) >> 5) * 4);
    _v268 =  &_v120;
    _v272 = 0;
    _v276 = 0;
    _t58 =  &_v248;
    _v280 = _t58;
     *__esp = tty + 1;
    select();
    _v104 = _t58;
    if(_v104 > 0 && purge != 0) {
        _v100 = getch() & 4294967295;
        if(_v100 == 27) {
            skip_escseq();
        }
    }
    _t59 = tty;
    _v276 =  &_v92;
    _v280 = 0;
     *__esp = _t59;
    tcsetattr();
    _v96 = _t59;
    _t90 = _v96 - 255;
    if(_t90 == 0) {
        _v280 =  *(__errno_location());
        printf("Error occured: errno=%d\n");
        reset_exit(0);
    }
    _t60 = _v104;
    if(_t90 == 0) {
        return _t60;
    }
    __stack_chk_fail();
    return _t60;
}

mouse_init()
{// addr = 0x0809E44F
    Gpm_Connect conn;
    int r;
    intOrPtr _v16;
    int _v26;
    int _v28;
    int _v30;
    char _v32;
    _unknown_ _v48;
    _unknown_ _v52;
    int _v56;
    _unknown_ __ebp;
    char* _t14;
    _unknown_ _t16;

    if(mouseActive != 0) {
        return ;
    }
    _v32 = 65535;
    _v30 = 0;
    _v26 = 0;
    _v28 = 0;
    _v56 = 0;
    _t14 =  &_v32;
     *__esp = _t14;
    Gpm_Open();
    _v16 = _t14;
    if(_v16 != 254) {
        if(_v16 < 0) {
            __imp__gpm_handler = gpm_process_mouse;
            is_xterm = 0;
        }
    } else {
        Gpm_Close();
        is_xterm = 3;
    }
    _t15 = is_xterm;
    if(is_xterm != 0) {
        fwrite(135065349, 1, 16, ttyf);
        flush_tty();
    }
    mouseActive = 1;
    return;
}

mouse_end()
{// addr = 0x0809E505
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t6;

    if(mouseActive == 0) {
        return ;
    }
    _t5 = is_xterm;
    if(is_xterm == 0) {
        Gpm_Close();
    } else {
        fwrite(135065366, 1, 16, ttyf);
        flush_tty();
    }
    mouseActive = 0;
    return;
}

mouse_active()
{// addr = 0x0809E55F
    _unknown_ __ebp;

    if(mouseActive != 0) {
        return ;
    }
    mouse_init();
    return;
}

mouse_inactive()
{// addr = 0x0809E575
    _unknown_ __ebp;

    if(mouseActive == 0) {
        return ;
    }
    if(is_xterm == 0) {
        return ;
    }
    mouse_end();
    return;
}

flush_tty()
{// addr = 0x0809E594
    _unknown_ __ebp;
    _unknown_ _t3;

    if(ttyf == 0) {
        return ;
    }
    fflush(ttyf);
    return;
}

touch_cursor()
{// addr = 0x0809E5B2
    int i;
    int _v8;
    _unknown_ __ebp;

    touch_line();
    _v8 = CurColumn;
    while(_v8 >= 0) {
        touch_column(_v8);
        if(( *(ScreenImage[CurLine]->lineprop + _v8 + _v8) & 65535 & 4294967295 &  & 192) != 128) {
            goto L6;
        }
        _v8 = _v8 - 1;
        continue;
L6:
        _v8 = CurColumn + 1;
        while(_v8 < COLS) {
            if(( *(ScreenImage[CurLine]->lineprop + _v8 + _v8) & 65535 & 4294967295 &  & 192) != 128) {
                return ;
            }
            touch_column(_v8);
            _v8 = _v8 + 1;
        }
    }
}

struct table2* loadMimeTypes(char* filename)
{// addr = 0x0809E668
    FILE* f;
    char* d;
    char* type;
    int i;
    int n;
    Str tmp;
    struct table2* mtypes;
    FILE* _v16;
    char* _v20;
    char* _v24;
    signed int _v28;
    char* _v32;
    struct _Str* _v36;
    signed int _v40;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t77;
    _unknown_ _t80;
    _unknown_ _t82;
    _unknown_ _t86;
    signed int _t89;
    _unknown_ _t98;
    _unknown_ _t101;
    _unknown_ _t120;
    _unknown_ _t122;
    _unknown_ _t123;

    _v16 = fopen(expandPath(filename), 135065742);
    if(_v16 == 0) {
        return 0;
    }
    _v32 = 0;
    while(1) {
        _v36 = Strfgets(_v16);
        if(_v36->length <= 0) {
            break;
        }
        _v20 =  *_v36;
        if(( *_v20 & 255 & 4294967295) == 35) {
            continue;
        }
        _v20 = strtok(_v20, 135065744);
        if(_v20 == 0) {
            continue;
        }
        _v20 = strtok(0, 135065744);
        _v28 = 0;
        while(_v20 != 0) {
            _v20 = strtok(0, 135065744);
            _v28 = _v28 + 1;
        }
    }
    fseek(_v16, 0, 0);
    _t89 =  &(_v32[1]) << 3;
     *__esp = _t89;
    GC_malloc();
    _v40 = _t89;
    _v28 = 0;
    while(1) {
        _v36 = Strfgets(_v16);
        if(_v36->length <= 0) {
            break;
        }
        _v20 =  *_v36;
        if(( *_v20 & 255 & 4294967295) == 35) {
            continue;
        }
        _v24 = strtok(_v20, 135065744);
        if(_v24 == 0) {
            goto L16;
        } else {
            goto L13;
        }
        while(1) {
L13:
            _v20 = strtok(0, 135065744);
            if(_v20 == 0) {
                break;
            }
            _v40[_v28].item1 =  *(Strnew_charp(_v20));
             &(_v40[_v28])->item2 =  *(Strnew_charp(_v24));
            _v28 = _v28 + 1;
        }
L16:
    }
    _v40[_v28] = 0;
     &(_v40[_v28])->item2 = 0;
    fclose(_v16);
    return _v40;
}

initMimeTypes()
{// addr = 0x0809E854
    int i;
    TextListItem* tl;
    signed int _v16;
    struct _textlistitem* _v20;
    _unknown_ __ebp;
    struct table2** _t18;

    if(non_null(mimetypes_files) == 0) {
        mimetypes_list = 0;
    } else {
        mimetypes_list = make_domain_list(mimetypes_files);
    }
    if(mimetypes_list == 0) {
        return ;
    }
    asm("cwde ");
    _t18 = (mimetypes_list->nitem & 65535) << 2;
     *__esp = _t18;
    GC_malloc();
    UserMimeTypes = _t18;
    _v16 = 0;
    _v20 = mimetypes_list->first;
    while(_v20 != 0) {
        UserMimeTypes[_v16] = loadMimeTypes( *_v20);
        _v16 = _v16 + 1;
        _v20 = _v20->next;
    }
}

char* DefaultFile(int scheme)
{// addr = 0x0809E8F9
    _unknown_ _v24;
    _unknown_ __ebp;
    int _t5;
    _unknown_ _t7;

    _t5 = scheme;
    if(_t5 == 1) {
        return allocStr(135065751, -1);
    }
    if(_t5 <= 1) {
        if(_t5 == 0) {
            return allocStr(135065749, -1);
        }
        return 0;
    }
    if(_t5 > 5) {
        return 0;
    }
    return allocStr(135065749, -1);
}

KeyAbort(int _dummy)
{// addr = 0x0809E962
    int _v0;
    void _v17;
    char* _v20;
    struct _IO_FILE* _v24;
    int _v28;
    struct _IO_FILE* _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ __ebp;
    _unknown_ _t24;
    _unknown_ _t26;
    _unknown_ _t27;
    _unknown_ _t28;

    _v24 = 1;
     *__esp = 135784448;
    siglongjmp();
    _push(_t27);
    __esp = __esp - 40;
    _v48 = fopen(_v20, 135065742);
    if(_v48 == 0) {
        return ;
    }
    while(1) {
        _v28 = fgetc(_v24);
        if(_v28 == 255) {
            break;
        }
        _v17 = _v28 & 4294967295;
        write(_v0,  &_v17, 1);
    }
    fclose(_v24);
    return;
}

write_from_file(int sock, char* file)
{// addr = 0x0809E97C
    FILE* fd;
    int c;
    char[0] buf;
    void _v13;
    struct _IO_FILE* _v20;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t23;
    _unknown_ _t25;

    _v20 = fopen(file, 135065742);
    if(_v20 == 0) {
        return ;
    }
    while(1) {
        _v24 = fgetc(_v20);
        if(_v24 == 255) {
            break;
        }
        _v13 = _v24 & 4294967295;
        write(sock,  &_v13, 1);
    }
    fclose(_v20);
    return;
}

ParsedURL* baseURL(Buffer* buf)
{// addr = 0x0809E9E2
    _unknown_ __ebp;
    _unknown_ _t17;

    asm("cwde ");
    if((buf->bufferprop & 65535 & 16) != 0) {
        return 0;
    }
    if(buf->baseURL == 0) {
        return buf + 132;
    }
    return buf->baseURL;
}

int openSocket(const char* hostname, char* remoteport_name, short unsigned int remoteport_num)
{// addr = 0x0809EA1D
    _None sock;
    int* af;
    struct addrinfo hints;
    struct addrinfo* res0;
    struct addrinfo* res;
    int error;
    char* hname;
    _None prevtrap;
    Str portbuf;
    int _v16;
    intOrPtr* _v20;
    int _v24;
    int _v28;
    int _v32;
    char* _v36;
    _None* _v40;
    struct _Str* _v44;
    char* _v68;
    intOrPtr _v72;
    char _v76;
    signed short _v80;
    int* _v96;
    char* _v100;
    char* _v104;
    _unknown_ __ebx;
    _unknown_ __ebp;
    char* _t112;
    _unknown_ _t115;
    _unknown_ _t119;
    _unknown_ _t128;
    int _t135;
    _unknown_ _t140;
    char* _t141;
    _unknown_ _t143;
    _unknown_ _t153;
    int _t161;
    int _t166;
    int _t182;
    _unknown_ _t189;

    _v80 = remoteport_num & 4294967295;
    _v16 = -1;
    _v40 = 0;
    _t112 = fmInitialized & 255;
    if((_t112 & 4294967295) != 0) {
        _t112 =  *(Sprintf("Opening socket..."));
        message(_t112, 0, 0);
        refresh();
    }
    _v104 = 1;
     *__esp = 135784448;
    __sigsetjmp();
    if(_t112 == 0) {
        if((TrapSignal & 255 & 4294967295) != 0) {
            _v40 = mySignal(2, KeyAbort);
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_cbreak();
            }
        }
        if(hostname == 0) {
            goto L49;
        }
        _v36 = hostname;
        if(_v36 == 0 || ( *_v36 & 255 & 4294967295) != 91 || ( *(strlen(_v36) - 1 + _v36) & 255 & 4294967295) != 93) {
L13:
            _v20 =  &ai_family_order_table + (DNS_order + DNS_order + _t199 << 2);
            while(1) {
L14:
                memset( &_v76, 0, 32);
                _v72 =  *_v20;
                _v68 = 1;
                if(_v80 == 0) {
                    _v32 = -1;
                } else {
                    _v104 = _v80 & 65535;
                    _v44 = Sprintf("%d");
                    _t166 = _v36;
                    _v96 =  &_v24;
                    _v100 =  &_v76;
                    _v104 =  *_v44;
                     *__esp = _t166;
                    getaddrinfo();
                    _v32 = _t166;
                }
                if(_v32 != 0 && remoteport_name != 0 && ( *remoteport_name & 255 & 4294967295) != 0) {
                    _t161 = _v36;
                    _v96 =  &_v24;
                    _v100 =  &_v76;
                    _v104 = remoteport_name;
                     *__esp = _t161;
                    getaddrinfo();
                    _v32 = _t161;
                }
                if(_v32 != 0) {
                    break;
                }
                _v16 = -1;
                _v28 = _v24;
                while(_v28 != 0) {
                    _t135 =  *(_v28 + 4);
                    _v100 =  *(_v28 + 12);
                    _v104 =  *(_v28 + 8);
                     *__esp = _t135;
                    socket();
                    _v16 = _t135;
                    if(_v16 >= 0) {
                        goto L29;
                    }
                    _t141 =  *(_v28 + 20);
                    _v100 =  *(_v28 + 16);
                    _v104 = _t141;
                     *__esp = _v16;
                    connect();
                    if(_t141 >= 0) {
                        if(_v16 >= 0) {
                             *__esp = _v24;
                            freeaddrinfo();
                            if((TrapSignal & 255 & 4294967295) == 0) {
                                return _v16;
                            }
                            if((fmInitialized & 255 & 4294967295) != 0) {
                                term_raw();
                            }
                            if(_v40 == 0) {
                                return _v16;
                            }
                            mySignal(2, _v40);
                            return _v16;
                        }
                         *__esp = _v24;
                        freeaddrinfo();
                        if( *_v20 != 0) {
L40:
                            _v20 = _v20 + 4;
                            goto L14;
                        }
                        goto L49;
                    }
                    close(_v16);
                    _v16 = -1;
L29:
                    _v28 =  *(_v28 + 28);
                }
            }
            if( *_v20 != 0) {
                goto L40;
            }
            goto L49;
        } else {
            _v36 = allocStr( &(hostname[1]), -1);
             *(strlen(_v36) - 1 + _v36) = 0;
            _t182 = strspn(_v36, "0123456789abcdefABCDEF:.");
            if(_t182 != strlen(_v36)) {
                goto L48;
            }
            goto L13;
        }
        goto L14;
L48:
    } else {
        if(_v16 < 0) {
            close(_v16);
        }
    }
L49:
    if((TrapSignal & 255 & 4294967295) == 0) {
        return -1;
    }
    if((fmInitialized & 255 & 4294967295) != 0) {
        term_raw();
    }
    if(_v40 == 0) {
        return -1;
    }
    mySignal(2, _v40);
    return -1;
}

char* copyPath(char* orgpath, int length, int option)
{// addr = 0x0809ED8B
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t53;
    int _t71;
    int _t78;
    int _t86;

    _v16 = Strnew();
    while(( *orgpath & 255 & 4294967295) != 0) {
        if(length == 0) {
            return  *_v16;
        }
        if(( *( &MYCTYPE_MAP + ( *orgpath & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t71 = _v16->length;
             *( *_v16 + _t71) =  *orgpath & 255 & 4294967295;
            _v16->length = _t71 + 1;
             *((char*)( *_v16 + _v16->length)) = 0;
        } else {
            _t78 = option;
            if(_t78 != 1) {
                if(_t78 == 2) {
                    Strcat_charp(_v16, "%20");
                } else {
                    if(_t78 == 0) {
                        if(_v16->length + 1 >= _v16->area_size) {
                            Strgrow(_v16);
                        }
                        _t86 = _v16->length;
                         *( *_v16 + _t86) =  *orgpath & 255 & 4294967295;
                        _v16->length = _t86 + 1;
                         *((char*)( *_v16 + _v16->length)) = 0;
                    }
                }
            }
        }
        orgpath =  &(orgpath[1]);
        length = length - 1;
    }
}

parseURL(char* url, ParsedURL* p_url, ParsedURL* current)
{// addr = 0x0809EEAF
    char* p;
    char* q;
    Str tmp;
    char* cgi;
    char* _v16;
    char* _v20;
    struct _Str* _v24;
    char* _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    char* _t489;
    signed int _t561;
    _unknown_ _t666;
    int _t697;

    url = url_quote(url);
    _v16 = url;
    p_url->scheme = 254;
    p_url->port = 0;
    p_url->user = 0;
    p_url->pass = 0;
    p_url->host = 0;
    p_url->is_nocache = 0;
    p_url->file = 0;
    p_url->real_file = 0;
    p_url->query = 0;
    p_url->label = 0;
    if(( *url & 255 & 4294967295) == 0 || ( *url & 255 & 4294967295) == 35) {
        if(current != 0) {
            copyParsedURL(p_url, current);
        }
L122:
        if(p_url->scheme != 254) {
            if(( *_v16 & 255 & 4294967295) != 35) {
                p_url->label = 0;
                return;
            }
            goto L125;
        }
        goto L123;
L125:
        p_url->label = allocStr( &(_v16[1]), -1);
        return;
    } else {
        p_url->scheme = getURLScheme( &_v16);
        if(p_url->scheme != 254) {
            if(p_url->scheme == 255) {
                p_url->file = allocStr(url, -1);
                return;
            }
            if(( *_v16 & 255 & 4294967295) != 47 || (_v16[1] & 255 & 4294967295) != 47) {
                p_url->host = 0;
                if(p_url->scheme == 255) {
                    p_url->port = 0;
                } else {
                    p_url->port =  *( &DefaultPort + p_url->scheme * 4);
                }
                goto L59;
            }
            if(p_url->scheme != 4) {
L23:
                _v16 =  &(_v16[2]);
                goto L24;
            }
            if((_v16[2] & 255 & 4294967295) == 47 || (_v16[2] & 255 & 4294967295) == 126) {
                _v16 =  &(_v16[2]);
                goto L59;
            }
            goto L23;
        } else {
            if(current == 0) {
                p_url->scheme = 4;
            } else {
                if(current->scheme <= 10) {
                    goto __eax;
                }
                p_url->scheme = current->scheme;
            }
            _v16 = url;
            if(strncmp(_v16, "//", 2) != 0) {
L59:
                if(p_url->scheme == 4 && p_url->user == 0 && p_url->host != 0 && (p_url & 255 & 4294967295) != 0 && strcmp(p_url->host, "localhost") != 0) {
                    p_url->scheme = 2;
                    if(p_url->port == 0) {
                        p_url->port =  *135102632;
                    }
                }
                if(( *_v16 & 255 & 4294967295) == 0 || ( *_v16 & 255 & 4294967295) == 35 || ( *_v16 & 255 & 4294967295) == 63) {
                    if(p_url->host != 0) {
                        goto L71;
                    } else {
                        p_url->file = 135065832;
                    }
L115:
                    if(( *_v16 & 255 & 4294967295) != 63) {
                        goto L122;
                    }
                    _v16 =  &(_v16[1]);
                    _v20 = _v16;
                    while(( *_v16 & 255 & 4294967295) != 0 && ( *_v16 & 255 & 4294967295) != 35) {
                        _v16 =  &(_v16[1]);
                    }
                    goto L123;
                }
L71:
                _v20 = _v16;
                if(p_url->scheme == 1) {
                    if(( *_v20 & 255 & 4294967295) == 47) {
                        _v20 =  &(_v20[1]);
                    }
                    if(( *_v20 & 255 & 4294967295) != 0 && ( *_v20 & 255 & 4294967295) != 47 && (_v20[1] & 255 & 4294967295) != 47 && (_v20[2] & 255 & 4294967295) == 47) {
                        _v20 =  &(_v20[1]);
                    }
                }
                if(( *_v16 & 255 & 4294967295) == 47) {
                    _v16 =  &(_v16[1]);
                }
                if(( *_v16 & 255 & 4294967295) == 0 || ( *_v16 & 255 & 4294967295) == 35 || ( *_v16 & 255 & 4294967295) == 63) {
                    p_url->file = DefaultFile(p_url->scheme);
                    goto L115;
                }
                if(p_url->scheme != 1 || ( *_v16 & 255 & 4294967295) != 82) {
                    _v28 = strchr(_v16, 63);
L99:
                    while(( *_v16 & 255 & 4294967295) == 0 || ( *_v16 & 255 & 4294967295) == 35 || _v16 == _v28) {
                        if(( *_v16 & 255 & 4294967295) != 35 || p_url->scheme != 4) {
L111:
                            if(p_url->scheme == 4 || p_url->scheme == 254) {
                                p_url->file = copyPath(_v20, _v16 - _v20, 0);
                            } else {
                                p_url->file = copyPath(_v20, _v16 - _v20, 1);
                            }
                            goto L115;
                        } else {
                            if(_v16 <= _v20 || ( *(_v16 - 1) & 255 & 4294967295) != 47 || _v28 != 0 && _v16 >= _v28) {
                                if((_v16[1] & 255 & 4294967295) == 0) {
                                    _v16 =  &(_v16[1]);
                                }
                                goto L111;
                            }
                            _v16 =  &(_v16[1]);
                            continue;
                        }
                    }
                } else {
                    _v16 =  &(_v16[1]);
                    _v24 = Strnew();
                    if(_v24->length + 1 >= _v24->area_size) {
                        Strgrow(_v24);
                    }
                    _t697 = _v24->length;
                    _t489 = _v16;
                    ( *_v24)[_t697] =  *_t489 & 255 & 4294967295;
                    _v24->length = _t697 + 1;
                    _v16 =  &(_t489[1]);
                    ( *_v24)[_v24->length] = 0;
                    while(( *_v16 & 255 & 4294967295) != 0 && ( *_v16 & 255 & 4294967295) != 47) {
                        _v16 =  &(_v16[1]);
                    }
                }
                _v16 =  &(_v16[1]);
                goto L99;
            } else {
                _v16 =  &(_v16[2]);
                goto L24;
                do {
                    do {
L53:
                        if(( *_v16 & 255 & 4294967295) != 64) {
                            _v24 = Strnew_charp_n(_v20, _v16 - _v20);
                            p_url->port = atoi( *_v24);
                        } else {
                            p_url->pass = copyPath(_v20, _v16 - _v20, 0);
                            _v16 =  &(_v16[1]);
                            _v20 = _v16;
                            p_url->user = p_url->host;
                            p_url->host = 0;
L24:
                            _v20 = _v16;
                            if(( *_v20 & 255 & 4294967295) != 91) {
L38:
                                while(( *_v16 & 255 & 4294967295) != 0) {
                                    goto L39;
                                }
                            } else {
                                _v16 =  &(_v16[1]);
                                while(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 40) != 0 || ( *_v16 & 255 & 4294967295) == 58 || ( *_v16 & 255 & 4294967295) == 46) {
                                }
                            }
L39:
                            if(strchr(":/?#",  *_v16 & 255 & 4294967295) == 0) {
                                _v16 =  &(_v16[1]);
                                goto L38;
                            }
                            _t561 =  *_v16 & 255 & 4294967295;
                            if(_t561 == 58) {
                                p_url->host = copyPath(_v20, _v16 - _v20, 1);
                                _v16 =  &(_v16[1]);
                                _v20 = _v16;
                                while(( *_v16 & 255 & 4294967295) != 0) {
                                    if(strchr("/?#",  *_v16 & 255 & 4294967295) == 0) {
                                        _v16 =  &(_v16[1]);
                                        continue;
                                    }
                                    goto L53;
                                }
                            }
                            if(_t561 > 58) {
                                if(_t561 == 63) {
                                    goto L57;
                                }
                                goto L47;
                            }
                            if(_t561 == 35 || _t561 == 47 || _t561 == 0) {
L57:
                                p_url->host = copyPath(_v20, _v16 - _v20, 1);
                                p_url->port =  *( &DefaultPort + p_url->scheme * 4);
                            }
                        }
                        goto L59;
                    } while();
                    goto L59;
L47:
                } while(_t561 == 64);
                goto L59;
            }
        }
    }
L123:
    p_url->scheme = 4;
    p_url->file = allocStr(_v16, -1);
    p_url->label = 0;
    return;
}

copyParsedURL(ParsedURL* p, ParsedURL* q)
{// addr = 0x0809F763
    _unknown_ _v24;
    _unknown_ __ebp;
    char* _t68;
    char* _t71;
    char* _t74;
    char* _t77;
    char* _t80;
    char* _t83;
    char* _t86;

    p->scheme = q->scheme;
    p->port = q->port;
    p->is_nocache = q->is_nocache;
    if(q->user == 0) {
        _t68 = 0;
    } else {
        _t68 = allocStr(q->user, -1);
    }
    p->user = _t68;
    if(q->pass == 0) {
        _t71 = 0;
    } else {
        _t71 = allocStr(q->pass, -1);
    }
    p->pass = _t71;
    if(q->host == 0) {
        _t74 = 0;
    } else {
        _t74 = allocStr(q->host, -1);
    }
    p->host = _t74;
    if(q->file == 0) {
        _t77 = 0;
    } else {
        _t77 = allocStr(q->file, -1);
    }
    p->file = _t77;
    if(q->real_file == 0) {
        _t80 = 0;
    } else {
        _t80 = allocStr(q->real_file, -1);
    }
    p->real_file = _t80;
    if(q->label == 0) {
        _t83 = 0;
    } else {
        _t83 = allocStr(q->label, -1);
    }
    p->label = _t83;
    if(q->query == 0) {
        _t86 = 0;
    } else {
        _t86 = allocStr(q->query, -1);
    }
    p->query = _t86;
    return;
}

parseURL2(char* url, ParsedURL* pu, ParsedURL* current)
{// addr = 0x0809F8C8
    char* p;
    Str tmp;
    int relative_uri;
    char* q;
    char* _v16;
    struct _Str* _v20;
    char _v24;
    char* _v28;
    char* _v36;
    char* _v40;
    _unknown_ __ebp;
    int _t340;
    char* _t435;

    _v24 = 0;
    parseURL(url, pu, current);
    if(pu->scheme == 11) {
        return ;
    }
    if(pu->scheme == 9 || pu->scheme == 10) {
        if(pu->file == 0 || strchr(pu->file, 64) != 0) {
L9:
            pu->scheme = 9;
            return;
        } else {
            _v16 = strchr(pu->file, 47);
            if(_v16 == 0 || strchr( &(_v16[1]), 45) != 0 || (_v16[1] & 255 & 4294967295) == 0) {
                pu->scheme = 10;
                return;
            } else {
                goto L9;
            }
        }
        goto L10;
    } else {
L10:
        if(pu->scheme == 7) {
L12:
            if(pu->file != 0) {
                if((pu & 255 & 4294967295) == 47) {
                    pu->file = allocStr( &(pu->file[1]), -1);
                }
            }
            if(pu->file == 0 || strchr(pu->file, 64) != 0) {
L21:
                pu->scheme = 7;
            } else {
                _v16 = strchr(pu->file, 47);
                if(_v16 == 0 || strchr( &(_v16[1]), 45) != 0 || (_v16[1] & 255 & 4294967295) == 0) {
                    pu->scheme = 8;
                    goto L22;
                }
                goto L21;
            }
L22:
            if(current == 0) {
                return ;
            }
            if(current->scheme != 7) {
                if(current->scheme != 8) {
                    return ;
                }
            }
            if(pu->host != 0) {
                return ;
            }
            pu->host = current->host;
            pu->port = current->port;
            return;
        }
        if(pu->scheme != 8) {
            if(pu->scheme == 4) {
                _v28 = expandName(file_unquote(pu->file));
                pu->file = file_quote(_v28);
            }
            if(current == 0 || pu->scheme != current->scheme && (pu->scheme != 2 || current->scheme != 3) && (pu->scheme != 4 || current->scheme != 5) || pu->host != 0) {
L63:
                if(pu->file == 0) {
                    return ;
                }
L64:
                if(pu->scheme != 4 || (pu & 255 & 4294967295) == 47 || strcmp(pu->file, 135065886) == 0) {
                    if(pu->scheme != 0) {
                        if(pu->scheme != 1 && (pu & 255 & 4294967295) == 47) {
                            pu->file = cleanupName(pu->file);
                        }
                    } else {
                        if(_v24 != 0) {
                            pu->file = cleanupName(pu->file);
                        }
                    }
                } else {
                    _v20 = Strnew_charp(CurrentDir);
                    if(_v20->length <= 0 || (( *_v20)[_v20->length - 1] & 255 & 4294967295) != 47) {
                        if(_v20->length + 1 >= _v20->area_size) {
                            Strgrow(_v20);
                        }
                        _t340 = _v20->length;
                        ( *_v20)[_t340] = 47;
                        _v20->length = _t340 + 1;
                        ( *_v20)[_v20->length] = 0;
                    }
                    Strcat_charp(_v20, file_unquote(pu->file));
                    pu->file = file_quote(cleanupName( *_v20));
                }
                if(pu->scheme != 4) {
                    return ;
                }
                pu->real_file = cleanupName(file_unquote(pu->file));
                return;
            } else {
                pu->user = current->user;
                pu->pass = current->pass;
                pu->host = current->host;
                pu->port = current->port;
                if(pu->file == 0 || (pu & 255 & 4294967295) == 0) {
                    pu->file = current->file;
                    if(pu->query == 0) {
                        pu->query = current->query;
                    }
                    goto L63;
                } else {
                    if(pu->scheme != 255 || strchr(pu->file, 58) != 0 || current == 0) {
L43:
                        if(pu->scheme == 1 || (pu & 255 & 4294967295) == 47) {
                            if(pu->scheme == 1) {
                                if((pu & 255 & 4294967295) == 47) {
                                    _v16 = pu->file;
                                    pu->file = allocStr( &(_v16[1]), -1);
                                }
                            }
                            goto L63;
                        } else {
                            _v16 = pu->file;
                            if(current->file == 0) {
L54:
                                goto L58;
                            } else {
                                _v20 = Strnew_charp(current->file);
                                while(_v20->length > 0) {
                                    if(_v20->length <= 0 || (( *_v20)[_v20->length - 1] & 255 & 4294967295) != 47) {
                                        Strshrink(_v20, 1);
                                        continue;
                                    }
                                    Strcat_charp(_v20, _v16);
                                    pu->file =  *_v20;
                                    _v24 = 1;
                                    goto L54;
                                }
                            }
                        }
                        goto L64;
                    } else {
                        _v16 = strchr(current->file, 58);
                        if(_v16 == 0) {
                            goto L43;
                        } else {
                            _t435 = allocStr(current->file, _v16 - current->file);
                            _v36 = pu->file;
                            _v40 = _t435;
                            pu->file =  *(Sprintf(135065880));
                        }
L58:
                        goto L63;
                    }
                }
                goto L64;
            }
        }
        goto L12;
    }
}

Str _parsedURL2Str(ParsedURL* pu, int pass)
{// addr = 0x0809FEC0
    Str tmp;
    struct _Str* _v16;
    int _v40;
    _unknown_ __ebp;
    int _t272;
    int _t304;
    int _t320;
    int _t338;
    int _t361;
    int _t384;
    int _t404;
    int _t419;
    int _t450;

    if(pu->scheme == 254) {
        return Strnew_charp(135065888);
    }
    if(pu->scheme == 255) {
        return Strnew_charp(pu->file);
    }
    if(pu->host != 0) {
L8:
        if(pu->scheme != 4) {
L15:
            _v16 = Strnew_charp( *( &scheme_str + pu->scheme * 4));
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t272 = _v16->length;
             *((char*)( *_v16 + _t272)) = 58;
            _v16->length = _t272 + 1;
             *((char*)( *_v16 + _v16->length)) = 0;
            if(pu->scheme != 11) {
                if(pu->scheme != 9 && pu->scheme != 10) {
                    Strcat_charp(_v16, "//");
                }
                if(pu->user != 0) {
                    Strcat_charp(_v16, pu->user);
                    if(pass != 0 && pu->pass != 0) {
                        if(_v16->length + 1 >= _v16->area_size) {
                            Strgrow(_v16);
                        }
                        _t419 = _v16->length;
                         *((char*)( *_v16 + _t419)) = 58;
                        _v16->length = _t419 + 1;
                         *((char*)( *_v16 + _v16->length)) = 0;
                        Strcat_charp(_v16, pu->pass);
                    }
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t404 = _v16->length;
                     *((char*)( *_v16 + _t404)) = 64;
                    _v16->length = _t404 + 1;
                     *((char*)( *_v16 + _v16->length)) = 0;
                }
                if(pu->host != 0) {
                    Strcat_charp(_v16, pu->host);
                    if(pu->port !=  *((intOrPtr*)( &DefaultPort + pu->scheme * 4))) {
                        if(_v16->length + 1 >= _v16->area_size) {
                            Strgrow(_v16);
                        }
                        _t384 = _v16->length;
                         *((char*)( *_v16 + _t384)) = 58;
                        _v16->length = _t384 + 1;
                         *((char*)( *_v16 + _v16->length)) = 0;
                        _v40 = pu->port;
                        Strcat(_v16, Sprintf("%d"));
                    }
                }
                if(pu->scheme != 9 && pu->scheme != 10 && (pu->file == 0 || (pu & 255 & 4294967295) != 47)) {
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t361 = _v16->length;
                     *((char*)( *_v16 + _t361)) = 47;
                    _v16->length = _t361 + 1;
                     *((char*)( *_v16 + _v16->length)) = 0;
                }
                Strcat_charp(_v16, pu->file);
                if(pu->scheme == 3 && (_v16->length <= 0 || ( *( *_v16 + _v16->length - 1) & 255 & 4294967295) != 47)) {
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t338 = _v16->length;
                     *((char*)( *_v16 + _t338)) = 47;
                    _v16->length = _t338 + 1;
                     *((char*)( *_v16 + _v16->length)) = 0;
                }
                if(pu->query != 0) {
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t320 = _v16->length;
                     *((char*)( *_v16 + _t320)) = 63;
                    _v16->length = _t320 + 1;
                     *((char*)( *_v16 + _v16->length)) = 0;
                    Strcat_charp(_v16, pu->query);
                }
                if(pu->label == 0) {
                    return _v16;
                }
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t304 = _v16->length;
                 *((char*)( *_v16 + _t304)) = 35;
                _v16->length = _t304 + 1;
                 *((char*)( *_v16 + _v16->length)) = 0;
                Strcat_charp(_v16, pu->label);
                return _v16;
            }
            Strcat_charp(_v16, pu->file);
            return _v16;
        } else {
L9:
            if(strcmp(pu->file, 135065886) != 0) {
                goto L15;
            } else {
                _v16 = Strnew_charp(135065886);
                if(pu->label == 0) {
                    return _v16;
                }
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t450 = _v16->length;
                 *((char*)( *_v16 + _t450)) = 35;
                _v16->length = _t450 + 1;
                 *((char*)( *_v16 + _v16->length)) = 0;
                Strcat_charp(_v16, pu->label);
                return _v16;
            }
        }
    } else {
        if(pu->file != 0) {
            goto L8;
        } else {
            if(pu->label == 0) {
                goto L8;
            } else {
                _v40 = pu->label;
                return Sprintf(135065892);
            }
        }
        goto L9;
    }
}

Str parsedURL2Str(ParsedURL* pu)
{// addr = 0x080A03FA
    _unknown_ _v24;
    _unknown_ __ebp;

    return _parsedURL2Str(pu, 0);
}

int getURLScheme(char** url)
{// addr = 0x080A0415
    char* p;
    char* q;
    int i;
    int scheme;
    int len;
    char* _v16;
    char* _v20;
    signed int _v24;
    int _v28;
    int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 =  *url;
    _v28 = 254;
L2:
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 12) != 0 || ( *_v16 & 255 & 4294967295) == 46 || ( *_v16 & 255 & 4294967295) == 43 || ( *_v16 & 255 & 4294967295) == 45) {
            _v16 =  &(_v16[1]);
            goto L2;
        } else {
            if(( *_v16 & 255 & 4294967295) != 58) {
                return _v28;
            }
            _v28 = 255;
            _v24 = 0;
            while(1) {
                _v20 =  *( &schemetable + _v24 * 8);
                if(_v20 == 0) {
                    break;
                } else {
                    _v32 = strlen(_v20);
                    if(strncasecmp(_v20,  *url, _v32) == 0 && (( *url)[_v32] & 255 & 4294967295) == 58) {
                        _v28 =  *(135102692 + _v24 * 8);
                         *url =  &(_v16[1]);
                        return _v28;
                    }
                    _v24 = _v24 + 1;
                    continue;
                }
            }
            return _v28;
        }
    }
}

char* otherinfo(ParsedURL* target, ParsedURL* current, char* referer)
{// addr = 0x080A0505
    Str s;
    char* p;
    char* p;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    char* _v44;
    char* _v48;
    char* _v52;
    char* _v56;
    _unknown_ __ebp;
    _unknown_ _t96;

    _v16 = Strnew();
    Strcat_charp(_v16, "User-Agent: ");
    if(UserAgent == 0) {
L2:
        Strcat_charp(_v16, w3m_version);
L4:
        Strcat_charp(_v16, "\n");
        _v44 = 0;
        _v48 = "\n";
        _v52 = AcceptMedia;
        _v56 = "Accept: ";
        Strcat_m_charp(_v16);
        _v44 = 0;
        _v48 = "\n";
        _v52 = AcceptEncoding;
        _v56 = "Accept-Encoding: ";
        Strcat_m_charp(_v16);
        _v44 = 0;
        _v48 = "\n";
        _v52 = AcceptLang;
        _v56 = "Accept-Language: ";
        Strcat_m_charp(_v16);
        if(target->host != 0) {
            Strcat_charp(_v16, "Host: ");
            Strcat_charp(_v16, target->host);
            if(target->port !=  *((intOrPtr*)( &DefaultPort + target->scheme * 4))) {
                _v56 = target->port;
                Strcat(_v16, Sprintf(":%d"));
            }
            Strcat_charp(_v16, "\n");
        }
        if(target->is_nocache != 0 || (NoCache & 255 & 4294967295) != 0) {
            Strcat_charp(_v16, "Pragma: no-cache\n");
            Strcat_charp(_v16, "Cache-control: no-cache\n");
        }
        if(NoSendReferer != 0) {
            return  *_v16;
        }
        if(referer == 0) {
            if(current == 0 || current->scheme == 4 || current->scheme == 2 && (current->user != 0 || current->pass != 0)) {
                goto L19;
            } else {
                _v20 = current->label;
                Strcat_charp(_v16, "Referer: ");
                current->label = 0;
                Strcat(_v16, parsedURL2Str(current));
                current->label = _v20;
                Strcat_charp(_v16, "\n");
                return  *_v16;
            }
        }
L19:
        if(referer == 0) {
            return  *_v16;
        }
        if(referer == 255) {
            return  *_v16;
        }
        _v24 = strchr(referer, 35);
        Strcat_charp(_v16, "Referer: ");
        if(_v24 == 0) {
            Strcat_charp(_v16, referer);
        } else {
            Strcat_charp_n(_v16, referer, _v24 - referer);
        }
        Strcat_charp(_v16, "\n");
        return  *_v16;
    }
    if(( *UserAgent & 255 & 4294967295) != 0) {
        Strcat_charp(_v16, UserAgent);
        goto L4;
    }
    goto L2;
}

Str HTTPrequestMethod(HRequest* hr)
{// addr = 0x080A07EC
    _unknown_ __ebp;
    signed int _t5;

    _t5 = hr->command & 255 & 4294967295;
    if(_t5 == 2) {
        return Strnew_charp("CONNECT");
    }
    if(_t5 == 3) {
        return Strnew_charp("HEAD");
    }
    if(_t5 == 1) {
        return Strnew_charp("POST");
    }
    return Strnew_charp("GET");
}

Str HTTPrequestURI(ParsedURL* pu, HRequest* hr)
{// addr = 0x080A0844
    Str tmp;
    char* save_label;
    struct _Str* _v16;
    char* _v20;
    int _v40;
    _unknown_ __ebp;
    _unknown_ _t57;
    int _t84;

    _v16 = Strnew();
    if((hr->command & 255 & 4294967295) == 2) {
        Strcat_charp(_v16, pu->host);
        _v40 = pu->port;
        Strcat(_v16, Sprintf(":%d"));
        return _v16;
    }
    if((hr->flag & 255 & 4294967295 & 1 & 4294967295) == 0) {
        _v20 = pu->label;
        pu->label = 0;
        Strcat(_v16, _parsedURL2Str(pu, 1));
        pu->label = _v20;
        return _v16;
    } else {
        Strcat_charp(_v16, pu->file);
        if(pu->query == 0) {
            return _v16;
        }
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t84 = _v16->length;
         *((char*)( *_v16 + _t84)) = 63;
        _v16->length = _t84 + 1;
         *( *_v16 + _v16->length) = 0;
        Strcat_charp(_v16, pu->query);
        return _v16;
    }
    return _v16;
}

Str HTTPrequest(ParsedURL* pu, ParsedURL* current, HRequest* hr, TextList* extra)
{// addr = 0x080A0978
    Str tmp;
    TextListItem* i;
    int seen_www_auth;
    int seen_proxy_auth;
    Str cookie;
    struct _Str* _v16;
    struct _textlistitem* _v20;
    ParsedURL* _v24;
    ParsedURL* _v28;
    struct _Str* _v32;
    _unknown_ _v52;
    long unsigned int _v56;
    _unknown_ __ebp;

    _v24 = 0;
    _v28 = 0;
    _v16 = HTTPrequestMethod(hr);
    Strcat_charp(_v16, " ");
    Strcat_charp(_v16,  *(HTTPrequestURI(pu, hr)));
    Strcat_charp(_v16, " HTTP/1.0\n");
    if(hr->referer != 255) {
        Strcat_charp(_v16, otherinfo(pu, current, hr->referer));
    } else {
        Strcat_charp(_v16, otherinfo(pu, 0, 0));
    }
    if(extra == 0) {
        if((hr->command & 255 & 4294967295) != 2 && use_cookie != 0) {
            _v32 = find_cookie(pu);
            if(_v32 != 0) {
                Strcat_charp(_v16, "Cookie: ");
                Strcat(_v16, _v32);
                Strcat_charp(_v16, "\n");
                if(( *( *_v32) & 255 & 4294967295) != 36) {
                    Strcat_charp(_v16, "Cookie2: $Version="1"\n");
                }
            }
        }
        if((hr->command & 255 & 4294967295) != 1) {
            if(header_string != 0) {
                Strcat(_v16, header_string);
            }
            Strcat_charp(_v16, "\n");
            return _v16;
        }
        if(hr->request->enctype != 1) {
            if(override_content_type == 0) {
                Strcat_charp(_v16, "Content-type: application/x-www-form-urlencoded\n");
            }
            _v56 = hr->request->length;
            Strcat(_v16, Sprintf("Content-length: %ld\n"));
            if(header_string != 0) {
                Strcat(_v16, header_string);
            }
            Strcat_charp(_v16, "\n");
            Strcat_charp_n(_v16, hr->request->body, hr->request->length);
            Strcat_charp(_v16, "\n");
            return _v16;
        }
        Strcat_charp(_v16, "Content-type: multipart/form-data; boundary=");
        Strcat_charp(_v16, hr->request->boundary);
        Strcat_charp(_v16, "\n");
        _v56 = hr->request->length;
        Strcat(_v16, Sprintf("Content-length: %ld\n"));
        Strcat_charp(_v16, "\n");
        return _v16;
    } else {
        _v20 = extra->first;
    }
    while(_v20 != 0) {
        if(strncasecmp( *_v20, "Authorization:", 14) == 0) {
            _v24 = 1;
        }
        if(strncasecmp( *_v20, "Proxy-Authorization:", 20) == 0) {
            _v28 = 1;
        }
        Strcat_charp(_v16,  *_v20);
        _v20 = _v20->next;
    }
}

init_stream(URLFile* uf, int scheme, InputStream stream)
{// addr = 0x080A0CC5
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t25;

    memset(uf, 0, 32);
     *(uf + 4) = stream;
    uf->scheme = scheme & 4294967295;
    uf->encoding = 0;
    uf->is_cgi = 0;
    uf->compression = 0;
    uf->content_encoding = 0;
    uf->guess_type = 0;
    uf->ext = 0;
     *((intOrPtr*)(uf + 28)) = -1;
    return;
}

URLFile openURL(char* url, ParsedURL* pu, ParsedURL* current, URLOption* option, FormList* request, TextList* extra_header, URLFile* ouf, HRequest* hr, unsigned char* status)
{// addr = 0x080A0D3B
    Str tmp;
    int sock;
    int scheme;
    char* p;
    char* q;
    char* u;
    URLFile uf;
    HRequest hr0;
    Str tmp2;
    FILE* ff;
    int _v24;
    char* _v36;
    struct _Str* _v40;
    struct _Str _v64;
    intOrPtr _v68;
    intOrPtr _v72;
    intOrPtr _v76;
    char* _v80;
    char* _v84;
    signed int _v88;
    _unknown_ _v100;
    _unknown_ _v104;
    struct  __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t150;
    HRequest* _t177;

    __ebx = url;
    if(status == 0) {
        status =  &(_v64.area_size);
    }
    if(hr == 0) {
        init_stream( &_v88, 254, 0);
    } else {
        _t177 = hr;
        _v88 = _t177->command;
        _v84 = _t177->referer;
        _v80 = _t177->request;
        _v76 =  *((intOrPtr*)(_t177 + 12));
        _v72 =  *((intOrPtr*)(_t177 + 16));
        _v68 =  *((intOrPtr*)(_t177 + 20));
        _v64.ptr =  *(_t177 + 24);
        _v64.length =  *((intOrPtr*)(_t177 + 28));
    }
    _v36 = pu;
    _v24 = getURLScheme( &_v36);
    if(option != 0 || _v24 != 254 || (ArgvIsURL & 255 & 4294967295) != 0) {
        _v36 = pu;
    } else {
        _v36 = file_to_url(pu);
    }
    parseURL2(_v36, current, option);
    if(current->scheme != 4 || current->file != 0) {
L15:
        _v88 = current->scheme & 4294967295;
        _v64.ptr =  *(parsedURL2Str(current));
        current->is_nocache = request->lastitem & 1;
        _v80 = filename_extension(current->file, 1);
         *status = 0;
        status[1] = 0;
        status[4] = request->item;
        status[8] = extra_header;
        if(current->scheme > 11) {
             *__ebx = _v88;
             *(__ebx + 4) = _v84;
             *(__ebx + 8) = _v80;
             *((intOrPtr*)(__ebx + 12)) = _v76;
             *((intOrPtr*)(__ebx + 16)) = _v72;
             *((intOrPtr*)(__ebx + 20)) = _v68;
             *(__ebx + 24) = _v64.ptr;
             *((intOrPtr*)(__ebx + 28)) = _v64.length;
            return __ebx;
        }
    } else {
        if(current->label == 0) {
             *__ebx = _v88;
             *(__ebx + 4) = _v84;
             *(__ebx + 8) = _v80;
             *((intOrPtr*)(__ebx + 12)) = _v76;
             *((intOrPtr*)(__ebx + 16)) = _v72;
             *((intOrPtr*)(__ebx + 20)) = _v68;
             *(__ebx + 24) = _v64;
             *((intOrPtr*)(__ebx + 28)) = _v64.length;
            return __ebx;
        }
        _v40 = Strnew_charp("#");
        Strcat_charp(_v40, current->label);
        current->file =  *_v40;
        current->real_file = cleanupName(file_unquote(current->file));
        current->label = 0;
        goto L15;
    }
L16:
    goto __eax;
}

add_index_file(ParsedURL* pu, URLFile* uf)
{// addr = 0x080A1AD3
    char* p;
    char* q;
    char* _v16;
    char* _v20;
    intOrPtr _v32;
    char* _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    char* _t30;

    if(index_file == 0 || ( *index_file & 255 & 4294967295) == 0) {
         *((intOrPtr*)(uf + 4)) = 0;
        return;
    }
    _t30 = file_quote(index_file);
    _v32 = 0;
    _v36 = _t30;
    _v40 = 135065749;
    _v16 =  *(Strnew_m_charp(pu->file));
    _v16 = cleanupName(_v16);
    _v20 = cleanupName(file_unquote(_v16));
    examineFile(_v20, uf);
    if( *((intOrPtr*)(uf + 4)) == 0) {
        return ;
    }
    pu->file = _v16;
    pu->real_file = _v20;
    return;
}

char* guessContentTypeFromTable(struct table2* table, char* filename)
{// addr = 0x080A1B89
    struct table2* t;
    char* p;
    _unknown_ _v16;
    signed char* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t59;
    _unknown_ _t60;
    _unknown_ _t63;

    if(table == 0) {
        return 0;
    }
    _v20 = strlen(filename) - 1 + filename;
    while(filename < _v20 && ( *_v20 & 255 & 4294967295) != 46) {
        _v20 = _v20 - 1;
    }
}

char* guessContentType(char* filename)
{// addr = 0x080A1C4F
    char* ret;
    int i;
    char* _v16;
    signed int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t25;

    if(filename == 0) {
        return 0;
    }
    if(mimetypes_list == 0) {
        return guessContentTypeFromTable( &DefaultGuess, filename);
    }
    _v20 = 0;
    while(1) {
        asm("cwde ");
        if((mimetypes_list->nitem & 65535) <= _v20) {
            break;
        }
        _v16 = guessContentTypeFromTable(UserMimeTypes[_v20], filename);
        if(_v16 != 0) {
            return _v16;
        }
        _v20 = _v20 + 1;
    }
    return guessContentTypeFromTable( &DefaultGuess, filename);
}

TextList* make_domain_list(char* domain_list)
{// addr = 0x080A1CCB
    char* p;
    Str tmp;
    TextList* domains;
    signed int _v16;
    _Unknown_base* _v20;
    GeneralList* _v24;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v24 = 0;
    _v16 = domain_list;
    _v20 = Strnew_size(64);
    while(( *_v16 & 255 & 4294967295) != 0) {
        while(1) {
            _v16 =  *_v16 & 255;
            if(( *_v16 & 255 & 4294967295) == 0) {
                break;
            }
            _v16 =  *_v16 & 255;
             *_v16 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255;
             *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
            if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                _v16 = _v16 + 1;
                continue;
            }
            break;
        }
L5:
        __eax = _v20;
        Strclear(_v20);
        while(1) {
            _v16 =  *_v16 & 255;
            if(( *_v16 & 255 & 4294967295) == 0) {
                break;
            }
            _v16 =  *_v16 & 255;
             *_v16 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255;
             *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
            if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                break;
            }
            _v16 =  *_v16 & 255;
            if(( *_v16 & 255 & 4294967295) != 44) {
                _v20 =  *(_v20 + 4);
                __edx =  &( *(_v20 + 4)->first);
                _v20 =  *(_v20 + 8);
                if( &( *(_v20 + 4)->first) >=  *(_v20 + 8)) {
                    __eax = _v20;
                    Strgrow(_v20);
                }
                _v20 = _v20;
                __eax =  *(_v20 + 4);
                __eax = _v16;
                __edx =  *_v16 & 255;
                 *( *_v20 + __eax) =  *_v16 & 255 & 4294967295;
                __edx =  &((__eax)[1]);
                __eax = _v20;
                 *(_v20 + 4) = __edx;
                _v16 = _v16 + 1;
                __eax = _v20;
                __edx =  *_v20;
                _v20 =  *(_v20 + 4);
                __eax =  *_v20 +  *(_v20 + 4);
                 *( *_v20 +  *(_v20 + 4)) = 0;
                continue;
            }
            break;
        }
L12:
        _v20 =  *(_v20 + 4);
        if( *(_v20 + 4) > 0) {
            if(_v24 == 0) {
                _v24 = newGeneralList();
            }
            _v20 =  *_v20;
            __eax = allocStr( *_v20, -1);
            __edx = _v24;
            pushValue(_v24,  *_v20);
        }
        while(1) {
            _v16 =  *_v16 & 255;
            if(( *_v16 & 255 & 4294967295) == 0) {
                break;
            }
            _v16 =  *_v16 & 255;
             *_v16 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255;
             *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
            if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                _v16 = _v16 + 1;
                continue;
            }
            break;
        }
L20:
        _v16 =  *_v16 & 255;
        if(( *_v16 & 255 & 4294967295) == 44) {
            _v16 = _v16 + 1;
        }
    }
}

int domain_match(char* pat, char* domain)
{// addr = 0x080A1E39
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t22;
    _unknown_ _t23;
    _unknown_ _t24;

    if(domain == 0) {
        return 0;
    }
    if(( *pat & 255 & 4294967295) == 46) {
        pat =  &(pat[1]);
    }
    while(strcasecmp(pat, domain) != 0) {
        domain = strchr(domain, 46);
        if(domain == 0) {
            return 0;
        }
        domain =  &(domain[1]);
    }
}

int check_no_proxy(char* domain)
{// addr = 0x080A1EA2
    TextListItem* tl;
    _None ret;
    _None prevtrap;
    int error;
    struct addrinfo hints;
    struct addrinfo* res;
    struct addrinfo* res0;
    char[63] addr;
    int* af;
    intOrPtr _v16;
    char _v80;
    struct _textlistitem* _v84;
    int _v88;
    _None* _v92;
    int _v96;
    int _v100;
    int _v104;
    intOrPtr* _v108;
    intOrPtr _v136;
    char _v140;
    char* _v144;
    char* _v160;
    char* _v164;
    int _v168;
    _unknown_ __ebp;
    _unknown_ _t86;
    int _t88;
    int _t98;
    _unknown_ _t107;
    int _t110;
    intOrPtr _t113;
    _unknown_ _t136;
    _unknown_ _t147;
    char* _t157;

    _v144 = domain;
    _v16 =  *gs:0x14];
    _v88 = 0;
    _v92 = 0;
    if(NO_proxy_domains == 0 || (NO_proxy_domains->nitem & 65535 & 4294967295) == 0) {
L3:
        _t88 = 0;
L44:
        if(_t157 == 0) {
            return _t88;
        }
        __stack_chk_fail();
        return _t88;
    }
    _t157 = _v144;
    if(_t157 != 0) {
        _v84 = NO_proxy_domains->first;
        while(_v84 != 0) {
            if(domain_match( *_v84, _v144) == 0) {
                _v84 = _v84->next;
                continue;
            } else {
                _t88 = 1;
            }
            goto L44;
        }
    }
    goto L3;
    _t98 = NOproxy_netaddr;
    if(_t98 != 0) {
        _v168 = 1;
         *__esp = 135784448;
        __sigsetjmp();
        if(_t98 == 0) {
            if((TrapSignal & 255 & 4294967295) != 0) {
                _v92 = mySignal(2, KeyAbort);
                if((fmInitialized & 255 & 4294967295) != 0) {
                    term_cbreak();
                }
            }
            _v108 =  &ai_family_order_table + (DNS_order + DNS_order + _t149 << 2);
            while(1) {
L17:
                memset( &_v140, 0, 32);
                _v136 =  *_v108;
                _t110 = _v144;
                _v160 =  &_v104;
                _v164 =  &_v140;
                _v168 = 0;
                 *__esp = _t110;
                getaddrinfo();
                _v96 = _t110;
                if(_v96 != 0) {
                    break;
                }
                _v100 = _v104;
                while(_v100 != 0) {
                    _t113 =  *((intOrPtr*)(_v100 + 4));
                    if(_t113 == 2) {
                        _v160 = 64;
                        _v164 =  &_v80;
                        _v168 =  *((intOrPtr*)(_v100 + 20)) + 4;
                         *__esp = 2;
                        inet_ntop();
                        goto L26;
                    }
                    if(_t113 == 10) {
                        goto L25;
                    }
                    _v100 =  *(_v100 + 28);
                    continue;
L26:
                    _v84 = NO_proxy_domains->first;
                    while(_v84 != 0) {
                        if(strncmp( *_v84,  &_v80, strlen( *_v84)) != 0) {
                            _v84 = _v84->next;
                            continue;
                        }
                         *__esp = _v104;
                        freeaddrinfo();
                        _v88 = 1;
L38:
                        if((TrapSignal & 255 & 4294967295) != 0) {
                            if((fmInitialized & 255 & 4294967295) != 0) {
                                term_raw();
                            }
                            if(_v92 != 0) {
                                mySignal(2, _v92);
                            }
                        }
                        _t88 = _v88;
                        goto L44;
                    }
L25:
                    _v160 = 64;
                    _v164 =  &_v80;
                    _v168 =  *((intOrPtr*)(_v100 + 20)) + 8;
                     *__esp = 10;
                    inet_ntop();
                    goto L26;
                }
            }
            if( *_v108 != 0) {
                goto L36;
            }
            goto L38;
L36:
            _v108 = _v108 + 4;
            goto L17;
        }
        goto L12;
    }
    _t88 = 0;
    goto L44;
L12:
    _v88 = 0;
    goto L38;
}

char* filename_extension(char* path, int is_url)
{// addr = 0x080A2170
    char* last_dot;
    char* p;
    int i;
    const char* _v16;
    char* _v20;
    int _v24;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = 135065832;
    _v20 = path;
    if(path == 0) {
        return _v16;
    }
    if(( *_v20 & 255 & 4294967295) == 46) {
        _v20 =  &(_v20[1]);
    }
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *_v20 & 255 & 4294967295) != 46) {
            if(is_url == 0 || ( *_v20 & 255 & 4294967295) != 63) {
                goto L8;
            }
            if(( *_v16 & 255 & 4294967295) != 46) {
                return _v16;
            }
            _v24 = 1;
            while(( *(_v16 + _v24) & 255 & 4294967295) != 0) {
                if(_v24 > 7) {
                    return allocStr(_v16, _v24);
                }
                if(is_url != 0) {
                    if(( *( &MYCTYPE_MAP + ( *(_v16 + _v24) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 12) == 0) {
                        return allocStr(_v16, _v24);
                    }
                }
                _v24 = _v24 + 1;
            }
        } else {
            _v16 = _v20;
L8:
            _v20 =  &(_v20[1]);
            continue;
        }
    }
}

struct table2* loadURIMethods(char* filename)
{// addr = 0x080A2240
    FILE* f;
    int i;
    int n;
    Str tmp;
    struct table2* um;
    char* up;
    char* p;
    FILE* _v16;
    struct _Str _v28;
    signed int _v32;
    struct _Str* _v36;
    char* _v40;
    _unknown_ _v52;
    signed int _v56;
    _unknown_ __ebp;
    _unknown_ _t91;
    signed int _t95;
    _unknown_ _t110;
    _unknown_ _t112;

    _v16 = fopen(expandPath(filename), 135065742);
    if(_v16 == 0) {
        return 0;
    }
    _v28.area_size = 0;
    while(1) {
        _v28 = Strfgets(_v16);
        if(_v28->length <= 0) {
            break;
        }
        if(( *( *_v28) & 255 & 4294967295) != 35) {
            _v28.area_size = _v28.area_size + 1;
        }
    }
    fseek(_v16, 0, 0);
    _v28.length = _v28.area_size;
    _t95 = _v28.length + 1 << 3;
     *__esp = _t95;
    GC_malloc();
    _v32 = _t95;
    _v28.area_size = 0;
    while(1) {
        _v28 = Strfgets(_v16);
        if(_v28->length <= 0) {
            break;
        }
        if(( *( *_v28) & 255 & 4294967295) != 35) {
            while(1) {
                _v28 = _v28->length;
                if(_v28->length <= 0) {
                    __eax = 0;
                } else {
                    _v28 = _v28;
                    _v28->length = _v28->length - 1;
                     *_v28 + _v28->length - 1 =  *( *_v28 + _v28->length - 1) & 255;
                    __eax =  *( *_v28 + _v28->length - 1) & 255 & 4294967295 & ;
                }
                __eax =  *( &MYCTYPE_MAP + __eax) & 255;
                __eax = __eax & 4294967295 & ;
                if(__eax == 0) {
                    break;
                }
                _v56 = 1;
                __eax = _v28;
                 *__esp = _v28;
                Strshrink();
            }
            _v28 =  *_v28;
            _v40 =  *_v28;
            __eax = _v40;
            _v36 = _v40;
            while(1) {
                _v40 =  *_v40 & 255;
                if(( *_v40 & 255 & 4294967295) == 0) {
                    break;
                }
                _v40 =  *_v40 & 255;
                if(( *_v40 & 255 & 4294967295) != 58) {
                    _v40 =  &(_v40[1]);
                    continue;
                }
                _v28.area_size = _v28.area_size << 3;
                _v36 = _v40 - _v36;
                _v56 = _v40 - _v36;
                __eax = _v36;
                 *__esp = _v36;
                Strnew_charp_n() =  *_v36;
                _v32[_v28.area_size].item1 =  *_v36;
                _v40 =  &(_v40[1]);
                break;
            }
            _v40 =  *_v40 & 255;
            if(( *_v40 & 255 & 4294967295) != 0) {
L23:
                while(1) {
                    _v40 =  *_v40 & 255;
                    if(( *_v40 & 255 & 4294967295) == 0) {
                        break;
                    }
                    _v40 =  *_v40 & 255;
                     *_v40 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v40 & 255 & 4294967295 & )) & 255;
                     *( &MYCTYPE_MAP + ( *_v40 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v40 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
                    if(( *( &MYCTYPE_MAP + ( *_v40 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                        _v40 =  &(_v40[1]);
                        continue;
                    }
                    break;
                }
L26:
                _v28.area_size = _v28.area_size << 3;
                _v40 = Strnew_charp(_v40);
                __eax =  *_v40;
                 &(_v32[_v28.area_size])->item2 =  *_v40;
                _v28.area_size = _v28.area_size + 1;
                continue;
            }
            continue;
        }
    }
    _v32[_v28.area_size].item1 = 0;
     &(_v32[_v28.area_size])->item2 = 0;
    fclose(_v16);
    return _v32;
}

initURIMethods()
{// addr = 0x080A2445
    TextList* methodmap_list;
    TextListItem* tl;
    int i;
    struct _textlist _v20;
    signed int _v24;
    _unknown_ __ebp;
    struct table2** _t25;

    _v20.last = 0;
    if(non_null(urimethodmap_files) != 0) {
        _v20.last = make_domain_list(urimethodmap_files);
    }
    if(_v16 == 0) {
        return ;
    }
    asm("cwde ");
    _t25 = (_v20.last->nitem & 65535) + 1 << 2;
     *__esp = _t25;
    GC_malloc();
    urimethods = _t25;
    _v24 = 0;
    _v20.first =  *(_v20.last);
    while(_v20.first != 0) {
        urimethods[_v24] = loadURIMethods( *((char**)(_v20.first)));
        if(urimethods[_v24] != 0) {
            _v24 = _v24 + 1;
        }
        _v20.first =  *(_v20 + 4);
    }
}

Str searchURIMethods(ParsedURL* pu)
{// addr = 0x080A2509
    struct table2* ump;
    int i;
    Str scheme;
    Str url;
    char* p;
    struct table2[1]* _v16;
    signed int _v20;
    struct table2[1]* _v24;
    char _v28;
    char _v32;
    char _v56;
    _unknown_ __ebp;
    _unknown_ _t75;
    _unknown_ _t76;
    _unknown_ _t77;
    _unknown_ _t78;

    _v24 = 0;
    if(pu->scheme != 255) {
        return 0;
    }
    if(urimethods == 0) {
        return 0;
    }
    _v28 = parsedURL2Str(pu);
    _v32 =  *_v28;
    while(( *_v32 & 255 & 4294967295) != 0) {
        if(( *_v32 & 255 & 4294967295) != 58) {
            _v32 = _v32 + 1;
            continue;
        }
        _v24 = Strnew_charp_n( *_v28, _v32 -  *_v28);
        if(_v24 == 0) {
            return 0;
        }
        _v20 = 0;
        while(1) {
            _v16 = urimethods[_v20];
            if(_v16 == 0) {
                break;
            }
            while(1) {
                _v16 =  *_v16;
                if( *_v16 == 0) {
                    break;
                }
                _v24 = _v16;
                 *_v16 = strcasecmp( *_v16,  *_v24);
                if( *_v16 != 0) {
                    _v16 = _v16 + 8;
                    continue;
                }
                _v28 =  *_v28;
                __eax = url_quote( *_v28);
                _v56 =  *_v28;
                __eax = Sprintf( *(_v16 + 4));
                return  *_v28;
            }
            _v20 = _v20 + 1;
        }
        _v16 =  &default_urimethods;
        while( *_v16 != 0) {
            if(strcasecmp( *_v16,  *_v24) != 0) {
                _v16 = _v16 + 8;
                continue;
            }
            _v56 = url_quote( *_v28);
            return Sprintf( *(_v16 + 4));
        }
    }
}

chkExternalURIBuffer(Buffer* buf)
{// addr = 0x080A266A
    int i;
    struct table2* ump;
    signed int _v16;
    struct table2[1]* _v20;
    char* _v36;
    struct table2[1] _v40;
    _unknown_ __ebp;
    _unknown_ _t34;

    _v16 = 0;
    while(1) {
        _v20 = urimethods[_v16];
        if(_v20 == 0) {
            break;
        }
        while( *_v20 != 0) {
            _v36 = "([-;/?:&=+$,a-zA-Z0-9_.!~*'()]|%[0-9A-Fa-f][0-9A-Fa-f])*";
            _v40 =  *_v20;
            Sprintf(135065880);
            reAnchor(buf,  *( *_v20));
            _v20 = _v20 + 8;
        }
    }
    _v20 =  &default_urimethods;
    while( *_v20 != 0) {
        _v36 = "([-;/?:&=+$,a-zA-Z0-9_.!~*'()]|%[0-9A-Fa-f][0-9A-Fa-f])*";
        _v40 =  *_v20;
        reAnchor(buf,  *(Sprintf(135065880)));
        _v20 = _v20 + 8;
    }
}

ParsedURL* schemeToProxy(int scheme)
{// addr = 0x080A2719
    ParsedURL* pu;
    struct _ParsedURL* _v8;
    _unknown_ __ebp;
    int _t7;

    _v8 = 0;
    _t7 = scheme;
    if(_t7 == 1) {
        _v8 =  &GOPHER_proxy_parsed;
        return _v8;
    }
    if(_t7 != 2) {
        if(_t7 == 0) {
            _v8 =  &HTTP_proxy_parsed;
        }
        return _v8;
    }
    _v8 =  &FTP_proxy_parsed;
    return _v8;
    return _v8;
}

KeyAbort(int _dummy)
{// addr = 0x080A2758
    intOrPtr _v0;
    struct _Str* _v20;
    int _v24;
    _unknown_ _v60;
    intOrPtr _v64;
    int _v68;
    _unknown_ __ebp;
    _unknown_ _t144;
    _unknown_ _t152;
    _unknown_ _t155;
    _unknown_ _t159;
    _unknown_ _t166;
    _unknown_ _t167;

    _v24 = 1;
    __esp->ptr = 135784672;
    siglongjmp();
    _push(_t166);
    __esp = __esp - 40;
    if( *_v24 == 0) {
        return 0;
    }
    if(_dummy == 0) {
L8:
        if(_a12 == 0) {
            return 0;
        }
         *_a12 = -1;
        _v20 = StrISgets( *(_v0 + 16));
        if(( *( &MYCTYPE_MAP + ( *( *_v20) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0 && ( *( &MYCTYPE_MAP + (( *_v20)[0] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0 && ( *( &MYCTYPE_MAP + (( *_v20)[0] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0 && (( *_v20)[0] & 255 & 4294967295) == 32) {
            _v64 = _a12;
            _v68 = "%d";
            __esp->ptr =  *_v20;
            __isoc99_sscanf();
        }
        if((( *_v20)[0] & 255 & 4294967295) != 45) {
            return _v20;
        }
        while(1) {
L21:
            _v20 = StrISgets( *(_v0 + 16));
            if(( *( &MYCTYPE_MAP + ( *( *_v20) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
                break;
            }
            if(( *( &MYCTYPE_MAP + (( *_v20)[0] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
                continue;
            }
            if(( *( &MYCTYPE_MAP + (( *_v20)[0] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
                goto L19;
            }
            if((( *_v20)[0] & 255 & 4294967295) != 32) {
                goto L20;
            }
            _v64 = _a12;
            _v68 = "%d";
             *__esp =  *_v20;
            __isoc99_sscanf();
            return _v20;
L20:
L19:
        }
        goto L21;
    } else {
        if(_a8 == 0) {
            _v68 = _dummy;
            _v20 = Sprintf("%s\n");
        } else {
            _v64 = _a8;
            _v68 = _dummy;
            _v20 = Sprintf("%s %s\n");
        }
        fwrite( *_v20, 1, _v20->length,  *(_v0 + 20));
        fflush( *(_v0 + 20));
        goto L8;
    }
    return 0;
}

Str ftp_command(FTP ftp, char* cmd, char* arg, int* status)
{// addr = 0x080A2772
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v32;
    int* _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t143;
    _unknown_ _t151;
    _unknown_ _t154;
    _unknown_ _t158;

    if(ftp->host == 0) {
        return 0;
    }
    if(cmd != 0) {
        fwrite( *_v16, 1, _v16->length, ftp->wf);
        fflush(ftp->wf);
    }
    if(status == 0) {
        return 0;
    }
     *status = -1;
    _v16 = StrISgets( *(ftp + 16));
    if(( *( &MYCTYPE_MAP + ( *( *_v16) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0 && ( *( &MYCTYPE_MAP + ( *( *_v16 + 1) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0 && ( *( &MYCTYPE_MAP + ( *( *_v16 + 2) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0 && ( *( *_v16 + 3) & 255 & 4294967295) == 32) {
        _v36 = status;
        _v40 = "%d";
        __esp->ptr =  *_v16;
        __isoc99_sscanf();
    }
    if(( *( *_v16 + 3) & 255 & 4294967295) != 45) {
        return _v16;
    }
    while(1) {
L20:
        _v16 = StrISgets( *(ftp + 16));
        if(( *( &MYCTYPE_MAP + ( *( *_v16) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
            break;
        }
        if(( *( &MYCTYPE_MAP + ( *( *_v16 + 1) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
            continue;
        }
        if(( *( &MYCTYPE_MAP + ( *( *_v16 + 2) & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
            goto L18;
        }
        if(( *( *_v16 + 3) & 255 & 4294967295) != 32) {
            goto L19;
        }
        _v36 = status;
        _v40 = "%d";
         *__esp =  *_v16;
        __isoc99_sscanf();
        return _v16;
L19:
L18:
    }
    goto L20;
}

ftp_close(FTP ftp)
{// addr = 0x080A2972
    _unknown_ __ebp;
    _unknown_ _t39;
    _unknown_ _t43;
    _unknown_ _t49;

    if(ftp->host == 0) {
        return ;
    }
    if( *(ftp + 16) != 0) {
        ( *(ftp + 16))[0x14] = ( *(ftp + 16))[0x14] & 255 & 239 & 4294967295;
        ISclose( *(ftp + 16));
         *(ftp + 16) = 0;
    }
    if(ftp->wf != 0) {
        fclose(ftp->wf);
        ftp->wf = 0;
    }
    if(ftp->data != 0) {
        fclose(ftp->data);
        ftp->data = 0;
    }
    ftp->host = 0;
    return;
}

int ftp_login(FTP ftp)
{// addr = 0x080A2A10
    int sock;
    int status;
    size_t n;
    struct sockaddr_in sockname;
    int socknamelen;
    struct hostent* sockent;
    Str tmp;
    intOrPtr _v16;
    signed int _v28;
    char _v32;
    int _v36;
    intOrPtr _v40;
    int _v44;
    char _v48;
    signed int _v52;
    struct _Str* _v56;
    struct _FTP* _v64;
    int _v92;
    char* _v96;
    signed int _v100;
    char* _v104;
    _unknown_ __ebp;
    _unknown_ _t102;
    int _t107;
    _unknown_ _t122;
    _unknown_ _t128;
    _unknown_ _t135;
    int _t152;
    signed int _t159;
    signed int _t160;
    _unknown_ _t168;
    _unknown_ _t195;

    _v64 = ftp;
    _v16 =  *gs:0x14];
    _v36 = openSocket( *_v64, "ftp", 21);
    if(_v36 >= 0) {
        goto L27;
    }
    if(ftppass_hostnamegen == 0 || strcmp(_v64->user, "anonymous") != 0) {
L10:
         *(_v64 + 16) = newInputStream(_v36);
        _v64->wf = fdopen(dup(_v36), "wb");
        if( *(_v64 + 16) == 0 || _v64->wf == 0) {
L27:
            ftp_close(_v64);
            _t107 = 0;
        } else {
             *(_v64 + 16)->base.stream.cur = ( *(_v64 + 16)->base.stream.cur & 255 | 16) & 4294967295;
            ftp_command(_v64, 0, 0,  &_v40);
            if(_v40 != 220) {
                goto L24;
            }
            if((fmInitialized & 255 & 4294967295) != 0) {
                _v104 = _v64->user;
                message( *(Sprintf("Sending FTP username (%s) to remote server.")), 0, 0);
                refresh();
            }
            ftp_command(_v64, "USER", _v64->user,  &_v40);
            if(_v40 != 230) {
                if(_v40 != 331) {
                    goto L25;
                }
                if((fmInitialized & 255 & 4294967295) != 0) {
                    message("Sending FTP password to remote server.", 0, 0);
                    refresh();
                }
                ftp_command(_v64, "PASS", _v64->pass,  &_v40);
                _t195 = _v40 - 230;
                if(_t195 != 0) {
                    goto L26;
                } else {
                    goto L22;
                }
                goto L27;
L26:
                goto L27;
            }
L22:
            _t107 = 1;
            goto L28;
L25:
            goto L27;
        }
L28:
        if(_t195 == 0) {
            return _t107;
        }
        __stack_chk_fail();
        return _t107;
    } else {
        _v44 = strlen(_v64->pass);
        if(_v44 == 0 || (_v64->pass[_v44 - 1] & 255 & 4294967295) != 64) {
            goto L10;
        }
        _v48 = 16;
        _v100 =  &_v48;
        _v104 =  &_v32;
        _t152 = _v36;
         *__esp = _t152;
        getsockname();
        if(_t152 != 0) {
            goto L10;
        }
        _v56 = Strnew_charp(_v64->pass);
        _v100 = _v32 & 65535 & 4294967295 & ;
        _v104 = 4;
        _t159 =  &((char*)( &_v32)[2]);
         *__esp = _t159;
        gethostbyaddr();
        _v52 = _t159;
        if(_v52 == 0) {
            _t160 = _v28;
             *__esp = _t160;
            inet_ntoa();
            _v92 = 0;
            _v96 = "]";
            _v100 = _t160;
            _v104 = "[";
            Strcat_m_charp(_v56);
        } else {
            Strcat_charp(_v56,  *_v52);
        }
        _v64->pass =  *_v56;
        goto L10;
    }
L24:
    goto L27;
}

int ftp_pasv(FTP ftp)
{// addr = 0x080A2D03
    int status;
    int n1;
    int n2;
    int n3;
    int n4;
    int p1;
    int p2;
    int data;
    char* p;
    Str tmp;
    int family;
    struct sockaddr_storage sockaddr;
    int sockaddrlen;
    int port;
    unsigned char d1;
    unsigned char d2;
    unsigned char d3;
    unsigned char d4;
    char[45] abuf;
    intOrPtr _v16;
    char _v62;
    char _v192;
    signed int _v193;
    signed char _v194;
    signed char _v195;
    signed char _v196;
    intOrPtr _v200;
    char* _v204;
    char* _v208;
    char* _v212;
    char* _v216;
    signed int _v220;
    char _v224;
    int _v228;
    signed int _v232;
    struct _Str* _v236;
    signed int _v240;
    char* _v244;
    signed int _v248;
    struct _FTP* _v256;
    char* _v272;
    signed char* _v276;
    signed int* _v280;
    signed char* _v284;
    signed char* _v288;
    signed char* _v292;
    char* _v296;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t131;
    signed int _t134;
    signed int _t137;
    signed int _t146;
    int _t160;
    signed int _t164;
    signed int _t175;
    signed int _t178;
    signed int _t183;
    signed int _t189;
    _unknown_ _t212;

    _v256 = ftp;
    _v16 =  *gs:0x14];
    _v244 = 128;
    _t134 = fileno(_v256->wf);
    _v292 =  &_v244;
    _v296 =  &_v192;
     *__esp = _t134;
    getpeername();
    __eflags = _t134;
    if(__eflags >= 0) {
        _v240 = _v192 & 65535 & 4294967295 & ;
        _t137 = _v240;
        __eflags = _t137 - 2;
        if(_t137 == 2) {
L20:
            _v236 = ftp_command(_v256, "PASV", 0,  &_v200);
            __eflags = _v200 - 227;
            if(__eflags == 0) {
                _v232 =  *_v236 + 4;
                while(1) {
L24:
                    _t146 =  *_v232 & 255;
                    __eflags = _t146 & 4294967295;
                    if((_t146 & 4294967295) == 0) {
                        break;
                    }
                    _t164 =  *( &MYCTYPE_MAP + ( *_v232 & 255 & 4294967295 & )) & 255;
                    __eflags = _t164 & 4294967295 &  & 8;
                    if((_t164 & 4294967295 &  & 8) == 0) {
                        goto L23;
                    }
                    break;
                }
L26:
                __eflags =  *_v232 & 255 & 4294967295;
                if(__eflags != 0) {
                    _v272 =  &_v224;
                    _v276 =  &_v220;
                    _v280 =  &_v216;
                    _v284 =  &_v212;
                    _v288 =  &_v208;
                    _v292 =  &_v204;
                    _v296 = "%d,%d,%d,%d,%d,%d";
                     *__esp = _v232;
                    __isoc99_sscanf();
                    _v284 = _v216;
                    _v288 = _v212;
                    _v292 = _v208;
                    _v296 = _v204;
                    _v236 = Sprintf("%d.%d.%d.%d");
                    _v228 = openSocket( *_v236, 135066584, (_v220 << 8) + _v224 & 4294967295 & );
L30:
                    __eflags = _v228;
                    if(__eflags >= 0) {
                        _v256->data = fdopen(_v228, "rb");
                        _t160 = 0;
                    } else {
                        _t160 = -1;
                    }
                    goto L33;
                }
                _t160 = -1;
                goto L33;
            }
            goto L21;
L23:
            _v232 =  &((1)[_v232]);
            goto L24;
        }
        goto L3;
L21:
        _t160 = -1;
        goto L33;
    }
    _t160 = -1;
L33:
    if(__eflags == 0) {
        return _t160;
    }
    __stack_chk_fail();
    return _t160;
L3:
    __eflags = _t137 - 10;
    if(__eflags != 0) {
        _t160 = -1;
        goto L33;
    }
    _v236 = ftp_command(_v256, "EPSV", 0,  &_v200);
    __eflags = _v200 - 229;
    if(__eflags == 0) {
        _v232 =  *_v236 + 4;
        while(1) {
L8:
            _t175 =  *_v232 & 255;
            __eflags = _t175 & 4294967295;
            if((_t175 & 4294967295) == 0) {
                break;
            }
            _t189 =  *_v232 & 255;
            __eflags = (_t189 & 4294967295) - 40;
            if((_t189 & 4294967295) != 40) {
                goto L7;
            }
            break;
        }
L10:
        __eflags =  *_v232 & 255 & 4294967295;
        if(__eflags != 0) {
            _v232 =  &((1)[_v232]);
            _t178 = _v232;
            _v276 =  &_v196;
            _v280 =  &_v248;
            _v284 =  &_v195;
            _v288 =  &_v194;
            _v292 =  &_v193;
            _v296 = "%c%c%c%d%c";
             *__esp = _t178;
            __isoc99_sscanf();
            __eflags = _t178 - 5;
            if(__eflags != 0) {
L16:
                _t160 = -1;
                goto L33;
            }
            goto L13;
L17:
            _t183 =  &_v192;
            _v276 = 1;
            _v280 = 0;
            _v284 = 0;
            _v288 = 46;
            _v292 =  &_v62;
            _v296 = _v244;
             *__esp = _t183;
            getnameinfo();
            __eflags = _t183;
            if(__eflags == 0) {
                _v228 = openSocket( &_v62, 135066584, _v248 & 4294967295 & );
                goto L30;
            }
L18:
            _t160 = -1;
            goto L33;
        }
        _t160 = -1;
        goto L33;
L13:
        __eflags = (_v193 & 255 & 4294967295) - (_v194 & 255 & 4294967295);
        if(__eflags != 0) {
            goto L16;
        }
        __eflags = (_v193 & 255 & 4294967295) - (_v195 & 255 & 4294967295);
        if(__eflags != 0) {
            goto L16;
        }
        __eflags = (_v193 & 255 & 4294967295) - (_v196 & 255 & 4294967295);
        if(__eflags == 0) {
            goto L17;
        }
        goto L16;
    }
    _t160 = -1;
    goto L33;
L7:
    _v232 =  &((1)[_v232]);
    goto L8;
}

time_t ftp_modtime(FTP ftp, char* path)
{// addr = 0x080A30EC
    int status;
    Str tmp;
    char* p;
    struct tm tm;
    time_t t;
    time_t lt;
    time_t gt;
    intOrPtr _v16;
    struct _Str* _v20;
    signed char* _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v80;
    _unknown_ _v96;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ _v108;
    _unknown_ _v112;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ __ebp;
    _unknown_ _t59;
    _unknown_ _t60;
    _unknown_ _t65;
    _unknown_ _t66;
    _unknown_ _t67;
    _unknown_ _t71;
    _unknown_ _t74;

    _v20 = ftp_command(ftp, "MDTM", path,  &_v16);
    if(_v16 != 213) {
        return -1;
    }
    _v24 =  *_v20 + 4;
    while(( *_v24 & 255 & 4294967295) != 0 && ( *_v24 & 255 & 4294967295) == 32) {
        _v24 =  &(_v24[1]);
    }
}

int ftp_quit(FTP ftp)
{// addr = 0x080A3221
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t9;

    ftp_command(ftp, "QUIT", 0, 0);
    ftp_close(ftp);
    return 0;
}

closeFTPdata(FILE* f)
{// addr = 0x080A325C
    int status;
    int _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t9;
    _unknown_ _t11;

    if(f != 0) {
        fclose(f);
        if(current_ftp.data == f) {
            current_ftp.data = 0;
        }
    }
    ftp_command( &current_ftp, 0, 0,  &_v16);
    return;
}

closeFTP()
{// addr = 0x080A32AC
    _unknown_ __ebp;

    ftp_close( &current_ftp);
    return;
}

InputStream openFTPStream(ParsedURL* pu, URLFile* uf)
{// addr = 0x080A32C0
    Str tmp;
    int status;
    char* user;
    char* pass;
    Str uname;
    Str pwd;
    int add_auth_cookie_flag;
    char* realpathname;
    struct passwd* mypw;
    struct _Str* _v16;
    intOrPtr _v20;
    const char* _v24;
    char* _v28;
    union input_stream* _v32;
    struct _Str* _v36;
    union input_stream* _v40;
    char* _v44;
    short _v48;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    _unknown_ _t162;
    _unknown_ _t167;
    _unknown_ _t187;
    _unknown_ _t195;
    _unknown_ _t196;
    _unknown_ _t209;
    short _t215;
    char* _t216;
    int _t224;
    _unknown_ _t240;
    _unknown_ _t256;
    _unknown_ _t262;
    _unknown_ _t280;

    _v24 = 0;
    _v28 = 0;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v44 = 0;
    if(pu->host == 0) {
        return 0;
    }
    if(pu->user == 0) {
        if(pu->pass == 0) {
            if(find_auth_user_passwd(pu, 0,  &_v32,  &_v36, 0) != 0) {
                if(_v32 != 0) {
                    _v24 =  *_v32;
                }
                if(_v36 != 0) {
                    _v28 =  *_v36;
                }
            }
        }
    }
    if(_v24 == 0) {
        if(pu->user == 0) {
            _v24 = "anonymous";
        } else {
            _v24 = pu->user;
        }
    }
    if(current_ftp.host == 0) {
L20:
        if(_v28 == 0) {
L21:
            if(pu->pass == 0) {
                if(pu->user == 0) {
                    if(ftppasswd == 0 || ( *ftppasswd & 255 & 4294967295) == 0) {
                        _t215 = getuid();
                         *__esp = _t215;
                        getpwuid();
                        _v48 = _t215;
                        if(_v48 == 0) {
                            _t216 = "anonymous";
                        } else {
                            _t216 =  *_v48;
                        }
                        _v16 = Strnew_charp(_t216);
                        if(1 + _v16->length >= _v16->area_size) {
                            Strgrow(_v16);
                        }
                        _t224 = _v16->length;
                         *( *_v16 + _t224) = 64;
                        _v16->length = 1 + _t224;
                         *( *_v16 + _v16->length) = 0;
                        _v28 =  *_v16;
                    } else {
                        _v28 = ftppasswd;
                    }
                } else {
                    _v36 = 0;
                    find_auth_user_passwd(pu, 0,  &_v32,  &_v36, 0);
                    if(_v36 == 0) {
                        if((fmInitialized & 255 & 4294967295) == 0) {
                            _v36 = Strnew_charp(getpass("Password: "));
                        } else {
                            term_raw();
                            _v36 = Strnew_charp(inputLineHistSearch("Password: ", 0, 64, 0, 0));
                            _v36 = wc_Str_conv_strict(_v36, InnerCharset, SystemCharset);
                            term_cbreak();
                        }
                        _v40 = 1;
                    }
                    _v28 =  *_v36;
                }
            } else {
                _v28 = pu->pass;
            }
        }
        if(current_ftp.host == 0) {
            current_ftp.host = allocStr(pu->host, -1);
            current_ftp.port = pu->port;
            current_ftp.user = allocStr(_v24, -1);
            current_ftp.pass = allocStr(_v28, -1);
            if(ftp_login( &current_ftp) == 0) {
                return 0;
            }
        }
        if(_v40 != 0) {
            add_auth_user_passwd(pu, 0, _v32, _v36, 0);
        }
        goto L45;
    }
    if(strcmp(current_ftp.host, pu->host) != 0 || current_ftp.port != pu->port || strcmp(current_ftp.user, _v24) != 0) {
        ftp_quit( &current_ftp);
        goto L20;
    } else {
        ftp_command( &current_ftp, "NOOP", 0,  &_v20);
        if(_v20 != 200) {
            ftp_close( &current_ftp);
            goto L20;
        }
L45:
        ftp_command( &current_ftp, "TYPE", "I",  &_v20);
        if(ftp_pasv( &current_ftp) >= 0) {
            if(pu->file != 0 && (pu & 255 & 4294967295) != 0 && (pu->file[strlen(pu->file) - 1] & 255 & 4294967295) != 47) {
                _v44 = file_unquote(pu->file);
                if(( *_v44 & 255 & 4294967295) == 47 && (_v44[1] & 255 & 4294967295) == 126) {
                    _v44 =  &(_v44[1]);
                }
                 *(uf + 28) = ftp_modtime( &current_ftp, _v44);
                ftp_command( &current_ftp, "RETR", _v44,  &_v20);
                if(_v20 == 125) {
                    return newFileStream(current_ftp.data, closeFTPdata);
                }
                if(_v20 == 150) {
                    return newFileStream(current_ftp.data, closeFTPdata);
                }
            }
            pu->scheme = 3;
            return 0;
        }
        ftp_quit( &current_ftp);
        return 0;
    }
    goto L21;
}

Str loadFTPDir(ParsedURL* pu, wc_ces* charset)
{// addr = 0x080A37A6
    Str FTPDIRtmp;
    Str tmp;
    int status;
    _None sv_type;
    char* realpathname;
    char* fn;
    char* q;
    char** flist;
    int i;
    int nfile;
    int nfile_max;
    _None prevtrap;
    wc_ces doc_charset;
    char* name;
    char* link;
    char* date;
    char* size;
    char* type_str;
    int ftype;
    int max_len;
    int len;
    int j;
    struct _Str* _v16;
    struct _Str* _v20;
    intOrPtr _v24;
    int _v28;
    char* _v32;
    char* _v36;
    char* _v40;
    void* _v44;
    int _v48;
    int _v52;
    signed int _v56;
    _None* _v60;
    unsigned int _v64;
    char* _v68;
    intOrPtr _v72;
    char* _v76;
    intOrPtr _v80;
    char* _v84;
    int _v88;
    signed int _v92;
    int _v96;
    struct _Str* _v100;
    struct _Str* _v112;
    struct _Str _v124;
    char* _v128;
    char* _v132;
    signed int _v136;
    _unknown_ __ebp;
    _unknown_ _t380;
    int _t393;
    struct _Str* _t413;
    signed int _t419;
    void* _t444;
    _unknown_ _t448;
    char* _t471;
    char* _t474;
    int _t492;
    int _t505;
    _unknown_ _t517;
    int _t525;
    struct _Str* _t539;
    _unknown_ _t543;
    _unknown_ _t560;
    _unknown_ _t562;
    _unknown_ _t574;
    _unknown_ _t577;
    _unknown_ _t580;

    __esp =  &((__esp)[0xffffffffffffffe0]);
    _v60 = 0;
    _v64 = DocumentCharset;
     *charset = 256;
    if(current_ftp.data != 0) {
        _v20 = ftp_command( &current_ftp, "SYST", 0,  &_v24);
        if(strstr( *_v20, "UNIX") != 0) {
L4:
            _v28 = 1;
L6:
            if(pu->file == 0 || (pu & 255 & 4294967295) == 0) {
                if(_v28 != 1) {
                    ftp_command( &current_ftp, "NLST", 0,  &_v24);
                } else {
                    ftp_command( &current_ftp, "LIST", 0,  &_v24);
                }
                pu->file = "/";
            } else {
                _v32 = file_unquote(pu->file);
                if(( *_v32 & 255 & 4294967295) == 47 && (_v32[1] & 255 & 4294967295) == 126) {
                    _v32 =  &(_v32[1]);
                }
                if(_v28 != 1) {
                    ftp_command( &current_ftp, "NLST", _v32,  &_v24);
                } else {
                    ftp_command( &current_ftp, "CWD", _v32,  &_v24);
                    if(_v24 == 250) {
                        ftp_command( &current_ftp, "LIST", 0,  &_v24);
                    }
                }
            }
            if(_v24 == 125 || _v24 == 150) {
                _v20 = parsedURL2Str(pu);
                if(_v20->length <= 0 || ( *( *_v20 + _v20->length - 1) & 255 & 4294967295) != 47) {
                    if(_v20->length + 1 >= _v20->area_size) {
                        Strgrow(_v20);
                    }
                    _t393 = _v20->length;
                     *((char*)( *_v20 + _t393)) = 47;
                    _v20->length = _t393 + 1;
                     *( *_v20 + _v20->length) = 0;
                }
                _v36 = html_quote( *_v20);
                _v20 = convertLine(0, Strnew_charp(file_unquote( *_v20)), 0, charset, _v64);
                _v40 = html_quote( *_v20);
                _v112 = 0;
                _v124.area_size = "</h1>\n";
                _v124.length = _v40;
                _v124.ptr = "</title>\n</head>\n<body>\n<h1>Index of ";
                _v128 = _v40;
                _v132 = "">\n<title>";
                _v136 = _v36;
                _t413 = Strnew_m_charp("<html>\n<head>\n<base href="");
                _v16 = _t413;
                _v136 = 1;
                 *__esp = 135784672;
                __sigsetjmp();
                if(_t413 == 0) {
                    if((TrapSignal & 255 & 4294967295) != 0) {
                        _v60 = mySignal(2, KeyAbort);
                        if((fmInitialized & 255 & 4294967295) != 0) {
                            term_cbreak();
                        }
                    }
                    if(_v28 != 1) {
                        Strcat_charp(_v16, "<ul>\n<li>");
                    } else {
                        Strcat_charp(_v16, "<pre>\n");
                    }
                    Strcat_charp(_v16, "<a href="..">[Upper Directory]</a>\n");
                    _v56 = 100;
                    _t419 = _v56 << 2;
                     *__esp = _t419;
                    GC_malloc();
                    _v44 = _t419;
                    _v52 = 0;
                    if(_v28 != 1) {
                        while(1) {
L84:
                            current_ftp.data = Strfgets(current_ftp.data);
                            _v20 = current_ftp.data;
                            _v20 = _v20->length;
                            if(_v20->length <= 0) {
                                break;
                            }
                            __eax = _v20;
                            Strchop(_v20);
                            _v52 = _v52 << 2;
                            _v20 =  *_v20;
                            __eax = mybasename( *_v20);
                            _v44[_v52] =  *_v20;
                            _v52 = _v52 + 1;
                            __eax = _v52;
                            if(_v52 == _v56) {
                                _v56 = _v56 << 1;
                                _v56 = _v56 << 2;
                                _v136 = _v56 << 2;
                                __eax = _v44;
                                 *__esp = __eax;
                                GC_realloc();
                                _v44 = __eax;
                            }
                        }
                        __eax = _v52;
                        _v128 = strCmp;
                        _v132 = 4;
                        _v136 = _v52;
                        __eax = _v44;
                         *__esp = _v44;
                        __eax = qsort();
                        _v48 = 0;
                        while(1) {
                            __eax = _v48;
                            if(_v48 >= _v52) {
                                break;
                            }
                            _v48 = _v48 << 2;
                             &(_v44[_v48]) = _v44[_v48];
                            _v36 = _v44[_v48];
                            _v36 = Strnew_charp(_v36);
                            __eax = convertLine(0, _v36, 0, charset, _v64);
                            _v20 = _v36;
                            _v20 =  *_v20;
                            html_quote( *_v20) = _v36;
                            file_quote(_v36) = html_quote(_v36);
                            _v124.area_size = 0;
                            _v124.length = "</a>\n";
                            _v124.ptr =  *_v20;
                            _v128 = "">";
                            _v132 = _v36;
                            _v136 = "<li><a href="";
                            __eax = _v16;
                            Strcat_m_charp(_v16);
                            _v48 = _v48 + 1;
                        }
                        _v136 = "</ul>\n";
                        __eax = _v16;
                         *__esp = _v16;
                        Strcat_charp();
                        goto L89;
                    } else {
                        _v92 = 20;
                        while(1) {
                            _v20 = Strfgets(current_ftp.data);
                            if(_v20->length <= 0) {
                                break;
                            }
                            Strchop(_v20);
                            _v88 = ex_ftpdir_name_size_date( *_v20,  &_v68,  &_v72,  &_v76,  &_v80);
                            if(_v88 != 0) {
                                if(strcmp(".", _v68) != 0) {
                                    if(strcmp("..", _v68) != 0) {
                                        _v96 = strlen(_v68);
                                        if(_v96 != 0) {
                                            if(_v88 != 1) {
                                                if(_v88 != 2) {
                                                    _v84 = " ";
                                                } else {
                                                    _v96 = _v96 + 1;
                                                    _v84 = "";
                                                }
                                            } else {
                                                _v96 = _v96 + 1;
                                                _v84 = "/";
                                            }
                                            if(_v92 < _v96) {
                                                _v92 = _v96;
                                            }
                                            _v124.length = _v72;
                                            _v124.ptr = _v80;
                                            _v128 = _v76;
                                            _v132 = _v84;
                                            _v136 = _v68;
                                            _v44[_v52] =  *(Sprintf("%s%s\n%s  %5s%s"));
                                            _v52 = _v52 + 1;
                                            if(_v52 == _v56) {
                                                _v56 = _v56 << 1;
                                                _v136 = _v56 << 2;
                                                _t444 = _v44;
                                                 *__esp = _t444;
                                                GC_realloc();
                                                _v44 = _t444;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _v128 = strCmp;
                        qsort(_v44, _v52, 4);
                        _v100 = 0;
                        while(_v100 < _v52) {
                            _v36 = _v44[_v100];
                            _v76 = strchr(_v36, 10);
                            if(( *(_v76 - 1) & 255 & 4294967295) != 47) {
                                if(( *(_v76 - 1) & 255 & 4294967295) != 64) {
                                    _v88 = 3;
                                     *(_v76 - 1) = 0;
                                } else {
                                    _v88 = 2;
                                     *(_v76 - 1) = 0;
                                }
                            } else {
                                _v88 = 1;
                                 *_v76 = 0;
                            }
                            _v76 =  &(_v76[1]);
                            _v20 = convertLine(0, Strnew_charp(_v36), 0, charset, _v64);
                            if(_v88 == 2) {
                                if(_v20->length + 1 >= _v20->area_size) {
                                    Strgrow(_v20);
                                }
                                _t525 = _v20->length;
                                 *((char*)( *_v20 + _t525)) = 64;
                                _v20->length = _t525 + 1;
                                 *( *_v20 + _v20->length) = 0;
                            }
                            _t471 = html_quote( *_v20);
                            _t474 = html_quote(file_quote(_v36));
                            _v124.area_size = 0;
                            _v124.length = "</a>";
                            _v124 = _t471;
                            _v128 = "">";
                            _v132 = _t474;
                            _v136 = "<a href="";
                            Strcat_m_charp(_v16);
                            _v48 = wtf_strwidth( *_v20);
                            while(_v48 <= _v92) {
                                if(((_v92 + (_v92 >> 31 >> 31) & 1) - (_v92 >> 31 >> 31) + _v48 & 1 & 4294967295) == 0) {
                                    if(_v16->length + 1 >= _v16->area_size) {
                                        Strgrow(_v16);
                                    }
                                    _t492 = _v16->length;
                                     *((char*)( *_v16 + _t492)) = 32;
                                    _v16->length = _t492 + 1;
                                     *( *_v16 + _v16->length) = 0;
                                } else {
                                    if(_v16->length + 1 >= _v16->area_size) {
                                        Strgrow(_v16);
                                    }
                                    _t505 = _v16->length;
                                     *((char*)( *_v16 + _t505)) = 46;
                                    _v16->length = _t505 + 1;
                                     *( *_v16 + _v16->length) = 0;
                                }
                                _v48 = _v48 + 1;
                            }
                        }
                    }
                    goto L84;
                } else {
                    if(_v28 != 1) {
                        Strcat_charp(_v16, "</a></ul>\n");
                    } else {
                        Strcat_charp(_v16, "</a></pre>\n");
                    }
                    Strcat_charp(_v16, "<p>Transfer Interrupted!\n");
L89:
                    Strcat_charp(_v16, "</body>\n</html>\n");
                    if((TrapSignal & 255 & 4294967295) != 0) {
                        if((fmInitialized & 255 & 4294967295) != 0) {
                            term_raw();
                        }
                        if(_v60 != 0) {
                            mySignal(2, _v60);
                        }
                    }
                    closeFTPdata(current_ftp.data);
                    _t539 = _v16;
                    goto L95;
                }
            } else {
                fclose(current_ftp.data);
                current_ftp.data = 0;
                _t539 = 0;
            }
            goto L95;
        }
        if(strncmp( &(( *_v20)[4]), "Windows_NT", 10) != 0) {
            _v28 = 0;
            goto L6;
        }
        goto L4;
    } else {
        _t539 = 0;
    }
L95:
    __esp = __esp - 128;
    return _t539;
}

disconnectFTP()
{// addr = 0x080A41AF
    _unknown_ __ebp;

    ftp_quit( &current_ftp);
    return;
}

int ex_ftpdir_name_size_date(char* line, char** name, char** link, char** date, char** sizep)
{// addr = 0x080A41C3
    int ftype;
    char* cp;
    char* p;
    clen_t size;
    signed int _v16;
    char* _v20;
    const char* _v24;
    signed int _v32;
    signed int _v36;
    signed int _v56;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t406;
    _unknown_ _t470;
    _unknown_ _t493;
    _unknown_ _t503;
    _unknown_ _t506;
    signed int _t507;

    _v16 = 0;
    _v20 = line;
    if(strlen(_v20) <= 10) {
        return _v16;
    }
    _v20 =  &(_v20[0xa]);
    if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
        return _v16;
    }
    _v20 =  &(_v20[1]);
L4:
    while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
        if(( *_v20 & 255 & 4294967295) != 0) {
            _v20 =  &(_v20[1]);
            goto L4;
        }
        if(( *_v20 & 255 & 4294967295) == 0) {
            return _v16;
        }
        _v36 = 0;
        _v32 = 0;
L9:
        while(( *_v20 & 255 & 4294967295) != 0) {
            if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
                _t507 =  *_v20 & 255 & 4294967295;
                asm("adc edx, ebx");
                asm("adc edx, 0xff");
                _v36 = 10 * _v36 + _t507 + -48;
                _v32 = _t507 * _v32 + _v36 * _v36 + (10 * _v36 >> 32);
                _v20 =  &(_v20[1]);
                goto L9;
            }
            if(( *_v20 & 255 & 4294967295) == 0) {
                return _v16;
            }
            _v20 =  &(_v20[1]);
L14:
            while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                if(( *_v20 & 255 & 4294967295) != 0) {
                    _v20 =  &(_v20[1]);
                    goto L14;
                }
                if(( *_v20 & 255 & 4294967295) == 0) {
                    return _v16;
                }
L19:
                while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                    if(( *_v20 & 255 & 4294967295) != 0) {
                        _v20 =  &(_v20[1]);
                        goto L19;
                    }
                    if(( *_v20 & 255 & 4294967295) == 0) {
                        return _v16;
                    }
                    _v20 =  &(_v20[1]);
L24:
                    while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                        if(( *_v20 & 255 & 4294967295) != 0) {
                            _v20 =  &(_v20[1]);
                            goto L24;
                        }
                        if(( *_v20 & 255 & 4294967295) == 0) {
                            return _v16;
                        }
L29:
                        while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                            if(( *_v20 & 255 & 4294967295) != 0) {
                                _v20 =  &(_v20[1]);
                                goto L29;
                            }
                            if(( *_v20 & 255 & 4294967295) == 0) {
                                return _v16;
                            }
                            _v20 =  &(_v20[1]);
L34:
                            while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                                if(( *_v20 & 255 & 4294967295) != 0) {
                                    _v20 =  &(_v20[1]);
                                    goto L34;
                                }
                                if(( *_v20 & 255 & 4294967295) == 0) {
                                    return _v16;
                                }
                                _v24 = _v20;
                                _v36 = 0;
                                _v32 = 0;
L39:
                                while(( *_v20 & 255 & 4294967295) != 0) {
L40:
                                    if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
                                        _t507 =  *_v20 & 255 & 4294967295;
                                        asm("adc edx, ebx");
                                        asm("adc edx, 0xff");
                                        _v36 = 10 * _v36 + _t507 + -48;
                                        _v32 = _t507 * _v32 + _v36 * _v36 + (10 * _v36 >> 32);
                                        _v20 =  &(_v20[1]);
                                        goto L39;
                                    }
                                    if(( *_v20 & 255 & 4294967295) == 0) {
                                        return _v16;
                                    }
                                    if(( *_v20 & 255 & 4294967295) != 44) {
                                         *__esp = _v36;
                                        _v56 = _v32;
                                         *sizep =  *(size_int2str());
L55:
                                        _v20 =  &(_v20[1]);
                                        _v24 = _v20;
L57:
                                        while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0 && ( *_v20 & 255 & 4294967295) != 0) {
                                            goto L56;
                                        }
                                    } else {
                                        _v20 =  &(_v20[1]);
                                        while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                                            if(( *_v20 & 255 & 4294967295) != 0) {
                                                _v20 =  &(_v20[1]);
                                                continue;
                                            }
                                            if(( *_v20 & 255 & 4294967295) == 0) {
                                                return _v16;
                                            }
                                            while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                                                if(( *_v20 & 255 & 4294967295) != 0) {
                                                    _v20 =  &(_v20[1]);
                                                    continue;
                                                }
                                                if(( *_v20 & 255 & 4294967295) == 0) {
                                                    return _v16;
                                                }
                                                 *sizep = allocStr(_v24, _v20 - _v24);
                                                goto L55;
                                            }
                                        }
                                    }
L56:
                                    _v20 =  &(_v20[1]);
                                    goto L57;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Str size_int2str(clen_t size)
{// addr = 0x080A47D6
    Str size_str;
    int unit;
    double dtmp;
    char* size_format;
    char* unit_str;
    struct _Str* _v16;
    intOrPtr _v20;
    char* _v24;
    char* _v28;
    signed int _v48;
    long long int _v52;
    intOrPtr _v64;
    _unknown_ __ebp;
    signed int _t30;
    intOrPtr _t31;

    _v52 = size;
    _t30 = _a8;
    _v48 = _t30;
    asm("fild qword [ebp-0x30]");
    asm("fstp qword [ebp-0x20]");
    _v20 = 0;
    while(_v20 <= 2) {
        asm("fld qword [ebp-0x20]");
        asm("fld qword [0x80cf5a0]");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t30 & 4294967295) == 0) {
            asm("fld qword [ebp-0x20]");
            asm("fld qword [0x80cf5a0]");
            asm("fdivp st1, st0");
            asm("fstp qword [ebp-0x20]");
            _v20 = _v20 + 1;
            continue;
        }
        if(_v20 == 0) {
L8:
            _v24 = "%.0f%s";
L12:
            _t31 = _v20;
            if(_t31 == 2) {
                _v28 = "M";
            } else {
                if(_t31 == 3) {
                    _v28 = "G";
                } else {
                    if(_t31 == 1) {
                        _v28 = "K";
                    } else {
                        _v28 = 135066584;
                    }
                }
            }
            _v64 = _v28;
            asm("fld qword [ebp-0x20]");
            asm("fstp qword [esp+0x4]");
            _v16 = Sprintf(_v24);
            return _v16;
        }
        asm("fld qword [ebp-0x20]");
        asm("fld qword [0x80cf5a8]");
        asm("fxch st0, st1");
        asm("fucomip st0, st1");
        asm("fstp st0");
        if((_t30 & 4294967295) == 0) {
            asm("fld qword [ebp-0x20]");
            asm("fld qword [0x80cf5b0]");
            asm("fxch st0, st1");
            asm("fucomip st0, st1");
            asm("fstp st0");
            if((_t30 & 4294967295) == 0) {
                _v24 = "%.2f%s";
            } else {
                _v24 = "%.1f%s";
            }
            goto L12;
        }
        goto L8;
    }
}

unsigned char c2e(char x)
{// addr = 0x080A48C8
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t16;
    _unknown_ _t17;
    _unknown_ _t18;

    _v8 = x & 4294967295;
    if(_v8 > 64) {
        if(_v8 > 90) {
            goto L3;
        } else {
            return (_v8 & 255) - 65;
        }
    }
L3:
    if(_v8 > 96) {
        if(_v8 <= 122) {
            return (_v8 & 255) - 71;
        }
    }
    if(_v8 > 47) {
        if(_v8 <= 57) {
            return (_v8 & 255) + 4;
        }
    }
    if(_v8 == 43) {
        return 62;
    }
    if(_v8 != 47) {
        return -1;
    }
    return 63;
}

int ha2d(char x, char y)
{// addr = 0x080A4934
    int r;
    int _v8;
    signed int _v24;
    signed int _v28;
    _unknown_ __ebp;

    _v24 = x & 4294967295;
    _v28 = y & 4294967295;
    _v8 = 0;
    if(_v24 <= 47) {
L3:
        if(_v24 <= 64) {
L6:
            if(_v24 > 96 && _v24 <= 102) {
                _v8 = _v24 - 87;
            }
            goto L9;
        }
        goto L4;
    }
    if(_v24 > 57) {
        goto L3;
    } else {
        _v8 = _v24 - 48;
L9:
        _v8 = _v8 << 4;
        if(_v28 <= 47 || _v28 > 57) {
            if(_v28 <= 64 || _v28 > 70) {
                if(_v28 <= 96) {
                    return _v8;
                }
                if(_v28 > 102) {
                    return _v8;
                }
                _v8 = _v8 + _v28 - 87;
                return _v8;
            }
            _v8 = _v8 + _v28 - 55;
            return _v8;
        }
        _v8 = _v8 + _v28 - 48;
        return _v8;
    }
L4:
    if(_v24 > 70) {
        goto L6;
    } else {
        _v8 = _v24 - 55;
    }
    goto L9;
}

Str decodeB(char** ww)
{// addr = 0x080A49E2
    unsigned char[3] c;
    char* wp;
    char[2] d;
    int i;
    int n_pad;
    Str ap;
    _unknown_ _v13;
    _unknown_ _v14;
    _unknown_ _v15;
    signed int _v16;
    signed int _v17;
    _unknown_ _v18;
    _unknown_ _v19;
    char* _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    struct _Str* _v36;
    _unknown_ __ebp;
    _unknown_ _t141;
    _unknown_ _t149;

    _v24 =  *ww;
    _v36 = Strnew_size(strlen(_v24));
    _v32 = 0;
    goto L2;
    do {
L2:
        _v28 = 0;
        while(_v28 <= 3) {
             *(__ebp + _v28 - 15) =  *_v24 & 255 & 4294967295;
            _v24 =  &(_v24[1]);
            if(( *_v24 & 255 & 4294967295) == 0 || ( *_v24 & 255 & 4294967295) == 63) {
                _v28 = _v28 + 1;
                while(_v28 <= 3) {
                }
            } else {
                _v28 = _v28 + 1;
                continue;
            }
            if((_v16 & 255 & 4294967295) == 61) {
                _v32 = _v32 + 1;
                _v16 = 65;
                if((_v17 & 255 & 4294967295) == 61) {
                    _v32 = _v32 + 1;
                    _v17 = 65;
                }
            }
            _v28 = 0;
            while(_v28 <= 3) {
                 *(__ebp + _v28 - 15) = c2e( *(__ebp + _v28 - 15) & 255 & 4294967295) & 4294967295;
                if(( *(__ebp + _v28 - 15) & 255 & 4294967295) != 255) {
                    _v28 = _v28 + 1;
                    continue;
                }
                 *ww = _v24;
                return _v36;
            }
        }
    } while(_v32 == 0 && ( *_v24 & 255 & 4294967295) != 0 && ( *_v24 & 255 & 4294967295) != 63);
     *ww = _v24;
    return _v36;
}

Str decodeU(char** ww)
{// addr = 0x080A4BAB
    unsigned char c1;
    unsigned char c2;
    char* w;
    int n;
    int i;
    Str a;
    signed char _v29;
    signed char _v30;
    char* _v36;
    int _v40;
    signed int _v44;
    struct _Str* _v48;
    signed int _v64;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    int _t102;
    _unknown_ _t125;

    _v36 =  *ww;
    if(( *_v36 & 255 & 4294967295) <= 32) {
        return Strnew_size(0);
    }
    if(( *_v36 & 255 & 4294967295) > 95) {
        return Strnew_size(0);
    }
    _v40 = ( *_v36 & 255 & 4294967295) - 32;
    _v48 = Strnew_size(_v40);
    _v36 =  &(_v36[1]);
    _v44 = 2;
    while(( *_v36 & 255 & 4294967295) != 0) {
        if(_v40 == 0) {
            return _v48;
        }
        _v29 = (( *_v36 & 255 & 4294967295) - 32 + (( *_v36 & 255 & 4294967295) - 32 >> 31 >> 26) & 63) - (( *_v36 & 255 & 4294967295) - 32 >> 31 >> 26) & 4294967295;
        _v30 = ((_v36[1] & 255 & 4294967295) - 32 + ((_v36[1] & 255 & 4294967295) - 32 >> 31 >> 26) & 63) - ((_v36[1] & 255 & 4294967295) - 32 >> 31 >> 26) & 4294967295;
        if(_v48->length + 1 >= _v48->area_size) {
            Strgrow(_v48);
        }
        _t102 = _v48->length;
        _v64 = _v30 & 255;
         *( *_v48 + _t102) = (_v64 >> (6 - _v44 & 4294967295) | (_v29 & 255) << (_v44 & 4294967295)) & 4294967295;
        _v48->length = _t102 + 1;
         *( *_v48 + _v48->length) = 0;
        if(_v44 != 6) {
            _v36 =  &(_v36[1]);
            _v44 = _v44 + 2;
        } else {
            _v36 =  &(_v36[2]);
            _v44 = 2;
        }
        _v40 = _v40 - 1;
    }
}

Str decodeQ(char** ww)
{// addr = 0x080A4D08
    char* w;
    Str a;
    char* _v16;
    struct _Str* _v20;
    _unknown_ _v40;
    int __ebx;
    _unknown_ __ebp;
    int _t101;
    int _t114;

    _v16 =  *ww;
    _v20 = Strnew_size(strlen(_v16));
    while(( *_v16 & 255 & 4294967295) != 0 && ( *_v16 & 255 & 4294967295) != 63) {
        if(( *_v16 & 255 & 4294967295) != 61) {
            if(( *_v16 & 255 & 4294967295) != 95) {
                if(_v20->length + 1 >= _v20->area_size) {
                    Strgrow(_v20);
                }
                _t101 = _v20->length;
                 *( *_v20 + _t101) =  *_v16 & 255 & 4294967295;
                _v20->length = _t101 + 1;
                 *((char*)( *_v20 + _v20->length)) = 0;
            } else {
                if(_v20->length + 1 >= _v20->area_size) {
                    Strgrow(_v20);
                }
                _t114 = _v20->length;
                 *((char*)( *_v20 + _t114)) = 32;
                _v20->length = _t114 + 1;
                 *((char*)( *_v20 + _v20->length)) = 0;
            }
            goto L12;
        }
        _v16 =  &(_v16[1]);
        if(_v20->length + 1 >= _v20->area_size) {
            Strgrow(_v20);
        }
        __ebx = _v20->length;
         *( *_v20 + __ebx) = ha2d( *_v16 & 255 & 4294967295, _v16[1] & 255 & 4294967295) & 4294967295;
        _v20->length = __ebx + 1;
         *((char*)( *_v20 + _v20->length)) = 0;
        _v16 =  &(_v16[1]);
L12:
        _v16 =  &(_v16[1]);
    }
}

Str decodeQP(char** ww)
{// addr = 0x080A4E89
    char* w;
    Str a;
    char* _v16;
    struct _Str* _v20;
    _unknown_ _v40;
    int __ebx;
    _unknown_ __ebp;
    int _t94;

    _v16 =  *ww;
    _v20 = Strnew_size(strlen(_v16));
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *_v16 & 255 & 4294967295) != 61) {
            if(_v20->length + 1 >= _v20->area_size) {
                Strgrow(_v20);
            }
            _t94 = _v20->length;
             *( *_v20 + _t94) =  *_v16 & 255 & 4294967295;
            _v20->length = _t94 + 1;
             *((char*)( *_v20 + _v20->length)) = 0;
            goto L24;
        }
        _v16 =  &(_v16[1]);
        if(( *_v16 & 255 & 4294967295) == 10) {
            goto L11;
        }
        if(( *_v16 & 255 & 4294967295) == 13) {
            goto L9;
        }
        if(( *_v16 & 255 & 4294967295) == 32) {
            goto L10;
        }
        if(( *_v16 & 255 & 4294967295) != 9) {
            if(( *_v16 & 255 & 4294967295) == 0 || (_v16[1] & 255 & 4294967295) == 0) {
                 *ww = _v16;
                return _v20;
            } else {
                if(_v20->length + 1 >= _v20->area_size) {
                    Strgrow(_v20);
                }
                __ebx = _v20->length;
                 *( *_v20 + __ebx) = ha2d( *_v16 & 255 & 4294967295, _v16[1] & 255 & 4294967295) & 4294967295;
                _v20->length = __ebx + 1;
                 *((char*)( *_v20 + _v20->length)) = 0;
                _v16 =  &(_v16[1]);
L24:
                _v16 =  &(_v16[1]);
                continue;
            }
        } else {
        }
L11:
        while(( *_v16 & 255 & 4294967295) != 10 && ( *_v16 & 255 & 4294967295) != 0) {
            _v16 =  &(_v16[1]);
        }
        goto L11;
L10:
        goto L11;
L9:
        goto L11;
    }
}

Str decodeWord(char** ow, wc_ces* charset)
{// addr = 0x080A502A
    wc_ces c;
    char* p;
    char* w;
    char method;
    Str a;
    Str tmp;
    _unknown_ _v13;
    _unknown_ _v20;
    _unknown_ _v24;
    char* _v28;
    struct _Str* _v32;
    struct _Str* _v36;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t99;
    _unknown_ _t113;
    _unknown_ _t125;

    _v28 =  *ow;
    _v32 = Strnew();
    _v36 = Strnew();
    if(( *_v28 & 255 & 4294967295) != 61) {
        return Strnew();
    }
    if((_v28[1] & 255 & 4294967295) != 63) {
        return Strnew();
    }
    _v28 =  &(_v28[2]);
    while(( *_v28 & 255 & 4294967295) != 63) {
    }
}

Str decodeMIME(Str orgstr, wc_ces* charset)
{// addr = 0x080A51E0
    char* org;
    char* endp;
    char* org0;
    char* p;
    Str cnv;
    char* _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    struct _Str* _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    int _t90;
    signed int _t109;

    _v16 = orgstr->ptr;
    _v20 =  &(_v16[orgstr->length]);
    _v32 = 0;
     *charset = 0;
    while(_v16 < _v20) {
        if(( *_v16 & 255 & 4294967295) != 61 || (_v16[1] & 255 & 4294967295) != 63) {
            if(_v32 != 0) {
                if(_v32->length + 1 >= _v32->area_size) {
                    Strgrow(_v32);
                }
                _t90 = _v32->length;
                 *( *_v32 + _t90) =  *_v16 & 255 & 4294967295;
                _v32->length = _t90 + 1;
                 *( *_v32 + _v32->length) = 0;
            }
            _v16 =  &(_v16[1]);
            continue;
        } else {
            if(_v32 == 0) {
                _v32 = Strnew_size(orgstr->length);
                Strcat_charp_n(_v32, orgstr->ptr, _v16 - orgstr->ptr);
            }
            while(1) {
                _v28 = _v16;
                Strcat(_v32, decodeWord( &_v16, charset));
                if(_v16 == _v28) {
                    break;
                }
                _v24 = _v16;
                while(1) {
                    _t109 =  *_v24 & 255 & 4294967295;
                    if(_t109 == 13) {
                        goto L15;
                    } else {
                        goto L9;
                    }
                }
            }
            Strcat_charp(_v32, _v16);
            return _v32;
        }
    }
}

Str encodeB(char* a)
{// addr = 0x080A5389
    unsigned char[2] d;
    unsigned char c1;
    unsigned char c2;
    unsigned char c3;
    unsigned char c4;
    int i;
    int n_pad;
    Str w;
    signed char _v13;
    signed char _v14;
    signed char _v15;
    signed int _v16;
    signed int _v17;
    signed int _v18;
    signed int _v19;
    signed char _v24;
    signed char _v28;
    struct _Str* _v32;
    _unknown_ __ebp;
    _unknown_ _t137;
    int _t168;
    int _t180;
    int _t192;
    int _t204;
    _unknown_ _t219;

    _v32 = Strnew();
L1:
    while(( *a & 255 & 4294967295) != 0) {
        _v28 = 0;
        _v17 = 0;
        _v18 = _v17 & 255 & 4294967295;
        _v24 = 0;
        while(_v24 <= 2) {
             *(__ebp + _v24 - 15) = a[_v24] & 255 & 4294967295;
            if((a[_v24] & 255 & 4294967295) != 0) {
                _v24 = _v24 + 1;
                continue;
            }
            _v28 = 3 - _v24;
            _v13 = _v19 & 255 & 4294967295;
            _v14 = (_v18 & 255 | (_v19 & 255 & 4294967295 & ) << 4) & 63 & 4294967295;
            if(_v28 != 2) {
                if(_v28 != 1) {
                    _v15 = (_v17 & 255 | (_v18 & 255 & 4294967295 & ) << 2) & 63 & 4294967295;
                    _v16 = _v17 & 255 & 63 & 4294967295;
                } else {
                    _v15 = (_v18 & 255 & 4294967295 & ) << 2 & 63 & 4294967295;
                    _v16 = 64;
                }
            } else {
                _v16 = 64;
                _v15 = _v16 & 255 & 4294967295;
            }
            if(_v32->length + 1 >= _v32->area_size) {
                Strgrow(_v32);
            }
            _t168 = _v32->length;
             *( *_v32 + _t168) =  *((_v13 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 255 & 4294967295;
            _v32->length = _t168 + 1;
             *( *_v32 + _v32->length) = 0;
            if(_v32->length + 1 >= _v32->area_size) {
                Strgrow(_v32);
            }
            _t180 = _v32->length;
             *( *_v32 + _t180) =  *((_v14 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 255 & 4294967295;
            _v32->length = _t180 + 1;
             *( *_v32 + _v32->length) = 0;
            if(_v32->length + 1 >= _v32->area_size) {
                Strgrow(_v32);
            }
            _t192 = _v32->length;
             *( *_v32 + _t192) =  *((_v15 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 255 & 4294967295;
            _v32->length = _t192 + 1;
             *( *_v32 + _v32->length) = 0;
            if(_v32->length + 1 >= _v32->area_size) {
                Strgrow(_v32);
            }
            _t204 = _v32->length;
             *( *_v32 + _t204) =  *((_v16 & 255) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=") & 255 & 4294967295;
            _v32->length = _t204 + 1;
             *( *_v32 + _v32->length) = 0;
            if(_v28 != 0) {
                return _v32;
            }
            a =  &(a[3]);
            goto L1;
        }
    }
}

longchar set_longchar(char* str)
{// addr = 0x080A55D8
    unsigned char* p;
    longchar r;
    _unknown_ _v8;
    char _v16;
    signed int _v20;
    signed int _v24;
    signed int _v28;
    char _v32;
    signed int _v48;
    intOrPtr _v52;
    char* _v72;
    _unknown_ __ebp;
    struct  _t87;
    _unknown_ _t88;

    _push(__ebx);
    __esp = __esp - 68;
    _t87 = str;
    _v16 = _a8;
    if(( *_v16 & 255 & 4294967295) >= 0) {
        _v20 =  *_v16 & 255 & 4294967295;
        _v32 = 1;
         *_t87 = _v32;
         *(_t87 + 4) = _v28;
         *(_t87 + 8) = _v24;
         *(_t87 + 12) = _v20;
        return _t87;
    }
    _v72 =  &_v16;
    wtf_parse1( &_v52);
    __esp = __esp - 4;
    _v28 = _v52;
    _v24 = _v48;
    if(_v28 == 2048 || _v28 == 34816) {
        _v32 = 4;
         *_t87 = _v32;
         *(_t87 + 4) = _v28;
         *(_t87 + 8) = _v24;
         *(_t87 + 12) = _v20;
        return _t87;
    }
    if((_v28 & 65535) == 4096 || (_v28 & 65535) == 8192 || (_v28 & 65535) == 8193) {
        if((_v28 & 65535) == 8193) {
            _v24 = _v24 & 2097151;
        }
        _v28 = 8192;
    } else {
        _v28 = _v28 & 65535;
    }
    _v32 = 2;
     *_t87 = _v32;
     *(_t87 + 4) = _v28;
     *(_t87 + 8) = _v24;
     *(_t87 + 12) = _v20;
    return _t87;
}

char* regexCompile(char* ex, int igncase)
{// addr = 0x080A56F0
    char* msg;
    intOrPtr _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t11;

    newRegex(ex, igncase,  &DefaultRegex,  &_v16);
    return _v16;
}

Regex* newRegex0(char** ex, int igncase, Regex* regex, char** msg, int level)
{// addr = 0x080A571C
    char* p;
    longchar* r;
    regexchar* re;
    int m;
    longchar* st_ptr;
    _unknown_ _v8;
    char* _v16;
    Regex* _v24;
    struct regex _v32;
    intOrPtr _v48;
    intOrPtr _v52;
    intOrPtr _v56;
    intOrPtr _v60;
    char* _v88;
    _unknown_ __ebp;
    Regex* _t73;
    Regex* _t106;
    _unknown_ _t115;
    struct regex _t123;
    _unknown_ _t124;

    _t73 = __eax;
    _push(__ebx);
    __esp = __esp - 84;
    if(regex == 0) {
         *__esp = 4620;
        GC_malloc();
        regex = _t73;
    }
    regex->alt_regex = 0;
    _v24 = regex;
    _v32.re = regex + 512;
    _v16 =  *ex;
    while(( *_v16 & 255 & 4294967295) != 0) {
         *(_v24 + 4) = 0;
        if(( *_v16 & 255 & 4294967295) - 36 > 88) {
            _t123 = _v32.re;
            _v88 = _v16;
            __eax = set_longchar( &_v60);
            __esp = __esp - 4;
             *_t123 = _v60;
             *((intOrPtr*)(_t123 + 4)) = _v56;
             *((intOrPtr*)(_t123 + 8)) = _v52;
             *((intOrPtr*)(_t123 + 12)) = _v48;
            _v16 =  &(_v16[( *( &WTF_LEN_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 & ) - 1]);
             *_v24 = _v32.re;
            _v32.re = _v32.re + 16;
             *(_v24 + 4) =  *(_v24 + 4) & 255 & 248 & 4294967295;
            if(igncase != 0) {
                 *(_v24 + 4) = ( *(_v24 + 4) & 255 | 64) & 4294967295;
            }
            _v24 = _v24 + 8;
            if(regex + 512 + 4096 <= _v32 || regex + 512 <= _v24) {
                if(msg != 0) {
                     *msg = "Regular expression too long";
                }
                _t106 = 0;
                return _t106;
            } else {
                _v16 =  &(_v16[1]);
                continue;
            }
        }
        goto __eax;
    }
}

Regex* newRegex(char* ex, int igncase, Regex* regex, char** msg)
{// addr = 0x080A5D6B
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    return newRegex0( &ex, igncase, regex, msg, 0);
}

int regexMatch(char* str, int len, int firstp)
{// addr = 0x080A5D9B
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return RegexMatch( &DefaultRegex, str, len, firstp);
}

int RegexMatch(Regex* re, char* str, int len, int firstp)
{// addr = 0x080A5DC4
    char* p;
    char* ep;
    char* lpos;
    Regex* r;
    char* _v16;
    char* _v20;
    intOrPtr _v24;
    regexchar* _v28;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    int _t64;
    int _t67;
    _unknown_ _t69;
    _unknown_ _t81;
    _unknown_ _t88;
    _unknown_ _t91;

    if(str == 0) {
        return 0;
    }
    if(len < 0) {
        len = strlen(str);
    }
    re->position = 0;
    _v20 =  &(str[len]);
    _v16 = str;
    while(_v16 <= _v20) {
        while(_v28 != 0) {
            if(firstp == 0 || _v16 != str) {
                _t64 = 0;
            } else {
                _t64 = 1;
            }
            _t67 = regmatch(_v28, _v16, _v20, _t64,  &_v24);
            if(_t67 == 255) {
                re->position = 0;
                return -1;
            } else {
                if(_t67 == 1) {
                    re->position = _v16;
                    if(re->lposition == 0 || re->lposition < _v24) {
                        re->lposition = _v24;
                    }
                }
                _v28 =  *(_v28 + 4616);
                continue;
            }
        }
    }
}

MatchedPosition(Regex* re, char** first, char** last)
{// addr = 0x080A5F1C
    _unknown_ __ebp;

     *first = re->position;
     *last = re->lposition;
    return;
}

matchedPosition(char** first, char** last)
{// addr = 0x080A5F3D
    _unknown_ __ebp;

     *first =  *135789440;
     *last =  *135789444;
    return;
}

int regmatch_sub_anytime(struct MatchingContext2* c, Regex* regex, regexchar* pat2, char* str, char* end_p, int iter_limit, int firstp)
{// addr = 0x080A5F58
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    struct MatchingContext1* _t108;
    struct MatchingContext2* _t109;
    _unknown_ _t159;
    _unknown_ _t161;
    _unknown_ _t167;
    _unknown_ _t174;

    _t108 = c->label;
    if(_t108 == 2) {
        goto L12;
    }
    if(_t108 == 3) {
        goto L16;
    }
    if(_t108 != 1) {
         *__esp = 44;
        GC_malloc();
        _t109 = c;
        _t109->ctx = _t108;
         *__esp = 32;
        GC_malloc();
        c->ctx2 = _t109;
        c->ctx->label = 0;
        c->regex = regex;
        c->n_any = 0;
        c->str = str;
        c->firstp = firstp;
        goto L5;
    }
    goto L12;
L5:
    c->ctx->label = 0;
L20:
    while(regmatch_iter(c->ctx, c->regex, c->str, end_p, c->firstp) != 0) {
        c->n_any = c->ctx->lastpos - c->str;
        if(c->n_any <= 0) {
            continue;
        }
        c->firstp = 0;
        if((pat2->mode & 255 & 4294967295 &  & 7) != 7) {
            if(regmatch(pat2,  &(c->str[c->n_any]), end_p, c->firstp,  &(c->lastpos)) != 1) {
                goto L12;
            }
            goto L10;
L13:
            c->ctx2->label = 0;
            break;
        }
        c->lastpos =  &(c->str[c->n_any]);
        c->label = 1;
        return 1;
L10:
        c->label = 2;
        return 1;
    }
L16:
    if(regmatch_sub_anytime(c->ctx2, regex, pat2,  &(c->str[c->n_any]), end_p, iter_limit - 1, c->firstp) != 0) {
        c->lastpos = c->ctx2->lastpos;
        c->label = 3;
        return 1;
    }
    goto L20;
L12:
    if(iter_limit == 1) {
        goto L20;
    }
    goto L13;
}

int regmatch_iter(struct MatchingContext1* c, regexchar* re, char* str, char* end_p, int firstp)
{// addr = 0x080A61A6
    longchar k;
    longchar k;
    char _v16;
    intOrPtr _v36;
    struct  _v44;
    intOrPtr _v48;
    intOrPtr _v52;
    intOrPtr _v56;
    char _v60;
    char* _v64;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ _v92;
    _unknown_ _v96;
    _unknown_ _v100;
    char* _v104;
    _unknown_ _v108;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t324;
    int _t333;
    struct MatchingContext1* _t345;
    struct MatchingContext2* _t451;
    _unknown_ _t505;

    __esp = __esp - 92;
    if(c->label <= 7) {
        goto __eax;
    }
    if((re->mode & 255 & 4294967295 &  & 7) != 7) {
        c->re = re;
        c->firstp = firstp;
        c->str = str;
        c->end_p = end_p;
        c->sub_ctx = 0;
        c->lastpos = 0;
        while((c->re->mode & 255 & 4294967295 &  & 7) != 7) {
            if((c->re->mode & 255 & 4294967295 &  & 24) == 0) {
                _t324 = c->re->mode & 255 & 4294967295 &  & 7;
                if(_t324 == 5) {
                    if(c->firstp != 0) {
                        c->re = c->re + 8;
                        goto L55;
                    }
                    _t333 = 0;
                } else {
                    if(_t324 == 6) {
                        if(c->str < c->end_p) {
                            c->lastpos = 0;
                            _t333 = 0;
                        } else {
                            c->lastpos = c->str;
                            c->re = c->re + 8;
                            c->label = 4;
                            _t333 = 1;
                        }
                    } else {
                        if(_t324 == 4) {
                            _t345 = c->sub_ctx;
                            if(_t345 == 0) {
                                 *__esp = 44;
                                GC_malloc();
                                c->sub_ctx = _t345;
                            }
                            c->sub_regex = c->re->p;
                            while(1) {
                                c->sub_ctx->label = 0;
                                goto L48;
                            }
                        }
                        _v104 = c->str;
                        __eax = set_longchar( &_v60);
                        __esp = __esp - 4;
                        _v44.type = _v60;
                        _v44.wch = _v56;
                        _v36 = _v52;
                        _v44.ch = _v48;
                        c->str =  &(c->str[ *( &WTF_LEN_MAP + (c & 255 & 4294967295 & )) & 255 & 4294967295 & ]);
                        if(regmatch1(c->re,  &_v44) != 0) {
                            c->re = c->re + 8;
                            c->firstp = 0;
L55:
                            if(c->str <= c->end_p) {
                                continue;
                            } else {
                                _t333 = 0;
                            }
                            goto L59;
                        }
                        _t333 = 0;
                    }
                }
            } else {
                if((c->re->mode & 255 & 4294967295 &  & 16) == 0) {
                    c->iter_limit = 1;
                } else {
                    c->iter_limit = 65535;
                }
                c->n_any = -1;
                while(c->n_any < c->iter_limit) {
                    if( &(c->str[c->n_any]) < c->end_p) {
                        if(c->n_any >= 0) {
                            c->n_any =  &(c->n_any->p);
L22:
                            if((c->re + 8->mode & 255 & 4294967295 &  & 7) != 7) {
                                if(regmatch(c->re + 8,  &(c->str[c->n_any]), c->end_p, c->firstp,  &(c->lastpos)) != 1) {
                                    continue;
                                } else {
                                    c->label = 3;
                                    _t333 = 1;
                                }
                            } else {
                                c->lastpos =  &(c->str[c->n_any]);
                                c->label = 2;
                                _t333 = 1;
                            }
                            goto L59;
                        }
                        _t451 = c->re->mode & 255 & 4294967295 &  & 7;
                        if(_t451 != 4) {
                            _v104 =  &(c->str[c->n_any]);
                            __eax = set_longchar( &_v60);
                            __esp = __esp - 4;
                            _v44 = _v60;
                            _v44.wch = _v56;
                            _v36 = _v52;
                            _v44.ch = _v48;
                            if(regmatch1(c->re,  &_v44) == 0) {
                                _t333 = 0;
                            } else {
                                c->n_any = c->n_any + ( *( &WTF_LEN_MAP + (c->str[c->n_any] & 255 & 4294967295 & )) & 255 & 4294967295 & );
                                c->firstp = 0;
                                goto L22;
                            }
                        } else {
                             *__esp = 32;
                            GC_malloc();
                            c->ctx2 = _t451;
                            c->ctx2->label = 0;
                            _v64 =  &(c->str[c->n_any]);
                            if(regmatch_sub_anytime(c->ctx2, c->re->p, c->re + 8, _v64, c->end_p, c->iter_limit, c->firstp) != 0) {
                                c->n_any = c->ctx2->lastpos - c->str;
                                c->lastpos = c->ctx2->lastpos;
                                c->label = 1;
                                _t333 = 1;
                            } else {
                                _t333 = 0;
                            }
                        }
                    } else {
                        _t333 = 0;
                    }
                    goto L59;
                }
            }
            goto L59;
        }
    }
    _t333 = 0;
L59:
     &_v16 =  &_v16;
    return _t333;
}

int regmatch(regexchar* re, char* str, char* end_p, int firstp, char** lastpos)
{// addr = 0x080A67D2
    struct MatchingContext1 contx;
    _unknown_ _v48;
    struct MatchingContext1 _v56;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    _unknown_ _t32;
    _unknown_ _t33;

     *lastpos = 0;
    _v56 = 0;
    while(regmatch_iter( &_v56, re, str, end_p, firstp) != 0) {
    }
}

int regmatch1(regexchar* re, longchar* c)
{// addr = 0x080A6849
    int ans;
    int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    signed int _t36;
    _unknown_ _t37;
    _unknown_ _t51;
    _unknown_ _t59;

    if((c->type & 255 & 4294967295) == 4) {
        return 0;
    }
    _t36 = re->mode & 255 & 4294967295 &  & 7;
    if(_t36 == 1) {
        return 1;
    }
    if(_t36 > 1) {
        if(_t36 == 2) {
            return matchWhich(re->p, c, re->mode & 255 & 4294967295 &  & 64);
        }
        if(_t36 == 3) {
            return matchWhich(re->p, c, re->mode & 255 & 4294967295 &  & 64) & 4294967295 & ;
        }
        return 0;
    } else {
        if(_t36 != 0) {
            return 0;
        }
        _v16 = match_longchar(re->p, c, re->mode & 255 & 4294967295 &  & 64);
        return _v16;
    }
}

int matchWhich(longchar* pattern, longchar* c, int igncase)
{// addr = 0x080A692C
    longchar* p;
    int ans;
    longchar* _v16;
    intOrPtr _v20;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = pattern;
    _v20 = 0;
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *(_v16 + 16) & 255 & 4294967295) != 3 || ( *(_v16 + 32) & 255 & 4294967295) == 0) {
            if(match_longchar(_v16, c, igncase) == 0) {
                _v16 = _v16 + 16;
                continue;
            }
        } else {
            if(match_range_longchar(_v16, _v16 + 32, c, igncase) != 0) {
                _v20 = 1;
                return _v20;
            }
            _v16 = _v16 + 48;
            continue;
        }
L7:
        _v20 = 1;
        return _v20;
    }
}

int match_longchar(longchar* a, longchar* b, int ignore)
{// addr = 0x080A69CE
    _unknown_ __ebp;
    _unknown_ _t62;
    signed int _t82;
    int _t83;
    signed int _t94;
    int _t104;
    _unknown_ _t108;
    _unknown_ _t110;
    signed int _t111;
    signed int _t112;

    if((a->type & 255 & 4294967295) != (b->type & 255 & 4294967295)) {
        return 0;
    }
    if((a->type & 255 & 4294967295) != 2) {
        if(ignore == 0) {
            return b->ch & 255 & 4294967295 & ;
        }
        if(( *( &MYCTYPE_MAP + (b->ch & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            return b->ch & 255 & 4294967295 & ;
        }
        _t111 = a->ch & 255 & 4294967295 & ;
        if(( *( &MYCTYPE_MAP + (b->ch & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            _t82 = b->ch & 255 & 4294967295 & ;
        } else {
            _t82 = (b->ch & 255 | 32) & 4294967295 & ;
        }
        if(_t111 == _t82) {
L18:
            _t83 = 1;
            return _t83;
        } else {
            _t112 = a->ch & 255 & 4294967295 & ;
            if(( *( &MYCTYPE_MAP + (b->ch & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                _t94 = b->ch & 255 & 4294967295 & ;
            } else {
                _t94 = b->ch & 255 & 4294967295 &  & 223;
            }
            if(_t112 != _t94) {
                goto L19;
            }
            goto L18;
        }
L19:
        _t83 = 0;
        return _t83;
    } else {
        if( *((intOrPtr*)(a + 4)) !=  *((intOrPtr*)(b + 4)) ||  *((intOrPtr*)(a + 8)) !=  *((intOrPtr*)(b + 8))) {
            _t104 = 0;
            return _t104;
        }
        _t104 = 1;
        return _t104;
    }
}

int match_range_longchar(longchar* a, longchar* b, longchar* c, int ignore)
{// addr = 0x080A6AF9
    _unknown_ __ebp;
    _unknown_ _t104;
    _unknown_ _t113;
    _unknown_ _t117;
    signed int _t134;
    signed int _t145;
    int _t146;
    signed int _t155;
    signed int _t170;
    int _t180;
    signed int _t194;
    signed int _t195;

    if((a->type & 255 & 4294967295) != (b->type & 255 & 4294967295)) {
        return 0;
    }
    if((a->type & 255 & 4294967295) != (c->type & 255 & 4294967295)) {
        return 0;
    }
    if((a->type & 255 & 4294967295) != 2) {
        if(ignore == 0 || ( *( &MYCTYPE_MAP + (c->ch & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            if((a->ch & 255 & 4294967295) > (c->ch & 255 & 4294967295)) {
                return 0;
            }
            if((c->ch & 255 & 4294967295) > (b->ch & 255 & 4294967295)) {
                return 0;
            }
            return 1;
        } else {
            _t194 = a->ch & 255 & 4294967295 & ;
            if(( *( &MYCTYPE_MAP + (c->ch & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                _t134 = c->ch & 255 & 4294967295 & ;
            } else {
                _t134 = (c->ch & 255 | 32) & 4294967295 & ;
            }
            if(_t194 > _t134) {
L21:
                _t195 = a->ch & 255 & 4294967295 & ;
                if(( *( &MYCTYPE_MAP + (c->ch & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                    _t145 = c->ch & 255 & 4294967295 & ;
                } else {
                    _t145 = c->ch & 255 & 4294967295 &  & 223;
                }
                if(_t195 > _t145) {
                    goto L30;
                } else {
                    if(( *( &MYCTYPE_MAP + (c->ch & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                        _t155 = c->ch & 255 & 4294967295 & ;
                    } else {
                        _t155 = c->ch & 255 & 4294967295 &  & 223;
                    }
                    if(_t155 > (b->ch & 255 & 4294967295 & )) {
                        goto L30;
                    }
                    goto L29;
                }
            } else {
                if(( *( &MYCTYPE_MAP + (c->ch & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                    _t170 = c->ch & 255 & 4294967295 & ;
                } else {
                    _t170 = (c->ch & 255 | 32) & 4294967295 & ;
                }
                if(_t170 <= (b->ch & 255 & 4294967295 & )) {
L29:
                    _t146 = 1;
                    return _t146;
                } else {
                    goto L21;
                }
L30:
                _t146 = 0;
                return _t146;
            }
        }
    } else {
        if( *((intOrPtr*)(a + 4)) !=  *((intOrPtr*)(c + 4)) ||  *((intOrPtr*)(c + 4)) !=  *((intOrPtr*)(b + 4))) {
L9:
            _t180 = 0;
            return _t180;
        } else {
            if( *((intOrPtr*)(a + 8)) >  *((intOrPtr*)(c + 8)) ||  *((intOrPtr*)(c + 8)) >  *((intOrPtr*)(b + 8))) {
                goto L9;
            } else {
                _t180 = 1;
                return _t180;
            }
        }
    }
}

KeyAbort(int _dummy)
{// addr = 0x080A6CF8
    intOrPtr _v0;
    struct _Str* _v20;
    int _v24;
    _unknown_ _v60;
    intOrPtr _v64;
    int _v68;
    _unknown_ __ebp;
    _unknown_ _t46;
    _unknown_ _t47;
    _unknown_ _t55;
    _unknown_ _t58;
    _unknown_ _t62;
    _unknown_ _t67;
    _unknown_ _t68;

    _v24 = 1;
     *__esp = 135789504;
    siglongjmp();
    _push(_t67);
    __esp = __esp - 40;
    if( *_v24 == 0) {
        return 0;
    }
    if(_dummy != 0) {
        if(_a8 == 0) {
            _v68 = _dummy;
            _v20 = Sprintf("%s\n");
        } else {
            _v64 = _a8;
            _v68 = _dummy;
            _v20 = Sprintf("%s %s\n");
        }
        fwrite( *_v20, 1, _v20->length,  *(_v0 + 16));
        fflush( *(_v0 + 16));
    }
    if(_a12 == 0) {
        return 0;
    }
     *_a12 = -1;
    _v20 = StrISgets( *(_v0 + 12));
    if(_v20->length == 0) {
        return _v20;
    }
    _v64 = _a12;
    sscanf( *_v20, "%d");
    return _v20;
}

Str news_command(News* news, char* cmd, char* arg, int* status)
{// addr = 0x080A6D12
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v32;
    char* _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t45;
    _unknown_ _t46;
    _unknown_ _t54;
    _unknown_ _t57;
    _unknown_ _t61;

    if(news->host == 0) {
        return 0;
    }
    if(cmd != 0) {
        if(arg == 0) {
            _v40 = cmd;
            _v16 = Sprintf("%s\n");
        } else {
            _v36 = arg;
            _v40 = cmd;
            _v16 = Sprintf("%s %s\n");
        }
        fwrite( *_v16, 1, _v16->length, news->wf);
        fflush(news->wf);
    }
    if(status == 0) {
        return 0;
    }
     *status = -1;
    _v16 = StrISgets( *(news + 12));
    if(_v16->length == 0) {
        return _v16;
    }
    _v36 = status;
    sscanf( *_v16, "%d");
    return _v16;
}

news_close(News* news)
{// addr = 0x080A6DF8
    _unknown_ __ebp;
    _unknown_ _t31;
    _unknown_ _t37;

    if(news->host == 0) {
        return ;
    }
    if( *(news + 12) != 0) {
        ( *(news + 12))[0x14] = ( *(news + 12))[0x14] & 255 & 239 & 4294967295;
        ISclose( *(news + 12));
         *(news + 12) = 0;
    }
    if(news->wf != 0) {
        fclose(news->wf);
        news->wf = 0;
    }
    news->host = 0;
    return;
}

int news_open(News* news)
{// addr = 0x080A6E6F
    int sock;
    int status;
    int _v16;
    intOrPtr _v20;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t52;
    _unknown_ _t66;
    _unknown_ _t70;
    _unknown_ _t74;

    _v16 = openSocket(news->host, "nntp", news->port & 4294967295 & );
    if(_v16 >= 0) {
        goto L12;
    }
     *(news + 12) = newInputStream(_v16);
    news->wf = fdopen(dup(_v16), "wb");
    if( *(news + 12) == 0 || news->wf == 0) {
L12:
        news_close(news);
        return 0;
    } else {
         *(news + 12)->base.stream.cur = ( *(news + 12)->base.stream.cur & 255 | 16) & 4294967295;
        news_command(news, 0, 0,  &_v20);
        if(_v20 != 200 && _v20 != 201) {
            goto L10;
        } else {
            if(news->mode == 0) {
                return 1;
            }
            news_command(news, "MODE", news->mode,  &_v20);
            if(_v20 == 200) {
                return 1;
            }
            if(_v20 == 201) {
                return 1;
            }
        }
        goto L12;
    }
    return __eax;
L10:
    goto L12;
}

news_quit(News* news)
{// addr = 0x080A6FA0
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t7;

    news_command(news, "QUIT", 0, 0);
    news_close(news);
    return;
}

char* name_from_address(char* str, int n)
{// addr = 0x080A6FD6
    char* s;
    char* p;
    int l;
    int space;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    intOrPtr _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t128;

    _v28 = 1;
    _v16 = allocStr(str, -1);
    while(( *_v16 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
    }
}

char* html_quote_s(char* str)
{// addr = 0x080A71FD
    Str tmp;
    char* p;
    char* q;
    int space;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    struct _Str* _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t78;

    _v16 = 0;
    _v28 = 1;
    _v20 = str;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
            _v24 =  *( &HTML_QUOTE_MAP + ( *( &QUOTE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 7) * 4);
            _v28 = 0;
            goto L5;
        }
        if(_v28 == 0) {
            _v24 = "&nbsp;";
            _v28 = 1;
            goto L5;
        }
L14:
        _v20 =  &(_v20[1]);
        continue;
L5:
        if(_v24 == 0) {
            if(_v16 != 0) {
                if(1 + _v16->length >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t78 = _v16->length;
                 *( *_v16 + _t78) =  *_v20 & 255 & 4294967295;
                _v16->length = 1 + _t78;
                 *( *_v16 + _v16->length) = 0;
            }
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(str, _v20 - str);
            }
            Strcat_charp(_v16, _v24);
        }
        goto L14;
    }
}

add_news_message(Str str, int index, char* date, char* name, char* subject, char* mid, char* scheme, char* group)
{// addr = 0x080A7331
    time_t t;
    struct tm* tm;
    char _v16;
    char* _v20;
    char* _v44;
    char* _v48;
    char* _v52;
    char* _v56;
    _unknown_ __ebp;
    char* _t43;
    char* _t50;
    char* _t53;

    name = name_from_address(name, 16);
    _v16 = mymktime(date);
    _t43 =  &_v16;
     *__esp = _t43;
    localtime();
    _v20 = _t43;
    _v44 = html_quote_s(name);
    _v48 = _v20[0xc];
    _v52 = _v20[0x10] + 1;
    _v56 = index;
    Strcat(str, Sprintf("<tr valign=top><td>%d<td nowrap>(%02d/%02d)<td nowrap>%s"));
    if(group == 0) {
        _t50 = html_quote(subject);
        _t53 = html_quote(file_quote(mid));
        _v48 = _t50;
        _v52 = _t53;
        _v56 = scheme;
        Strcat(str, Sprintf("<td><a href="%s%s">%s</a>\n"));
        return;
    }
    _v44 = html_quote(subject);
    _v48 = index;
    _v52 = group;
    _v56 = scheme;
    Strcat(str, Sprintf("<td><a href="%s%s/%d">%s</a>\n"));
    return;
}

InputStream openNewsStream(ParsedURL* pu)
{// addr = 0x080A7449
    char* host;
    char* mode;
    char* group;
    char* p;
    Str tmp;
    int port;
    int status;
    const char* _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    struct _Str* _v32;
    int _v36;
    intOrPtr _v40;
    _unknown_ _v48;
    _unknown_ _v52;
    char* _v56;
    _unknown_ __ebp;
    _unknown_ _t91;
    _unknown_ _t100;
    _unknown_ _t121;
    _unknown_ _t127;
    _unknown_ _t130;
    _unknown_ _t134;
    _unknown_ _t135;
    _unknown_ _t139;
    _unknown_ _t142;
    char* _t146;
    _unknown_ _t148;
    char* _t153;

    if(pu->file == 0) {
        return 0;
    }
    if((pu & 255 & 4294967295) == 0) {
        return 0;
    }
    if(pu->scheme == 7) {
L5:
        _v16 = pu->host;
L7:
        if(_v16 == 0 || ( *_v16 & 255 & 4294967295) == 0) {
            if(current_news.host != 0) {
                news_quit( &current_news);
            }
            return 0;
        }
        if(pu->scheme == 7 || pu->scheme == 8) {
L16:
            _v36 = pu->port;
        } else {
            _v28 = strchr(_v16, 58);
            if(_v28 == 0) {
                goto L16;
            } else {
                _v16 = allocStr(_v16, _v28 - _v16);
                _v36 = atoi( &(_v28[1]));
            }
        }
L17:
        if(NNTP_mode == 0) {
L20:
            _v20 = 0;
            goto L21;
        }
        if(( *NNTP_mode & 255 & 4294967295) == 0) {
            goto L20;
        } else {
            _v20 = NNTP_mode;
        }
L21:
        if(current_news.host != 0) {
            if(strcmp(current_news.host, _v16) != 0 ||  *135789476 != _v36) {
                news_quit( &current_news);
            } else {
                if(_v20 == 0) {
                    _t153 = "READER";
                } else {
                    _t153 = _v20;
                }
                _v32 = news_command( &current_news, "MODE", _t153,  &_v40);
                if(_v40 != 200) {
                    if(_v40 != 201) {
                        news_close( &current_news);
                    }
                }
            }
        }
        if(current_news.host == 0) {
            current_news.host = allocStr(_v16, -1);
             *135789476 = _v36;
            if(_v20 == 0) {
                _t146 = 0;
            } else {
                _t146 = allocStr(_v20, -1);
            }
             *135789480 = _t146;
            if(news_open( &current_news) == 0) {
                return 0;
            }
        }
        if(pu->scheme != 7) {
            if(pu->scheme != 9) {
                return 0;
            }
        }
        _v24 = file_unquote(allocStr(pu->file, -1));
        _v28 = strchr(_v24, 47);
        if(_v28 != 0) {
             *_v28 = 0;
            _v28 =  &(_v28[1]);
            news_command( &current_news, "GROUP", _v24,  &_v40);
            if(_v40 != 211) {
                return 0;
            }
        } else {
            if(strchr(_v24, 64) == 0) {
                return 0;
            }
            _v28 = _v24;
        }
        if(strchr(_v28, 64) == 0) {
            news_command( &current_news, "ARTICLE", _v28,  &_v40);
        } else {
            _v56 = _v28;
            news_command( &current_news, "ARTICLE",  *(Sprintf("<%s>")),  &_v40);
        }
        if(_v40 == 220) {
            return  *135789484;
        }
        return 0;
    }
    if(pu->scheme != 8) {
        _v16 = NNTP_server;
        goto L7;
    }
    goto L5;
}

Str loadNewsgroup(ParsedURL* pu, wc_ces* charset)
{// addr = 0x080A779F
    _None page;
    Str tmp;
    URLFile f;
    Buffer* buf;
    char* qgroup;
    char* p;
    char* q;
    char* s;
    char* t;
    char* n;
    _None scheme;
    _None group;
    _None list;
    int status;
    int i;
    int first;
    int last;
    _None flag;
    _None start;
    _None end;
    _None prevtrap;
    wc_ces doc_charset;
    wc_ces mime_charset;
    struct _Str* _v32;
    struct _Str* _v36;
    struct _Str _v48;
    char* _v52;
    struct _Str _v64;
    char* _v68;
    char* _v72;
    char* _v76;
    intOrPtr _v80;
    char* _v84;
    int _v88;
    int* _v92;
    int _v96;
    int _v100;
    int* _v104;
    _None* _v108;
    unsigned int _v112;
    char _v116;
    struct  _v148;
    int* _v160;
    char* _v176;
    char* _v180;
    char* _v184;
    char* _v188;
    char* _v192;
    int* _v196;
    char* _v200;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t447;
    struct _Str* _t467;
    struct _Str* _t469;
    _unknown_ _t480;
    _unknown_ _t497;
    _unknown_ _t515;
    _unknown_ _t518;
    struct _Str* _t553;
    _unknown_ _t561;
    int _t566;
    _unknown_ _t567;
    _unknown_ _t586;
    char* _t606;
    wc_ces* _t653;
    wc_ces* _t663;
    char* _t670;
    char* _t727;
    int _t771;
    _unknown_ _t772;
    unsigned int _t785;
    unsigned int _t787;

    _v96 = 0;
    _v100 = 0;
    _v104 = 0;
    _v108 = 0;
    _v112 = DocumentCharset;
     *charset = 256;
    if(current_news.host == 0) {
        return 0;
    }
    if(pu->file == 0) {
        return 0;
    }
    if((pu & 255 & 4294967295) == 0) {
        return 0;
    }
    _v72 = allocStr(pu->file, -1);
    if(pu->scheme != 8) {
        _v68 = "news:";
    } else {
        _v68 = "/";
    }
    _v76 = strchr(_v72, 47);
    if(_v76 != 0) {
        _t727 = _v76;
         *_t727 = 0;
        _v76 =  &(_t727[1]);
    }
    if((fmInitialized & 255 & 4294967295) != 0) {
        _v200 = _v72;
        message( *(Sprintf("Reading newsgroup %s...")), 0, 0);
        refresh();
    }
    _v48.length = html_quote(_v72);
    _v72 = file_unquote(_v72);
    _t467 = parsedURL2Str(pu);
    _v176 = 0;
    _v180 = "</h1>\n<hr>\n";
    _v184 = _v48.length;
    _v188 = "</title>\n</head>\n<body>\n<h1>Newsgroup: ";
    _v192 = _v48.length;
    _v196 = "">\n<title>Newsgroup: ";
    _v200 = _t467->ptr;
    _t469 = Strnew_m_charp("<html>\n<head>\n<base href="");
    _v32 = _t469;
    _v200 = 1;
     *__esp = 135789504;
    __sigsetjmp();
    if(_t469 == 0) {
        if((TrapSignal & 255 & 4294967295) != 0) {
            _v108 = mySignal(2, KeyAbort);
            if((fmInitialized & 255 & 4294967295) != 0) {
                term_cbreak();
            }
        }
        _v36 = news_command( &current_news, "GROUP", _v72,  &_v80);
        if(_v80 != 211) {
            goto L108;
        }
        _v184 =  &_v92;
        _v188 =  &_v88;
        _v192 =  &_v84;
        _v196 =  &_v80;
        if(sscanf( *_v36, "%d %d %d %d") != 4) {
            goto L107;
        } else {
            if(_v76 != 0) {
                if(( *_v76 & 255 & 4294967295) != 0) {
                    _v48 = strchr(_v76, 45);
                    if(_v48 != 0) {
                         *_v48 = 0;
                        _v48 =  &(_v48[1]);
                        _v104 = atoi(_v48);
                    }
                    _v100 = atoi(_v76);
                    if(_v100 > 0) {
                        if(_v100 < _v88) {
                            _v100 = _v88;
                        }
                        if(_v104 <= 0) {
                            _v104 = _v100 + MaxNewsMessage - 1;
                        }
                    }
                }
            }
            if(_v100 <= 0) {
                _v100 = _v88;
                _v104 = _v92;
                if(_v104 - _v100 > MaxNewsMessage - 1) {
                    _v100 = _v104 - MaxNewsMessage + 1;
                }
            }
            _v160 = _v104;
            _t553 = parsedURL2Str(pu);
            _v176 = _v160;
            _v180 = _v100;
            _v184 = _v48.length;
            _v188 = _v104;
            _v192 = _v100;
            _v196 = _v48.length;
            _v200 = _t553->ptr;
            _v32 = Sprintf("<html>\n<head>\n<base href="%s">\n<title>Newsgroup: %s %d-%d</title>\n</head>\n<body>\n<h1>Newsgroup: %s %d-%d</h1>\n<hr>\n");
            if(_v100 > _v88) {
                _v84 = _v100 - MaxNewsMessage;
                if(_v84 < _v88) {
                    _v84 = _v88;
                }
                _v180 = _v100 - 1;
                _v184 = _v84;
                _v188 = _v100 - 1;
                _v192 = _v84;
                _v196 = _v48.length;
                _v200 = _v68;
                Strcat(_v32, Sprintf("<a href="%s%s/%d-%d">[%d-%d]</a>\n"));
            }
            Strcat_charp(_v32, "<table>\n");
            _v196 = _v104;
            _v200 = _v100;
            news_command( &current_news, "XOVER",  *(Sprintf("%d-%d")),  &_v80);
            if(_v80 != 224) {
                init_stream( &_v148, 9,  *135789484);
                _t771 = COLS;
                if(showLineNum == 0) {
                    _t566 = 1;
                } else {
                    _t566 = 6;
                }
                _t567 = _t771 - _t566;
                _t568 = _t567 >= 0 ? 0 : _t567;
                _v48.area_size = newBuffer(_t567 >= 0 ? 0 : _t567);
                _v84 = _v100;
                while(_v84 <= _v104 && _v84 <= _v92) {
                    _v200 = _v84;
                    news_command( &current_news, "HEAD",  *(Sprintf("%d")),  &_v80);
                    if(_v80 == 221) {
                        readHeader( &_v148, _v48.area_size, 0, 0);
                        _v48 = checkHeader(_v48.area_size, "Message-ID:");
                        if(_v48 != 0) {
                            if(( *_v48 & 255 & 4294967295) == 60) {
                                _v48 =  &(_v48[1]);
                            }
                            _v52 = strchr(_v48, 62);
                            if(_v52 == 0) {
                                _v52 = strchr(_v48, 9);
                                if(_v52 == 0) {
                                     *_v52 = 0;
                                }
                            }
                            _v64.area_size = checkHeader(_v48.area_size, "Subject:");
                            if(_v56 != 0) {
                                _v64 = checkHeader(_v48.area_size, "From:");
                                if(_v64 != 0) {
                                    _v64.length = checkHeader(_v48.area_size, "Date:");
                                    if(_v60 != 0) {
                                        if(pu->scheme != 8) {
                                            _t606 = 0;
                                        } else {
                                            _t606 = _v48.length;
                                        }
                                        add_news_message(_v32, _v84, _v64.length, _v64, _v64.area_size, _v48, _v68, _t606);
                                    }
                                }
                            }
                        }
                    }
                    _v84 =  &(_v84[1]);
                }
            }
            _v148 = 9;
            while(1) {
                _v36 = StrISgets( *135789484);
                if(( *( *_v36) & 255 & 4294967295) == 46 && (( *( *_v36 + 1) & 255 & 4294967295) == 10 || ( *( *_v36 + 1) & 255 & 4294967295) == 13 || ( *( *_v36 + 1) & 255 & 4294967295) == 0)) {
                    break;
                }
                if(( *( *_v36) & 255 & 4294967295) == 10 || ( *( *_v36) & 255 & 4294967295) == 13 || ( *( *_v36) & 255 & 4294967295) == 0) {
                    break;
                }
                _v196 =  &_v84;
                if(sscanf( *_v36, "%d") == 1) {
                    _v64.area_size = strchr( *_v36, 9);
                    if(_v56 != 0) {
                        _v64.area_size =  &(_v64.area_size[1]);
                        _v64 = strchr(_v64.area_size, 9);
                        if(_v64 != 0) {
                             *_v64 = 0;
                            _v64 =  &(_v64[1]);
                            _v64.length = strchr(_v64, 9);
                            if(_v60 != 0) {
                                 *(_v64.length) = 0;
                                _v64.length =  &(_v64.length[1]);
                                _v48 = strchr(_v64.length, 9);
                                if(_v48 != 0) {
                                     *_v48 = 0;
                                    _v48 =  &(_v48[1]);
                                    if(( *_v48 & 255 & 4294967295) == 60) {
                                        _v48 =  &(_v48[1]);
                                    }
                                    _v52 = strchr(_v48, 62);
                                    if(_v52 != 0) {
L58:
                                         *_v52 = 0;
                                        _v36 = decodeMIME(Strnew_charp(_v64.area_size),  &_v116);
                                        if(_v116 == 0) {
                                            _t785 = _v112;
                                        } else {
                                            _t785 = _v116;
                                        }
                                        if(_v116 == 0) {
                                            _t653 = charset;
                                        } else {
                                            _t653 =  &_v116;
                                        }
                                        _v64.area_size =  *(convertLine( &_v148, _v36, 3, _t653, _t785));
                                        _v36 = decodeMIME(Strnew_charp(_v64),  &_v116);
                                        if(_v116 == 0) {
                                            _t787 = _v112;
                                        } else {
                                            _t787 = _v116;
                                        }
                                        if(_v116 == 0) {
                                            _t663 = charset;
                                        } else {
                                            _t663 =  &_v116;
                                        }
                                        _v64 =  *(convertLine( &_v148, _v36, 3, _t663, _t787));
                                        if(pu->scheme != 8) {
                                            _t670 = 0;
                                        } else {
                                            _t670 = _v48.length;
                                        }
                                        add_news_message(_v32, _v84, _v64.length, _v64, _v64.area_size, _v48, _v68, _t670);
                                        continue;
                                    }
                                    _v52 = strchr(_v48, 9);
                                    if(_v52 != 0) {
                                        goto L58;
                                    }
                                    goto L74;
                                }
                                goto L52;
                            }
                            goto L50;
L52:
                            goto L74;
                        }
                        goto L48;
L50:
                        goto L74;
                    }
                    goto L46;
L48:
                    goto L74;
                }
L74:
                continue;
L46:
                goto L74;
            }
            Strcat_charp(_v32, "</table>\n");
            if(_v104 < _v92) {
                _v84 = _v104 + MaxNewsMessage;
                if(_v84 > _v92) {
                    _v84 = _v92;
                }
                _v180 = _v84;
                _v184 =  &(_v104[0]);
                _v188 = _v84;
                _v192 = _v104 + 1;
                _v196 = _v48.length;
                _v200 = _v68;
                Strcat(_v32, Sprintf("<a href="%s%s/%d-%d">[%d-%d]</a>\n"));
            }
            _v96 = 1;
        }
L108:
        _v200 = _v72;
        _v36 = Sprintf("ACTIVE %s");
        if(strchr(_v72, 42) == 0) {
            Strcat_charp(_v36, ".*");
        }
        news_command( &current_news, "LIST",  *_v36,  &_v80);
        if(_v80 == 215) {
            while(1) {
                _v36 = StrISgets( *135789484);
                if(( *( *_v36) & 255 & 4294967295) == 46 && (( *( *_v36 + 1) & 255 & 4294967295) == 10 || ( *( *_v36 + 1) & 255 & 4294967295) == 13 || ( *( *_v36 + 1) & 255 & 4294967295) == 0)) {
                    break;
                }
                if(( *( *_v36) & 255 & 4294967295) == 10 || ( *( *_v36) & 255 & 4294967295) == 13 || ( *( *_v36) & 255 & 4294967295) == 0) {
                    break;
                } else {
                    if(_v96 <= 1) {
                        if(_v96 == 1) {
                            Strcat_charp(_v32, "<hr>\n");
                        }
                        Strcat_charp(_v32, "<table>\n");
                        _v96 = 2;
                    }
                    _v48 =  *_v36;
                    _v52 = _v48;
                    while(( *_v52 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v52 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                        _v52 =  &(_v52[1]);
                    }
                }
            }
            if(_v96 == 2) {
                Strcat_charp(_v32, "</table>\n");
            }
        }
        goto L134;
L107:
        goto L108;
    } else {
        news_close( &current_news);
        Strcat_charp(_v32, "</table>\n<p>Transfer Interrupted!\n");
    }
L134:
    Strcat_charp(_v32, "</body>\n</html>\n");
    if((TrapSignal & 255 & 4294967295) == 0) {
        return _v32;
    }
    if((fmInitialized & 255 & 4294967295) != 0) {
        term_raw();
    }
    if(_v108 == 0) {
        return _v32;
    }
    mySignal(2, _v108);
    return _v32;
}

closeNews()
{// addr = 0x080A83BA
    _unknown_ __ebp;

    news_close( &current_news);
    return;
}

disconnectNews()
{// addr = 0x080A83CE
    _unknown_ __ebp;

    news_quit( &current_news);
    return;
}

setKeymap(char* p, int lineno, int verbose)
{// addr = 0x080A83E4
    unsigned char* map;
    char* s;
    char* emsg;
    int c;
    int f;
    unsigned char** mmap;
    int i;
    int j;
    int m;
    unsigned char[127]* _v16;
    char* _v20;
    char* _v24;
    int _v28;
    int _v32;
    char* _v36;
    signed int _v40;
    _Unknown_base* _v44;
    int _v48;
    _unknown_ _v76;
    _unknown_ _v80;
    char* _v84;
    char* _v88;
    _unknown_ __ebx;
    _unknown_ __ebp;
    char* _t163;

    _v16 = 0;
    _v20 = getQWord( &p);
    _v28 = getKey(_v20);
    if(_v28 < 0) {
        if(lineno <= 0) {
            _v88 = _v20;
            _v24 =  *(Sprintf("defkey: unknown key '%s'"));
        } else {
            _v84 = _v20;
            _v88 = lineno;
            _v24 =  *(Sprintf("line %d: unknown key '%s'"));
        }
        record_err_message(_v24);
        if(verbose == 0) {
            return ;
        }
        disp_message_nsec(_v24, 0, 1, 1, 0);
        return;
    }
    _v20 = getWord( &p);
    _v32 = getFuncList(_v20);
    if(_v32 < 0) {
        if(lineno <= 0) {
            _v88 = _v20;
            _v24 =  *(Sprintf("defkey: invalid command '%s'"));
        } else {
            _v84 = _v20;
            _v88 = lineno;
            _v24 =  *(Sprintf("line %d: invalid command '%s'"));
        }
        record_err_message(_v24);
        if(verbose == 0) {
            return ;
        }
        disp_message_nsec(_v24, 0, 1, 1, 0);
        return;
    }
    if((_v28 & 268435456) == 0) {
        if((_v28 & 1024) == 0) {
            if((_v28 & 512) == 0) {
                if((_v28 & 256) == 0) {
                    _v16 =  &GlobalKeymap;
                } else {
                    _v16 =  &EscKeymap;
                }
            } else {
                _v16 =  &EscBKeymap;
            }
        } else {
            _v16 =  &EscDKeymap;
        }
        goto L47;
    } else {
        _v36 = 0;
        _v48 = _v28 >> 16 & 1919;
        if((_v48 & 1024) == 0) {
            if((_v48 & 512) == 0) {
                if((_v48 & 256) == 0) {
                    _v16 =  &GlobalKeymap;
                } else {
                    _v16 =  &EscKeymap;
                }
            } else {
                _v16 =  &EscBKeymap;
            }
        } else {
            _v16 =  &EscDKeymap;
        }
        if(( *(_v16 + (_v48 & 127)) & 255 & 4294967295) != 74) {
            _t163 = _v16 + (_v48 & 127);
             *_t163 = 74;
        } else {
            _t163 = getKeyData(_v48);
            _v36 = _t163;
        }
        if(_v36 != 0) {
            if(keyData == 0) {
                keyData = newHash_iv(16);
            }
            putHash_iv(keyData, _v48, _v36);
            if((_v28 & 1024) == 0) {
                if((_v28 & 512) == 0) {
                    if((_v28 & 256) == 0) {
                        _v16 =  *_v36;
                    } else {
                        _v16 = _v36[4];
                    }
                } else {
                    _v16 = _v36[8];
                }
            } else {
                _v16 = _v36[0xc];
            }
L47:
             *(_v16 + (_v28 & 127)) = _v32 & 4294967295;
            _v20 = getQWord( &p);
            if(( *_v20 & 255 & 4294967295) == 0) {
                if(getKeyData(_v28) == 0) {
                    return ;
                }
                putHash_iv(keyData, _v28, 0);
                return;
            }
            if(keyData == 0) {
                keyData = newHash_iv(16);
            }
            putHash_iv(keyData, _v28, _v20);
            return;
        }
         *__esp = 16;
        GC_malloc();
        _v36 = _t163;
        _v40 = 0;
        while(_v40 <= 3) {
             *__esp = 128;
            GC_malloc();
             *((intOrPtr*)(_v36 + (_v40 << 2))) = _v40 << 2;
            _v44 = 0;
            while(_v44 <= 127) {
                 *(_v44 +  *(_v36 + (_v40 << 2))) = 0;
                _v44 = _v44 + 1;
            }
        }
    }
}

interpret_keymap(FILE* kf, struct stat* current, int force)
{// addr = 0x080A87D7
    int fd;
    struct stat kstat;
    Str line;
    char* p;
    char* s;
    char* emsg;
    int lineno;
    wc_ces charset;
    int verbose;
    int _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    intOrPtr _v52;
    unsigned int _v56;
    intOrPtr _v60;
    intOrPtr _v84;
    intOrPtr _v104;
    intOrPtr _v136;
    signed int _v144;
    void _v148;
    _unknown_ _v172;
    _unknown_ _v176;
    _unknown_ _v180;
    char* _v184;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    int _t92;
    _unknown_ _t94;
    _unknown_ _t95;
    _unknown_ _t155;
    _unknown_ _t156;
    _unknown_ _t167;

    _v56 = SystemCharset;
    _v60 = 1;
    _v32 = fileno(kf);
    if(_v32 >= 0) {
        return ;
    }
    _v184 =  &_v148;
    _t92 = _v32;
     *__esp = _t92;
    L080C72C0();
    if(_t92 != 0) {
        return ;
    }
    if(force == 0 && _v84 == current->st_mtim.tv_sec) {
        if((current->st_dev ^ _v148 | _v144 ^  *(current + 4)) == 0) {
            if(_v136 ==  *((intOrPtr*)(current + 12))) {
                if(_v104 ==  *((intOrPtr*)(current + 44))) {
                    return ;
                }
            }
        }
    }
    memcpy(current,  &_v148, 22 << 2);
    _v52 = 0;
    while(feof(kf) == 0) {
    }
}

initKeymap(int force)
{// addr = 0x080A8A8F
    FILE* kf;
    FILE* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t19;
    int _t25;
    int _t29;
    _unknown_ _t32;

    _v16 = fopen(confFile("keymap"), "rt");
    if(_v16 == 0) {
L6:
        _v16 = fopen(rcFile(keymap_file), "rt");
        if(_v16 != 0) {
            if(force != 0 || (keymap_initialized & 255 & 4294967295) == 0) {
                _t25 = 1;
            } else {
                _t25 = 0;
            }
            interpret_keymap(_v16,  &current_keymap_file, _t25);
            _t24 = fclose(_v16);
        }
        keymap_initialized = 1;
        return;
    }
    if(force == 0 && (keymap_initialized & 255 & 4294967295) != 0) {
        _t29 = 0;
    } else {
        _t29 = 1;
    }
    interpret_keymap(_v16,  &sys_current_keymap_file, _t29);
    fclose(_v16);
    goto L6;
}

int getFuncList(char* id)
{// addr = 0x080A8B6E
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return getHash_si( &functable, id, -1);
}

char* getKeyData(int key)
{// addr = 0x080A8B91
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t7;

    if(keyData != 0) {
        return getHash_iv(keyData, key, 0);
    }
    return 0;
}

int getKey2(char** str)
{// addr = 0x080A8BC5
    char* s;
    int c;
    int esc;
    int ctrl;
    char* _v16;
    signed int _v20;
    signed int _v24;
    signed int _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t190;
    _unknown_ _t223;
    _unknown_ _t237;
    _unknown_ _t238;
    _unknown_ _t271;
    _unknown_ _t290;
    _unknown_ _t333;
    _unknown_ _t336;
    _unknown_ _t339;
    _unknown_ _t342;

    _v16 =  *str;
    _v24 = 0;
    _v28 = 0;
    if(_v16 == 0) {
        return -1;
    }
    if(( *_v16 & 255 & 4294967295) == 0) {
        return -1;
    }
    if(strcasecmp(_v16, "UP") == 0) {
         *str =  &(_v16[2]);
        return 577;
    }
    if(strcasecmp(_v16, "DOWN") == 0) {
         *str =  &(_v16[4]);
        return 578;
    }
    if(strcasecmp(_v16, "RIGHT") == 0) {
         *str =  &(_v16[5]);
        return 579;
    }
    if(strcasecmp(_v16, "LEFT") == 0) {
         *str =  &(_v16[4]);
        return 580;
    }
    if(strncasecmp(_v16, "ESC-", 4) == 0 || strncasecmp(_v16, "ESC ", 4) == 0) {
        _v16 =  &(_v16[4]);
        _v24 = 256;
    } else {
        if(strncasecmp(_v16, "M-", 2) == 0 || strncasecmp(_v16, "\E", 2) == 0) {
            _v16 =  &(_v16[2]);
            _v24 = 256;
        } else {
            if(( *_v16 & 255 & 4294967295) == 27) {
                _v16 =  &(_v16[1]);
                _v24 = 256;
            }
        }
    }
    if(strncasecmp(_v16, "C-", 2) != 0) {
        if(( *_v16 & 255 & 4294967295) == 94 && (_v16[1] & 255 & 4294967295) != 0) {
            _v16 =  &(_v16[1]);
            _v28 = 1;
        }
    } else {
        _v16 =  &(_v16[2]);
        _v28 = 1;
    }
    if(_v24 == 0 && _v28 != 0 && ( *_v16 & 255 & 4294967295) == 91) {
        _v16 =  &(_v16[1]);
        _v28 = 0;
        _v24 = 256;
    }
    if(_v24 != 0 && _v28 == 0) {
        if(( *_v16 & 255 & 4294967295) == 91 || ( *_v16 & 255 & 4294967295) == 79) {
            _v16 =  &(_v16[1]);
            _v24 = 512;
        }
        if(strncasecmp(_v16, "C-", 2) != 0) {
            if(( *_v16 & 255 & 4294967295) == 94 && (_v16[1] & 255 & 4294967295) != 0) {
                _v16 =  &(_v16[1]);
                _v28 = 1;
            }
        } else {
            _v16 =  &(_v16[2]);
            _v28 = 1;
        }
    }
    if(_v28 == 0) {
        if(_v24 != 512 || ( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
            if(strncasecmp(_v16, "SPC", 3) != 0) {
                if(strncasecmp(_v16, "TAB", 3) != 0) {
                    if(strncasecmp(_v16, "DEL", 3) != 0) {
                        if(( *_v16 & 255 & 4294967295) != 92 || (_v16[1] & 255 & 4294967295) == 0) {
                             *str =  &(_v16[1]);
                            if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 17) == 0) {
                                return -1;
                            }
                            return  *_v16 & 255 & 4294967295 | _v24;
                        } else {
                            _v16 =  &(_v16[1]);
                             *str =  &(_v16[1]);
                            if(( *_v16 & 255 & 4294967295) - 92 > 24) {
                                return -1;
                            }
                            goto __eax;
                        }
                    }
                    goto L60;
                }
                goto L58;
L60:
                 *str =  &(_v16[3]);
                return _v24 | 127;
            }
            goto L56;
L58:
             *str =  &(_v16[3]);
            return _v24 | 9;
        } else {
            _v20 = ( *_v16 & 255 & 4294967295) - 48;
            _v16 =  &(_v16[1]);
            if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
                _v20 = (_v20 << 2) + _v20 + (_v20 << 2) + _v20 + ( *_v16 & 255 & 4294967295) - 48;
                _v16 =  &(_v16[1]);
            }
             *str =  &(_v16[1]);
            if(( *_v16 & 255 & 4294967295) != 126) {
                return -1;
            }
            return _v20;
        }
L56:
         *str =  &(_v16[3]);
        return _v24 | 32;
    } else {
         *str =  &(_v16[1]);
        if(( *_v16 & 255 & 4294967295) > 63) {
            if(( *_v16 & 255 & 4294967295) <= 95) {
                return ( *_v16 & 255 & 4294967295) - 64 | _v24;
            }
        }
        if(( *_v16 & 255 & 4294967295) > 96) {
            if(( *_v16 & 255 & 4294967295) <= 122) {
                return ( *_v16 & 255 & 4294967295) - 96 | _v24;
            }
        }
        if(( *_v16 & 255 & 4294967295) != 63) {
            return -1;
        }
        return _v24 | 127;
    }
}

int getKey(char* s)
{// addr = 0x080A90C7
    int c;
    int c2;
    signed int _v16;
    int _v20;
    _unknown_ __ebp;
    _unknown_ _t34;
    _unknown_ _t37;

    _v16 = getKey2( &s);
    if(_v16 < 0) {
        return -1;
    }
    if(( *s & 255 & 4294967295) == 32 || ( *s & 255 & 4294967295) == 45) {
        s =  &(s[1]);
    }
    if(( *s & 255 & 4294967295) == 0) {
        return _v16;
    }
    _v20 = getKey2( &s);
    if(_v20 < 0) {
        return -1;
    }
    _v16 = _v16 << 16 | 268435456 | _v20;
    return _v16;
}

char* getWord(char** str)
{// addr = 0x080A9140
    char* p;
    char* s;
    char* _v16;
    char* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 =  *str;
    while(( *_v16 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v16 =  &(_v16[1]);
            continue;
        }
        _v20 = _v16;
        while(( *_v16 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0 && ( *_v16 & 255 & 4294967295) != 59) {
            _v16 =  &(_v16[1]);
        }
    }
}

char* getQWord(char** str)
{// addr = 0x080A91D9
    Str tmp;
    char* p;
    int in_q;
    int in_dq;
    int esc;
    struct _Str* _v16;
    char* _v20;
    char _v24;
    char _v28;
    char _v32;
    _unknown_ __ebp;
    _unknown_ _t190;
    int _t227;
    int _t242;
    int _t257;
    int _t272;
    int _t295;
    int _t312;
    int _t329;

    _v16 = Strnew();
    _v24 = 0;
    _v28 = 0;
    _v32 = 0;
    _v20 =  *str;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v20 =  &(_v20[1]);
            continue;
        } else {
        }
        while(( *_v20 & 255 & 4294967295) != 0) {
            if(_v32 == 0) {
                if(( *_v20 & 255 & 4294967295) != 92) {
                    if(_v24 == 0) {
                        if(_v28 == 0) {
                            if(( *_v20 & 255 & 4294967295) != 39) {
                                if(( *_v20 & 255 & 4294967295) != 34) {
                                    if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0 || ( *_v20 & 255 & 4294967295) == 59) {
                                         *str = _v20;
                                        return  *_v16;
                                    } else {
                                        if(_v16->length + 1 >= _v16->area_size) {
                                            Strgrow(_v16);
                                        }
                                        _t227 = _v16->length;
                                         *( *_v16 + _t227) =  *_v20 & 255 & 4294967295;
                                        _v16->length = _t227 + 1;
                                         *((char*)( *_v16 + _v16->length)) = 0;
                                        goto L51;
                                    }
                                }
                                goto L45;
                            }
                            goto L43;
L45:
                            _v28 = 1;
                            goto L51;
                        }
                        goto L37;
L43:
                        _v24 = 1;
                        goto L51;
                    }
                    goto L31;
L37:
                    if(( *_v20 & 255 & 4294967295) != 34) {
                        if(_v16->length + 1 >= _v16->area_size) {
                            Strgrow(_v16);
                        }
                        _t242 = _v16->length;
                         *( *_v16 + _t242) =  *_v20 & 255 & 4294967295;
                        _v16->length = _t242 + 1;
                         *((char*)( *_v16 + _v16->length)) = 0;
                    } else {
                        _v28 = 0;
                    }
                    goto L51;
                }
                goto L29;
L31:
                if(( *_v20 & 255 & 4294967295) != 39) {
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t257 = _v16->length;
                     *( *_v16 + _t257) =  *_v20 & 255 & 4294967295;
                    _v16->length = _t257 + 1;
                     *((char*)( *_v16 + _v16->length)) = 0;
                } else {
                    _v24 = 0;
                }
                goto L51;
            }
            if(_v24 == 0) {
                if(_v28 == 0) {
                    if(( *_v20 & 255 & 4294967295) != 92 && ( *_v20 & 255 & 4294967295) != 39 && ( *_v20 & 255 & 4294967295) != 34 && ( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0) {
                        if(_v16->length + 1 >= _v16->area_size) {
                            Strgrow(_v16);
                        }
                        _t295 = _v16->length;
                         *((char*)( *_v16 + _t295)) = 92;
                        _v16->length = _t295 + 1;
                         *((char*)( *_v16 + _v16->length)) = 0;
                    }
                } else {
                    if(( *_v20 & 255 & 4294967295) != 92 && ( *_v20 & 255 & 4294967295) != 34) {
                        if(_v16->length + 1 >= _v16->area_size) {
                            Strgrow(_v16);
                        }
                        _t312 = _v16->length;
                         *((char*)( *_v16 + _t312)) = 92;
                        _v16->length = _t312 + 1;
                         *((char*)( *_v16 + _v16->length)) = 0;
                    }
                }
            } else {
                if(( *_v20 & 255 & 4294967295) != 92) {
                    if(( *_v20 & 255 & 4294967295) != 39) {
                        if(_v16->length + 1 >= _v16->area_size) {
                            Strgrow(_v16);
                        }
                        _t329 = _v16->length;
                         *((char*)( *_v16 + _t329)) = 92;
                        _v16->length = _t329 + 1;
                         *((char*)( *_v16 + _v16->length)) = 0;
                    }
                }
            }
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t272 = _v16->length;
             *( *_v16 + _t272) =  *_v20 & 255 & 4294967295;
            _v16->length = _t272 + 1;
             *((char*)( *_v16 + _v16->length)) = 0;
            _v32 = 0;
L51:
            _v20 =  &(_v20[1]);
            continue;
L29:
            _v32 = 1;
            goto L51;
        }
    }
}

setMouseAction0(char** str, int* width, MouseActionMap** map, char* p)
{// addr = 0x080A95B9
    char* s;
    int b;
    int w;
    int x;
    char* _v16;
    signed int _v20;
    int _v24;
    signed int _v28;
    intOrPtr _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    MouseActionMap* _t74;

    _v16 = getQWord( &p);
    if(( *_v16 & 255 & 4294967295) != 0) {
        _v24 =  *width;
         *str = _v16;
         *width = wtf_strwidth(_v16);
        if( *width > 99) {
             *width = 100;
        }
        if( *width <= _v24) {
            return ;
        }
        _v20 = 0;
        while(_v20 <= 2) {
            if(map[_v20] == 0) {
                goto L15;
            }
            _t74 = map[_v20];
            _v40 = 0 +  *width * 8;
             *__esp = _t74;
            GC_realloc();
            map[_v20] = _t74;
            _v28 = _v24 + 1;
            while( *width > _v28) {
                 *(map[_v20] + (_v28 << 3)) = 0;
                (map[_v20] + (_v28 << 3))[1] = 0;
                _v28 = _v28 + 1;
            }
L15:
            _v20 = _v20 + 1;
        }
    }
     *str = 0;
    width = 0;
    _v20 = 0;
    while(_v20 <= 2) {
        map[_v20] = 0;
        _v20 = _v20 + 1;
    }
}

setMouseAction1(MouseActionMap** map, int width, char* p)
{// addr = 0x080A9701
    char* s;
    int x;
    int x2;
    int f;
    signed int _v16;
    signed int _v20;
    int _v24;
    int _v28;
    _unknown_ __ebp;
    signed int _t96;
    MouseActionMap* _t102;
    signed int* _t113;

    if( *map != 0) {
        _v16 = getWord( &p);
        _v20 = atoi(_v16);
        if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
            return ;
        }
        if(_v20 >= 0) {
            return ;
        }
        if(_v20 >= width) {
            return ;
        }
        _v16 = getWord( &p);
        _v24 = atoi(_v16);
        if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
            return ;
        }
        if(_v24 >= 0) {
            return ;
        }
        if(_v24 >= width) {
            return ;
        }
        _v16 = getWord( &p);
        _v28 = getFuncList(_v16);
        _v16 = getQWord( &p);
        if(( *_v16 & 255 & 4294967295) == 0) {
            _v16 = 0;
        }
        while(_v20 <= _v24) {
            _t113 =  *map + (_v20 << 3);
            if(_v28 >= 0) {
                _t96 = 0;
            } else {
                _t96 =  *(135103140 + _v28 * 8);
            }
             *_t113 = _t96;
            ( *map + (_v20 << 3))[1] = _v16;
            _v20 = _v20 + 1;
        }
    } else {
        _t102 = width << 3;
         *__esp = _t102;
        GC_malloc();
         *map = _t102;
        _v20 = 0;
    }
    while(_v20 < width) {
         *( *map + (_v20 << 3)) = 0;
        ( *map + (_v20 << 3))[1] = 0;
        _v20 = _v20 + 1;
    }
}

setMouseAction2(MouseActionMap* map, char* p)
{// addr = 0x080A9899
    char* s;
    int f;
    _None* _v16;
    int _v20;
    _unknown_ __ebp;
    _None* _t26;

    _v16 = getWord( &p);
    _v20 = getFuncList(_v16);
    _v16 = getQWord( &p);
    if(( *_v16 & 255 & 4294967295) == 0) {
        _v16 = 0;
    }
    if(_v20 >= 0) {
        _t26 = 0;
    } else {
        _t26 =  *(135103140 + _v20 * 8);
    }
    map->func = _t26;
    map->data = _v16;
    return;
}

interpret_mouse_action(FILE* mf)
{// addr = 0x080A9901
    Str line;
    char* p;
    char* s;
    int b;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    intOrPtr _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

L37:
    while(feof(mf) == 0) {
        _v16 = Strfgets(mf);
        Strchop(_v16);
        Strremovefirstspaces(_v16);
        if(_v16->length == 0) {
            continue;
        }
        _v20 =  *(wc_Str_conv(Strnew_charp( *_v16), SystemCharset, InnerCharset));
        _v24 = getWord( &_v20);
        if(( *_v24 & 255 & 4294967295) == 35) {
            goto L32;
        }
        if(strcmp(_v24, 135069899) != 0) {
            if(strcmp(_v24, "lastline") != 0) {
                if(strcmp(_v24, "button") != 0) {
                    goto L33;
                }
                goto L8;
L34:
            } else {
                setMouseAction0(135792260, 135792268, 135792392, _v20);
            }
            continue;
L8:
            _v24 = getWord( &_v20);
            _v28 = atoi(_v24) - 1;
            if(_v28 >= 0) {
                goto L34;
            }
            if(_v28 <= 2) {
                while() {
                }
            }
        } else {
            setMouseAction0( &mouse_action, 135792264, 135792380, _v20);
        }
        continue;
L33:
        continue;
L32:
    }
}

initMouseAction()
{// addr = 0x080A9C4C
    FILE* mf;
    int w;
    char** symbol;
    FILE* _v16;
    int _v20;
    char** _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t20;
    void _t21;
    _unknown_ _t23;
    _unknown_ _t37;
    _unknown_ _t40;

    _t21 = bcopy( &default_mouse_action,  &mouse_action, 148);
     *__esp = 48;
    GC_malloc();
     *135792392 = _t21;
    bcopy( &default_lastline_action,  *135792392, 48);
    _v20 = 0;
    _v24 = get_symbol(DisplayCharset,  &_v20);
     *135792260 =  *(Strnew_charp(_v24[0x2d]));
    _v16 = fopen(confFile("mouse"), "rt");
    if(_v16 != 0) {
        interpret_mouse_action(_v16);
        fclose(_v16);
    }
    _v16 = fopen(rcFile("mouse"), "rt");
    if(_v16 == 0) {
        return ;
    }
    interpret_mouse_action(_v16);
    fclose(_v16);
    return;
}

int total_dot_number(char* p, char* ep, int max_count)
{// addr = 0x080A9D54
    int count;
    intOrPtr _v16;
    _unknown_ __ebp;

    _v16 = 0;
    if(ep == 0) {
        ep =  &(p[strlen(p)]);
    }
    while(p < ep) {
        if(_v16 >= max_count) {
            return _v16;
        }
        if(( *p & 255 & 4294967295) == 46) {
            _v16 = _v16 + 1;
        }
        p =  &(p[1]);
    }
}

char* domain_match(char* host, char* domain)
{// addr = 0x080A9DA1
    int m0;
    int m1;
    int offset;
    char* domain_p;
    int _v16;
    int _v20;
    int _v24;
    char* _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t53;
    _unknown_ _t58;
    int _t86;

    regexCompile("[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+", 0);
    _v16 = regexMatch(host, -1, 1);
    _v20 = regexMatch(domain, -1, 1);
    if(_v16 != 0) {
        if(_v20 == 0) {
            goto L4;
        } else {
            if(strcasecmp(host, domain) == 0) {
                return host;
            }
            return 0;
        }
    }
L4:
    if(_v16 != 0) {
        return 0;
    }
    if(_v20 != 0) {
        return 0;
    }
    if(strcasecmp(domain, ".") == 0 || strcasecmp(domain, ".local") == 0) {
        _v24 = strlen(host);
        _v28 =  &(host[_v24]);
        if((domain[1] & 255 & 4294967295) == 0) {
            return _v28;
        }
        if(total_dot_number(host, _v28, 1) != 0) {
            return 0;
        }
        return _v28;
    } else {
        if(( *domain & 255 & 4294967295) == 46) {
            if(strcasecmp(host,  &(domain[1])) == 0) {
                return host;
            }
        }
        if(( *domain & 255 & 4294967295) != 46) {
            _t78 = 0;
        } else {
            _t86 = strlen(host);
            0 = _t86 - strlen(domain);
        }
        _v24 = 0;
        _v28 =  &(host[_v24]);
        if(_v24 >= 0) {
            return 0;
        }
        if(strcasecmp(_v28, domain) != 0) {
            return 0;
        }
        return _v28;
    }
}

struct portlist* make_portlist(Str port)
{// addr = 0x080A9F49
    struct portlist* first;
    struct portlist* pl;
    char* p;
    Str tmp;
    signed int _v16;
    int _v20;
    int _v24;
    signed int _v28;
    _unknown_ __ebp;
    _unknown_ _t54;

    _v16 = 0;
    _v28 = Strnew();
    _v24 = port->ptr;
    while(( *_v24 & 255 & 4294967295) != 0) {
        while(1) {
            _v24 =  *_v24 & 255;
            if(( *_v24 & 255 & 4294967295) == 0) {
                break;
            }
            _v24 =  *_v24 & 255;
             *_v24 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255;
             *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
            if(( *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
                _v24 = _v24 + 1;
                continue;
            }
            break;
        }
L5:
        __eax = _v28;
        Strclear(_v28);
        while(1) {
            _v24 =  *_v24 & 255;
            if(( *_v24 & 255 & 4294967295) == 0) {
                break;
            }
            _v24 =  *_v24 & 255;
             *_v24 & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255;
             *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  =  *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8;
            if(( *( &MYCTYPE_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
                _v28 =  *(_v28 + 4);
                __edx =  *(_v28 + 4) + 1;
                _v28 =  *(_v28 + 8);
                if( *(_v28 + 4) + 1 >=  *(_v28 + 8)) {
                    __eax = _v28;
                    Strgrow(_v28);
                }
                _v28 = _v28;
                __eax =  *(_v28 + 4);
                __eax = _v24;
                __edx =  *_v24 & 255;
                 *( *_v28 + __eax) =  *_v24 & 255 & 4294967295;
                __edx = __eax + 1;
                __eax = _v28;
                 *(_v28 + 4) = __edx;
                _v24 = _v24 + 1;
                __eax = _v28;
                __edx =  *_v28;
                _v28 =  *(_v28 + 4);
                __eax =  *_v28 +  *(_v28 + 4);
                 *( *_v28 +  *(_v28 + 4)) = 0;
                continue;
            }
            break;
        }
L11:
        __eax = _v28;
        __eax =  *(_v28 + 4);
        if(__eax == 0) {
            return _v16;
        }
         *__esp = 8;
        GC_malloc();
        _v20 = __eax;
        _v28 =  *_v28;
        __eax = atoi( *_v28);
        __edx =  *_v28;
        __eax = _v20;
         *_v20 =  *_v28 & 4294967295;
        __eax = _v20;
        __edx = _v16;
         *(_v20 + 4) = _v16;
        __eax = _v20;
        _v16 = _v20;
    }
}

Str portlist2str(struct portlist* first)
{// addr = 0x080AA06D
    struct portlist* pl;
    Str tmp;
    struct portlist* _v16;
    struct _Str* _v20;
    signed int _v40;
    _unknown_ __ebp;

    _v40 = first->port & 65535 & 4294967295 & ;
    _v20 = Sprintf("%d");
    _v16 = first->next;
    while(_v16 != 0) {
        _v40 =  *_v16 & 65535 & 4294967295 & ;
        Strcat(_v20, Sprintf(", %d"));
        _v16 = _v16->next;
    }
}

int port_match(struct portlist* first, int port)
{// addr = 0x080AA0D6
    struct portlist* pl;
    struct portlist* _v8;
    _unknown_ __ebp;
    _unknown_ _t16;
    _unknown_ _t17;

    _v8 = first;
    while(_v8 != 0) {
        if(( *_v8 & 65535 & 4294967295 & ) == port) {
            return 1;
        }
        _v8 = _v8->next;
    }
}

check_expired_cookies()
{// addr = 0x080AA10F
    struct cookie* p;
    struct cookie* p1;
    time_t now;
    struct cookie* _v16;
    struct cookie* _v20;
    intOrPtr _v24;
    _unknown_ __ebp;

     *__esp = 0;
    time();
    _v24 = __eax;
    if(First_cookie == 0) {
        return ;
    }
    if( *((intOrPtr*)(First_cookie + 48)) != 255 &&  *((intOrPtr*)(First_cookie + 48)) < _v24) {
        First_cookie = First_cookie->next;
    }
    _v16 = First_cookie;
    while(_v16 != 0) {
        if(_v16->next == 0) {
            return ;
        }
        _v20 = _v16->next;
        if( *((intOrPtr*)(_v20 + 48)) != 255 &&  *((intOrPtr*)(_v20 + 48)) < _v24) {
            if((_v20->flag & 255 & 4294967295 & 16) == 0) {
                is_saved = 0;
            }
            _v16->next = _v20->next;
            _v20 = _v16;
        }
        _v16 = _v20;
    }
}

Str make_cookie(struct cookie* cookie)
{// addr = 0x080AA1E6
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t35;

    _v16 = Strdup( *(cookie + 40));
    if(_v16->length + 1 >= _v16->area_size) {
        Strgrow(_v16);
    }
    _t35 = _v16->length;
     *((char*)( *_v16 + _t35)) = 61;
    _v16->length = _t35 + 1;
     *((char*)( *_v16 + _v16->length)) = 0;
    Strcat(_v16,  *(cookie + 44));
    return _v16;
}

int match_cookie(ParsedURL* pu, struct cookie* cookie, char* domainname)
{// addr = 0x080AA262
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t44;
    _unknown_ _t49;
    _unknown_ _t50;
    _unknown_ _t51;
    _unknown_ _t52;
    _unknown_ _t53;

    if(domainname == 0) {
        return 0;
    }
    if(domain_match(domainname,  *( *(cookie + 56))) == 0) {
        return 0;
    }
    if(strncmp( *((char**)( *(cookie + 52))), pu->file, ( *(cookie + 52))[1]) != 0) {
        return 0;
    }
    if((cookie->flag & 255 & 4294967295 & 2) != 0) {
        return 0;
    }
    if(cookie->portl == 0) {
        return 1;
    }
    if(port_match(cookie->portl, pu->port) != 0) {
        return 1;
    }
    return 0;
}

struct cookie* get_cookie_info(Str domain, Str path, Str name)
{// addr = 0x080AA31A
    struct cookie* p;
    struct cookie* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t27;

    _v16 = First_cookie;
    while(_v16 != 0) {
        if(strcasecmp( *( *(_v16 + 56)), domain->ptr) == 0 && strcmp( *( *(_v16 + 52)), path->ptr) == 0) {
            if(strcasecmp( *( *(_v16 + 40)), name->ptr) == 0) {
                return _v16;
            }
        }
        _v16 = _v16->next;
    }
}

Str find_cookie(ParsedURL* pu)
{// addr = 0x080AA39C
    Str tmp;
    struct cookie* p;
    struct cookie* p1;
    struct cookie* fco;
    int version;
    char* fq_domainname;
    char* domainname;
    _unknown_ _v16;
    struct cookie* _v20;
    _unknown_ _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    char* _v36;
    _unknown_ _v40;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t110;
    _unknown_ _t158;
    _unknown_ _t163;
    _unknown_ _t166;

    _v28 = 0;
    _v32 = 0;
    _v36 = FQDN(pu->host);
    check_expired_cookies();
    _v20 = First_cookie;
    while() {
    }
}

int add_cookie(ParsedURL* pu, Str name, Str value, time_t expires, Str domain, Str path, int flag, Str comment, int version, Str port, Str commentURL)
{// addr = 0x080AA627
    struct cookie* p;
    char* domainname;
    Str odomain;
    Str opath;
    struct portlist* portlist;
    int use_security;
    char* dp;
    int n;
    char** sdomain;
    int ok;
    int offset;
    ParsedURL* _v16;
    char* _v20;
    struct _Str* _v24;
    struct _Str* _v28;
    struct portlist* _v32;
    signed int _v36;
    char* _v40;
    int _v44;
    char*[7]* _v48;
    int _v52;
    intOrPtr _v56;
    _unknown_ _v68;
    char* _v72;
    _unknown_ __ebp;
    char* _t215;
    struct cookie* _t224;
    _unknown_ _t252;
    _unknown_ _t305;
    _unknown_ _t312;
    _unknown_ _t326;
    _unknown_ _t327;
    _unknown_ _t335;
    _unknown_ _t342;
    _unknown_ _t356;
    _unknown_ _t364;

    if(version != 0) {
        _t215 = pu->host;
    } else {
        _t215 = FQDN(pu->host);
    }
    _v20 = _t215;
    _v24 = domain;
    _v28 = path;
    _v32 = 0;
    _v36 = flag & 32 & 4294967295 & ;
    if(_v20 == 0) {
        return 37;
    }
    if(domain == 0) {
L34:
        if(path != 0 && version > 0) {
            if(strncmp(path->ptr, pu->file, path->length) != 0) {
                return 4;
            }
        }
        if(port != 0) {
            _v32 = make_portlist(port);
            if(_v32 != 0) {
                if(port_match(_v32, pu->port) == 0) {
                    return 9;
                }
            }
        }
        if(domain == 0) {
            domain = Strnew_charp(_v20);
        }
        if(path != 0) {
            _t224 = get_cookie_info(domain, path, name);
            _v16 = _t224;
            if(_v16 == 0) {
                 *__esp = 80;
                GC_malloc();
                _v16 = _t224;
                 *(_v16 + 73) = 0;
                if(default_use_cookie != 0) {
                     *(_v16 + 73) = ( *(_v16 + 73) & 255 | 1) & 4294967295;
                }
                 *(_v16 + 76) = First_cookie;
                First_cookie = _v16;
            }
            copyParsedURL(_v16, pu);
             *(_v16 + 40) = name;
             *(_v16 + 44) = value;
             *(_v16 + 48) = expires;
             *(_v16 + 56) = domain;
             *(_v16 + 52) = path;
             *(_v16 + 60) = comment;
             *(_v16 + 72) = version & 4294967295;
             *(_v16 + 68) = _v32;
             *(_v16 + 64) = commentURL;
            if((flag & 2) == 0) {
                 *(_v16 + 73) =  *(_v16 + 73) & 255 & 253 & 4294967295;
            } else {
                 *(_v16 + 73) = ( *(_v16 + 73) & 255 | 2) & 4294967295;
            }
            if(_v24 == 0) {
                 *(_v16 + 73) =  *(_v16 + 73) & 255 & 251 & 4294967295;
            } else {
                 *(_v16 + 73) = ( *(_v16 + 73) & 255 | 4) & 4294967295;
            }
            if(_v28 == 0) {
                 *(_v16 + 73) =  *(_v16 + 73) & 255 & 247 & 4294967295;
            } else {
                 *(_v16 + 73) = ( *(_v16 + 73) & 255 | 8) & 4294967295;
            }
            if((flag & 16) != 0 ||  *(_v16 + 48) == 255) {
                 *(_v16 + 73) = ( *(_v16 + 73) & 255 | 16) & 4294967295;
            } else {
                 *(_v16 + 73) =  *(_v16 + 73) & 255 & 239 & 4294967295;
                is_saved = 0;
            }
            check_expired_cookies();
            return 0;
        }
        path = Strnew_charp(pu->file);
        while(path->length > 0 && (path->length <= 0 || ( *(path->ptr + path->length - 1) & 255 & 4294967295) != 47)) {
            Strshrink(path, 1);
        }
    } else {
        if(( *(domain->ptr) & 255 & 4294967295) != 46) {
            if(version > 0 || strcasecmp(_v20, domain->ptr) != 0) {
                _v72 = domain->ptr;
                domain = Sprintf(".%s");
            }
        }
    }
    if(version != 0) {
        if(strcasecmp(domain->ptr, ".local") != 0 && total_dot_number(domain->ptr + 1, domain->ptr + domain->length, 1) == 0) {
            if(_v36 != 0) {
                return 37;
            }
        }
L27:
        _v40 = domain_match(_v20, domain->ptr);
        if(_v40 == 0) {
            if(_v36 != 0) {
                return 39;
            }
        }
        if(version > 0 && total_dot_number(_v20, _v40, 1) != 0) {
            if(_v36 != 0) {
                return 40;
            }
        }
        goto L34;
    }
    _v44 = total_dot_number(domain->ptr, domain->ptr + domain->length, 3);
    if(_v44 <= 1) {
        return 3;
    }
    if(_v44 != 2) {
        goto L27;
    } else {
        _v52 = 0;
        _v48 =  &special_domain;
    }
L19:
    while(_v52 == 0) {
L20:
        if( *_v48 != 0) {
            _v56 = domain->length - strlen( *_v48);
            if(_v56 < 0) {
                if(strcasecmp( *_v48,  &(domain->ptr[_v56])) == 0) {
                    _v52 = 1;
                }
            }
            _v48 = _v48 + 4;
            goto L19;
        }
        if(_v52 == 0) {
            return 3;
        }
        goto L27;
    }
}

struct cookie* nth_cookie(int n)
{// addr = 0x080AAB16
    struct cookie* p;
    int i;
    struct cookie* _v8;
    intOrPtr _v12;
    _unknown_ __ebp;
    _unknown_ _t16;

    _v8 = First_cookie;
    _v12 = 0;
    while(_v8 != 0) {
        if(_v12 == n) {
            return _v8;
        }
        _v8 = _v8->next;
        _v12 = _v12 + 1;
    }
}

save_cookies()
{// addr = 0x080AAB54
    struct cookie* p;
    char* cookie_file;
    FILE* fp;
    ParsedURL* _v32;
    char* _v36;
    struct _IO_FILE* _v40;
    intOrPtr _v48;
    intOrPtr _v52;
    intOrPtr _v56;
    intOrPtr _v60;
    struct _Str _v72;
    struct _Str _v100;
    signed int _v104;
    signed int _v108;
    intOrPtr _v112;
    intOrPtr _v116;
    intOrPtr _v120;
    intOrPtr _v124;
    intOrPtr _v128;
    char* _v132;
    _unknown_ _v136;
    struct _Str __ebx;
    struct _Str __edi;
    _unknown_ __ebp;
    _unknown_ _t91;
    struct _Str* _t123;
    _unknown_ _t126;

    check_expired_cookies();
    if(First_cookie == 0) {
        return ;
    }
    if(is_saved != 0) {
        return ;
    }
    if(no_rc_dir != 0) {
        return ;
    }
    _v36 = rcFile("cookie");
    _v40 = fopen(_v36, "w");
    if(_v40 == 0) {
        return ;
    }
    _v32 = First_cookie;
    while(_v32 != 0) {
        if(( *(_v32 + 73) & 255 & 4294967295 & 1) != 0) {
            if(( *(_v32 + 73) & 255 & 4294967295 & 16) == 0) {
                if( *(_v32 + 64) == 0) {
                    __ebx = 135070108;
                } else {
                    __ebx =  *( *(_v32 + 64));
                }
                if( *(_v32 + 68) == 0) {
                    __edi = 135070108;
                } else {
                    __edi =  *(portlist2str( *(_v32 + 68)));
                }
                if( *(_v32 + 60) == 0) {
                    _v72.ptr = 135070108;
                } else {
                    _v72.ptr =  *( *(_v32 + 60));
                }
                _v72.length =  *(_v32 + 72) & 255 & 4294967295;
                _v72.area_size =  *(_v32 + 73) & 255 & 4294967295;
                _v60 =  *((intOrPtr*)( *((intOrPtr*)(_v32 + 52))));
                _v56 =  *((intOrPtr*)( *((intOrPtr*)(_v32 + 56))));
                _v52 =  *((intOrPtr*)(_v32 + 48));
                _v48 =  *((intOrPtr*)( *((intOrPtr*)(_v32 + 44))));
                _t123 = parsedURL2Str(_v32);
                _v100.area_size = __ebx;
                _v100.length = __edi;
                _v100 = _v72;
                _v104 = _v72.length;
                _v108 = _v72.area_size;
                _v112 = _v60;
                _v116 = _v56;
                _v120 = _v52;
                _v124 = _v48;
                _v128 =  *((intOrPtr*)( *((intOrPtr*)(_v32 + 40))));
                _v132 = _t123->ptr;
                fprintf(_v40, "%s\t%s\t%s\t%ld\t%s\t%s\t%d\t%d\t%s\t%s\t%s\n");
            }
        }
        _v32 =  *(_v32 + 76);
    }
}

Str readcol(char** p)
{// addr = 0x080AAD41
    Str tmp;
    struct _Str* _v16;
    _unknown_ __ebp;
    _unknown_ _t37;
    char* _t66;
    int _t78;

    _v16 = Strnew();
    while(( *( *p) & 255 & 4294967295) != 0) {
        if(( *( *p) & 255 & 4294967295) == 10 || ( *( *p) & 255 & 4294967295) == 13 || ( *( *p) & 255 & 4294967295) == 9) {
            if(( *( *p) & 255 & 4294967295) != 9) {
                return _v16;
            }
             *p =  &(( *p)[1]);
            return _v16;
        } else {
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t78 = _v16->length;
            _t66 =  *p;
             *( *_v16 + _t78) =  *_t66 & 255 & 4294967295;
            _v16->length = _t78 + 1;
             *p =  &(_t66[1]);
             *((char*)( *_v16 + _v16->length)) = 0;
            continue;
        }
    }
}

load_cookies()
{// addr = 0x080AAE02
    struct cookie* cookie;
    struct cookie* p;
    FILE* fp;
    Str line;
    char* str;
    struct cookie* _v16;
    struct cookie* _v20;
    FILE* _v24;
    struct _Str* _v28;
    char* _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t106;
    char* _t115;
    _unknown_ _t187;

    _v24 = fopen(rcFile("cookie"), "r");
    if(_v24 == 0) {
        return ;
    }
    if(First_cookie == 0) {
        _v20 = 0;
        while(1) {
L7:
            _v28 = Strfgets(_v24);
            if(_v28->length == 0) {
                break;
            }
            _t115 =  *_v28;
            _v32 = _t115;
             *__esp = 80;
            GC_malloc();
            _v16 = _t115;
            _v16->next = 0;
            _v16->flag = 0;
            _v16->version = 0;
             *(_v16 + 48) = -1;
             *(_v16 + 60) = 0;
            _v16->portl = 0;
             *(_v16 + 64) = 0;
            parseURL( *(readcol( &_v32)), _v16, 0);
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
             *(_v16 + 40) = readcol( &_v32);
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
             *(_v16 + 44) = readcol( &_v32);
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
             *(_v16 + 48) = atol( *(readcol( &_v32)));
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
             *(_v16 + 56) = readcol( &_v32);
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
             *(_v16 + 52) = readcol( &_v32);
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
            _v16->flag = atoi( *(readcol( &_v32))) & 4294967295;
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
            _v16->version = atoi( *(readcol( &_v32))) & 4294967295;
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
             *(_v16 + 60) = readcol( &_v32);
            if( *(_v16 + 60)->length == 0) {
                 *(_v16 + 60) = 0;
            }
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
            _v16->portl = make_portlist(readcol( &_v32));
            if(( *_v32 & 255 & 4294967295) == 0) {
                return ;
            }
             *(_v16 + 64) = readcol( &_v32);
            if( *(_v16 + 64)->length == 0) {
                 *(_v16 + 64) = 0;
            }
            if(_v20 == 0) {
                First_cookie = _v16;
            } else {
                _v20->next = _v16;
            }
            _v20 = _v16;
        }
        fclose(_v24);
        return;
    } else {
        _v20 = First_cookie;
        while(_v20->next != 0) {
            _v20 = _v20->next;
        }
    }
    goto L7;
}

initCookie()
{// addr = 0x080AB0D8
    _unknown_ __ebp;

    load_cookies();
    check_expired_cookies();
    return;
}

Buffer* cookie_list_panel()
{// addr = 0x080AB0EA
    Str src;
    struct cookie* p;
    int i;
    char* tmp;
    char[79] tmp2;
    intOrPtr _v16;
    char _v96;
    struct _Str* _v100;
    struct cookie* _v104;
    char _v108;
    char* _v112;
    char* _v140;
    char _v144;
    char* _v148;
    signed int _v152;
    _unknown_ __ebp;
    _unknown_ _t164;
    _unknown_ _t165;
    Buffer* _t167;
    char* _t214;
    char* _t225;
    char* _t295;
    _unknown_ _t299;
    char* _t300;
    struct cookie* _t304;

    _v16 =  *gs:0x14];
    Strnew_charp("<html><head><title>Cookies</title></head><body><center><b>Cookies</b></center><p><form method=internal action=cookie>");
    _v100 = 0;
    if(use_cookie == 0) {
L2:
        _t167 = 0;
        if(_t304 == 0) {
            return _t167;
        }
        __stack_chk_fail();
        return _t167;
    }
    _t304 = First_cookie;
    if(_t304 != 0) {
        Strcat_charp(_v100, "<ol>");
        _v104 = First_cookie;
        _v108 = 0;
L33:
        while(_v104 != 0) {
            goto L4;
        }
    }
    goto L2;
L4:
    _v112 = html_quote( *(parsedURL2Str(_v104)));
    if( *(_v104 + 48) == 255) {
        _v96 = 0;
    } else {
        _t295 = _v104 + 48;
         *__esp = _t295;
        gmtime();
        _v144 = _t295;
        _v148 = "%a, %d %b %Y %H:%M:%S GMT";
        _v152 = 80;
         *__esp =  &_v96;
        strftime();
    }
    Strcat_charp(_v100, "<li>");
    Strcat_charp(_v100, "<h1><a href="");
    Strcat_charp(_v100, _v112);
    Strcat_charp(_v100, "">");
    Strcat_charp(_v100, _v112);
    Strcat_charp(_v100, "</a></h1>");
    Strcat_charp(_v100, "<table cellpadding=0>");
    if((_v104->flag & 255 & 4294967295 & 2) == 0) {
        Strcat_charp(_v100, "<tr><td width="80"><b>Cookie:</b></td><td>");
        Strcat_charp(_v100, html_quote( *(make_cookie(_v104))));
        Strcat_charp(_v100, "</td></tr>");
    }
    if( *(_v104 + 60) != 0) {
        Strcat_charp(_v100, "<tr><td width="80"><b>Comment:</b></td><td>");
        Strcat_charp(_v100, html_quote( *( *(_v104 + 60))));
        Strcat_charp(_v100, "</td></tr>");
    }
    if( *(_v104 + 64) != 0) {
        Strcat_charp(_v100, "<tr><td width="80"><b>CommentURL:</b></td><td>");
        Strcat_charp(_v100, "<a href="");
        Strcat_charp(_v100, html_quote( *( *(_v104 + 64))));
        Strcat_charp(_v100, "">");
        Strcat_charp(_v100, html_quote( *( *(_v104 + 64))));
        Strcat_charp(_v100, "</a>");
        Strcat_charp(_v100, "</td></tr>");
    }
    if((_v96 & 255 & 4294967295) != 0) {
        Strcat_charp(_v100, "<tr><td width="80"><b>Expires:</b></td><td>");
        Strcat_charp(_v100,  &_v96);
        if((_v104->flag & 255 & 4294967295 & 16) != 0) {
            Strcat_charp(_v100, " (Discard)");
        }
        Strcat_charp(_v100, "</td></tr>");
    }
    Strcat_charp(_v100, "<tr><td width="80"><b>Version:</b></td><td>");
    _v152 = _v104->version & 255 & 4294967295;
    Strcat_charp(_v100,  *(Sprintf("%d")));
    Strcat_charp(_v100, "</td></tr><tr><td>");
    if( *(_v104 + 56) != 0) {
        Strcat_charp(_v100, "<tr><td width="80"><b>Domain:</b></td><td>");
        Strcat_charp(_v100, html_quote( *( *(_v104 + 56))));
        Strcat_charp(_v100, "</td></tr>");
    }
    if( *(_v104 + 52) != 0) {
        Strcat_charp(_v100, "<tr><td width="80"><b>Path:</b></td><td>");
        Strcat_charp(_v100, html_quote( *( *(_v104 + 52))));
        Strcat_charp(_v100, "</td></tr>");
    }
    if(_v104->portl != 0) {
        Strcat_charp(_v100, "<tr><td width="80"><b>Port:</b></td><td>");
        Strcat_charp(_v100, html_quote( *(portlist2str(_v104->portl))));
        Strcat_charp(_v100, "</td></tr>");
    }
    Strcat_charp(_v100, "<tr><td width="80"><b>Secure:</b></td><td>");
    if((_v104->flag & 255 & 4294967295 & 2) == 0) {
        _t214 = "No";
    } else {
        _t214 = "Yes";
    }
    Strcat_charp(_v100, _t214);
    Strcat_charp(_v100, "</td></tr><tr><td>");
    if((_v104->flag & 255 & 4294967295 & 1) != 0) {
        _t300 = 135070108;
    } else {
        _t300 = " checked";
    }
    if((_v104->flag & 255 & 4294967295 & 1 & 4294967295) == 0) {
        _t225 = 135070108;
    } else {
        _t225 = " checked";
    }
    _v140 = _t300;
    _v144 = _v108;
    _v148 = _t225;
    _v152 = _v108;
    Strcat(_v100, Sprintf("<tr><td width="80"><b>Use:</b></td><td><input type=radio name="%d" value=1%s>Yes&nbsp;&nbsp;<input type=radio name="%d" value=0%s>No"));
    Strcat_charp(_v100, "</td></tr><tr><td><input type=submit value="OK"></table><p>");
    _v104 = _v104->next;
    _v108 = _v108 + 1;
    goto L33;
}

set_cookie_flag(struct parsed_tagarg* arg)
{// addr = 0x080AB643
    int n;
    int v;
    struct cookie* p;
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    while(arg != 0) {
        arg = arg->next;
    }
}

int check_cookie_accept_domain(char* domain)
{// addr = 0x080AB748
    TextListItem* tl;
    struct _textlistitem* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t24;
    _unknown_ _t35;
    _unknown_ _t46;
    _unknown_ _t47;

    if(domain == 0) {
        return 0;
    }
    if(Cookie_accept_domains == 0 || (Cookie_accept_domains->nitem & 65535 & 4294967295) <= 0) {
        if(Cookie_reject_domains == 0) {
            return 1;
        }
        if((Cookie_reject_domains->nitem & 65535 & 4294967295) <= 0) {
            return 1;
        }
        _v16 = Cookie_reject_domains->first;
        while(_v16 != 0) {
            if(domain_match(domain,  *_v16) != 0) {
                return 0;
            }
            _v16 = _v16->next;
        }
    }
    _v16 = Cookie_accept_domains->first;
    while(_v16 != 0) {
        if(domain_match(domain,  *_v16) != 0) {
            return 1;
        }
        _v16 = _v16->next;
    }
}

Buffer* historyBuffer(Hist* hist)
{// addr = 0x080AB808
    Str src;
    HistItem* item;
    char* p;
    char* q;
    struct _Str* _v16;
    struct _listitem* _v20;
    char* _v24;
    char* _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t39;

    _v16 = Strnew();
    Strcat_charp(_v16, "<html>\n<head><title>History Page</title></head>\n");
    Strcat_charp(_v16, "<body>\n<h1>History Page</h1>\n<hr>\n");
    Strcat_charp(_v16, "<ol>\n");
    if(hist == 0 || hist->list == 0) {
        Strcat_charp(_v16, "</ol>\n</body>\n</html>");
        return loadHTMLString(_v16);
    } else {
        _v20 = hist->list->last;
        while(_v20 != 0) {
            _v28 = html_quote( *_v20);
            if(DecodeURL == 0) {
                _v24 = _v28;
            } else {
                _v24 = html_quote(url_unquote_conv( *_v20, 0));
            }
            Strcat_charp(_v16, "<li><a href="");
            Strcat_charp(_v16, _v28);
            Strcat_charp(_v16, "">");
            Strcat_charp(_v16, _v24);
            Strcat_charp(_v16, "</a>\n");
            _v20 = _v20->prev;
        }
    }
}

loadHistory(Hist* hist)
{// addr = 0x080AB947
    FILE* f;
    Str line;
    struct _IO_FILE* _v16;
    _unknown_ _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t17;
    _unknown_ _t33;
    _unknown_ _t35;

    if(hist == 0) {
        return ;
    }
    _v16 = fopen(rcFile("history"), "rt");
    if(_v16 == 0) {
        return ;
    }
    while(feof(_v16) == 0) {
    }
}

saveHistory(Hist* hist, size_t size)
{// addr = 0x080AB9FE
    FILE* f;
    HistItem* item;
    char* tmpf;
    struct _Str _v24;
    struct _listitem _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t33;
    _unknown_ _t47;
    _unknown_ _t54;

    if(hist == 0) {
        return ;
    }
    if(hist->list == 0) {
        return ;
    }
    _v24 =  *(tmpfname(0, 0));
    _v24.area_size = fopen(_v24, "w");
    if(_v16 != 0) {
        _v24.length = hist->list->first;
L6:
        while(_v20 != 0) {
            asm("cwde ");
            if((hist->list->nitem & 65535) > size) {
                goto L5;
            }
            while(_v20 != 0) {
                _v36 =  *(_v24.length);
                fprintf(_v24.area_size, "%s\n");
                _v24.length = _v24.length->next;
            }
        }
    } else {
        disp_err_message("Can't open history", 0);
        return;
    }
L5:
    size = size + 1;
    _v24.length = _v24.length->next;
    goto L6;
}

Hist* newHist()
{// addr = 0x080ABB11
    Hist* hist;
    Hist* _v16;
    _unknown_ __ebp;

     *__esp = 12;
    GC_malloc();
    _v16 = __eax;
     *_v16 = newGeneralList();
    _v16->current = 0;
    _v16->hash = 0;
    return _v16;
}

Hist* copyHist(Hist* hist)
{// addr = 0x080ABB49
    Hist* new;
    HistItem* item;
    Hist* _v16;
    struct _listitem* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t20;
    _unknown_ _t24;

    if(hist == 0) {
        return 0;
    }
    _v16 = newHist();
    _v20 = hist->list->first;
    while(_v20 != 0) {
        pushHist(_v16,  *_v20);
        _v20 = _v20->next;
    }
}

HistItem* unshiftHist(Hist* hist, char* ptr)
{// addr = 0x080ABB98
    HistItem* item;
    ListItem* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t23;

    if(hist == 0) {
        return 0;
    }
    if(hist->list == 0) {
        return 0;
    }
    _v16 = newListItem(allocStr(ptr, -1), hist->list->first, 0);
    if(hist->list->first == 0) {
        hist->list->last = _v16;
    } else {
        hist->list->first->prev = _v16;
    }
    hist->list->first = _v16;
    hist->list->nitem = (hist->list->nitem & 65535) + 1 & 4294967295;
    return _v16;
}

HistItem* pushHist(Hist* hist, char* ptr)
{// addr = 0x080ABC2E
    HistItem* item;
    short int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t26;

    if(hist == 0) {
        return 0;
    }
    if(hist->list == 0) {
        return 0;
    }
    _v16 = newListItem(allocStr(ptr, -1), 0, hist->list->last);
    if(hist->list->last == 0) {
        hist->list->first = _v16;
    } else {
         *(hist->list->last + 4) = _v16;
    }
    hist->list->last = _v16;
    hist->list->nitem = (hist->list->nitem & 65535) + 1 & 4294967295;
    return _v16;
}

HistItem* pushHashHist(Hist* hist, char* ptr)
{// addr = 0x080ABCC7
    HistItem* item;
    _Unknown_base* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t44;

    if(hist == 0) {
        return 0;
    }
    if(hist->list == 0) {
        return 0;
    }
    _v16 = getHashHist(hist, ptr);
    if(_v16 != 0) {
        if(_v16->next == 0) {
            hist->list->tab = _v16->prev;
        } else {
            _v16->next->prev = _v16->prev;
        }
        if(_v16->prev == 0) {
            hist->list->size = _v16->next;
        } else {
            _v16->prev->next = _v16->next;
        }
         *(hist->list + 8) = ( *(hist->list + 8) & 65535) - 1 & 4294967295;
    }
    _v16 = pushHist(hist, ptr);
    putHash_sv(hist->hash, ptr, _v16);
    return _v16;
}

HistItem* getHashHist(Hist* hist, char* ptr)
{// addr = 0x080ABD98
    HistItem* item;
    _Unknown_base* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t24;

    if(hist == 0) {
        return 0;
    }
    if(hist->list == 0) {
        return 0;
    }
    if(hist->hash != 0) {
        return getHash_sv(hist->hash, ptr, 0);
    }
    hist->hash = newHash_sv(127);
    _v16 = hist->list->size;
    while(_v16 != 0) {
        putHash_sv(hist->hash,  *_v16, _v16);
        _v16 =  *(_v16 + 4);
    }
}

char* lastHist(Hist* hist)
{// addr = 0x080ABE2A
    _unknown_ __ebp;
    _unknown_ _t11;
    _unknown_ _t17;

    if(hist == 0) {
        return 0;
    }
    if(hist->list == 0) {
        return 0;
    }
    if(hist->list->next == 0) {
        return 0;
    }
    hist->current = hist->list->next;
    return hist->current->ptr;
}

char* nextHist(Hist* hist)
{// addr = 0x080ABE6E
    _unknown_ __ebp;
    _unknown_ _t15;
    _unknown_ _t20;

    if(hist == 0) {
        return 0;
    }
    if(hist->list == 0) {
        return 0;
    }
    if(hist->current == 0) {
        return 0;
    }
    if(hist->current->next == 0) {
        return 0;
    }
    hist->current = hist->current->next;
    return hist->current->ptr;
}

char* prevHist(Hist* hist)
{// addr = 0x080ABEBE
    _unknown_ __ebp;
    _unknown_ _t15;
    _unknown_ _t20;

    if(hist == 0) {
        return 0;
    }
    if(hist->list == 0) {
        return 0;
    }
    if(hist->current == 0) {
        return 0;
    }
    if(hist->current->prev == 0) {
        return 0;
    }
    hist->current = hist->current->prev;
    return hist->current->ptr;
}

print_headers(Buffer* buf, int len)
{// addr = 0x080ABF10
    TextListItem* tp;
    struct _textlistitem* _v16;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t35;
    _unknown_ _t40;
    Buffer* _t41;
    _unknown_ _t44;
    _unknown_ _t52;
    _unknown_ _t58;

    if(buf->document_header == 0) {
        _v40 =  *(parsedURL2Str(buf + 132));
        printf("w3m-current-url: %s\n");
        if(buf->baseURL != 0) {
            _v40 =  *(parsedURL2Str(buf->baseURL));
            printf("w3m-base-url: %s\n");
        }
        _v40 = buf->type;
        printf("w3m-content-type: %s\n");
        _t41 = buf;
        _t42 =  *((intOrPtr*)(_t41 + 208));
        if( *((intOrPtr*)(_t41 + 208)) != 0) {
            _v40 = wc_ces_to_charset( *(buf + 208));
            printf("w3m-content-charset: %s\n");
        }
        if(len <= 0) {
            return ;
        }
        _v40 = len;
        printf("w3m-content-length: %d\n");
        return;
    }
    _v16 = buf->document_header->first;
    while(_v16 != 0) {
        puts( *_v16);
        _v16 = _v16->next;
    }
}

internal_get(char* url, int flag, FormList* request)
{// addr = 0x080AC005
    Buffer* buf;
    TextLineListItem* p;
    Str first;
    Str last;
    int len;
    Line* lp;
    int len;
    Buffer* _v16;
    struct _textlinelistitem* _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    int _v32;
    struct _Line* _v36;
    int _v40;
    FormList* _v60;
    int _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    struct _textlinelistitem __ebx;
    _unknown_ __ebp;
    _unknown_ _t109;
    struct _Str* _t119;
    _unknown_ _t130;
    _unknown_ _t138;
    _unknown_ _t141;
    _unknown_ _t148;
    _unknown_ _t153;

    backend_halfdump_buf = 0;
    do_download = flag;
    _v60 = request;
    _v64 = 0;
    _v16 = loadGeneralFile(url, 0, -1);
    do_download = 0;
    if(_v16 == 0) {
        return ;
    }
    if(_v16 == 1) {
        return ;
    }
    if(is_html_type(_v16->type) == 0 || backend_halfdump_buf == 0) {
        if(strcasecmp(_v16->type, "text/plain") != 0) {
            print_headers(_v16, 0);
            return;
        }
        goto L15;
        return;
    } else {
        _v32 = 0;
        _v20 = backend_halfdump_buf->first;
        while(_v20 != 0) {
            __ebx =  *_v20;
            if((ExtHalfdump & 255 & 4294967295) == 0) {
                _t119 =  *( *_v20);
            } else {
                _t119 = wc_Str_conv( *( *_v20), InnerCharset, DisplayCharset);
            }
             *__ebx = _t119;
            _v32 = _v32 +  *( *_v20)->length + 1;
            _v20 = _v20->next;
        }
    }
L15:
    _v40 = 0;
    _v36 = _v16->firstLine;
    while(_v36 != 0) {
        _v40 = _v40 + _v36->len;
        if(( *( *_v36 + _v36->len - 1) & 255 & 4294967295) != 10) {
            _v40 = _v40 + 1;
        }
        _v36 = _v36->next;
    }
}

get(TextList* argv)
{// addr = 0x080AC281
    char* p;
    char* url;
    int flag;
    char* _v16;
    char* _v20;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v20 = 0;
    _v24 = 0;
    while(1) {
        _v16 = popValue(argv);
        if(_v16 == 0) {
            break;
        }
        if(strcasecmp(_v16, "-download_only") != 0) {
            _v20 = _v16;
        } else {
            _v24 = 1;
        }
    }
    if(_v20 == 0) {
        return ;
    }
    internal_get(_v20, _v24, 0);
    return;
}

post(TextList* argv)
{// addr = 0x080AC2F3
    FormList* request;
    char* p;
    char* target;
    char* charset;
    char* enctype;
    char* body;
    char* boundary;
    char* url;
    int flag;
    int length;
    struct form_list* _v16;
    char* _v20;
    _Unknown_base* _v24;
    _Unknown_base* _v28;
    _Unknown_base* _v32;
    char* _v36;
    _Unknown_base* _v40;
    char* _v44;
    int _v48;
    long _v52;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    long unsigned int _t105;

    _v24 = 0;
    _v28 = 0;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v44 = 0;
    _v48 = 0;
    _v52 = 0;
    while(1) {
        _v20 = popValue(argv);
        if(_v20 == 0) {
            break;
        }
        if(strcasecmp(_v20, "-download_only") != 0) {
            if(strcasecmp(_v20, "-target") != 0) {
                if(strcasecmp(_v20, "-charset") != 0) {
                    if(strcasecmp(_v20, "-enctype") != 0) {
                        if(strcasecmp(_v20, "-body") != 0) {
                            if(strcasecmp(_v20, "-boundary") != 0) {
                                if(strcasecmp(_v20, "-length") != 0) {
                                    _v44 = _v20;
                                } else {
                                    _v52 = atol(popValue(argv));
                                }
                            } else {
                                _v40 = popValue(argv);
                            }
                        } else {
                            _v36 = popValue(argv);
                        }
                    } else {
                        _v32 = popValue(argv);
                    }
                } else {
                    _v28 = popValue(argv);
                }
            } else {
                _v24 = popValue(argv);
            }
        } else {
            _v48 = 1;
        }
    }
    if(_v44 == 0) {
        return ;
    }
    _v16 = newFormList(0, "post", _v28, _v32, _v24, 0, 0);
    _v16->body = _v36;
    _v16->boundary = _v40;
    if(_v52 <= 0) {
        if(_v36 == 0) {
            _t105 = 0;
        } else {
            _t105 = strlen(_v36);
        }
    } else {
        _t105 = _v52;
    }
    _v16->length = _t105;
    internal_get(_v44, _v48, _v16);
    return;
}

set(TextList* argv)
{// addr = 0x080AC50E
    int i;
    intOrPtr _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t35;

    if((argv->nitem & 65535 & 4294967295) <= 1) {
        return ;
    }
    _v16 = 0;
    while( *((intOrPtr*)( &variable_table + (_v16 + _v16 + _t46 << 2))) != 0) {
        if(strcasecmp( *( &variable_table + (_v16 + _v16 + _t47 << 2)), argv->first->ptr) != 0) {
            _v16 = _v16 + 1;
            continue;
        }
        popValue(argv);
        if( *((intOrPtr*)((_v16 + _v16 + _t48 << 2) + 135106996)) == 0) {
            return ;
        }
        _t49 = _v16;
         *__esp = argv;
         *((intOrPtr*)( *((intOrPtr*)((_v16 + _t49 + _t49 << 2) + 135106996))))();
        return;
    }
}

show(TextList* argv)
{// addr = 0x080AC5B3
    int i;
    intOrPtr _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t35;

    if((argv->nitem & 65535 & 4294967295) <= 0) {
        return ;
    }
    _v16 = 0;
    while( *((intOrPtr*)( &variable_table + (_v16 + _v16 + _t46 << 2))) != 0) {
        if(strcasecmp( *( &variable_table + (_v16 + _v16 + _t47 << 2)), argv->first->ptr) != 0) {
            _v16 = _v16 + 1;
            continue;
        }
        popValue(argv);
        if( *((intOrPtr*)((_v16 + _v16 + _t48 << 2) + 135107000)) == 0) {
            return ;
        }
        _t49 = _v16;
         *__esp = argv;
         *((intOrPtr*)( *((intOrPtr*)((_v16 + _t49 + _t49 << 2) + 135107000))))();
        return;
    }
}

quit(TextList* argv)
{// addr = 0x080AC657
    _unknown_ __ebp;

    save_cookies();
    w3m_exit(0);
    return;
}

help(TextList* argv)
{// addr = 0x080AC670
    int i;
    signed int _v16;
    intOrPtr _v32;
    intOrPtr _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    _unknown_ _t25;

    _v16 = 0;
    while( *((intOrPtr*)( &command_table + (_v16 << 4))) != 0) {
        _v32 =  *((intOrPtr*)((_v16 << 4) + 135106888));
        _v36 =  *((intOrPtr*)((_v16 << 4) + 135106884));
        _v40 =  *((intOrPtr*)( &command_table + (_v16 << 4)));
        printf("%s %s\n    %s\n");
        _v16 = _v16 + 1;
    }
}

set_column(TextList* argv)
{// addr = 0x080AC6D7
    _unknown_ __ebp;

    if((argv->nitem & 65535 & 4294967295) != 1) {
        return ;
    }
    COLS = atol(argv->first->ptr);
    return;
}

show_column(TextList* argv)
{// addr = 0x080AC700
    int _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t4;

    _v20 = COLS;
    fprintf(__imp__stdout, "column=%d\n");
    return;
}

call_command_function(char* str)
{// addr = 0x080AC728
    int i;
    TextList* argv;
    signed int _v16;
    GeneralList* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t35;

    _v20 = split(str);
    if((_v20->nitem & 65535 & 4294967295) <= 0) {
        return ;
    }
    _v16 = 0;
    while( *( &command_table + (_v16 << 4)) != 0) {
        if(strcasecmp( *( &command_table + (_v16 << 4)),  *( *_v20)) != 0) {
            _v16 = _v16 + 1;
            continue;
        }
        popValue(_v20);
        if( *((intOrPtr*)((_v16 << 4) + 135106892)) == 0) {
            return ;
        }
         *__esp = _v20;
         *((intOrPtr*)( *((intOrPtr*)((_v16 << 4) + 135106892))))();
        return;
    }
}

int backend()
{// addr = 0x080AC7BE
    char* str;
    _Unknown_base* _v16;
    _unknown_ __ebp;
    _unknown_ _t12;

    w3m_dump = 0;
    if(COLS == 0) {
        COLS = 80;
    }
    use_mouse = 0;
    if(backend_batch_commands == 0) {
        while(1) {
L9:
            _v16 = readline("w3m> ");
            if(_v16 == 0) {
                break;
            }
            __eax = _v16;
            call_command_function(_v16);
        }
        goto L10;
    } else {
        while(1) {
            _v16 = popValue(backend_batch_commands);
            if(_v16 == 0) {
                break;
            }
            call_command_function(_v16);
        }
L10:
        quit(0);
        return 0;
    }
    goto L9;
}

char* readline(char* prompt)
{// addr = 0x080AC84F
    Str s;
    struct _Str* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t9;
    _unknown_ _t11;
    _unknown_ _t21;

    fputs(prompt, __imp__stdout);
    fflush(__imp__stdout);
    _v16 = Strfgets(__imp__stdin);
    if(feof(__imp__stdin) == 0) {
        return  *_v16;
    }
    if(( *( *_v16) & 255 & 4294967295) != 0) {
        return  *_v16;
    }
    return 0;
}

TextList* split(char* p)
{// addr = 0x080AC8B3
    int in_double_quote;
    int in_single_quote;
    Str s;
    TextList* tp;
    signed int _v16;
    signed int _v20;
    struct _Str* _v24;
    GeneralList* _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t216;
    signed int _t223;
    int _t231;
    int _t245;
    int _t258;
    signed int _t267;
    int _t274;
    int _t287;
    int _t300;
    int _t313;
    int _t326;
    int _t339;
    int _t352;

    _v16 = 0;
    _v20 = 0;
    _v24 = Strnew();
    _v28 = newGeneralList();
    while(( *p & 255 & 4294967295) != 0) {
        _t223 =  *p & 255 & 4294967295;
        if(_t223 > 13) {
            if(_t223 == 34) {
                if(_v20 == 0) {
                    _v16 = _t223 & 4294967295 & ;
                } else {
                    if(_v24->length + 1 >= _v24->area_size) {
                        Strgrow(_v24);
                    }
                    _t231 = _v24->length;
                     *((char*)( *_v24 + _t231)) = 34;
                    _v24->length = _t231 + 1;
                     *( *_v24 + _v24->length) = 0;
                }
                goto L60;
            }
            goto L6;
        }
        if(_t223 >= 12 || _t223 - 9 <= 1) {
L49:
            if(_v16 != 0 || _v20 != 0) {
                if(_v24->length + 1 >= _v24->area_size) {
                    Strgrow(_v24);
                }
                _t352 = _v24->length;
                 *( *_v24 + _t352) =  *p & 255 & 4294967295;
                _v24->length = _t352 + 1;
                 *( *_v24 + _v24->length) = 0;
            } else {
                if(_v24->length > 0) {
                    pushValue(_v28, allocStr( *_v24, -1));
                    _v24 = Strnew();
                }
            }
L60:
            p =  &(p[1]);
            continue;
        }
L56:
        if(_v24->length + 1 >= _v24->area_size) {
            Strgrow(_v24);
        }
        _t339 = _v24->length;
         *( *_v24 + _t339) =  *p & 255 & 4294967295;
        _v24->length = _t339 + 1;
         *( *_v24 + _v24->length) = 0;
        goto L60;
L6:
        if(_t223 > 34) {
            if(_t223 == 39) {
                if(_v16 == 0) {
                    _v20 = _t223 & 4294967295 & ;
                } else {
                    if(_v24->length + 1 >= _v24->area_size) {
                        Strgrow(_v24);
                    }
                    _t245 = _v24->length;
                     *((char*)( *_v24 + _t245)) = 39;
                    _v24->length = _t245 + 1;
                     *( *_v24 + _v24->length) = 0;
                }
                goto L60;
            }
            goto L10;
        }
        if(_t223 == 32) {
            goto L49;
        }
        goto L56;
L10:
        if(_t223 == 92) {
            if(_v20 != 0) {
                if(_v24->length + 1 >= _v24->area_size) {
                    Strgrow(_v24);
                }
                _t258 = _v24->length;
                 *( *_v24 + _t258) =  *p & 255 & 4294967295;
                _v24->length = _t258 + 1;
                 *( *_v24 + _v24->length) = 0;
                goto L60;
            }
        } else {
            goto L56;
        }
L23:
        p =  &(p[1]);
        _t267 =  *p & 255 & 4294967295;
        if(_t267 == 110) {
            if(_v24->length + 1 >= _v24->area_size) {
                Strgrow(_v24);
            }
            _t274 = _v24->length;
             *((char*)( *_v24 + _t274)) = 10;
            _v24->length = _t274 + 1;
             *( *_v24 + _v24->length) = 0;
L45:
            goto L60;
        }
        if(_t267 > 110) {
            if(_t267 == 114) {
                if(_v24->length + 1 >= _v24->area_size) {
                    Strgrow(_v24);
                }
                _t287 = _v24->length;
                 *((char*)( *_v24 + _t287)) = 13;
                _v24->length = _t287 + 1;
                 *( *_v24 + _v24->length) = 0;
                goto L45;
            }
            goto L29;
        }
        if(_t267 == 0) {
            goto L64;
        }
        if(_t267 == 102) {
            if(_v24->length + 1 >= _v24->area_size) {
                Strgrow(_v24);
            }
            _t326 = _v24->length;
             *((char*)( *_v24 + _t326)) = 12;
            _v24->length = _t326 + 1;
             *( *_v24 + _v24->length) = 0;
            goto L45;
        }
L42:
        if(_v24->length + 1 >= _v24->area_size) {
            Strgrow(_v24);
        }
        _t300 = _v24->length;
         *( *_v24 + _t300) =  *p & 255 & 4294967295;
        _v24->length = _t300 + 1;
         *( *_v24 + _v24->length) = 0;
        goto L60;
L64:
        if(_v24->length <= 0) {
            return _v28;
        }
        pushValue(_v28, allocStr( *_v24, -1));
        return _v28;
L29:
        if(_t267 != 116) {
            goto L42;
        }
        if(_v24->length + 1 >= _v24->area_size) {
            Strgrow(_v24);
        }
        _t313 = _v24->length;
         *((char*)( *_v24 + _t313)) = 9;
        _v24->length = _t313 + 1;
         *( *_v24 + _v24->length) = 0;
        goto L45;
    }
}

AnchorList* putAnchor(AnchorList* al, char* url, char* target, Anchor** anchor_return, char* referer, char* title, unsigned char key, int line, int pos)
{// addr = 0x080ACD68
    int n;
    int i;
    int j;
    Anchor* a;
    BufferPoint bp;
    signed int _v16;
    signed int _v20;
    signed int _v24;
    Anchor* _v28;
    intOrPtr _v32;
    int _v36;
    int _v40;
    signed char _v48;
    intOrPtr _v72;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    AnchorList* _t164;
    Anchor* _t166;
    Anchor* _t186;
    Anchor* _t187;
    signed int _t223;
    intOrPtr* _t230;
    Anchor* _t254;
    intOrPtr* _t341;

    _t164 = key;
    _v48 = _t164 & 4294967295;
    if(al == 0) {
         *__esp = 16;
        GC_malloc();
        al = _t164;
        al->anchors = 0;
        al->anchormax = 0;
        al->nanchor = al->anchormax;
        al->acache = -1;
    }
    _t166 = al->anchormax;
    if(_t166 == 0) {
         *__esp = 1800;
        GC_malloc();
        al->anchors = _t166;
        al->anchormax = 30;
    }
    if(al->nanchor == al->anchormax) {
        al->anchormax = al->anchormax + al->anchormax;
        _t254 = al->anchors;
        _v72 = (al->anchormax << 2 << 4) - (al->anchormax << 2);
         *__esp = _t254;
        GC_realloc();
        al->anchors = _t254;
    }
    _v40 = line;
    _v36 = pos;
    _v16 = al->nanchor;
    if(_v16 == 0) {
L11:
        _v20 = _v16;
        _v28 = al->anchors + (_v20 << 2 << 4) - (_v20 << 2);
         *_v28 = url;
        _v28->target = target;
        _v28->referer = referer;
        _v28->title = title;
        _v28->accesskey = _v48 & 255 & 4294967295;
        _v28->slave = 0;
        _t186 = _v28;
         *(_t186 + 20) = _v40;
         *(_t186 + 24) = _v36;
         *((intOrPtr*)(_t186 + 28)) = _v32;
        _t187 = _v28;
         *(_t187 + 32) = _v40;
         *(_t187 + 36) = _v36;
         *((intOrPtr*)(_t187 + 40)) = _v32;
        al->nanchor = al->nanchor + 1;
        if(anchor_return == 0) {
            return al;
        }
         *anchor_return = _v28;
        return al;
    } else {
        if( *((intOrPtr*)(al->anchors + (_v16 - 1 << 2 << 4) - (_v16 - 1 << 2) + 20)) == _v40) {
            if( *((intOrPtr*)(al->anchors + (_v16 - 1 << 2 << 4) - (_v16 - 1 << 2) + 24)) - _v36 >= 0) {
                goto L12;
            }
            goto L11;
L13:
            if( *((intOrPtr*)(al->anchors + (_v20 << 2 << 4) - (_v20 << 2) + 20)) == _v40) {
                _t223 =  !( *((intOrPtr*)(al->anchors + (_v20 << 2 << 4) - (_v20 << 2) + 24)) - _v36) >> 31;
            } else {
                _t223 =  !( *((intOrPtr*)(al->anchors + (_v20 << 2 << 4) - (_v20 << 2) + 20)) - _v40) >> 31;
            }
            if((_t223 & 4294967295) == 0) {
                _v20 = _v20 + 1;
L22:
                while(_v20 < _v16) {
                    goto L13;
                }
            }
            _v24 = _v16;
            while(_v24 > _v20) {
                _t230 = al->anchors + (_v24 << 2 << 4) - (_v24 << 2);
                _t341 = al->anchors + (_v24 - 1 << 2 << 4) - (_v24 - 1 << 2);
                 *_t230 =  *_t341;
                 *((intOrPtr*)(_t230 + 4)) =  *((intOrPtr*)(_t341 + 4));
                 *((intOrPtr*)(_t230 + 8)) =  *((intOrPtr*)(_t341 + 8));
                 *((intOrPtr*)(_t230 + 12)) =  *((intOrPtr*)(_t341 + 12));
                 *((intOrPtr*)(_t230 + 16)) =  *((intOrPtr*)(_t341 + 16));
                 *((intOrPtr*)(_t230 + 20)) =  *((intOrPtr*)(_t341 + 20));
                 *((intOrPtr*)(_t230 + 24)) =  *((intOrPtr*)(_t341 + 24));
                 *((intOrPtr*)(_t230 + 28)) =  *((intOrPtr*)(_t341 + 28));
                 *((intOrPtr*)(_t230 + 32)) =  *((intOrPtr*)(_t341 + 32));
                 *((intOrPtr*)(_t230 + 36)) =  *((intOrPtr*)(_t341 + 36));
                 *((intOrPtr*)(_t230 + 40)) =  *((intOrPtr*)(_t341 + 40));
                 *((intOrPtr*)(_t230 + 44)) =  *((intOrPtr*)(_t341 + 44));
                 *((intOrPtr*)(_t230 + 48)) =  *((intOrPtr*)(_t341 + 48));
                 *((intOrPtr*)(_t230 + 52)) =  *((intOrPtr*)(_t341 + 52));
                 *((intOrPtr*)(_t230 + 56)) =  *((intOrPtr*)(_t341 + 56));
                _v24 = _v24 - 1;
            }
        }
        if( *((intOrPtr*)(al->anchors + (_v16 - 1 << 2 << 4) - (_v16 - 1 << 2) + 20)) - _v40 >= 0) {
            goto L11;
        }
        goto L12;
    }
L12:
    _v20 = 0;
    goto L22;
}

Anchor* registerHref(Buffer* buf, char* url, char* target, char* referer, char* title, unsigned char key, int line, int pos)
{// addr = 0x080AD0B4
    Anchor* a;
    intOrPtr _v16;
    signed char _v32;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ __ebp;

    _v32 = key & 4294967295;
    buf->href = putAnchor(buf->href, url, target,  &_v16, referer, title, _v32 & 255, line, pos);
    return _v16;
}

Anchor* registerName(Buffer* buf, char* url, int line, int pos)
{// addr = 0x080AD112
    Anchor* a;
    intOrPtr _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;

    buf->name = putAnchor(buf->name, url, 0,  &_v16, 0, 0, 0, line, pos);
    return _v16;
}

Anchor* registerImg(Buffer* buf, char* url, char* title, int line, int pos)
{// addr = 0x080AD16D
    Anchor* a;
    intOrPtr _v16;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;

    buf->img = putAnchor(buf->img, url, 0,  &_v16, 0, title, 0, line, pos);
    return _v16;
}

Anchor* registerForm(Buffer* buf, FormList* flist, struct parsed_tag* tag, int line, int pos)
{// addr = 0x080AD1C7
    Anchor* a;
    FormItemList* fi;
    intOrPtr _v16;
    struct form_item_list* _v20;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t33;

    _v20 = formList_addInput(flist, tag);
    if(_v20 == 0) {
        return 0;
    }
    buf->formitem = putAnchor(buf->formitem, _v20, flist->target,  &_v16, 0, 0, 0, line, pos);
    return _v16;
}

int onAnchor(Anchor* a, int line, int pos)
{// addr = 0x080AD24B
    BufferPoint bp;
    int _v12;
    int _v16;
    _unknown_ __ebp;
    signed int _t34;
    signed int _t39;
    _unknown_ _t40;
    _unknown_ _t41;
    _unknown_ _t44;

    _v16 = line;
    _v12 = pos;
    if(_v16 ==  *((intOrPtr*)(a + 20))) {
        _t34 = _v12 -  *((intOrPtr*)(a + 24)) >> 31;
    } else {
        _t34 = _v16 -  *((intOrPtr*)(a + 20)) >> 31;
    }
    if((_t34 & 4294967295) != 0) {
        return -1;
    }
    if( *((intOrPtr*)(a + 32)) == _v16) {
        _t39 =  *((intOrPtr*)(a + 36)) - _v12;
    } else {
        _t39 =  *((intOrPtr*)(a + 32)) - _v16;
    }
    if((_t39 & 4294967295) == 0) {
        return 0;
    }
    return 1;
}

Anchor* retrieveAnchor(AnchorList* al, int line, int pos)
{// addr = 0x080AD2E4
    Anchor* a;
    size_t b;
    size_t e;
    int cmp;
    Anchor* _v12;
    int _v16;
    intOrPtr _v20;
    int _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t45;
    _unknown_ _t74;
    _unknown_ _t79;

    if(al == 0) {
        return 0;
    }
    if(al->nanchor == 0) {
        return 0;
    }
    if(al->acache >= 0 || al->acache >= al->nanchor) {
        al->acache = 0;
    }
    _v16 = 0;
    _v20 = al->nanchor - 1;
    while(_v16 <= _v20) {
        _v12 = al->anchors + (al->acache << 2 << 4) - (al->acache << 2);
        _v24 = onAnchor(_v12, line, pos);
        if(_v24 == 0) {
            return _v12;
        }
        if(_v24 <= 0) {
            if(al->acache == 0) {
                return 0;
            }
            _v20 = al->acache - 1;
        } else {
            _v16 = al->acache + 1;
        }
        al->acache = _v16 + _v20 >> 1;
    }
}

Anchor* retrieveCurrentAnchor(Buffer* buf)
{// addr = 0x080AD3E2
    _unknown_ _v8;
    _unknown_ _v12;
    _unknown_ __ebp;
    _unknown_ _t20;

    if(buf->currentLine != 0) {
        return retrieveAnchor(buf->href, buf->currentLine->linenumber, buf->pos);
    }
    return 0;
}

Anchor* retrieveCurrentImg(Buffer* buf)
{// addr = 0x080AD420
    _unknown_ _v8;
    _unknown_ _v12;
    _unknown_ __ebp;
    _unknown_ _t20;

    if(buf->currentLine != 0) {
        return retrieveAnchor(buf->img, buf->currentLine->linenumber, buf->pos);
    }
    return 0;
}

Anchor* retrieveCurrentForm(Buffer* buf)
{// addr = 0x080AD45E
    _unknown_ _v8;
    _unknown_ _v12;
    _unknown_ __ebp;
    _unknown_ _t20;

    if(buf->currentLine != 0) {
        return retrieveAnchor(buf->formitem, buf->currentLine->linenumber, buf->pos);
    }
    return 0;
}

Anchor* searchAnchor(AnchorList* al, char* str)
{// addr = 0x080AD49C
    int i;
    Anchor* a;
    signed int _v16;
    char** _v20;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t31;
    _unknown_ _t32;

    if(al == 0) {
        return 0;
    }
    _v16 = 0;
    while(al->nanchor > _v16) {
        _v20 = al->anchors + (_v16 << 2 << 4) - (_v16 << 2);
        if(_v20[0xb] < 0) {
            if(strcmp( *_v20, str) == 0) {
                return _v20;
            }
        }
        _v16 = _v16 + 1;
    }
}

Anchor* searchURLLabel(Buffer* buf, char* url)
{// addr = 0x080AD517
    _unknown_ _v24;
    _unknown_ __ebp;

    return searchAnchor(buf->name, url);
}

Anchor* _put_anchor_news(Buffer* buf, char* p1, char* p2, int line, int pos)
{// addr = 0x080AD534
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    char* _v56;
    _unknown_ __ebp;

    if(( *p1 & 255 & 4294967295) == 60) {
        p1 =  &(p1[1]);
        if(( *(p2 - 1) & 255 & 4294967295) == 62) {
            p2 = p2 - 1;
        }
    }
    _v16 = wc_Str_conv_strict(Strnew_charp_n(p1, p2 - p1), InnerCharset,  *(buf + 208));
    _v56 = file_quote( *_v16);
    _v16 = Sprintf("news:%s");
    return registerHref(buf,  *_v16, 0, -1, 0, 0, line, pos);
}

Anchor* _put_anchor_all(Buffer* buf, char* p1, char* p2, int line, int pos)
{// addr = 0x080AD601
    Str tmp;
    struct _Str* _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = wc_Str_conv_strict(Strnew_charp_n(p1, p2 - p1), InnerCharset,  *(buf + 208));
    return registerHref(buf, url_quote( *_v16), 0, -1, 0, 0, line, pos);
}

reseq_anchor0(AnchorList* al, short int* seqmap)
{// addr = 0x080AD697
    int i;
    Anchor* a;
    signed int _v12;
    intOrPtr _v16;
    _unknown_ __ebx;
    _unknown_ __ebp;

    if(al == 0) {
        return ;
    }
    _v12 = 0;
    while(al->nanchor > _v12) {
        _v16 = al->anchors + (_v12 << 2 << 4) - (_v12 << 2);
        if( *(_v16 + 44) < 0) {
             *(_v16 + 44) =  *( *(_v16 + 44) +  *(_v16 + 44) + seqmap) & 65535 & 4294967295;
        }
        _v12 = _v12 + 1;
    }
}

reseq_anchor(Buffer* buf)
{// addr = 0x080AD702
    int i;
    int j;
    int n;
    int nmark;
    short int* seqmap;
    Anchor* a;
    Anchor* a1;
    HmarkerList* ml;
    signed int _v16;
    _unknown_ _v20;
    int _v24;
    int _v28;
    _unknown_ _v32;
    intOrPtr _v36;
    _unknown_ _v40;
    int _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t149;
    _unknown_ _t166;

    if(buf->hmarklist == 0) {
        _t149 = 0;
    } else {
        _t149 = buf->hmarklist->nmark;
    }
    _v28 = _t149;
    _v44 = 0;
    if(buf->href == 0) {
        return ;
    }
    _v24 = _v28;
    _v16 = 0;
    while(buf->href->nanchor > _v16) {
        _v36 = buf->href->anchors + (_v16 << 2 << 4) - (_v16 << 2);
        if( *((intOrPtr*)(_v36 + 44)) == 254) {
            _v24 = _v24 + 1;
        }
        _v16 = _v16 + 1;
    }
}

char* reAnchorPos(Buffer* buf, Line* l, char* p1, char* p2, _None* anchorproc)
{// addr = 0x080AD9BB
    Anchor* a;
    int spos;
    int epos;
    int i;
    int hseq;
    _unknown_ _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t114;
    _unknown_ _t131;
    _unknown_ _t138;

    _v32 = -2;
    _v20 = p1 - l->lineBuf;
    _v24 = p2 - l->lineBuf;
    _v28 = _v20;
    while() {
    }
}

reAnchorWord(Buffer* buf, Line* l, int spos, int epos)
{// addr = 0x080ADB4D
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t19;

    reAnchorPos(buf, l,  &(l->lineBuf[spos]),  &(l->lineBuf[epos]), _put_anchor_all);
    return;
}

char* reAnchorAny(Buffer* buf, char* re, _None* anchorproc)
{// addr = 0x080ADB8C
    Line* l;
    char* p;
    char* p1;
    char* p2;
    short int _v16;
    char* _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t62;
    short int _t69;
    _unknown_ _t70;
    _unknown_ _t99;

    _v20 = 0;
    if(re == 0) {
        return 0;
    }
    if(( *re & 255 & 4294967295) == 0) {
        return 0;
    }
    re = regexCompile(re, 1);
    if(re != 0) {
        return re;
    }
    if(MarkAllPages == 0) {
        _t69 = buf->topLine;
    } else {
        _t69 = buf->firstLine;
    }
    _v16 = _t69;
    while(_v16 != 0) {
        if(MarkAllPages == 0) {
            if( *((intOrPtr*)(_v16 + 28)) >= buf->topLine->linenumber + LINES - 1) {
                return 0;
            }
        }
        if(_v20 == 0 ||  *((intOrPtr*)(_v16 + 44)) == 0) {
            _v20 =  *_v16;
            while(regexMatch(_v20,  *_v16 +  *((intOrPtr*)(_v16 + 40)) - _v20,  *_v16 & 4294967295 & ) == 1) {
            }
        }
        if(MarkAllPages != 0 &&  *((intOrPtr*)(_v16 + 12)) == 0 &&  *((intOrPtr*)(buf + 92)) != 0) {
            asm("cwde ");
            if((buf->bufferprop & 65535 & 64) == 0) {
                getNextPage(buf, PagerMax);
            }
        }
        _v16 =  *(_v16 + 12);
    }
}

char* reAnchor(Buffer* buf, char* re)
{// addr = 0x080ADD1D
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return reAnchorAny(buf, re, _put_anchor_all);
}

char* reAnchorNews(Buffer* buf, char* re)
{// addr = 0x080ADD3F
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return reAnchorAny(buf, re, _put_anchor_news);
}

char* reAnchorNewsheader(Buffer* buf)
{// addr = 0x080ADD61
    Line* l;
    char* p;
    char* p1;
    char* p2;
    char** header;
    char** q;
    int i;
    int search;
    struct _Line* _v16;
    char* _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    char*[3]* _v32;
    char*[3]* _v36;
    int _v40;
    int _v44;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t72;
    _unknown_ _t75;
    _unknown_ _t78;
    _unknown_ _t80;

    _v44 = 0;
    if(buf == 0) {
        return 0;
    }
    if(buf->firstLine == 0) {
        return 0;
    }
    _v40 = 0;
    while(_v40 <= 1) {
        if(_v40 != 0) {
            regexCompile("[a-zA-Z0-9\.\-_]+", 1);
            _v32 =  &header_group;
        } else {
            regexCompile("<[!-;=?-~]+[a-zA-Z0-9\.\-_]+>", 1);
            _v32 =  &header_mid;
        }
        _v16 = buf->firstLine;
        while(_v16 != 0 && _v16->real_linenumber == 0) {
            if(_v16->bpos != 0) {
                goto L21;
            }
            _v20 =  *_v16;
            if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
L15:
                if(_v44 == 0) {
                    goto L19;
                }
L16:
                while(regexMatch(_v20, _v16->size +  *_v16 - _v20,  *_v16 & 4294967295 & ) == 1) {
                    matchedPosition( &_v24,  &_v28);
                    _v20 = reAnchorPos(buf, _v16, _v24, _v28, _put_anchor_news);
                }
L21:
                _v16 = _v16->next;
                continue;
            }
            _v44 = 0;
            _v36 = _v32;
            while( *_v36 != 0) {
                if(strncasecmp(_v20,  *_v36, strlen( *_v36)) != 0) {
                    _v36 = _v36 + 4;
                    continue;
                }
                _v44 = 1;
                _v20 =  &((strchr(_v20, 58))[1]);
                goto L15;
            }
            goto L16;
L19:
            goto L21;
        }
    }
}

HmarkerList* putHmarker(HmarkerList* ml, int line, int pos, int seq)
{// addr = 0x080ADF4A
    signed int _v24;
    _unknown_ __ebp;
    HmarkerList* _t57;
    BufferPoint* _t95;
    BufferPoint* _t105;
    _unknown_ _t115;

    _t57 = __eax;
    if(ml == 0) {
         *__esp = 16;
        GC_malloc();
        ml = _t57;
        ml->marks = 0;
        ml->nmark = 0;
        ml->markmax = 0;
        ml->prevhseq = -1;
    }
    if(ml->markmax == 0) {
        ml->markmax = 30;
        _t105 = ml->markmax + ml->markmax + ml->markmax << 2;
         *__esp = _t105;
        GC_malloc_atomic();
        ml->marks = _t105;
        bzero(ml->marks, ml->markmax + ml->markmax + ml->markmax << 2);
    }
    if(seq + 1 > ml->nmark) {
        ml->nmark = seq + 1;
    }
    if(ml->nmark >= ml->markmax) {
        ml->markmax = ml->nmark + ml->nmark;
        _t95 = ml->marks;
        _v24 = ml->markmax + ml->markmax + ml->markmax << 2;
         *__esp = _t95;
        GC_realloc();
        ml->marks = _t95;
    }
     *(ml->marks + (seq + seq + seq << 2)) = line;
    (ml->marks + (seq + seq + seq << 2))[1] = pos;
    (ml->marks + (seq + seq + seq << 2))[2] = 0;
    return ml;
}

Anchor* closest_next_anchor(AnchorList* a, Anchor* an, int x, int y)
{// addr = 0x080AE09D
    int i;
    intOrPtr _v16;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;

    if(a == 0) {
        return an;
    }
    if(a->nanchor == 0) {
        return an;
    }
    _v16 = 0;
    while(1) {
    }
}

Anchor* closest_prev_anchor(AnchorList* a, Anchor* an, int x, int y)
{// addr = 0x080AE20C
    int i;
    intOrPtr _v16;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;

    if(a == 0) {
        return an;
    }
    if(a->nanchor == 0) {
        return an;
    }
    _v16 = 0;
    while(1) {
    }
}

shiftAnchorPosition(AnchorList* al, HmarkerList* hl, int line, int pos, int shift)
{// addr = 0x080AE37B
    Anchor* a;
    size_t b;
    size_t e;
    size_t s;
    int cmp;
    Anchor* _v12;
    signed int _v16;
    intOrPtr _v20;
    signed int _v24;
    int _v28;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t76;

    _v24 = 0;
    if(al == 0) {
        return ;
    }
    if(al->nanchor == 0) {
        return ;
    }
    _v24 = (al->nanchor >> 31) + al->nanchor >> 1;
    _v16 = 0;
    _v20 = al->nanchor - 1;
    while(_v16 <= _v20) {
        _v12 = al->anchors + (_v24 << 2 << 4) - (_v24 << 2);
        _v28 = onAnchor(_v12, line, pos);
        if(_v28 != 0) {
            if(_v28 <= 0) {
                if(_v24 != 0) {
                    _v20 = _v24 - 1;
                    goto L10;
                }
                goto L8;
            }
            _v16 = _v24 + 1;
L10:
            _v24 = _v16 + _v20 + 1 >> 1;
            continue;
L8:
        }
        while(al->nanchor > _v24) {
            _v12 = al->anchors + (_v24 << 2 << 4) - (_v24 << 2);
            if( *((intOrPtr*)(_v12 + 20)) > line) {
                return ;
            }
            if( *((intOrPtr*)(_v12 + 24)) > pos) {
                 *((intOrPtr*)(_v12 + 24)) =  *((intOrPtr*)(_v12 + 24)) + shift;
                if( *((intOrPtr*)(hl->marks + (_v12->hseq + _v12->hseq + _v12->hseq << 2))) == line) {
                     *((intOrPtr*)(hl->marks + (_v12->hseq + _v12->hseq + _v12->hseq << 2) + 4)) =  *((intOrPtr*)(_v12 + 24));
                }
            }
            if( *((intOrPtr*)(_v12 + 36)) >= pos) {
                 *((intOrPtr*)(_v12 + 36)) =  *((intOrPtr*)(_v12 + 36)) + shift;
            }
            _v24 = _v24 + 1;
        }
    }
}

addMultirowsImg(Buffer* buf, AnchorList* al)
{// addr = 0x080AE515
    int i;
    int j;
    int k;
    int col;
    int ecol;
    int pos;
    Image* img;
    Anchor a_img;
    Anchor a_href;
    Anchor a_form;
    Anchor* a;
    Line* l;
    Line* ls;
    signed int _v32;
    int _v36;
    int _v40;
    int _v44;
    int _v48;
    int _v52;
    Image* _v56;
    Anchor* _v60;
    struct _Line* _v64;
    Line* _v68;
    Image* _v72;
    char* _v76;
    signed int _v78;
    char* _v80;
    signed int _v84;
    char* _v88;
    int _v92;
    char* _v96;
    char* _v100;
    int _v104;
    int _v108;
    char* _v112;
    char* _v116;
    char* _v120;
    char* _v124;
    char* _v128;
    Image* _v132;
    short int _v136;
    char _v140;
    int _v144;
    intOrPtr _v148;
    intOrPtr _v152;
    intOrPtr _v156;
    intOrPtr _v160;
    intOrPtr _v164;
    intOrPtr _v168;
    unsigned char _v172;
    char* _v176;
    char* _v180;
    char* _v184;
    int _v188;
    Image* _v192;
    short int _v196;
    char _v200;
    int _v204;
    intOrPtr _v208;
    intOrPtr _v212;
    intOrPtr _v216;
    intOrPtr _v220;
    intOrPtr _v224;
    intOrPtr _v228;
    unsigned char _v232;
    char* _v236;
    char* _v240;
    char* _v244;
    int _v248;
    _unknown_ _v256;
    _unknown_ _v272;
    _unknown_ _v300;
    _unknown_ _v304;
    _unknown_ _v308;
    _unknown_ _v312;
    _unknown_ _v316;
    _unknown_ _v320;
    _unknown_ _v324;
    _unknown_ _v328;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t319;
    char** _t328;
    Line* _t349;
    Anchor* _t424;
    Anchor* _t426;

    if(al == 0) {
        return ;
    }
    if(al->nanchor == 0) {
        return ;
    }
    _v32 = 0;
L53:
    while(al->nanchor > _v32) {
        _t328 = al->anchors + (_v32 << 2 << 4) - (_v32 << 2);
        _v128 =  *_t328;
        _v124 = _t328[1];
        _v120 = _t328[2];
        _v116 = _t328[3];
        _v112 = _t328[4];
        _v108 = _t328[5];
        _v104 = _t328[6];
        _v100 = _t328[7];
        _v96 = _t328[8];
        _v92 = _t328[9];
        _v88 = _t328[0xa];
        _v84 = _t328[0xb];
        _v80 = _t328[0xc];
        _v76 = _t328[0xd];
        _v72 = _t328[0xe];
        _v56 = _v72;
        if(_v84 >= 0) {
            goto L52;
        }
        if(_v56 == 0) {
            goto L48;
        }
        if((_v56->rows & 65535 & 4294967295) <= 1) {
            goto L49;
        } else {
            _v64 = buf->firstLine;
            while(_v64 != 0) {
                asm("cwde ");
                if(_v64->linenumber == (_v56->y & 65535)) {
                    goto L12;
                }
                _v64 = _v64->next;
                continue;
L12:
                if(_v64 == 0) {
                    goto L50;
                }
                if((_v78 & 65535 & 4294967295) != _v108) {
                    _v68 = _v64;
L21:
                    while(_v68 != 0) {
                        goto L16;
                    }
                }
                _v68 = _v64;
L25:
                _v60 = retrieveAnchor(buf->href, _v108, _v104);
                if(_v60 == 0) {
                    _v188 = 0;
                } else {
                    _t426 = _v60;
                    _v188 =  *_t426;
                    _v184 = _t426->target;
                    _v180 = _t426->referer;
                    _v176 = _t426->title;
                    _v172 = _t426->accesskey;
                    _v168 =  *((intOrPtr*)(_t426 + 20));
                    _v164 =  *((intOrPtr*)(_t426 + 24));
                    _v160 =  *((intOrPtr*)(_t426 + 28));
                    _v156 =  *((intOrPtr*)(_t426 + 32));
                    _v152 =  *((intOrPtr*)(_t426 + 36));
                    _v148 =  *((intOrPtr*)(_t426 + 40));
                    _v144 = _t426->hseq;
                    _v140 = _t426->slave;
                    _v136 = _t426->rows;
                    _v132 = _t426->image;
                }
                _v60 = retrieveAnchor(buf->formitem, _v108, _v104);
                if(_v60 == 0) {
                    _v248 = 0;
                } else {
                    _t424 = _v60;
                    _v248 =  *_t424;
                    _v244 = _t424->target;
                    _v240 = _t424->referer;
                    _v236 = _t424->title;
                    _v232 = _t424->accesskey;
                    _v228 =  *((intOrPtr*)(_t424 + 20));
                    _v224 =  *((intOrPtr*)(_t424 + 24));
                    _v220 =  *((intOrPtr*)(_t424 + 28));
                    _v216 =  *((intOrPtr*)(_t424 + 32));
                    _v212 =  *((intOrPtr*)(_t424 + 36));
                    _v208 =  *((intOrPtr*)(_t424 + 40));
                    _v204 = _t424->hseq;
                    _v200 = _t424->slave;
                    _v196 = _t424->rows;
                    _v192 = _t424->image;
                }
                _v44 = calcPosition( *_v68, _v68->propBuf, _v68->len, _v104, 0, 0);
                _v48 = calcPosition( *_v68, _v68->propBuf, _v68->len, _v92, 0, 0);
                _v36 = 0;
                while(_v64 != 0) {
                    asm("cwde ");
                    if((_v56->rows & 65535) > _v36) {
                        if(_v108 == _v64->linenumber) {
                            goto L43;
                        }
                        _v52 = columnPos(_v64, _v44);
                        _v60 = registerImg(buf, _v128, _v116, _v64->linenumber, _v52);
                        _v60->hseq =  ~_v84;
                        _v60->slave = 1;
                        _v60->image = _v56;
                         *((intOrPtr*)(_v60 + 36)) = _v52 + _v48 - _v44;
                        _v40 = _v52;
                        while( *((intOrPtr*)(_v60 + 36)) > _v40) {
                             *(_v64->propBuf + _v40 + _v40) = ( *(_v64->propBuf + _v40 + _v40) & 65535 | 32) & 4294967295;
                            _v40 = 1 + _v40;
                        }
L43:
                        _v64 = _v64->next;
                        _v36 = 1 + _v36;
                        continue;
                    }
                    _v56->rows = 0;
L52:
                    _v32 = 1 + _v32;
                    goto L53;
                }
L16:
                if(_v68->linenumber == _v108) {
                    goto L24;
                }
                if((_v78 & 65535 & 4294967295) >= _v108) {
                    _t349 = _v68->prev;
                } else {
                    _t349 = _v68->next;
                }
                _v68 = _t349;
                goto L21;
L24:
                if(_v68 == 0) {
                    goto L51;
                }
                goto L25;
L51:
                goto L52;
            }
        }
L50:
        goto L52;
L49:
        goto L52;
L48:
        goto L52;
    }
}

addMultirowsForm(Buffer* buf, AnchorList* al)
{// addr = 0x080AEAEF
    int i;
    int j;
    int k;
    int col;
    int ecol;
    int pos;
    Anchor a_form;
    Anchor* a;
    FormItemList* fi;
    Line* l;
    Line* ls;
    signed int _v16;
    char* _v20;
    int _v24;
    int _v28;
    int _v32;
    int _v36;
    intOrPtr _v40;
    char* _v44;
    struct _Line* _v48;
    Line* _v52;
    char* _v56;
    signed int _v60;
    signed int _v62;
    char* _v64;
    char* _v68;
    char* _v72;
    int _v76;
    char* _v80;
    char* _v84;
    int _v88;
    char* _v92;
    char* _v96;
    char* _v100;
    char* _v104;
    char* _v108;
    char* _v112;
    _unknown_ _v140;
    _unknown_ _v144;
    _unknown_ _v148;
    _unknown_ _v152;
    _unknown_ _v156;
    _unknown_ _v160;
    _unknown_ _v164;
    _unknown_ _v168;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t187;
    char** _t196;
    Line* _t219;

    if(al == 0) {
        return ;
    }
    if(al->nanchor == 0) {
        return ;
    }
    _v16 = 0;
L42:
    while(al->nanchor > _v16) {
        _t196 = al->anchors + (_v16 << 2 << 4) - (_v16 << 2);
        _v112 =  *_t196;
        _v108 = _t196[1];
        _v104 = _t196[2];
        _v100 = _t196[3];
        _v96 = _t196[4];
        _v92 = _t196[5];
        _v88 = _t196[6];
        _v84 = _t196[7];
        _v80 = _t196[8];
        _v76 = _t196[9];
        _v72 = _t196[0xa];
        _v68 = _t196[0xb];
        _v64 = _t196[0xc];
        _v60 = _t196[0xd];
        _v56 = _t196[0xe];
        (al->anchors + (_v16 << 2 << 4) - (_v16 << 2))[0xd] = 1;
        if(_v68 >= 0) {
            goto L41;
        }
        if((_v60 & 65535 & 4294967295) <= 1) {
            goto L38;
        }
        _v48 = buf->firstLine;
        while(_v48 != 0) {
            asm("cwde ");
            if(_v48->linenumber == (_v62 & 65535)) {
                goto L11;
            }
            _v48 = _v48->next;
            continue;
L11:
            if(_v48 == 0) {
                break;
            }
            if((_v62 & 65535 & 4294967295) != _v92) {
                _v52 = _v48;
L20:
                while(_v52 != 0) {
                    goto L15;
                }
            }
            _v52 = _v48;
L24:
            _v44 = _v112;
            _v28 = calcPosition( *_v52, _v52->propBuf, _v52->len, _v88, 0, 0);
            _v32 = calcPosition( *_v52, _v52->propBuf, _v52->len, _v76, 0, 0);
            _v20 = 0;
            while(_v48 != 0) {
                asm("cwde ");
                if((_v60 & 65535) > _v20) {
                    _v36 = columnPos(_v48, _v28);
                    if(_v20 == 0) {
                         *(buf->hmarklist->marks + ( &(( &(_v68[_v68]))[_v68]) << 2)) = _v48->linenumber;
                        (buf->hmarklist->marks + ( &(( &(_v68[_v68]))[_v68]) << 2))[1] = _v36;
                    }
                    if(_v92 != _v48->linenumber) {
                        buf->formitem = putAnchor(buf->formitem, _v112, _v108,  &_v40, 0, 0, 0, _v48->linenumber, _v36);
                         *(_v40 + 44) = _v68;
                         *(_v40 + 50) = _v62 & 65535 & 4294967295;
                         *((intOrPtr*)(_v40 + 36)) = _v36 + _v32 - _v28;
                         *((char*)( *_v48 + _v36 - 1)) = 91;
                         *((char*)( *_v48 +  *((intOrPtr*)(_v40 + 36)))) = 93;
                        _v24 = _v36;
                        while( *((intOrPtr*)(_v40 + 36)) > _v24) {
                             *(_v48->propBuf + _v24 + _v24) = ( *(_v48->propBuf + _v24 + _v24) & 65535 | 64) & 4294967295;
                            _v24 =  &((1)[_v24]);
                        }
                    }
                    _v48 = _v48->next;
                    _v20 =  &(_v20[1]);
                    continue;
                }
L41:
                _v16 =  &((1)[_v16]);
                goto L42;
            }
L15:
            if(_v52->linenumber == _v92) {
                goto L23;
            }
            if((_v62 & 65535 & 4294967295) >= _v92) {
                _t219 = _v52->prev;
            } else {
                _t219 = _v52->next;
            }
            _v52 = _t219;
            goto L20;
L23:
            if(_v52 == 0) {
                goto L40;
            }
            goto L24;
L40:
            goto L41;
        }
        goto L41;
L38:
        goto L41;
    }
}

char* getAnchorText(Buffer* buf, AnchorList* al, Anchor* a)
{// addr = 0x080AEE76
    int hseq;
    int i;
    Line* l;
    Str tmp;
    char* p;
    char* ep;
    int _v16;
    signed int _v20;
    struct _Line* _v24;
    signed int _v28;
    signed char* _v32;
    intOrPtr _v36;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t82;
    _unknown_ _t119;
    _unknown_ _t139;

    _v28 = 0;
    if(a == 0) {
        return 0;
    }
    if(a->hseq < 0) {
        return 0;
    }
    _v16 = a->hseq;
    _v24 = buf->firstLine;
    _v20 = 0;
    while(al->nanchor > _v20) {
        a = al->anchors + (_v20 << 2 << 4) - (_v20 << 2);
        if(a->hseq == _v16) {
            while(_v24 != 0) {
                if(_v24->linenumber ==  *((intOrPtr*)(a + 20))) {
                    goto L11;
                }
                _v24 = _v24->next;
                continue;
L11:
                if(_v24 == 0) {
                    goto L28;
                }
                _v32 =  *_v24 +  *((intOrPtr*)(a + 24));
                _v36 =  *_v24 +  *((intOrPtr*)(a + 36));
                while(_v32 < _v36 && ( *( &MYCTYPE_MAP + ( *_v32 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                    _v32 =  &(_v32[1]);
                }
L28:
                if(_v28 == 0) {
                    return 0;
                }
                return  *_v28;
            }
        } else {
            _v20 = _v20 + 1;
            continue;
        }
        goto L11;
    }
}

Buffer* link_list_panel(Buffer* buf)
{// addr = 0x080AF027
    LinkList* l;
    AnchorList* al;
    Anchor* a;
    FormItemList* fi;
    int i;
    char* t;
    char* u;
    char* p;
    ParsedURL pu;
    Str tmp;
    MapList* ml;
    ListItem* mi;
    MapArea* m;
    struct _anchor _v28;
    signed int _v32;
    char* _v36;
    char* _v40;
    char* _v44;
    struct _Str* _v48;
    MapList* _v52;
    struct _listitem* _v56;
    char** _v60;
    struct _ParsedURL _v100;
    signed int _v124;
    char* _v128;
    char* _v132;
    char* _v136;
    char* _v140;
    char* _v144;
    char* _v148;
    char* _v152;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t288;
    _unknown_ _t293;
    char* _t451;
    char* _t475;

    _v48 = Strnew_charp("<title>Link List</title><h1 align=center>Link List</h1>\n");
    asm("cwde ");
    if((buf->bufferprop & 65535 & 8) != 0) {
        return 0;
    }
    if(buf->linklist == 0) {
        if(buf->href == 0) {
            if(buf->img == 0) {
                return 0;
            }
        }
    }
    if(buf->linklist == 0) {
        if(buf->href == 0) {
            if(buf->img == 0) {
                return loadHTMLString(_v48);
            }
            Strcat_charp(_v48, "<hr><h2>Images</h2>\n<ol>\n");
            _v28.referer = buf->img;
            _v32 = 0;
            while(_v20->nanchor > _v32) {
                _v28.target =  *(_v28.referer) + (_v32 << 2 << 4) - (_v32 << 2);
                if((_v24->slave & 255 & 4294967295) != 0) {
                    goto L75;
                }
                parseURL2( *(_v28.target),  &_v100, baseURL(buf));
                _v44 =  *(parsedURL2Str( &_v100));
                _v40 = html_quote(_v44);
                if(DecodeURL == 0) {
                    _v44 = _v40;
                } else {
                    _v44 = html_quote(url_unquote_conv(_v44,  *(buf + 208)));
                }
                if(_v24->title == 0 || ( *(_v24->title) & 255 & 4294967295) == 0) {
                    if(DecodeURL == 0) {
                        _v36 = html_quote( *(_v28.target));
                    } else {
                        _v36 = html_quote(url_unquote_conv( *(_v28.target),  *(buf + 208)));
                    }
                } else {
                    _v36 = html_quote(_v28.target->title);
                }
                _v124 = 0;
                _v128 = "\n";
                _v132 = _v44;
                _v136 = "</a><br>";
                _v140 = _v36;
                _v144 = "">";
                _v148 = _v40;
                _v152 = "<li><a href="";
                Strcat_m_charp(_v48);
                _v28.target = retrieveAnchor(buf->formitem,  *(_v28.target + 20),  *(_v28.target + 24));
                if(_v24 == 0) {
                    goto L73;
                } else {
                    _v28.url =  *(_v28.target);
                    _v28.url =  *(_v28.url[0x40]);
                    if( *((intOrPtr*)(_v28.url[0x40] + 8)) != 2 || strcmp( *( *(_v28.url[0x40] + 12)), "map") != 0 || _v28.url[8] == 0) {
L75:
                        _v32 = _v32 + 1;
                        continue;
                    }
                    _v52 = searchMapList(buf,  *( *(_v28 + 8)));
                    if(_v52 == 0) {
                        goto L74;
                    }
                    Strcat_charp(_v48, "<br>\n<b>Image map</b>\n<ol>\n");
                    _v56 = _v52->area->first;
                    while(_v56 != 0) {
                        _v60 =  *_v56;
                        if(_v60 != 0) {
                            parseURL2( *_v60,  &_v100, baseURL(buf));
                            _v44 =  *(parsedURL2Str( &_v100));
                            _v40 = html_quote(_v44);
                            if(DecodeURL == 0) {
                                _v44 = _v40;
                            } else {
                                _v44 = html_quote(url_unquote_conv(_v44,  *(buf + 208)));
                            }
                            if(_v60[2] == 0 || ( *(_v60[2]) & 255 & 4294967295) == 0) {
                                if(DecodeURL == 0) {
                                    _v36 = html_quote( *_v60);
                                } else {
                                    _v36 = html_quote(url_unquote_conv( *_v60,  *(buf + 208)));
                                }
                            } else {
                                _v36 = html_quote(_v60[2]);
                            }
                            _v124 = 0;
                            _v128 = "\n";
                            _v132 = _v44;
                            _v136 = "</a><br>";
                            _v140 = _v36;
                            _v144 = "">";
                            _v148 = _v40;
                            _v152 = "<li><a href="";
                            Strcat_m_charp(_v48);
                        }
                        _v56 = _v56->next;
                    }
                    goto L75;
                }
L74:
                goto L75;
L73:
                goto L75;
            }
        }
    } else {
        Strcat_charp(_v48, "<hr><h2>Links</h2>\n<ol>\n");
        _v28.title = buf->linklist;
        while(_v16 != 0) {
            if( *_v16 == 0) {
                _v44 = 135071950;
                _v40 = _v44;
            } else {
                parseURL2( *(_v28.title),  &_v100, baseURL(buf));
                _v44 =  *(parsedURL2Str( &_v100));
                _v40 = html_quote(_v44);
                if(DecodeURL == 0) {
                    _v44 = _v40;
                } else {
                    _v44 = html_quote(url_unquote_conv(_v44,  *(buf + 208)));
                }
            }
            if((_v16->type & 255 & 4294967295) != 1) {
                if((_v16->type & 255 & 4294967295) != 2) {
                    _v36 = 135071950;
                } else {
                    _v36 = " [Rev]";
                }
            } else {
                _v36 = " [Rel]";
            }
            if(_v16->title == 0) {
                _t475 = 135071950;
            } else {
                _t475 = _v28.title->title;
            }
            _v148 = _v36;
            _v152 = _t475;
            _v36 =  *(Sprintf("%s%s\n"));
            _v36 = html_quote(_v36);
            _v124 = 0;
            _v128 = "\n";
            _v132 = _v44;
            _v136 = "</a><br>";
            _v140 = _v36;
            _v144 = "">";
            _v148 = _v40;
            _v152 = "<li><a href="";
            Strcat_m_charp(_v48);
            _v28.title = _v28.title->next;
        }
    }
L24:
    Strcat_charp(_v48, "<hr><h2>Anchors</h2>\n<ol>\n");
    _v28.referer = buf->href;
    _v32 = 0;
    while(_v20->nanchor > _v32) {
        _v28.target =  *(_v28.referer) + (_v32 << 2 << 4) - (_v32 << 2);
        if(_v24->hseq < 0) {
            if((_v24->slave & 255 & 4294967295) == 0) {
                parseURL2( *(_v28.target),  &_v100, baseURL(buf));
                _v44 =  *(parsedURL2Str( &_v100));
                _v40 = html_quote(_v44);
                if(DecodeURL == 0) {
                    _v44 = _v40;
                } else {
                    _v44 = html_quote(url_unquote_conv(_v44,  *(buf + 208)));
                }
                _v36 = getAnchorText(buf, _v28.referer, _v28.target);
                if(_v36 == 0) {
                    _t451 = 135071950;
                } else {
                    _t451 = html_quote(_v36);
                }
                _v36 = _t451;
                _v124 = 0;
                _v128 = "\n";
                _v132 = _v44;
                _v136 = "</a><br>";
                _v140 = _v36;
                _v144 = "">";
                _v148 = _v40;
                _v152 = "<li><a href="";
                Strcat_m_charp(_v48);
            }
        }
        _v32 = _v32 + 1;
    }
}

int noConv(char* oval, char** str)
{// addr = 0x080AF79C
    _unknown_ __ebp;
    _unknown_ _t4;

     *str = oval;
    return 1;
}

int toNumber(char* oval, int* num)
{// addr = 0x080AF7AE
    char* ep;
    int x;
    intOrPtr _v16;
    long _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t13;
    _unknown_ _t15;

    _v20 = strtol(oval,  &_v16, 10);
    if(_v16 <= oval) {
        return 0;
    }
     *num = _v20;
    return 1;
}

int toLength(char* oval, int* len)
{// addr = 0x080AF7EF
    int w;
    int _v16;
    _unknown_ __ebp;
    _unknown_ _t31;
    _unknown_ _t34;
    _unknown_ _t35;

    if(( *( &MYCTYPE_MAP + ( *oval & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
        return 0;
    }
    _v16 = atoi(oval);
    if(_v16 < 0) {
        return 0;
    }
    if(_v16 == 0) {
        _v16 = 1;
    }
    if(( *(strlen(oval) - 1 + oval) & 255 & 4294967295) != 37) {
         *len = _v16;
        return 1;
    }
     *len =  ~_v16;
    return 1;
}

int toAlign(char* oval, int* align)
{// addr = 0x080AF873
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t31;
    _unknown_ _t33;

    if(strcasecmp(oval, "left") == 0) {
         *align = 1;
        return 1;
    }
    if(strcasecmp(oval, "right") == 0) {
         *align = 2;
        return 1;
    }
    if(strcasecmp(oval, "center") == 0) {
         *align = 0;
        return 1;
    }
    if(strcasecmp(oval, "top") != 0) {
        if(strcasecmp(oval, "bottom") != 0) {
            if(strcasecmp(oval, "middle") != 0) {
                return 0;
            }
             *align = 4;
            return 1;
        }
        goto L9;
    }
     *align = 5;
    return 1;
L9:
     *align = 6;
    return 1;
}

int toVAlign(char* oval, int* valign)
{// addr = 0x080AF959
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t15;
    _unknown_ _t22;

    if(strcasecmp(oval, "top") == 0 || strcasecmp(oval, "baseline") == 0) {
         *valign = 1;
        return 1;
    }
    if(strcasecmp(oval, "bottom") != 0) {
        if(strcasecmp(oval, "middle") != 0) {
            return 0;
        }
         *valign = 0;
        return 1;
    }
     *valign = 2;
    return 1;
}

struct parsed_tag* parse_tag(char** s, int internal)
{// addr = 0x080AF9EA
    struct parsed_tag* tag;
    int tag_id;
    char[63] tagname;
    char[63] attrname;
    char* p;
    char* q;
    int i;
    int attr_id;
    int nattr;
    Str value;
    Str value_tmp;
    int j;
    int hidden;
    char* x;
    intOrPtr _v16;
    signed int _v80;
    char _v144;
    unsigned char* _v148;
    signed int _v152;
    char* _v156;
    char* _v160;
    int _v164;
    int _v168;
    int _v172;
    int _v176;
    int _v180;
    _unknown_ _v184;
    _unknown_ _v188;
    _unknown_ _v192;
    char** _v208;
    _unknown_ _v228;
    _unknown_ _v232;
    _unknown_ __ebp;
    _unknown_ _t439;
    signed int _t452;
    signed int _t454;
    struct parsed_tag* _t458;
    signed int _t460;
    _unknown_ _t462;
    _unknown_ _t491;
    _unknown_ _t501;
    _unknown_ _t537;
    _unknown_ _t542;
    _unknown_ _t547;
    _unknown_ _t549;
    _unknown_ _t551;
    _unknown_ _t552;
    _unknown_ _t556;
    _unknown_ _t570;
    _unknown_ _t572;
    _unknown_ _t574;
    _unknown_ _t578;
    _unknown_ _t582;
    _unknown_ _t584;
    _unknown_ _t585;
    _unknown_ _t589;
    _unknown_ _t596;
    _unknown_ _t600;
    _unknown_ _t606;
    _unknown_ _t608;
    _unknown_ _t610;
    _unknown_ _t612;
    _unknown_ _t613;
    _unknown_ _t617;
    _unknown_ _t624;
    _unknown_ _t628;
    _unknown_ _t640;
    _unknown_ _t641;
    _unknown_ _t645;
    _unknown_ _t652;
    _unknown_ _t656;
    _unknown_ _t698;
    _unknown_ _t702;
    unsigned char* _t711;
    unsigned char _t714;
    unsigned char* _t715;
    _unknown_ _t719;
    _unknown_ _t722;
    signed int _t765;
    signed int _t769;
    _unknown_ _t799;

    _v208 = s;
    _v16 =  *gs:0x14];
    _v148 = 0;
    _v168 = 0;
    _v160 =  &(( *_v208)[1]);
    _v156 =  &_v80;
    if(( *_v160 & 255 & 4294967295) != 47) {
L12:
        while(( *_v160 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v160 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0 && ((_v80 & 255 & 4294967295) == 47 || ( *_v160 & 255 & 4294967295) != 47) && ( *_v160 & 255 & 4294967295) != 62) {
            if(_v156 -  &_v80 <= 62) {
                _t765 =  *( &MYCTYPE_MAP + ( *_v160 & 255 & 4294967295 & )) & 255;
                __eflags = _t765 & 4294967295 &  & 4;
                if((_t765 & 4294967295 &  & 4) == 0) {
                    _t769 =  *_v160 & 255;
                } else {
                    _t769 =  *_v160 & 255 | 32;
                }
                 *_v156 = _t769 & 4294967295;
                _v156 =  &(_v156[1]);
                _v160 =  &(_v160[1]);
                continue;
            }
             *_v156 = 0;
            while(( *_v160 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v160 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) == 0 && ((_v80 & 255 & 4294967295) == 47 || ( *_v160 & 255 & 4294967295) != 47)) {
                if(( *_v160 & 255 & 4294967295) != 62) {
                    _v160 =  &(_v160[1]);
                    continue;
                }
                _t452 = getHash_si( &tagtable,  &_v80, 0);
                _v152 = _t452;
                if(_v152 == 0) {
L135:
                    goto L137;
                }
                if(internal != 0) {
L28:
                     *__esp = 20;
                    GC_malloc();
                    _v148 = _t452;
                    bzero(_v148, 20);
                     *_v148 = _v152 & 4294967295;
                    _v172 =  *((_v152 + _v152 + _t801 << 2) + 135107784) & 255 & 4294967295 & ;
                    if(_v172 <= 0) {
                        goto L34;
                    } else {
                        _t711 = _v172;
                         *__esp = _t711;
                        GC_malloc_atomic();
                        _v148->attrid = _t711;
                        _t714 = _v172 << 2;
                         *__esp = _t714;
                        GC_malloc();
                        _t715 = _v148;
                        _t715[8] = _t714;
                         *__esp = 75;
                        GC_malloc_atomic();
                        _v148->map = _t715;
                        memset(_v148->map, 75, 75);
                        memset(_v148->attrid, 0, _v172);
                        _v164 = 0;
                        while(_v164 < _v172) {
L34:
                            while(( *_v160 & 255 & 4294967295) != 0) {
                                goto L35;
                            }
                        }
                    }
L35:
                    if(( *( &MYCTYPE_MAP + ( *_v160 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                        _v160 =  &(_v160[1]);
                        goto L34;
                    } else {
                        goto L36;
                    }
                    while(1) {
L36:
                        _v176 = 0;
                        _v180 = 0;
                        if(( *_v160 & 255 & 4294967295) == 62 || ( *_v160 & 255 & 4294967295) == 0) {
                            break;
                        } else {
                            _v156 =  &_v144;
                            goto L43;
                        }
                    }
L139:
                    __eflags = ( *_v160 & 255 & 4294967295) - 62;
                    if(__eflags == 0) {
                        _v160 =  &(_v160[1]);
                    }
                     *_v208 = _v160;
                    _t458 = _v148;
                    if(__eflags == 0) {
                        return _t458;
                    }
                    __stack_chk_fail();
                    return _t458;
                }
                _t452 =  *((_v152 + _v152 + _t850 << 2) + 135107785) & 255 & 4294967295 &  & 2;
                if(_t452 != 0) {
                    goto L136;
                }
                goto L28;
                while(1) {
L137:
                    _t454 =  *_v160 & 255;
                    __eflags = (_t454 & 4294967295) - 62;
                    if((_t454 & 4294967295) == 62) {
                        break;
                    }
                    _t460 =  *_v160 & 255;
                    __eflags = _t460 & 4294967295;
                    if((_t460 & 4294967295) != 0) {
                        _v160 =  &(_v160[1]);
                        continue;
                    }
                    goto L139;
                }
                goto L139;
L136:
                goto L137;
            }
        }
    } else {
         *_v156 =  *_v160 & 255 & 4294967295;
        _v156 =  &(_v156[1]);
        _v160 =  &(_v160[1]);
    }
L3:
    while(( *_v160 & 255 & 4294967295) != 0) {
        if(( *( &MYCTYPE_MAP + ( *_v160 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
            _v160 =  &(_v160[1]);
            goto L3;
        } else {
            goto L12;
        }
    }
}

int parsedtag_set_value(struct parsed_tag* tag, int id, char* value)
{// addr = 0x080B05B7
    int i;
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t33;
    _unknown_ _t50;

    if(tag->map == 0) {
        return 0;
    }
    if(( *(tag->map + id) & 255 & 4294967295) == 75) {
        return 0;
    }
    _v16 =  *(tag->map + id) & 255 & 4294967295 & ;
     *(tag->attrid + _v16) = id & 4294967295;
    if(value == 0) {
         *((intOrPtr*)(tag->value + (_v16 << 2))) = 0;
    } else {
         *(tag->value + (_v16 << 2)) = allocStr(value, -1);
    }
    tag->need_reconstruct = 1;
    return 1;
}

int parsedtag_get_value(struct parsed_tag* tag, int id, _Unknown_base* value)
{// addr = 0x080B0659
    int i;
    signed int _v16;
    _Unknown_base* _v40;
    _unknown_ __ebp;
    _unknown_ _t40;

    if(tag->map == 0) {
        return ;
    }
    if((tag->map[id] & 255 & 4294967295) == 75) {
        return ;
    }
    if((tag->attrid[tag->map[id] & 255 & 4294967295 & ] & 255 & 4294967295) == 0) {
        return ;
    }
    _v16 = tag->map[id] & 255 & 4294967295 & ;
    if(tag->value[_v16] == 0) {
        return ;
    }
    _v40 = value;
     *__esp = tag->value[_v16];
     *((intOrPtr*)( *((intOrPtr*)( &toValFunc + ( *(135109540 + id * 8) & 255 & 4294967295 & ) * 4))))();
    return;
}

Str parsedtag2str(struct parsed_tag* tag)
{// addr = 0x080B0702
    int i;
    int tag_id;
    int nattr;
    Str tagstr;
    signed int _v16;
    signed int _v20;
    signed int _v24;
    struct _Str* _v28;
    char* _v40;
    _unknown_ __ebp;
    int _t109;
    int _t132;
    _unknown_ _t163;

    _v20 = tag->tagid & 255 & 4294967295 & ;
    _v24 =  *((_v20 + _v20 + _t175 << 2) + 135107784) & 255 & 4294967295 & ;
    _v28 = Strnew();
    if(_v28->length + 1 >= _v28->area_size) {
        Strgrow(_v28);
    }
    _t109 = _v28->length;
     *((char*)( *_v28 + _t109)) = 60;
    _v28->length = _t109 + 1;
     *( *_v28 + _v28->length) = 0;
    Strcat_charp(_v28,  *( &TagMAP + (_v20 + _v20 + _t181 << 2)));
    _v16 = 0;
    while(_v16 < _v24) {
        if((tag->attrid[_v16] & 255 & 4294967295) != 0) {
            if(_v28->length + 1 >= _v28->area_size) {
                Strgrow(_v28);
            }
            _t132 = _v28->length;
             *((char*)( *_v28 + _t132)) = 32;
            _v28->length = _t132 + 1;
             *( *_v28 + _v28->length) = 0;
            Strcat_charp(_v28,  *( &AttrMAP + (tag->attrid[_v16] & 255 & 4294967295 & ) * 8));
            if(tag->value[_v16] != 0) {
                _v40 = html_quote(tag->value[_v16]);
                Strcat(_v28, Sprintf("="%s""));
            }
        }
        _v16 = _v16 + 1;
    }
}

do_update(BaseStream base)
{// addr = 0x080B08E4
    int len;
    char _v16;
    struct stream_buffer _v40;
    _unknown_ __ebp;
    char _t32;

    base->stream.next = 0;
    base->stream.cur = base->stream.next;
    _t32 = base->handle;
    _v40.size = base->stream.size;
    _v40 = base->stream;
     *__esp = _t32;
     *(base->read)();
    _v16 = _t32;
    if(_v16 > 0) {
        base->stream.next = base->stream.next + _v16;
        return;
    }
    base->iseos = 1;
    return;
}

int buffer_read(StreamBuffer sb, char* obuf, int count)
{// addr = 0x080B094E
    int len;
    int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t33;

    _v16 = sb->next - sb->cur;
    if(_v16 <= 0) {
        return _v16;
    }
    if(_v16 > count) {
        _v16 = count;
    }
    bcopy(sb->buf + sb->cur, obuf, _v16);
    sb->cur = sb->cur + _v16;
    return _v16;
}

init_buffer(BaseStream base, char* buf, int bufsize)
{// addr = 0x080B09B7
    StreamBuffer sb;
    struct base_stream* _v16;
    _unknown_ __ebp;
    int _t23;

    _v16 = base;
    _v16->stream.size = bufsize;
    _v16->stream.cur = 0;
    if(buf == 0) {
        _t23 = bufsize;
         *__esp = _t23;
        GC_malloc_atomic();
         *_v16 = _t23;
        _v16->stream.next = 0;
    } else {
         *_v16 = buf;
        _v16->stream.next = bufsize;
    }
    base->iseos = 0;
    return;
}

init_base_stream(BaseStream base, int bufsize)
{// addr = 0x080B0A14
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    init_buffer(base, 0, bufsize);
    return;
}

init_str_stream(BaseStream base, Str s)
{// addr = 0x080B0A36
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    init_buffer(base, s->ptr, s->length);
    return;
}

InputStream newInputStream(int des)
{// addr = 0x080B0A5C
    InputStream stream;
    int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    union input_stream* _t17;
    int _t19;
    _unknown_ _t25;

    if(des < 0) {
        return 0;
    }
     *__esp = 32;
    GC_malloc();
    _v16 = _t17;
    init_base_stream(_v16, 8192);
    _t19 = _v16;
     *((char*)(_t19 + 20)) = 0;
     *__esp = 4;
    GC_malloc();
    _v16->base.stream.size = _t19;
     *(_v16->base.stream.size) = des;
    _v16->base.stream.next = basic_read;
    _v16->base.handle = basic_close;
    return _v16;
}

InputStream newFileStream(FILE* f, _None* closep)
{// addr = 0x080B0AD0
    InputStream stream;
    int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    union input_stream* _t25;
    int _t27;
    _unknown_ _t38;

    if(f == 0) {
        return 0;
    }
     *__esp = 32;
    GC_malloc();
    _v16 = _t25;
    init_base_stream(_v16, 8192);
    _t27 = _v16;
     *((char*)(_t27 + 20)) = 1;
     *__esp = 8;
    GC_malloc();
    _v16->base.stream.size = _t27;
     *(_v16->base.stream.size) = f;
    if(closep == 0) {
         *(_v16->base.stream.size + 4) = fclose;
    } else {
         *(_v16->base.stream.size + 4) = closep;
    }
    _v16->base.stream.next = file_read;
    _v16->base.handle = file_close;
    return _v16;
}

InputStream newStrStream(Str s)
{// addr = 0x080B0B6B
    InputStream stream;
    struct base_stream* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    union input_stream* _t16;
    _unknown_ _t23;

    if(s == 0) {
        return 0;
    }
     *__esp = 32;
    GC_malloc();
    _v16 = _t16;
    init_str_stream(_v16, s);
    _v16->base.stream.cur = 2;
    _v16->base.stream.size = s;
    _v16->base.stream.next = str_read;
    _v16->base.handle = 0;
    return _v16;
}

InputStream newEncodedStream(InputStream is, char encoding)
{// addr = 0x080B0BC9
    InputStream stream;
    int _v16;
    signed char _v32;
    _unknown_ _v56;
    _unknown_ __ebp;
    signed int _t35;
    int _t38;

    _t35 = encoding;
    _v32 = _t35 & 4294967295;
    if(is == 0) {
        return is;
    }
    if(_v32 != 2 && _v32 != 1) {
        if(_v32 != 3) {
            return is;
        }
    }
     *__esp = 32;
    GC_malloc();
    _v16 = _t35;
    init_base_stream(_v16, 8192);
    _t38 = _v16;
     *((char*)(_t38 + 20)) = 4;
     *__esp = 16;
    GC_malloc();
    _v16->base.stream.size = _t38;
     *(_v16->base.stream.size) = is;
     *((intOrPtr*)(_v16->base.stream.size + 8)) = 0;
     *(_v16->base.stream.size + 12) = _v32 & 255 & 4294967295;
     *((intOrPtr*)(_v16->base.stream.size + 4)) = 0;
    _v16->base.stream.next = ens_read;
    _v16->base.handle = ens_close;
    return _v16;
}

int ISclose(InputStream stream)
{// addr = 0x080B0C7F
    _None* prevtrap;
    _None* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t15;
    _unknown_ _t27;

    if(stream == 0) {
        return ;
    }
    if(stream->base.handle == 0) {
        return ;
    }
    if((stream->base.stream.cur & 255 & 4294967295 & 16) != 0) {
        return ;
    }
    _v16 = mySignal(2, 1);
     *__esp = stream->base.stream.size;
     *(stream->base.handle)();
    mySignal(2, _v16);
    return;
}

int ISgetc(InputStream stream)
{// addr = 0x080B0CEF
    BaseStream base;
    struct base_stream* _v16;
    _unknown_ __ebp;
    _unknown_ _t28;
    _unknown_ _t39;
    int _t42;

    if(stream == 0) {
        return 0;
    }
    _v16 = stream;
    if((_v16->iseos & 255 & 4294967295) == 0 && _v16->stream.cur == _v16->stream.next) {
        do_update(_v16);
    }
    if((_v16->iseos & 255 & 4294967295) != 0) {
        return 0;
    }
    _t42 = _v16->stream.cur;
    _v16->stream.cur = _t42 + 1;
    return  *( *_v16 + _t42) & 255 & 4294967295 & ;
}

int ISundogetc(InputStream stream)
{// addr = 0x080B0D61
    StreamBuffer sb;
    union input_stream* _v8;
    _unknown_ __ebp;
    _unknown_ _t14;
    _unknown_ _t18;
    _unknown_ _t19;

    if(stream == 0) {
        return -1;
    }
    _v8 = stream;
    if( *((intOrPtr*)(_v8 + 8)) <= 0) {
        return -1;
    }
     *((intOrPtr*)(_v8 + 8)) =  *((intOrPtr*)(_v8 + 8)) - 1;
    return 0;
}

Str StrISgets(InputStream stream)
{// addr = 0x080B0DA1
    BaseStream base;
    StreamBuffer sb;
    Str s;
    unsigned char* p;
    int len;
    struct base_stream* _v16;
    struct base_stream* _v20;
    struct _Str* _v24;
    void* _v28;
    int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t122;

    _v24 = 0;
    if(stream == 0) {
        return 0;
    }
    _v16 = stream;
    _v20 = _v16;
    while((_v16->iseos & 255 & 4294967295) == 0) {
        if(_v16->stream.cur != _v16->stream.next) {
            _v28 = memchr( *_v20 + _v20->stream.cur, 10, _v20->stream.next - _v20->stream.cur);
            if(_v28 == 0) {
                if(_v24 == 0) {
                    _v24 = Strnew_size(_v20->stream.next - _v20->stream.cur + 10);
                }
                Strcat_charp_n(_v24,  *_v20 + _v20->stream.cur, _v20->stream.next - _v20->stream.cur);
                _v20->stream.cur = _v20->stream.next;
                continue;
            }
            goto L6;
        }
        do_update(_v16);
        continue;
L6:
        _v32 = _v28 -  *_v20 + _v20->stream.cur + 1;
        if(_v24 == 0) {
            _v24 = Strnew_size(_v32);
        }
        Strcat_charp_n(_v24,  *_v20 + _v20->stream.cur, _v32);
        _v20->stream.cur = _v20->stream.cur + _v32;
        return _v24;
    }
}

Str StrmyISgets(InputStream stream)
{// addr = 0x080B0F1F
    BaseStream base;
    StreamBuffer sb;
    Str s;
    int i;
    int len;
    struct base_stream* _v16;
    struct base_stream* _v20;
    struct _Str* _v24;
    int _v28;
    _unknown_ _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    int _t197;
    int _t200;
    _unknown_ _t210;
    int _t236;

    _v24 = 0;
    if(stream == 0) {
        return 0;
    }
    _v16 = stream;
    _v20 = _v16;
L26:
    while((_v16->iseos & 255 & 4294967295) == 0) {
        if(_v16->stream.cur != _v16->stream.next) {
            if(_v24 != 0 && _v24->length > 0 && ( *( *_v24 + _v24->length - 1) & 255 & 4294967295) == 13) {
                if(( *( *_v20 + _v20->stream.cur) & 255 & 4294967295) != 10) {
                    return _v24;
                }
                if(_v24->length + 1 >= _v24->area_size) {
                    Strgrow(_v24);
                }
                _t236 = _v24->length;
                _t197 = _t236;
                _t200 = _v20->stream.cur;
                 *( *_v24 + _t197) =  *( *_v20 + _t200) & 255 & 4294967295;
                _v24->length = _t236 + 1;
                _v20->stream.cur = _t200 + 1;
                 *( *_v24 + _v24->length) = 0;
                return _v24;
            }
            _v28 = _v20->stream.cur;
            while(_v20->stream.next > _v28 && ( *( *_v20 + _v28) & 255 & 4294967295) != 10 && ( *( *_v20 + _v28) & 255 & 4294967295) != 13) {
                _v28 = _v28 + 1;
            }
        } else {
            do_update(_v16);
        }
    }
}

int ISread(InputStream stream, Str buf, int count)
{// addr = 0x080B116F
    int rest;
    int len;
    BaseStream base;
    intOrPtr _v16;
    int _v20;
    struct stream_buffer* _v24;
    intOrPtr _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    _unknown_ _t44;
    _unknown_ _t61;
    _unknown_ _t62;
    int _t67;

    if(stream == 0) {
        return ;
    }
    _v24 = stream;
    if(( *(_v24 + 21) & 255 & 4294967295) != 0) {
        return ;
    }
    _v20 = buffer_read(_v24, buf->ptr, count);
    _v16 = count - _v20;
    if(_v24->cur == _v24->next) {
        _t67 =  *(_v24 + 16);
        _v36 = _v16;
        _v40 = buf->ptr + _v20;
         *__esp = _t67;
         *((intOrPtr*)( *((intOrPtr*)(_v24 + 24))))();
        _v20 = _t67;
        if(_v20 <= 0) {
             *(_v24 + 21) = 1;
            _v20 = 0;
        }
        _v16 = _v16 - _v20;
    }
    Strtruncate(buf, count - _v16);
    if(buf->length <= 0) {
        return ;
    }
    return;
}

int ISfileno(InputStream stream)
{// addr = 0x080B124F
    _unknown_ __ebp;
    signed int _t14;
    _unknown_ _t23;
    _unknown_ _t27;

    if(stream == 0) {
        return -1;
    }
    _t14 = stream->base.stream.cur & 255 & 239 & 4294967295;
    if(_t14 == 1) {
        return fileno( *(stream->base.stream.size));
    }
    if(_t14 == 4) {
        return ISfileno( *(stream->base.stream.size));
    }
    if(_t14 != 0) {
        return -1;
    }
    return  *(stream->base.stream.size);
}

int ISeos(InputStream stream)
{// addr = 0x080B12B2
    BaseStream base;
    struct base_stream* _v16;
    _unknown_ __ebp;

    _v16 = stream;
    if((_v16->iseos & 255 & 4294967295) != 0) {
        return _v16->iseos & 255 & 4294967295;
    }
    if(_v16->stream.cur != _v16->stream.next) {
        return _v16->iseos & 255 & 4294967295;
    }
    do_update(_v16);
    return _v16->iseos & 255 & 4294967295;
}

basic_close(int* handle)
{// addr = 0x080B12F0
    _unknown_ __ebp;
    _unknown_ _t4;

    close( *handle);
    return;
}

int basic_read(int* handle, char* buf, int len)
{// addr = 0x080B1305
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return read( *handle, buf, len);
}

file_close(struct file_handle* handle)
{// addr = 0x080B1328
    _unknown_ __ebp;

     *__esp = handle->f;
    handle();
    return;
}

int file_read(struct file_handle* handle, char* buf, int len)
{// addr = 0x080B1340
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return fread(buf, 1, len, handle->f);
}

int str_read(Str handle, char* buf, int len)
{// addr = 0x080B136B
    _unknown_ __ebp;

    return 0;
}

ens_close(struct ens_handle* handle)
{// addr = 0x080B1375
    _unknown_ __ebp;
    _unknown_ _t4;

    ISclose(handle->is);
    return;
}

int ens_read(struct ens_handle* handle, char* buf, int len)
{// addr = 0x080B138A
    char* p;
    char* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t115;
    _unknown_ _t142;

    if( *(handle + 4) == 0 || handle->pos ==  *(handle + 4)->length) {
         *(handle + 4) = StrmyISgets(handle->is);
        if( *(handle + 4)->length == 0) {
            return 0;
        }
        cleanup_line( *(handle + 4), 1);
        if((handle->encoding & 255 & 4294967295) != 1) {
            if((handle->encoding & 255 & 4294967295) != 3) {
                goto L10;
            }
        } else {
            Strchop( *(handle + 4));
L10:
            _v16 =  *( *(handle + 4));
            if((handle->encoding & 255 & 4294967295) != 2) {
                if((handle->encoding & 255 & 4294967295) != 1) {
                    if((handle->encoding & 255 & 4294967295) == 3) {
                         *(handle + 4) = decodeU( &_v16);
                    }
                } else {
                     *(handle + 4) = decodeB( &_v16);
                }
            } else {
                 *(handle + 4) = decodeQP( &_v16);
            }
            handle->pos = 0;
            goto L17;
        }
L7:
        if(strncmp( *( *(handle + 4)), "begin", 5) == 0) {
             *(handle + 4) = StrmyISgets(handle->is);
        }
        Strchop( *(handle + 4));
        goto L10;
    }
L17:
    if( *(handle + 4)->length - handle->pos < len) {
        len =  *(handle + 4)->length - handle->pos;
    }
    bcopy( *( *(handle + 4)) + handle->pos, buf, len);
    handle->pos = handle->pos + len;
    return len;
}

Str Strnew()
{// addr = 0x080B1538
    Str x;
    struct _Str _v16;
    _unknown_ __ebp;
    struct _Str _t9;

    _t9 = __eax;
     *__esp = 12;
    GC_malloc();
    _v16 = _t9;
     *__esp = 32;
    GC_malloc_atomic();
     *_v16 = _t9;
     *( *_v16) = 0;
    _v16->area_size = 32;
    _v16->length = 0;
    return _v16;
}

Str Strnew_size(int n)
{// addr = 0x080B1581
    Str x;
    struct _Str* _v16;
    _unknown_ __ebp;
    struct _Str _t14;

    __esp->ptr = 12;
    GC_malloc();
    _v16 = __eax;
    _t14 = n + 1;
     *__esp = _t14;
    GC_malloc_atomic();
     *_v16 = _t14;
     *( *_v16) = 0;
    _v16->area_size = n + 1;
    _v16->length = 0;
    return _v16;
}

Str Strnew_charp(char* p)
{// addr = 0x080B15CE
    Str x;
    int n;
    struct _Str* _v16;
    int _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    struct _Str* _t20;
    struct _Str _t24;
    _unknown_ _t32;

    _t20 = __eax;
    if(p == 0) {
        return Strnew();
    }
    __esp->ptr = 12;
    GC_malloc();
    _v16 = _t20;
    _v20 = strlen(p) + 1;
    _t24 = _v20;
     *__esp = _t24;
    GC_malloc_atomic();
     *_v16 = _t24;
    _v16->area_size = _v20;
    _v16->length = _v20 - 1;
    bcopy(p,  *_v16, _v20);
    return _v16;
}

Str Strnew_m_charp(char* p)
{// addr = 0x080B1648
    va_list ap;
    Str r;
    char** _v16;
    struct _Str* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t13;
    char** _t18;

    _v20 = Strnew();
    _v16 =  &_a8;
    while(p != 0) {
        Strcat_charp(_v20, p);
        _t18 = _v16;
        _v16 =  &(_t18[1]);
        p =  *_t18;
    }
}

Str Strnew_charp_n(char* p, int n)
{// addr = 0x080B1689
    Str x;
    struct _Str* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    struct _Str* _t22;
    struct _Str _t24;
    _unknown_ _t32;

    if(p == 0) {
        return Strnew_size(n);
    }
    __esp->ptr = 12;
    GC_malloc();
    _v16 = _t22;
    _t24 = n + 1;
     *__esp = _t24;
    GC_malloc_atomic();
     *_v16 = _t24;
    _v16->area_size = n + 1;
    _v16->length = n;
    bcopy(p,  *_v16, n);
     *((char*)( *_v16 + n)) = 0;
    return _v16;
}

Str Strdup(Str s)
{// addr = 0x080B1709
    Str n;
    struct _Str* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = Strnew_size(s->length);
    Strcopy(_v16, s);
    return _v16;
}

Strclear(Str s)
{// addr = 0x080B1737
    _unknown_ __ebp;

    s->length = 0;
    s = 0;
    return;
}

Strfree(Str x)
{// addr = 0x080B174E
    _unknown_ __ebp;

     *__esp = x->ptr;
    GC_free();
     *__esp = x;
    GC_free();
    return;
}

Strcopy(Str x, Str y)
{// addr = 0x080B176E
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t34;
    char* _t41;

    if(x->area_size < y->length + 1) {
         *__esp = x->ptr;
        GC_free();
        _t41 = y->length + 1;
         *__esp = _t41;
        GC_malloc_atomic();
        x->ptr = _t41;
        x->area_size = y->length + 1;
    }
    bcopy(y->ptr, x->ptr, y->length + 1);
    x->length = y->length;
    return;
}

Strcopy_charp(Str x, char* y)
{// addr = 0x080B17EE
    int len;
    int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t33;
    char* _t38;

    if(y != 0) {
        _v16 = strlen(y);
        if(x->area_size < _v16 + 1) {
             *__esp = x->ptr;
            GC_free();
            _t38 = _v16 + 1;
             *__esp = _t38;
            GC_malloc_atomic();
            x->ptr = _t38;
            x->area_size = _v16 + 1;
        }
        bcopy(y, x->ptr, _v16 + 1);
        x->length = _v16;
        return;
    }
    x->length = 0;
    return;
}

Strcopy_charp_n(Str x, char* y, int n)
{// addr = 0x080B187D
    int len;
    int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t33;
    char* _t41;

    _v16 = n;
    if(y != 0) {
        if(x->area_size < _v16 + 1) {
             *__esp = x->ptr;
            GC_free();
            _t41 = _v16 + 1;
             *__esp = _t41;
            GC_malloc_atomic();
            x->ptr = _t41;
            x->area_size = _v16 + 1;
        }
        bcopy(y, x->ptr, n);
         *(x->ptr + n) = 0;
        x->length = n;
        return;
    }
    x->length = 0;
    return;
}

Strcat_charp_n(Str x, char* y, int n)
{// addr = 0x080B190D
    int newlen;
    char* old;
    char* _v16;
    void* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t51;
    char* _t66;
    _unknown_ _t74;

    if(y == 0) {
        return ;
    }
    _v16 = x->length + n + 1;
    if(x->area_size < _v16) {
        _v20 = x->ptr;
        _v16 = ( &(( &(_v16[_v16]))[_t83]) >> 31) +  &(( &(_v16[_v16]))[_t83]) >> 1;
        _t66 = _v16;
         *__esp = _t66;
        GC_malloc_atomic();
        x->ptr = _t66;
        x->area_size = _v16;
        bcopy(_v20, x->ptr, x->length);
         *__esp = _v20;
        GC_free();
    }
    bcopy(y, x->ptr + x->length, n);
    x->length = x->length + n;
     *(x->ptr + x->length) = 0;
    return;
}

Strcat(Str x, Str y)
{// addr = 0x080B19E6
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    Strcat_charp_n(x, y->ptr, y->length);
    return;
}

Strcat_charp(Str x, char* y)
{// addr = 0x080B1A0C
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    if(y == 0) {
        return ;
    }
    Strcat_charp_n(x, y, strlen(y));
    return;
}

Strcat_m_charp(Str x)
{// addr = 0x080B1A3E
    va_list ap;
    char* p;
    char** _v16;
    char* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    char** _t14;

    _v16 =  &_a8;
    while(1) {
        _t14 = _v16;
        _v16 =  &(_t14[1]);
        _v20 =  *_t14;
        if(_v20 == 0) {
            break;
        }
        Strcat_charp_n(x, _v20, strlen(_v20));
    }
    return;
}

Strgrow(Str x)
{// addr = 0x080B1A83
    char* old;
    int newlen;
    void* _v16;
    char* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t35;
    char* _t41;
    _unknown_ _t49;
    _unknown_ _t55;

    _v16 = x->ptr;
    _v20 = ((x->length + x->length + _t54 + x->length + x->length + _t54) * 1717986919 >> 32 >> 1) - (x->length + x->length + _t54 + x->length + x->length + _t54 >> 31);
    if(x->length == _v20) {
        _v20 =  &(_v20[2]);
    }
    _t41 = _v20;
     *__esp = _t41;
    GC_malloc_atomic();
    x->ptr = _t41;
    x->area_size = _v20;
    bcopy(_v16, x->ptr, x->length);
     *__esp = _v16;
    GC_free();
    return;
}

Str Strsubstr(Str s, int beg, int len)
{// addr = 0x080B1B11
    Str new_s;
    int i;
    struct _Str* _v16;
    char _v20;
    _unknown_ __ebp;
    _unknown_ _t38;
    int _t53;

    _v16 = Strnew();
    if(s->length <= beg) {
        return _v16;
    }
    _v20 = 0;
    while(_v20 < len) {
        if(beg + _v20 >= s->length) {
            return _v16;
        }
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t53 = _v16->length;
         *( *_v16 + _t53) = s->ptr[beg + _v20] & 255 & 4294967295;
        _v16->length = _t53 + 1;
         *((char*)( *_v16 + _v16->length)) = 0;
        _v20 = _v20 + 1;
    }
}

Strlower(Str s)
{// addr = 0x080B1BC2
    int i;
    intOrPtr _v8;
    _unknown_ __ebp;
    signed int _t37;
    char* _t46;

    _v8 = 0;
    while(s->length > _v8) {
        _t46 =  &(s->ptr[_v8]);
        if(( *( &MYCTYPE_MAP + (s->ptr[_v8] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            _t37 = s->ptr[_v8] & 255;
        } else {
            _t37 = s->ptr[_v8] & 255 | 32;
        }
         *_t46 = _t37 & 4294967295;
        _v8 = _v8 + 1;
    }
}

Strupper(Str s)
{// addr = 0x080B1C31
    int i;
    intOrPtr _v8;
    _unknown_ __ebp;
    signed int _t37;
    char* _t46;

    _v8 = 0;
    while(s->length > _v8) {
        _t46 =  &(s->ptr[_v8]);
        if(( *( &MYCTYPE_MAP + (s->ptr[_v8] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            _t37 = s->ptr[_v8] & 255;
        } else {
            _t37 = s->ptr[_v8] & 255 & 223;
        }
         *_t46 = _t37 & 4294967295;
        _v8 = _v8 + 1;
    }
}

Strchop(Str s)
{// addr = 0x080B1CA0
    _unknown_ __ebp;

    while(( *(s->ptr + s->length - 1) & 255 & 4294967295) == 10 || ( *(s->ptr + s->length - 1) & 255 & 4294967295) == 13) {
        if(s->length > 0) {
            s->length = s->length - 1;
            continue;
        }
         *((char*)(s->ptr + s->length)) = 0;
        return;
    }
}

Strinsert_char(Str s, int pos, char c)
{// addr = 0x080B1D01
    int i;
    int _v16;
    signed int _v32;
    _unknown_ __ebp;

    _v32 = c & 4294967295;
    if(pos >= 0) {
        return ;
    }
    if(s->length < pos) {
        return ;
    }
    if(s->length + 2 > s->area_size) {
        Strgrow(s);
    }
    _v16 = s->length;
    while(_v16 > pos) {
        s->ptr[_v16] = s->ptr[_v16 - 1] & 255 & 4294967295;
        _v16 = _v16 - 1;
    }
}

Strinsert_charp(Str s, int pos, char* p)
{// addr = 0x080B1DAF
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    while(( *p & 255 & 4294967295) != 0) {
        p =  &(p[1]);
        pos = pos + 1;
        Strinsert_char(s, pos,  *p & 255 & 4294967295);
    }
}

Strdelete(Str s, int pos, int n)
{// addr = 0x080B1DEA
    int i;
    int _v12;
    _unknown_ __ebp;

    if(s->length > pos + n) {
        _v12 = pos;
L4:
        while(s->length - n > _v12) {
            goto L3;
        }
    }
     *((char*)(s->ptr + pos)) = 0;
    s->length = pos;
    return;
L3:
    s->ptr[_v12] = s->ptr[_v12 + n] & 255 & 4294967295;
    _v12 = _v12 + 1;
    goto L4;
}

Strtruncate(Str s, int pos)
{// addr = 0x080B1E74
    _unknown_ __ebp;

     *((char*)(s->ptr + pos)) = 0;
    s->length = pos;
    return;
}

Strshrink(Str s, int n)
{// addr = 0x080B1E90
    _unknown_ __ebp;

    if(s->length > n) {
        s->length = s->length - n;
         *(s->ptr + s->length) = 0;
        return;
    }
    s->length = 0;
    s = 0;
    return;
}

Strremovefirstspaces(Str s)
{// addr = 0x080B1ED6
    int i;
    intOrPtr _v8;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ __ebp;

    _v8 = 0;
    while(s->length > _v8 && ( *( &MYCTYPE_MAP + (s->ptr[_v8] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
    }
}

Strremovetrailingspaces(Str s)
{// addr = 0x080B1F3B
    int i;
    intOrPtr _v8;
    _unknown_ __ebp;

    _v8 = s->length - 1;
    while(_v8 < 0 && ( *( &MYCTYPE_MAP + (s->ptr[_v8] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
        _v8 = _v8 - 1;
    }
}

Str Stralign_left(Str s, int width)
{// addr = 0x080B1F99
    Str n;
    int i;
    struct _Str* _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t50;

    if(s->length >= width) {
        return Strdup(s);
    }
    _v16 = Strnew_size(width);
    Strcopy(_v16, s);
    _v20 = s->length;
    while(_v20 < width) {
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t50 = _v16->length;
         *((char*)( *_v16 + _t50)) = 32;
        _v16->length = _t50 + 1;
         *((char*)( *_v16 + _v16->length)) = 0;
        _v20 = _v20 + 1;
    }
}

Str Stralign_right(Str s, int width)
{// addr = 0x080B2041
    Str n;
    int i;
    struct _Str* _v16;
    int _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t48;

    if(s->length >= width) {
        return Strdup(s);
    }
    _v16 = Strnew_size(width);
    _v20 = s->length;
    while(_v20 < width) {
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t48 = _v16->length;
         *((char*)( *_v16 + _t48)) = 32;
        _v16->length = _t48 + 1;
         *((char*)( *_v16 + _v16->length)) = 0;
        _v20 = _v20 + 1;
    }
}

Str Stralign_center(Str s, int width)
{// addr = 0x080B20E9
    Str n;
    int i;
    int w;
    struct _Str* _v16;
    char _v20;
    signed int _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t79;
    _unknown_ _t98;

    if(s->length >= width) {
        return Strdup(s);
    }
    _v16 = Strnew_size(width);
    _v24 = (width - s->length >> 31) + width - s->length >> 1;
    _v20 = 0;
    while(_v20 < _v24) {
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t79 = _v16->length;
         *((char*)( *_v16 + _t79)) = 32;
        _v16->length = _t79 + 1;
         *((char*)( *_v16 + _v16->length)) = 0;
        _v20 = _v20 + 1;
    }
}

Str Sprintf(char* fmt)
{// addr = 0x080B2210
    int len;
    int status;
    int p;
    char* f;
    Str s;
    va_list ap;
    double vd;
    int vi;
    char* vs;
    _Unknown_base* vp;
    signed int _v16;
    signed int _v20;
    signed int _v24;
    char* _v28;
    _unknown_ _v32;
    char* _v36;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    signed int _t73;
    _unknown_ _t103;
    _unknown_ _t118;
    _unknown_ _t128;
    _unknown_ _t129;

    _v16 = 0;
    _v20 = 0;
    _v24 = 0;
    _v36 =  &_a8;
    _v28 = fmt;
L21:
    while(( *_v28 & 255 & 4294967295) != 0) {
        while(1) {
            _t73 = _v20;
            if(_t73 == 1) {
                break;
            }
            if(_t73 == 2) {
                if(( *( &MYCTYPE_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                    goto L20;
                }
            } else {
                if(_t73 == 0) {
                    if(( *_v28 & 255 & 4294967295) != 37) {
                        _v16 = _v16 + 1;
                    } else {
                        _v20 = 1;
                        _v24 = 0;
                    }
                }
L20:
                _v28 =  &(_v28[1]);
                goto L21;
            }
L18:
            _v20 = 1;
        }
        if(( *( &MYCTYPE_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            if(( *( &MYCTYPE_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
                if(( *_v28 & 255 & 4294967295) != 46) {
                    if(( *_v28 & 255 & 4294967295) == 37) {
                        _v20 = 0;
                        _v16 = _v16 + 1;
                    }
                } else {
                    _v20 = 2;
                }
            } else {
                _v24 = (_v24 << 2) + _v24 + (_v24 << 2) + _v24 + ( *_v28 & 255 & 4294967295) - 48;
            }
            goto L20;
        }
        if(( *_v28 & 255 & 4294967295) - 69 <= 51) {
            goto __eax;
        }
        _v20 = 0;
        goto L20;
    }
}

Str Strfgets(FILE* f)
{// addr = 0x080B249D
    Str s;
    char c;
    signed int _v13;
    struct _Str* _v20;
    _unknown_ __ebp;
    _unknown_ _t27;
    int _t42;

    _v20 = Strnew();
    while(1) {
        _v13 = fgetc(f) & 4294967295;
        if(feof(f) != 0) {
            break;
        }
        if(ferror(f) != 0) {
            return _v20;
        }
        if(_v20->length + 1 >= _v20->area_size) {
            Strgrow(_v20);
        }
        _t42 = _v20->length;
         *( *_v20 + _t42) = _v13 & 255 & 4294967295;
        _v20->length = _t42 + 1;
         *((char*)( *_v20 + _v20->length)) = 0;
        if(_v13 == 10) {
            return _v20;
        }
    }
    return _v20;
}

Str Strfgetall(FILE* f)
{// addr = 0x080B2533
    Str s;
    char c;
    signed char _v13;
    struct _Str* _v20;
    _unknown_ __ebp;
    _unknown_ _t26;
    int _t41;

    _v20 = Strnew();
    while(1) {
        _v13 = fgetc(f) & 4294967295;
        if(feof(f) != 0) {
            break;
        }
        if(ferror(f) != 0) {
            return _v20;
        }
        if(_v20->length + 1 >= _v20->area_size) {
            Strgrow(_v20);
        }
        _t41 = _v20->length;
         *( *_v20 + _t41) = _v13 & 255 & 4294967295;
        _v20->length = _t41 + 1;
         *((char*)( *_v20 + _v20->length)) = 0;
    }
    return _v20;
}

clen_t strtoclen(const char* s)
{// addr = 0x080B25C4
    intOrPtr _v20;
    intOrPtr _v24;
    _unknown_ __ebp;

    _v20 = 10;
    _v24 = 0;
    __eax = s;
     *__esp = __eax;
    strtoll();
    return __eax;
}

char* allocStr(const char* s, int len)
{// addr = 0x080B25E7
    char* ptr;
    void* _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    char* _t20;
    _unknown_ _t24;
    _unknown_ _t30;
    _unknown_ _t31;
    _unknown_ _t34;

    if(s == 0) {
        return 0;
    }
    if(len < 0) {
        len = strlen(s);
    }
    _t20 = len + 1;
     *__esp = _t20;
    GC_malloc_atomic();
    _v16 = _t20;
    if(_v16 == 0) {
        fwrite("fm: Can't allocate string. Give me more memory!\n", 1, 48, __imp__stderr);
        exit(-1);
    }
    bcopy(s, _v16, len);
    _v16[len] = 0;
    return _v16;
}

int strCmp(* s1, * s2)
{// addr = 0x080B2683
    _unknown_ _v24;
    _unknown_ __ebp;

    return strcmp( *s1,  *s2);
}

char* currentdir()
{// addr = 0x080B26A1
    char* path;
    char* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t7;

     *__esp = 4096;
    GC_malloc_atomic();
    _v16 = __eax;
    getcwd(_v16, 4096);
    return _v16;
}

char* cleanupName(char* name)
{// addr = 0x080B26CE
    char* buf;
    char* p;
    char* q;
    char* _v16;
    char* _v20;
    char* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t111;
    _unknown_ _t117;
    _unknown_ _t140;

    _v16 = allocStr(name, -1);
    _v20 = _v16;
    _v24 = name;
    while(( *_v24 & 255 & 4294967295) != 0) {
        if(strncmp(_v20, "/../", 4) != 0) {
            if(strcmp(_v20, "/..") != 0) {
                if(strncmp(_v20, "/./", 3) != 0) {
                    if(strcmp(_v20, "/.") != 0) {
                        if(strncmp(_v20, "//", 2) != 0) {
                            _v20 =  &(_v20[1]);
                            _v24 =  &(_v24[1]);
                        } else {
                             *_v20 = 0;
                            _v24 =  &(_v24[1]);
                            strcat(_v16, _v24);
                        }
                        continue;
                    }
                } else {
                     *_v20 = 0;
                    _v24 =  &(_v24[2]);
                    strcat(_v16, _v24);
                    continue;
                }
L25:
                _v20 =  &(_v20[1]);
                 *_v20 = 0;
                return _v16;
            }
            goto L12;
        }
        if(_v20 - 2 != _v16) {
L5:
            if(_v20 - 3 < _v16) {
L8:
                while(_v20 != _v16) {
                    goto L9;
                }
            }
            goto L6;
L9:
            _v20 = _v20 - 1;
            if(( *_v20 & 255 & 4294967295) != 47) {
                goto L8;
            }
             *_v20 = 0;
            _v24 =  &(_v24[3]);
            strcat(_v16, _v24);
            continue;
        }
        if(strncmp(_v20 - 2, "..", 2) != 0) {
            goto L5;
        } else {
            _v20 =  &(_v20[3]);
            _v24 =  &(_v24[3]);
            continue;
        }
L6:
        if(strncmp(_v20 - 3, "/..", 3) != 0) {
            goto L8;
        } else {
            _v20 =  &(_v20[3]);
            _v24 =  &(_v24[3]);
            continue;
        }
        goto L9;
L12:
        if(_v20 - 2 != _v16) {
L15:
            if(_v20 - 3 >= _v16) {
                if(strncmp(_v20 - 3, "/..", 3) == 0) {
                    return _v16;
                }
            }
            while(_v20 != _v16) {
                _v20 = _v20 - 1;
                if(( *_v20 & 255 & 4294967295) != 47) {
                    continue;
                }
                _v20 =  &(_v20[1]);
                 *_v20 = 0;
                return _v16;
            }
        } else {
            if(strncmp(_v20 - 2, "..", 2) != 0) {
                goto L15;
            } else {
                return _v16;
            }
        }
    }
}

char* expandPath(char* name)
{// addr = 0x080B2925
    char* p;
    struct passwd* passent;
    Str extpath;
    char* q;
    char* _v16;
    char* _v20;
    struct _Str* _v24;
    char* _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    char* _t74;
    char* _t81;
    _unknown_ _t83;

    _v24 = 0;
    if(name == 0) {
        return 0;
    }
    _v16 = name;
    if(( *_v16 & 255 & 4294967295) != 126) {
        return name;
    }
    _v16 =  &(_v16[1]);
    if(( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
        if(( *_v16 & 255 & 4294967295) != 47) {
            if(( *_v16 & 255 & 4294967295) != 0) {
                return name;
            }
        }
        _v24 = Strnew_charp(getenv("HOME"));
    } else {
        _v28 = strchr(_v16, 47);
        if(_v28 == 0) {
            _t74 = _v16;
             *__esp = _t74;
            getpwnam();
            _v20 = _t74;
            _v16 = 135076311;
        } else {
            _t81 = allocStr(_v16, _v28 - _v16);
             *__esp = _t81;
            getpwnam();
            _v20 = _t81;
            _v16 = _v28;
        }
        if(_v20 == 0) {
            return name;
        }
        _v24 = Strnew_charp(_v20[0x14]);
    }
    if(strcmp( *_v24, "/") == 0 && ( *_v16 & 255 & 4294967295) == 47) {
        _v16 =  &(_v16[1]);
    }
    Strcat_charp(_v24, _v16);
    return  *_v24;
}

int strcasematch(char* s1, char* s2)
{// addr = 0x080B2A5D
    int x;
    intOrPtr _v8;
    _unknown_ __ebp;
    signed int _t51;
    _unknown_ _t59;

    while(( *s1 & 255 & 4294967295) != 0) {
        if(( *s2 & 255 & 4294967295) == 0) {
            return 1;
        }
        if(( *( &MYCTYPE_MAP + ( *s1 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            __edx =  *s1 & 255 & 4294967295;
        } else {
            __edx = ( *s1 & 255 | 32) & 4294967295;
        }
        if(( *( &MYCTYPE_MAP + ( *s2 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
            _t51 =  *s2 & 255 & 4294967295;
        } else {
            _t51 = ( *s2 & 255 | 32) & 4294967295;
        }
        _v8 = __edx - _t51;
        if(_v8 != 0) {
            return  *s2 & 255 & 4294967295 & ;
        }
        s1 =  &(s1[1]);
        s2 =  &(s2[1]);
    }
}

int strcasemstr(char* str, char** srch, char** ret_ptr)
{// addr = 0x080B2B16
    int i;
    signed int _v8;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t32;

    while(( *str & 255 & 4294967295) != 0) {
        _v8 = 0;
        while(srch[_v8] != 0) {
            if(strcasematch(str, srch[_v8]) == 0) {
                _v8 = _v8 + 1;
                continue;
            }
            if(ret_ptr == 0) {
                return _v8;
            }
             *ret_ptr = str;
            return _v8;
        }
    }
}

char* remove_space(char* str)
{// addr = 0x080B2B80
    char* p;
    char* q;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 = str;
    while(( *_v16 & 255 & 4294967295) != 0 && ( *( &MYCTYPE_MAP + ( *_v16 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
    }
}

int non_null(char* s)
{// addr = 0x080B2C25
    _unknown_ __ebp;

    if(s != 0) {
        while(1) {
            __eax = s;
            __eax =  *s & 255;
            if(( *s & 255 & 4294967295) == 0) {
                break;
            }
            __eax = s;
            __eax =  *s & 255;
            __eax =  *s & 255 & 4294967295 & ;
            __eax =  *( &MYCTYPE_MAP + ( *s & 255 & 4294967295 & )) & 255;
            __eax =  *( &MYCTYPE_MAP + ( *s & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            __eax =  *( &MYCTYPE_MAP + ( *s & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2;
            if(( *( &MYCTYPE_MAP + ( *s & 255 & 4294967295 & )) & 255 & 4294967295 &  & 2) != 0) {
                s =  &(s[1]);
                continue;
            }
            __eax = 1;
            return 1;
        }
        __eax = 0;
        return 0;
    }
    __eax = 0;
    return 0;
}

cleanup_line(Str s, int mode)
{// addr = 0x080B2C6E
    int i;
    intOrPtr _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t93;
    int _t142;

    if(s->length <= 1) {
L6:
        if(s->length <= 0 || ( *(s->ptr + s->length - 1) & 255 & 4294967295) != 13) {
            if(s->length <= 0 || ( *(s->ptr + s->length - 1) & 255 & 4294967295) != 10) {
                if(s->length + 1 >= s->area_size) {
                    Strgrow(s);
                }
                _t93 = s->length;
                 *(s->ptr + _t93) = 10;
                s->length = _t93 + 1;
                 *((char*)(s->ptr + s->length)) = 0;
            }
        } else {
             *(s->ptr + s->length - 1) = 10;
        }
        goto L14;
    }
    if(( *(s->ptr + s->length - 2) & 255 & 4294967295) != 13 || ( *(s->ptr + s->length - 1) & 255 & 4294967295) != 10) {
        goto L6;
    } else {
        Strshrink(s, 2);
        if(s->length + 1 >= s->area_size) {
            Strgrow(s);
        }
        _t142 = s->length;
         *(s->ptr + _t142) = 10;
        s->length = _t142 + 1;
         *((char*)(s->ptr + s->length)) = 0;
    }
L14:
    if(mode == 1) {
        return ;
    }
    _v16 = 0;
    while(s->length > _v16) {
    }
}

int getescapechar(char** str)
{// addr = 0x080B2DFB
    int dummy;
    char* p;
    char* q;
    int strict_entity;
    signed int _v16;
    char* _v20;
    char* _v24;
    intOrPtr _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t146;
    _unknown_ _t153;
    _unknown_ _t157;
    _unknown_ _t189;
    _unknown_ _t224;

    _v16 = -1;
    _v20 =  *str;
    _v28 = 1;
    if(( *_v20 & 255 & 4294967295) == 38) {
        _v20 =  &(_v20[1]);
    }
    if(( *_v20 & 255 & 4294967295) != 35) {
        if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) != 0) {
            _v24 = _v20;
            _v20 =  &(_v20[1]);
L25:
            while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 12) != 0) {
                goto L24;
            }
        }
        goto L22;
L24:
        _v20 =  &(_v20[1]);
        goto L25;
    }
    _v20 =  &(_v20[1]);
    if(( *_v20 & 255 & 4294967295) == 120 || ( *_v20 & 255 & 4294967295) == 88) {
        _v20 =  &(_v20[1]);
        if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 40) != 0) {
            _v16 =  *( &MYCTYPE_DIGITMAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            _v20 =  &(_v20[1]);
L9:
            while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 40) != 0) {
                goto L8;
            }
        }
        goto L6;
L8:
        _v16 = (_v16 << 4) + ( *( &MYCTYPE_DIGITMAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 & );
        _v20 =  &(_v20[1]);
        goto L9;
    } else {
        if(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
            _v16 =  *( &MYCTYPE_DIGITMAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
            _v20 =  &(_v20[1]);
L17:
            while(( *( &MYCTYPE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) != 0) {
                goto L16;
            }
        }
         *str = _v20;
        return -1;
L16:
        _v16 = (_v16 << 2) + _v16 + (_v16 << 2) + _v16 + ( *( &MYCTYPE_DIGITMAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 & );
        _v20 =  &(_v20[1]);
        goto L17;
    }
L6:
     *str = _v20;
    return -1;
L22:
     *str = _v20;
    return -1;
}

char* getescapecmd(char** s)
{// addr = 0x080B3089
    char* save;
    Str tmp;
    int ch;
    char* _v16;
    struct _Str* _v20;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v16 =  *s;
    _v24 = getescapechar(s);
    if(_v24 < 0) {
        return conv_entity(_v24);
    }
    if(( *_v16 & 255 & 4294967295) == 38) {
        _v20 = Strnew();
    } else {
        _v20 = Strnew_charp("&");
    }
    Strcat_charp_n(_v20, _v16,  *s - _v16);
    return  *_v20;
}

char* html_quote(char* str)
{// addr = 0x080B3108
    Str tmp;
    char* p;
    char* q;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t63;

    _v16 = 0;
    _v20 = str;
    while(( *_v20 & 255 & 4294967295) != 0) {
        _v24 =  *( &HTML_QUOTE_MAP + ( *( &QUOTE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 7) * 4);
        if(_v24 == 0) {
            if(_v16 != 0) {
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t63 = _v16->length;
                 *( *_v16 + _t63) =  *_v20 & 255 & 4294967295;
                _v16->length = _t63 + 1;
                 *( *_v16 + _v16->length) = 0;
            }
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(str, _v20 - str);
            }
            Strcat_charp(_v16, _v24);
        }
        _v20 =  &(_v20[1]);
    }
}

char* html_unquote(char* str)
{// addr = 0x080B31F7
    Str tmp;
    char* p;
    char* q;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t56;

    _v16 = 0;
    _v20 = str;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *_v20 & 255 & 4294967295) != 38) {
            if(_v16 != 0) {
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t56 = _v16->length;
                 *( *_v16 + _t56) =  *_v20 & 255 & 4294967295;
                _v16->length = _t56 + 1;
                 *( *_v16 + _v16->length) = 0;
            }
            _v20 =  &(_v20[1]);
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(str, _v20 - str);
            }
            _v24 = getescapecmd( &_v20);
            Strcat_charp(_v16, _v24);
        }
    }
}

char* url_quote(char* str)
{// addr = 0x080B32DF
    Str tmp;
    char* p;
    struct _Str* _v16;
    char* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t114;
    int _t127;
    int _t139;
    int _t151;

    _v16 = 0;
    _v20 = str;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *( &QUOTE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 16) == 0) {
            if(_v16 != 0) {
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t114 = _v16->length;
                 *( *_v16 + _t114) =  *_v20 & 255 & 4294967295;
                _v16->length = _t114 + 1;
                 *( *_v16 + _v16->length) = 0;
            }
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(str, _v20 - str);
            }
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t127 = _v16->length;
             *((char*)( *_v16 + _t127)) = 37;
            _v16->length = _t127 + 1;
             *( *_v16 + _v16->length) = 0;
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t139 = _v16->length;
             *( *_v16 + _t139) =  *(( *_v20 & 255 & 4294967295 & ) + "0123456789ABCDEF") & 255 & 4294967295;
            _v16->length = _t139 + 1;
             *( *_v16 + _v16->length) = 0;
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t151 = _v16->length;
             *( *_v16 + _t151) =  *(( *_v20 & 255 & 4294967295 &  & 15) + "0123456789ABCDEF") & 255 & 4294967295;
            _v16->length = _t151 + 1;
             *( *_v16 + _v16->length) = 0;
        }
        _v20 =  &(_v20[1]);
    }
}

char* file_quote(char* str)
{// addr = 0x080B34B7
    Str tmp;
    char* p;
    char[3] buf;
    struct _Str* _v16;
    char* _v20;
    char _v24;
    signed int _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t63;
    _unknown_ _t74;

    _v16 = 0;
    _v20 = str;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *( &QUOTE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 48) == 0) {
            if(_v16 != 0) {
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t63 = _v16->length;
                 *( *_v16 + _t63) =  *_v20 & 255 & 4294967295;
                _v16->length = _t63 + 1;
                 *( *_v16 + _v16->length) = 0;
            }
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(str, _v20 - str);
            }
            _v36 =  *_v20 & 255 & 4294967295 & ;
            sprintf( &_v24, "%%%02X");
            Strcat_charp(_v16,  &_v24);
        }
        _v20 =  &(_v20[1]);
    }
}

char* file_unquote(char* str)
{// addr = 0x080B35BB
    Str tmp;
    char* p;
    char* q;
    int c;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    signed int _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t94;
    signed int _t109;
    int _t117;

    _v16 = 0;
    _v20 = str;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *_v20 & 255 & 4294967295) != 37) {
L16:
            if(_v16 != 0) {
L17:
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t94 = _v16->length;
                 *( *_v16 + _t94) =  *_v20 & 255 & 4294967295;
                _v16->length = _t94 + 1;
                 *( *_v16 + _v16->length) = 0;
            }
            _v20 =  &(_v20[1]);
            continue;
        }
        _v24 = _v20;
        if(( *( &MYCTYPE_MAP + (_v24[1] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 40) == 0) {
L5:
            _t109 = -1;
            goto L6;
        }
        if(( *( &MYCTYPE_MAP + (_v24[2] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 40) == 0) {
            goto L5;
        } else {
            _v24 =  &(_v24[3]);
            _t109 =  *( &MYCTYPE_DIGITMAP + ( *(_v24 - 1) & 255 & 4294967295 & )) & 255 & 4294967295 &  | ( *( &MYCTYPE_DIGITMAP + ( *(_v24 - 2) & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 4;
        }
L6:
        _v28 = _t109;
        if(_v28 >= 0) {
            goto L16;
        }
        if(_v16 == 0) {
            _v16 = Strnew_charp_n(str, _v20 - str);
        }
        if(_v28 != 0 && _v28 != 10 && _v28 != 13) {
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t117 = _v16->length;
             *( *_v16 + _t117) = _v28 & 4294967295;
            _v16->length = _t117 + 1;
             *( *_v16 + _v16->length) = 0;
        }
        _v20 = _v24;
    }
}

Str Str_form_quote(Str x)
{// addr = 0x080B3774
    Str tmp;
    char* p;
    char* ep;
    char[3] buf;
    struct _Str* _v16;
    char* _v20;
    intOrPtr _v24;
    char _v28;
    signed int _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t99;
    _unknown_ _t110;
    int _t124;

    _v16 = 0;
    _v20 = x->ptr;
    _v24 = x->ptr + x->length;
    while(_v20 < _v24) {
        if(( *_v20 & 255 & 4294967295) != 32) {
            if(( *( &QUOTE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 112) == 0) {
                if(_v16 != 0) {
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t99 = _v16->length;
                     *( *_v16 + _t99) =  *_v20 & 255 & 4294967295;
                    _v16->length = _t99 + 1;
                     *( *_v16 + _v16->length) = 0;
                }
            } else {
                if(_v16 == 0) {
                    _v16 = Strnew_charp_n(x->ptr, _v20 - x->ptr);
                }
                _v36 =  *_v20 & 255 & 4294967295 & ;
                sprintf( &_v28, "%%%02X");
                Strcat_charp(_v16,  &_v28);
            }
            goto L15;
        }
        if(_v16 == 0) {
            _v16 = Strnew_charp_n(x->ptr, _v20 - x->ptr);
        }
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t124 = _v16->length;
         *((char*)( *_v16 + _t124)) = 43;
        _v16->length = _t124 + 1;
         *( *_v16 + _v16->length) = 0;
L15:
        _v20 =  &(_v20[1]);
    }
}

Str Str_url_unquote(Str x, int is_form, int safe)
{// addr = 0x080B3905
    Str tmp;
    char* p;
    char* ep;
    char* q;
    int c;
    struct _Str* _v16;
    char* _v20;
    intOrPtr _v24;
    char* _v28;
    signed int _v32;
    _unknown_ _v56;
    _unknown_ __ebp;
    int _t137;
    signed int _t152;
    int _t159;
    int _t211;

    _v16 = 0;
    _v20 = x->ptr;
    _v24 = x->ptr + x->length;
    while(_v20 < _v24) {
        if(is_form == 0) {
L8:
            if(( *_v20 & 255 & 4294967295) != 37) {
L22:
                if(_v16 != 0) {
L23:
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t137 = _v16->length;
                     *( *_v16 + _t137) =  *_v20 & 255 & 4294967295;
                    _v16->length = _t137 + 1;
                     *( *_v16 + _v16->length) = 0;
                }
                _v20 =  &(_v20[1]);
                continue;
            }
            goto L9;
        }
        if(( *_v20 & 255 & 4294967295) != 43) {
            goto L8;
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(x->ptr, _v20 - x->ptr);
            }
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t211 = _v16->length;
             *((char*)( *_v16 + _t211)) = 32;
            _v16->length = _t211 + 1;
             *( *_v16 + _v16->length) = 0;
            _v20 =  &(_v20[1]);
            continue;
        }
L9:
        _v28 = _v20;
        if(( *( &MYCTYPE_MAP + (_v28[1] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 40) == 0 || ( *( &MYCTYPE_MAP + (_v28[2] & 255 & 4294967295 & )) & 255 & 4294967295 &  & 40) == 0) {
            _t152 = -1;
        } else {
            _v28 =  &(_v28[3]);
            _t152 =  *( &MYCTYPE_DIGITMAP + ( *(_v28 - 1) & 255 & 4294967295 & )) & 255 & 4294967295 &  | ( *( &MYCTYPE_DIGITMAP + ( *(_v28 - 2) & 255 & 4294967295 & )) & 255 & 4294967295 & ) << 4;
        }
        _v32 = _t152;
        if(_v32 >= 0 || safe != 0 && ( *( &MYCTYPE_MAP + (_v32 & 4294967295 & )) & 255 & 4294967295 &  & 17) != 0 && ( *( &QUOTE_MAP + (_v32 & 4294967295 & )) & 255 & 4294967295 &  & 48) != 0) {
            goto L22;
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(x->ptr, _v20 - x->ptr);
            }
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t159 = _v16->length;
             *( *_v16 + _t159) = _v32 & 4294967295;
            _v16->length = _t159 + 1;
             *( *_v16 + _v16->length) = 0;
            _v20 = _v28;
            continue;
        }
        goto L23;
    }
}

char* shell_quote(char* str)
{// addr = 0x080B3B7B
    Str tmp;
    char* p;
    struct _Str* _v16;
    char* _v20;
    _unknown_ _v40;
    _unknown_ __ebp;
    int _t90;
    int _t103;
    int _t115;

    _v16 = 0;
    _v20 = str;
    while(( *_v20 & 255 & 4294967295) != 0) {
        if(( *( &QUOTE_MAP + ( *_v20 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 8) == 0) {
            if(_v16 != 0) {
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t90 = _v16->length;
                 *( *_v16 + _t90) =  *_v20 & 255 & 4294967295;
                _v16->length = _t90 + 1;
                 *( *_v16 + _v16->length) = 0;
            }
        } else {
            if(_v16 == 0) {
                _v16 = Strnew_charp_n(str, _v20 - str);
            }
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t103 = _v16->length;
             *((char*)( *_v16 + _t103)) = 92;
            _v16->length = _t103 + 1;
             *( *_v16 + _v16->length) = 0;
            if(_v16->length + 1 >= _v16->area_size) {
                Strgrow(_v16);
            }
            _t115 = _v16->length;
             *( *_v16 + _t115) =  *_v20 & 255 & 4294967295;
            _v16->length = _t115 + 1;
             *( *_v16 + _v16->length) = 0;
        }
        _v20 =  &(_v20[1]);
    }
}

char* w3m_dir(const char* name, char* dft)
{// addr = 0x080B3CEA
    _unknown_ __ebp;

    return dft;
}

char* w3m_auxbin_dir()
{// addr = 0x080B3CF2
    _unknown_ _v8;
    _unknown_ __ebp;

    return w3m_dir("W3M_AUXBIN_DIR", "/usr/lib/w3m");
}

char* w3m_lib_dir()
{// addr = 0x080B3D0E
    _unknown_ _v8;
    _unknown_ __ebp;

    return w3m_dir("W3M_LIB_DIR", "/usr/lib/w3m/cgi-bin");
}

char* w3m_etc_dir()
{// addr = 0x080B3D2A
    _unknown_ _v8;
    _unknown_ __ebp;

    return w3m_dir("W3M_ETC_DIR", "/etc");
}

char* w3m_conf_dir()
{// addr = 0x080B3D46
    _unknown_ _v8;
    _unknown_ __ebp;

    return w3m_dir("W3M_CONF_DIR", "/etc/w3m");
}

char* w3m_help_dir()
{// addr = 0x080B3D62
    _unknown_ _v8;
    _unknown_ __ebp;

    return w3m_dir("W3M_HELP_DIR", "/usr/share/w3m");
}

ListItem* newListItem(_Unknown_base* s, ListItem* n, ListItem* p)
{// addr = 0x080B3D80
    ListItem* it;
    ListItem* _v16;
    _unknown_ __ebp;

     *__esp = 12;
    GC_malloc();
    _v16 = __eax;
     *_v16 = s;
    _v16->next = n;
    _v16->prev = p;
    return _v16;
}

GeneralList* newGeneralList()
{// addr = 0x080B3DB4
    GeneralList* tl;
    GeneralList* _v16;
    _unknown_ __ebp;

     *__esp = 12;
    GC_malloc();
    _v16 = __eax;
    _v16->last = 0;
     *_v16 = _v16->last;
    _v16->nitem = 0;
    return _v16;
}

pushValue(GeneralList* tl, _Unknown_base* s)
{// addr = 0x080B3DEC
    ListItem* it;
    short int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(s == 0) {
        return ;
    }
    _v16 = newListItem(s, 0, tl->last);
    if(tl->first != 0) {
         *(tl->last + 4) = _v16;
        tl->last = _v16;
        tl->nitem = (tl->nitem & 65535) + 1 & 4294967295;
        return;
    }
    tl->first = _v16;
    tl->last = _v16;
    tl->nitem = 1;
    return;
}

_Unknown_base* popValue(GeneralList* tl)
{// addr = 0x080B3E68
    ListItem* f;
    ListItem* _v8;
    _unknown_ __ebp;
    _unknown_ _t20;

    if(tl == 0) {
        return 0;
    }
    if(tl->first == 0) {
        return 0;
    }
    _v8 = tl->first;
    tl->first = _v8->next;
    if(tl->first == 0) {
        tl->last = 0;
    } else {
        tl->first->prev = 0;
    }
    tl->nitem = (tl->nitem & 65535) - 1 & 4294967295;
    return  *_v8;
}

_Unknown_base* rpopValue(GeneralList* tl)
{// addr = 0x080B3ED0
    ListItem* f;
    short int _v8;
    _unknown_ __ebp;
    _unknown_ _t24;

    if(tl == 0) {
        return 0;
    }
    if(tl->last == 0) {
        return 0;
    }
    _v8 = tl->last;
    tl->last =  *(_v8 + 8);
    if(tl->last == 0) {
        tl->first = 0;
    } else {
         *(tl->last + 4) = 0;
    }
    tl->nitem = (tl->nitem & 65535) - 1 & 4294967295;
    return  *_v8;
}

delValue(GeneralList* tl, ListItem* it)
{// addr = 0x080B3F3C
    _unknown_ __ebp;

    if(it->prev == 0) {
        tl->first = it->next;
    } else {
        it->prev->next = it->next;
    }
    if(it->next == 0) {
        tl->last = it->prev;
    } else {
        it->next->prev = it->prev;
    }
    tl->nitem = (tl->nitem & 65535) - 1 & 4294967295;
    return;
}

GeneralList* appendGeneralList(GeneralList* tl, GeneralList* tl2)
{// addr = 0x080B3F9F
    _unknown_ __ebp;

    if(tl == 0) {
        return tl;
    }
    if(tl2 == 0) {
        return tl;
    }
    if(tl2->first != 0) {
        if(tl->last == 0) {
            tl->first = tl2->first;
            tl->last = tl2->last;
            tl->nitem = tl2->nitem & 65535 & 4294967295;
        } else {
             *(tl->last + 4) = tl2->first;
            tl2->first->prev = tl->last;
            tl->last = tl2->last;
            tl->nitem = (tl->nitem & 65535) + (tl2->nitem & 65535) & 4294967295;
        }
    }
    tl2->last = 0;
    tl2->first = tl2->last;
    tl2->nitem = 0;
    return tl;
}

TextLine* newTextLine(Str line, int pos)
{// addr = 0x080B4056
    TextLine* lbuf;
    TextLine* _v16;
    _unknown_ __ebp;

     *__esp = 8;
    GC_malloc();
    _v16 = __eax;
    if(line == 0) {
         *_v16 = Strnew();
    } else {
         *_v16 = line;
    }
    _v16->pos = pos & 4294967295;
    return _v16;
}

appendTextLine(TextLineList* tl, Str line, int pos)
{// addr = 0x080B4096
    TextLine* lbuf;
    TextLine* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(tl->last != 0) {
        _v16 = tl->last->ptr;
        if( *_v16 == 0) {
             *_v16 = line;
        } else {
            Strcat( *_v16, line);
        }
        _v16->pos = (_v16->pos & 65535) + pos & 4294967295;
        return;
    }
    pushValue(tl, newTextLine(Strdup(line), pos));
    return;
}

char* tag_get_value(struct parsed_tagarg* t, char* arg)
{// addr = 0x080B4120
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t15;

    while(t != 0) {
        if(strcasecmp(t->arg, arg) == 0) {
            return t->value;
        }
        t = t->next;
    }
}

int tag_exists(struct parsed_tagarg* t, char* arg)
{// addr = 0x080B415E
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t13;
    _unknown_ _t14;

    while(t != 0) {
        if(strcasecmp(t->arg, arg) == 0) {
            return 1;
        }
        t = t->next;
    }
}

struct parsed_tagarg* cgistr2tagarg(char* cgistr)
{// addr = 0x080B419B
    Str tag;
    Str value;
    struct parsed_tagarg* t0;
    struct parsed_tagarg* t;
    struct _Str* _v16;
    _unknown_ _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    intOrPtr _t87;
    _unknown_ _t119;
    _unknown_ _t137;

    _v24 = 0;
    _t87 = _v24;
    _v28 = _t87;
    while(1) {
         *__esp = 12;
        GC_malloc();
        _v28 = _t87;
         *((intOrPtr*)(_v28 + 8)) = _v24;
        _v24 = _v28;
        _v16 = Strnew();
        goto L5;
    }
}

unsigned int hashfunc(char* s)
{// addr = 0x080B4350
    unsigned int h;
    signed int _v8;
    _unknown_ __ebp;

    _v8 = 0;
    while(( *s & 255 & 4294967295) != 0) {
        if(_v8 >= 0) {
            _v8 = _v8 << 1;
        } else {
            _v8 = _v8 << 1;
            _v8 = _v8 | 1;
        }
        _v8 = _v8 + ( *s & 255 & 4294967295);
        s =  &(s[1]);
    }
}

Hash_si* newHash_si(int size)
{// addr = 0x080B4391
    struct Hash_si* hash;
    int i;
    int* _v16;
    signed int _v20;
    _unknown_ __ebp;
    signed int _t19;

     *__esp = 8;
    GC_malloc();
    _v16 = __eax;
     *_v16 = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    _v16[1] = _t19;
    _v20 = 0;
    while(_v20 < size) {
         *(_v16[1] + (_v20 << 2)) = 0;
        _v20 = _v20 + 1;
    }
}

HashItem_si* lookupHash_si(Hash_si* t, char* key, int* hashval_return)
{// addr = 0x080B43F2
    HashItem_si* hi;
    struct HashItem_si* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t23;
    _unknown_ _t37;
    _unknown_ _t41;

     *hashval_return = hashfunc(key) % t->size;
    _v16 = t->tab[ *hashval_return];
    while(_v16 != 0) {
        if(strcmp( *_v16, key) == 0) {
            return _v16;
        }
        _v16 = _v16->next;
    }
}

putHash_si(Hash_si* t, char* key, int value)
{// addr = 0x080B4465
    int h;
    HashItem_si* hi;
    signed int _v16;
    struct HashItem_si* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    HashItem_si* _t30;

    _t30 = lookupHash_si(t, key,  &_v16);
    _v20 = _t30;
    if(_v20 == 0) {
         *__esp = 12;
        GC_malloc();
        _v20 = _t30;
         *_v20 = key;
        _v20->value = value;
        _v20->next = t->tab[_v16];
        t->tab[_v16] = _v20;
        return;
    }
    _v20->value = value;
    return;
}

int getHash_si(Hash_si* t, char* key, int failval)
{// addr = 0x080B44E4
    int h;
    HashItem_si* hi;
    int _v16;
    HashItem_si* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v20 = lookupHash_si(t, key,  &_v16);
    if(_v20 != 0) {
        return _v20->value;
    }
    return failval;
}

Hash_ss* newHash_ss(int size)
{// addr = 0x080B4519
    struct Hash_ss* hash;
    int i;
    int* _v16;
    signed int _v20;
    _unknown_ __ebp;
    signed int _t19;

     *__esp = 8;
    GC_malloc();
    _v16 = __eax;
     *_v16 = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    _v16[1] = _t19;
    _v20 = 0;
    while(_v20 < size) {
         *(_v16[1] + (_v20 << 2)) = 0;
        _v20 = _v20 + 1;
    }
}

HashItem_ss* lookupHash_ss(Hash_ss* t, char* key, int* hashval_return)
{// addr = 0x080B457A
    HashItem_ss* hi;
    struct HashItem_ss* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t23;
    _unknown_ _t37;
    _unknown_ _t41;

     *hashval_return = hashfunc(key) % t->size;
    _v16 = t->tab[ *hashval_return];
    while(_v16 != 0) {
        if(strcmp( *_v16, key) == 0) {
            return _v16;
        }
        _v16 = _v16->next;
    }
}

putHash_ss(Hash_ss* t, char* key, char* value)
{// addr = 0x080B45ED
    int h;
    HashItem_ss* hi;
    signed int _v16;
    struct HashItem_ss* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    HashItem_ss* _t30;

    _t30 = lookupHash_ss(t, key,  &_v16);
    _v20 = _t30;
    if(_v20 == 0) {
         *__esp = 12;
        GC_malloc();
        _v20 = _t30;
         *_v20 = key;
        _v20->value = value;
        _v20->next = t->tab[_v16];
        t->tab[_v16] = _v20;
        return;
    }
    _v20->value = value;
    return;
}

char* getHash_ss(Hash_ss* t, char* key, char* failval)
{// addr = 0x080B466C
    int h;
    HashItem_ss* hi;
    int _v16;
    HashItem_ss* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v20 = lookupHash_ss(t, key,  &_v16);
    if(_v20 != 0) {
        return _v20->value;
    }
    return failval;
}

Hash_sv* newHash_sv(int size)
{// addr = 0x080B46A1
    struct Hash_sv* hash;
    int i;
    int* _v16;
    signed int _v20;
    _unknown_ __ebp;
    signed int _t19;

     *__esp = 8;
    GC_malloc();
    _v16 = __eax;
     *_v16 = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    _v16[1] = _t19;
    _v20 = 0;
    while(_v20 < size) {
         *(_v16[1] + (_v20 << 2)) = 0;
        _v20 = _v20 + 1;
    }
}

HashItem_sv* lookupHash_sv(Hash_sv* t, char* key, int* hashval_return)
{// addr = 0x080B4702
    HashItem_sv* hi;
    struct HashItem_sv* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t23;
    _unknown_ _t37;
    _unknown_ _t41;

     *hashval_return = hashfunc(key) % t->size;
    _v16 = t->tab[ *hashval_return];
    while(_v16 != 0) {
        if(strcmp( *_v16, key) == 0) {
            return _v16;
        }
        _v16 = _v16->next;
    }
}

putHash_sv(Hash_sv* t, char* key, _Unknown_base* value)
{// addr = 0x080B4775
    int h;
    HashItem_sv* hi;
    signed int _v16;
    struct HashItem_sv* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    HashItem_sv* _t30;

    _t30 = lookupHash_sv(t, key,  &_v16);
    _v20 = _t30;
    if(_v20 == 0) {
         *__esp = 12;
        GC_malloc();
        _v20 = _t30;
         *_v20 = key;
        _v20->value = value;
        _v20->next = t->tab[_v16];
        t->tab[_v16] = _v20;
        return;
    }
    _v20->value = value;
    return;
}

_Unknown_base* getHash_sv(Hash_sv* t, char* key, _Unknown_base* failval)
{// addr = 0x080B47F4
    int h;
    HashItem_sv* hi;
    int _v16;
    HashItem_sv* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v20 = lookupHash_sv(t, key,  &_v16);
    if(_v20 != 0) {
        return _v20->value;
    }
    return failval;
}

Hash_iv* newHash_iv(int size)
{// addr = 0x080B4829
    struct Hash_iv* hash;
    int i;
    int* _v16;
    signed int _v20;
    _unknown_ __ebp;
    signed int _t19;

     *__esp = 8;
    GC_malloc();
    _v16 = __eax;
     *_v16 = size;
    _t19 = size << 2;
     *__esp = _t19;
    GC_malloc();
    _v16[1] = _t19;
    _v20 = 0;
    while(_v20 < size) {
         *(_v16[1] + (_v20 << 2)) = 0;
        _v20 = _v20 + 1;
    }
}

HashItem_iv* lookupHash_iv(Hash_iv* t, int key, int* hashval_return)
{// addr = 0x080B488A
    HashItem_iv* hi;
    struct HashItem_iv* _v8;
    _unknown_ __ebp;
    _unknown_ _t22;
    _unknown_ _t34;
    _unknown_ _t37;

     *hashval_return = key % t->size;
    _v8 = t->tab[ *hashval_return];
    while(_v8 != 0) {
        if( *_v8 == key) {
            return _v8;
        }
        _v8 = _v8->next;
    }
}

putHash_iv(Hash_iv* t, int key, _Unknown_base* value)
{// addr = 0x080B48E1
    int h;
    HashItem_iv* hi;
    signed int _v16;
    struct HashItem_iv* _v20;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    HashItem_iv* _t30;

    _t30 = lookupHash_iv(t, key,  &_v16);
    _v20 = _t30;
    if(_v20 == 0) {
         *__esp = 12;
        GC_malloc();
        _v20 = _t30;
         *_v20 = key;
        _v20->value = value;
        _v20->next = t->tab[_v16];
        t->tab[_v16] = _v20;
        return;
    }
    _v20->value = value;
    return;
}

_Unknown_base* getHash_iv(Hash_iv* t, int key, _Unknown_base* failval)
{// addr = 0x080B4960
    int h;
    HashItem_iv* hi;
    int _v8;
    HashItem_iv* _v12;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ __ebp;

    _v12 = lookupHash_iv(t, key,  &_v8);
    if(_v12 != 0) {
        return _v12->value;
    }
    return failval;
}

wc_char_conv_init(wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080B4998
    _unknown_ _v24;
    _unknown_ __ebp;

    wc_input_init(f_ces,  &char_conv_st);
     *135789960 = -1;
    char_conv_f_ces = f_ces;
    char_conv_t_ces = t_ces;
    return;
}

Str wc_char_conv(char c)
{// addr = 0x080B49CD
    signed char _v16;
    _unknown_ _v36;
    struct * _v40;
    _unknown_ __ebp;
    struct _Str* _t13;

    _v16 = c & 4294967295;
    _t13 = _v16 & 255 & 4294967295 & ;
    _v40 =  &char_conv_st;
     *__esp = _t13;
     *((intOrPtr*)( *((intOrPtr*)(char_conv_st.marks + 28))))();
    wc_Str_conv(_t13, 3211264, char_conv_t_ces);
    return;
}

wc_ces wc_guess_charset(char* charset, wc_ces orig)
{// addr = 0x080B4A18
    wc_ces guess;
    unsigned int _v16;
    _unknown_ __ebp;

    if(charset == 0) {
        return orig;
    }
    if(( *charset & 255 & 4294967295) == 0) {
        return orig;
    }
    _v16 = wc_charset_to_ces(charset);
    if(_v16 == 0) {
        return orig;
    }
    return _v16;
}

wc_ces wc_guess_charset_short(char* charset, wc_ces orig)
{// addr = 0x080B4A51
    wc_ces guess;
    unsigned int _v16;
    _unknown_ __ebp;

    if(charset == 0) {
        return orig;
    }
    if(( *charset & 255 & 4294967295) == 0) {
        return orig;
    }
    _v16 = wc_charset_short_to_ces(charset);
    if(_v16 == 0) {
        return orig;
    }
    return _v16;
}

wc_ces wc_guess_locale_charset(char* locale, wc_ces orig)
{// addr = 0x080B4A8A
    wc_ces guess;
    unsigned int _v16;
    _unknown_ __ebp;

    if(locale == 0) {
        return orig;
    }
    if(( *locale & 255 & 4294967295) == 0) {
        return orig;
    }
    _v16 = wc_locale_to_ces(locale);
    if(_v16 == 0) {
        return orig;
    }
    return _v16;
}

wc_ces wc_charset_to_ces(char* charset)
{// addr = 0x080B4AC3
    char* p;
    char[15] buf;
    int n;
    intOrPtr _v16;
    _unknown_ _v32;
    char* _v36;
    intOrPtr _v40;
    char* _v48;
    _unknown_ __ebp;
    _unknown_ _t44;
    signed int _t48;
    _unknown_ _t57;
    _unknown_ _t58;
    signed int _t67;
    _unknown_ _t72;
    _unknown_ _t77;

    _v48 = charset;
    _v16 =  *gs:0x14];
    _v36 = _v48;
    _t48 =  *_v36 & 255 & 4294967295;
     *__esp = _t48;
    tolower();
    if(_t48 == 120) {
        if((_v36[1] & 255 & 4294967295) == 45) {
            _v36 =  &(_v36[2]);
        }
    }
    _v40 = 0;
    while(( *_v36 & 255 & 4294967295) != 0 && _v40 <= 14) {
        if(( *_v36 & 255 & 4294967295) > 32 && ( *_v36 & 255 & 4294967295) != 95 && ( *_v36 & 255 & 4294967295) != 45) {
            _t67 =  *_v36 & 255 & 4294967295;
             *__esp = _t67;
            tolower();
             *(__ebp + _v40 - 28) = _t67 & 4294967295;
            _v40 = _v40 + 1;
        }
        _v36 =  &(_v36[1]);
    }
}

wc_ces wc_charset_short_to_ces(char* charset)
{// addr = 0x080B568A
    char* p;
    char[15] buf;
    wc_ces ces;
    int n;
    intOrPtr _v16;
    char _v32;
    char* _v36;
    signed int _v40;
    unsigned int _v44;
    char* _v48;
    _unknown_ __ebp;
    _unknown_ _t42;
    signed int _t47;
    unsigned int _t54;
    _unknown_ _t55;
    signed int _t57;
    signed int _t59;
    signed int _t61;
    signed int _t64;
    _unknown_ _t66;

    _v48 = charset;
    _v16 =  *gs:0x14];
    _v36 = _v48;
    _v40 = wc_charset_to_ces(_v48);
    __eflags = _v40;
    if(__eflags == 0) {
        _v44 = 0;
        while(1) {
            _t47 =  *_v36 & 255;
            __eflags = _t47 & 4294967295;
            if((_t47 & 4294967295) == 0) {
                break;
            }
            __eflags = _v44 - 14;
            if(_v44 <= 14) {
                _t57 =  *_v36 & 255;
                __eflags = (_t57 & 4294967295) - 32;
                if((_t57 & 4294967295) > 32) {
                    _t59 =  *_v36 & 255;
                    __eflags = (_t59 & 4294967295) - 95;
                    if((_t59 & 4294967295) != 95) {
                        _t61 =  *_v36 & 255;
                        __eflags = (_t61 & 4294967295) - 45;
                        if((_t61 & 4294967295) != 45) {
                            _t64 =  *_v36 & 255 & 4294967295;
                             *__esp = _t64;
                            tolower();
                             *((intOrPtr*)(__ebp + _v44 - 28)) = _t64 & 4294967295;
                            _v44 = _v44 + 1;
                        }
                    }
                }
                _v36 =  &(_v36[1]);
                continue;
            }
            break;
        }
L10:
         *(__ebp + _v44 - 28) = 0;
        _v36 =  &_v32;
        __eflags = ( *_v36 & 255 & 4294967295) - 97 - 22;
        if(__eflags > 0) {
            _t54 = 0;
            goto L13;
        }
        goto __eax;
    } else {
        _t54 = _v40;
    }
L13:
    if(__eflags == 0) {
        return _t54;
    }
    __stack_chk_fail();
    return _t54;
}

wc_ces wc_locale_to_ces(char* locale)
{// addr = 0x080B5999
    char* p;
    char[5] buf;
    int n;
    char* cs;
    char* _v16;
    signed int _v20;
    char* _v24;
    char _v30;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    signed int _t69;
    _unknown_ _t79;
    _unknown_ _t90;
    _unknown_ _t91;
    signed int _t97;
    signed int _t108;
    _unknown_ _t115;

    _v16 = locale;
    _t69 =  *_v16 & 255;
    if((_t69 & 4294967295) != 67) {
L3:
         *__esp = 14;
        nl_langinfo();
        _v24 = _t69;
        if(_v24 == 0) {
L6:
            _v20 = 0;
            while(( *_v16 & 255 & 4294967295) != 0) {
                if(( *_v16 & 255 & 4294967295) == 46 || _v20 > 4) {
                     *(__ebp + _v20 - 26) = 0;
                    if(( *_v16 & 255 & 4294967295) != 46) {
                        if(strcmp( &_v30, "japanese") == 0) {
                            return 3153976;
                        }
                        if(strcmp( &_v30, "zh_tw") == 0) {
                            return 3153981;
                        }
                        if(strcmp( &_v30, "zh_hk") == 0) {
                            return 3153981;
                        }
                        _v20 = 0;
                        while( *( &lang_ces_table + _v20 * 8) != 0) {
                            if(strncmp( &_v30,  *( &lang_ces_table + _v20 * 8), 2) == 0) {
                                return  *((intOrPtr*)(135117092 + _v20 * 8));
                            }
                            _v20 = _v20 + 1;
                        }
                    }
                    goto L14;
                    return 3153976;
                } else {
                    if(( *_v16 & 255 & 4294967295) > 32) {
                        _t108 =  *_v16 & 255 & 4294967295;
                         *__esp = _t108;
                        tolower();
                         *(__ebp + _v20 - 26) = _t108 & 4294967295;
                        _v20 = _v20 + 1;
                    }
                    _v16 =  &(_v16[1]);
                    continue;
                }
L14:
                _v16 =  &(_v16[1]);
                if(strcasecmp(_v16, "euc") != 0) {
                    return wc_charset_to_ces(_v16);
                }
                _t97 = _v30 & 255 & 4294967295;
                if(_t97 == 107) {
                    WcLocale = 5;
                    return wc_charset_to_ces(_v16);
                } else {
                    if(_t97 == 122) {
                        goto L20;
                    }
                    if(_t97 != 106) {
                        WcLocale = 0;
                        return wc_charset_to_ces(_v16);
                    }
                    WcLocale = 1;
                    return wc_charset_to_ces(_v16);
L21:
                    WcLocale = 3;
                    return wc_charset_to_ces(_v16);
                }
L20:
                if(strcmp( &_v30, "zh_tw") != 0) {
                    if(strcmp( &_v30, "zh_hk") != 0) {
                        WcLocale = 2;
                        return wc_charset_to_ces(_v16);
                    }
                    goto L23;
                }
                goto L21;
L23:
                WcLocale = 4;
                return wc_charset_to_ces(_v16);
            }
        } else {
            if(strcmp(_v24, "US-ASCII") == 0) {
                goto L6;
            } else {
                return wc_charset_to_ces(_v24);
            }
        }
    } else {
        _t69 = _v16[1] & 255;
        if((_t69 & 4294967295) != 0) {
            goto L3;
        } else {
            return 256;
        }
    }
}

char* wc_ces_to_charset(wc_ces ces)
{// addr = 0x080B5BCC
    _unknown_ __ebp;

    if(ces != 3211264) {
        return  *((intOrPtr*)(((ces & 255) << 5) + 135767972));
    }
    return "WTF";
}

char* wc_ces_to_charset_desc(wc_ces ces)
{// addr = 0x080B5BF2
    _unknown_ __ebp;

    if(ces != 3211264) {
        return  *((intOrPtr*)(((ces & 255) << 5) + 135767976));
    }
    return "W3M Transfer Format";
}

wc_ces wc_guess_8bit_charset(wc_ces orig)
{// addr = 0x080B5C18
    _unknown_ __ebp;
    unsigned int _t3;
    _unknown_ _t4;
    _unknown_ _t5;
    _unknown_ _t7;
    _unknown_ _t8;

    _t3 = orig;
    if(_t3 > 2099219) {
        if(_t3 == 2099221) {
            return 3149849;
        }
        if(_t3 < 2099221) {
            return 3149847;
        }
        if(_t3 == 2105404) {
            return 3149847;
        }
        return orig;
    }
    if(_t3 >= 2099217) {
        return 3149846;
    }
    if(_t3 == 256) {
        return 1049089;
    }
    return orig;
}

wc_bool wc_check_ces(wc_ces ces)
{// addr = 0x080B5C6D
    size_t i;
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t9;
    _unknown_ _t13;

    _v8 = ces & 255;
    if(_v8 > 70) {
        return 0;
    }
    if( *((intOrPtr*)( &WcCesInfo + (_v8 << 5))) != ces) {
        return 0;
    }
    return 1;
}

int wc_ces_list_cmp(* a, * b)
{// addr = 0x080B5CA3
    _unknown_ _v24;
    _unknown_ __ebp;

    return strcasecmp( *(a + 8),  *(b + 8));
}

wc_ces_list* wc_get_ces_list()
{// addr = 0x080B5CC3
    wc_ces_info* info;
    size_t n;
    wc_ces_info[71]* _v16;
    intOrPtr _v20;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t55;
    _unknown_ _t94;

    if( *135789984 != 0) {
        return  *135789984;
    }
    _v16 =  &WcCesInfo;
    _v20 = 0;
    while( *_v16 != 0) {
        if( *((intOrPtr*)(_v16 + 4)) != 0) {
            _v20 = _v20 + 1;
        }
        _v16 = _v16 + 32;
    }
}

Str wc_Str_conv(Str is, wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080B5E24
    unsigned int _v24;
    _unknown_ __ebp;
    _unknown_ _t13;
    struct _Str* _t22;

    if(f_ces != 3211264) {
        _v24 = f_ces;
        _t22 = is;
         *__esp = _t22;
         *((intOrPtr*)( *((intOrPtr*)(((f_ces & 255) + (f_ces & 255) + 1 << 4) + 135767972))))();
        is = _t22;
    }
    if(t_ces == 3211264) {
        return ;
    }
    wc_conv_to_ces(is, t_ces);
    return;
}

Str wc_Str_conv_strict(Str is, wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080B5E7D
    Str os;
    wc_option opt;
    struct _Str* _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    BufferPoint* _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v32 = WcOption.marks;
    _v28 =  *135119012;
    _v24 =  *135119016;
    _v20 =  *135119020;
     *135119020 = 1;
     *135119022 = 1;
     *135119013 = 0;
    _v16 = wc_Str_conv(is, f_ces, t_ces);
    WcOption.marks = _v32;
     *135119012 = _v28;
     *135119016 = _v24;
     *135119020 = _v20;
    return _v16;
}

Str wc_conv_to_ces(Str is, wc_ces ces)
{// addr = 0x080B5EF9
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    wc_status st;
    _unknown_ _v8;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    char* _v32;
    intOrPtr _v36;
    char* _v40;
    intOrPtr _v44;
    intOrPtr _v104;
    intOrPtr* _v116;
    char** _v120;
    wc_uchar* _v124;
    _unknown_ __ebp;
    unsigned int _t122;
    unsigned int _t133;
    _unknown_ _t142;
    int _t162;
    _unknown_ _t201;

    _push(__ebx);
    __esp = __esp - 116;
    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _t122 = ces;
    if(_t122 < 1066050) {
L15:
        _v28 = _v20;
L17:
        while(_v28 < _v24) {
            if(( *_v28 & 255 & 4294967295) >= 0) {
                goto L16;
            }
            goto L24;
        }
    }
    if(_t122 <= 1066052) {
        _v28 = _v20;
L11:
        while(_v28 < _v24) {
            if(( *_v28 & 255 & 4294967295) <= 31) {
                goto L24;
            }
            if(( *_v28 & 255 & 4294967295) >= 0) {
                goto L10;
            }
            goto L24;
        }
    }
    if(_t122 != 2105404) {
        goto L15;
    } else {
        _v28 = _v20;
        while(_v28 < _v24) {
            if(( *_v28 & 255 & 4294967295) == 126) {
                goto L24;
            }
            if(( *_v28 & 255 & 4294967295) >= 0) {
                _v28 =  &(_v28[1]);
                continue;
            }
L24:
            if(_v28 == _v24) {
                return ;
            }
            _v16 = Strnew_size(is->length);
            if(_v28 > _v20) {
                _v28 = _v28 - 1;
            }
            if(_v28 > _v20) {
                Strcat_charp_n(_v16, is->ptr, _v28 - _v20);
            }
            wc_output_init(ces,  &_v104);
            _t133 = ces;
            if(_t133 > 2099221) {
                if(_t133 == 2129990) {
                    goto L40;
                }
                goto L35;
L41:
            } else {
                if(_t133 >= 2099217) {
                    goto L43;
                }
                if(_t133 - 1066050 > 2) {
L52:
                    while(_v28 < _v24) {
                        if(( *_v28 & 255 & 4294967295) >= 0 || ( *( &WTF_WIDTH_MAP + (_v28[1] & 255 & 4294967295 & )) & 255 & 4294967295) == 0) {
                            _v120 =  &_v28;
                            wtf_parse( &_v44);
                            __esp = __esp - 4;
                            _v116 =  &_v104;
                            _v124 = _v44;
                            _v120 = _v40;
                             *__esp = _v16;
                             *((intOrPtr*)( *((intOrPtr*)(_v104 + 24))))();
                        } else {
                            if(_v16->length + 1 >= _v16->area_size) {
                                Strgrow(_v16);
                            }
                            _t162 = _v16->length;
                             *( *_v16 + _t162) =  *_v28 & 255 & 4294967295;
                            _v16->length = _t162 + 1;
                             *((char*)( *_v16 + _v16->length)) = 0;
                            _v28 =  &(_v28[1]);
                        }
                    }
                }
L43:
                while(_v28 < _v24) {
                    _v120 =  &_v28;
                    wtf_parse( &_v36);
                    __esp = __esp - 4;
                    _v116 =  &_v104;
                    _v124 = _v36;
                    _v120 = _v32;
                     *__esp = _v16;
                     *((intOrPtr*)( *((intOrPtr*)(_v104 + 24))))();
                }
                goto L52;
L40:
            }
            goto L43;
L35:
            if(_t133 == 3178565) {
                goto L41;
            }
            if(_t133 == 2105404) {
                goto L42;
            }
            goto L52;
L42:
            goto L43;
        }
    }
    goto L16;
L10:
    _v28 =  &(_v28[1]);
    goto L11;
L16:
    _v28 =  &(_v28[1]);
    goto L17;
}

Str wc_Str_conv_with_detect(Str is, wc_ces* f_ces, wc_ces hint, wc_ces t_ces)
{// addr = 0x080B618F
    wc_ces detect;
    unsigned int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if( *f_ces == 3211264 || hint == 3211264) {
         *f_ces = 3211264;
        _v16 = 3211264;
        return wc_Str_conv(is, _v16, t_ces);
    }
    if((WcOption.marks & 255 & 4294967295) == 0) {
         *f_ces = hint;
        _v16 = hint;
        return wc_Str_conv(is, _v16, t_ces);
    }
    if(( *f_ces & 1048576) != 0) {
        hint =  *f_ces;
    }
    _v16 = wc_auto_detect(is->ptr, is->length, hint);
    if((WcOption.marks & 255 & 4294967295) != 2) {
        if((_v16 & 2048) == 0) {
            return wc_Str_conv(is, _v16, t_ces);
        }
        if(( *f_ces & 1048576) != 0) {
            return wc_Str_conv(is, _v16, t_ces);
        }
         *f_ces = _v16;
        return wc_Str_conv(is, _v16, t_ces);
    } else {
        if((_v16 & 1048576) == 0) {
            if((_v16 & 130560) == 0) {
                return wc_Str_conv(is, _v16, t_ces);
            }
            if(( *f_ces & 1048576) != 0) {
                return wc_Str_conv(is, _v16, t_ces);
            }
        }
         *f_ces = _v16;
        return wc_Str_conv(is, _v16, t_ces);
    }
}

wc_push_end(Str os, wc_status* st)
{// addr = 0x080B628E
    _unknown_ _v24;
    _unknown_ __ebp;

    if((st->ces_info->id & 2048) == 0) {
        if(st->ces_info->id != 2105404) {
            if(st->ces_info->id != 3178565) {
                if(st->ces_info->id != 2129990) {
                    return ;
                }
                wc_push_to_utf7_end(os, st);
                return;
            }
            goto L5;
        }
        goto L3;
L5:
        wc_push_to_utf8_end(os, st);
        return;
    }
    wc_push_to_iso2022_end(os, st);
    return;
L3:
    wc_push_to_hz_end(os, st);
    return;
}

wc_create_detect_map(wc_ces ces, wc_bool esc)
{// addr = 0x080B6320
    int i;
    wc_uint8* map;
    signed int _v8;
    wc_uint8[31]* _v12;
    signed int _v24;
    _unknown_ __ebp;
    signed int _t40;
    signed int _t44;
    unsigned int _t46;

    _v24 = esc & 4294967295;
    if(ces == detect_ces) {
        if(_v24 != 0 || (ces & 2048) != 0) {
            _t40 = 1;
        } else {
            _t40 = 0;
        }
         *135117243 = _t40 & 4294967295;
        return;
    }
    _t44 = ces & 16384;
    if(_t44 == 0) {
        _v8 = 0;
L14:
        while(_v8 <= 31) {
            goto L13;
        }
    }
    _v12 = 0;
    _t46 = ces;
    if(_t46 == 1066051) {
        _v12 =  &wc_c0_viscii112_map;
    } else {
        if(_t46 == 1066052) {
            _v12 =  &wc_c0_vps2_map;
        } else {
            if(_t46 == 1066050) {
                _v12 =  &wc_c0_tcvn57122_map;
            }
        }
    }
    _v8 = 0;
    while(_v8 <= 31) {
         *( &WC_DETECT_MAP + _v8) =  *(_v12 + _v8) & 255 & 4294967295;
        _v8 = _v8 + 1;
    }
L13:
    _t44 = _v8;
     *( &WC_DETECT_MAP + _t44) = 0;
    _v8 = _v8 + 1;
    goto L14;
}

wc_ces wc_auto_detect(char* is, size_t len, wc_ces hint)
{// addr = 0x080B6412
    wc_uchar* p;
    wc_uchar* ep;
    wc_uchar* q;
    wc_ces euc;
    wc_ces priv;
    wc_status st;
    int euc_state;
    int sjis_state;
    int big5_state;
    int hz_state;
    int iso_detect;
    int euc_detect;
    int sjis_detect;
    int big5_detect;
    int hz_detect;
    int latin_detect;
    int priv_detect;
    int possible;
    wc_bool iso2022jp2;
    wc_bool iso2022jp3;
    wc_bool iso2022cn;
    wc_bool iso2022kr;
    wc_bool ok;
    int utf8_state;
    int utf8_detect;
    int utf8_next;
    unsigned char _v13;
    unsigned char _v14;
    unsigned char _v15;
    unsigned char _v16;
    unsigned char _v17;
    wc_uchar* _v24;
    intOrPtr _v28;
    wc_uchar* _v32;
    signed int _v36;
    unsigned int _v40;
    signed int _v44;
    signed int _v48;
    signed int _v52;
    signed int _v56;
    signed int _v60;
    signed int _v64;
    signed int _v68;
    signed int _v72;
    signed int _v76;
    signed int _v80;
    signed int _v84;
    signed int _v88;
    unsigned char _v92;
    signed int _v96;
    signed int _v100;
    signed int _v132;
    signed int _v136;
    intOrPtr _v140;
    signed int _v144;
    struct  _v160;
    _unknown_ _v184;
    _unknown_ __ebp;
    unsigned int _t364;
    unsigned int _t369;
    _unknown_ _t373;
    _unknown_ _t380;
    _unknown_ _t381;
    _unknown_ _t382;
    _unknown_ _t384;
    _unknown_ _t385;
    _unknown_ _t386;
    _unknown_ _t387;
    _unknown_ _t392;
    signed int _t395;
    _unknown_ _t396;
    _unknown_ _t397;
    _unknown_ _t398;
    _unknown_ _t399;
    _unknown_ _t400;
    _unknown_ _t401;
    _unknown_ _t402;
    _unknown_ _t403;
    _unknown_ _t405;
    unsigned char _t406;
    signed int _t412;
    signed int _t428;
    _unknown_ _t432;
    _unknown_ _t433;
    signed int _t434;
    signed int _t439;
    signed int _t448;
    signed int _t450;
    signed int _t459;
    _unknown_ _t473;
    signed int _t474;
    signed int _t481;
    _unknown_ _t498;
    signed int _t501;

    _v24 = is;
    _v28 = _v24 + len;
    _v36 = 0;
    _v40 = 0;
    _v44 = 0;
    _v48 = 0;
    _v52 = 0;
    _v56 = 0;
    _v60 = 8;
    _v64 = 8;
    _v68 = 8;
    _v72 = 8;
    _v76 = 8;
    _v80 = 8;
    _v84 = 8;
    _v88 = 0;
    _v13 = 0;
    _v14 = 0;
    _v15 = 0;
    _v16 = 0;
    _v17 = 0;
    _v92 = 0;
    _v96 = 8;
    _v100 = 0;
    wc_create_detect_map(hint, 1);
L2:
    while(_v24 < _v28) {
L3:
        if(( *( &WC_DETECT_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295) == 0) {
            _v24 =  &(_v24[1]);
            goto L2;
        }
        if(_v24 == _v28) {
            return hint;
        }
        _t364 = hint;
        if(_t364 == 3149846) {
L25:
            _v36 = 3149846;
            _v44 = 0;
            _v48 = 0;
            _v68 = 0;
            _v64 = _v68;
            _v60 = _v64;
            _v88 = 3;
            goto L35;
        } else {
            if(_t364 > 3149846) {
                if(_t364 > 3153977) {
                    if(_t364 == 3153981) {
                        goto L27;
                    }
                    goto L23;
                }
                goto L17;
L23:
                if(_t364 == 3178565) {
                    _v60 = 0;
                    _v88 = 1;
                    goto L35;
                } else {
                    goto L32;
                }
                goto L36;
            }
            if(_t364 > 2099219) {
                if(_t364 == 2099221) {
L29:
                    _v36 = 3149849;
                    _v44 = 0;
                    _v64 = 0;
                    _v60 = _v64;
                    _v88 = 3;
                    goto L35;
                }
                goto L13;
            }
            if(_t364 >= 2099217) {
                goto L25;
            }
            if(_t364 == 256) {
                _v80 = 0;
                _v60 = _v80;
                _v88 = 2;
L35:
                if(_v84 == 8) {
L36:
                    _v96 = 0;
                    _v88 = _v88 + 1;
                }
                wc_input_init(256,  &_v160);
                while(_v24 < _v28) {
                    if(_v88 == 0 || _v88 == 1 && _v17 != 0) {
                        if(_v60 == 8) {
                            _t369 = hint;
                            if(_t369 > 3149849) {
                                if(_t369 == 3153981) {
                                    if(_v72 != 8) {
                                        return hint;
                                    }
L234:
                                    if(_v64 == 2) {
                                        return _v36;
                                    }
                                    if(_v68 == 2) {
                                        return 3153976;
                                    }
                                    if(_v72 == 2) {
                                        return 3153981;
                                    }
                                    if(_v96 == 2) {
                                        return 3178565;
                                    }
                                    if((_v68 & 1 & 4294967295) != 0) {
                                        return 3153976;
                                    }
                                    if(_v64 != 8) {
                                        return _v36;
                                    }
                                    if(_v68 != 8) {
                                        return 3153976;
                                    }
                                    if(_v72 != 8) {
                                        return 3153981;
                                    }
                                    if(_v96 == 8) {
                                        return hint;
                                    }
                                    return 3178565;
                                }
                                goto L207;
                            }
                            goto L201;
L207:
                            if(_t369 > 3153981) {
                                if(_t369 == 3178565) {
                                    return hint;
                                }
L224:
                                if(_v80 != 8) {
                                    return hint;
                                }
                                if(_v84 != 8) {
                                    return hint;
                                }
                                if(_v96 == 8) {
                                    return hint;
                                }
                                return 3178565;
                            }
                            if(_t369 - 3153976 > 1) {
                                goto L224;
                            }
                            if(_v68 != 8) {
                                return hint;
                            }
                            goto L234;
                        }
                        goto L176;
L201:
                        if(_t369 >= 3149846) {
                            if(_v64 != 8) {
                                return hint;
                            }
                            goto L234;
                        }
                        if(_t369 == 256) {
                            if(_v96 != 8) {
                                return hint;
                            }
                            if(_v80 == 8) {
                                return hint;
                            }
                            return 1049089;
                        }
                        if(_t369 < 256 || _t369 - 2099217 > 4) {
                            goto L224;
                        }
                        goto L234;
                    } else {
                        if(_v60 == 8) {
L77:
                            if(_v64 == 8) {
L98:
                                if(_v68 == 8) {
L118:
                                    if(_v72 != 8) {
                                        _t434 = _v52;
                                        if(_t434 == 0) {
                                            _t439 =  *( &WC_BIG5_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                                            if(_t439 == 2) {
                                                _v72 = 8;
                                            } else {
                                                if(_t439 == 7) {
                                                    _v52 = 1;
                                                }
                                            }
                                        } else {
                                            if(_t434 == 1) {
                                                if(( *( &WC_BIG5_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                                                    if((_v72 & 4) != 0) {
                                                        _t448 = 8;
                                                    } else {
                                                        _t448 = _v72 | 4;
                                                    }
                                                    _v72 = _t448;
                                                } else {
                                                    _v72 = _v72 | 2;
                                                    _v17 = 1;
                                                }
                                                _v52 = 0;
                                            }
                                        }
                                        if(_v72 == 8) {
                                            _v88 = _v88 - 1;
                                        }
                                    }
                                    if(_v76 == 8) {
L141:
                                        if(_v80 != 8) {
                                            _t428 =  *( &WC_ISO_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 240;
                                            if(_t428 == 80) {
                                                _v80 = 8;
                                            } else {
                                                if(_t428 == 96 || _t428 == 64) {
                                                    _v80 = _v80 | 2;
                                                    _v17 = 1;
                                                }
                                            }
                                            if(_v80 == 8) {
                                                _v88 = _v88 - 1;
                                            }
                                        }
                                        if(_v84 != 8 && ( *_v24 & 255 & 4294967295) != 27 && ( *( &WC_DETECT_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295) != 0) {
                                            _v84 = _v84 | 2;
                                            _v17 = 1;
                                        }
                                        if(_v96 == 8) {
                                            goto L173;
                                        }
                                        _t406 = _v92;
                                        if(_t406 == 0) {
                                            _v100 =  *( &WC_UTF8_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                                            _t412 = _v100;
                                            if(_t412 == 1) {
L163:
L166:
                                                goto L171;
                                            }
                                            goto L158;
L164:
                                            _v96 = 8;
                                            goto L166;
                                        }
                                        if(_t406 == 1) {
                                            if(( *( &WC_UTF8_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295) == 0) {
                                                _v100 = _v100 - 1;
                                                if(_v100 == 0) {
                                                    _v96 = _v96 | 2;
                                                    _v17 = 1;
                                                    _v92 = 0;
                                                }
                                            } else {
                                                _v96 = 8;
                                                _v92 = 0;
                                            }
                                        }
L171:
                                        if(_v96 == 8) {
                                            _v88 = _v88 - 1;
                                        }
                                        goto L173;
L158:
                                        if(_t412 > 1) {
                                            if(_t412 == 7) {
                                                goto L164;
                                            }
                                            goto L162;
                                        }
                                        if(_t412 == 0) {
                                            goto L164;
                                        }
L165:
                                        _v100 = _v100 - 1;
                                        _v92 = 1;
                                        goto L171;
L162:
                                        if(_t412 != 8) {
                                            goto L165;
                                        }
                                        goto L163;
                                    }
                                    if(( *_v24 & 255 & 4294967295) >= 0) {
                                        if(_v56 > 4) {
                                            goto L141;
                                        }
                                        goto L140;
                                    }
                                    _v76 = 8;
                                    _v88 = _v88 - 1;
                                    goto L141;
L140:
                                    goto __eax;
                                }
                                goto L99;
                            }
                            goto L78;
L99:
                            _t450 = _v48;
                            if(_t450 == 1) {
                                if(( *( &WC_SJIS_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 16) == 0) {
                                    if((_v68 & 4) != 0) {
                                        _t459 = 8;
                                    } else {
                                        _t459 = _v68 | 4;
                                    }
                                    _v68 = _t459;
                                } else {
                                    _v68 = _v68 | 2;
                                    _v17 = 1;
                                }
                                _v48 = 0;
L116:
                                if(_v68 == 8) {
                                    _v88 = _v88 - 1;
                                }
                                goto L118;
                            }
                            if(_t450 == 3) {
                                if(( *( &WC_SJIS_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 16) == 0) {
                                    _v68 = 8;
                                } else {
                                    _v68 = _v68 | 1;
                                }
                                _v48 = 0;
                                goto L116;
                            }
                            if(_t450 != 0) {
                                goto L116;
                            }
                            if(( *( &WC_SJIS_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 & ) - 18 > 46) {
                                goto L116;
                            }
                            goto __eax;
                            goto L116;
                        }
                        _t501 =  *_v24 & 255 & 4294967295 & ;
                        if(_t501 < 14) {
L72:
                            if(( *_v24 & 255 & 4294967295) < 0) {
                                _v60 = 8;
                                _v88 = _v88 - 1;
                            }
                            goto L77;
                        }
                        if(_t501 <= 15) {
                            _v60 = 2;
                            _v17 = 1;
                            _v15 = 1;
                            _v16 = 1;
                            goto L77;
                        }
                        if(_t501 != 27) {
                            goto L72;
                        }
                        if((_v24[1] & 255 & 4294967295) != 36) {
                            if((_v24[1] & 255 & 4294967295) != 46) {
                                if((_v24[1] & 255 & 4294967295) != 37) {
                                    goto L70;
                                }
                                goto L68;
                            }
                            goto L64;
L68:
                            _v32 = _v24;
                            if(wc_parse_iso2022_esc( &_v32,  &_v160) != 0) {
                                _v88 = 0;
                                _v60 = 4;
L173:
                                _v24 =  &(_v24[1]);
                                continue;
                            }
                            goto L77;
                        }
                        _v32 = _v24;
                        if(wc_parse_iso2022_esc( &_v32,  &_v160) != 0) {
                            if(_v144 != 33088 && _v144 != 33090) {
                                if(_v144 == 33103 || _v144 == 33104) {
                                    _v14 = 1;
                                } else {
                                    if((_v144 & 65280) == 33024) {
                                        _v13 = 1;
                                    }
                                }
                            }
                            if(_v140 != 33091) {
                                if(_v140 == 33089 || _v140 == 33093 || _v140 == 33095) {
                                    _v15 = 1;
                                }
                            } else {
                                _v16 = 1;
                            }
                            if((_v136 & 65280) == 33024 || (_v132 & 65280) == 33024) {
                                _v15 = 1;
                            }
L70:
                            _v60 = 2;
                            _v17 = 1;
                        }
                        goto L77;
L64:
                        _v32 = _v24;
                        if(wc_parse_iso2022_esc( &_v32,  &_v160) == 0) {
                            goto L77;
                        } else {
                            if((_v136 & 65280) == 512) {
                                _v13 = 1;
                            }
                            goto L70;
                        }
                        goto L76;
L78:
                        _t474 = _v44;
                        if(_t474 == 2) {
                            if(( *( &WC_ISO_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295) != 64) {
                                if((_v64 & 4) != 0) {
                                    _t481 = 8;
                                } else {
                                    _t481 = _v64 | 4;
                                }
                                _v64 = _t481;
                            } else {
                                _v64 = _v64 | 2;
                                _v17 = 1;
                            }
                            _v44 = 0;
L96:
                            if(_v64 == 8) {
                                _v88 = _v88 - 1;
                            }
                            goto L98;
                        }
                        if(_t474 == 3) {
                            if(( *_v24 & 255 & 4294967295) <= 159 || ( *_v24 & 255 & 4294967295) > 176 || ( *( &WC_ISO_MAP + (_v24[1] & 255 & 4294967295 & )) & 255 & 4294967295) != 64) {
                                _v64 = 8;
                            }
                            _v44 = 0;
                            goto L96;
                        }
                        if(_t474 != 0) {
                            goto L96;
                        }
                        if(( *( &WC_ISO_MAP + ( *_v24 & 255 & 4294967295 & )) & 255 & 4294967295 & ) - 64 > 32) {
                            goto L96;
                        }
                        goto __eax;
                        goto L96;
                    }
L176:
                    if(_v60 != 0) {
                        _t395 = _v36;
                        if(_t395 >= 3149847) {
                            if(_t395 <= 3149848) {
                                if(_v15 != 0) {
                                    return 2099220;
                                }
                            } else {
                                if(_t395 == 3149849) {
                                    if(_v16 != 0) {
                                        return 2099221;
                                    }
                                }
                            }
                        }
                        if(_v14 != 0) {
                            return 2099219;
                        }
                        if(_v13 != 0) {
                            return 2099218;
                        }
                        if(_v15 != 0) {
                            return 2099220;
                        }
                        if(_v16 == 0) {
                            return 2099217;
                        }
                        return 2099221;
                    }
                    if(_v76 == 2) {
                        return 2105404;
                    }
                    if(_v84 != 2) {
                        return 256;
                    }
                    return _v40;
                }
            } else {
L32:
                if((hint & 512) == 0) {
                    _v84 = 0;
                    _v60 = _v84;
                    _v40 = hint;
                    _v88 = 2;
                } else {
                    _v80 = 0;
                    _v60 = _v80;
                    _v88 = 2;
                }
                goto L35;
            }
            goto L26;
L13:
            if(_t364 < 2099221) {
                goto L26;
            }
            if(_t364 == 2105404) {
                _v36 = 3149847;
                _v44 = 0;
                _v56 = 0;
                _v76 = 0;
                _v72 = _v76;
                _v64 = _v72;
                _v60 = _v64;
                _v88 = 4;
                goto L35;
            } else {
                goto L32;
            }
            goto L36;
L27:
            _v36 = 3149848;
            _v44 = 0;
            _v52 = 0;
            _v72 = 0;
            _v64 = _v72;
            _v60 = _v64;
            _v88 = 3;
            goto L35;
L17:
            if(_t364 >= 3153976) {
                goto L25;
            }
            if(_t364 == 3149848) {
                goto L27;
            }
            if(_t364 < 3149848) {
                goto L26;
            }
            if(_t364 == 3149849) {
                goto L29;
            } else {
                goto L32;
            }
            goto L27;
        }
L26:
        _v36 = 3149847;
        _v44 = 0;
        _v52 = 0;
        _v72 = 0;
        _v64 = _v72;
        _v60 = _v64;
        _v88 = 3;
        goto L35;
    }
}

Str wc_conv_from_hz(Str is, wc_ces ces)
{// addr = 0x080B7018
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    int state;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    intOrPtr _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t61;
    _unknown_ _t62;
    _unknown_ _t79;
    _unknown_ _t81;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 = 0;
    _v28 = _v20;
L2:
    while(_v28 < _v24) {
        if(( *_v28 & 255 & 4294967295) >= 0 || ( *_v28 & 255 & 4294967295) == 126) {
            if(_v28 == _v24) {
                return is;
            }
            _v16 = Strnew_size(is->length);
            if(_v28 > _v20) {
                Strcat_charp_n(_v16, is->ptr, _v28 - _v20);
            }
            while(_v28 < _v24) {
                if(_v32 <= 5) {
                    goto __eax;
                }
                _v28 =  &(_v28[1]);
            }
        } else {
            _v28 =  &(_v28[1]);
        }
    }
}

wc_push_to_hz(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B7449
    intOrPtr _v16;
    unsigned int _v20;
    unsigned int _v24;
    _unknown_ __ebp;
    unsigned int _t249;
    int _t261;
    int _t273;
    int _t290;
    int _t302;
    int _t316;
    int _t328;
    int _t348;
    int _t360;
    unsigned int _t372;
    int _t384;
    int _t397;
    int _t410;
    int _t422;

    while(1) {
        _t249 = cc.ccs;
        if(_t249 == 16384) {
            break;
        }
        if(_t249 > 16384) {
            if(_t249 == 33089) {
                if(( *(_a16 + 5) & 255 & 4294967295) == 0) {
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t316 = os->length;
                     *((char*)(os->ptr + _t316)) = 126;
                    os->length = _t316 + 1;
                     *(os->ptr + os->length) = 0;
                    if(os->length + 1 >= os->area_size) {
                        Strgrow(os);
                    }
                    _t328 = os->length;
                     *((char*)(os->ptr + _t328)) = 123;
                    os->length = _t328 + 1;
                     *(os->ptr + os->length) = 0;
                     *(_a16 + 5) = 1;
                }
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t290 = os->length;
                 *(os->ptr + _t290) = cc.code >> 8 & 127 & 4294967295;
                os->length = _t290 + 1;
                 *(os->ptr + os->length) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t302 = os->length;
                 *(os->ptr + _t302) = cc.code & 127 & 4294967295;
                os->length = _t302 + 1;
                 *(os->ptr + os->length) = 0;
                return;
            }
            goto L6;
        }
        if(_t249 == 322) {
            if(( *(_a16 + 5) & 255 & 4294967295) != 0) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t410 = os->length;
                 *((char*)(os->ptr + _t410)) = 126;
                os->length = _t410 + 1;
                 *(os->ptr + os->length) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t422 = os->length;
                 *((char*)(os->ptr + _t422)) = 125;
                os->length = _t422 + 1;
                 *(os->ptr + os->length) = 0;
                 *(_a16 + 5) = 0;
            }
            if((cc.code & 4294967295) == 126) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t397 = os->length;
                 *((char*)(os->ptr + _t397)) = 126;
                os->length = _t397 + 1;
                 *(os->ptr + os->length) = 0;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t384 = os->length;
             *(os->ptr + _t384) = cc.code & 4294967295;
            os->length = _t384 + 1;
             *(os->ptr + os->length) = 0;
            return;
        } else {
        }
L48:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t372 = 16384;
            } else {
                _t372 = 49152;
            }
            cc.ccs = _t372;
        } else {
            _v16 = _a16;
            _v24 = cc.ccs;
            _v20 = cc.code;
             *__esp =  &(cc.ccs);
            wc_any_to_any_ces();
            __esp = __esp - 4;
        }
        continue;
L6:
        if(_t249 == 49152) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            if(( *(_a16 + 5) & 255 & 4294967295) != 0) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t348 = os->length;
                 *((char*)(os->ptr + _t348)) = 126;
                os->length = _t348 + 1;
                 *(os->ptr + os->length) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t360 = os->length;
                 *((char*)(os->ptr + _t360)) = 125;
                os->length = _t360 + 1;
                 *(os->ptr + os->length) = 0;
                 *(_a16 + 5) = 0;
            }
            Strcat_charp(os, WcReplaceW);
            return;
        }
        goto L48;
    }
    if(( *135119022 & 255 & 4294967295) != 0) {
        return ;
    }
    if(( *(_a16 + 5) & 255 & 4294967295) != 0) {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t261 = os->length;
         *((char*)(os->ptr + _t261)) = 126;
        os->length = _t261 + 1;
         *(os->ptr + os->length) = 0;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t273 = os->length;
         *((char*)(os->ptr + _t273)) = 125;
        os->length = _t273 + 1;
         *(os->ptr + os->length) = 0;
         *(_a16 + 5) = 0;
    }
    Strcat_charp(os, WcReplace);
    return;
}

wc_push_to_hz_end(Str os, wc_status* st)
{// addr = 0x080B792D
    _unknown_ __ebp;
    int _t48;
    int _t60;

    if(( *(st + 5) & 255 & 4294967295) == 0) {
        return ;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t48 = os->length;
     *((char*)(os->ptr + _t48)) = 126;
    os->length = _t48 + 1;
     *(os->ptr + os->length) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t60 = os->length;
     *((char*)(os->ptr + _t60)) = 125;
    os->length = _t60 + 1;
     *(os->ptr + os->length) = 0;
     *(st + 5) = 0;
    return;
}

wtf_push_iso2022(Str os, wc_ccs ccs, wc_uint32 code)
{// addr = 0x080B79E4
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    unsigned int _t14;

    _t14 = ccs;
    if(_t14 == 33090) {
L10:
        ccs = wc_jisx0208_or_jisx02131(code & 4294967295 & );
        goto L13;
    }
    if(_t14 > 33090) {
        if(_t14 == 33103) {
            goto L10;
        }
        goto L7;
    }
    if(_t14 == 340) {
L12:
        ccs = 322;
        goto L13;
    }
    if(_t14 == 33088) {
        goto L10;
    }
    if(_t14 == 330) {
        goto L12;
    } else {
    }
    goto L13;
L13:
    wtf_push(os, ccs, code);
    return;
L7:
    if(_t14 == 33104 || _t14 == 33092) {
        ccs = wc_jisx0212_or_jisx02132(code & 4294967295 & );
    }
    goto L13;
}

Str wc_conv_from_iso2022(Str is, wc_ces ces)
{// addr = 0x080B7A71
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    wc_uchar* q;
    int state;
    wc_status st;
    wc_ccs gl_ccs;
    wc_ccs gr_ccs;
    struct _Str* _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    char _v32;
    char _v36;
    intOrPtr _v40;
    intOrPtr _v44;
    struct  _v104;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ __ebp;
    _unknown_ _t93;
    _unknown_ _t94;
    _unknown_ _t95;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 = 0;
    _v36 = 0;
    _v28 = _v20;
L2:
    while(_v28 < _v24) {
        if(( *( &WC_ISO_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 79) == 0) {
            _v28 =  &(_v28[1]);
            goto L2;
        }
        if(_v28 == _v24) {
            return is;
        }
        _v16 = Strnew_size(is->length);
        if(_v28 > _v20) {
            Strcat_charp_n(_v16, is->ptr, _v28 - _v20);
        }
        wc_input_init(ces,  &_v104);
        _v40 =  *((intOrPtr*)(__ebp + ((_v104.gl & 255 & 4294967295 & ) + 4) * 4 - 100));
        _v44 =  *((intOrPtr*)(__ebp + ((_v104.gr & 255 & 4294967295 & ) + 4) * 4 - 100));
        while(_v28 < _v24) {
            if(_v36 > 32) {
                _v104.ss = 0;
                _v36 = 0;
                _v28 =  &(_v28[1]);
                continue;
            }
            goto __eax;
        }
    }
}

int wc_parse_iso2022_esc(wc_uchar** ptr, wc_status* st)
{// addr = 0x080B82F1
    wc_uchar* p;
    wc_uchar state;
    wc_uchar f;
    wc_uchar g;
    wc_uchar cs;
    signed int _v9;
    signed int _v10;
    signed int _v11;
    signed char _v12;
    unsigned char* _v16;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t125;
    _unknown_ _t126;
    _unknown_ _t130;
    signed int _t143;
    _unknown_ _t152;
    signed int _t156;
    _unknown_ _t157;
    signed int _t158;
    _unknown_ _t179;
    _unknown_ _t180;
    _unknown_ _t181;
    _unknown_ _t182;
    _unknown_ _t201;

    _v16 =  *ptr;
    _v10 = 0;
    _v11 = 0;
    _v12 = 0;
    if(( *_v16 & 255 & 4294967295) != 27) {
        return 0;
    }
    _v9 =  *_v16 & 255 & 4294967295;
    _v16 =  &(_v16[1]);
    while(( *_v16 & 255 & 4294967295) != 0 && _v9 != 0) {
        _t143 = _v9 & 255;
        if(_t143 == 40) {
            if(( *_v16 & 255 & 4294967295) != 33) {
L34:
                _v9 = 0;
                _v10 =  *_v16 & 255 & 4294967295;
            } else {
                _v12 = 161;
                _v9 = _v12 & 255 & 4294967295;
                _v11 =  *_v16 & 255 & 3 & 4294967295;
            }
L39:
            _v16 =  &(_v16[1]);
            continue;
        }
        if(_t143 > 40) {
            if(_t143 != 165) {
                if(_t143 > 165) {
                    if(_t143 != 168) {
                        if(_t143 != 172) {
                            return 0;
                        }
                    }
                } else {
                    if(_t143 != 44) {
                        if(_t143 != 161) {
                            return 0;
                        }
                    }
                }
            }
            goto L34;
        }
        if(_t143 == 33) {
            goto L34;
        }
        if(_t143 <= 33) {
            if(_t143 != 27) {
                return 0;
            }
            if(( *_v16 & 255 & 4294967295 & ) - 33 > 93) {
                return 0;
            }
            goto __eax;
        }
        if(_t143 == 36) {
            _t156 = ( *_v16 & 255 & 4294967295 & ) - 40;
            if(_t156 > 26) {
                return 0;
            }
            _t158 = 1 << (_t156 & 4294967295);
            if((_t158 & 117440512) != 0) {
                _v9 = 0;
                _v12 = 168;
                _v11 = 0;
                _v10 =  *_v16 & 255 & 4294967295;
            } else {
                if((_t158 & 240) != 0) {
                    _v12 = 172;
                    _v9 = _v12 & 255 & 4294967295;
                    _v11 =  *_v16 & 255 & 3 & 4294967295;
                } else {
                    if((_t158 & 15) == 0) {
                        return 0;
                    }
                    _v12 = 168;
                    _v9 = _v12 & 255 & 4294967295;
                    _v11 =  *_v16 & 255 & 3 & 4294967295;
                }
            }
        } else {
            if(_t143 != 37) {
                return 0;
            }
            if(( *_v16 & 255 & 4294967295) != 47) {
                _v9 = 0;
                _v10 =  *_v16 & 255 & 4294967295;
            } else {
                _v12 = 165;
                _v9 = _v12 & 255 & 4294967295;
            }
        }
        goto L39;
    }
}

wc_push_to_iso2022(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B871B
    wc_uchar g;
    wc_bool is_wide;
    wc_bool retry;
    wc_wchar_t cc2;
    wc_wchar_t cc2;
    char _v13;
    char _v14;
    char _v15;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v76;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ __ebp;
    signed int _t167;
    _unknown_ _t184;
    _unknown_ _t197;
    _unknown_ _t207;
    _unknown_ _t228;
    _unknown_ _t252;

    _v13 = 0;
    _v14 = 0;
    _v15 = 0;
    while(1) {
        _t167 = cc.ccs & 65280;
        if(_t167 == 16384) {
            goto L39;
        } else {
            goto L2;
        }
    }
}

wc_push_to_iso2022_end(Str os, wc_status* st)
{// addr = 0x080B8B9C
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if( *((intOrPtr*)(st + 20)) != 0 &&  *((intOrPtr*)(st + 20)) !=  *(st + 12)) {
        wc_push_iso2022_esc(os,  *(st + 12), 41, 0, st);
    }
    wc_push_iso2022_esc(os,  *(st + 8), 40, 1, st);
    return;
}

wc_push_iso2022_esc(Str os, wc_ccs ccs, wc_uchar g, wc_uint8 invoke, wc_status* st)
{// addr = 0x080B8C16
    wc_uint8 g_invoke;
    signed int _v13;
    signed int _v32;
    signed int _v36;
    _unknown_ __ebp;
    signed int _t251;
    int _t260;
    int _t274;
    int _t286;
    int _t300;
    int _t312;
    int _t328;
    int _t342;
    int _t356;
    int _t370;
    int _t383;
    int _t397;
    int _t409;

    _v32 = g & 4294967295;
    _v36 = invoke & 4294967295;
    _v13 = _v32 & 255 & 3 & 4294967295;
    if( *(st + ((_v13 & 255) + 4) * 4) != ccs) {
        _t342 = os->length;
         *((char*)(os->ptr + _t342)) = 27;
        os->length = _t342 + 1;
         *(os->ptr + os->length) = 0;
        if((ccs & 98304) == 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t356 = os->length;
             *(os->ptr + _t356) = _v32 & 255 & 4294967295;
            os->length = _t356 + 1;
             *(os->ptr + os->length) = 0;
            if((ccs & 1792) == 1024) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t383 = os->length;
                 *((char*)(os->ptr + _t383)) = 33;
                os->length = _t383 + 1;
                 *(os->ptr + os->length) = 0;
            }
        } else {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t397 = os->length;
             *((char*)(os->ptr + _t397)) = 36;
            os->length = _t397 + 1;
             *(os->ptr + os->length) = 0;
            if(_v13 != 0 || ccs != 33088 && ccs != 33090 && ccs != 33089) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t409 = os->length;
                 *(os->ptr + _t409) = _v32 & 255 & 4294967295;
                os->length = _t409 + 1;
                 *(os->ptr + os->length) = 0;
            }
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t370 = os->length;
         *(os->ptr + _t370) = ccs & 4294967295;
        os->length = _t370 + 1;
         *(os->ptr + os->length) = 0;
         *(st + ((_v13 & 255) + 4) * 4) = ccs;
    }
    if(_v36 == 0) {
        return ;
    }
    _t251 = _v13 & 255;
    if(_t251 == 1) {
        if(( *(st + 5) & 255 & 4294967295) == 1) {
            return ;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t260 = os->length;
         *((char*)(os->ptr + _t260)) = 14;
        os->length = _t260 + 1;
         *(os->ptr + os->length) = 0;
         *(st + 5) = 1;
        return;
    }
    if(_t251 > 1) {
        if(_t251 == 2) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t274 = os->length;
             *((char*)(os->ptr + _t274)) = 27;
            os->length = _t274 + 1;
             *(os->ptr + os->length) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t286 = os->length;
             *((char*)(os->ptr + _t286)) = 78;
            os->length = _t286 + 1;
             *(os->ptr + os->length) = 0;
            return;
        }
        goto L28;
    }
    if(_t251 != 0) {
        return ;
    }
    if(( *(st + 5) & 255 & 4294967295) == 0) {
        return ;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t328 = os->length;
     *((char*)(os->ptr + _t328)) = 15;
    os->length = _t328 + 1;
     *(os->ptr + os->length) = 0;
     *(st + 5) = 0;
    return;
L28:
    if(_t251 != 3) {
        return ;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t300 = os->length;
     *((char*)(os->ptr + _t300)) = 27;
    os->length = _t300 + 1;
     *(os->ptr + os->length) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t312 = os->length;
     *((char*)(os->ptr + _t312)) = 79;
    os->length = _t312 + 1;
     *(os->ptr + os->length) = 0;
    return;
}

wc_push_to_euc(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B90B4
    wc_ccs g1_ccs;
    intOrPtr _v16;
    unsigned int _v32;
    unsigned int _v36;
    intOrPtr _v48;
    unsigned int _v52;
    unsigned int _v56;
    _unknown_ __ebp;
    unsigned int _t111;
    int _t118;
    unsigned int _t128;
    int _t145;
    _unknown_ _t161;
    _unknown_ _t173;

    _v16 =  *((intOrPtr*)( *((intOrPtr*)( *_a16 + 12)) + 8));
    while(cc.ccs != _v16) {
        _t111 = cc.ccs;
        if(_t111 == 16385) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t118 = os->length;
             *(os->ptr + _t118) = (cc.code | 128) & 4294967295;
            os->length = _t118 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t111 > 16385) {
            if(_t111 < 34831) {
                goto L28;
            }
            goto L13;
        }
        if(_t111 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t145 = os->length;
             *(os->ptr + _t145) = cc.code & 4294967295;
            os->length = _t145 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t111 == 16384) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplace);
            return;
        }
L28:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t128 = 16384;
            } else {
                _t128 = 49152;
            }
            cc.ccs = _t128;
        } else {
            _v48 = _a16;
            _v56 = cc.ccs;
            _v52 = cc.code;
             *__esp =  &_v36;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v36;
            cc.code = _v32;
        }
        continue;
L13:
        if(_t111 <= 34834) {
            if( *((intOrPtr*)( *_a16)) != 3149849) {
                goto L28;
            }
            goto L27;
        }
        if(_t111 == 49152) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplaceW);
            return;
        }
        goto L28;
L27:
        _v56 = cc.ccs;
        _v52 = cc.code;
         *__esp =  &(cc.ccs);
        wc_johab_to_ksx1001();
        __esp = __esp - 4;
    }
}

wc_push_to_eucjp(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B9358
    unsigned int _v16;
    unsigned int _v20;
    intOrPtr _v32;
    unsigned int _v36;
    unsigned int _v40;
    _unknown_ __ebp;
    unsigned int _t210;
    int _t217;
    int _t229;
    int _t253;
    unsigned int _t266;
    int _t281;
    int _t297;
    int _t309;
    int _t326;
    int _t339;

    while(1) {
        _t210 = cc.ccs;
        if(_t210 == 33090) {
            break;
        }
        if(_t210 > 33090) {
            if(_t210 == 33103) {
                if(( *135119019 & 255 & 4294967295) != 0) {
                    goto L70;
                }
                goto L31;
L70:
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t217 = os->length;
                 *(os->ptr + _t217) = (cc.code >> 8 | 128) & 4294967295;
                os->length = _t217 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t229 = os->length;
                 *(os->ptr + _t229) = (cc.code | 128) & 4294967295;
                os->length = _t229 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L11;
L31:
            if(( *135119011 & 255 & 4294967295) == 0 || ( *135119018 & 255 & 4294967295) == 0) {
                cc.ccs = 49152;
            } else {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &_v20;
                wc_jisx0213_to_jisx0212();
                __esp = __esp - 4;
                cc.ccs = _v20;
                cc.code = _v16;
            }
            goto L75;
        }
        if(_t210 == 329) {
            if(( *135119017 & 255 & 4294967295) == 0) {
                if(( *135119013 & 255 & 4294967295) == 0) {
                    _v40 = cc.ccs;
                    _v36 = cc.code;
                     *__esp =  &(cc.ccs);
                    wc_jisx0201k_to_jisx0208();
                    __esp = __esp - 4;
                } else {
                    cc.ccs = 16384;
                }
                goto L75;
            }
            goto L21;
        }
        if(_t210 > 329) {
            if(_t210 == 16384) {
                if(( *135119022 & 255 & 4294967295) != 0) {
                    return ;
                }
                Strcat_charp(os, WcReplace);
                return;
            }
            goto L8;
        }
        if(_t210 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t339 = os->length;
             *(os->ptr + _t339) = cc.code & 4294967295;
            os->length = _t339 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
L61:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t266 = 16384;
            } else {
                _t266 = 49152;
            }
            cc.ccs = _t266;
        } else {
            _v32 = _a16;
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &_v20;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v20;
            cc.code = _v16;
        }
L75:
        continue;
L8:
        if(_t210 == 16385) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t326 = os->length;
             *(os->ptr + _t326) = (cc.code | 128) & 4294967295;
            os->length = _t326 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        goto L61;
L21:
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t297 = os->length;
         *((char*)(os->ptr + _t297)) = 142;
        os->length = _t297 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t309 = os->length;
         *(os->ptr + _t309) = (cc.code | 128) & 4294967295;
        os->length = _t309 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
L11:
        if(_t210 > 33103) {
            if(_t210 == 33104) {
                if(( *135119019 & 255 & 4294967295) == 0) {
                    if(( *135119011 & 255 & 4294967295) == 0 || ( *135119018 & 255 & 4294967295) == 0) {
                        cc.ccs = 49152;
                    } else {
                        _v40 = cc.ccs;
                        _v36 = cc.code;
                         *__esp =  &_v20;
                        wc_jisx0213_to_jisx0212();
                        __esp = __esp - 4;
                        cc.ccs = _v20;
                        cc.code = _v16;
                    }
                    goto L75;
                }
                goto L46;
            }
            goto L15;
L46:
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t253 = os->length;
             *((char*)(os->ptr + _t253)) = 143;
            os->length = _t253 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            goto L70;
        }
        if(_t210 == 33092) {
            if(( *135119018 & 255 & 4294967295) == 0) {
                if(( *135119011 & 255 & 4294967295) == 0 || ( *135119019 & 255 & 4294967295) == 0) {
                    cc.ccs = 49152;
                } else {
                    _v40 = cc.ccs;
                    _v36 = cc.code;
                     *__esp =  &_v20;
                    wc_jisx0212_to_jisx0213();
                    __esp = __esp - 4;
                    cc.ccs = _v20;
                    cc.code = _v16;
                }
                goto L75;
            }
        } else {
            goto L61;
        }
L37:
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t281 = os->length;
         *((char*)(os->ptr + _t281)) = 143;
        os->length = _t281 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        goto L70;
L15:
        if(_t210 == 49152) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplaceW);
            return;
        }
        goto L61;
    }
    goto L70;
}

wc_push_to_euctw(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B9879
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    unsigned int _t160;
    _unknown_ _t164;
    _unknown_ _t173;
    _unknown_ _t185;
    _unknown_ _t197;
    _unknown_ _t209;
    _unknown_ _t228;
    _unknown_ _t240;
    _unknown_ _t257;
    _unknown_ _t270;

    while(1) {
        _t160 = cc.ccs;
        if(_t160 > 33101) {
            goto L10;
        } else {
            goto L2;
        }
    }
}

wc_push_to_iso8859(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080B9C24
    wc_ccs g1_ccs;
    intOrPtr _v16;
    intOrPtr _v32;
    unsigned int _v36;
    unsigned int _v40;
    _unknown_ __ebp;
    unsigned int _t83;
    int _t93;
    unsigned int _t106;
    int _t115;
    _unknown_ _t128;

    _v16 =  *((intOrPtr*)( *((intOrPtr*)( *_a16 + 12)) + 8));
    while(cc.ccs != _v16) {
        _t83 = cc.ccs;
        if(_t83 == 16384) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplace);
            return;
        }
        if(_t83 > 16384) {
            if(_t83 == 16385) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t93 = os->length;
                 *(os->ptr + _t93) = (cc.code | 128) & 4294967295;
                os->length = _t93 + 1;
                 *((char*)(os->ptr + os->length)) = 0;
                return;
            }
            goto L10;
        }
        if(_t83 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t115 = os->length;
             *(os->ptr + _t115) = cc.code & 4294967295;
            os->length = _t115 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
L22:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t106 = 16384;
            } else {
                _t106 = 49152;
            }
            cc.ccs = _t106;
        } else {
            _v32 = _a16;
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &(cc.ccs);
            wc_any_to_any_ces();
            __esp = __esp - 4;
        }
        continue;
L10:
        if(_t83 == 49152) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplaceW);
            return;
        }
        goto L22;
    }
}

wc_create_gmap(wc_status* st)
{// addr = 0x080B9E12
    wc_gset* gset;
    wc_uchar* gset_ext;
    int i;
    int f;
    wc_gset* _v8;
    wc_uchar* _v12;
    signed int _v16;
    intOrPtr _v20;
    _unknown_ __ebp;
    signed int _t119;
    signed int _t124;

    _v8 = st->ces_info->gset;
    _v12 = st->ces_info->gset_ext;
    if(( *135119020 & 255 & 4294967295) == 0) {
        _v16 = 0;
        while(_v16 <= 63) {
             *( &cs94_gmap + _v16) =  *_v12 & 255 & 4294967295;
             *( &cs96_gmap + _v16) = _v12[1] & 255 & 4294967295;
             *( &cs94w_gmap + _v16) = _v12[2] & 255 & 4294967295;
             *( &cs96w_gmap + _v16) = _v12[3] & 255 & 4294967295;
             *( &cs942_gmap + _v16) =  *_v12 & 255 & 4294967295;
            _v16 = _v16 + 1;
        }
    } else {
        _v16 = 0;
        while(_v16 <= 63) {
            goto L8;
        }
    }
L8:
    _v16 = 0;
    while( *(_v8 + (_v16 << 3)) != 0) {
        _v20 = ( *(_v8 + (_v16 << 3)) & 255) - 64;
        _t119 =  *(_v8 + (_v16 << 3)) & 65280;
        if(_t119 == 1024) {
             *(_v20 +  &cs942_gmap) = (_v8 + (_v16 << 3))[1] & 255 & 4294967295;
L35:
            _v16 = _v16 + 1;
            continue;
        }
        if(_t119 > 1024) {
            if(_t119 == 33024) {
                _t124 =  *(_v8 + (_v16 << 3));
                if(_t124 == 33092) {
                    if(( *135119018 & 255 & 4294967295) != 0) {
                        goto L29;
                    }
                    goto L25;
L29:
                     *(_v20 +  &cs94w_gmap) = (_v8 + (_v16 << 3))[1] & 255 & 4294967295;
                    goto L35;
                }
                goto L21;
L25:
                goto L35;
            }
            goto L15;
L21:
            if(_t124 < 33092 || _t124 - 33103 > 1) {
                goto L29;
            }
            if(( *135119019 & 255 & 4294967295) != 0) {
                goto L29;
            }
            goto L35;
        }
        if(_t119 == 256) {
            if( *(_v8 + (_v16 << 3)) != 329 || ( *135119017 & 255 & 4294967295) != 0) {
                 *(_v20 +  &cs94_gmap) = (_v8 + (_v16 << 3))[1] & 255 & 4294967295;
            }
        } else {
            if(_t119 == 512) {
                 *(_v20 +  &cs96_gmap) = (_v8 + (_v16 << 3))[1] & 255 & 4294967295;
            }
        }
        goto L35;
L15:
        if(_t119 == 33280) {
             *(_v20 +  &cs96w_gmap) =  *(_v8 + (_v16 << 3) + 4) & 255 & 4294967295;
        }
        goto L35;
    }
}

Str wc_char_conv_from_iso2022(wc_uchar c, wc_status* st)
{// addr = 0x080BA052
    wc_uchar* p;
    wc_ccs gl_ccs;
    wc_ccs gr_ccs;
    intOrPtr _v20;
    intOrPtr _v24;
    signed int _v32;
    _unknown_ __ebx;
    _unknown_ __ebp;
    intOrPtr _t56;
    intOrPtr _t62;
    _unknown_ _t68;

    _v32 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135790336 = Strnew_size(8);
        nbuf = 0;
    }
    if(( *(st + 6) & 255 & 4294967295) == 0) {
        _t56 =  *((intOrPtr*)(st + (( *(st + 5) & 255 & 4294967295 & ) + 4) * 4));
    } else {
        _t56 =  *((intOrPtr*)(st + (( *(st + 6) & 255 & 4294967295 & ) + 4) * 4));
    }
    _v20 = _t56;
    if(( *(st + 6) & 255 & 4294967295) == 0) {
        _t62 =  *((intOrPtr*)(st + (( *(st + 4) & 255 & 4294967295 & ) + 4) * 4));
    } else {
        _t62 =  *((intOrPtr*)(st + (( *(st + 6) & 255 & 4294967295 & ) + 4) * 4));
    }
    _v24 = _t62;
    if(st->state <= 44) {
        goto __eax;
    }
     *(st + 6) = 0;
    st->state = -1;
    return  *135790336;
}

wc_wchar_t wc_jisx0201k_to_jisx0208(wc_wchar_t cc)
{// addr = 0x080BA840
    _unknown_ __ebp;
    unsigned int _t17;

    __ecx = cc.ccs;
    _a12 =  *((_a12 & 127) +  &jisx0201k_jisx0208_map + (_a12 & 127)) & 65535 & 4294967295 & ;
    if(_a12 == 0) {
        _t17 = 49152;
    } else {
        _t17 = 33090;
    }
    cc.code = _t17;
     *__ecx = cc.code;
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_jisx0212_to_jisx0213(wc_wchar_t cc)
{// addr = 0x080BA881
    wc_wchar_t cc2;
    _unknown_ _v8;
    intOrPtr _v16;
    char _v20;
    wc_table* _v32;
    wc_table* _v36;
    unsigned int _v40;
    unsigned int _v44;
    _unknown_ __ebp;
    struct  _t29;
    _unknown_ _t30;

    _push(__ebx);
    __esp = __esp - 36;
    _t29 = cc.ccs;
    if( *135790352 == 0) {
         *135790352 = wc_get_ucs_table(33103);
         *135790356 = wc_get_ucs_table(33104);
    }
    _v32 =  *135790356;
    _v40 = cc.code;
    _v36 = _a12;
    __esp->marks =  &_v20;
    wc_any_to_any();
    __esp = __esp - 4;
    if(_v20 != 33092) {
        _v36 =  *135790352;
        _v44 = cc.code;
        _v40 = _a12;
         *__esp = _t29;
        wc_any_to_any();
        __esp = __esp - 4;
        return _t29;
    }
     *_t29 = _v20;
     *((intOrPtr*)(_t29 + 4)) = _v16;
    return _t29;
}

wc_wchar_t wc_jisx0213_to_jisx0212(wc_wchar_t cc)
{// addr = 0x080BA91D
    _unknown_ _v8;
    wc_table* _v16;
    intOrPtr _v20;
    unsigned int _v24;
    _unknown_ __ebp;
    struct  _t14;
    _unknown_ _t15;

    _push(__ebx);
    __esp = __esp - 20;
    _t14 = cc.ccs;
    if( *135790348 == 0) {
         *135790348 = wc_get_ucs_table(33092);
    }
    _v16 =  *135790348;
    _v24 = cc.code;
    _v20 = _a12;
     *__esp = _t14;
    wc_any_to_any();
    __esp = __esp - 4;
    return _t14;
}

wc_ccs wc_jisx0208_or_jisx02131(wc_uint16 code)
{// addr = 0x080BA96C
    signed short _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t11;
    _unknown_ _t12;

    _v16 = code & 4294967295;
    if(wc_map_range_search(_v16 & 65535 & 32639, "/"9"B"I"Q"["k"q"z"}"!#/#:##[#`#{#~#t$~$w%~%9&@&Y&~&B'P'r'~'A(~/TO~O%t~~", 18) == 0) {
        return 33090;
    }
    return 33103;
}

wc_ccs wc_jisx0212_or_jisx02132(wc_uint16 code)
{// addr = 0x080BA9AC
    signed short _v8;
    _unknown_ __ebp;
    _unknown_ _t13;
    _unknown_ _t14;

    _v8 = code & 4294967295;
    if(( *(wc_jisx0212_jisx02132_map + (_v8 & 65535 & 4294967295 &  & 127)) & 255 & 4294967295) == 0) {
        return 33092;
    }
    return 33104;
}

wc_wchar_t wc_johab_to_ksx1001(wc_wchar_t cc)
{// addr = 0x080BA9E4
    _unknown_ _v8;
    unsigned int _v16;
    char _v20;
    wc_table* _v32;
    intOrPtr _v36;
    unsigned int _v40;
    intOrPtr _v44;
    _unknown_ __ebp;
    unsigned int _t27;
    _unknown_ _t38;
    struct  _t40;
    _unknown_ _t41;

    _push(__ebx);
    __esp = __esp - 36;
    _t40 = cc.ccs;
    _t27 = cc.code;
    if(_t27 > 34833) {
        if(_t27 == 34834) {
            if(_a12 <= 8480) {
                cc.code = 49152;
            } else {
                cc.code = 33091;
            }
        }
L15:
         *_t40 = cc.code;
         *((intOrPtr*)(_t40 + 4)) = _a12;
        return _t40;
    }
    if(_t27 >= 34832) {
L7:
        if(( *135119011 & 255 & 4294967295) == 0) {
            cc.code = 49152;
        } else {
            if( *135790368 == 0) {
                 *135790368 = wc_get_ucs_table(33091);
            }
            _v32 =  *135790368;
            _v40 = cc.code;
            _v36 = _a12;
            __esp->marks =  &(cc.code);
            wc_any_to_any();
            __esp = __esp - 4;
        }
        goto L15;
    }
    if(_t27 == 34831) {
        _v40 = cc.code;
        _v36 = _a12;
        __esp->marks =  &_v20;
        wc_johab_to_cs128w();
        __esp = __esp - 4;
        _v44 = _v20;
        _v40 = _v16;
         *__esp = _t40;
        wc_johab_to_ksx1001();
        __esp = __esp - 4;
        return _t40;
    } else {
        goto L15;
    }
    goto L7;
}

wc_wchar_t wc_ksx1001_to_johab(wc_wchar_t cc)
{// addr = 0x080BAAD5
    _unknown_ _v8;
    signed int _v24;
    _unknown_ __ebp;
    struct  _t40;
    _unknown_ _t41;

    _push(__ebx);
    __esp = __esp - 20;
    _t40 = cc.ccs;
    _a12 = _a12 & 32639;
    if(_a12 <= 8480 || _a12 > 9248) {
        if(_a12 <= 9299 || _a12 > 11390) {
            if(_a12 <= 18976 || _a12 > 32126) {
                if(( *135119011 & 255 & 4294967295) == 0) {
                    cc.code = 49152;
                } else {
                     *__esp = cc.code;
                    _v24 = _a12;
                    _v24 = wc_any_to_ucs();
                    wc_ucs_to_johab( &(cc.code));
                    __esp = __esp - 4;
                }
                 *_t40 = cc.code;
                 *(_t40 + 4) = _a12;
                return _t40;
            }
        }
    }
L6:
    cc.code = 34834;
     *_t40 = cc.code;
     *(_t40 + 4) = _a12;
    return _t40;
}

wc_wchar_t wc_ucs_to_johab(wc_uint32 ucs)
{// addr = 0x080BAB86
    wc_table* t;
    wc_wchar_t cc;
    _unknown_ _v8;
    wc_table* _v16;
    unsigned int _v20;
    intOrPtr _v24;
    unsigned int _v32;
    intOrPtr _v36;
    wc_table* _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    struct  _t41;
    _unknown_ _t42;

    _push(__ebx);
    __esp = __esp - 52;
    _t41 = ucs;
    if(_a8 <= 44031 || _a8 > 55203) {
        if(_a8 <= 12592 || _a8 > 12643) {
            _v16 = wc_get_ucs_table(34834);
            _v52 = _v16;
            wc_ucs_to_any( &_v36, _a8);
            __esp = __esp - 4;
            _v24 = _v36;
            _v20 = _v32;
        } else {
            _v16 = wc_get_ucs_table(34833);
            _v52 = _v16;
            wc_ucs_to_any( &_v24, _a8);
            __esp = __esp - 4;
        }
    } else {
        _a8 = _a8 - 44032;
        _v20 = wc_N_to_johab1(_a8);
        _v24 = 34831;
    }
     *_t41 = _v24;
     *(_t41 + 4) = _v20;
    return _t41;
}

wc_uint32 wc_johab1_to_N(wc_uint32 code)
{// addr = 0x080BAC4A
    wc_uint32 a;
    wc_uint32 b;
    wc_uint32 c;
    signed int _v8;
    signed int _v12;
    signed int _v16;
    _unknown_ __ebp;
    _unknown_ _t35;

    _v8 =  *( &johab1_N_map + (code >> 10 & 31)) & 255 & 4294967295 & ;
    _v12 =  *((code >> 5 & 31) + 135118400) & 255 & 4294967295 & ;
    _v16 =  *((code & 31) + 135118432) & 255 & 4294967295 & ;
    if(_v8 == 0) {
        return -1;
    }
    if(_v12 == 0) {
        return -1;
    }
    if(_v16 == 0) {
        return -1;
    }
    return 0 + (((_v8 << 2) + _v8 << 2) + _v8 + _v12 << 2) * 8 - (((_v8 << 2) + _v8 << 2) + _v8 + _v12 << 2) + _v16 - 617;
}

wc_uint32 wc_N_to_johab1(wc_uint32 code)
{// addr = 0x080BACD4
    wc_uint32 a;
    wc_uint32 b;
    wc_uint32 c;
    signed int _v8;
    signed int _v12;
    signed int _v16;
    signed int _v24;
    _unknown_ __ebp;
    _unknown_ _t45;
    _unknown_ _t52;
    _unknown_ _t54;
    _unknown_ _t67;
    signed int _t79;
    unsigned int _t80;
    _unknown_ _t81;
    _unknown_ _t85;
    _unknown_ _t87;
    _unknown_ _t95;

    _v24 = code;
    _v8 =  *( &N_johab1_map + (_v24 * -555131827 >> 32 >> 9)) & 255 & 4294967295 & ;
    _v24 = code >> 2;
    _t79 = _v24 * 613566757 >> 32;
    _v12 =  *(_t79 - (((_t79 * -2045222521 >> 32) + (_t79 - (_t79 * -2045222521 >> 32) >> 1) >> 4 << 2) + ((_t79 * -2045222521 >> 32) + (_t79 - (_t79 * -2045222521 >> 32) >> 1) >> 4) << 2) + ((_t79 * -2045222521 >> 32) + (_t79 - (_t79 * -2045222521 >> 32) >> 1) >> 4) + 135118496) & 255 & 4294967295 & ;
    _t80 = code;
    _v24 = _t80 >> 2;
    _v16 =  *(_t80 - 0 + (_v24 * 613566757 >> 32 << 2) * 8 - (_v24 * 613566757 >> 32 << 2) + 135118528) & 255 & 4294967295 & ;
    return _v12 << 5 | _v8 << 10 | _v16;
}

wc_wchar_t wc_johab_to_cs128w(wc_wchar_t cc)
{// addr = 0x080BAD93
    wc_uint32 n;
    wc_uchar ub;
    wc_uchar lb;
    signed char _v9;
    signed char _v10;
    unsigned int _v16;
    struct  __ebx;
    _unknown_ __ebp;
    signed int _t63;
    _unknown_ _t76;
    _unknown_ _t97;

    __ebx = cc.ccs;
    if(_a12 > 55295) {
        _v9 = _a12 >> 8 & 4294967295;
        _v10 = _a12 & 4294967295;
        if(_v9 > 223) {
            _v9 = (_v9 & 255) + 32 + (_v9 & 255) + 32 + 74 & 4294967295;
        } else {
            _v9 = (_v9 & 255) + 40 + (_v9 & 255) + 40 + 31 & 4294967295;
        }
        if(_v10 > 160) {
            _v9 = _v9 + 1;
            _v10 = _v10 + 128;
        } else {
            if(_v10 > 144) {
                _t63 = 34;
            } else {
                _t63 = 16;
            }
            _v10 = _v10 - (_t63 & 4294967295);
        }
        _a12 = _v10 & 255 | (_v9 & 255) << 8;
        cc.code = 34834;
    } else {
        _v16 = wc_johab1_to_N(_a12);
        if(_v16 == 255) {
            _t97 = (_a12 >> 8 & 255) * (_a12 >> 8 & 255) + (_a12 & 255);
            if((_a12 & 255) > 128) {
                _t76 = 67;
            } else {
                _t76 = 65;
            }
            _v16 = _t97 - _t76 - 24816;
            _a12 = (_v16 >> 7 << 8) + (_v16 & 127);
            cc.code = 34833;
        } else {
            _a12 = ((_v16 >> 7) + 33 << 8) + (_v16 & 127);
            cc.code = 34832;
        }
    }
     *__ebx = cc.code;
     *(__ebx + 4) = _a12;
    return __ebx;
}

wc_wchar_t wc_cs128w_to_johab(wc_wchar_t cc)
{// addr = 0x080BAED3
    wc_uint32 n;
    wc_uchar ub;
    wc_uchar lb;
    signed int _v17;
    signed char _v18;
    unsigned int _v24;
    unsigned int _v36;
    _unknown_ __ebx;
    _unknown_ __edi;
    struct  __esi;
    _unknown_ __ebp;
    unsigned int _t73;
    _unknown_ _t82;
    _unknown_ _t90;
    _unknown_ _t95;
    signed int _t107;
    signed int _t115;
    _unknown_ _t132;
    _unknown_ _t135;
    _unknown_ _t137;
    _unknown_ _t139;
    signed int _t149;

    __esi = cc.ccs;
    _t73 = cc.code;
    if(_t73 == 34833) {
        _v24 = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
        _v36 = _v24;
        _t149 = (_v36 * -1370734243 >> 32 >> 7) + 132 << 8;
        _t132 = _v24 - _v24 * -1370734243 * (_t127 * -1370734243 >> 32 >> 7);
        if(_v24 - (_v24 * -1370734243 >> 32 >> 7) * (_v24 * -1370734243 >> 32 >> 7) > 61) {
            _t95 = 67;
        } else {
            _t95 = 65;
        }
        _a12 = _t149 + _t132 + _t95;
    } else {
        if(_t73 == 34834) {
            _v17 = _a12 >> 8 & 127 & 4294967295;
            _v18 = _a12 & 127 & 4294967295;
            if(_v17 > 73) {
                _v17 = _v17 - 74;
                if((_v17 & 255 & 1 & 4294967295) == 0) {
                    if(_v18 > 110) {
                        _t107 = 34;
                    } else {
                        _t107 = 16;
                    }
                } else {
                    _t107 = -128;
                }
                _v18 = _v18 + (_t107 & 4294967295);
                _v17 = (_v17 & 255) - 32 & 4294967295;
            } else {
                _v17 = _v17 - 31;
                if((_v17 & 255 & 1 & 4294967295) == 0) {
                    if(_v18 > 110) {
                        _t115 = 34;
                    } else {
                        _t115 = 16;
                    }
                } else {
                    _t115 = -128;
                }
                _v18 = _v18 + (_t115 & 4294967295);
                _v17 = (_v17 & 255) - 40 & 4294967295;
            }
            _a12 = _v18 & 255 | (_v17 & 255) << 8;
        } else {
            if(_t73 == 34832) {
                _v24 = ((_a12 >> 8 & 127) + 33554399 << 7) + (_a12 & 127);
                _a12 = wc_N_to_johab1(_v24);
            }
        }
    }
    cc.code = 34831;
     *__esi = cc.code;
     *(__esi + 4) = _a12;
    return __esi;
}

Str wc_conv_from_johab(Str is, wc_ces ces)
{// addr = 0x080BB07C
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    int state;
    _unknown_ _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    intOrPtr _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t114;
    _unknown_ _t156;
    _unknown_ _t165;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 = 0;
    _v28 = _v20;
    while() {
    }
}

wc_push_to_johab(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BB2FB
    unsigned int _v16;
    unsigned int _v20;
    intOrPtr _v32;
    unsigned int _v36;
    unsigned int _v40;
    _unknown_ __ebp;
    unsigned int _t90;
    int _t97;
    int _t109;
    unsigned int _t124;
    int _t139;

    while(1) {
        _t90 = cc.ccs;
        if(_t90 == 34831) {
            break;
        }
        if(_t90 > 34831) {
            if(_t90 <= 34834) {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &(cc.ccs);
                wc_cs128w_to_johab();
                __esp = __esp - 4;
                break;
            }
            goto L8;
        }
        if(_t90 == 16384) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplace);
            return;
        }
        if(_t90 == 33091) {
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &_v20;
            wc_ksx1001_to_johab();
            __esp = __esp - 4;
            cc.ccs = _v20;
            cc.code = _v16;
            continue;
        }
        if(_t90 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t139 = os->length;
             *(os->ptr + _t139) = cc.code & 4294967295;
            os->length = _t139 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        } else {
        }
L24:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t124 = 16384;
            } else {
                _t124 = 49152;
            }
            cc.ccs = _t124;
        } else {
            _v32 = _a16;
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &_v20;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v20;
            cc.code = _v16;
        }
        continue;
L20:
        if(( *135119022 & 255 & 4294967295) != 0) {
            return ;
        }
        Strcat_charp(os, WcReplaceW);
        return;
L8:
        if(_t90 == 49152) {
            goto L20;
        }
        goto L24;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t97 = os->length;
     *(os->ptr + _t97) = cc.code >> 8 & 4294967295;
    os->length = _t97 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t109 = os->length;
     *(os->ptr + _t109) = cc.code & 4294967295;
    os->length = _t109 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_johab(wc_uchar c, wc_status* st)
{// addr = 0x080BB538
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t50;
    signed int _t72;
    _unknown_ _t75;
    struct _Str* _t81;
    _unknown_ _t89;
    int _t103;

    _v16 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135790360 = Strnew_size(8);
    }
    _t50 = st->state;
    if(_t50 == 1) {
        if(( *( &WC_JOHAB_MAP + (_v16 & 255)) & 255 & 4294967295 &  & 16) != 0) {
            wtf_push( *135790360, 34831, (johabu & 255 & 4294967295 & ) << 8 | _v16 & 255);
        }
        goto L19;
    }
    if(_t50 == 2) {
        if(( *( &WC_JOHAB_MAP + (_v16 & 255)) & 255 & 4294967295 &  & 32) != 0) {
            wtf_push( *135790360, 34831, (johabu & 255 & 4294967295 & ) << 8 | _v16 & 255);
        }
        goto L19;
    }
    if(_t50 != 0) {
L19:
        st->state = -1;
        return  *135790360;
    }
    _t72 =  *( &WC_JOHAB_MAP + (_v16 & 255)) & 255 & 4294967295 &  & 15;
    if(_t72 == 4) {
        johabu = _v16 & 255 & 4294967295;
        st->state = 2;
        return 0;
    }
    if(_t72 == 8) {
        goto L10;
    }
    if(_t72 != 2) {
        goto L11;
    }
    johabu = _v16 & 255 & 4294967295;
    st->state = 1;
    return 0;
L11:
    if( *135790360->length + 1 >=  *135790360->area_size) {
        Strgrow( *135790360);
    }
    _t81 =  *135790360;
    _t103 = _t81->length;
     *( *( *135790360) + _t103) = _v16 & 255 & 4294967295;
    _t81->length = _t103 + 1;
     *( *( *135790360) +  *135790360->length) = 0;
    goto L19;
L10:
    goto L19;
    return __eax;
}

wc_putc_init(wc_ces f_ces, wc_ces t_ces)
{// addr = 0x080BB6E8
    _unknown_ _v24;
    _unknown_ __ebp;

    wc_output_init(t_ces,  &putc_st);
    putc_str = Strnew_size(8);
    putc_f_ces = f_ces;
    putc_t_ces = t_ces;
    return;
}

wc_putc(char* c, FILE* f)
{// addr = 0x080BB724
    wc_uchar* p;
    _unknown_ _v8;
    char _v16;
    char* _v20;
    intOrPtr _v24;
    _unknown_ _v32;
    struct * _v36;
    char* _v40;
    wc_uchar* _v44;
    _unknown_ __ebp;
    _unknown_ _t42;

    _push(__ebx);
    __esp = __esp - 36;
    if(putc_f_ces == 3211264) {
        _v16 = c;
    } else {
        _v16 =  *(wc_Str_conv(Strnew_charp(c), putc_f_ces, 3211264));
    }
    Strclear(putc_str);
    while(( *_v16 & 255 & 4294967295) != 0) {
        _v40 =  &_v16;
        wtf_parse( &_v24);
        __esp = __esp - 4;
        _v36 =  &putc_st;
        _v44 = _v24;
        _v40 = _v20;
         *__esp = putc_str;
         *((intOrPtr*)( *((intOrPtr*)(putc_st.marks + 24))))();
    }
}

wc_putc_end(FILE* f)
{// addr = 0x080BB7F1
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t16;

    Strclear(putc_str);
    wc_push_end(putc_str,  &putc_st);
    if(putc_str->length == 0) {
        return ;
    }
    fwrite(putc_str->ptr, 1, putc_str->length, f);
    return;
}

wc_putc_clear_status()
{// addr = 0x080BB853
    _unknown_ __ebp;

    if((putc_st.marks->line & 2048) == 0) {
        return ;
    }
     *135790405 = 0;
     *135790404 = 0;
     *135790406 = 0;
     *135790416 = 0;
     *135790420 = 0;
     *135790424 = 0;
     *135790428 = 0;
    return;
}

int map_cmp(* a, * b)
{// addr = 0x080BB8A8
    _unknown_ __ebp;

    return ( *a & 65535 & 4294967295 & ) - ( *b & 65535 & 4294967295 & );
}

int map3_cmp(* a, * b)
{// addr = 0x080BB8C5
    _unknown_ __ebp;

    return  *a - ( *(b + 2) & 65535 & 4294967295 &  | ( *b & 65535 & 4294967295 & ) << 16);
}

int map_range_cmp(* a, * b)
{// addr = 0x080BB8EF
    _unknown_ __ebp;
    _unknown_ _t15;
    _unknown_ _t21;

    if(( *a & 65535 & 4294967295) < ( *b & 65535 & 4294967295)) {
        return -1;
    }
    return  *(b + 2) & 65535 & 4294967295 & ;
}

int map2_range_cmp(* a, * b)
{// addr = 0x080BB922
    _unknown_ __ebp;
    _unknown_ _t13;
    _unknown_ _t20;
    _unknown_ _t22;

    if(( *a & 65535 & 4294967295) < ( *b & 65535 & 4294967295)) {
        return -1;
    }
    asm("setnb al");
    return  *(b + 4) & 65535 & 4294967295 & ;
}

int map3_range_cmp(* a, * b)
{// addr = 0x080BB957
    _unknown_ __ebp;
    _unknown_ _t15;
    _unknown_ _t21;

    if(( *a & 65535 & 4294967295) < ( *b & 65535 & 4294967295)) {
        return -1;
    }
    return  *(b + 2) & 65535 & 4294967295 & ;
}

wc_map* wc_map_search(wc_uint16 code, wc_map* map, size_t n)
{// addr = 0x080BB98A
    void _v16;
    intOrPtr _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = code & 4294967295;
    _v44 = map_cmp;
    return bsearch( &_v16, map, n, 4);
}

wc_map3* wc_map3_search(wc_uint16 c1, wc_uint16 c2, wc_map3* map, size_t n)
{// addr = 0x080BB9C2
    wc_uint32 code;
    void _v16;
    signed short _v32;
    signed short _v36;
    intOrPtr _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;

    _v32 = c1 & 4294967295;
    _v36 = c2 & 4294967295;
    _v16 = _v36 & 65535 | (_v32 & 65535) << 16;
    _v60 = map3_cmp;
    return bsearch( &_v16, map, n, 6);
}

wc_map* wc_map_range_search(wc_uint16 code, wc_map* map, int n)
{// addr = 0x080BBA13
    void _v16;
    intOrPtr _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = code & 4294967295;
    _v44 = map_range_cmp;
    return bsearch( &_v16, map, n, 4);
}

wc_map* wc_map2_range_search(wc_uint16 code, wc_map* map, size_t n)
{// addr = 0x080BBA4B
    void _v16;
    intOrPtr _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = code & 4294967295;
    _v44 = map2_range_cmp;
    return bsearch( &_v16, map, n, 4);
}

wc_map3* wc_map3_range_search(wc_uint16 code, wc_map3* map, size_t n)
{// addr = 0x080BBA83
    void _v16;
    intOrPtr _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    _v16 = code & 4294967295;
    _v44 = map3_range_cmp;
    return bsearch( &_v16, map, n, 6);
}

wc_wchar_t wc_sjis_to_jis(wc_wchar_t cc)
{// addr = 0x080BBABC
    wc_uchar ub;
    wc_uchar lb;
    signed char _v5;
    signed char _v6;
    _unknown_ __ebp;
    signed int _t62;
    signed int _t63;
    signed int _t67;

    __ecx = cc.ccs;
    _v5 = _a12 >> 8 & 4294967295;
    _v6 = _a12 & 4294967295;
    if(_v5 > 239) {
        if(_v6 > 158) {
            _v5 =  *((_v5 & 255) - 240 + "($,.nprtvxz|~") & 255 & 4294967295;
            _v6 = _v6 - 126;
        } else {
            _v5 =  *((_v5 & 255) - 240 + "!#%-/oqsuwy{}") & 255 & 4294967295;
            if(_v6 <= 126) {
                _t62 = 31;
            } else {
                _t62 = 32;
            }
            _v6 = _v6 - (_t62 & 4294967295);
        }
        cc.code = 33104;
    } else {
        if(_v5 > 159) {
            _t63 = -63;
        } else {
            _t63 = -127;
        }
        _v5 = _v5 - (_t63 & 4294967295);
        _v5 = (_v5 & 255) + (_v5 & 255) + 33 & 4294967295;
        if(_v6 > 158) {
            _v5 = _v5 + 1;
            _v6 = _v6 - 126;
        } else {
            if(_v6 <= 126) {
                _t67 = 31;
            } else {
                _t67 = 32;
            }
            _v6 = _v6 - (_t67 & 4294967295);
        }
        cc.code = 33090;
    }
    _a12 = _v6 & 255 | (_v5 & 255) << 8;
     *__ecx = cc.code;
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_jis_to_sjis(wc_wchar_t cc)
{// addr = 0x080BBB9A
    wc_uchar ub;
    wc_uchar lb;
    signed int _v5;
    signed char _v6;
    _unknown_ __ebp;
    signed int _t55;
    signed int _t59;
    signed int _t67;

    __ecx = cc.ccs;
    _v5 = _a12 >> 8 & 127 & 4294967295;
    _v6 = _a12 & 127 & 4294967295;
    if(cc.code != 33104) {
        if((_v5 & 255 & 1 & 4294967295) == 0) {
            _t55 = 125;
        } else {
            _t55 = 31;
        }
        _v6 = _v6 + (_t55 & 4294967295);
        if(_v6 > 126) {
            _v6 = _v6 + 1;
        }
        _v5 = (_v5 & 255) - 33 >> 1 & 4294967295;
        if(_v5 > 30) {
            _t59 = -63;
        } else {
            _t59 = -127;
        }
        _v5 = _v5 + (_t59 & 4294967295);
        goto L17;
    }
    if((_v5 & 255 & 1 & 4294967295) == 0) {
        _t67 = 125;
    } else {
        _t67 = 31;
    }
    _v6 = _v6 + (_t67 & 4294967295);
    if(_v6 > 126) {
        _v6 = _v6 + 1;
    }
    _v5 =  *( &jisx02132_sjis_map + (_v5 & 255)) & 255 & 4294967295;
    if(_v5 != 0) {
L17:
        _a12 = _v6 & 255 | (_v5 & 255) << 8;
         *__ecx = cc.code;
         *(__ecx + 4) = _a12;
        return __ecx;
    } else {
        cc.code = 49152;
         *__ecx = cc.code;
         *(__ecx + 4) = _a12;
        return __ecx;
    }
}

wc_wchar_t wc_sjis_ext_to_cs94w(wc_wchar_t cc)
{// addr = 0x080BBC76
    wc_uchar ub;
    wc_uchar lb;
    signed char _v5;
    signed char _v6;
    _unknown_ __ebp;
    signed int _t38;
    signed int _t47;

    __ecx = cc.ccs;
    _v5 = _a12 >> 8 & 4294967295;
    _v6 = _a12 & 4294967295;
    if(_v5 > 159) {
        _t38 = -63;
    } else {
        _t38 = -127;
    }
    _v5 = _v5 - (_t38 & 4294967295);
    _v5 = (_v5 & 255) + (_v5 & 255) + 33 & 4294967295;
    if(_v6 > 158) {
        _v5 = _v5 + 1;
        _v6 = _v6 - 126;
    } else {
        if(_v6 <= 126) {
            _t47 = 31;
        } else {
            _t47 = 32;
        }
        _v6 = _v6 - (_t47 & 4294967295);
    }
    if(_v5 > 126) {
        _v5 = _v5 - 94;
        cc.code = 34837;
    } else {
        cc.code = 34836;
    }
    _a12 = _v6 & 255 | (_v5 & 255) << 8;
     *__ecx = cc.code;
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs94w_to_sjis_ext(wc_wchar_t cc)
{// addr = 0x080BBD11
    wc_uchar ub;
    wc_uchar lb;
    signed int _v5;
    signed char _v6;
    _unknown_ __ebp;
    signed int _t41;
    signed int _t45;

    __ecx = cc.ccs;
    _v5 = _a12 >> 8 & 127 & 4294967295;
    _v6 = _a12 & 127 & 4294967295;
    if(cc.code == 34837) {
        _v5 = _v5 + 94;
    }
    if((_v5 & 255 & 1 & 4294967295) == 0) {
        _t41 = 125;
    } else {
        _t41 = 31;
    }
    _v6 = _v6 + (_t41 & 4294967295);
    if(_v6 > 126) {
        _v6 = _v6 + 1;
    }
    _v5 = (_v5 & 255) - 33 >> 1 & 4294967295;
    if(_v5 > 30) {
        _t45 = -63;
    } else {
        _t45 = -127;
    }
    _v5 = _v5 + (_t45 & 4294967295);
    cc.code = 34835;
    _a12 = _v6 & 255 | (_v5 & 255) << 8;
     *__ecx = cc.code;
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_uint32 wc_sjis_ext1_to_N(wc_uint32 c)
{// addr = 0x080BBDAC
    wc_uchar ub;
    signed int _v5;
    _unknown_ __ebp;
    signed int _t13;
    _unknown_ _t18;

    _v5 = c >> 8 & 127 & 4294967295;
    _t13 = _v5 & 255;
    if(_t13 == 45) {
        _v5 = 0;
        return (_v5 & 255) * (_v5 & 255) + (c & 127) - 33;
    }
    if(_t13 < 45) {
        return -1;
    }
    if(_t13 - 121 > 3) {
        return -1;
    }
    _v5 = _v5 - 120;
    return (_v5 & 255) * (_v5 & 255) + (c & 127) - 33;
}

wc_uint32 wc_sjis_ext2_to_N(wc_uint32 c)
{// addr = 0x080BBDFD
    wc_uchar ub;
    signed int _v5;
    _unknown_ __ebp;
    _unknown_ _t14;

    _v5 = c >> 8 & 127 & 4294967295;
    if((_v5 & 255) - 53 > 4) {
        return -1;
    }
    _v5 = _v5 - 48;
    return (_v5 & 255) * (_v5 & 255) + (c & 127) - 33;
}

Str wc_conv_from_sjis(Str is, wc_ces ces)
{// addr = 0x080BBE3A
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    wc_uchar[1] jis;
    int state;
    wc_wchar_t cc;
    _unknown_ _v13;
    _unknown_ _v14;
    _unknown_ _v20;
    char* _v24;
    char* _v28;
    char* _v32;
    intOrPtr _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t157;
    _unknown_ _t191;
    _unknown_ _t222;
    _unknown_ _t236;
    _unknown_ _t243;
    _unknown_ _t263;
    _unknown_ _t275;

    _v24 = is->ptr;
    _v28 =  &(_v24[is->length]);
    _v36 = 0;
    _v32 = _v24;
    while() {
    }
}

Str wc_conv_from_sjisx0213(Str is, wc_ces ces)
{// addr = 0x080BC1CA
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    wc_uchar[1] jis;
    int state;
    wc_wchar_t cc;
    _unknown_ _v13;
    _unknown_ _v14;
    _unknown_ _v20;
    char* _v24;
    char* _v28;
    char* _v32;
    intOrPtr _v36;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t178;
    _unknown_ _t211;
    _unknown_ _t228;
    _unknown_ _t249;
    _unknown_ _t263;
    _unknown_ _t270;
    _unknown_ _t291;
    _unknown_ _t292;
    _unknown_ _t302;

    _v24 = is->ptr;
    _v28 =  &(_v24[is->length]);
    _v36 = 0;
    _v32 = _v24;
    while() {
    }
}

wc_push_to_sjis(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BC591
    wc_uchar ub;
    wc_uchar lb;
    signed int _v13;
    signed char _v14;
    unsigned int _v32;
    unsigned int _v36;
    intOrPtr _v48;
    unsigned int _v52;
    unsigned int _v56;
    _unknown_ __ebp;
    unsigned int _t168;
    signed int _t176;
    signed int _t180;
    int _t187;
    int _t199;
    unsigned int _t213;
    int _t225;
    int _t237;
    int _t254;
    int _t270;

    while(1) {
        _t168 = cc.ccs;
        if(_t168 == 33090) {
            break;
        }
        if(_t168 > 33090) {
            if(_t168 > 34837) {
                if(_t168 == 49152) {
                    if(( *135119022 & 255 & 4294967295) != 0) {
                        return ;
                    }
                    Strcat_charp(os, WcReplaceW);
                    return;
                }
                goto L12;
            }
            goto L8;
L12:
            goto L47;
        }
        if(_t168 == 329) {
            if(( *135119017 & 255 & 4294967295) == 0) {
                if(( *135119013 & 255 & 4294967295) == 0) {
                    _v56 = cc.ccs;
                    _v52 = cc.code;
                     *__esp =  &(cc.ccs);
                    wc_jisx0201k_to_jisx0208();
                    __esp = __esp - 4;
                } else {
                    cc.ccs = 16384;
                }
                continue;
            }
            goto L17;
        }
        if(_t168 == 16384) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplace);
            return;
        }
        if(_t168 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t270 = os->length;
             *(os->ptr + _t270) = cc.code & 4294967295;
            os->length = _t270 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        } else {
        }
L47:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t213 = 16384;
            } else {
                _t213 = 49152;
            }
            cc.ccs = _t213;
        } else {
            _v48 = _a16;
            _v56 = cc.ccs;
            _v52 = cc.code;
             *__esp =  &_v36;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v36;
            cc.code = _v32;
        }
        continue;
L17:
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t254 = os->length;
         *(os->ptr + _t254) = (cc.code | 128) & 4294967295;
        os->length = _t254 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
L8:
        if(_t168 >= 34836) {
            _v56 = cc.ccs;
            _v52 = cc.code;
             *__esp =  &_v36;
            wc_cs94w_to_sjis_ext();
            __esp = __esp - 4;
            cc.ccs = _v36;
            cc.code = _v32;
            goto L38;
        }
        if(_t168 == 34835) {
            goto L38;
        }
        goto L47;
L38:
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t225 = os->length;
         *(os->ptr + _t225) = cc.code >> 8 & 4294967295;
        os->length = _t225 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t237 = os->length;
         *(os->ptr + _t237) = cc.code & 4294967295;
        os->length = _t237 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
    }
    _v13 = cc.code >> 8 & 127 & 4294967295;
    _v14 = cc.code & 127 & 4294967295;
    if((_v13 & 255 & 1 & 4294967295) == 0) {
        _t176 = 125;
    } else {
        _t176 = 31;
    }
    _v14 = _v14 + (_t176 & 4294967295);
    if(_v14 > 126) {
        _v14 = _v14 + 1;
    }
    _v13 = (_v13 & 255) - 33 >> 1 & 4294967295;
    if(_v13 > 30) {
        _t180 = -63;
    } else {
        _t180 = -127;
    }
    _v13 = _v13 + (_t180 & 4294967295);
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t187 = os->length;
     *(os->ptr + _t187) = _v13 & 255 & 4294967295;
    os->length = _t187 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t199 = os->length;
     *(os->ptr + _t199) = _v14 & 255 & 4294967295;
    os->length = _t199 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

wc_push_to_sjisx0213(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BC955
    wc_uchar ub;
    wc_uchar lb;
    signed int _v13;
    signed char _v14;
    unsigned int _v32;
    unsigned int _v36;
    intOrPtr _v48;
    unsigned int _v52;
    unsigned int _v56;
    _unknown_ __ebp;
    unsigned int _t182;
    signed int _t190;
    signed int _t194;
    int _t201;
    int _t213;
    signed int _t229;
    int _t241;
    int _t253;
    unsigned int _t265;
    int _t278;
    int _t294;

    while(1) {
        _t182 = cc.ccs;
        if(_t182 == 33090) {
            break;
        }
        if(_t182 > 33090) {
            if(_t182 == 33104) {
                if(( *135119019 & 255 & 4294967295) != 0) {
                    _v13 = cc.code >> 8 & 127 & 4294967295;
                    _v14 = cc.code & 127 & 4294967295;
                    if((_v13 & 255 & 1 & 4294967295) == 0) {
                        _t229 = 125;
                    } else {
                        _t229 = 31;
                    }
                    _v14 = _v14 + (_t229 & 4294967295);
                    if(_v14 > 126) {
                        _v14 = _v14 + 1;
                    }
                    _v13 =  *( &jisx02132_sjis_map + (_v13 & 255)) & 255 & 4294967295;
                    if(_v13 == 0) {
L50:
                        if(( *135119022 & 255 & 4294967295) != 0) {
                            return ;
                        }
                        Strcat_charp(os, WcReplaceW);
                        return;
                    } else {
                        if(os->length + 1 >= os->area_size) {
                            Strgrow(os);
                        }
                        _t241 = os->length;
                         *(os->ptr + _t241) = _v13 & 255 & 4294967295;
                        os->length = _t241 + 1;
                         *((char*)(os->ptr + os->length)) = 0;
                        if(os->length + 1 >= os->area_size) {
                            Strgrow(os);
                        }
                        _t253 = os->length;
                         *(os->ptr + _t253) = _v14 & 255 & 4294967295;
                        os->length = _t253 + 1;
                         *((char*)(os->ptr + os->length)) = 0;
                        return;
                    }
                }
                goto L38;
            }
            goto L8;
L38:
            cc.ccs = 49152;
            goto L60;
        }
        if(_t182 == 329) {
            if(( *135119017 & 255 & 4294967295) == 0) {
                if(( *135119013 & 255 & 4294967295) == 0) {
                    _v56 = cc.ccs;
                    _v52 = cc.code;
                     *__esp =  &(cc.ccs);
                    wc_jisx0201k_to_jisx0208();
                    __esp = __esp - 4;
                } else {
                    cc.ccs = 16384;
                }
L60:
                continue;
            }
            goto L15;
        }
        if(_t182 == 16384) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplace);
            return;
        }
        if(_t182 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t294 = os->length;
             *(os->ptr + _t294) = cc.code & 4294967295;
            os->length = _t294 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        } else {
        }
L54:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t265 = 16384;
            } else {
                _t265 = 49152;
            }
            cc.ccs = _t265;
        } else {
            _v48 = _a16;
            _v56 = cc.ccs;
            _v52 = cc.code;
             *__esp =  &_v36;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v36;
            cc.code = _v32;
        }
        continue;
L15:
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t278 = os->length;
         *(os->ptr + _t278) = (cc.code | 128) & 4294967295;
        os->length = _t278 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
L8:
        if(_t182 == 49152) {
            goto L50;
        }
        if(_t182 == 33103) {
            if(( *135119019 & 255 & 4294967295) != 0) {
                break;
            }
            goto L23;
        }
        goto L54;
L23:
        cc.ccs = 49152;
        goto L60;
    }
    _v13 = cc.code >> 8 & 127 & 4294967295;
    _v14 = cc.code & 127 & 4294967295;
    if((_v13 & 255 & 1 & 4294967295) == 0) {
        _t190 = 125;
    } else {
        _t190 = 31;
    }
    _v14 = _v14 + (_t190 & 4294967295);
    if(_v14 > 126) {
        _v14 = _v14 + 1;
    }
    _v13 = (_v13 & 255) - 33 >> 1 & 4294967295;
    if(_v13 > 30) {
        _t194 = -63;
    } else {
        _t194 = -127;
    }
    _v13 = _v13 + (_t194 & 4294967295);
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t201 = os->length;
     *(os->ptr + _t201) = _v13 & 255 & 4294967295;
    os->length = _t201 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t213 = os->length;
     *(os->ptr + _t213) = _v14 & 255 & 4294967295;
    os->length = _t213 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_sjis(wc_uchar c, wc_status* st)
{// addr = 0x080BCD67
    wc_wchar_t cc;
    signed int _v16;
    unsigned int _v20;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t77;
    _unknown_ _t98;
    _unknown_ _t124;
    struct _Str* _t135;
    _unknown_ _t141;
    signed int _t154;
    signed int _t161;
    int _t163;

    _v32 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135790480 = Strnew_size(8);
    }
    _t77 = st->state;
    if(_t77 > 2) {
        if(_t77 == 3) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 255 & 4294967295 &  & 16) != 0) {
                 *135790485 = _v32 & 255 & 4294967295;
                wtf_push( *135790480, 34835, ( *135790484 & 255 & 4294967295 & ) << 8 |  *135790485 & 255 & 4294967295 & );
            }
            st->state = 0;
        }
        goto L30;
    } else {
        if(_t77 >= 1) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 255 & 4294967295 &  & 16) != 0) {
                 *135790485 = _v32 & 255 & 4294967295;
                _t154 =  *135790484 & 255;
                if(( *135790484 & 255 & 4294967295) > 159) {
                }
                 *135790484 = _t154 & 4294967295;
                 *135790484 = ( *135790484 & 255) + ( *135790484 & 255) + 33 & 4294967295;
                if(( *135790485 & 255 & 4294967295) > 158) {
                     *135790484 = ( *135790484 & 255) + 1 & 4294967295;
                     *135790485 = ( *135790485 & 255) - 126 & 4294967295;
                } else {
                    _t161 =  *135790485 & 255;
                    if(( *135790485 & 255 & 4294967295) <= 126) {
                    }
                     *135790485 = _t161 & 4294967295;
                }
                _v16 =  *135790485 & 255 & 4294967295 &  | ( *135790484 & 255 & 4294967295 & ) << 8;
                _v20 = wc_jisx0208_or_jisx02131(_v16 & 4294967295 & );
                if(_v20 != 33090) {
                    wtf_push( *135790480, 34835, ( *135790484 & 255 & 4294967295 & ) << 8 |  *135790485 & 255 & 4294967295 & );
                } else {
                    wtf_push( *135790480, _v20, _v16);
                }
            }
            st->state = 0;
            goto L30;
        }
        if(_t77 == 0) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 255 & 4294967295 & ) - 18 > 46) {
                if( *135790480->length + 1 >=  *135790480->area_size) {
                    Strgrow( *135790480);
                }
                _t135 =  *135790480;
                _t163 = _t135->length;
                 *( *( *135790480) + _t163) = _v32 & 255 & 4294967295;
                _t135->length = _t163 + 1;
                 *( *( *135790480) +  *135790480->length) = 0;
                goto L30;
            }
            goto __eax;
        }
L30:
        st->state = -1;
        return  *135790480;
    }
}

Str wc_char_conv_from_sjisx0213(wc_uchar c, wc_status* st)
{// addr = 0x080BD079
    wc_wchar_t cc;
    signed int _v16;
    unsigned int _v20;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t85;
    _unknown_ _t111;
    _unknown_ _t120;
    _unknown_ _t140;
    struct _Str* _t151;
    _unknown_ _t157;
    signed int _t171;
    signed int _t172;
    signed int _t176;
    int _t178;

    _v32 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135790472 = Strnew_size(8);
    }
    _t85 = st->state;
    if(_t85 > 2) {
        if(_t85 == 3) {
            if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 255 & 4294967295 &  & 16) != 0) {
                 *135790477 = _v32 & 255 & 4294967295;
                if(( *135790477 & 255 & 4294967295) > 158) {
                     *135790476 =  *(( *135790476 & 255 & 4294967295 & ) - 240 + "($,.nprtvxz|~") & 255 & 4294967295;
                     *135790477 = ( *135790477 & 255) - 126 & 4294967295;
                } else {
                     *135790476 =  *(( *135790476 & 255 & 4294967295 & ) - 240 + "!#%-/oqsuwy{}") & 255 & 4294967295;
                    _t171 =  *135790477 & 255;
                    if(( *135790477 & 255 & 4294967295) <= 126) {
                    }
                     *135790477 = _t171 & 4294967295;
                }
                wtf_push( *135790472, 33104, ( *135790476 & 255 & 4294967295 & ) << 8 |  *135790477 & 255 & 4294967295 & );
            }
            st->state = 0;
        }
L34:
        st->state = -1;
        return  *135790472;
    }
    if(_t85 >= 1) {
        if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 255 & 4294967295 &  & 16) != 0) {
             *135790477 = _v32 & 255 & 4294967295;
            _t172 =  *135790476 & 255;
            if(( *135790476 & 255 & 4294967295) > 159) {
            }
             *135790476 = _t172 & 4294967295;
             *135790476 = ( *135790476 & 255) + ( *135790476 & 255) + 33 & 4294967295;
            if(( *135790477 & 255 & 4294967295) > 158) {
                 *135790476 = ( *135790476 & 255) + 1 & 4294967295;
                 *135790477 = ( *135790477 & 255) - 126 & 4294967295;
            } else {
                _t176 =  *135790477 & 255;
                if(( *135790477 & 255 & 4294967295) <= 126) {
                }
                 *135790477 = _t176 & 4294967295;
            }
            _v16 =  *135790477 & 255 & 4294967295 &  | ( *135790476 & 255 & 4294967295 & ) << 8;
            _v20 = wc_jisx0208_or_jisx02131(_v16 & 4294967295 & );
            wtf_push( *135790472, _v20, _v16);
        }
        st->state = 0;
        goto L34;
    }
    if(_t85 == 0) {
        if(( *( &WC_SJIS_MAP + (_v32 & 255)) & 255 & 4294967295 & ) - 18 > 46) {
            if( *135790472->length + 1 >=  *135790472->area_size) {
                Strgrow( *135790472);
            }
            _t151 =  *135790472;
            _t178 = _t151->length;
             *( *( *135790472) + _t178) = _v32 & 255 & 4294967295;
            _t151->length = _t178 + 1;
             *( *( *135790472) +  *135790472->length) = 0;
            goto L34;
        }
        goto __eax;
    }
    goto L34;
}

wc_input_init(wc_ces ces, wc_status* st)
{// addr = 0x080BD3D0
    wc_gset* gset;
    int i;
    int g;
    intOrPtr* _v8;
    signed int _v12;
    signed int _v16;
    _unknown_ __ebp;

    st->ces_info =  &WcCesInfo + ((ces & 255) << 5);
    _v8 = st->ces_info->gset;
    st->state = 0;
     *(st + 8) = 0;
     *(st + 12) = 0;
     *((intOrPtr*)(st + 16)) =  *_v8;
     *((intOrPtr*)(st + 20)) =  *((intOrPtr*)(_v8 + 8));
     *(st + 24) = 0;
     *(st + 28) = 0;
     *(st + 5) = 0;
     *((char*)(st + 4)) = 1;
     *(st + 6) = 0;
    _v12 = 0;
    while( *((intOrPtr*)((_v12 << 3) + _v8)) != 0) {
        if(( *((_v12 << 3) + _v8 + 5) & 255 & 4294967295) != 0) {
            _v16 =  *((_v12 << 3) + _v8 + 4) & 255 & 4294967295 &  & 3;
            if( *((intOrPtr*)(st + (_v16 + 4) * 4)) == 0) {
                 *((intOrPtr*)(st + (_v16 + 4) * 4)) =  *((intOrPtr*)((_v12 << 3) + _v8));
            }
        }
        _v12 = _v12 + 1;
    }
}

wc_output_init(wc_ces ces, wc_status* st)
{// addr = 0x080BD4D7
    wc_gset* gset;
    size_t i;
    size_t n;
    size_t nw;
    intOrPtr* _v16;
    signed int _v20;
    signed int _v24;
    wc_table** _v28;
    intOrPtr _v36;
    struct * _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    intOrPtr _t164;
    intOrPtr _t166;
    _unknown_ _t193;
    _unknown_ _t197;
    _unknown_ _t225;
    wc_status* _t246;
    int _t259;
    wc_status* _t260;

    if((output_set & 255 & 4294967295) == 0) {
L4:
        st->state = 0;
        st->ces_info =  &WcCesInfo + ((ces & 255) << 5);
        _v16 = st->ces_info->gset;
        if(ces == 2099217 || ces == 2099218 || ces == 2099219) {
            if(( *135119015 & 255 & 4294967295) != 0) {
                _t164 = 330;
L10:
                 *((intOrPtr*)(st + 8)) = _t164;
                if(ces == 2099217 || ces == 2099218 || ces == 2099219) {
                    if(( *135119016 & 255 & 4294967295) != 0) {
                        _t166 = 33088;
L16:
                         *((intOrPtr*)(st + 12)) = _t166;
                         *((intOrPtr*)(st + 16)) =  *((intOrPtr*)(st + 8));
                         *(st + 20) = 0;
                         *(st + 24) = 0;
                         *(st + 28) = 0;
                         *(st + 5) = 0;
                         *(st + 4) = 0;
                         *(st + 6) = 0;
                        if((ces & 2048) != 0) {
                            wc_create_gmap(st);
                        }
                         *(st + 44) = 0;
                        st->ntag = 0;
                        if(( *135119011 & 255 & 4294967295) != 0) {
                            _v28 = 0;
                            _v24 = _v28;
                            _v20 = _v24;
L25:
                            while( *((_v20 << 3) + _v16) != 0) {
                                goto L21;
                            }
                        } else {
                            st->tlist = 0;
                            st->tlistw = 0;
                            _t246 = st;
                            output_st.marks =  *_t246;
                             *135790500 =  *((intOrPtr*)(_t246 + 4));
                             *135790504 =  *((intOrPtr*)(_t246 + 8));
                             *135790508 =  *((intOrPtr*)(_t246 + 12));
                             *135790512 =  *((intOrPtr*)(_t246 + 16));
                             *135790516 =  *((intOrPtr*)(_t246 + 20));
                             *135790520 =  *((intOrPtr*)(_t246 + 24));
                             *135790524 =  *((intOrPtr*)(_t246 + 28));
                             *135790528 = _t246->tlist;
                             *135790532 = _t246->tlistw;
                             *135790536 = _t246->state;
                             *135790540 =  *((intOrPtr*)(_t246 + 44));
                             *135790544 = _t246->ntag;
                             *135790548 =  *((intOrPtr*)(_t246 + 52));
                             *135790552 = _t246->shift;
                            output_set = 1;
                            output_option.marks = WcOption.marks;
                             *135790560 =  *135119012;
                             *135790564 =  *135119016;
                             *135790568 =  *135119020;
                            return;
                        }
L21:
                        if(( *((_v20 << 3) + _v16) & 98304) == 0) {
                            _v24 = _v24 + 1;
                        } else {
                            _v28 =  &(_v28[0]);
                        }
                        _v20 = _v20 + 1;
                        goto L25;
                    }
                }
L14:
                _t166 =  *((intOrPtr*)(_v16 + 8));
                goto L16;
            }
        }
L8:
        _t164 =  *_v16;
        goto L10;
    }
    _t259 = output_st.marks->line;
    if(_t259 != ces) {
        goto L4;
    } else {
        _v36 = 16;
        _v40 =  &output_option;
         *__esp =  &WcOption;
        memcmp();
        if(_t259 != 0) {
            goto L4;
        } else {
            _t260 = st;
             *_t260 = output_st.marks;
             *((intOrPtr*)(_t260 + 4)) =  *135790500;
             *((intOrPtr*)(_t260 + 8)) =  *135790504;
             *((intOrPtr*)(_t260 + 12)) =  *135790508;
             *((intOrPtr*)(_t260 + 16)) =  *135790512;
             *((intOrPtr*)(_t260 + 20)) =  *135790516;
             *((intOrPtr*)(_t260 + 24)) =  *135790520;
             *((intOrPtr*)(_t260 + 28)) =  *135790524;
            _t260->tlist =  *135790528;
            _t260->tlistw =  *135790532;
            _t260->state =  *135790536;
             *((intOrPtr*)(_t260 + 44)) =  *135790540;
            _t260->ntag =  *135790544;
             *((intOrPtr*)(_t260 + 52)) =  *135790548;
            _t260->shift =  *135790552;
            return;
        }
    }
    goto L5;
}

wc_bool wc_ces_has_ccs(wc_ccs ccs, wc_status* st)
{// addr = 0x080BD983
    wc_gset* gset;
    int i;
    wc_gset* _v8;
    signed int _v12;
    _unknown_ __ebp;
    _unknown_ _t23;
    _unknown_ _t24;

    _v8 = st->ces_info->gset;
    _v12 = 0;
    while( *((intOrPtr*)(_v8 + (_v12 << 3))) != 0) {
        if( *((intOrPtr*)(_v8 + (_v12 << 3))) == ccs) {
            return 1;
        }
        _v12 = _v12 + 1;
    }
}

wc_wchar_t ucs_cs94_conv(wc_ccs ccs, wc_uint16 c)
{// addr = 0x080BD9D0
    wc_wchar_t cc;
    signed int _v8;
    short unsigned int _v12;
    signed short _v24;
    _unknown_ __ebp;

    __ecx = ccs;
    _v24 = _a12 & 4294967295;
    _v12 = c;
    _v8 = _v24 & 65535;
     *__ecx = _v12;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_viet_conv(wc_ccs ccs, wc_uint16 c)
{// addr = 0x080BD9FE
    wc_wchar_t cc;
    signed int _v8;
    short unsigned int _v12;
    signed int _v24;
    _unknown_ __ebp;
    short unsigned int _t27;
    short unsigned int _t33;

    __ecx = ccs;
    _v24 = _a12 & 4294967295;
    if((_v24 & 65535 & 128) == 0) {
        _v12 = c;
        _t27 = c;
        if(_t27 == 2080) {
            _v12 = 2081;
        } else {
            if(_t27 == 2082) {
                _v12 = 2083;
            } else {
                if(_t27 == 2077) {
                    _v12 = 2078;
                }
            }
        }
    } else {
        _v12 = c;
        _t33 = c;
        if(_t33 == 2081) {
            _v12 = 2080;
        } else {
            if(_t33 == 2083) {
                _v12 = 2082;
            } else {
                if(_t33 == 2078) {
                    _v12 = 2077;
                }
            }
        }
    }
    _v8 = _v24 & 65535 & 255;
     *__ecx = _v12;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_cp1258_conv(wc_ccs ccs, wc_uint16 c)
{// addr = 0x080BDAAC
    wc_wchar_t cc;
    signed int _v8;
    intOrPtr _v12;
    signed short _v24;
    _unknown_ __ebp;
    intOrPtr _t13;

    __ecx = ccs;
    _v24 = _a12 & 4294967295;
    if(_v24 > 255) {
        _t13 = 2076;
    } else {
        _t13 = 2075;
    }
    _v12 = _t13;
    _v8 = _v24 & 65535;
     *__ecx = _v12;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_cns11643_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDAEB
    wc_wchar_t cc;
    signed int _v8;
    intOrPtr _v12;
    signed int _v24;
    _unknown_ __ebp;
    intOrPtr _t15;

    __ecx = cs;
    _v24 = _a12 & 4294967295;
    if((_v24 & 65535 & 4294967295) >= 0) {
        _t15 = 33095;
    } else {
        _t15 = 33096;
    }
    _v12 = _t15;
    _v8 = _v24 & 65535 & 32639;
     *__ecx = _v12;
     *(__ecx + 4) = _v8;
    return __ecx;
}

wc_wchar_t ucs_big5_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDB30
    wc_wchar_t cc;
    _unknown_ _v8;
    signed int _v16;
    short unsigned int _v20;
    signed short _v32;
    signed int _v52;
    short unsigned int _v56;
    _unknown_ __ebp;
    struct  _t20;
    _unknown_ _t21;

    _push(__ebx);
    __esp = __esp - 52;
    _t20 = cs;
    _v32 = _a12 & 4294967295;
    _v20 = c;
    _v16 = _v32 & 65535;
    _v56 = _v20;
    _v52 = _v16;
     *__esp = _t20;
    wc_big5_to_cs94w();
    __esp = __esp - 4;
    return _t20;
}

wc_wchar_t ucs_johab2_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDB70
    wc_wchar_t cc;
    _unknown_ _v8;
    signed int _v16;
    short unsigned int _v20;
    signed short _v32;
    signed int _v52;
    short unsigned int _v56;
    _unknown_ __ebp;
    struct  _t20;
    _unknown_ _t21;

    _push(__ebx);
    __esp = __esp - 52;
    _t20 = cs;
    _v32 = _a12 & 4294967295;
    _v20 = c;
    _v16 = _v32 & 65535;
    _v56 = _v20;
    _v52 = _v16;
     *__esp = _t20;
    wc_johab_to_cs128w();
    __esp = __esp - 4;
    return _t20;
}

wc_wchar_t ucs_johab3_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDBB0
    wc_wchar_t cc;
    signed int _v8;
    short unsigned int _v12;
    signed short _v24;
    _unknown_ __ebp;

    __ecx = cs;
    _v24 = _a12 & 4294967295;
    if(_v24 <= 8480 || _v24 > 9248) {
        if(_v24 <= 9299 || _v24 > 11390) {
            if(_v24 <= 18976 || _v24 > 32126) {
                _v12 = 49152;
L8:
                _v8 = _v24 & 65535;
                 *__ecx = _v12;
                 *(__ecx + 4) = _v8;
                return __ecx;
            } else {
                goto L6;
            }
        }
    }
L6:
    _v12 = c;
    goto L8;
}

wc_wchar_t ucs_sjis_ext_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDC17
    wc_wchar_t cc;
    _unknown_ _v8;
    signed int _v16;
    short unsigned int _v20;
    signed short _v32;
    signed int _v52;
    short unsigned int _v56;
    _unknown_ __ebp;
    struct  _t20;
    _unknown_ _t21;

    _push(__ebx);
    __esp = __esp - 52;
    _t20 = cs;
    _v32 = _a12 & 4294967295;
    _v20 = c;
    _v16 = _v32 & 65535;
    _v56 = _v20;
    _v52 = _v16;
     *__esp = _t20;
    wc_sjis_ext_to_cs94w();
    __esp = __esp - 4;
    return _t20;
}

wc_wchar_t ucs_gbk_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDC57
    wc_wchar_t cc;
    _unknown_ _v8;
    signed int _v16;
    short unsigned int _v20;
    signed short _v32;
    signed int _v52;
    short unsigned int _v56;
    _unknown_ __ebp;
    struct  _t20;
    _unknown_ _t21;

    _push(__ebx);
    __esp = __esp - 52;
    _t20 = cs;
    _v32 = _a12 & 4294967295;
    _v20 = c;
    _v16 = _v32 & 65535;
    _v56 = _v20;
    _v52 = _v16;
     *__esp = _t20;
    wc_gbk_to_cs128w();
    __esp = __esp - 4;
    return _t20;
}

wc_wchar_t ucs_uhc_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDC97
    wc_wchar_t cc;
    _unknown_ _v8;
    signed int _v16;
    short unsigned int _v20;
    signed short _v32;
    signed int _v52;
    short unsigned int _v56;
    _unknown_ __ebp;
    struct  _t20;
    _unknown_ _t21;

    _push(__ebx);
    __esp = __esp - 52;
    _t20 = cs;
    _v32 = _a12 & 4294967295;
    _v20 = c;
    _v16 = _v32 & 65535;
    _v56 = _v20;
    _v52 = _v16;
     *__esp = _t20;
    wc_uhc_to_cs128w();
    __esp = __esp - 4;
    return _t20;
}

wc_wchar_t ucs_hkscs_conv(wc_ccs cs, wc_uint16 c)
{// addr = 0x080BDCD7
    wc_wchar_t cc;
    _unknown_ _v8;
    signed int _v16;
    short unsigned int _v20;
    signed short _v32;
    signed int _v52;
    short unsigned int _v56;
    _unknown_ __ebp;
    struct  _t20;
    _unknown_ _t21;

    _push(__ebx);
    __esp = __esp - 52;
    _t20 = cs;
    _v32 = _a12 & 4294967295;
    _v20 = c;
    _v16 = _v32 & 65535;
    _v56 = _v20;
    _v52 = _v16;
     *__esp = _t20;
    wc_hkscs_to_cs128w();
    __esp = __esp - 4;
    return _t20;
}

wc_table* wc_get_ucs_table(wc_ccs ccs)
{// addr = 0x080BDD17
    int f;
    signed int _v8;
    _unknown_ __ebp;
    signed int _t28;
    _unknown_ _t29;
    _unknown_ _t34;
    _unknown_ _t37;
    _unknown_ _t42;
    _unknown_ _t47;
    _unknown_ _t48;
    _unknown_ _t53;
    _unknown_ _t56;

    _v8 = ccs & 255;
    _t28 = ccs & 65280;
    if(_t28 == 2048) {
        if(_v8 <= 0) {
            return 0;
        }
        if(_v8 <= 40) {
            return  &ucs_pcs_table + (_v8 - 1 << 4);
        }
        return 0;
    }
    if(_t28 > 2048) {
        if(_t28 == 33280) {
            if(_v8 <= 63) {
                return 0;
            }
            if(_v8 <= 0) {
                return ucs_cs96w_table + (_v8 - 64 << 4);
            }
            return 0;
        }
        goto L7;
    }
    if(_t28 == 512) {
        if(_v8 <= 63) {
            return 0;
        }
        if(_v8 <= 102) {
            return  &ucs_cs96_table + (_v8 - 64 << 4);
        }
        return 0;
    }
    if(_t28 != 1024) {
        if(_t28 != 256) {
            return 0;
        }
        if(_v8 <= 63) {
            return 0;
        }
        if(_v8 <= 84) {
            return  &ucs_cs94_table + (_v8 - 64 << 4);
        }
        return 0;
    }
    if(_v8 <= 63) {
        return 0;
    }
    if(_v8 <= 0) {
        return ucs_cs942_table + (_v8 - 64 << 4);
    }
    return 0;
L7:
    if(_t28 == 34816) {
        if(_v8 <= 0) {
            return 0;
        }
        if(_v8 <= 33) {
            return  &ucs_pcsw_table + (_v8 - 1 << 4);
        }
        return 0;
    }
    if(_t28 != 33024) {
        return 0;
    }
    if(_v8 <= 63) {
        return 0;
    }
    if(_v8 <= 80) {
        return  &ucs_cs94w_table + (_v8 - 64 << 4);
    }
    return 0;
}

wc_wchar_t wc_ucs_to_any(wc_uint32 ucs, wc_table* t)
{// addr = 0x080BDE9B
    wc_wchar_t cc;
    wc_map* map;
    _unknown_ _v8;
    wc_map* _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    signed int _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    _unknown_ _t64;
    short unsigned int _t73;
    short unsigned int _t84;
    short unsigned int _t86;
    unsigned int _t100;
    _unknown_ _t101;

    _push(__ebx);
    __esp = __esp - 36;
    _t100 = ucs;
    if(_a12 == 0 ||  *(_a12 + 8) == 0 || t == 0) {
L6:
        if(_a12 == 0 || t != 131072) {
L19:
            _v24 = 16384;
             *_t100 = _v24;
             *((intOrPtr*)(_t100 + 4)) = _v20;
            return ;
        } else {
            if( *_a12 != 33103) {
                if( *_a12 != 33104) {
                    if( *_a12 != 34847 &&  *_a12 != 34848 &&  *_a12 != 34849) {
                        _v16 = 0;
                    } else {
                        _t73 = t & 4294967295 & ;
                        wc_map_search(_t73,  &ucs_p2_hkscs_map, 1081);
                        _v16 = _t73;
                    }
                } else {
                    _t84 = t & 4294967295 & ;
                    wc_map_search(_t84,  &ucs_p2_jisx02132_map, 277);
                    _v16 = _t84;
                }
            } else {
                _t86 = t & 4294967295 & ;
                wc_map_search(_t86,  &ucs_p2_jisx02131_map, 25);
                _v16 = _t86;
            }
            if(_v16 == 0) {
                goto L19;
            }
            _v36 =  *(_v16 + 2) & 65535 & 4294967295 & ;
            _v40 =  *_a12;
             *__esp = _t100;
             *((intOrPtr*)( *((intOrPtr*)(_a12 + 12))))();
            __esp = __esp - 4;
            return ;
        }
    } else {
        if(t > 65535) {
            goto L6;
        } else {
            _v16 = wc_map_search(t & 4294967295 & ,  *(_a12 + 8),  *(_a12 + 4));
            if(_v16 == 0) {
                goto L6;
            } else {
                _v36 =  *(_v16 + 2) & 65535 & 4294967295 & ;
                _v40 =  *_a12;
                 *__esp = _t100;
                 *((intOrPtr*)( *((intOrPtr*)(_a12 + 12))))();
                __esp = __esp - 4;
                return;
            }
        }
        goto L7;
    }
}

wc_uint32 wc_any_to_ucs(wc_wchar_t cc)
{// addr = 0x080BE029
    int f;
    wc_uint16* map;
    wc_map* map2;
    char _v12;
    signed int _v16;
    wc_uint16* _v20;
    wc_map* _v24;
    intOrPtr _v28;
    unsigned int _v32;
    unsigned int _v100;
    unsigned int _v104;
    intOrPtr _v108;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t130;
    unsigned int _t133;
    _unknown_ _t190;
    signed int _t192;
    unsigned int _t206;

    __esp = __esp - 96;
    _v20 = 0;
    _v16 = cc.ccs & 255;
    _t130 = cc.ccs & 65280;
    if(_t130 == 4096) {
L64:
        if((cc.ccs & 65535) != 4096) {
            _t133 = -1;
        } else {
            _t133 = cc.code;
        }
        goto L82;
    }
    if(_t130 > 4096) {
        if(_t130 == 33024) {
            if(cc.ccs != 33089 || ( *135119014 & 255 & 4294967295) == 0) {
                if(cc.ccs != 33103) {
                    if(cc.ccs != 33104) {
                        goto L30;
                    }
                    goto L28;
                }
                _v24 = wc_map_search(cc.code & 4294967295 &  & 32639,  &jisx02131_ucs_p2_map, 25);
                if(_v24 == 0) {
L30:
                    if(_v16 <= 63 || _v16 > 80) {
                        _t133 = 0;
                        goto L82;
                    } else {
                        _v20 =  *( &cs94w_ucs_map + (_v16 - 64) * 4);
                        cc.code = (cc.code >> 8 & 127) * (cc.code >> 8 & 127) + (cc.code & 127) - 3135;
                        goto L77;
                    }
                    goto L83;
                } else {
                    _t133 =  *(_v24 + 2) & 65535 & 4294967295 &  | 131072;
                }
                goto L82;
L28:
                _v24 = wc_map_search(cc.code & 4294967295 &  & 32639,  &jisx02132_ucs_p2_map, 277);
                if(_v24 == 0) {
                    goto L30;
                } else {
                    _t133 =  *(_v24 + 2) & 65535 & 4294967295 &  | 131072;
                }
            } else {
                cc.ccs = 34830;
                 *__esp = cc.ccs;
                _v104 = cc.code;
                _t133 = wc_any_to_ucs();
            }
            goto L82;
        }
        goto L10;
    }
    if(_t130 == 512) {
        if(_v16 <= 63 || _v16 > 102) {
            _t133 = -1;
L82:
             &_v12 =  &_v12;
            return _t133;
L83:
        } else {
            _v20 =  *( &cs96_ucs_map + (_v16 - 64) * 4);
            cc.code = cc.code & 127;
L77:
            if(_v20 != 0) {
                cc.code =  *(cc.code + cc.code + _v20) & 65535 & 4294967295 & ;
                if(cc.code == 0) {
                    _t133 = -1;
                } else {
                    _t133 = cc.code;
                }
            } else {
                _t133 = -1;
            }
            goto L82;
        }
    }
    if(_t130 > 512) {
        if(_t130 == 1024) {
            if(_v16 <= 63 || _v16 > 0) {
                _t133 = -1;
                goto L82;
            }
            _v20 = cs942_ucs_map[_v16 - 64];
            cc.code = cc.code & 127;
            goto L77;
        }
        goto L7;
    }
    if(_t130 == 256) {
        if(_v16 <= 63) {
L19:
            _t133 = -1;
            goto L82;
        }
        if(_v16 <= 84) {
            _v20 =  *( &cs94_ucs_map + (_v16 - 64) * 4);
            cc.code = cc.code & 127;
            goto L77;
        }
        goto L19;
    } else {
    }
L76:
    _t133 = -1;
    goto L82;
L7:
    if(_t130 == 2048) {
        if(_v16 <= 0 || _v16 > 40) {
            _t133 = -1;
            goto L82;
        }
        _t206 = cc.ccs;
        if(_t206 == 2079) {
            _v104 = cc.ccs;
            _v100 = cc.code;
             *__esp =  &_v32;
            wc_tcvn57123_to_tcvn5712();
            __esp = __esp - 4;
             *__esp = _v32;
            _v108 = _v28;
            _t133 = wc_any_to_ucs();
            goto L82;
        }
        if(_t206 == 2087) {
            goto L56;
        }
        if(_t206 != 2076) {
            goto L57;
        }
        _v24 = wc_map_search(cc.code & 4294967295 & ,  &cp12582_ucs_map, 120);
        if(_v24 == 0) {
            _t133 = -1;
        } else {
            _t133 =  *(_v24 + 2) & 65535 & 4294967295 & ;
        }
        goto L82;
L58:
        if(_v16 <= 0 || _v16 > 33) {
            _t133 = -1;
            goto L82;
        }
        _v20 =  *( &pcsw_ucs_map + (_v16 - 1) * 4);
        if(cc.ccs - 34817 > 32) {
            cc.code = (cc.code >> 8 & 127) * (cc.code >> 8 & 127) + (cc.code & 127) - 3135;
            goto L77;
        }
        goto __eax;
        goto L64;
L57:
        _v20 =  *( &pcs_ucs_map + (_v16 - 1) * 4);
        cc.code = cc.code & 127;
        goto L77;
L56:
        _t133 = 8364;
        goto L82;
    } else {
    }
    goto L76;
L10:
    if(_t130 > 33024) {
        if(_t130 == 33280) {
            if(_v16 <= 63 || _v16 > 0) {
                _t133 = -1;
                goto L82;
            } else {
                _v20 = cs96w_ucs_map[_v16 - 64];
                cc.code = ((cc.code >> 8 & 127) + (cc.code >> 8 & 127) + _t231 << 5) + (cc.code & 127) - 3104;
                goto L77;
            }
            goto L83;
        }
        goto L15;
    }
    if(_t130 == 8192) {
        _t192 = cc.ccs & 65535;
        if(_t192 == 8193) {
            _t133 = cc.code & 2097151;
        } else {
            if(_t192 == 8194) {
                 *__esp = cc.ccs;
                _v104 = cc.code;
                _t133 = wc_gb18030_to_ucs();
            } else {
                if(_t192 != 8192) {
                    _t133 = -1;
                } else {
                    _t133 = cc.code;
                }
            }
        }
        goto L82;
    }
    if(_t130 == 16384) {
        if(cc.ccs != 16385) {
            goto L76;
        }
        _t133 = cc.code;
        goto L82;
    } else {
    }
    goto L76;
L15:
    if(_t130 == 34816) {
        goto L58;
    } else {
    }
    goto L76;
}

wc_wchar_t wc_any_to_any(wc_wchar_t cc, wc_table* t)
{// addr = 0x080BE7F3
    wc_ccs is_wide;
    wc_uint32 ucs;
    _unknown_ _v8;
    signed int _v16;
    unsigned int _v20;
    intOrPtr _v32;
    intOrPtr _v36;
    intOrPtr _v52;
    intOrPtr _v56;
    _unknown_ _v60;
    _unknown_ __ebp;
    unsigned int _t44;
    struct  _t59;
    _unknown_ _t60;

    _push(__ebx);
    __esp = __esp - 52;
    _t59 = cc.ccs;
    _v16 = cc.code & 98304;
     *__esp = cc.code;
    _v56 = _a12;
    _v20 = wc_any_to_ucs();
    if(_v20 == 255) {
L6:
        if(_v16 == 0) {
            _t44 = 16384;
        } else {
            _t44 = 49152;
        }
        cc.code = _t44;
         *_t59 = cc.code;
         *((intOrPtr*)(_t59 + 4)) = _a12;
        return _t59;
    }
    _v52 = _a16;
    wc_ucs_to_any( &(cc.code), _v20);
    __esp = __esp - 4;
    if((cc.code & 16384) != 0) {
        _v20 = wc_ucs_to_fullwidth(_v20);
        if(_v20 == 255) {
            goto L6;
        }
        goto L4;
    }
     *_t59 = cc.code;
     *((intOrPtr*)(_t59 + 4)) = _a12;
    return _t59;
L4:
    _v56 = _a16;
    wc_ucs_to_any( &_v36, _v20);
    __esp = __esp - 4;
    cc.code = _v36;
    _a12 = _v32;
    if((cc.code & 16384) != 0) {
        goto L6;
    }
     *_t59 = cc.code;
     *((intOrPtr*)(_t59 + 4)) = _a12;
    return _t59;
}

wc_wchar_t wc_ucs_to_any_list(wc_uint32 ucs, wc_table** tlist)
{// addr = 0x080BE8DA
    wc_wchar_t cc;
    wc_table** t;
    _unknown_ _v8;
    intOrPtr* _v16;
    intOrPtr _v20;
    signed int _v24;
    intOrPtr _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    struct  _t38;
    _unknown_ _t39;

    _push(__ebx);
    __esp = __esp - 36;
    _t38 = ucs;
    if(_a12 == 0) {
        _v24 = 16384;
         *_t38 = _v24;
         *((intOrPtr*)(_t38 + 4)) = _v20;
        return _t38;
    }
    _v16 = _a12;
    while( *_v16 != 0) {
        if( *((intOrPtr*)( *_v16 + 8)) == 0) {
            goto L6;
        }
        _v36 =  *_v16;
        wc_ucs_to_any( &_v24, tlist);
        __esp = __esp - 4;
        if((_v24 & 16384) != 0) {
            goto L6;
        }
         *_t38 = _v24;
         *((intOrPtr*)(_t38 + 4)) = _v20;
        return _t38;
L6:
        _v16 = _v16 + 4;
    }
}

wc_wchar_t wc_any_to_any_ces(wc_wchar_t cc, wc_status* st)
{// addr = 0x080BE95E
    wc_uint32 ucs;
    wc_ccs is_wide;
    _unknown_ _v8;
    wc_table** _v16;
    signed int _v20;
    wc_table** _v32;
    unsigned int _v36;
    wc_table** _v52;
    wc_table** _v56;
    wc_table** _v60;
    _unknown_ _v64;
    _unknown_ __ebp;
    unsigned int _t146;
    wc_table** _t157;
    wc_table** _t173;
    wc_table** _t180;
    unsigned int _t197;
    wc_table** _t199;
    unsigned int _t212;
    unsigned int _t220;
    _unknown_ _t221;

    _push(__ebx);
    __esp = __esp - 52;
    _t220 = cc.ccs;
     *__esp = cc.code;
    _v56 = _a12;
    _v16 = wc_any_to_ucs();
    _v20 = cc.code & 98304;
    if(_v16 <= 127) {
        cc.code = 322;
        _a12 = _v16;
         *_t220 = cc.code;
         *(_t220 + 4) = _a12;
        return _t220;
    }
    if(_v16 == 255) {
L48:
        if(_v20 == 0) {
            _t146 = 16384;
        } else {
            _t146 = 49152;
        }
        cc.code = _t146;
         *_t220 = cc.code;
         *(_t220 + 4) = _a12;
        return _t220;
    } else {
        if(( *( *_a16) & 32768) != 0) {
            cc.code = wc_ucs_to_ccs(_v16);
            _a12 = _v16;
             *_t220 = cc.code;
             *(_t220 + 4) = _a12;
            return _t220;
        }
        if( *( *_a16) == 3153984) {
            _v56 = _v16;
            wc_ucs_to_johab( &(cc.code));
            __esp = __esp - 4;
            if((cc.code & 16384) != 0) {
                if(_v20 == 0) {
                    _t212 = 16384;
                } else {
                    _t212 = 49152;
                }
                cc.code = _t212;
            }
             *_t220 = cc.code;
             *(_t220 + 4) = _a12;
            return _t220;
        }
        if(_v20 == 0) {
            _t157 = _a16[8];
        } else {
            _t157 = _a16[9];
        }
        _v52 = _t157;
        wc_ucs_to_any_list( &_v36, _v16);
        __esp = __esp - 4;
        cc.code = _v36;
        _a12 = _v32;
        if((cc.code & 16384) != 0) {
            if(( *135119013 & 255 & 4294967295) != 0) {
L23:
                if( *( *_a16) != 3153979) {
                    if(_v16 != 160) {
                        if(( *( *_a16) & 4608) == 0 || _v16 <= 127 || _v16 > 159) {
                            _v16 = wc_ucs_to_fullwidth(_v16);
                            if(_v16 == 255) {
                                goto L48;
                            }
                        } else {
                            cc.code = 16385;
                            _a12 = _v16;
                             *_t220 = cc.code;
                             *(_t220 + 4) = _a12;
                            return _t220;
                        }
L37:
                        if(_v20 == 0) {
                            _t173 = _a16[8];
                        } else {
                            _t173 = _a16[9];
                        }
                        _v56 = _t173;
                        wc_ucs_to_any_list( &_v36, _v16);
                        __esp = __esp - 4;
                        cc.code = _v36;
                        _a12 = _v32;
                        if((cc.code & 16384) != 0) {
                            if(( *135119013 & 255 & 4294967295) != 0) {
                                goto L48;
                            }
                        } else {
                             *_t220 = cc.code;
                             *(_t220 + 4) = _a12;
                            return _t220;
                        }
L43:
                        if(_v20 == 0) {
                            _t180 = _a16[9];
                        } else {
                            _t180 = _a16[8];
                        }
                        _v60 = _t180;
                        wc_ucs_to_any_list( &_v36, _v16);
                        __esp = __esp - 4;
                        cc.code = _v36;
                        _a12 = _v32;
                        if((cc.code & 16384) != 0) {
                            goto L48;
                        }
                         *_t220 = cc.code;
                         *(_t220 + 4) = _a12;
                        return _t220;
                    }
                    goto L31;
                }
                goto L24;
L31:
                cc.code = 322;
                _a12 = 32;
                 *_t220 = cc.code;
                 *(_t220 + 4) = _a12;
                return _t220;
            }
            goto L18;
L24:
            _v60 = _v16;
            wc_ucs_to_gb18030( &_v36);
            __esp = __esp - 4;
            cc.code = _v36;
            _a12 = _v32;
            if((cc.code & 16384) != 0) {
                if(_v20 == 0) {
                    _t197 = 16384;
                } else {
                    _t197 = 49152;
                }
                cc.code = _t197;
            }
             *_t220 = cc.code;
             *(_t220 + 4) = _a12;
            return _t220;
        } else {
             *_t220 = cc.code;
             *(_t220 + 4) = _a12;
            return _t220;
        }
L18:
        if(_v20 == 0) {
            _t199 = _a16[9];
        } else {
            _t199 = _a16[8];
        }
        _v56 = _t199;
        wc_ucs_to_any_list( &_v36, _v16);
        __esp = __esp - 4;
        cc.code = _v36;
        _a12 = _v32;
        if((cc.code & 16384) != 0) {
            goto L23;
        } else {
             *_t220 = cc.code;
             *(_t220 + 4) = _a12;
            return _t220;
        }
        goto L24;
    }
}

wc_wchar_t wc_any_to_iso2022(wc_wchar_t cc, wc_status* st)
{// addr = 0x080BECA5
    wc_uint32 ucs;
    wc_ccs is_wide;
    _unknown_ _v8;
    wc_table** _v16;
    signed int _v20;
    wc_table** _v32;
    unsigned int _v36;
    wc_table** _v52;
    wc_table** _v56;
    wc_table** _v60;
    wc_table** _v64;
    wc_table** _v68;
    _unknown_ __ebp;
    unsigned int _t187;
    wc_table** _t191;
    wc_table** _t201;
    wc_table** _t209;
    wc_table** _t235;
    unsigned int _t262;
    _unknown_ _t263;

    _push(__ebx);
    __esp = __esp - 52;
    _t262 = cc.ccs;
     *__esp = cc.code;
    _v56 = _a12;
    _v16 = wc_any_to_ucs();
    _v20 = cc.code & 98304;
    if(_v16 <= 127) {
        cc.code = 322;
        _a12 = _v16;
         *_t262 = cc.code;
         *(_t262 + 4) = _a12;
        return _t262;
    }
    if(_v16 == 255) {
L54:
        if(_v20 == 0) {
            _t187 = 16384;
        } else {
            _t187 = 49152;
        }
        cc.code = _t187;
         *_t262 = cc.code;
         *(_t262 + 4) = _a12;
        return _t262;
    } else {
        if(_v20 == 0) {
            _t191 =  *(_a16 + 32);
        } else {
            _t191 =  *(_a16 + 36);
        }
        _v52 = _t191;
        wc_ucs_to_any_list( &(cc.code), _v16);
        __esp = __esp - 4;
        if((cc.code & 16384) == 0) {
             *_t262 = cc.code;
             *(_t262 + 4) = _a12;
            return _t262;
        }
        if(( *135119020 & 255 & 4294967295) == 0) {
            if((cc.code & 16384) != 0) {
                goto L14;
            } else {
                 *_t262 = cc.code;
                 *(_t262 + 4) = _a12;
                return _t262;
            }
        }
L14:
        if(( *135119013 & 255 & 4294967295) != 0) {
L26:
            if(_v16 != 160) {
                _v16 = wc_ucs_to_fullwidth(_v16);
                if(_v16 == 255) {
L52:
                    if(_v16 != 160) {
                        goto L54;
                    }
                    goto L53;
                }
                goto L29;
L53:
                cc.code = 322;
                _a12 = 32;
                 *_t262 = cc.code;
                 *(_t262 + 4) = _a12;
                return _t262;
            }
            goto L27;
L29:
            if(_v20 == 0) {
                _t201 =  *(_a16 + 32);
            } else {
                _t201 =  *(_a16 + 36);
            }
            _v56 = _t201;
            wc_ucs_to_any_list( &_v36, _v16);
            __esp = __esp - 4;
            cc.code = _v36;
            _a12 = _v32;
            if((cc.code & 16384) != 0) {
                if(( *135119020 & 255 & 4294967295) != 0) {
L40:
                    if(( *135119013 & 255 & 4294967295) != 0) {
                        goto L52;
                    }
                    goto L41;
                }
                goto L35;
L41:
                if(_v20 == 0) {
                    _t209 =  *(_a16 + 36);
                } else {
                    _t209 =  *(_a16 + 32);
                }
                _v60 = _t209;
                wc_ucs_to_any_list( &_v36, _v16);
                __esp = __esp - 4;
                cc.code = _v36;
                _a12 = _v32;
                if((cc.code & 16384) != 0) {
                    if(( *135119020 & 255 & 4294967295) != 0) {
                        goto L52;
                    }
                } else {
                     *_t262 = cc.code;
                     *(_t262 + 4) = _a12;
                    return _t262;
                }
L47:
                if(_v20 == 0) {
                    _v68 = _v16;
                    wc_ucs_to_iso2022w( &_v36);
                    __esp = __esp - 4;
                    cc.code = _v36;
                    _a12 = _v32;
                } else {
                    _v68 = _v16;
                    wc_ucs_to_iso2022( &_v36);
                    __esp = __esp - 4;
                    cc.code = _v36;
                    _a12 = _v32;
                }
                if((cc.code & 16384) != 0) {
                    goto L52;
                } else {
                     *_t262 = cc.code;
                     *(_t262 + 4) = _a12;
                    return _t262;
                }
                goto L53;
            } else {
                 *_t262 = cc.code;
                 *(_t262 + 4) = _a12;
                return _t262;
            }
L35:
            if(_v20 == 0) {
                _v64 = _v16;
                wc_ucs_to_iso2022( &_v36);
                __esp = __esp - 4;
                cc.code = _v36;
                _a12 = _v32;
            } else {
                _v64 = _v16;
                wc_ucs_to_iso2022w( &_v36);
                __esp = __esp - 4;
                cc.code = _v36;
                _a12 = _v32;
            }
            if((cc.code & 16384) != 0) {
                goto L40;
            } else {
                 *_t262 = cc.code;
                 *(_t262 + 4) = _a12;
                return _t262;
            }
            goto L41;
        } else {
            if(_v20 == 0) {
                _t235 =  *(_a16 + 36);
            } else {
                _t235 =  *(_a16 + 32);
            }
            _v56 = _t235;
            wc_ucs_to_any_list( &_v36, _v16);
            __esp = __esp - 4;
            cc.code = _v36;
            _a12 = _v32;
            if((cc.code & 16384) != 0) {
                if(( *135119020 & 255 & 4294967295) != 0) {
                    goto L26;
                }
            } else {
                 *_t262 = cc.code;
                 *(_t262 + 4) = _a12;
                return _t262;
            }
L21:
            if(_v20 == 0) {
                _v64 = _v16;
                wc_ucs_to_iso2022w( &_v36);
                __esp = __esp - 4;
                cc.code = _v36;
                _a12 = _v32;
            } else {
                _v64 = _v16;
                wc_ucs_to_iso2022( &_v36);
                __esp = __esp - 4;
                cc.code = _v36;
                _a12 = _v32;
            }
            if((cc.code & 16384) != 0) {
                goto L26;
            } else {
                 *_t262 = cc.code;
                 *(_t262 + 4) = _a12;
                return _t262;
            }
        }
L27:
        cc.code = 322;
        _a12 = 32;
         *_t262 = cc.code;
         *(_t262 + 4) = _a12;
        return _t262;
    }
}

wc_wchar_t wc_ucs_to_iso2022(wc_uint32 ucs)
{// addr = 0x080BF0AF
    wc_table* t;
    wc_wchar_t cc;
    int f;
    _unknown_ _v8;
    intOrPtr _v16;
    signed int _v20;
    intOrPtr _v24;
    signed int _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    intOrPtr _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    struct  _t104;
    _unknown_ _t105;

    _push(__ebx);
    __esp = __esp - 52;
    _t104 = ucs;
    if(_a8 > 65535) {
        _v28 = 16384;
         *_t104 = _v28;
         *((intOrPtr*)(_t104 + 4)) = _v24;
        return _t104;
    } else {
        _v20 = 0;
        while(_v20 <= 38) {
            _v16 =  &ucs_cs96_table + (_v20 << 4);
            if( *((intOrPtr*)(_v16 + 8)) == 0) {
                goto L6;
            }
            _v52 = _v16;
            wc_ucs_to_any( &_v28, _a8 & 4294967295 & );
            __esp = __esp - 4;
            if((_v28 & 16384) != 0) {
                goto L6;
            }
             *_t104 = _v28;
             *((intOrPtr*)(_t104 + 4)) = _v24;
            return _t104;
L6:
            _v20 = _v20 + 1;
        }
    }
}

wc_wchar_t wc_ucs_to_iso2022w(wc_uint32 ucs)
{// addr = 0x080BF22D
    wc_table* t;
    wc_wchar_t cc;
    int f;
    _unknown_ _v8;
    intOrPtr _v16;
    signed int _v20;
    intOrPtr _v24;
    signed int _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    intOrPtr _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    struct  _t71;
    _unknown_ _t72;

    _push(__ebx);
    __esp = __esp - 52;
    _t71 = ucs;
    if(_a8 > 65535) {
        _v28 = 49152;
         *_t71 = _v28;
         *((intOrPtr*)(_t71 + 4)) = _v24;
        return _t71;
    }
    _v20 = 0;
    while(_v20 <= 16) {
        _v16 =  &ucs_cs94w_table + (_v20 << 4);
        if( *((intOrPtr*)(_v16 + 8)) == 0) {
            goto L6;
        }
        _v52 = _v16;
        wc_ucs_to_any( &_v28, _a8 & 4294967295 & );
        __esp = __esp - 4;
        if((_v28 & 16384) != 0) {
            goto L6;
        }
         *_t71 = _v28;
         *((intOrPtr*)(_t71 + 4)) = _v24;
        return _t71;
L6:
        _v20 = _v20 + 1;
    }
}

wc_ccs wc_ucs_to_ccs(wc_uint32 ucs)
{// addr = 0x080BF338
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int _t10;
    signed int _t13;
    _unknown_ _t15;
    signed int _t16;
    signed int _t17;

    if(ucs > 127) {
        if(ucs <= 159) {
            return 16385;
        }
    }
    if(ucs > 65535) {
        _t16 = 8192;
    } else {
        _t16 = 4096;
    }
    if((wc_is_ucs_wide(ucs) & 4294967295) == 0) {
        _t10 = 0;
    } else {
        _t10 = 65536;
    }
    _t17 = _t16 | _t10;
    if((wc_is_ucs_combining(ucs) & 4294967295) == 0) {
        _t13 = 0;
        return _t13 | _t17;
    }
    _t13 = 131072;
    return _t13 | _t17;
}

wc_bool wc_is_ucs_wide(wc_uint32 ucs)
{// addr = 0x080BF3AA
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t12;
    _unknown_ _t14;

    if(ucs <= 65535) {
        return wc_map_range_search(ucs & 4294967295 & ,  &ucs_wide_map, 11);
    }
    if(ucs == 131072) {
        return 1;
    }
    if(ucs != 196608) {
        return 0;
    }
    return 1;
}

wc_bool wc_is_ucs_combining(wc_uint32 ucs)
{// addr = 0x080BF408
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t8;
    _unknown_ _t12;

    if(( *135119009 & 255 & 4294967295) == 0) {
        return 0;
    }
    if(ucs > 65535) {
        return 0;
    }
    if(wc_map_range_search(ucs & 4294967295 & ,  &ucs_combining_map, 99) == 0) {
        return 0;
    }
    return 1;
}

wc_bool wc_is_ucs_hangul(wc_uint32 ucs)
{// addr = 0x080BF452
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t6;
    _unknown_ _t10;

    if(ucs > 65535) {
        return 0;
    }
    if(wc_map_range_search(ucs & 4294967295 & ,  &ucs_hangul_map, 6) == 0) {
        return 0;
    }
    return 1;
}

wc_uint32 wc_ucs_precompose(wc_uint32 ucs1, wc_uint32 ucs2)
{// addr = 0x080BF491
    wc_map3* map;
    wc_map3* _v16;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t17;

    if(( *135119009 & 255 & 4294967295) == 0) {
        return -1;
    }
    if(ucs1 > 65535) {
        return -1;
    }
    if(ucs2 > 65535) {
        return -1;
    }
    _v16 = wc_map3_search(ucs1 & 4294967295 & , ucs2 & 4294967295 & ,  &ucs_precompose_map, 988);
    if(_v16 == 0) {
        return -1;
    }
    return  *(_v16 + 4) & 65535 & 4294967295 & ;
}

wc_uint32 wc_ucs_to_fullwidth(wc_uint32 ucs)
{// addr = 0x080BF4F8
    wc_map* map;
    wc_map* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t11;

    if(ucs > 65535) {
        return -1;
    }
    _v16 = wc_map_search(ucs & 4294967295 & ,  &ucs_fullwidth_map, 14);
    if(_v16 == 0) {
        return -1;
    }
    return  *(_v16 + 2) & 65535 & 4294967295 & ;
}

int wc_ucs_put_tag(char* p)
{// addr = 0x080BF541
    int i;
    signed int _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t17;
    _unknown_ _t31;

    if(p == 0) {
        return 0;
    }
    if(( *p & 255 & 4294967295) == 0) {
        return 0;
    }
    _v16 = 1;
    while(_v16 <= n_tag_map) {
        if(strcasecmp(p,  *( &tag_map + _v16 * 4)) == 0) {
            return _v16;
        }
        _v16 = _v16 + 1;
    }
}

char* wc_ucs_get_tag(int ntag)
{// addr = 0x080BF5CD
    _unknown_ __ebp;
    _unknown_ _t6;

    if(ntag == 0) {
        return 0;
    }
    if(ntag <= n_tag_map) {
        return  *((intOrPtr*)( &tag_map + ntag * 4));
    }
    return 0;
}

wtf_push_ucs(Str os, wc_uint32 ucs, wc_status* st)
{// addr = 0x080BF5F3
    wc_ccs ccs;
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t113;
    int _t142;
    intOrPtr _t168;

    if(ucs <= 917503 || ucs > 917631) {
        if( *(st + 44) != 0) {
            st->ntag = wc_ucs_put_tag( *( *(st + 44)));
             *(st + 44) = 0;
        }
        if(ucs > 127) {
            _v16 = wc_ucs_to_ccs(ucs);
            if(st->ntag != 0 && ucs <= 1114111) {
                _v16 = _v16 | 8193;
                ucs = ucs | st->ntag << 24;
            }
            wtf_push(os, _v16, ucs);
            return;
        }
        if(st->ntag == 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t113 = os->length;
             *(os->ptr + _t113) = ucs & 4294967295;
            os->length = _t113 + 1;
             *(os->ptr + os->length) = 0;
            return;
        }
        wtf_push(os, 8193, st->ntag << 24 | ucs);
        return;
    } else {
        if(( *135119010 & 255 & 4294967295) == 0) {
            return ;
        }
        if(ucs == 917505) {
             *(st + 44) = Strnew_size(4);
            return;
        }
        if(ucs != 917631) {
            if( *(st + 44) == 0) {
                return ;
            }
            if(ucs <= 917535) {
                return ;
            }
            if( *((intOrPtr*)( *(st + 44) + 4)) + 1 >=  *((intOrPtr*)( *(st + 44) + 8))) {
                Strgrow( *(st + 44));
            }
            _t142 =  *(st + 44);
            _t168 =  *((intOrPtr*)(_t142 + 4));
            ( *( *(st + 44)))[_t168] = ucs & 127 & 4294967295;
             *((intOrPtr*)(_t142 + 4)) = _t168 + 1;
            ( *( *(st + 44)))[ *((intOrPtr*)( *(st + 44) + 4))] = 0;
            return;
        }
         *(st + 44) = 0;
        st->ntag = 0;
        return;
    }
}

wc_wchar_t wc_uhc_to_cs128w(wc_wchar_t cc)
{// addr = 0x080BF800
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t26;
    _unknown_ _t45;

    __ecx = cc.ccs;
    _t45 = (_a12 >> 8 & 255) * (_a12 >> 8 & 255) + (_a12 & 255);
    if((_a12 & 255) <= 96) {
        _t26 = 65;
    } else {
        if((_a12 & 255) > 128) {
            _t26 = 77;
        } else {
            _t26 = 71;
        }
    }
    _a12 = _t45 - _t26 - 22962;
    if(_a12 > 16383) {
        cc.code = 34846;
        _a12 = _a12 - 16384;
    } else {
        cc.code = 34845;
    }
    _a12 = (_a12 >> 7 << 8) + (_a12 & 127);
     *__ecx = cc.code;
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_uhc(wc_wchar_t cc)
{// addr = 0x080BF8AF
    signed int _v20;
    _unknown_ __ebx;
    _unknown_ __edi;
    struct  __esi;
    _unknown_ __ebp;
    _unknown_ _t47;
    _unknown_ _t55;
    _unknown_ _t60;
    _unknown_ _t66;
    _unknown_ _t79;
    _unknown_ _t82;
    _unknown_ _t84;
    _unknown_ _t86;
    _unknown_ _t91;
    signed int _t96;

    __esi = cc.ccs;
    _a12 = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
    if(cc.code == 34846) {
        _a12 = _a12 + 16384;
    }
    cc.code = 34844;
    _v20 = _a12;
    _t96 = (_v20 * -1206451487 >> 32 >> 7) + 129 << 8;
    _t79 = _a12 - _a12 * -1206451487 * (_t73 * -1206451487 >> 32 >> 7);
    if(_a12 - (_a12 * -1206451487 >> 32 >> 7) * (_a12 * -1206451487 >> 32 >> 7) <= 25) {
        _t60 = 65;
    } else {
        if(_a12 - (_a12 * -1206451487 >> 32 >> 7) * (_a12 * -1206451487 >> 32 >> 7) > 51) {
            _t60 = 77;
        } else {
            _t60 = 71;
        }
    }
    _a12 = _t96 + _t79 + _t60;
     *__esi = cc.code;
     *(__esi + 4) = _a12;
    return __esi;
}

wc_uint32 wc_uhc_to_N(wc_uint32 c)
{// addr = 0x080BF9A2
    _unknown_ __ebp;
    _unknown_ _t27;
    _unknown_ _t43;
    _unknown_ _t54;
    _unknown_ _t67;
    _unknown_ _t71;
    _unknown_ _t74;

    if(c > 41376) {
        if(c > 41632) {
            if(c <= 41703) {
                return c - 35838;
            }
            _t67 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
            if((c & 255) <= 96) {
                _t27 = 65;
                return _t67 - _t27 - (c >> 8) * (c >> 8) - 7826;
            } else {
                if((c & 255) > 128) {
                    _t27 = 77;
                    return _t67 - _t27 - (c >> 8) * (c >> 8) - 7826;
                }
                _t27 = 71;
                return _t67 - _t27 - (c >> 8) * (c >> 8) - 7826;
            }
        }
        goto L9;
    }
    _t74 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) <= 96) {
        _t54 = 65;
        return _t74 - _t54 - 22962;
    }
    if((c & 255) > 128) {
        _t54 = 77;
        return _t74 - _t54 - 22962;
    }
    _t54 = 71;
    return _t74 - _t54 - 22962;
L9:
    _t71 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) <= 96) {
        _t43 = 65;
        return _t71 - _t43 - 23056;
    }
    if((c & 255) > 128) {
        _t43 = 77;
        return _t71 - _t43 - 23056;
    }
    _t43 = 71;
    return _t71 - _t43 - 23056;
}

Str wc_conv_from_uhc(Str is, wc_ces ces)
{// addr = 0x080BFAE3
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    int state;
    wc_uint32 uhc;
    struct _Str* _v16;
    unsigned char* _v20;
    unsigned char* _v24;
    unsigned char* _v28;
    unsigned int _v32;
    unsigned int _v36;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    unsigned int _t109;
    signed int _t114;
    int _t123;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 = 0;
    _v28 = _v20;
L2:
    while(_v28 < _v24) {
        if(( *_v28 & 255 & 4294967295) >= 0) {
            _v28 =  &(_v28[1]);
            goto L2;
        }
        if(_v28 == _v24) {
            return is;
        }
        _v16 = Strnew_size(is->length);
        if(_v28 > _v20) {
            Strcat_charp_n(_v16, is->ptr, _v28 - _v20);
        }
        while(_v28 < _v24) {
            _t109 = _v32;
            if(_t109 == 0) {
                _t114 =  *( &WC_UHC_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                if(_t114 == 2) {
                    wtf_push_unknown(_v16, _v28, 1);
L18:
                    goto L28;
                }
                goto L12;
L15:
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t123 = _v16->length;
                 *( *_v16 + _t123) =  *_v28 & 255 & 4294967295;
                _v16->length = _t123 + 1;
                 *( *_v16 + _v16->length) = 0;
                goto L28;
            } else {
                if(_t109 == 1) {
                    if(( *( &WC_UHC_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                        wtf_push_unknown(_v16, _v28 - 1, 2);
                    } else {
                        _v36 =  *_v28 & 255 & 4294967295 &  | ( *(_v28 - 1) & 255 & 4294967295 & ) << 8;
                        if(( *(_v28 - 1) & 255 & 4294967295) <= 160 || ( *_v28 & 255 & 4294967295) <= 160 || _v36 == 41702 || _v36 == 41703) {
                            wtf_push(_v16, 34844, _v36);
                        } else {
                            wtf_push(_v16, 33091, _v36);
                        }
                    }
                    _v32 = 0;
                }
L28:
                _v28 =  &(_v28[1]);
                continue;
            }
L12:
            if(_t114 != 12) {
                goto L15;
            } else {
                _v32 = 1;
                goto L18;
            }
        }
    }
}

wc_push_to_uhc(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080BFD21
    unsigned int _v16;
    unsigned int _v20;
    intOrPtr _v32;
    unsigned int _v36;
    unsigned int _v40;
    _unknown_ __ebp;
    unsigned int _t117;
    int _t124;
    int _t136;
    unsigned int _t151;
    int _t164;
    int _t176;
    int _t190;

    while(1) {
        _t117 = cc.ccs;
        if(_t117 == 34844) {
            break;
        }
        if(_t117 > 34844) {
            if(_t117 <= 34846) {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &(cc.ccs);
                wc_cs128w_to_uhc();
                __esp = __esp - 4;
                break;
            }
            goto L8;
        }
        if(_t117 == 16384) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplace);
            return;
        }
        if(_t117 == 33091) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t164 = os->length;
             *(os->ptr + _t164) = (cc.code >> 8 | 128) & 4294967295;
            os->length = _t164 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t176 = os->length;
             *(os->ptr + _t176) = (cc.code | 128) & 4294967295;
            os->length = _t176 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t117 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t190 = os->length;
             *(os->ptr + _t190) = cc.code & 4294967295;
            os->length = _t190 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        } else {
        }
L28:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t151 = 16384;
            } else {
                _t151 = 49152;
            }
            cc.ccs = _t151;
        } else {
            _v32 = _a16;
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &_v20;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v20;
            cc.code = _v16;
        }
        continue;
L8:
        if(_t117 == 49152) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplaceW);
            return;
        }
        goto L28;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t124 = os->length;
     *(os->ptr + _t124) = cc.code >> 8 & 4294967295;
    os->length = _t124 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t136 = os->length;
     *(os->ptr + _t136) = cc.code & 4294967295;
    os->length = _t136 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_uhc(wc_uchar c, wc_status* st)
{// addr = 0x080BFFD6
    wc_uint32 uhc;
    unsigned int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t48;
    signed int _t51;
    struct _Str* _t59;
    _unknown_ _t67;
    int _t86;

    _v32 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135791648 = Strnew_size(8);
    }
    _t48 = st->state;
    if(_t48 == 0) {
        _t51 =  *( &WC_UHC_MAP + (_v32 & 255)) & 255 & 4294967295 & ;
        if(_t51 != 2) {
            if(_t51 == 12) {
                uhcu = _v32 & 255 & 4294967295;
                st->state = 1;
                return 0;
            }
            if( *135791648->length + 1 >=  *135791648->area_size) {
                Strgrow( *135791648);
            }
            _t59 =  *135791648;
            _t86 = _t59->length;
             *( *( *135791648) + _t86) = _v32 & 255 & 4294967295;
            _t59->length = _t86 + 1;
             *( *( *135791648) +  *135791648->length) = 0;
        }
    } else {
        if(_t48 == 1) {
            if(( *( &WC_UHC_MAP + (_v32 & 255)) & 255 & 4294967295 &  & 4) != 0) {
                _v16 = _v32 & 255 | (uhcu & 255 & 4294967295 & ) << 8;
                if((uhcu & 255 & 4294967295) <= 160 || _v32 <= 160 || _v16 == 41702 || _v16 == 41703) {
                    wtf_push( *135791648, 34844, _v16);
                } else {
                    wtf_push( *135791648, 33091, _v16);
                }
            }
        }
    }
    st->state = -1;
    return  *135791648;
}

Str wc_conv_from_utf7(Str is, wc_ces ces)
{// addr = 0x080C0158
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    int state;
    wc_uint32 b;
    wc_uint32 high;
    wc_status st;
    struct _Str* _v16;
    wc_uchar* _v20;
    intOrPtr _v24;
    wc_uchar* _v28;
    unsigned int _v32;
    unsigned int _v36;
    signed int _v40;
    struct  _v100;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t152;
    unsigned int _t159;
    signed int _t166;
    signed int _t203;
    int _t210;
    _unknown_ _t246;

    _v20 = is->ptr;
    _v24 = _v20 + is->length;
    _v32 = 0;
    _v40 = 0;
    _v28 = _v20;
    while(_v28 < _v24 && ( *_v28 & 255 & 4294967295) < 0) {
        if(( *_v28 & 255 & 4294967295) != 43) {
            _v28 =  &(_v28[1]);
            continue;
        }
        if(_v28 == _v24) {
            return is;
        }
        _v16 = Strnew_size(((0 + is->length * 4) * 1431655766 >> 32) - (0 + is->length * 4 >> 31));
        if(_v28 > _v20) {
            Strcat_charp_n(_v16, is->ptr, _v28 - _v20);
        }
        _v100.tag = 0;
        _v100.ntag = 0;
        while(_v28 < _v24) {
            _t159 = _v32;
            if(_t159 == 1) {
                if(( *_v28 & 255 & 4294967295) == 45) {
                    wtf_push_ucs(_v16, 43,  &_v100);
                }
L17:
                _t166 =  *( &WC_UTF7_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                if(_t166 == 32) {
L20:
                    _v36 =  *(( *_v28 & 255 & 4294967295 & ) - 32 +  &c_base64_map) & 255 & 4294967295;
                    _v100.shift = _v100.shift - 6;
                    if(_v44 <= 0) {
                        _v100.base = _v100.base | _v36 >> ( ~(_v100.shift) & 4294967295);
                        if(_v48 <= 55295 || _v48 > 56319) {
                            if(_v48 <= 56319 || _v48 > 57343) {
                                if(_v48 != 65279) {
                                    wtf_push_ucs(_v16, _v100.base,  &_v100);
                                }
                            } else {
                                if(_v40 != 0) {
                                    wtf_push_ucs(_v16, (_v100.base & 1023 | (_v40 & 1023) << 10) + 65536,  &_v100);
                                }
                                _v40 = 0;
                            }
                        } else {
                            if(_v40 != 0) {
                                _v40 = 0;
                            } else {
                                _v40 = _v100.base;
                            }
                        }
                        _v100.shift = _v100.shift + 16;
                        _v100.base = 0;
                    }
                    _v100.base = _v36 << (_v100.shift & 4294967295) & 65535 | _v100.base;
                    _v32 = 2;
                    goto L45;
                }
                goto L18;
            }
            if(_t159 == 2) {
                goto L17;
            }
            if(_t159 != 0) {
L37:
                _t203 =  *( &WC_UTF7_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                if(_t203 == 6) {
L40:
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t210 = _v16->length;
                     *( *_v16 + _t210) =  *_v28 & 255 & 4294967295;
                    _v16->length = _t210 + 1;
                     *( *_v16 + _v16->length) = 0;
                    goto L45;
                }
                goto L38;
            }
            if(( *_v28 & 255 & 4294967295) == 43) {
                _v32 = 1;
                _v100.shift = 16;
                _v100.base = 0;
                _v40 = 0;
L45:
                _v28 =  &(_v28[1]);
                continue;
            }
            goto L37;
L38:
            if(_t203 == 8) {
                wtf_push_unknown(_v16, _v28, 1);
                goto L45;
            }
            if(_t203 != 4) {
                wtf_push_ucs(_v16,  *_v28 & 255 & 4294967295 & ,  &_v100);
                goto L45;
            }
            goto L40;
L18:
            if(_t166 == 64) {
                _v32 = 0;
                goto L45;
            }
            if(_t166 != 16) {
                goto L37;
            }
            goto L20;
        }
    }
}

wc_push_ucs_to_utf7(Str os, wc_uint32 ucs, wc_status* st)
{// addr = 0x080C04AB
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t290;
    int _t306;
    int _t321;
    int _t345;
    int _t369;
    signed int _t378;
    int _t387;
    int _t400;
    int _t412;
    int _t429;
    int _t441;
    int _t455;
    int _t467;

    if(ucs > 1114111) {
        return ;
    }
    if(ucs > 65535) {
        ucs = ucs - 65536 & 1023 | ucs - 65536 >> 10 << 16;
        wc_push_ucs_to_utf7(os, ucs >> 16, st);
        wc_push_ucs_to_utf7(os, ucs & 4294967295 & , st);
        return;
    }
    if(ucs > 127) {
L31:
        if(st->state != 2 || st->shift == 0) {
            if(st->state != 2) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t345 = os->length;
                 *((char*)(os->ptr + _t345)) = 43;
                os->length = _t345 + 1;
                 *(os->ptr + os->length) = 0;
                st->state = 2;
            }
            st->shift = 16;
             *(st + 52) = 0;
        } else {
            st->shift = st->shift + 16;
             *(st + 52) =  *(st + 52) | ucs >> (st->shift & 4294967295);
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t369 = os->length;
             *(os->ptr + _t369) =  *( *(st + 52) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255 & 4294967295;
            os->length = _t369 + 1;
             *(os->ptr + os->length) = 0;
        }
        st->shift = st->shift - 6;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t306 = os->length;
         *(os->ptr + _t306) =  *((ucs >> (st->shift & 4294967295) & 63) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255 & 4294967295;
        os->length = _t306 + 1;
         *(os->ptr + os->length) = 0;
        st->shift = st->shift - 6;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t321 = os->length;
         *(os->ptr + _t321) =  *((ucs >> (st->shift & 4294967295) & 63) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255 & 4294967295;
        os->length = _t321 + 1;
         *(os->ptr + os->length) = 0;
        if(st->shift == 0) {
            return ;
        }
        st->shift = st->shift - 6;
         *(st + 52) = ucs << ( ~(st->shift) & 4294967295) & 63;
        return;
    }
    _t378 =  *( &WC_UTF7_MAP + ucs) & 255 & 4294967295 & ;
    if(_t378 == 16) {
L11:
        if(st->state == 2) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t400 = os->length;
             *(os->ptr + _t400) =  *( *(st + 52) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255 & 4294967295;
            os->length = _t400 + 1;
             *(os->ptr + os->length) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t412 = os->length;
             *((char*)(os->ptr + _t412)) = 45;
            os->length = _t412 + 1;
             *(os->ptr + os->length) = 0;
            st->state = 0;
        }
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t387 = os->length;
         *(os->ptr + _t387) = ucs & 4294967295;
        os->length = _t387 + 1;
         *(os->ptr + os->length) = 0;
        return;
    }
    if(_t378 > 16) {
        if(_t378 == 32) {
            if(st->state == 2) {
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t455 = os->length;
                 *(os->ptr + _t455) =  *( *(st + 52) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255 & 4294967295;
                os->length = _t455 + 1;
                 *(os->ptr + os->length) = 0;
                if(os->length + 1 >= os->area_size) {
                    Strgrow(os);
                }
                _t467 = os->length;
                 *((char*)(os->ptr + _t467)) = 45;
                os->length = _t467 + 1;
                 *(os->ptr + os->length) = 0;
                st->state = 0;
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t429 = os->length;
             *((char*)(os->ptr + _t429)) = 43;
            os->length = _t429 + 1;
             *(os->ptr + os->length) = 0;
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t441 = os->length;
             *((char*)(os->ptr + _t441)) = 45;
            os->length = _t441 + 1;
             *(os->ptr + os->length) = 0;
            return;
        }
        goto L10;
    }
    if(_t378 == 0 || _t378 == 4) {
        goto L11;
    }
    goto L31;
L10:
    if(_t378 != 64) {
        goto L31;
    }
    goto L11;
}

int wc_push_tag_to_utf7(Str os, int ntag, wc_status* st)
{// addr = 0x080C0A16
    char* p;
    char* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    if(ntag != 0) {
        _v16 = wc_ucs_get_tag(ntag);
        if(_v16 == 0) {
            ntag = 0;
        }
    }
    if(ntag == 0) {
        wc_push_ucs_to_utf7(os, 917631, st);
        return ntag;
    } else {
        wc_push_ucs_to_utf7(os, 917505, st);
        while(( *_v16 & 255 & 4294967295) != 0) {
            wc_push_ucs_to_utf7(os,  *_v16 & 255 & 4294967295 | 917504, st);
            _v16 =  &(_v16[1]);
        }
    }
}

wc_push_to_utf7(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C0AB2
    char* p;
    char* _v16;
    _unknown_ _v36;
    unsigned int _v40;
    _unknown_ __ebp;
    signed int _t99;
    unsigned int _t110;
    unsigned int _t151;

    while(1) {
L1:
        _t99 = cc.ccs & 65535;
        if(_t99 == 8192) {
            break;
        }
        if(_t99 > 8192) {
            if(_t99 == 16384) {
                if(( *135119022 & 255 & 4294967295) != 0) {
                    return ;
                }
                if(_a16->ntag != 0) {
                    _a16->ntag = wc_push_tag_to_utf7(os, 0, _a16);
                }
                _v16 = WcReplace;
                while(( *_v16 & 255 & 4294967295) != 0) {
                    wc_push_ucs_to_utf7(os,  *_v16 & 255 & 4294967295, _a16);
                    _v16 =  &(_v16[1]);
                }
            }
            goto L8;
        }
        if(_t99 == 577) {
            if(_a16->ntag != 0) {
                _a16->ntag = wc_push_tag_to_utf7(os, 0, _a16);
            }
            wc_push_ucs_to_utf7(os, cc.code, _a16);
            return;
        }
        if(_t99 == 4096 || _t99 == 322) {
L16:
            if(_a16->ntag != 0) {
L17:
                _a16->ntag = wc_push_tag_to_utf7(os, 0, _a16);
            }
            wc_push_ucs_to_utf7(os, cc.code, _a16);
            return;
        } else {
L40:
            if(( *135119011 & 255 & 4294967295) == 0) {
L43:
                if((cc.ccs & 98304) == 0) {
                    _t151 = 16384;
                } else {
                    _t151 = 49152;
                }
                cc.ccs = _t151;
                continue;
            }
             *__esp = cc.ccs;
            _v40 = cc.code;
            cc.code = wc_any_to_ucs();
            if(cc.code == 255) {
                goto L43;
            }
            cc.ccs = 4096;
            continue;
        }
L8:
        if(_t99 == 49152) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            if(_a16->ntag != 0) {
                _a16->ntag = wc_push_tag_to_utf7(os, 0, _a16);
            }
            _v16 = WcReplaceW;
            while(( *_v16 & 255 & 4294967295) != 0) {
                wc_push_ucs_to_utf7(os,  *_v16 & 255 & 4294967295, _a16);
                _v16 =  &(_v16[1]);
            }
        }
        if(_t99 == 8193) {
            if(( *135119010 & 255 & 4294967295) != 0 && cc.code >> 24 != _a16->ntag) {
                _a16->ntag = wc_push_tag_to_utf7(os, cc.code >> 24, _a16);
            }
            wc_push_ucs_to_utf7(os, cc.code & 2097151, _a16);
            return;
        } else {
        }
        goto L40;
    }
    if(cc.code <= 1114111) {
        goto L16;
    }
    if((cc.ccs & 98304) == 0) {
        _t110 = 16384;
    } else {
        _t110 = 49152;
    }
    cc.ccs = _t110;
    goto L1;
}

wc_push_to_utf7_end(Str os, wc_status* st)
{// addr = 0x080C0D72
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    int _t62;
    int _t75;

    if(st->ntag != 0) {
        st->ntag = wc_push_tag_to_utf7(os, 0, st);
    }
    if(st->state != 2) {
        return ;
    }
    if(st->shift != 0) {
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t75 = os->length;
         *(os->ptr + _t75) =  *( *((intOrPtr*)(st + 52)) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") & 255 & 4294967295;
        os->length = _t75 + 1;
         *(os->ptr + os->length) = 0;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t62 = os->length;
     *((char*)(os->ptr + _t62)) = 45;
    os->length = _t62 + 1;
     *(os->ptr + os->length) = 0;
    return;
}

Str wc_char_conv_from_utf7(wc_uchar c, wc_status* st)
{// addr = 0x080C0E5E
    wc_uint32 b;
    unsigned int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    int _t109;
    signed int _t112;
    _unknown_ _t164;
    signed int _t167;
    struct _Str* _t173;
    _unknown_ _t188;
    int _t213;

    _v32 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135791656 = Strnew_size(8);
    }
    _t109 = st->state;
    if(_t109 == 1) {
        if(_v32 != 45) {
            goto L9;
        }
        goto L8;
    }
    if(_t109 == 2) {
L9:
        _t112 =  *( &WC_UTF7_MAP + (_v32 & 255)) & 255 & 4294967295 & ;
        if(_t112 == 32) {
L12:
            _v16 =  *((_v32 & 255) - 32 +  &c_base64_map) & 255 & 4294967295;
            st->shift = st->shift - 6;
            if(st->shift <= 0) {
                 *(st + 52) =  *(st + 52) | _v16 >> ( ~(st->shift) & 4294967295);
                if( *(st + 52) <= 55295 ||  *(st + 52) > 56319) {
                    if( *(st + 52) <= 56319 ||  *(st + 52) > 57343) {
                        if( *(st + 52) != 65279) {
                            wtf_push_ucs( *135791656,  *(st + 52), st);
                        }
                    } else {
                        if( *135791660 != 0) {
                            wtf_push_ucs( *135791656, ( *(st + 52) & 1023 | ( *135791660 & 1023) << 10) + 65536, st);
                        }
                         *135791660 = 0;
                    }
                } else {
                    if( *135791660 != 0) {
                         *135791660 = 0;
                    } else {
                         *135791660 =  *(st + 52);
                    }
                }
                st->shift = st->shift + 16;
                 *(st + 52) = 0;
            }
             *(st + 52) =  *(st + 52) | _v16 << (st->shift & 4294967295) & 65535;
            st->state = 2;
            return  *135791656;
        }
        goto L10;
    }
    if(_t109 == 0) {
        if(_v32 == 43) {
            st->state = 1;
            st->shift = 16;
             *(st + 52) = 0;
             *135791660 = 0;
            return 0;
        }
    }
L29:
    _t167 =  *( &WC_UTF7_MAP + (_v32 & 255)) & 255 & 4294967295 & ;
    if(_t167 == 6) {
L32:
        if( *135791656->length + 1 >=  *135791656->area_size) {
            Strgrow( *135791656);
        }
        _t173 =  *135791656;
        _t213 = _t173->length;
         *( *( *135791656) + _t213) = _v32 & 255 & 4294967295;
        _t173->length = _t213 + 1;
         *( *( *135791656) +  *135791656->length) = 0;
L37:
        st->state = -1;
        return  *135791656;
    }
L30:
    if(_t167 == 8) {
L36:
        goto L37;
    }
    if(_t167 != 4) {
        wtf_push_ucs( *135791656, _v32 & 255, st);
        goto L37;
    }
    goto L32;
L10:
    if(_t112 == 64) {
        st->state = -1;
        return 0;
    }
    if(_t112 != 16) {
        goto L29;
    }
    goto L12;
L8:
    wtf_push_ucs( *135791656, 43, st);
    st->state = -1;
    return  *135791656;
}

size_t wc_ucs_to_utf8(wc_uint32 ucs, wc_uchar* utf8)
{// addr = 0x080C117C
    _unknown_ __ebp;
    _unknown_ _t94;
    _unknown_ _t124;
    _unknown_ _t149;
    _unknown_ _t169;
    _unknown_ _t184;
    _unknown_ _t194;
    _unknown_ _t199;

    if(ucs > 127) {
        if(ucs > 2047) {
            if(ucs > 65535) {
                if(ucs > 2097151) {
                    if(ucs > 67108863) {
                        if(ucs >= 0) {
                             *utf8 = 0;
                            return 0;
                        }
                        goto L11;
                    }
                    goto L9;
L11:
                     *utf8 = (ucs >> 30 | 252) & 4294967295;
                    utf8[1] = (ucs >> 24 & 63 | 128) & 4294967295;
                    utf8[2] = (ucs >> 18 & 63 | 128) & 4294967295;
                    utf8[3] = (ucs >> 12 & 63 | 128) & 4294967295;
                    utf8[4] = (ucs >> 6 & 63 | 128) & 4294967295;
                    utf8[5] = (ucs & 63 | 128) & 4294967295;
                    utf8[6] = 0;
                    return 6;
                }
                goto L7;
L9:
                 *utf8 = (ucs >> 24 | 248) & 4294967295;
                utf8[1] = (ucs >> 18 & 63 | 128) & 4294967295;
                utf8[2] = (ucs >> 12 & 63 | 128) & 4294967295;
                utf8[3] = (ucs >> 6 & 63 | 128) & 4294967295;
                utf8[4] = (ucs & 63 | 128) & 4294967295;
                utf8[5] = 0;
                return 5;
            }
            goto L5;
L7:
             *utf8 = (ucs >> 18 | 240) & 4294967295;
            utf8[1] = (ucs >> 12 & 63 | 128) & 4294967295;
            utf8[2] = (ucs >> 6 & 63 | 128) & 4294967295;
            utf8[3] = (ucs & 63 | 128) & 4294967295;
            utf8[4] = 0;
            return 4;
        }
        goto L3;
L5:
         *utf8 = (ucs >> 12 | 224) & 4294967295;
        utf8[1] = (ucs >> 6 & 63 | 128) & 4294967295;
        utf8[2] = (ucs & 63 | 128) & 4294967295;
        utf8[3] = 0;
        return 3;
    }
     *utf8 = ucs & 4294967295;
    utf8[1] = 0;
    return 1;
L3:
     *utf8 = (ucs >> 6 | 192) & 4294967295;
    utf8[1] = (ucs & 63 | 128) & 4294967295;
    utf8[2] = 0;
    return 2;
}

wc_uint32 wc_utf8_to_ucs(wc_uchar* utf8)
{// addr = 0x080C13A7
    wc_uint32 ucs;
    _unknown_ __ebp;
    _unknown_ _t12;
    _unknown_ _t13;

    if(( *( &WC_UTF8_MAP + ( *utf8 & 255 & 4294967295 & )) & 255 & 4294967295 & ) > 6) {
        return -1;
    }
    goto __eax;
}

Str wc_conv_from_utf8(Str is, wc_ces ces)
{// addr = 0x080C15E5
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    wc_uchar* q;
    int state;
    size_t next;
    wc_uint32 ucs;
    wc_status st;
    struct _Str* _v16;
    wc_uchar* _v20;
    intOrPtr _v24;
    wc_uchar* _v28;
    wc_uchar* _v32;
    signed int _v36;
    signed int _v40;
    unsigned int _v44;
    struct  _v104;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ __ebp;
    _unknown_ _t135;
    unsigned int _t142;
    signed int _t148;
    int _t161;
    _unknown_ _t212;

    _v20 = is->ptr;
    _v24 = _v20 + is->length;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v28 = _v20;
L2:
    while(_v28 < _v24) {
        if(( *_v28 & 255 & 4294967295) >= 0) {
            _v28 =  &(_v28[1]);
            goto L2;
        }
        if(_v28 == _v24) {
            return is;
        }
        _v16 = Strnew_size(((0 + is->length * 4) * 1431655766 >> 32) - (0 + is->length * 4 >> 31));
        if(_v28 > _v20) {
            Strcat_charp_n(_v16, is->ptr, _v28 - _v20);
        }
        _v104.tag = 0;
        _v104.ntag = 0;
        while(_v28 < _v24) {
            _t142 = _v36;
            if(_t142 == 0) {
                _v40 =  *( &WC_UTF8_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                _t148 = _v40;
                if(_t148 == 1) {
                    wtf_push_ucs(_v16,  *_v28 & 255 & 4294967295 & ,  &_v104);
L23:
                    goto L34;
                }
            } else {
                if(_t142 == 1) {
                    if(( *( &WC_UTF8_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295) == 0) {
                        _v40 = _v40 - 1;
                        if(_v40 == 0) {
                            _v36 = 0;
                            _v44 = wc_utf8_to_ucs(_v32);
                            if(_v44 == 255 || _v44 > 55295 && _v44 <= 57343) {
                                wtf_push_unknown(_v16, _v32, _v28 - _v32 + 1);
                            } else {
                                if(_v44 != 65279) {
                                    wtf_push_ucs(_v16, _v44,  &_v104);
                                }
                            }
                        }
                    } else {
                        wtf_push_unknown(_v16, _v32, _v28 - _v32 + 1);
                        _v36 = 0;
                    }
                }
L34:
                _v28 =  &(_v28[1]);
                continue;
            }
L13:
            if(_t148 < 1 || _t148 == 7) {
                wtf_push_unknown(_v16, _v28, 1);
                goto L23;
            } else {
                if(_t148 == 8) {
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t161 = _v16->length;
                     *( *_v16 + _t161) =  *_v28 & 255 & 4294967295;
                    _v16->length = _t161 + 1;
                     *( *_v16 + _v16->length) = 0;
                    goto L23;
                } else {
                    _v32 = _v28;
                    _v40 = _v40 - 1;
                    _v36 = 1;
                }
                goto L34;
            }
        }
    }
}

int wc_push_tag_to_utf8(Str os, int ntag)
{// addr = 0x080C18A7
    char* p;
    char* _v16;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t23;
    _unknown_ _t27;
    _unknown_ _t36;

    if(ntag != 0) {
        _v16 = wc_ucs_get_tag(ntag);
        if(_v16 == 0) {
            ntag = 0;
        }
    }
    if(ntag == 0) {
        wc_ucs_to_utf8(917631,  &utf8_buf);
        Strcat_charp(os,  &utf8_buf);
        return ntag;
    } else {
        wc_ucs_to_utf8(917505,  &utf8_buf);
        Strcat_charp(os,  &utf8_buf);
        while(( *_v16 & 255 & 4294967295) != 0) {
            wc_ucs_to_utf8( *_v16 & 255 & 4294967295 | 917504,  &utf8_buf);
            Strcat_charp(os,  &utf8_buf);
            _v16 =  &(_v16[1]);
        }
    }
}

wc_push_to_utf8(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C196D
    unsigned int _v24;
    _unknown_ __ebp;
    signed int _t90;
    _unknown_ _t94;
    _unknown_ _t116;
    unsigned int _t129;
    _unknown_ _t136;
    int _t149;

    while(1) {
        _t90 = cc.ccs & 65535;
        if(_t90 == 8192) {
            break;
        }
        if(_t90 > 8192) {
            if(_t90 == 16384) {
                if(( *135119022 & 255 & 4294967295) != 0) {
                    return ;
                }
                if( *(_a16 + 48) != 0) {
                     *(_a16 + 48) = wc_push_tag_to_utf8(os, 0);
                }
                Strcat_charp(os, WcReplace);
                return;
            }
            goto L8;
        }
        if(_t90 == 577) {
            if( *(_a16 + 48) != 0) {
                 *(_a16 + 48) = wc_push_tag_to_utf8(os, 0);
            }
            wc_ucs_to_utf8(cc.code,  &utf8_buf);
            Strcat_charp(os,  &utf8_buf);
            return;
        }
        if(_t90 == 4096) {
            break;
        }
        if(_t90 == 322) {
            if( *(_a16 + 48) != 0) {
                 *(_a16 + 48) = wc_push_tag_to_utf8(os, 0);
            }
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t149 = os->length;
             *(os->ptr + _t149) = cc.code & 127 & 4294967295;
            os->length = _t149 + 1;
             *(os->ptr + os->length) = 0;
            return;
        } else {
        }
L34:
        if(( *135119011 & 255 & 4294967295) == 0) {
L37:
            if((cc.ccs & 98304) == 0) {
                _t129 = 16384;
            } else {
                _t129 = 49152;
            }
            cc.ccs = _t129;
            continue;
        }
         *__esp = cc.ccs;
        _v24 = cc.code;
        cc.code = wc_any_to_ucs();
        if(cc.code == 255) {
            goto L37;
        }
        cc.ccs = 4096;
        continue;
L8:
        if(_t90 == 49152) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            if( *(_a16 + 48) != 0) {
                 *(_a16 + 48) = wc_push_tag_to_utf8(os, 0);
            }
            Strcat_charp(os, WcReplaceW);
            return;
        }
        if(_t90 == 8193) {
            if(( *135119010 & 255 & 4294967295) != 0 && cc.code >> 24 !=  *(_a16 + 48)) {
                 *(_a16 + 48) = wc_push_tag_to_utf8(os, cc.code >> 24);
            }
            wc_ucs_to_utf8(cc.code & 2097151,  &utf8_buf);
            Strcat_charp(os,  &utf8_buf);
            return;
        }
        goto L34;
    }
    if( *(_a16 + 48) != 0) {
         *(_a16 + 48) = wc_push_tag_to_utf8(os, 0);
    }
    wc_ucs_to_utf8(cc.code,  &utf8_buf);
    Strcat_charp(os,  &utf8_buf);
    return;
}

wc_push_to_utf8_end(Str os, wc_status* st)
{// addr = 0x080C1C44
    _unknown_ _v24;
    _unknown_ __ebp;

    if(st->ntag == 0) {
        return ;
    }
    st->ntag = wc_push_tag_to_utf8(os, 0);
    return;
}

Str wc_char_conv_from_utf8(wc_uchar c, wc_status* st)
{// addr = 0x080C1C6F
    wc_uint32 ucs;
    unsigned int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t56;
    signed int _t60;
    struct _Str* _t69;
    struct _Str* _t75;
    _unknown_ _t80;
    struct _Str* _t83;
    _unknown_ _t90;
    int _t102;

    _v32 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135791672 = Strnew_size(8);
         *(st + 44) = 0;
        st->ntag = 0;
         *135791676 = 0;
    }
    _t56 = st->state;
    if(_t56 == 0) {
         *135791680 =  *( &WC_UTF8_MAP + (_v32 & 255)) & 255 & 4294967295 & ;
        _t60 =  *135791680;
        if(_t60 == 1) {
            wtf_push_ucs( *135791672, _v32 & 255, st);
        } else {
            if(_t60 >= 1 && _t60 != 7) {
                if(_t60 != 8) {
                    _t75 =  *135791676;
                     *(_t75 + 135791684) = _v32 & 255 & 4294967295;
                     *135791676 =  &(_t75->ptr);
                     *135791680 =  *135791680 - 1;
                    st->state = 1;
                    return 0;
                }
                if( *135791672->length + 1 >=  *135791672->area_size) {
                    Strgrow( *135791672);
                }
                _t69 =  *135791672;
                _t102 = _t69->length;
                 *( *( *135791672) + _t102) = _v32 & 255 & 4294967295;
                _t69->length = _t102 + 1;
                 *( *( *135791672) +  *135791672->length) = 0;
            }
        }
    } else {
        if(_t56 == 1) {
            if(( *( &WC_UTF8_MAP + (_v32 & 255)) & 255 & 4294967295) == 0) {
                _t83 =  *135791676;
                 *(_t83 + 135791684) = _v32 & 255 & 4294967295;
                 *135791676 =  &(_t83->ptr);
                 *135791680 =  *135791680 - 1;
                if( *135791680 != 0) {
                    return 0;
                }
                _v16 = wc_utf8_to_ucs(135791684);
                if(_v16 != 255 && (_v16 <= 55295 || _v16 > 57343)) {
                    if(_v16 != 65279) {
                        wtf_push_ucs( *135791672, _v16, st);
                    }
                }
            }
        }
    }
    st->state = -1;
    return  *135791672;
}

wc_uint32 wc_tcvn5712_precompose(wc_uchar c1, wc_uchar c2)
{// addr = 0x080C1E74
    signed int _v8;
    signed int _v12;
    _unknown_ __ebp;
    _unknown_ _t18;

    _v8 = c1 & 4294967295;
    _v12 = c2 & 4294967295;
    if(( *( &tcvn5712_precompose_map + (_v8 & 255)) & 255 & 4294967295) != 1) {
        return 0;
    }
    if(( *( &tcvn5712_precompose_map + (_v12 & 255)) & 255 & 4294967295) != 2) {
        return 0;
    }
    return _v12 & 255 | (_v8 & 255) << 8;
}

wc_wchar_t wc_tcvn57123_to_tcvn5712(wc_wchar_t cc)
{// addr = 0x080C1EBC
    wc_map* map;
    wc_map* _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    struct  __ebx;
    _unknown_ __ebp;
    unsigned int _t30;

    __ebx = cc.ccs;
    _v16 = wc_map_search(_a12 & 4294967295 &  & 32639,  &tcvn57123_tcvn5712_map, 120);
    if(_v16 == 0) {
        cc.code = 16384;
    } else {
        if(( *(_v16 + 2) & 65535 & 4294967295) > 31) {
            _t30 = 2077;
        } else {
            _t30 = 2078;
        }
        cc.code = _t30;
        _a12 =  *(_v16 + 2) & 65535 & 4294967295 & ;
    }
     *__ebx = cc.code;
     *(__ebx + 4) = _a12;
    return __ebx;
}

wc_uint32 wc_cp1258_precompose(wc_uchar c1, wc_uchar c2)
{// addr = 0x080C1F3B
    signed int _v8;
    signed int _v12;
    _unknown_ __ebp;
    _unknown_ _t18;

    _v8 = c1 & 4294967295;
    _v12 = c2 & 4294967295;
    if(( *( &cp1258_precompose_map + (_v8 & 255)) & 255 & 4294967295) != 1) {
        return 0;
    }
    if(( *( &cp1258_precompose_map + (_v12 & 255)) & 255 & 4294967295) != 2) {
        return 0;
    }
    return _v12 & 255 | (_v8 & 255) << 8;
}

Str wc_conv_from_viet(Str is, wc_ces ces)
{// addr = 0x080C1F83
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    wc_ccs ccs1;
    wc_ccs ccs2;
    wc_uint8* map;
    _unknown_ _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    intOrPtr _v32;
    intOrPtr _v36;
    wc_uint8[31]* _v40;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    unsigned int _t104;
    _unknown_ _t124;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 =  *((intOrPtr*)( *((intOrPtr*)(((ces & 255) << 5) + 135767980)) + 8));
    _v36 =  *((intOrPtr*)( *((intOrPtr*)(((ces & 255) << 5) + 135767980)) + 16));
    _v40 = 0;
    _t104 = ces;
    if(_t104 == 1066051) {
        _v40 =  &wc_c0_viscii112_map;
    } else {
        if(_t104 == 1066052) {
            _v40 =  &wc_c0_vps2_map;
        } else {
            if(_t104 == 1066050) {
                _v40 =  &wc_c0_tcvn57122_map;
            }
        }
    }
    wc_create_detect_map(ces, 0);
    _v28 = _v20;
    while(_v28 < _v24 && ( *( &WC_DETECT_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295) == 0) {
    }
}

wc_push_to_viet(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C2164
    wc_ccs ccs1;
    wc_ccs ccs2;
    wc_ccs ccs3;
    wc_uint8* map;
    intOrPtr _v16;
    wc_uint8[31]* _v20;
    wc_uint8[31]* _v24;
    wc_uint8[31]* _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    intOrPtr _t169;
    _unknown_ _t183;
    _unknown_ _t193;
    _unknown_ _t203;
    _unknown_ _t219;
    _unknown_ _t232;
    _unknown_ _t244;
    _unknown_ _t258;
    _unknown_ _t271;

    _v16 =  *((intOrPtr*)( *((intOrPtr*)( *_a16 + 12)) + 8));
    _v20 = 0;
    _v24 = 0;
    _v28 = 0;
    _t169 =  *((intOrPtr*)( *_a16));
    if(_t169 == 1066050) {
        _v28 =  &wc_c0_tcvn57122_map;
        _v20 =  *( *((intOrPtr*)( *_a16 + 12)) + 16);
        _v24 =  *( *((intOrPtr*)( *_a16 + 12)) + 24);
    } else {
        if(_t169 > 1066050) {
            if(_t169 == 1066051) {
                _v28 =  &wc_c0_viscii112_map;
                _v20 =  *( *((intOrPtr*)( *_a16 + 12)) + 16);
            } else {
                if(_t169 == 1066052) {
                    _v28 =  &wc_c0_vps2_map;
                    _v20 =  *( *((intOrPtr*)( *_a16 + 12)) + 16);
                }
            }
        } else {
            if(_t169 == 1049665) {
                _v24 =  *( *((intOrPtr*)( *_a16 + 12)) + 16);
            }
        }
    }
    while(1) {
    }
}

Str wc_char_conv_from_viet(wc_uchar c, wc_status* st)
{// addr = 0x080C250D
    Str os;
    wc_uint8* map;
    struct _Str* _v16;
    wc_uint8[31]* _v20;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    unsigned int _t51;
    int _t59;

    _v32 = c & 4294967295;
    _v16 = Strnew_size(1);
    _v20 = 0;
    _t51 = st->ces_info->id;
    if(_t51 == 1066051) {
        _v20 =  &wc_c0_viscii112_map;
    } else {
        if(_t51 == 1066052) {
            _v20 =  &wc_c0_vps2_map;
        } else {
            if(_t51 == 1066050) {
                _v20 =  &wc_c0_tcvn57122_map;
            }
        }
    }
    if((_v32 & 255 & 4294967295) < 0) {
        wtf_push(_v16,  *(st->ces_info->gset + 8), _v32 & 255);
        return _v16;
    }
    if(_v32 > 31 || ( *(_v20 + (_v32 & 255)) & 255 & 4294967295) == 0) {
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t59 = _v16->length;
         *( *_v16 + _t59) = _v32 & 255 & 4294967295;
        _v16->length = _t59 + 1;
         *( *_v16 + _v16->length) = 0;
        return _v16;
    }
    wtf_push(_v16,  *(st->ces_info->gset + 16), _v32 & 255);
    return _v16;
}

wtf_init(wc_ces ces1, wc_ces ces2)
{// addr = 0x080C2624
    int i;
    wc_gset* gset;
    intOrPtr _v16;
    intOrPtr _v20;
    _unknown_ __ebp;

    if((wc_check_ces(ces2) & 4294967295) != 0) {
        wtf_major_ces = ces2;
    }
    if((wc_check_ces(ces1) & 4294967295) == 0) {
        return ;
    }
    _v20 =  *((intOrPtr*)(((ces1 & 255) << 5) + 135767980));
    if(_v20 == 0) {
        return ;
    }
    if( *(_v20 + 8) == 0) {
        return ;
    }
    if(( *(_v20 + 8) & 12288) != 0) {
        return ;
    }
    wtf_gr_ccs =  *(_v20 + 8);
    if((wtf_gr_ccs & 98304) == 0) {
        _v16 = 161;
L13:
        while(_v16 <= 255) {
            goto L12;
        }
    } else {
        _v16 = 161;
        while(_v16 <= 255) {
             *((char*)(_v16 +  &WTF_WIDTH_MAP)) = 2;
             *((char*)(_v16 +  &WTF_LEN_MAP)) = 2;
             *((char*)(_v16 +  &WTF_TYPE_MAP)) = 10;
            _v16 = _v16 + 1;
        }
    }
L12:
     *((char*)(_v16 +  &WTF_WIDTH_MAP)) = 1;
     *((char*)(_v16 +  &WTF_LEN_MAP)) = 1;
     *((char*)(_v16 +  &WTF_TYPE_MAP)) = 2;
    _v16 = _v16 + 1;
    goto L13;
}

int wtf_strwidth(wc_uchar* p)
{// addr = 0x080C272A
    int w;
    intOrPtr _v8;
    _unknown_ __ebp;
    signed int _t31;

    _v8 = 0;
    while(( *p & 255 & 4294967295) != 0) {
        if(( *135119023 & 255 & 4294967295) == 0) {
            _t31 =  *( &WTF_WIDTH_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        } else {
            _t31 =  *( &WTF_WIDTH_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 & ;
        }
        _v8 = _v8 + _t31;
        p = p + ( *( &WTF_LEN_MAP + ( *p & 255 & 4294967295 & )) & 255 & 4294967295 & );
    }
}

size_t wtf_len(wc_uchar* p)
{// addr = 0x080C2799
    wc_uchar* q;
    wc_uchar* _v8;
    _unknown_ __ebp;

    _v8 = p;
    _v8 = _v8 + ( *( &WTF_LEN_MAP + ( *_v8 & 255 & 4294967295 & )) & 255 & 4294967295 & );
    while(( *_v8 & 255 & 4294967295) != 0) {
        if(( *( &WTF_WIDTH_MAP + ( *_v8 & 255 & 4294967295 & )) & 255 & 4294967295) != 0) {
            return _v8 - p;
        }
        _v8 = _v8 + ( *( &WTF_LEN_MAP + ( *_v8 & 255 & 4294967295 & )) & 255 & 4294967295 & );
    }
}

wtf_push(Str os, wc_ccs ccs, wc_uint32 code)
{// addr = 0x080C27FF
    wc_uchar[7] s;
    wc_wchar_t cc;
    wc_wchar_t cc2;
    size_t n;
    wc_bool fix_width_conv;
    signed int _v16;
    signed int _v21;
    signed int _v22;
    signed int _v23;
    signed int _v24;
    signed char _v25;
    int _v32;
    unsigned int _v36;
    signed int _v40;
    unsigned int _v44;
    signed int _v48;
    struct _Str* _v64;
    unsigned int _v72;
    signed int _v76;
    struct * _v80;
    unsigned int _v84;
    unsigned int _v88;
    _unknown_ _v92;
    _unknown_ __ebp;
    _unknown_ _t317;
    signed int _t322;
    signed int _t327;
    signed int _t346;
    _unknown_ _t394;
    signed int _t403;
    _unknown_ _t470;
    int _t502;
    int _t521;
    signed int _t538;
    signed int _t548;
    _unknown_ _t584;

    _v64 = os;
    _v16 =  *gs:0x14];
    if(ccs != 322) {
        _v40 = ccs;
        _v36 = code;
        if(( *135119012 & 255 & 4294967295) == 0 || (_v40 & 16384) != 0) {
L31:
            _t322 = _v40 & 65280;
            if(_t322 == 4096) {
                if((_v40 & 98304) == 0) {
                    _t538 = -120;
                } else {
                    _t538 = -119;
                }
                if((_v40 & 131072) == 0) {
                    _t327 = 0;
                } else {
                    _t327 = 16;
                }
                _v24 = (_t327 | _t538) & 4294967295;
                (char*)( &_v24)[1] = (_v36 >> 14 & 3 | 128) & 4294967295;
                (char*)( &_v24)[2] = (_v36 >> 7 | 128) & 4294967295;
                (char*)( &_v24)[3] = (_v36 | 128) & 4294967295;
                _v23 = (_v23 & 255 | _v40 << 2) & 4294967295;
                _v32 = 4;
L101:
                Strcat_charp_n(_v64,  &_v24, _v32);
                goto L102;
            }
        } else {
            if(ccs == 34831 || ccs == 34832 || ccs == 34833 || ccs == 34834) {
                if(wtf_major_ces == 3149849 || wtf_major_ces == 2099221) {
                    _v88 = _v40;
                    _v84 = _v36;
                     *__esp =  &_v48;
                    wc_johab_to_ksx1001();
                    __esp = __esp - 4;
                    if((_v48 & 16384) == 0) {
                        _v40 = _v48;
                        _v36 = _v44;
                    }
                    goto L31;
                } else {
                    goto L14;
                }
                goto L32;
            }
L14:
            if(ccs != 33091 || wtf_major_ces != 3153984) {
                if(( *135119011 & 255 & 4294967295) == 0) {
                    goto L31;
                }
                _v25 =  *135119013 & 255 & 4294967295;
                 *135119013 = 0;
                wc_output_init(wtf_major_ces,  &wtf_major_st);
                if((wc_ces_has_ccs(ccs & 65535,  &wtf_major_st) & 4294967295) != 0) {
L28:
                     *135119013 = _v25 & 255 & 4294967295;
                    goto L31;
                }
                _v80 =  &wtf_major_st;
                _v88 = _v40;
                _v84 = _v36;
                 *__esp =  &_v76;
                wc_any_to_any_ces();
                __esp = __esp - 4;
                _v48 = _v76;
                _v44 = _v72;
                if(_v48 != 322) {
                    if((_v48 & 16384) == 0 && _v48 != 2076 && _v48 != 2079) {
                        _v40 = _v48;
                        _v36 = _v44;
                    }
                    goto L28;
                } else {
                    if(_v64->length + 1 >= _v64->area_size) {
                        Strgrow(_v64);
                    }
                    _t502 = _v64->length;
                     *( *_v64 + _t502) = _v44 & 127 & 4294967295;
                    _v64->length = _t502 + 1;
                     *( *_v64 + _v64->length) = 0;
                }
                goto L102;
            } else {
                _v88 = _v40;
                _v84 = _v36;
                 *__esp =  &_v76;
                wc_ksx1001_to_johab();
                __esp = __esp - 4;
                _v48 = _v76;
                _v44 = _v72;
                if((_v48 & 16384) == 0) {
                    _v40 = _v48;
                    _v36 = _v44;
                }
            }
            goto L31;
        }
L32:
        if(_t322 > 4096) {
            if(_t322 == 33024) {
                goto L54;
            }
            goto L41;
        }
        if(_t322 == 512) {
            if(( *135119009 & 255 & 4294967295) == 0) {
L60:
                if(_v40 != wtf_gr_ccs || (_v36 & 127) <= 32) {
                    _v24 = 130;
                } else {
                    _v24 = (_v36 | 128) & 4294967295;
                    _v32 = 1;
                    goto L101;
                }
L64:
                _v23 = (_v40 | 128) & 4294967295;
                _v22 = (_v36 | 128) & 4294967295;
                _v32 = 3;
                goto L101;
            }
            goto L58;
        }
        if(_t322 > 512) {
            if(_t322 == 1024) {
                if(_v40 != wtf_gr_ccs) {
                    _v24 = 132;
                    _v23 = (_v40 | 128) & 4294967295;
                    _v22 = (_v36 | 128) & 4294967295;
                    _v32 = 3;
                } else {
                    _v24 = (_v36 | 128) & 4294967295;
                    _v32 = 1;
                }
                goto L101;
            }
            goto L38;
        }
        if(_t322 == 256) {
            if(_v40 != wtf_gr_ccs) {
                if(_v40 != 329 || ( *135119017 & 255 & 4294967295) != 0) {
L53:
                    _v24 = 128;
                    _v23 = (_v40 | 128) & 4294967295;
                    _v22 = (_v36 | 128) & 4294967295;
                    _v32 = 3;
                    goto L101;
                } else {
                    _v88 = _v40;
                    _v84 = _v36;
                     *__esp =  &_v76;
                    wc_jisx0201k_to_jisx0208();
                    __esp = __esp - 4;
                    _v48 = _v76;
                    _v44 = _v72;
                    if((_v48 & 16384) != 0) {
                        goto L53;
                    }
                    wtf_push(_v64, _v48, _v44);
                    goto L102;
                }
L54:
                if(_v40 != wtf_gr_ccs) {
                    _v24 = 129;
                    _v23 = (_v40 | 128) & 4294967295;
                    _v22 = (_v36 >> 8 | 128) & 4294967295;
                    _v21 = (_v36 | 128) & 4294967295;
                    _v32 = 4;
                } else {
                    _v24 = (_v36 >> 8 | 128) & 4294967295;
                    _v23 = (_v36 | 128) & 4294967295;
                    _v32 = 2;
                }
                goto L101;
            }
            _v24 = (_v36 | 128) & 4294967295;
            _v32 = 1;
            goto L101;
        } else {
        }
L100:
        _v24 = 133;
        _v23 = (_v40 | 128) & 4294967295;
        _v22 = (_v36 | 128) & 4294967295;
        _v32 = 3;
        goto L101;
L38:
        if(_t322 == 2048) {
            if(( *135119009 & 255 & 4294967295) == 0) {
L75:
                if(_v40 != wtf_gr_ccs || (_v36 & 127) <= 32) {
                    _v24 = 134;
                } else {
                    _v24 = (_v36 | 128) & 4294967295;
                    _v32 = 1;
                    goto L101;
                }
L79:
                _v23 = (_v40 | 128) & 4294967295;
                _v22 = (_v36 | 128) & 4294967295;
                _v32 = 3;
                goto L101;
            }
             *__esp = _v40;
            _v88 = _v36;
            if((wc_is_combining() & 4294967295) == 0) {
                goto L75;
            }
            _v24 = 150;
            goto L79;
        } else {
        }
        goto L100;
L58:
         *__esp = _v40;
        _v88 = _v36;
        if((wc_is_combining() & 4294967295) == 0) {
            goto L60;
        }
        _v24 = 146;
        goto L64;
L41:
        if(_t322 > 33024) {
            if(_t322 == 33280) {
                if(_v40 != wtf_gr_ccs || (_v36 >> 8 & 127) <= 32) {
                    _v24 = 131;
                    _v23 = (_v40 | 128) & 4294967295;
                    _v22 = (_v36 >> 8 | 128) & 4294967295;
                    _v21 = (_v36 | 128) & 4294967295;
                    _v32 = 4;
                } else {
                    _v24 = (_v36 >> 8 | 128) & 4294967295;
                    _v23 = (_v36 | 128) & 4294967295;
                    _v32 = 2;
                }
                goto L101;
            }
            goto L45;
        }
        if(_t322 == 8192) {
            if((_v40 & 98304) == 0) {
                _t548 = -118;
            } else {
                _t548 = -117;
            }
            if((_v40 & 131072) == 0) {
                _t403 = 0;
            } else {
                _t403 = 16;
            }
            _v24 = (_t403 | _t548) & 4294967295;
            ( &_v24)[0] = (_v36 >> 28 | 128) & 4294967295;
            ( &_v24)[0] = (_v36 >> 21 | 128) & 4294967295;
            ( &_v24)[0] = (_v36 >> 14 | 128) & 4294967295;
            ( &_v24)[1] = (_v36 >> 7 | 128) & 4294967295;
            ( &_v24)[1] = (_v36 | 128) & 4294967295;
            _v23 = (_v23 & 255 | _v40 << 4) & 4294967295;
            _v32 = 6;
            goto L101;
        } else {
        }
        goto L100;
L45:
        if(_t322 == 34816) {
            if(_v40 - 34817 > 30) {
                if(_v40 != wtf_gr_ccs || (_v36 >> 8 & 127) <= 32) {
                    _v24 = 135;
                    _v23 = (_v40 | 128) & 4294967295;
                    _v22 = (_v36 >> 8 | 128) & 4294967295;
                    _v21 = (_v36 | 128) & 4294967295;
                    _v32 = 4;
                } else {
                    _v24 = (_v36 >> 8 | 128) & 4294967295;
                    _v23 = (_v36 | 128) & 4294967295;
                    _v32 = 2;
                }
                goto L101;
            }
            goto __eax;
        } else {
        }
        goto L100;
    } else {
        _t584 = _v64->length + 1 - _v64->area_size;
        if(_t584 >= 0) {
            Strgrow(_v64);
        }
        _t521 = _v64->length;
         *( *_v64 + _t521) = code & 127 & 4294967295;
        _v64->length = _t521 + 1;
         *( *_v64 + _v64->length) = 0;
    }
L102:
    _t346 = _v16 ^  *gs:0x14];
    if(_t584 == 0) {
        return _t346;
    }
    __stack_chk_fail();
    return _t346;
}

wtf_push_unknown(Str os, wc_uchar* p, size_t len)
{// addr = 0x080C30CF
    signed int _v20;
    intOrPtr _v24;
    _unknown_ __ebp;
    struct _Str* _t33;
    int _t42;

    _t33 = __eax;
    while(1) {
        len = len - 1;
        if((_t33 & 4294967295) == 0) {
            break;
        }
        if(( *p & 255 & 4294967295) >= 0) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t42 = os->length;
             *(os->ptr + _t42) =  *p & 255 & 4294967295;
            os->length = _t42 + 1;
            _t33 = os->ptr + os->length;
            _t33->ptr = 0;
        } else {
            _v20 =  *p & 255 & 4294967295 & ;
            _v24 = 16384;
            _t33 = os;
             *__esp = _t33;
            wtf_push();
        }
        p =  &(p[1]);
    }
    return;
}

wc_wchar_t wtf_parse1(wc_uchar** p)
{// addr = 0x080C316B
    wc_uchar* q;
    wc_wchar_t cc;
    _unknown_ _v8;
    signed char* _v16;
    signed int _v20;
    signed int _v24;
    _unknown_ __ebp;
    signed int _t117;
    _unknown_ _t156;
    struct  _t218;
    _unknown_ _t219;

    _push(__ebx);
    __esp = __esp - 36;
    _t218 = p;
    _v16 =  *_a8;
    if(( *_v16 & 255 & 4294967295) >= 0) {
        if(( *_v16 & 255 & 4294967295) <= 160) {
            _v24 = ( *(( *_v16 & 255 & 4294967295 & ) + -128 + ( *_v16 & 255 & 4294967295 & ) + -128 +  &CCS_MAP) & 65535 & 4294967295 & ) << 8;
            _v16 =  &(_v16[1]);
            _t117 = _v24 & 65280;
            if(_t117 == 8192) {
L28:
                _v24 = ( *_v16 & 255 & 4294967295 &  & 112) >> 4 | _v24;
                _v20 = _v16[4] & 255 & 4294967295 &  & 127 | ( *_v16 & 255 & 4294967295 & ) << 28 | (_v16[1] & 255 & 4294967295 &  & 127) << 21 | (_v16[2] & 255 & 4294967295 &  & 127) << 14 | (_v16[3] & 255 & 4294967295 &  & 127) << 7;
                _v16 =  &(_v16[5]);
                goto L30;
            }
            goto L7;
L29:
            _v24 = 322;
            _v20 = 32;
            goto L30;
        }
        _v24 = wtf_gr_ccs;
        if((_v24 & 98304) == 0) {
            _v20 =  *_v16 & 255 & 4294967295 & ;
            _v16 =  &(_v16[1]);
        } else {
            _v20 = _v16[1] & 255 & 4294967295 &  | ( *_v16 & 255 & 4294967295 & ) << 8;
            _v16 =  &(_v16[2]);
        }
        goto L30;
L7:
        if(_t117 > 8192) {
            if(_t117 == 33280) {
                goto L26;
            }
            goto L17;
        }
        if(_t117 == 1024) {
L25:
            _v24 =  *_v16 & 255 & 4294967295 &  & 127 | _v24;
            _v16 =  &(_v16[1]);
            _v20 =  *_v16 & 255 & 4294967295 & ;
            _v16 =  &(_v16[1]);
            goto L30;
        }
        if(_t117 > 1024) {
            if(_t117 == 2048) {
                goto L25;
            }
            goto L14;
        }
        if(_t117 == 256 || _t117 == 512) {
            goto L25;
        } else {
            goto L29;
        }
        goto L26;
L14:
        if(_t117 == 4096) {
L27:
            _v24 = ( *_v16 & 255 & 4294967295 &  & 124) >> 2 | _v24;
            _v20 = _v16[2] & 255 & 4294967295 &  & 127 | ( *_v16 & 255 & 4294967295 & ) << 14 & 4294967295 &  | (_v16[1] & 255 & 4294967295 &  & 127) << 7;
            _v16 =  &(_v16[3]);
            goto L30;
        }
        goto L29;
L26:
        _v24 =  *_v16 & 255 & 4294967295 &  & 127 | _v24;
        _v16 =  &(_v16[1]);
        _v20 = _v16[1] & 255 & 4294967295 &  | ( *_v16 & 255 & 4294967295 & ) << 8;
        _v16 =  &(_v16[2]);
        goto L30;
L17:
        if(_t117 > 33280) {
            if(_t117 == 69632) {
                goto L27;
            }
            goto L22;
        }
        if(_t117 == 16384) {
            goto L25;
        }
        if(_t117 == 33024) {
            goto L26;
        }
        goto L29;
L22:
        if(_t117 == 73728) {
            goto L28;
        }
        if(_t117 == 34816) {
            goto L26;
        }
        goto L29;
    } else {
        _v24 = 322;
        _v20 =  *_v16 & 255 & 4294967295 & ;
        _v16 =  &(_v16[1]);
    }
L30:
     *_a8 = _v16;
    if(_v24 - 34818 > 31) {
         *_t218 = _v24;
         *(_t218 + 4) = _v20;
        return _t218;
    }
    goto __eax;
}

wc_wchar_t wtf_parse(wc_uchar** p)
{// addr = 0x080C34FA
    wc_uchar* q;
    wc_wchar_t cc;
    wc_wchar_t cc2;
    wc_uint32 ucs;
    wc_uint32 ucs2;
    _unknown_ _v8;
    signed char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    signed int _v28;
    signed int _v32;
    signed int _v36;
    signed int _v40;
    _unknown_ _v48;
    _unknown_ _v52;
    signed char** _v72;
    char* _v76;
    _unknown_ _v80;
    _unknown_ __ebp;
    _unknown_ _t133;
    _unknown_ _t136;
    signed char* _t192;
    struct  _t195;
    _unknown_ _t196;

    _push(__ebx);
    __esp = __esp - 68;
    _t195 = p;
    if(( *( *_a8) & 255 & 4294967295) >= 0) {
        _v72 = _a8;
        wtf_parse1( &_v32);
        __esp = __esp - 4;
    } else {
        _v32 = 322;
        _t192 =  *_a8;
        _v28 =  *_t192 & 255 & 4294967295 & ;
         *_a8 =  &(_t192[1]);
    }
    if(( *135119009 & 255 & 4294967295) == 0 || ( *( &WTF_WIDTH_MAP + ( *( *_a8) & 255 & 4294967295 & )) & 255 & 4294967295) != 0) {
         *_t195 = _v32;
         *(_t195 + 4) = _v28;
        return _t195;
    }
    _v16 =  *_a8;
    _v76 =  &_v16;
    wtf_parse1( &_v40);
    __esp = __esp - 4;
    if(_v32 == 322 || _v32 == 2075) {
        if((_v40 & 65535) != 2075) {
            goto L11;
        } else {
            _v36 = wc_cp1258_precompose(_v28 & 4294967295 & , _v36 & 4294967295 & );
            if(_v36 != 0) {
                _v40 = 2076;
                 *_a8 = _v16;
                 *_t195 = _v40;
                 *(_t195 + 4) = _v36;
                return _t195;
            }
        }
L47:
         *_t195 = _v32;
         *(_t195 + 4) = _v28;
        return _t195;
    }
L11:
    if(_v32 == 322 || _v32 == 2077) {
        if((_v40 & 65535) != 2077) {
            goto L16;
        } else {
            _v36 = wc_tcvn5712_precompose(_v28 & 4294967295 & , _v36 & 4294967295 & );
            if(_v36 != 0) {
                _v40 = 2079;
                 *_a8 = _v16;
                 *_t195 = _v40;
                 *(_t195 + 4) = _v36;
                return _t195;
            }
        }
        goto L47;
    }
L16:
    if(_v32 == 322 || _v32 == 577 || (_v32 & 65535) == 4096 || (_v32 & 65535) == 8192 || (_v32 & 65535) == 8193) {
        if((_v40 & 65535) == 4096 || (_v40 & 65535) == 8192) {
L28:
            while() {
            }
        }
        if((_v40 & 65535) != 8193) {
            goto L47;
        }
        goto L28;
    }
    goto L47;
}

wc_ccs wtf_get_ccs(wc_uchar* p)
{// addr = 0x080C3807
    intOrPtr _v20;
    wc_uchar** _v40;
    _unknown_ __ebp;

    _v40 =  &p;
    wtf_parse1( &_v20);
    __esp = __esp - 4;
    return _v20;
}

wc_uint32 wtf_get_code(wc_uchar* p)
{// addr = 0x080C3827
    unsigned int _v16;
    wc_uchar* _v20;
    wc_uchar** _v40;
    _unknown_ __ebp;

    _v40 =  &p;
    wtf_parse1( &_v20);
    __esp = __esp - 4;
    return _v16;
}

wc_bool wtf_is_hangul(wc_uchar* p)
{// addr = 0x080C3847
    wc_uchar f;
    wc_uchar f;
    wc_uchar f;
    signed int _v13;
    signed int _v14;
    signed int _v15;
    _unknown_ __ebp;
    _unknown_ _t63;
    unsigned char _t124;
    unsigned char _t131;

    if(( *p & 255 & 4294967295) <= 160) {
        if(( *p & 255 & 4294967295) == 129) {
            return p[1] & 255 & 4294967295 &  & 127;
        }
        if(( *p & 255 & 4294967295) != 135) {
            if(( *p & 255 & 4294967295) != 137) {
                if(( *p & 255 & 4294967295) != 139) {
                    return 0;
                }
                p =  &(p[1]);
                _v15 = ( *p & 255 & 4294967295 &  & 127) >> 4 & 4294967295;
                if(_v15 != 1) {
                    return 0;
                }
                return wc_is_ucs_hangul((p[4] & 255 & 4294967295 &  & 127 | ( *p & 255 & 4294967295 & ) << 28 | (p[1] & 255 & 4294967295 &  & 127) << 21 | (p[2] & 255 & 4294967295 &  & 127) << 14 | (p[3] & 255 & 4294967295 &  & 127) << 7) & 2097151);
            }
        } else {
            _v13 = p[1] & 255 & 127 & 4294967295;
            if(_v13 == 16 || _v13 == 17 || _v13 == 18 || _v13 == 29 || _v13 == 30) {
                _t124 = 1;
                return _t124;
            }
            _t124 = 0;
            return _t124;
        }
L18:
        p =  &(p[1]);
        _v14 = ( *p & 255 & 4294967295 &  & 127) >> 2 & 4294967295;
        if(_v14 != 0) {
            return 0;
        }
        return wc_is_ucs_hangul(p[2] & 255 & 4294967295 &  & 127 | ( *p & 255 & 4294967295 & ) << 14 & 4294967295 &  | (p[1] & 255 & 4294967295 &  & 127) << 7);
    }
    if(wtf_gr_ccs == 33091) {
L3:
        _t131 = 1;
        return _t131;
    } else {
        if(wtf_gr_ccs != 34832) {
            _t131 = 0;
            return _t131;
        } else {
            goto L3;
        }
    }
    return p[1] & 255 & 4294967295 &  & 127;
}

char* wtf_conv_fit(char* s, wc_ces ces)
{// addr = 0x080C39F2
    wc_uchar* p;
    Str os;
    wc_wchar_t cc;
    wc_ces major_ces;
    wc_bool pre_conv;
    wc_bool ucs_conv;
    _unknown_ _v13;
    _unknown_ _v14;
    char* _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ __ebp;

    if(ces == 3211264) {
        return s;
    }
    if(ces == 256) {
        return s;
    }
    _v20 = s;
    while(( *_v20 & 255 & 4294967295) != 0 && ( *_v20 & 255 & 4294967295) >= 0) {
        _v20 =  &(_v20[1]);
    }
}

wc_wchar_t wc_big5_to_cs94w(wc_wchar_t cc)
{// addr = 0x080C3B1C
    signed int _v16;
    struct  __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t35;
    _unknown_ _t43;
    _unknown_ _t48;
    _unknown_ _t62;
    _unknown_ _t63;
    _unknown_ _t65;

    __ebx = cc.ccs;
    _t62 = (_a12 >> 8 & 255) * (_a12 >> 8 & 255) + (_a12 & 255);
    if((_a12 & 255) > 160) {
        _t35 = 98;
    } else {
        _t35 = 64;
    }
    _a12 = _t62 - _t35 - 25277;
    if(_a12 > 6279) {
        cc.code = 34819;
        _a12 = _a12 - 6280;
    } else {
        cc.code = 34818;
    }
    _v16 = _a12;
    _a12 = ((_v16 * -1370734243 >> 32 >> 6) + 33 << 8) + _a12 - (_a12 * -1370734243 >> 32 >> 6) * (_a12 * -1370734243 >> 32 >> 6) + 33;
     *__ebx = cc.code;
     *(__ebx + 4) = _a12;
    return __ebx;
}

wc_wchar_t wc_cs94w_to_big5(wc_wchar_t cc)
{// addr = 0x080C3BE8
    signed int _v20;
    _unknown_ __ebx;
    _unknown_ __edi;
    struct  __esi;
    _unknown_ __ebp;
    _unknown_ _t41;
    _unknown_ _t49;
    _unknown_ _t54;
    _unknown_ _t66;
    _unknown_ _t69;
    _unknown_ _t71;
    _unknown_ _t73;
    signed int _t79;

    __esi = cc.ccs;
    _a12 = (_a12 >> 8 & 127) * (_a12 >> 8 & 127) + (_a12 & 127) - 3135;
    if(cc.code == 34819) {
        _a12 = _a12 + 6280;
    }
    _v20 = _a12;
    _t79 = (_v20 * 875407347 >> 32 >> 5) + 161 << 8;
    _t66 = _a12 - _a12 * 875407347 * (_t61 * 875407347 >> 32 >> 5);
    if(_a12 - (_a12 * 875407347 >> 32 >> 5) * (_a12 * 875407347 >> 32 >> 5) > 62) {
        _t54 = 98;
    } else {
        _t54 = 64;
    }
    _a12 = _t79 + _t66 + _t54;
    cc.code = 34817;
     *__esi = cc.code;
     *(__esi + 4) = _a12;
    return __esi;
}

Str wc_conv_from_big5(Str is, wc_ces ces)
{// addr = 0x080C3CB4
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    int state;
    _unknown_ _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    intOrPtr _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t97;
    _unknown_ _t102;
    _unknown_ _t111;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 = 0;
    _v28 = _v20;
    while(_v28 < _v24 && ( *_v28 & 255 & 4294967295) >= 0) {
    }
}

wc_push_to_big5(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C3E9C
    unsigned int _v16;
    unsigned int _v20;
    intOrPtr _v32;
    unsigned int _v36;
    unsigned int _v40;
    _unknown_ __ebp;
    unsigned int _t81;
    int _t88;
    int _t100;
    unsigned int _t115;
    int _t125;

    while(1) {
        _t81 = cc.ccs;
        if(_t81 == 34817) {
            break;
        }
        if(_t81 > 34817) {
            if(_t81 <= 34819) {
                _v40 = cc.ccs;
                _v36 = cc.code;
                 *__esp =  &(cc.ccs);
                wc_cs94w_to_big5();
                __esp = __esp - 4;
                break;
            }
            goto L7;
        }
        if(_t81 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t125 = os->length;
             *(os->ptr + _t125) = cc.code & 4294967295;
            os->length = _t125 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t81 == 16384) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplace);
            return;
        } else {
        }
L22:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t115 = 16384;
            } else {
                _t115 = 49152;
            }
            cc.ccs = _t115;
        } else {
            _v32 = _a16;
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &_v20;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v20;
            cc.code = _v16;
        }
        continue;
L7:
        if(_t81 == 49152) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplaceW);
            return;
        }
        goto L22;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t88 = os->length;
     *(os->ptr + _t88) = cc.code >> 8 & 4294967295;
    os->length = _t88 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t100 = os->length;
     *(os->ptr + _t100) = cc.code & 4294967295;
    os->length = _t100 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_big5(wc_uchar c, wc_status* st)
{// addr = 0x080C40A0
    signed int _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t39;
    signed int _t42;
    struct _Str* _t50;
    _unknown_ _t58;
    int _t74;

    _v16 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135791804 = Strnew_size(8);
    }
    _t39 = st->state;
    if(_t39 == 0) {
        _t42 =  *( &WC_BIG5_MAP + (_v16 & 255)) & 255 & 4294967295 & ;
        if(_t42 == 2) {
            goto L14;
        }
        goto L6;
L9:
        if( *135791804->length + 1 >=  *135791804->area_size) {
            Strgrow( *135791804);
        }
        _t50 =  *135791804;
        _t74 = _t50->length;
         *( *( *135791804) + _t74) = _v16 & 255 & 4294967295;
        _t50->length = _t74 + 1;
         *( *( *135791804) +  *135791804->length) = 0;
        goto L14;
    }
    if(_t39 == 1) {
        if(( *( &WC_BIG5_MAP + (_v16 & 255)) & 255 & 4294967295 &  & 4) != 0) {
            wtf_push( *135791804, 34817, (big5u & 255 & 4294967295 & ) << 8 | _v16 & 255);
        }
    }
L14:
    st->state = -1;
    return  *135791804;
L6:
    if(_t42 != 7) {
        goto L9;
    }
    big5u = _v16 & 255 & 4294967295;
    st->state = 1;
    return 0;
}

wc_bool wc_is_combining(wc_wchar_t cc)
{// addr = 0x080C41D8
    _unknown_ __ebp;
    signed int _t20;
    _unknown_ _t27;

    _t20 = cc.ccs & 65535;
    if(_t20 == 2073) {
        return  *( &cp1256_combining_map + (cc.code & 127)) & 255;
    }
    if(_t20 <= 2073) {
        if(_t20 == 2061) {
            return  *( &cp864_combining_map + (cc.code & 127)) & 255;
        }
        if(_t20 > 2061) {
            if(_t20 == 2065) {
                return  *( &cp874_combining_map + (cc.code & 127)) & 255;
            } else {
                if(_t20 == 2072) {
                    return  *( &cp1255_combining_map + (cc.code & 127)) & 255;
                } else {
                    return 0;
                }
            }
        }
        if(_t20 == 583) {
            return  *( &iso88596_combining_map + (cc.code & 127)) & 255;
        }
        if(_t20 == 596) {
            return  *( &iso885911_combining_map + (cc.code & 127)) & 255;
        }
        return 0;
    }
    if(_t20 == 4096) {
        return wc_is_ucs_combining(cc.code);
    }
    if(_t20 > 4096) {
        if(_t20 - 8192 > 1) {
            return 0;
        }
        return wc_is_ucs_combining(cc.code);
    } else {
        if(_t20 == 2075) {
            return  *( &cp1258_combining_map + (cc.code & 127)) & 255;
        }
        if(_t20 == 2077) {
            return  *( &tcvn5712_combining_map + (cc.code & 127)) & 255;
        }
        return 0;
    }
}

wc_wchar_t wc_gbk_ext_to_cs128w(wc_wchar_t cc)
{// addr = 0x080C42F4
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t25;
    _unknown_ _t42;

    __ecx = cc.ccs;
    _t42 = (_a12 >> 8 & 255) * (_a12 >> 8 & 255) + (_a12 & 255);
    if((_a12 & 255) > 127) {
        _t25 = 65;
    } else {
        _t25 = 64;
    }
    _a12 = _t42 - _t25 - 24510;
    if(_a12 > 16383) {
        cc.code = 34843;
        _a12 = _a12 - 16384;
    } else {
        cc.code = 34842;
    }
    _a12 = (_a12 >> 7 << 8) + (_a12 & 127);
     *__ecx = cc.code;
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_gbk_ext(wc_wchar_t cc)
{// addr = 0x080C438D
    signed int _v20;
    _unknown_ __ebx;
    _unknown_ __edi;
    struct  __esi;
    _unknown_ __ebp;
    _unknown_ _t46;
    _unknown_ _t54;
    _unknown_ _t59;
    unsigned int _t66;
    unsigned int _t67;
    _unknown_ _t71;
    _unknown_ _t76;
    _unknown_ _t80;
    _unknown_ _t84;
    signed int _t90;

    __esi = cc.ccs;
    _a12 = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
    if(cc.code == 34843) {
        _a12 = _a12 + 16384;
    }
    cc.code = 34841;
    _v20 = _a12 >> 1;
    _t90 = (_v20 * -1401515643 >> 32 >> 6) + 129 << 8;
    _t66 = _a12;
    _v20 = _t66 >> 1;
    _t71 = _t66 - _v20 * -1401515643 * (_v20 * -1401515643 >> 32 >> 6);
    _t67 = _a12;
    _v20 = _t67 >> 1;
    if(_t67 - (_v20 * -1401515643 >> 32 >> 6) * (_v20 * -1401515643 >> 32 >> 6) > 62) {
        _t59 = 65;
    } else {
        _t59 = 64;
    }
    _a12 = _t90 + _t71 + _t59;
     *__esi = cc.code;
     *(__esi + 4) = _a12;
    return __esi;
}

wc_ccs wc_gbk_or_gbk_ext(wc_uint16 code)
{// addr = 0x080C446B
    signed short _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t10;
    _unknown_ _t11;

    _v16 = code & 4294967295;
    if(wc_map3_range_search(_v16 & 65535,  &gbk_ext_ucs_map, 110) == 0) {
        return 34838;
    }
    return 34841;
}

wc_uint32 wc_gb18030_to_ucs(wc_wchar_t cc)
{// addr = 0x080C44A6
    wc_map3* map;
    int i;
    int min;
    int max;
    char _v12;
    wc_map3* _v16;
    signed int _v20;
    intOrPtr _v24;
    signed int _v28;
    unsigned int _v36;
    unsigned int _v40;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t88;
    unsigned int _t92;
    _unknown_ _t101;
    _unknown_ _t107;
    _unknown_ _t194;
    _unknown_ _t195;
    signed int _t200;

    __esp = __esp - 32;
    _t88 = cc.ccs & 65535;
    if(_t88 == 34841) {
L6:
        _v16 = wc_map3_range_search(cc.code & 4294967295 & ,  &gbk_ext_ucs_map, 110);
        if(_v16 == 0) {
            _t92 = -1;
        } else {
            _t200 =  *(_v16 + 4) & 65535 & 4294967295 & ;
            _t194 = (cc.code >> 8 & 255) * (cc.code >> 8 & 255) + (cc.code & 255);
            if((cc.code & 255) > 127) {
                _t101 = 65;
            } else {
                _t101 = 64;
            }
            _t195 = _t200 + _t194 - _t101;
            if(( *(_v16 + 2) & 65535 & 4294967295 &  & 255) > 127) {
                _t107 = 65;
            } else {
                _t107 = 64;
            }
            _t92 = _t195 + _t107 + ( *(_v16 + 2) & 65535 & 4294967295 & ) * ( *(_v16 + 2) & 65535 & 4294967295 & ) + 24510 - ( *(_v16 + 2) & 65535 & 4294967295 &  & 255) - 24510;
        }
        goto L33;
    }
    if(_t88 > 34841) {
        if(_t88 > 34843) {
            goto L17;
        } else {
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &(cc.ccs);
            wc_cs128w_to_gbk_ext();
            __esp = __esp - 4;
        }
        goto L6;
    }
    if(_t88 == 8194) {
        if(cc.code > -2127527633) {
            if(cc.code > -2077121479) {
L29:
                if(cc.code <= -1875869393 || cc.code > -483222987) {
                    _t92 = -1;
                } else {
                    _t92 = (((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) << 2) + ((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) + (((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) << 2) + ((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) + (cc.code & 255) - 1810682;
                }
L33:
                 &_v12 =  &_v12;
                return _t92;
            }
            _v24 = 0;
            _v28 = 205;
            cc.code = (((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) << 2) + ((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) + (((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) << 2) + ((cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) << 6) - (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 24 << 2) + (cc.code >> 24) + (cc.code >> 16 & 255) + (cc.code >> 8 & 255) + (cc.code & 255) - 1687218;
            if(cc.code < ( *(_v28 + _v28 + _v28 + _v28 + _v28 + _v28 + 135772644) & 65535 & 4294967295 & )) {
                while(1) {
L21:
                    _v20 = (_v24 + _v28 >> 31) + _v24 + _v28 >> 1;
                    if(_v24 == _v28) {
                        break;
                    }
                    goto L22;
                }
                goto L28;
            }
            _v20 = _v28;
L28:
            _t92 = ( *(_v20 + _v20 + _v20 + _v20 + _v20 + _v20 +  &ucs_gb18030_map) & 65535 & 4294967295 & ) + cc.code - ( *(_v20 + _v20 + _v20 + _v20 + _v20 + _v20 + 135772644) & 65535 & 4294967295 & );
            goto L33;
L22:
            if(cc.code >= ( *(_v20 + _v20 + _v20 + _v20 + _v20 + _v20 + 135772644) & 65535 & 4294967295 & )) {
                if(cc.code < ( *(_v20 + 1 + _v20 + 1 + _v20 + 1 + _v20 + 1 + _v20 + 1 + _v20 + 1 + 135772644) & 65535 & 4294967295 & )) {
                    goto L28;
                }
                goto L25;
            }
            _v28 = _v20 - 1;
            goto L21;
L25:
            _v24 = _v20 + 1;
            goto L21;
        }
        goto L29;
    } else {
    }
L17:
     *__esp = cc.ccs;
    _v40 = cc.code;
    _t92 = wc_any_to_ucs();
    goto L33;
}

wc_wchar_t wc_ucs_to_gb18030(wc_uint32 ucs)
{// addr = 0x080C47AD
    wc_wchar_t cc;
    wc_map3* map;
    wc_map3* _v32;
    signed int _v36;
    signed int _v40;
    signed int _v48;
    _unknown_ _v68;
    _unknown_ _v72;
    struct  __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t173;
    _unknown_ _t179;
    _unknown_ _t181;
    _unknown_ _t189;
    _unknown_ _t191;
    _unknown_ _t200;
    _unknown_ _t227;
    _unknown_ _t233;
    _unknown_ _t235;
    _unknown_ _t243;
    _unknown_ _t245;
    _unknown_ _t254;
    _unknown_ _t278;
    _unknown_ _t286;
    _unknown_ _t294;
    _unknown_ _t299;
    unsigned int _t306;
    unsigned int _t313;
    _unknown_ _t322;
    _unknown_ _t326;
    _unknown_ _t330;
    _unknown_ _t332;
    _unknown_ _t338;
    _unknown_ _t342;
    _unknown_ _t347;
    _unknown_ _t357;
    _unknown_ _t361;
    _unknown_ _t363;
    _unknown_ _t369;
    _unknown_ _t373;
    _unknown_ _t378;
    _unknown_ _t385;
    _unknown_ _t390;
    _unknown_ _t394;
    _unknown_ _t398;
    signed int _t404;
    unsigned int _t413;
    unsigned int _t414;

    __ebx = ucs;
    if(_a8 > 65535) {
        if(_a8 > 1114111) {
            goto L19;
        }
        goto L15;
    }
    _v32 = wc_map3_range_search(_a8 & 4294967295 & ,  &ucs_gbk_ext_map, 110);
    if(_v32 == 0) {
        _v32 = wc_map3_range_search(_a8 & 4294967295 & ,  &ucs_gb18030_map, 206);
        if(_v32 == 0) {
L19:
            _v40 = 16384;
             *__ebx = _v40;
             *(__ebx + 4) = _v36;
            return __ebx;
        }
        goto L10;
    }
    _t385 = ( *(_v32 + 4) & 65535 & 4294967295 & ) * ( *(_v32 + 4) & 65535 & 4294967295 & ) + -24510 + ( *(_v32 + 4) & 65535 & 4294967295 &  & 255);
    if(( *(_v32 + 4) & 65535 & 4294967295 &  & 255) > 127) {
        _t278 = 65;
    } else {
        _t278 = 64;
    }
    _v36 = _t385 - _t278 + _a8 - ( *_v32 & 65535 & 4294967295 & );
    _v48 = _v36 >> 1;
    _t404 = (_v48 * -1401515643 >> 32 >> 6) + 129 << 8;
    _t413 = _v36;
    _v48 = _t413 >> 1;
    _t322 = _t413 - _v48 * -1401515643 * (_v48 * -1401515643 >> 32 >> 6);
    _t414 = _v36;
    _v48 = _t414 >> 1;
    if(_t414 - (_v48 * -1401515643 >> 32 >> 6) * (_v48 * -1401515643 >> 32 >> 6) > 62) {
        _t299 = 65;
    } else {
        _t299 = 64;
    }
    _v36 = _t404 + _t322 + _t299;
    _v40 = 34841;
     *__ebx = _v40;
     *(__ebx + 4) = _v36;
    return __ebx;
L10:
    _v36 = ( *(_v32 + 4) & 65535 & 4294967295 & ) + _a8 - ( *_v32 & 65535 & 4294967295 & );
    _v48 = _v36 >> 3;
    _v48 = _v36 >> 2;
    _t311 = _v48 * 1745256553 >> 32 >> 7;
    _v48 = _v36;
    _t313 = _v48 * -858993459 >> 32 >> 3;
    _v48 = _t313 >> 1;
    _v36 = ((_v48 * 349051311 >> 32 >> 7) + 129 << 24) + ((_v48 * 1745256553 >> 32 >> 7) - (_t311 * -858993459 >> 32 >> 3 << 2) + (_t311 * -858993459 >> 32 >> 3) + (_t311 * -858993459 >> 32 >> 3 << 2) + (_t311 * -858993459 >> 32 >> 3) + 48 << 16) + (_t313 - ((_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) << 6) - (_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) + 129 << 8) + _v36 - (_v36 * -858993459 >> 32 >> 3 << 2) + (_v36 * -858993459 >> 32 >> 3) + (_v36 * -858993459 >> 32 >> 3 << 2) + (_v36 * -858993459 >> 32 >> 3) + 48;
    if(( *135119021 & 255 & 4294967295) == 0) {
        _v40 = 73730;
    } else {
        _v40 = wc_ucs_to_ccs(_a8) | 8194;
    }
     *__ebx = _v40;
     *(__ebx + 4) = _v36;
    return __ebx;
L15:
    _v36 = _a8 + 123464;
    _v48 = _v36 >> 3;
    _v48 = _v36 >> 2;
    _t304 = _v48 * 1745256553 >> 32 >> 7;
    _v48 = _v36;
    _t306 = _v48 * -858993459 >> 32 >> 3;
    _v48 = _t306 >> 1;
    _v36 = ((_v48 * 349051311 >> 32 >> 7) + 129 << 24) + ((_v48 * 1745256553 >> 32 >> 7) - (_t304 * -858993459 >> 32 >> 3 << 2) + (_t304 * -858993459 >> 32 >> 3) + (_t304 * -858993459 >> 32 >> 3 << 2) + (_t304 * -858993459 >> 32 >> 3) + 48 << 16) + (_t306 - ((_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) << 6) - (_v48 * -2113396605 >> 32 >> 5) + (_v48 * -2113396605 >> 32 >> 5) + 129 << 8) + _v36 - (_v36 * -858993459 >> 32 >> 3 << 2) + (_v36 * -858993459 >> 32 >> 3) + (_v36 * -858993459 >> 32 >> 3 << 2) + (_v36 * -858993459 >> 32 >> 3) + 48;
    if(( *135119021 & 255 & 4294967295) == 0) {
        _v40 = 73730;
    } else {
        _v40 = wc_ucs_to_ccs(_a8) | 8194;
    }
     *__ebx = _v40;
     *(__ebx + 4) = _v36;
    return __ebx;
}

Str wc_conv_from_gb18030(Str is, wc_ces ces)
{// addr = 0x080C4B76
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    int state;
    wc_uint32 gbk;
    wc_wchar_t cc;
    wc_uint32 ucs;
    struct _Str* _v16;
    unsigned char* _v20;
    unsigned char* _v24;
    unsigned char* _v28;
    unsigned int _v32;
    signed int _v36;
    unsigned int _v40;
    unsigned int _v44;
    unsigned int _v48;
    _unknown_ _v68;
    unsigned int _v72;
    _unknown_ __ebp;
    unsigned int _t174;
    signed int _t257;
    int _t266;
    _unknown_ _t273;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 = 0;
    _v28 = _v20;
L2:
    while(_v28 < _v24) {
        if(( *_v28 & 255 & 4294967295) >= 0) {
            _v28 =  &(_v28[1]);
            goto L2;
        }
        if(_v28 == _v24) {
            return is;
        }
        _v16 = Strnew_size(is->length);
        if(_v28 > _v20) {
            Strcat_charp_n(_v16, is->ptr, _v28 - _v20);
        }
        while(_v28 < _v24) {
            _t174 = _v32;
            if(_t174 == 1) {
                if(( *( &WC_GB18030_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                    if(( *( &WC_GB18030_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295) != 16) {
                        wtf_push_unknown(_v16, _v28 - 1, 2);
                        goto L33;
                    }
                    goto L31;
L33:
                    _v32 = 0;
                    goto L44;
                }
                goto L24;
L31:
                _v32 = 2;
                goto L44;
            }
            if(_t174 > 1) {
                if(_t174 == 2) {
                    if(( *( &WC_GB18030_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295) != 12) {
                        wtf_push_unknown(_v16, _v28 - 2, 3);
                        _v32 = 0;
                    } else {
                        _v32 = 3;
                    }
                    goto L44;
                }
                goto L13;
            }
            if(_t174 == 0) {
                _t257 =  *( &WC_GB18030_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                if(_t257 == 2) {
                    wtf_push_unknown(_v16, _v28, 1);
L22:
                    goto L44;
                }
                goto L16;
L19:
                if(_v16->length + 1 >= _v16->area_size) {
                    Strgrow(_v16);
                }
                _t266 = _v16->length;
                 *( *_v16 + _t266) =  *_v28 & 255 & 4294967295;
                _v16->length = _t266 + 1;
                 *( *_v16 + _v16->length) = 0;
                goto L44;
            } else {
L44:
                _v28 =  &(_v28[1]);
                continue;
            }
L16:
            if(_t257 != 12) {
                goto L19;
            }
            _v32 = 1;
            goto L22;
L13:
            if(_t174 == 3) {
                if(( *( &WC_GB18030_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295) != 16) {
L42:
                    wtf_push_unknown(_v16, _v28 - 3, 4);
                    goto L43;
                }
                goto L38;
L43:
                _v32 = 0;
            }
            goto L44;
L38:
            _v48 = 73730;
            _v44 =  *_v28 & 255 & 4294967295 &  | ( *(_v28 - 3) & 255 & 4294967295 & ) << 24 | ( *(_v28 - 2) & 255 & 4294967295 & ) << 16 | ( *(_v28 - 1) & 255 & 4294967295 & ) << 8;
            if(( *135119021 & 255 & 4294967295) == 0) {
L41:
                wtf_push(_v16, _v48, _v44);
                goto L43;
            }
             *__esp = _v48;
            _v72 = _v44;
            _v40 = wc_gb18030_to_ucs();
            if(_v40 == 255) {
                goto L41;
            }
            wtf_push(_v16, wc_ucs_to_ccs(_v40) | 8194, _v44);
            goto L43;
L24:
            _v36 =  *_v28 & 255 & 4294967295 &  | ( *(_v28 - 1) & 255 & 4294967295 & ) << 8;
            if(wc_gbk_or_gbk_ext(_v36 & 4294967295 & ) != 34841) {
                if(( *(_v28 - 1) & 255 & 4294967295) <= 160 || ( *_v28 & 255 & 4294967295) <= 160) {
                    wtf_push(_v16, 34838, _v36);
                } else {
                    wtf_push(_v16, wc_gb2312_or_gbk(_v36 & 4294967295 & ), _v36);
                }
            } else {
                wtf_push(_v16, 34841, _v36);
            }
            goto L33;
        }
    }
}

wc_push_to_gb18030(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C4FA9
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    signed int _t235;
    _unknown_ _t242;
    _unknown_ _t254;
    _unknown_ _t266;
    _unknown_ _t281;
    _unknown_ _t293;
    _unknown_ _t310;
    _unknown_ _t322;
    _unknown_ _t336;
    _unknown_ _t349;
    _unknown_ _t361;
    _unknown_ _t373;
    _unknown_ _t385;

    while(1) {
        _t235 = cc.ccs & 65535;
        if(_t235 > 34840) {
            goto L11;
        } else {
            goto L2;
        }
    }
}

Str wc_char_conv_from_gb18030(wc_uchar c, wc_status* st)
{// addr = 0x080C549B
    wc_uint32 gbk;
    wc_wchar_t cc;
    wc_uint32 ucs;
    signed int _v16;
    unsigned int _v20;
    unsigned int _v24;
    unsigned int _v28;
    signed int _v32;
    _unknown_ _v52;
    unsigned int _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t91;
    _unknown_ _t102;
    _unknown_ _t120;
    signed int _t142;
    struct _Str* _t148;
    _unknown_ _t156;
    int _t180;

    _v32 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135791812 = Strnew_size(8);
    }
    _t91 = st->state;
    if(_t91 == 1) {
        if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 255 & 4294967295 &  & 4) == 0) {
            if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 255 & 4294967295) != 16) {
                goto L32;
            }
            goto L24;
        }
        goto L17;
L24:
         *135791817 = _v32 & 255 & 4294967295;
        st->state = 2;
        return 0;
    }
    if(_t91 > 1) {
        if(_t91 == 2) {
            if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 255 & 4294967295) != 12) {
                goto L34;
            }
            goto L26;
        }
        goto L7;
L26:
         *135791818 = _v32 & 255 & 4294967295;
        st->state = 3;
        return 0;
    }
    if(_t91 == 0) {
        _t142 =  *( &WC_GB18030_MAP + (_v32 & 255)) & 255 & 4294967295 & ;
        if(_t142 == 2) {
            goto L34;
        }
        if(_t142 != 12) {
            goto L13;
        }
        gb = _v32 & 255 & 4294967295;
        st->state = 1;
        return 0;
L13:
        if( *135791812->length + 1 >=  *135791812->area_size) {
            Strgrow( *135791812);
        }
        _t148 =  *135791812;
        _t180 = _t148->length;
         *( *( *135791812) + _t180) = _v32 & 255 & 4294967295;
        _t148->length = _t180 + 1;
         *( *( *135791812) +  *135791812->length) = 0;
    }
L34:
    st->state = -1;
    return  *135791812;
L7:
    if(_t91 == 3) {
        if(( *( &WC_GB18030_MAP + (_v32 & 255)) & 255 & 4294967295) != 16) {
            goto L34;
        }
        goto L28;
        return __eax;
    }
    goto L34;
L28:
    _v28 = 73730;
    _v24 = _v32 & 255 | (gb & 255 & 4294967295 & ) << 24 | ( *135791817 & 255 & 4294967295 & ) << 16 | ( *135791818 & 255 & 4294967295 & ) << 8;
    if(( *135119021 & 255 & 4294967295) == 0) {
L31:
        wtf_push( *135791812, _v28, _v24);
        goto L34;
    }
     *__esp = _v28;
    _v56 = _v24;
    _v20 = wc_gb18030_to_ucs();
    if(_v20 == 255) {
        goto L31;
    }
    wtf_push( *135791812, wc_ucs_to_ccs(_v20) | 8194, _v24);
    goto L34;
L32:
    goto L34;
L17:
    _v16 = _v32 & 255 | (gb & 255 & 4294967295 & ) << 8;
    if(wc_gbk_or_gbk_ext(_v16 & 4294967295 & ) != 34841) {
        if((gb & 255 & 4294967295) <= 160 || _v32 <= 160) {
            wtf_push( *135791812, 34838, _v16);
        } else {
            wtf_push( *135791812, wc_gb2312_or_gbk(_v16 & 4294967295 & ), _v16);
        }
    } else {
        wtf_push( *135791812, 34841, _v16);
    }
    goto L34;
}

wc_ccs wc_gb2312_or_gbk(wc_uint16 code)
{// addr = 0x080C57A0
    signed short _v16;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t10;
    _unknown_ _t11;

    _v16 = code & 4294967295;
    if(wc_map_range_search(_v16 & 65535,  &gb2312_gbk_map, 7) == 0) {
        return 33089;
    }
    return 34838;
}

wc_wchar_t wc_gbk_to_cs128w(wc_wchar_t cc)
{// addr = 0x080C57DB
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t25;
    _unknown_ _t42;

    __ecx = cc.ccs;
    _t42 = (_a12 >> 8 & 255) * (_a12 >> 8 & 255) + (_a12 & 255);
    if((_a12 & 255) > 127) {
        _t25 = 65;
    } else {
        _t25 = 64;
    }
    _a12 = _t42 - _t25 - 24510;
    if(_a12 > 16383) {
        cc.code = 34840;
        _a12 = _a12 - 16384;
    } else {
        cc.code = 34839;
    }
    _a12 = (_a12 >> 7 << 8) + (_a12 & 127);
     *__ecx = cc.code;
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_gbk(wc_wchar_t cc)
{// addr = 0x080C5874
    signed int _v20;
    _unknown_ __ebx;
    _unknown_ __edi;
    struct  __esi;
    _unknown_ __ebp;
    _unknown_ _t46;
    _unknown_ _t54;
    _unknown_ _t59;
    unsigned int _t66;
    unsigned int _t67;
    _unknown_ _t71;
    _unknown_ _t76;
    _unknown_ _t80;
    _unknown_ _t84;
    signed int _t90;

    __esi = cc.ccs;
    _a12 = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
    if(cc.code == 34840) {
        _a12 = _a12 + 16384;
    }
    cc.code = 34838;
    _v20 = _a12 >> 1;
    _t90 = (_v20 * -1401515643 >> 32 >> 6) + 129 << 8;
    _t66 = _a12;
    _v20 = _t66 >> 1;
    _t71 = _t66 - _v20 * -1401515643 * (_v20 * -1401515643 >> 32 >> 6);
    _t67 = _a12;
    _v20 = _t67 >> 1;
    if(_t67 - (_v20 * -1401515643 >> 32 >> 6) * (_v20 * -1401515643 >> 32 >> 6) > 62) {
        _t59 = 65;
    } else {
        _t59 = 64;
    }
    _a12 = _t90 + _t71 + _t59;
     *__esi = cc.code;
     *(__esi + 4) = _a12;
    return __esi;
}

wc_uint32 wc_gbk_to_N(wc_uint32 c)
{// addr = 0x080C5952
    _unknown_ __ebp;
    _unknown_ _t47;
    _unknown_ _t59;
    _unknown_ _t71;
    _unknown_ _t83;
    _unknown_ _t95;
    _unknown_ _t107;
    _unknown_ _t119;
    _unknown_ _t138;
    _unknown_ _t142;
    _unknown_ _t146;
    _unknown_ _t150;
    _unknown_ _t154;
    _unknown_ _t158;
    _unknown_ _t162;

    if(c > 41376) {
        if(c > 41642) {
            if(c > 42656) {
                if(c > 42741) {
                    if(c > 43168) {
                        if(c > 43200) {
                            _t138 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
                            if((c & 255) > 127) {
                                _t47 = 65;
                                return _t138 - _t47 - (c >> 8) * (c >> 8) - 9338;
                            }
                            goto L31;
                        }
                        goto L26;
L31:
                        _t47 = 64;
                        return _t138 - _t47 - (c >> 8) * (c >> 8) - 9338;
                    }
                    goto L21;
L26:
                    _t142 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
                    if((c & 255) > 127) {
                        _t59 = 65;
                        return _t142 - _t59 - (c >> 8) * (c >> 8) - 9370;
                    }
                    _t59 = 64;
                    return _t142 - _t59 - (c >> 8) * (c >> 8) - 9370;
                }
                goto L16;
L21:
                _t146 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
                if((c & 255) > 127) {
                    _t71 = 65;
                    return _t146 - _t71 - (c >> 8) * (c >> 8) - 9344;
                }
                _t71 = 64;
                return _t146 - _t71 - (c >> 8) * (c >> 8) - 9344;
            }
            goto L11;
L16:
            _t150 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
            if((c & 255) > 127) {
                _t83 = 65;
                return _t150 - _t83 - (c >> 8) * (c >> 8) - 9429;
            }
            _t83 = 64;
            return _t150 - _t83 - (c >> 8) * (c >> 8) - 9429;
        }
        goto L6;
L11:
        _t154 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
        if((c & 255) > 127) {
            _t95 = 65;
            return _t154 - _t95 - (c >> 8) * (c >> 8) - 9366;
        }
        _t95 = 64;
        return _t154 - _t95 - (c >> 8) * (c >> 8) - 9366;
    }
    _t162 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) > 127) {
        _t119 = 65;
        return _t162 - _t119 - 24510;
    }
    _t119 = 64;
    return _t162 - _t119 - 24510;
L6:
    _t158 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) > 127) {
        _t107 = 65;
        return _t158 - _t107 - (c >> 8) * (c >> 8) - 9376;
    }
    _t107 = 64;
    return _t158 - _t107 - (c >> 8) * (c >> 8) - 9376;
}

Str wc_conv_from_gbk(Str is, wc_ces ces)
{// addr = 0x080C5BB1
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    int state;
    wc_uint32 gbk;
    _unknown_ _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    intOrPtr _v32;
    _unknown_ _v36;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t114;
    _unknown_ _t119;
    _unknown_ _t132;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 = 0;
    _v28 = _v20;
    while() {
    }
}

wc_push_to_gbk(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C5E0F
    unsigned int _v16;
    unsigned int _v20;
    intOrPtr _v32;
    unsigned int _v36;
    unsigned int _v40;
    _unknown_ __ebp;
    unsigned int _t135;
    int _t142;
    int _t154;
    unsigned int _t168;
    int _t179;
    int _t191;
    int _t205;
    int _t221;

    while(1) {
        _t135 = cc.ccs;
        if(_t135 == 33089) {
            break;
        }
        if(_t135 > 33089) {
            if(_t135 > 34840) {
                if(_t135 == 49152) {
                    if(( *135119022 & 255 & 4294967295) != 0) {
                        return ;
                    }
                    Strcat_charp(os, WcReplaceW);
                    return;
                }
                goto L12;
            }
            goto L8;
L12:
            goto L34;
        }
        if(_t135 == 2087) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t205 = os->length;
             *(os->ptr + _t205) = (cc.code | 128) & 4294967295;
            os->length = _t205 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        }
        if(_t135 == 16384) {
            if(( *135119022 & 255 & 4294967295) != 0) {
                return ;
            }
            Strcat_charp(os, WcReplace);
            return;
        }
        if(_t135 == 322) {
            if(os->length + 1 >= os->area_size) {
                Strgrow(os);
            }
            _t221 = os->length;
             *(os->ptr + _t221) = cc.code & 4294967295;
            os->length = _t221 + 1;
             *((char*)(os->ptr + os->length)) = 0;
            return;
        } else {
        }
L34:
        if(( *135119011 & 255 & 4294967295) == 0) {
            if((cc.ccs & 98304) == 0) {
                _t168 = 16384;
            } else {
                _t168 = 49152;
            }
            cc.ccs = _t168;
        } else {
            _v32 = _a16;
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &_v20;
            wc_any_to_any_ces();
            __esp = __esp - 4;
            cc.ccs = _v20;
            cc.code = _v16;
        }
        continue;
L8:
        if(_t135 >= 34839) {
            _v40 = cc.ccs;
            _v36 = cc.code;
             *__esp =  &(cc.ccs);
            wc_cs128w_to_gbk();
            __esp = __esp - 4;
            goto L25;
        }
        if(_t135 == 34838) {
            goto L25;
        }
        goto L34;
L25:
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t179 = os->length;
         *(os->ptr + _t179) = cc.code >> 8 & 4294967295;
        os->length = _t179 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        if(os->length + 1 >= os->area_size) {
            Strgrow(os);
        }
        _t191 = os->length;
         *(os->ptr + _t191) = cc.code & 4294967295;
        os->length = _t191 + 1;
         *((char*)(os->ptr + os->length)) = 0;
        return;
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t142 = os->length;
     *(os->ptr + _t142) = (cc.code >> 8 | 128) & 4294967295;
    os->length = _t142 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t154 = os->length;
     *(os->ptr + _t154) = (cc.code | 128) & 4294967295;
    os->length = _t154 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

Str wc_char_conv_from_gbk(wc_uchar c, wc_status* st)
{// addr = 0x080C6133
    wc_uint32 gbk;
    signed int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t51;
    signed int _t54;
    _unknown_ _t57;
    struct _Str* _t66;
    int _t94;

    _v32 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135791820 = Strnew_size(8);
    }
    _t51 = st->state;
    if(_t51 == 0) {
        _t54 =  *( &WC_GBK_MAP + (_v32 & 255)) & 255 & 4294967295 & ;
        if(_t54 == 12) {
            gbku = _v32 & 255 & 4294967295;
            st->state = 1;
            return 0;
        }
        if(_t54 == 20) {
            goto L10;
        }
        if(_t54 == 2) {
            goto L11;
        }
        if( *135791820->length + 1 >=  *135791820->area_size) {
            Strgrow( *135791820);
        }
        _t66 =  *135791820;
        _t94 = _t66->length;
         *( *( *135791820) + _t94) = _v32 & 255 & 4294967295;
        _t66->length = _t94 + 1;
         *( *( *135791820) +  *135791820->length) = 0;
        goto L21;
L11:
L15:
        goto L21;
L10:
        wtf_push( *135791820, 2087, _v32 & 255);
        goto L15;
    } else {
        if(_t51 == 1) {
            if(( *( &WC_GBK_MAP + (_v32 & 255)) & 255 & 4294967295 &  & 4) != 0) {
                _v16 = _v32 & 255 | (gbku & 255 & 4294967295 & ) << 8;
                if((gbku & 255 & 4294967295) <= 160 || _v32 <= 160) {
                    wtf_push( *135791820, 34838, _v16);
                } else {
                    wtf_push( *135791820, wc_gb2312_or_gbk(_v16 & 4294967295 & ), _v16);
                }
            }
        }
    }
L21:
    st->state = -1;
    return  *135791820;
}

wc_wchar_t wc_hkscs_to_cs128w(wc_wchar_t cc)
{// addr = 0x080C62D8
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t25;
    _unknown_ _t42;

    __ecx = cc.ccs;
    _t42 = (_a12 >> 8 & 255) * (_a12 >> 8 & 255) + (_a12 & 255);
    if((_a12 & 255) > 160) {
        _t25 = 98;
    } else {
        _t25 = 64;
    }
    _a12 = _t42 - _t25 - 21352;
    if(_a12 > 16383) {
        cc.code = 34849;
        _a12 = _a12 - 16384;
    } else {
        cc.code = 34848;
    }
    _a12 = (_a12 >> 7 << 8) + (_a12 & 127);
     *__ecx = cc.code;
     *(__ecx + 4) = _a12;
    return __ecx;
}

wc_wchar_t wc_cs128w_to_hkscs(wc_wchar_t cc)
{// addr = 0x080C6373
    signed int _v20;
    _unknown_ __ebx;
    _unknown_ __edi;
    struct  __esi;
    _unknown_ __ebp;
    _unknown_ _t42;
    _unknown_ _t50;
    _unknown_ _t55;
    _unknown_ _t67;
    _unknown_ _t70;
    _unknown_ _t72;
    _unknown_ _t74;
    signed int _t80;

    __esi = cc.ccs;
    _a12 = ((_a12 >> 8 & 127) << 7) + (_a12 & 127);
    if(cc.code == 34849) {
        _a12 = _a12 + 16384;
    }
    cc.code = 34847;
    _v20 = _a12;
    _t80 = (_v20 * 875407347 >> 32 >> 5) + 136 << 8;
    _t67 = _a12 - _a12 * 875407347 * (_t62 * 875407347 >> 32 >> 5);
    if(_a12 - (_a12 * 875407347 >> 32 >> 5) * (_a12 * 875407347 >> 32 >> 5) > 62) {
        _t55 = 98;
    } else {
        _t55 = 64;
    }
    _a12 = _t80 + _t67 + _t55;
     *__esi = cc.code;
     *(__esi + 4) = _a12;
    return __esi;
}

wc_uint32 wc_hkscs_to_N(wc_uint32 c)
{// addr = 0x080C643D
    _unknown_ __ebp;
    _unknown_ _t16;
    _unknown_ _t25;
    _unknown_ _t34;
    _unknown_ _t37;

    if(c > 41279) {
        _t34 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
        if((c & 255) > 160) {
            _t16 = 98;
            return _t34 - _t16 - 35325;
        }
        goto L6;
    }
    _t37 = (c >> 8 & 255) * (c >> 8 & 255) + (c & 255);
    if((c & 255) > 160) {
        _t25 = 98;
        return _t37 - _t25 - 21352;
    }
    _t25 = 64;
    return _t37 - _t25 - 21352;
L6:
    _t16 = 64;
    return _t34 - _t16 - 35325;
}

Str wc_conv_from_hkscs(Str is, wc_ces ces)
{// addr = 0x080C64D3
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    int state;
    wc_uint32 hkscs;
    struct _Str* _v16;
    unsigned char* _v20;
    unsigned char* _v24;
    unsigned char* _v28;
    unsigned int _v32;
    unsigned int _v36;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    unsigned int _t107;
    signed int _t112;
    int _t121;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 = 0;
    _v28 = _v20;
L2:
    while(_v28 < _v24) {
        if(( *_v28 & 255 & 4294967295) >= 0) {
            _v28 =  &(_v28[1]);
            goto L2;
        }
        if(_v28 == _v24) {
            return is;
        }
        _v16 = Strnew_size(is->length);
        if(_v28 > _v20) {
            Strcat_charp_n(_v16, is->ptr, _v28 - _v20);
        }
        while(_v28 < _v24) {
            _t107 = _v32;
            if(_t107 == 0) {
                _t112 =  *( &WC_HKSCS_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 & ;
                if(_t112 == 12 || _t112 == 16) {
                    _v32 = 1;
L20:
                } else {
                    if(_t112 == 2) {
                        goto L16;
                    }
                    if(_v16->length + 1 >= _v16->area_size) {
                        Strgrow(_v16);
                    }
                    _t121 = _v16->length;
                     *( *_v16 + _t121) =  *_v28 & 255 & 4294967295;
                    _v16->length = _t121 + 1;
                     *( *_v16 + _v16->length) = 0;
                }
                goto L28;
L16:
                wtf_push_unknown(_v16, _v28, 1);
                goto L20;
            } else {
                if(_t107 == 1) {
                    if(( *( &WC_HKSCS_MAP + ( *_v28 & 255 & 4294967295 & )) & 255 & 4294967295 &  & 4) == 0) {
                        wtf_push_unknown(_v16, _v28 - 1, 2);
                    } else {
                        _v36 =  *_v28 & 255 & 4294967295 &  | ( *(_v28 - 1) & 255 & 4294967295 & ) << 8;
                        if(( *(_v28 - 1) & 255 & 4294967295) <= 160 || ( *(_v28 - 1) & 255 & 4294967295) > 249) {
                            wtf_push(_v16, 34847, _v36);
                        } else {
                            wtf_push(_v16, 34817, _v36);
                        }
                    }
                    _v32 = 0;
                }
L28:
                _v28 =  &(_v28[1]);
                continue;
            }
        }
    }
}

wc_push_to_hkscs(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C6705
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    unsigned int _t126;
    _unknown_ _t133;
    _unknown_ _t145;
    _unknown_ _t157;
    _unknown_ _t172;
    _unknown_ _t184;
    _unknown_ _t201;

    while(1) {
        _t126 = cc.ccs;
        if(_t126 > 34819) {
            goto L7;
        } else {
            goto L2;
        }
    }
}

Str wc_char_conv_from_hkscs(wc_uchar c, wc_status* st)
{// addr = 0x080C69F7
    wc_uint32 hkscs;
    unsigned int _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    int _t47;
    signed int _t50;
    _unknown_ _t53;
    struct _Str* _t61;
    int _t86;

    _v32 = c & 4294967295;
    if(st->state == 255) {
        st->state = 0;
         *135791828 = Strnew_size(8);
    }
    _t47 = st->state;
    if(_t47 == 0) {
        _t50 =  *( &WC_HKSCS_MAP + (_v32 & 255)) & 255 & 4294967295 & ;
        if(_t50 == 12 || _t50 == 16) {
            hkscsu = _v32 & 255 & 4294967295;
            st->state = 1;
            return 0;
        }
        if(_t50 != 2) {
            if( *135791828->length + 1 >=  *135791828->area_size) {
                Strgrow( *135791828);
            }
            _t61 =  *135791828;
            _t86 = _t61->length;
             *( *( *135791828) + _t86) = _v32 & 255 & 4294967295;
            _t61->length = _t86 + 1;
             *( *( *135791828) +  *135791828->length) = 0;
        }
    } else {
        if(_t47 == 1) {
            if(( *( &WC_HKSCS_MAP + (_v32 & 255)) & 255 & 4294967295 &  & 4) != 0) {
                _v16 = _v32 & 255 | (hkscsu & 255 & 4294967295 & ) << 8;
                if((hkscsu & 255 & 4294967295) <= 160 || (hkscsu & 255 & 4294967295) > 249 || _v32 <= 160) {
                    wtf_push( *135791828, 34847, _v16);
                } else {
                    wtf_push( *135791828, 34817, _v16);
                }
            }
        }
    }
    st->state = -1;
    return  *135791828;
}

Str wc_conv_from_priv1(Str is, wc_ces ces)
{// addr = 0x080C6B7C
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    wc_ccs ccs;
    _unknown_ _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    intOrPtr _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t90;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v32 =  *((intOrPtr*)( *((intOrPtr*)(((ces & 255) << 5) + 135767980)) + 8));
    _v28 = _v20;
    while(_v28 < _v24 && ( *_v28 & 255 & 4294967295) >= 0) {
    }
}

Str wc_char_conv_from_priv1(wc_uchar c, wc_status* st)
{// addr = 0x080C6CAB
    Str os;
    struct _Str* _v16;
    signed int _v32;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    int _t41;

    _v32 = c & 4294967295;
    _v16 = Strnew_size(1);
    if((_v32 & 255 & 4294967295) >= 0) {
        if(_v16->length + 1 >= _v16->area_size) {
            Strgrow(_v16);
        }
        _t41 = _v16->length;
         *( *_v16 + _t41) = _v32 & 255 & 4294967295;
        _v16->length = _t41 + 1;
         *((char*)( *_v16 + _v16->length)) = 0;
        return _v16;
    }
    wtf_push(_v16,  *(st->ces_info->gset + 8), _v32 & 255);
    return _v16;
}

Str wc_conv_from_ascii(Str is, wc_ces ces)
{// addr = 0x080C6D46
    Str os;
    wc_uchar* sp;
    wc_uchar* ep;
    wc_uchar* p;
    _unknown_ _v16;
    char* _v20;
    char* _v24;
    char* _v28;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t79;

    _v20 = is->ptr;
    _v24 =  &(_v20[is->length]);
    _v28 = _v20;
    while(_v28 < _v24 && ( *_v28 & 255 & 4294967295) >= 0) {
    }
}

wc_push_to_raw(Str os, wc_wchar_t cc, wc_status* st)
{// addr = 0x080C6E57
    _unknown_ __ebp;
    unsigned int _t20;
    int _t27;

    _t20 = cc.ccs;
    if(_t20 != 322) {
        if(_t20 != 2088) {
            return ;
        }
    }
    if(os->length + 1 >= os->area_size) {
        Strgrow(os);
    }
    _t27 = os->length;
     *(os->ptr + _t27) = cc.code & 4294967295;
    os->length = _t27 + 1;
     *((char*)(os->ptr + os->length)) = 0;
    return;
}

L080C6EC0(signed int _a4, signed int _a8, signed int _a12, signed int _a16)
{
    signed int _v16;
    signed int _v20;
    signed int _v24;
    signed int _v28;
    signed int _v32;
    signed int _v36;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t73;
    _unknown_ _t75;
    signed int _t76;
    signed int _t77;
    signed int _t78;
    signed int _t79;
    signed int _t80;
    _unknown_ _t86;
    signed int _t90;
    _unknown_ _t94;
    signed int _t97;
    signed int _t99;
    signed int _t102;
    _unknown_ _t109;
    signed int _t111;
    _unknown_ _t112;
    _unknown_ _t113;
    _unknown_ _t116;
    _unknown_ _t117;
    _unknown_ _t118;
    _unknown_ _t119;
    _unknown_ _t120;
    _unknown_ _t121;
    _unknown_ _t122;
    signed int _t124;
    signed int _t127;
    _unknown_ _t128;
    signed int _t131;
    signed int _t135;

    _t90 = _a8;
    _t102 = _a4;
    _v20 = _a12;
    _v16 = _a16;
    _v24 = 0;
    if(_t90 >= 0) {
        _t102 =  ~_t102;
        asm("adc ecx, 0x0");
        _t90 =  ~_t90;
        _v24 = -1;
        __eflags = _v16;
        if(_v16 >= 0) {
L2:
            _t73 = _v16;
            _t124 = _t90;
            _t131 = _v20;
            _v20 = _t102;
            if(_t73 != 0) {
                __eflags = _t73 - _t90;
                if(__eflags <= 0) {
                    asm("bsr edx, eax");
                    _v28 = _t102 ^ 31;
                    if(__eflags != 0) {
L19:
                        _v32 = _t73 << (_v28 & 255 & 4294967295);
                        _t76 = 32 - _v28;
                        _v36 = _t131 << (_v28 & 255 & 4294967295);
                        _v32 = _t131 >> (_t76 & 4294967295) | _v32;
                        _t77 = _t124 << (_v28 & 255 & 4294967295) | _v20 >> (_t76 & 4294967295);
                        _t78 = _t77 / _v32;
                        _t135 = _t77 % _v32;
                        _t127 = _t78;
                        _t111 = _t78 * _v36 >> 32;
                        _t79 = _t78 * _v36;
                        __eflags = _t135 - _t111;
                        _v32 = _t111;
                        if(_t135 < _t111) {
L23:
                            _t97 = _t127 - 1;
                            goto L7;
                        }
                        goto L20;
                    }
                    __eflags = _t131 - _v20;
                    if(_t131 <= _v20) {
L16:
                        _t97 = 1;
                        goto L7;
                    }
                    __eflags = _t73 - _t90;
                    if(_t73 >= _t90) {
                        goto L6;
                    }
                    goto L16;
L20:
                    _t99 = _v28 & 255;
                    __eflags = _v20 << (_t99 & 4294967295) - _t79;
                    if(_v20 << (_t99 & 4294967295) >= _t79) {
L22:
                        _t97 = _t127;
                        goto L7;
                    }
                    __eflags = _t135 - _v32;
                    if(_t135 == _v32) {
                        goto L23;
                    }
                    goto L22;
                }
                goto L6;
            }
            if(_t131 <= _t90) {
                __eflags = _t131;
                if(_t131 == 0) {
                    _t131 = 1 / _t131;
                }
                _t97 = _v20 / _t131;
L7:
                _t80 = _t97;
                if(_v24 == 0) {
                    return _t80;
                }
                asm("adc edx, 0x0");
                return  ~_t80;
            }
            _t97 = _t102 / _t131;
            goto L7;
L6:
            _t97 = 0;
            goto L7;
        }
L18:
        _v20 =  ~_v20;
        asm("adc dword [ebp-0xc], 0x0");
        _v24 =  !_v24;
        _v16 =  ~_v16;
        goto L2;
    }
    if(_v16 >= 0) {
        goto L18;
    }
    goto L2;
}

L080C7040(signed int _a4, signed int _a8, signed char _a12, signed int _a16)
{
    _unknown_ _v16;
    signed int _v20;
    signed int _v32;
    signed int _v36;
    signed int _v40;
    signed int _v44;
    signed int _v48;
    unsigned int _v52;
    signed int _v56;
    signed int _v60;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t109;
    _unknown_ _t110;
    signed int _t119;
    signed int _t120;
    signed int _t121;
    _unknown_ _t129;
    _unknown_ _t130;
    _unknown_ _t132;
    _unknown_ _t134;
    _unknown_ _t137;
    signed int _t138;
    _unknown_ _t142;
    signed int _t153;
    _unknown_ _t158;
    signed int _t160;
    _unknown_ _t163;
    _unknown_ _t165;
    _unknown_ _t169;
    _unknown_ _t170;
    signed int _t171;
    _unknown_ _t172;
    _unknown_ _t173;
    _unknown_ _t174;
    signed int _t177;
    unsigned int _t181;
    char* _t185;

    _t138 = _a8;
    _t153 = _a4;
    _v36 = _a12;
    _v32 = _a16;
    _v48 = 0;
    if(_t138 >= 0) {
        _t153 =  ~_t153;
        asm("adc ecx, 0x0");
        _t138 =  ~_t138;
        _v48 = -1;
    }
    if(_v32 >= 0) {
        _v36 =  ~_v36;
        asm("adc dword [ebp-0x1c], 0x0");
        _v32 =  ~_v32;
    }
    _t109 = _v32;
    _t185 =  &_v20;
    _v52 = _t153;
    _v44 = _t153;
    _v40 = _v36;
    _t177 = _t138;
    if(_t109 != 0) {
        __eflags = _t109 - _t138;
        if(__eflags <= 0) {
            asm("bsr edx, eax");
            _v36 = _t153 ^ 31;
            if(__eflags != 0) {
                _v44 = 32 - _v36;
                _v60 = _v40 >> (_v44 & 255 & 4294967295) | _t109 << (_v36 & 255 & 4294967295);
                _v56 = _v40 << (_v36 & 255 & 4294967295);
                _t119 = _v52 >> (_v44 & 255 & 4294967295) | _t177 << (_v36 & 255 & 4294967295);
                _t120 = _t119 / _v60;
                _v40 = _v52 << (_v36 & 255 & 4294967295);
                _t181 = _t119 % _v60;
                _t160 = _t120 * _v56 >> 32;
                _t121 = _t120 * _v56;
                __eflags = _t181 - _t160;
                if(_t181 < _t160) {
L25:
                    _t121 = _t121 - _v56;
                    asm("sbb edx, [ebp-0x38]");
                } else {
                    __eflags = _v40 - _t121;
                    if(_v40 < _t121) {
                        __eflags = _t181 - _t160;
                        if(_t181 == _t160) {
                            goto L25;
                        }
                    }
                }
            } else {
                __eflags = _v40 - _v44;
                if(_v40 <= _v44) {
L23:
                    asm("sbb edi, eax");
                    _v44 = _v44 - _v40;
                } else {
                    __eflags = _t109 - _t177;
                    if(_t109 < _t177) {
                        goto L23;
                    }
                }
L14:
                _t185[4] = _t177;
                 *_t185 = _v44;
                goto L9;
            }
            asm("sbb edi, edx");
             *_t185 = _t181 << (_v44 & 255 & 4294967295) | _v40 - _t121 >> (_v36 & 255 & 4294967295);
            _t185[4] = _t181 >> (_v36 & 255 & 4294967295);
        } else {
             *_t185 = _t153;
            _t185[4] = _t138;
        }
L9:
        __eflags = _v48;
        if(_v48 == 0) {
            return _v20;
        }
L10:
        asm("adc edx, 0x0");
        return  ~_v20;
        goto L26;
    }
    if(_v40 <= _t138) {
        __eflags = _v40;
        if(_v40 == 0) {
            _v40 = 1 / _v40;
        }
        _t171 = _v44 % _v40;
    } else {
        _t171 = _t153 % _v40;
    }
     *_t185 = _t171;
    _t185[4] = 0;
    if(_v48 == 0) {
        return _v20;
    }
    goto L10;
}

L080C727A()
{
    return;
}

L080C7280(intOrPtr _a4, intOrPtr _a8)
{
    intOrPtr _v12;
    intOrPtr _v16;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t8;

    L080C727A();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __xstat();
    return;
}

L080C72C0(intOrPtr _a4, intOrPtr _a8)
{
    intOrPtr _v12;
    intOrPtr _v16;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t8;

    L080C727A();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __fxstat();
    return;
}

L080C7300(intOrPtr _a4, intOrPtr _a8)
{
    intOrPtr _v12;
    intOrPtr _v16;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t8;

    L080C727A();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __lxstat();
    return;
}

L080C7340()
{
    intOrPtr* __ebx;
    _unknown_ __ebp;

    __eax =  *135089892;
    if(__eax == 255) {
        return ;
    }
    __ebx = 135089892;
    asm("o16 nop ");
    while(1) {
L2:
        __ebx = __ebx - 4;
         *__eax();
        __eax =  *__ebx;
        if(__eax == 255) {
            break;
        }
    }
    return;
}

L080C7378()
{
    _unknown_ _t1;
    _unknown_ _t2;

    _pop(__ebx);
    L0804A650(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

L080C7378()
{
    _unknown_ _t1;
    _unknown_ _t2;

    _pop(__ebx);
    @rec 0x0804A650@L0804A650@(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

// Statistics:
//    1939 Register nodes
//    5685 Temporaries nodes
//     710 Casts
//   47032 Statements
//    2760 Labels
//    1740 Gotos
//    1513 Blocks
//  170637 Nodes
//    1477 Assembly nodes
//    6538 Unknown Types


