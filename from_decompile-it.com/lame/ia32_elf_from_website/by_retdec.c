//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <time.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;
typedef int16_t int15_t;
typedef int64_t int80_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker * e12;
    struct _IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_1 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_1 * e12;
    struct _IO_FILE_1 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_2 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_2 * e12;
    struct _IO_FILE_2 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_3 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_3 * e12;
    struct _IO_FILE_3 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_4 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_4 * e12;
    struct _IO_FILE_4 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_5 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_5 * e12;
    struct _IO_FILE_5 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_marker {
    struct _IO_marker * e0;
    struct _IO_FILE * e1;
    int32_t e2;
};

struct _IO_marker_1 {
    struct _IO_marker_1 * e0;
    struct _IO_FILE_1 * e1;
    int32_t e2;
};

struct _IO_marker_2 {
    struct _IO_marker_2 * e0;
    struct _IO_FILE_2 * e1;
    int32_t e2;
};

struct _IO_marker_3 {
    struct _IO_marker_3 * e0;
    struct _IO_FILE_3 * e1;
    int32_t e2;
};

struct _IO_marker_4 {
    struct _IO_marker_4 * e0;
    struct _IO_FILE_4 * e1;
    int32_t e2;
};

struct _IO_marker_5 {
    struct _IO_marker_5 * e0;
    struct _IO_FILE_5 * e1;
    int32_t e2;
};

struct anon_struct_1 {
    int32_t e0;
    int32_t e1;
    struct _IO_FILE_1 * e2;
    struct _IO_FILE_1 * e3;
    struct _IO_FILE_1 * e4;
    int32_t e5;
    int32_t e6;
    char e7[10];
    char e8[10];
    char e9[10];
    char e10[10];
    char e11[2048];
    int32_t e12;
};

struct anon_struct_1_0 {
    int32_t e0;
    int32_t e1;
    struct _IO_FILE_1 * e2;
    struct _IO_FILE_1 * e3;
    struct _IO_FILE_1 * e4;
    int32_t e5;
    int32_t e6;
    char e7[10];
    char e8[10];
    char e9[10];
    char e10[10];
    char e11[2048];
    int32_t e12;
};

struct anon_struct_2 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
};

struct anon_struct_3 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
};

struct anon_struct_5 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
};

struct anon_struct_6 {
    float64_t e0;
    float64_t e1;
    float64_t e2;
    float64_t e3;
};

struct anon_struct_8 {
    int32_t e0;
    int32_t e1;
    int32_t e2[14];
    int32_t e3;
    char e4[513];
    char e5[513];
    char e6[513];
    char e7[513];
};

struct blockAlign_struct {
    int32_t e0;
    int32_t e1;
};

struct IFF_AIFF_struct {
    int16_t e0;
    int32_t e1;
    int16_t e2;
    float64_t e3;
    int32_t e4;
    struct blockAlign_struct e5;
};

struct lame_global_struct {
    int32_t e0;
};

struct lame_global_struct_1 {
    int32_t e0;
};

struct lame_global_struct_2 {
    int32_t e0;
};

struct lame_global_struct_3 {
    int32_t e0;
};

struct lame_global_struct_4 {
    int32_t e0;
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

void __do_global_ctors_aux(void);
int32_t __i686_get_pc_thunk_bx(void);
int32_t __libc_csu_init(int32_t a1, int32_t a2, int32_t a3);
void _init(int32_t a1);
int32_t aiff_check2(struct IFF_AIFF_struct * pcm_aiff_data);
void apply_termcap_settings(struct anon_struct_1 * mfp);
void brhist_disp(struct lame_global_struct_4 * gf);
void brhist_disp_line(int32_t i, int32_t br_hist_TOT, int32_t br_hist_LR, int32_t full, int32_t frames);
int32_t brhist_init(struct lame_global_struct_4 * gf, int32_t bitrate_kbps_min, int32_t bitrate_kbps_max);
void brhist_init_package(struct lame_global_struct * gf);
void brhist_jump_back(void);
int32_t calculate_index(int32_t * array, uint32_t len, int32_t value);
int32_t check_aid(char * header);
void close_infile(void);
void CloseSndFile(int32_t input, struct _IO_FILE_2 * musicin);
void console_flush(void);
int32_t console_printf(char * format, ...);
void console_up(int32_t n_lines);
float64_t ConvertFromIeeeExtended(char * bytes);
void decoder_progress(struct anon_struct_5 * mp3data);
void decoder_progress_finish(void);
void deinit_console(struct anon_struct_1 * mfp);
int32_t digits(uint32_t number);
void display_bitrate(struct _IO_FILE_4 * fp, char * version, int32_t d, int32_t indx);
int32_t display_bitrates(struct _IO_FILE_4 * fp);
void encoder_progress(struct lame_global_struct_3 * gf);
void encoder_progress_begin(struct lame_global_struct_3 * gf, char * inPath, char * outPath);
void encoder_progress_end(struct lame_global_struct_3 * gf);
int32_t error_printf(char * format, ...);
int32_t filename_to_type(char * FileName);
void frame_dummy(void);
void frontend_close_console(void);
void frontend_debugf(char * format, char * ap);
void frontend_errorf(char * format, char * ap);
void frontend_msgf(char * format, char * ap);
int32_t frontend_open_console(void);
int32_t fskip(struct _IO_FILE_2 * fp, int32_t offset, int32_t whence);
void function_804a018(int32_t a1, int32_t a2);
void genre_list_handler(int32_t num, char * name, char * cookie);
int32_t get_audio(struct lame_global_struct_1 * gfp, int32_t (*buffer)[1152]);
int32_t get_audio16(struct lame_global_struct_1 * gfp, int16_t (*buffer)[1152]);
int32_t get_audio_common(struct lame_global_struct_1 * gfp, int32_t (*buffer)[1152], int16_t (*buffer16)[1152]);
float64_t GetCPUTime(void);
float64_t GetRealTime(void);
int32_t id3_tag(struct lame_global_struct_2 * gfp, int32_t type, int32_t enc, char * str);
int32_t init_console(struct anon_struct_1 * mfp);
struct _IO_FILE * init_files(struct lame_global_struct * gf, char * inPath, char * outPath, int32_t * enc_delay, int32_t * enc_padding);
void init_infile(struct lame_global_struct_1 * gfp, char * inPath, int32_t * enc_delay, int32_t * enc_padding);
struct _IO_FILE_2 * init_outfile(char * outPath, int32_t decode);
int32_t is_mpeg_file_format(int32_t input_file_format);
int32_t is_syncword_mp123(char * headerptr);
int32_t lame_decode_fromfile(struct _IO_FILE_2 * fd, int16_t * pcm_l, int16_t * pcm_r, struct anon_struct_2 * mp3data);
int32_t lame_decode_initfile(struct _IO_FILE_2 * fd, struct anon_struct_2 * mp3data, int32_t * enc_delay, int32_t * enc_padding);
int32_t lame_decoder(struct lame_global_struct * gfp, struct _IO_FILE * outf, int32_t skip_start, char * inPath, char * outPath, int32_t * enc_delay, int32_t * enc_padding);
int32_t lame_encoder(struct lame_global_struct * gf, struct _IO_FILE * outf, int32_t nogap, char * inPath, char * outPath);
int64_t lame_get_file_size(char * filename);
int32_t lame_set_stream_binary_mode(struct _IO_FILE_3 * fp);
int32_t lame_version_print(struct _IO_FILE_4 * fp);
int32_t local_strcasecmp(char * s1, char * s2);
int32_t long_help(struct lame_global_struct_2 * gfp, struct _IO_FILE_4 * fp, char * ProgramName, int32_t lessmode);
int32_t make_even_number_of_bytes_in_length(uint32_t x);
int32_t min_size_t(uint32_t a, uint32_t b);
int32_t my_console_printing(struct _IO_FILE_1 * fp, char * format, char * ap);
struct _IO_FILE_2 * OpenSndFile(struct lame_global_struct_1 * gfp, char * inPath, int32_t * enc_delay, int32_t * enc_padding);
int32_t parse_aiff_header(struct lame_global_struct_1 * gfp, struct _IO_FILE_2 * sf);
int32_t parse_args(struct lame_global_struct_2 * gfp, uint32_t argc, char ** argv, char * inPath, char * outPath, char ** nogap_inPath, int32_t * num_nogap);
int32_t parse_args_from_string(struct lame_global_struct * gfp, char * p, char * inPath, char * outPath);
int32_t parse_file_header(struct lame_global_struct_1 * gfp, struct _IO_FILE_2 * sf);
void parse_nogap_filenames(int32_t nogapout, char * inPath, char * outPath, char * outdir);
int32_t parse_wave_header(struct lame_global_struct_1 * gfp, struct _IO_FILE_2 * sf);
void presets_longinfo_dm(struct _IO_FILE_4 * msgfp);
int32_t presets_set(struct lame_global_struct_2 * gfp, int32_t fast, int32_t cbr, char * preset_name, char * ProgramName);
void print_lame_tag_leading_info(struct lame_global_struct * gf);
int32_t print_license(struct _IO_FILE_4 * fp);
void print_trailing_info(struct lame_global_struct * gf);
void progress_line(struct lame_global_struct_4 * gf, int32_t full, int32_t frames);
int32_t Read16BitsHighLow(struct _IO_FILE_5 * fp);
int32_t Read16BitsLowHigh(struct _IO_FILE_5 * fp);
int32_t Read32Bits(struct _IO_FILE_5 * fp);
int32_t Read32BitsHighLow(struct _IO_FILE_5 * fp);
int32_t read_samples_mp3(struct lame_global_struct_1 * gfp, struct _IO_FILE_2 * musicin, int16_t (*mpg123pcm)[1152]);
int32_t read_samples_pcm(struct _IO_FILE_2 * musicin, int32_t * sample_buffer, int32_t samples_to_read);
void ReadBytes(struct _IO_FILE_5 * fp, char * p, int32_t n);
float64_t ReadIeeeExtendedHighLow(struct _IO_FILE_5 * fp);
int32_t report_printf(char * format, ...);
int32_t resample_rate(float64_t freq);
void set_debug_file(char * fn);
int32_t set_id3_albumart(struct lame_global_struct_2 * gfp, char * file_name);
int32_t set_id3tag(struct lame_global_struct_2 * gfp, int32_t type, char * str);
int32_t short_help(struct lame_global_struct_2 * gfp, struct _IO_FILE_4 * fp, char * ProgramName);
int32_t stats_head(float64_t x, char * txt);
void stats_line(float64_t * stat);
int32_t stats_value(float64_t x);
void timestatus(struct lame_global_struct_3 * gfp);
void timestatus_finish(void);
void ts_calc_times(struct anon_struct_6 * tstime, int32_t sample_freq, uint32_t frameNum, int32_t totalframes, int32_t framesize);
void ts_time_decompose(uint32_t time_in_sec, char padded_char);
int32_t unknown_ffffffff(void);
int32_t unpack_read_samples(int32_t samples_to_read, int32_t bytes_per_sample, int32_t swap_order, int32_t * sample_buffer, struct _IO_FILE_2 * pcm_in);
int32_t usage(struct _IO_FILE_4 * fp, char * ProgramName);
void wait_for(struct _IO_FILE_4 * fp, int32_t lessmode);
void Write16BitsLowHigh(struct _IO_FILE_5 * fp, uint32_t i);
void Write32BitsLowHigh(struct _IO_FILE_5 * fp, uint32_t i);
int32_t write_xing_frame(struct lame_global_struct * gf, struct _IO_FILE * outf);
int32_t WriteWaveHeader(struct _IO_FILE_2 * fp, int32_t pcmbytes, int32_t freq, int32_t channels, int32_t bits);

// --------------------- Global Variables ---------------------

struct anon_struct_1_0 Console_IO = {
    .e0 = 0,
    .e1 = 0,
    .e2 = NULL,
    .e3 = NULL,
    .e4 = NULL,
    .e5 = 0,
    .e6 = 0,
    .e12 = 0
};
struct anon_struct_8 brhist = {
    .e0 = 0,
    .e1 = 0,
    .e3 = 0
};
int32_t disable_wav_header = 0;
int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // edx
int32_t flush_write = 0;
int32_t global = 0;
int32_t g5 = 0x90a00; // 0x80548b4
char * g6 = "\x1b\x5b\x41"; // 0x8054f47
char * g7 = "\x41\x69\x44\x01"; // 0x805540a
char * g8; // 0x80554a5
char * g9; // 0x8055592
int32_t g10 = -1; // 0x805aefc
int32_t g11 = 0; // 0x805b2e0
int32_t g12 = 0; // 0x805b3a0
struct _IO_FILE_2 * g13 = NULL; // 0x805b3a4
struct _IO_FILE_2 * g14 = NULL; // 0x805b3c0
int32_t g15 = 0; // 0x805b3d0
int32_t g16 = 0; // 0x805b3d4
int32_t g17 = 0; // 0x805b3d8
int32_t g18 = 0; // 0x805b3dc
struct _IO_FILE_2 * g19 = NULL; // 0x805b3e0
struct _IO_FILE_2 * g20 = NULL; // 0x805b3e4
int32_t g21 = 0; // 0x805b400
float64_t g22 = 0.0; // 0x805b408
struct anon_struct_6 * g23 = NULL; // 0x805b420
float64_t g24 = 0.0; // 0x805b428
float64_t g25 = 0.0; // 0x805b430
float64_t g26 = 0.0; // 0x805b440
float64_t g27 = 0.0; // 0x805b448
float64_t g28 = 0.0; // 0x805b450
float64_t g29 = 0.0; // 0x805b458
int32_t g30 = 0; // 0x805b460
int32_t g31 = 0; // 0x805b484
char * g32; // 0x805b488
int32_t g33 = 0; // 0x805b4c0
int32_t g34 = 0; // 0x805b4c4
int32_t g35 = 0; // 0x805b6c5
char * g36; // 0x805b8c6
int32_t g37 = 0; // 0x805bac7
struct _IO_FILE_1 * g38 = NULL; // 0x805bce8
struct _IO_FILE_1 * g39 = NULL; // 0x805bcec
struct _IO_FILE_1 * g40 = NULL; // 0x805bcf0
int32_t g41 = 0; // 0x805bcf4
char * g42; // 0x805bcfc
char g43 = 0; // 0x805bd06
int32_t g44 = 0; // 0x805c55c
int32_t g45 = 0; // 0x805c564
int32_t g46 = 0; // 0x805c568
int32_t g47 = 0; // 0x805c56c
int64_t g48 = 0; // 0x805c578
struct _IO_FILE_2 * g49 = NULL; // 0x805c57c
int32_t g50 = 0; // 0x805c580
int32_t g51 = 0; // 0x805c584
int32_t ignore_tag_errors = 0;
int32_t in_bitwidth = 16;
int32_t in_endian = 0;
int32_t in_signed = -1;
int32_t input_format = 0;
int32_t mp3_delay = 0;
int32_t mp3_delay_set = 0;
struct anon_struct_3 mp3input_data = {
    .e0 = 0,
    .e1 = 0,
    .e2 = 0,
    .e3 = 0,
    .e4 = 0,
    .e5 = 0,
    .e6 = 0,
    .e7 = 0,
    .e8 = 0,
    .e9 = 0
};
int32_t print_clipping_info = 0;
int32_t silent = 0;
float80_t g52 = 0.0L; // st0
float80_t g53 = 0.0L; // st1
float80_t g54 = 0.0L; // st2
float80_t g55 = 0.0L; // st3
float80_t g56 = 0.0L; // st4
float80_t g57 = 0.0L; // st5
float80_t g58 = 0.0L; // st6
float80_t g59 = 0.0L; // st7
int32_t swapbytes = 0;
float32_t update_interval = 0.0f;

// ------------------------ Functions -------------------------

// Address range: 0x804a00c - 0x804a017
void _init(int32_t a1) {
    // 0x804a00c
    int32_t v1;
    function_804a018(v1, g3);
}

// Address range: 0x804a018 - 0x804a03b
void function_804a018(int32_t a1, int32_t a2) {
    // 0x804a018
    int32_t v1;
    g3 = v1 + 0x10fdc;
    if (*(int32_t *)(v1 + 0x10fd8) != 0) {
        // 0x804a029
        __gmon_start();
        // branch -> 0x804a02e
    }
    // 0x804a02e
    frame_dummy();
    __do_global_ctors_aux();
    g3 = a2;
}

// Address range: 0x804ab60 - 0x804ab83
void frame_dummy(void) {
    // 0x804ab60
    return;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804ab84 - 0x804ac91
// Line range:    98 - 126
int32_t parse_args_from_string(struct lame_global_struct * gfp, char * p, char * inPath, char * outPath) {
    // 0x804ab84
    int32_t v1;
    char * v2 = (char *)v1; // bp-540
    int32_t v3;
    int32_t c = v3; // bp-28
    char * v4;
    char * f = v4; // bp-24
    char * v5;
    char * q = v5; // bp-20
    int32_t v6;
    int32_t v7 = &v6; // ebp
    f = NULL;
    if (p == NULL || *p == 0) {
        // 0x804ac90
        return 0;
    }
    char * mem = malloc(strlen(p) + 1); // 0x804abbf
    q = mem;
    strcpy(mem, p);
    v2 = "lhama";
    char * v8 = (char *)((int32_t)f + 1); // 0x804abed_8
    f = v8;
    int32_t v9 = (int32_t)mem; // 0x804ac8712
    // branch -> 0x804abf1
    while (true) {
        // 0x804abf1
        *(int32_t *)(v7 - 536 + 4 * (int32_t)v8) = v9;
        int32_t v10 = (int32_t)f + 1; // 0x804abfe
        f = (char *)v10;
        char * v11 = (char *)v9;
        char * v12 = v11;
        int32_t v13; // 0x804ac69
        if (*v11 == 32) {
            // 0x804ac1c
            if (*v12 != 0) {
                goto lab_0x804ac81_2;
            }
            // 0x804ac26
            *(int32_t *)(4 * v10 - 536 + v7) = 0;
            v13 = parse_args((struct lame_global_struct_2 *)gfp, (int32_t)f, &v2, inPath, outPath, NULL, NULL);
            c = v13;
            free(q);
            // branch -> 0x804ac90
            // 0x804ac90
            return c;
        }
        while (true) {
            // 0x804ac12
            if (*v11 != 0) {
                int32_t v14 = v9 + 1; // 0x804ac04
                char * v15 = (char *)v14;
                if (*v15 == 32) {
                    v12 = v15;
                    // break -> 0x804ac1c
                    break;
                }
                v11 = v15;
                v9 = v14;
                // continue -> 0x804ac12
                continue;
            } else {
                v12 = v11;
            }
            // 0x804ac1c
            if (*v12 != 0) {
              lab_0x804ac81_2:
                // 0x804ac81
                *v12 = 0;
                // branch -> 0x804abf1
                break;
            }
            // 0x804ac26
            *(int32_t *)(4 * v10 - 536 + v7) = 0;
            v13 = parse_args((struct lame_global_struct_2 *)gfp, (int32_t)f, &v2, inPath, outPath, NULL, NULL);
            c = v13;
            free(q);
            // branch -> 0x804ac90
            // 0x804ac90
            return c;
        }
        // 0x804ac1c
        if (*v12 != 0) {
            goto lab_0x804ac81_2;
        }
        // 0x804ac26
        *(int32_t *)(4 * v10 - 536 + v7) = 0;
        v13 = parse_args((struct lame_global_struct_2 *)gfp, (int32_t)f, &v2, inPath, outPath, NULL, NULL);
        c = v13;
        free(q);
        // branch -> 0x804ac90
        // 0x804ac90
        return c;
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804ac92 - 0x804ad39
// Line range:    133 - 158
struct _IO_FILE * init_files(struct lame_global_struct * gf, char * inPath, char * outPath, int32_t * enc_delay, int32_t * enc_padding) {
    if (strcmp("-", outPath) != 0) {
        // 0x804acaf
        if (strcmp(inPath, outPath) == 0) {
            // 0x804acc5
            error_printf("Input file and Output file are the same. Abort.\n");
            // branch -> 0x804ad38
            // 0x804ad38
            return NULL;
        }
    }
    // 0x804acd8
    init_infile((struct lame_global_struct_1 *)gf, inPath, enc_delay, enc_padding);
    int32_t v1 = (int32_t)gf; // 0x804acf8_0
    lame_get_decode_only(v1);
    struct _IO_FILE_2 * v2 = init_outfile(outPath, v1); // 0x804ad0d
    struct _IO_FILE * result; // 0x804ad39_2
    if (v2 == NULL) {
        // 0x804ad1b
        error_printf("Can't init outfile '%s'\n");
        result = NULL;
        // branch -> 0x804ad38
    } else {
        // 0x804ad35
        result = (struct _IO_FILE *)v2;
        // branch -> 0x804ad38
    }
    // 0x804ad38
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804ad3a - 0x804b4ef
// Line range:    174 - 347
int32_t lame_decoder(struct lame_global_struct * gfp, struct _IO_FILE * outf, int32_t skip_start, char * inPath, char * outPath, int32_t * enc_delay, int32_t * enc_padding) {
    int16_t v1[2][1152];
    int16_t v2[2][1152];
    void (*v3)(struct _IO_FILE *, char *, int32_t);
    void (*WriteFunction)(struct _IO_FILE *, char *, int32_t) = v3; // bp-32
    int32_t v4;
    int32_t i = v4; // bp-28
    int32_t v5;
    int32_t skip_end = v5; // bp-24
    int32_t v6;
    int32_t iread = v6; // bp-20
    iread = 0;
    int32_t v7 = (int32_t)gfp; // 0x804ad4c_0
    lame_get_num_channels(v7);
    WriteFunction = (void (*)(struct _IO_FILE *, char *, int32_t))v7;
    if (silent <= 9) {
        // 0x804ad68
        lame_get_in_samplerate((int32_t)gfp);
        g3 = strlen(inPath) < 27 ? (int32_t)"  " : (int32_t)"\n\t";
        strcmp(inPath, "-");
        console_printf("\rinput:  %s%s(%g kHz, %i channel%s, ");
        // branch -> 0x804ae05
    }
    // 0x804ae05
    int32_t v8; // 0x804b389
    int32_t v9; // 0x804b158_0
    int32_t v10; // 0x804b1dc_0
    int32_t v11; // 0x804b468_0
    int32_t v12; // 0x804b1ec
    float80_t v13; // 0x804b3e5
    int32_t v14;
    bool v15;
    float64_t v16;
    float64_t v17;
    float80_t v18;
    float80_t v19;
    int32_t v20; // 0x804b3ce
    bool v21; // 0x804b3f2
    int32_t v22; // 0x804b25a104
    int32_t v23; // 0x804b25a105228
    int32_t v24;
    switch (input_format) {
        default: {
            // 0x804b07e
            if (silent <= 9) {
                // 0x804b088
                console_printf("unknown");
                // branch -> 0x804b094
            }
            int32_t v25 = (int32_t)gfp; // 0x804b094_0
            lame_get_num_samples(v25);
            g49 = (struct _IO_FILE_2 *)v25;
            g48 = 1152;
            v24 = 0;
            // branch -> 0x804b0be
            // 0x804b0be
            v23 = v24;
            if (silent <= 9) {
                // 0x804b0cc
                g3 = strlen(outPath) < 46 ? (int32_t)"  " : (int32_t)"\n\t";
                strcmp(outPath, "-");
                console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
                if (v24 >= 1) {
                    // 0x804b123
                    console_printf("skipping initial %i samples (encoder+decoder delay)\n");
                    // branch -> 0x804b136
                }
                // 0x804b136
                if (iread >= 1) {
                    // 0x804b13c
                    console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
                    v23 = v24;
                    // branch -> 0x804b14f
                } else {
                    v23 = v24;
                }
            }
            // 0x804b14f
            if (disable_wav_header == 0) {
                // 0x804b158
                v9 = (int32_t)gfp;
                lame_get_in_samplerate(v9);
                WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                // branch -> 0x804b189
            }
            // 0x804b189
            i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
            g50 = (int64_t)(int32_t)g49 / g48;
            v10 = (int32_t)&v2;
            v22 = v23;
            v16 = -((v23 + iread));
            // branch -> 0x804b1dc
            while (true) {
                // 0x804b1dc
                v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                v17 = v16;
                if (v12 >= 0) {
                  lab_0x804b1fe_11:;
                    int32_t v26 = (int32_t)((0x100000000 * (int64_t)(v12 >> 31) | (int64_t)v12) / g48) + g51; // 0x804b21d
                    g51 = v26;
                    float80_t v27 = v16;
                    g58 = v27;
                    float80_t v28 = v27 + (float80_t)v12; // 0x804b22b
                    g59 = v28;
                    float64_t v29 = v28;
                    if (silent <= 0) {
                        // 0x804b239
                        decoder_progress((struct anon_struct_5 *)&mp3input_data);
                        console_flush();
                        v26 = g51;
                        // branch -> 0x804b24a
                    }
                    int32_t v30 = v12 > v22 ? v22 : v12; // 0x804b1ec
                    skip_end = v30;
                    int32_t v31 = v22 - v30; // 0x804b25a
                    int32_t v32 = iread; // 0x804b25d
                    int32_t v33;
                    int32_t v34; // 0x804b295
                    if (v32 < 1153) {
                        // after_if_804b250_0.dec_label_pc_804b28f_crit_edge
                        v34 = g50;
                        // branch -> 0x804b28f
                    } else {
                        int32_t v35 = g50; // 0x804b26e
                        if (v26 + 2 > v35) {
                            // 0x804b277
                            iread = 1152;
                            v33 = 1152 - v32 + v12;
                            // branch -> 0x804b35b
                          lab_0x804b35b_2:
                            // 0x804b35b
                            if (v30 < v33) {
                                while (true) {
                                    // 0x804b2b7
                                    if (disable_wav_header == 0) {
                                        int16_t v36 = *(int16_t *)(2 * v30 - 0x1228 + g2); // 0x804b319
                                        Write16BitsLowHigh((struct _IO_FILE_5 *)outf, (int32_t)v36);
                                        if (WriteFunction == (void (*)(struct _IO_FILE *, char *, int32_t))2) {
                                            int16_t v37 = *(int16_t *)(g2 - 0x1228 + 2 * (skip_end + 1152)); // 0x804b33f
                                            Write16BitsLowHigh((struct _IO_FILE_5 *)outf, (int32_t)v37);
                                            // branch -> 0x804b357
                                        }
                                    } else {
                                        int32_t v38 = 2 * v30; // 0x804b2c9
                                        g4 = v38;
                                        g1 = i;
                                        ((int32_t (*)(int32_t, int32_t, int32_t))i)((int32_t)outf, v38 + v10, 2);
                                        if (WriteFunction == (void (*)(struct _IO_FILE *, char *, int32_t))2) {
                                            int32_t v39 = 2 * skip_end + 2304; // 0x804b2f9
                                            g4 = v39;
                                            g1 = i;
                                            ((int32_t (*)(int32_t, int32_t, int32_t))i)((int32_t)outf, v39 + v10, 2);
                                            // branch -> 0x804b357
                                        }
                                    }
                                    int32_t v40 = skip_end + 1; // 0x804b357
                                    skip_end = v40;
                                    if (v40 >= v33) {
                                        // break (via goto) -> 0x804b367
                                        goto lab_0x804b367;
                                    }
                                    v30 = v40;
                                    // continue -> 0x804b2b7
                                }
                                int32_t v41 = flush_write; // 0x804b367
                                if (v41 == 1) {
                                  lab_0x804b371:
                                    // 0x804b371
                                    fflush(outf);
                                    // branch -> 0x804b37c
                                }
                              lab_0x804b37c:
                                // 0x804b37c
                                if (v33 <= 0) {
                                    v17 = v29;
                                    // break (via goto) -> 0x804b386
                                    goto lab_0x804b386;
                                }
                                v22 = v31;
                                v16 = v29;
                                // continue -> 0x804b1dc
                                continue;
                            }
                          lab_0x804b367:
                            // 0x804b367
                            if (flush_write == 1) {
                                goto lab_0x804b371;
                            }
                            goto lab_0x804b37c;
                        } else {
                            v34 = v35;
                        }
                    }
                    // 0x804b28f
                    v33 = v26 != v34 ? v12 : 0;
                    if (v12 == 0 || v26 != v34) {
                        goto lab_0x804b35b_2;
                    }
                    // 0x804b2ac
                    v33 = v12 - v32;
                    // branch -> 0x804b35b
                    goto lab_0x804b35b_2;
                }
                // 0x804b386
                v8 = 2 * (int32_t)WriteFunction;
                skip_end = v8;
                v18 = v17;
                v14 = 0;
                if (v17 >= 0.0) {
                    // if_804b393_0_false
                    if (v17 <= 0.0) {
                        // if_804b393_1_false
                        v14 = v17 != 0.0;
                        // branch -> after_if_804b393_0
                    } else {
                        v14 = 1;
                    }
                }
                // after_if_804b393_0
                if ((v14 || v8 & -256) != 1) {
                    // 0x804b39e
                    if (silent <= 9) {
                        // 0x804b3a8
                        error_printf("WAVE file contains 0 PCM samples\n");
                        // branch -> 0x804b3b4
                    }
                    // 0x804b3b4
                    // branch -> 0x804b425
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
                // 0x804b3bb
                v20 = 0xffffffffffffffd0 / (int64_t)v8;
                v13 = v20;
                v15 = false;
                v21 = false;
                if (v18 <= v13) {
                    // if_804b3ee_0_false
                    if (v18 >= v13) {
                        // if_804b3ee_1_false
                        v15 = v18 != v13;
                        v21 = true;
                        // branch -> after_if_804b3ee_0
                    } else {
                        v15 = true;
                        v21 = false;
                    }
                }
                // after_if_804b3ee_0
                if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                    // 0x804b41a
                    v19 = v18 * (float80_t)v8;
                    // branch -> 0x804b425
                } else {
                    // 0x804b3f9
                    if (silent <= 9) {
                        // 0x804b403
                        error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                        // branch -> 0x804b40f
                    }
                    // 0x804b40f
                    v19 = 4294967248.0L;
                    // branch -> 0x804b425
                }
                // 0x804b425
                if (disable_wav_header == 0) {
                    // 0x804b432
                    if (strcmp("-", outPath) != 0) {
                        // 0x804b449
                        if (fseek(outf, 0, SEEK_SET) == 0) {
                            // 0x804b468
                            v11 = (int32_t)gfp;
                            lame_get_in_samplerate(v11);
                            v1[0][1] = 64;
                            v1[0][0] = 3136;
                            WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                            // branch -> 0x804b4c8
                        }
                    }
                }
                // 0x804b4c8
                fclose(outf);
                if (silent <= 0) {
                    // 0x804b4dc
                    decoder_progress_finish();
                    // branch -> 0x804b4e1
                }
                // 0x804b4e1
                return 0;
            }
        }
        case 1: {
            // 0x804afd0
            if (silent <= 9) {
                // 0x804afda
                console_printf("raw PCM data");
                // branch -> 0x804afe6
            }
            int32_t v42 = (int32_t)gfp; // 0x804afe6_0
            lame_get_num_samples(v42);
            g49 = (struct _IO_FILE_2 *)v42;
            g48 = 1152;
            v24 = 0;
            // branch -> 0x804b0be
            // 0x804b0be
            v23 = v24;
            if (silent <= 9) {
                // 0x804b0cc
                g3 = strlen(outPath) < 46 ? (int32_t)"  " : (int32_t)"\n\t";
                strcmp(outPath, "-");
                console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
                if (v24 >= 1) {
                    // 0x804b123
                    console_printf("skipping initial %i samples (encoder+decoder delay)\n");
                    // branch -> 0x804b136
                }
                // 0x804b136
                if (iread >= 1) {
                    // 0x804b13c
                    console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
                    v23 = v24;
                    // branch -> 0x804b14f
                } else {
                    v23 = v24;
                }
            }
            // 0x804b14f
            if (disable_wav_header == 0) {
                // 0x804b158
                v9 = (int32_t)gfp;
                lame_get_in_samplerate(v9);
                WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                // branch -> 0x804b189
            }
            // 0x804b189
            i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
            g50 = (int64_t)(int32_t)g49 / g48;
            v10 = (int32_t)&v2;
            v22 = v23;
            v16 = -((v23 + iread));
            // branch -> 0x804b1dc
            while (true) {
                // 0x804b1dc
                v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                if (v12 >= 0) {
                    goto lab_0x804b1fe_11;
                }
                v17 = v16;
                // 0x804b386
                v8 = 2 * (int32_t)WriteFunction;
                skip_end = v8;
                v18 = v17;
                v14 = 0;
                if (v17 >= 0.0) {
                    // if_804b393_0_false
                    if (v17 <= 0.0) {
                        // if_804b393_1_false
                        v14 = v17 != 0.0;
                        // branch -> after_if_804b393_0
                    } else {
                        v14 = 1;
                    }
                }
                // after_if_804b393_0
                if ((v14 || v8 & -256) != 1) {
                    // 0x804b39e
                    if (silent <= 9) {
                        // 0x804b3a8
                        error_printf("WAVE file contains 0 PCM samples\n");
                        // branch -> 0x804b3b4
                    }
                    // 0x804b3b4
                    // branch -> 0x804b425
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
                // 0x804b3bb
                v20 = 0xffffffffffffffd0 / (int64_t)v8;
                v13 = v20;
                v15 = false;
                v21 = false;
                if (v18 <= v13) {
                    // if_804b3ee_0_false
                    if (v18 >= v13) {
                        // if_804b3ee_1_false
                        v15 = v18 != v13;
                        v21 = true;
                        // branch -> after_if_804b3ee_0
                    } else {
                        v15 = true;
                        v21 = false;
                    }
                }
                // after_if_804b3ee_0
                if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                    // 0x804b41a
                    v19 = v18 * (float80_t)v8;
                    // branch -> 0x804b425
                } else {
                    // 0x804b3f9
                    if (silent <= 9) {
                        // 0x804b403
                        error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                        // branch -> 0x804b40f
                    }
                    // 0x804b40f
                    v19 = 4294967248.0L;
                    // branch -> 0x804b425
                }
                // 0x804b425
                if (disable_wav_header == 0) {
                    // 0x804b432
                    if (strcmp("-", outPath) != 0) {
                        // 0x804b449
                        if (fseek(outf, 0, SEEK_SET) == 0) {
                            // 0x804b468
                            v11 = (int32_t)gfp;
                            lame_get_in_samplerate(v11);
                            v1[0][1] = 64;
                            v1[0][0] = 3136;
                            WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                            // branch -> 0x804b4c8
                        }
                    }
                }
                // 0x804b4c8
                fclose(outf);
                if (silent <= 0) {
                    // 0x804b4dc
                    decoder_progress_finish();
                    // branch -> 0x804b4e1
                }
                // 0x804b4e1
                return 0;
            }
        }
        case 2: {
            // 0x804b00c
            if (silent <= 9) {
                // 0x804b016
                console_printf("Microsoft WAVE");
                // branch -> 0x804b022
            }
            int32_t v43 = (int32_t)gfp; // 0x804b022_0
            lame_get_num_samples(v43);
            g49 = (struct _IO_FILE_2 *)v43;
            g48 = 1152;
            v24 = 0;
            // branch -> 0x804b0be
            // 0x804b0be
            v23 = v24;
            if (silent <= 9) {
                // 0x804b0cc
                g3 = strlen(outPath) < 46 ? (int32_t)"  " : (int32_t)"\n\t";
                strcmp(outPath, "-");
                console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
                if (v24 >= 1) {
                    // 0x804b123
                    console_printf("skipping initial %i samples (encoder+decoder delay)\n");
                    // branch -> 0x804b136
                }
                // 0x804b136
                if (iread >= 1) {
                    // 0x804b13c
                    console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
                    v23 = v24;
                    // branch -> 0x804b14f
                } else {
                    v23 = v24;
                }
            }
            // 0x804b14f
            if (disable_wav_header == 0) {
                // 0x804b158
                v9 = (int32_t)gfp;
                lame_get_in_samplerate(v9);
                WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                // branch -> 0x804b189
            }
            // 0x804b189
            i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
            g50 = (int64_t)(int32_t)g49 / g48;
            v10 = (int32_t)&v2;
            v22 = v23;
            v16 = -((v23 + iread));
            // branch -> 0x804b1dc
            while (true) {
                // 0x804b1dc
                v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                if (v12 >= 0) {
                    goto lab_0x804b1fe_11;
                }
                v17 = v16;
                // 0x804b386
                v8 = 2 * (int32_t)WriteFunction;
                skip_end = v8;
                v18 = v17;
                v14 = 0;
                if (v17 >= 0.0) {
                    // if_804b393_0_false
                    if (v17 <= 0.0) {
                        // if_804b393_1_false
                        v14 = v17 != 0.0;
                        // branch -> after_if_804b393_0
                    } else {
                        v14 = 1;
                    }
                }
                // after_if_804b393_0
                if ((v14 || v8 & -256) != 1) {
                    // 0x804b39e
                    if (silent <= 9) {
                        // 0x804b3a8
                        error_printf("WAVE file contains 0 PCM samples\n");
                        // branch -> 0x804b3b4
                    }
                    // 0x804b3b4
                    // branch -> 0x804b425
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
                // 0x804b3bb
                v20 = 0xffffffffffffffd0 / (int64_t)v8;
                v13 = v20;
                v15 = false;
                v21 = false;
                if (v18 <= v13) {
                    // if_804b3ee_0_false
                    if (v18 >= v13) {
                        // if_804b3ee_1_false
                        v15 = v18 != v13;
                        v21 = true;
                        // branch -> after_if_804b3ee_0
                    } else {
                        v15 = true;
                        v21 = false;
                    }
                }
                // after_if_804b3ee_0
                if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                    // 0x804b41a
                    v19 = v18 * (float80_t)v8;
                    // branch -> 0x804b425
                } else {
                    // 0x804b3f9
                    if (silent <= 9) {
                        // 0x804b403
                        error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                        // branch -> 0x804b40f
                    }
                    // 0x804b40f
                    v19 = 4294967248.0L;
                    // branch -> 0x804b425
                }
                // 0x804b425
                if (disable_wav_header == 0) {
                    // 0x804b432
                    if (strcmp("-", outPath) != 0) {
                        // 0x804b449
                        if (fseek(outf, 0, SEEK_SET) == 0) {
                            // 0x804b468
                            v11 = (int32_t)gfp;
                            lame_get_in_samplerate(v11);
                            v1[0][1] = 64;
                            v1[0][0] = 3136;
                            WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                            // branch -> 0x804b4c8
                        }
                    }
                }
                // 0x804b4c8
                fclose(outf);
                if (silent <= 0) {
                    // 0x804b4dc
                    decoder_progress_finish();
                    // branch -> 0x804b4e1
                }
                // 0x804b4e1
                return 0;
            }
        }
        case 3: {
            // 0x804b045
            if (silent <= 9) {
                // 0x804b04f
                console_printf("SGI/Apple AIFF");
                // branch -> 0x804b05b
            }
            int32_t v44 = (int32_t)gfp; // 0x804b05b_0
            lame_get_num_samples(v44);
            g49 = (struct _IO_FILE_2 *)v44;
            g48 = 1152;
            v24 = 0;
            // branch -> 0x804b0be
            // 0x804b0be
            v23 = v24;
            if (silent <= 9) {
                // 0x804b0cc
                g3 = strlen(outPath) < 46 ? (int32_t)"  " : (int32_t)"\n\t";
                strcmp(outPath, "-");
                console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
                if (v24 >= 1) {
                    // 0x804b123
                    console_printf("skipping initial %i samples (encoder+decoder delay)\n");
                    // branch -> 0x804b136
                }
                // 0x804b136
                if (iread >= 1) {
                    // 0x804b13c
                    console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
                    v23 = v24;
                    // branch -> 0x804b14f
                } else {
                    v23 = v24;
                }
            }
            // 0x804b14f
            if (disable_wav_header == 0) {
                // 0x804b158
                v9 = (int32_t)gfp;
                lame_get_in_samplerate(v9);
                WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                // branch -> 0x804b189
            }
            // 0x804b189
            i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
            g50 = (int64_t)(int32_t)g49 / g48;
            v10 = (int32_t)&v2;
            v22 = v23;
            v16 = -((v23 + iread));
            // branch -> 0x804b1dc
            while (true) {
                // 0x804b1dc
                v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                if (v12 >= 0) {
                    goto lab_0x804b1fe_11;
                }
                v17 = v16;
                // 0x804b386
                v8 = 2 * (int32_t)WriteFunction;
                skip_end = v8;
                v18 = v17;
                v14 = 0;
                if (v17 >= 0.0) {
                    // if_804b393_0_false
                    if (v17 <= 0.0) {
                        // if_804b393_1_false
                        v14 = v17 != 0.0;
                        // branch -> after_if_804b393_0
                    } else {
                        v14 = 1;
                    }
                }
                // after_if_804b393_0
                if ((v14 || v8 & -256) != 1) {
                    // 0x804b39e
                    if (silent <= 9) {
                        // 0x804b3a8
                        error_printf("WAVE file contains 0 PCM samples\n");
                        // branch -> 0x804b3b4
                    }
                    // 0x804b3b4
                    // branch -> 0x804b425
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
                // 0x804b3bb
                v20 = 0xffffffffffffffd0 / (int64_t)v8;
                v13 = v20;
                v15 = false;
                v21 = false;
                if (v18 <= v13) {
                    // if_804b3ee_0_false
                    if (v18 >= v13) {
                        // if_804b3ee_1_false
                        v15 = v18 != v13;
                        v21 = true;
                        // branch -> after_if_804b3ee_0
                    } else {
                        v15 = true;
                        v21 = false;
                    }
                }
                // after_if_804b3ee_0
                if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                    // 0x804b41a
                    v19 = v18 * (float80_t)v8;
                    // branch -> 0x804b425
                } else {
                    // 0x804b3f9
                    if (silent <= 9) {
                        // 0x804b403
                        error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                        // branch -> 0x804b40f
                    }
                    // 0x804b40f
                    v19 = 4294967248.0L;
                    // branch -> 0x804b425
                }
                // 0x804b425
                if (disable_wav_header == 0) {
                    // 0x804b432
                    if (strcmp("-", outPath) != 0) {
                        // 0x804b449
                        if (fseek(outf, 0, SEEK_SET) == 0) {
                            // 0x804b468
                            v11 = (int32_t)gfp;
                            lame_get_in_samplerate(v11);
                            v1[0][1] = 64;
                            v1[0][0] = 3136;
                            WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                            // branch -> 0x804b4c8
                        }
                    }
                }
                // 0x804b4c8
                fclose(outf);
                if (silent <= 0) {
                    // 0x804b4dc
                    decoder_progress_finish();
                    // branch -> 0x804b4e1
                }
                // 0x804b4e1
                return 0;
            }
        }
        case 4: {
            int32_t v45 = skip_start + 241; // 0x804af66
            if (silent <= 9) {
                int32_t v46 = (int32_t)gfp; // 0x804af7b_0
                lame_get_out_samplerate(v46);
                g3 = v46 > 0x3e7f ? (int32_t)&g5 : (int32_t)".5";
                lame_get_version((int32_t)gfp);
                console_printf("MPEG-%u%s Layer %s");
                v24 = v45;
                // branch -> 0x804b0be
                // 0x804b0be
                v23 = v24;
                if (silent <= 9) {
                    // 0x804b0cc
                    g3 = strlen(outPath) < 46 ? (int32_t)"  " : (int32_t)"\n\t";
                    strcmp(outPath, "-");
                    console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
                    if (v24 >= 1) {
                        // 0x804b123
                        console_printf("skipping initial %i samples (encoder+decoder delay)\n");
                        // branch -> 0x804b136
                    }
                    // 0x804b136
                    if (iread >= 1) {
                        // 0x804b13c
                        console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
                        v23 = v24;
                        // branch -> 0x804b14f
                    } else {
                        v23 = v24;
                    }
                }
                // 0x804b14f
                if (disable_wav_header == 0) {
                    // 0x804b158
                    v9 = (int32_t)gfp;
                    lame_get_in_samplerate(v9);
                    WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                    // branch -> 0x804b189
                }
                // 0x804b189
                i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
                g50 = (int64_t)(int32_t)g49 / g48;
                v10 = (int32_t)&v2;
                v22 = v23;
                v16 = -((v23 + iread));
                // branch -> 0x804b1dc
                while (true) {
                    // 0x804b1dc
                    v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                    if (v12 >= 0) {
                        goto lab_0x804b1fe_11;
                    }
                    v17 = v16;
                    // 0x804b386
                    v8 = 2 * (int32_t)WriteFunction;
                    skip_end = v8;
                    v18 = v17;
                    v14 = 0;
                    if (v17 >= 0.0) {
                        // if_804b393_0_false
                        if (v17 <= 0.0) {
                            // if_804b393_1_false
                            v14 = v17 != 0.0;
                            // branch -> after_if_804b393_0
                        } else {
                            v14 = 1;
                        }
                    }
                    // after_if_804b393_0
                    if ((v14 || v8 & -256) != 1) {
                        // 0x804b39e
                        if (silent <= 9) {
                            // 0x804b3a8
                            error_printf("WAVE file contains 0 PCM samples\n");
                            // branch -> 0x804b3b4
                        }
                        // 0x804b3b4
                        // branch -> 0x804b425
                        // 0x804b425
                        if (disable_wav_header == 0) {
                            // 0x804b432
                            if (strcmp("-", outPath) != 0) {
                                // 0x804b449
                                if (fseek(outf, 0, SEEK_SET) == 0) {
                                    // 0x804b468
                                    v11 = (int32_t)gfp;
                                    lame_get_in_samplerate(v11);
                                    v1[0][1] = 64;
                                    v1[0][0] = 3136;
                                    WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                    // branch -> 0x804b4c8
                                }
                            }
                        }
                        // 0x804b4c8
                        fclose(outf);
                        if (silent <= 0) {
                            // 0x804b4dc
                            decoder_progress_finish();
                            // branch -> 0x804b4e1
                        }
                        // 0x804b4e1
                        return 0;
                    }
                    // 0x804b3bb
                    v20 = 0xffffffffffffffd0 / (int64_t)v8;
                    v13 = v20;
                    v15 = false;
                    v21 = false;
                    if (v18 <= v13) {
                        // if_804b3ee_0_false
                        if (v18 >= v13) {
                            // if_804b3ee_1_false
                            v15 = v18 != v13;
                            v21 = true;
                            // branch -> after_if_804b3ee_0
                        } else {
                            v15 = true;
                            v21 = false;
                        }
                    }
                    // after_if_804b3ee_0
                    if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                        // 0x804b41a
                        v19 = v18 * (float80_t)v8;
                        // branch -> 0x804b425
                    } else {
                        // 0x804b3f9
                        if (silent <= 9) {
                            // 0x804b403
                            error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                            // branch -> 0x804b40f
                        }
                        // 0x804b40f
                        v19 = 4294967248.0L;
                        // branch -> 0x804b425
                    }
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
            }
            // 0x804b0be
            v23 = v45;
            // branch -> 0x804b14f
            // 0x804b14f
            if (disable_wav_header == 0) {
                // 0x804b158
                v9 = (int32_t)gfp;
                lame_get_in_samplerate(v9);
                WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                // branch -> 0x804b189
            }
            // 0x804b189
            i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
            g50 = (int64_t)(int32_t)g49 / g48;
            v10 = (int32_t)&v2;
            v22 = v23;
            v16 = -((v23 + iread));
            // branch -> 0x804b1dc
            while (true) {
                // 0x804b1dc
                v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                if (v12 >= 0) {
                    goto lab_0x804b1fe_11;
                }
                v17 = v16;
                // 0x804b386
                v8 = 2 * (int32_t)WriteFunction;
                skip_end = v8;
                v18 = v17;
                v14 = 0;
                if (v17 >= 0.0) {
                    // if_804b393_0_false
                    if (v17 <= 0.0) {
                        // if_804b393_1_false
                        v14 = v17 != 0.0;
                        // branch -> after_if_804b393_0
                    } else {
                        v14 = 1;
                    }
                }
                // after_if_804b393_0
                if ((v14 || v8 & -256) != 1) {
                    // 0x804b39e
                    if (silent <= 9) {
                        // 0x804b3a8
                        error_printf("WAVE file contains 0 PCM samples\n");
                        // branch -> 0x804b3b4
                    }
                    // 0x804b3b4
                    // branch -> 0x804b425
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
                // 0x804b3bb
                v20 = 0xffffffffffffffd0 / (int64_t)v8;
                v13 = v20;
                v15 = false;
                v21 = false;
                if (v18 <= v13) {
                    // if_804b3ee_0_false
                    if (v18 >= v13) {
                        // if_804b3ee_1_false
                        v15 = v18 != v13;
                        v21 = true;
                        // branch -> after_if_804b3ee_0
                    } else {
                        v15 = true;
                        v21 = false;
                    }
                }
                // after_if_804b3ee_0
                if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                    // 0x804b41a
                    v19 = v18 * (float80_t)v8;
                    // branch -> 0x804b425
                } else {
                    // 0x804b3f9
                    if (silent <= 9) {
                        // 0x804b403
                        error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                        // branch -> 0x804b40f
                    }
                    // 0x804b40f
                    v19 = 4294967248.0L;
                    // branch -> 0x804b425
                }
                // 0x804b425
                if (disable_wav_header == 0) {
                    // 0x804b432
                    if (strcmp("-", outPath) != 0) {
                        // 0x804b449
                        if (fseek(outf, 0, SEEK_SET) == 0) {
                            // 0x804b468
                            v11 = (int32_t)gfp;
                            lame_get_in_samplerate(v11);
                            v1[0][1] = 64;
                            v1[0][0] = 3136;
                            WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                            // branch -> 0x804b4c8
                        }
                    }
                }
                // 0x804b4c8
                fclose(outf);
                if (silent <= 0) {
                    // 0x804b4dc
                    decoder_progress_finish();
                    // branch -> 0x804b4e1
                }
                // 0x804b4e1
                return 0;
            }
        }
        case 5: {
            int32_t v47 = skip_start + 241; // 0x804aefc
            if (silent <= 9) {
                int32_t v48 = (int32_t)gfp; // 0x804af11_0
                lame_get_out_samplerate(v48);
                g3 = v48 > 0x3e7f ? (int32_t)&g5 : (int32_t)".5";
                lame_get_version((int32_t)gfp);
                console_printf("MPEG-%u%s Layer %s");
                v24 = v47;
                // branch -> 0x804b0be
                // 0x804b0be
                v23 = v24;
                if (silent <= 9) {
                    // 0x804b0cc
                    g3 = strlen(outPath) < 46 ? (int32_t)"  " : (int32_t)"\n\t";
                    strcmp(outPath, "-");
                    console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
                    if (v24 >= 1) {
                        // 0x804b123
                        console_printf("skipping initial %i samples (encoder+decoder delay)\n");
                        // branch -> 0x804b136
                    }
                    // 0x804b136
                    if (iread >= 1) {
                        // 0x804b13c
                        console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
                        v23 = v24;
                        // branch -> 0x804b14f
                    } else {
                        v23 = v24;
                    }
                }
                // 0x804b14f
                if (disable_wav_header == 0) {
                    // 0x804b158
                    v9 = (int32_t)gfp;
                    lame_get_in_samplerate(v9);
                    WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                    // branch -> 0x804b189
                }
                // 0x804b189
                i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
                g50 = (int64_t)(int32_t)g49 / g48;
                v10 = (int32_t)&v2;
                v22 = v23;
                v16 = -((v23 + iread));
                // branch -> 0x804b1dc
                while (true) {
                    // 0x804b1dc
                    v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                    if (v12 >= 0) {
                        goto lab_0x804b1fe_11;
                    }
                    v17 = v16;
                    // 0x804b386
                    v8 = 2 * (int32_t)WriteFunction;
                    skip_end = v8;
                    v18 = v17;
                    v14 = 0;
                    if (v17 >= 0.0) {
                        // if_804b393_0_false
                        if (v17 <= 0.0) {
                            // if_804b393_1_false
                            v14 = v17 != 0.0;
                            // branch -> after_if_804b393_0
                        } else {
                            v14 = 1;
                        }
                    }
                    // after_if_804b393_0
                    if ((v14 || v8 & -256) != 1) {
                        // 0x804b39e
                        if (silent <= 9) {
                            // 0x804b3a8
                            error_printf("WAVE file contains 0 PCM samples\n");
                            // branch -> 0x804b3b4
                        }
                        // 0x804b3b4
                        // branch -> 0x804b425
                        // 0x804b425
                        if (disable_wav_header == 0) {
                            // 0x804b432
                            if (strcmp("-", outPath) != 0) {
                                // 0x804b449
                                if (fseek(outf, 0, SEEK_SET) == 0) {
                                    // 0x804b468
                                    v11 = (int32_t)gfp;
                                    lame_get_in_samplerate(v11);
                                    v1[0][1] = 64;
                                    v1[0][0] = 3136;
                                    WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                    // branch -> 0x804b4c8
                                }
                            }
                        }
                        // 0x804b4c8
                        fclose(outf);
                        if (silent <= 0) {
                            // 0x804b4dc
                            decoder_progress_finish();
                            // branch -> 0x804b4e1
                        }
                        // 0x804b4e1
                        return 0;
                    }
                    // 0x804b3bb
                    v20 = 0xffffffffffffffd0 / (int64_t)v8;
                    v13 = v20;
                    v15 = false;
                    v21 = false;
                    if (v18 <= v13) {
                        // if_804b3ee_0_false
                        if (v18 >= v13) {
                            // if_804b3ee_1_false
                            v15 = v18 != v13;
                            v21 = true;
                            // branch -> after_if_804b3ee_0
                        } else {
                            v15 = true;
                            v21 = false;
                        }
                    }
                    // after_if_804b3ee_0
                    if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                        // 0x804b41a
                        v19 = v18 * (float80_t)v8;
                        // branch -> 0x804b425
                    } else {
                        // 0x804b3f9
                        if (silent <= 9) {
                            // 0x804b403
                            error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                            // branch -> 0x804b40f
                        }
                        // 0x804b40f
                        v19 = 4294967248.0L;
                        // branch -> 0x804b425
                    }
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
            }
            // 0x804b0be
            v23 = v47;
            // branch -> 0x804b14f
            // 0x804b14f
            if (disable_wav_header == 0) {
                // 0x804b158
                v9 = (int32_t)gfp;
                lame_get_in_samplerate(v9);
                WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                // branch -> 0x804b189
            }
            // 0x804b189
            i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
            g50 = (int64_t)(int32_t)g49 / g48;
            v10 = (int32_t)&v2;
            v22 = v23;
            v16 = -((v23 + iread));
            // branch -> 0x804b1dc
            while (true) {
                // 0x804b1dc
                v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                if (v12 >= 0) {
                    goto lab_0x804b1fe_11;
                }
                v17 = v16;
                // 0x804b386
                v8 = 2 * (int32_t)WriteFunction;
                skip_end = v8;
                v18 = v17;
                v14 = 0;
                if (v17 >= 0.0) {
                    // if_804b393_0_false
                    if (v17 <= 0.0) {
                        // if_804b393_1_false
                        v14 = v17 != 0.0;
                        // branch -> after_if_804b393_0
                    } else {
                        v14 = 1;
                    }
                }
                // after_if_804b393_0
                if ((v14 || v8 & -256) != 1) {
                    // 0x804b39e
                    if (silent <= 9) {
                        // 0x804b3a8
                        error_printf("WAVE file contains 0 PCM samples\n");
                        // branch -> 0x804b3b4
                    }
                    // 0x804b3b4
                    // branch -> 0x804b425
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
                // 0x804b3bb
                v20 = 0xffffffffffffffd0 / (int64_t)v8;
                v13 = v20;
                v15 = false;
                v21 = false;
                if (v18 <= v13) {
                    // if_804b3ee_0_false
                    if (v18 >= v13) {
                        // if_804b3ee_1_false
                        v15 = v18 != v13;
                        v21 = true;
                        // branch -> after_if_804b3ee_0
                    } else {
                        v15 = true;
                        v21 = false;
                    }
                }
                // after_if_804b3ee_0
                if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                    // 0x804b41a
                    v19 = v18 * (float80_t)v8;
                    // branch -> 0x804b425
                } else {
                    // 0x804b3f9
                    if (silent <= 9) {
                        // 0x804b403
                        error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                        // branch -> 0x804b40f
                    }
                    // 0x804b40f
                    v19 = 4294967248.0L;
                    // branch -> 0x804b425
                }
                // 0x804b425
                if (disable_wav_header == 0) {
                    // 0x804b432
                    if (strcmp("-", outPath) != 0) {
                        // 0x804b449
                        if (fseek(outf, 0, SEEK_SET) == 0) {
                            // 0x804b468
                            v11 = (int32_t)gfp;
                            lame_get_in_samplerate(v11);
                            v1[0][1] = 64;
                            v1[0][0] = 3136;
                            WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                            // branch -> 0x804b4c8
                        }
                    }
                }
                // 0x804b4c8
                fclose(outf);
                if (silent <= 0) {
                    // 0x804b4dc
                    decoder_progress_finish();
                    // branch -> 0x804b4e1
                }
                // 0x804b4e1
                return 0;
            }
        }
        case 6: {
            // 0x804ae34
            int32_t v49; // 0x804aea7_0
            int32_t v50; // 0x804b25a106
            if (skip_start == 0) {
                // 0x804ae3a
                if (*enc_delay <= 0) {
                    // 0x804ae43
                    if (*enc_padding < 0) {
                        int32_t v51 = (int32_t)gfp; // 0x804ae7a_0
                        lame_get_encoder_delay(v51);
                        v50 = v51 + 529;
                        // branch -> 0x804ae99
                        // 0x804ae99
                        if (silent > 9) {
                            // 0x804b0be
                            v23 = v50;
                            // branch -> 0x804b14f
                        } else {
                            // 0x804aea7
                            v49 = (int32_t)gfp;
                            lame_get_out_samplerate(v49);
                            g3 = v49 > 0x3e7f ? (int32_t)&g5 : (int32_t)".5";
                            lame_get_version((int32_t)gfp);
                            console_printf("MPEG-%u%s Layer %s");
                            v24 = v50;
                            // branch -> 0x804b0be
                            // 0x804b0be
                            if (silent <= 9) {
                                // 0x804b0cc
                                g3 = strlen(outPath) < 46 ? (int32_t)"  " : (int32_t)"\n\t";
                                strcmp(outPath, "-");
                                console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
                                if (v24 >= 1) {
                                    // 0x804b123
                                    console_printf("skipping initial %i samples (encoder+decoder delay)\n");
                                    // branch -> 0x804b136
                                }
                                // 0x804b136
                                if (iread >= 1) {
                                    // 0x804b13c
                                    console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
                                    v23 = v24;
                                    // branch -> 0x804b14f
                                } else {
                                    v23 = v24;
                                }
                            } else {
                                v23 = v24;
                            }
                        }
                        // 0x804b14f
                        if (disable_wav_header == 0) {
                            // 0x804b158
                            v9 = (int32_t)gfp;
                            lame_get_in_samplerate(v9);
                            WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                            // branch -> 0x804b189
                        }
                        // 0x804b189
                        i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
                        g50 = (int64_t)(int32_t)g49 / g48;
                        v10 = (int32_t)&v2;
                        v22 = v23;
                        v16 = -((v23 + iread));
                        // branch -> 0x804b1dc
                        while (true) {
                            // 0x804b1dc
                            v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                            if (v12 >= 0) {
                                goto lab_0x804b1fe_11;
                            }
                            v17 = v16;
                            // 0x804b386
                            v8 = 2 * (int32_t)WriteFunction;
                            skip_end = v8;
                            v18 = v17;
                            v14 = 0;
                            if (v17 >= 0.0) {
                                // if_804b393_0_false
                                if (v17 <= 0.0) {
                                    // if_804b393_1_false
                                    v14 = v17 != 0.0;
                                    // branch -> after_if_804b393_0
                                } else {
                                    v14 = 1;
                                }
                            }
                            // after_if_804b393_0
                            if ((v14 || v8 & -256) != 1) {
                                // 0x804b39e
                                if (silent <= 9) {
                                    // 0x804b3a8
                                    error_printf("WAVE file contains 0 PCM samples\n");
                                    // branch -> 0x804b3b4
                                }
                                // 0x804b3b4
                                // branch -> 0x804b425
                                // 0x804b425
                                if (disable_wav_header == 0) {
                                    // 0x804b432
                                    if (strcmp("-", outPath) != 0) {
                                        // 0x804b449
                                        if (fseek(outf, 0, SEEK_SET) == 0) {
                                            // 0x804b468
                                            v11 = (int32_t)gfp;
                                            lame_get_in_samplerate(v11);
                                            v1[0][1] = 64;
                                            v1[0][0] = 3136;
                                            WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                            // branch -> 0x804b4c8
                                        }
                                    }
                                }
                                // 0x804b4c8
                                fclose(outf);
                                if (silent <= 0) {
                                    // 0x804b4dc
                                    decoder_progress_finish();
                                    // branch -> 0x804b4e1
                                }
                                // 0x804b4e1
                                return 0;
                            }
                            // 0x804b3bb
                            v20 = 0xffffffffffffffd0 / (int64_t)v8;
                            v13 = v20;
                            v15 = false;
                            v21 = false;
                            if (v18 <= v13) {
                                // if_804b3ee_0_false
                                if (v18 >= v13) {
                                    // if_804b3ee_1_false
                                    v15 = v18 != v13;
                                    v21 = true;
                                    // branch -> after_if_804b3ee_0
                                } else {
                                    v15 = true;
                                    v21 = false;
                                }
                            }
                            // after_if_804b3ee_0
                            if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                                // 0x804b41a
                                v19 = v18 * (float80_t)v8;
                                // branch -> 0x804b425
                            } else {
                                // 0x804b3f9
                                if (silent <= 9) {
                                    // 0x804b403
                                    error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                                    // branch -> 0x804b40f
                                }
                                // 0x804b40f
                                v19 = 4294967248.0L;
                                // branch -> 0x804b425
                            }
                            // 0x804b425
                            if (disable_wav_header == 0) {
                                // 0x804b432
                                if (strcmp("-", outPath) != 0) {
                                    // 0x804b449
                                    if (fseek(outf, 0, SEEK_SET) == 0) {
                                        // 0x804b468
                                        v11 = (int32_t)gfp;
                                        lame_get_in_samplerate(v11);
                                        v1[0][1] = 64;
                                        v1[0][0] = 3136;
                                        WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                                        // branch -> 0x804b4c8
                                    }
                                }
                            }
                            // 0x804b4c8
                            fclose(outf);
                            if (silent <= 0) {
                                // 0x804b4dc
                                decoder_progress_finish();
                                // branch -> 0x804b4e1
                            }
                            // 0x804b4e1
                            return 0;
                        }
                    }
                }
                int32_t v52 = 0; // 0x804b25a107
                if (*enc_delay >= 0) {
                    // 0x804ae55
                    v52 = *enc_delay + 529;
                    // branch -> 0x804ae62
                }
                // 0x804ae62
                if (*enc_padding >= 0) {
                    // 0x804ae6b
                    iread = *enc_padding - 529;
                    v50 = v52;
                    // branch -> 0x804ae99
                } else {
                    v50 = v52;
                }
            } else {
                // 0x804ae8f
                v50 = skip_start + 529;
                // branch -> 0x804ae99
            }
            // 0x804ae99
            if (silent <= 9) {
                // 0x804aea7
                v49 = (int32_t)gfp;
                lame_get_out_samplerate(v49);
                g3 = v49 > 0x3e7f ? (int32_t)&g5 : (int32_t)".5";
                lame_get_version((int32_t)gfp);
                console_printf("MPEG-%u%s Layer %s");
                v24 = v50;
                // branch -> 0x804b0be
                // 0x804b0be
                v23 = v24;
                if (silent <= 9) {
                    // 0x804b0cc
                    g3 = strlen(outPath) < 46 ? (int32_t)"  " : (int32_t)"\n\t";
                    strcmp(outPath, "-");
                    console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
                    if (v24 >= 1) {
                        // 0x804b123
                        console_printf("skipping initial %i samples (encoder+decoder delay)\n");
                        // branch -> 0x804b136
                    }
                    // 0x804b136
                    if (iread >= 1) {
                        // 0x804b13c
                        console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
                        v23 = v24;
                        // branch -> 0x804b14f
                    } else {
                        v23 = v24;
                    }
                }
                // 0x804b14f
                if (disable_wav_header == 0) {
                    // 0x804b158
                    v9 = (int32_t)gfp;
                    lame_get_in_samplerate(v9);
                    WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                    // branch -> 0x804b189
                }
                // 0x804b189
                i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
                g50 = (int64_t)(int32_t)g49 / g48;
                v10 = (int32_t)&v2;
                v22 = v23;
                v16 = -((v23 + iread));
                // branch -> 0x804b1dc
                while (true) {
                    // 0x804b1dc
                    v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                    if (v12 >= 0) {
                        goto lab_0x804b1fe_11;
                    }
                    v17 = v16;
                    // 0x804b386
                    v8 = 2 * (int32_t)WriteFunction;
                    skip_end = v8;
                    v18 = v17;
                    v14 = 0;
                    if (v17 >= 0.0) {
                        // if_804b393_0_false
                        if (v17 <= 0.0) {
                            // if_804b393_1_false
                            v14 = v17 != 0.0;
                            // branch -> after_if_804b393_0
                        } else {
                            v14 = 1;
                        }
                    }
                    // after_if_804b393_0
                    if ((v14 || v8 & -256) != 1) {
                        // 0x804b39e
                        if (silent <= 9) {
                            // 0x804b3a8
                            error_printf("WAVE file contains 0 PCM samples\n");
                            // branch -> 0x804b3b4
                        }
                        // 0x804b3b4
                        // branch -> 0x804b425
                        // 0x804b425
                        if (disable_wav_header == 0) {
                            // 0x804b432
                            if (strcmp("-", outPath) != 0) {
                                // 0x804b449
                                if (fseek(outf, 0, SEEK_SET) == 0) {
                                    // 0x804b468
                                    v11 = (int32_t)gfp;
                                    lame_get_in_samplerate(v11);
                                    v1[0][1] = 64;
                                    v1[0][0] = 3136;
                                    WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                    // branch -> 0x804b4c8
                                }
                            }
                        }
                        // 0x804b4c8
                        fclose(outf);
                        if (silent <= 0) {
                            // 0x804b4dc
                            decoder_progress_finish();
                            // branch -> 0x804b4e1
                        }
                        // 0x804b4e1
                        return 0;
                    }
                    // 0x804b3bb
                    v20 = 0xffffffffffffffd0 / (int64_t)v8;
                    v13 = v20;
                    v15 = false;
                    v21 = false;
                    if (v18 <= v13) {
                        // if_804b3ee_0_false
                        if (v18 >= v13) {
                            // if_804b3ee_1_false
                            v15 = v18 != v13;
                            v21 = true;
                            // branch -> after_if_804b3ee_0
                        } else {
                            v15 = true;
                            v21 = false;
                        }
                    }
                    // after_if_804b3ee_0
                    if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                        // 0x804b41a
                        v19 = v18 * (float80_t)v8;
                        // branch -> 0x804b425
                    } else {
                        // 0x804b3f9
                        if (silent <= 9) {
                            // 0x804b403
                            error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                            // branch -> 0x804b40f
                        }
                        // 0x804b40f
                        v19 = 4294967248.0L;
                        // branch -> 0x804b425
                    }
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
            }
            // 0x804b0be
            v23 = v50;
            // branch -> 0x804b14f
            // 0x804b14f
            if (disable_wav_header == 0) {
                // 0x804b158
                v9 = (int32_t)gfp;
                lame_get_in_samplerate(v9);
                WriteWaveHeader((struct _IO_FILE_2 *)outf, 0x7fffffff, v9, (int32_t)WriteFunction, 16);
                // branch -> 0x804b189
            }
            // 0x804b189
            i = swapbytes == 0 ? 0x8052c9e : 0x8052cd3;
            g50 = (int64_t)(int32_t)g49 / g48;
            v10 = (int32_t)&v2;
            v22 = v23;
            v16 = -((v23 + iread));
            // branch -> 0x804b1dc
            while (true) {
                // 0x804b1dc
                v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
                if (v12 >= 0) {
                    goto lab_0x804b1fe_11;
                }
                v17 = v16;
                // 0x804b386
                v8 = 2 * (int32_t)WriteFunction;
                skip_end = v8;
                v18 = v17;
                v14 = 0;
                if (v17 >= 0.0) {
                    // if_804b393_0_false
                    if (v17 <= 0.0) {
                        // if_804b393_1_false
                        v14 = v17 != 0.0;
                        // branch -> after_if_804b393_0
                    } else {
                        v14 = 1;
                    }
                }
                // after_if_804b393_0
                if ((v14 || v8 & -256) != 1) {
                    // 0x804b39e
                    if (silent <= 9) {
                        // 0x804b3a8
                        error_printf("WAVE file contains 0 PCM samples\n");
                        // branch -> 0x804b3b4
                    }
                    // 0x804b3b4
                    // branch -> 0x804b425
                    // 0x804b425
                    if (disable_wav_header == 0) {
                        // 0x804b432
                        if (strcmp("-", outPath) != 0) {
                            // 0x804b449
                            if (fseek(outf, 0, SEEK_SET) == 0) {
                                // 0x804b468
                                v11 = (int32_t)gfp;
                                lame_get_in_samplerate(v11);
                                v1[0][1] = 64;
                                v1[0][0] = 3136;
                                WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)0.0L, v11, (int32_t)WriteFunction, 16);
                                // branch -> 0x804b4c8
                            }
                        }
                    }
                    // 0x804b4c8
                    fclose(outf);
                    if (silent <= 0) {
                        // 0x804b4dc
                        decoder_progress_finish();
                        // branch -> 0x804b4e1
                    }
                    // 0x804b4e1
                    return 0;
                }
                // 0x804b3bb
                v20 = 0xffffffffffffffd0 / (int64_t)v8;
                v13 = v20;
                v15 = false;
                v21 = false;
                if (v18 <= v13) {
                    // if_804b3ee_0_false
                    if (v18 >= v13) {
                        // if_804b3ee_1_false
                        v15 = v18 != v13;
                        v21 = true;
                        // branch -> after_if_804b3ee_0
                    } else {
                        v15 = true;
                        v21 = false;
                    }
                }
                // after_if_804b3ee_0
                if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                    // 0x804b41a
                    v19 = v18 * (float80_t)v8;
                    // branch -> 0x804b425
                } else {
                    // 0x804b3f9
                    if (silent <= 9) {
                        // 0x804b403
                        error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                        // branch -> 0x804b40f
                    }
                    // 0x804b40f
                    v19 = 4294967248.0L;
                    // branch -> 0x804b425
                }
                // 0x804b425
                if (disable_wav_header == 0) {
                    // 0x804b432
                    if (strcmp("-", outPath) != 0) {
                        // 0x804b449
                        if (fseek(outf, 0, SEEK_SET) == 0) {
                            // 0x804b468
                            v11 = (int32_t)gfp;
                            lame_get_in_samplerate(v11);
                            v1[0][1] = 64;
                            v1[0][0] = 3136;
                            WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                            // branch -> 0x804b4c8
                        }
                    }
                }
                // 0x804b4c8
                fclose(outf);
                if (silent <= 0) {
                    // 0x804b4dc
                    decoder_progress_finish();
                    // branch -> 0x804b4e1
                }
                // 0x804b4e1
                return 0;
            }
        }
        case 7: {
            // 0x804ae1c
            error_printf("Internal error.  Aborting.");
            exit(-1);
            // UNREACHABLE
        }
    }
    // branch -> 0x804b14f
    int32_t v53; // 0x804b14f
    if (v53 == 0) {
        // branch -> 0x804b189
    }
    // branch -> 0x804b1dc
    while (true) {
        // 0x804b1dc
        v12 = get_audio16((struct lame_global_struct_1 *)gfp, v2);
        if (v12 >= 0) {
            goto lab_0x804b1fe_11;
        }
        v17 = v16;
      lab_0x804b386:
        // 0x804b386
        v8 = 2 * (int32_t)WriteFunction;
        skip_end = v8;
        v18 = v17;
        v14 = 0;
        if (v17 >= 0.0) {
            // if_804b393_0_false
            if (v17 <= 0.0) {
                // if_804b393_1_false
                v14 = v17 != 0.0;
                // branch -> after_if_804b393_0
            } else {
                v14 = 1;
            }
            // after_if_804b393_0
            if ((v14 || v8 & -256) == 1) {
                // 0x804b3bb
                v20 = 0xffffffffffffffd0 / (int64_t)v8;
                v13 = v20;
                v15 = false;
                v21 = false;
                if (v18 <= v13) {
                    // if_804b3ee_0_false
                    if (v18 >= v13) {
                        // if_804b3ee_1_false
                        v15 = v18 != v13;
                        v21 = true;
                        // branch -> after_if_804b3ee_0
                    } else {
                        v15 = true;
                        v21 = false;
                    }
                }
                // after_if_804b3ee_0
                if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                    // 0x804b41a
                    v19 = v18 * (float80_t)v8;
                    // branch -> 0x804b425
                } else {
                    // 0x804b3f9
                    if (silent <= 9) {
                        // 0x804b403
                        error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                        // branch -> 0x804b40f
                    }
                    // 0x804b40f
                    v19 = 4294967248.0L;
                    // branch -> 0x804b425
                }
                // 0x804b425
                if (disable_wav_header == 0) {
                    // 0x804b432
                    if (strcmp("-", outPath) != 0) {
                        // 0x804b449
                        if (fseek(outf, 0, SEEK_SET) == 0) {
                            // 0x804b468
                            v11 = (int32_t)gfp;
                            lame_get_in_samplerate(v11);
                            v1[0][1] = 64;
                            v1[0][0] = 3136;
                            WriteWaveHeader((struct _IO_FILE_2 *)outf, (int32_t)v19, v11, (int32_t)WriteFunction, 16);
                            // branch -> 0x804b4c8
                        }
                    }
                }
                // 0x804b4c8
                fclose(outf);
                if (silent <= 0) {
                    // 0x804b4dc
                    decoder_progress_finish();
                    // branch -> 0x804b4e1
                }
                // 0x804b4e1
                return 0;
            }
            // 0x804b39e
            if (silent <= 9) {
                // 0x804b3a8
                error_printf("WAVE file contains 0 PCM samples\n");
                // branch -> 0x804b3b4
            }
            // 0x804b3b4
            // branch -> 0x804b425
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // after_if_804b393_0
        if ((v14 || v8 & -256) == 1) {
            // 0x804b3bb
            v20 = 0xffffffffffffffd0 / (int64_t)v8;
            v13 = v20;
            v15 = false;
            v21 = false;
            if (v18 <= v13) {
                // if_804b3ee_0_false
                if (v18 >= v13) {
                    // if_804b3ee_1_false
                    v15 = v18 != v13;
                    v21 = true;
                    // branch -> after_if_804b3ee_0
                } else {
                    v15 = true;
                    v21 = false;
                }
            }
            // after_if_804b3ee_0
            if (((int32_t)(v21 || v15) || v20 & -256) == 1) {
                // 0x804b41a
                // branch -> 0x804b425
            } else {
                // 0x804b3f9
                if (silent <= 9) {
                    // 0x804b403
                    error_printf("Very huge WAVE file, can't set filesize accordingly\n");
                    // branch -> 0x804b40f
                }
                // 0x804b40f
                // branch -> 0x804b425
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        } else {
            // 0x804b39e
            if (silent <= 9) {
                // 0x804b3a8
                error_printf("WAVE file contains 0 PCM samples\n");
                // branch -> 0x804b3b4
            }
            // 0x804b3b4
            // branch -> 0x804b425
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804b4f0 - 0x804b512
// Line range:    352 - 356
void print_lame_tag_leading_info(struct lame_global_struct * gf) {
    int32_t v1 = (int32_t)gf; // 0x804b4f6_0
    lame_get_bWriteVbrTag(v1);
    if (v1 != 0) {
        // 0x804b505
        console_printf("Writing LAME Tag...");
        // branch -> 0x804b511
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804b513 - 0x804b68a
// Line range:    359 - 412
void print_trailing_info(struct lame_global_struct * gf) {
    // 0x804b513
    float32_t v1;
    float32_t noclipGainChange = v1; // bp-24
    int32_t v2;
    int32_t RadioGain = v2; // bp-20
    int32_t v3 = (int32_t)gf; // 0x804b519_0
    lame_get_bWriteVbrTag(v3);
    if (v3 != 0) {
        // 0x804b528
        console_printf("done\n");
        // branch -> 0x804b534
    }
    int32_t v4 = (int32_t)gf; // 0x804b534_0
    lame_get_findReplayGain(v4);
    int32_t v5; // 0x804b5ad_0
    int32_t v6; // 0x804b5c0_0
    int32_t v7; // 0x804b5dc_0
    int32_t v8; // 0x804b60a
    bool v9;
    bool v10;
    bool v11;
    int32_t v12;
    bool v13; // 0x804b5f5
    bool v14; // 0x804b61a
    bool v15; // 0x804b65f
    int32_t v16; // 0x804b5ea
    float32_t v17; // 0x804b60f
    if (v4 != 0) {
        int32_t v18 = (int32_t)gf; // 0x804b543_0
        lame_get_RadioGain(v18);
        struct lame_global_struct * v19 = (struct lame_global_struct *)v18;
        console_printf("ReplayGain: %s%.1fdB\n");
        if (v19 > (struct lame_global_struct *)510 || v19 <= (struct lame_global_struct *)-511) {
            // 0x804b594
            error_printf("WARNING: ReplayGain exceeds the -51dB to +51dB range. Such a result is too\n         high to be stored in the header.\n");
            // branch -> 0x804b5a0
        }
        // 0x804b5a0
        if (print_clipping_info == 0) {
            // 0x804b689
            return;
        }
        // 0x804b5ad
        v5 = (int32_t)gf;
        lame_get_decode_on_the_fly(v5);
        if (v5 == 0) {
            // 0x804b689
            return;
        }
        // 0x804b5c0
        v6 = (int32_t)gf;
        lame_get_noclipGainChange(v6);
        RadioGain = (float32_t)((float80_t)v6 / 10.0L);
        v7 = (int32_t)gf;
        lame_get_noclipScale(v7);
        noclipGainChange = g52;
        v16 = RadioGain;
        v9 = false;
        v13 = false;
        if ((float80_t)(int80_t)v16 <= 0.0L) {
            // if_804b5f1_0_false
            if ((float80_t)(int80_t)v16 >= 0.0L) {
                // if_804b5f1_1_false
                v9 = (float80_t)(int80_t)v16 != 0.0L;
                v13 = true;
                // branch -> after_if_804b5f1_0
            } else {
                v9 = true;
                v13 = false;
            }
        }
        // after_if_804b5f1_0
        v12 = v7 & -256;
        if (((int32_t)(v13 || v9) || v12) == 1) {
            // 0x804b650
            v11 = false;
            v15 = false;
            if ((float80_t)(int80_t)v16 <= -0.1L) {
                // if_804b65b_0_false
                if ((float80_t)(int80_t)v16 >= -0.1L) {
                    // if_804b65b_1_false
                    v11 = (float80_t)(int80_t)v16 != -0.1L;
                    v15 = true;
                    // branch -> after_if_804b65b_0
                } else {
                    v11 = true;
                    v15 = false;
                }
            }
            // after_if_804b65b_0
            if (((int32_t)(v15 || v11) || v12) == 1) {
                // 0x804b674
                console_printf("\nThe waveform does not clip and is at least %.1fdB away from full scale.\n");
                // branch -> 0x804b689
            } else {
                // 0x804b666
                console_printf("\nThe waveform does not clip and is less than 0.1dB away from full scale.\n");
                // branch -> 0x804b689
            }
            // 0x804b689
            return;
        }
        // 0x804b5fc
        v8 = console_printf("WARNING: clipping occurs at the current gain. Set your decoder to decrease\n         the  gain  by  at least %.1fdB or encode again ");
        v17 = noclipGainChange;
        v10 = false;
        v14 = false;
        if (v17 <= 0.0f) {
            // if_804b616_0_false
            if (v17 >= 0.0f) {
                // if_804b616_1_false
                v10 = v17 != 0.0f;
                v14 = true;
                // branch -> after_if_804b616_0
            } else {
                v10 = true;
                v14 = false;
            }
        }
        // after_if_804b616_0
        if (((int32_t)(v14 || v10) || v8 & -256) == 1) {
            // 0x804b642
            console_printf("using --scale <arg>\n         (For   a   suggestion  on  the  optimal  value  of  <arg>  encode\n         with  --scale 1  first)\n");
            // branch -> 0x804b689
        } else {
            // 0x804b621
            console_printf("using  --scale %.2f\n");
            console_printf("         or less (the value under --scale is approximate).\n");
            // branch -> 0x804b689
        }
        // 0x804b689
        return;
    }
    // 0x804b5a0
    if (print_clipping_info == 0) {
        // 0x804b689
        return;
    }
    // 0x804b5ad
    v5 = (int32_t)gf;
    lame_get_decode_on_the_fly(v5);
    if (v5 == 0) {
        // 0x804b689
        return;
    }
    // 0x804b5c0
    v6 = (int32_t)gf;
    lame_get_noclipGainChange(v6);
    RadioGain = (float32_t)((float80_t)v6 / 10.0L);
    v7 = (int32_t)gf;
    lame_get_noclipScale(v7);
    noclipGainChange = g52;
    v16 = RadioGain;
    if ((float80_t)(int80_t)v16 > 0.0L) {
        // after_if_804b5f1_0
        v12 = v7 & -256;
        if (((int32_t)0 || v12) == 1) {
            // 0x804b650
            v11 = false;
            v15 = false;
            if ((float80_t)(int80_t)v16 <= -0.1L) {
                // if_804b65b_0_false
                if ((float80_t)(int80_t)v16 >= -0.1L) {
                    // if_804b65b_1_false
                    v11 = (float80_t)(int80_t)v16 != -0.1L;
                    v15 = true;
                    // branch -> after_if_804b65b_0
                } else {
                    v11 = true;
                    v15 = false;
                }
            }
            // after_if_804b65b_0
            if (((int32_t)(v15 || v11) || v12) == 1) {
                // 0x804b674
                console_printf("\nThe waveform does not clip and is at least %.1fdB away from full scale.\n");
                // branch -> 0x804b689
            } else {
                // 0x804b666
                console_printf("\nThe waveform does not clip and is less than 0.1dB away from full scale.\n");
                // branch -> 0x804b689
            }
            // 0x804b689
            return;
        }
        // 0x804b5fc
        v8 = console_printf("WARNING: clipping occurs at the current gain. Set your decoder to decrease\n         the  gain  by  at least %.1fdB or encode again ");
        v17 = noclipGainChange;
        v10 = false;
        v14 = false;
        if (v17 <= 0.0f) {
            // if_804b616_0_false
            if (v17 >= 0.0f) {
                // if_804b616_1_false
                v10 = v17 != 0.0f;
                v14 = true;
                // branch -> after_if_804b616_0
            } else {
                v10 = true;
                v14 = false;
            }
        }
        // after_if_804b616_0
        if (((int32_t)(v14 || v10) || v8 & -256) == 1) {
            // 0x804b642
            console_printf("using --scale <arg>\n         (For   a   suggestion  on  the  optimal  value  of  <arg>  encode\n         with  --scale 1  first)\n");
            // branch -> 0x804b689
        } else {
            // 0x804b621
            console_printf("using  --scale %.2f\n");
            console_printf("         or less (the value under --scale is approximate).\n");
            // branch -> 0x804b689
        }
        // 0x804b689
        return;
    }
    // if_804b5f1_0_false
    if ((float80_t)(int80_t)v16 >= 0.0L) {
        // if_804b5f1_1_false
        v9 = (float80_t)(int80_t)v16 != 0.0L;
        v13 = true;
        // branch -> after_if_804b5f1_0
    } else {
        v9 = true;
        v13 = false;
    }
    // after_if_804b5f1_0
    v12 = v7 & -256;
    if (((int32_t)(v13 || v9) || v12) == 1) {
        // 0x804b650
        v11 = false;
        v15 = false;
        if ((float80_t)(int80_t)v16 <= -0.1L) {
            // if_804b65b_0_false
            if ((float80_t)(int80_t)v16 >= -0.1L) {
                // if_804b65b_1_false
                v11 = (float80_t)(int80_t)v16 != -0.1L;
                v15 = true;
                // branch -> after_if_804b65b_0
            } else {
                v11 = true;
                v15 = false;
            }
        }
        // after_if_804b65b_0
        if (((int32_t)(v15 || v11) || v12) == 1) {
            // 0x804b674
            console_printf("\nThe waveform does not clip and is at least %.1fdB away from full scale.\n");
            // branch -> 0x804b689
        } else {
            // 0x804b666
            console_printf("\nThe waveform does not clip and is less than 0.1dB away from full scale.\n");
            // branch -> 0x804b689
        }
        // 0x804b689
        return;
    }
    // 0x804b5fc
    v8 = console_printf("WARNING: clipping occurs at the current gain. Set your decoder to decrease\n         the  gain  by  at least %.1fdB or encode again ");
    v17 = noclipGainChange;
    v10 = false;
    v14 = false;
    if (v17 <= 0.0f) {
        // if_804b616_0_false
        if (v17 >= 0.0f) {
            // if_804b616_1_false
            v10 = v17 != 0.0f;
            v14 = true;
            // branch -> after_if_804b616_0
        } else {
            v10 = true;
            v14 = false;
        }
    }
    // after_if_804b616_0
    if (((int32_t)(v14 || v10) || v8 & -256) == 1) {
        // 0x804b642
        console_printf("using --scale <arg>\n         (For   a   suggestion  on  the  optimal  value  of  <arg>  encode\n         with  --scale 1  first)\n");
        // branch -> 0x804b689
    } else {
        // 0x804b621
        console_printf("using  --scale %.2f\n");
        console_printf("         or less (the value under --scale is approximate).\n");
        // branch -> 0x804b689
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804b68b - 0x804b799
// Line range:    418 - 443
int32_t write_xing_frame(struct lame_global_struct * gf, struct _IO_FILE * outf) {
    char v1[10000];
    char v2[10000];
    int32_t v3 = (int32_t)gf; // 0x804b694_0
    lame_get_lametag_frame(v3, (int32_t)&v2, 0x24000);
    char v4 = v3; // 0x804b6d1_0
    v1[0] = v4;
    int32_t result = 0;
    if (v4 != 0) {
        // 0x804b6e3
        error_printf("Error writing LAME-tag frame: buffer too small: buffer size=%d  frame size=%d\n");
        result = -1;
        // branch -> 0x804b787
    }
    // 0x804b787
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x804b793
        __stack_chk_fail();
        // branch -> 0x804b798
    }
    // 0x804b798
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804b79a - 0x804bc84
// Line range:    448 - 567
int32_t lame_encoder(struct lame_global_struct * gf, struct _IO_FILE * outf, int32_t nogap, char * inPath, char * outPath) {
    char v1[10000];
    char data[10000];
    int32_t v2;
    int32_t owrite = v2; // bp-147488
    int32_t v3;
    int32_t iread = v3; // bp-147480
    int32_t nmemb = (int32_t)gf; // 0x804b7a3_0
    int32_t v4 = *(int32_t *)20; // 0x804b7c8
    encoder_progress_begin((struct lame_global_struct_3 *)gf, inPath, outPath);
    int32_t v5 = (int32_t)&data; // 0x804b7fc_0
    lame_get_id3v2_tag(nmemb, v5, 0x24000);
    iread = nmemb;
    if (nmemb >= 0x24001) {
        // 0x804b827
        encoder_progress_end((struct lame_global_struct_3 *)gf);
        error_printf("Error writing ID3v2 tag: buffer too small: buffer size=%d  ID3v2 size=%d\n");
        // branch -> 0x804bc72
        // 0x804bc72
        if (*(int32_t *)20 != v4) {
            // 0x804bc7e
            __stack_chk_fail();
            // branch -> 0x804bc83
        }
        // 0x804bc83
        return 1;
    }
    int32_t items_written = fwrite(data, 1, nmemb, outf); // 0x804b882
    if (items_written != iread) {
        // 0x804b89b
        encoder_progress_end((struct lame_global_struct_3 *)gf);
        error_printf("Error writing ID3v2 tag \n");
        // branch -> 0x804bc72
        // 0x804bc72
        if (*(int32_t *)20 != v4) {
            // 0x804bc7e
            __stack_chk_fail();
            // branch -> 0x804bc83
        }
        // 0x804bc83
        return 1;
    }
    if (flush_write == 1) {
        // 0x804b8c9
        fflush(outf);
        items_written = iread;
        // branch -> 0x804b8d7
    }
    // 0x804b8d7
    owrite = items_written;
    int32_t v6;
    int32_t v7 = &v6; // 0x804b8e3_0
    int32_t v8;
    int32_t v9 = &v8; // 0x804b922_0
    // branch -> 0x804b8e3
    while (true) {
        char v10 = get_audio((struct lame_global_struct_1 *)gf, (int32_t (*)[1152])&v6);
        v1[0] = v10;
        if (v10 >= 0) {
            // 0x804b90e
            encoder_progress((struct lame_global_struct_3 *)gf);
            char v11 = v1[0]; // 0x804b940
            lame_encode_buffer_int(nmemb, v7, v9, (int32_t)v11, v5, 0x24000);
            iread = nmemb;
            if (nmemb <= 0) {
                // 0x804b96f
                if (nmemb == -1) {
                    // 0x804b978
                    error_printf("mp3 buffer is not big enough... \n");
                    // branch -> 0x804b99c
                } else {
                    // 0x804b986
                    error_printf("mp3 internal error:  error code=%i\n");
                    // branch -> 0x804b99c
                }
                // 0x804b99c
                // branch -> 0x804bc72
                // 0x804bc72
                if (*(int32_t *)20 != v4) {
                    // 0x804bc7e
                    __stack_chk_fail();
                    // branch -> 0x804bc83
                }
                // 0x804bc83
                return 1;
            }
            // 0x804b9a6
            if (fwrite(data, 1, nmemb, outf) == iread) {
                // 0x804b9fa
                if (flush_write == 1) {
                  lab_0x804ba04:
                    // 0x804ba04
                    fflush(outf);
                    // branch -> 0x804ba12
                }
              lab_0x804ba12:
                // 0x804ba12
                if (v1[0] <= 0) {
                    // break -> 0x804ba1f
                    break;
                }
                // continue -> 0x804b8e3
                continue;
            } else {
                // 0x804b9e4
                error_printf("Error writing mp3 output \n");
                // branch -> 0x804bc72
            }
            // 0x804bc72
            if (*(int32_t *)20 != v4) {
                // 0x804bc7e
                __stack_chk_fail();
                // branch -> 0x804bc83
            }
            // 0x804bc83
            return 1;
        }
        // 0x804b9fa
        if (flush_write == 1) {
            goto lab_0x804ba04;
        }
        goto lab_0x804ba12;
    }
    // 0x804ba1f
    if (nogap == 0) {
        // 0x804ba4d
        lame_encode_flush(nmemb, v5, 0x24000);
        // branch -> 0x804ba73
    } else {
        // 0x804ba25
        lame_encode_flush_nogap(nmemb, v5, 0x24000);
        // branch -> 0x804ba73
    }
    // 0x804ba73
    iread = nmemb;
    if (nmemb <= 0) {
        // 0x804ba7c
        if (nmemb == -1) {
            // 0x804ba85
            error_printf("mp3 buffer is not big enough... \n");
            // branch -> 0x804baa9
        } else {
            // 0x804ba93
            error_printf("mp3 internal error:  error code=%i\n");
            // branch -> 0x804baa9
        }
        // 0x804baa9
        // branch -> 0x804bc72
        // 0x804bc72
        if (*(int32_t *)20 != v4) {
            // 0x804bc7e
            __stack_chk_fail();
            // branch -> 0x804bc83
        }
        // 0x804bc83
        return 1;
    }
    // 0x804bab3
    encoder_progress_end((struct lame_global_struct_3 *)gf);
    int32_t v12; // eax
    int32_t result; // 0x804bc84_2
    int32_t v13; // bp+227
    if (fwrite(data, 1, iread, outf) == iread) {
        // 0x804bb15
        if (flush_write == 1) {
            // 0x804bb1f
            fflush(outf);
            // branch -> 0x804bb2d
        }
        // 0x804bb2d
        lame_get_id3v1_tag(nmemb, v5, 0x24000);
        iread = nmemb;
        if (nmemb < 0x24001) {
            // 0x804bb80
            if (nmemb >= 1) {
                // 0x804bb89
                if (fwrite(data, 1, nmemb, outf) == iread) {
                    // 0x804bbdd
                    if (flush_write == 1) {
                        // 0x804bbe7
                        fflush(outf);
                        // branch -> 0x804bbf5
                    }
                    // 0x804bbf5
                    if (silent <= 0) {
                        // 0x804bbfe
                        print_lame_tag_leading_info(gf);
                        // branch -> 0x804bc0c
                    }
                    // 0x804bc0c
                    if (fseek(outf, owrite, SEEK_SET) == 0) {
                        // 0x804bc3e
                        write_xing_frame(gf, outf);
                        // branch -> 0x804bc56
                    } else {
                        // 0x804bc30
                        error_printf("fatal error: can't update LAME-tag frame!\n");
                        // branch -> 0x804bc56
                    }
                    // 0x804bc56
                    if (silent <= 0) {
                        // 0x804bc5f
                        print_trailing_info(gf);
                        // branch -> 0x804bc6d
                    }
                    // 0x804bc6d
                    v12 = 0;
                    v13 = 0;
                    // branch -> 0x804bc72
                } else {
                    // 0x804bbc7
                    error_printf("Error writing ID3v1 tag \n");
                    v12 = 1;
                    v13 = 1;
                    // branch -> 0x804bc72
                }
                // 0x804bc72
                if (*(int32_t *)20 != v4) {
                    // 0x804bc7e
                    __stack_chk_fail();
                    result = v12;
                    // branch -> 0x804bc83
                } else {
                    result = v13;
                }
                // 0x804bc83
                return result;
            }
        } else {
            // 0x804bb60
            error_printf("Error writing ID3v1 tag: buffer too small: buffer size=%d  ID3v1 size=%d\n");
            // branch -> 0x804bbf5
        }
        // 0x804bbf5
        if (silent <= 0) {
            // 0x804bbfe
            print_lame_tag_leading_info(gf);
            // branch -> 0x804bc0c
        }
        // 0x804bc0c
        if (fseek(outf, owrite, SEEK_SET) == 0) {
            // 0x804bc3e
            write_xing_frame(gf, outf);
            // branch -> 0x804bc56
        } else {
            // 0x804bc30
            error_printf("fatal error: can't update LAME-tag frame!\n");
            // branch -> 0x804bc56
        }
        // 0x804bc56
        if (silent <= 0) {
            // 0x804bc5f
            print_trailing_info(gf);
            // branch -> 0x804bc6d
        }
        // 0x804bc6d
        v12 = 0;
        v13 = 0;
        // branch -> 0x804bc72
    } else {
        // 0x804baff
        error_printf("Error writing mp3 output \n");
        v12 = 1;
        v13 = 1;
        // branch -> 0x804bc72
    }
    // 0x804bc72
    if (*(int32_t *)20 != v4) {
        // 0x804bc7e
        __stack_chk_fail();
        result = v12;
        // branch -> 0x804bc83
    } else {
        result = v13;
    }
    // 0x804bc83
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804bc85 - 0x804bcf0
// Line range:    575 - 588
void brhist_init_package(struct lame_global_struct * gf) {
    int32_t v1 = (int32_t)gf; // 0x804bce0_0
    if (g44 == 0) {
        // 0x804bcd0
        brhist_init((struct lame_global_struct_4 *)gf, 128, 128);
        // branch -> 0x804bceb
        // 0x804bceb
        return;
    }
    // 0x804bc95
    lame_get_VBR_max_bitrate_kbps(v1);
    int32_t v2 = (int32_t)gf; // 0x804bca2_0
    lame_get_VBR_min_bitrate_kbps(v2);
    if (brhist_init((struct lame_global_struct_4 *)gf, v2, v1) != 0) {
        // 0x804bcc4
        g44 = 0;
        // branch -> 0x804bceb
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804bcf1 - 0x804bfa4
// Line range:    594 - 662
void parse_nogap_filenames(int32_t nogapout, char * inPath, char * outPath, char * outdir) {
    // 0x804bcf1
    char * v1;
    char * slasher = v1; // bp-20
    int32_t v2 = (int32_t)outPath; // 0x804bcfe_0
    strcpy(outPath, outdir);
    if (nogapout == 0) {
        // 0x804bd13
        strncpy(outPath, inPath, 4093);
        int32_t len = strlen(outPath); // 0x804bd33
        slasher = (char *)len;
        char * v3 = (char *)(v2 - 3 + len);
        if (*v3 == 119) {
            int32_t v4 = v2 - 2; // 0x804bd4e
            if (*(char *)(v4 + len) == 97) {
                int32_t v5 = v2 - 1; // 0x804bd5e
                if (*(char *)(v5 + len) == 118) {
                    // 0x804bd6b
                    if (*(char *)(v2 - 4 + len) == 46) {
                        // 0x804bd7b
                        *v3 = 109;
                        *(char *)(v4 + (int32_t)slasher) = 112;
                        *(char *)(v5 + (int32_t)slasher) = 51;
                        // branch -> 0x804bfa3
                        // 0x804bfa3
                        return;
                    }
                }
            }
        }
        // 0x804bda5
        *(char *)(len + v2) = 46;
        *(char *)(v2 + 1 + (int32_t)slasher) = 109;
        *(char *)(v2 + 2 + (int32_t)slasher) = 112;
        *(char *)(v2 + 3 + (int32_t)slasher) = 51;
        *(char *)(v2 + 4 + (int32_t)slasher) = 0;
        // branch -> 0x804bfa3
    } else {
        int32_t v6 = (int32_t)inPath + 4093; // 0x804bdec
        char * v7 = (char *)v6;
        char * str = v7;
        int32_t len2; // 0x804be83
        int32_t len3; // 0x804bef9
        char * str2;
        char * v8;
        char v9; // 0x804be8e
        int32_t v10; // 0x804be88
        int32_t v11; // 0x804bf14
        if (*v7 != 47) {
            int32_t v12 = v6;
            int32_t v13;
            while (true) {
                // 0x804be03
                if (*v7 != 92) {
                    // 0x804be0d
                    if (v7 != inPath) {
                        // 0x804be15
                        if (*v7 != 58) {
                            int32_t v14 = v12 - 1; // 0x804bdf5
                            char * v15 = (char *)v14;
                            if (*v15 == 47) {
                                v13 = v14;
                                str = v15;
                                // break -> 0x804be1f
                                break;
                            }
                            v7 = v15;
                            v12 = v14;
                            // continue -> 0x804be03
                            continue;
                        } else {
                            v13 = v12;
                            str = v7;
                        }
                    } else {
                        v13 = v12;
                        str = inPath;
                    }
                } else {
                    v13 = v12;
                    str = v7;
                }
            }
            // 0x804be1f
            len2 = strlen(outPath);
            v10 = v2 - 1;
            v9 = *(char *)(v10 + len2);
            if (str == inPath) {
                // 0x804be7d
                if (v9 != 47) {
                    // 0x804be95
                    if (*(char *)(v10 + strlen(outPath)) != 92) {
                        // 0x804bead
                        if (*(char *)(v10 + strlen(outPath)) != 58) {
                            // 0x804bec5
                            strcat(outPath, "/");
                            str2 = inPath;
                            // branch -> 0x804bed9
                        } else {
                            str2 = inPath;
                        }
                    } else {
                        str2 = inPath;
                    }
                } else {
                    str2 = inPath;
                }
            } else {
                // 0x804be27
                if (v9 != 47) {
                    // 0x804be3f
                    if (*(char *)(v10 + strlen(outPath)) != 92) {
                        // 0x804be57
                        if (*(char *)(v10 + strlen(outPath)) != 58) {
                            // 0x804be75
                            // branch -> 0x804bed9
                            // 0x804bed9
                            strncat(outPath, str, 4093);
                            len3 = strlen(outPath);
                            slasher = (char *)len3;
                            v8 = (char *)(v2 - 3 + len3);
                            if (*v8 == 119) {
                                // 0x804bf11
                                v11 = v2 - 2;
                                if (*(char *)(v11 + len3) == 97) {
                                    // 0x804bf21
                                    if (*(char *)(v10 + len3) == 118) {
                                        // 0x804bf31
                                        if (*(char *)(v2 - 4 + len3) == 46) {
                                            // 0x804bf41
                                            *v8 = 109;
                                            *(char *)(v11 + (int32_t)slasher) = 112;
                                            *(char *)(v10 + (int32_t)slasher) = 51;
                                            // branch -> 0x804bfa3
                                            // 0x804bfa3
                                            return;
                                        }
                                    }
                                }
                            }
                            // 0x804bf67
                            *(char *)(len3 + v2) = 46;
                            *(char *)(v2 + 1 + (int32_t)slasher) = 109;
                            *(char *)(v2 + 2 + (int32_t)slasher) = 112;
                            *(char *)(v2 + 3 + (int32_t)slasher) = 51;
                            *(char *)(v2 + 4 + (int32_t)slasher) = 0;
                            // branch -> 0x804bfa3
                            // 0x804bfa3
                            return;
                        }
                    }
                }
                // 0x804be6f
                str2 = (char *)(v13 + 1);
                // branch -> 0x804bed9
            }
            // 0x804bed9
            strncat(outPath, str2, 4093);
            len3 = strlen(outPath);
            slasher = (char *)len3;
            v8 = (char *)(v2 - 3 + len3);
            if (*v8 == 119) {
                // 0x804bf11
                v11 = v2 - 2;
                if (*(char *)(v11 + len3) == 97) {
                    // 0x804bf21
                    if (*(char *)(v10 + len3) == 118) {
                        // 0x804bf31
                        if (*(char *)(v2 - 4 + len3) == 46) {
                            // 0x804bf41
                            *v8 = 109;
                            *(char *)(v11 + (int32_t)slasher) = 112;
                            *(char *)(v10 + (int32_t)slasher) = 51;
                            // branch -> 0x804bfa3
                            // 0x804bfa3
                            return;
                        }
                    }
                }
            }
            // 0x804bf67
            *(char *)(len3 + v2) = 46;
            *(char *)(v2 + 1 + (int32_t)slasher) = 109;
            *(char *)(v2 + 2 + (int32_t)slasher) = 112;
            *(char *)(v2 + 3 + (int32_t)slasher) = 51;
            *(char *)(v2 + 4 + (int32_t)slasher) = 0;
            // branch -> 0x804bfa3
            // 0x804bfa3
            return;
        }
        // 0x804be1f
        len2 = strlen(outPath);
        v10 = v2 - 1;
        v9 = *(char *)(v10 + len2);
        if (str == inPath) {
            // 0x804be7d
            if (v9 != 47) {
                // 0x804be95
                if (*(char *)(v10 + strlen(outPath)) != 92) {
                    // 0x804bead
                    if (*(char *)(v10 + strlen(outPath)) != 58) {
                        // 0x804bec5
                        strcat(outPath, "/");
                        str2 = inPath;
                        // branch -> 0x804bed9
                    } else {
                        str2 = inPath;
                    }
                } else {
                    str2 = inPath;
                }
            } else {
                str2 = inPath;
            }
        } else {
            // 0x804be27
            if (v9 != 47) {
                // 0x804be3f
                if (*(char *)(v10 + strlen(outPath)) != 92) {
                    // 0x804be57
                    if (*(char *)(v10 + strlen(outPath)) != 58) {
                        // 0x804be75
                        // branch -> 0x804bed9
                        // 0x804bed9
                        strncat(outPath, str, 4093);
                        len3 = strlen(outPath);
                        slasher = (char *)len3;
                        v8 = (char *)(v2 - 3 + len3);
                        if (*v8 == 119) {
                            // 0x804bf11
                            v11 = v2 - 2;
                            if (*(char *)(v11 + len3) == 97) {
                                // 0x804bf21
                                if (*(char *)(v10 + len3) == 118) {
                                    // 0x804bf31
                                    if (*(char *)(v2 - 4 + len3) == 46) {
                                        // 0x804bf41
                                        *v8 = 109;
                                        *(char *)(v11 + (int32_t)slasher) = 112;
                                        *(char *)(v10 + (int32_t)slasher) = 51;
                                        // branch -> 0x804bfa3
                                        // 0x804bfa3
                                        return;
                                    }
                                }
                            }
                        }
                        // 0x804bf67
                        *(char *)(len3 + v2) = 46;
                        *(char *)(v2 + 1 + (int32_t)slasher) = 109;
                        *(char *)(v2 + 2 + (int32_t)slasher) = 112;
                        *(char *)(v2 + 3 + (int32_t)slasher) = 51;
                        *(char *)(v2 + 4 + (int32_t)slasher) = 0;
                        // branch -> 0x804bfa3
                        // 0x804bfa3
                        return;
                    }
                }
            }
            // 0x804be6f
            str2 = (char *)(v6 + 1);
            // branch -> 0x804bed9
        }
        // 0x804bed9
        strncat(outPath, str2, 4093);
        len3 = strlen(outPath);
        slasher = (char *)len3;
        v8 = (char *)(v2 - 3 + len3);
        if (*v8 == 119) {
            // 0x804bf11
            v11 = v2 - 2;
            if (*(char *)(v11 + len3) == 97) {
                // 0x804bf21
                if (*(char *)(v10 + len3) == 118) {
                    // 0x804bf31
                    if (*(char *)(v2 - 4 + len3) == 46) {
                        // 0x804bf41
                        *v8 = 109;
                        *(char *)(v11 + (int32_t)slasher) = 112;
                        *(char *)(v10 + (int32_t)slasher) = 51;
                        // branch -> 0x804bfa3
                        // 0x804bfa3
                        return;
                    }
                }
            }
        }
        // 0x804bf67
        *(char *)(len3 + v2) = 46;
        *(char *)(v2 + 1 + (int32_t)slasher) = 109;
        *(char *)(v2 + 2 + (int32_t)slasher) = 112;
        *(char *)(v2 + 3 + (int32_t)slasher) = 51;
        *(char *)(v2 + 4 + (int32_t)slasher) = 0;
        // branch -> 0x804bfa3
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/main.c
// Address range: 0x804bfa5 - 0x804c6bf
// Line range:    675 - 864
int main(int argc, char ** argv) {
    char v1[4097];
    char v2[200][4097];
    int32_t v3;
    int32_t i = v3; // bp-12356
    int32_t v4 = (int32_t)&v2; // 0x804c004_0
    memset(&v2[0][0], 0, 0xc80c8);
    i = 0;
    int32_t v5 = 0; // 0x804c01d
    *(int32_t *)(0xc8104 + 4 * v5) = 0x1001 * v5 + v4;
    int32_t v6 = i + 1; // 0x804c040
    i = v6;
    // branch -> 0x804c01d
    while (v6 < 200) {
        // 0x804c01d
        v5 = v6;
        *(int32_t *)(0xc8104 + 4 * v5) = 0x1001 * v5 + v4;
        v6 = i + 1;
        i = v6;
        // continue -> 0x804c01d
    }
    // 0x804c055
    memset(v1, 0, 0x1001);
    frontend_open_console();
    input_format = 0;
    lame_init();
    error_printf("fatal error during initialization\n");
    frontend_close_console();
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x804c6ae
        __stack_chk_fail();
        // branch -> 0x804c6b3
    }
    // 0x804c6b3
    return 1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804c6c0 - 0x804c6ed
// Line range:    49 - 54
int32_t my_console_printing(struct _IO_FILE_1 * fp, char * format, char * ap) {
    // 0x804c6c0
    int32_t chars_printed;
    if (fp != NULL) {
        // 0x804c6cc
        chars_printed = vfprintf((struct _IO_FILE *)fp, format, (int32_t)ap);
        // branch -> 0x804c6ec
    } else {
        chars_printed = 0;
    }
    // 0x804c6ec
    return chars_printed;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804c74a - 0x804c977
// Line range:    85 - 144
void apply_termcap_settings(struct anon_struct_1 * mfp) {
    // 0x804c74a
    char * v1;
    char * term_name = v1; // bp-2084
    int32_t v2 = (int32_t)mfp; // 0x804c753_0
    char * env_val = getenv("TERM"); // 0x804c76e
    if (env_val != NULL) {
        // 0x804c786
        int32_t v3;
        int32_t v4 = &v3; // 0x804c790_0
        int32_t v5 = v4; // eax
        tgetent(v4, (int32_t)env_val);
        if (v5 == 1) {
            // 0x804c7a7
            tgetnum((int32_t)"co");
            char * v6 = (char *)v5; // 0x804c7b3_0
            if (v6 >= (char *)40 && v6 <= (char *)512) {
                // 0x804c7ce
                v5 = v2;
                *(int32_t *)(v2 + 20) = v4;
                // branch -> 0x804c7dd
            }
            // 0x804c7dd
            tgetnum((int32_t)"li");
            char * v7 = (char *)v5; // 0x804c7e9_0
            if (v7 >= (char *)16 && v7 <= (char *)256) {
                // 0x804c804
                *(int32_t *)(v2 + 24) = v5;
                // branch -> 0x804c813
            }
            // 0x804c813
            int32_t v8;
            term_name = (char *)&v8;
            v8 = 0;
            int32_t v9 = (int32_t)&term_name; // 0x804c825_0
            tgetstr((int32_t)"up", v9);
            term_name = (char *)v9;
            strcpy((char *)(v2 + 28), (char *)&term_name);
            term_name = (char *)&v8;
            v8 = 0;
            tgetstr((int32_t)"ce", v9);
            term_name = (char *)v9;
            strcpy((char *)(v2 + 38), (char *)&term_name);
            term_name = (char *)&v8;
            v8 = 0;
            tgetstr((int32_t)"md", v9);
            term_name = (char *)v9;
            strcpy((char *)(v2 + 48), (char *)&term_name);
            term_name = (char *)&v8;
            v8 = 0;
            tgetstr((int32_t)"me", v9);
            term_name = (char *)v9;
            strcpy((char *)(v2 + 58), (char *)&term_name);
            // branch -> 0x804c965
        }
    }
    // 0x804c965
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x804c971
        __stack_chk_fail();
        // branch -> 0x804c976
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804c978 - 0x804ca22
// Line range:    148 - 179
int32_t init_console(struct anon_struct_1 * mfp) {
    // 0x804c978
    *(int32_t *)((int32_t)mfp + 20) = 80;
    *(int32_t *)((int32_t)mfp + 24) = 25;
    *(int32_t *)((int32_t)mfp + 8) = g12;
    *(int32_t *)((int32_t)mfp + 12) = g12;
    *(int32_t *)((int32_t)mfp + 16) = 0;
    int32_t v1 = (int32_t)mfp; // 0x804c9b4_0
    int32_t stream = *(int32_t *)(v1 + 8); // 0x804c9bd
    setvbuf((struct _IO_FILE *)stream, (char *)(v1 + 68), 0, 2048);
    memcpy((char *)((int32_t)mfp + 28), (char *)&g6, 4);
    apply_termcap_settings(mfp);
    mfp->e0 = 0x434f4e53;
    *(int32_t *)((int32_t)mfp + 2116) = 0;
    return 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804ca23 - 0x804ca9e
// Line range:    182 - 192
void deinit_console(struct anon_struct_1 * mfp) {
    int32_t * file = (int32_t *)((int32_t)mfp + 16); // 0x804ca2c_0
    if (*file != 0) {
        // 0x804ca33
        fclose((struct _IO_FILE *)*file);
        *(int32_t *)((int32_t)mfp + 16) = 0;
        // branch -> 0x804ca4b
    }
    // 0x804ca4b
    fflush((struct _IO_FILE *)*(int32_t *)((int32_t)mfp + 8));
    setvbuf((struct _IO_FILE *)*(int32_t *)((int32_t)mfp + 8), NULL, 2, 0);
    memset((char *)((int32_t)mfp + 68), 85, 1024);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804ca9f - 0x804cab2
// Line range:    200 - 203
int32_t frontend_open_console(void) {
    // 0x804ca9f
    init_console((struct anon_struct_1 *)&Console_IO);
    return 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804cab3 - 0x804cac6
// Line range:    206 - 209
void frontend_close_console(void) {
    // 0x804cab3
    deinit_console((struct anon_struct_1 *)&Console_IO);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804cac7 - 0x804cae9
// Line range:    212 - 215
void frontend_debugf(char * format, char * ap) {
    // 0x804cac7
    abort();
    // UNREACHABLE
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804caea - 0x804cb0c
// Line range:    218 - 221
void frontend_msgf(char * format, char * ap) {
    // 0x804caea
    my_console_printing(g38, format, ap);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804cb0d - 0x804cb2f
// Line range:    224 - 227
void frontend_errorf(char * format, char * ap) {
    // 0x804cb0d
    abort();
    // UNREACHABLE
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804cb30 - 0x804cb5e
// Line range:    230 - 240
int32_t console_printf(char * format, ...) {
    int32_t v1;
    int32_t result = my_console_printing(g38, format, (char *)&v1); // 0x804cb52
    int32_t v2;
    g2 = v2;
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804cb5f - 0x804cb8d
// Line range:    243 - 253
int32_t error_printf(char * format, ...) {
    int32_t v1;
    int32_t result = my_console_printing(g39, format, (char *)&v1); // 0x804cb81
    int32_t v2;
    g2 = v2;
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804cb8e - 0x804cbbc
// Line range:    256 - 266
int32_t report_printf(char * format, ...) {
    int32_t v1;
    int32_t result = my_console_printing(g40, format, (char *)&v1); // 0x804cbb0
    int32_t v2;
    g2 = v2;
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804cbbd - 0x804cbd1
// Line range:    269 - 272
void console_flush(void) {
    // 0x804cbbd
    fflush((struct _IO_FILE *)g38);
    int32_t v1;
    g2 = v1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804cbfc - 0x804cc30
// Line range:    287 - 305
void console_up(int32_t n_lines) {
    int32_t v1 = n_lines - 1;
    if (n_lines < 1) {
        // 0x804cc2a
        console_flush();
        return;
    }
    while (((int32_t)(v1 < 1) | fputs((char *)&g42, (struct _IO_FILE *)g38) & -256) != 1) {
        // 0x804cc04
        v1--;
        // continue -> 0x804cc04
    }
    // 0x804cc2a
    console_flush();
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/console.c
// Address range: 0x804cc31 - 0x804cc8b
// Line range:    309 - 320
void set_debug_file(char * fn) {
    // 0x804cc31
    if (g40 != NULL) {
        // 0x804cc8a
        return;
    }
    struct _IO_FILE * v1 = fopen64(fn, "a"); // 0x804cc4f
    g40 = (struct _IO_FILE_1 *)v1;
    if (v1 == NULL) {
        // 0x804cc77
        error_printf("Error: can't open for debug info: %s\n");
        // branch -> 0x804cc8a
    } else {
        // 0x804cc62
        error_printf("writing debug info into: %s\n");
        // branch -> 0x804cc8a
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804cc8c - 0x804cca0
// Line range:    111 - 117
int32_t min_size_t(uint32_t a, uint32_t b) {
    // 0x804cc8c
    return a < b ? a : b;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804ccbe - 0x804ce8c
// Line range:    134 - 201
int32_t fskip(struct _IO_FILE_2 * fp, int32_t offset, int32_t whence) {
    char v1[4096];
    char data[4096];
    int32_t v2 = *(int32_t *)20; // 0x804ccd1
    int32_t v3 = fileno((struct _IO_FILE *)fp); // 0x804cce4
    v1[0] = v3;
    int32_t v4; // eax
    int32_t result; // 0x804ce8c_2
    int32_t v5; // bp+227
    int32_t v6;
    int32_t v7; // 0x804ce7e
    if (fstat64(v3, (struct stat64 *)&v6) == 0) {
        // 0x804cd0f
        int32_t v8;
        if ((v8 & 0xf000) == 0x1000) {
            // 0x804cd25
            if (offset > 0 && whence == 1) {
                int32_t v9 = offset; // 0x804ce6f1721
                // branch -> 0x804cd3b
                while (true) {
                    int32_t nmemb = min_size_t(0x1000, v9); // 0x804cd49
                    int32_t items_read = fread(data, 1, nmemb, (struct _IO_FILE *)fp); // 0x804cd79
                    if (items_read == 0) {
                        // 0x804cd8d
                        // branch -> 0x804ce7a
                    } else {
                        int32_t v10 = v9 - items_read; // 0x804cd9a
                        if (v10 <= 0) {
                            // break -> 0x804cda9
                            break;
                        }
                        v9 = v10;
                        // continue -> 0x804cd3b
                        continue;
                    }
                    // 0x804ce7a
                    v7 = *(int32_t *)20;
                    g4 = v7 ^ v2;
                    if (v7 != v2) {
                        // 0x804ce86
                        __stack_chk_fail();
                        // branch -> 0x804ce8b
                    }
                    // 0x804ce8b
                    return -1;
                }
                // 0x804cda9
                v4 = 0;
                v5 = 0;
                // branch -> 0x804ce7a
            } else {
                // 0x804cd31
                v4 = -1;
                v5 = -1;
                // branch -> 0x804ce7a
            }
            // 0x804ce7a
            v7 = *(int32_t *)20;
            g4 = v7 ^ v2;
            if (v7 != v2) {
                // 0x804ce86
                __stack_chk_fail();
                result = v4;
                // branch -> 0x804ce8b
            } else {
                result = v5;
            }
            // 0x804ce8b
            return result;
        }
    }
    // 0x804cdb3
    if (fseek((struct _IO_FILE *)fp, offset, whence) == 0) {
        // 0x804cdd3
        // branch -> 0x804ce7a
        // 0x804ce7a
        v7 = *(int32_t *)20;
        g4 = v7 ^ v2;
        if (v7 != v2) {
            // 0x804ce86
            __stack_chk_fail();
            // branch -> 0x804ce8b
        }
        // 0x804ce8b
        return 0;
    }
    // 0x804cddd
    if (offset > 0 && whence == 1) {
        // branch -> 0x804ce0a
        while (true) {
            int32_t nmemb2 = min_size_t(0x1000, offset); // 0x804ce18
            int32_t items_read2 = fread(data, 1, nmemb2, (struct _IO_FILE *)fp); // 0x804ce48
            if (items_read2 == 0) {
                // 0x804ce5c
                // branch -> 0x804ce7a
            } else {
                int32_t v11 = offset - items_read2; // 0x804ce66
                if (v11 <= 0) {
                    // break -> 0x804ce75
                    break;
                }
                offset = v11;
                // continue -> 0x804ce0a
                continue;
            }
            // 0x804ce7a
            v7 = *(int32_t *)20;
            g4 = v7 ^ v2;
            if (v7 != v2) {
                // 0x804ce86
                __stack_chk_fail();
                // branch -> 0x804ce8b
            }
            // 0x804ce8b
            return -1;
        }
        // 0x804ce75
        v4 = 0;
        v5 = 0;
        // branch -> 0x804ce7a
    } else {
        // 0x804cded
        if (silent <= 9) {
            // 0x804cdf7
            error_printf("fskip problem: Mostly the return status of functions is not evaluate so it is more secure to polute <stderr>.\n");
            // branch -> 0x804ce03
        }
        // 0x804ce03
        v4 = -1;
        v5 = -1;
        // branch -> 0x804ce7a
    }
    // 0x804ce7a
    v7 = *(int32_t *)20;
    g4 = v7 ^ v2;
    if (v7 != v2) {
        // 0x804ce86
        __stack_chk_fail();
        result = v4;
        // branch -> 0x804ce8b
    } else {
        result = v5;
    }
    // 0x804ce8b
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804ce8d - 0x804cee7
// Line range:    205 - 236
struct _IO_FILE_2 * init_outfile(char * outPath, int32_t decode) {
    // 0x804ce8d
    if (strcmp(outPath, "-") == 0) {
        // 0x804ceaa
        lame_set_stream_binary_mode((struct _IO_FILE_3 *)g14);
        // branch -> 0x804cee3
        // 0x804cee3
        // branch -> 0x804cee6
        // 0x804cee6
        return (struct _IO_FILE_2 *)(int32_t)g14;
    }
    struct _IO_FILE * v1 = fopen64(outPath, "w+b"); // 0x804cece
    int32_t v2;
    if (v1 != NULL) {
        // 0x804cee3
        v2 = (int32_t)(struct _IO_FILE_2 *)v1;
        // branch -> 0x804cee6
    } else {
        v2 = 0;
    }
    // 0x804cee6
    return (struct _IO_FILE_2 *)v2;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804cee8 - 0x804cf4f
// Line range:    244 - 253
void init_infile(struct lame_global_struct_1 * gfp, char * inPath, int32_t * enc_delay, int32_t * enc_padding) {
    // 0x804cee8
    global = 0;
    g18 = 0;
    g15 = in_bitwidth;
    g16 = swapbytes;
    g17 = in_signed != 1;
    g19 = OpenSndFile(gfp, inPath, enc_delay, enc_padding);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804cf50 - 0x804cf6e
// Line range:    256 - 259
void close_infile(void) {
    // 0x804cf50
    CloseSndFile(input_format, g19);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804cff1 - 0x804d012
// Line range:    330 - 333
int32_t get_audio(struct lame_global_struct_1 * gfp, int32_t (*buffer)[1152]) {
    // 0x804cff1
    return get_audio_common(gfp, buffer, NULL);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804d013 - 0x804d034
// Line range:    340 - 343
int32_t get_audio16(struct lame_global_struct_1 * gfp, int16_t (*buffer)[1152]) {
    int32_t result = get_audio_common(gfp, NULL, buffer); // 0x804d02e
    int32_t v1;
    g2 = v1;
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804d035 - 0x804d383
// Line range:    355 - 469
int32_t get_audio_common(struct lame_global_struct_1 * gfp, int32_t (*buffer)[1152], int16_t (*buffer16)[1152]) {
    int32_t v1;
    int32_t i = v1; // bp-44
    int32_t v2;
    int32_t tmp_num_samples = v2; // bp-40
    int32_t v3;
    int32_t remaining = v3; // bp-36
    int32_t v4;
    int32_t framesize = v4; // bp-28
    int32_t v5;
    int32_t samples_read = v5; // bp-24
    int32_t v6;
    int32_t num_channels = v6; // bp-20
    int32_t v7 = (int32_t)gfp; // 0x804d03e_0
    lame_get_num_channels(v7);
    struct lame_global_struct_1 * v8 = (struct lame_global_struct_1 *)v7;
    int32_t v9 = (int32_t)gfp; // 0x804d04c_0
    lame_get_framesize(v9);
    samples_read = v9;
    framesize = v9;
    int32_t v10 = (int32_t)gfp; // 0x804d060_0
    lame_get_num_samples(v10);
    remaining = v10;
    int32_t v11; // 0x804d154
    int32_t v12; // 0x804d12e
    int32_t v13;
    int32_t v14;
    struct _IO_FILE_2 * v15;
    int32_t v16; // 0x804d18b
    int32_t v17; // 0x804d19a
    int32_t v18; // 0x804d1a9
    int32_t v19; // 0x804d1a982
    int32_t v20; // 0x804d1f3
    int32_t v21; // 0x804d202
    int32_t v22; // 0x804d20289
    int32_t v23; // 0x804d22b
    int32_t v24; // 0x804d23e
    int32_t v25; // 0x804d253
    int32_t v26; // 0x804d25368
    int32_t v27; // 0x804d292
    int32_t v28; // 0x804d2a7
    int32_t v29; // 0x804d2a775
    int32_t v30; // 0x804d2f2
    int32_t v31; // 0x804d2f261
    int32_t v32; // 0x804d330
    int32_t v33; // 0x804d33054
    int32_t v34; // 0x804d161
    int32_t v35; // 0x804d192
    int32_t v36; // 0x804d1a1
    uint32_t v37; // 0x804d232
    uint32_t v38; // 0x804d245
    uint32_t v39; // 0x804d299
    int32_t v40; // 0x804d107
    int32_t v41; // 0x804d2d8
    int32_t (*v42)[1152]; // 0x804d2ec
    int32_t v43; // 0x804d313
    int16_t v44; // 0x804d2de
    int16_t v45; // 0x804d31f
    int32_t (*v46)[1152]; // 0x804d167
    int32_t (*v47)[1152]; // 0x804d2c6
    if (global != 0) {
        uint32_t v48 = g18; // 0x804d077
        int32_t v49 = v10 - (v48 > v10 ? v10 : v48); // 0x804d08a
        if (v10 != 0 && samples_read > v49) {
            // 0x804d09f
            framesize = v49;
            // branch -> 0x804d0a5
        }
        // 0x804d0a5
        if (is_mpeg_file_format(input_format) == 0) {
            // 0x804d10f
            v12 = read_samples_pcm(g19, &v13, framesize * v7);
            num_channels = v12;
            if (v12 > 0) {
                // 0x804d144
                v11 = 4 * v12 + (int32_t)&v13;
                i = v11;
                v34 = (0x100000000 * (int64_t)(v12 >> 31) | (int64_t)v12) / (int64_t)v7;
                num_channels = v34;
                v46 = buffer;
                int32_t result2; // 0x804d374
                int32_t result; // 0x804d37f
                if (v46 == NULL) {
                    // 0x804d211
                    if (v8 == (struct lame_global_struct_1 *)2) {
                        // 0x804d217
                        v26 = v34 - 1;
                        tmp_num_samples = v26;
                        if (v26 > 0) {
                            int32_t v50 = v11; // 0x804d22b
                            int32_t v51 = v26; // 0x804d228
                            while (true) {
                                // 0x804d21f
                                v23 = v50 - 4;
                                i = v23;
                                v37 = *(int32_t *)v23;
                                *(int16_t *)(2 * v51 + 2304 + (int32_t)buffer16) = (int16_t)(v37 / 0x10000);
                                v24 = i - 4;
                                i = v24;
                                v38 = *(int32_t *)v24;
                                *(int16_t *)((int32_t)buffer16 + 2 * tmp_num_samples) = (int16_t)(v38 / 0x10000);
                                v25 = tmp_num_samples - 1;
                                tmp_num_samples = v25;
                                if (v25 > 0) {
                                  lab_0x804d21f:
                                    // 0x804d21f
                                    v50 = i;
                                    v51 = v25;
                                    // branch -> 0x804d21f
                                    continue;
                                }
                            }
                        }
                    } else {
                        // 0x804d25f
                        if (v8 == (struct lame_global_struct_1 *)1) {
                            // 0x804d265
                            memset((char *)((int32_t)buffer16 + 2304), 0, 2 * v34);
                            v29 = num_channels - 1;
                            tmp_num_samples = v29;
                            if (v29 > 0) {
                                v27 = i - 4;
                                i = v27;
                                v39 = *(int32_t *)v27;
                                *(int16_t *)((int32_t)buffer16 + 2 * v29) = (int16_t)(v39 / 0x10000);
                                v28 = tmp_num_samples - 1;
                                tmp_num_samples = v28;
                                while (v28 > 0) {
                                    // 0x804d28f
                                    v27 = i - 4;
                                    i = v27;
                                    v39 = *(int32_t *)v27;
                                    *(int16_t *)((int32_t)buffer16 + 2 * v28) = (int16_t)(v39 / 0x10000);
                                    v28 = tmp_num_samples - 1;
                                    tmp_num_samples = v28;
                                    // continue -> 0x804d28f
                                }
                                // 0x804d2b1
                                if (is_mpeg_file_format(input_format) != 0) {
                                    // 0x804d2c6
                                    v47 = buffer;
                                    if (v47 != NULL) {
                                        // 0x804d2d0
                                        v31 = num_channels - 1;
                                        tmp_num_samples = v31;
                                        if (v31 > 0) {
                                            v42 = v47;
                                            v41 = v31;
                                            while (true) {
                                                // 0x804d2d8
                                                v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                                *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                                v30 = tmp_num_samples - 1;
                                                tmp_num_samples = v30;
                                                if (v30 > 0) {
                                                  lab_0x804d2d8_13:
                                                    // 0x804d2d8
                                                    v42 = buffer;
                                                    v41 = v30;
                                                    // branch -> 0x804d2d8
                                                    continue;
                                                }
                                            }
                                        }
                                        // 0x804d2fc
                                        switch (v7) {
                                            case 2: {
                                                // 0x804d302
                                                v33 = num_channels - 1;
                                                tmp_num_samples = v33;
                                                if (v33 > 0) {
                                                    v43 = v33;
                                                    while (true) {
                                                        // 0x804d30a
                                                        v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                        *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                        v32 = tmp_num_samples - 1;
                                                        tmp_num_samples = v32;
                                                        if (v32 <= 0) {
                                                            // break (via goto) -> 0x804d368
                                                            goto lab_0x804d368_25;
                                                        }
                                                        v43 = v32;
                                                        // continue -> 0x804d30a
                                                    }
                                                }
                                                break;
                                            }
                                            case 1: {
                                                // 0x804d342
                                                memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                                // branch -> 0x804d368
                                                break;
                                            }
                                        }
                                        // 0x804d368
                                        if (remaining == -1) {
                                            // 0x804d368
                                            result = num_channels;
                                            // branch -> 0x804d37f
                                        } else {
                                            // 0x804d36e
                                            result2 = num_channels;
                                            g18 += result2;
                                            result = result2;
                                            // branch -> 0x804d37f
                                        }
                                        // 0x804d37f
                                        // branch -> 0x804d382
                                        // 0x804d382
                                        return result;
                                    }
                                }
                                // 0x804d368
                                if (remaining == -1) {
                                    // 0x804d368
                                    result = num_channels;
                                    // branch -> 0x804d37f
                                } else {
                                    // 0x804d36e
                                    result2 = num_channels;
                                    g18 += result2;
                                    result = result2;
                                    // branch -> 0x804d37f
                                }
                                // 0x804d37f
                                // branch -> 0x804d382
                                // 0x804d382
                                return result;
                            }
                        }
                    }
                    // 0x804d2b1
                    if (is_mpeg_file_format(input_format) != 0) {
                        // 0x804d2c6
                        v47 = buffer;
                        if (v47 != NULL) {
                            // 0x804d2d0
                            v31 = num_channels - 1;
                            tmp_num_samples = v31;
                            if (v31 > 0) {
                                v42 = v47;
                                v41 = v31;
                                while (true) {
                                    // 0x804d2d8
                                    v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                    *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                    v30 = tmp_num_samples - 1;
                                    tmp_num_samples = v30;
                                    if (v30 > 0) {
                                        goto lab_0x804d2d8_13;
                                    }
                                    // 0x804d2fc
                                    switch (v7) {
                                        case 2: {
                                            // 0x804d302
                                            v33 = num_channels - 1;
                                            tmp_num_samples = v33;
                                            if (v33 > 0) {
                                                v43 = v33;
                                                while (true) {
                                                    // 0x804d30a
                                                    v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                    *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                    v32 = tmp_num_samples - 1;
                                                    tmp_num_samples = v32;
                                                    if (v32 <= 0) {
                                                        // break (via goto) -> 0x804d368
                                                        goto lab_0x804d368_25;
                                                    }
                                                    v43 = v32;
                                                    // continue -> 0x804d30a
                                                }
                                            }
                                            break;
                                        }
                                        case 1: {
                                            // 0x804d342
                                            memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                            // branch -> 0x804d368
                                            break;
                                        }
                                    }
                                    // 0x804d368
                                    if (remaining == -1) {
                                        // 0x804d368
                                        // branch -> 0x804d37f
                                        // 0x804d37f
                                        // branch -> 0x804d382
                                        // 0x804d382
                                        return num_channels;
                                    }
                                    // 0x804d36e
                                    result2 = num_channels;
                                    g18 += result2;
                                    // branch -> 0x804d37f
                                    // 0x804d37f
                                    // branch -> 0x804d382
                                    // 0x804d382
                                    return result2;
                                }
                            }
                            // 0x804d2fc
                            switch (v7) {
                                case 2: {
                                    // 0x804d302
                                    v33 = num_channels - 1;
                                    tmp_num_samples = v33;
                                    if (v33 > 0) {
                                        v43 = v33;
                                        while (true) {
                                            // 0x804d30a
                                            v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                            *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                            v32 = tmp_num_samples - 1;
                                            tmp_num_samples = v32;
                                            if (v32 <= 0) {
                                                // break (via goto) -> 0x804d368
                                                goto lab_0x804d368_25;
                                            }
                                            v43 = v32;
                                            // continue -> 0x804d30a
                                        }
                                    }
                                    break;
                                }
                                case 1: {
                                    // 0x804d342
                                    memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                    // branch -> 0x804d368
                                    break;
                                }
                            }
                            // 0x804d368
                            if (remaining == -1) {
                                // 0x804d368
                                result = num_channels;
                                // branch -> 0x804d37f
                            } else {
                                // 0x804d36e
                                result2 = num_channels;
                                g18 += result2;
                                result = result2;
                                // branch -> 0x804d37f
                            }
                            // 0x804d37f
                            // branch -> 0x804d382
                            // 0x804d382
                            return result;
                        }
                    }
                    // 0x804d368
                    if (remaining == -1) {
                        // 0x804d368
                        result = num_channels;
                        // branch -> 0x804d37f
                    } else {
                        // 0x804d36e
                        result2 = num_channels;
                        g18 += result2;
                        result = result2;
                        // branch -> 0x804d37f
                    }
                    // 0x804d37f
                    // branch -> 0x804d382
                    // 0x804d382
                    return result;
                }
                // 0x804d171
                if (v8 == (struct lame_global_struct_1 *)2) {
                    // 0x804d177
                    v19 = v34 - 1;
                    tmp_num_samples = v19;
                    if (v19 > 0) {
                        int32_t v52 = v11; // 0x804d18b
                        int32_t v53 = v19; // 0x804d188
                        int32_t (*v54)[1152] = v46; // 0x804d17f
                        while (true) {
                            // 0x804d17f
                            v16 = v52 - 4;
                            i = v16;
                            v35 = *(int32_t *)v16;
                            *(int32_t *)(4 * v53 + 0x1200 + (int32_t)v54) = v35;
                            v17 = i - 4;
                            i = v17;
                            v36 = *(int32_t *)v17;
                            *(int32_t *)((int32_t)buffer + 4 * tmp_num_samples) = v36;
                            v18 = tmp_num_samples - 1;
                            tmp_num_samples = v18;
                            if (v18 > 0) {
                              lab_0x804d17f:
                                // 0x804d17f
                                v52 = i;
                                v53 = v18;
                                v54 = buffer;
                                // branch -> 0x804d17f
                                continue;
                            }
                        }
                    }
                } else {
                    // 0x804d1b8
                    if (v8 == (struct lame_global_struct_1 *)1) {
                        // 0x804d1c2
                        memset((char *)((int32_t)v46 + 0x1200), 0, 4 * v34);
                        v22 = num_channels - 1;
                        tmp_num_samples = v22;
                        if (v22 > 0) {
                            v20 = i - 4;
                            i = v20;
                            *(int32_t *)((int32_t)buffer + 4 * v22) = *(int32_t *)v20;
                            v21 = tmp_num_samples - 1;
                            tmp_num_samples = v21;
                            while (v21 > 0) {
                                // 0x804d1f0
                                v20 = i - 4;
                                i = v20;
                                *(int32_t *)((int32_t)buffer + 4 * v21) = *(int32_t *)v20;
                                v21 = tmp_num_samples - 1;
                                tmp_num_samples = v21;
                                // continue -> 0x804d1f0
                            }
                            // 0x804d2b1
                            if (is_mpeg_file_format(input_format) != 0) {
                                // 0x804d2c6
                                v47 = buffer;
                                if (v47 != NULL) {
                                    // 0x804d2d0
                                    v31 = num_channels - 1;
                                    tmp_num_samples = v31;
                                    if (v31 > 0) {
                                        v42 = v47;
                                        v41 = v31;
                                        while (true) {
                                            // 0x804d2d8
                                            v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                            *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                            v30 = tmp_num_samples - 1;
                                            tmp_num_samples = v30;
                                            if (v30 > 0) {
                                                goto lab_0x804d2d8_13;
                                            }
                                            // 0x804d2fc
                                            switch (v7) {
                                                case 2: {
                                                    // 0x804d302
                                                    v33 = num_channels - 1;
                                                    tmp_num_samples = v33;
                                                    if (v33 > 0) {
                                                        v43 = v33;
                                                        while (true) {
                                                            // 0x804d30a
                                                            v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                            *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                            v32 = tmp_num_samples - 1;
                                                            tmp_num_samples = v32;
                                                            if (v32 <= 0) {
                                                                // break (via goto) -> 0x804d368
                                                                goto lab_0x804d368_25;
                                                            }
                                                            v43 = v32;
                                                            // continue -> 0x804d30a
                                                        }
                                                    }
                                                    break;
                                                }
                                                case 1: {
                                                    // 0x804d342
                                                    memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                                    // branch -> 0x804d368
                                                    break;
                                                }
                                            }
                                            // 0x804d368
                                            if (remaining == -1) {
                                                // 0x804d368
                                                // branch -> 0x804d37f
                                                // 0x804d37f
                                                // branch -> 0x804d382
                                                // 0x804d382
                                                return num_channels;
                                            }
                                            // 0x804d36e
                                            result2 = num_channels;
                                            g18 += result2;
                                            // branch -> 0x804d37f
                                            // 0x804d37f
                                            // branch -> 0x804d382
                                            // 0x804d382
                                            return result2;
                                        }
                                    }
                                    // 0x804d2fc
                                    switch (v7) {
                                        case 2: {
                                            // 0x804d302
                                            v33 = num_channels - 1;
                                            tmp_num_samples = v33;
                                            if (v33 > 0) {
                                                v43 = v33;
                                                while (true) {
                                                    // 0x804d30a
                                                    v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                    *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                    v32 = tmp_num_samples - 1;
                                                    tmp_num_samples = v32;
                                                    if (v32 <= 0) {
                                                        // break (via goto) -> 0x804d368
                                                        goto lab_0x804d368_25;
                                                    }
                                                    v43 = v32;
                                                    // continue -> 0x804d30a
                                                }
                                            }
                                            break;
                                        }
                                        case 1: {
                                            // 0x804d342
                                            memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                            // branch -> 0x804d368
                                            break;
                                        }
                                    }
                                    // 0x804d368
                                    if (remaining == -1) {
                                        // 0x804d368
                                        result = num_channels;
                                        // branch -> 0x804d37f
                                    } else {
                                        // 0x804d36e
                                        result2 = num_channels;
                                        g18 += result2;
                                        result = result2;
                                        // branch -> 0x804d37f
                                    }
                                    // 0x804d37f
                                    // branch -> 0x804d382
                                    // 0x804d382
                                    return result;
                                }
                            }
                            // 0x804d368
                            if (remaining == -1) {
                                // 0x804d368
                                result = num_channels;
                                // branch -> 0x804d37f
                            } else {
                                // 0x804d36e
                                result2 = num_channels;
                                g18 += result2;
                                result = result2;
                                // branch -> 0x804d37f
                            }
                            // 0x804d37f
                            // branch -> 0x804d382
                            // 0x804d382
                            return result;
                        }
                    }
                }
                // 0x804d2b1
                if (is_mpeg_file_format(input_format) != 0) {
                    // 0x804d2c6
                    v47 = buffer;
                    if (v47 != NULL) {
                        // 0x804d2d0
                        v31 = num_channels - 1;
                        tmp_num_samples = v31;
                        if (v31 > 0) {
                            v42 = v47;
                            v41 = v31;
                            while (true) {
                                // 0x804d2d8
                                v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                v30 = tmp_num_samples - 1;
                                tmp_num_samples = v30;
                                if (v30 > 0) {
                                    goto lab_0x804d2d8_13;
                                }
                                // 0x804d2fc
                                switch (v7) {
                                    case 2: {
                                        // 0x804d302
                                        v33 = num_channels - 1;
                                        tmp_num_samples = v33;
                                        if (v33 > 0) {
                                            v43 = v33;
                                            while (true) {
                                                // 0x804d30a
                                                v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                v32 = tmp_num_samples - 1;
                                                tmp_num_samples = v32;
                                                if (v32 <= 0) {
                                                    // break (via goto) -> 0x804d368
                                                    goto lab_0x804d368_25;
                                                }
                                                v43 = v32;
                                                // continue -> 0x804d30a
                                            }
                                        }
                                        break;
                                    }
                                    case 1: {
                                        // 0x804d342
                                        memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                        // branch -> 0x804d368
                                        break;
                                    }
                                }
                                // 0x804d368
                                if (remaining == -1) {
                                    // 0x804d368
                                    // branch -> 0x804d37f
                                    // 0x804d37f
                                    // branch -> 0x804d382
                                    // 0x804d382
                                    return num_channels;
                                }
                                // 0x804d36e
                                g18 += num_channels;
                                // branch -> 0x804d37f
                                // Detected a possible infinite recursion (goto support failed); quitting...
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804d2fc
                        switch (v7) {
                            case 2: {
                                // 0x804d302
                                v33 = num_channels - 1;
                                tmp_num_samples = v33;
                                if (v33 > 0) {
                                    v43 = v33;
                                    while (true) {
                                        // 0x804d30a
                                        v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                        *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                        v32 = tmp_num_samples - 1;
                                        tmp_num_samples = v32;
                                        if (v32 <= 0) {
                                            // break (via goto) -> 0x804d368
                                            goto lab_0x804d368_25;
                                        }
                                        v43 = v32;
                                        // continue -> 0x804d30a
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                break;
                            }
                            case 1: {
                                // 0x804d342
                                memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                // branch -> 0x804d368
                                break;
                            }
                        }
                        // 0x804d368
                        if (remaining == -1) {
                            // 0x804d368
                            // branch -> 0x804d37f
                        } else {
                            // 0x804d36e
                            g18 += num_channels;
                            // branch -> 0x804d37f
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x804d368
                if (remaining == -1) {
                    // 0x804d368
                    // branch -> 0x804d37f
                } else {
                    // 0x804d36e
                    g18 += num_channels;
                    // branch -> 0x804d37f
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
                // 0x804d2b1
                if (is_mpeg_file_format(input_format) != 0) {
                    // 0x804d2c6
                    v47 = buffer;
                    if (v47 != NULL) {
                        // 0x804d2d0
                        v31 = num_channels - 1;
                        tmp_num_samples = v31;
                        if (v31 > 0) {
                            v42 = v47;
                            v41 = v31;
                            while (true) {
                                // 0x804d2d8
                                v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                v30 = tmp_num_samples - 1;
                                tmp_num_samples = v30;
                                if (v30 > 0) {
                                    goto lab_0x804d2d8_13;
                                }
                                // 0x804d2fc
                                switch (v7) {
                                    case 2: {
                                        // 0x804d302
                                        v33 = num_channels - 1;
                                        tmp_num_samples = v33;
                                        if (v33 > 0) {
                                            v43 = v33;
                                            while (true) {
                                                // 0x804d30a
                                                v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                v32 = tmp_num_samples - 1;
                                                tmp_num_samples = v32;
                                                if (v32 <= 0) {
                                                    // break (via goto) -> 0x804d368
                                                    goto lab_0x804d368_25;
                                                }
                                                v43 = v32;
                                                // continue -> 0x804d30a
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        break;
                                    }
                                    case 1: {
                                        // 0x804d342
                                        memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                        // branch -> 0x804d368
                                        break;
                                    }
                                }
                                // 0x804d368
                                if (remaining == -1) {
                                    // 0x804d368
                                    // branch -> 0x804d37f
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x804d36e
                                    g18 += num_channels;
                                    // branch -> 0x804d37f
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804d2fc
                        switch (v7) {
                            case 2: {
                                // 0x804d302
                                v33 = num_channels - 1;
                                tmp_num_samples = v33;
                                if (v33 > 0) {
                                    v43 = v33;
                                    while (true) {
                                        // 0x804d30a
                                        v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                        *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                        v32 = tmp_num_samples - 1;
                                        tmp_num_samples = v32;
                                        if (v32 <= 0) {
                                            // break (via goto) -> 0x804d368
                                            goto lab_0x804d368_25;
                                        }
                                        v43 = v32;
                                        // continue -> 0x804d30a
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                break;
                            }
                            case 1: {
                                // 0x804d342
                                memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                // branch -> 0x804d368
                                break;
                            }
                        }
                        // 0x804d368
                        if (remaining == -1) {
                            // 0x804d368
                            // branch -> 0x804d37f
                        } else {
                            // 0x804d36e
                            g18 += num_channels;
                            // branch -> 0x804d37f
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x804d368
                if (remaining == -1) {
                    // 0x804d368
                    // branch -> 0x804d37f
                } else {
                    // 0x804d36e
                    g18 += num_channels;
                    // branch -> 0x804d37f
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        } else {
            // 0x804d0b6
            v15 = g19;
            if (buffer == NULL) {
                // 0x804d0df
                v40 = read_samples_mp3(gfp, v15, buffer16);
                // branch -> 0x804d0fd
            } else {
                // 0x804d0bc
                v40 = read_samples_mp3(gfp, v15, (int16_t (*)[1152])&v14);
                // branch -> 0x804d0fd
            }
            // 0x804d0fd
            num_channels = v40;
            if (v40 > 0) {
                // 0x804d2b1
                if (is_mpeg_file_format(input_format) != 0) {
                    // 0x804d2c6
                    v47 = buffer;
                    if (v47 != NULL) {
                        // 0x804d2d0
                        v31 = num_channels - 1;
                        tmp_num_samples = v31;
                        if (v31 > 0) {
                            v42 = v47;
                            v41 = v31;
                            while (true) {
                                // 0x804d2d8
                                v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                v30 = tmp_num_samples - 1;
                                tmp_num_samples = v30;
                                if (v30 > 0) {
                                    goto lab_0x804d2d8_13;
                                }
                                // 0x804d2fc
                                switch (v7) {
                                    case 2: {
                                        // 0x804d302
                                        v33 = num_channels - 1;
                                        tmp_num_samples = v33;
                                        if (v33 > 0) {
                                            v43 = v33;
                                            while (true) {
                                                // 0x804d30a
                                                v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                v32 = tmp_num_samples - 1;
                                                tmp_num_samples = v32;
                                                if (v32 <= 0) {
                                                    // break (via goto) -> 0x804d368
                                                    goto lab_0x804d368_25;
                                                }
                                                v43 = v32;
                                                // continue -> 0x804d30a
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        break;
                                    }
                                    case 1: {
                                        // 0x804d342
                                        memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                        // branch -> 0x804d368
                                        break;
                                    }
                                }
                              lab_0x804d368_25:
                                // 0x804d368
                                if (remaining == -1) {
                                    // 0x804d368
                                    // branch -> 0x804d37f
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x804d36e
                                    g18 += num_channels;
                                    // branch -> 0x804d37f
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804d2fc
                        switch (v7) {
                            case 2: {
                                // 0x804d302
                                v33 = num_channels - 1;
                                tmp_num_samples = v33;
                                if (v33 > 0) {
                                    v43 = v33;
                                    while (true) {
                                        // 0x804d30a
                                        v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                        *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                        v32 = tmp_num_samples - 1;
                                        tmp_num_samples = v32;
                                        if (v32 <= 0) {
                                            // break (via goto) -> 0x804d368
                                            goto lab_0x804d368_25;
                                        }
                                        v43 = v32;
                                        // continue -> 0x804d30a
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                break;
                            }
                            case 1: {
                                // 0x804d342
                                memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                // branch -> 0x804d368
                                break;
                            }
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804d0a5
    if (is_mpeg_file_format(input_format) == 0) {
        // 0x804d10f
        v12 = read_samples_pcm(g19, &v13, framesize * v7);
        num_channels = v12;
        if (v12 > 0) {
            // 0x804d144
            v11 = 4 * v12 + (int32_t)&v13;
            i = v11;
            v34 = (0x100000000 * (int64_t)(v12 >> 31) | (int64_t)v12) / (int64_t)v7;
            num_channels = v34;
            v46 = buffer;
            if (v46 == NULL) {
                // 0x804d211
                if (v8 == (struct lame_global_struct_1 *)2) {
                    // 0x804d217
                    v26 = v34 - 1;
                    tmp_num_samples = v26;
                    if (v26 > 0) {
                        while (true) {
                            // 0x804d21f
                            v23 = v11 - 4;
                            i = v23;
                            v37 = *(int32_t *)v23;
                            *(int16_t *)(2 * v26 + 2304 + (int32_t)buffer16) = (int16_t)(v37 / 0x10000);
                            v24 = i - 4;
                            i = v24;
                            v38 = *(int32_t *)v24;
                            *(int16_t *)((int32_t)buffer16 + 2 * tmp_num_samples) = (int16_t)(v38 / 0x10000);
                            v25 = tmp_num_samples - 1;
                            tmp_num_samples = v25;
                            if (v25 > 0) {
                                goto lab_0x804d21f;
                            }
                            // 0x804d2b1
                            if (is_mpeg_file_format(input_format) != 0) {
                                // 0x804d2c6
                                v47 = buffer;
                                if (v47 != NULL) {
                                    // 0x804d2d0
                                    v31 = num_channels - 1;
                                    tmp_num_samples = v31;
                                    if (v31 > 0) {
                                        v42 = v47;
                                        v41 = v31;
                                        while (true) {
                                            // 0x804d2d8
                                            v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                            *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                            v30 = tmp_num_samples - 1;
                                            tmp_num_samples = v30;
                                            if (v30 > 0) {
                                                goto lab_0x804d2d8_13;
                                            }
                                            // 0x804d2fc
                                            switch (v7) {
                                                case 2: {
                                                    // 0x804d302
                                                    v33 = num_channels - 1;
                                                    tmp_num_samples = v33;
                                                    if (v33 > 0) {
                                                        v43 = v33;
                                                        while (true) {
                                                            // 0x804d30a
                                                            v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                            *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                            v32 = tmp_num_samples - 1;
                                                            tmp_num_samples = v32;
                                                            if (v32 <= 0) {
                                                                // break (via goto) -> 0x804d368
                                                                goto lab_0x804d368_25;
                                                            }
                                                            v43 = v32;
                                                            // continue -> 0x804d30a
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    break;
                                                }
                                                case 1: {
                                                    // 0x804d342
                                                    memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                                    // branch -> 0x804d368
                                                    break;
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d2fc
                                    switch (v7) {
                                        case 2: {
                                            // 0x804d302
                                            v33 = num_channels - 1;
                                            tmp_num_samples = v33;
                                            if (v33 > 0) {
                                                v43 = v33;
                                                while (true) {
                                                    // 0x804d30a
                                                    v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                    *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                    v32 = tmp_num_samples - 1;
                                                    tmp_num_samples = v32;
                                                    if (v32 <= 0) {
                                                        // break (via goto) -> 0x804d368
                                                        goto lab_0x804d368_25;
                                                    }
                                                    v43 = v32;
                                                    // continue -> 0x804d30a
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            break;
                                        }
                                        case 1: {
                                            // 0x804d342
                                            memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                            // branch -> 0x804d368
                                            break;
                                        }
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                } else {
                    // 0x804d25f
                    if (v8 == (struct lame_global_struct_1 *)1) {
                        // 0x804d265
                        memset((char *)((int32_t)buffer16 + 2304), 0, 2 * v34);
                        v29 = num_channels - 1;
                        tmp_num_samples = v29;
                        if (v29 > 0) {
                            v27 = i - 4;
                            i = v27;
                            v39 = *(int32_t *)v27;
                            *(int16_t *)((int32_t)buffer16 + 2 * v29) = (int16_t)(v39 / 0x10000);
                            v28 = tmp_num_samples - 1;
                            tmp_num_samples = v28;
                            while (v28 > 0) {
                                // 0x804d28f
                                v27 = i - 4;
                                i = v27;
                                v39 = *(int32_t *)v27;
                                *(int16_t *)((int32_t)buffer16 + 2 * v28) = (int16_t)(v39 / 0x10000);
                                v28 = tmp_num_samples - 1;
                                tmp_num_samples = v28;
                                // continue -> 0x804d28f
                            }
                            // 0x804d2b1
                            if (is_mpeg_file_format(input_format) != 0) {
                                // 0x804d2c6
                                v47 = buffer;
                                if (v47 != NULL) {
                                    // 0x804d2d0
                                    v31 = num_channels - 1;
                                    tmp_num_samples = v31;
                                    if (v31 > 0) {
                                        v42 = v47;
                                        v41 = v31;
                                        while (true) {
                                            // 0x804d2d8
                                            v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                            *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                            v30 = tmp_num_samples - 1;
                                            tmp_num_samples = v30;
                                            if (v30 > 0) {
                                                goto lab_0x804d2d8_13;
                                            }
                                            // 0x804d2fc
                                            switch (v7) {
                                                case 2: {
                                                    // 0x804d302
                                                    v33 = num_channels - 1;
                                                    tmp_num_samples = v33;
                                                    if (v33 > 0) {
                                                        v43 = v33;
                                                        while (true) {
                                                            // 0x804d30a
                                                            v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                            *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                            v32 = tmp_num_samples - 1;
                                                            tmp_num_samples = v32;
                                                            if (v32 <= 0) {
                                                                // break (via goto) -> 0x804d368
                                                                goto lab_0x804d368_25;
                                                            }
                                                            v43 = v32;
                                                            // continue -> 0x804d30a
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    break;
                                                }
                                                case 1: {
                                                    // 0x804d342
                                                    memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                                    // branch -> 0x804d368
                                                    break;
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d2fc
                                    switch (v7) {
                                        case 2: {
                                            // 0x804d302
                                            v33 = num_channels - 1;
                                            tmp_num_samples = v33;
                                            if (v33 > 0) {
                                                v43 = v33;
                                                while (true) {
                                                    // 0x804d30a
                                                    v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                    *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                    v32 = tmp_num_samples - 1;
                                                    tmp_num_samples = v32;
                                                    if (v32 <= 0) {
                                                        // break (via goto) -> 0x804d368
                                                        goto lab_0x804d368_25;
                                                    }
                                                    v43 = v32;
                                                    // continue -> 0x804d30a
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            break;
                                        }
                                        case 1: {
                                            // 0x804d342
                                            memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                            // branch -> 0x804d368
                                            break;
                                        }
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                }
                // 0x804d2b1
                if (is_mpeg_file_format(input_format) != 0) {
                    // 0x804d2c6
                    v47 = buffer;
                    if (v47 != NULL) {
                        // 0x804d2d0
                        v31 = num_channels - 1;
                        tmp_num_samples = v31;
                        if (v31 > 0) {
                            v42 = v47;
                            v41 = v31;
                            while (true) {
                                // 0x804d2d8
                                v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                v30 = tmp_num_samples - 1;
                                tmp_num_samples = v30;
                                if (v30 > 0) {
                                    goto lab_0x804d2d8_13;
                                }
                                // 0x804d2fc
                                switch (v7) {
                                    case 2: {
                                        // 0x804d302
                                        v33 = num_channels - 1;
                                        tmp_num_samples = v33;
                                        if (v33 > 0) {
                                            v43 = v33;
                                            while (true) {
                                                // 0x804d30a
                                                v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                v32 = tmp_num_samples - 1;
                                                tmp_num_samples = v32;
                                                if (v32 <= 0) {
                                                    // break (via goto) -> 0x804d368
                                                    goto lab_0x804d368_25;
                                                }
                                                v43 = v32;
                                                // continue -> 0x804d30a
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        break;
                                    }
                                    case 1: {
                                        // 0x804d342
                                        memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                        // branch -> 0x804d368
                                        break;
                                    }
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804d2fc
                        switch (v7) {
                            case 2: {
                                // 0x804d302
                                v33 = num_channels - 1;
                                tmp_num_samples = v33;
                                if (v33 > 0) {
                                    v43 = v33;
                                    while (true) {
                                        // 0x804d30a
                                        v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                        *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                        v32 = tmp_num_samples - 1;
                                        tmp_num_samples = v32;
                                        if (v32 <= 0) {
                                            // break (via goto) -> 0x804d368
                                            goto lab_0x804d368_25;
                                        }
                                        v43 = v32;
                                        // continue -> 0x804d30a
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                break;
                            }
                            case 1: {
                                // 0x804d342
                                memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                // branch -> 0x804d368
                                break;
                            }
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            } else {
                // 0x804d171
                if (v8 == (struct lame_global_struct_1 *)2) {
                    // 0x804d177
                    v19 = v34 - 1;
                    tmp_num_samples = v19;
                    if (v19 > 0) {
                        while (true) {
                            // 0x804d17f
                            v16 = v11 - 4;
                            i = v16;
                            v35 = *(int32_t *)v16;
                            *(int32_t *)(4 * v19 + 0x1200 + (int32_t)v46) = v35;
                            v17 = i - 4;
                            i = v17;
                            v36 = *(int32_t *)v17;
                            *(int32_t *)((int32_t)buffer + 4 * tmp_num_samples) = v36;
                            v18 = tmp_num_samples - 1;
                            tmp_num_samples = v18;
                            if (v18 > 0) {
                                goto lab_0x804d17f;
                            }
                            // 0x804d2b1
                            if (is_mpeg_file_format(input_format) != 0) {
                                // 0x804d2c6
                                v47 = buffer;
                                if (v47 != NULL) {
                                    // 0x804d2d0
                                    v31 = num_channels - 1;
                                    tmp_num_samples = v31;
                                    if (v31 > 0) {
                                        v42 = v47;
                                        v41 = v31;
                                        while (true) {
                                            // 0x804d2d8
                                            v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                            *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                            v30 = tmp_num_samples - 1;
                                            tmp_num_samples = v30;
                                            if (v30 > 0) {
                                                goto lab_0x804d2d8_13;
                                            }
                                            // 0x804d2fc
                                            switch (v7) {
                                                case 2: {
                                                    // 0x804d302
                                                    v33 = num_channels - 1;
                                                    tmp_num_samples = v33;
                                                    if (v33 > 0) {
                                                        v43 = v33;
                                                        while (true) {
                                                            // 0x804d30a
                                                            v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                            *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                            v32 = tmp_num_samples - 1;
                                                            tmp_num_samples = v32;
                                                            if (v32 <= 0) {
                                                                // break (via goto) -> 0x804d368
                                                                goto lab_0x804d368_25;
                                                            }
                                                            v43 = v32;
                                                            // continue -> 0x804d30a
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    break;
                                                }
                                                case 1: {
                                                    // 0x804d342
                                                    memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                                    // branch -> 0x804d368
                                                    break;
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d2fc
                                    switch (v7) {
                                        case 2: {
                                            // 0x804d302
                                            v33 = num_channels - 1;
                                            tmp_num_samples = v33;
                                            if (v33 > 0) {
                                                v43 = v33;
                                                while (true) {
                                                    // 0x804d30a
                                                    v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                    *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                    v32 = tmp_num_samples - 1;
                                                    tmp_num_samples = v32;
                                                    if (v32 <= 0) {
                                                        // break (via goto) -> 0x804d368
                                                        goto lab_0x804d368_25;
                                                    }
                                                    v43 = v32;
                                                    // continue -> 0x804d30a
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            break;
                                        }
                                        case 1: {
                                            // 0x804d342
                                            memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                            // branch -> 0x804d368
                                            break;
                                        }
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                } else {
                    // 0x804d1b8
                    if (v8 == (struct lame_global_struct_1 *)1) {
                        // 0x804d1c2
                        memset((char *)((int32_t)v46 + 0x1200), 0, 4 * v34);
                        v22 = num_channels - 1;
                        tmp_num_samples = v22;
                        if (v22 > 0) {
                            v20 = i - 4;
                            i = v20;
                            *(int32_t *)((int32_t)buffer + 4 * v22) = *(int32_t *)v20;
                            v21 = tmp_num_samples - 1;
                            tmp_num_samples = v21;
                            while (v21 > 0) {
                                // 0x804d1f0
                                v20 = i - 4;
                                i = v20;
                                *(int32_t *)((int32_t)buffer + 4 * v21) = *(int32_t *)v20;
                                v21 = tmp_num_samples - 1;
                                tmp_num_samples = v21;
                                // continue -> 0x804d1f0
                            }
                            // 0x804d2b1
                            if (is_mpeg_file_format(input_format) != 0) {
                                // 0x804d2c6
                                v47 = buffer;
                                if (v47 != NULL) {
                                    // 0x804d2d0
                                    v31 = num_channels - 1;
                                    tmp_num_samples = v31;
                                    if (v31 > 0) {
                                        v42 = v47;
                                        v41 = v31;
                                        while (true) {
                                            // 0x804d2d8
                                            v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                            *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                            v30 = tmp_num_samples - 1;
                                            tmp_num_samples = v30;
                                            if (v30 > 0) {
                                                goto lab_0x804d2d8_13;
                                            }
                                            // 0x804d2fc
                                            switch (v7) {
                                                case 2: {
                                                    // 0x804d302
                                                    v33 = num_channels - 1;
                                                    tmp_num_samples = v33;
                                                    if (v33 > 0) {
                                                        v43 = v33;
                                                        while (true) {
                                                            // 0x804d30a
                                                            v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                            *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                            v32 = tmp_num_samples - 1;
                                                            tmp_num_samples = v32;
                                                            if (v32 <= 0) {
                                                                // break (via goto) -> 0x804d368
                                                                goto lab_0x804d368_25;
                                                            }
                                                            v43 = v32;
                                                            // continue -> 0x804d30a
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    break;
                                                }
                                                case 1: {
                                                    // 0x804d342
                                                    memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                                    // branch -> 0x804d368
                                                    break;
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d2fc
                                    switch (v7) {
                                        case 2: {
                                            // 0x804d302
                                            v33 = num_channels - 1;
                                            tmp_num_samples = v33;
                                            if (v33 > 0) {
                                                v43 = v33;
                                                while (true) {
                                                    // 0x804d30a
                                                    v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                    *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                    v32 = tmp_num_samples - 1;
                                                    tmp_num_samples = v32;
                                                    if (v32 <= 0) {
                                                        // break (via goto) -> 0x804d368
                                                        goto lab_0x804d368_25;
                                                    }
                                                    v43 = v32;
                                                    // continue -> 0x804d30a
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            break;
                                        }
                                        case 1: {
                                            // 0x804d342
                                            memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                            // branch -> 0x804d368
                                            break;
                                        }
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                }
                // 0x804d2b1
                if (is_mpeg_file_format(input_format) != 0) {
                    // 0x804d2c6
                    v47 = buffer;
                    if (v47 != NULL) {
                        // 0x804d2d0
                        v31 = num_channels - 1;
                        tmp_num_samples = v31;
                        if (v31 > 0) {
                            v42 = v47;
                            v41 = v31;
                            while (true) {
                                // 0x804d2d8
                                v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                                *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                                v30 = tmp_num_samples - 1;
                                tmp_num_samples = v30;
                                if (v30 > 0) {
                                    goto lab_0x804d2d8_13;
                                }
                                // 0x804d2fc
                                switch (v7) {
                                    case 2: {
                                        // 0x804d302
                                        v33 = num_channels - 1;
                                        tmp_num_samples = v33;
                                        if (v33 > 0) {
                                            v43 = v33;
                                            while (true) {
                                                // 0x804d30a
                                                v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                                *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                                v32 = tmp_num_samples - 1;
                                                tmp_num_samples = v32;
                                                if (v32 <= 0) {
                                                    // break (via goto) -> 0x804d368
                                                    goto lab_0x804d368_25;
                                                }
                                                v43 = v32;
                                                // continue -> 0x804d30a
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        break;
                                    }
                                    case 1: {
                                        // 0x804d342
                                        memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                        // branch -> 0x804d368
                                        break;
                                    }
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804d2fc
                        switch (v7) {
                            case 2: {
                                // 0x804d302
                                v33 = num_channels - 1;
                                tmp_num_samples = v33;
                                if (v33 > 0) {
                                    v43 = v33;
                                    while (true) {
                                        // 0x804d30a
                                        v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                        *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                        v32 = tmp_num_samples - 1;
                                        tmp_num_samples = v32;
                                        if (v32 <= 0) {
                                            // break (via goto) -> 0x804d368
                                            goto lab_0x804d368_25;
                                        }
                                        v43 = v32;
                                        // continue -> 0x804d30a
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                break;
                            }
                            case 1: {
                                // 0x804d342
                                memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                // branch -> 0x804d368
                                break;
                            }
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804d2b1
            if (is_mpeg_file_format(input_format) != 0) {
                // 0x804d2c6
                v47 = buffer;
                if (v47 != NULL) {
                    // 0x804d2d0
                    v31 = num_channels - 1;
                    tmp_num_samples = v31;
                    if (v31 > 0) {
                        v42 = v47;
                        v41 = v31;
                        while (true) {
                            // 0x804d2d8
                            v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                            *(int32_t *)(4 * v41 + (int32_t)v42) = 0x10000 * (int32_t)v44;
                            v30 = tmp_num_samples - 1;
                            tmp_num_samples = v30;
                            if (v30 > 0) {
                                goto lab_0x804d2d8_13;
                            }
                            // 0x804d2fc
                            switch (v7) {
                                case 2: {
                                    // 0x804d302
                                    v33 = num_channels - 1;
                                    tmp_num_samples = v33;
                                    if (v33 > 0) {
                                        v43 = v33;
                                        while (true) {
                                            // 0x804d30a
                                            v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                            *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                            v32 = tmp_num_samples - 1;
                                            tmp_num_samples = v32;
                                            if (v32 <= 0) {
                                                // break (via goto) -> 0x804d368
                                                goto lab_0x804d368_25;
                                            }
                                            v43 = v32;
                                            // continue -> 0x804d30a
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    break;
                                }
                                case 1: {
                                    // 0x804d342
                                    memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                                    // branch -> 0x804d368
                                    break;
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804d2fc
                    switch (v7) {
                        case 2: {
                            // 0x804d302
                            v33 = num_channels - 1;
                            tmp_num_samples = v33;
                            if (v33 > 0) {
                                v43 = v33;
                                while (true) {
                                    // 0x804d30a
                                    v45 = *(int16_t *)(2 * v43 - 2344 + g2);
                                    *(int32_t *)((int32_t)buffer + 0x1200 + 4 * v43) = 0x10000 * (int32_t)v45;
                                    v32 = tmp_num_samples - 1;
                                    tmp_num_samples = v32;
                                    if (v32 <= 0) {
                                        // break (via goto) -> 0x804d368
                                        goto lab_0x804d368_25;
                                    }
                                    v43 = v32;
                                    // continue -> 0x804d30a
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            break;
                        }
                        case 1: {
                            // 0x804d342
                            memset((char *)((int32_t)buffer + 0x1200), 0, 4 * num_channels);
                            // branch -> 0x804d368
                            break;
                        }
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
    } else {
        // 0x804d0b6
        v15 = g19;
        if (buffer == NULL) {
            // 0x804d0df
            v40 = read_samples_mp3(gfp, v15, buffer16);
            // branch -> 0x804d0fd
        } else {
            // 0x804d0bc
            v40 = read_samples_mp3(gfp, v15, (int16_t (*)[1152])&v14);
            // branch -> 0x804d0fd
        }
        // 0x804d0fd
        num_channels = v40;
        if (v40 > 0) {
            // 0x804d2b1
            if (is_mpeg_file_format(input_format) != 0) {
                // 0x804d2c6
                v47 = buffer;
                if (v47 != NULL) {
                    // 0x804d2d0
                    v31 = num_channels - 1;
                    tmp_num_samples = v31;
                    if (v31 > 0) {
                        v41 = v31;
                        while (true) {
                            // 0x804d2d8
                            v44 = *(int16_t *)(g2 - 0x1228 + 2 * v41);
                            *(int32_t *)(4 * v41 + (int32_t)v47) = 0x10000 * (int32_t)v44;
                            v30 = tmp_num_samples - 1;
                            tmp_num_samples = v30;
                            if (v30 > 0) {
                                goto lab_0x804d2d8_13;
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804d384 - 0x804d454
// Line range:    474 - 508
int32_t read_samples_mp3(struct lame_global_struct_1 * gfp, struct _IO_FILE_2 * musicin, int16_t (*mpg123pcm)[1152]) {
    int32_t result = lame_decode_fromfile(musicin, mpg123pcm, (int16_t *)((int32_t)mpg123pcm + 2304), (struct anon_struct_2 *)&mp3input_data); // 0x804d3ac
    if (result <= 0) {
        // 0x804d3ba
        memset((char *)mpg123pcm, 0, 0x1200);
        // branch -> 0x804d453
        // 0x804d453
        return 0;
    }
    int32_t v1 = (int32_t)gfp; // 0x804d3dc_0
    lame_get_num_channels(v1);
    if (v1 != g45) {
        // 0x804d3f1
        if (silent <= 9) {
            // 0x804d3fb
            error_printf("Error: number of channels has changed in %s - not supported\n");
            result = -1;
            // branch -> 0x804d416
        } else {
            result = -1;
        }
    }
    int32_t v2 = (int32_t)gfp; // 0x804d416_0
    lame_get_in_samplerate(v2);
    if (v2 == g46) {
        // 0x804d453
        return result;
    }
    // 0x804d42b
    if (silent <= 9) {
        // 0x804d435
        error_printf("Error: sample frequency has changed in %s - not supported\n");
        // branch -> 0x804d453
    }
    // 0x804d453
    return -1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804d455 - 0x804d5a7
// Line range:    512 - 532
int32_t WriteWaveHeader(struct _IO_FILE_2 * fp, int32_t pcmbytes, int32_t freq, int32_t channels, int32_t bits) {
    int32_t v1 = bits + 7; // 0x804d45e
    int32_t v2 = v1; // 0x804d469
    if (v1 < 0) {
        // if_804d466_0_true
        v2 = bits + 14;
        // branch -> after_if_804d466_0
    }
    int32_t v3 = v2 / 8; // 0x804d469
    fwrite("RIFF", 1, 4, (struct _IO_FILE *)fp);
    Write32BitsLowHigh((struct _IO_FILE_5 *)fp, pcmbytes + 36);
    fwrite("WAVEfmt ", 2, 4, (struct _IO_FILE *)fp);
    Write32BitsLowHigh((struct _IO_FILE_5 *)fp, 16);
    Write16BitsLowHigh((struct _IO_FILE_5 *)fp, 1);
    Write16BitsLowHigh((struct _IO_FILE_5 *)fp, channels);
    Write32BitsLowHigh((struct _IO_FILE_5 *)fp, freq);
    Write32BitsLowHigh((struct _IO_FILE_5 *)fp, channels * freq * v3);
    Write16BitsLowHigh((struct _IO_FILE_5 *)fp, v3 * channels);
    Write16BitsLowHigh((struct _IO_FILE_5 *)fp, bits);
    fwrite("data", 1, 4, (struct _IO_FILE *)fp);
    Write32BitsLowHigh((struct _IO_FILE_5 *)fp, pcmbytes);
    return ferror((struct _IO_FILE *)fp) != 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804d5a8 - 0x804d9aa
// Line range:    923 - 965
int32_t unpack_read_samples(int32_t samples_to_read, int32_t bytes_per_sample, int32_t swap_order, int32_t * sample_buffer, struct _IO_FILE_2 * pcm_in) {
    // 0x804d5a8
    char * v1;
    char * ip = v1; // bp-32
    int32_t * v2;
    int32_t * op = v2; // bp-28
    int32_t v3;
    int32_t i = v3; // bp-24
    int32_t v4;
    int32_t samples_read = v4; // bp-20
    op = sample_buffer;
    ip = (char *)32;
    int32_t items_read = fread((char *)sample_buffer, bytes_per_sample, samples_to_read, (struct _IO_FILE *)pcm_in); // 0x804d5d8
    int32_t v5 = 4 * items_read + (int32_t)sample_buffer; // 0x804d5e6
    i = v5;
    if (swap_order != 0) {
        // 0x804d7c0
        if (bytes_per_sample == 1) {
            int32_t v6 = items_read - 1; // 0x804d810264
            if (v6 <= 0) {
                // 0x804d9a1
                return items_read;
            }
            samples_read = v6;
            while (true) {
                int32_t v7 = v5 - 4; // 0x804d7d2
                i = v7;
                unsigned char v8 = *(char *)((int32_t)op + v6); // 0x804d7dc
                int32_t v9 = (int32_t)ip; // 0x804d7e5_0
                *(int32_t *)v7 = ((int32_t)v8 ^ 128) << (v9 + 24) % 32 | 127 << (v9 + 16) % 32;
                int32_t v10 = samples_read - 1; // 0x804d810
                samples_read = v10;
                if (v10 > 0) {
                    // 0x804d7d2
                    v5 = i;
                    v6 = v10;
                    // branch -> 0x804d7d2
                    continue;
                }
            }
        }
        // 0x804d819
        int32_t v11; // 0x804d918_0
        uint32_t v12; // 0x804d921_0
        int32_t v13; // 0x804d994
        int32_t v14; // 0x804d994252
        int32_t v15; // 0x804d994255
        int32_t v16; // 0x804d911
        unsigned char v17; // 0x804d91b
        unsigned char v18; // 0x804d936
        unsigned char v19; // 0x804d955
        unsigned char v20; // 0x804d974
        int32_t v21; // 0x804d994254
        int32_t v22;
        int32_t v23; // 0x804d905
        switch (bytes_per_sample) {
            case 2: {
                int32_t v24 = 2 * items_read; // 0x804d822
                int32_t v25 = v24 - 2; // 0x804d870260
                samples_read = v25;
                if (v25 > 0) {
                    while (true) {
                        int32_t v26 = i - 4; // 0x804d82b
                        i = v26;
                        int32_t v27 = (int32_t)op; // 0x804d832_0
                        unsigned char v28 = *(char *)(v27 + v25); // 0x804d835
                        int32_t v29 = (int32_t)ip; // 0x804d83b_0
                        unsigned char v30 = *(char *)(v24 - 1 + v27); // 0x804d850
                        *(int32_t *)v26 = (int32_t)v28 << (v29 + 24) % 32 | (int32_t)v30 << (v29 + 16) % 32;
                        int32_t v31 = samples_read;
                        int32_t v32 = v31 - 2; // 0x804d870
                        samples_read = v32;
                        if (v32 <= 0) {
                            // break (via goto) -> 0x804d9a1
                            goto lab_0x804d9a1_6;
                        }
                        v25 = v32;
                        v24 = v31;
                        // continue -> 0x804d82b
                    }
                }
                break;
            }
            case 3: {
                int32_t v33 = 3 * items_read; // 0x804d882
                int32_t v34 = v33 - 3; // 0x804d8ef256
                samples_read = v34;
                if (v34 > 0) {
                    while (true) {
                        int32_t v35 = i - 4; // 0x804d88b
                        i = v35;
                        int32_t v36 = (int32_t)op; // 0x804d892_0
                        unsigned char v37 = *(char *)(v36 + v34); // 0x804d895
                        int32_t v38 = (int32_t)ip; // 0x804d89b_0
                        unsigned char v39 = *(char *)(v33 - 2 + v36); // 0x804d8b0
                        unsigned char v40 = *(char *)(v33 - 1 + v36); // 0x804d8cf
                        *(int32_t *)v35 = (int32_t)v37 << (v38 + 24) % 32 | (int32_t)v39 << (v38 + 16) % 32 | (int32_t)v40 << (v38 + 8) % 32;
                        int32_t v41 = samples_read;
                        int32_t v42 = v41 - 3; // 0x804d8ef
                        samples_read = v42;
                        if (v42 <= 0) {
                            // break (via goto) -> 0x804d8f8
                            goto lab_0x804d8f8;
                        }
                        v34 = v42;
                        v33 = v41;
                        // continue -> 0x804d88b
                    }
                  lab_0x804d8f8:
                    // 0x804d8f8
                    if (bytes_per_sample == 4) {
                        // 0x804d902
                        v23 = 4 * items_read;
                        v14 = v23 - 4;
                        samples_read = v14;
                        if (v14 > 0) {
                            v15 = v14;
                            v21 = v23;
                            while (true) {
                                // 0x804d911
                                v16 = i - 4;
                                i = v16;
                                v11 = (int32_t)op;
                                v17 = *(char *)(v11 + v15);
                                v12 = (int32_t)ip;
                                v18 = *(char *)(v21 - 3 + v11);
                                v19 = *(char *)(v21 - 2 + v11);
                                v20 = *(char *)(v21 - 1 + v11);
                                *(int32_t *)v16 = (int32_t)v17 << (v12 + 24) % 32 | (int32_t)v18 << (v12 + 16) % 32 | (int32_t)v19 << (v12 + 8) % 32 | (int32_t)v20 << v12 % 32;
                                v22 = samples_read;
                                v13 = v22 - 4;
                                samples_read = v13;
                                if (v13 <= 0) {
                                    // break (via goto) -> 0x804d9a1
                                    goto lab_0x804d9a1_6;
                                }
                                v15 = v13;
                                v21 = v22;
                                // continue -> 0x804d911
                            }
                            // 0x804d9a1
                            return items_read;
                        }
                    }
                }
                break;
            }
            case 4: {
                // 0x804d902
                v23 = 4 * items_read;
                v14 = v23 - 4;
                samples_read = v14;
                if (v14 > 0) {
                    v15 = v14;
                    v21 = v23;
                    while (true) {
                        // 0x804d911
                        v16 = i - 4;
                        i = v16;
                        v11 = (int32_t)op;
                        v17 = *(char *)(v11 + v15);
                        v12 = (int32_t)ip;
                        v18 = *(char *)(v21 - 3 + v11);
                        v19 = *(char *)(v21 - 2 + v11);
                        v20 = *(char *)(v21 - 1 + v11);
                        *(int32_t *)v16 = (int32_t)v17 << (v12 + 24) % 32 | (int32_t)v18 << (v12 + 16) % 32 | (int32_t)v19 << (v12 + 8) % 32 | (int32_t)v20 << v12 % 32;
                        v22 = samples_read;
                        v13 = v22 - 4;
                        samples_read = v13;
                        if (v13 <= 0) {
                            // break (via goto) -> 0x804d9a1
                            goto lab_0x804d9a1_6;
                        }
                        v15 = v13;
                        v21 = v22;
                        // continue -> 0x804d911
                    }
                }
                break;
            }
        }
        // 0x804d9a1
        return items_read;
      lab_0x804d9a1_6:
        // 0x804d9a1
        return items_read;
    }
    // 0x804d5f6
    if (bytes_per_sample == 1) {
        int32_t v43 = items_read - 1; // 0x804d62a249
        if (v43 <= 0) {
            // 0x804d9a1
            return items_read;
        }
        samples_read = v43;
        while (true) {
            int32_t v44 = v5 - 4; // 0x804d608
            i = v44;
            int32_t v45 = (int32_t)*(char *)((int32_t)op + v43); // 0x804d612
            uint32_t v46 = ((int32_t)ip - 8) % 32; // 0x804d620
            int32_t v47 = v45; // 0x804d625
            if (v46 != 0) {
                // if_804d620_0_true
                v47 = v45 << v46;
                // branch -> after_if_804d620_0
            }
            // after_if_804d620_0
            *(int32_t *)v44 = v47;
            int32_t v48 = samples_read - 1; // 0x804d62a
            samples_read = v48;
            if (v48 > 0) {
                // after_if_804d620_0.dec_label_pc_804d608_crit_edge
                v5 = i;
                v43 = v48;
                // branch -> 0x804d608
                continue;
            }
        }
    }
    // 0x804d633
    int32_t v49; // 0x804d732_0
    uint32_t v50; // 0x804d73b_0
    int32_t v51; // 0x804d7ae
    int32_t v52; // 0x804d7ae237
    int32_t v53; // 0x804d7ae240
    int32_t v54; // 0x804d72b
    unsigned char v55; // 0x804d735
    unsigned char v56; // 0x804d750
    unsigned char v57; // 0x804d76f
    unsigned char v58; // 0x804d78e
    int32_t v59; // 0x804d7ae239
    int32_t v60;
    int32_t v61; // 0x804d71f
    switch (bytes_per_sample) {
        case 2: {
            int32_t v62 = 2 * items_read; // 0x804d63c
            int32_t v63 = v62 - 2; // 0x804d68a245
            samples_read = v63;
            if (v63 > 0) {
                while (true) {
                    int32_t v64 = i - 4; // 0x804d645
                    i = v64;
                    int32_t v65 = (int32_t)op; // 0x804d64c_0
                    unsigned char v66 = *(char *)(v65 + v63); // 0x804d64f
                    int32_t v67 = (int32_t)ip; // 0x804d655_0
                    unsigned char v68 = *(char *)(v62 - 1 + v65); // 0x804d66a
                    *(int32_t *)v64 = (int32_t)v66 << (v67 + 16) % 32 | (int32_t)v68 << (v67 + 24) % 32;
                    int32_t v69 = samples_read;
                    int32_t v70 = v69 - 2; // 0x804d68a
                    samples_read = v70;
                    if (v70 <= 0) {
                        // break (via goto) -> 0x804d9a1
                        goto lab_0x804d9a1_6;
                    }
                    v63 = v70;
                    v62 = v69;
                    // continue -> 0x804d645
                }
            }
            break;
        }
        case 3: {
            int32_t v71 = 3 * items_read; // 0x804d69c
            int32_t v72 = v71 - 3; // 0x804d709241
            samples_read = v72;
            if (v72 > 0) {
                while (true) {
                    int32_t v73 = i - 4; // 0x804d6a5
                    i = v73;
                    int32_t v74 = (int32_t)op; // 0x804d6ac_0
                    unsigned char v75 = *(char *)(v74 + v72); // 0x804d6af
                    int32_t v76 = (int32_t)ip; // 0x804d6b5_0
                    unsigned char v77 = *(char *)(v71 - 2 + v74); // 0x804d6ca
                    unsigned char v78 = *(char *)(v71 - 1 + v74); // 0x804d6e9
                    *(int32_t *)v73 = (int32_t)v75 << (v76 + 8) % 32 | (int32_t)v77 << (v76 + 16) % 32 | (int32_t)v78 << (v76 + 24) % 32;
                    int32_t v79 = samples_read;
                    int32_t v80 = v79 - 3; // 0x804d709
                    samples_read = v80;
                    if (v80 <= 0) {
                        // break (via goto) -> 0x804d712
                        goto lab_0x804d712;
                    }
                    v72 = v80;
                    v71 = v79;
                    // continue -> 0x804d6a5
                }
              lab_0x804d712:
                // 0x804d712
                if (bytes_per_sample == 4) {
                    // 0x804d71c
                    v61 = 4 * items_read;
                    v52 = v61 - 4;
                    samples_read = v52;
                    if (v52 > 0) {
                        v53 = v52;
                        v59 = v61;
                        while (true) {
                            // 0x804d72b
                            v54 = i - 4;
                            i = v54;
                            v49 = (int32_t)op;
                            v55 = *(char *)(v49 + v53);
                            v50 = (int32_t)ip;
                            v56 = *(char *)(v59 - 3 + v49);
                            v57 = *(char *)(v59 - 2 + v49);
                            v58 = *(char *)(v59 - 1 + v49);
                            *(int32_t *)v54 = (int32_t)v55 << v50 % 32 | (int32_t)v56 << (v50 + 8) % 32 | (int32_t)v57 << (v50 + 16) % 32 | (int32_t)v58 << (v50 + 24) % 32;
                            v60 = samples_read;
                            v51 = v60 - 4;
                            samples_read = v51;
                            if (v51 <= 0) {
                                // break (via goto) -> 0x804d9a1
                                goto lab_0x804d9a1_6;
                            }
                            v53 = v51;
                            v59 = v60;
                            // continue -> 0x804d72b
                        }
                        // 0x804d9a1
                        return items_read;
                    }
                }
            }
            break;
        }
        case 4: {
            // 0x804d71c
            v61 = 4 * items_read;
            v52 = v61 - 4;
            samples_read = v52;
            if (v52 > 0) {
                v53 = v52;
                v59 = v61;
                while (true) {
                    // 0x804d72b
                    v54 = i - 4;
                    i = v54;
                    v49 = (int32_t)op;
                    v55 = *(char *)(v49 + v53);
                    v50 = (int32_t)ip;
                    v56 = *(char *)(v59 - 3 + v49);
                    v57 = *(char *)(v59 - 2 + v49);
                    v58 = *(char *)(v59 - 1 + v49);
                    *(int32_t *)v54 = (int32_t)v55 << v50 % 32 | (int32_t)v56 << (v50 + 8) % 32 | (int32_t)v57 << (v50 + 16) % 32 | (int32_t)v58 << (v50 + 24) % 32;
                    v60 = samples_read;
                    v51 = v60 - 4;
                    samples_read = v51;
                    if (v51 <= 0) {
                        // break (via goto) -> 0x804d9a1
                        goto lab_0x804d9a1_6;
                    }
                    v53 = v51;
                    v59 = v60;
                    // continue -> 0x804d72b
                }
            }
            break;
        }
    }
    // 0x804d9a1
    return items_read;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804d9ab - 0x804dae2
// Line range:    982 - 1030
int32_t read_samples_pcm(struct _IO_FILE_2 * musicin, int32_t * sample_buffer, int32_t samples_to_read) {
    // 0x804d9ab
    int32_t result;
    int32_t v1;
    int32_t v2; // 0x804da41
    if (g15 == 16) {
        // 0x804d9dc
        if (in_signed == 0) {
            // 0x804d9e5
            error_printf("Unsigned input only supported with bitwidth 8\n");
            exit(1);
            // UNREACHABLE
        }
        // 0x804d9fd
        v1 = in_endian == 0;
        v2 = v1 ^ 1;
        if (g16 != 0) {
            // 0x804da16
            v2 = v1;
            // branch -> after_if_804da2d_0
        }
        // after_if_804da2d_0
        result = unpack_read_samples(samples_to_read, g15 / 8, v2, sample_buffer, musicin);
        // branch -> 0x804daad
        // 0x804daad
        if (ferror((struct _IO_FILE *)musicin) == 0) {
            // 0x804dade
            return result;
        }
        // 0x804dabc
        if (silent <= 9) {
            // 0x804dac6
            error_printf("Error reading input file\n");
            // branch -> 0x804dad2
        }
        // 0x804dad2
        exit(1);
        // UNREACHABLE
    }
    // 0x804d9bb
    if (g15 <= 16) {
        // 0x804d9c0
        if (g15 != 8) {
            // 0x804da8b
            if (silent <= 9) {
                // 0x804da95
                error_printf("Only 8, 16, 24 and 32 bit input files supported \n");
                // branch -> 0x804daa1
            }
            // 0x804daa1
            exit(1);
            // UNREACHABLE
        }
        // 0x804da5c
        result = unpack_read_samples(samples_to_read, 1, g17, sample_buffer, musicin);
        // branch -> 0x804daad
        // 0x804daad
        if (ferror((struct _IO_FILE *)musicin) == 0) {
            // 0x804dade
            return result;
        }
        // 0x804dabc
        if (silent <= 9) {
            // 0x804dac6
            error_printf("Error reading input file\n");
            // branch -> 0x804dad2
        }
        // 0x804dad2
        exit(1);
        // UNREACHABLE
    }
    // 0x804d9ce
    switch (g15) {
        case 24: {
            // 0x804d9dc
            if (in_signed != 0) {
                // 0x804d9fd
                v1 = in_endian == 0;
                v2 = v1 ^ 1;
                if (g16 != 0) {
                    // 0x804da16
                    v2 = v1;
                    // branch -> after_if_804da2d_0
                }
                // after_if_804da2d_0
                result = unpack_read_samples(samples_to_read, g15 / 8, v2, sample_buffer, musicin);
                // branch -> 0x804daad
                // 0x804daad
                if (ferror((struct _IO_FILE *)musicin) == 0) {
                    // 0x804dade
                    return result;
                }
                // 0x804dabc
                if (silent <= 9) {
                    // 0x804dac6
                    error_printf("Error reading input file\n");
                    // branch -> 0x804dad2
                }
                // 0x804dad2
                exit(1);
                // UNREACHABLE
            }
            break;
        }
        case 32: {
            // 0x804d9dc
            if (in_signed != 0) {
                // 0x804d9fd
                v1 = in_endian == 0;
                v2 = v1 ^ 1;
                if (g16 != 0) {
                    // 0x804da16
                    v2 = v1;
                    // branch -> after_if_804da2d_0
                }
                // after_if_804da2d_0
                result = unpack_read_samples(samples_to_read, g15 / 8, v2, sample_buffer, musicin);
                // branch -> 0x804daad
                // 0x804daad
                if (ferror((struct _IO_FILE *)musicin) == 0) {
                    // 0x804dade
                    return result;
                }
                // 0x804dabc
                if (silent <= 9) {
                    // 0x804dac6
                    error_printf("Error reading input file\n");
                    // branch -> 0x804dad2
                }
                // 0x804dad2
                exit(1);
                // UNREACHABLE
            }
            break;
        }
    }
    // 0x804da8b
    if (silent <= 9) {
        // 0x804da95
        error_printf("Only 8, 16, 24 and 32 bit input files supported \n");
        // branch -> 0x804daa1
    }
    // 0x804daa1
    exit(1);
    // UNREACHABLE
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804dae3 - 0x804ddcf
// Line range:    1070 - 1169
int32_t parse_wave_header(struct lame_global_struct_1 * gfp, struct _IO_FILE_2 * sf) {
    // 0x804dae3
    int32_t v1;
    int32_t subSize = v1; // bp-56
    int32_t v2;
    int32_t file_length = v2; // bp-52
    int32_t v3;
    int32_t is_wav = v3; // bp-44
    int32_t v4;
    int32_t avg_bytes_per_sec = v4; // bp-40
    int32_t v5;
    int32_t bits_per_sample = v5; // bp-32
    int32_t v6;
    int32_t block_align = v6; // bp-28
    int32_t v7;
    int32_t format_tag = v7; // bp-20
    format_tag = 0;
    block_align = 0;
    bits_per_sample = 0;
    avg_bytes_per_sec = 0;
    is_wav = 0;
    file_length = 0;
    subSize = 0;
    Read32BitsHighLow((struct _IO_FILE_5 *)sf);
    Read32BitsHighLow((struct _IO_FILE_5 *)sf);
    if (Read32BitsHighLow((struct _IO_FILE_5 *)sf) != 0x57415645) {
        // 0x804db52
        // branch -> 0x804ddce
        // 0x804ddce
        return -1;
    }
    // 0x804dce7
    subSize = 0;
    int32_t v8 = 0; // 0x804dd122939
    // branch -> 0x804db68
    int32_t v9; // 0x804dd91
    int32_t v10; // 0x804dd36_0
    int32_t v11; // 0x804dd1228
    int32_t v12; // 0x804dd7c
    int32_t v13; // 0x804dda8
    int32_t v14; // 0x804dda1
    while (true) {
        int32_t v15 = Read32BitsHighLow((struct _IO_FILE_5 *)sf); // 0x804db6e
        if (v15 != 0x666d7420) {
            int32_t v16 = Read32Bits((struct _IO_FILE_5 *)sf); // 0x804dc96
            file_length = v16;
            if (v15 != 0x64617461) {
                // 0x804dcad
                if (fskip(sf, v16, 1) == 0) {
                    v11 = v8;
                    goto lab_0x804dce3_2;
                }
                // 0x804dcd9
                // branch -> 0x804ddce
                // 0x804ddce
                return -1;
            }
            // 0x804dcf1
            is_wav = v16;
            avg_bytes_per_sec = 1;
            // branch -> 0x804dcfb
            // 0x804dcfb
            if (v8 != 1) {
                // 0x804dd08
                if (silent <= 9) {
                    // 0x804dd12
                    error_printf("Unsupported data format: 0x%04X\n");
                    // branch -> 0x804dd25
                }
                // 0x804dd25
                // branch -> 0x804ddce
                // 0x804ddce
                return 0;
            }
            // 0x804dd2f
            v10 = (int32_t)gfp;
            lame_set_num_channels(v10, format_tag);
            if (v10 == -1) {
                // 0x804dd46
                if (silent <= 9) {
                    // 0x804dd50
                    error_printf("Unsupported number of channels: %u\n");
                    // branch -> 0x804dd63
                }
                // 0x804dd63
                // branch -> 0x804ddce
                // 0x804ddce
                return 0;
            }
            // 0x804dd6a
            lame_set_in_samplerate((int32_t)gfp, bits_per_sample);
            v12 = block_align;
            g15 = v12;
            g17 = 1;
            v9 = v12 + 7;
            if (v9 < 0) {
                // if_804dd99_0_true
                // branch -> after_if_804dd99_0
                // after_if_804dd99_0
                v14 = format_tag * (v12 + 14) / 8;
                v13 = is_wav;
                lame_set_num_samples((int32_t)gfp, (int32_t)((0x100000000 * (int64_t)(v13 >> 31) | (int64_t)v13) / (int64_t)v14));
                // branch -> 0x804ddce
                // 0x804ddce
                return 1;
            }
            // after_if_804dd99_0
            v14 = format_tag * v9 / 8;
            v13 = is_wav;
            lame_set_num_samples((int32_t)gfp, (int32_t)((0x100000000 * (int64_t)(v13 >> 31) | (int64_t)v13) / (int64_t)v14));
            // branch -> 0x804ddce
            // 0x804ddce
            return 1;
        }
        int32_t v17 = Read32Bits((struct _IO_FILE_5 *)sf); // 0x804db8a
        file_length = v17;
        if (v17 <= 15) {
            // 0x804db98
            // branch -> 0x804ddce
            // 0x804ddce
            return -1;
        }
        int32_t v18 = Read16BitsLowHigh((struct _IO_FILE_5 *)sf); // 0x804dba8
        file_length -= 2;
        format_tag = Read16BitsLowHigh((struct _IO_FILE_5 *)sf);
        file_length -= 2;
        bits_per_sample = Read32Bits((struct _IO_FILE_5 *)sf);
        file_length -= 4;
        Read32Bits((struct _IO_FILE_5 *)sf);
        Read32Bits((struct _IO_FILE_5 *)sf);
        file_length -= 4;
        Read16BitsLowHigh((struct _IO_FILE_5 *)sf);
        Read16BitsLowHigh((struct _IO_FILE_5 *)sf);
        file_length -= 2;
        block_align = Read16BitsLowHigh((struct _IO_FILE_5 *)sf);
        int32_t v19 = file_length - 2; // 0x804dc0a
        file_length = v19;
        int32_t v20; // 0x804dc66
        int32_t v21; // 0x804dc6650
        int32_t v22; // 0x804dd1230
        int32_t v23; // 0x804dd123051
        if (v19 < 10) {
            v20 = v19;
            v22 = v18;
          lab_0x804dc54:
            // 0x804dc54
            if (v20 < 1) {
                v11 = v22;
              lab_0x804dce3_2:;
                int32_t v24 = subSize + 1; // 0x804dce3
                subSize = v24;
                if (v24 >= 20) {
                    // break -> 0x804dcf1
                    break;
                }
                v8 = v11;
                // continue -> 0x804db68
                continue;
            } else {
                v23 = v22;
                v21 = v20;
            }
        } else {
            // 0x804dc14
            if (v18 == -2) {
                // 0x804dc21
                Read16BitsLowHigh((struct _IO_FILE_5 *)sf);
                Read16BitsLowHigh((struct _IO_FILE_5 *)sf);
                Read32Bits((struct _IO_FILE_5 *)sf);
                int32_t v25 = file_length - 10; // 0x804dc50
                file_length = v25;
                v20 = v25;
                v22 = Read16BitsLowHigh((struct _IO_FILE_5 *)sf);
                // branch -> 0x804dc54
                goto lab_0x804dc54;
            } else {
                v23 = v18;
                v21 = v19;
            }
        }
        // 0x804dc5e
        if (fskip(sf, v21, 1) == 0) {
            v11 = v23;
            goto lab_0x804dce3_2;
        }
        // 0x804dc7c
        // branch -> 0x804ddce
        // 0x804ddce
        return -1;
    }
    // 0x804dcf1
    if (avg_bytes_per_sec == 0) {
        // 0x804ddc9
        // branch -> 0x804ddce
        // 0x804ddce
        return -1;
    }
    // 0x804dcfb
    if (v11 != 1) {
        // 0x804dd08
        if (silent <= 9) {
            // 0x804dd12
            error_printf("Unsupported data format: 0x%04X\n");
            // branch -> 0x804dd25
        }
        // 0x804dd25
        // branch -> 0x804ddce
        // 0x804ddce
        return 0;
    }
    // 0x804dd2f
    v10 = (int32_t)gfp;
    lame_set_num_channels(v10, format_tag);
    int32_t result; // 0x804ddcf_2
    if (v10 == -1) {
        // 0x804dd46
        if (silent <= 9) {
            // 0x804dd50
            error_printf("Unsupported number of channels: %u\n");
            // branch -> 0x804dd63
        }
        // 0x804dd63
        result = 0;
        // branch -> 0x804ddce
    } else {
        // 0x804dd6a
        lame_set_in_samplerate((int32_t)gfp, bits_per_sample);
        v12 = block_align;
        g15 = v12;
        g17 = 1;
        v9 = v12 + 7;
        int32_t v26 = v9; // 0x804dd9c
        if (v9 < 0) {
            // if_804dd99_0_true
            v26 = v12 + 14;
            // branch -> after_if_804dd99_0
        }
        // after_if_804dd99_0
        v14 = format_tag * v26 / 8;
        v13 = is_wav;
        lame_set_num_samples((int32_t)gfp, (int32_t)((0x100000000 * (int64_t)(v13 >> 31) | (int64_t)v13) / (int64_t)v14));
        result = 1;
        // branch -> 0x804ddce
    }
    // 0x804ddce
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804ddd0 - 0x804deb1
// Line range:    1181 - 1220
int32_t aiff_check2(struct IFF_AIFF_struct * pcm_aiff_data) {
    int32_t v1 = (int32_t)pcm_aiff_data; // 0x804ddd7_0
    if (*(int32_t *)(v1 + 20) == 0x53534e44) {
        uint32_t v2 = (int32_t)*(int16_t *)(v1 + 8) - 8; // 0x804de0e
        if (v2 <= 24) {
            uint32_t v3 = v2 % 32; // 0x804de1f
            if (v3 == 0) {
                // after_if_804de1f_0.thread
                // branch -> 0x804de2c
            } else {
                // after_if_804de1f_0
                if ((1 << v3 & 0x1010101) == 0) {
                    // 0x804de3a
                    if (silent <= 9) {
                        // 0x804de44
                        error_printf("ERROR: input sound data is not 8, 16, 24 or 32 bits\n");
                        // branch -> 0x804de50
                    }
                    // 0x804de50
                    // branch -> 0x804deac
                    // 0x804deac
                    return 1;
                }
            }
            // 0x804de2c
            if (pcm_aiff_data->e0 != 1) {
                // 0x804de57
                if (pcm_aiff_data->e0 != 2) {
                    // 0x804de63
                    if (silent <= 9) {
                        // 0x804de6d
                        error_printf("ERROR: input sound data is not mono or stereo\n");
                        // branch -> 0x804de79
                    }
                    // 0x804de79
                    // branch -> 0x804deac
                    // 0x804deac
                    return 1;
                }
            }
            // 0x804de80
            int32_t result; // 0x804deb1_2
            if (*(int32_t *)(v1 + 28) == 0) {
                // 0x804dea7
                result = 0;
                // branch -> 0x804deac
            } else {
                // 0x804de8a
                if (silent <= 9) {
                    // 0x804de94
                    error_printf("ERROR: block size of input sound data is not 0 bytes\n");
                    // branch -> 0x804dea0
                }
                // 0x804dea0
                result = 1;
                // branch -> 0x804deac
            }
            // 0x804deac
            return result;
        }
        // 0x804de3a
        if (silent <= 9) {
            // 0x804de44
            error_printf("ERROR: input sound data is not 8, 16, 24 or 32 bits\n");
            // branch -> 0x804de50
        }
        // 0x804de50
        // branch -> 0x804deac
    } else {
        // 0x804dde6
        if (silent <= 9) {
            // 0x804ddf0
            error_printf("ERROR: input sound data is not PCM\n");
            // branch -> 0x804ddfc
        }
        // 0x804ddfc
        // branch -> 0x804deac
    }
    // 0x804deac
    return 1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804deb2 - 0x804decb
// Line range:    1224 - 1230
int32_t make_even_number_of_bytes_in_length(uint32_t x) {
    // 0x804deb2
    int32_t result;
    if (x % 2 != 0) {
        // 0x804debf
        result = x + 1;
        // branch -> 0x804deca
    } else {
        result = x;
    }
    // 0x804deca
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804decc - 0x804e2e3
// Line range:    1243 - 1363
int32_t parse_aiff_header(struct lame_global_struct_1 * gfp, struct _IO_FILE_2 * sf) {
    int32_t v1;
    int32_t pcm_data_pos = v1; // bp-44
    int32_t v2;
    int32_t seen_ssnd_chunk = v2; // bp-40
    int32_t v3;
    int32_t seen_comm_chunk = v3; // bp-36
    int32_t v4;
    int32_t dataType = v4; // bp-32
    int32_t v5;
    int32_t typeID = v5; // bp-28
    int32_t v6;
    int32_t subSize = v6; // bp-24
    subSize = 0;
    typeID = 0x4e4f4e45;
    dataType = 0;
    seen_comm_chunk = 0;
    seen_ssnd_chunk = -1;
    int32_t v7;
    memset((char *)&v7, 0, 32);
    int32_t v8 = Read32BitsHighLow((struct _IO_FILE_5 *)sf); // 0x804df25
    int32_t v9 = Read32BitsHighLow((struct _IO_FILE_5 *)sf); // 0x804df33
    subSize = v9;
    int32_t v10 = v8;
    int32_t v11;
    float64_t v12 = (int64_t)v11;
    int32_t v13;
    int32_t v14 = v13;
    int32_t v15;
    int32_t v16 = v15;
    int32_t v17; // 0x804e20b_0
    int32_t v18; // 0x804e177
    int32_t v19; // 0x804e1654669
    uint32_t offset; // 0x804e295
    if (v9 != 0x41494646) {
        // 0x804df49
        if (v9 != 0x41494643) {
            // 0x804df57
            // branch -> 0x804e2e2
            // 0x804e2e2
            return -1;
        }
        v10 = v8;
        v12 = (int64_t)v11;
        v14 = v13;
        v16 = v15;
        while (true) {
            // 0x804e165
            if (v10 > 0) {
                v19 = v10;
              lab_0x804df61:
                while (true) {
                    int32_t v20 = Read32BitsHighLow((struct _IO_FILE_5 *)sf); // 0x804df67
                    int32_t v21 = v19 - 4; // 0x804df6f
                    if (v20 == 0x434f4d4d) {
                        // 0x804df81
                        dataType = seen_comm_chunk + 1;
                        int32_t v22 = make_even_number_of_bytes_in_length(Read32BitsHighLow((struct _IO_FILE_5 *)sf)); // 0x804df9e
                        pcm_data_pos = v22;
                        v7 = 0x10000 * Read16BitsHighLow((struct _IO_FILE_5 *)sf) / 0x10000;
                        pcm_data_pos -= 2;
                        int32_t v23 = Read32BitsHighLow((struct _IO_FILE_5 *)sf); // 0x804dfc5
                        pcm_data_pos -= 4;
                        int32_t v24 = 0x10000 * Read16BitsHighLow((struct _IO_FILE_5 *)sf) / 0x10000; // 0x804dfdc_0
                        pcm_data_pos -= 2;
                        float64_t v25 = ReadIeeeExtendedHighLow((struct _IO_FILE_5 *)sf); // 0x804dfea
                        g59 = v25;
                        int32_t v26 = pcm_data_pos - 10; // 0x804dff2
                        pcm_data_pos = v26;
                        if (subSize == 0x41494643) {
                            // 0x804e000
                            typeID = Read32BitsHighLow((struct _IO_FILE_5 *)sf);
                            int32_t v27 = pcm_data_pos - 4; // 0x804e00e
                            pcm_data_pos = v27;
                            v26 = v27;
                            // branch -> 0x804e012
                        }
                        // 0x804e012
                        if (fskip(sf, v26, 1) != 0) {
                            // break (via goto) -> 0x804e034
                            goto lab_0x804e034;
                        }
                        v10 = v21 - v22;
                        v12 = v25;
                        v14 = v24;
                        v16 = v23;
                        // continue (via goto) -> 0x804e165
                        goto lab_0x804e165_2;
                    } else {
                        // 0x804e03e
                        int32_t v28; // 0x804e067
                        if (v20 == 0x53534e44) {
                            // 0x804e04c
                            seen_comm_chunk = 1;
                            v28 = make_even_number_of_bytes_in_length(Read32BitsHighLow((struct _IO_FILE_5 *)sf));
                            pcm_data_pos = v28;
                            int32_t v29 = Read32BitsHighLow((struct _IO_FILE_5 *)sf); // 0x804e07b
                            pcm_data_pos -= 4;
                            Read32BitsHighLow((struct _IO_FILE_5 *)sf);
                            Read32BitsHighLow((struct _IO_FILE_5 *)sf);
                            pcm_data_pos -= 4;
                            if (dataType < 1) {
                                int32_t curr_file_offset = ftell((struct _IO_FILE *)sf); // 0x804e0d9
                                seen_ssnd_chunk = curr_file_offset;
                                if (curr_file_offset >= 0) {
                                    // 0x804e0e7
                                    seen_ssnd_chunk = curr_file_offset + v29;
                                    // branch -> 0x804e0f3
                                }
                                // 0x804e0f3
                                if (fskip(sf, pcm_data_pos, 1) != 0) {
                                    // 0x804e111
                                    // branch -> 0x804e2e2
                                    // 0x804e2e2
                                    return -1;
                                }
                              lab_0x804e165:;
                                int32_t v30 = v21 - v28;
                                if (v30 <= 0) {
                                    // break -> 0x804e172
                                    break;
                                }
                                v19 = v30;
                                // continue -> 0x804df61
                                continue;
                            }
                            // 0x804e0a7
                            if (fskip(sf, v29, 1) != 0) {
                                // 0x804e0c9
                                // branch -> 0x804e2e2
                                // 0x804e2e2
                                return -1;
                            }
                            // 0x804e172
                            v18 = typeID;
                            if (v18 != 0x736f7774) {
                                // 0x804e188
                                if (v18 == 0x74776f73) {
                                    // 0x804e192
                                    g16 = swapbytes == 0;
                                    // branch -> 0x804e1ce
                                    // 0x804e1ce
                                    if (dataType == 0) {
                                        // 0x804e2dd
                                        // branch -> 0x804e2e2
                                        // 0x804e2e2
                                        return -1;
                                    }
                                    // 0x804e1d8
                                    if (seen_comm_chunk <= 0) {
                                        // 0x804e1de
                                        if (v16 != 0) {
                                            // 0x804e2dd
                                            // branch -> 0x804e2e2
                                            // 0x804e2e2
                                            return -1;
                                        }
                                    }
                                    // 0x804e1e9
                                    if (aiff_check2((struct IFF_AIFF_struct *)&v7) != 0) {
                                        // 0x804e1f8
                                        // branch -> 0x804e2e2
                                        // 0x804e2e2
                                        return 0;
                                    }
                                    // 0x804e202
                                    v17 = (int32_t)gfp;
                                    lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                    if (v17 == -1) {
                                        // 0x804e21b
                                        if (silent <= 9) {
                                            // 0x804e225
                                            error_printf("Unsupported number of channels: %u\n");
                                            // branch -> 0x804e23a
                                        }
                                        // 0x804e23a
                                        // branch -> 0x804e2e2
                                        // 0x804e2e2
                                        return 0;
                                    }
                                    // 0x804e244
                                    lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                    lame_set_num_samples((int32_t)gfp, v16);
                                    g15 = 0x10000 * v14 / 0x10000;
                                    g17 = 0;
                                    offset = seen_ssnd_chunk;
                                    if (offset >= 0) {
                                        // 0x804e29b
                                        if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                            // 0x804e2b9
                                            if (silent <= 9) {
                                                // 0x804e2c3
                                                error_printf("Can't rewind stream to audio data position\n");
                                                // branch -> 0x804e2cf
                                            }
                                            // 0x804e2cf
                                            // branch -> 0x804e2e2
                                            // 0x804e2e2
                                            return 0;
                                        }
                                    }
                                    // 0x804e2d6
                                    // branch -> 0x804e2e2
                                    // 0x804e2e2
                                    return 1;
                                }
                                // 0x804e1a6
                                if (v18 != 0x4e4f4e45) {
                                    // 0x804e1c4
                                    // branch -> 0x804e2e2
                                    // 0x804e2e2
                                    return -1;
                                }
                                // 0x804e1b0
                                g16 = swapbytes == 0;
                                // branch -> 0x804e1ce
                                // 0x804e1ce
                                if (dataType == 0) {
                                    // 0x804e2dd
                                    // branch -> 0x804e2e2
                                    // 0x804e2e2
                                    return -1;
                                }
                                // 0x804e1d8
                                if (seen_comm_chunk <= 0) {
                                    // 0x804e1de
                                    if (v16 != 0) {
                                        // 0x804e2dd
                                        // branch -> 0x804e2e2
                                        // 0x804e2e2
                                        return -1;
                                    }
                                }
                                // 0x804e1e9
                                if (aiff_check2((struct IFF_AIFF_struct *)&v7) != 0) {
                                    // 0x804e1f8
                                    // branch -> 0x804e2e2
                                    // 0x804e2e2
                                    return 0;
                                }
                                // 0x804e202
                                v17 = (int32_t)gfp;
                                lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                if (v17 == -1) {
                                    // 0x804e21b
                                    if (silent <= 9) {
                                        // 0x804e225
                                        error_printf("Unsupported number of channels: %u\n");
                                        // branch -> 0x804e23a
                                    }
                                    // 0x804e23a
                                    // branch -> 0x804e2e2
                                    // 0x804e2e2
                                    return 0;
                                }
                                // 0x804e244
                                lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                lame_set_num_samples((int32_t)gfp, v16);
                                g15 = 0x10000 * v14 / 0x10000;
                                g17 = 0;
                                offset = seen_ssnd_chunk;
                                if (offset >= 0) {
                                    // 0x804e29b
                                    if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                        // 0x804e2b9
                                        if (silent <= 9) {
                                            // 0x804e2c3
                                            error_printf("Can't rewind stream to audio data position\n");
                                            // branch -> 0x804e2cf
                                        }
                                        // 0x804e2cf
                                        // branch -> 0x804e2e2
                                        // 0x804e2e2
                                        return 0;
                                    }
                                }
                                // 0x804e2d6
                                // branch -> 0x804e2e2
                                // 0x804e2e2
                                return 1;
                            }
                            // 0x804e17c
                            g16 = swapbytes;
                            // branch -> 0x804e1ce
                            // 0x804e1ce
                            if (dataType != 0) {
                                // 0x804e1d8
                                if (seen_comm_chunk <= 0) {
                                    // 0x804e1de
                                    if (v16 != 0) {
                                        // 0x804e2dd
                                        // branch -> 0x804e2e2
                                        // 0x804e2e2
                                        return -1;
                                    }
                                }
                                // 0x804e1e9
                                if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                                    // 0x804e202
                                    v17 = (int32_t)gfp;
                                    lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                    if (v17 == -1) {
                                        // 0x804e21b
                                        if (silent <= 9) {
                                            // 0x804e225
                                            error_printf("Unsupported number of channels: %u\n");
                                            // branch -> 0x804e23a
                                        }
                                        // 0x804e23a
                                        // branch -> 0x804e2e2
                                        // 0x804e2e2
                                        return 0;
                                    }
                                    // 0x804e244
                                    lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                    lame_set_num_samples((int32_t)gfp, v16);
                                    g15 = 0x10000 * v14 / 0x10000;
                                    g17 = 0;
                                    offset = seen_ssnd_chunk;
                                    if (offset >= 0) {
                                        // 0x804e29b
                                        if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                            // 0x804e2b9
                                            if (silent <= 9) {
                                                // 0x804e2c3
                                                error_printf("Can't rewind stream to audio data position\n");
                                                // branch -> 0x804e2cf
                                            }
                                            // 0x804e2cf
                                            // branch -> 0x804e2e2
                                            // 0x804e2e2
                                            return 0;
                                        }
                                    }
                                    // 0x804e2d6
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804e2dd
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            int32_t v31 = make_even_number_of_bytes_in_length(Read32BitsHighLow((struct _IO_FILE_5 *)sf)); // 0x804e12f
                            pcm_data_pos = v31;
                            if (fskip(sf, v31, 1) == 0) {
                                v28 = v31;
                                goto lab_0x804e165;
                            }
                            // 0x804e15b
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804e172
                        v18 = typeID;
                        if (v18 == 0x736f7774) {
                            // 0x804e17c
                            g16 = swapbytes;
                            // branch -> 0x804e1ce
                        } else {
                            // 0x804e188
                            if (v18 == 0x74776f73) {
                                // 0x804e192
                                g16 = swapbytes == 0;
                                // branch -> 0x804e1ce
                            } else {
                                // 0x804e1a6
                                if (v18 == 0x4e4f4e45) {
                                    // 0x804e1b0
                                    g16 = swapbytes == 0;
                                    // branch -> 0x804e1ce
                                    // 0x804e1ce
                                    if (dataType != 0) {
                                        // 0x804e1d8
                                        if (seen_comm_chunk <= 0) {
                                            // 0x804e1de
                                            if (v16 != 0) {
                                                // 0x804e2dd
                                                // branch -> 0x804e2e2
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804e1e9
                                        if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                                            // 0x804e202
                                            v17 = (int32_t)gfp;
                                            lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                            if (v17 == -1) {
                                                // 0x804e21b
                                                if (silent <= 9) {
                                                    // 0x804e225
                                                    error_printf("Unsupported number of channels: %u\n");
                                                    // branch -> 0x804e23a
                                                }
                                                // 0x804e23a
                                                // branch -> 0x804e2e2
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                // 0x804e244
                                                lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                                lame_set_num_samples((int32_t)gfp, v16);
                                                g15 = 0x10000 * v14 / 0x10000;
                                                g17 = 0;
                                                offset = seen_ssnd_chunk;
                                                if (offset >= 0) {
                                                    // 0x804e29b
                                                    if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                                        // 0x804e2b9
                                                        if (silent <= 9) {
                                                            // 0x804e2c3
                                                            error_printf("Can't rewind stream to audio data position\n");
                                                            // branch -> 0x804e2cf
                                                        }
                                                        // 0x804e2cf
                                                        // branch -> 0x804e2e2
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // 0x804e2d6
                                                // branch -> 0x804e2e2
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804e2dd
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804e1ce
                            if (dataType != 0) {
                                // 0x804e1d8
                                if (seen_comm_chunk <= 0) {
                                    // 0x804e1de
                                    if (v16 != 0) {
                                        // 0x804e2dd
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804e1e9
                                if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                                    // 0x804e202
                                    v17 = (int32_t)gfp;
                                    lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                    if (v17 == -1) {
                                        // 0x804e21b
                                        if (silent <= 9) {
                                            // 0x804e225
                                            error_printf("Unsupported number of channels: %u\n");
                                            // branch -> 0x804e23a
                                        }
                                        // 0x804e23a
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x804e244
                                        lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                        lame_set_num_samples((int32_t)gfp, v16);
                                        g15 = 0x10000 * v14 / 0x10000;
                                        g17 = 0;
                                        offset = seen_ssnd_chunk;
                                        if (offset >= 0) {
                                            // 0x804e29b
                                            if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                                // 0x804e2b9
                                                if (silent <= 9) {
                                                    // 0x804e2c3
                                                    error_printf("Can't rewind stream to audio data position\n");
                                                    // branch -> 0x804e2cf
                                                }
                                                // 0x804e2cf
                                                // branch -> 0x804e2e2
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804e2d6
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804e2dd
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804e1ce
                        if (dataType != 0) {
                            // 0x804e1d8
                            if (seen_comm_chunk <= 0) {
                                // 0x804e1de
                                if (v16 != 0) {
                                    // 0x804e2dd
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804e1e9
                            if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                                // 0x804e202
                                v17 = (int32_t)gfp;
                                lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                if (v17 == -1) {
                                    // 0x804e21b
                                    if (silent <= 9) {
                                        // 0x804e225
                                        error_printf("Unsupported number of channels: %u\n");
                                        // branch -> 0x804e23a
                                    }
                                    // 0x804e23a
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x804e244
                                    lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                    lame_set_num_samples((int32_t)gfp, v16);
                                    g15 = 0x10000 * v14 / 0x10000;
                                    g17 = 0;
                                    offset = seen_ssnd_chunk;
                                    if (offset >= 0) {
                                        // 0x804e29b
                                        if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                            // 0x804e2b9
                                            if (silent <= 9) {
                                                // 0x804e2c3
                                                error_printf("Can't rewind stream to audio data position\n");
                                                // branch -> 0x804e2cf
                                            }
                                            // 0x804e2cf
                                            // branch -> 0x804e2e2
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804e2d6
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804e2dd
                        // branch -> 0x804e2e2
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804e172
                    v18 = typeID;
                    if (v18 == 0x736f7774) {
                        // 0x804e17c
                        g16 = swapbytes;
                        // branch -> 0x804e1ce
                    } else {
                        // 0x804e188
                        if (v18 == 0x74776f73) {
                            // 0x804e192
                            g16 = swapbytes == 0;
                            // branch -> 0x804e1ce
                        } else {
                            // 0x804e1a6
                            if (v18 == 0x4e4f4e45) {
                                // 0x804e1b0
                                g16 = swapbytes == 0;
                                // branch -> 0x804e1ce
                                // 0x804e1ce
                                if (dataType != 0) {
                                    // 0x804e1d8
                                    if (seen_comm_chunk <= 0) {
                                        // 0x804e1de
                                        if (v16 != 0) {
                                            // 0x804e2dd
                                            // branch -> 0x804e2e2
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804e1e9
                                    if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                                        // 0x804e202
                                        v17 = (int32_t)gfp;
                                        lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                        if (v17 == -1) {
                                            // 0x804e21b
                                            if (silent <= 9) {
                                                // 0x804e225
                                                error_printf("Unsupported number of channels: %u\n");
                                                // branch -> 0x804e23a
                                            }
                                            // 0x804e23a
                                            // branch -> 0x804e2e2
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x804e244
                                            lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                            lame_set_num_samples((int32_t)gfp, v16);
                                            g15 = 0x10000 * v14 / 0x10000;
                                            g17 = 0;
                                            offset = seen_ssnd_chunk;
                                            if (offset >= 0) {
                                                // 0x804e29b
                                                if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                                    // 0x804e2b9
                                                    if (silent <= 9) {
                                                        // 0x804e2c3
                                                        error_printf("Can't rewind stream to audio data position\n");
                                                        // branch -> 0x804e2cf
                                                    }
                                                    // 0x804e2cf
                                                    // branch -> 0x804e2e2
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x804e2d6
                                            // branch -> 0x804e2e2
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x804e2dd
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804e1ce
                        if (dataType != 0) {
                            // 0x804e1d8
                            if (seen_comm_chunk <= 0) {
                                // 0x804e1de
                                if (v16 != 0) {
                                    // 0x804e2dd
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804e1e9
                            if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                                // 0x804e202
                                v17 = (int32_t)gfp;
                                lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                if (v17 == -1) {
                                    // 0x804e21b
                                    if (silent <= 9) {
                                        // 0x804e225
                                        error_printf("Unsupported number of channels: %u\n");
                                        // branch -> 0x804e23a
                                    }
                                    // 0x804e23a
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x804e244
                                    lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                    lame_set_num_samples((int32_t)gfp, v16);
                                    g15 = 0x10000 * v14 / 0x10000;
                                    g17 = 0;
                                    offset = seen_ssnd_chunk;
                                    if (offset >= 0) {
                                        // 0x804e29b
                                        if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                            // 0x804e2b9
                                            if (silent <= 9) {
                                                // 0x804e2c3
                                                error_printf("Can't rewind stream to audio data position\n");
                                                // branch -> 0x804e2cf
                                            }
                                            // 0x804e2cf
                                            // branch -> 0x804e2e2
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804e2d6
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804e2dd
                        // branch -> 0x804e2e2
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804e1ce
                    if (dataType != 0) {
                        // 0x804e1d8
                        if (seen_comm_chunk <= 0) {
                            // 0x804e1de
                            if (v16 != 0) {
                                // 0x804e2dd
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804e1e9
                        if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                            // 0x804e202
                            v17 = (int32_t)gfp;
                            lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                            if (v17 == -1) {
                                // 0x804e21b
                                if (silent <= 9) {
                                    // 0x804e225
                                    error_printf("Unsupported number of channels: %u\n");
                                    // branch -> 0x804e23a
                                }
                                // 0x804e23a
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x804e244
                                lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                lame_set_num_samples((int32_t)gfp, v16);
                                g15 = 0x10000 * v14 / 0x10000;
                                g17 = 0;
                                offset = seen_ssnd_chunk;
                                if (offset >= 0) {
                                    // 0x804e29b
                                    if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                        // 0x804e2b9
                                        if (silent <= 9) {
                                            // 0x804e2c3
                                            error_printf("Can't rewind stream to audio data position\n");
                                            // branch -> 0x804e2cf
                                        }
                                        // 0x804e2cf
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804e2d6
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804e2dd
                    // branch -> 0x804e2e2
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804e172
                v18 = typeID;
                if (v18 == 0x736f7774) {
                    // 0x804e17c
                    g16 = swapbytes;
                    // branch -> 0x804e1ce
                } else {
                    // 0x804e188
                    if (v18 == 0x74776f73) {
                        // 0x804e192
                        g16 = swapbytes == 0;
                        // branch -> 0x804e1ce
                    } else {
                        // 0x804e1a6
                        if (v18 == 0x4e4f4e45) {
                            // 0x804e1b0
                            g16 = swapbytes == 0;
                            // branch -> 0x804e1ce
                            // 0x804e1ce
                            if (dataType != 0) {
                                // 0x804e1d8
                                if (seen_comm_chunk <= 0) {
                                    // 0x804e1de
                                    if (v16 != 0) {
                                        // 0x804e2dd
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804e1e9
                                if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                                    // 0x804e202
                                    v17 = (int32_t)gfp;
                                    lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                    if (v17 == -1) {
                                        // 0x804e21b
                                        if (silent <= 9) {
                                            // 0x804e225
                                            error_printf("Unsupported number of channels: %u\n");
                                            // branch -> 0x804e23a
                                        }
                                        // 0x804e23a
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x804e244
                                        lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                        lame_set_num_samples((int32_t)gfp, v16);
                                        g15 = 0x10000 * v14 / 0x10000;
                                        g17 = 0;
                                        offset = seen_ssnd_chunk;
                                        if (offset >= 0) {
                                            // 0x804e29b
                                            if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                                // 0x804e2b9
                                                if (silent <= 9) {
                                                    // 0x804e2c3
                                                    error_printf("Can't rewind stream to audio data position\n");
                                                    // branch -> 0x804e2cf
                                                }
                                                // 0x804e2cf
                                                // branch -> 0x804e2e2
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804e2d6
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804e2dd
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804e1ce
                    if (dataType != 0) {
                        // 0x804e1d8
                        if (seen_comm_chunk <= 0) {
                            // 0x804e1de
                            if (v16 != 0) {
                                // 0x804e2dd
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804e1e9
                        if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                            // 0x804e202
                            v17 = (int32_t)gfp;
                            lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                            if (v17 == -1) {
                                // 0x804e21b
                                if (silent <= 9) {
                                    // 0x804e225
                                    error_printf("Unsupported number of channels: %u\n");
                                    // branch -> 0x804e23a
                                }
                                // 0x804e23a
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x804e244
                                lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                lame_set_num_samples((int32_t)gfp, v16);
                                g15 = 0x10000 * v14 / 0x10000;
                                g17 = 0;
                                offset = seen_ssnd_chunk;
                                if (offset >= 0) {
                                    // 0x804e29b
                                    if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                        // 0x804e2b9
                                        if (silent <= 9) {
                                            // 0x804e2c3
                                            error_printf("Can't rewind stream to audio data position\n");
                                            // branch -> 0x804e2cf
                                        }
                                        // 0x804e2cf
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804e2d6
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804e2dd
                    // branch -> 0x804e2e2
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804e1ce
                if (dataType != 0) {
                    // 0x804e1d8
                    if (seen_comm_chunk <= 0) {
                        // 0x804e1de
                        if (v16 != 0) {
                            // 0x804e2dd
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804e1e9
                    if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                        // 0x804e202
                        v17 = (int32_t)gfp;
                        lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                        if (v17 == -1) {
                            // 0x804e21b
                            if (silent <= 9) {
                                // 0x804e225
                                error_printf("Unsupported number of channels: %u\n");
                                // branch -> 0x804e23a
                            }
                            // 0x804e23a
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x804e244
                            lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                            lame_set_num_samples((int32_t)gfp, v16);
                            g15 = 0x10000 * v14 / 0x10000;
                            g17 = 0;
                            offset = seen_ssnd_chunk;
                            if (offset >= 0) {
                                // 0x804e29b
                                if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                    // 0x804e2b9
                                    if (silent <= 9) {
                                        // 0x804e2c3
                                        error_printf("Can't rewind stream to audio data position\n");
                                        // branch -> 0x804e2cf
                                    }
                                    // 0x804e2cf
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804e2d6
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804e2dd
                // branch -> 0x804e2e2
                // Detected a possible infinite recursion (goto support failed); quitting...
            } else {
                // 0x804e172
                v18 = typeID;
                if (v18 == 0x736f7774) {
                    // 0x804e17c
                    g16 = swapbytes;
                    // branch -> 0x804e1ce
                } else {
                    // 0x804e188
                    if (v18 == 0x74776f73) {
                        // 0x804e192
                        g16 = swapbytes == 0;
                        // branch -> 0x804e1ce
                    } else {
                        // 0x804e1a6
                        if (v18 == 0x4e4f4e45) {
                            // 0x804e1b0
                            g16 = swapbytes == 0;
                            // branch -> 0x804e1ce
                            // 0x804e1ce
                            if (dataType != 0) {
                                // 0x804e1d8
                                if (seen_comm_chunk <= 0) {
                                    // 0x804e1de
                                    if (v16 != 0) {
                                        // 0x804e2dd
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804e1e9
                                if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                                    // 0x804e202
                                    v17 = (int32_t)gfp;
                                    lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                                    if (v17 == -1) {
                                        // 0x804e21b
                                        if (silent <= 9) {
                                            // 0x804e225
                                            error_printf("Unsupported number of channels: %u\n");
                                            // branch -> 0x804e23a
                                        }
                                        // 0x804e23a
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x804e244
                                        lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                        lame_set_num_samples((int32_t)gfp, v16);
                                        g15 = 0x10000 * v14 / 0x10000;
                                        g17 = 0;
                                        offset = seen_ssnd_chunk;
                                        if (offset >= 0) {
                                            // 0x804e29b
                                            if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                                // 0x804e2b9
                                                if (silent <= 9) {
                                                    // 0x804e2c3
                                                    error_printf("Can't rewind stream to audio data position\n");
                                                    // branch -> 0x804e2cf
                                                }
                                                // 0x804e2cf
                                                // branch -> 0x804e2e2
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804e2d6
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804e1ce
                    if (dataType != 0) {
                        // 0x804e1d8
                        if (seen_comm_chunk <= 0) {
                            // 0x804e1de
                            if (v16 != 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804e1e9
                        if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                            // 0x804e202
                            v17 = (int32_t)gfp;
                            lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                            if (v17 == -1) {
                                // 0x804e21b
                                if (silent <= 9) {
                                    // 0x804e225
                                    error_printf("Unsupported number of channels: %u\n");
                                    // branch -> 0x804e23a
                                }
                                // 0x804e23a
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x804e244
                                lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                lame_set_num_samples((int32_t)gfp, v16);
                                g15 = 0x10000 * v14 / 0x10000;
                                g17 = 0;
                                offset = seen_ssnd_chunk;
                                if (offset >= 0) {
                                    // 0x804e29b
                                    if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                        // 0x804e2b9
                                        if (silent <= 9) {
                                            // 0x804e2c3
                                            error_printf("Can't rewind stream to audio data position\n");
                                            // branch -> 0x804e2cf
                                        }
                                        // 0x804e2cf
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804e2d6
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804e1ce
                if (dataType != 0) {
                    // 0x804e1d8
                    if (seen_comm_chunk <= 0) {
                        // 0x804e1de
                        if (v16 != 0) {
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804e1e9
                    if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                        // 0x804e202
                        v17 = (int32_t)gfp;
                        lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                        if (v17 == -1) {
                            // 0x804e21b
                            if (silent <= 9) {
                                // 0x804e225
                                error_printf("Unsupported number of channels: %u\n");
                                // branch -> 0x804e23a
                            }
                            // 0x804e23a
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x804e244
                            lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                            lame_set_num_samples((int32_t)gfp, v16);
                            g15 = 0x10000 * v14 / 0x10000;
                            g17 = 0;
                            offset = seen_ssnd_chunk;
                            if (offset >= 0) {
                                // 0x804e29b
                                if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                    // 0x804e2b9
                                    if (silent <= 9) {
                                        // 0x804e2c3
                                        error_printf("Can't rewind stream to audio data position\n");
                                        // branch -> 0x804e2cf
                                    }
                                    // 0x804e2cf
                                    // branch -> 0x804e2e2
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804e2d6
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
    }
  lab_0x804e165_2:
    while (true) {
        // 0x804e165
        if (v10 > 0) {
            v19 = v10;
            goto lab_0x804df61;
        }
        // 0x804e172
        v18 = typeID;
        if (v18 == 0x736f7774) {
            // 0x804e17c
            g16 = swapbytes;
            // branch -> 0x804e1ce
        } else {
            // 0x804e188
            if (v18 == 0x74776f73) {
                // 0x804e192
                g16 = swapbytes == 0;
                // branch -> 0x804e1ce
            } else {
                // 0x804e1a6
                if (v18 == 0x4e4f4e45) {
                    // 0x804e1b0
                    g16 = swapbytes == 0;
                    // branch -> 0x804e1ce
                    // 0x804e1ce
                    if (dataType != 0) {
                        // 0x804e1d8
                        if (seen_comm_chunk <= 0) {
                            // 0x804e1de
                            if (v16 != 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804e1e9
                        if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                            // 0x804e202
                            v17 = (int32_t)gfp;
                            lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                            if (v17 == -1) {
                                // 0x804e21b
                                if (silent <= 9) {
                                    // 0x804e225
                                    error_printf("Unsupported number of channels: %u\n");
                                    // branch -> 0x804e23a
                                }
                                // 0x804e23a
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x804e244
                                lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                                lame_set_num_samples((int32_t)gfp, v16);
                                g15 = 0x10000 * v14 / 0x10000;
                                g17 = 0;
                                offset = seen_ssnd_chunk;
                                if (offset >= 0) {
                                    // 0x804e29b
                                    if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                        // 0x804e2b9
                                        if (silent <= 9) {
                                            // 0x804e2c3
                                            error_printf("Can't rewind stream to audio data position\n");
                                            // branch -> 0x804e2cf
                                        }
                                        // 0x804e2cf
                                        // branch -> 0x804e2e2
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804e2d6
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804e1ce
            if (dataType != 0) {
                // 0x804e1d8
                if (seen_comm_chunk <= 0) {
                    // 0x804e1de
                    if (v16 != 0) {
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x804e1e9
                if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                    // 0x804e202
                    v17 = (int32_t)gfp;
                    lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                    if (v17 == -1) {
                        // 0x804e21b
                        if (silent <= 9) {
                            // 0x804e225
                            error_printf("Unsupported number of channels: %u\n");
                            // branch -> 0x804e23a
                        }
                        // 0x804e23a
                        // branch -> 0x804e2e2
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x804e244
                        lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                        lame_set_num_samples((int32_t)gfp, v16);
                        g15 = 0x10000 * v14 / 0x10000;
                        g17 = 0;
                        offset = seen_ssnd_chunk;
                        if (offset >= 0) {
                            // 0x804e29b
                            if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                                // 0x804e2b9
                                if (silent <= 9) {
                                    // 0x804e2c3
                                    error_printf("Can't rewind stream to audio data position\n");
                                    // branch -> 0x804e2cf
                                }
                                // 0x804e2cf
                                // branch -> 0x804e2e2
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804e2d6
                        // branch -> 0x804e2e2
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x804e1ce
        if (dataType != 0) {
            // 0x804e1d8
            if (seen_comm_chunk <= 0) {
                // 0x804e1de
                if (v16 != 0) {
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // 0x804e1e9
            if (aiff_check2((struct IFF_AIFF_struct *)&v7) == 0) {
                // 0x804e202
                v17 = (int32_t)gfp;
                lame_set_num_channels(v17, 0x10000 * v7 / 0x10000);
                if (v17 == -1) {
                    // 0x804e21b
                    if (silent <= 9) {
                        // 0x804e225
                        error_printf("Unsupported number of channels: %u\n");
                        // branch -> 0x804e23a
                    }
                    // 0x804e23a
                    // branch -> 0x804e2e2
                    // Detected a possible infinite recursion (goto support failed); quitting...
                } else {
                    // 0x804e244
                    lame_set_in_samplerate((int32_t)gfp, (int32_t)v12);
                    lame_set_num_samples((int32_t)gfp, v16);
                    g15 = 0x10000 * v14 / 0x10000;
                    g17 = 0;
                    offset = seen_ssnd_chunk;
                    if (offset >= 0) {
                        // 0x804e29b
                        if (fseek((struct _IO_FILE *)sf, offset, SEEK_SET) != 0) {
                            // 0x804e2b9
                            if (silent <= 9) {
                                // 0x804e2c3
                                error_printf("Can't rewind stream to audio data position\n");
                                // branch -> 0x804e2cf
                            }
                            // 0x804e2cf
                            // branch -> 0x804e2e2
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804e2d6
                    // branch -> 0x804e2e2
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
  lab_0x804e034:;
    // 0x804e034
    // branch -> 0x804e2e2
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804e2e4 - 0x804e3e0
// Line range:    1382 - 1429
int32_t parse_file_header(struct lame_global_struct_1 * gfp, struct _IO_FILE_2 * sf) {
    int32_t v1 = Read32BitsHighLow((struct _IO_FILE_5 *)sf); // 0x804e2f0
    global = 0;
    g17 = in_signed != 1;
    int32_t result; // 0x804e3e0_2
    if (v1 == 0x52494646) {
        // 0x804e31f
        if (parse_wave_header(gfp, sf) < 1) {
            // 0x804e358
            if (silent <= 9) {
                // 0x804e362
                error_printf("Warning: corrupt or unsupported WAVE format\n");
                // branch -> 0x804e3da
            }
            // 0x804e3da
            result = 0;
            // branch -> 0x804e3df
        } else {
            // 0x804e33a
            global = 1;
            result = 2;
            // branch -> 0x804e3df
        }
        // 0x804e3df
        return result;
    }
    // 0x804e370
    if (v1 != 0x464f524d) {
        // 0x804e3c4
        if (silent <= 9) {
            // 0x804e3ce
            error_printf("Warning: unsupported audio format\n");
            // branch -> 0x804e3da
        }
        // 0x804e3da
        // branch -> 0x804e3df
        // 0x804e3df
        return 0;
    }
    // 0x804e37a
    if (parse_aiff_header(gfp, sf) < 1) {
        // 0x804e3ac
        if (silent <= 9) {
            // 0x804e3b6
            error_printf("Warning: corrupt or unsupported AIFF format\n");
            // branch -> 0x804e3da
        }
        // 0x804e3da
        result = 0;
        // branch -> 0x804e3df
    } else {
        // 0x804e395
        global = 1;
        result = 3;
        // branch -> 0x804e3df
    }
    // 0x804e3df
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804e3e1 - 0x804e419
// Line range:    1434 - 1443
void CloseSndFile(int32_t input, struct _IO_FILE_2 * musicin) {
    // 0x804e3e1
    if (fclose((struct _IO_FILE *)musicin) == 0) {
        // 0x804e418
        return;
    }
    // 0x804e3f6
    if (silent <= 9) {
        // 0x804e400
        error_printf("Could not close audio input file\n");
        // branch -> 0x804e40c
    }
    // 0x804e40c
    exit(2);
    // UNREACHABLE
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804e41a - 0x804e747
// Line range:    1450 - 1544
struct _IO_FILE_2 * OpenSndFile(struct lame_global_struct_1 * gfp, char * inPath, int32_t * enc_delay, int32_t * enc_padding) {
    // 0x804e41a
    struct _IO_FILE_2 * v1;
    struct _IO_FILE_2 * musicin = v1; // bp-20
    lame_set_num_samples((int32_t)gfp, -1);
    struct _IO_FILE_2 * result;
    if (strcmp(inPath, "-") == 0) {
        // 0x804e44a
        lame_set_stream_binary_mode((struct _IO_FILE_3 *)g13);
        result = g13;
        // branch -> 0x804e4a5
    } else {
        // 0x804e45f
        g4 = (int32_t)"rb";
        struct _IO_FILE * v2 = fopen64(inPath, "rb"); // 0x804e46e
        if (v2 == NULL) {
            // 0x804e47c
            if (silent <= 9) {
                // 0x804e486
                error_printf("Could not find \"%s\".\n");
                // branch -> 0x804e499
            }
            // 0x804e499
            exit(1);
            // UNREACHABLE
        }
        result = (struct _IO_FILE_2 *)v2;
    }
    // 0x804e4a5
    int32_t v3; // 0x804e621_0
    uint32_t v4; // 0x804e649_3
    int32_t v5; // 0x804e6b1_0
    int32_t v6; // 0x804e700_0
    int32_t v7;
    float80_t v8;
    int32_t v9;
    int32_t v10; // 0x804e681
    if (is_mpeg_file_format(input_format) != 0) {
        // 0x804e4ba
        if (lame_decode_initfile(result, (struct anon_struct_2 *)&mp3input_data, enc_delay, enc_padding) == -1) {
            // 0x804e4e0
            if (silent <= 9) {
                // 0x804e4ea
                error_printf("Error reading headers in mp3 input file %s.\n");
                // branch -> 0x804e4fd
            }
            // 0x804e4fd
            exit(1);
            // UNREACHABLE
        }
        int32_t v11 = (int32_t)gfp; // 0x804e512_0
        lame_set_num_channels(v11, g45);
        if (v11 == -1) {
            // 0x804e522
            if (silent <= 9) {
                // 0x804e52c
                error_printf("Unsupported number of channels: %ud\n");
                // branch -> 0x804e541
            }
            // 0x804e541
            exit(1);
            // UNREACHABLE
        }
        // 0x804e54d
        lame_set_in_samplerate((int32_t)gfp, g46);
        lame_set_num_samples((int32_t)gfp, (int32_t)g49);
        // branch -> 0x804e60c
        // 0x804e60c
        // branch -> 0x804e60c
        // 0x804e60c
        if (input_format == 0) {
            // 0x804e615
            exit(1);
            // UNREACHABLE
        }
        // 0x804e621
        v3 = (int32_t)gfp;
        lame_get_num_samples(v3);
        if (v3 == -1) {
            // 0x804e635
            if (result != g13) {
                // 0x804e643
                v4 = (int32_t)lame_get_file_size(inPath);
                v8 = v4;
                v7 = 0;
                if (v4 <= 0) {
                    // if_804e661_0_false
                    if (v4 >= 0) {
                        // if_804e661_1_false
                        v7 = v4 != 0;
                        // branch -> after_if_804e661_0
                    } else {
                        v7 = 1;
                    }
                }
                // after_if_804e661_0
                if ((v7 || v4 & -256) != 1) {
                    // 0x804e670
                    if (is_mpeg_file_format(input_format) == 0) {
                        // 0x804e700
                        v6 = (int32_t)gfp;
                        lame_get_num_channels(v6);
                        lame_set_num_samples((int32_t)gfp, (int32_t)(v8 / (float80_t)(2 * v6)));
                        // branch -> 0x804e743
                    } else {
                        // 0x804e681
                        v10 = g47;
                        if (v10 >= 1) {
                            // 0x804e68e
                            v5 = (int32_t)gfp;
                            lame_get_in_samplerate(v5);
                            v9 = 8.0L * v8 / (1000.0L * (float80_t)v10) * (float80_t)v5;
                            musicin = (struct _IO_FILE_2 *)v9;
                            lame_set_num_samples((int32_t)gfp, v9);
                            g49 = musicin;
                            // branch -> 0x804e743
                        }
                    }
                    // 0x804e743
                    return result;
                }
            }
        }
        // 0x804e743
        return result;
    }
    int32_t v12 = input_format; // 0x804e57a
    if (v12 == 8) {
        // 0x804e584
        if (silent <= 9) {
            // 0x804e58e
            error_printf("sorry, vorbis support in LAME is deprecated.\n");
            // branch -> 0x804e59a
        }
        // 0x804e59a
        exit(1);
        // UNREACHABLE
    }
    // 0x804e5a6
    int32_t v13; // 0x804e60c
    if (v12 == 1) {
        // 0x804e5b0
        if (silent <= 9) {
            // 0x804e5ba
            console_printf("Assuming raw pcm input file");
            if (swapbytes == 0) {
                // 0x804e5dd
                console_printf("\n");
                // branch -> 0x804e5e9
            } else {
                // 0x804e5cf
                console_printf(" : Forcing byte-swapping\n");
                // branch -> 0x804e5e9
            }
            // 0x804e5e9
            g16 = swapbytes;
            // branch -> 0x804e60c
            // 0x804e60c
            // branch -> 0x804e60c
            // 0x804e60c
            if (input_format == 0) {
                // 0x804e615
                exit(1);
                // UNREACHABLE
            }
            // 0x804e621
            v3 = (int32_t)gfp;
            lame_get_num_samples(v3);
            if (v3 == -1) {
                // 0x804e635
                if (result != g13) {
                    // 0x804e643
                    v4 = (int32_t)lame_get_file_size(inPath);
                    v8 = v4;
                    v7 = 0;
                    if (v4 <= 0) {
                        // if_804e661_0_false
                        if (v4 >= 0) {
                            // if_804e661_1_false
                            v7 = v4 != 0;
                            // branch -> after_if_804e661_0
                        } else {
                            v7 = 1;
                        }
                    }
                    // after_if_804e661_0
                    if ((v7 || v4 & -256) != 1) {
                        // 0x804e670
                        if (is_mpeg_file_format(input_format) == 0) {
                            // 0x804e700
                            v6 = (int32_t)gfp;
                            lame_get_num_channels(v6);
                            lame_set_num_samples((int32_t)gfp, (int32_t)(v8 / (float80_t)(2 * v6)));
                            // branch -> 0x804e743
                        } else {
                            // 0x804e681
                            v10 = g47;
                            if (v10 >= 1) {
                                // 0x804e68e
                                v5 = (int32_t)gfp;
                                lame_get_in_samplerate(v5);
                                v9 = 8.0L * v8 / (1000.0L * (float80_t)v10) * (float80_t)v5;
                                musicin = (struct _IO_FILE_2 *)v9;
                                lame_set_num_samples((int32_t)gfp, v9);
                                g49 = musicin;
                                // branch -> 0x804e743
                            }
                        }
                        // 0x804e743
                        return result;
                    }
                }
            }
            // 0x804e743
            return result;
        }
        // 0x804e5e9
        g16 = swapbytes;
        // branch -> 0x804e60c
        // 0x804e60c
        v13 = input_format;
        // branch -> 0x804e60c
    } else {
        int32_t v14 = parse_file_header(gfp, result); // 0x804e602
        input_format = v14;
        v13 = v14;
        // branch -> 0x804e60c
    }
    // 0x804e60c
    if (v13 == 0) {
        // 0x804e615
        exit(1);
        // UNREACHABLE
    }
    // 0x804e621
    v3 = (int32_t)gfp;
    lame_get_num_samples(v3);
    if (v3 == -1) {
        // 0x804e635
        if (result != g13) {
            // 0x804e643
            v4 = (int32_t)lame_get_file_size(inPath);
            v8 = v4;
            v7 = 0;
            if (v4 <= 0) {
                // if_804e661_0_false
                if (v4 >= 0) {
                    // if_804e661_1_false
                    v7 = v4 != 0;
                    // branch -> after_if_804e661_0
                } else {
                    v7 = 1;
                }
            }
            // after_if_804e661_0
            if ((v7 || v4 & -256) != 1) {
                // 0x804e670
                if (is_mpeg_file_format(input_format) == 0) {
                    // 0x804e700
                    v6 = (int32_t)gfp;
                    lame_get_num_channels(v6);
                    lame_set_num_samples((int32_t)gfp, (int32_t)(v8 / (float80_t)(2 * v6)));
                    // branch -> 0x804e743
                } else {
                    // 0x804e681
                    v10 = g47;
                    if (v10 >= 1) {
                        // 0x804e68e
                        v5 = (int32_t)gfp;
                        lame_get_in_samplerate(v5);
                        v9 = 8.0L * v8 / (1000.0L * (float80_t)v10) * (float80_t)v5;
                        musicin = (struct _IO_FILE_2 *)v9;
                        lame_set_num_samples((int32_t)gfp, v9);
                        g49 = musicin;
                        // branch -> 0x804e743
                    }
                }
                // 0x804e743
                return result;
            }
        }
    }
    // 0x804e743
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804e748 - 0x804e772
// Line range:    1553 - 1556
int32_t check_aid(char * header) {
    // 0x804e748
    return memcmp(header, (char *)&g7, 4) == 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804e773 - 0x804e960
// Line range:    1565 - 1613
int32_t is_syncword_mp123(char * headerptr) {
    int32_t v1 = (int32_t)headerptr; // 0x804e77a_0
    if (*headerptr == -1) {
        char * v2 = (char *)(v1 + 1);
        if (((int32_t)*v2 & 224) == 224) {
            // 0x804e7b6
            int32_t v3;
            if (((int32_t)*v2 & 24) == 8) {
                // 0x804e7ca
                // branch -> 0x804e95b
                // 0x804e95b
                g2 = v3;
                return 0;
            }
            // 0x804e7d4
            int32_t result; // 0x804e960_2
            char * v4;
            unsigned char v5; // 0x804e7da
            int32_t v6; // 0x804e826
            unsigned char v7; // 0x804e903
            unsigned char v8; // 0x804e91c
            char v9; // 0x804e90c
            switch ((int3_t)((int32_t)v5 & 6)) {
                default: {
                    // 0x804e7f2
                    // branch -> 0x804e95b
                    // 0x804e95b
                    g2 = v3;
                    return 0;
                }
                case -4: {
                    // 0x804e826
                    v6 = input_format;
                    if (v6 == 5) {
                        // 0x804e844
                        input_format = 5;
                        // branch -> 0x804e878
                        // 0x804e878
                        if (((int32_t)*v2 & 6) == 0) {
                            // 0x804e88b
                            // branch -> 0x804e95b
                            // 0x804e95b
                            g2 = v3;
                            return 0;
                        }
                        // 0x804e895
                        v4 = (char *)(v1 + 2);
                        if (((int32_t)*v4 & 240) == 240 || ((int32_t)*v4 & 12) == 12) {
                            // 0x804e8ad
                            // branch -> 0x804e95b
                            // 0x804e95b
                            g2 = v3;
                            return 0;
                        }
                        // 0x804e8d5
                        if (((int32_t)*v2 & 24) == 24) {
                            // 0x804e8e9
                            if (((int32_t)*v2 & 6) == 4) {
                                // 0x804e8fd
                                v7 = *v4;
                                v9 = *(char *)((int32_t)(v7 / 16) + (int32_t)&g8);
                                v8 = *(char *)(v1 + 3);
                                if (((int32_t)v9 >> (int32_t)(v8 / 64)) % 2 != 0) {
                                    // 0x804e934
                                    // branch -> 0x804e95b
                                    // 0x804e95b
                                    g2 = v3;
                                    return 0;
                                }
                            }
                        }
                        // 0x804e93b
                        if (*(char *)(v1 + 3) % 4 == 2) {
                            // 0x804e94f
                            result = 0;
                            // branch -> 0x804e95b
                        } else {
                            // 0x804e956
                            result = 1;
                            // branch -> 0x804e95b
                        }
                        // 0x804e95b
                        g2 = v3;
                        return result;
                    }
                    break;
                }
                case -2: {
                    int32_t v10 = input_format; // 0x804e850
                    if (v10 != 4) {
                        // 0x804e85a
                        if (v10 != 7) {
                            // 0x804e864
                            // branch -> 0x804e95b
                            // 0x804e95b
                            g2 = v3;
                            return 0;
                        }
                    }
                    // 0x804e86e
                    input_format = 4;
                    // branch -> 0x804e878
                    // 0x804e878
                    if (((int32_t)*v2 & 6) == 0) {
                        // 0x804e88b
                        // branch -> 0x804e95b
                        // 0x804e95b
                        g2 = v3;
                        return 0;
                    }
                    // 0x804e895
                    v4 = (char *)(v1 + 2);
                    if (((int32_t)*v4 & 240) == 240 || ((int32_t)*v4 & 12) == 12) {
                        // 0x804e8ad
                        // branch -> 0x804e95b
                        // 0x804e95b
                        g2 = v3;
                        return 0;
                    }
                    // 0x804e8d5
                    if (((int32_t)*v2 & 24) == 24) {
                        // 0x804e8e9
                        if (((int32_t)*v2 & 6) == 4) {
                            // 0x804e8fd
                            v7 = *v4;
                            v9 = *(char *)((int32_t)(v7 / 16) + (int32_t)&g8);
                            v8 = *(char *)(v1 + 3);
                            if (((int32_t)v9 >> (int32_t)(v8 / 64)) % 2 != 0) {
                                // 0x804e934
                                // branch -> 0x804e95b
                                // 0x804e95b
                                g2 = v3;
                                return 0;
                            }
                        }
                    }
                    // 0x804e93b
                    if (*(char *)(v1 + 3) % 4 == 2) {
                        // 0x804e94f
                        result = 0;
                        // branch -> 0x804e95b
                    } else {
                        // 0x804e956
                        result = 1;
                        // branch -> 0x804e95b
                    }
                    // 0x804e95b
                    g2 = v3;
                    return result;
                }
                case 2: {
                    int32_t v11 = input_format; // 0x804e7fc
                    if (v11 != 6) {
                        // 0x804e806
                        if (v11 != 7) {
                            // 0x804e810
                            // branch -> 0x804e95b
                            // 0x804e95b
                            g2 = v3;
                            return 0;
                        }
                    }
                    // 0x804e81a
                    input_format = 6;
                    // branch -> 0x804e878
                    // 0x804e878
                    if (((int32_t)*v2 & 6) == 0) {
                        // 0x804e88b
                        // branch -> 0x804e95b
                        // 0x804e95b
                        g2 = v3;
                        return 0;
                    }
                    // 0x804e895
                    v4 = (char *)(v1 + 2);
                    if (((int32_t)*v4 & 240) == 240 || ((int32_t)*v4 & 12) == 12) {
                        // 0x804e8ad
                        // branch -> 0x804e95b
                        // 0x804e95b
                        g2 = v3;
                        return 0;
                    }
                    // 0x804e8d5
                    if (((int32_t)*v2 & 24) == 24) {
                        // 0x804e8e9
                        if (((int32_t)*v2 & 6) == 4) {
                            // 0x804e8fd
                            v7 = *v4;
                            v9 = *(char *)((int32_t)(v7 / 16) + (int32_t)&g8);
                            v8 = *(char *)(v1 + 3);
                            if (((int32_t)v9 >> (int32_t)(v8 / 64)) % 2 != 0) {
                                // 0x804e934
                                // branch -> 0x804e95b
                                // 0x804e95b
                                g2 = v3;
                                return 0;
                            }
                        }
                    }
                    // 0x804e93b
                    if (*(char *)(v1 + 3) % 4 == 2) {
                        // 0x804e94f
                        result = 0;
                        // branch -> 0x804e95b
                    } else {
                        // 0x804e956
                        result = 1;
                        // branch -> 0x804e95b
                    }
                    // 0x804e95b
                    g2 = v3;
                    return result;
                }
            }
            // 0x804e830
            if (v6 != 7) {
                // 0x804e83a
                // branch -> 0x804e95b
                // 0x804e95b
                g2 = v3;
                return 0;
            }
            // 0x804e844
            input_format = 5;
            // branch -> 0x804e878
            // 0x804e878
            if (((int32_t)*v2 & 6) == 0) {
                // 0x804e88b
                // branch -> 0x804e95b
                // 0x804e95b
                g2 = v3;
                return 0;
            }
            // 0x804e895
            v4 = (char *)(v1 + 2);
            if (((int32_t)*v4 & 240) == 240 || ((int32_t)*v4 & 12) == 12) {
                // 0x804e8ad
                // branch -> 0x804e95b
                // 0x804e95b
                g2 = v3;
                return 0;
            }
            // 0x804e8d5
            if (((int32_t)*v2 & 24) == 24) {
                // 0x804e8e9
                if (((int32_t)*v2 & 6) == 4) {
                    // 0x804e8fd
                    v7 = *v4;
                    v9 = *(char *)((int32_t)(v7 / 16) + (int32_t)&g8);
                    v8 = *(char *)(v1 + 3);
                    if (((int32_t)v9 >> (int32_t)(v8 / 64)) % 2 != 0) {
                        // 0x804e934
                        // branch -> 0x804e95b
                        // 0x804e95b
                        g2 = v3;
                        return 0;
                    }
                }
            }
            // 0x804e93b
            if (*(char *)(v1 + 3) % 4 == 2) {
                // 0x804e94f
                result = 0;
                // branch -> 0x804e95b
            } else {
                // 0x804e956
                result = 1;
                // branch -> 0x804e95b
            }
            // 0x804e95b
            g2 = v3;
            return result;
        }
        // 0x804e7ac
        // branch -> 0x804e95b
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804e961 - 0x804ee67
// Line range:    1616 - 1734
int32_t lame_decode_initfile(struct _IO_FILE_2 * fd, struct anon_struct_2 * mp3data, int32_t * enc_delay, int32_t * enc_padding) {
    char v1[100];
    char data[100];
    int32_t v2;
    int32_t freeformat = v2; // bp-136
    int32_t v3;
    int32_t aid_header = v3; // bp-132
    int32_t v4;
    int32_t len = v4; // bp-128
    int32_t v5;
    int32_t ret = v5; // bp-124
    int32_t v6 = (int32_t)mp3data; // 0x804e973_0
    int32_t v7 = (int32_t)enc_delay; // 0x804e97c_0
    int32_t v8 = (int32_t)enc_padding; // 0x804e985_0
    int32_t v9 = *(int32_t *)20; // 0x804e98f
    aid_header = 0;
    memset((char *)mp3data, 0, 40);
    struct _IO_FILE_2 * v10 = g20;
    int32_t v11 = (int32_t)v10;
    int32_t v12 = v11; // eax
    if (v10 != NULL) {
        // 0x804e9c7
        v12 = v11;
        hip_decode_exit(v11);
        // branch -> 0x804e9d4
    }
    // 0x804e9d4
    hip_decode_init();
    g20 = (struct _IO_FILE_2 *)v12;
    ret = 4;
    int32_t data2 = (int32_t)&data; // 0x804e9fe_0
    if (fread(data, 1, 4, (struct _IO_FILE *)fd) == ret) {
        // 0x804ea18
        int32_t v13; // 0x804eb9f
        int32_t v14; // 0x804ecf5_0
        int32_t v15; // 0x804ecff_0
        char v16; // 0x804ed1f_0
        int32_t v17; // 0x804eb48
        int32_t v18; // 0x804ee2f
        int32_t result; // 0x804ee67_2
        int32_t v19; // bp+241
        int32_t v20;
        int32_t v21;
        int32_t v22;
        int32_t v23; // 0x804ebc1
        if (v1[4] == 73) {
            // 0x804ea24
            if (v1[5] == 68) {
                // 0x804ea30
                if (v1[6] == 51) {
                    // 0x804ea3c
                    if (silent <= 9) {
                        // 0x804ea46
                        console_printf("ID3v2 found. Be aware that the ID3 tag is currently lost when transcoding.\n");
                        // branch -> 0x804ea52
                    }
                    // 0x804ea52
                    ret = 6;
                    if (fread(data, 1, 6, (struct _IO_FILE *)fd) != ret) {
                        // 0x804ea82
                        // branch -> 0x804ee55
                        // 0x804ee55
                        if (*(int32_t *)20 != v9) {
                            // 0x804ee61
                            __stack_chk_fail();
                            // branch -> 0x804ee66
                        }
                        // 0x804ee66
                        return -1;
                    }
                    unsigned char v24 = v1[6]; // 0x804ea8c
                    v1[6] = v24 % 128;
                    unsigned char v25 = v1[7]; // 0x804ea96
                    v1[7] = v25 % 128;
                    unsigned char v26 = v1[8]; // 0x804eaa0
                    v1[8] = v26 % 128;
                    unsigned char v27 = v1[9]; // 0x804eaaa
                    v1[9] = v27 % 128;
                    int32_t v28 = 128 * (128 * ((int32_t)(v25 % 128) | 128 * (int32_t)v24 & 0x3f80) | (int32_t)(v26 % 128)) | (int32_t)(v27 % 128); // 0x804eae5
                    ret = v28;
                    fskip(fd, v28, 1);
                    ret = 4;
                    if (fread(data, 1, 4, (struct _IO_FILE *)fd) == ret) {
                        // 0x804eb42
                        v17 = check_aid(data);
                        len = v17;
                        if (v17 != 0) {
                            // 0x804eb5a
                            if (fread(data, 1, 2, (struct _IO_FILE *)fd) != 2) {
                                // 0x804eb84
                                // branch -> 0x804ee55
                                // 0x804ee55
                                if (*(int32_t *)20 != v9) {
                                    // 0x804ee61
                                    __stack_chk_fail();
                                    // branch -> 0x804ee66
                                }
                                // 0x804ee66
                                return -1;
                            }
                            // 0x804eb8e
                            v13 = 256 * (int32_t)v1[5] | (int32_t)v1[4];
                            len = v13;
                            v23 = v13;
                            if (silent <= 9) {
                                // 0x804ebae
                                console_printf("Album ID found.  length=%i \n");
                                v23 = len;
                                // branch -> 0x804ebc1
                            }
                            // 0x804ebc1
                            fskip(fd, v23 - 6, 1);
                            if (fread(data, 1, ret, (struct _IO_FILE *)fd) == ret) {
                                // 0x804ec14
                                ret = 4;
                                // branch -> 0x804ec92
                                while (true) {
                                    // 0x804ec92
                                    if (is_syncword_mp123(data) != 0) {
                                        // 0x804eca5
                                        if (((int32_t)v1[6] & 240) == 0) {
                                            // 0x804ecb5
                                            if (silent <= 9) {
                                                // 0x804ecbf
                                                console_printf("Input file is freeformat.\n");
                                                // branch -> 0x804eccb
                                            }
                                            // 0x804eccb
                                            aid_header = 1;
                                            // branch -> 0x804ecd2
                                        }
                                        // 0x804ecd2
                                        v22 = (int32_t)g20;
                                        v14 = &v21;
                                        v15 = &v20;
                                        hip_decode1_headersB(v22, data2, ret, v15, v14, v6, v7, v8);
                                        v16 = v22;
                                        v1[0] = v16;
                                        if (v16 == -1) {
                                            // 0x804ed2c
                                            // branch -> 0x804ee55
                                        } else {
                                            // 0x804edcf
                                            // branch -> 0x804edcf
                                            while (true) {
                                                // 0x804edcf
                                                if (mp3data->e0 == 0) {
                                                  lab_0x804ed36_3:;
                                                    int32_t items_read = fread(data, 1, 100, (struct _IO_FILE *)fd); // 0x804ed56
                                                    ret = items_read;
                                                    if (items_read == 100) {
                                                        int32_t v29 = (int32_t)g20;
                                                        hip_decode1_headersB(v29, data2, 100, v15, v14, v6, v7, v8);
                                                        char v30 = v29; // 0x804edbb_0
                                                        v1[0] = v30;
                                                        if (v30 == -1) {
                                                            // break -> 0x804edc4
                                                            break;
                                                        }
                                                        // continue -> 0x804edcf
                                                        continue;
                                                    }
                                                    // 0x804ee55
                                                    if (*(int32_t *)20 != v9) {
                                                        // 0x804ee61
                                                        __stack_chk_fail();
                                                        // branch -> 0x804ee66
                                                    }
                                                    // 0x804ee66
                                                    return -1;
                                                }
                                                // 0x804eddf
                                                if ((aid_header | *(int32_t *)(v6 + 12)) == 0) {
                                                    // 0x804edf2
                                                    if (silent <= 9) {
                                                        // 0x804edfc
                                                        error_printf("fail to sync...\n");
                                                        // branch -> 0x804ee08
                                                    }
                                                    // 0x804ee08
                                                    v18 = lame_decode_initfile(fd, mp3data, enc_delay, enc_padding);
                                                    v12 = v18;
                                                    v19 = v18;
                                                    // branch -> 0x804ee55
                                                } else {
                                                    // 0x804ee36
                                                    if (*(int32_t *)(v6 + 32) <= 0) {
                                                        // 0x804ee43
                                                        *(int32_t *)(v6 + 28) = -1;
                                                        // branch -> 0x804ee50
                                                    }
                                                    // 0x804ee50
                                                    v12 = 0;
                                                    v19 = 0;
                                                    // branch -> 0x804ee55
                                                }
                                                // 0x804ee55
                                                if (*(int32_t *)20 != v9) {
                                                    // 0x804ee61
                                                    __stack_chk_fail();
                                                    result = v12;
                                                    // branch -> 0x804ee66
                                                } else {
                                                    result = v19;
                                                }
                                                // 0x804ee66
                                                return result;
                                            }
                                            // 0x804edc4
                                            // branch -> 0x804ee55
                                        }
                                        // 0x804ee55
                                        if (*(int32_t *)20 != v9) {
                                            // 0x804ee61
                                            __stack_chk_fail();
                                            // branch -> 0x804ee66
                                        }
                                        // 0x804ee66
                                        return -1;
                                    }
                                  lab_0x804ec48_3:
                                    // 0x804ec48
                                    freeformat = 0;
                                    if (ret != 1) {
                                        int32_t v31 = 0; // 0x804ec2977
                                        int32_t v32 = g2; // 0x804ec38
                                        char v33 = *(char *)(v31 - 111 + v32); // 0x804ec38
                                        *(char *)(v31 - 112 + v32) = v33;
                                        int32_t v34 = freeformat + 1; // 0x804ec41
                                        freeformat = v34;
                                        int32_t v35 = ret - 1; // 0x804ec4b
                                        while (v35 > v34) {
                                            // 0x804ec29
                                            v31 = v34;
                                            v32 = g2;
                                            v33 = *(char *)(v31 - 111 + v32);
                                            *(char *)(v31 - 112 + v32) = v33;
                                            v34 = freeformat + 1;
                                            freeformat = v34;
                                            v35 = ret - 1;
                                            // continue -> 0x804ec29
                                        }
                                        // 0x804ec56
                                        if (fread((char *)(v35 + data2), 1, 1, (struct _IO_FILE *)fd) != 1) {
                                            // break -> 0x804ec88
                                            break;
                                        }
                                        // continue -> 0x804ec92
                                        continue;
                                    }
                                    // 0x804ec56
                                    if (fread((char *)data2, 1, 1, (struct _IO_FILE *)fd) != 1) {
                                        // break -> 0x804ec88
                                        break;
                                    }
                                    // continue -> 0x804ec92
                                }
                            } else {
                                // 0x804ec0a
                                v12 = -1;
                                v19 = -1;
                                // branch -> 0x804ee55
                            }
                            // 0x804ee55
                            if (*(int32_t *)20 != v9) {
                                // 0x804ee61
                                __stack_chk_fail();
                                result = v12;
                                // branch -> 0x804ee66
                            } else {
                                result = v19;
                            }
                            // 0x804ee66
                            return result;
                        }
                        // 0x804ec14
                        ret = 4;
                        // branch -> 0x804ec92
                        while (true) {
                            // 0x804ec92
                            if (is_syncword_mp123(data) == 0) {
                                goto lab_0x804ec48_3;
                            }
                            // 0x804eca5
                            if (((int32_t)v1[6] & 240) == 0) {
                                // 0x804ecb5
                                if (silent <= 9) {
                                    // 0x804ecbf
                                    console_printf("Input file is freeformat.\n");
                                    // branch -> 0x804eccb
                                }
                                // 0x804eccb
                                aid_header = 1;
                                // branch -> 0x804ecd2
                            }
                            // 0x804ecd2
                            v22 = (int32_t)g20;
                            v14 = &v21;
                            v15 = &v20;
                            hip_decode1_headersB(v22, data2, ret, v15, v14, v6, v7, v8);
                            v16 = v22;
                            v1[0] = v16;
                            if (v16 == -1) {
                                // 0x804ed2c
                                // branch -> 0x804ee55
                            } else {
                                // 0x804edcf
                                // branch -> 0x804edcf
                                while (true) {
                                    // 0x804edcf
                                    if (mp3data->e0 == 0) {
                                        goto lab_0x804ed36_3;
                                    }
                                    // 0x804eddf
                                    if ((aid_header | *(int32_t *)(v6 + 12)) == 0) {
                                        // 0x804edf2
                                        if (silent <= 9) {
                                            // 0x804edfc
                                            error_printf("fail to sync...\n");
                                            // branch -> 0x804ee08
                                        }
                                        // 0x804ee08
                                        v18 = lame_decode_initfile(fd, mp3data, enc_delay, enc_padding);
                                        v12 = v18;
                                        v19 = v18;
                                        // branch -> 0x804ee55
                                    } else {
                                        // 0x804ee36
                                        if (*(int32_t *)(v6 + 32) <= 0) {
                                            // 0x804ee43
                                            *(int32_t *)(v6 + 28) = -1;
                                            // branch -> 0x804ee50
                                        }
                                        // 0x804ee50
                                        v12 = 0;
                                        v19 = 0;
                                        // branch -> 0x804ee55
                                    }
                                    // 0x804ee55
                                    if (*(int32_t *)20 != v9) {
                                        // 0x804ee61
                                        __stack_chk_fail();
                                        result = v12;
                                        // branch -> 0x804ee66
                                    } else {
                                        result = v19;
                                    }
                                    // 0x804ee66
                                    return result;
                                }
                            }
                            // 0x804ee55
                            if (*(int32_t *)20 != v9) {
                                // 0x804ee61
                                __stack_chk_fail();
                                // branch -> 0x804ee66
                            }
                            // 0x804ee66
                            return -1;
                        }
                    }
                    // 0x804ee55
                    if (*(int32_t *)20 != v9) {
                        // 0x804ee61
                        __stack_chk_fail();
                        // branch -> 0x804ee66
                    }
                    // 0x804ee66
                    return -1;
                }
            }
        }
        // 0x804eb42
        v17 = check_aid(data);
        len = v17;
        if (v17 != 0) {
            // 0x804eb5a
            if (fread(data, 1, 2, (struct _IO_FILE *)fd) != 2) {
                // 0x804eb84
                // branch -> 0x804ee55
                // 0x804ee55
                if (*(int32_t *)20 != v9) {
                    // 0x804ee61
                    __stack_chk_fail();
                    // branch -> 0x804ee66
                }
                // 0x804ee66
                return -1;
            }
            // 0x804eb8e
            v13 = 256 * (int32_t)v1[5] | (int32_t)v1[4];
            len = v13;
            v23 = v13;
            if (silent <= 9) {
                // 0x804ebae
                console_printf("Album ID found.  length=%i \n");
                v23 = len;
                // branch -> 0x804ebc1
            }
            // 0x804ebc1
            fskip(fd, v23 - 6, 1);
            if (fread(data, 1, ret, (struct _IO_FILE *)fd) == ret) {
                // 0x804ec14
                ret = 4;
                // branch -> 0x804ec92
                while (true) {
                    // 0x804ec92
                    if (is_syncword_mp123(data) == 0) {
                        goto lab_0x804ec48_3;
                    }
                    // 0x804eca5
                    if (((int32_t)v1[6] & 240) == 0) {
                        // 0x804ecb5
                        if (silent <= 9) {
                            // 0x804ecbf
                            console_printf("Input file is freeformat.\n");
                            // branch -> 0x804eccb
                        }
                        // 0x804eccb
                        aid_header = 1;
                        // branch -> 0x804ecd2
                    }
                    // 0x804ecd2
                    v22 = (int32_t)g20;
                    v14 = &v21;
                    v15 = &v20;
                    hip_decode1_headersB(v22, data2, ret, v15, v14, v6, v7, v8);
                    v16 = v22;
                    v1[0] = v16;
                    if (v16 == -1) {
                        // 0x804ed2c
                        // branch -> 0x804ee55
                    } else {
                        // 0x804edcf
                        // branch -> 0x804edcf
                        while (true) {
                            // 0x804edcf
                            if (mp3data->e0 == 0) {
                                goto lab_0x804ed36_3;
                            }
                            // 0x804eddf
                            if ((aid_header | *(int32_t *)(v6 + 12)) == 0) {
                                // 0x804edf2
                                if (silent <= 9) {
                                    // 0x804edfc
                                    error_printf("fail to sync...\n");
                                    // branch -> 0x804ee08
                                }
                                // 0x804ee08
                                v18 = lame_decode_initfile(fd, mp3data, enc_delay, enc_padding);
                                v12 = v18;
                                v19 = v18;
                                // branch -> 0x804ee55
                            } else {
                                // 0x804ee36
                                if (*(int32_t *)(v6 + 32) <= 0) {
                                    // 0x804ee43
                                    *(int32_t *)(v6 + 28) = -1;
                                    // branch -> 0x804ee50
                                }
                                // 0x804ee50
                                v12 = 0;
                                v19 = 0;
                                // branch -> 0x804ee55
                            }
                            // 0x804ee55
                            if (*(int32_t *)20 != v9) {
                                // 0x804ee61
                                __stack_chk_fail();
                                result = v12;
                                // branch -> 0x804ee66
                            } else {
                                result = v19;
                            }
                            // 0x804ee66
                            return result;
                        }
                    }
                    // 0x804ee55
                    if (*(int32_t *)20 != v9) {
                        // 0x804ee61
                        __stack_chk_fail();
                        // branch -> 0x804ee66
                    }
                    // 0x804ee66
                    return -1;
                }
            }
            // 0x804ee55
            if (*(int32_t *)20 != v9) {
                // 0x804ee61
                __stack_chk_fail();
                // branch -> 0x804ee66
            }
            // 0x804ee66
            return -1;
        }
        // 0x804ec14
        ret = 4;
        // branch -> 0x804ec92
        while (true) {
            // 0x804ec92
            if (is_syncword_mp123(data) == 0) {
                goto lab_0x804ec48_3;
            }
            // 0x804eca5
            if (((int32_t)v1[6] & 240) == 0) {
                // 0x804ecb5
                if (silent <= 9) {
                    // 0x804ecbf
                    console_printf("Input file is freeformat.\n");
                    // branch -> 0x804eccb
                }
                // 0x804eccb
                aid_header = 1;
                // branch -> 0x804ecd2
            }
            // 0x804ecd2
            v22 = (int32_t)g20;
            v14 = &v21;
            v15 = &v20;
            hip_decode1_headersB(v22, data2, ret, v15, v14, v6, v7, v8);
            v16 = v22;
            v1[0] = v16;
            if (v16 == -1) {
                // 0x804ed2c
                // branch -> 0x804ee55
            } else {
                // 0x804edcf
                // branch -> 0x804edcf
                while (true) {
                    // 0x804edcf
                    if (mp3data->e0 == 0) {
                        goto lab_0x804ed36_3;
                    }
                    // 0x804eddf
                    if ((aid_header | *(int32_t *)(v6 + 12)) == 0) {
                        // 0x804edf2
                        if (silent <= 9) {
                            // 0x804edfc
                            error_printf("fail to sync...\n");
                            // branch -> 0x804ee08
                        }
                        // 0x804ee08
                        v18 = lame_decode_initfile(fd, mp3data, enc_delay, enc_padding);
                        v12 = v18;
                        v19 = v18;
                        // branch -> 0x804ee55
                    } else {
                        // 0x804ee36
                        if (*(int32_t *)(v6 + 32) <= 0) {
                            // 0x804ee43
                            *(int32_t *)(v6 + 28) = -1;
                            // branch -> 0x804ee50
                        }
                        // 0x804ee50
                        v12 = 0;
                        v19 = 0;
                        // branch -> 0x804ee55
                    }
                    // 0x804ee55
                    if (*(int32_t *)20 != v9) {
                        // 0x804ee61
                        __stack_chk_fail();
                        result = v12;
                        // branch -> 0x804ee66
                    } else {
                        result = v19;
                    }
                    // 0x804ee66
                    return result;
                }
            }
            // 0x804ee55
            if (*(int32_t *)20 != v9) {
                // 0x804ee61
                __stack_chk_fail();
                // branch -> 0x804ee66
            }
            // 0x804ee66
            return -1;
        }
    }
    // 0x804ee55
    if (*(int32_t *)20 != v9) {
        // 0x804ee61
        __stack_chk_fail();
        // branch -> 0x804ee66
    }
    // 0x804ee66
    return -1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804ee68 - 0x804f04c
// Line range:    1748 - 1784
int32_t lame_decode_fromfile(struct _IO_FILE_2 * fd, int16_t * pcm_l, int16_t * pcm_r, struct anon_struct_2 * mp3data) {
    char v1[1024];
    char data[1024];
    int32_t v2 = (int32_t)pcm_l; // 0x804ee7a_0
    int32_t v3 = (int32_t)pcm_r; // 0x804ee83_0
    int32_t v4 = (int32_t)mp3data; // 0x804ee8c_0
    int32_t v5 = *(int32_t *)20; // 0x804ee96
    v1[0] = 0;
    int32_t v6 = (int32_t)g20;
    int32_t v7 = (int32_t)&data; // 0x804eee1_0
    hip_decode1_headers(v6, v7, 0, v2, v3, v4);
    char v8 = v6; // 0x804eef3_0
    v1[0] = v8;
    int32_t result; // 0x804f034_0
    if (v8 == 0) {
        // 0x804ef0e
        // branch -> 0x804ef0e
        char v9; // 0x804ef84_0
        while (true) {
            int32_t items_read = fread(data, 1, 1024, (struct _IO_FILE *)fd); // 0x804ef31
            int32_t v10 = (int32_t)g20;
            hip_decode1_headers(v10, v7, items_read, v2, v3, v4);
            v9 = v10;
            v1[0] = v9;
            if (items_read != 0) {
                // 0x804efb8
                if (v9 == -1) {
                    // 0x804f006
                    hip_decode_exit((int32_t)g20);
                    g20 = NULL;
                    // branch -> 0x804f03a
                } else {
                    // 0x804f024
                    if (v9 >= 1) {
                        // break -> 0x804f034
                        break;
                    }
                    // continue -> 0x804ef0e
                    continue;
                }
                // 0x804f03a
                if (*(int32_t *)20 != v5) {
                    // 0x804f046
                    __stack_chk_fail();
                    // branch -> 0x804f04b
                }
                // 0x804f04b
                return -1;
            }
            // 0x804ef45
            if (v9 > 0) {
                // 0x804f034
                result = v9;
                // branch -> 0x804f03a
            } else {
                // 0x804ef97
                hip_decode_exit((int32_t)g20);
                g20 = NULL;
                result = -1;
                // branch -> 0x804f03a
            }
            // 0x804f03a
            if (*(int32_t *)20 != v5) {
                // 0x804f046
                __stack_chk_fail();
                // branch -> 0x804f04b
            }
            // 0x804f04b
            return result;
        }
        // 0x804f034
        result = v9;
        // branch -> 0x804f03a
    } else {
        // 0x804ef02
        result = v8;
        // branch -> 0x804f03a
    }
    // 0x804f03a
    if (*(int32_t *)20 != v5) {
        // 0x804f046
        __stack_chk_fail();
        // branch -> 0x804f04b
    }
    // 0x804f04b
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/get_audio.c
// Address range: 0x804f04d - 0x804f093
// Line range:    1789 - 1804
int32_t is_mpeg_file_format(int32_t input_file_format) {
    // 0x804f04d
    int32_t v1;
    if (input_file_format == 5) {
        // 0x804f077
        // branch -> 0x804f091
        // 0x804f091
        g2 = v1;
        return 2;
    }
    // 0x804f058
    if (input_file_format > 5) {
        // 0x804f064
        switch (input_file_format) {
            case 6: {
                // 0x804f07e
                // branch -> 0x804f091
                break;
            }
            case 7: {
                // 0x804f085
                // branch -> 0x804f091
                break;
            }
        }
        // 0x804f08c
        // branch -> 0x804f091
        // 0x804f091
        g2 = v1;
        return 0;
    }
    // 0x804f05d
    int32_t result; // 0x804f092_2
    if (input_file_format == 4) {
        // 0x804f070
        result = 1;
        // branch -> 0x804f091
    } else {
        // 0x804f08c
        result = 0;
        // branch -> 0x804f091
    }
    // 0x804f091
    g2 = v1;
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/lametime.c
// Address range: 0x804f094 - 0x804f0ae
// Line range:    58 - 68
float64_t GetCPUTime(void) {
    int32_t proc_time = clock(); // 0x804f09a
    g1 = proc_time;
    return (float80_t)proc_time / 1.0e+6L;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/lametime.c
// Address range: 0x804f0af - 0x804f0e5
// Line range:    86 - 93
float64_t GetRealTime(void) {
    int32_t tp;
    gettimeofday((struct timeval *)&tp, NULL);
    int32_t v1;
    g1 = v1;
    return 9.9999999e-7L * (float80_t)v1 + (float80_t)tp;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/lametime.c
// Address range: 0x804f0e6 - 0x804f0ef
// Line range:    132 - 146
int32_t lame_set_stream_binary_mode(struct _IO_FILE_3 * fp) {
    // 0x804f0e6
    return 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/lametime.c
// Address range: 0x804f0f0 - 0x804f11f
// Line range:    160 - 167
int64_t lame_get_file_size(char * filename) {
    int32_t v1;
    int32_t v2 = stat64(filename, (struct stat64 *)&v1); // 0x804f103
    int32_t v3;
    g4 = v2 == 0 ? v3 : -1;
    int32_t v4;
    return v2 == 0 ? v4 : -1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804f120 - 0x804f203
// Line range:    443 - 457
int32_t set_id3tag(struct lame_global_struct_2 * gfp, int32_t type, char * str) {
    // 0x804f120
    int32_t result; // eax
    switch (type) {
        default: {
            // 0x804f1fd
            result = 0;
            // branch -> 0x804f202
            break;
        }
        case 97: {
            // 0x804f13e
            id3tag_set_artist((int32_t)gfp, (int32_t)str);
            result = 0;
            // branch -> 0x804f202
            break;
        }
        case 99: {
            // 0x804f1a3
            id3tag_set_comment((int32_t)gfp, (int32_t)str);
            result = 0;
            // branch -> 0x804f202
            break;
        }
        case 103: {
            int32_t v1 = (int32_t)gfp; // 0x804f196_0
            result = v1;
            id3tag_set_genre(v1, (int32_t)str);
            // branch -> 0x804f202
            break;
        }
        case 108: {
            // 0x804f176
            id3tag_set_album((int32_t)gfp, (int32_t)str);
            result = 0;
            // branch -> 0x804f202
            break;
        }
        case 110: {
            int32_t v2 = (int32_t)gfp; // 0x804f1c3_0
            result = v2;
            id3tag_set_track(v2, (int32_t)str);
            // branch -> 0x804f202
            break;
        }
        case 116: {
            // 0x804f15a
            id3tag_set_title((int32_t)gfp, (int32_t)str);
            result = 0;
            // branch -> 0x804f202
            break;
        }
        case 118: {
            int32_t v3 = (int32_t)gfp; // 0x804f1f0_0
            result = v3;
            id3tag_set_fieldvalue(v3, (int32_t)str);
            // branch -> 0x804f202
            break;
        }
        case 121: {
            // 0x804f1d0
            id3tag_set_year((int32_t)gfp, (int32_t)str);
            result = 0;
            // branch -> 0x804f202
            break;
        }
    }
    // 0x804f202
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804f204 - 0x804f24a
// Line range:    460 - 484
int32_t id3_tag(struct lame_global_struct_2 * gfp, int32_t type, int32_t enc, char * str) {
    // 0x804f204
    char * v1;
    char * x = v1; // bp-20
    char * v2 = strdup(str); // 0x804f217
    x = (char *)set_id3tag(gfp, type, v2);
    free(v2);
    return (int32_t)x;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804f24b - 0x804f3aa
// Line range:    498 - 527
int32_t lame_version_print(struct _IO_FILE_4 * fp) {
    // 0x804f24b
    int32_t v1;
    int32_t lenb = v1; // bp-32
    char * v2;
    char * u = v2; // bp-28
    char * v3;
    char * v = v3; // bp-24
    char * v4;
    char * b = v4; // bp-20
    get_lame_os_bitness((int32_t)fp);
    get_lame_version(g1);
    b = (char *)g1;
    get_lame_url(g1);
    v = (char *)g1;
    char * str = (char *)g1;
    u = (char *)strlen(str);
    lenb = strlen(b);
    int32_t len = strlen(v); // 0x804f28b
    char * v5; // 0x804f2f9
    char * v6; // 0x804f300
    if (len + 16 + lenb + (int32_t)u <= 80) {
        // 0x804f2c0
        v5 = v;
        v6 = b;
        if (u == NULL) {
            // 0x804f2f4
            fprintf((struct _IO_FILE *)fp, "LAME version %s (%s)\n\n", v6, v5);
            // branch -> 0x804f3a4
        } else {
            // 0x804f2c6
            fprintf((struct _IO_FILE *)fp, "LAME %s version %s (%s)\n\n", str, v6, v5);
            // branch -> 0x804f3a4
        }
        // 0x804f3a4
        return 0;
    }
    // 0x804f2b5
    if (len <= 78) {
        int32_t v7 = 78 - len; // 0x804f373
        if (u == NULL) {
            // 0x804f367
            fprintf((struct _IO_FILE *)fp, "LAME version %s\n%*s(%s)\n\n", b, v7, (char *)&g9, v);
            // branch -> 0x804f3a4
        } else {
            // 0x804f321
            fprintf((struct _IO_FILE *)fp, "LAME %s version %s\n%*s(%s)\n\n", str, b, v7, (char *)&g9, v);
            // branch -> 0x804f3a4
        }
        // 0x804f3a4
        return 0;
    }
    // 0x804f2c0
    v5 = v;
    v6 = b;
    if (u == NULL) {
        // 0x804f2f4
        fprintf((struct _IO_FILE *)fp, "LAME version %s (%s)\n\n", v6, v5);
        // branch -> 0x804f3a4
    } else {
        // 0x804f2c6
        fprintf((struct _IO_FILE *)fp, "LAME %s version %s (%s)\n\n", str, v6, v5);
        // branch -> 0x804f3a4
    }
    // 0x804f3a4
    return 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804f3ab - 0x804f49a
// Line range:    530 - 568
int32_t print_license(struct _IO_FILE_4 * fp) {
    // 0x804f3ab
    g1 = (int32_t)fp;
    lame_version_print(fp);
    fwrite("Can I use LAME in my commercial program?\n\nYes, you can, under the restrictions of the LGPL.  In particular, you\ncan include a compiled version of the LAME library (for example,\nlame.dll) with a commercial program.  Some notable requirements of\nthe LGPL:\n\n", 1, 255, (struct _IO_FILE *)fp);
    fwrite("1. In your program, you cannot include any source code from LAME, with\n   the exception of files whose only purpose is to describe the library\n   interface (such as lame.h).\n\n", 1, 175, (struct _IO_FILE *)fp);
    fwrite("2. Any modifications of LAME must be released under the LGPL.\n   The LAME project (www.mp3dev.org) would appreciate being\n   notified of any modifications.\n\n", 1, 157, (struct _IO_FILE *)fp);
    fwrite("3. You must give prominent notice that your program is:\n      A. using LAME (including version number)\n      B. LAME is under the LGPL\n      C. Provide a copy of the LGPL.  (the file COPYING contains the LGPL)\n      D. Provide a copy of LAME source, or a pointer where the LAME\n         source can be obtained (such as www.mp3dev.org)\n   An example of prominent notice would be an \"About the LAME encoding engine\"\n   button in some pull down menu within the executable of your program.\n\n", 1, 487, (struct _IO_FILE *)fp);
    fwrite("4. If you determine that distribution of LAME requires a patent license,\n   you must obtain such license.\n\n\n", 1, 108, (struct _IO_FILE *)fp);
    fwrite("*** IMPORTANT NOTE ***\n\nThe decoding functions provided in LAME use the mpglib decoding engine which\nis under the GPL.  They may not be used by any program not released under the\nGPL unless you obtain such permission from the MPG123 project (www.mpg123.de).\n\n", 1, 259, (struct _IO_FILE *)fp);
    return 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804f49b - 0x804f4e9
// Line range:    580 - 597
int32_t usage(struct _IO_FILE_4 * fp, char * ProgramName) {
    // 0x804f49b
    g1 = (int32_t)fp;
    lame_version_print(fp);
    fprintf((struct _IO_FILE *)fp, "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nTry:\n     \"%s --help\"           for general usage information\n or:\n     \"%s --preset help\"    for information on suggested predefined settings\n or:\n     \"%s --longhelp\"\n  or \"%s -?\"              for a complete options list\n\n", ProgramName, ProgramName, ProgramName, ProgramName, ProgramName);
    return 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804f4ea - 0x804f587
// Line range:    610 - 652
int32_t short_help(struct lame_global_struct_2 * gfp, struct _IO_FILE_4 * fp, char * ProgramName) {
    // 0x804f4ea
    g1 = (int32_t)fp;
    lame_version_print(fp);
    fprintf((struct _IO_FILE *)fp, "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nRECOMMENDED:\n    lame -V2 input.wav output.mp3\n\n", ProgramName);
    int32_t v1 = (int32_t)gfp; // 0x804f516_0
    lame_get_VBR_q(v1);
    fprintf((struct _IO_FILE *)fp, "OPTIONS:\n    -b bitrate      set the bitrate, default 128 kbps\n    -h              higher quality, but a little slower.  Recommended.\n    -f              fast mode (lower quality)\n    -V n            quality setting for VBR.  default n=%i\n                    0=high quality,bigger files. 9=smaller files\n", v1);
    fwrite("    --preset type   type must be \"medium\", \"standard\", \"extreme\", \"insane\",\n                    or a value for an average desired bitrate and depending\n                    on the value specified, appropriate quality settings will\n                    be used.\n                    \"--preset help\" gives more info on these\n\n", 1, 321, (struct _IO_FILE *)fp);
    fwrite("    --longhelp      full list of options\n\n    --license       print License information\n\n", 1, 89, (struct _IO_FILE *)fp);
    return 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804f588 - 0x804f5cd
// Line range:    663 - 673
void wait_for(struct _IO_FILE_4 * fp, int32_t lessmode) {
    // 0x804f588
    if (lessmode == 0) {
        // 0x804f5a6
        fputc(10, (struct _IO_FILE *)fp);
        // branch -> 0x804f5b9
    } else {
        // 0x804f594
        fflush((struct _IO_FILE *)fp);
        getchar();
        // branch -> 0x804f5b9
    }
    // 0x804f5b9
    fputc(10, (struct _IO_FILE *)fp);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804f5ce - 0x804f990
// Line range:    676 - 920
int32_t long_help(struct lame_global_struct_2 * gfp, struct _IO_FILE_4 * fp, char * ProgramName, int32_t lessmode) {
    // 0x804f5ce
    g1 = (int32_t)fp;
    lame_version_print(fp);
    fprintf((struct _IO_FILE *)fp, "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nRECOMMENDED:\n    lame -V2 input.wav output.mp3\n\n", ProgramName);
    fwrite("OPTIONS:\n  Input options:\n    --scale <arg>   scale input (multiply PCM data) by <arg>\n    --scale-l <arg> scale channel 0 (left) input (multiply PCM data) by <arg>\n    --scale-r <arg> scale channel 1 (right) input (multiply PCM data) by <arg>\n    --mp1input      input file is a MPEG Layer I   file\n    --mp2input      input file is a MPEG Layer II  file\n    --mp3input      input file is a MPEG Layer III file\n    --nogap <file1> <file2> <...>\n                    gapless encoding for a set of contiguous files\n    --nogapout <dir>\n                    output dir for gapless encoding (must precede --nogap)\n    --nogaptags     allow the use of VBR tags in gapless encoding\n", 1, 675, (struct _IO_FILE *)fp);
    fwrite("\n  Input options for RAW PCM:\n    -r              input is raw pcm\n    -x              force byte-swapping of input\n    -s sfreq        sampling frequency of input file (kHz) - default 44.1 kHz\n    --bitwidth w    input bit width is w (default 16)\n    --signed        input is signed (default)\n    --unsigned      input is unsigned\n    --little-endian input is little-endian (default)\n    --big-endian    input is big-endian\n", 1, 425, (struct _IO_FILE *)fp);
    wait_for(fp, lessmode);
    fwrite("  Operational options:\n    -a              downmix from stereo to mono file for mono encoding\n    -m <mode>       (j)oint, (s)imple, (f)orce, (d)dual-mono, (m)ono\n                    default is (j) or (s) depending on bitrate\n                    joint  = joins the best possible of MS and LR stereo\n                    simple = force LR stereo on all frames\n                    force  = force MS stereo on all frames.\n    --preset type   type must be \"medium\", \"standard\", \"extreme\", \"insane\",\n                    or a value for an average desired bitrate and depending\n                    on the value specified, appropriate quality settings will\n                    be used.\n                    \"--preset help\" gives more info on these\n    --comp  <arg>   choose bitrate to achive a compression ratio of <arg>\n", 1, 812, (struct _IO_FILE *)fp);
    fwrite("    --replaygain-fast   compute RG fast but slightly inaccurately (default)\n    --replaygain-accurate   compute RG more accurately and find the peak sample\n    --noreplaygain  disable ReplayGain analysis\n    --clipdetect    enable --replaygain-accurate and print a message whether\n                    clipping occurs and how far the waveform is from full scale\n", 1, 361, (struct _IO_FILE *)fp);
    fwrite("    --flush         flush output stream as soon as possible\n    --freeformat    produce a free format bitstream\n    --decode        input=mp3 file, output=wav\n    -t              disable writing wav header when using --decode\n", 1, 226, (struct _IO_FILE *)fp);
    wait_for(fp, lessmode);
    fwrite("  Verbosity:\n    --disptime <arg>print progress report every arg seconds\n    -S              don't print progress report, VBR histograms\n    --nohist        disable VBR histogram display\n    --silent        don't print anything on screen\n    --quiet         don't print anything on screen\n    --brief         print more useful information\n    --verbose       print a lot of useful information\n\n", 1, 394, (struct _IO_FILE *)fp);
    fwrite("  Noise shaping & psycho acoustic algorithms:\n    -q <arg>        <arg> = 0...9.  Default  -q 5 \n                    -q 0:  Highest quality, very slow \n                    -q 9:  Poor quality, but fast \n    -h              Same as -q 2.   Recommended.\n    -f              Same as -q 7.   Fast, ok quality\n", 1, 305, (struct _IO_FILE *)fp);
    wait_for(fp, lessmode);
    fwrite("  CBR (constant bitrate, the default) options:\n    -b <bitrate>    set the bitrate in kbps, default 128 kbps\n    --cbr           enforce use of constant bitrate\n\n  ABR options:\n    --abr <bitrate> specify average bitrate desired (instead of quality)\n\n", 1, 251, (struct _IO_FILE *)fp);
    int32_t v1 = (int32_t)gfp; // 0x804f750_0
    lame_get_VBR_q(v1);
    fprintf((struct _IO_FILE *)fp, "  VBR options:\n    -V n            quality setting for VBR.  default n=%i\n                    0=high quality,bigger files. 9=smaller files\n    -v              the same as -V 4\n    --vbr-old       use old variable bitrate (VBR) routine\n    --vbr-new       use new variable bitrate (VBR) routine (default)\n", v1);
    fwrite("    -b <bitrate>    specify minimum allowed bitrate, default  32 kbps\n    -B <bitrate>    specify maximum allowed bitrate, default 320 kbps\n    -F              strictly enforce the -b option, for use with players that\n                    do not support low bitrate mp3\n    -t              disable writing LAME Tag\n    -T              enable and force writing LAME Tag\n", 1, 368, (struct _IO_FILE *)fp);
    wait_for(fp, lessmode);
    fwrite("  PSY related:\n", 1, 15, (struct _IO_FILE *)fp);
    fwrite("    --temporal-masking x   x=0 disables, x=1 enables temporal masking effect\n    --nssafejoint   M/S switching criterion\n    --nsmsfix <arg> M/S switching tuning [effective 0-3.5]\n    --interch x     adjust inter-channel masking ratio\n    --ns-bass x     adjust masking for sfbs  0 -  6 (long)  0 -  5 (short)\n    --ns-alto x     adjust masking for sfbs  7 - 13 (long)  6 - 10 (short)\n    --ns-treble x   adjust masking for sfbs 14 - 21 (long) 11 - 12 (short)\n", 1, 460, (struct _IO_FILE *)fp);
    fwrite("    --ns-sfb21 x    change ns-treble by x dB for sfb21\n", 1, 55, (struct _IO_FILE *)fp);
    wait_for(fp, lessmode);
    fwrite("  experimental switches:\n    -Y              lets LAME ignore noise in sfb21, like in CBR\n", 1, 90, (struct _IO_FILE *)fp);
    wait_for(fp, lessmode);
    fwrite("  MP3 header/stream options:\n    -e <emp>        de-emphasis n/5/c  (obsolete)\n    -c              mark as copyright\n    -o              mark as non-original\n    -p              error protection.  adds 16 bit checksum to every frame\n                    (the checksum is computed correctly)\n    --nores         disable the bit reservoir\n    --strictly-enforce-ISO   comply as much as possible to ISO MPEG spec\n\n", 1, 410, (struct _IO_FILE *)fp);
    fprintf((struct _IO_FILE *)fp, "  Filter options:\n  --lowpass <freq>        frequency(kHz), lowpass filter cutoff above freq\n  --lowpass-width <freq>  frequency(kHz) - default 15%% of lowpass freq\n  --highpass <freq>       frequency(kHz), highpass filter cutoff below freq\n  --highpass-width <freq> frequency(kHz) - default 15%% of highpass freq\n");
    fwrite("  --resample <sfreq>  sampling frequency of output file(kHz)- default=automatic\n", 1, 80, (struct _IO_FILE *)fp);
    wait_for(fp, lessmode);
    fwrite("  ID3 tag options:\n    --tt <title>    audio/song title (max 30 chars for version 1 tag)\n    --ta <artist>   audio/song artist (max 30 chars for version 1 tag)\n    --tl <album>    audio/song album (max 30 chars for version 1 tag)\n    --ty <year>     audio/song year of issue (1 to 9999)\n    --tc <comment>  user-defined text (max 30 chars for v1 tag, 28 for v1.1)\n    --tn <track[/total]>   audio/song track number and (optionally) the total\n                           number of tracks on the original recording. (track\n                           and total each 1 to 255. just the track number\n                           creates v1.1 tag, providing a total forces v2.0).\n    --tg <genre>    audio/song genre (name or number in list)\n    --ti <file>     audio/song albumArt (jpeg/png/gif file, 128KB max, v2.3)\n    --tv <id=value> user-defined frame specified by id and value (v2.3 tag)\n", 1, 886, (struct _IO_FILE *)fp);
    fwrite("    --add-id3v2     force addition of version 2 tag\n    --id3v1-only    add only a version 1 tag\n    --id3v2-only    add only a version 2 tag\n    --space-id3v1   pad version 1 tag with spaces instead of nulls\n    --pad-id3v2     same as '--pad-id3v2-size 128'\n    --pad-id3v2-size <value> adds version 2 tag, pad with extra <value> bytes\n    --genre-list    print alphabetically sorted ID3 genre list and exit\n    --ignore-tag-errors  ignore errors in values passed for tags\n\n", 1, 476, (struct _IO_FILE *)fp);
    fwrite("    Note: A version 2 tag will NOT be added unless one of the input fields\n    won't fit in a version 1 tag (e.g. the title string is longer than 30\n    characters), or the '--add-id3v2' or '--id3v2-only' options are used,\n    or output is redirected to stdout.\n\nMisc:\n    --license       print License information\n\n", 1, 316, (struct _IO_FILE *)fp);
    wait_for(fp, lessmode);
    fwrite("  Platform specific:\n    --noasm <instructions> disable assembly optimizations for mmx/3dnow/sse\n", 1, 97, (struct _IO_FILE *)fp);
    wait_for(fp, lessmode);
    display_bitrates(fp);
    return 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804f991 - 0x804fa4f
// Line range:    923 - 937
void display_bitrate(struct _IO_FILE_4 * fp, char * version, int32_t d, int32_t indx) {
    // 0x804f991
    int32_t v1;
    int32_t i = v1; // bp-20
    i = d == 4 ? 8 : 14;
    int64_t v2 = d; // 0x804f9c0
    fprintf((struct _IO_FILE *)fp, "\nMPEG-%-3s layer III sample frequencies (kHz):  %2d  %2d  %g\nbitrates (kbps):", version, (int32_t)(32 / v2), (int32_t)(48 / v2), (float64_t)(44.1L / (float80_t)d));
    if (i < 1) {
        // 0x804fa3b
        fputc(10, (struct _IO_FILE *)fp);
        return;
    }
    int32_t v3 = 16 * indx; // 0x804fa0a
    // branch -> 0x804fa04
    for (int32_t j = 1; j < i + 1; j++) {
        int32_t v4 = *(int32_t *)(4 * (j + v3) + (int32_t)&g11); // 0x804fa10
        fprintf((struct _IO_FILE *)fp, " %2i", v4);
        // continue -> 0x804fa04
    }
    // 0x804fa3b
    fputc(10, (struct _IO_FILE *)fp);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804fa50 - 0x804fae3
// Line range:    940 - 948
int32_t display_bitrates(struct _IO_FILE_4 * fp) {
    // 0x804fa50
    display_bitrate(fp, "1", 1, 1);
    display_bitrate(fp, "2", 2, 0);
    display_bitrate(fp, "2.5", 4, 0);
    fputc(10, (struct _IO_FILE *)fp);
    fflush((struct _IO_FILE *)fp);
    return 0;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804fae4 - 0x804fc9b
// Line range:    976 - 1047
void presets_longinfo_dm(struct _IO_FILE_4 * msgfp) {
    // 0x804fae4
    fwrite("\nThe --preset switches are aliases over LAME settings.\n\n\n", 1, 57, (struct _IO_FILE *)msgfp);
    fwrite("To activate these presets:\n\n   For VBR modes (generally highest quality):\n\n", 1, 75, (struct _IO_FILE *)msgfp);
    fwrite("     \"--preset medium\" This preset should provide near transparency\n                             to most people on most music.\n\n     \"--preset standard\" This preset should generally be transparent\n                             to most people on most music and is already\n                             quite high in quality.\n\n", 1, 323, (struct _IO_FILE *)msgfp);
    fwrite("     \"--preset extreme\" If you have extremely good hearing and similar\n                             equipment, this preset will generally provide\n                             slightly higher quality than the \"standard\"\n                             mode.\n\n", 1, 255, (struct _IO_FILE *)msgfp);
    fwrite("   For CBR 320kbps (highest quality possible from the --preset switches):\n\n     \"--preset insane\"  This preset will usually be overkill for most\n                             people and most situations, but if you must\n                             have the absolute highest quality with no\n                             regard to filesize, this is the way to go.\n\n", 1, 362, (struct _IO_FILE *)msgfp);
    fwrite("   For ABR modes (high quality per given bitrate but not as high as VBR):\n\n     \"--preset <kbps>\"  Using this preset will usually give you good\n                             quality at a specified bitrate. Depending on the\n                             bitrate entered, this preset will determine the\n", 1, 299, (struct _IO_FILE *)msgfp);
    fwrite("                             optimal settings for that particular situation.\n                             While this approach works, it is not nearly as\n                             flexible as VBR, and usually will not attain the\n                             same level of quality as VBR at higher bitrates.\n\n", 1, 310, (struct _IO_FILE *)msgfp);
    fwrite("The following options are also available for the corresponding profiles:\n\n   <fast>        standard\n   <fast>        extreme\n                 insane\n   <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n                      simply specify a bitrate. For example:\n                      \"--preset 185\" activates this\n                      preset and uses 185 as an average kbps.\n\n", 1, 383, (struct _IO_FILE *)msgfp);
    fwrite("   \"fast\" - Enables the fast VBR mode for a particular profile.\n\n", 1, 65, (struct _IO_FILE *)msgfp);
    fwrite("   \"cbr\"  - If you use the ABR mode (read above) with a significant\n            bitrate such as 80, 96, 112, 128, 160, 192, 224, 256, 320,\n            you can use the \"cbr\" option to force CBR mode encoding\n            instead of the standard abr mode. ABR does provide higher\n            quality but CBR may be useful in situations such as when\n            streaming an mp3 over the internet may be important.\n\n", 1, 412, (struct _IO_FILE *)msgfp);
    fwrite("    For example:\n\n    \"--preset fast standard <input file> <output file>\"\n or \"--preset cbr 192 <input file> <output file>\"\n or \"--preset 172 <input file> <output file>\"\n or \"--preset extreme <input file> <output file>\"\n\n\n", 1, 222, (struct _IO_FILE *)msgfp);
    fwrite("A few aliases are also available for ABR mode:\nphone => 16kbps/mono        phon+/lw/mw-eu/sw => 24kbps/mono\nmw-us => 40kbps/mono        voice => 56kbps/mono\nfm/radio/tape => 112kbps    hifi => 160kbps\ncd => 192kbps               studio => 256kbps\n", 1, 247, (struct _IO_FILE *)msgfp);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x804fc9c - 0x80500dd
// Line range:    1055 - 1192
int32_t presets_set(struct lame_global_struct_2 * gfp, int32_t fast, int32_t cbr, char * preset_name, char * ProgramName) {
    if (cbr > 0 | fast > 0 | strcmp(preset_name, "help") != 0) {
        int32_t strcmp_rc = strcmp(preset_name, "phone"); // 0x804fcfe
        char * str = strcmp_rc == 0 ? "16" : preset_name;
        char * str8; // 0x805001536
        char * str6; // 0x805001538
        char * str4; // 0x805001540
        char * str2; // 0x805001542
        int32_t v1; // 0x804fec3_0
        int32_t v2; // 0x804ff25_0
        int32_t v3; // 0x804ff87_0
        int32_t strcmp_rc2; // 0x804fd8d
        int32_t strcmp_rc3; // 0x804fdb2
        int32_t str_as_i; // 0x805001b
        struct _IO_FILE_1 * v4;
        struct _IO_FILE_1 * v5;
        char * str7; // 0x805001536
        char * str5; // 0x805001538
        char * str3; // 0x805001540
        int32_t v6; // 0x805004833
        if (strcmp(str, "phon+") != 0) {
            // 0x804fd2c
            if (strcmp(str, "lw") != 0) {
                // 0x804fd43
                if (strcmp(str, "mw-eu") != 0) {
                    // 0x804fd5a
                    if (strcmp(str, "sw") != 0) {
                        v6 = strcmp_rc == 0;
                        // 0x804fd7f
                        strcmp_rc2 = strcmp(str, "mw-us");
                        str2 = strcmp_rc2 == 0 ? "40" : str;
                        strcmp_rc3 = strcmp(str2, "voice");
                        str3 = strcmp_rc3 == 0 ? "56" : str2;
                        str4 = strcmp(str3, "fm") == 0 ? "112" : str3;
                        if (strcmp(str4, "radio") != 0) {
                            // 0x804fdfe
                            if (strcmp(str4, "tape") != 0) {
                                str5 = str4;
                                // 0x804fe1c
                                str6 = strcmp(str5, "hifi") == 0 ? "160" : str5;
                                str7 = strcmp(str6, "cd") == 0 ? "192" : str6;
                                str8 = strcmp(str7, "studio") == 0 ? "256" : str7;
                                if (strcmp(str8, "medium") == 0) {
                                    // 0x804fe8d
                                    lame_set_VBR_q((int32_t)gfp, 4);
                                    v1 = (int32_t)gfp;
                                    if (fast < 1) {
                                        // 0x804febb
                                        lame_set_VBR(v1, 2);
                                        // branch -> 0x804fece
                                    } else {
                                        // 0x804fea6
                                        lame_set_VBR(v1, 4);
                                        // branch -> 0x804fece
                                    }
                                    // 0x804fece
                                    // branch -> 0x80500dc
                                    // 0x80500dc
                                    return 0;
                                }
                                // 0x804fed8
                                if (strcmp(str8, "standard") == 0) {
                                    // 0x804feef
                                    lame_set_VBR_q((int32_t)gfp, 2);
                                    v2 = (int32_t)gfp;
                                    if (fast < 1) {
                                        // 0x804ff1d
                                        lame_set_VBR(v2, 2);
                                        // branch -> 0x804ff30
                                    } else {
                                        // 0x804ff08
                                        lame_set_VBR(v2, 4);
                                        // branch -> 0x804ff30
                                    }
                                    // 0x804ff30
                                    // branch -> 0x80500dc
                                    // 0x80500dc
                                    return 0;
                                }
                                // 0x804ff3a
                                if (strcmp(str8, "extreme") == 0) {
                                    // 0x804ff51
                                    lame_set_VBR_q((int32_t)gfp, 0);
                                    v3 = (int32_t)gfp;
                                    if (fast < 1) {
                                        // 0x804ff7f
                                        lame_set_VBR(v3, 2);
                                        // branch -> 0x804ff92
                                    } else {
                                        // 0x804ff6a
                                        lame_set_VBR(v3, 4);
                                        // branch -> 0x804ff92
                                    }
                                    // 0x804ff92
                                    // branch -> 0x80500dc
                                    // 0x80500dc
                                    return 0;
                                }
                                // 0x804ff9c
                                if (fast > 0 | strcmp(str8, "insane") != 0) {
                                    // 0x804ffd6
                                    if (fast > 0 | atoi(str8) < 1) {
                                        // 0x805008f
                                        v5 = g39;
                                        g1 = (int32_t)v5;
                                        lame_version_print((struct _IO_FILE_4 *)v5);
                                        error_printf("Error: You did not enter a valid profile and/or options with --preset\n\nAvailable profiles are:\n\n   <fast>        medium\n   <fast>        standard\n   <fast>        extreme\n                 insane\n          <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n                             simply specify a bitrate. For example:\n                             \"--preset 185\" activates this\n                             preset and uses 185 as an average kbps.\n\n");
                                        error_printf("    Some examples:\n\n or \"%s --preset fast standard <input file> <output file>\"\n or \"%s --preset cbr 192 <input file> <output file>\"\n or \"%s --preset 172 <input file> <output file>\"\n or \"%s --preset extreme <input file> <output file>\"\n\nFor further information try: \"%s --preset help\"\n");
                                        // branch -> 0x80500dc
                                    } else {
                                        // 0x804fff3
                                        if (atoi(str8) >= 8) {
                                            // 0x8050003
                                            if (atoi(str8) <= 320) {
                                                // 0x8050015
                                                str_as_i = atoi(str8);
                                                lame_set_preset((int32_t)gfp, str_as_i);
                                                if (cbr == 1) {
                                                    // 0x8050035
                                                    lame_set_VBR((int32_t)gfp, 0);
                                                    // branch -> 0x8050048
                                                }
                                                // 0x8050048
                                                if (strcmp_rc3 == 0 || v6 == 1 || strcmp_rc2 == 0) {
                                                    // 0x805004e
                                                    lame_set_mode((int32_t)gfp, 3);
                                                    // branch -> 0x8050061
                                                }
                                                // 0x8050061
                                                // branch -> 0x80500dc
                                                // 0x80500dc
                                                return 0;
                                            }
                                        }
                                        // 0x8050068
                                        v4 = g39;
                                        g1 = (int32_t)v4;
                                        lame_version_print((struct _IO_FILE_4 *)v4);
                                        error_printf("Error: The bitrate specified is out of the valid range for this preset\n\nWhen using this mode you must enter a value between \"32\" and \"320\"\n\nFor further information try: \"%s --preset help\"\n");
                                        // branch -> 0x80500dc
                                    }
                                    // 0x80500dc
                                    return -1;
                                }
                                // 0x804ffb9
                                lame_set_preset((int32_t)gfp, 1003);
                                // branch -> 0x80500dc
                                // 0x80500dc
                                return 0;
                            }
                        }
                        // 0x804fe15
                        str5 = "112";
                        // branch -> 0x804fe1c
                        // 0x804fe1c
                        str6 = strcmp(str5, "hifi") == 0 ? "160" : str5;
                        str7 = strcmp(str6, "cd") == 0 ? "192" : str6;
                        str8 = strcmp(str7, "studio") == 0 ? "256" : str7;
                        if (strcmp(str8, "medium") == 0) {
                            // 0x804fe8d
                            lame_set_VBR_q((int32_t)gfp, 4);
                            v1 = (int32_t)gfp;
                            if (fast < 1) {
                                // 0x804febb
                                lame_set_VBR(v1, 2);
                                // branch -> 0x804fece
                            } else {
                                // 0x804fea6
                                lame_set_VBR(v1, 4);
                                // branch -> 0x804fece
                            }
                            // 0x804fece
                            // branch -> 0x80500dc
                            // 0x80500dc
                            return 0;
                        }
                        // 0x804fed8
                        if (strcmp(str8, "standard") == 0) {
                            // 0x804feef
                            lame_set_VBR_q((int32_t)gfp, 2);
                            v2 = (int32_t)gfp;
                            if (fast < 1) {
                                // 0x804ff1d
                                lame_set_VBR(v2, 2);
                                // branch -> 0x804ff30
                            } else {
                                // 0x804ff08
                                lame_set_VBR(v2, 4);
                                // branch -> 0x804ff30
                            }
                            // 0x804ff30
                            // branch -> 0x80500dc
                            // 0x80500dc
                            return 0;
                        }
                        // 0x804ff3a
                        if (strcmp(str8, "extreme") == 0) {
                            // 0x804ff51
                            lame_set_VBR_q((int32_t)gfp, 0);
                            v3 = (int32_t)gfp;
                            if (fast < 1) {
                                // 0x804ff7f
                                lame_set_VBR(v3, 2);
                                // branch -> 0x804ff92
                            } else {
                                // 0x804ff6a
                                lame_set_VBR(v3, 4);
                                // branch -> 0x804ff92
                            }
                            // 0x804ff92
                            // branch -> 0x80500dc
                            // 0x80500dc
                            return 0;
                        }
                        // 0x804ff9c
                        if (fast > 0 | strcmp(str8, "insane") != 0) {
                            // 0x804ffd6
                            if (fast > 0 | atoi(str8) < 1) {
                                // 0x805008f
                                v5 = g39;
                                g1 = (int32_t)v5;
                                lame_version_print((struct _IO_FILE_4 *)v5);
                                error_printf("Error: You did not enter a valid profile and/or options with --preset\n\nAvailable profiles are:\n\n   <fast>        medium\n   <fast>        standard\n   <fast>        extreme\n                 insane\n          <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n                             simply specify a bitrate. For example:\n                             \"--preset 185\" activates this\n                             preset and uses 185 as an average kbps.\n\n");
                                error_printf("    Some examples:\n\n or \"%s --preset fast standard <input file> <output file>\"\n or \"%s --preset cbr 192 <input file> <output file>\"\n or \"%s --preset 172 <input file> <output file>\"\n or \"%s --preset extreme <input file> <output file>\"\n\nFor further information try: \"%s --preset help\"\n");
                                // branch -> 0x80500dc
                            } else {
                                // 0x804fff3
                                if (atoi(str8) >= 8) {
                                    // 0x8050003
                                    if (atoi(str8) <= 320) {
                                        // 0x8050015
                                        str_as_i = atoi(str8);
                                        lame_set_preset((int32_t)gfp, str_as_i);
                                        if (cbr == 1) {
                                            // 0x8050035
                                            lame_set_VBR((int32_t)gfp, 0);
                                            // branch -> 0x8050048
                                        }
                                        // 0x8050048
                                        if (strcmp_rc3 == 0 || v6 == 1 || strcmp_rc2 == 0) {
                                            // 0x805004e
                                            lame_set_mode((int32_t)gfp, 3);
                                            // branch -> 0x8050061
                                        }
                                        // 0x8050061
                                        // branch -> 0x80500dc
                                        // 0x80500dc
                                        return 0;
                                    }
                                }
                                // 0x8050068
                                v4 = g39;
                                g1 = (int32_t)v4;
                                lame_version_print((struct _IO_FILE_4 *)v4);
                                error_printf("Error: The bitrate specified is out of the valid range for this preset\n\nWhen using this mode you must enter a value between \"32\" and \"320\"\n\nFor further information try: \"%s --preset help\"\n");
                                // branch -> 0x80500dc
                            }
                            // 0x80500dc
                            return -1;
                        }
                        // 0x804ffb9
                        lame_set_preset((int32_t)gfp, 1003);
                        // branch -> 0x80500dc
                        // 0x80500dc
                        return 0;
                    }
                }
            }
        }
        // 0x804fd71
        str = "24";
        v6 = 1;
        // branch -> 0x804fd7f
        // 0x804fd7f
        strcmp_rc2 = strcmp(str, "mw-us");
        str2 = strcmp_rc2 == 0 ? "40" : str;
        strcmp_rc3 = strcmp(str2, "voice");
        str3 = strcmp_rc3 == 0 ? "56" : str2;
        str4 = strcmp(str3, "fm") == 0 ? "112" : str3;
        if (strcmp(str4, "radio") != 0) {
            // 0x804fdfe
            if (strcmp(str4, "tape") != 0) {
                str5 = str4;
                // 0x804fe1c
                str6 = strcmp(str5, "hifi") == 0 ? "160" : str5;
                str7 = strcmp(str6, "cd") == 0 ? "192" : str6;
                str8 = strcmp(str7, "studio") == 0 ? "256" : str7;
                if (strcmp(str8, "medium") == 0) {
                    // 0x804fe8d
                    lame_set_VBR_q((int32_t)gfp, 4);
                    v1 = (int32_t)gfp;
                    if (fast < 1) {
                        // 0x804febb
                        lame_set_VBR(v1, 2);
                        // branch -> 0x804fece
                    } else {
                        // 0x804fea6
                        lame_set_VBR(v1, 4);
                        // branch -> 0x804fece
                    }
                    // 0x804fece
                    // branch -> 0x80500dc
                    // 0x80500dc
                    return 0;
                }
                // 0x804fed8
                if (strcmp(str8, "standard") == 0) {
                    // 0x804feef
                    lame_set_VBR_q((int32_t)gfp, 2);
                    v2 = (int32_t)gfp;
                    if (fast < 1) {
                        // 0x804ff1d
                        lame_set_VBR(v2, 2);
                        // branch -> 0x804ff30
                    } else {
                        // 0x804ff08
                        lame_set_VBR(v2, 4);
                        // branch -> 0x804ff30
                    }
                    // 0x804ff30
                    // branch -> 0x80500dc
                    // 0x80500dc
                    return 0;
                }
                // 0x804ff3a
                if (strcmp(str8, "extreme") == 0) {
                    // 0x804ff51
                    lame_set_VBR_q((int32_t)gfp, 0);
                    v3 = (int32_t)gfp;
                    if (fast < 1) {
                        // 0x804ff7f
                        lame_set_VBR(v3, 2);
                        // branch -> 0x804ff92
                    } else {
                        // 0x804ff6a
                        lame_set_VBR(v3, 4);
                        // branch -> 0x804ff92
                    }
                    // 0x804ff92
                    // branch -> 0x80500dc
                    // 0x80500dc
                    return 0;
                }
                // 0x804ff9c
                if (fast > 0 | strcmp(str8, "insane") != 0) {
                    // 0x804ffd6
                    if (fast > 0 | atoi(str8) < 1) {
                        // 0x805008f
                        v5 = g39;
                        g1 = (int32_t)v5;
                        lame_version_print((struct _IO_FILE_4 *)v5);
                        error_printf("Error: You did not enter a valid profile and/or options with --preset\n\nAvailable profiles are:\n\n   <fast>        medium\n   <fast>        standard\n   <fast>        extreme\n                 insane\n          <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n                             simply specify a bitrate. For example:\n                             \"--preset 185\" activates this\n                             preset and uses 185 as an average kbps.\n\n");
                        error_printf("    Some examples:\n\n or \"%s --preset fast standard <input file> <output file>\"\n or \"%s --preset cbr 192 <input file> <output file>\"\n or \"%s --preset 172 <input file> <output file>\"\n or \"%s --preset extreme <input file> <output file>\"\n\nFor further information try: \"%s --preset help\"\n");
                        // branch -> 0x80500dc
                    } else {
                        // 0x804fff3
                        if (atoi(str8) >= 8) {
                            // 0x8050003
                            if (atoi(str8) <= 320) {
                                // 0x8050015
                                str_as_i = atoi(str8);
                                lame_set_preset((int32_t)gfp, str_as_i);
                                if (cbr == 1) {
                                    // 0x8050035
                                    lame_set_VBR((int32_t)gfp, 0);
                                    // branch -> 0x8050048
                                }
                                // 0x8050048
                                if (strcmp_rc3 == 0 || v6 == 1 || strcmp_rc2 == 0) {
                                    // 0x805004e
                                    lame_set_mode((int32_t)gfp, 3);
                                    // branch -> 0x8050061
                                }
                                // 0x8050061
                                // branch -> 0x80500dc
                                // 0x80500dc
                                return 0;
                            }
                        }
                        // 0x8050068
                        v4 = g39;
                        g1 = (int32_t)v4;
                        lame_version_print((struct _IO_FILE_4 *)v4);
                        error_printf("Error: The bitrate specified is out of the valid range for this preset\n\nWhen using this mode you must enter a value between \"32\" and \"320\"\n\nFor further information try: \"%s --preset help\"\n");
                        // branch -> 0x80500dc
                    }
                    // 0x80500dc
                    return -1;
                }
                // 0x804ffb9
                lame_set_preset((int32_t)gfp, 1003);
                // branch -> 0x80500dc
                // 0x80500dc
                return 0;
            }
        }
        // 0x804fe15
        str5 = "112";
        // branch -> 0x804fe1c
        // 0x804fe1c
        str6 = strcmp(str5, "hifi") == 0 ? "160" : str5;
        str7 = strcmp(str6, "cd") == 0 ? "192" : str6;
        str8 = strcmp(str7, "studio") == 0 ? "256" : str7;
        if (strcmp(str8, "medium") == 0) {
            // 0x804fe8d
            lame_set_VBR_q((int32_t)gfp, 4);
            v1 = (int32_t)gfp;
            if (fast < 1) {
                // 0x804febb
                lame_set_VBR(v1, 2);
                // branch -> 0x804fece
            } else {
                // 0x804fea6
                lame_set_VBR(v1, 4);
                // branch -> 0x804fece
            }
            // 0x804fece
            // branch -> 0x80500dc
            // 0x80500dc
            return 0;
        }
        // 0x804fed8
        if (strcmp(str8, "standard") == 0) {
            // 0x804feef
            lame_set_VBR_q((int32_t)gfp, 2);
            v2 = (int32_t)gfp;
            if (fast < 1) {
                // 0x804ff1d
                lame_set_VBR(v2, 2);
                // branch -> 0x804ff30
            } else {
                // 0x804ff08
                lame_set_VBR(v2, 4);
                // branch -> 0x804ff30
            }
            // 0x804ff30
            // branch -> 0x80500dc
            // 0x80500dc
            return 0;
        }
        // 0x804ff3a
        if (strcmp(str8, "extreme") == 0) {
            // 0x804ff51
            lame_set_VBR_q((int32_t)gfp, 0);
            v3 = (int32_t)gfp;
            if (fast < 1) {
                // 0x804ff7f
                lame_set_VBR(v3, 2);
                // branch -> 0x804ff92
            } else {
                // 0x804ff6a
                lame_set_VBR(v3, 4);
                // branch -> 0x804ff92
            }
            // 0x804ff92
            // branch -> 0x80500dc
            // 0x80500dc
            return 0;
        }
        // 0x804ff9c
        if (fast > 0 | strcmp(str8, "insane") != 0) {
            // 0x804ffd6
            if (fast > 0 | atoi(str8) < 1) {
                // 0x805008f
                v5 = g39;
                g1 = (int32_t)v5;
                lame_version_print((struct _IO_FILE_4 *)v5);
                error_printf("Error: You did not enter a valid profile and/or options with --preset\n\nAvailable profiles are:\n\n   <fast>        medium\n   <fast>        standard\n   <fast>        extreme\n                 insane\n          <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n                             simply specify a bitrate. For example:\n                             \"--preset 185\" activates this\n                             preset and uses 185 as an average kbps.\n\n");
                error_printf("    Some examples:\n\n or \"%s --preset fast standard <input file> <output file>\"\n or \"%s --preset cbr 192 <input file> <output file>\"\n or \"%s --preset 172 <input file> <output file>\"\n or \"%s --preset extreme <input file> <output file>\"\n\nFor further information try: \"%s --preset help\"\n");
                // branch -> 0x80500dc
            } else {
                // 0x804fff3
                if (atoi(str8) >= 8) {
                    // 0x8050003
                    if (atoi(str8) <= 320) {
                        // 0x8050015
                        str_as_i = atoi(str8);
                        lame_set_preset((int32_t)gfp, str_as_i);
                        if (cbr == 1) {
                            // 0x8050035
                            lame_set_VBR((int32_t)gfp, 0);
                            // branch -> 0x8050048
                        }
                        // 0x8050048
                        if (strcmp_rc3 == 0 || v6 == 1 || strcmp_rc2 == 0) {
                            // 0x805004e
                            lame_set_mode((int32_t)gfp, 3);
                            // branch -> 0x8050061
                        }
                        // 0x8050061
                        // branch -> 0x80500dc
                        // 0x80500dc
                        return 0;
                    }
                }
                // 0x8050068
                v4 = g39;
                g1 = (int32_t)v4;
                lame_version_print((struct _IO_FILE_4 *)v4);
                error_printf("Error: The bitrate specified is out of the valid range for this preset\n\nWhen using this mode you must enter a value between \"32\" and \"320\"\n\nFor further information try: \"%s --preset help\"\n");
                // branch -> 0x80500dc
            }
            // 0x80500dc
            return -1;
        }
        // 0x804ffb9
        lame_set_preset((int32_t)gfp, 1003);
        // branch -> 0x80500dc
        // 0x80500dc
        return 0;
    }
    // 0x804fccc
    g1 = (int32_t)g14;
    lame_version_print((struct _IO_FILE_4 *)g14);
    presets_longinfo_dm((struct _IO_FILE_4 *)g14);
    // branch -> 0x80500dc
    // 0x80500dc
    return -1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x80500de - 0x80500ff
// Line range:    1195 - 1199
void genre_list_handler(int32_t num, char * name, char * cookie) {
    // 0x80500de
    console_printf("%3d %s\n");
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x8050100 - 0x8050157
// Line range:    1219 - 1234
int32_t local_strcasecmp(char * s1, char * s2) {
    // branch -> 0x8050106
    uint32_t v1; // 0x805012b_0
    int32_t v2; // 0x805013c
    while (true) {
        int32_t v3 = 0x1000000 * tolower((int32_t)*s1);
        uint32_t v4 = v3 / 0x1000000; // 0x8050117_0
        v1 = 0x1000000 * tolower((int32_t)*s2) / 0x1000000;
        if (v3 == 0) {
            // 0x8050106
            // branch -> 0x8050148
            // 0x8050148
            return v4 % 256 - v1 % 256;
        }
        // 0x8050134
        v2 = v4 % 256;
        if (v4 != v1) {
            // break -> 0x8050148
            break;
        }
        s1 = (char *)((int32_t)s1 + 1);
        s2 = (char *)((int32_t)s2 + 1);
        // continue -> 0x8050106
    }
    // 0x8050148
    return v2 - v1 % 256;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x8050158 - 0x8050284
// Line range:    1242 - 1267
int32_t filename_to_type(char * FileName) {
    uint32_t len = strlen(FileName); // 0x8050164
    if (len <= 3) {
        // 0x8050172
        // branch -> 0x8050283
        // 0x8050283
        return 0;
    }
    char * v1 = (char *)((int32_t)FileName - 4 + len); // 0x8050182_8
    if (local_strcasecmp(v1, ".mpg") == 0 || local_strcasecmp(v1, ".mp1") == 0 || local_strcasecmp(v1, ".mp2") == 0 || local_strcasecmp(v1, ".mp3") == 0) {
        // 0x805019c
        // branch -> 0x8050283
        // 0x8050283
        return 7;
    }
    // 0x8050206
    if (local_strcasecmp(v1, ".wav") == 0) {
        // 0x805021d
        // branch -> 0x8050283
        // 0x8050283
        return 2;
    }
    // 0x8050224
    if (local_strcasecmp(v1, ".aif") == 0) {
        // 0x805023b
        // branch -> 0x8050283
        // 0x8050283
        return 3;
    }
    // 0x8050242
    if (local_strcasecmp(v1, ".raw") == 0) {
        // 0x8050259
        // branch -> 0x8050283
        // 0x8050283
        return 1;
    }
    // 0x8050260
    int32_t result; // 0x8050284_2
    if (local_strcasecmp(v1, ".ogg") == 0) {
        // 0x8050277
        result = 8;
        // branch -> 0x8050283
    } else {
        // 0x805027e
        result = 0;
        // branch -> 0x8050283
    }
    // 0x8050283
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x8050285 - 0x8050340
// Line range:    1270 - 1298
int32_t resample_rate(float64_t freq) {
    float80_t v1 = freq;
    g58 = v1;
    int32_t result; // 0x8050340_2
    int32_t v2;
    float64_t v3;
    float80_t v4;
    if (freq > 1000.0) {
        // after_if_80502a2_0
        v3 = freq;
        if ((v2 & -256) != 1) {
            // 0x80502ad
            g58 = 0.001L;
            v3 = 0.001L * v1;
            // branch -> 0x80502bb
        }
        // 0x80502bb
        v4 = v3;
        g59 = v4;
        switch ((int32_t)v3) {
            default: {
                // 0x8050327
                g59 = v4;
                error_printf("Illegal resample frequency: %.3f kHz\n");
                result = 0;
                // branch -> 0x805033f
                break;
            }
            case 8: {
                // 0x80502e8
                result = 0x1f40;
                // branch -> 0x805033f
                break;
            }
            case 11: {
                // 0x80502ef
                result = 0x2b11;
                // branch -> 0x805033f
                break;
            }
            case 12: {
                // 0x80502f6
                result = 0x2ee0;
                // branch -> 0x805033f
                break;
            }
            case 16: {
                // 0x80502fd
                result = 0x3e80;
                // branch -> 0x805033f
                break;
            }
            case 22: {
                // 0x8050304
                result = 0x5622;
                // branch -> 0x805033f
                break;
            }
            case 24: {
                // 0x805030b
                result = 0x5dc0;
                // branch -> 0x805033f
                break;
            }
            case 32: {
                // 0x8050312
                result = 0x7d00;
                // branch -> 0x805033f
                break;
            }
            case 44: {
                // 0x8050319
                result = 0xac44;
                // branch -> 0x805033f
                break;
            }
            case 48: {
                // 0x8050320
                result = 0xbb80;
                // branch -> 0x805033f
                break;
            }
        }
        // 0x805033f
        return result;
    }
    // if_80502a2_0_false
    int32_t v5;
    if (freq >= 1000.0) {
        // if_80502a2_1_false
        v5 = freq != 1000.0;
        // branch -> after_if_80502a2_0
    } else {
        v5 = 1;
    }
    // after_if_80502a2_0
    v3 = freq;
    if ((v5 || v2 & -256) != 1) {
        // 0x80502ad
        g58 = 0.001L;
        v3 = 0.001L * v1;
        // branch -> 0x80502bb
    }
    // 0x80502bb
    v4 = v3;
    g59 = v4;
    switch ((int32_t)v3) {
        default: {
            // 0x8050327
            g59 = v4;
            error_printf("Illegal resample frequency: %.3f kHz\n");
            result = 0;
            // branch -> 0x805033f
            break;
        }
        case 8: {
            // 0x80502e8
            result = 0x1f40;
            // branch -> 0x805033f
            break;
        }
        case 11: {
            // 0x80502ef
            result = 0x2b11;
            // branch -> 0x805033f
            break;
        }
        case 12: {
            // 0x80502f6
            result = 0x2ee0;
            // branch -> 0x805033f
            break;
        }
        case 16: {
            // 0x80502fd
            result = 0x3e80;
            // branch -> 0x805033f
            break;
        }
        case 22: {
            // 0x8050304
            result = 0x5622;
            // branch -> 0x805033f
            break;
        }
        case 24: {
            // 0x805030b
            result = 0x5dc0;
            // branch -> 0x805033f
            break;
        }
        case 32: {
            // 0x8050312
            result = 0x7d00;
            // branch -> 0x805033f
            break;
        }
        case 44: {
            // 0x8050319
            result = 0xac44;
            // branch -> 0x805033f
            break;
        }
        case 48: {
            // 0x8050320
            result = 0xbb80;
            // branch -> 0x805033f
            break;
        }
    }
    // 0x805033f
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x8050341 - 0x80504d6
// Line range:    1302 - 1344
int32_t set_id3_albumart(struct lame_global_struct_2 * gfp, char * file_name) {
    // 0x8050341
    char * v1;
    char * albumart = v1; // bp-28
    struct _IO_FILE_4 * v2;
    struct _IO_FILE_4 * fpi = v2; // bp-24
    int32_t v3;
    int32_t ret = v3; // bp-20
    ret = 0;
    fpi = NULL;
    if (file_name == NULL) {
        // 0x80504d5
        return 0;
    }
    struct _IO_FILE * stream = fopen64(file_name, "rb"); // 0x805037b
    ret = (int32_t)stream;
    if (stream == NULL) {
        // 0x8050487
        error_printf("Could not find: '%s'.\n");
        // branch -> 0x80504d5
        // 0x80504d5
        return 1;
    }
    // 0x8050395
    fseek(stream, 0, SEEK_END);
    albumart = (char *)ftell((struct _IO_FILE *)ret);
    fseek((struct _IO_FILE *)ret, 0, SEEK_SET);
    char * mem = malloc((int32_t)albumart); // 0x80503df
    fpi = (struct _IO_FILE_4 *)mem;
    int32_t v4 = 2;
    if (mem != NULL) {
        int32_t v5 = 3;
        if (fread(mem, 1, (int32_t)albumart, (struct _IO_FILE *)ret) == 0) {
            int32_t v6 = (int32_t)gfp; // 0x8050433_0
            id3tag_set_albumart(v6, (int32_t)fpi, (int32_t)albumart);
            v5 = v6 == 0 ? 0 : 4;
            // branch -> 0x8050451
        }
        // 0x8050451
        free((char *)fpi);
        v4 = v5;
        // branch -> 0x8050467
    }
    // 0x8050467
    fclose((struct _IO_FILE *)ret);
    int32_t result;
    if (v4 == 2) {
        // 0x805049c
        error_printf("Insufficient memory for reading the albumart.\n");
        result = 2;
        // branch -> 0x80504d5
    } else {
        // 0x805046f
        if (v4 > 2) {
            // 0x805047b
            result = v4;
            switch (v4) {
                case 3: {
                    // 0x80504aa
                    error_printf("Read error: '%s'.\n");
                    result = 3;
                    // branch -> 0x80504d5
                    break;
                }
                case 4: {
                    // 0x80504bf
                    error_printf("Unsupported image: '%s'.\nSpecify JPEG/PNG/GIF image (128KB maximum)\n");
                    result = 4;
                    // branch -> 0x80504d5
                    break;
                }
            }
            // 0x80504d5
            return result;
        }
        result = v4;
    }
    // 0x80504d5
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/parse.c
// Address range: 0x80504d7 - 0x8052913
// Line range:    1363 - 2338
int32_t parse_args(struct lame_global_struct_2 * gfp, uint32_t argc, char ** argv, char * inPath, char * outPath, char ** nogap_inPath, int32_t * num_nogap) {
    int32_t v1;
    int32_t tmp_quality = v1; // bp-120
    int32_t v2;
    int32_t fast = v2; // bp-108
    struct _IO_FILE_4 * v3;
    struct _IO_FILE_4 * fp = v3; // bp-104
    int32_t v4;
    int32_t k = v4; // bp-100
    char * v5;
    char * nextArg = v5; // bp-68
    char * v6;
    char * arg = v6; // bp-64
    char * v7;
    char * token = v7; // bp-60
    int32_t v8;
    int32_t id3tag_mode = v8; // bp-56
    int32_t v9;
    int32_t noreplaygain = v9; // bp-52
    int32_t v10;
    int32_t count_nogap = v10; // bp-48
    char * v11;
    char * ProgramName = v11; // bp-44
    int32_t v12;
    int32_t nogap_tags = v12; // bp-40
    int32_t v13;
    int32_t nogap = v13; // bp-36
    int32_t v14;
    int32_t autoconvert = v14; // bp-32
    int32_t v15;
    int32_t i = v15; // bp-28
    int32_t v16;
    int32_t input_file = v16; // bp-24
    struct lame_global_struct_2 * v17 = gfp;
    i = 0;
    autoconvert = 0;
    nogap = 0;
    int32_t v18 = (int32_t)argv; // 0x80504fc_0
    nogap_tags = *(int32_t *)argv;
    ProgramName = NULL;
    count_nogap = 0;
    noreplaygain = 0;
    *inPath = 0;
    *outPath = 0;
    silent = 0;
    ignore_tag_errors = 0;
    g44 = 1;
    mp3_delay = 0;
    mp3_delay_set = 0;
    print_clipping_info = 0;
    disable_wav_header = 0;
    id3tag_init((int32_t)gfp);
    input_file = 1;
    if (argc > 1) {
        int32_t v19 = 1; // 0x80526d210051023
        int32_t v20 = 0; // 0x80526d210041022
        int32_t v21 = 0;
      lab_0x8050582_5:
        while (true) {
            int32_t v22 = v19; // 0x80526d21008
            int32_t v23 = v20; // 0x80526d21007
            // branch -> 0x8050582
            int32_t v24; // 0x805277a_0
            int32_t v25; // 0x80527d2_0
            int32_t v26; // 0x8052877_0
            int32_t v27; // 0x805288f_0
            int32_t v28; // 0x80528af_0
            int32_t v29; // 0x80528be_0
            int32_t v30; // 0x80528ce_0
            int32_t v31; // 0x8052832
            int32_t v32; // eax
            int32_t v33; // 0x8052710
            int32_t v34; // 0x805271f
            int32_t v35; // 0x8052823
            int32_t v36; // 0x805283c
            int32_t v37;
            while (true) {
                int32_t * str = (int32_t *)(4 * v22 + v18); // 0x805058b_0
                int32_t v38 = *str; // 0x805058b
                id3tag_mode = v38;
                int32_t v39 = v38 + 1; // 0x805059b
                id3tag_mode = v39;
                int32_t v40; // 0x80526d21005
                int32_t result; // 0x8052913_2
                struct _IO_FILE_1 * v41;
                int32_t v42; // 0x8052785
                int32_t v43; // 0x80527dd
                int32_t v44; // 0x80528ba
                char v45; // 0x8052709
                char v46; // 0x8052727
                char v47; // 0x805273b
                char v48; // 0x8052809
                int32_t v49; // 0x80528d9
                int32_t v50; // 0x8052882
                uint32_t v51; // 0x80528c9
                int32_t v52; // 0x80526ed
                struct lame_global_struct_2 * v53; // 0x805277a
                struct lame_global_struct_2 * v54; // 0x80527c1
                struct lame_global_struct_2 * v55; // 0x80527d2
                struct lame_global_struct_2 * v56; // 0x80527fb
                struct lame_global_struct_2 * v57; // 0x8052818
                struct lame_global_struct_2 * v58; // 0x8052877
                struct lame_global_struct_2 * v59; // 0x805288f
                struct lame_global_struct_2 * v60; // 0x80528af
                struct lame_global_struct_2 * v61; // 0x80528be
                struct lame_global_struct_2 * v62; // 0x80528ce
                char * v63; // 0x8052908
                int32_t v64; // 0x80526d21004
                int32_t v65;
                char * v66; // 0x8052732
                int32_t v67; // 0x80527b3
                int32_t v68; // 0x80527cc
                int32_t v69; // 0x80527e1
                int32_t v70; // 0x805285c
                if (*(char *)v38 != 45) {
                    // 0x80525d2
                    if (autoconvert == 0) {
                        // 0x8052643
                        if (*inPath != 0) {
                            // 0x8052678
                            if (*outPath != 0) {
                                // 0x80526a6
                                error_printf("%s: excess arg %s\n");
                                // branch -> 0x8052912
                                // 0x8052912
                                return -1;
                            }
                            // 0x8052682
                            strncpy(outPath, (char *)*str, 0x1001);
                            int32_t v71 = input_file; // 0x80526d2
                            int32_t v72 = v71 + 1; // 0x80526d2
                            input_file = v72;
                            if (v72 >= argc) {
                                v37 = v21;
                                // break -> 0x80526e2
                                break;
                            }
                            v22 = v72;
                            v23 = v71;
                            // continue -> 0x8050582
                            continue;
                        }
                        // 0x805264d
                        strncpy(inPath, (char *)*str, 0x1001);
                        v65 = 1;
                        // branch -> 0x80526d2
                      lab_0x80526d2:
                        // 0x80526d2
                        v64 = input_file;
                        v40 = v64 + 1;
                        input_file = v40;
                        if (v40 >= argc) {
                            v37 = v65;
                            // break (via goto) -> 0x80526e2
                            goto lab_0x80526e2_5;
                        }
                        v19 = v40;
                        v20 = v64;
                        v21 = v65;
                        // continue (via goto) -> 0x8050582
                        goto lab_0x8050582_5;
                        // 0x80526e2
                        if (v37 == 0) {
                            // 0x80526e8
                            v41 = g38;
                            v52 = nogap_tags;
                            usage((struct _IO_FILE_4 *)v41, (char *)v52);
                            result = -1;
                            // branch -> 0x8052912
                            // 0x8052912
                            return result;
                        }
                        // 0x8052706
                        v45 = *inPath;
                        if (v45 == 45) {
                            // 0x8052710
                            v33 = silent;
                            v34 = v33;
                            if (v33 < 1) {
                                // if_805271c_0_true
                                v34 = 1;
                                // branch -> after_if_805271c_0
                            }
                            // after_if_805271c_0
                            silent = v34;
                            // branch -> 0x8052724
                        }
                        // 0x8052724
                        v46 = *outPath;
                        v66 = ProgramName;
                        if (v46 == 0 && v66 == NULL) {
                            // 0x8052738
                            v47 = *inPath;
                            if (v47 == 45) {
                                // 0x8052742
                                memcpy(outPath, "-", 2);
                                // branch -> 0x80527b3
                                // 0x80527b3
                                v67 = count_nogap;
                                if (v67 == 0) {
                                    // 0x80527b9
                                    v54 = v17;
                                    lame_set_findReplayGain((int32_t)v54, 1);
                                    // branch -> 0x80527cc
                                }
                                // 0x80527cc
                                v68 = autoconvert;
                                if (v68 != 0) {
                                    // 0x80527d2
                                    v55 = v17;
                                    v25 = (int32_t)v55;
                                    v32 = v25;
                                    lame_get_bWriteVbrTag(v25);
                                    v43 = v32;
                                    v69 = nogap;
                                    if (v43 != 0 && v69 == 0) {
                                        // 0x80527e7
                                        console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
                                        v56 = v17;
                                        lame_set_bWriteVbrTag((int32_t)v56, 0);
                                        // branch -> 0x8052806
                                    }
                                }
                                // 0x8052806
                                v48 = *outPath;
                                if (v48 == 45) {
                                    // 0x8052810
                                    v57 = v17;
                                    lame_set_bWriteVbrTag((int32_t)v57, 0);
                                    // branch -> 0x8052823
                                }
                                // 0x8052823
                                v35 = input_format;
                                v36 = v35;
                                if (v35 == 0) {
                                    // 0x805282c
                                    v31 = filename_to_type(inPath);
                                    input_format = v31;
                                    v36 = v31;
                                    // branch -> 0x805283c
                                }
                                // 0x805283c
                                if (v36 == 8) {
                                    // 0x8052846
                                    error_printf("sorry, vorbis support in LAME is deprecated.\n");
                                    result = -1;
                                    // branch -> 0x8052912
                                    // 0x8052912
                                    return result;
                                }
                                // 0x805285c
                                v70 = i;
                                v58 = v17;
                                v26 = (int32_t)v58;
                                v32 = v26;
                                if (v70 != 0) {
                                    // 0x8052862
                                    lame_set_num_channels(v26, 2);
                                    // branch -> 0x80528af
                                    // 0x80528af
                                    v60 = v17;
                                    v28 = (int32_t)v60;
                                    v32 = v28;
                                    lame_get_free_format(v28);
                                    v44 = v32;
                                    if (v44 == 0) {
                                        // 0x80528ff
                                        if (num_nogap != NULL) {
                                            // 0x8052905
                                            v63 = ProgramName;
                                            *num_nogap = (int32_t)v63;
                                            // branch -> 0x805290d
                                        }
                                        // 0x805290d
                                        result = 0;
                                        // branch -> 0x8052912
                                        // 0x8052912
                                        return result;
                                    }
                                    // 0x80528be
                                    v61 = v17;
                                    v29 = (int32_t)v61;
                                    v32 = v29;
                                    lame_get_brate(v29);
                                    v51 = v32;
                                    if (v51 >= 8) {
                                        // 0x80528ce
                                        v62 = v17;
                                        v30 = (int32_t)v62;
                                        v32 = v30;
                                        lame_get_brate(v30);
                                        v49 = v32;
                                        if (v49 < 641) {
                                            // 0x80528ff
                                            if (num_nogap != NULL) {
                                                // 0x8052905
                                                v63 = ProgramName;
                                                *num_nogap = (int32_t)v63;
                                                // branch -> 0x805290d
                                            }
                                            // 0x805290d
                                            result = 0;
                                            // branch -> 0x8052912
                                            // 0x8052912
                                            return result;
                                        }
                                    }
                                    // 0x80528e0
                                    error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                    error_printf("with the -b <bitrate> option\n");
                                    result = -1;
                                    // branch -> 0x8052912
                                    // 0x8052912
                                    return result;
                                }
                                // 0x8052877
                                lame_get_mode(v26);
                                v50 = v32;
                                v59 = v17;
                                v27 = (int32_t)v59;
                                if (v50 == 3) {
                                    // 0x8052887
                                    lame_set_num_channels(v27, 1);
                                    // branch -> 0x80528af
                                } else {
                                    // 0x805289c
                                    lame_set_num_channels(v27, 2);
                                    // branch -> 0x80528af
                                }
                                // 0x80528af
                                v60 = v17;
                                v28 = (int32_t)v60;
                                v32 = v28;
                                lame_get_free_format(v28);
                                v44 = v32;
                                if (v44 == 0) {
                                    // 0x80528ff
                                    if (num_nogap != NULL) {
                                        // 0x8052905
                                        v63 = ProgramName;
                                        *num_nogap = (int32_t)v63;
                                        // branch -> 0x805290d
                                    }
                                    // 0x805290d
                                    result = 0;
                                    // branch -> 0x8052912
                                    // 0x8052912
                                    return result;
                                }
                                // 0x80528be
                                v61 = v17;
                                v29 = (int32_t)v61;
                                v32 = v29;
                                lame_get_brate(v29);
                                v51 = v32;
                                if (v51 >= 8) {
                                    // 0x80528ce
                                    v62 = v17;
                                    v30 = (int32_t)v62;
                                    v32 = v30;
                                    lame_get_brate(v30);
                                    v49 = v32;
                                    if (v49 < 641) {
                                        // 0x80528ff
                                        if (num_nogap != NULL) {
                                            // 0x8052905
                                            v63 = ProgramName;
                                            *num_nogap = (int32_t)v63;
                                            // branch -> 0x805290d
                                        }
                                        // 0x805290d
                                        result = 0;
                                        // branch -> 0x8052912
                                        // 0x8052912
                                        return result;
                                    }
                                }
                                // 0x80528e0
                                error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                error_printf("with the -b <bitrate> option\n");
                                result = -1;
                                // branch -> 0x8052912
                                // 0x8052912
                                return result;
                            }
                            // 0x8052760
                            strncpy(outPath, inPath, 4093);
                            v53 = v17;
                            v24 = (int32_t)v53;
                            v32 = v24;
                            lame_get_decode_only(v24);
                            v42 = v32;
                            if (v42 == 0) {
                                // 0x805279f
                                strcat(outPath, ".mp3");
                                // branch -> 0x80527b3
                            } else {
                                // 0x8052789
                                strcat(outPath, ".wav");
                                // branch -> 0x80527b3
                            }
                            // 0x80527b3
                            v67 = count_nogap;
                            if (v67 == 0) {
                                // 0x80527b9
                                v54 = v17;
                                lame_set_findReplayGain((int32_t)v54, 1);
                                // branch -> 0x80527cc
                            }
                            // 0x80527cc
                            v68 = autoconvert;
                            if (v68 != 0) {
                                // 0x80527d2
                                v55 = v17;
                                v25 = (int32_t)v55;
                                v32 = v25;
                                lame_get_bWriteVbrTag(v25);
                                v43 = v32;
                                v69 = nogap;
                                if (v43 != 0 && v69 == 0) {
                                    // 0x80527e7
                                    console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
                                    v56 = v17;
                                    lame_set_bWriteVbrTag((int32_t)v56, 0);
                                    // branch -> 0x8052806
                                }
                            }
                            // 0x8052806
                            v48 = *outPath;
                            if (v48 == 45) {
                                // 0x8052810
                                v57 = v17;
                                lame_set_bWriteVbrTag((int32_t)v57, 0);
                                // branch -> 0x8052823
                            }
                            // 0x8052823
                            v35 = input_format;
                            v36 = v35;
                            if (v35 == 0) {
                                // 0x805282c
                                v31 = filename_to_type(inPath);
                                input_format = v31;
                                v36 = v31;
                                // branch -> 0x805283c
                            }
                            // 0x805283c
                            if (v36 == 8) {
                                // 0x8052846
                                error_printf("sorry, vorbis support in LAME is deprecated.\n");
                                result = -1;
                                // branch -> 0x8052912
                                // 0x8052912
                                return result;
                            }
                            // 0x805285c
                            v70 = i;
                            v58 = v17;
                            v26 = (int32_t)v58;
                            v32 = v26;
                            if (v70 != 0) {
                                // 0x8052862
                                lame_set_num_channels(v26, 2);
                                // branch -> 0x80528af
                                // 0x80528af
                                v60 = v17;
                                v28 = (int32_t)v60;
                                v32 = v28;
                                lame_get_free_format(v28);
                                v44 = v32;
                                if (v44 == 0) {
                                    // 0x80528ff
                                    if (num_nogap != NULL) {
                                        // 0x8052905
                                        v63 = ProgramName;
                                        *num_nogap = (int32_t)v63;
                                        // branch -> 0x805290d
                                    }
                                    // 0x805290d
                                    result = 0;
                                    // branch -> 0x8052912
                                    // 0x8052912
                                    return result;
                                }
                                // 0x80528be
                                v61 = v17;
                                v29 = (int32_t)v61;
                                v32 = v29;
                                lame_get_brate(v29);
                                v51 = v32;
                                if (v51 >= 8) {
                                    // 0x80528ce
                                    v62 = v17;
                                    v30 = (int32_t)v62;
                                    v32 = v30;
                                    lame_get_brate(v30);
                                    v49 = v32;
                                    if (v49 < 641) {
                                        // 0x80528ff
                                        if (num_nogap != NULL) {
                                            // 0x8052905
                                            v63 = ProgramName;
                                            *num_nogap = (int32_t)v63;
                                            // branch -> 0x805290d
                                        }
                                        // 0x805290d
                                        result = 0;
                                        // branch -> 0x8052912
                                        // 0x8052912
                                        return result;
                                    }
                                }
                                // 0x80528e0
                                error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                error_printf("with the -b <bitrate> option\n");
                                result = -1;
                                // branch -> 0x8052912
                                // 0x8052912
                                return result;
                            }
                            // 0x8052877
                            lame_get_mode(v26);
                            v50 = v32;
                            v59 = v17;
                            v27 = (int32_t)v59;
                            if (v50 == 3) {
                                // 0x8052887
                                lame_set_num_channels(v27, 1);
                                // branch -> 0x80528af
                            } else {
                                // 0x805289c
                                lame_set_num_channels(v27, 2);
                                // branch -> 0x80528af
                            }
                            // 0x80528af
                            v60 = v17;
                            v28 = (int32_t)v60;
                            v32 = v28;
                            lame_get_free_format(v28);
                            v44 = v32;
                            if (v44 == 0) {
                                // 0x80528ff
                                if (num_nogap != NULL) {
                                    // 0x8052905
                                    v63 = ProgramName;
                                    *num_nogap = (int32_t)v63;
                                    // branch -> 0x805290d
                                }
                                // 0x805290d
                                result = 0;
                                // branch -> 0x8052912
                                // 0x8052912
                                return result;
                            }
                            // 0x80528be
                            v61 = v17;
                            v29 = (int32_t)v61;
                            v32 = v29;
                            lame_get_brate(v29);
                            v51 = v32;
                            if (v51 >= 8) {
                                // 0x80528ce
                                v62 = v17;
                                v30 = (int32_t)v62;
                                v32 = v30;
                                lame_get_brate(v30);
                                v49 = v32;
                                if (v49 < 641) {
                                    // 0x80528ff
                                    if (num_nogap != NULL) {
                                        // 0x8052905
                                        v63 = ProgramName;
                                        *num_nogap = (int32_t)v63;
                                        // branch -> 0x805290d
                                    }
                                    // 0x805290d
                                    result = 0;
                                    // branch -> 0x8052912
                                    // 0x8052912
                                    return result;
                                }
                            }
                            // 0x80528e0
                            error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                            error_printf("with the -b <bitrate> option\n");
                            result = -1;
                            // branch -> 0x8052912
                            // 0x8052912
                            return result;
                        }
                        // 0x80527b3
                        v67 = count_nogap;
                        if (v67 == 0) {
                            // 0x80527b9
                            v54 = v17;
                            lame_set_findReplayGain((int32_t)v54, 1);
                            // branch -> 0x80527cc
                        }
                        // 0x80527cc
                        v68 = autoconvert;
                        if (v68 != 0) {
                            // 0x80527d2
                            v55 = v17;
                            v25 = (int32_t)v55;
                            v32 = v25;
                            lame_get_bWriteVbrTag(v25);
                            v43 = v32;
                            v69 = nogap;
                            if (v43 != 0 && v69 == 0) {
                                // 0x80527e7
                                console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
                                v56 = v17;
                                lame_set_bWriteVbrTag((int32_t)v56, 0);
                                // branch -> 0x8052806
                            }
                        }
                        // 0x8052806
                        v48 = *outPath;
                        if (v48 == 45) {
                            // 0x8052810
                            v57 = v17;
                            lame_set_bWriteVbrTag((int32_t)v57, 0);
                            // branch -> 0x8052823
                        }
                        // 0x8052823
                        v35 = input_format;
                        v36 = v35;
                        if (v35 == 0) {
                            // 0x805282c
                            v31 = filename_to_type(inPath);
                            input_format = v31;
                            v36 = v31;
                            // branch -> 0x805283c
                        }
                        // 0x805283c
                        if (v36 == 8) {
                            // 0x8052846
                            error_printf("sorry, vorbis support in LAME is deprecated.\n");
                            result = -1;
                            // branch -> 0x8052912
                            // 0x8052912
                            return result;
                        }
                        // 0x805285c
                        v70 = i;
                        v58 = v17;
                        v26 = (int32_t)v58;
                        v32 = v26;
                        if (v70 == 0) {
                            // 0x8052877
                            lame_get_mode(v26);
                            v50 = v32;
                            v59 = v17;
                            v27 = (int32_t)v59;
                            if (v50 == 3) {
                                // 0x8052887
                                lame_set_num_channels(v27, 1);
                                // branch -> 0x80528af
                            } else {
                                // 0x805289c
                                lame_set_num_channels(v27, 2);
                                // branch -> 0x80528af
                            }
                            // 0x80528af
                            v60 = v17;
                            v28 = (int32_t)v60;
                            v32 = v28;
                            lame_get_free_format(v28);
                            v44 = v32;
                            if (v44 == 0) {
                                // 0x80528ff
                                if (num_nogap != NULL) {
                                    // 0x8052905
                                    v63 = ProgramName;
                                    *num_nogap = (int32_t)v63;
                                    // branch -> 0x805290d
                                }
                                // 0x805290d
                                result = 0;
                                // branch -> 0x8052912
                                // 0x8052912
                                return result;
                            }
                            // 0x80528be
                            v61 = v17;
                            v29 = (int32_t)v61;
                            v32 = v29;
                            lame_get_brate(v29);
                            v51 = v32;
                            if (v51 >= 8) {
                                // 0x80528ce
                                v62 = v17;
                                v30 = (int32_t)v62;
                                v32 = v30;
                                lame_get_brate(v30);
                                v49 = v32;
                                if (v49 < 641) {
                                    // 0x80528ff
                                    if (num_nogap != NULL) {
                                        // 0x8052905
                                        v63 = ProgramName;
                                        *num_nogap = (int32_t)v63;
                                        // branch -> 0x805290d
                                    }
                                    // 0x805290d
                                    result = 0;
                                    // branch -> 0x8052912
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x80528e0
                            error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                            error_printf("with the -b <bitrate> option\n");
                            result = -1;
                            // branch -> 0x8052912
                            // Detected a possible infinite recursion (goto support failed); quitting...
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x8052862
                            lame_set_num_channels(v26, 2);
                            // branch -> 0x80528af
                        }
                        // 0x80528af
                        v60 = v17;
                        v28 = (int32_t)v60;
                        v32 = v28;
                        lame_get_free_format(v28);
                        v44 = v32;
                        if (v44 == 0) {
                            // 0x80528ff
                            if (num_nogap != NULL) {
                                // 0x8052905
                                v63 = ProgramName;
                                *num_nogap = (int32_t)v63;
                                // branch -> 0x805290d
                            }
                            // 0x805290d
                            result = 0;
                            // branch -> 0x8052912
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x80528be
                            v61 = v17;
                            v29 = (int32_t)v61;
                            v32 = v29;
                            lame_get_brate(v29);
                            v51 = v32;
                            if (v51 >= 8) {
                                // 0x80528ce
                                v62 = v17;
                                v30 = (int32_t)v62;
                                v32 = v30;
                                lame_get_brate(v30);
                                v49 = v32;
                                if (v49 < 641) {
                                    // 0x80528ff
                                    if (num_nogap != NULL) {
                                        // 0x8052905
                                        v63 = ProgramName;
                                        *num_nogap = (int32_t)v63;
                                        // branch -> 0x805290d
                                    }
                                    // 0x805290d
                                    result = 0;
                                    // branch -> 0x8052912
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x80528e0
                            error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                            error_printf("with the -b <bitrate> option\n");
                            result = -1;
                            // branch -> 0x8052912
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                        // Detected a possible infinite recursion (goto support failed); quitting...
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x80525d8
                        if (num_nogap != NULL) {
                            int32_t v73 = (int32_t)ProgramName; // 0x80525e3_0
                            if (*num_nogap > v73) {
                                int32_t str2 = *(int32_t *)(4 * v73 + (int32_t)nogap_inPath); // 0x80525fe
                                ProgramName = (char *)(v73 + 1);
                                strncpy((char *)str2, (char *)*str, 0x1001);
                                v65 = 1;
                                // branch -> 0x80526d2
                                goto lab_0x80526d2;
                            }
                        }
                        // 0x8052624
                        error_printf("Error: 'nogap option'.  Calling program does not allow nogap option, or\nyou have exceeded maximum number of input files for the nogap option\n");
                        *num_nogap = -1;
                        // branch -> 0x8052912
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                  lab_0x80526d2_27:
                    // 0x80526d2
                    v64 = input_file;
                    v40 = v64 + 1;
                    input_file = v40;
                    if (v40 >= argc) {
                        v37 = v65;
                        // break (via goto) -> 0x80526e2
                        goto lab_0x80526e2_5;
                    }
                    v19 = v40;
                    v20 = v64;
                    v21 = v65;
                    // continue (via goto) -> 0x8050582
                    goto lab_0x8050582_5;
                } else {
                    // 0x80505a7
                    nextArg = NULL;
                    int32_t v74 = v23 + 2; // 0x80505b1
                    int32_t v75 = (int32_t)&g9;
                    if (v74 < argc) {
                        // 0x80505b9
                        v75 = *(int32_t *)(4 * v74 + v18);
                        // branch -> 0x80505ce
                    }
                    // 0x80505ce
                    arg = (char *)v75;
                    int32_t v76 = v21; // 0x80526e2406
                    char * v77;
                    int32_t v78; // 0x805063c
                    if (*(char *)v39 == 0) {
                        // 0x80505db
                        if (*inPath == 0) {
                            // 0x80505ec
                            strncpy(inPath, (char *)*str, 0x1001);
                            v76 = 1;
                            // branch -> 0x805063c
                        } else {
                            // 0x8050610
                            if (*outPath == 0) {
                                // 0x805061a
                                strncpy(outPath, (char *)*str, 0x1001);
                                v76 = 1;
                                // branch -> 0x805063c
                            } else {
                                v76 = 1;
                            }
                        }
                        // 0x805063c
                        v78 = id3tag_mode;
                        v77 = (char *)v78;
                        if (*v77 == 45) {
                          lab_0x805064a:;
                            int32_t v79 = v78 + 1; // 0x805064a
                            id3tag_mode = v79;
                            if (local_strcasecmp((char *)v79, "resample") == 0) {
                                // 0x8050665
                                nextArg = (char *)1;
                                atof(arg);
                                lame_set_out_samplerate((int32_t)v17, resample_rate((float64_t)g59));
                                // branch -> 0x805203c
                            } else {
                                // 0x8050693
                                if (local_strcasecmp((char *)id3tag_mode, "vbr-old") == 0) {
                                    // 0x80506aa
                                    lame_set_VBR((int32_t)v17, 2);
                                    // branch -> 0x805203c
                                } else {
                                    // 0x80506c2
                                    if (local_strcasecmp((char *)id3tag_mode, "vbr-new") == 0) {
                                        // 0x80506d9
                                        lame_set_VBR((int32_t)v17, 4);
                                        // branch -> 0x805203c
                                    } else {
                                        // 0x80506f1
                                        if (local_strcasecmp((char *)id3tag_mode, "vbr-mtrh") == 0) {
                                            // 0x8050708
                                            lame_set_VBR((int32_t)v17, 4);
                                            // branch -> 0x805203c
                                        } else {
                                            // 0x8050720
                                            if (local_strcasecmp((char *)id3tag_mode, "cbr") == 0) {
                                                // 0x8050737
                                                lame_set_VBR((int32_t)v17, 0);
                                                // branch -> 0x805203c
                                            } else {
                                                // 0x805074f
                                                if (local_strcasecmp((char *)id3tag_mode, "abr") == 0) {
                                                    // 0x805076a
                                                    nextArg = (char *)1;
                                                    lame_set_VBR((int32_t)v17, 3);
                                                    lame_set_VBR_mean_bitrate_kbps((int32_t)v17, atoi(arg));
                                                    int32_t v80 = (int32_t)v17; // 0x805079e_0
                                                    lame_get_VBR_mean_bitrate_kbps(v80);
                                                    if (v80 >= 0x1f40) {
                                                        int32_t v81 = (int32_t)v17; // 0x80507b0_0
                                                        lame_get_VBR_mean_bitrate_kbps(v81);
                                                        lame_set_VBR_mean_bitrate_kbps((int32_t)v17, (v81 + 500) / 1000);
                                                        // branch -> 0x80507e7
                                                    }
                                                    int32_t v82 = (int32_t)v17; // 0x80507e7_0
                                                    lame_get_VBR_mean_bitrate_kbps(v82);
                                                    int32_t v83; // 0x805080b
                                                    if (v82 > 319) {
                                                        // 0x8050806
                                                        v83 = 320;
                                                        // branch -> 0x805080b
                                                    } else {
                                                        int32_t v84 = (int32_t)v17; // 0x80507f9_0
                                                        lame_get_VBR_mean_bitrate_kbps(v84);
                                                        v83 = v84;
                                                        // branch -> 0x805080b
                                                    }
                                                    // 0x805080b
                                                    lame_set_VBR_mean_bitrate_kbps((int32_t)v17, v83);
                                                    int32_t v85 = (int32_t)v17; // 0x805081a_0
                                                    lame_get_VBR_mean_bitrate_kbps(v85);
                                                    int32_t v86; // 0x805083c
                                                    if (v85 < 9) {
                                                        // 0x8050837
                                                        v86 = 8;
                                                        // branch -> 0x805083c
                                                    } else {
                                                        int32_t v87 = (int32_t)v17; // 0x805082a_0
                                                        lame_get_VBR_mean_bitrate_kbps(v87);
                                                        v86 = v87;
                                                        // branch -> 0x805083c
                                                    }
                                                    // 0x805083c
                                                    lame_set_VBR_mean_bitrate_kbps((int32_t)v17, v86);
                                                    // branch -> 0x805203c
                                                } else {
                                                    // 0x8050850
                                                    if (local_strcasecmp((char *)id3tag_mode, "r3mix") == 0) {
                                                        // 0x8050867
                                                        lame_set_preset((int32_t)v17, 1000);
                                                        // branch -> 0x805203c
                                                    } else {
                                                        // 0x805087f
                                                        if (local_strcasecmp((char *)id3tag_mode, "bitwidth") == 0) {
                                                            // 0x8050896
                                                            nextArg = (char *)1;
                                                            in_bitwidth = atoi(arg);
                                                            // branch -> 0x805203c
                                                        } else {
                                                            // 0x80508b2
                                                            if (local_strcasecmp((char *)id3tag_mode, "signed") == 0) {
                                                                // 0x80508c9
                                                                in_signed = 1;
                                                                // branch -> 0x805203c
                                                            } else {
                                                                // 0x80508d8
                                                                if (local_strcasecmp((char *)id3tag_mode, "unsigned") == 0) {
                                                                    // 0x80508ef
                                                                    in_signed = 0;
                                                                    // branch -> 0x805203c
                                                                } else {
                                                                    // 0x80508fe
                                                                    if (local_strcasecmp((char *)id3tag_mode, "little-endian") == 0) {
                                                                        // 0x8050915
                                                                        in_endian = 0;
                                                                        // branch -> 0x805203c
                                                                    } else {
                                                                        // 0x8050924
                                                                        if (local_strcasecmp((char *)id3tag_mode, "big-endian") == 0) {
                                                                            // 0x805093b
                                                                            in_endian = 1;
                                                                            // branch -> 0x805203c
                                                                        } else {
                                                                            // 0x805094a
                                                                            if (local_strcasecmp((char *)id3tag_mode, "mp1input") == 0) {
                                                                                // 0x8050961
                                                                                input_format = 4;
                                                                                // branch -> 0x805203c
                                                                            } else {
                                                                                // 0x8050970
                                                                                if (local_strcasecmp((char *)id3tag_mode, "mp2input") == 0) {
                                                                                    // 0x8050987
                                                                                    input_format = 5;
                                                                                    // branch -> 0x805203c
                                                                                } else {
                                                                                    // 0x8050996
                                                                                    if (local_strcasecmp((char *)id3tag_mode, "mp3input") == 0) {
                                                                                        // 0x80509ad
                                                                                        input_format = 6;
                                                                                        // branch -> 0x805203c
                                                                                      lab_0x805203c_27:
                                                                                        // 0x805203c
                                                                                        input_file += (int32_t)nextArg;
                                                                                        v65 = v76;
                                                                                        // branch -> 0x80526d2
                                                                                        goto lab_0x80526d2_27;
                                                                                    } else {
                                                                                        // 0x80509bc
                                                                                        if (local_strcasecmp((char *)id3tag_mode, "ogginput") == 0) {
                                                                                            // 0x80509d3
                                                                                            error_printf("sorry, vorbis support in LAME is deprecated.\n");
                                                                                            // branch -> 0x8052912
                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                        } else {
                                                                                            // 0x80509e9
                                                                                            if (local_strcasecmp((char *)id3tag_mode, "phone") == 0) {
                                                                                                // 0x8050a00
                                                                                                if (presets_set(v17, 0, 0, (char *)id3tag_mode, (char *)nogap_tags) > 0) {
                                                                                                    // 0x8050a37
                                                                                                    error_printf("Warning: --phone is deprecated, use --preset phone instead!");
                                                                                                    // branch -> 0x805203c
                                                                                                    goto lab_0x805203c_27;
                                                                                                }
                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                            } else {
                                                                                                // 0x8050a48
                                                                                                if (local_strcasecmp((char *)id3tag_mode, "voice") == 0) {
                                                                                                    // 0x8050a5f
                                                                                                    if (presets_set(v17, 0, 0, (char *)id3tag_mode, (char *)nogap_tags) > 0) {
                                                                                                        // 0x8050a96
                                                                                                        error_printf("Warning: --voice is deprecated, use --preset voice instead!");
                                                                                                        // branch -> 0x805203c
                                                                                                        goto lab_0x805203c_27;
                                                                                                    }
                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                } else {
                                                                                                    // 0x8050aa7
                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "decode") == 0) {
                                                                                                        // 0x8050abe
                                                                                                        lame_set_decode_only((int32_t)v17, 1);
                                                                                                        // branch -> 0x805203c
                                                                                                        goto lab_0x805203c_27;
                                                                                                    } else {
                                                                                                        // 0x8050ad6
                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "flush") == 0) {
                                                                                                            // 0x8050aed
                                                                                                            flush_write = 1;
                                                                                                            // branch -> 0x805203c
                                                                                                            goto lab_0x805203c_27;
                                                                                                        } else {
                                                                                                            // 0x8050afc
                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "decode-mp3delay") == 0) {
                                                                                                                // 0x8050b13
                                                                                                                mp3_delay = atoi(arg);
                                                                                                                mp3_delay_set = 1;
                                                                                                                nextArg = (char *)1;
                                                                                                                // branch -> 0x805203c
                                                                                                                goto lab_0x805203c_27;
                                                                                                            } else {
                                                                                                                // 0x8050b39
                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "nores") == 0) {
                                                                                                                    // 0x8050b50
                                                                                                                    lame_set_disable_reservoir((int32_t)v17, 1);
                                                                                                                    // branch -> 0x805203c
                                                                                                                    goto lab_0x805203c_27;
                                                                                                                } else {
                                                                                                                    // 0x8050b68
                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "strictly-enforce-ISO") == 0) {
                                                                                                                        // 0x8050b7f
                                                                                                                        lame_set_strict_ISO((int32_t)v17, 1);
                                                                                                                        // branch -> 0x805203c
                                                                                                                        goto lab_0x805203c_27;
                                                                                                                    } else {
                                                                                                                        // 0x8050b97
                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "scale") == 0) {
                                                                                                                            // 0x8050bae
                                                                                                                            nextArg = (char *)1;
                                                                                                                            lame_set_scale((int32_t)v17, (int32_t)(float32_t)atof(arg));
                                                                                                                            // branch -> 0x805203c
                                                                                                                            goto lab_0x805203c_27;
                                                                                                                        } else {
                                                                                                                            // 0x8050be0
                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "scale-l") == 0) {
                                                                                                                                // 0x8050bf7
                                                                                                                                nextArg = (char *)1;
                                                                                                                                atof(arg);
                                                                                                                                float80_t v88 = g53; // 0x8050c09
                                                                                                                                g53 = v88;
                                                                                                                                lame_set_scale_left((int32_t)v17, (int32_t)(float32_t)v88);
                                                                                                                                // branch -> 0x805203c
                                                                                                                                goto lab_0x805203c_27;
                                                                                                                            } else {
                                                                                                                                // 0x8050c29
                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "scale-r") == 0) {
                                                                                                                                    // 0x8050c40
                                                                                                                                    nextArg = (char *)1;
                                                                                                                                    atof(arg);
                                                                                                                                    float80_t v89 = g54; // 0x8050c52
                                                                                                                                    g54 = v89;
                                                                                                                                    lame_set_scale_right((int32_t)v17, (int32_t)(float32_t)v89);
                                                                                                                                    // branch -> 0x805203c
                                                                                                                                    goto lab_0x805203c_27;
                                                                                                                                } else {
                                                                                                                                    // 0x8050c72
                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "noasm") == 0) {
                                                                                                                                        // 0x8050c8d
                                                                                                                                        nextArg = (char *)1;
                                                                                                                                        if (strcmp(arg, "mmx") == 0) {
                                                                                                                                            // 0x8050cab
                                                                                                                                            lame_set_asm_optimizations((int32_t)v17, 1, 0);
                                                                                                                                            // branch -> 0x8050cc6
                                                                                                                                        }
                                                                                                                                        // 0x8050cc6
                                                                                                                                        if (strcmp(arg, "3dnow") == 0) {
                                                                                                                                            // 0x8050cdd
                                                                                                                                            lame_set_asm_optimizations((int32_t)v17, 2, 0);
                                                                                                                                            // branch -> 0x8050cf8
                                                                                                                                        }
                                                                                                                                        // 0x8050cf8
                                                                                                                                        if (strcmp(arg, "sse") != 0) {
                                                                                                                                            goto lab_0x805203c_27;
                                                                                                                                        }
                                                                                                                                        // 0x8050d13
                                                                                                                                        lame_set_asm_optimizations((int32_t)v17, 3, 0);
                                                                                                                                        // branch -> 0x805203c
                                                                                                                                        goto lab_0x805203c_27;
                                                                                                                                    } else {
                                                                                                                                        // 0x8050d33
                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "freeformat") == 0) {
                                                                                                                                            // 0x8050d4a
                                                                                                                                            lame_set_free_format((int32_t)v17, 1);
                                                                                                                                            // branch -> 0x805203c
                                                                                                                                            goto lab_0x805203c_27;
                                                                                                                                        } else {
                                                                                                                                            // 0x8050d62
                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "replaygain-fast") == 0) {
                                                                                                                                                // 0x8050d79
                                                                                                                                                lame_set_findReplayGain((int32_t)v17, 1);
                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                goto lab_0x805203c_27;
                                                                                                                                            } else {
                                                                                                                                                // 0x8050d91
                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "replaygain-accurate") == 0) {
                                                                                                                                                    // 0x8050da8
                                                                                                                                                    lame_set_decode_on_the_fly((int32_t)v17, 1);
                                                                                                                                                    lame_set_findReplayGain((int32_t)v17, 1);
                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                    goto lab_0x805203c_27;
                                                                                                                                                } else {
                                                                                                                                                    // 0x8050dd3
                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "noreplaygain") == 0) {
                                                                                                                                                        // 0x8050dea
                                                                                                                                                        count_nogap = 1;
                                                                                                                                                        lame_set_findReplayGain((int32_t)v17, 0);
                                                                                                                                                        // branch -> 0x805203c
                                                                                                                                                        goto lab_0x805203c_27;
                                                                                                                                                    } else {
                                                                                                                                                        // 0x8050e09
                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "clipdetect") == 0) {
                                                                                                                                                            // 0x8050e20
                                                                                                                                                            print_clipping_info = 1;
                                                                                                                                                            lame_set_decode_on_the_fly((int32_t)v17, 1);
                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                            goto lab_0x805203c_27;
                                                                                                                                                        } else {
                                                                                                                                                            // 0x8050e42
                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "nohist") == 0) {
                                                                                                                                                                // 0x8050e59
                                                                                                                                                                g44 = 0;
                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                goto lab_0x805203c_27;
                                                                                                                                                            } else {
                                                                                                                                                                // 0x8050e68
                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "tt") == 0) {
                                                                                                                                                                    // 0x8050e7f
                                                                                                                                                                    nextArg = (char *)1;
                                                                                                                                                                    id3_tag(v17, 116, 0, arg);
                                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                                    goto lab_0x805203c_27;
                                                                                                                                                                } else {
                                                                                                                                                                    // 0x8050ead
                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "ta") == 0) {
                                                                                                                                                                        // 0x8050ec4
                                                                                                                                                                        nextArg = (char *)1;
                                                                                                                                                                        id3_tag(v17, 97, 0, arg);
                                                                                                                                                                        // branch -> 0x805203c
                                                                                                                                                                        goto lab_0x805203c_27;
                                                                                                                                                                    } else {
                                                                                                                                                                        // 0x8050ef2
                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "tl") == 0) {
                                                                                                                                                                            // 0x8050f09
                                                                                                                                                                            nextArg = (char *)1;
                                                                                                                                                                            id3_tag(v17, 108, 0, arg);
                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                            goto lab_0x805203c_27;
                                                                                                                                                                        } else {
                                                                                                                                                                            // 0x8050f37
                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "ty") == 0) {
                                                                                                                                                                                // 0x8050f4e
                                                                                                                                                                                nextArg = (char *)1;
                                                                                                                                                                                id3_tag(v17, 121, 0, arg);
                                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                                goto lab_0x805203c_27;
                                                                                                                                                                            } else {
                                                                                                                                                                                // 0x8050f7c
                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "tc") == 0) {
                                                                                                                                                                                    // 0x8050f93
                                                                                                                                                                                    nextArg = (char *)1;
                                                                                                                                                                                    id3_tag(v17, 99, 0, arg);
                                                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                                                    goto lab_0x805203c_27;
                                                                                                                                                                                } else {
                                                                                                                                                                                    // 0x8050fc1
                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "tn") == 0) {
                                                                                                                                                                                        // 0x8050fdc
                                                                                                                                                                                        nextArg = (char *)1;
                                                                                                                                                                                        if (id3_tag(v17, 110, 0, arg) == 0) {
                                                                                                                                                                                            goto lab_0x805203c_27;
                                                                                                                                                                                        }
                                                                                                                                                                                        // 0x8051012
                                                                                                                                                                                        if (ignore_tag_errors != 0) {
                                                                                                                                                                                            goto lab_0x805203c_27;
                                                                                                                                                                                        }
                                                                                                                                                                                        // 0x805101f
                                                                                                                                                                                        switch (noreplaygain) {
                                                                                                                                                                                            default: {
                                                                                                                                                                                                // 0x8051045
                                                                                                                                                                                                if (silent > 9) {
                                                                                                                                                                                                    goto lab_0x805203c_27;
                                                                                                                                                                                                }
                                                                                                                                                                                                // 0x8051053
                                                                                                                                                                                                error_printf("The track number has to be between 1 and 255 for ID3v1, ignored for ID3v1.\n");
                                                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                                                goto lab_0x805203c_27;
                                                                                                                                                                                                break;
                                                                                                                                                                                            }
                                                                                                                                                                                            case 1: {
                                                                                                                                                                                                // 0x8051025
                                                                                                                                                                                                error_printf("The track number has to be between 1 and 255 for ID3v1.\n");
                                                                                                                                                                                                // branch -> 0x8052912
                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                break;
                                                                                                                                                                                            }
                                                                                                                                                                                            case 2: {
                                                                                                                                                                                              lab_0x805203c_31:
                                                                                                                                                                                                // 0x805203c
                                                                                                                                                                                                input_file += (int32_t)nextArg;
                                                                                                                                                                                                v65 = v76;
                                                                                                                                                                                                // branch -> 0x80526d2
                                                                                                                                                                                                goto lab_0x80526d2_27;
                                                                                                                                                                                                break;
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                    } else {
                                                                                                                                                                                        // 0x8051064
                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "tg") == 0) {
                                                                                                                                                                                            int32_t v90 = id3_tag(v17, 103, 0, arg); // 0x805109c
                                                                                                                                                                                            nextArg = (char *)1;
                                                                                                                                                                                            if (v90 == 0) {
                                                                                                                                                                                                goto lab_0x805203c_31;
                                                                                                                                                                                            }
                                                                                                                                                                                            // 0x80510b5
                                                                                                                                                                                            if (ignore_tag_errors != 0) {
                                                                                                                                                                                                goto lab_0x805203c_31;
                                                                                                                                                                                            }
                                                                                                                                                                                            // 0x80510c2
                                                                                                                                                                                            switch (v90) {
                                                                                                                                                                                                default: {
                                                                                                                                                                                                    // 0x805113e
                                                                                                                                                                                                    error_printf("Internal error.\n");
                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                    break;
                                                                                                                                                                                                }
                                                                                                                                                                                                case -1: {
                                                                                                                                                                                                    // 0x80510c8
                                                                                                                                                                                                    error_printf("Unknown ID3v1 genre number: '%s'.\n");
                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                    break;
                                                                                                                                                                                                }
                                                                                                                                                                                                case -2: {
                                                                                                                                                                                                    // 0x80510eb
                                                                                                                                                                                                    switch (noreplaygain) {
                                                                                                                                                                                                        default: {
                                                                                                                                                                                                            // 0x8051118
                                                                                                                                                                                                            if (silent > 9) {
                                                                                                                                                                                                                goto lab_0x805203c_31;
                                                                                                                                                                                                            }
                                                                                                                                                                                                            // 0x8051126
                                                                                                                                                                                                            error_printf("Unknown ID3v1 genre: '%s'.  Setting ID3v1 genre to 'Other'\n");
                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                            goto lab_0x805203c_31;
                                                                                                                                                                                                            break;
                                                                                                                                                                                                        }
                                                                                                                                                                                                        case 1: {
                                                                                                                                                                                                            // 0x80510f1
                                                                                                                                                                                                            error_printf("Unknown ID3v1 genre: '%s'.\n");
                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                            break;
                                                                                                                                                                                                        }
                                                                                                                                                                                                        case 2: {
                                                                                                                                                                                                          lab_0x805203c_68:
                                                                                                                                                                                                            // 0x805203c
                                                                                                                                                                                                            input_file += (int32_t)nextArg;
                                                                                                                                                                                                            v65 = v76;
                                                                                                                                                                                                            // branch -> 0x80526d2
                                                                                                                                                                                                            goto lab_0x80526d2_27;
                                                                                                                                                                                                            break;
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                    break;
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                        } else {
                                                                                                                                                                                            // 0x8051154
                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "tv") == 0) {
                                                                                                                                                                                                // 0x805116b
                                                                                                                                                                                                nextArg = (char *)1;
                                                                                                                                                                                                if (id3_tag(v17, 118, 0, arg) == 0) {
                                                                                                                                                                                                    goto lab_0x805203c_68;
                                                                                                                                                                                                }
                                                                                                                                                                                                // 0x805119c
                                                                                                                                                                                                if (silent > 9) {
                                                                                                                                                                                                    goto lab_0x805203c_68;
                                                                                                                                                                                                }
                                                                                                                                                                                                // 0x80511aa
                                                                                                                                                                                                error_printf("Invalid field value: '%s'. Ignored\n");
                                                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                                                goto lab_0x805203c_68;
                                                                                                                                                                                            } else {
                                                                                                                                                                                                // 0x80511c2
                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "ti") == 0) {
                                                                                                                                                                                                    // 0x80511d9
                                                                                                                                                                                                    nextArg = (char *)1;
                                                                                                                                                                                                    if (set_id3_albumart(v17, arg) == 0) {
                                                                                                                                                                                                        goto lab_0x805203c_68;
                                                                                                                                                                                                    }
                                                                                                                                                                                                    // 0x80511fa
                                                                                                                                                                                                    if (ignore_tag_errors != 0) {
                                                                                                                                                                                                        goto lab_0x805203c_68;
                                                                                                                                                                                                    }
                                                                                                                                                                                                    // 0x8051207
                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                } else {
                                                                                                                                                                                                    // 0x8051211
                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "ignore-tag-errors") == 0) {
                                                                                                                                                                                                        // 0x8051228
                                                                                                                                                                                                        ignore_tag_errors = 1;
                                                                                                                                                                                                        // branch -> 0x805203c
                                                                                                                                                                                                        goto lab_0x805203c_68;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        // 0x8051237
                                                                                                                                                                                                        char * v91; // 0x805203c
                                                                                                                                                                                                        int32_t v92; // 0x805203f
                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "add-id3v2") == 0) {
                                                                                                                                                                                                            // 0x805124e
                                                                                                                                                                                                            id3tag_add_v2((int32_t)v17);
                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                        } else {
                                                                                                                                                                                                            // 0x805125e
                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "id3v1-only") == 0) {
                                                                                                                                                                                                                // 0x8051275
                                                                                                                                                                                                                id3tag_v1_only((int32_t)v17);
                                                                                                                                                                                                                noreplaygain = 1;
                                                                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                                                                goto lab_0x805203c_68;
                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                // 0x805128c
                                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "id3v2-only") == 0) {
                                                                                                                                                                                                                    // 0x80512a3
                                                                                                                                                                                                                    id3tag_v2_only((int32_t)v17);
                                                                                                                                                                                                                    noreplaygain = 2;
                                                                                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                                                                                    goto lab_0x805203c_68;
                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                    // 0x80512ba
                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "space-id3v1") == 0) {
                                                                                                                                                                                                                        // 0x80512d1
                                                                                                                                                                                                                        id3tag_space_v1((int32_t)v17);
                                                                                                                                                                                                                        // branch -> 0x805203c
                                                                                                                                                                                                                        goto lab_0x805203c_68;
                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                        // 0x80512e1
                                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "pad-id3v2") == 0) {
                                                                                                                                                                                                                            // 0x80512f8
                                                                                                                                                                                                                            id3tag_pad_v2((int32_t)v17);
                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                            // 0x8051308
                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "pad-id3v2-size") == 0) {
                                                                                                                                                                                                                                int32_t str_as_i = atoi(arg); // 0x8051325
                                                                                                                                                                                                                                int32_t v93 = str_as_i > 0x1f400 ? 0x1f400 : str_as_i;
                                                                                                                                                                                                                                id3tag_set_pad((int32_t)v17, v93 > 0 ? v93 : 0);
                                                                                                                                                                                                                                nextArg = (char *)1;
                                                                                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                                                                                goto lab_0x805203c_68;
                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                // 0x805136e
                                                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "genre-list") == 0) {
                                                                                                                                                                                                                                    // 0x8051385
                                                                                                                                                                                                                                    id3tag_genre_list((int32_t)genre_list_handler, 0);
                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                    // 0x80513a3
                                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "lowpass") == 0) {
                                                                                                                                                                                                                                        char * str3 = arg; // 0x80513be
                                                                                                                                                                                                                                        atof(str3);
                                                                                                                                                                                                                                        float80_t v94 = g55; // 0x80513c9
                                                                                                                                                                                                                                        float64_t v95 = v94;
                                                                                                                                                                                                                                        nextArg = (char *)1;
                                                                                                                                                                                                                                        g55 = v94;
                                                                                                                                                                                                                                        g54 = 0.0L;
                                                                                                                                                                                                                                        bool v96 = false;
                                                                                                                                                                                                                                        bool v97 = false; // 0x80513e2
                                                                                                                                                                                                                                        if (v95 >= 0.0) {
                                                                                                                                                                                                                                            // if_80513de_0_false
                                                                                                                                                                                                                                            if (v95 <= 0.0) {
                                                                                                                                                                                                                                                // if_80513de_1_false
                                                                                                                                                                                                                                                v96 = v95 != 0.0;
                                                                                                                                                                                                                                                v97 = true;
                                                                                                                                                                                                                                                // branch -> after_if_80513de_0
                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                v96 = true;
                                                                                                                                                                                                                                                v97 = false;
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                        int32_t v98 = (int32_t)str3 & -256;
                                                                                                                                                                                                                                        if (((int32_t)(v97 || v96) || v98) == 1) {
                                                                                                                                                                                                                                            bool v99 = false;
                                                                                                                                                                                                                                            bool v100 = false; // 0x8051411
                                                                                                                                                                                                                                            if (v95 >= 0.001) {
                                                                                                                                                                                                                                                // if_805140d_0_false
                                                                                                                                                                                                                                                if (v95 <= 0.001) {
                                                                                                                                                                                                                                                    // if_805140d_1_false
                                                                                                                                                                                                                                                    v99 = v95 != 0.001;
                                                                                                                                                                                                                                                    v100 = true;
                                                                                                                                                                                                                                                    // branch -> after_if_805140d_0
                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                    v99 = true;
                                                                                                                                                                                                                                                    v100 = false;
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                            // after_if_805140d_0
                                                                                                                                                                                                                                            if (((int32_t)(v100 || v99) || v98) == 1) {
                                                                                                                                                                                                                                                bool v101 = false;
                                                                                                                                                                                                                                                bool v102 = false; // 0x805142a
                                                                                                                                                                                                                                                if (v95 <= 5.0e+4) {
                                                                                                                                                                                                                                                    // if_8051426_0_false
                                                                                                                                                                                                                                                    if (v95 >= 5.0e+4) {
                                                                                                                                                                                                                                                        // if_8051426_1_false
                                                                                                                                                                                                                                                        v101 = v95 != 5.0e+4;
                                                                                                                                                                                                                                                        v102 = true;
                                                                                                                                                                                                                                                        // branch -> after_if_8051426_0
                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                        v101 = true;
                                                                                                                                                                                                                                                        v102 = false;
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                // after_if_8051426_0
                                                                                                                                                                                                                                                if (((int32_t)(v102 || v101) || v98) == 1) {
                                                                                                                                                                                                                                                    // 0x8051447
                                                                                                                                                                                                                                                    g55 = v94;
                                                                                                                                                                                                                                                    bool v103 = false;
                                                                                                                                                                                                                                                    bool v104 = false; // 0x8051457
                                                                                                                                                                                                                                                    if (v95 >= 50.0) {
                                                                                                                                                                                                                                                        // if_8051453_0_false
                                                                                                                                                                                                                                                        if (v95 <= 50.0) {
                                                                                                                                                                                                                                                            // if_8051453_1_false
                                                                                                                                                                                                                                                            v103 = v95 != 50.0;
                                                                                                                                                                                                                                                            v104 = true;
                                                                                                                                                                                                                                                            // branch -> after_if_8051453_0
                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                            v103 = true;
                                                                                                                                                                                                                                                            v104 = false;
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    // after_if_8051453_0
                                                                                                                                                                                                                                                    float80_t v105; // 0x8051468
                                                                                                                                                                                                                                                    if (((int32_t)(v104 || v103) || v98) == 1) {
                                                                                                                                                                                                                                                        // 0x8051466
                                                                                                                                                                                                                                                        v105 = 1.0L;
                                                                                                                                                                                                                                                        // branch -> 0x8051468
                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                        // 0x805145e
                                                                                                                                                                                                                                                        g55 = 1000.0L;
                                                                                                                                                                                                                                                        v105 = 50.0L;
                                                                                                                                                                                                                                                        // branch -> 0x8051468
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    // 0x8051468
                                                                                                                                                                                                                                                    g53 = 0.5L;
                                                                                                                                                                                                                                                    float80_t v106 = v94 * v105 + 0.5L; // 0x8051474
                                                                                                                                                                                                                                                    g54 = v106;
                                                                                                                                                                                                                                                    lame_set_lowpassfreq((int32_t)v17, (int32_t)v106);
                                                                                                                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                                                                                                                    goto lab_0x805203c_68;
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                            // 0x8051431
                                                                                                                                                                                                                                            error_printf("Must specify lowpass with --lowpass freq, freq >= 0.001 kHz\n");
                                                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                            // 0x80513e9
                                                                                                                                                                                                                                            lame_set_lowpassfreq((int32_t)v17, -1);
                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                        // 0x80514b8
                                                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "lowpass-width") == 0) {
                                                                                                                                                                                                                                            char * str4 = arg; // 0x80514d3
                                                                                                                                                                                                                                            atof(str4);
                                                                                                                                                                                                                                            float80_t v107 = g55; // 0x80514de
                                                                                                                                                                                                                                            float64_t v108 = v107;
                                                                                                                                                                                                                                            nextArg = (char *)1;
                                                                                                                                                                                                                                            bool v109 = false;
                                                                                                                                                                                                                                            bool v110 = false; // 0x80514fb
                                                                                                                                                                                                                                            if (v108 >= 0.001) {
                                                                                                                                                                                                                                                // if_80514f7_0_false
                                                                                                                                                                                                                                                if (v108 <= 0.001) {
                                                                                                                                                                                                                                                    // if_80514f7_1_false
                                                                                                                                                                                                                                                    v109 = v108 != 0.001;
                                                                                                                                                                                                                                                    v110 = true;
                                                                                                                                                                                                                                                    // branch -> after_if_80514f7_0
                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                    v109 = true;
                                                                                                                                                                                                                                                    v110 = false;
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                            int32_t v111 = (int32_t)str4 & -256;
                                                                                                                                                                                                                                            if (((int32_t)(v110 || v109) || v111) == 1) {
                                                                                                                                                                                                                                                bool v112 = false;
                                                                                                                                                                                                                                                bool v113 = false; // 0x8051514
                                                                                                                                                                                                                                                if (v108 <= 5.0e+4) {
                                                                                                                                                                                                                                                    // if_8051510_0_false
                                                                                                                                                                                                                                                    if (v108 >= 5.0e+4) {
                                                                                                                                                                                                                                                        // if_8051510_1_false
                                                                                                                                                                                                                                                        v112 = v108 != 5.0e+4;
                                                                                                                                                                                                                                                        v113 = true;
                                                                                                                                                                                                                                                        // branch -> after_if_8051510_0
                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                        v112 = true;
                                                                                                                                                                                                                                                        v113 = false;
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                // after_if_8051510_0
                                                                                                                                                                                                                                                if (((int32_t)(v113 || v112) || v111) == 1) {
                                                                                                                                                                                                                                                    // 0x8051531
                                                                                                                                                                                                                                                    g55 = v107;
                                                                                                                                                                                                                                                    bool v114 = false;
                                                                                                                                                                                                                                                    bool v115 = false; // 0x8051541
                                                                                                                                                                                                                                                    if (v108 >= 16.0) {
                                                                                                                                                                                                                                                        // if_805153d_0_false
                                                                                                                                                                                                                                                        if (v108 <= 16.0) {
                                                                                                                                                                                                                                                            // if_805153d_1_false
                                                                                                                                                                                                                                                            v114 = v108 != 16.0;
                                                                                                                                                                                                                                                            v115 = true;
                                                                                                                                                                                                                                                            // branch -> after_if_805153d_0
                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                            v114 = true;
                                                                                                                                                                                                                                                            v115 = false;
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    // after_if_805153d_0
                                                                                                                                                                                                                                                    float80_t v116; // 0x8051552
                                                                                                                                                                                                                                                    if (((int32_t)(v115 || v114) || v111) == 1) {
                                                                                                                                                                                                                                                        // 0x8051550
                                                                                                                                                                                                                                                        v116 = 1.0L;
                                                                                                                                                                                                                                                        // branch -> 0x8051552
                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                        // 0x8051548
                                                                                                                                                                                                                                                        g55 = 1000.0L;
                                                                                                                                                                                                                                                        v116 = 16.0L;
                                                                                                                                                                                                                                                        // branch -> 0x8051552
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    // 0x8051552
                                                                                                                                                                                                                                                    g53 = 0.5L;
                                                                                                                                                                                                                                                    float80_t v117 = v107 * v116 + 0.5L; // 0x805155e
                                                                                                                                                                                                                                                    g54 = v117;
                                                                                                                                                                                                                                                    lame_set_lowpasswidth((int32_t)v17, (int32_t)v117);
                                                                                                                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                                                                                                                    goto lab_0x805203c_68;
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                            // 0x805151b
                                                                                                                                                                                                                                            error_printf("Must specify lowpass width with --lowpass-width freq, freq >= 0.001 kHz\n");
                                                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                            // 0x80515a2
                                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "highpass") == 0) {
                                                                                                                                                                                                                                                char * str5 = arg; // 0x80515bd
                                                                                                                                                                                                                                                atof(str5);
                                                                                                                                                                                                                                                float80_t v118 = g55; // 0x80515c8
                                                                                                                                                                                                                                                float64_t v119 = v118;
                                                                                                                                                                                                                                                nextArg = (char *)1;
                                                                                                                                                                                                                                                g55 = v118;
                                                                                                                                                                                                                                                g54 = 0.0L;
                                                                                                                                                                                                                                                bool v120 = false;
                                                                                                                                                                                                                                                bool v121 = false; // 0x80515e1
                                                                                                                                                                                                                                                if (v119 >= 0.0) {
                                                                                                                                                                                                                                                    // if_80515dd_0_false
                                                                                                                                                                                                                                                    if (v119 <= 0.0) {
                                                                                                                                                                                                                                                        // if_80515dd_1_false
                                                                                                                                                                                                                                                        v120 = v119 != 0.0;
                                                                                                                                                                                                                                                        v121 = true;
                                                                                                                                                                                                                                                        // branch -> after_if_80515dd_0
                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                        v120 = true;
                                                                                                                                                                                                                                                        v121 = false;
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                int32_t v122 = (int32_t)str5 & -256;
                                                                                                                                                                                                                                                if (((int32_t)(v121 || v120) || v122) == 1) {
                                                                                                                                                                                                                                                    bool v123 = false;
                                                                                                                                                                                                                                                    bool v124 = false; // 0x8051610
                                                                                                                                                                                                                                                    if (v119 >= 0.001) {
                                                                                                                                                                                                                                                        // if_805160c_0_false
                                                                                                                                                                                                                                                        if (v119 <= 0.001) {
                                                                                                                                                                                                                                                            // if_805160c_1_false
                                                                                                                                                                                                                                                            v123 = v119 != 0.001;
                                                                                                                                                                                                                                                            v124 = true;
                                                                                                                                                                                                                                                            // branch -> after_if_805160c_0
                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                            v123 = true;
                                                                                                                                                                                                                                                            v124 = false;
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    // after_if_805160c_0
                                                                                                                                                                                                                                                    if (((int32_t)(v124 || v123) || v122) == 1) {
                                                                                                                                                                                                                                                        bool v125 = false;
                                                                                                                                                                                                                                                        bool v126 = false; // 0x8051629
                                                                                                                                                                                                                                                        if (v119 <= 5.0e+4) {
                                                                                                                                                                                                                                                            // if_8051625_0_false
                                                                                                                                                                                                                                                            if (v119 >= 5.0e+4) {
                                                                                                                                                                                                                                                                // if_8051625_1_false
                                                                                                                                                                                                                                                                v125 = v119 != 5.0e+4;
                                                                                                                                                                                                                                                                v126 = true;
                                                                                                                                                                                                                                                                // branch -> after_if_8051625_0
                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                v125 = true;
                                                                                                                                                                                                                                                                v126 = false;
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                        // after_if_8051625_0
                                                                                                                                                                                                                                                        if (((int32_t)(v126 || v125) || v122) == 1) {
                                                                                                                                                                                                                                                            // 0x8051646
                                                                                                                                                                                                                                                            g55 = v118;
                                                                                                                                                                                                                                                            bool v127 = false;
                                                                                                                                                                                                                                                            bool v128 = false; // 0x8051656
                                                                                                                                                                                                                                                            if (v119 >= 16.0) {
                                                                                                                                                                                                                                                                // if_8051652_0_false
                                                                                                                                                                                                                                                                if (v119 <= 16.0) {
                                                                                                                                                                                                                                                                    // if_8051652_1_false
                                                                                                                                                                                                                                                                    v127 = v119 != 16.0;
                                                                                                                                                                                                                                                                    v128 = true;
                                                                                                                                                                                                                                                                    // branch -> after_if_8051652_0
                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                    v127 = true;
                                                                                                                                                                                                                                                                    v128 = false;
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                            // after_if_8051652_0
                                                                                                                                                                                                                                                            float80_t v129; // 0x8051667
                                                                                                                                                                                                                                                            if (((int32_t)(v128 || v127) || v122) == 1) {
                                                                                                                                                                                                                                                                // 0x8051665
                                                                                                                                                                                                                                                                v129 = 1.0L;
                                                                                                                                                                                                                                                                // branch -> 0x8051667
                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                // 0x805165d
                                                                                                                                                                                                                                                                g55 = 1000.0L;
                                                                                                                                                                                                                                                                v129 = 16.0L;
                                                                                                                                                                                                                                                                // branch -> 0x8051667
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                            // 0x8051667
                                                                                                                                                                                                                                                            g53 = 0.5L;
                                                                                                                                                                                                                                                            float80_t v130 = v118 * v129 + 0.5L; // 0x8051673
                                                                                                                                                                                                                                                            g54 = v130;
                                                                                                                                                                                                                                                            lame_set_highpassfreq((int32_t)v17, (int32_t)v130);
                                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    // 0x8051630
                                                                                                                                                                                                                                                    error_printf("Must specify highpass with --highpass freq, freq >= 0.001 kHz\n");
                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                    // 0x80515e8
                                                                                                                                                                                                                                                    lame_set_highpassfreq((int32_t)v17, -1);
                                                                                                                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                                                                                                                    goto lab_0x805203c_68;
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                // 0x80516b7
                                                                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "highpass-width") == 0) {
                                                                                                                                                                                                                                                    char * str6 = arg; // 0x80516d2
                                                                                                                                                                                                                                                    atof(str6);
                                                                                                                                                                                                                                                    float80_t v131 = g55; // 0x80516dd
                                                                                                                                                                                                                                                    float64_t v132 = v131;
                                                                                                                                                                                                                                                    nextArg = (char *)1;
                                                                                                                                                                                                                                                    bool v133 = false;
                                                                                                                                                                                                                                                    bool v134 = false; // 0x80516fa
                                                                                                                                                                                                                                                    if (v132 >= 0.001) {
                                                                                                                                                                                                                                                        // if_80516f6_0_false
                                                                                                                                                                                                                                                        if (v132 <= 0.001) {
                                                                                                                                                                                                                                                            // if_80516f6_1_false
                                                                                                                                                                                                                                                            v133 = v132 != 0.001;
                                                                                                                                                                                                                                                            v134 = true;
                                                                                                                                                                                                                                                            // branch -> after_if_80516f6_0
                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                            v133 = true;
                                                                                                                                                                                                                                                            v134 = false;
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    int32_t v135 = (int32_t)str6 & -256;
                                                                                                                                                                                                                                                    if (((int32_t)(v134 || v133) || v135) == 1) {
                                                                                                                                                                                                                                                        // 0x8051701
                                                                                                                                                                                                                                                        g54 = v131;
                                                                                                                                                                                                                                                        bool v136 = false;
                                                                                                                                                                                                                                                        bool v137 = false; // 0x8051713
                                                                                                                                                                                                                                                        if (v132 <= 5.0e+4) {
                                                                                                                                                                                                                                                            // if_805170f_0_false
                                                                                                                                                                                                                                                            if (v132 >= 5.0e+4) {
                                                                                                                                                                                                                                                                // if_805170f_1_false
                                                                                                                                                                                                                                                                v136 = v132 != 5.0e+4;
                                                                                                                                                                                                                                                                v137 = true;
                                                                                                                                                                                                                                                                // branch -> after_if_805170f_0
                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                v136 = true;
                                                                                                                                                                                                                                                                v137 = false;
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                        // after_if_805170f_0
                                                                                                                                                                                                                                                        if (((int32_t)(v137 || v136) || v135) == 1) {
                                                                                                                                                                                                                                                            // 0x8051730
                                                                                                                                                                                                                                                            g55 = v131;
                                                                                                                                                                                                                                                            lame_set_highpasswidth((int32_t)v17, (int32_t)v132);
                                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    // 0x805171a
                                                                                                                                                                                                                                                    error_printf("Must specify highpass width with --highpass-width freq, freq >= 0.001 kHz\n");
                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                    // 0x8051778
                                                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "comp") == 0) {
                                                                                                                                                                                                                                                        // 0x805178f
                                                                                                                                                                                                                                                        nextArg = (char *)1;
                                                                                                                                                                                                                                                        char * str7 = arg; // 0x8051796
                                                                                                                                                                                                                                                        atof(str7);
                                                                                                                                                                                                                                                        float80_t v138 = g56; // 0x80517a1
                                                                                                                                                                                                                                                        float64_t v139 = v138;
                                                                                                                                                                                                                                                        g55 = 1.0L;
                                                                                                                                                                                                                                                        bool v140 = false;
                                                                                                                                                                                                                                                        bool v141 = false; // 0x80517b3
                                                                                                                                                                                                                                                        if (v139 >= 1.0) {
                                                                                                                                                                                                                                                            // if_80517af_0_false
                                                                                                                                                                                                                                                            if (v139 <= 1.0) {
                                                                                                                                                                                                                                                                // if_80517af_1_false
                                                                                                                                                                                                                                                                v140 = v139 != 1.0;
                                                                                                                                                                                                                                                                v141 = true;
                                                                                                                                                                                                                                                                // branch -> after_if_80517af_0
                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                v140 = true;
                                                                                                                                                                                                                                                                v141 = false;
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                        // after_if_80517af_0
                                                                                                                                                                                                                                                        if (((int32_t)(v141 || v140) || (int32_t)str7 & -256) == 1) {
                                                                                                                                                                                                                                                            // 0x80517d0
                                                                                                                                                                                                                                                            g56 = v138;
                                                                                                                                                                                                                                                            lame_set_compression_ratio((int32_t)v17, (int32_t)(float32_t)v138);
                                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                            // 0x80517ba
                                                                                                                                                                                                                                                            error_printf("Must specify compression ratio >= 1.0\n");
                                                                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                        // 0x80517f6
                                                                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "notemp") == 0) {
                                                                                                                                                                                                                                                            // 0x805180d
                                                                                                                                                                                                                                                            lame_set_useTemporal((int32_t)v17, 0);
                                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                            // 0x8051825
                                                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "interch") == 0) {
                                                                                                                                                                                                                                                                // 0x805183c
                                                                                                                                                                                                                                                                nextArg = (char *)1;
                                                                                                                                                                                                                                                                atof(arg);
                                                                                                                                                                                                                                                                float80_t v142 = g57; // 0x805184e
                                                                                                                                                                                                                                                                g57 = v142;
                                                                                                                                                                                                                                                                lame_set_interChRatio((int32_t)v17, (int32_t)(float32_t)v142);
                                                                                                                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                                                                                                                goto lab_0x805203c_68;
                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                // 0x805186e
                                                                                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "temporal-masking") == 0) {
                                                                                                                                                                                                                                                                    // 0x8051885
                                                                                                                                                                                                                                                                    nextArg = (char *)1;
                                                                                                                                                                                                                                                                    lame_set_useTemporal((int32_t)v17, (int32_t)(atoi(arg) != 0));
                                                                                                                                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                                                                                                                                    goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                    // 0x80518b3
                                                                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "nspsytune") == 0) {
                                                                                                                                                                                                                                                                        goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                    // 0x80518ce
                                                                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "nssafejoint") == 0) {
                                                                                                                                                                                                                                                                        int32_t v143 = (int32_t)v17; // 0x80518e5_0
                                                                                                                                                                                                                                                                        lame_get_exp_nspsytune(v143);
                                                                                                                                                                                                                                                                        lame_set_exp_nspsytune((int32_t)v17, v143 | 2);
                                                                                                                                                                                                                                                                        // branch -> 0x805203c
                                                                                                                                                                                                                                                                        goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                        // 0x8051907
                                                                                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "nsmsfix") == 0) {
                                                                                                                                                                                                                                                                            // 0x805191e
                                                                                                                                                                                                                                                                            nextArg = (char *)1;
                                                                                                                                                                                                                                                                            atof(arg);
                                                                                                                                                                                                                                                                            lame_set_msfix((int32_t)v17, (int32_t)(float32_t)g58);
                                                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                                            // 0x8051944
                                                                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "ns-bass") == 0) {
                                                                                                                                                                                                                                                                                // 0x805195f
                                                                                                                                                                                                                                                                                nextArg = (char *)1;
                                                                                                                                                                                                                                                                                atof(arg);
                                                                                                                                                                                                                                                                                g58 = 4.0L;
                                                                                                                                                                                                                                                                                float80_t v144 = 4.0L * g59; // 0x8051983
                                                                                                                                                                                                                                                                                g59 = v144;
                                                                                                                                                                                                                                                                                int32_t v145 = v144; // 0x80519a1
                                                                                                                                                                                                                                                                                int32_t v146 = v145 < -32 ? -32 : v145;
                                                                                                                                                                                                                                                                                int32_t v147 = v146 > 31 ? 31 : v146; // 0x80519d9404
                                                                                                                                                                                                                                                                                int32_t v148 = v147 > 0 ? v147 : v147 + 64; // 0x80519ca
                                                                                                                                                                                                                                                                                int32_t v149 = (int32_t)v17; // 0x80519ce_0
                                                                                                                                                                                                                                                                                lame_get_exp_nspsytune(v149);
                                                                                                                                                                                                                                                                                lame_set_exp_nspsytune((int32_t)v17, 4 * v148 | v149);
                                                                                                                                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                                                                                                                                goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                                // 0x80519f5
                                                                                                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "ns-alto") == 0) {
                                                                                                                                                                                                                                                                                    // 0x8051a10
                                                                                                                                                                                                                                                                                    nextArg = (char *)1;
                                                                                                                                                                                                                                                                                    g59 = 4.0L;
                                                                                                                                                                                                                                                                                    int32_t v150 = 4.0L * (float80_t)atof(arg); // 0x8051a52
                                                                                                                                                                                                                                                                                    int32_t v151 = v150 < -32 ? -32 : v150;
                                                                                                                                                                                                                                                                                    int32_t v152 = v151 > 31 ? 31 : v151; // 0x8051a8a401
                                                                                                                                                                                                                                                                                    int32_t v153 = v152 > 0 ? v152 : v152 + 64; // 0x8051a7b
                                                                                                                                                                                                                                                                                    int32_t v154 = (int32_t)v17; // 0x8051a7f_0
                                                                                                                                                                                                                                                                                    lame_get_exp_nspsytune(v154);
                                                                                                                                                                                                                                                                                    lame_set_exp_nspsytune((int32_t)v17, 256 * v153 | v154);
                                                                                                                                                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                                                                                                                                                    goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                    // 0x8051aa6
                                                                                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "ns-treble") == 0) {
                                                                                                                                                                                                                                                                                        // 0x8051ac1
                                                                                                                                                                                                                                                                                        nextArg = (char *)1;
                                                                                                                                                                                                                                                                                        atof(arg);
                                                                                                                                                                                                                                                                                        float80_t v155 = 4.0L * g53; // 0x8051ae5
                                                                                                                                                                                                                                                                                        g53 = v155;
                                                                                                                                                                                                                                                                                        int32_t v156 = v155; // 0x8051b03
                                                                                                                                                                                                                                                                                        int32_t v157 = v156 < -32 ? -32 : v156;
                                                                                                                                                                                                                                                                                        int32_t v158 = v157 > 31 ? 31 : v157; // 0x8051b3b398
                                                                                                                                                                                                                                                                                        int32_t v159 = v158 > 0 ? v158 : v158 + 64; // 0x8051b2c
                                                                                                                                                                                                                                                                                        int32_t v160 = (int32_t)v17; // 0x8051b30_0
                                                                                                                                                                                                                                                                                        lame_get_exp_nspsytune(v160);
                                                                                                                                                                                                                                                                                        lame_set_exp_nspsytune((int32_t)v17, 0x4000 * v159 | v160);
                                                                                                                                                                                                                                                                                        // branch -> 0x805203c
                                                                                                                                                                                                                                                                                        goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                                        // 0x8051b57
                                                                                                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "ns-sfb21") == 0) {
                                                                                                                                                                                                                                                                                            // 0x8051b72
                                                                                                                                                                                                                                                                                            nextArg = (char *)1;
                                                                                                                                                                                                                                                                                            atof(arg);
                                                                                                                                                                                                                                                                                            g53 = 4.0L;
                                                                                                                                                                                                                                                                                            float80_t v161 = 4.0L * g54; // 0x8051b96
                                                                                                                                                                                                                                                                                            g54 = v161;
                                                                                                                                                                                                                                                                                            int32_t v162 = v161; // 0x8051bb4
                                                                                                                                                                                                                                                                                            int32_t v163 = v162 < -32 ? -32 : v162;
                                                                                                                                                                                                                                                                                            int32_t v164 = v163 > 31 ? 31 : v163; // 0x8051bec395
                                                                                                                                                                                                                                                                                            int32_t v165 = v164 > 0 ? v164 : v164 + 64; // 0x8051bdd
                                                                                                                                                                                                                                                                                            int32_t v166 = (int32_t)v17; // 0x8051be1_0
                                                                                                                                                                                                                                                                                            lame_get_exp_nspsytune(v166);
                                                                                                                                                                                                                                                                                            lame_set_exp_nspsytune((int32_t)v17, 0x100000 * v165 | v166);
                                                                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                                                            // 0x8051c08
                                                                                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "nspsytune2") == 0) {
                                                                                                                                                                                                                                                                                                goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                            // 0x8051c23
                                                                                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "quiet") != 0) {
                                                                                                                                                                                                                                                                                                // 0x8051c3a
                                                                                                                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "silent") != 0) {
                                                                                                                                                                                                                                                                                                    // 0x8051c60
                                                                                                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "brief") == 0) {
                                                                                                                                                                                                                                                                                                        // 0x8051c77
                                                                                                                                                                                                                                                                                                        silent = -5;
                                                                                                                                                                                                                                                                                                        // branch -> 0x805203c
                                                                                                                                                                                                                                                                                                        goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                                                        // 0x8051c86
                                                                                                                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "verbose") == 0) {
                                                                                                                                                                                                                                                                                                            // 0x8051c9d
                                                                                                                                                                                                                                                                                                            silent = -10;
                                                                                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                                                                            // 0x8051cac
                                                                                                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "version") != 0) {
                                                                                                                                                                                                                                                                                                                // 0x8051cc3
                                                                                                                                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "license") != 0) {
                                                                                                                                                                                                                                                                                                                    // 0x8051cf1
                                                                                                                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "help") != 0) {
                                                                                                                                                                                                                                                                                                                        // 0x8051d08
                                                                                                                                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "usage") != 0) {
                                                                                                                                                                                                                                                                                                                            // 0x8051d44
                                                                                                                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "longhelp") == 0) {
                                                                                                                                                                                                                                                                                                                                // 0x8051d5b
                                                                                                                                                                                                                                                                                                                                long_help(v17, (struct _IO_FILE_4 *)g14, (char *)nogap_tags, 0);
                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                                                                                // 0x8051d88
                                                                                                                                                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "?") == 0) {
                                                                                                                                                                                                                                                                                                                                    struct _IO_FILE * v167 = popen("less -Mqc", "w"); // 0x8051dae
                                                                                                                                                                                                                                                                                                                                    k = (int32_t)v167;
                                                                                                                                                                                                                                                                                                                                    long_help(v17, (struct _IO_FILE_4 *)v167, (char *)nogap_tags, 0);
                                                                                                                                                                                                                                                                                                                                    pclose((struct _IO_FILE *)k);
                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                                                                    // 0x8051dec
                                                                                                                                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "preset") != 0) {
                                                                                                                                                                                                                                                                                                                                        // 0x8051e03
                                                                                                                                                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "alt-preset") != 0) {
                                                                                                                                                                                                                                                                                                                                            // 0x8051f19
                                                                                                                                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "disptime") == 0) {
                                                                                                                                                                                                                                                                                                                                                // 0x8051f30
                                                                                                                                                                                                                                                                                                                                                nextArg = (char *)1;
                                                                                                                                                                                                                                                                                                                                                atof(arg);
                                                                                                                                                                                                                                                                                                                                                float80_t v168 = g55; // 0x8051f42
                                                                                                                                                                                                                                                                                                                                                g55 = v168;
                                                                                                                                                                                                                                                                                                                                                update_interval = v168;
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                                                                                                                                                                                                goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                                                                                                // 0x8051f59
                                                                                                                                                                                                                                                                                                                                                if (local_strcasecmp((char *)id3tag_mode, "nogaptags") == 0) {
                                                                                                                                                                                                                                                                                                                                                    // 0x8051f70
                                                                                                                                                                                                                                                                                                                                                    nogap = 1;
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x805203c
                                                                                                                                                                                                                                                                                                                                                    goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                                                                                    // 0x8051f7c
                                                                                                                                                                                                                                                                                                                                                    if (local_strcasecmp((char *)id3tag_mode, "nogapout") == 0) {
                                                                                                                                                                                                                                                                                                                                                        // 0x8051f93
                                                                                                                                                                                                                                                                                                                                                        strcpy(outPath, arg);
                                                                                                                                                                                                                                                                                                                                                        nextArg = (char *)1;
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x805203c
                                                                                                                                                                                                                                                                                                                                                        goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                                                                                                        // 0x8051fb1
                                                                                                                                                                                                                                                                                                                                                        if (local_strcasecmp((char *)id3tag_mode, "nogap") == 0) {
                                                                                                                                                                                                                                                                                                                                                            // 0x8051fc8
                                                                                                                                                                                                                                                                                                                                                            autoconvert = 1;
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                                                                                                                                            goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                                                                                                                            // 0x8051fd1
                                                                                                                                                                                                                                                                                                                                                            if (local_strcasecmp((char *)id3tag_mode, "athaa-sensitivity") == 0) {
                                                                                                                                                                                                                                                                                                                                                                // 0x8051fe8
                                                                                                                                                                                                                                                                                                                                                                nextArg = (char *)1;
                                                                                                                                                                                                                                                                                                                                                                atof(arg);
                                                                                                                                                                                                                                                                                                                                                                float80_t v169 = g56; // 0x8051ffa
                                                                                                                                                                                                                                                                                                                                                                g56 = v169;
                                                                                                                                                                                                                                                                                                                                                                lame_set_athaa_sensitivity((int32_t)v17, (int32_t)(float32_t)v169);
                                                                                                                                                                                                                                                                                                                                                                // branch -> 0x805203c
                                                                                                                                                                                                                                                                                                                                                                goto lab_0x805203c_68;
                                                                                                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                                                                                                                // 0x8052017
                                                                                                                                                                                                                                                                                                                                                                error_printf("%s: unrecognized option --%s\n");
                                                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        // 0x805203c
                                                                                                                                                                                                                                                                                                                                                        input_file += (int32_t)nextArg;
                                                                                                                                                                                                                                                                                                                                                        v65 = v76;
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x80526d2
                                                                                                                                                                                                                                                                                                                                                        goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    // 0x805203c
                                                                                                                                                                                                                                                                                                                                                    v91 = nextArg;
                                                                                                                                                                                                                                                                                                                                                    v92 = input_file;
                                                                                                                                                                                                                                                                                                                                                    input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                                                                                                                    v65 = v76;
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x80526d2
                                                                                                                                                                                                                                                                                                                                                    goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x805203c
                                                                                                                                                                                                                                                                                                                                                v91 = nextArg;
                                                                                                                                                                                                                                                                                                                                                v92 = input_file;
                                                                                                                                                                                                                                                                                                                                                input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                                                                                                                v65 = v76;
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x80526d2
                                                                                                                                                                                                                                                                                                                                                goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                          lab_0x805203c_69:
                                                                                                                                                                                                                                                                                                                                            // 0x805203c
                                                                                                                                                                                                                                                                                                                                            input_file += (int32_t)nextArg;
                                                                                                                                                                                                                                                                                                                                            v65 = v76;
                                                                                                                                                                                                                                                                                                                                            // branch -> 0x80526d2
                                                                                                                                                                                                                                                                                                                                            goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                    // 0x8051e1e
                                                                                                                                                                                                                                                                                                                                    nextArg = (char *)1;
                                                                                                                                                                                                                                                                                                                                    fp = NULL;
                                                                                                                                                                                                                                                                                                                                    fast = 0;
                                                                                                                                                                                                                                                                                                                                    char * str8 = arg; // 0x8051eb2
                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8051eaa
                                                                                                                                                                                                                                                                                                                                    while (true) {
                                                                                                                                                                                                                                                                                                                                        // 0x8051eaa
                                                                                                                                                                                                                                                                                                                                        if (strcmp(str8, "fast") != 0) {
                                                                                                                                                                                                                                                                                                                                            // 0x8051ec5
                                                                                                                                                                                                                                                                                                                                            if (strcmp(arg, "cbr") != 0) {
                                                                                                                                                                                                                                                                                                                                                // 0x8051ee0
                                                                                                                                                                                                                                                                                                                                                if (presets_set(v17, (int32_t)fp, fast, arg, (char *)nogap_tags) > 0) {
                                                                                                                                                                                                                                                                                                                                                    goto lab_0x805203c_69;
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x8051f0f
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        // 0x8051e35
                                                                                                                                                                                                                                                                                                                                        if (strcmp(arg, "fast") == 0 && fp <= NULL) {
                                                                                                                                                                                                                                                                                                                                            // 0x8051e52
                                                                                                                                                                                                                                                                                                                                            fp = (struct _IO_FILE_4 *)1;
                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8051e59
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        // 0x8051e59
                                                                                                                                                                                                                                                                                                                                        if (strcmp(arg, "cbr") == 0 && fast <= 0) {
                                                                                                                                                                                                                                                                                                                                            // 0x8051e76
                                                                                                                                                                                                                                                                                                                                            fast = 1;
                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8051e7d
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        int32_t v170 = (int32_t)nextArg + 1; // 0x8051e7d
                                                                                                                                                                                                                                                                                                                                        nextArg = (char *)v170;
                                                                                                                                                                                                                                                                                                                                        int32_t v171 = v170 + input_file; // 0x8051e87
                                                                                                                                                                                                                                                                                                                                        int32_t v172 = (int32_t)&g9;
                                                                                                                                                                                                                                                                                                                                        if (v171 < argc) {
                                                                                                                                                                                                                                                                                                                                            // 0x8051e8f
                                                                                                                                                                                                                                                                                                                                            v172 = *(int32_t *)(4 * v171 + v18);
                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8051ea7
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        char * v173 = (char *)v172; // 0x8051ea7_0
                                                                                                                                                                                                                                                                                                                                        arg = v173;
                                                                                                                                                                                                                                                                                                                                        str8 = v173;
                                                                                                                                                                                                                                                                                                                                        // branch -> 0x8051eaa
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                    // 0x80526e2
                                                                                                                                                                                                                                                                                                                                    if (v37 == 0) {
                                                                                                                                                                                                                                                                                                                                        // 0x80526e8
                                                                                                                                                                                                                                                                                                                                        v41 = g38;
                                                                                                                                                                                                                                                                                                                                        v52 = nogap_tags;
                                                                                                                                                                                                                                                                                                                                        usage((struct _IO_FILE_4 *)v41, (char *)v52);
                                                                                                                                                                                                                                                                                                                                        result = -1;
                                                                                                                                                                                                                                                                                                                                        // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                                                                                        // 0x8052706
                                                                                                                                                                                                                                                                                                                                        v45 = *inPath;
                                                                                                                                                                                                                                                                                                                                        if (v45 == 45) {
                                                                                                                                                                                                                                                                                                                                            // 0x8052710
                                                                                                                                                                                                                                                                                                                                            v33 = silent;
                                                                                                                                                                                                                                                                                                                                            v34 = v33;
                                                                                                                                                                                                                                                                                                                                            if (v33 < 1) {
                                                                                                                                                                                                                                                                                                                                                // if_805271c_0_true
                                                                                                                                                                                                                                                                                                                                                v34 = 1;
                                                                                                                                                                                                                                                                                                                                                // branch -> after_if_805271c_0
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            // after_if_805271c_0
                                                                                                                                                                                                                                                                                                                                            silent = v34;
                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8052724
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        // 0x8052724
                                                                                                                                                                                                                                                                                                                                        v46 = *outPath;
                                                                                                                                                                                                                                                                                                                                        v66 = ProgramName;
                                                                                                                                                                                                                                                                                                                                        if (v46 == 0 && v66 == NULL) {
                                                                                                                                                                                                                                                                                                                                            // 0x8052738
                                                                                                                                                                                                                                                                                                                                            v47 = *inPath;
                                                                                                                                                                                                                                                                                                                                            if (v47 == 45) {
                                                                                                                                                                                                                                                                                                                                                // 0x8052742
                                                                                                                                                                                                                                                                                                                                                memcpy(outPath, "-", 2);
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x80527b3
                                                                                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                                                                                                // 0x8052760
                                                                                                                                                                                                                                                                                                                                                strncpy(outPath, inPath, 4093);
                                                                                                                                                                                                                                                                                                                                                v53 = v17;
                                                                                                                                                                                                                                                                                                                                                v24 = (int32_t)v53;
                                                                                                                                                                                                                                                                                                                                                v32 = v24;
                                                                                                                                                                                                                                                                                                                                                lame_get_decode_only(v24);
                                                                                                                                                                                                                                                                                                                                                v42 = v32;
                                                                                                                                                                                                                                                                                                                                                if (v42 == 0) {
                                                                                                                                                                                                                                                                                                                                                    // 0x805279f
                                                                                                                                                                                                                                                                                                                                                    strcat(outPath, ".mp3");
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x80527b3
                                                                                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                                                                                    // 0x8052789
                                                                                                                                                                                                                                                                                                                                                    strcat(outPath, ".wav");
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x80527b3
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x80527b3
                                                                                                                                                                                                                                                                                                                                                v67 = count_nogap;
                                                                                                                                                                                                                                                                                                                                                if (v67 == 0) {
                                                                                                                                                                                                                                                                                                                                                    // 0x80527b9
                                                                                                                                                                                                                                                                                                                                                    v54 = v17;
                                                                                                                                                                                                                                                                                                                                                    lame_set_findReplayGain((int32_t)v54, 1);
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x80527cc
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x80527cc
                                                                                                                                                                                                                                                                                                                                                v68 = autoconvert;
                                                                                                                                                                                                                                                                                                                                                if (v68 != 0) {
                                                                                                                                                                                                                                                                                                                                                    // 0x80527d2
                                                                                                                                                                                                                                                                                                                                                    v55 = v17;
                                                                                                                                                                                                                                                                                                                                                    v25 = (int32_t)v55;
                                                                                                                                                                                                                                                                                                                                                    v32 = v25;
                                                                                                                                                                                                                                                                                                                                                    lame_get_bWriteVbrTag(v25);
                                                                                                                                                                                                                                                                                                                                                    v43 = v32;
                                                                                                                                                                                                                                                                                                                                                    v69 = nogap;
                                                                                                                                                                                                                                                                                                                                                    if (v43 != 0 && v69 == 0) {
                                                                                                                                                                                                                                                                                                                                                        // 0x80527e7
                                                                                                                                                                                                                                                                                                                                                        console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
                                                                                                                                                                                                                                                                                                                                                        v56 = v17;
                                                                                                                                                                                                                                                                                                                                                        lame_set_bWriteVbrTag((int32_t)v56, 0);
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x8052806
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x8052806
                                                                                                                                                                                                                                                                                                                                                v48 = *outPath;
                                                                                                                                                                                                                                                                                                                                                if (v48 == 45) {
                                                                                                                                                                                                                                                                                                                                                    // 0x8052810
                                                                                                                                                                                                                                                                                                                                                    v57 = v17;
                                                                                                                                                                                                                                                                                                                                                    lame_set_bWriteVbrTag((int32_t)v57, 0);
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052823
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x8052823
                                                                                                                                                                                                                                                                                                                                                v35 = input_format;
                                                                                                                                                                                                                                                                                                                                                v36 = v35;
                                                                                                                                                                                                                                                                                                                                                if (v35 == 0) {
                                                                                                                                                                                                                                                                                                                                                    // 0x805282c
                                                                                                                                                                                                                                                                                                                                                    v31 = filename_to_type(inPath);
                                                                                                                                                                                                                                                                                                                                                    input_format = v31;
                                                                                                                                                                                                                                                                                                                                                    v36 = v31;
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x805283c
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x805283c
                                                                                                                                                                                                                                                                                                                                                if (v36 == 8) {
                                                                                                                                                                                                                                                                                                                                                    // 0x8052846
                                                                                                                                                                                                                                                                                                                                                    error_printf("sorry, vorbis support in LAME is deprecated.\n");
                                                                                                                                                                                                                                                                                                                                                    result = -1;
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                                                                                    // 0x805285c
                                                                                                                                                                                                                                                                                                                                                    v70 = i;
                                                                                                                                                                                                                                                                                                                                                    v58 = v17;
                                                                                                                                                                                                                                                                                                                                                    v26 = (int32_t)v58;
                                                                                                                                                                                                                                                                                                                                                    v32 = v26;
                                                                                                                                                                                                                                                                                                                                                    if (v70 == 0) {
                                                                                                                                                                                                                                                                                                                                                        // 0x8052877
                                                                                                                                                                                                                                                                                                                                                        lame_get_mode(v26);
                                                                                                                                                                                                                                                                                                                                                        v50 = v32;
                                                                                                                                                                                                                                                                                                                                                        v59 = v17;
                                                                                                                                                                                                                                                                                                                                                        v27 = (int32_t)v59;
                                                                                                                                                                                                                                                                                                                                                        if (v50 == 3) {
                                                                                                                                                                                                                                                                                                                                                            // 0x8052887
                                                                                                                                                                                                                                                                                                                                                            lame_set_num_channels(v27, 1);
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x80528af
                                                                                                                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                                                                                                                            // 0x805289c
                                                                                                                                                                                                                                                                                                                                                            lame_set_num_channels(v27, 2);
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x80528af
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        // 0x80528af
                                                                                                                                                                                                                                                                                                                                                        v60 = v17;
                                                                                                                                                                                                                                                                                                                                                        v28 = (int32_t)v60;
                                                                                                                                                                                                                                                                                                                                                        v32 = v28;
                                                                                                                                                                                                                                                                                                                                                        lame_get_free_format(v28);
                                                                                                                                                                                                                                                                                                                                                        v44 = v32;
                                                                                                                                                                                                                                                                                                                                                        if (v44 == 0) {
                                                                                                                                                                                                                                                                                                                                                            // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                            if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                                // 0x8052905
                                                                                                                                                                                                                                                                                                                                                                v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                                *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                                // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                            // 0x805290d
                                                                                                                                                                                                                                                                                                                                                            result = 0;
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                                                                                                                            // 0x80528be
                                                                                                                                                                                                                                                                                                                                                            v61 = v17;
                                                                                                                                                                                                                                                                                                                                                            v29 = (int32_t)v61;
                                                                                                                                                                                                                                                                                                                                                            v32 = v29;
                                                                                                                                                                                                                                                                                                                                                            lame_get_brate(v29);
                                                                                                                                                                                                                                                                                                                                                            v51 = v32;
                                                                                                                                                                                                                                                                                                                                                            if (v51 >= 8) {
                                                                                                                                                                                                                                                                                                                                                                // 0x80528ce
                                                                                                                                                                                                                                                                                                                                                                v62 = v17;
                                                                                                                                                                                                                                                                                                                                                                v30 = (int32_t)v62;
                                                                                                                                                                                                                                                                                                                                                                v32 = v30;
                                                                                                                                                                                                                                                                                                                                                                lame_get_brate(v30);
                                                                                                                                                                                                                                                                                                                                                                v49 = v32;
                                                                                                                                                                                                                                                                                                                                                                if (v49 < 641) {
                                                                                                                                                                                                                                                                                                                                                                    // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                                    if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                                        // 0x8052905
                                                                                                                                                                                                                                                                                                                                                                        v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                                        *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                    // 0x805290d
                                                                                                                                                                                                                                                                                                                                                                    result = 0;
                                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                            // 0x80528e0
                                                                                                                                                                                                                                                                                                                                                            error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                                                                                                                                                                                                                                                                                                                                            error_printf("with the -b <bitrate> option\n");
                                                                                                                                                                                                                                                                                                                                                            result = -1;
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                                                                                                        // 0x8052862
                                                                                                                                                                                                                                                                                                                                                        lame_set_num_channels(v26, 2);
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x80528af
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    // 0x80528af
                                                                                                                                                                                                                                                                                                                                                    v60 = v17;
                                                                                                                                                                                                                                                                                                                                                    v28 = (int32_t)v60;
                                                                                                                                                                                                                                                                                                                                                    v32 = v28;
                                                                                                                                                                                                                                                                                                                                                    lame_get_free_format(v28);
                                                                                                                                                                                                                                                                                                                                                    v44 = v32;
                                                                                                                                                                                                                                                                                                                                                    if (v44 == 0) {
                                                                                                                                                                                                                                                                                                                                                        // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                        if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                            // 0x8052905
                                                                                                                                                                                                                                                                                                                                                            v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                            *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        // 0x805290d
                                                                                                                                                                                                                                                                                                                                                        result = 0;
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                                                                                                        // 0x80528be
                                                                                                                                                                                                                                                                                                                                                        v61 = v17;
                                                                                                                                                                                                                                                                                                                                                        v29 = (int32_t)v61;
                                                                                                                                                                                                                                                                                                                                                        v32 = v29;
                                                                                                                                                                                                                                                                                                                                                        lame_get_brate(v29);
                                                                                                                                                                                                                                                                                                                                                        v51 = v32;
                                                                                                                                                                                                                                                                                                                                                        if (v51 >= 8) {
                                                                                                                                                                                                                                                                                                                                                            // 0x80528ce
                                                                                                                                                                                                                                                                                                                                                            v62 = v17;
                                                                                                                                                                                                                                                                                                                                                            v30 = (int32_t)v62;
                                                                                                                                                                                                                                                                                                                                                            v32 = v30;
                                                                                                                                                                                                                                                                                                                                                            lame_get_brate(v30);
                                                                                                                                                                                                                                                                                                                                                            v49 = v32;
                                                                                                                                                                                                                                                                                                                                                            if (v49 < 641) {
                                                                                                                                                                                                                                                                                                                                                                // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                                if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                                    // 0x8052905
                                                                                                                                                                                                                                                                                                                                                                    v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                                    *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                // 0x805290d
                                                                                                                                                                                                                                                                                                                                                                result = 0;
                                                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        // 0x80528e0
                                                                                                                                                                                                                                                                                                                                                        error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                                                                                                                                                                                                                                                                                                                                        error_printf("with the -b <bitrate> option\n");
                                                                                                                                                                                                                                                                                                                                                        result = -1;
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            // 0x80527b3
                                                                                                                                                                                                                                                                                                                                            v67 = count_nogap;
                                                                                                                                                                                                                                                                                                                                            if (v67 == 0) {
                                                                                                                                                                                                                                                                                                                                                // 0x80527b9
                                                                                                                                                                                                                                                                                                                                                v54 = v17;
                                                                                                                                                                                                                                                                                                                                                lame_set_findReplayGain((int32_t)v54, 1);
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x80527cc
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            // 0x80527cc
                                                                                                                                                                                                                                                                                                                                            v68 = autoconvert;
                                                                                                                                                                                                                                                                                                                                            if (v68 != 0) {
                                                                                                                                                                                                                                                                                                                                                // 0x80527d2
                                                                                                                                                                                                                                                                                                                                                v55 = v17;
                                                                                                                                                                                                                                                                                                                                                v25 = (int32_t)v55;
                                                                                                                                                                                                                                                                                                                                                v32 = v25;
                                                                                                                                                                                                                                                                                                                                                lame_get_bWriteVbrTag(v25);
                                                                                                                                                                                                                                                                                                                                                v43 = v32;
                                                                                                                                                                                                                                                                                                                                                v69 = nogap;
                                                                                                                                                                                                                                                                                                                                                if (v43 != 0 && v69 == 0) {
                                                                                                                                                                                                                                                                                                                                                    // 0x80527e7
                                                                                                                                                                                                                                                                                                                                                    console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
                                                                                                                                                                                                                                                                                                                                                    v56 = v17;
                                                                                                                                                                                                                                                                                                                                                    lame_set_bWriteVbrTag((int32_t)v56, 0);
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052806
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            // 0x8052806
                                                                                                                                                                                                                                                                                                                                            v48 = *outPath;
                                                                                                                                                                                                                                                                                                                                            if (v48 == 45) {
                                                                                                                                                                                                                                                                                                                                                // 0x8052810
                                                                                                                                                                                                                                                                                                                                                v57 = v17;
                                                                                                                                                                                                                                                                                                                                                lame_set_bWriteVbrTag((int32_t)v57, 0);
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052823
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            // 0x8052823
                                                                                                                                                                                                                                                                                                                                            v35 = input_format;
                                                                                                                                                                                                                                                                                                                                            v36 = v35;
                                                                                                                                                                                                                                                                                                                                            if (v35 == 0) {
                                                                                                                                                                                                                                                                                                                                                // 0x805282c
                                                                                                                                                                                                                                                                                                                                                v31 = filename_to_type(inPath);
                                                                                                                                                                                                                                                                                                                                                input_format = v31;
                                                                                                                                                                                                                                                                                                                                                v36 = v31;
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x805283c
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            // 0x805283c
                                                                                                                                                                                                                                                                                                                                            if (v36 == 8) {
                                                                                                                                                                                                                                                                                                                                                // 0x8052846
                                                                                                                                                                                                                                                                                                                                                error_printf("sorry, vorbis support in LAME is deprecated.\n");
                                                                                                                                                                                                                                                                                                                                                result = -1;
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                                                                                                // 0x805285c
                                                                                                                                                                                                                                                                                                                                                v70 = i;
                                                                                                                                                                                                                                                                                                                                                v58 = v17;
                                                                                                                                                                                                                                                                                                                                                v26 = (int32_t)v58;
                                                                                                                                                                                                                                                                                                                                                v32 = v26;
                                                                                                                                                                                                                                                                                                                                                if (v70 == 0) {
                                                                                                                                                                                                                                                                                                                                                    // 0x8052877
                                                                                                                                                                                                                                                                                                                                                    lame_get_mode(v26);
                                                                                                                                                                                                                                                                                                                                                    v50 = v32;
                                                                                                                                                                                                                                                                                                                                                    v59 = v17;
                                                                                                                                                                                                                                                                                                                                                    v27 = (int32_t)v59;
                                                                                                                                                                                                                                                                                                                                                    if (v50 == 3) {
                                                                                                                                                                                                                                                                                                                                                        // 0x8052887
                                                                                                                                                                                                                                                                                                                                                        lame_set_num_channels(v27, 1);
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x80528af
                                                                                                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                                                                                                        // 0x805289c
                                                                                                                                                                                                                                                                                                                                                        lame_set_num_channels(v27, 2);
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x80528af
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    // 0x80528af
                                                                                                                                                                                                                                                                                                                                                    v60 = v17;
                                                                                                                                                                                                                                                                                                                                                    v28 = (int32_t)v60;
                                                                                                                                                                                                                                                                                                                                                    v32 = v28;
                                                                                                                                                                                                                                                                                                                                                    lame_get_free_format(v28);
                                                                                                                                                                                                                                                                                                                                                    v44 = v32;
                                                                                                                                                                                                                                                                                                                                                    if (v44 == 0) {
                                                                                                                                                                                                                                                                                                                                                        // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                        if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                            // 0x8052905
                                                                                                                                                                                                                                                                                                                                                            v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                            *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        // 0x805290d
                                                                                                                                                                                                                                                                                                                                                        result = 0;
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                                                                                                                                                        // 0x80528be
                                                                                                                                                                                                                                                                                                                                                        v61 = v17;
                                                                                                                                                                                                                                                                                                                                                        v29 = (int32_t)v61;
                                                                                                                                                                                                                                                                                                                                                        v32 = v29;
                                                                                                                                                                                                                                                                                                                                                        lame_get_brate(v29);
                                                                                                                                                                                                                                                                                                                                                        v51 = v32;
                                                                                                                                                                                                                                                                                                                                                        if (v51 >= 8) {
                                                                                                                                                                                                                                                                                                                                                            // 0x80528ce
                                                                                                                                                                                                                                                                                                                                                            v62 = v17;
                                                                                                                                                                                                                                                                                                                                                            v30 = (int32_t)v62;
                                                                                                                                                                                                                                                                                                                                                            v32 = v30;
                                                                                                                                                                                                                                                                                                                                                            lame_get_brate(v30);
                                                                                                                                                                                                                                                                                                                                                            v49 = v32;
                                                                                                                                                                                                                                                                                                                                                            if (v49 < 641) {
                                                                                                                                                                                                                                                                                                                                                                // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                                if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                                    // 0x8052905
                                                                                                                                                                                                                                                                                                                                                                    v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                                    *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                // 0x805290d
                                                                                                                                                                                                                                                                                                                                                                result = 0;
                                                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        // 0x80528e0
                                                                                                                                                                                                                                                                                                                                                        error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                                                                                                                                                                                                                                                                                                                                        error_printf("with the -b <bitrate> option\n");
                                                                                                                                                                                                                                                                                                                                                        result = -1;
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                                                                                    // 0x8052862
                                                                                                                                                                                                                                                                                                                                                    lame_set_num_channels(v26, 2);
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x80528af
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x80528af
                                                                                                                                                                                                                                                                                                                                                v60 = v17;
                                                                                                                                                                                                                                                                                                                                                v28 = (int32_t)v60;
                                                                                                                                                                                                                                                                                                                                                v32 = v28;
                                                                                                                                                                                                                                                                                                                                                lame_get_free_format(v28);
                                                                                                                                                                                                                                                                                                                                                v44 = v32;
                                                                                                                                                                                                                                                                                                                                                if (v44 == 0) {
                                                                                                                                                                                                                                                                                                                                                    // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                    if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                        // 0x8052905
                                                                                                                                                                                                                                                                                                                                                        v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                        *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    // 0x805290d
                                                                                                                                                                                                                                                                                                                                                    result = 0;
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                                                                                    // 0x80528be
                                                                                                                                                                                                                                                                                                                                                    v61 = v17;
                                                                                                                                                                                                                                                                                                                                                    v29 = (int32_t)v61;
                                                                                                                                                                                                                                                                                                                                                    v32 = v29;
                                                                                                                                                                                                                                                                                                                                                    lame_get_brate(v29);
                                                                                                                                                                                                                                                                                                                                                    v51 = v32;
                                                                                                                                                                                                                                                                                                                                                    if (v51 >= 8) {
                                                                                                                                                                                                                                                                                                                                                        // 0x80528ce
                                                                                                                                                                                                                                                                                                                                                        v62 = v17;
                                                                                                                                                                                                                                                                                                                                                        v30 = (int32_t)v62;
                                                                                                                                                                                                                                                                                                                                                        v32 = v30;
                                                                                                                                                                                                                                                                                                                                                        lame_get_brate(v30);
                                                                                                                                                                                                                                                                                                                                                        v49 = v32;
                                                                                                                                                                                                                                                                                                                                                        if (v49 < 641) {
                                                                                                                                                                                                                                                                                                                                                            // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                            if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                                // 0x8052905
                                                                                                                                                                                                                                                                                                                                                                v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                                *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                                // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                            // 0x805290d
                                                                                                                                                                                                                                                                                                                                                            result = 0;
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    // 0x80528e0
                                                                                                                                                                                                                                                                                                                                                    error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                                                                                                                                                                                                                                                                                                                                    error_printf("with the -b <bitrate> option\n");
                                                                                                                                                                                                                                                                                                                                                    result = -1;
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        // 0x80527b3
                                                                                                                                                                                                                                                                                                                                        v67 = count_nogap;
                                                                                                                                                                                                                                                                                                                                        if (v67 == 0) {
                                                                                                                                                                                                                                                                                                                                            // 0x80527b9
                                                                                                                                                                                                                                                                                                                                            v54 = v17;
                                                                                                                                                                                                                                                                                                                                            lame_set_findReplayGain((int32_t)v54, 1);
                                                                                                                                                                                                                                                                                                                                            // branch -> 0x80527cc
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        // 0x80527cc
                                                                                                                                                                                                                                                                                                                                        v68 = autoconvert;
                                                                                                                                                                                                                                                                                                                                        if (v68 != 0) {
                                                                                                                                                                                                                                                                                                                                            // 0x80527d2
                                                                                                                                                                                                                                                                                                                                            v55 = v17;
                                                                                                                                                                                                                                                                                                                                            v25 = (int32_t)v55;
                                                                                                                                                                                                                                                                                                                                            v32 = v25;
                                                                                                                                                                                                                                                                                                                                            lame_get_bWriteVbrTag(v25);
                                                                                                                                                                                                                                                                                                                                            v43 = v32;
                                                                                                                                                                                                                                                                                                                                            v69 = nogap;
                                                                                                                                                                                                                                                                                                                                            if (v43 != 0 && v69 == 0) {
                                                                                                                                                                                                                                                                                                                                                // 0x80527e7
                                                                                                                                                                                                                                                                                                                                                console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
                                                                                                                                                                                                                                                                                                                                                v56 = v17;
                                                                                                                                                                                                                                                                                                                                                lame_set_bWriteVbrTag((int32_t)v56, 0);
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052806
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        // 0x8052806
                                                                                                                                                                                                                                                                                                                                        v48 = *outPath;
                                                                                                                                                                                                                                                                                                                                        if (v48 == 45) {
                                                                                                                                                                                                                                                                                                                                            // 0x8052810
                                                                                                                                                                                                                                                                                                                                            v57 = v17;
                                                                                                                                                                                                                                                                                                                                            lame_set_bWriteVbrTag((int32_t)v57, 0);
                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8052823
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        // 0x8052823
                                                                                                                                                                                                                                                                                                                                        v35 = input_format;
                                                                                                                                                                                                                                                                                                                                        v36 = v35;
                                                                                                                                                                                                                                                                                                                                        if (v35 == 0) {
                                                                                                                                                                                                                                                                                                                                            // 0x805282c
                                                                                                                                                                                                                                                                                                                                            v31 = filename_to_type(inPath);
                                                                                                                                                                                                                                                                                                                                            input_format = v31;
                                                                                                                                                                                                                                                                                                                                            v36 = v31;
                                                                                                                                                                                                                                                                                                                                            // branch -> 0x805283c
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        // 0x805283c
                                                                                                                                                                                                                                                                                                                                        if (v36 == 8) {
                                                                                                                                                                                                                                                                                                                                            // 0x8052846
                                                                                                                                                                                                                                                                                                                                            error_printf("sorry, vorbis support in LAME is deprecated.\n");
                                                                                                                                                                                                                                                                                                                                            result = -1;
                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                                                                                                                                            // 0x805285c
                                                                                                                                                                                                                                                                                                                                            v70 = i;
                                                                                                                                                                                                                                                                                                                                            v58 = v17;
                                                                                                                                                                                                                                                                                                                                            v26 = (int32_t)v58;
                                                                                                                                                                                                                                                                                                                                            v32 = v26;
                                                                                                                                                                                                                                                                                                                                            if (v70 == 0) {
                                                                                                                                                                                                                                                                                                                                                // 0x8052877
                                                                                                                                                                                                                                                                                                                                                lame_get_mode(v26);
                                                                                                                                                                                                                                                                                                                                                v50 = v32;
                                                                                                                                                                                                                                                                                                                                                v59 = v17;
                                                                                                                                                                                                                                                                                                                                                v27 = (int32_t)v59;
                                                                                                                                                                                                                                                                                                                                                if (v50 == 3) {
                                                                                                                                                                                                                                                                                                                                                    // 0x8052887
                                                                                                                                                                                                                                                                                                                                                    lame_set_num_channels(v27, 1);
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x80528af
                                                                                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                                                                                    // 0x805289c
                                                                                                                                                                                                                                                                                                                                                    lame_set_num_channels(v27, 2);
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x80528af
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x80528af
                                                                                                                                                                                                                                                                                                                                                v60 = v17;
                                                                                                                                                                                                                                                                                                                                                v28 = (int32_t)v60;
                                                                                                                                                                                                                                                                                                                                                v32 = v28;
                                                                                                                                                                                                                                                                                                                                                lame_get_free_format(v28);
                                                                                                                                                                                                                                                                                                                                                v44 = v32;
                                                                                                                                                                                                                                                                                                                                                if (v44 == 0) {
                                                                                                                                                                                                                                                                                                                                                    // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                    if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                        // 0x8052905
                                                                                                                                                                                                                                                                                                                                                        v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                        *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    // 0x805290d
                                                                                                                                                                                                                                                                                                                                                    result = 0;
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                                                                                                                                                    // 0x80528be
                                                                                                                                                                                                                                                                                                                                                    v61 = v17;
                                                                                                                                                                                                                                                                                                                                                    v29 = (int32_t)v61;
                                                                                                                                                                                                                                                                                                                                                    v32 = v29;
                                                                                                                                                                                                                                                                                                                                                    lame_get_brate(v29);
                                                                                                                                                                                                                                                                                                                                                    v51 = v32;
                                                                                                                                                                                                                                                                                                                                                    if (v51 >= 8) {
                                                                                                                                                                                                                                                                                                                                                        // 0x80528ce
                                                                                                                                                                                                                                                                                                                                                        v62 = v17;
                                                                                                                                                                                                                                                                                                                                                        v30 = (int32_t)v62;
                                                                                                                                                                                                                                                                                                                                                        v32 = v30;
                                                                                                                                                                                                                                                                                                                                                        lame_get_brate(v30);
                                                                                                                                                                                                                                                                                                                                                        v49 = v32;
                                                                                                                                                                                                                                                                                                                                                        if (v49 < 641) {
                                                                                                                                                                                                                                                                                                                                                            // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                            if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                                // 0x8052905
                                                                                                                                                                                                                                                                                                                                                                v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                                *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                                // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                            // 0x805290d
                                                                                                                                                                                                                                                                                                                                                            result = 0;
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    // 0x80528e0
                                                                                                                                                                                                                                                                                                                                                    error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                                                                                                                                                                                                                                                                                                                                    error_printf("with the -b <bitrate> option\n");
                                                                                                                                                                                                                                                                                                                                                    result = -1;
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                                                                                                // 0x8052862
                                                                                                                                                                                                                                                                                                                                                lame_set_num_channels(v26, 2);
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x80528af
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            // 0x80528af
                                                                                                                                                                                                                                                                                                                                            v60 = v17;
                                                                                                                                                                                                                                                                                                                                            v28 = (int32_t)v60;
                                                                                                                                                                                                                                                                                                                                            v32 = v28;
                                                                                                                                                                                                                                                                                                                                            lame_get_free_format(v28);
                                                                                                                                                                                                                                                                                                                                            v44 = v32;
                                                                                                                                                                                                                                                                                                                                            if (v44 == 0) {
                                                                                                                                                                                                                                                                                                                                                // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                    // 0x8052905
                                                                                                                                                                                                                                                                                                                                                    v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                    *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                    // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x805290d
                                                                                                                                                                                                                                                                                                                                                result = 0;
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                                                                                                // 0x80528be
                                                                                                                                                                                                                                                                                                                                                v61 = v17;
                                                                                                                                                                                                                                                                                                                                                v29 = (int32_t)v61;
                                                                                                                                                                                                                                                                                                                                                v32 = v29;
                                                                                                                                                                                                                                                                                                                                                lame_get_brate(v29);
                                                                                                                                                                                                                                                                                                                                                v51 = v32;
                                                                                                                                                                                                                                                                                                                                                if (v51 >= 8) {
                                                                                                                                                                                                                                                                                                                                                    // 0x80528ce
                                                                                                                                                                                                                                                                                                                                                    v62 = v17;
                                                                                                                                                                                                                                                                                                                                                    v30 = (int32_t)v62;
                                                                                                                                                                                                                                                                                                                                                    v32 = v30;
                                                                                                                                                                                                                                                                                                                                                    lame_get_brate(v30);
                                                                                                                                                                                                                                                                                                                                                    v49 = v32;
                                                                                                                                                                                                                                                                                                                                                    if (v49 < 641) {
                                                                                                                                                                                                                                                                                                                                                        // 0x80528ff
                                                                                                                                                                                                                                                                                                                                                        if (num_nogap != NULL) {
                                                                                                                                                                                                                                                                                                                                                            // 0x8052905
                                                                                                                                                                                                                                                                                                                                                            v63 = ProgramName;
                                                                                                                                                                                                                                                                                                                                                            *num_nogap = (int32_t)v63;
                                                                                                                                                                                                                                                                                                                                                            // branch -> 0x805290d
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        // 0x805290d
                                                                                                                                                                                                                                                                                                                                                        result = 0;
                                                                                                                                                                                                                                                                                                                                                        // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                // 0x80528e0
                                                                                                                                                                                                                                                                                                                                                error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                                                                                                                                                                                                                                                                                                                                error_printf("with the -b <bitrate> option\n");
                                                                                                                                                                                                                                                                                                                                                result = -1;
                                                                                                                                                                                                                                                                                                                                                // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                    // 0x8051d1f
                                                                                                                                                                                                                                                                                                                    short_help(v17, (struct _IO_FILE_4 *)g14, (char *)nogap_tags);
                                                                                                                                                                                                                                                                                                                    // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                            // 0x8051cda
                                                                                                                                                                                                                                                                                                            print_license((struct _IO_FILE_4 *)g14);
                                                                                                                                                                                                                                                                                                            // branch -> 0x8052912
                                                                                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                  lab_0x805203c_70:
                                                                                                                                                                                                                                                                                                    // 0x805203c
                                                                                                                                                                                                                                                                                                    input_file += (int32_t)nextArg;
                                                                                                                                                                                                                                                                                                    v65 = v76;
                                                                                                                                                                                                                                                                                                    // branch -> 0x80526d2
                                                                                                                                                                                                                                                                                                    goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                            // 0x8051c51
                                                                                                                                                                                                                                                                                            silent = 10;
                                                                                                                                                                                                                                                                                            // branch -> 0x805203c
                                                                                                                                                                                                                                                                                            goto lab_0x805203c_70;
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                        // 0x805203c
                                                                                                                                                                                                                                                                                        v91 = nextArg;
                                                                                                                                                                                                                                                                                        v92 = input_file;
                                                                                                                                                                                                                                                                                        input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                                                        v65 = v76;
                                                                                                                                                                                                                                                                                        // branch -> 0x80526d2
                                                                                                                                                                                                                                                                                        goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                    // 0x805203c
                                                                                                                                                                                                                                                                                    v91 = nextArg;
                                                                                                                                                                                                                                                                                    v92 = input_file;
                                                                                                                                                                                                                                                                                    input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                                                    v65 = v76;
                                                                                                                                                                                                                                                                                    // branch -> 0x80526d2
                                                                                                                                                                                                                                                                                    goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                // 0x805203c
                                                                                                                                                                                                                                                                                v91 = nextArg;
                                                                                                                                                                                                                                                                                v92 = input_file;
                                                                                                                                                                                                                                                                                input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                                                v65 = v76;
                                                                                                                                                                                                                                                                                // branch -> 0x80526d2
                                                                                                                                                                                                                                                                                goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                            // 0x805203c
                                                                                                                                                                                                                                                                            v91 = nextArg;
                                                                                                                                                                                                                                                                            v92 = input_file;
                                                                                                                                                                                                                                                                            input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                                            v65 = v76;
                                                                                                                                                                                                                                                                            // branch -> 0x80526d2
                                                                                                                                                                                                                                                                            goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                        // 0x805203c
                                                                                                                                                                                                                                                                        v91 = nextArg;
                                                                                                                                                                                                                                                                        v92 = input_file;
                                                                                                                                                                                                                                                                        input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                                        v65 = v76;
                                                                                                                                                                                                                                                                        // branch -> 0x80526d2
                                                                                                                                                                                                                                                                        goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                    // 0x805203c
                                                                                                                                                                                                                                                                    v91 = nextArg;
                                                                                                                                                                                                                                                                    v92 = input_file;
                                                                                                                                                                                                                                                                    input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                                    v65 = v76;
                                                                                                                                                                                                                                                                    // branch -> 0x80526d2
                                                                                                                                                                                                                                                                    goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                // 0x805203c
                                                                                                                                                                                                                                                                v91 = nextArg;
                                                                                                                                                                                                                                                                v92 = input_file;
                                                                                                                                                                                                                                                                input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                                v65 = v76;
                                                                                                                                                                                                                                                                // branch -> 0x80526d2
                                                                                                                                                                                                                                                                goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                            // 0x805203c
                                                                                                                                                                                                                                                            v91 = nextArg;
                                                                                                                                                                                                                                                            v92 = input_file;
                                                                                                                                                                                                                                                            input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                            v65 = v76;
                                                                                                                                                                                                                                                            // branch -> 0x80526d2
                                                                                                                                                                                                                                                            goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                        // 0x805203c
                                                                                                                                                                                                                                                        v91 = nextArg;
                                                                                                                                                                                                                                                        v92 = input_file;
                                                                                                                                                                                                                                                        input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                                                        v65 = v76;
                                                                                                                                                                                                                                                        // branch -> 0x80526d2
                                                                                                                                                                                                                                                        goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    // 0x805203c
                                                                                                                                                                                                                                                    input_file += (int32_t)nextArg;
                                                                                                                                                                                                                                                    v65 = v76;
                                                                                                                                                                                                                                                    // branch -> 0x80526d2
                                                                                                                                                                                                                                                    goto lab_0x80526d2_27;
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                // 0x805203c
                                                                                                                                                                                                                                                input_file += (int32_t)nextArg;
                                                                                                                                                                                                                                                v65 = v76;
                                                                                                                                                                                                                                                // branch -> 0x80526d2
                                                                                                                                                                                                                                                goto lab_0x80526d2_27;
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                        // 0x805203c
                                                                                                                                                                                                                                        input_file += (int32_t)nextArg;
                                                                                                                                                                                                                                        v65 = v76;
                                                                                                                                                                                                                                        // branch -> 0x80526d2
                                                                                                                                                                                                                                        goto lab_0x80526d2_27;
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                        // 0x805203c
                                                                                                                                                                                                                        input_file += (int32_t)nextArg;
                                                                                                                                                                                                                        v65 = v76;
                                                                                                                                                                                                                        // branch -> 0x80526d2
                                                                                                                                                                                                                        goto lab_0x80526d2_27;
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                    // 0x805203c
                                                                                                                                                                                                                    v91 = nextArg;
                                                                                                                                                                                                                    v92 = input_file;
                                                                                                                                                                                                                    input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                    v65 = v76;
                                                                                                                                                                                                                    // branch -> 0x80526d2
                                                                                                                                                                                                                    goto lab_0x80526d2_27;
                                                                                                                                                                                                                }
                                                                                                                                                                                                                // 0x805203c
                                                                                                                                                                                                                v91 = nextArg;
                                                                                                                                                                                                                v92 = input_file;
                                                                                                                                                                                                                input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                                v65 = v76;
                                                                                                                                                                                                                // branch -> 0x80526d2
                                                                                                                                                                                                                goto lab_0x80526d2_27;
                                                                                                                                                                                                            }
                                                                                                                                                                                                            // 0x805203c
                                                                                                                                                                                                            v91 = nextArg;
                                                                                                                                                                                                            v92 = input_file;
                                                                                                                                                                                                            input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                            v65 = v76;
                                                                                                                                                                                                            // branch -> 0x80526d2
                                                                                                                                                                                                            goto lab_0x80526d2_27;
                                                                                                                                                                                                        }
                                                                                                                                                                                                        // 0x805203c
                                                                                                                                                                                                        v91 = nextArg;
                                                                                                                                                                                                        v92 = input_file;
                                                                                                                                                                                                        input_file = (int32_t)v91 + v92;
                                                                                                                                                                                                        v65 = v76;
                                                                                                                                                                                                        // branch -> 0x80526d2
                                                                                                                                                                                                        goto lab_0x80526d2_27;
                                                                                                                                                                                                    }
                                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                                }
                                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                            }
                                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                        }
                                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                    }
                                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                                }
                                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                            }
                                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                        }
                                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                    }
                                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                                }
                                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                            }
                                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                        }
                                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                    }
                                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                                }
                                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                            }
                                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                        }
                                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                    }
                                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                                }
                                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                            }
                                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                        }
                                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                    }
                                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                                }
                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                            }
                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                        }
                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                    }
                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                }
                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                            }
                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                        }
                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                    }
                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                }
                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                            }
                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                        }
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                          lab_0x80525b1_2:;
                            char v174 = *v77; // 0x80525b41011
                            int32_t v175 = v78 + 1; // 0x80525c11015
                            id3tag_mode = v175;
                            if (v174 == 0) {
                                v65 = v76;
                                goto lab_0x80526d2_27;
                            }
                            while (true) {
                                int32_t v176 = v175;
                                if (*(char *)v175 == 0) {
                                    // 0x8052056
                                    v176 = (int32_t)arg;
                                    // branch -> 0x8052059
                                }
                                char * str9 = (char *)v176; // 0x8052059_0
                                token = str9;
                                int32_t v177;
                                char * v178; // 0x8052588
                                int32_t v179;
                                switch ((int32_t)v174) {
                                    default: {
                                        // 0x8052562
                                        error_printf("%s: unrecognized option -%c\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 63: {
                                        // 0x8052535
                                        long_help(v17, (struct _IO_FILE_4 *)g14, (char *)nogap_tags, 0);
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 66: {
                                        // 0x8052300
                                        nextArg = (char *)1;
                                        lame_set_VBR_max_bitrate_kbps((int32_t)v17, atoi(str9));
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 70: {
                                        // 0x8052326
                                        lame_set_VBR_hard_min((int32_t)v17, 1);
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 83: {
                                        // 0x80523f7
                                        silent = 10;
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 84: {
                                        // 0x8052360
                                        lame_set_bWriteVbrTag((int32_t)v17, 1);
                                        nogap = 1;
                                        disable_wav_header = 0;
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 86: {
                                        // 0x8052142
                                        nextArg = (char *)1;
                                        int32_t v180 = (int32_t)v17; // 0x8052149_0
                                        lame_get_VBR(v180);
                                        if (v180 == 0) {
                                            // 0x8052158
                                            lame_set_VBR((int32_t)v17, 4);
                                            // branch -> 0x805216b
                                        }
                                        // 0x805216b
                                        atof(token);
                                        float80_t v181 = g57; // 0x8052176
                                        g57 = v181;
                                        lame_set_VBR_quality((int32_t)v17, (int32_t)(float32_t)v181);
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 88: {
                                        // 0x8052406
                                        if (sscanf(str9, "%d,%d", &tmp_quality, &v177) == 1) {
                                            // 0x8052431
                                            v177 = tmp_quality;
                                            // branch -> 0x8052588
                                        }
                                        // 0x8052588
                                        nextArg = (char *)1;
                                        // branch -> 0x805258e
                                      lab_0x805258e:;
                                        int32_t v182 = id3tag_mode; // 0x8052591
                                        int32_t v183;
                                        if ((int32_t)token == v182) {
                                            // 0x8052596
                                            id3tag_mode = (int32_t)&g9;
                                            v183 = (int32_t)&g9;
                                            // branch -> 0x80525a3
                                        } else {
                                            // 0x805259f
                                            input_file++;
                                            v183 = v182;
                                            // branch -> 0x80525a3
                                        }
                                        // 0x80525a3
                                        token = (char *)&g9;
                                        nextArg = NULL;
                                        v179 = v183;
                                        // branch -> 0x80525b1
                                      lab_0x80525b1:;
                                        char v184 = *(char *)v179; // 0x80525b4
                                        int32_t v185 = v179 + 1; // 0x80525c1
                                        id3tag_mode = v185;
                                        if (v184 == 0) {
                                            v65 = v76;
                                            // break (via goto) -> 0x80526d2
                                            goto lab_0x80526d2_28;
                                        }
                                        v175 = v185;
                                        v174 = v184;
                                        // continue -> 0x8052047
                                        continue;
                                    }
                                    case 89: {
                                        // 0x8052443
                                        lame_set_experimentalY((int32_t)v17, 1);
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 90: {
                                        // 0x805245b
                                        v177 = 1;
                                        char * items_assigned = (char *)sscanf(str9, "%d", &v177);
                                        nextArg = items_assigned;
                                        v178 = items_assigned;
                                        // branch -> 0x8052588
                                      lab_0x8052588_24:
                                        // 0x8052588
                                        if (v178 != NULL) {
                                            goto lab_0x805258e;
                                        }
                                        // 0x8052588
                                        v179 = id3tag_mode;
                                        // branch -> 0x80525b1
                                        goto lab_0x80525b1;
                                        break;
                                    }
                                    case 97: {
                                        // 0x80523bf
                                        i = 1;
                                        lame_set_mode((int32_t)v17, 3);
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 98: {
                                        // 0x80522c0
                                        nextArg = (char *)1;
                                        lame_set_brate((int32_t)v17, atoi(str9));
                                        int32_t v186 = (int32_t)v17; // 0x80522e1_0
                                        lame_get_brate(v186);
                                        lame_set_VBR_min_bitrate_kbps((int32_t)v17, v186);
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 99: {
                                        // 0x805250b
                                        lame_set_copyright((int32_t)v17, 1);
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 100: {
                                        // 0x80523de
                                        error_printf("WARNING: -%c is obsolete.\n");
                                        // branch -> 0x8052588
                                        break;
                                    }
                                    case 101: {
                                        // 0x8052485
                                        nextArg = (char *)1;
                                        switch (*str9) {
                                            default: {
                                                // 0x80524e5
                                                error_printf("%s: -e emp must be n/5/c not %s\n");
                                                // branch -> 0x8052912
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                break;
                                            }
                                            case 99: {
                                                // 0x80524d0
                                                lame_set_emphasis((int32_t)v17, 3);
                                                // branch -> 0x8052588
                                                break;
                                            }
                                            case 110: {
                                                // 0x80524a6
                                                lame_set_emphasis((int32_t)v17, 0);
                                                // branch -> 0x8052588
                                                break;
                                            }
                                            case 53: {
                                                // 0x80524bb
                                                lame_set_emphasis((int32_t)v17, 1);
                                                // branch -> 0x8052588
                                                break;
                                            }
                                        }
                                      lab_0x8052588_23:
                                        // 0x8052588
                                        v178 = nextArg;
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_24;
                                        break;
                                    }
                                    case 102: {
                                        // 0x8052207
                                        lame_set_quality((int32_t)v17, 7);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 104: {
                                        // 0x805221f
                                        lame_set_quality((int32_t)v17, 2);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 107: {
                                        // 0x80523de
                                        error_printf("WARNING: -%c is obsolete.\n");
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 109: {
                                        // 0x8052075
                                        nextArg = (char *)1;
                                        char v187; // 0x805207f
                                        switch ((int32_t)v187) {
                                            case 97: {
                                                // 0x8052104
                                                lame_set_mode((int32_t)v17, 1);
                                                // branch -> 0x8052588
                                                goto lab_0x8052588_23;
                                                break;
                                            }
                                            case 100: {
                                                // 0x80520b2
                                                lame_set_mode((int32_t)v17, 2);
                                                // branch -> 0x8052588
                                                goto lab_0x8052588_23;
                                                break;
                                            }
                                            case 102: {
                                                // 0x80520c7
                                                lame_set_force_ms((int32_t)v17, 1);
                                                // branch -> 0x80520da
                                            }
                                            case 106: {
                                              lab_0x80520da:
                                                // 0x80520da
                                                lame_set_mode((int32_t)v17, 1);
                                                // branch -> 0x8052588
                                                goto lab_0x8052588_23;
                                                break;
                                            }
                                            case 109: {
                                                // 0x80520ef
                                                lame_set_mode((int32_t)v17, 3);
                                                // branch -> 0x8052588
                                                goto lab_0x8052588_23;
                                                break;
                                            }
                                            case 115: {
                                                // 0x805209a
                                                lame_set_mode((int32_t)v17, 0);
                                                // branch -> 0x8052588
                                                goto lab_0x8052588_23;
                                                break;
                                            }
                                        }
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 111: {
                                        // 0x8052520
                                        lame_set_original((int32_t)v17, 0);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 112: {
                                        // 0x80523a7
                                        lame_set_error_protection((int32_t)v17, 1);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 113: {
                                        // 0x80521c1
                                        nextArg = (char *)1;
                                        int32_t str_as_i2 = atoi(str9); // 0x80521ce
                                        int32_t v188 = str_as_i2 > 0 ? str_as_i2 : 0;
                                        lame_set_quality((int32_t)v17, v188 > 9 ? 9 : v188);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 114: {
                                        // 0x8052389
                                        input_format = 1;
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 115: {
                                        // 0x8052237
                                        nextArg = (char *)1;
                                        atof(str9);
                                        float80_t v189 = g58; // 0x8052249
                                        float64_t v190 = v189;
                                        bool v191 = false;
                                        if (v190 >= 192.0) {
                                            // if_805225b_0_false
                                            v191 = v190 > 192.0 | v190 != 192.0 & v190 <= 192.0;
                                            // branch -> after_if_805225b_0
                                        }
                                        // after_if_805225b_0
                                        float80_t v192; // 0x8052270
                                        if ((v176 & -256 || (int32_t)v191) == 1) {
                                            // 0x805226e
                                            v192 = 1.0L;
                                            // branch -> 0x8052270
                                        } else {
                                            // 0x8052266
                                            g58 = 1000.0L;
                                            v192 = 192.0L;
                                            // branch -> 0x8052270
                                        }
                                        // 0x8052270
                                        g56 = 0.5L;
                                        float80_t v193 = v189 * v192 + 0.5L; // 0x805227c
                                        g57 = v193;
                                        lame_set_in_samplerate((int32_t)v17, (int32_t)v193);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 116: {
                                        // 0x805233e
                                        lame_set_bWriteVbrTag((int32_t)v17, 0);
                                        disable_wav_header = 1;
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 118: {
                                        int32_t v194 = (int32_t)v17; // 0x8052196_0
                                        lame_get_VBR(v194);
                                        if (v194 != 0) {
                                            goto lab_0x8052588_23;
                                        }
                                        // 0x80521a9
                                        lame_set_VBR((int32_t)v17, 4);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 120: {
                                        // 0x8052398
                                        swapbytes = 1;
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 121: {
                                        // 0x8052104
                                        lame_set_mode((int32_t)v17, 1);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 122: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 123: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 124: {
                                        // 0x80520b2
                                        lame_set_mode((int32_t)v17, 2);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 125: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 126: {
                                        // 0x80520c7
                                        lame_set_force_ms((int32_t)v17, 1);
                                        // branch -> 0x80520da
                                        goto lab_0x80520da;
                                        break;
                                    }
                                    case 127: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 128: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 129: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 130: {
                                        // 0x80520da
                                        lame_set_mode((int32_t)v17, 1);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 131: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 132: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 133: {
                                        // 0x80520ef
                                        lame_set_mode((int32_t)v17, 3);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                    case 134: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 135: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 136: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 137: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 138: {
                                        // 0x8052119
                                        error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
                                        // branch -> 0x8052912
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        break;
                                    }
                                    case 139: {
                                        // 0x805209a
                                        lame_set_mode((int32_t)v17, 0);
                                        // branch -> 0x8052588
                                        goto lab_0x8052588_23;
                                        break;
                                    }
                                }
                                // 0x8052588
                                v178 = nextArg;
                                // branch -> 0x8052588
                                goto lab_0x8052588_24;
                            }
                            // 0x80526d2
                            v64 = input_file;
                            v40 = v64 + 1;
                            input_file = v40;
                            if (v40 >= argc) {
                                v37 = v65;
                                // break (via goto) -> 0x80526e2
                                goto lab_0x80526e2_5;
                            }
                            v19 = v40;
                            v20 = v64;
                            v21 = v65;
                            // continue (via goto) -> 0x8050582
                            goto lab_0x8050582_5;
                        }
                        // 0x80526d2
                        v64 = input_file;
                        v40 = v64 + 1;
                        input_file = v40;
                        if (v40 >= argc) {
                            v37 = v65;
                            // break (via goto) -> 0x80526e2
                            goto lab_0x80526e2_5;
                        }
                        v19 = v40;
                        v20 = v64;
                        v21 = v65;
                        // continue (via goto) -> 0x8050582
                        goto lab_0x8050582_5;
                    }
                    // 0x805063c
                    v78 = id3tag_mode;
                    v77 = (char *)v78;
                    if (*v77 == 45) {
                        goto lab_0x805064a;
                    }
                    goto lab_0x80525b1_2;
                }
              lab_0x80526d2_28:
                // 0x80526d2
                v64 = input_file;
                v40 = v64 + 1;
                input_file = v40;
                if (v40 >= argc) {
                    v37 = v65;
                    // break (via goto) -> 0x80526e2
                    goto lab_0x80526e2_5;
                }
                v19 = v40;
                v20 = v64;
                v21 = v65;
                // continue (via goto) -> 0x8050582
                goto lab_0x8050582_5;
            }
          lab_0x80526e2_5:
            // 0x80526e2
            if (v37 == 0) {
                // 0x80526e8
                usage((struct _IO_FILE_4 *)g38, (char *)nogap_tags);
                // branch -> 0x8052912
                // Detected a possible infinite recursion (goto support failed); quitting...
            } else {
                // 0x8052706
                if (*inPath == 45) {
                    // 0x8052710
                    v33 = silent;
                    v34 = v33;
                    if (v33 < 1) {
                        // if_805271c_0_true
                        v34 = 1;
                        // branch -> after_if_805271c_0
                    }
                    // after_if_805271c_0
                    silent = v34;
                    // branch -> 0x8052724
                }
                // 0x8052724
                if (*outPath == 0 && ProgramName == NULL) {
                    // 0x8052738
                    if (*inPath == 45) {
                        // 0x8052742
                        memcpy(outPath, "-", 2);
                        // branch -> 0x80527b3
                    } else {
                        // 0x8052760
                        strncpy(outPath, inPath, 4093);
                        v24 = (int32_t)v17;
                        lame_get_decode_only(v24);
                        if (v24 == 0) {
                            // 0x805279f
                            strcat(outPath, ".mp3");
                            // branch -> 0x80527b3
                        } else {
                            // 0x8052789
                            strcat(outPath, ".wav");
                            // branch -> 0x80527b3
                        }
                        // 0x80527b3
                        if (count_nogap == 0) {
                            // 0x80527b9
                            lame_set_findReplayGain((int32_t)v17, 1);
                            // branch -> 0x80527cc
                        }
                        // 0x80527cc
                        if (autoconvert != 0) {
                            // 0x80527d2
                            v25 = (int32_t)v17;
                            lame_get_bWriteVbrTag(v25);
                            if (v25 != 0 && nogap == 0) {
                                // 0x80527e7
                                console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
                                lame_set_bWriteVbrTag((int32_t)v17, 0);
                                // branch -> 0x8052806
                            }
                        }
                        // 0x8052806
                        if (*outPath == 45) {
                            // 0x8052810
                            lame_set_bWriteVbrTag((int32_t)v17, 0);
                            // branch -> 0x8052823
                        }
                        // 0x8052823
                        v35 = input_format;
                        v36 = v35;
                        if (v35 == 0) {
                            // 0x805282c
                            v31 = filename_to_type(inPath);
                            input_format = v31;
                            v36 = v31;
                            // branch -> 0x805283c
                        }
                        // 0x805283c
                        if (v36 == 8) {
                            // 0x8052846
                            error_printf("sorry, vorbis support in LAME is deprecated.\n");
                            // branch -> 0x8052912
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x805285c
                            v26 = (int32_t)v17;
                            v32 = v26;
                            if (i == 0) {
                                // 0x8052877
                                lame_get_mode(v26);
                                v27 = (int32_t)v17;
                                if (v32 == 3) {
                                    // 0x8052887
                                    lame_set_num_channels(v27, 1);
                                    // branch -> 0x80528af
                                } else {
                                    // 0x805289c
                                    lame_set_num_channels(v27, 2);
                                    // branch -> 0x80528af
                                }
                                // 0x80528af
                                v28 = (int32_t)v17;
                                lame_get_free_format(v28);
                                if (v28 == 0) {
                                    // 0x80528ff
                                    if (num_nogap != NULL) {
                                        // 0x8052905
                                        *num_nogap = (int32_t)ProgramName;
                                        // branch -> 0x805290d
                                    }
                                    // 0x805290d
                                    // branch -> 0x8052912
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x80528be
                                    v29 = (int32_t)v17;
                                    lame_get_brate(v29);
                                    if (v29 >= 8) {
                                        // 0x80528ce
                                        v30 = (int32_t)v17;
                                        lame_get_brate(v30);
                                        if (v30 < 641) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x80528e0
                                    error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                    error_printf("with the -b <bitrate> option\n");
                                    // branch -> 0x8052912
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x8052862
                                lame_set_num_channels(v26, 2);
                                // branch -> 0x80528af
                            }
                            // 0x80528af
                            v28 = (int32_t)v17;
                            lame_get_free_format(v28);
                            if (v28 == 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x80528be
                                v29 = (int32_t)v17;
                                lame_get_brate(v29);
                                if (v29 >= 8) {
                                    // 0x80528ce
                                    v30 = (int32_t)v17;
                                    lame_get_brate(v30);
                                    if (v30 < 641) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x80528e0
                                error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                error_printf("with the -b <bitrate> option\n");
                                // branch -> 0x8052912
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x80527b3
                    if (count_nogap == 0) {
                        // 0x80527b9
                        lame_set_findReplayGain((int32_t)v17, 1);
                        // branch -> 0x80527cc
                    }
                    // 0x80527cc
                    if (autoconvert != 0) {
                        // 0x80527d2
                        v25 = (int32_t)v17;
                        lame_get_bWriteVbrTag(v25);
                        if (v25 != 0 && nogap == 0) {
                            // 0x80527e7
                            console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
                            lame_set_bWriteVbrTag((int32_t)v17, 0);
                            // branch -> 0x8052806
                        }
                    }
                    // 0x8052806
                    if (*outPath == 45) {
                        // 0x8052810
                        lame_set_bWriteVbrTag((int32_t)v17, 0);
                        // branch -> 0x8052823
                    }
                    // 0x8052823
                    v35 = input_format;
                    v36 = v35;
                    if (v35 == 0) {
                        // 0x805282c
                        v31 = filename_to_type(inPath);
                        input_format = v31;
                        v36 = v31;
                        // branch -> 0x805283c
                    }
                    // 0x805283c
                    if (v36 == 8) {
                        // 0x8052846
                        error_printf("sorry, vorbis support in LAME is deprecated.\n");
                        // branch -> 0x8052912
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x805285c
                        v26 = (int32_t)v17;
                        v32 = v26;
                        if (i == 0) {
                            // 0x8052877
                            lame_get_mode(v26);
                            v27 = (int32_t)v17;
                            if (v32 == 3) {
                                // 0x8052887
                                lame_set_num_channels(v27, 1);
                                // branch -> 0x80528af
                            } else {
                                // 0x805289c
                                lame_set_num_channels(v27, 2);
                                // branch -> 0x80528af
                            }
                            // 0x80528af
                            v28 = (int32_t)v17;
                            lame_get_free_format(v28);
                            if (v28 == 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x80528be
                                v29 = (int32_t)v17;
                                lame_get_brate(v29);
                                if (v29 >= 8) {
                                    // 0x80528ce
                                    v30 = (int32_t)v17;
                                    lame_get_brate(v30);
                                    if (v30 < 641) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x80528e0
                                error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                                error_printf("with the -b <bitrate> option\n");
                                // branch -> 0x8052912
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x8052862
                            lame_set_num_channels(v26, 2);
                            // branch -> 0x80528af
                        }
                        // 0x80528af
                        v28 = (int32_t)v17;
                        lame_get_free_format(v28);
                        if (v28 == 0) {
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x80528be
                            v29 = (int32_t)v17;
                            lame_get_brate(v29);
                            if (v29 >= 8) {
                                // 0x80528ce
                                v30 = (int32_t)v17;
                                lame_get_brate(v30);
                                if (v30 < 641) {
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x80528e0
                            error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                            error_printf("with the -b <bitrate> option\n");
                            // branch -> 0x8052912
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x80527b3
                if (count_nogap == 0) {
                    // 0x80527b9
                    lame_set_findReplayGain((int32_t)v17, 1);
                    // branch -> 0x80527cc
                }
                // 0x80527cc
                if (autoconvert != 0) {
                    // 0x80527d2
                    v25 = (int32_t)v17;
                    lame_get_bWriteVbrTag(v25);
                    if (v25 != 0 && nogap == 0) {
                        // 0x80527e7
                        console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
                        lame_set_bWriteVbrTag((int32_t)v17, 0);
                        // branch -> 0x8052806
                    }
                }
                // 0x8052806
                if (*outPath == 45) {
                    // 0x8052810
                    lame_set_bWriteVbrTag((int32_t)v17, 0);
                    // branch -> 0x8052823
                }
                // 0x8052823
                v35 = input_format;
                v36 = v35;
                if (v35 == 0) {
                    // 0x805282c
                    v31 = filename_to_type(inPath);
                    input_format = v31;
                    v36 = v31;
                    // branch -> 0x805283c
                }
                // 0x805283c
                if (v36 == 8) {
                    // 0x8052846
                    error_printf("sorry, vorbis support in LAME is deprecated.\n");
                    // branch -> 0x8052912
                    // Detected a possible infinite recursion (goto support failed); quitting...
                } else {
                    // 0x805285c
                    v26 = (int32_t)v17;
                    v32 = v26;
                    if (i == 0) {
                        // 0x8052877
                        lame_get_mode(v26);
                        v27 = (int32_t)v17;
                        if (v32 == 3) {
                            // 0x8052887
                            lame_set_num_channels(v27, 1);
                            // branch -> 0x80528af
                        } else {
                            // 0x805289c
                            lame_set_num_channels(v27, 2);
                            // branch -> 0x80528af
                        }
                        // 0x80528af
                        v28 = (int32_t)v17;
                        lame_get_free_format(v28);
                        if (v28 == 0) {
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x80528be
                            v29 = (int32_t)v17;
                            lame_get_brate(v29);
                            if (v29 >= 8) {
                                // 0x80528ce
                                v30 = (int32_t)v17;
                                lame_get_brate(v30);
                                if (v30 < 641) {
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x80528e0
                            error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                            error_printf("with the -b <bitrate> option\n");
                            // branch -> 0x8052912
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x8052862
                        lame_set_num_channels(v26, 2);
                        // branch -> 0x80528af
                    }
                    // 0x80528af
                    v28 = (int32_t)v17;
                    lame_get_free_format(v28);
                    if (v28 == 0) {
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x80528be
                        v29 = (int32_t)v17;
                        lame_get_brate(v29);
                        if (v29 >= 8) {
                            // 0x80528ce
                            v30 = (int32_t)v17;
                            lame_get_brate(v30);
                            if (v30 < 641) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x80528e0
                        error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
                        error_printf("with the -b <bitrate> option\n");
                        // branch -> 0x8052912
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
    } else {
        // 0x80526e8
        usage((struct _IO_FILE_4 *)g38, (char *)nogap_tags);
        // branch -> 0x8052912
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/portableio.c
// Address range: 0x8052945 - 0x8052994
// Line range:    127 - 140
int32_t Read16BitsLowHigh(struct _IO_FILE_5 * fp) {
    uint32_t v1 = _IO_getc((struct _IO_FILE *)fp); // 0x8052951
    int32_t v2 = 256 * (_IO_getc((struct _IO_FILE *)fp) % 256); // 0x8052974
    int32_t v3 = v2 | v1 % 256; // 0x8052977
    int32_t result; // 0x8052990
    if ((v2 & 0x8000) != 0) {
        // 0x8052989
        result = v3 | -0x10000;
        // branch -> 0x8052990
    } else {
        result = v3;
    }
    // 0x8052990
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/portableio.c
// Address range: 0x8052995 - 0x80529e4
// Line range:    157 - 191
int32_t Read16BitsHighLow(struct _IO_FILE_5 * fp) {
    int32_t v1 = _IO_getc((struct _IO_FILE *)fp); // 0x80529a1
    int32_t v2 = _IO_getc((struct _IO_FILE *)fp) % 256; // 0x80529b9
    int32_t v3 = 256 * v1; // 0x80529a6
    int32_t v4 = v2 | v3 & 0xff00; // 0x80529c7
    int32_t result; // 0x80529e0
    if ((v3 & 0x8000) != 0) {
        // 0x80529d9
        result = v4 | -0x10000;
        // branch -> 0x80529e0
    } else {
        result = v4;
    }
    // 0x80529e0
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/portableio.c
// Address range: 0x8052a02 - 0x8052a36
// Line range:    202 - 206
void Write16BitsLowHigh(struct _IO_FILE_5 * fp, uint32_t i) {
    // 0x8052a02
    _IO_putc(i % 256, (struct _IO_FILE *)fp);
    _IO_putc(i / 256 % 256, (struct _IO_FILE *)fp);
    int32_t v1;
    g2 = v1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/portableio.c
// Address range: 0x8052ada - 0x8052b16
// Line range:    264 - 277
int32_t Read32Bits(struct _IO_FILE_5 * fp) {
    uint32_t v1 = Read16BitsLowHigh(fp); // 0x8052ae6
    return 0x10000 * Read16BitsLowHigh(fp) | v1 % 0x10000;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/portableio.c
// Address range: 0x8052b17 - 0x8052b53
// Line range:    297 - 310
int32_t Read32BitsHighLow(struct _IO_FILE_5 * fp) {
    int32_t v1 = Read16BitsHighLow(fp); // 0x8052b23
    return Read16BitsHighLow(fp) % 0x10000 | 0x10000 * v1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/portableio.c
// Address range: 0x8052b88 - 0x8052bbb
// Line range:    323 - 327
void Write32BitsLowHigh(struct _IO_FILE_5 * fp, uint32_t i) {
    // 0x8052b88
    Write16BitsLowHigh(fp, i % 0x10000);
    Write16BitsLowHigh(fp, i / 0x10000);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/portableio.c
// Address range: 0x8052bf0 - 0x8052c30
// Line range:    346 - 352
void ReadBytes(struct _IO_FILE_5 * fp, char * p, int32_t n) {
    int32_t is_feof = feof((struct _IO_FILE *)fp); // 0x8052c14
    // branch -> 0x8052c0e
    while (((g4 & -256 || (int32_t)(is_feof == 0)) & ((is_feof & -256 || (int32_t)(n < 1)) ^ 1)) != 0) {
        // 0x8052c0e
        int32_t v1 = 0x1000000 * _IO_getc((struct _IO_FILE *)fp) / 0x1000000;
        g4 = v1;
        *p = (char)v1;
        n--;
        p = (char *)((int32_t)p + 1);
        is_feof = feof((struct _IO_FILE *)fp);
        // branch -> 0x8052c0e
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/portableio.c
// Address range: 0x8052d11 - 0x8052e8a
// Line range:    431 - 477
float64_t ConvertFromIeeeExtended(char * bytes) {
    // 0x8052d11
    int32_t v1;
    int32_t hiMant = v1; // bp-24
    int32_t v2 = (int32_t)bytes; // 0x8052d17_0
    unsigned char v3 = *(char *)(v2 + 1); // 0x8052d2e
    int32_t v4 = 256 * (int32_t)*bytes & 0x7f00 | (int32_t)v3; // 0x8052d39
    char v5 = *(char *)(v2 + 2); // 0x8052d44
    unsigned char v6 = *(char *)(v2 + 3); // 0x8052d55
    char v7 = *(char *)(v2 + 4); // 0x8052d6b
    unsigned char v8 = *(char *)(v2 + 5); // 0x8052d81
    int32_t v9 = 256 * (int32_t)v7 & 0xff00 | 0x10000 * (int32_t)v6 | 0x1000000 * (int32_t)v5 | (int32_t)v8; // 0x8052d8c
    char v10 = *(char *)(v2 + 6); // 0x8052d97
    unsigned char v11 = *(char *)(v2 + 7); // 0x8052da8
    char v12 = *(char *)(v2 + 8); // 0x8052dbe
    unsigned char v13 = *(char *)(v2 + 9); // 0x8052dd4
    int32_t v14 = 256 * (int32_t)v12 & 0xff00 | 0x10000 * (int32_t)v11 | 0x1000000 * (int32_t)v10 | (int32_t)v13; // 0x8052ddf
    hiMant = v14;
    float80_t result; // 0x8052e8a_2
    float80_t v15;
    float80_t v16; // 0x8052e41
    float80_t v17; // 0x8052e70
    switch ((int15_t)v4) {
        case 0: {
            // 0x8052dea
            if ((v9 || v14) == 0) {
                // 0x8052df6
                v15 = 0.0L;
                // branch -> 0x8052e75
                // 0x8052e75
                if (*bytes == 0) {
                    // 0x8052e7f
                    g59 = -v15;
                    result = g58;
                    // branch -> 0x8052e89
                } else {
                    // 0x8052e86
                    result = v15;
                    // branch -> 0x8052e89
                }
                // 0x8052e89
                return result;
            }
            // 0x8052e11
            ldexp((float64_t)((float80_t)(v9 ^ -0x80000000) + 2147483648.0L), v4 - 0x401e);
            v16 = g58;
            ldexp((float64_t)((float80_t)(hiMant ^ -0x80000000) + 2147483648.0L), v4 - 0x403e);
            g58 = v16;
            v17 = v16 + g59;
            g59 = v17;
            v15 = v17;
            // branch -> 0x8052e75
            // 0x8052e75
            if (*bytes == 0) {
                // 0x8052e7f
                g59 = -v15;
                result = g58;
                // branch -> 0x8052e89
            } else {
                // 0x8052e86
                result = v15;
                // branch -> 0x8052e89
            }
            // 0x8052e89
            return result;
        }
        case -1: {
            // 0x8052e06
            v15 = INFINITY;
            // branch -> 0x8052e75
            // 0x8052e75
            if (*bytes == 0) {
                // 0x8052e7f
                g59 = -v15;
                result = g58;
                // branch -> 0x8052e89
            } else {
                // 0x8052e86
                result = v15;
                // branch -> 0x8052e89
            }
            // 0x8052e89
            return result;
        }
    }
    // 0x8052e11
    ldexp((float64_t)((float80_t)(v9 ^ -0x80000000) + 2147483648.0L), v4 - 0x401e);
    v16 = g58;
    ldexp((float64_t)((float80_t)(hiMant ^ -0x80000000) + 2147483648.0L), v4 - 0x403e);
    g58 = v16;
    v17 = v16 + g59;
    g59 = v17;
    v15 = v17;
    // branch -> 0x8052e75
    // 0x8052e75
    if (*bytes == 0) {
        // 0x8052e7f
        g59 = -v15;
        result = g58;
        // branch -> 0x8052e89
    } else {
        // 0x8052e86
        result = v15;
        // branch -> 0x8052e89
    }
    // 0x8052e89
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/portableio.c
// Address range: 0x8052e8b - 0x8052edb
// Line range:    484 - 490
float64_t ReadIeeeExtendedHighLow(struct _IO_FILE_5 * fp) {
    int32_t v1;
    ReadBytes(fp, (char *)&v1, 10);
    float80_t v2 = ConvertFromIeeeExtended((char *)&v1); // 0x8052ec2_3
    g58 = v2;
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8052ed3
        g58 = v2;
        __stack_chk_fail();
        // branch -> 0x8052eda
    }
    // 0x8052eda
    return g59;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/timestatus.c
// Address range: 0x8052edc - 0x8052f46
// Line range:    73 - 89
void ts_calc_times(struct anon_struct_6 * tstime, int32_t sample_freq, uint32_t frameNum, int32_t totalframes, int32_t framesize) {
    int32_t v1 = (int32_t)tstime;
    if (frameNum < 1) {
        // 0x8052f35
        *(float64_t *)(v1 + 16) = 0.0;
        *(float64_t *)(v1 + 24) = 0.0;
        // branch -> 0x8052f45
        // 0x8052f45
        return;
    }
    float64_t * v2 = (float64_t *)(v1 + 8); // 0x8052eeb_0
    float64_t v3 = *v2; // 0x8052eeb
    bool v4 = false;
    bool v5 = false; // 0x8052ef6
    if (v3 <= 0.0) {
        // if_8052ef2_0_false
        if (v3 >= 0.0) {
            // if_8052ef2_1_false
            v4 = v3 != 0.0;
            v5 = true;
            // branch -> after_if_8052ef2_0
        } else {
            v4 = true;
            v5 = false;
        }
    }
    // after_if_8052ef2_0
    if (((int32_t)(v5 || v4) || v1 & -256) == 1) {
        // 0x8052f35
        *(float64_t *)(v1 + 16) = 0.0;
        *(float64_t *)(v1 + 24) = 0.0;
        // branch -> 0x8052f45
        // 0x8052f45
        return;
    }
    float64_t v6 = *v2; // 0x8052f00
    *(float64_t *)(v1 + 16) = (float64_t)((float80_t)totalframes * (float80_t)v6 / (float80_t)frameNum);
    float64_t v7 = *v2; // 0x8052f26
    *(float64_t *)(v1 + 24) = (float64_t)((float80_t)(framesize * frameNum) / ((float80_t)sample_freq * (float80_t)v7));
    // branch -> 0x8052f45
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/timestatus.c
// Address range: 0x8052f47 - 0x805303e
// Line range:    96 - 108
void ts_time_decompose(uint32_t time_in_sec, char padded_char) {
    // 0x8052f47
    if (time_in_sec < 3600) {
        // 0x8052fcd
        g1 = console_printf("   %2u:%02u%c");
        // branch -> 0x805303d
        // 0x805303d
        return;
    }
    // 0x8052ff1
    if (time_in_sec > 0x57e3f) {
        // 0x8053022
        g1 = console_printf("%6lu h%c");
        // branch -> 0x805303d
    } else {
        // 0x8052ff7
        g1 = console_printf("%2lu:%02u:%02u%c");
        // branch -> 0x805303d
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/timestatus.c
// Address range: 0x805303f - 0x8053375
// Line range:    111 - 183
void timestatus(struct lame_global_struct_3 * gfp) {
    // 0x805303f
    int32_t v1;
    int32_t totalframes = v1; // bp-32
    int32_t v2;
    int32_t frameNum = v2; // bp-28
    int32_t v3;
    int32_t samp_rate = v3; // bp-24
    int32_t v4;
    int32_t percent = v4; // bp-20
    int32_t v5 = (int32_t)gfp; // 0x8053045_0
    lame_get_out_samplerate(v5);
    percent = v5;
    int32_t v6 = (int32_t)gfp; // 0x8053053_0
    lame_get_frameNum(v6);
    samp_rate = v6;
    int32_t v7 = (int32_t)gfp; // 0x8053061_0
    lame_get_totalframes(v7);
    frameNum = v7;
    int32_t v8 = (int32_t)gfp; // 0x805306f_0
    lame_get_framesize(v8);
    totalframes = v8;
    if (frameNum < samp_rate) {
        // 0x8053085
        frameNum = samp_rate;
        // branch -> 0x805308b
    }
    // 0x805308b
    if (samp_rate == 0) {
        // 0x8053091
        *(float64_t *)&g23 = GetRealTime();
        g26 = GetCPUTime();
        g24 = 0.0;
        g27 = 0.0;
        // branch -> 0x80530b7
    }
    // 0x80530b7
    GetRealTime();
    float80_t v9 = g56; // 0x80530bc
    float64_t v10 = v9;
    float64_t v11 = v9 - (float80_t)*(float64_t *)&g23;
    int32_t v12;
    int32_t v13;
    bool v14;
    int32_t v15;
    float64_t v16;
    float64_t v17;
    float64_t v18;
    bool v19; // 0x8053119
    float64_t v20; // 0x8053309
    int32_t v21; // 0x80531c7
    int32_t v22; // 0x805323255
    float80_t v23; // 0x8053340
    int32_t v24; // 0x80531ca
    float80_t v25; // 0x80530ff
    uint32_t v26; // 0x805313d
    int32_t v27; // 0x80531f7
    float80_t v28; // 0x8053346
    if (v11 >= 0.0) {
        // if_80530d2_0_false
        bool v29;
        bool v30; // 0x80530d6
        if (v11 <= 0.0) {
            // if_80530d2_1_false
            v29 = v11 != 0.0;
            v30 = true;
            // branch -> after_if_80530d2_0
        } else {
            v29 = true;
            v30 = false;
        }
        // after_if_80530d2_0
        v16 = v11;
        if (((int32_t)(v30 || v29) || g1 & -256) != 1) {
            // 0x80530dd
            v16 = 0.0;
            // branch -> 0x80530e2
        }
        // 0x80530e2
        g24 = (float80_t)v16 + (float80_t)g24;
        *(float64_t *)&g23 = v10;
        GetCPUTime();
        v25 = g57;
        v17 = v25 - (float80_t)g26;
        g56 = 0.0L;
        v14 = false;
        v19 = false;
        if (v17 >= 0.0) {
            // if_8053115_0_false
            if (v17 <= 0.0) {
                // if_8053115_1_false
                v14 = v17 != 0.0;
                v19 = true;
                // branch -> after_if_8053115_0
            } else {
                v14 = true;
                v19 = false;
            }
        }
        // after_if_8053115_0
        v18 = v17;
        if (((int32_t)(v19 || v14) || g1 & -256) != 1) {
            // 0x8053120
            v18 = 0.0;
            // branch -> 0x8053125
        }
        // 0x8053125
        g27 = (float80_t)v18 + (float80_t)g27;
        g57 = v25;
        g26 = v25;
        v26 = samp_rate;
        if (v26 == 0) {
            // 0x8053143
            if (g30 == 0) {
                // 0x805314c
                console_printf("\r    Frame          |  CPU time/estim | REAL time/estim | play/CPU |    ETA \n     0/       ( 0%%)|    0:00/     :  |    0:00/     :  |         x|     :  \r");
                g30 = 1;
                // branch -> 0x8053374
                // 0x8053374
                return;
            }
        } else {
            // 0x8053167
            if (v26 >= 1) {
                // 0x805316d
                g30 = 0;
                // branch -> 0x8053177
            }
        }
        // 0x8053177
        ts_calc_times((struct anon_struct_6 *)&g23, percent, v26, frameNum, totalframes);
        ts_calc_times((struct anon_struct_6 *)&g26, percent, samp_rate, frameNum, totalframes);
        v21 = samp_rate;
        v24 = frameNum;
        v22 = 100;
        if (v21 < v24) {
            // 0x80531cf
            v27 = 100.0L * (float80_t)v21 / (float80_t)v24 + 0.5L;
            v22 = v27;
            // branch -> 0x8053206
        }
        // 0x8053206
        console_printf("\r%6i/%-6i");
        v12 = v22 > 99 ? (int32_t)"(%3.3d%%)|" : (int32_t)" (%2d%%)|";
        console_printf((char *)v12);
        ts_time_decompose((int32_t)g27, 47);
        ts_time_decompose((int32_t)g28, 124);
        ts_time_decompose((int32_t)g24, 47);
        ts_time_decompose((int32_t)g25, 124);
        v20 = g29;
        v15 = 0;
        if (v20 >= 1.0) {
            // if_8053317_0_false
            if (v20 <= 1.0) {
                // if_8053317_1_false
                v15 = v20 != 1.0;
                // branch -> after_if_8053317_0
            } else {
                v15 = 1;
            }
        }
        // after_if_8053317_0
        v13 = (g1 & -256 | v15) == 1 ? (int32_t)"%#9.5gx|" : (int32_t)"%9.4fx|";
        console_printf((char *)v13);
        v23 = g24;
        g56 = v23;
        v28 = (float80_t)g25 - v23;
        g57 = v28;
        ts_time_decompose((int32_t)v28, 32);
        // branch -> 0x8053374
        // 0x8053374
        return;
    }
    // after_if_80530d2_0
    v16 = v11;
    if (((int32_t)0 || g1 & -256) != 1) {
        // 0x80530dd
        v16 = 0.0;
        // branch -> 0x80530e2
    }
    // 0x80530e2
    g24 = (float80_t)v16 + (float80_t)g24;
    *(float64_t *)&g23 = v10;
    GetCPUTime();
    v25 = g57;
    float64_t v31 = v25;
    v17 = v25 - (float80_t)g26;
    g56 = 0.0L;
    if (v17 >= 0.0) {
        // if_8053115_0_false
        if (v17 <= 0.0) {
            // if_8053115_1_false
            v14 = v17 != 0.0;
            v19 = true;
            // branch -> after_if_8053115_0
        } else {
            v14 = true;
            v19 = false;
        }
        // after_if_8053115_0
        v18 = v17;
        if (((int32_t)(v19 || v14) || g1 & -256) != 1) {
            // 0x8053120
            v18 = 0.0;
            // branch -> 0x8053125
        }
        // 0x8053125
        g27 = (float80_t)v18 + (float80_t)g27;
        g57 = v25;
        g26 = v31;
        v26 = samp_rate;
        if (v26 == 0) {
            // 0x8053143
            if (g30 == 0) {
                // 0x805314c
                console_printf("\r    Frame          |  CPU time/estim | REAL time/estim | play/CPU |    ETA \n     0/       ( 0%%)|    0:00/     :  |    0:00/     :  |         x|     :  \r");
                g30 = 1;
                // branch -> 0x8053374
                // 0x8053374
                return;
            }
        } else {
            // 0x8053167
            if (v26 >= 1) {
                // 0x805316d
                g30 = 0;
                // branch -> 0x8053177
            }
        }
        // 0x8053177
        ts_calc_times((struct anon_struct_6 *)&g23, percent, v26, frameNum, totalframes);
        ts_calc_times((struct anon_struct_6 *)&g26, percent, samp_rate, frameNum, totalframes);
        v21 = samp_rate;
        v24 = frameNum;
        v22 = 100;
        if (v21 < v24) {
            // 0x80531cf
            v27 = 100.0L * (float80_t)v21 / (float80_t)v24 + 0.5L;
            v22 = v27;
            // branch -> 0x8053206
        }
        // 0x8053206
        console_printf("\r%6i/%-6i");
        v12 = v22 > 99 ? (int32_t)"(%3.3d%%)|" : (int32_t)" (%2d%%)|";
        console_printf((char *)v12);
        ts_time_decompose((int32_t)g27, 47);
        ts_time_decompose((int32_t)g28, 124);
        ts_time_decompose((int32_t)g24, 47);
        ts_time_decompose((int32_t)g25, 124);
        v20 = g29;
        v15 = 0;
        if (v20 >= 1.0) {
            // if_8053317_0_false
            if (v20 <= 1.0) {
                // if_8053317_1_false
                v15 = v20 != 1.0;
                // branch -> after_if_8053317_0
            } else {
                v15 = 1;
            }
        }
        // after_if_8053317_0
        v13 = (g1 & -256 | v15) == 1 ? (int32_t)"%#9.5gx|" : (int32_t)"%9.4fx|";
        console_printf((char *)v13);
        v23 = g24;
        g56 = v23;
        v28 = (float80_t)g25 - v23;
        g57 = v28;
        ts_time_decompose((int32_t)v28, 32);
        // branch -> 0x8053374
        // 0x8053374
        return;
    }
    // after_if_8053115_0
    v18 = v17;
    if (((int32_t)0 || g1 & -256) != 1) {
        // 0x8053120
        v18 = 0.0;
        // branch -> 0x8053125
    }
    // 0x8053125
    g27 = (float80_t)v18 + (float80_t)g27;
    g57 = v25;
    g26 = v31;
    v26 = samp_rate;
    if (v26 != 0) {
        // 0x8053167
        if (v26 >= 1) {
            // 0x805316d
            g30 = 0;
            // branch -> 0x8053177
        }
        // 0x8053177
        ts_calc_times((struct anon_struct_6 *)&g23, percent, v26, frameNum, totalframes);
        ts_calc_times((struct anon_struct_6 *)&g26, percent, samp_rate, frameNum, totalframes);
        v21 = samp_rate;
        v24 = frameNum;
        v22 = 100;
        if (v21 < v24) {
            // 0x80531cf
            v27 = 100.0L * (float80_t)v21 / (float80_t)v24 + 0.5L;
            v22 = v27;
            // branch -> 0x8053206
        }
        // 0x8053206
        console_printf("\r%6i/%-6i");
        v12 = v22 > 99 ? (int32_t)"(%3.3d%%)|" : (int32_t)" (%2d%%)|";
        console_printf((char *)v12);
        ts_time_decompose((int32_t)g27, 47);
        ts_time_decompose((int32_t)g28, 124);
        ts_time_decompose((int32_t)g24, 47);
        ts_time_decompose((int32_t)g25, 124);
        v20 = g29;
        v15 = 0;
        if (v20 >= 1.0) {
            // if_8053317_0_false
            if (v20 <= 1.0) {
                // if_8053317_1_false
                v15 = v20 != 1.0;
                // branch -> after_if_8053317_0
            } else {
                v15 = 1;
            }
        }
        // after_if_8053317_0
        v13 = (g1 & -256 | v15) == 1 ? (int32_t)"%#9.5gx|" : (int32_t)"%9.4fx|";
        console_printf((char *)v13);
        v23 = g24;
        g56 = v23;
        v28 = (float80_t)g25 - v23;
        g57 = v28;
        ts_time_decompose((int32_t)v28, 32);
        // branch -> 0x8053374
        // 0x8053374
        return;
    }
    // 0x8053143
    if (g30 == 0) {
        // 0x805314c
        console_printf("\r    Frame          |  CPU time/estim | REAL time/estim | play/CPU |    ETA \n     0/       ( 0%%)|    0:00/     :  |    0:00/     :  |         x|     :  \r");
        g30 = 1;
        // branch -> 0x8053374
        // 0x8053374
        return;
    }
    // 0x8053177
    ts_calc_times((struct anon_struct_6 *)&g23, percent, v26, frameNum, totalframes);
    ts_calc_times((struct anon_struct_6 *)&g26, percent, samp_rate, frameNum, totalframes);
    v21 = samp_rate;
    v24 = frameNum;
    v22 = 100;
    if (v21 < v24) {
        // 0x80531cf
        v27 = 100.0L * (float80_t)v21 / (float80_t)v24 + 0.5L;
        v22 = v27;
        // branch -> 0x8053206
    }
    // 0x8053206
    console_printf("\r%6i/%-6i");
    v12 = v22 > 99 ? (int32_t)"(%3.3d%%)|" : (int32_t)" (%2d%%)|";
    console_printf((char *)v12);
    ts_time_decompose((int32_t)g27, 47);
    ts_time_decompose((int32_t)g28, 124);
    ts_time_decompose((int32_t)g24, 47);
    ts_time_decompose((int32_t)g25, 124);
    v20 = g29;
    if (v20 < 1.0) {
        // after_if_8053317_0
        v13 = (g1 & -256) == 1 ? (int32_t)"%#9.5gx|" : (int32_t)"%9.4fx|";
        console_printf((char *)v13);
        v23 = g24;
        g56 = v23;
        v28 = (float80_t)g25 - v23;
        g57 = v28;
        ts_time_decompose((int32_t)v28, 32);
        // branch -> 0x8053374
        // 0x8053374
        return;
    }
    // if_8053317_0_false
    if (v20 <= 1.0) {
        // if_8053317_1_false
        v15 = v20 != 1.0;
        // branch -> after_if_8053317_0
    } else {
        v15 = 1;
    }
    // after_if_8053317_0
    v13 = (g1 & -256 | v15) == 1 ? (int32_t)"%#9.5gx|" : (int32_t)"%9.4fx|";
    console_printf((char *)v13);
    v23 = g24;
    g56 = v23;
    v28 = (float80_t)g25 - v23;
    g57 = v28;
    ts_time_decompose((int32_t)v28, 32);
    // branch -> 0x8053374
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/timestatus.c
// Address range: 0x8053376 - 0x8053389
// Line range:    186 - 189
void timestatus_finish(void) {
    // 0x8053376
    console_printf("\n");
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/timestatus.c
// Address range: 0x805338a - 0x80537bd
// Line range:    193 - 255
void encoder_progress_begin(struct lame_global_struct_3 * gf, char * inPath, char * outPath) {
    // 0x805338a
    if (silent > 9) {
        // 0x80537b6
        return;
    }
    // 0x80533a1
    lame_print_config((int32_t)gf);
    strcmp(outPath, "-");
    strlen(inPath);
    strlen(outPath);
    strcmp(inPath, "-");
    console_printf("Encoding %s%s to %s\n");
    int32_t v1 = (int32_t)gf; // 0x8053432_0
    lame_get_out_samplerate(v1);
    g58 = 0.001L;
    g59 = 0.001L * (float80_t)v1;
    console_printf("Encoding as %g kHz ");
    int32_t v2 = (int32_t)gf; // 0x805345b_0
    lame_get_VBR(v2);
    if (v2 == 2) {
        // 0x8053495
        lame_get_quality((int32_t)gf);
        lame_get_VBR_quality((int32_t)gf);
        lame_get_out_samplerate((int32_t)gf);
        lame_get_version((int32_t)gf);
        lame_get_force_ms((int32_t)gf);
        lame_get_mode((int32_t)gf);
        console_printf("%s MPEG-%u%s Layer III VBR(q=%g) qval=%i\n");
        // branch -> 0x80537a1
        // 0x80537a1
        if (silent <= 0xfffffff6) {
            // 0x80537ab
            lame_print_internals((int32_t)gf);
            // branch -> 0x80537b6
        }
        // 0x80537b6
        return;
    }
    // 0x805346b
    if (v2 <= 2) {
        // 0x8053470
        if (v2 == 1) {
            // 0x8053539
            lame_get_VBR_quality((int32_t)gf);
            lame_get_out_samplerate((int32_t)gf);
            lame_get_version((int32_t)gf);
            lame_get_force_ms((int32_t)gf);
            lame_get_mode((int32_t)gf);
            console_printf("%s MPEG-%u%s Layer III VBR(q=%g)\n");
            // branch -> 0x80537a1
        } else {
            // 0x80536b6
            lame_get_quality((int32_t)gf);
            lame_get_brate((int32_t)gf);
            lame_get_compression_ratio((int32_t)gf);
            lame_get_out_samplerate((int32_t)gf);
            lame_get_version((int32_t)gf);
            lame_get_force_ms((int32_t)gf);
            lame_get_mode((int32_t)gf);
            console_printf("%s MPEG-%u%s Layer III (%gx) %3d kbps qval=%i\n");
            // branch -> 0x80537a1
        }
        // 0x80537a1
        if (silent <= 0xfffffff6) {
            // 0x80537ab
            lame_print_internals((int32_t)gf);
            // branch -> 0x80537b6
        }
        // 0x80537b6
        return;
    }
    // 0x805347e
    switch (v2) {
        case 3: {
            // 0x80535c6
            lame_get_quality((int32_t)gf);
            lame_get_VBR_mean_bitrate_kbps((int32_t)gf);
            lame_get_compression_ratio((int32_t)gf);
            lame_get_out_samplerate((int32_t)gf);
            lame_get_version((int32_t)gf);
            lame_get_force_ms((int32_t)gf);
            lame_get_mode((int32_t)gf);
            console_printf("%s MPEG-%u%s Layer III (%gx) average %d kbps qval=%i\n");
            // branch -> 0x80537a1
            break;
        }
        case 4: {
            // 0x8053539
            lame_get_VBR_quality((int32_t)gf);
            lame_get_out_samplerate((int32_t)gf);
            lame_get_version((int32_t)gf);
            lame_get_force_ms((int32_t)gf);
            lame_get_mode((int32_t)gf);
            console_printf("%s MPEG-%u%s Layer III VBR(q=%g)\n");
            // branch -> 0x80537a1
            break;
        }
    }
    // 0x80536b6
    lame_get_quality((int32_t)gf);
    lame_get_brate((int32_t)gf);
    lame_get_compression_ratio((int32_t)gf);
    lame_get_out_samplerate((int32_t)gf);
    lame_get_version((int32_t)gf);
    lame_get_force_ms((int32_t)gf);
    lame_get_mode((int32_t)gf);
    console_printf("%s MPEG-%u%s Layer III (%gx) %3d kbps qval=%i\n");
    // branch -> 0x80537a1
    // 0x80537a1
    if (silent <= 0xfffffff6) {
        // 0x80537ab
        lame_print_internals((int32_t)gf);
        // branch -> 0x80537b6
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/timestatus.c
// Address range: 0x80537be - 0x80538ae
// Line range:    258 - 291
void encoder_progress(struct lame_global_struct_3 * gf) {
    int32_t v1 = g3; // 0x80537c1
    if (silent > 0) {
        // 0x80538a9
        g3 = v1;
        return;
    }
    int32_t v2 = (int32_t)gf; // 0x80537d2_0
    lame_get_frameNum(v2);
    struct lame_global_struct_3 * v3 = (struct lame_global_struct_3 *)v2;
    g57 = update_interval;
    g56 = 0.0L;
    int32_t v4;
    bool v5;
    int32_t v6; // 0x8053809
    float64_t v7;
    int32_t v8;
    bool v9; // 0x8053862
    float80_t v10; // 0x8053853
    float80_t v11; // 0x805383c
    if (update_interval >= 0.0f) {
        // if_80537e8_0_false
        int32_t v12;
        if (update_interval <= 0.0f) {
            // if_80537e8_1_false
            v12 = update_interval != 0.0f;
            // branch -> after_if_80537e8_0
        } else {
            v12 = 1;
        }
        // after_if_80537e8_0
        if ((v12 || v2 & -256) == 1) {
            // 0x805381f
            if (v2 != 0 && v3 != (struct lame_global_struct_3 *)9) {
                // 0x805382b
                GetRealTime();
                v11 = g58 - (float80_t)g22;
                v7 = v11;
                g57 = v11;
                g58 = 0.0L;
                v4 = 0;
                if (v7 <= 0.0) {
                    // if_8053848_0_false
                    if (v7 >= 0.0) {
                        // if_8053848_1_false
                        v4 = v7 != 0.0;
                        // branch -> after_if_8053848_0
                    } else {
                        v4 = 1;
                    }
                }
                // after_if_8053848_0
                v8 = g1 & -256;
                if ((v8 || v4) != 1) {
                    // 0x8053853
                    v10 = update_interval;
                    g57 = v10;
                    g58 = v11;
                    v5 = false;
                    v9 = false;
                    if (v10 <= v11) {
                        // if_805385e_0_false
                        if (v10 >= v11) {
                            // if_805385e_1_false
                            v5 = v10 != v11;
                            v9 = true;
                            // branch -> after_if_805385e_0
                        } else {
                            v5 = true;
                            v9 = false;
                        }
                    }
                    // after_if_805385e_0
                    if (((int32_t)(v9 || v5) || v8) != 1) {
                        // 0x80538a9
                        g3 = v1;
                        return;
                    }
                }
            }
            // 0x8053869
            GetRealTime();
            g22 = g59;
            // branch -> 0x8053874
        } else {
            // 0x80537f3
            v6 = v2 / 100;
            g3 = v6;
            if (v2 != 100 * v6) {
                // 0x80538a9
                g3 = v1;
                return;
            }
        }
        // 0x8053874
        if (g44 != 0) {
            // 0x805387d
            brhist_jump_back();
            // branch -> 0x8053882
        }
        // 0x8053882
        timestatus(gf);
        if (g44 != 0) {
            // 0x8053896
            brhist_disp((struct lame_global_struct_4 *)gf);
            // branch -> 0x80538a1
        }
        // 0x80538a1
        console_flush();
        // branch -> 0x80538a9
        // 0x80538a9
        g3 = v1;
        return;
    }
    // after_if_80537e8_0
    if ((v2 & -256) != 1) {
        // 0x80537f3
        v6 = v2 / 100;
        g3 = v6;
        if (v2 != 100 * v6) {
            // 0x80538a9
            g3 = v1;
            return;
        }
        // 0x8053874
        if (g44 != 0) {
            // 0x805387d
            brhist_jump_back();
            // branch -> 0x8053882
        }
        // 0x8053882
        timestatus(gf);
        if (g44 != 0) {
            // 0x8053896
            brhist_disp((struct lame_global_struct_4 *)gf);
            // branch -> 0x80538a1
        }
        // 0x80538a1
        console_flush();
        // branch -> 0x80538a9
        // 0x80538a9
        g3 = v1;
        return;
    }
    // 0x805381f
    if (v2 != 0 && v3 != (struct lame_global_struct_3 *)9) {
        // 0x805382b
        GetRealTime();
        v11 = g58 - (float80_t)g22;
        v7 = v11;
        g57 = v11;
        g58 = 0.0L;
        v4 = 0;
        if (v7 <= 0.0) {
            // if_8053848_0_false
            if (v7 >= 0.0) {
                // if_8053848_1_false
                v4 = v7 != 0.0;
                // branch -> after_if_8053848_0
            } else {
                v4 = 1;
            }
        }
        // after_if_8053848_0
        v8 = g1 & -256;
        if ((v8 || v4) != 1) {
            // 0x8053853
            v10 = update_interval;
            g57 = v10;
            g58 = v11;
            v5 = false;
            v9 = false;
            if (v10 <= v11) {
                // if_805385e_0_false
                if (v10 >= v11) {
                    // if_805385e_1_false
                    v5 = v10 != v11;
                    v9 = true;
                    // branch -> after_if_805385e_0
                } else {
                    v5 = true;
                    v9 = false;
                }
            }
            // after_if_805385e_0
            if (((int32_t)(v9 || v5) || v8) != 1) {
                // 0x80538a9
                g3 = v1;
                return;
            }
        }
    }
    // 0x8053869
    GetRealTime();
    g22 = g59;
    // branch -> 0x8053874
    // 0x8053874
    if (g44 != 0) {
        // 0x805387d
        brhist_jump_back();
        // branch -> 0x8053882
    }
    // 0x8053882
    timestatus(gf);
    if (g44 != 0) {
        // 0x8053896
        brhist_disp((struct lame_global_struct_4 *)gf);
        // branch -> 0x80538a1
    }
    // 0x80538a1
    console_flush();
    // branch -> 0x80538a9
    // 0x80538a9
    g3 = v1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/timestatus.c
// Address range: 0x80538af - 0x80538f1
// Line range:    294 - 310
void encoder_progress_end(struct lame_global_struct_3 * gf) {
    if (silent > 0) {
        // 0x80538f0
        return;
    }
    if (g44 != 0) {
        // 0x80538c7
        brhist_jump_back();
        // branch -> 0x80538cc
    }
    // 0x80538cc
    timestatus(gf);
    if (g44 != 0) {
        // 0x80538e0
        brhist_disp((struct lame_global_struct_4 *)gf);
        // branch -> 0x80538eb
    }
    // 0x80538eb
    timestatus_finish();
    // branch -> 0x80538f0
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/timestatus.c
// Address range: 0x80538f2 - 0x80539f7
// Line range:    316 - 342
void decoder_progress(struct anon_struct_5 * mp3data) {
    // 0x80538f2
    console_printf("\rFrame#%6i/%-6i %3i kbps");
    int32_t v1 = (int32_t)mp3data; // 0x8053922_0
    int32_t v2; // 0x8053934
    if (*(int32_t *)(v1 + 16) == 1) {
        // 0x8053931
        v2 = *(int32_t *)(v1 + 20);
        if (v2 % 2 == 0) {
            // 0x8053960
            // branch -> 0x805397a
        }
        // 0x805397a
        if ((v2 & 2) == 0) {
            // 0x805399e
            if ((g21 & 2) == 0) {
                // 0x80539b1
                // branch -> 0x80539b6
            }
            // 0x80539b6
            console_printf("  %s  %c");
            // branch -> 0x80539ea
            // 0x80539ea
            g21 = v2;
            console_printf("        \b\b\b\b\b\b\b\b");
            return;
        }
        // 0x8053984
        // branch -> 0x80539b6
        // 0x80539b6
        console_printf("  %s  %c");
        // branch -> 0x80539ea
    } else {
        // 0x80539d4
        console_printf("         ");
        v2 = 0;
        // branch -> 0x80539ea
    }
    // 0x80539ea
    g21 = v2;
    console_printf("        \b\b\b\b\b\b\b\b");
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/timestatus.c
// Address range: 0x80539f8 - 0x8053a0b
// Line range:    345 - 348
void decoder_progress_finish(void) {
    // 0x80539f8
    console_printf("\n");
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x8053a0c - 0x8053a42
// Line range:    76 - 84
int32_t calculate_index(int32_t * array, uint32_t len, int32_t value) {
    // 0x8053a0c
    if (len <= 0) {
        // 0x8053a41
        return -1;
    }
    int32_t result = 0;
    // branch -> 0x8053a1b
    while (true) {
        // 0x8053a1b
        if (*(int32_t *)(4 * result + (int32_t)array) != value) {
            int32_t v1 = result + 1; // 0x8053a30
            if (v1 >= len) {
                // break -> 0x8053a41
                break;
            }
            result = v1;
            // continue -> 0x8053a1b
            continue;
        }
        // 0x8053a41
        return result;
    }
    // 0x8053a41
    return -1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x8053a43 - 0x8053b51
// Line range:    87 - 109
int32_t brhist_init(struct lame_global_struct_4 * gf, int32_t bitrate_kbps_min, int32_t bitrate_kbps_max) {
    // 0x8053a43
    g33 = 0;
    lame_bitrate_kbps((int32_t)gf, (int32_t)&g32);
    brhist.e0 = calculate_index((int32_t *)&g32, 14, bitrate_kbps_min);
    int32_t v1 = calculate_index((int32_t *)&g32, 14, bitrate_kbps_max); // 0x8053a9c
    g31 = v1;
    if (brhist.e0 <= 13) {
        // 0x8053ab0
        if (v1 < 14) {
            // 0x8053adb
            memset((char *)&g34, 42, 512);
            memset((char *)&g35, 37, 512);
            memset((char *)&g37, 45, 512);
            memset((char *)&g36, 45, 512);
            // branch -> 0x8053b50
            // 0x8053b50
            return 0;
        }
    }
    // 0x8053aba
    error_printf("lame internal error: VBR min %d kbps or VBR max %d kbps not allowed.\n");
    // branch -> 0x8053b50
    // 0x8053b50
    return -1;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x8053b52 - 0x8053bd9
// Line range:    112 - 133
int32_t digits(uint32_t number) {
    // 0x8053b52
    if (number >= 0x5f5e100) {
        // 0x8053ba9
        // branch -> 0x8053bcb
        // 0x8053bcb
        return 9;
    }
    int32_t v1 = number;
    int32_t v2 = 1; // 0x8053bd524
    if (number >= 0x2710) {
        // 0x8053b8d
        v1 = 0;
        v2 = 5;
        // branch -> 0x8053ba9
    }
    // 0x8053ba9
    int32_t v3; // 0x8053bd523
    int32_t v4; // 0x8053bcb
    if (v1 >= 100) {
        // 0x8053baf
        v4 = 0;
        v3 = v2 | 2;
        // branch -> 0x8053bcb
    } else {
        v4 = v1;
        v3 = v2;
    }
    // 0x8053bcb
    return (int32_t)(v4 > 9) + v3;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x8053bda - 0x8053d7b
// Line range:    137 - 172
void brhist_disp_line(int32_t i, int32_t br_hist_TOT, int32_t br_hist_LR, int32_t full, int32_t frames) {
    digits(frames);
    digits(frames);
    if (full == 0) {
        // 0x8053c45
        // branch -> 0x8053c52
    }
    // 0x8053c52
    if (frames >= 1) {
        // 0x8053c58
        // branch -> 0x8053c7c
    }
    int32_t v1 = digits(frames); // 0x8053c82
    int32_t str;
    sprintf((char *)&str, " [%*i]", v1, br_hist_TOT);
    if (g43 == 0) {
        // 0x8053cff
        console_printf("\n%3d%s %.*s%.*s%*s");
        // branch -> 0x8053d5c
    } else {
        // 0x8053cb1
        console_printf("\n%3d%s %.*s%.*s%s");
        // branch -> 0x8053d5c
    }
    // 0x8053d5c
    g33++;
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8053d75
        __stack_chk_fail();
        // branch -> 0x8053d7a
    }
    // 0x8053d7a
    int32_t v2;
    g2 = v2;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x8053d7c - 0x805409c
// Line range:    177 - 232
void progress_line(struct lame_global_struct_4 * gf, int32_t full, int32_t frames) {
    char v1[20];
    char str[20];
    // 0x8053d7c
    int32_t v2;
    int32_t srate = v2; // bp-80
    int32_t v3;
    int32_t sec = v3; // bp-72
    int32_t v4;
    int32_t min = v4; // bp-68
    int32_t v5;
    int32_t hour = v5; // bp-64
    float32_t v6;
    float32_t time_in_sec = v6; // bp-60
    int32_t v7;
    int32_t res = v7; // bp-56
    int32_t v8;
    int32_t barlen_RST = v8; // bp-52
    int32_t v9 = (int32_t)gf; // 0x8053d85_0
    srate = v9;
    v1[4] = 0;
    v1[6] = 0;
    v1[10] = 0;
    v1[14] = 0;
    v1[18] = 0;
    v1[0] = 0;
    barlen_RST = 1;
    res = 0;
    lame_get_framesize(v9);
    sec = v9;
    lame_get_out_samplerate(srate);
    int32_t v10 = full < frames ? frames : full;
    int32_t v11; // 0x8053e83
    if (srate < 1) {
        // 0x8053e11
        v11 = res;
        // branch -> 0x8053e42
    } else {
        // 0x8053e17
        res = (float32_t)((float80_t)(int80_t)(v10 - frames) * (float80_t)sec / (float80_t)srate);
        v11 = (float32_t)((float80_t)(int80_t)(v10 - frames) * (float80_t)sec / (float80_t)srate);
        // branch -> 0x8053e42
    }
    float32_t v12 = (float80_t)(int80_t)v11 / 3600.0L;
    time_in_sec = v12;
    float80_t v13 = (float80_t)(int80_t)v11 - (float80_t)(3600 * (int32_t)v12); // 0x8053e86
    hour = (float32_t)(v13 / 60.0L);
    float80_t v14 = v13 - (float80_t)(60 * (int32_t)(float32_t)(v13 / 60.0L)); // 0x8053eca
    res = (float32_t)v14;
    min = (float32_t)v14;
    if (v10 == 0) {
        // 0x8053fdc
        v1[0] = 0;
        // branch -> 0x8053fef
    } else {
        // 0x8053eee
        int32_t v15; // 0x8053fb4
        if (v12 == 0.0f) {
            // 0x8053f3f
            sprintf(str, "%02u:%02u", (int32_t)(float32_t)(v13 / 60.0L), (int32_t)(float32_t)v14);
            v15 = barlen_RST + 5;
            // branch -> 0x8053f65
        } else {
            int32_t v16 = digits((int32_t)v12); // 0x8053efa
            sprintf(str, "%*d:%02u:%02u", v16, (int32_t)time_in_sec, hour, min);
            v15 = digits((int32_t)time_in_sec) + 6 + barlen_RST;
            // branch -> 0x8053f65
        }
        // 0x8053f65
        barlen_RST = v15;
        int32_t v17 = g41 - v15; // 0x8053f6a
        int32_t v18 = (v17 + 1) * v10 - 1; // 0x8053f74
        int64_t v19 = v10; // 0x8053f7c
        char v20 = (0x100000000 * (int64_t)(v18 >> 31) | (int64_t)v18) / v19;
        v1[0] = v20;
        int32_t v21 = v10 - 1 + v17 * frames; // 0x8053f91
        int32_t v22 = (0x100000000 * (int64_t)(v21 >> 31) | (int64_t)v21) / v19; // 0x8053f99
        if ((int32_t)v20 == v22) {
            // 0x8053fb4
            sprintf(str, "%.*s", v15 - 1, (char *)&g36);
            // branch -> 0x8053fef
        }
    }
    // 0x8053fef
    if (g43 == 0) {
        // 0x8054035
        console_printf("\n%.*s%s%.*s%*s");
        // branch -> 0x805407d
    } else {
        // 0x8053ffa
        console_printf("\n%.*s%s%.*s%s");
        // branch -> 0x805407d
    }
    // 0x805407d
    g33++;
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8054096
        __stack_chk_fail();
        // branch -> 0x805409b
    }
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x805409d - 0x80540e1
// Line range:    236 - 243
int32_t stats_value(float64_t x) {
    float80_t v1 = x;
    g56 = v1;
    g57 = 0.0L;
    int32_t v2;
    int32_t result;
    if (x > 0.0) {
        // after_if_80540b6_0
        if (((int32_t)0 || v2 & -256) != 1) {
            // 0x80540c1
            g57 = v1;
            console_printf(" %5.1f");
            result = 6;
            // branch -> 0x80540e0
        } else {
            result = 0;
        }
        // 0x80540e0
        return result;
    }
    // if_80540b6_0_false
    bool v3;
    bool v4; // 0x80540ba
    if (x >= 0.0) {
        // if_80540b6_1_false
        v3 = x != 0.0;
        v4 = true;
        // branch -> after_if_80540b6_0
    } else {
        v3 = true;
        v4 = false;
    }
    // after_if_80540b6_0
    if (((int32_t)(v4 || v3) || v2 & -256) != 1) {
        // 0x80540c1
        g57 = v1;
        console_printf(" %5.1f");
        result = 6;
        // branch -> 0x80540e0
    } else {
        result = 0;
    }
    // 0x80540e0
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x80540e2 - 0x805411e
// Line range:    246 - 253
int32_t stats_head(float64_t x, char * txt) {
    // 0x80540e2
    int32_t v1;
    int32_t result;
    if (x > 0.0) {
        // after_if_80540fb_0
        if (((int32_t)0 || v1 & -256) != 1) {
            // 0x8054106
            console_printf(txt);
            result = 6;
            // branch -> 0x805411d
        } else {
            result = 0;
        }
        // 0x805411d
        return result;
    }
    // if_80540fb_0_false
    bool v2;
    bool v3; // 0x80540ff
    if (x >= 0.0) {
        // if_80540fb_1_false
        v2 = x != 0.0;
        v3 = true;
        // branch -> after_if_80540fb_0
    } else {
        v2 = true;
        v3 = false;
    }
    // after_if_80540fb_0
    if (((int32_t)(v3 || v2) || v1 & -256) != 1) {
        // 0x8054106
        console_printf(txt);
        result = 6;
        // branch -> 0x805411d
    } else {
        result = 0;
    }
    // 0x805411d
    return result;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x805411f - 0x8054398
// Line range:    257 - 301
void stats_line(float64_t * stat) {
    // 0x805411f
    console_printf("\n   kbps     ");
    int32_t v1 = (int32_t)stat; // 0x805413c_0
    stats_head(*(float64_t *)(v1 + 8), "  mono");
    stats_head(*(float64_t *)(v1 + 16), "   IS ");
    stats_head(*(float64_t *)(v1 + 24), "   LR ");
    stats_head(*(float64_t *)(v1 + 32), "   MS ");
    console_printf(" %%    ");
    stats_head(*(float64_t *)(v1 + 40), " long ");
    stats_head(*(float64_t *)(v1 + 48), "switch");
    stats_head(*(float64_t *)(v1 + 56), " short");
    stats_head(*(float64_t *)(v1 + 64), " mixed");
    console_printf(" %%");
    if (g43 == 0) {
        // 0x8054254
        console_printf("%*s");
        // branch -> 0x8054274
    } else {
        // 0x805423e
        console_printf("%s");
        // branch -> 0x8054274
    }
    // 0x8054274
    g33++;
    int32_t v2 = (int32_t)stat; // 0x8054288_0
    console_printf("\n  %5.1f     ");
    stats_value(*(float64_t *)(v2 + 8));
    stats_value(*(float64_t *)(v2 + 16));
    stats_value(*(float64_t *)(v2 + 24));
    stats_value(*(float64_t *)(v2 + 32));
    console_printf("      ");
    stats_value(*(float64_t *)(v2 + 40));
    stats_value(*(float64_t *)(v2 + 48));
    stats_value(*(float64_t *)(v2 + 56));
    stats_value(*(float64_t *)(v2 + 64));
    if (g43 == 0) {
        // 0x805436a
        console_printf("%*s");
        // branch -> 0x805438a
    } else {
        // 0x8054354
        console_printf("%s");
        // branch -> 0x805438a
    }
    // 0x805438a
    g33++;
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x8054399 - 0x80546f3
// Line range:    309 - 367
void brhist_disp(struct lame_global_struct_4 * gf) {
    int32_t v1[4];
    int32_t v2[4];
    int32_t v3;
    int32_t most_often = v3; // bp-32
    int32_t v4;
    int32_t frames = v4; // bp-28
    int32_t v5;
    int32_t lines_used = v5; // bp-24
    int32_t v6;
    int32_t i = v6; // bp-20
    int32_t v7;
    int32_t v8 = &v7; // ebp
    int32_t v9 = g3; // bp-12
    i = 0;
    int32_t v10;
    memset((char *)&v10, 0, 18);
    most_often = 0;
    g33 = 0;
    int32_t v11;
    lame_bitrate_stereo_mode_hist((int32_t)gf, (int32_t)&v11);
    int32_t v12;
    lame_bitrate_hist((int32_t)gf, (int32_t)&v12);
    lame_stereo_mode_hist((int32_t)gf, (int32_t)&v2);
    int32_t v13;
    lame_block_type_hist((int32_t)gf, (int32_t)&v13);
    frames = 0;
    lines_used = 0;
    int32_t v14 = 0; // 0x805447d
    int32_t v15 = 0; // 0x8054445
    int32_t v16 = 0;
    float80_t v17 = 0.0L;
    // branch -> 0x805443b
    float80_t v18;
    while (true) {
        int32_t v19 = 4 * v16; // 0x805443e
        int32_t * v20 = (int32_t *)(v8 - 136 + v19); // 0x805443e_0
        int32_t v21 = *v20 + v15; // 0x8054445
        lines_used = v21;
        int32_t v22 = *(int32_t *)(v19 + (int32_t)&g32); // 0x8054455
        int32_t v23 = v14; // 0x805447d38
        if (*v20 > v14) {
            int32_t v24 = *v20; // 0x8054485
            frames = v24;
            v23 = v24;
            // branch -> 0x805448f
        }
        // 0x805448f
        if (*v20 != 0) {
            // 0x805449d
            i++;
            // branch -> 0x80544a1
        }
        int32_t v25 = v16 + 1; // 0x80544a1
        v18 = v17 + (float80_t)(v22 * *v20);
        if (v25 >= 14) {
            // break -> 0x80544b7
            break;
        }
        v14 = v23;
        v15 = v21;
        v16 = v25;
        v17 = v18;
        // continue -> 0x805443b
    }
    int32_t v26 = 0;
    // branch -> 0x80544b7
    int32_t v27;
    while (true) {
        int32_t * v28 = (int32_t *)(v8 - 136 + 4 * v26); // 0x80544ba_0
        if (*v28 == 0 || i < 2) {
            // 0x80544e5
            int32_t v29; // 0x8054536
            if (brhist.e0 <= v26) {
                // 0x80544ef
                if (g31 >= v26) {
                  lab_0x80544f9:;
                    int32_t v30 = *(int32_t *)((int32_t)&v9 - 424 + 16 * v26); // 0x8054509
                    brhist_disp_line(v26, *v28, v30, frames, lines_used);
                    v27 = g2;
                    // branch -> 0x8054536
                } else {
                    v27 = v8;
                }
                // 0x8054536
                v29 = v26 + 1;
                if (v29 >= 14) {
                    // break -> 0x805455b
                    break;
                }
                v8 = v27;
                v26 = v29;
                // continue -> 0x80544b7
                continue;
            } else {
                v27 = v8;
            }
            // 0x8054536
            v29 = v26 + 1;
            if (v29 >= 14) {
                // break -> 0x805455b
                break;
            }
            v8 = v27;
            v26 = v29;
            // continue -> 0x80544b7
            continue;
        } else {
            // 0x80544dc
            // branch -> 0x80544f9
            goto lab_0x80544f9;
        }
    }
    int32_t v31 = v27 - 56; // 0x8054550
    int32_t v32 = 0;
    int32_t v33 = *(int32_t *)(v31 + 4 * v32) + most_often; // 0x8054554
    most_often = v33;
    int32_t v34 = v32 + 1; // 0x8054557
    // branch -> 0x805454d
    while (v34 < 4) {
        // 0x805454d
        v32 = v34;
        v33 += *(int32_t *)(v31 + 4 * v32);
        most_often = v33;
        v34 = v32 + 1;
        // continue -> 0x805454d
    }
    // 0x8054561
    if (lines_used >= 1) {
        // 0x8054567
        v10 = (float32_t)(v18 / (float80_t)lines_used);
        // branch -> 0x80545a0
    }
    // 0x80545a0
    if (v33 >= 1) {
        // 0x80545a6
        // branch -> 0x80545f2
    }
    // 0x80545f2
    if (v1[0] >= 1) {
        // 0x80545fd
        // branch -> 0x80546bb
    }
    int32_t v35 = (int32_t)gf; // 0x80546bb_0
    lame_get_totalframes(v35);
    progress_line(gf, v35, lines_used);
    stats_line((float64_t *)&v10);
}

// From module:   /home/naftali/source/lame-3.98.4/frontend/brhist.c
// Address range: 0x80546f4 - 0x805471f
// Line range:    370 - 374
void brhist_jump_back(void) {
    // 0x80546f4
    console_up(g33);
    g33 = 0;
}

// Address range: 0x8054730 - 0x8054789
int32_t __libc_csu_init(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x8054735
    __i686_get_pc_thunk_bx();
    g3 += 0x68b9;
    int32_t v2;
    _init(v2);
    int32_t v3 = g3; // 0x8054749
    g3 = v1;
    int32_t v4;
    g2 = v4;
    return v3 - 248;
}

// Address range: 0x805478a - 0x805478f
int32_t __i686_get_pc_thunk_bx(void) {
    // 0x805478a
    int32_t v1;
    g3 = v1;
    return g1;
}

// Address range: 0x8054810 - 0x805483b
void __do_global_ctors_aux(void) {
    // 0x8054810
    int32_t v1;
    if (g10 == -1) {
        // 0x8054834
        g2 = v1;
        return;
    }
    int32_t v2 = &g10; // 0x8054828
    unknown_ffffffff();
    // branch -> 0x8054828
    while (*(int32_t *)(v2 - 4) != -1) {
        // 0x8054828
        v2 -= 4;
        unknown_ffffffff();
        // continue -> 0x8054828
    }
    // 0x8054834
    // branch -> 0x8054834
    // 0x8054834
    g2 = v1;
}

// --------------- Statically Linked Functions ----------------

// int fstat64(int fd, struct stat64 * buf);
// int stat64(const char * restrict file, struct stat64 * restrict buf);

// --------------- Dynamically Linked Functions ---------------

// void __gmon_start(void);
// void __stack_chk_fail(void);
// int _IO_getc(_IO_FILE * fp);
// int _IO_putc(int c, _IO_FILE * fp);
// double atof(const char * nptr);
// int atoi(const char * nptr);
// clock_t clock(void);
// void exit(int status);
// int fclose(FILE * stream);
// int feof(FILE * stream);
// int ferror(FILE * stream);
// int fflush(FILE * stream);
// int fileno(FILE * stream);
// FILE * fopen64(const char * restrict filename, const char * restrict modes);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputc(int c, FILE * stream);
// int fputs(const char * restrict s, FILE * restrict stream);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void free(void * ptr);
// int fseek(FILE * stream, long int off, int whence);
// long int ftell(FILE * stream);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// void get_lame_os_bitness(int32_t a1);
// void get_lame_url(int32_t a1);
// void get_lame_version(int32_t a1);
// int getchar(void);
// char * getenv(const char * name);
// int gettimeofday(struct timeval * restrict tv, __timezone_ptr_t tz);
// void hip_decode1_headers(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
// void hip_decode1_headersB(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
// void hip_decode_exit(int32_t a1);
// void hip_decode_init(void);
// void id3tag_add_v2(int32_t a1);
// void id3tag_genre_list(int32_t a1, int32_t a2);
// void id3tag_init(int32_t a1);
// void id3tag_pad_v2(int32_t a1);
// void id3tag_set_album(int32_t a1, int32_t a2);
// void id3tag_set_albumart(int32_t a1, int32_t a2, int32_t a3);
// void id3tag_set_artist(int32_t a1, int32_t a2);
// void id3tag_set_comment(int32_t a1, int32_t a2);
// void id3tag_set_fieldvalue(int32_t a1, int32_t a2);
// void id3tag_set_genre(int32_t a1, int32_t a2);
// void id3tag_set_pad(int32_t a1, int32_t a2);
// void id3tag_set_title(int32_t a1, int32_t a2);
// void id3tag_set_track(int32_t a1, int32_t a2);
// void id3tag_set_year(int32_t a1, int32_t a2);
// void id3tag_space_v1(int32_t a1);
// void id3tag_v1_only(int32_t a1);
// void id3tag_v2_only(int32_t a1);
// void lame_bitrate_hist(int32_t a1, int32_t a2);
// void lame_bitrate_kbps(int32_t a1, int32_t a2);
// void lame_bitrate_stereo_mode_hist(int32_t a1, int32_t a2);
// void lame_block_type_hist(int32_t a1, int32_t a2);
// void lame_encode_buffer_int(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
// void lame_encode_flush(int32_t a1, int32_t a2, int32_t a3);
// void lame_encode_flush_nogap(int32_t a1, int32_t a2, int32_t a3);
// void lame_get_brate(int32_t a1);
// void lame_get_bWriteVbrTag(int32_t a1);
// void lame_get_compression_ratio(int32_t a1);
// void lame_get_decode_on_the_fly(int32_t a1);
// void lame_get_decode_only(int32_t a1);
// void lame_get_encoder_delay(int32_t a1);
// void lame_get_exp_nspsytune(int32_t a1);
// void lame_get_findReplayGain(int32_t a1);
// void lame_get_force_ms(int32_t a1);
// void lame_get_frameNum(int32_t a1);
// void lame_get_framesize(int32_t a1);
// void lame_get_free_format(int32_t a1);
// void lame_get_id3v1_tag(int32_t a1, int32_t a2, int32_t a3);
// void lame_get_id3v2_tag(int32_t a1, int32_t a2, int32_t a3);
// void lame_get_in_samplerate(int32_t a1);
// void lame_get_lametag_frame(int32_t a1, int32_t a2, int32_t a3);
// void lame_get_mode(int32_t a1);
// void lame_get_noclipGainChange(int32_t a1);
// void lame_get_noclipScale(int32_t a1);
// void lame_get_num_channels(int32_t a1);
// void lame_get_num_samples(int32_t a1);
// void lame_get_out_samplerate(int32_t a1);
// void lame_get_quality(int32_t a1);
// void lame_get_RadioGain(int32_t a1);
// void lame_get_totalframes(int32_t a1);
// void lame_get_VBR(int32_t a1);
// void lame_get_VBR_max_bitrate_kbps(int32_t a1);
// void lame_get_VBR_mean_bitrate_kbps(int32_t a1);
// void lame_get_VBR_min_bitrate_kbps(int32_t a1);
// void lame_get_VBR_q(int32_t a1);
// void lame_get_VBR_quality(int32_t a1);
// void lame_get_version(int32_t a1);
// void lame_init(void);
// void lame_print_config(int32_t a1);
// void lame_print_internals(int32_t a1);
// void lame_set_asm_optimizations(int32_t a1, int32_t a2, int32_t a3);
// void lame_set_athaa_sensitivity(int32_t a1, int32_t a2);
// void lame_set_brate(int32_t a1, int32_t a2);
// void lame_set_bWriteVbrTag(int32_t a1, int32_t a2);
// void lame_set_compression_ratio(int32_t a1, int32_t a2);
// void lame_set_copyright(int32_t a1, int32_t a2);
// void lame_set_decode_on_the_fly(int32_t a1, int32_t a2);
// void lame_set_decode_only(int32_t a1, int32_t a2);
// void lame_set_disable_reservoir(int32_t a1, int32_t a2);
// void lame_set_emphasis(int32_t a1, int32_t a2);
// void lame_set_error_protection(int32_t a1, int32_t a2);
// void lame_set_exp_nspsytune(int32_t a1, int32_t a2);
// void lame_set_experimentalY(int32_t a1, int32_t a2);
// void lame_set_findReplayGain(int32_t a1, int32_t a2);
// void lame_set_force_ms(int32_t a1, int32_t a2);
// void lame_set_free_format(int32_t a1, int32_t a2);
// void lame_set_highpassfreq(int32_t a1, int32_t a2);
// void lame_set_highpasswidth(int32_t a1, int32_t a2);
// void lame_set_in_samplerate(int32_t a1, int32_t a2);
// void lame_set_interChRatio(int32_t a1, int32_t a2);
// void lame_set_lowpassfreq(int32_t a1, int32_t a2);
// void lame_set_lowpasswidth(int32_t a1, int32_t a2);
// void lame_set_mode(int32_t a1, int32_t a2);
// void lame_set_msfix(int32_t a1, int32_t a2);
// void lame_set_num_channels(int32_t a1, int32_t a2);
// void lame_set_num_samples(int32_t a1, int32_t a2);
// void lame_set_original(int32_t a1, int32_t a2);
// void lame_set_out_samplerate(int32_t a1, int32_t a2);
// void lame_set_preset(int32_t a1, int32_t a2);
// void lame_set_quality(int32_t a1, int32_t a2);
// void lame_set_scale(int32_t a1, int32_t a2);
// void lame_set_scale_left(int32_t a1, int32_t a2);
// void lame_set_scale_right(int32_t a1, int32_t a2);
// void lame_set_strict_ISO(int32_t a1, int32_t a2);
// void lame_set_useTemporal(int32_t a1, int32_t a2);
// void lame_set_VBR(int32_t a1, int32_t a2);
// void lame_set_VBR_hard_min(int32_t a1, int32_t a2);
// void lame_set_VBR_max_bitrate_kbps(int32_t a1, int32_t a2);
// void lame_set_VBR_mean_bitrate_kbps(int32_t a1, int32_t a2);
// void lame_set_VBR_min_bitrate_kbps(int32_t a1, int32_t a2);
// void lame_set_VBR_q(int32_t a1, int32_t a2);
// void lame_set_VBR_quality(int32_t a1, int32_t a2);
// void lame_stereo_mode_hist(int32_t a1, int32_t a2);
// double ldexp(double, int);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int pclose(FILE * stream);
// FILE * popen(const char * command, const char * modes);
// int setvbuf(FILE * restrict stream, char * restrict buf, int modes, size_t n);
// int sprintf(char * restrict s, const char * restrict format, ...);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// char * strcat(char * restrict dest, const char * restrict src);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strdup(const char * s);
// size_t strlen(const char * s);
// char * strncat(char * restrict dest, const char * restrict src, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// void tgetent(int32_t a1, int32_t a2);
// void tgetnum(int32_t a1);
// void tgetstr(int32_t a1, int32_t a2);
// int tolower(int c);
// int vfprintf(FILE * restrict s, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.5)
// Detected language: C
// Detected functions: 105
// Decompiler release: VERSION
// Decompilation date: DATE
