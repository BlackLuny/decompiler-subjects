//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int80_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker * e12;
    struct _IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_marker {
    struct _IO_marker * e0;
    struct _IO_FILE * e1;
    int32_t e2;
};

struct quantum_matrix_struct_1 {
    int32_t e0;
    int32_t e1;
    float64_t * e2;
};

struct quantum_matrix_struct_2 {
    int32_t e0;
    int32_t e1;
    float64_t * e2;
};

struct quantum_reg_node_struct {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_node_struct_11 {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_node_struct_12 {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_node_struct_2 {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_node_struct_3 {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_node_struct_4 {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_node_struct_5 {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_node_struct_7 {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_node_struct_8 {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_node_struct_9 {
    float64_t e0;
    int64_t e1;
};

struct quantum_reg_struct {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct * e3;
    int32_t * e4;
};

struct quantum_reg_struct_11 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct_11 * e3;
    int32_t * e4;
};

struct quantum_reg_struct_12 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct_12 * e3;
    int32_t * e4;
};

struct quantum_reg_struct_2 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct_2 * e3;
    int32_t * e4;
};

struct quantum_reg_struct_3 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct_3 * e3;
    int32_t * e4;
};

struct quantum_reg_struct_4 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct_4 * e3;
    int32_t * e4;
};

struct quantum_reg_struct_5 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct_5 * e3;
    int32_t * e4;
};

struct quantum_reg_struct_7 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct_7 * e3;
    int32_t * e4;
};

struct quantum_reg_struct_8 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct_8 * e3;
    int32_t * e4;
};

struct quantum_reg_struct_9 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct quantum_reg_node_struct_9 * e3;
    int32_t * e4;
};

// ------------------- Function Prototypes --------------------

void add_mod_n(int32_t N, int32_t a, int32_t width2, struct quantum_reg_struct_5 * reg);
void addn(int32_t N, int32_t a, uint32_t width2, struct quantum_reg_struct_5 * reg);
void addn_inv(int32_t N, int32_t a, uint32_t width2, struct quantum_reg_struct_5 * reg);
void emul(int32_t a, int32_t L, int32_t width2, struct quantum_reg_struct_7 * reg);
int32_t function_8048ab6(int32_t a1);
void madd(int32_t a, uint32_t a_inv, int32_t width2, struct quantum_reg_struct_5 * reg);
void madd_inv(int32_t a, uint32_t a_inv, int32_t width2, struct quantum_reg_struct_5 * reg);
void mul_mod_n(int32_t N, int32_t a, int32_t ctl, int32_t width2, struct quantum_reg_struct_7 * reg);
void muln(int32_t N, uint32_t a, int32_t ctl, uint32_t width2, struct quantum_reg_struct_7 * reg);
void muln_inv(int32_t N, int32_t a, int32_t ctl, int32_t width2, struct quantum_reg_struct_7 * reg);
void muxfa(int32_t a, int32_t b_in, int32_t c_in, int32_t c_out, int32_t xlt_l, int32_t L, int32_t total, struct quantum_reg_struct_5 * reg);
void muxfa_inv(int32_t a, int32_t b_in, int32_t c_in, int32_t c_out, int32_t xlt_l, int32_t L, int32_t total, struct quantum_reg_struct_5 * reg);
void muxha(int32_t a, int32_t b_in, int32_t c_in, int32_t xlt_l, int32_t L, int32_t total, struct quantum_reg_struct_5 * reg);
void muxha_inv(int32_t a, int32_t b_in, int32_t c_in, int32_t xlt_l, int32_t L, int32_t total, struct quantum_reg_struct_5 * reg);
void quantum_add_hash_5(int64_t a, int32_t pos, struct quantum_reg_struct_3 * reg);
void quantum_addscratch(int32_t bits, struct quantum_reg_struct_11 * reg);
int32_t quantum_bmeasure(uint32_t pos, struct quantum_reg_struct_4 * reg);
float64_t quantum_cexp(float32_t phi);
void quantum_cnot(int32_t control, uint32_t target, struct quantum_reg_struct_3 * reg);
void quantum_cnot_ft(int32_t control, int32_t target, struct quantum_reg_struct_8 * reg);
void quantum_cond_phase(int32_t control, uint32_t target, struct quantum_reg_struct_3 * reg);
void quantum_decohere(struct quantum_reg_struct * reg);
void quantum_delete_matrix(struct quantum_matrix_struct_2 * m);
void quantum_delete_qureg(struct quantum_reg_struct_11 * reg);
void quantum_delete_qureg_hashpreserve(struct quantum_reg_struct_11 * reg);
void quantum_destroy_hash(struct quantum_reg_struct_11 * reg);
void quantum_double2char(float64_t d, char * buf);
void quantum_error(int32_t errno);
char * quantum_error_handler(char * (*f)(int32_t));
void quantum_exp_mod_n(int32_t N, uint32_t x, int32_t width_input, int32_t width2, struct quantum_reg_struct_2 * reg);
void quantum_frac_approx(int32_t * a, int32_t * b, uint32_t width2);
float64_t quantum_frand(void);
void quantum_gate1(int32_t target, struct quantum_matrix_struct_1 m, struct quantum_reg_struct_3 * reg);
int32_t quantum_gate_counter(uint32_t inc);
int32_t quantum_gcd(int32_t u, int32_t v);
float32_t quantum_get_decoherence(void);
int32_t quantum_get_state_7(int64_t a, struct quantum_reg_struct_3 reg);
int32_t quantum_getwidth(uint32_t n);
void quantum_hadamard(int32_t target, struct quantum_reg_struct_3 * reg);
int32_t quantum_hash64_6(int64_t key, int32_t width2);
float32_t quantum_imag_10(float64_t a);
float32_t quantum_imag_15(float64_t a);
float32_t quantum_imag_19(float64_t a);
void quantum_int2char(int32_t j, char * buf);
int32_t quantum_inverse_mod(int32_t n, int32_t c);
int32_t quantum_ipow(int32_t a, uint32_t b);
int64_t quantum_measure(struct quantum_reg_struct_4 reg);
int32_t quantum_memman(int32_t change);
void quantum_mu2char(int64_t mu, char * buf);
struct quantum_matrix_struct_2 quantum_new_matrix(int32_t cols, int32_t rows);
struct quantum_reg_struct_11 quantum_new_qureg(int64_t initval, int32_t width2);
void quantum_objcode_exit(char * file);
void quantum_objcode_file(char * file);
int32_t quantum_objcode_put(char operation, ...);
void quantum_objcode_start(void);
float32_t quantum_prob_inline_13(float64_t a);
float32_t quantum_prob_inline_18(float64_t a);
float32_t quantum_prob_inline_8(float64_t a);
int32_t quantum_qec_counter(uint32_t inc, int32_t frequency, struct quantum_reg_struct_8 * reg);
void quantum_qec_decode(int32_t type2, int32_t width2, struct quantum_reg_struct_8 * reg);
void quantum_qec_encode(int32_t type2, int32_t width2, struct quantum_reg_struct_8 * reg);
void quantum_qec_get_status(int32_t * ptype, int32_t * pwidth);
void quantum_qec_set_status(int32_t stype, int32_t swidth);
void quantum_qft(int32_t width2, struct quantum_reg_struct_9 * reg);
float32_t quantum_real_14(float64_t a);
float32_t quantum_real_20(float64_t a);
float32_t quantum_real_9(float64_t a);
void quantum_reconstruct_hash_4(struct quantum_reg_struct_3 * reg);
void quantum_set_decoherence(float32_t l);
void quantum_sigma_x(int32_t target, struct quantum_reg_struct_3 * reg);
void quantum_sigma_x_ft(int32_t target, struct quantum_reg_struct_8 * reg);
void quantum_sigma_z(int32_t target, struct quantum_reg_struct_3 * reg);
struct quantum_reg_struct_11 quantum_state_collapse(int32_t pos, int32_t value, struct quantum_reg_struct_11 reg);
char * quantum_strerr(int32_t errno);
void quantum_swaptheleads(int32_t width2, struct quantum_reg_struct_3 * reg);
void quantum_swaptheleads_omuln_controlled(int32_t control, int32_t width2, struct quantum_reg_struct_3 * reg);
void quantum_toffoli(int32_t control1, uint32_t control2, uint32_t target, struct quantum_reg_struct_3 * reg);
void quantum_toffoli_ft(int32_t control1, uint32_t control2, uint32_t target, struct quantum_reg_struct_8 * reg);
void test_sum(int32_t compare, int32_t width2, struct quantum_reg_struct_5 * reg);

// --------------------- Global Variables ---------------------

int32_t allocated = 0;
int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // edx
int32_t g7 = 0; // esi
int32_t g8 = 0x40000000; // 0x8056088
struct _IO_FILE * g9 = NULL; // 0x80560a0
char * (*g10)(int32_t) = NULL; // 0x80560c0
char * g11; // 0x80560d4
int32_t g12 = 0; // 0x80560d8
int32_t g13 = 0; // 0x80560dc
int32_t g14 = 0; // 0x80560e0
int32_t g15 = 0; // 0x80560fc
int32_t globalfile = 0;
int32_t objcode = 0;
int32_t opstatus = 0;
int32_t position = 0;
float32_t quantum_lambda = 0.0f;
int32_t quantum_status = 0;
float80_t g16 = 0.0L; // st1
float80_t g17 = 0.0L; // st2
float80_t g18 = 0.0L; // st3
float80_t g19 = 0.0L; // st5
float80_t g20 = 0.0L; // st6
float80_t g21 = 0.0L; // st7
int32_t type = 0;
int32_t width = 0;

// ------------------------ Functions -------------------------

// Address range: 0x8048ab6 - 0x8048abf
int32_t function_8048ab6(int32_t a1) {
    // 0x8048ab6
    return g7;
}

// From module:   /home/naftali/source/libquantum-0.9.1/classic.c
// Address range: 0x8048ae4 - 0x8048b14
// Line range:    30 - 38
int32_t quantum_ipow(int32_t a, uint32_t b) {
    int32_t result = 1;
    if (b > 0) {
        int32_t v1 = a; // 0x8048afd
        int32_t v2 = 1; // 0x8048b04
        while (v2 < b) {
            // 0x8048afa
            v1 *= a;
            v2++;
            // continue -> 0x8048afa
        }
        // 0x8048b08
        result = v1;
        // branch -> 0x8048b10
    }
    // 0x8048b10
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/classic.c
// Address range: 0x8048b15 - 0x8048b41
// Line range:    44 - 54
int32_t quantum_gcd(int32_t u, int32_t v) {
    // 0x8048b15
    if (v == 0) {
        // 0x8048b3d
        return u;
    }
    int32_t v1 = (0x100000000 * (int64_t)(u >> 31) | (int64_t)u) % (int64_t)v; // 0x8048b25
    while (v1 != 0) {
        // 0x8048b1d
        u = v;
        v = v1;
        v1 = (0x100000000 * (int64_t)(u >> 31) | (int64_t)u) % (int64_t)v;
        // continue -> 0x8048b1d
    }
    // 0x8048b37
    // branch -> 0x8048b3d
    // 0x8048b3d
    return v;
}

// From module:   /home/naftali/source/libquantum-0.9.1/classic.c
// Address range: 0x8048b42 - 0x8048c62
// Line range:    60 - 89
void quantum_frac_approx(int32_t * a, int32_t * b, uint32_t width2) {
    // 0x8048b42
    int32_t v1;
    int32_t num = v1; // bp-40
    int32_t v2;
    int32_t den1 = v2; // bp-36
    float80_t v3 = (float80_t)*a / (float80_t)*b; // 0x8048b62
    den1 = 0;
    num = 0;
    float32_t v4 = v3 + 5.0e-6L;
    uint32_t v5 = width2 % 32; // 0x8048be7
    if (1 << v5 < 1) {
        // 0x8048c51
        *a = 0;
        *b = num;
        return;
    }
    // 0x8048bed
    den1 = v4;
    num = 1;
    float80_t v6 = fabsl((float80_t)(int32_t)v4 - v3); // 0x8048c2c
    float80_t v7 = 1.0L / (float80_t)(2 << v5); // 0x8048c42
    if (v6 > v7) {
        // after_if_8048c46_0
        // branch -> 0x8048c51
        // 0x8048c51
        *a = den1;
        *b = num;
        return;
    }
    // if_8048c46_0_false
    if (v6 >= v7) {
        // if_8048c46_1_false
        // branch -> after_if_8048c46_0
    }
    // after_if_8048c46_0
    // branch -> 0x8048c51
    // 0x8048c51
    *a = den1;
    *b = num;
}

// From module:   /home/naftali/source/libquantum-0.9.1/classic.c
// Address range: 0x8048c63 - 0x8048c89
// Line range:    95 - 101
int32_t quantum_getwidth(uint32_t n) {
    int32_t result = 1;
    // branch -> 0x8048c76
    while (1 << result % 32 < n) {
        // 0x8048c76
        result++;
        // continue -> 0x8048c76
    }
    // 0x8048c85
    g4 = result;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/classic.c
// Address range: 0x8048c8a - 0x8048cbb
// Line range:    107 - 113
int32_t quantum_inverse_mod(int32_t n, int32_t c) {
    int32_t result = 1;
    // branch -> 0x8048c9d
    while ((int32_t)((0x100000000 * (int64_t)((result * c) >> 31) || (int64_t)(result * c)) % (int64_t)n) != 1) {
        // 0x8048c9d
        // 0x8048c9d
        result++;
        // continue -> 0x8048c9d
    }
    // 0x8048cb5
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.c
// Address range: 0x8048dfe - 0x8048e83
// Line range:    53 - 55
float64_t quantum_cexp(float32_t phi) {
    // 0x8048dfe
    int32_t v1;
    float64_t v2 = (int64_t)v1; // bp-28
    float64_t v3 = phi;
    cos(v3);
    sin(v3);
    __muldc3((float64_t)(int64_t)(int32_t)&v2, 0.0, 0.0, 0.0);
    float80_t v4 = v2;
    int32_t v5;
    float80_t v6 = (int64_t)v5;
    g16 = v4;
    float80_t v7 = g18 + v4; // 0x8048e55
    g17 = v6;
    g18 = v7;
    g1 = (float32_t)v7;
    g6 = (float32_t)v6;
    return g19;
}

// From module:   /home/naftali/source/libquantum-0.9.1/decoherence.c
// Address range: 0x8048e84 - 0x8048e96
// Line range:    46 - 48
float32_t quantum_get_decoherence(void) {
    // 0x8048e84
    return (float32_t)*(int32_t *)&quantum_lambda;
}

// From module:   /home/naftali/source/libquantum-0.9.1/decoherence.c
// Address range: 0x8048e97 - 0x8048ec9
// Line range:    55 - 63
void quantum_set_decoherence(float32_t l) {
    // 0x8048e97
    g18 = l;
    if (l > 0.0f) {
        // 0x8048ebe
        quantum_status = 0;
        // branch -> 0x8048ec8
        // 0x8048ec8
        return;
    }
    // if_8048ea1_0_false
    int32_t v1;
    if (l >= 0.0f) {
        // if_8048ea1_1_false
        v1 = l != 0.0f ? 1024 : 0;
        // branch -> after_if_8048ea1_0
    } else {
        v1 = 0;
    }
    // after_if_8048ea1_0
    if (v1 == 0) {
        // 0x8048ebe
        quantum_status = 0;
        // branch -> 0x8048ec8
    } else {
        // 0x8048eaa
        quantum_status = 1;
        *(int32_t *)&quantum_lambda = (int32_t)l;
        // branch -> 0x8048ec8
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/decoherence.c
// Address range: 0x8048eca - 0x804911b
// Line range:    71 - 130
void quantum_decohere(struct quantum_reg_struct * reg) {
    // 0x8048eca
    float32_t v1;
    float32_t angle = v1; // bp-48
    float32_t v2;
    float32_t x = v2; // bp-40
    int32_t v3 = g3; // 0x8048ecf
    quantum_gate_counter(1);
    if (quantum_status == 0) {
        // 0x8049114
        g3 = v3;
        return;
    }
    char * mem = calloc(reg->e0, 4); // 0x8048efc
    x = (int32_t)mem;
    if ((float32_t)(int32_t)mem == 0.0f) {
        // 0x8048f0a
        quantum_error(2);
        // branch -> 0x8048f16
    }
    // 0x8048f16
    quantum_memman(4 * reg->e0);
    angle = 0.0f;
    int32_t v4 = (int32_t)reg; // 0x8048ff3_0
    if (reg->e0 <= 0) {
        // 0x80490e8
        angle = 0.0f;
        if (*(int32_t *)(v4 + 4) <= 0) {
            // 0x80490f7
            free((char *)(int32_t)x);
            quantum_memman(-4 * reg->e0);
            // branch -> 0x8049114
            // 0x8049114
            g3 = v3;
            return;
        }
        int32_t v5 = 0; // bp+082
        struct quantum_reg_struct * v6 = reg; // 0x804909079
        while (true) {
            int32_t * v7 = (int32_t *)(v4 + 12); // 0x8049021_0
            int32_t v8 = 16 * v5; // 0x8049027
            int32_t v9 = *v7 + v8; // 0x804902a67
            int32_t v10; // 0x80490e4
            int32_t v11; // 0x80490e8_0
            int32_t v12; // edi
            int32_t v13; // 0x80490b2
            int32_t v14; // 0x80490b4
            int32_t v15; // 0x80490d7
            int32_t v16; // 0x80490d9
            int32_t v17; // 0x804909f
            int32_t v18; // 0x804909c
            struct quantum_reg_struct * v19;
            float32_t v20; // 0x80490a1
            if (v6->e0 > 0) {
                int32_t v21 = 0; // 0x804907369
                float32_t * v22 = NULL; // 0x804906b68
                float32_t * v23;
                int32_t v24; // 0x804902a
                while (true) {
                    uint32_t v25 = *(int32_t *)(v9 + 12); // 0x804902d
                    uint32_t v26 = *(int32_t *)(v9 + 8); // 0x8049030
                    char v27 = 0x1000000 * v21 / 0x1000000 % 32; // 0x8049036
                    int32_t v28 = v26; // 0x804904444
                    if (v27 != 0) {
                        uint32_t v29 = (int32_t)v27; // 0x8049036
                        v28 = v25 << 32 - v29 | v26 >> v29;
                        // branch -> after_if_8049036_0
                    }
                    uint32_t v30 = v21 % 32; // 0x8049039
                    int32_t v31 = v25; // 0x8049040
                    if (v30 != 0) {
                        // if_8049039_0_true
                        v31 = v25 >> v30;
                        // branch -> after_if_8049039_0
                    }
                    if (v21 != 32) {
                        // 0x8049040
                        v28 = v31;
                        // branch -> 0x8049044
                    }
                    float80_t v32 = (float80_t)*(float32_t *)((int32_t)x + 4 * v21); // 0x8049069
                    float80_t v33;
                    if (v28 % 2 == 0) {
                        // 0x8049060
                        v33 = (float80_t)(int80_t)(int32_t)v22 - v32;
                        // branch -> 0x8049073
                    } else {
                        // 0x804904b
                        v33 = (float80_t)(int80_t)(int32_t)v22 + v32;
                        // branch -> 0x8049073
                    }
                    // 0x8049073
                    v23 = (float32_t *)(int32_t)(float32_t)v33;
                    int32_t v34 = v21 + 1; // 0x8049073
                    v24 = *v7 + v8;
                    if (v6->e0 <= v34) {
                        // break -> 0x8049081
                        break;
                    }
                    v9 = v24;
                    v21 = v34;
                    v22 = v23;
                    // continue -> 0x804901e
                }
                // 0x8049081
                v12 = v24;
                v18 = *v7 + v8;
                v17 = *(int32_t *)v18;
                v20 = *(float32_t *)(v18 + 4);
                g19 = quantum_cexp((float32_t)(int32_t)v23);
                v13 = g1;
                v14 = g6;
                __mulsc3((float32_t)v17, v20, (float32_t)v13, (float32_t)v14);
                v15 = v14;
                g4 = v15;
                v16 = v13;
                g3 = v16;
                *(int32_t *)v12 = v15;
                *(int32_t *)(v12 + 4) = v16;
                v10 = (int32_t)angle + 1;
                v19 = reg;
                angle = v10;
                v11 = (int32_t)v19;
                if (*(int32_t *)(v11 + 4) <= v10) {
                    // break -> 0x80490f7
                    break;
                }
                v5 = v10;
                v4 = v11;
                v6 = v19;
                // continue -> 0x804900d
                continue;
            }
            // 0x8049081
            v12 = v9;
            v18 = *v7 + v8;
            v17 = *(int32_t *)v18;
            v20 = *(float32_t *)(v18 + 4);
            g19 = quantum_cexp((float32_t)(int32_t)NULL);
            v13 = g1;
            v14 = g6;
            __mulsc3((float32_t)v17, v20, (float32_t)v13, (float32_t)v14);
            v15 = v14;
            g4 = v15;
            v16 = v13;
            g3 = v16;
            *(int32_t *)v12 = v15;
            *(int32_t *)(v12 + 4) = v16;
            v10 = (int32_t)angle + 1;
            v19 = reg;
            angle = v10;
            v11 = (int32_t)v19;
            if (*(int32_t *)(v11 + 4) <= v10) {
                // break -> 0x80490f7
                break;
            }
            v5 = v10;
            v4 = v11;
            v6 = v19;
            // continue -> 0x804900d
        }
        // 0x80490f7
        free((char *)(int32_t)x);
        quantum_memman(-4 * reg->e0);
        // branch -> 0x8049114
        // 0x8049114
        g3 = v3;
        return;
    }
    while (true) {
        float80_t v35 = 2 * (float80_t)quantum_frand() - 1.0L; // 0x8048f3d
        quantum_frand();
        float80_t v36 = 2 * g21 - 1.0L; // 0x8048f4d
        float32_t v37 = v35 * v35 + v36 * v36; // 0x8048f60
        g21 = 1.0L;
        if (v37 <= 1.0f) {
            // if_8048f6a_0_false
            if (v37 >= 1.0f) {
                // if_8048f6a_1_false
                // branch -> after_if_8048f6a_0
            }
        }
        // after_if_8048f6a_0
        // branch -> 0x8048f32
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/error.c
// Address range: 0x8049f64 - 0x8049f7b
// Line range:    31 - 38
char * quantum_error_handler(char * (*f)(int32_t)) {
    // 0x8049f64
    char * result;
    if (f == NULL) {
        // 0x8049f64
        result = g11;
        // branch -> 0x8049f75
    } else {
        // 0x8049f6d
        g11 = (char *)f;
        result = (char *)f;
        // branch -> 0x8049f75
    }
    // 0x8049f75
    int32_t v1;
    g2 = v1;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/error.c
// Address range: 0x8049f7c - 0x804a01b
// Line range:    42 - 64
char * quantum_strerr(int32_t errno) {
    // 0x8049f7c
    int32_t v1;
    char * result;
    if (errno == 3) {
        result = "matrix too large";
        // 0x804a017
        g2 = v1;
        return result;
    }
    // 0x8049f8e
    if (errno <= 3) {
        // 0x8049f94
        if (errno == 1) {
            result = "failure";
            // 0x804a017
            g2 = v1;
            return result;
        }
        // 0x8049f9a
        if (errno <= 1 && errno != 0) {
            // 0x804a010
            result = "unknown error code";
            // branch -> 0x804a017
        } else {
            result = errno > 1 ? "malloc failed" : "success";
        }
        // 0x804a017
        g2 = v1;
        return result;
    }
    // 0x8049fa8
    if (errno == 5) {
        result = "hash table full";
        // 0x804a017
        g2 = v1;
        return result;
    }
    // 0x8049fae
    if (errno < 5) {
        result = "wrong matrix size";
        // 0x804a017
        g2 = v1;
        return result;
    }
    // 0x8049fb4
    if (errno == 0x10000) {
        result = "single-column matrix expected";
        // 0x804a017
        g2 = v1;
        return result;
    }
    // 0x8049fbd
    if (errno != 0x10001) {
        // 0x804a010
        result = "unknown error code";
        // branch -> 0x804a017
    } else {
        result = "unknown opcode";
    }
    // 0x804a017
    g2 = v1;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/error.c
// Address range: 0x804a01c - 0x804a087
// Line range:    68 - 80
void quantum_error(int32_t errno) {
    char * v1 = quantum_error_handler(NULL); // 0x804a029
    if (v1 != NULL) {
        // 0x804a037
        g1 = (int32_t)v1;
        ((int32_t (*)(int32_t))v1)(errno);
        int32_t v2;
        g2 = v2;
        return;
    }
    // 0x804a044
    fflush((struct _IO_FILE *)g10);
    char * v3 = quantum_strerr(errno); // 0x804a057
    fprintf(g9, "ERROR: %s\n", v3);
    fflush(g9);
    abort();
    // UNREACHABLE
}

// From module:   /home/naftali/source/libquantum-0.9.1/expn.c
// Address range: 0x804a088 - 0x804a12f
// Line range:    35 - 51
void quantum_exp_mod_n(int32_t N, uint32_t x, int32_t width_input, int32_t width2, struct quantum_reg_struct_2 * reg) {
    // 0x804a088
    quantum_sigma_x(2 * width2 + 2, (struct quantum_reg_struct_3 *)reg);
    if (width_input < 1) {
        // 0x804a12b
        return;
    }
    int64_t v1 = 0x100000000 * (int64_t)(x / 0x80000000) | (int64_t)x; // 0x804a0b7
    int32_t v2 = N; // 0x804a114
    int32_t v3 = 1;
    // branch -> 0x804a0af
    while (true) {
        int64_t v4 = v2; // 0x804a0b7
        int32_t v5 = v1 % v4; // 0x804a0b7
        if (v3 > 1) {
            int32_t v6 = 1; // 0x804a0de24
            int32_t v7 = v5 * v5; // 0x804a0c9
            int32_t v8 = (0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % v4; // 0x804a0d8
            // branch -> 0x804a0c6
            while (v6 + 1 < v3) {
                // 0x804a0c6
                v6++;
                v5 = v8;
                v7 = v5 * v5;
                v8 = (0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % v4;
                // continue -> 0x804a0c6
            }
            // 0x804a0e2
            v5 = v8;
            // branch -> 0x804a0ea
        }
        // 0x804a0ea
        mul_mod_n(v2, v5, 3 * width2 + 1 + v3, width2, (struct quantum_reg_struct_7 *)reg);
        int32_t v9 = v3 + 1;
        if (v9 > width_input) {
            // 0x804a12b
            return;
        }
        // 0x804a0ea
        v2 = N;
        v3 = v9;
        // branch -> 0x804a0af
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804a130 - 0x804a251
// Line range:    42 - 64
void quantum_cnot(int32_t control, uint32_t target, struct quantum_reg_struct_3 * reg) {
    // 0x804a130
    int32_t v1;
    int32_t i = v1; // bp-28
    int32_t v2 = g5; // 0x804a133
    int32_t v3 = g7; // 0x804a134
    int32_t v4 = g3; // 0x804a135
    quantum_qec_get_status(&i, NULL);
    if (i == 0) {
        // 0x804a171
        if (quantum_objcode_put(1) == 0) {
            char v5 = 0x1000000 * target / 0x1000000 % 32; // 0x804a209
            int32_t v6 = (int32_t)reg; // bp+034
            if (*(int32_t *)(v6 + 4) > 0) {
                uint32_t v7 = target % 32; // 0x804a20c
                struct quantum_reg_struct_3 * v8 = reg; // 0x804a23044
                int32_t v9 = 0;
                // branch -> 0x804a19f
                struct quantum_reg_struct_3 * v10; // 0x804a230
                while (true) {
                    int32_t * v11 = (int32_t *)(v6 + 12); // 0x804a1a2_0
                    int32_t v12 = 16 * v9; // 0x804a1a8
                    int32_t v13 = *v11 + v12; // 0x804a1ab
                    int32_t v14 = *(int32_t *)(v13 + 12); // 0x804a1ae
                    g6 = v14;
                    uint32_t v15 = *(int32_t *)(v13 + 8); // 0x804a1b1
                    g4 = control;
                    char v16 = 0x1000000 * control / 0x1000000 % 32; // 0x804a1b7
                    int32_t v17 = v15; // 0x804a1c526
                    if (v16 != 0) {
                        uint32_t v18 = (int32_t)v16; // 0x804a1b7
                        v17 = v14 << 32 - v18 | v15 >> v18;
                        // branch -> after_if_804a1b7_0
                    }
                    uint32_t v19 = control % 32; // 0x804a1ba
                    int32_t v20 = v14; // 0x804a1c1
                    if (v19 != 0) {
                        int32_t v21 = v14 >> v19; // 0x804a1ba
                        g6 = v21;
                        v20 = v21;
                        // branch -> after_if_804a1ba_0
                    }
                    if (control != 32) {
                        // 0x804a1c1
                        g6 = 0;
                        v17 = v20;
                        // branch -> 0x804a1c5
                    }
                    // 0x804a1c5
                    v10 = v8;
                    if (v17 % 2 != 0) {
                        int32_t v22 = *v11 + v12; // 0x804a1d8
                        int32_t v23 = *v11 + v12; // 0x804a1e9
                        int32_t v24 = *(int32_t *)(v23 + 8); // 0x804a1ec
                        g7 = v24;
                        int32_t v25 = *(int32_t *)(v23 + 12); // 0x804a1ef
                        g5 = v25;
                        int32_t v26 = 1; // 0x804a213
                        if (v7 != 0) {
                            // if_804a20c_0_true
                            v26 = 1 << v7;
                            // branch -> after_if_804a20c_0
                        }
                        int32_t v27 = v26; // 0x804a217
                        int32_t v28 = v5 == 0 ? 0 : 1 >> 32 - (int32_t)v5; // 0x804a219
                        if (target != 32) {
                            // 0x804a213
                            v27 = 0;
                            v28 = v26;
                            // branch -> 0x804a217
                        }
                        // 0x804a217
                        g3 = v28;
                        int32_t v29 = v28 ^ v25; // 0x804a221
                        g6 = v29;
                        g4 = v22;
                        *(int32_t *)(v22 + 8) = v27 ^ v24;
                        *(int32_t *)(g4 + 12) = v29;
                        v10 = reg;
                        // branch -> 0x804a22c
                    }
                    int32_t v30 = v9 + 1; // 0x804a22c
                    int32_t v31 = (int32_t)v10; // 0x804a230_0
                    if (*(int32_t *)(v31 + 4) <= v30) {
                        // break -> 0x804a23f
                        break;
                    }
                    v8 = v10;
                    v6 = v31;
                    v9 = v30;
                    // continue -> 0x804a19f
                }
                // 0x804a23f
                quantum_decohere((struct quantum_reg_struct *)v10);
                // branch -> 0x804a24a
                // 0x804a24a
                g3 = v4;
                g7 = v3;
                g5 = v2;
                return;
            }
            // 0x804a23f
            quantum_decohere((struct quantum_reg_struct *)reg);
            // branch -> 0x804a24a
        }
    } else {
        // 0x804a153
        quantum_cnot_ft(control, target, (struct quantum_reg_struct_8 *)reg);
        // branch -> 0x804a24a
    }
    // 0x804a24a
    g3 = v4;
    g7 = v3;
    g5 = v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804a252 - 0x804a3b2
// Line range:    70 - 98
void quantum_toffoli(int32_t control1, uint32_t control2, uint32_t target, struct quantum_reg_struct_3 * reg) {
    // 0x804a252
    int32_t v1;
    int32_t i = v1; // bp-28
    int32_t v2 = g5; // 0x804a255
    int32_t v3 = g7; // 0x804a256
    int32_t v4 = g3; // 0x804a257
    quantum_qec_get_status(&i, NULL);
    if (i == 0) {
        // 0x804a29a
        if (quantum_objcode_put(2) == 0) {
            int32_t v5 = 0x1000000 * control2 / 0x1000000 % 32; // 0x804a318
            char v6 = 0x1000000 * target / 0x1000000 % 32; // 0x804a36a
            int32_t v7 = (int32_t)reg; // bp+045
            if (*(int32_t *)(v7 + 4) > 0) {
                uint32_t v8 = control2 % 32; // 0x804a31b
                uint32_t v9 = target % 32; // 0x804a36d
                struct quantum_reg_struct_3 * v10 = reg; // 0x804a39155
                int32_t v11 = 0;
                // branch -> 0x804a2cf
                struct quantum_reg_struct_3 * v12; // 0x804a391
                while (true) {
                    int32_t * v13 = (int32_t *)(v7 + 12); // 0x804a2d2_0
                    int32_t v14 = 16 * v11; // 0x804a2d8
                    int32_t v15 = *v13 + v14; // 0x804a2db
                    int32_t v16 = *(int32_t *)(v15 + 12); // 0x804a2de
                    g6 = v16;
                    uint32_t v17 = *(int32_t *)(v15 + 8); // 0x804a2e1
                    g4 = control1;
                    char v18 = 0x1000000 * control1 / 0x1000000 % 32; // 0x804a2e7
                    int32_t v19 = v17; // 0x804a2f534
                    if (v18 != 0) {
                        uint32_t v20 = (int32_t)v18; // 0x804a2e7
                        v19 = v16 << 32 - v20 | v17 >> v20;
                        // branch -> after_if_804a2e7_0
                    }
                    uint32_t v21 = control1 % 32; // 0x804a2ea
                    int32_t v22 = v16; // 0x804a2f1
                    if (v21 != 0) {
                        int32_t v23 = v16 >> v21; // 0x804a2ea
                        g6 = v23;
                        v22 = v23;
                        // branch -> after_if_804a2ea_0
                    }
                    if (control1 != 32) {
                        // 0x804a2f1
                        g6 = 0;
                        v19 = v22;
                        // branch -> 0x804a2f5
                    }
                    // 0x804a2f5
                    v12 = v10;
                    if (v19 % 2 != 0) {
                        int32_t v24 = *v13 + v14; // 0x804a30c
                        int32_t v25 = *(int32_t *)(v24 + 12); // 0x804a30f
                        g6 = v25;
                        uint32_t v26 = *(int32_t *)(v24 + 8); // 0x804a312
                        g4 = control2;
                        int32_t v27 = v26; // 0x804a32637
                        if ((char)v5 != 0) {
                            // if_804a318_0_true
                            v27 = v26 >> v5 | v25 << 32 - v5;
                            // branch -> after_if_804a318_0
                        }
                        int32_t v28 = v25; // 0x804a322
                        if (v8 != 0) {
                            int32_t v29 = v25 >> v8; // 0x804a31b
                            g6 = v29;
                            v28 = v29;
                            // branch -> after_if_804a31b_0
                        }
                        if (control2 != 32) {
                            // 0x804a322
                            g6 = 0;
                            v27 = v28;
                            // branch -> 0x804a326
                        }
                        // 0x804a326
                        if (v27 % 2 != 0) {
                            int32_t v30 = *v13 + v14; // 0x804a339
                            int32_t v31 = *v13 + v14; // 0x804a34a
                            int32_t v32 = *(int32_t *)(v31 + 8); // 0x804a34d
                            g7 = v32;
                            int32_t v33 = *(int32_t *)(v31 + 12); // 0x804a350
                            g5 = v33;
                            int32_t v34 = 1; // 0x804a374
                            if (v9 != 0) {
                                // if_804a36d_0_true
                                v34 = 1 << v9;
                                // branch -> after_if_804a36d_0
                            }
                            int32_t v35 = v34; // 0x804a378
                            int32_t v36 = v6 == 0 ? 0 : 1 >> 32 - (int32_t)v6; // 0x804a37a
                            if (target != 32) {
                                // 0x804a374
                                v35 = 0;
                                v36 = v34;
                                // branch -> 0x804a378
                            }
                            // 0x804a378
                            g3 = v36;
                            int32_t v37 = v36 ^ v33; // 0x804a382
                            g6 = v37;
                            g4 = v30;
                            *(int32_t *)(v30 + 8) = v35 ^ v32;
                            *(int32_t *)(g4 + 12) = v37;
                            v12 = reg;
                            // branch -> 0x804a38d
                        } else {
                            v12 = v10;
                        }
                    }
                    int32_t v38 = v11 + 1; // 0x804a38d
                    int32_t v39 = (int32_t)v12; // 0x804a391_0
                    if (*(int32_t *)(v39 + 4) <= v38) {
                        // break -> 0x804a3a0
                        break;
                    }
                    v10 = v12;
                    v7 = v39;
                    v11 = v38;
                    // continue -> 0x804a2cf
                }
                // 0x804a3a0
                quantum_decohere((struct quantum_reg_struct *)v12);
                // branch -> 0x804a3ab
                // 0x804a3ab
                g3 = v4;
                g7 = v3;
                g5 = v2;
                return;
            }
            // 0x804a3a0
            quantum_decohere((struct quantum_reg_struct *)reg);
            // branch -> 0x804a3ab
        }
    } else {
        // 0x804a275
        quantum_toffoli_ft(control1, control2, target, (struct quantum_reg_struct_8 *)reg);
        // branch -> 0x804a3ab
    }
    // 0x804a3ab
    g3 = v4;
    g7 = v3;
    g5 = v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804a535 - 0x804a614
// Line range:    150 - 171
void quantum_sigma_x(int32_t target, struct quantum_reg_struct_3 * reg) {
    // 0x804a535
    int32_t v1;
    int32_t i = v1; // bp-28
    int32_t v2 = g5; // 0x804a538
    int32_t v3 = g7; // 0x804a539
    int32_t v4 = g3; // 0x804a53a
    quantum_qec_get_status(&i, NULL);
    if (i == 0) {
        // 0x804a56f
        if (quantum_objcode_put(3) == 0) {
            int32_t v5 = (int32_t)reg; // bp+022
            if (*(int32_t *)(v5 + 4) > 0) {
                int32_t v6 = 0;
                while (true) {
                    int32_t * v7 = (int32_t *)(v5 + 12); // 0x804a596_0
                    int32_t v8 = 16 * v6; // 0x804a59c
                    int32_t v9 = *v7 + v8; // 0x804a59f
                    int32_t v10 = *v7 + v8; // 0x804a5b0
                    int32_t v11 = *(int32_t *)(v10 + 8); // 0x804a5b3
                    g7 = v11;
                    int32_t v12 = *(int32_t *)(v10 + 12); // 0x804a5b6
                    g5 = v12;
                    char v13 = 0x1000000 * target / 0x1000000 % 32; // 0x804a5d0
                    int32_t v14 = 0;
                    if (v13 != 0) {
                        // if_804a5d0_0_true
                        v14 = 1 >> 32 - (int32_t)v13;
                        // branch -> after_if_804a5d0_0
                    }
                    uint32_t v15 = target % 32; // 0x804a5d3
                    int32_t v16 = 1; // 0x804a5da
                    if (v15 != 0) {
                        // if_804a5d3_0_true
                        v16 = 1 << v15;
                        // branch -> after_if_804a5d3_0
                    }
                    int32_t v17 = v16; // 0x804a5de
                    if (target != 32) {
                        // 0x804a5da
                        v17 = 0;
                        v14 = v16;
                        // branch -> 0x804a5de
                    }
                    // 0x804a5de
                    g3 = v14;
                    int32_t v18 = v14 ^ v12; // 0x804a5e8
                    g6 = v18;
                    g4 = v9;
                    *(int32_t *)(v9 + 8) = v17 ^ v11;
                    *(int32_t *)(g4 + 12) = v18;
                    int32_t v19 = v6 + 1; // 0x804a5f3
                    int32_t v20 = (int32_t)reg; // 0x804a5f7_0
                    if (*(int32_t *)(v20 + 4) <= v19) {
                        // break -> 0x804a602
                        break;
                    }
                    v5 = v20;
                    v6 = v19;
                    // continue -> 0x804a593
                }
                // 0x804a602
                quantum_decohere((struct quantum_reg_struct *)reg);
                // branch -> 0x804a60d
                // 0x804a60d
                g3 = v4;
                g7 = v3;
                g5 = v2;
                return;
            }
            // 0x804a602
            quantum_decohere((struct quantum_reg_struct *)reg);
            // branch -> 0x804a60d
        }
    } else {
        // 0x804a558
        quantum_sigma_x_ft(target, (struct quantum_reg_struct_8 *)reg);
        // branch -> 0x804a60d
    }
    // 0x804a60d
    g3 = v4;
    g7 = v3;
    g5 = v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804a79e - 0x804a85e
// Line range:    203 - 217
void quantum_sigma_z(int32_t target, struct quantum_reg_struct_3 * reg) {
    if (quantum_objcode_put(5) == 0) {
        int32_t v1 = (int32_t)reg; // bp+024
        struct quantum_reg_struct_3 * v2 = reg;
        if (*(int32_t *)(v1 + 4) > 0) {
            struct quantum_reg_struct_3 * v3 = reg; // 0x804a84333
            int32_t v4 = target; // 0x804a7dd
            int32_t v5 = 0;
            while (true) {
                int32_t * v6 = (int32_t *)(v1 + 12); // 0x804a7cb_0
                int32_t v7 = 16 * v5; // 0x804a7d1
                int32_t v8 = *v6 + v7; // 0x804a7d4
                int32_t v9 = *(int32_t *)(v8 + 12); // 0x804a7d7
                g6 = v9;
                uint32_t v10 = *(int32_t *)(v8 + 8); // 0x804a7da
                g4 = v4;
                char v11 = 0x1000000 * v4 / 0x1000000 % 32; // 0x804a7e0
                int32_t v12 = v10; // 0x804a7ee16
                if (v11 != 0) {
                    uint32_t v13 = (int32_t)v11; // 0x804a7e0
                    v12 = v9 << 32 - v13 | v10 >> v13;
                    // branch -> after_if_804a7e0_0
                }
                uint32_t v14 = v4 % 32; // 0x804a7e3
                int32_t v15 = v9; // 0x804a7ea
                if (v14 != 0) {
                    int32_t v16 = v9 >> v14; // 0x804a7e3
                    g6 = v16;
                    v15 = v16;
                    // branch -> after_if_804a7e3_0
                }
                if (v4 != 32) {
                    // 0x804a7ea
                    g6 = 0;
                    v12 = v15;
                    // branch -> 0x804a7ee
                }
                struct quantum_reg_struct_3 * v17 = v3; // 0x804a843
                if (v12 % 2 != 0) {
                    int32_t v18 = *v6 + v7; // 0x804a801
                    g4 = v18;
                    int32_t v19 = *v6 + v7; // 0x804a810
                    int32_t v20 = *(int32_t *)(v19 + 4); // 0x804a815
                    float80_t v21 = -(float80_t)(float32_t)*(int32_t *)v19; // 0x804a826
                    g21 = v21;
                    g6 = -(float32_t)v20;
                    *(int32_t *)v18 = (int32_t)(float32_t)v21;
                    *(int32_t *)(g4 + 4) = (int32_t)-(float32_t)v20;
                    v17 = reg;
                    // branch -> 0x804a83f
                }
                int32_t v22 = v5 + 1; // 0x804a83f
                int32_t v23 = (int32_t)v17; // 0x804a843_0
                if (*(int32_t *)(v23 + 4) > v22) {
                    // 0x804a83f
                    v3 = v17;
                    v4 = target;
                    v1 = v23;
                    v5 = v22;
                    // branch -> 0x804a7c8
                    continue;
                } else {
                    v2 = v17;
                }
            }
        }
        // 0x804a852
        quantum_decohere((struct quantum_reg_struct *)v2);
        // branch -> 0x804a85d
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804a85f - 0x804aa4a
// Line range:    224 - 268
void quantum_swaptheleads(int32_t width2, struct quantum_reg_struct_3 * reg) {
    // 0x804a85f
    int32_t v1;
    int32_t pat2 = v1; // bp-40
    int32_t v2 = width2;
    int32_t v3 = g5; // 0x804a862
    int32_t v4 = g7; // 0x804a863
    int32_t v5 = g3; // 0x804a864
    quantum_qec_get_status(&pat2, NULL);
    if (pat2 == 0) {
        // 0x804aa34
        if (*(int32_t *)((int32_t)reg + 4) > 0) {
            int32_t v6 = 0;
            while (true) {
                // 0x804a905
                if (quantum_objcode_put(14) == 0) {
                    int32_t * v7 = (int32_t *)((int32_t)reg + 12); // 0x804a923_0
                    int32_t v8 = 16 * v6; // 0x804a929
                    if ((char)(0x1000000 * v2 / 0x1000000 % 32) != 0) {
                        // if_804a944_0_true
                        // branch -> after_if_804a944_0
                    }
                    uint32_t v9 = v2 % 32; // 0x804a947
                    int32_t v10 = 1; // 0x804a94e
                    if (v9 != 0) {
                        // if_804a947_0_true
                        v10 = 1 << v9;
                        // branch -> after_if_804a947_0
                    }
                    if (v2 != 32) {
                        // 0x804a94e
                        v10 = 0;
                        // branch -> 0x804a952
                    }
                    int32_t v11 = v10 - 1 & *(int32_t *)(*v7 + v8 + 8); // 0x804a955
                    int32_t v12 = *v7 + v8; // 0x804a97672
                    int32_t v13 = 0;
                    int32_t v14; // 0x804aa30
                    int32_t v15; // 0x804a9d6
                    uint32_t v16; // 0x804a9fc
                    uint32_t v17; // 0x804aa0f
                    int32_t v18; // 0x804a9e1
                    int32_t v19; // 0x804a9f5
                    int32_t v20; // 0x804aa08
                    int32_t v21; // 0x804aa21
                    uint32_t v22; // 0x804a9ca
                    int32_t v23; // 0x804a9cd
                    int32_t v24; // 0x804a9e3
                    if (v2 > 0) {
                        int32_t v25 = 0; // 0x804a9af74
                        int32_t v26 = 0; // 0x804a9a673
                        while (true) {
                            uint32_t v27 = v25 + v2; // 0x804a987
                            if ((char)(0x1000000 * v27 / 0x1000000 % 32) != 0) {
                                // if_804a994_0_true
                                // branch -> after_if_804a994_0
                            }
                            uint32_t v28 = v27 % 32; // 0x804a997
                            int32_t v29 = 1; // 0x804a99e
                            if (v28 != 0) {
                                // if_804a997_0_true
                                v29 = 1 << v28;
                                // branch -> after_if_804a997_0
                            }
                            if (v27 != 32) {
                                // 0x804a99e
                                v29 = 0;
                                // branch -> 0x804a9a2
                            }
                            int32_t v30 = (v29 & *(int32_t *)(v12 + 8)) + v26; // 0x804a9a9
                            int32_t v31 = v25 + 1; // 0x804a9af
                            int32_t v32 = *v7 + v8; // 0x804a976
                            if (v31 >= v2) {
                                v12 = v32;
                                v13 = v30;
                                // break -> 0x804a9bb
                                break;
                            }
                            v12 = v32;
                            v25 = v31;
                            v26 = v30;
                            // continue -> 0x804a96a
                        }
                        // 0x804a9bb
                        v22 = *(int32_t *)(v12 + 8);
                        v23 = *(int32_t *)(v12 + 12);
                        g3 = v23;
                        v15 = v13 + v11;
                        v18 = v22 - v15;
                        g7 = v18;
                        v24 = (int32_t)(v22 < v15) + v23 - (v15 >> 31);
                        g5 = v24;
                        v19 = v11 << v9;
                        v16 = v18 + v19;
                        v20 = v13 >> v9;
                        v17 = v16 + v20;
                        v21 = *v7 + v8;
                        g4 = v21;
                        *(int32_t *)(v21 + 8) = v17;
                        *(int32_t *)(g4 + 12) = (v20 >> 31) + (v19 >> 31) + v24 + (int32_t)(v16 < v18) + (int32_t)(v17 < v16);
                        v14 = v6 + 1;
                        if (*(int32_t *)((int32_t)reg + 4) <= v14) {
                            // 0x804aa43
                            g3 = v5;
                            g7 = v4;
                            g5 = v3;
                            return;
                        }
                      lab_0x804a9bb:
                        // 0x804a9bb
                        v6 = v14;
                        // branch -> 0x804a905
                        continue;
                    }
                    // 0x804a9bb
                    v22 = *(int32_t *)(v12 + 8);
                    v23 = *(int32_t *)(v12 + 12);
                    g3 = v23;
                    v15 = v13 + v11;
                    v18 = v22 - v15;
                    g7 = v18;
                    v24 = (int32_t)(v22 < v15) + v23 - (v15 >> 31);
                    g5 = v24;
                    v19 = v11 << v9;
                    v16 = v18 + v19;
                    v20 = v13 >> v9;
                    v17 = v16 + v20;
                    v21 = *v7 + v8;
                    g4 = v21;
                    *(int32_t *)(v21 + 8) = v17;
                    *(int32_t *)(g4 + 12) = (v20 >> 31) + (v19 >> 31) + v24 + (int32_t)(v16 < v18) + (int32_t)(v17 < v16);
                    v14 = v6 + 1;
                    if (*(int32_t *)((int32_t)reg + 4) > v14) {
                        goto lab_0x804a9bb;
                    }
                    // 0x804aa43
                    g3 = v5;
                    g7 = v4;
                    g5 = v3;
                    return;
                }
            }
        }
    } else {
        // 0x804a8ec
        if (width2 > 0) {
            int32_t v33 = 0;
            quantum_cnot(v33, v33 + width2, reg);
            quantum_cnot(v2 + v33, v33, reg);
            quantum_cnot(v33, v2 + v33, reg);
            int32_t v34 = v33 + 1; // 0x804a8e8
            while (v34 < v2) {
                // 0x804a88b
                width2 = v2;
                v33 = v34;
                quantum_cnot(v33, v33 + width2, reg);
                quantum_cnot(v2 + v33, v33, reg);
                quantum_cnot(v33, v2 + v33, reg);
                v34 = v33 + 1;
                // continue -> 0x804a88b
            }
            // 0x804aa43
            g3 = v5;
            g7 = v4;
            g5 = v3;
            return;
        }
    }
    // 0x804aa43
    g3 = v5;
    g7 = v4;
    g5 = v3;
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804aa4b - 0x804aaf8
// Line range:    275 - 284
void quantum_swaptheleads_omuln_controlled(int32_t control, int32_t width2, struct quantum_reg_struct_3 * reg) {
    if (width2 > 0) {
        int32_t v1 = 0;
        int32_t v2 = 2 * width2 + 2 + v1; // 0x804aa65
        g4 = v2;
        int32_t v3 = v1 + width2; // 0x804aa6e
        quantum_toffoli(control, v3, v2, reg);
        g4 = v3;
        quantum_toffoli(control, v2, v3, reg);
        g4 = v2;
        quantum_toffoli(control, v3, v2, reg);
        int32_t v4 = v1 + 1; // 0x804aae7
        // branch -> 0x804aa5d
        while (v4 < width2) {
            // 0x804aa5d
            // 0x804aa5d
            v1 = v4;
            v2 = 2 * width2 + 2 + v1;
            g4 = v2;
            v3 = v1 + width2;
            quantum_toffoli(control, v3, v2, reg);
            g4 = v3;
            quantum_toffoli(control, v2, v3, reg);
            g4 = v2;
            quantum_toffoli(control, v3, v2, reg);
            v4 = v1 + 1;
            // branch -> 0x804aa5d
        }
        // 0x804aaf7
        return;
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804aaf9 - 0x804b508
// Line range:    290 - 442
void quantum_gate1(int32_t target, struct quantum_matrix_struct_1 m, struct quantum_reg_struct_3 * reg) {
    struct quantum_reg_struct_3 v1; // 0x804ac11
    struct quantum_reg_struct_3 v2; // 0x804ae67
    // 0x804aaf9
    float64_t v3;
    float64_t t = v3; // bp-76
    char * v4;
    char * done = v4; // bp-68
    float32_t v5;
    float32_t limit = v5; // bp-64
    int32_t v6;
    int32_t sorted = v6; // bp-60
    int32_t v7;
    int32_t decsize = v7; // bp-56
    int32_t v8;
    int32_t addsize = v8; // bp-52
    int32_t v9;
    int32_t iset = v9; // bp-48
    int32_t v10;
    int32_t k = v10; // bp-44
    int32_t v11;
    int32_t j = v11; // bp-40
    int32_t v12;
    int32_t i = v12; // bp-36
    int32_t v13 = g5; // 0x804aafc
    int32_t v14 = g7; // 0x804aafd
    int32_t v15 = g3; // 0x804aafe
    iset = 0;
    addsize = 0;
    decsize = 1;
    t = 0.0;
    int32_t v16; // 0x804accd
    int32_t v17; // 0x804acbc
    int32_t v18; // 0x804b3f7
    int32_t * v19; // 0x804ab96_0
    int32_t * v20; // 0x804abe8_0
    int32_t * v21; // 0x804ac26_0
    int32_t mem; // 0x804ac4d_5
    int32_t * v22; // 0x804af8c_0
    int32_t * v23; // 0x804af8e_0
    int32_t * v24; // 0x804afc2_0
    int32_t * v25; // 0x804afc4_0
    int32_t * v26; // 0x804b15c_0
    int32_t * v27; // 0x804b15e_0
    int32_t * v28; // 0x804b231_0
    int32_t * v29; // 0x804b233_0
    float80_t v30; // 0x804b405_4
    int32_t mem3; // 0x804b4c0_5
    char * mem2; // 0x804aced
    uint32_t v31; // 0x804ad38
    int32_t v32;
    int32_t v33;
    int32_t v34;
    int32_t v35;
    int32_t v36;
    int32_t v37;
    float80_t v38;
    int32_t v39; // 0x804ad3f
    uint32_t v40; // 0x804ad29
    int32_t v41; // 0x804b3f9
    int32_t v42; // 0x804ac99
    int32_t v43; // 0x804ac35
    int32_t v44; // 0x804ac43
    int32_t v45; // 0x804acd4
    int32_t v46; // 0x804acd4195
    int32_t v47; // 0x804b3f4
    int32_t v48; // 0x804b40a
    int32_t v49; // 0x804b491
    float80_t v50; // 0x804ad80
    if (reg != (struct quantum_reg_struct_3 *)2) {
        // 0x804ab3a
        quantum_error(4);
        // branch -> 0x804ab46
        // 0x804ab46
        quantum_reconstruct_hash_4((struct quantum_reg_struct_3 *)v33);
        v21 = (int32_t *)(v33 + 4);
        v19 = (int32_t *)(v33 + 12);
        v20 = (int32_t *)v33;
        if (*v21 > 0) {
            // 0x804ab5d
            v37 = 0;
            // branch -> 0x804ab5d
            while (true) {
                // 0x804ab5d
                if (decsize == 0) {
                    goto lab_0x804ab5d;
                }
                goto lab_0x804ab63;
            }
        }
        // 0x804ac32
        v43 = *v21;
        v44 = *v19;
        mem = (int32_t)realloc((char *)v44, 16 * (iset + v43));
        g6 = mem;
        *v19 = mem;
        if (*v19 == 0) {
            // 0x804ac64
            quantum_error(2);
            // branch -> 0x804ac70
        }
        // 0x804ac70
        quantum_memman(16 * iset);
        v46 = iset;
        if (v46 <= 0) {
            // 0x804acd9
            mem2 = calloc(*v21 + v46, 1);
            limit = (int32_t)mem2;
            if ((float32_t)(int32_t)mem2 == 0.0f) {
                // 0x804acfb
                quantum_error(2);
                // branch -> 0x804ad07
            }
            // 0x804ad07
            quantum_memman(iset + *v21);
            j = *v21;
            v40 = *v20;
            g4 = v40;
            if ((char)(0x1000000 * v40 / 0x1000000 % 32) != 0) {
                // if_804ad35_0_true
                // branch -> after_if_804ad35_0
            }
            // after_if_804ad35_0
            v31 = v40 % 32;
            v39 = 1;
            if (v31 != 0) {
                // if_804ad38_0_true
                v39 = 1 << v31;
                // branch -> after_if_804ad38_0
            }
            // after_if_804ad38_0
            if (v40 == 32) {
                // 0x804ad43
                v38 = v39;
                // branch -> 0x804ad6a
            } else {
                // 0x804ad43
                if (v39 < 0) {
                    // 0x804ad56
                    v38 = 1.84467e+19L;
                    // branch -> 0x804ad6a
                } else {
                    v38 = 0.0L;
                }
            }
            // 0x804ad6a
            g19 = 9.9999999e-7L;
            v50 = 9.9999999e-7L * 1.0L / v38;
            g20 = v50;
            sorted = (float32_t)v50;
            if (*v21 > 0) {
                // 0x804ad91
                v22 = (int32_t *)v32;
                v23 = (int32_t *)(v32 + 4);
                v24 = (int32_t *)(v32 + 8);
                v25 = (int32_t *)(v32 + 12);
                v28 = (int32_t *)(v32 + 16);
                v29 = (int32_t *)(v32 + 20);
                v26 = (int32_t *)(v32 + 24);
                v27 = (int32_t *)(v32 + 28);
                v36 = 0;
                // branch -> 0x804ad91
                while (true) {
                    // 0x804ad91
                    if (*(char *)((int32_t)limit + v36) == 0) {
                        goto lab_0x804ada2_5;
                    }
                    goto lab_0x804b38f_6;
                }
            }
            // 0x804b3a2
            *v21 = iset + *v21;
            free((char *)(int32_t)limit);
            quantum_memman(-*v21);
            if (decsize != 0) {
                // 0x804b4f3
                quantum_decohere((struct quantum_reg_struct *)v33);
                g3 = v15;
                g7 = v14;
                g5 = v13;
                return;
            }
            // 0x804b3d8
            i = 0;
            if (*v21 > 0) {
                v35 = 0;
                while (true) {
                    // 0x804b3eb
                    v47 = 16 * v35;
                    v18 = *v19 + v47;
                    g6 = v18;
                    v41 = *(int32_t *)v18;
                    v30 = quantum_prob_inline_8((float64_t)(int64_t)v41);
                    g20 = v30;
                    v48 = sorted;
                    g19 = (int80_t)v48;
                    if ((float80_t)(int80_t)v48 > v30) {
                        goto lab_after_if_804b40d_0_8;
                    }
                    goto lab_if_804b40d_0_false_8;
                }
            }
            // 0x804b491
            v49 = addsize;
            if (v49 != 0) {
                // 0x804b497
                *v21 = *v21 - v49;
                mem3 = (int32_t)realloc((char *)*v19, 16 * *v21);
                g6 = mem3;
                *v19 = mem3;
                if (*v19 == 0) {
                    // 0x804b4d7
                    quantum_error(2);
                    // branch -> 0x804b4e3
                }
                // 0x804b4e3
                quantum_memman(-16 * addsize);
                // branch -> 0x804b4f3
            }
            // 0x804b4f3
            quantum_decohere((struct quantum_reg_struct *)v33);
            g3 = v15;
            g7 = v14;
            g5 = v13;
            return;
        }
        v34 = 0;
        v42 = 16 * (*v21 + v34) + *v19;
        *(int32_t *)(v42 + 8) = 0;
        *(int32_t *)(v42 + 12) = 0;
        v17 = 16 * (*v21 + v34) + *v19;
        g6 = v17;
        *(int32_t *)v17 = 0;
        *(int32_t *)(g6 + 4) = 0;
        v16 = v34 + 1;
        v45 = iset;
        while (v16 < v45) {
            // 0x804ac87
            v34 = v16;
            v42 = 16 * (*v21 + v34) + *v19;
            *(int32_t *)(v42 + 8) = 0;
            *(int32_t *)(v42 + 12) = 0;
            v17 = 16 * (*v21 + v34) + *v19;
            g6 = v17;
            *(int32_t *)v17 = 0;
            *(int32_t *)(g6 + 4) = 0;
            v16 = v34 + 1;
            v45 = iset;
            // continue -> 0x804ac87
        }
        // 0x804acd9
        mem2 = calloc(*v21 + v45, 1);
        limit = (int32_t)mem2;
        if ((float32_t)(int32_t)mem2 == 0.0f) {
            // 0x804acfb
            quantum_error(2);
            // branch -> 0x804ad07
        }
        // 0x804ad07
        quantum_memman(iset + *v21);
        j = *v21;
        v40 = *v20;
        g4 = v40;
        if ((char)(0x1000000 * v40 / 0x1000000 % 32) != 0) {
            // if_804ad35_0_true
            // branch -> after_if_804ad35_0
        }
        // after_if_804ad35_0
        v31 = v40 % 32;
        v39 = 1;
        if (v31 != 0) {
            // if_804ad38_0_true
            v39 = 1 << v31;
            // branch -> after_if_804ad38_0
        }
        // after_if_804ad38_0
        if (v40 == 32) {
            // 0x804ad43
            v38 = v39;
            // branch -> 0x804ad6a
        } else {
            // 0x804ad43
            if (v39 < 0) {
                // 0x804ad56
                v38 = 1.84467e+19L;
                // branch -> 0x804ad6a
            } else {
                v38 = 0.0L;
            }
        }
        // 0x804ad6a
        g19 = 9.9999999e-7L;
        v50 = 9.9999999e-7L * 1.0L / v38;
        g20 = v50;
        sorted = (float32_t)v50;
        if (*v21 > 0) {
            // 0x804ad91
            v22 = (int32_t *)v32;
            v23 = (int32_t *)(v32 + 4);
            v24 = (int32_t *)(v32 + 8);
            v25 = (int32_t *)(v32 + 12);
            v28 = (int32_t *)(v32 + 16);
            v29 = (int32_t *)(v32 + 20);
            v26 = (int32_t *)(v32 + 24);
            v27 = (int32_t *)(v32 + 28);
            v36 = 0;
            // branch -> 0x804ad91
            while (true) {
                // 0x804ad91
                if (*(char *)((int32_t)limit + v36) == 0) {
                    goto lab_0x804ada2_5;
                }
                goto lab_0x804b38f_6;
            }
        }
        // 0x804b3a2
        *v21 = iset + *v21;
        free((char *)(int32_t)limit);
        quantum_memman(-*v21);
        if (decsize == 0) {
            // 0x804b3d8
            i = 0;
            if (*v21 > 0) {
                v35 = 0;
                while (true) {
                    // 0x804b3eb
                    v47 = 16 * v35;
                    v18 = *v19 + v47;
                    g6 = v18;
                    v41 = *(int32_t *)v18;
                    v30 = quantum_prob_inline_8((float64_t)(int64_t)v41);
                    g20 = v30;
                    v48 = sorted;
                    g19 = (int80_t)v48;
                    if ((float80_t)(int80_t)v48 > v30) {
                        goto lab_after_if_804b40d_0_8;
                    }
                    goto lab_if_804b40d_0_false_8;
                }
            }
            // 0x804b491
            v49 = addsize;
            if (v49 != 0) {
                // 0x804b497
                *v21 = *v21 - v49;
                mem3 = (int32_t)realloc((char *)*v19, 16 * *v21);
                g6 = mem3;
                *v19 = mem3;
                if (*v19 == 0) {
                    // 0x804b4d7
                    quantum_error(2);
                    // branch -> 0x804b4e3
                }
                // 0x804b4e3
                quantum_memman(-16 * addsize);
                // branch -> 0x804b4f3
            }
        }
        // 0x804b4f3
        quantum_decohere((struct quantum_reg_struct *)v33);
        g3 = v15;
        g7 = v14;
        g5 = v13;
        return;
    }
    // 0x804ab32
    if (m.e0 != 2) {
        // 0x804ab3a
        quantum_error(4);
        // branch -> 0x804ab46
    }
    // 0x804ab46
    quantum_reconstruct_hash_4((struct quantum_reg_struct_3 *)v33);
    v21 = (int32_t *)(v33 + 4);
    v19 = (int32_t *)(v33 + 12);
    v20 = (int32_t *)v33;
    if (*v21 <= 0) {
        // 0x804ac32
        v43 = *v21;
        v44 = *v19;
        mem = (int32_t)realloc((char *)v44, 16 * (iset + v43));
        g6 = mem;
        *v19 = mem;
        if (*v19 == 0) {
            // 0x804ac64
            quantum_error(2);
            // branch -> 0x804ac70
        }
        // 0x804ac70
        quantum_memman(16 * iset);
        v46 = iset;
        if (v46 <= 0) {
            // 0x804acd9
            mem2 = calloc(*v21 + v46, 1);
            limit = (int32_t)mem2;
            if ((float32_t)(int32_t)mem2 == 0.0f) {
                // 0x804acfb
                quantum_error(2);
                // branch -> 0x804ad07
            }
            // 0x804ad07
            quantum_memman(iset + *v21);
            j = *v21;
            v40 = *v20;
            g4 = v40;
            if ((char)(0x1000000 * v40 / 0x1000000 % 32) != 0) {
                // if_804ad35_0_true
                // branch -> after_if_804ad35_0
            }
            // after_if_804ad35_0
            v31 = v40 % 32;
            v39 = 1;
            if (v31 != 0) {
                // if_804ad38_0_true
                v39 = 1 << v31;
                // branch -> after_if_804ad38_0
            }
            // after_if_804ad38_0
            if (v40 == 32) {
                // 0x804ad43
                v38 = v39;
                // branch -> 0x804ad6a
            } else {
                // 0x804ad43
                if (v39 < 0) {
                    // 0x804ad56
                    v38 = 1.84467e+19L;
                    // branch -> 0x804ad6a
                } else {
                    v38 = 0.0L;
                }
            }
            // 0x804ad6a
            g19 = 9.9999999e-7L;
            v50 = 9.9999999e-7L * 1.0L / v38;
            g20 = v50;
            sorted = (float32_t)v50;
            if (*v21 > 0) {
                // 0x804ad91
                v22 = (int32_t *)v32;
                v23 = (int32_t *)(v32 + 4);
                v24 = (int32_t *)(v32 + 8);
                v25 = (int32_t *)(v32 + 12);
                v28 = (int32_t *)(v32 + 16);
                v29 = (int32_t *)(v32 + 20);
                v26 = (int32_t *)(v32 + 24);
                v27 = (int32_t *)(v32 + 28);
                v36 = 0;
                // branch -> 0x804ad91
                while (true) {
                    // 0x804ad91
                    if (*(char *)((int32_t)limit + v36) == 0) {
                        goto lab_0x804ada2_5;
                    }
                    goto lab_0x804b38f_6;
                }
            }
            // 0x804b3a2
            *v21 = iset + *v21;
            free((char *)(int32_t)limit);
            quantum_memman(-*v21);
            if (decsize == 0) {
                // 0x804b3d8
                i = 0;
                if (*v21 > 0) {
                    v35 = 0;
                    while (true) {
                        // 0x804b3eb
                        v47 = 16 * v35;
                        v18 = *v19 + v47;
                        g6 = v18;
                        v41 = *(int32_t *)v18;
                        v30 = quantum_prob_inline_8((float64_t)(int64_t)v41);
                        g20 = v30;
                        v48 = sorted;
                        g19 = (int80_t)v48;
                        if ((float80_t)(int80_t)v48 > v30) {
                            goto lab_after_if_804b40d_0_8;
                        }
                        goto lab_if_804b40d_0_false_8;
                    }
                }
                // 0x804b491
                v49 = addsize;
                if (v49 != 0) {
                    // 0x804b497
                    *v21 = *v21 - v49;
                    mem3 = (int32_t)realloc((char *)*v19, 16 * *v21);
                    g6 = mem3;
                    *v19 = mem3;
                    if (*v19 == 0) {
                        // 0x804b4d7
                        quantum_error(2);
                        // branch -> 0x804b4e3
                    }
                    // 0x804b4e3
                    quantum_memman(-16 * addsize);
                    // branch -> 0x804b4f3
                }
            }
            // 0x804b4f3
            quantum_decohere((struct quantum_reg_struct *)v33);
            g3 = v15;
            g7 = v14;
            g5 = v13;
            return;
        }
        v34 = 0;
        v42 = 16 * (*v21 + v34) + *v19;
        *(int32_t *)(v42 + 8) = 0;
        *(int32_t *)(v42 + 12) = 0;
        v17 = 16 * (*v21 + v34) + *v19;
        g6 = v17;
        *(int32_t *)v17 = 0;
        *(int32_t *)(g6 + 4) = 0;
        v16 = v34 + 1;
        v45 = iset;
        while (v16 < v45) {
            // 0x804ac87
            v34 = v16;
            v42 = 16 * (*v21 + v34) + *v19;
            *(int32_t *)(v42 + 8) = 0;
            *(int32_t *)(v42 + 12) = 0;
            v17 = 16 * (*v21 + v34) + *v19;
            g6 = v17;
            *(int32_t *)v17 = 0;
            *(int32_t *)(g6 + 4) = 0;
            v16 = v34 + 1;
            v45 = iset;
            // continue -> 0x804ac87
        }
        // 0x804acd9
        mem2 = calloc(*v21 + v45, 1);
        limit = (int32_t)mem2;
        if ((float32_t)(int32_t)mem2 == 0.0f) {
            // 0x804acfb
            quantum_error(2);
            // branch -> 0x804ad07
        }
        // 0x804ad07
        quantum_memman(iset + *v21);
        j = *v21;
        v40 = *v20;
        g4 = v40;
        if ((char)(0x1000000 * v40 / 0x1000000 % 32) != 0) {
            // if_804ad35_0_true
            // branch -> after_if_804ad35_0
        }
        // after_if_804ad35_0
        v31 = v40 % 32;
        v39 = 1;
        if (v31 != 0) {
            // if_804ad38_0_true
            v39 = 1 << v31;
            // branch -> after_if_804ad38_0
        }
        // after_if_804ad38_0
        if (v40 == 32) {
            // 0x804ad43
            v38 = v39;
            // branch -> 0x804ad6a
        } else {
            // 0x804ad43
            if (v39 < 0) {
                // 0x804ad56
                v38 = 1.84467e+19L;
                // branch -> 0x804ad6a
            } else {
                v38 = 0.0L;
            }
        }
        // 0x804ad6a
        g19 = 9.9999999e-7L;
        v50 = 9.9999999e-7L * 1.0L / v38;
        g20 = v50;
        sorted = (float32_t)v50;
        if (*v21 > 0) {
            // 0x804ad91
            v22 = (int32_t *)v32;
            v23 = (int32_t *)(v32 + 4);
            v24 = (int32_t *)(v32 + 8);
            v25 = (int32_t *)(v32 + 12);
            v28 = (int32_t *)(v32 + 16);
            v29 = (int32_t *)(v32 + 20);
            v26 = (int32_t *)(v32 + 24);
            v27 = (int32_t *)(v32 + 28);
            v36 = 0;
            // branch -> 0x804ad91
            while (true) {
                // 0x804ad91
                if (*(char *)((int32_t)limit + v36) == 0) {
                    goto lab_0x804ada2_5;
                }
                goto lab_0x804b38f_6;
            }
        }
        // 0x804b3a2
        *v21 = iset + *v21;
        free((char *)(int32_t)limit);
        quantum_memman(-*v21);
        if (decsize == 0) {
            // 0x804b3d8
            i = 0;
            if (*v21 > 0) {
                v35 = 0;
                while (true) {
                    // 0x804b3eb
                    v47 = 16 * v35;
                    v18 = *v19 + v47;
                    g6 = v18;
                    v41 = *(int32_t *)v18;
                    v30 = quantum_prob_inline_8((float64_t)(int64_t)v41);
                    g20 = v30;
                    v48 = sorted;
                    g19 = (int80_t)v48;
                    if ((float80_t)(int80_t)v48 > v30) {
                        goto lab_after_if_804b40d_0_8;
                    }
                    goto lab_if_804b40d_0_false_8;
                }
            }
            // 0x804b491
            v49 = addsize;
            if (v49 != 0) {
                // 0x804b497
                *v21 = *v21 - v49;
                mem3 = (int32_t)realloc((char *)*v19, 16 * *v21);
                g6 = mem3;
                *v19 = mem3;
                if (*v19 == 0) {
                    // 0x804b4d7
                    quantum_error(2);
                    // branch -> 0x804b4e3
                }
                // 0x804b4e3
                quantum_memman(-16 * addsize);
                // branch -> 0x804b4f3
            }
        }
        // 0x804b4f3
        quantum_decohere((struct quantum_reg_struct *)v33);
        g3 = v15;
        g7 = v14;
        g5 = v13;
        return;
    }
    // 0x804ab5d
    v37 = 0;
    // branch -> 0x804ab5d
    while (true) {
        // 0x804ab5d
        int32_t v51;
        if (decsize == 0) {
          lab_0x804ab5d:
            // 0x804ab5d
            v51 = 16 * v37;
            // branch -> 0x804ab93
        } else {
          lab_0x804ab63:;
            int32_t v52 = 16 * v37; // 0x804ab6c
            int32_t v53 = *v19 + v52; // 0x804ab6f
            int32_t v54 = *(int32_t *)(v53 + 12); // 0x804ab75
            if ((v54 ^ v37 >> 31 | *(int32_t *)(v53 + 8) ^ v37) != 0) {
                // 0x804ab8c
                decsize = 0;
                v51 = v52;
                // branch -> 0x804ab93
            } else {
                v51 = v52;
            }
        }
        int32_t v55 = *v19 + v51; // 0x804ab9f
        int32_t v56 = *(int32_t *)(v55 + 8); // 0x804aba2
        g7 = v56;
        g5 = *(int32_t *)(v55 + 12);
        if ((char)(0x1000000 * target / 0x1000000 % 32) != 0) {
            // if_804abcb_0_true
            // branch -> after_if_804abcb_0
        }
        uint32_t v57 = target % 32; // 0x804abce
        int32_t v58 = 1; // 0x804abd5
        if (v57 != 0) {
            // if_804abce_0_true
            v58 = 1 << v57;
            // branch -> after_if_804abce_0
        }
        if (target != 32) {
            // 0x804abd5
            v58 = 0;
            // branch -> 0x804abd9
        }
        // 0x804abd9
        g3 = v33;
        v1 = (struct quantum_reg_struct_3){
            .e0 = 0,
            .e1 = 0,
            .e2 = 0,
            .e3 = NULL,
            .e4 = NULL
        };
        v1.e0 = *v20;
        if (quantum_get_state_7((int64_t)(v58 ^ v56), v1) == -1) {
            // 0x804ac1b
            iset++;
            // branch -> 0x804ac1f
        }
        int32_t v59 = v37 + 1; // 0x804ac1f
        if (*v21 <= v59) {
            // break -> 0x804ac32
            break;
        }
        v37 = v59;
        // continue -> 0x804ab5d
    }
    // 0x804ac32
    v43 = *v21;
    v44 = *v19;
    mem = (int32_t)realloc((char *)v44, 16 * (iset + v43));
    g6 = mem;
    *v19 = mem;
    if (*v19 == 0) {
        // 0x804ac64
        quantum_error(2);
        // branch -> 0x804ac70
    }
    // 0x804ac70
    quantum_memman(16 * iset);
    v46 = iset;
    if (v46 <= 0) {
        // 0x804acd9
        mem2 = calloc(*v21 + v46, 1);
        limit = (int32_t)mem2;
        if ((float32_t)(int32_t)mem2 == 0.0f) {
            // 0x804acfb
            quantum_error(2);
            // branch -> 0x804ad07
        }
        // 0x804ad07
        quantum_memman(iset + *v21);
        j = *v21;
        v40 = *v20;
        g4 = v40;
        if ((char)(0x1000000 * v40 / 0x1000000 % 32) != 0) {
            // if_804ad35_0_true
            // branch -> after_if_804ad35_0
        }
        // after_if_804ad35_0
        v31 = v40 % 32;
        v39 = 1;
        if (v31 != 0) {
            // if_804ad38_0_true
            v39 = 1 << v31;
            // branch -> after_if_804ad38_0
        }
        // after_if_804ad38_0
        if (v40 == 32) {
            // 0x804ad43
            v38 = v39;
            // branch -> 0x804ad6a
        } else {
            // 0x804ad43
            if (v39 < 0) {
                // 0x804ad56
                v38 = 1.84467e+19L;
                // branch -> 0x804ad6a
            } else {
                v38 = 0.0L;
            }
        }
        // 0x804ad6a
        g19 = 9.9999999e-7L;
        v50 = 9.9999999e-7L * 1.0L / v38;
        g20 = v50;
        sorted = (float32_t)v50;
        if (*v21 > 0) {
            // 0x804ad91
            v22 = (int32_t *)v32;
            v23 = (int32_t *)(v32 + 4);
            v24 = (int32_t *)(v32 + 8);
            v25 = (int32_t *)(v32 + 12);
            v28 = (int32_t *)(v32 + 16);
            v29 = (int32_t *)(v32 + 20);
            v26 = (int32_t *)(v32 + 24);
            v27 = (int32_t *)(v32 + 28);
            v36 = 0;
            // branch -> 0x804ad91
            while (true) {
                // 0x804ad91
                if (*(char *)((int32_t)limit + v36) == 0) {
                    goto lab_0x804ada2_5;
                }
                goto lab_0x804b38f_6;
            }
        }
        // 0x804b3a2
        *v21 = iset + *v21;
        free((char *)(int32_t)limit);
        quantum_memman(-*v21);
        if (decsize == 0) {
            // 0x804b3d8
            i = 0;
            if (*v21 > 0) {
                v35 = 0;
                while (true) {
                    // 0x804b3eb
                    v47 = 16 * v35;
                    v18 = *v19 + v47;
                    g6 = v18;
                    v41 = *(int32_t *)v18;
                    v30 = quantum_prob_inline_8((float64_t)(int64_t)v41);
                    g20 = v30;
                    v48 = sorted;
                    g19 = (int80_t)v48;
                    if ((float80_t)(int80_t)v48 > v30) {
                        goto lab_after_if_804b40d_0_8;
                    }
                    goto lab_if_804b40d_0_false_8;
                }
            }
            // 0x804b491
            v49 = addsize;
            if (v49 != 0) {
                // 0x804b497
                *v21 = *v21 - v49;
                mem3 = (int32_t)realloc((char *)*v19, 16 * *v21);
                g6 = mem3;
                *v19 = mem3;
                if (*v19 == 0) {
                    // 0x804b4d7
                    quantum_error(2);
                    // branch -> 0x804b4e3
                }
                // 0x804b4e3
                quantum_memman(-16 * addsize);
                // branch -> 0x804b4f3
            }
        }
        // 0x804b4f3
        quantum_decohere((struct quantum_reg_struct *)v33);
        g3 = v15;
        g7 = v14;
        g5 = v13;
        return;
    }
    v34 = 0;
    v42 = 16 * (*v21 + v34) + *v19;
    *(int32_t *)(v42 + 8) = 0;
    *(int32_t *)(v42 + 12) = 0;
    v17 = 16 * (*v21 + v34) + *v19;
    g6 = v17;
    *(int32_t *)v17 = 0;
    *(int32_t *)(g6 + 4) = 0;
    v16 = v34 + 1;
    v45 = iset;
    while (v16 < v45) {
        // 0x804ac87
        v34 = v16;
        v42 = 16 * (*v21 + v34) + *v19;
        *(int32_t *)(v42 + 8) = 0;
        *(int32_t *)(v42 + 12) = 0;
        v17 = 16 * (*v21 + v34) + *v19;
        g6 = v17;
        *(int32_t *)v17 = 0;
        *(int32_t *)(g6 + 4) = 0;
        v16 = v34 + 1;
        v45 = iset;
        // continue -> 0x804ac87
    }
    // 0x804acd9
    mem2 = calloc(*v21 + v45, 1);
    limit = (int32_t)mem2;
    if ((float32_t)(int32_t)mem2 == 0.0f) {
        // 0x804acfb
        quantum_error(2);
        // branch -> 0x804ad07
    }
    // 0x804ad07
    quantum_memman(iset + *v21);
    j = *v21;
    v40 = *v20;
    g4 = v40;
    if ((char)(0x1000000 * v40 / 0x1000000 % 32) != 0) {
        // if_804ad35_0_true
        // branch -> after_if_804ad35_0
    }
    // after_if_804ad35_0
    v31 = v40 % 32;
    v39 = 1;
    if (v31 != 0) {
        // if_804ad38_0_true
        v39 = 1 << v31;
        // branch -> after_if_804ad38_0
    }
    // after_if_804ad38_0
    if (v40 == 32) {
        // 0x804ad43
        v38 = v39;
        // branch -> 0x804ad6a
    } else {
        // 0x804ad43
        if (v39 < 0) {
            // 0x804ad56
            v38 = 1.84467e+19L;
            // branch -> 0x804ad6a
        } else {
            v38 = 0.0L;
        }
    }
    // 0x804ad6a
    g19 = 9.9999999e-7L;
    v50 = 9.9999999e-7L * 1.0L / v38;
    g20 = v50;
    sorted = (float32_t)v50;
    if (*v21 > 0) {
        // 0x804ad91
        v22 = (int32_t *)v32;
        v23 = (int32_t *)(v32 + 4);
        v24 = (int32_t *)(v32 + 8);
        v25 = (int32_t *)(v32 + 12);
        v28 = (int32_t *)(v32 + 16);
        v29 = (int32_t *)(v32 + 20);
        v26 = (int32_t *)(v32 + 24);
        v27 = (int32_t *)(v32 + 28);
        v36 = 0;
        // branch -> 0x804ad91
        while (true) {
            // 0x804ad91
            int32_t v60; // 0x804b38f
            if (*(char *)((int32_t)limit + v36) == 0) {
              lab_0x804ada2_5:;
                int32_t v61 = 16 * v36; // 0x804adab
                if ((char)(0x1000000 * target / 0x1000000 % 32) != 0) {
                    // if_804adc6_0_true
                    // branch -> after_if_804adc6_0
                }
                uint32_t v62 = target % 32; // 0x804adc9
                int32_t v63 = 1; // 0x804add0
                if (v62 != 0) {
                    // if_804adc9_0_true
                    v63 = 1 << v62;
                    // branch -> after_if_804adc9_0
                }
                if (target != 32) {
                    // 0x804add0
                    v63 = 0;
                    // branch -> 0x804add4
                }
                // 0x804add4
                k = v63 & *(int32_t *)(*v19 + v61 + 8);
                t = 0.0;
                int32_t v64 = *(int32_t *)(*v19 + v61 + 8); // 0x804adf8
                if ((char)(0x1000000 * target / 0x1000000 % 32) != 0) {
                    // if_804ae21_0_true
                    // branch -> after_if_804ae21_0
                }
                int32_t v65 = 1; // 0x804ae2b
                if (v62 != 0) {
                    // if_804ae24_0_true
                    v65 = 1 << v62;
                    // branch -> after_if_804ae24_0
                }
                if (target != 32) {
                    // 0x804ae2b
                    v65 = 0;
                    // branch -> 0x804ae2f
                }
                // 0x804ae2f
                v2 = (struct quantum_reg_struct_3){
                    .e0 = 0,
                    .e1 = 0,
                    .e2 = 0,
                    .e3 = NULL,
                    .e4 = NULL
                };
                v2.e0 = *v20;
                int32_t v66 = quantum_get_state_7((int64_t)(v65 ^ v64), v2); // 0x804ae67
                i = v66;
                int32_t v67 = *v19 + v61; // 0x804ae7b
                int32_t v68 = *(int32_t *)v67; // 0x804ae7e
                int32_t v69 = *(int32_t *)(v67 + 4); // 0x804ae80
                done = (char *)v69;
                int32_t v70 = 0; // 0x804b165166
                if (v66 >= 0) {
                    int32_t v71 = *v19 + 16 * v66; // 0x804ae9b
                    t = (int64_t)*(int32_t *)(v71 + 4);
                    v70 = *(int32_t *)v71;
                    // branch -> 0x804aea9
                }
                // 0x804aea9
                g7 = *v19 + v61;
                int32_t v72; // ecx
                if (k == 0) {
                    int32_t v73 = *v22; // 0x804af8c
                    int32_t v74 = *v23; // 0x804af8e
                    __mulsc3((float32_t)v73, (float32_t)v74, (float32_t)v68, (float32_t)v69);
                    g5 = v69;
                    int32_t v75 = *v24; // 0x804afc2
                    int32_t v76 = *v25; // 0x804afc4
                    float32_t v77 = t; // 0x804afce_1
                    __mulsc3((float32_t)v75, (float32_t)v76, (float32_t)v70, v77);
                    int32_t v78 = v77; // 0x804afe5
                    v72 = v78;
                    int32_t v79 = v70; // 0x804afe7
                    g3 = v79;
                    float80_t v80 = v78;
                    g18 = v80;
                    *(int32_t *)g7 = (int32_t)(float32_t)((float80_t)(float32_t)v69 + v80);
                    *(int32_t *)(g7 + 4) = (int32_t)(float32_t)((float80_t)(float32_t)v68 + (float80_t)(float32_t)v79);
                    // branch -> 0x804b039
                } else {
                    int32_t v81 = *v28; // 0x804aec8
                    int32_t v82 = *v29; // 0x804aeca
                    float32_t v83 = t; // 0x804aed4_1
                    __mulsc3((float32_t)v81, (float32_t)v82, (float32_t)v70, v83);
                    int32_t v84 = v83; // 0x804aeeb
                    g5 = v84;
                    int32_t v85 = *v26; // 0x804aefe
                    int32_t v86 = *v27; // 0x804af00
                    int32_t v87 = (int32_t)done; // 0x804af0a_0
                    __mulsc3((float32_t)v85, (float32_t)v86, (float32_t)v68, (float32_t)v87);
                    v72 = v87;
                    g3 = v68;
                    float80_t v88 = v87;
                    g18 = v88;
                    *(int32_t *)g7 = (int32_t)(float32_t)((float80_t)(float32_t)v84 + v88);
                    *(int32_t *)(g7 + 4) = (int32_t)(float32_t)((float80_t)(float32_t)v70 + (float80_t)(float32_t)v68);
                    // branch -> 0x804b039
                }
                int32_t v89 = i; // 0x804b039
                int32_t v90; // 0x804b380
                if (v89 < 0) {
                    int32_t v91 = *v24; // 0x804b1de
                    int32_t v92 = *v25; // 0x804b1e0
                    bool v93 = false;
                    bool v94 = false;
                    int32_t v95 = 0; // 0x804b1ff
                    if ((float32_t)v91 >= 0.0f) {
                        // if_804b1fd_0_false
                        if ((float32_t)v91 <= 0.0f) {
                            // if_804b1fd_1_false
                            v93 = (float32_t)v91 != 0.0f;
                            v94 = (float32_t)v91 != 0.0f;
                            v95 = 1;
                            // branch -> after_if_804b1fd_0
                        } else {
                            v93 = true;
                            v94 = false;
                            v95 = 0;
                        }
                    }
                    int32_t v96 = v94 ? 1024 : 0; // 0x804b1ff
                    int32_t v97 = v92 & -0x10000; // 0x804b1ff
                    int32_t v98 = v97 | -v95 & 0x4000 | v96 | (v93 ? 256 : 0) | 0x2800; // 0x804b1ff
                    g20 = v92;
                    int32_t v99 = v72 & -256; // 0x804b204
                    int32_t v100 = ((v98 | (int32_t)v94) ^ 1) & (v99 | v95); // 0x804b20a
                    g4 = v100;
                    g19 = 0.0L;
                    bool v101 = false;
                    bool v102 = false;
                    int32_t v103 = 0; // 0x804b210
                    if ((float32_t)v92 >= 0.0f) {
                        // if_804b20e_0_false
                        if ((float32_t)v92 <= 0.0f) {
                            // if_804b20e_1_false
                            v101 = (float32_t)v92 != 0.0f;
                            v102 = (float32_t)v92 != 0.0f;
                            v103 = 1;
                            // branch -> after_if_804b20e_0
                        } else {
                            v101 = true;
                            v102 = false;
                            v103 = 0;
                        }
                    }
                    int32_t v104 = v101 ? 256 : 0; // 0x804b210
                    int32_t v105 = v102 ? 1024 : 0; // 0x804b210
                    int32_t v106 = k; // 0x804b221
                    if (v106 == 0 || ((((int32_t)v102 || v91 & -256) ^ 1) & v100 & (v97 || v103 || -v103 & 0x4000 || v105 || v104 || 0x3800)) == 0) {
                        int32_t v107 = *v28; // 0x804b231
                        int32_t v108 = *v29; // 0x804b233
                        bool v109 = false;
                        bool v110 = false;
                        int32_t v111 = 0; // 0x804b252
                        if ((float32_t)v107 >= 0.0f) {
                            // if_804b250_0_false
                            if ((float32_t)v107 <= 0.0f) {
                                // if_804b250_1_false
                                v109 = (float32_t)v107 != 0.0f;
                                v110 = (float32_t)v107 != 0.0f;
                                v111 = 1;
                                // branch -> after_if_804b250_0
                            } else {
                                v109 = true;
                                v110 = false;
                                v111 = 0;
                            }
                        }
                        int32_t v112 = v109 ? 256 : 0; // 0x804b252
                        int32_t v113 = v110 ? 1024 : 0; // 0x804b252
                        int32_t v114 = v108 & -0x10000; // 0x804b252
                        g20 = v108;
                        int32_t v115 = ((-v111 & 0x4000 | v114 | (int32_t)v110 | v113 | v112) ^ 0x2801) & (v111 | v98 & v99); // 0x804b25d
                        g4 = v115;
                        g19 = 0.0L;
                        bool v116 = false;
                        bool v117 = false;
                        int32_t v118 = 0; // 0x804b263
                        if ((float32_t)v108 >= 0.0f) {
                            // if_804b261_0_false
                            if ((float32_t)v108 <= 0.0f) {
                                // if_804b261_1_false
                                v116 = (float32_t)v108 != 0.0f;
                                v117 = (float32_t)v108 != 0.0f;
                                v118 = 1;
                                // branch -> after_if_804b261_0
                            } else {
                                v116 = true;
                                v117 = false;
                                v118 = 0;
                            }
                        }
                        int32_t v119 = v116 ? 256 : 0; // 0x804b263
                        int32_t v120 = v117 ? 1024 : 0; // 0x804b263
                        if (v106 != 0 || ((((int32_t)v117 || v107 & -256) ^ 1) & v115 & (v114 || v118 || -v118 & 0x4000 || v120 || v119 || 0x3800)) == 0) {
                            int32_t v121 = 16 * j + *v19; // 0x804b28a
                            int32_t v122 = *v19 + v61; // 0x804b29b
                            int32_t v123 = *(int32_t *)(v122 + 12); // 0x804b2a1
                            g5 = v123;
                            char v124 = 0x1000000 * target / 0x1000000 % 32; // 0x804b2c7
                            int32_t v125 = 0;
                            if (v124 != 0) {
                                // if_804b2c7_0_true
                                v125 = 1 >> 32 - (int32_t)v124;
                                // branch -> after_if_804b2c7_0
                            }
                            uint32_t v126 = target % 32; // 0x804b2ca
                            int32_t v127 = 1; // 0x804b2d1
                            if (v126 != 0) {
                                // if_804b2ca_0_true
                                v127 = 1 << v126;
                                // branch -> after_if_804b2ca_0
                            }
                            int32_t v128 = v127; // 0x804b2d5
                            if (target != 32) {
                                // 0x804b2d1
                                v128 = 0;
                                v125 = v127;
                                // branch -> 0x804b2d5
                            }
                            // 0x804b2d5
                            *(int32_t *)(v121 + 8) = v128 ^ *(int32_t *)(v122 + 8);
                            *(int32_t *)(v121 + 12) = v125 ^ v123;
                            g7 = 16 * j + *v19;
                            if (k == 0) {
                                int32_t v129 = *v28; // 0x804b34c
                                int32_t v130 = *v29; // 0x804b34e
                                int32_t v131 = (int32_t)done; // 0x804b358_0
                                __mulsc3((float32_t)v129, (float32_t)v130, (float32_t)v68, (float32_t)v131);
                                g4 = v131;
                                int32_t v132 = v68; // 0x804b371
                                g3 = v132;
                                *(int32_t *)g7 = v131;
                                *(int32_t *)(g7 + 4) = v132;
                                // branch -> 0x804b37c
                            } else {
                                int32_t v133 = *v24; // 0x804b305
                                int32_t v134 = *v25; // 0x804b307
                                int32_t v135 = (int32_t)done; // 0x804b311_0
                                __mulsc3((float32_t)v133, (float32_t)v134, (float32_t)v68, (float32_t)v135);
                                g4 = v135;
                                int32_t v136 = v68; // 0x804b32a
                                g3 = v136;
                                *(int32_t *)g7 = v135;
                                *(int32_t *)(g7 + 4) = v136;
                                // branch -> 0x804b37c
                            }
                            // 0x804b37c
                            j++;
                            // branch -> 0x804b380
                          lab_0x804b380_2:
                            // 0x804b380
                            v90 = i;
                            if (v90 >= 0) {
                              lab_0x804b386:
                                // 0x804b386
                                *(char *)((int32_t)limit + v90) = 1;
                                // branch -> 0x804b38f
                            }
                          lab_0x804b38f:
                            // 0x804b38f
                            v60 = v36 + 1;
                            if (*v21 <= v60) {
                                // break -> 0x804b3a2
                                break;
                            }
                            v36 = v60;
                            // continue -> 0x804ad91
                            continue;
                        }
                    }
                } else {
                    // 0x804b043
                    g7 = *v19 + 16 * v89;
                    if (k == 0) {
                        int32_t v137 = *v28; // 0x804b126
                        int32_t v138 = *v29; // 0x804b128
                        int32_t v139 = (int32_t)done; // 0x804b132_0
                        __mulsc3((float32_t)v137, (float32_t)v138, (float32_t)v68, (float32_t)v139);
                        g5 = v139;
                        int32_t v140 = *v26; // 0x804b15c
                        int32_t v141 = *v27; // 0x804b15e
                        float32_t v142 = t; // 0x804b168_1
                        __mulsc3((float32_t)v140, (float32_t)v141, (float32_t)v70, v142);
                        int32_t v143 = v142; // 0x804b17f
                        g4 = v143;
                        int32_t v144 = v70; // 0x804b181
                        g3 = v144;
                        float80_t v145 = v143;
                        g18 = v145;
                        float80_t v146 = (float80_t)(float32_t)v139 + v145; // 0x804b1b0
                        float80_t v147 = (float80_t)(float32_t)v68 + (float80_t)(float32_t)v144; // 0x804b1b2
                        g19 = v146;
                        g20 = v147;
                        *(int32_t *)g7 = (int32_t)(float32_t)v146;
                        *(int32_t *)(g7 + 4) = (int32_t)(float32_t)v147;
                        // branch -> 0x804b380
                        goto lab_0x804b380_2;
                    } else {
                        int32_t v148 = *v22; // 0x804b05f
                        int32_t v149 = *v23; // 0x804b061
                        float32_t v150 = t; // 0x804b06b_1
                        __mulsc3((float32_t)v148, (float32_t)v149, (float32_t)v70, v150);
                        int32_t v151 = v150; // 0x804b082
                        g5 = v151;
                        int32_t v152 = *v24; // 0x804b095
                        int32_t v153 = *v25; // 0x804b097
                        int32_t v154 = (int32_t)done; // 0x804b0a1_0
                        __mulsc3((float32_t)v152, (float32_t)v153, (float32_t)v68, (float32_t)v154);
                        g4 = v154;
                        int32_t v155 = v68; // 0x804b0ba
                        g3 = v155;
                        float80_t v156 = v154;
                        g18 = v156;
                        float80_t v157 = (float80_t)(float32_t)v151 + v156; // 0x804b0e9
                        float80_t v158 = (float80_t)(float32_t)v70 + (float80_t)(float32_t)v155; // 0x804b0eb
                        g19 = v157;
                        g20 = v158;
                        *(int32_t *)g7 = (int32_t)(float32_t)v157;
                        *(int32_t *)(g7 + 4) = (int32_t)(float32_t)v158;
                        // branch -> 0x804b380
                        goto lab_0x804b380_2;
                    }
                    // 0x804b380
                    v90 = i;
                    if (v90 < 0) {
                        goto lab_0x804b38f;
                    }
                    goto lab_0x804b386;
                }
                // 0x804b3a2
                *v21 = iset + *v21;
                free((char *)(int32_t)limit);
                quantum_memman(-*v21);
                if (decsize == 0) {
                    // 0x804b3d8
                    i = 0;
                    if (*v21 > 0) {
                        v35 = 0;
                        while (true) {
                            // 0x804b3eb
                            v47 = 16 * v35;
                            v18 = *v19 + v47;
                            g6 = v18;
                            v41 = *(int32_t *)v18;
                            v30 = quantum_prob_inline_8((float64_t)(int64_t)v41);
                            g20 = v30;
                            v48 = sorted;
                            g19 = (int80_t)v48;
                            if ((float80_t)(int80_t)v48 <= v30) {
                              lab_if_804b40d_0_false_8:
                                // if_804b40d_0_false
                                if ((float80_t)(int80_t)v48 >= v30) {
                                    // if_804b40d_1_false
                                    // branch -> after_if_804b40d_0
                                }
                            }
                          lab_after_if_804b40d_0_8:
                            // after_if_804b40d_0
                            if (i != 0) {
                                int32_t v159 = *v19 + 16 * (v35 - i); // 0x804b435
                                int32_t v160 = *v19 + v47; // 0x804b443
                                *(int32_t *)(v159 + 8) = *(int32_t *)(v160 + 8);
                                *(int32_t *)(v159 + 12) = *(int32_t *)(v160 + 12);
                                int32_t v161 = 16 * (v35 - i) + *v19; // 0x804b463
                                g4 = v161;
                                int32_t v162 = *v19 + v47; // 0x804b471
                                int32_t v163 = *(int32_t *)v162; // 0x804b474
                                g6 = v163;
                                *(int32_t *)v161 = v163;
                                *(int32_t *)(g4 + 4) = *(int32_t *)(v162 + 4);
                                // branch -> 0x804b47e
                            }
                            int32_t v164 = v35 + 1; // 0x804b47e
                            if (*v21 <= v164) {
                                // break -> 0x804b491
                                break;
                            }
                            v35 = v164;
                            // continue -> 0x804b3eb
                        }
                        // 0x804b491
                        v49 = addsize;
                        if (v49 == 0) {
                            // 0x804b4f3
                            quantum_decohere((struct quantum_reg_struct *)v33);
                            g3 = v15;
                            g7 = v14;
                            g5 = v13;
                            return;
                        }
                        // 0x804b497
                        *v21 = *v21 - v49;
                        mem3 = (int32_t)realloc((char *)*v19, 16 * *v21);
                        g6 = mem3;
                        *v19 = mem3;
                        if (*v19 != 0) {
                            // 0x804b4e3
                            quantum_memman(-16 * addsize);
                            // branch -> 0x804b4f3
                            // 0x804b4f3
                            quantum_decohere((struct quantum_reg_struct *)v33);
                            g3 = v15;
                            g7 = v14;
                            g5 = v13;
                            return;
                        }
                        // 0x804b4d7
                        quantum_error(2);
                        // branch -> 0x804b4e3
                        // 0x804b4e3
                        quantum_memman(-16 * addsize);
                        // branch -> 0x804b4f3
                        // 0x804b4f3
                        quantum_decohere((struct quantum_reg_struct *)v33);
                        g3 = v15;
                        g7 = v14;
                        g5 = v13;
                        return;
                    }
                    // 0x804b491
                    v49 = addsize;
                    if (v49 != 0) {
                        // 0x804b497
                        *v21 = *v21 - v49;
                        mem3 = (int32_t)realloc((char *)*v19, 16 * *v21);
                        g6 = mem3;
                        *v19 = mem3;
                        if (*v19 != 0) {
                            // 0x804b4e3
                            quantum_memman(-16 * addsize);
                            // branch -> 0x804b4f3
                            // 0x804b4f3
                            quantum_decohere((struct quantum_reg_struct *)v33);
                            g3 = v15;
                            g7 = v14;
                            g5 = v13;
                            return;
                        }
                        // 0x804b4d7
                        quantum_error(2);
                        // branch -> 0x804b4e3
                        // 0x804b4e3
                        quantum_memman(-16 * addsize);
                        // branch -> 0x804b4f3
                        // 0x804b4f3
                        quantum_decohere((struct quantum_reg_struct *)v33);
                        g3 = v15;
                        g7 = v14;
                        g5 = v13;
                        return;
                    }
                }
                // 0x804b4f3
                quantum_decohere((struct quantum_reg_struct *)v33);
                g3 = v15;
                g7 = v14;
                g5 = v13;
                return;
            }
          lab_0x804b38f_6:
            // 0x804b38f
            v60 = v36 + 1;
            if (*v21 <= v60) {
                // break -> 0x804b3a2
                break;
            }
            v36 = v60;
            // continue -> 0x804ad91
        }
    }
    // 0x804b3a2
    *v21 = iset + *v21;
    free((char *)(int32_t)limit);
    quantum_memman(-*v21);
    if (decsize == 0) {
        // 0x804b3d8
        i = 0;
        if (*v21 > 0) {
            v35 = 0;
            while (true) {
                // 0x804b3eb
                v47 = 16 * v35;
                v18 = *v19 + v47;
                g6 = v18;
                v41 = *(int32_t *)v18;
                v30 = quantum_prob_inline_8((float64_t)(int64_t)v41);
                g20 = v30;
                v48 = sorted;
                g19 = (int80_t)v48;
                if ((float80_t)(int80_t)v48 > v30) {
                    goto lab_after_if_804b40d_0_8;
                }
                goto lab_if_804b40d_0_false_8;
            }
        }
        // 0x804b491
        v49 = addsize;
        if (v49 != 0) {
            // 0x804b497
            *v21 = *v21 - v49;
            mem3 = (int32_t)realloc((char *)*v19, 16 * *v21);
            g6 = mem3;
            *v19 = mem3;
            if (*v19 == 0) {
                // 0x804b4d7
                quantum_error(2);
                // branch -> 0x804b4e3
            }
            // 0x804b4e3
            quantum_memman(-16 * addsize);
            // branch -> 0x804b4f3
        }
    }
    // 0x804b4f3
    quantum_decohere((struct quantum_reg_struct *)v33);
    g3 = v15;
    g7 = v14;
    g5 = v13;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.h
// Address range: 0x804b509 - 0x804b58b
// Line range:    159 - 166
void quantum_reconstruct_hash_4(struct quantum_reg_struct_3 * reg) {
    struct quantum_reg_struct_3 * v1 = reg;
    int32_t v2 = (int32_t)reg; // bp+023
    uint32_t v3 = *(int32_t *)(v2 + 8); // 0x804b53426
    g4 = v3;
    int32_t v4; // 0x804b57b
    int32_t v5; // 0x804b57f_0
    int32_t v6; // bp+015
    int32_t v7;
    int32_t v8; // 0x804b55b
    struct quantum_reg_struct_3 * v9;
    if (v3 % 32 == 31) {
        // 0x804b57f
        v6 = (int32_t)reg;
        if (*(int32_t *)(v6 + 4) <= 0) {
            // 0x804b58a
            return;
        }
        v7 = 0;
        v8 = *(int32_t *)(*(int32_t *)(v6 + 12) + 16 * v7 + 8);
        quantum_add_hash_5((int64_t)v8, v7, reg);
        v4 = v7 + 1;
        v9 = v1;
        v5 = (int32_t)v9;
        while (*(int32_t *)(v5 + 4) > v4) {
            // 0x804b54c
            v7 = v4;
            v8 = *(int32_t *)(*(int32_t *)(v5 + 12) + 16 * v7 + 8);
            quantum_add_hash_5((int64_t)v8, v7, v9);
            v4 = v7 + 1;
            v9 = v1;
            v5 = (int32_t)v9;
            // continue -> 0x804b54c
        }
        // 0x804b58a
        return;
    }
    int32_t v10 = 0;
    *(int32_t *)(*(int32_t *)(v2 + 16) + 4 * v10) = 0;
    int32_t v11 = v10 + 1; // 0x804b52d
    int32_t v12 = (int32_t)v1; // 0x804b531_0
    uint32_t v13 = *(int32_t *)(v12 + 8); // 0x804b534
    g4 = v13;
    reg = v1;
    while (1 << v13 % 32 > v11) {
        // 0x804b518
        v10 = v11;
        *(int32_t *)(*(int32_t *)(v12 + 16) + 4 * v10) = 0;
        v11 = v10 + 1;
        v12 = (int32_t)v1;
        v13 = *(int32_t *)(v12 + 8);
        g4 = v13;
        reg = v1;
        // continue -> 0x804b518
    }
    // 0x804b57f
    v6 = (int32_t)reg;
    if (*(int32_t *)(v6 + 4) <= 0) {
        // 0x804b58a
        return;
    }
    v7 = 0;
    v8 = *(int32_t *)(*(int32_t *)(v6 + 12) + 16 * v7 + 8);
    quantum_add_hash_5((int64_t)v8, v7, reg);
    v4 = v7 + 1;
    v9 = v1;
    v5 = (int32_t)v9;
    while (*(int32_t *)(v5 + 4) > v4) {
        // 0x804b54c
        v7 = v4;
        v8 = *(int32_t *)(*(int32_t *)(v5 + 12) + 16 * v7 + 8);
        quantum_add_hash_5((int64_t)v8, v7, v9);
        v4 = v7 + 1;
        v9 = v1;
        v5 = (int32_t)v9;
        // continue -> 0x804b54c
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.h
// Address range: 0x804b58c - 0x804b62a
// Line range:    131 - 153
void quantum_add_hash_5(int64_t a, int32_t pos, struct quantum_reg_struct_3 * reg) {
    // 0x804b58c
    int32_t v1;
    int32_t i = v1; // bp-12
    i = 0;
    int32_t v2 = quantum_hash64_6(a, *(int32_t *)((int32_t)reg + 8)); // 0x804b5bc
    int32_t v3 = (int32_t)reg; // bp+015
    int32_t * v4 = (int32_t *)(v3 + 16); // bp+017
    int32_t v5 = *v4; // 0x804b60118
    g6 = v5;
    int32_t v6 = 4 * v2; // 0x804b60719
    if (*(int32_t *)(v5 + v6) == 0) {
        // 0x804b613
        *(int32_t *)(*v4 + v6) = pos + 1;
        return;
    }
    struct quantum_reg_struct_3 * v7 = reg; // 0x804b5fe31
    int32_t * v8; // 0x804b601_0
    int32_t v9; // 0x804b607
    while (true) {
        int32_t v10 = v2 + 1; // 0x804b5c6
        uint32_t v11 = *(int32_t *)(v3 + 8); // 0x804b5cd
        g4 = v11;
        struct quantum_reg_struct_3 * v12 = v7; // 0x804b5fe
        int32_t v13 = v10;
        int32_t v14; // 0x804b5fe_0
        int32_t v15; // 0x804b601
        if (1 << v11 % 32 == v10) {
            // 0x804b5dc
            if (i == 0) {
                // 0x804b5e2
                i = 1;
                v12 = v7;
                v13 = 0;
                // branch -> 0x804b5fe
            } else {
                // 0x804b5f2
                quantum_error(5);
                v12 = reg;
                v13 = v10;
                // branch -> 0x804b5fe
            }
            // 0x804b5fe
            v14 = (int32_t)v12;
            v8 = (int32_t *)(v14 + 16);
            v15 = *v8;
            g6 = v15;
            v9 = 4 * v13;
            if (*(int32_t *)(v15 + v9) == 0) {
                // break -> 0x804b613
                break;
            }
            v7 = v12;
            v3 = v14;
            v2 = v13;
            // continue -> 0x804b5c6
            continue;
        }
        // 0x804b5fe
        v14 = (int32_t)v12;
        v8 = (int32_t *)(v14 + 16);
        v15 = *v8;
        g6 = v15;
        v9 = 4 * v13;
        if (*(int32_t *)(v15 + v9) == 0) {
            // break -> 0x804b613
            break;
        }
        v7 = v12;
        v3 = v14;
        v2 = v13;
        // continue -> 0x804b5c6
    }
    // 0x804b613
    *(int32_t *)(*v8 + v9) = pos + 1;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.h
// Address range: 0x804b62b - 0x804b66c
// Line range:    91 - 100
int32_t quantum_hash64_6(int64_t key, int32_t width2) {
    int32_t v1 = 32 - width2; // 0x804b662
    g4 = v1;
    int32_t v2;
    return -0x61c8ffff * (v2 ^ (int32_t)key) >> v1 % 32;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.h
// Address range: 0x804b66d - 0x804b732
// Line range:    106 - 125
int32_t quantum_get_state_7(int64_t a, struct quantum_reg_struct_3 reg) {
    int32_t result = a; // 0x804b673_0
    int32_t v1 = reg.e2; // 0x804b67f
    if (v1 == 0) {
        // 0x804b72e
        return result;
    }
    int32_t v2 = quantum_hash64_6(a, v1); // 0x804b6a5
    int32_t v3 = (int32_t)reg.e4; // 0x804b715_0
    int32_t * v4 = (int32_t *)(4 * v2 + v3); // bp+035
    if (*v4 == 0) {
        // 0x804b72e
        return -1;
    }
    // branch -> 0x804b6af
    while (true) {
        int32_t v5 = (int32_t)reg.e3 + 16 * *v4 - 16; // 0x804b6ce
        int32_t v6;
        int32_t v7 = *(int32_t *)(v5 + 12) ^ v6; // 0x804b6d9
        g4 = v7;
        if ((*(int32_t *)(v5 + 8) ^ result || v7) == 0) {
            // 0x804b6e5
            // branch -> 0x804b72e
            // 0x804b72e
            return *v4 - 1;
        }
        int32_t v8 = v2 + 1; // 0x804b6fb
        int32_t v9 = reg.e2; // 0x804b6ff
        g4 = v9;
        int32_t v10 = 1 << v9 % 32 == v8 ? 0 : v8; // 0x804b6fb
        int32_t * v11 = (int32_t *)(4 * v10 + v3); // 0x804b721_0
        if (*v11 == 0) {
            // break -> 0x804b72e
            break;
        }
        v4 = v11;
        v2 = v10;
        // continue -> 0x804b6af
    }
    // 0x804b72e
    return -1;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.h
// Address range: 0x804b733 - 0x804b772
// Line range:    57 - 64
float32_t quantum_prob_inline_8(float64_t a) {
    float80_t v1 = quantum_real_9(a); // 0x804b746_4
    float80_t v2 = quantum_imag_10(a); // 0x804b75b_4
    return v1 * v1 + v2 * v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.h
// Address range: 0x804b773 - 0x804b78b
// Line range:    39 - 42
float32_t quantum_real_9(float64_t a) {
    // 0x804b773
    return a;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.h
// Address range: 0x804b78c - 0x804b7a7
// Line range:    48 - 51
float32_t quantum_imag_10(float64_t a) {
    // 0x804b78c
    int32_t result;
    g1 = result;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804c0bf - 0x804c194
// Line range:    596 - 611
void quantum_hadamard(int32_t target, struct quantum_reg_struct_3 * reg) {
    struct quantum_matrix_struct_1 v1; // 0x804c183
    if (quantum_objcode_put(6) == 0) {
        // 0x804c0e0
        int32_t v2;
        quantum_new_matrix((int32_t)&v2, 2);
        int32_t v3 = v2;
        int32_t v4;
        *(int32_t *)v4 = 0x3f3504f3;
        *(int32_t *)(v4 + 4) = 0;
        int32_t v5 = v4 + 8; // 0x804c125
        *(int32_t *)v5 = 0x3f3504f3;
        *(int32_t *)(v5 + 4) = 0;
        int32_t v6 = v4 + 16; // 0x804c13a
        *(int32_t *)v6 = 0x3f3504f3;
        *(int32_t *)(v6 + 4) = 0;
        int32_t v7 = v4 + 24; // 0x804c14f
        g6 = v7;
        *(int32_t *)v7 = -0x40cafb0d;
        *(int32_t *)(g6 + 4) = 0;
        v1 = (struct quantum_matrix_struct_1){
            .e0 = 0,
            .e1 = 0,
            .e2 = NULL
        };
        v1.e0 = v3;
        int32_t v8;
        quantum_gate1(target, v1, (struct quantum_reg_struct_3 *)v8);
        quantum_delete_matrix((struct quantum_matrix_struct_2 *)&v3);
        // branch -> 0x804c193
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804c7b9 - 0x804c928
// Line range:    739 - 758
void quantum_cond_phase(int32_t control, uint32_t target, struct quantum_reg_struct_3 * reg) {
    // 0x804c7b9
    int32_t v1;
    int32_t i = v1; // bp-20
    int32_t v2 = g7; // 0x804c7bc
    int32_t v3 = g3; // 0x804c7bd
    if (quantum_objcode_put(12) == 0) {
        uint32_t v4 = control - target; // 0x804c7eb
        if ((char)(0x1000000 * v4 / 0x1000000 % 32) != 0) {
            // if_804c7f7_0_true
            // branch -> after_if_804c7f7_0
        }
        uint32_t v5 = v4 % 32; // 0x804c7fa
        int32_t v6 = 1; // 0x804c801
        if (v5 != 0) {
            // if_804c7fa_0_true
            v6 = 1 << v5;
            // branch -> after_if_804c7fa_0
        }
        // after_if_804c7fa_0
        float80_t v7;
        if (v4 == 32) {
            // 0x804c805
            v7 = v6;
            // branch -> 0x804c823
        } else {
            // 0x804c805
            if (v6 < 0) {
                // 0x804c815
                v7 = 1.84467e+19L;
                // branch -> 0x804c823
            } else {
                v7 = 0.0L;
            }
        }
        // 0x804c823
        g19 = quantum_cexp((float32_t)(3.141592653589793116L / v7));
        int32_t v8 = g1; // 0x804c842
        g4 = v8;
        int32_t v9 = g6; // 0x804c844
        g3 = v9;
        i = v9;
        int32_t v10 = 0x1000000 * target / 0x1000000 % 32; // 0x804c8a1
        int32_t v11 = (int32_t)reg; // bp+056
        if (*(int32_t *)(v11 + 4) > 0) {
            uint32_t v12 = target % 32; // 0x804c8a4
            struct quantum_reg_struct_3 * v13 = reg; // 0x804c90864
            int32_t v14 = 0;
            // branch -> 0x804c85c
            struct quantum_reg_struct_3 * v15; // 0x804c908
            while (true) {
                int32_t * v16 = (int32_t *)(v11 + 12); // 0x804c85f_0
                int32_t v17 = 16 * v14; // 0x804c865
                int32_t v18 = *v16 + v17; // 0x804c868
                int32_t v19 = *(int32_t *)(v18 + 12); // 0x804c86b
                g6 = v19;
                uint32_t v20 = *(int32_t *)(v18 + 8); // 0x804c86e
                g4 = control;
                char v21 = 0x1000000 * control / 0x1000000 % 32; // 0x804c874
                int32_t v22 = v20; // 0x804c88236
                if (v21 != 0) {
                    uint32_t v23 = (int32_t)v21; // 0x804c874
                    v22 = v19 << 32 - v23 | v20 >> v23;
                    // branch -> after_if_804c874_0
                }
                uint32_t v24 = control % 32; // 0x804c877
                int32_t v25 = v19; // 0x804c87e
                if (v24 != 0) {
                    int32_t v26 = v19 >> v24; // 0x804c877
                    g6 = v26;
                    v25 = v26;
                    // branch -> after_if_804c877_0
                }
                if (control != 32) {
                    // 0x804c87e
                    g6 = 0;
                    v22 = v25;
                    // branch -> 0x804c882
                }
                // 0x804c882
                v15 = v13;
                if (v22 % 2 != 0) {
                    int32_t v27 = *v16 + v17; // 0x804c895
                    int32_t v28 = *(int32_t *)(v27 + 12); // 0x804c898
                    g6 = v28;
                    uint32_t v29 = *(int32_t *)(v27 + 8); // 0x804c89b
                    g4 = target;
                    int32_t v30 = v29; // 0x804c8af39
                    if ((char)v10 != 0) {
                        // if_804c8a1_0_true
                        v30 = v29 >> v10 | v28 << 32 - v10;
                        // branch -> after_if_804c8a1_0
                    }
                    int32_t v31 = v28; // 0x804c8ab
                    if (v12 != 0) {
                        int32_t v32 = v28 >> v12; // 0x804c8a4
                        g6 = v32;
                        v31 = v32;
                        // branch -> after_if_804c8a4_0
                    }
                    if (target != 32) {
                        // 0x804c8ab
                        g6 = 0;
                        v30 = v31;
                        // branch -> 0x804c8af
                    }
                    // 0x804c8af
                    if (v30 % 2 != 0) {
                        // 0x804c8b6
                        g7 = *v16 + v17;
                        int32_t v33 = *v16 + v17; // 0x804c8d1
                        int32_t v34 = *(int32_t *)v33; // 0x804c8d4
                        int32_t v35 = *(int32_t *)(v33 + 4); // 0x804c8d6
                        g6 = v8;
                        __mulsc3((float32_t)v34, (float32_t)v35, (float32_t)v8, (float32_t)i);
                        g4 = i;
                        int32_t v36 = g6; // 0x804c8f9
                        g3 = v36;
                        *(int32_t *)g7 = i;
                        *(int32_t *)(g7 + 4) = v36;
                        v15 = reg;
                        // branch -> 0x804c904
                    } else {
                        v15 = v13;
                    }
                }
                int32_t v37 = v14 + 1; // 0x804c904
                int32_t v38 = (int32_t)v15; // 0x804c908_0
                if (*(int32_t *)(v38 + 4) <= v37) {
                    // break -> 0x804c917
                    break;
                }
                v13 = v15;
                v11 = v38;
                v14 = v37;
                // continue -> 0x804c85c
            }
            // 0x804c917
            quantum_decohere((struct quantum_reg_struct *)v15);
            // branch -> 0x804c922
            // 0x804c922
            g3 = v3;
            g7 = v2;
            return;
        }
        // 0x804c917
        quantum_decohere((struct quantum_reg_struct *)reg);
        // branch -> 0x804c922
    }
    // 0x804c922
    g3 = v3;
    g7 = v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/gates.c
// Address range: 0x804cb9a - 0x804cbcb
// Line range:    810 - 819
int32_t quantum_gate_counter(uint32_t inc) {
    // 0x804cb9a
    int32_t result;
    if (inc >= 1) {
        // 0x804cba3
        result = g12 + inc;
        // branch -> 0x804cbc2
    } else {
        result = 0;
    }
    // 0x804cbc2
    g12 = result;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/matrix.c
// Address range: 0x804cbcc - 0x804cbfb
// Line range:    35 - 44
int32_t quantum_memman(int32_t change) {
    int32_t result = g14 + change; // 0x804cbd4
    g14 = result;
    g6 = result;
    if (result > g13) {
        // 0x804cbeb
        g13 = result;
        // branch -> 0x804cbf5
    }
    // 0x804cbf5
    int32_t v1;
    g2 = v1;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/matrix.c
// Address range: 0x804cbfc - 0x804cc6f
// Line range:    50 - 68
struct quantum_matrix_struct_2 quantum_new_matrix(int32_t cols, int32_t rows) {
    struct quantum_matrix_struct_2 result; // 0x804cc6d_3
    // 0x804cbfc
    int32_t v1;
    char * mem = calloc(v1 * rows, 8); // 0x804cc20
    if (mem == NULL) {
        // 0x804cc2f
        quantum_error(2);
        // branch -> 0x804cc3b
    }
    // 0x804cc3b
    quantum_memman(8 * v1 * rows);
    *(int32_t *)cols = v1;
    *(int32_t *)(cols + 4) = rows;
    *(int32_t *)(cols + 8) = (int32_t)mem;
    result = (struct quantum_matrix_struct_2){
        .e0 = 0,
        .e1 = 0,
        .e2 = NULL
    };
    result.e0 = cols;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/matrix.c
// Address range: 0x804cc70 - 0x804ccac
// Line range:    74 - 84
void quantum_delete_matrix(struct quantum_matrix_struct_2 * m) {
    // 0x804cc70
    free((char *)*(int32_t *)((int32_t)m + 8));
    quantum_memman(-8 * *(int32_t *)((int32_t)m + 4) * m->e0);
    *(int32_t *)((int32_t)m + 8) = 0;
}

// From module:   /home/naftali/source/libquantum-0.9.1/measure.c
// Address range: 0x804cf20 - 0x804cf3c
// Line range:    42 - 44
float64_t quantum_frand(void) {
    int32_t v1 = rand(); // 0x804cf26
    g1 = v1;
    g19 = 2147483647.0L;
    return (float80_t)v1 / 2147483647.0L;
}

// From module:   /home/naftali/source/libquantum-0.9.1/measure.c
// Address range: 0x804cf3d - 0x804cfdf
// Line range:    50 - 78
int64_t quantum_measure(struct quantum_reg_struct_4 reg) {
    if (quantum_objcode_put(-128) != 0) {
        // 0x804cf53
        // branch -> 0x804cfd8
        // 0x804cfd8
        return 0;
    }
    // 0x804cf63
    quantum_frand();
    int32_t result; // 0x804cfd812
    if (reg.e1 > 0) {
        // 0x804cf74
        quantum_prob_inline_13((float64_t)(int64_t)(char)*(int32_t *)reg.e3);
        result = *(int32_t *)((int32_t)reg.e3 + 8);
        // branch -> 0x804cfd8
    } else {
        // 0x804cfca
        result = -1;
        // branch -> 0x804cfd8
    }
    // 0x804cfd8
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.h
// Address range: 0x804cfe0 - 0x804d01f
// Line range:    57 - 64
float32_t quantum_prob_inline_13(float64_t a) {
    float80_t v1 = quantum_real_14(a); // 0x804cff3_4
    float80_t v2 = quantum_imag_15(a); // 0x804d008_4
    return v1 * v1 + v2 * v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.h
// Address range: 0x804d020 - 0x804d038
// Line range:    39 - 42
float32_t quantum_real_14(float64_t a) {
    // 0x804d020
    return a;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.h
// Address range: 0x804d039 - 0x804d054
// Line range:    48 - 51
float32_t quantum_imag_15(float64_t a) {
    // 0x804d039
    int32_t result;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/measure.c
// Address range: 0x804d055 - 0x804d1a7
// Line range:    87 - 121
int32_t quantum_bmeasure(uint32_t pos, struct quantum_reg_struct_4 * reg) {
    struct quantum_reg_struct_11 v1; // 0x804d167
    int64_t v2;
    int64_t pos2 = v2; // bp-48
    float64_t v3;
    float64_t r = v3; // bp-40
    int32_t v4;
    int32_t i = v4; // bp-20
    int32_t v5 = g3; // 0x804d058
    i = 0;
    g20 = 0.0L;
    int32_t result = 0;
    if (quantum_objcode_put(-127) == 0) {
        char v6 = 0x1000000 * pos / 0x1000000 % 32; // 0x804d098
        int32_t v7 = 0;
        if (v6 != 0) {
            // if_804d098_0_true
            v7 = 1 >> 32 - (int32_t)v6;
            // branch -> after_if_804d098_0
        }
        uint32_t v8 = pos % 32; // 0x804d09b
        int32_t v9 = 1; // 0x804d0a2
        if (v8 != 0) {
            // if_804d09b_0_true
            v9 = 1 << v8;
            // branch -> after_if_804d09b_0
        }
        int32_t v10 = v9; // 0x804d0a6
        if (pos != 32) {
            // 0x804d0a2
            v10 = 0;
            v7 = v9;
            // branch -> 0x804d0a6
        }
        // 0x804d0a6
        r = (int64_t)v7;
        int32_t v11 = (int32_t)reg; // bp+050
        float64_t v12 = 0.0;
        if (*(int32_t *)(v11 + 4) > 0) {
            struct quantum_reg_struct_4 * v13 = reg; // 0x804d10559
            float64_t v14 = (int64_t)v7; // 0x804d0d1
            int32_t v15 = 0;
            float64_t v16 = 0.0;
            while (true) {
                int32_t * v17 = (int32_t *)(v11 + 12); // 0x804d0b8_0
                int32_t v18 = 16 * v15; // 0x804d0be
                int32_t v19 = *v17 + v18; // 0x804d0c1
                int32_t v20 = *(int32_t *)(v19 + 8); // 0x804d0c4
                int32_t v21 = *(int32_t *)(v19 + 12); // 0x804d0c7
                g3 = v21;
                struct quantum_reg_struct_4 * v22 = v13; // 0x804d105
                float64_t v23 = v16;
                if (((int32_t)(float32_t)v14 & v21 || v20 & v10) == 0) {
                    int32_t v24 = *(int32_t *)(*v17 + v18); // 0x804d0e8
                    float64_t v25 = (float80_t)v16 + (float80_t)quantum_prob_inline_13((float64_t)(int64_t)v24);
                    v22 = reg;
                    v23 = v25;
                    // branch -> 0x804d101
                }
                int32_t v26 = v15 + 1; // 0x804d101
                int32_t v27 = (int32_t)v22; // 0x804d105_0
                if (*(int32_t *)(v27 + 4) > v26) {
                    // 0x804d101
                    v13 = v22;
                    v14 = r;
                    v11 = v27;
                    v15 = v26;
                    v16 = v23;
                    // branch -> 0x804d0b5
                    continue;
                } else {
                    v12 = v23;
                }
            }
        }
        // 0x804d110
        quantum_frand();
        float80_t v28 = g21; // 0x804d115
        float64_t v29 = v28;
        g20 = v28;
        if (v29 <= v12) {
            // if_804d120_0_false
            if (v29 >= v12) {
                // if_804d120_1_false
                // branch -> after_if_804d120_0
            }
        }
        // after_if_804d120_0
        int32_t v30; // 0x804d156
        // after_if_804d120_0.dec_label_pc_804d12e_crit_edge
        v30 = i;
        // branch -> 0x804d12e
        // 0x804d12e
        v1 = (struct quantum_reg_struct_11){
            .e0 = 0,
            .e1 = 0,
            .e2 = 0,
            .e3 = NULL,
            .e4 = NULL
        };
        v1.e0 = v30;
        int32_t v31;
        quantum_state_collapse((int32_t)&v31, pos, v1);
        quantum_delete_qureg_hashpreserve((struct quantum_reg_struct_11 *)reg);
        int32_t v32 = (int32_t)reg; // edx
        reg->e0 = v31;
        int32_t v33;
        *(int32_t *)(v32 + 4) = v33;
        int32_t v34;
        *(int32_t *)(v32 + 8) = v34;
        int32_t v35;
        *(int32_t *)(v32 + 12) = v35;
        *(int32_t *)(v32 + 16) = (int32_t)pos2;
        result = i;
        // branch -> 0x804d1a0
    }
    // 0x804d1a0
    g3 = v5;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804d538 - 0x804d8fd
// Line range:    42 - 109
void test_sum(int32_t compare, int32_t width2, struct quantum_reg_struct_5 * reg) {
    int32_t v1 = g7; // 0x804d53b
    int32_t v2 = g3; // 0x804d53c
    g3 = compare;
    int32_t v3 = compare >> 31; // 0x804d547
    g7 = v3;
    int32_t v4 = width2 - 1; // 0x804d54d
    g4 = v4;
    char v5 = 0x1000000 * v4 / 0x1000000 % 32; // 0x804d554
    int32_t v6 = compare; // 0x804d56259
    if (v5 != 0) {
        uint32_t v7 = (int32_t)v5; // 0x804d554
        v6 = v3 << 32 - v7 | compare >> v7;
        // branch -> after_if_804d554_0
    }
    uint32_t v8 = v4 % 32; // 0x804d557
    int32_t v9 = v3; // 0x804d55e
    if (v8 != 0) {
        // if_804d557_0_true
        v9 = v3 >> v8;
        // branch -> after_if_804d557_0
    }
    if (v4 != 32) {
        // 0x804d55e
        v6 = v9;
        // branch -> 0x804d562
    }
    // 0x804d562
    if (v6 % 2 == 0) {
        int32_t v10 = 2 * width2 - 1; // 0x804d5c7
        quantum_sigma_x(v10, (struct quantum_reg_struct_3 *)reg);
        g4 = v4;
        quantum_cnot(v10, v4, (struct quantum_reg_struct_3 *)reg);
        // branch -> 0x804d5fa
    } else {
        // 0x804d569
        g4 = v4;
        int32_t v11 = 2 * width2 - 1; // 0x804d574
        quantum_cnot(v11, v4, (struct quantum_reg_struct_3 *)reg);
        quantum_sigma_x(v11, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(v11, 0, (struct quantum_reg_struct_3 *)reg);
        // branch -> 0x804d5fa
    }
    int32_t v12 = width2 - 2; // 0x804d5fd
    int32_t v13;
    int32_t v14; // 0x804d714
    int32_t v15; // 0x804d806
    int32_t v16; // 0x804d86b
    int32_t v17; // 0x804d8ca
    int32_t v18; // 0x804d6d3
    int32_t v19; // 0x804d73a
    if (v12 <= 0) {
        // 0x804d6d3
        v18 = compare;
        v19 = v18;
        if (v18 % 2 != 0) {
            // 0x804d6dd
            quantum_sigma_x(width2, (struct quantum_reg_struct_3 *)reg);
            quantum_toffoli(width2, 1, 0, (struct quantum_reg_struct_3 *)reg);
            v19 = compare;
            // branch -> 0x804d711
        }
        // 0x804d711
        v14 = 2 * width2;
        g4 = v14;
        quantum_toffoli(v14 | 1, 0, v14, (struct quantum_reg_struct_3 *)reg);
        if (v19 % 2 != 0) {
            // 0x804d744
            quantum_toffoli(width2, 1, 0, (struct quantum_reg_struct_3 *)reg);
            quantum_sigma_x(width2, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804d845
        }
        // 0x804d845
        if (v12 >= 1) {
            v13 = 1;
            while (true) {
                // 0x804d784
                v15 = v13 + width2;
                if ((compare & 1 << v13 % 32) == 0) {
                    goto lab_0x804d800;
                }
                goto lab_0x804d793;
            }
        }
        // 0x804d854
        g4 = v4;
        if ((compare & 1 << v8) == 0) {
            // 0x804d8bf
            g4 = v4;
            v17 = v14 - 1;
            quantum_cnot(v17, v4, (struct quantum_reg_struct_3 *)reg);
            quantum_sigma_x(v17, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804d8f7
        } else {
            // 0x804d866
            v16 = v14 - 1;
            quantum_cnot(v16, 0, (struct quantum_reg_struct_3 *)reg);
            quantum_sigma_x(v16, (struct quantum_reg_struct_3 *)reg);
            g4 = v4;
            quantum_cnot(v16, v4, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804d8f7
        }
        // 0x804d8f7
        g3 = v2;
        g7 = v1;
        return;
    }
    int32_t v20 = v12;
    while (true) {
        // 0x804d608
        g4 = v20;
        int32_t v21 = v20 + width2; // 0x804d68a
        if ((1 << v20 % 32 & compare) == 0) {
            // 0x804d684
            quantum_sigma_x(v21, (struct quantum_reg_struct_3 *)reg);
            int32_t v22 = v20 + 1; // 0x804d6a8
            g4 = v22;
            quantum_toffoli(v22, v21, v20, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804d6c5
        } else {
            int32_t v23 = v20 + 1; // 0x804d623
            g4 = v23;
            quantum_toffoli(v23, v21, v20, (struct quantum_reg_struct_3 *)reg);
            quantum_sigma_x(v21, (struct quantum_reg_struct_3 *)reg);
            g4 = v21;
            quantum_toffoli(v23, v21, 0, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804d6c5
        }
        // 0x804d6c5
        if (v20 <= 1) {
            // break -> 0x804d6d3
            break;
        }
        v20--;
        // continue -> 0x804d608
    }
    // 0x804d6d3
    v18 = compare;
    v19 = v18;
    if (v18 % 2 != 0) {
        // 0x804d6dd
        quantum_sigma_x(width2, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(width2, 1, 0, (struct quantum_reg_struct_3 *)reg);
        v19 = compare;
        // branch -> 0x804d711
    }
    // 0x804d711
    v14 = 2 * width2;
    g4 = v14;
    quantum_toffoli(v14 | 1, 0, v14, (struct quantum_reg_struct_3 *)reg);
    if (v19 % 2 != 0) {
        // 0x804d744
        quantum_toffoli(width2, 1, 0, (struct quantum_reg_struct_3 *)reg);
        quantum_sigma_x(width2, (struct quantum_reg_struct_3 *)reg);
        // branch -> 0x804d845
    }
    // 0x804d845
    if (v12 < 1) {
        // 0x804d854
        g4 = v4;
        if ((compare & 1 << v8) == 0) {
            // 0x804d8bf
            g4 = v4;
            v17 = v14 - 1;
            quantum_cnot(v17, v4, (struct quantum_reg_struct_3 *)reg);
            quantum_sigma_x(v17, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804d8f7
        } else {
            // 0x804d866
            v16 = v14 - 1;
            quantum_cnot(v16, 0, (struct quantum_reg_struct_3 *)reg);
            quantum_sigma_x(v16, (struct quantum_reg_struct_3 *)reg);
            g4 = v4;
            quantum_cnot(v16, v4, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804d8f7
        }
        // 0x804d8f7
        g3 = v2;
        g7 = v1;
        return;
    }
    v13 = 1;
    while (true) {
        // 0x804d784
        v15 = v13 + width2;
        if ((compare & 1 << v13 % 32) == 0) {
          lab_0x804d800:;
            int32_t v24 = v13 + 1; // 0x804d80c
            g4 = v24;
            quantum_toffoli(v24, v15, v13, (struct quantum_reg_struct_3 *)reg);
            quantum_sigma_x(v15, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804d841
        } else {
          lab_0x804d793:
            // 0x804d793
            g4 = v15;
            int32_t v25 = v13 + 1; // 0x804d79f
            quantum_toffoli(v25, v15, 0, (struct quantum_reg_struct_3 *)reg);
            quantum_sigma_x(v15, (struct quantum_reg_struct_3 *)reg);
            g4 = v25;
            quantum_toffoli(v25, v15, v13, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804d841
        }
        int32_t v26 = v13 + 1; // 0x804d841
        if (v12 < v26) {
            // break -> 0x804d854
            break;
        }
        v13 = v26;
        // continue -> 0x804d784
    }
    // 0x804d854
    g4 = v4;
    if ((compare & 1 << v8) == 0) {
        // 0x804d8bf
        g4 = v4;
        v17 = v14 - 1;
        quantum_cnot(v17, v4, (struct quantum_reg_struct_3 *)reg);
        quantum_sigma_x(v17, (struct quantum_reg_struct_3 *)reg);
        // branch -> 0x804d8f7
    } else {
        // 0x804d866
        v16 = v14 - 1;
        quantum_cnot(v16, 0, (struct quantum_reg_struct_3 *)reg);
        quantum_sigma_x(v16, (struct quantum_reg_struct_3 *)reg);
        g4 = v4;
        quantum_cnot(v16, v4, (struct quantum_reg_struct_3 *)reg);
        // branch -> 0x804d8f7
    }
    // 0x804d8f7
    g3 = v2;
    g7 = v1;
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804d8fe - 0x804dba6
// Line range:    117 - 153
void muxfa(int32_t a, int32_t b_in, int32_t c_in, int32_t c_out, int32_t xlt_l, int32_t L, int32_t total, struct quantum_reg_struct_5 * reg) {
    int32_t v1 = a; // 0x804d943
    if (a == 0) {
        // 0x804d90a
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        v1 = a;
        // branch -> 0x804d943
    }
    int32_t v2 = v1; // 0x804d9bb
    if (v1 == 3) {
        // 0x804d949
        quantum_toffoli(L, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(L, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        v2 = a;
        // branch -> 0x804d9bb
    }
    int32_t v3 = v2; // 0x804da9e
    if (v2 == 1) {
        // 0x804d9c5
        quantum_toffoli(L, xlt_l, b_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, b_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        v3 = a;
        // branch -> 0x804da9e
    }
    // 0x804da9e
    if (v3 == 2) {
        // 0x804daa8
        quantum_sigma_x(xlt_l, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, b_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, b_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_sigma_x(xlt_l, (struct quantum_reg_struct_3 *)reg);
        // branch -> 0x804dba5
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804dba7 - 0x804de4f
// Line range:    158 - 194
void muxfa_inv(int32_t a, int32_t b_in, int32_t c_in, int32_t c_out, int32_t xlt_l, int32_t L, int32_t total, struct quantum_reg_struct_5 * reg) {
    int32_t v1 = a; // 0x804dbec
    if (a == 0) {
        // 0x804dbb3
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        v1 = a;
        // branch -> 0x804dbec
    }
    int32_t v2 = v1; // 0x804dc64
    if (v1 == 3) {
        // 0x804dbf2
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(L, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        v2 = a;
        // branch -> 0x804dc64
    }
    int32_t v3 = v2; // 0x804dd47
    if (v2 == 1) {
        // 0x804dc6e
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, b_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, b_in, (struct quantum_reg_struct_3 *)reg);
        v3 = a;
        // branch -> 0x804dd47
    }
    // 0x804dd47
    if (v3 == 2) {
        // 0x804dd51
        quantum_sigma_x(xlt_l, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, b_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(b_in, c_in, c_out, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, b_in, (struct quantum_reg_struct_3 *)reg);
        quantum_sigma_x(xlt_l, (struct quantum_reg_struct_3 *)reg);
        // branch -> 0x804de4e
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804de50 - 0x804df50
// Line range:    201 - 224
void muxha(int32_t a, int32_t b_in, int32_t c_in, int32_t xlt_l, int32_t L, int32_t total, struct quantum_reg_struct_5 * reg) {
    int32_t v1 = a; // 0x804de75
    if (a == 0) {
        // 0x804de5c
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        v1 = a;
        // branch -> 0x804de75
    }
    int32_t v2 = v1; // 0x804dead
    if (v1 == 3) {
        // 0x804de7b
        quantum_cnot(L, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        v2 = a;
        // branch -> 0x804dead
    }
    int32_t v3 = v2; // 0x804deec
    if (v2 == 1) {
        // 0x804deb3
        quantum_toffoli(L, xlt_l, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        v3 = a;
        // branch -> 0x804deec
    }
    // 0x804deec
    if (v3 == 2) {
        // 0x804def2
        quantum_sigma_x(xlt_l, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_sigma_x(xlt_l, (struct quantum_reg_struct_3 *)reg);
        // branch -> 0x804df4f
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804df51 - 0x804e051
// Line range:    229 - 252
void muxha_inv(int32_t a, int32_t b_in, int32_t c_in, int32_t xlt_l, int32_t L, int32_t total, struct quantum_reg_struct_5 * reg) {
    int32_t v1 = a; // 0x804df76
    if (a == 0) {
        // 0x804df5d
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        v1 = a;
        // branch -> 0x804df76
    }
    int32_t v2 = v1; // 0x804dfae
    if (v1 == 3) {
        // 0x804df7c
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(L, c_in, (struct quantum_reg_struct_3 *)reg);
        v2 = a;
        // branch -> 0x804dfae
    }
    int32_t v3 = v2; // 0x804dfed
    if (v2 == 1) {
        // 0x804dfb4
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, c_in, (struct quantum_reg_struct_3 *)reg);
        v3 = a;
        // branch -> 0x804dfed
    }
    // 0x804dfed
    if (v3 == 2) {
        // 0x804dff3
        quantum_sigma_x(xlt_l, (struct quantum_reg_struct_3 *)reg);
        quantum_cnot(b_in, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_toffoli(L, xlt_l, c_in, (struct quantum_reg_struct_3 *)reg);
        quantum_sigma_x(xlt_l, (struct quantum_reg_struct_3 *)reg);
        // branch -> 0x804e050
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804e052 - 0x804e186
// Line range:    256 - 270
void madd(int32_t a, uint32_t a_inv, int32_t width2, struct quantum_reg_struct_5 * reg) {
    // 0x804e052
    int32_t v1;
    int32_t j = v1; // bp-24
    int32_t v2 = g7; // 0x804e055
    int32_t v3 = g3; // 0x804e056
    int32_t v4 = 2 * width2; // 0x804e05d
    int32_t v5 = v4 | 1; // 0x804e05f27
    j = 2 * v5;
    uint32_t v6 = width2 - 1; // 0x804e0f9
    uint32_t v7; // 0x804e115
    int32_t v8; // 0x804e154
    int32_t v9; // 0x804e175
    int32_t v10; // 0x804e137
    if (v6 <= 0) {
        // 0x804e105
        v7 = v6 % 32;
        v10 = 0;
        if ((a >> v7) % 2 != 0) {
            // 0x804e11e
            v10 = 2;
            // branch -> 0x804e125
        }
        // 0x804e125
        if ((a_inv >> v7) % 2 != 0) {
            // 0x804e137
            v9 = v10 | 1;
            // branch -> 0x804e13b
        } else {
            v9 = v10;
        }
        // 0x804e13b
        g3 = v5;
        g7 = v4;
        v8 = v4 - 1;
        g4 = v8;
        muxha(v9, v8, v6, v4, v5, j, reg);
        g3 = v3;
        g7 = v2;
        return;
    }
    int32_t v11 = 0;
    while (true) {
        uint32_t v12 = v11 % 32; // 0x804e079
        int32_t v13 = 2 * (a >> v12) & 2;
        int32_t v14 = v13; // 0x804e0e7
        if ((a_inv >> v12) % 2 != 0) {
            // 0x804e0a1
            v14 = v13 | 1;
            // branch -> 0x804e0a5
        }
        // 0x804e0a5
        g3 = v5;
        g7 = v4;
        int32_t v15 = v11 + 1; // 0x804e0b6
        g4 = v15;
        muxfa(v14, v11 + width2, v11, v15, v4, v5, j, reg);
        if (v6 <= v15) {
            // break -> 0x804e105
            break;
        }
        v11 = v15;
        // continue -> 0x804e073
    }
    // 0x804e105
    v7 = v6 % 32;
    v10 = 0;
    if ((a >> v7) % 2 != 0) {
        // 0x804e11e
        v10 = 2;
        // branch -> 0x804e125
    }
    // 0x804e125
    if ((a_inv >> v7) % 2 != 0) {
        // 0x804e137
        v9 = v10 | 1;
        // branch -> 0x804e13b
    } else {
        v9 = v10;
    }
    // 0x804e13b
    g3 = v5;
    g7 = v4;
    v8 = v4 - 1;
    g4 = v8;
    muxha(v9, v8, v6, v4, v5, j, reg);
    g3 = v3;
    g7 = v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804e187 - 0x804e2bd
// Line range:    272 - 288
void madd_inv(int32_t a, uint32_t a_inv, int32_t width2, struct quantum_reg_struct_5 * reg) {
    // 0x804e187
    int32_t v1;
    int32_t j = v1; // bp-24
    int32_t v2 = g7; // 0x804e18a
    int32_t v3 = g3; // 0x804e18b
    int32_t v4 = 2 * width2; // 0x804e192
    int32_t v5 = v4 | 1; // 0x804e19429
    int32_t v6 = 2 * v5; // 0x804e197
    j = v6;
    int32_t v7 = width2 - 1; // 0x804e1a6
    uint32_t v8 = v7 % 32; // 0x804e1ac
    int32_t v9 = 0; // 0x804e1ce
    if ((a >> v8) % 2 != 0) {
        // 0x804e1b5
        v9 = 2;
        // branch -> 0x804e1bc
    }
    int32_t v10 = v9; // 0x804e20c
    if ((a_inv >> v8) % 2 != 0) {
        // 0x804e1ce
        v10 = v9 | 1;
        // branch -> 0x804e1d2
    }
    // 0x804e1d2
    g3 = v5;
    g7 = v4;
    g4 = v7;
    muxha_inv(v10, v7, v4 - 1, v4, v5, v6, reg);
    int32_t v11 = width2 - 2; // 0x804e21a
    if (v11 > 0) {
        // branch -> 0x804e225
        while (true) {
            uint32_t v12 = v11 % 32; // 0x804e22b
            int32_t v13 = 2 * (a >> v12) & 2;
            int32_t v14 = v13; // 0x804e29e
            if ((a_inv >> v12) % 2 != 0) {
                // 0x804e253
                v14 = v13 | 1;
                // branch -> 0x804e257
            }
            // 0x804e257
            g3 = v5;
            g7 = v4;
            int32_t v15 = width2 + 1 + v11; // 0x804e26d
            g4 = v15;
            muxfa_inv(v14, v11, v11 + width2, v15, v4, v5, j, reg);
            if (v11 > 1) {
                // 0x804e257
                v11--;
                // branch -> 0x804e225
                continue;
            }
        }
    }
    // 0x804e2b7
    g3 = v3;
    g7 = v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804e2be - 0x804e316
// Line range:    290 - 295
void addn(int32_t N, int32_t a, uint32_t width2, struct quantum_reg_struct_5 * reg) {
    // 0x804e2be
    test_sum(N - a, width2, reg);
    madd(a - N + (1 << width2 % 32), a, width2, reg);
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804e317 - 0x804e39f
// Line range:    297 - 305
void addn_inv(int32_t N, int32_t a, uint32_t width2, struct quantum_reg_struct_5 * reg) {
    int32_t v1 = 2 * width2; // 0x804e320
    g4 = v1;
    quantum_cnot(v1 | 1, v1, (struct quantum_reg_struct_3 *)reg);
    madd_inv((1 << width2 % 32) - a, N - a, width2, reg);
    quantum_swaptheleads(width2, (struct quantum_reg_struct_3 *)reg);
    test_sum(a, width2, reg);
}

// From module:   /home/naftali/source/libquantum-0.9.1/oaddn.c
// Address range: 0x804e3a0 - 0x804e3e7
// Line range:    307 - 311
void add_mod_n(int32_t N, int32_t a, int32_t width2, struct quantum_reg_struct_5 * reg) {
    // 0x804e3a0
    addn(N, a, width2, reg);
    addn_inv(N, a, width2, reg);
}

// From module:   /home/naftali/source/libquantum-0.9.1/objcode.c
// Address range: 0x804e3e8 - 0x804e480
// Line range:    61 - 71
void quantum_mu2char(int64_t mu, char * buf) {
    // 0x804e40b
    int32_t v1;
    int32_t i = v1; // bp-20
    int64_t v2 = mu; // bp-36
    i = 8;
    int32_t v3 = mu;
    int32_t v4 = 8; // 0x804e413
    int32_t v5 = 0;
    // branch -> 0x804e40b
    while (true) {
        int32_t v6 = v4 - v5 - 1; // 0x804e41b
        int32_t v7 = 8 * v6; // 0x804e41d
        char v8 = 0x8000000 * v6 / 0x1000000 % 32; // 0x804e42a
        char v9 = v3;
        int32_t v10;
        if (v8 != 0) {
            uint32_t v11 = (int32_t)v8; // 0x804e42a
            v9 = v10 << 32 - v11 | v3 >> v11;
            // branch -> after_if_804e42a_0
        }
        uint32_t v12 = v7 & 24; // 0x804e42d
        int32_t v13 = v10; // 0x804e434
        if (v12 != 0) {
            // if_804e42d_0_true
            v13 = v10 >> v12;
            // branch -> after_if_804e42d_0
        }
        if (v7 != 32) {
            // 0x804e434
            v9 = v13;
            // branch -> 0x804e438
        }
        // 0x804e438
        *(char *)(v5 + (int32_t)buf) = v9;
        int32_t v14 = i - v5 - 1; // 0x804e442
        int32_t v15 = 8 * v14; // 0x804e444
        g4 = v15;
        char v16 = 0x8000000 * v14 / 0x1000000 % 32; // 0x804e455
        int32_t v17 = 0;
        if (v16 != 0) {
            // if_804e455_0_true
            v17 = 1 >> 32 - (int32_t)v16;
            // branch -> after_if_804e455_0
        }
        uint32_t v18 = v15 & 24; // 0x804e458
        int32_t v19 = 1; // 0x804e45f
        if (v18 != 0) {
            // if_804e458_0_true
            v19 = 1 << v18;
            // branch -> after_if_804e458_0
        }
        int32_t v20 = v19; // 0x804e463
        if (v15 != 32) {
            // 0x804e45f
            v20 = 0;
            v17 = v19;
            // branch -> 0x804e463
        }
        int32_t v21 = (int32_t)v2 & v20 - 1; // 0x804e469
        v2 = v21;
        int32_t v22 = v5 + 1; // 0x804e46f
        if (v22 >= i) {
            // break -> 0x804e47b
            break;
        }
        v3 = v21;
        v4 = i;
        v5 = v22;
        v10 &= v17 - 1 + (int32_t)(v20 != 0);
        // continue -> 0x804e40b
    }
    // 0x804e47b
    int32_t v23;
    g2 = v23;
}

// From module:   /home/naftali/source/libquantum-0.9.1/objcode.c
// Address range: 0x804e481 - 0x804e508
// Line range:    77 - 87
void quantum_int2char(int32_t j, char * buf) {
    // 0x804e498
    int32_t v1;
    int32_t i = v1; // bp-16
    i = 4;
    int32_t v2 = 0;
    *(char *)(v2 + (int32_t)buf) = (char)((0x100000000 * (int64_t)(j >> 31) | (int64_t)j) / (int64_t)(1 << (8 * (v2 - 4) & 24 ^ 24)));
    int32_t v3 = 8 * (v2 - i) ^ -8; // 0x804e4d6
    g4 = v3;
    int32_t v4 = j; // 0x804e4e9
    int32_t v5 = (0x100000000 * (int64_t)(v4 >> 31) | (int64_t)v4) % (int64_t)(1 << (v3 & 24)); // 0x804e4f1
    j = v5;
    int32_t v6 = v2 + 1; // 0x804e4f7
    // branch -> 0x804e498
    while (v6 < i) {
        // 0x804e498
        j = v5;
        v2 = v6;
        *(char *)(v2 + (int32_t)buf) = (char)((0x100000000 * (int64_t)(j >> 31) | (int64_t)j) / (int64_t)(1 << (8 * (v2 - i) & 24 ^ 24)));
        v3 = 8 * (v2 - i) ^ -8;
        g4 = v3;
        v4 = j;
        v5 = (0x100000000 * (int64_t)(v4 >> 31) | (int64_t)v4) % (int64_t)(1 << (v3 & 24));
        j = v5;
        v6 = v2 + 1;
        // continue -> 0x804e498
    }
    // 0x804e503
    int32_t v7;
    g2 = v7;
}

// From module:   /home/naftali/source/libquantum-0.9.1/objcode.c
// Address range: 0x804e509 - 0x804e54a
// Line range:    93 - 99
void quantum_double2char(float64_t d, char * buf) {
    // 0x804e509
    int32_t v1;
    int32_t i = v1; // bp-12
    int32_t v2; // bp-28
    int32_t v3 = &v2; // 0x804e50c_3
    v2 = (float32_t)d;
    i = v3;
    *buf = (char)(int32_t)(float32_t)d;
    int32_t v4 = 1; // 0x804e53d11
    char v5 = *(char *)(v4 + v3); // 0x804e538
    *(char *)(v4 + (int32_t)buf) = v5;
    int32_t v6 = v4 + 1; // 0x804e53d
    // 0x804e549
    int32_t v7;
    g2 = v7;
    // branch -> 0x804e52a
    while (v6 < 8) {
        // 0x804e52a
        // 0x804e52a
        v4 = v6;
        v5 = *(char *)(v4 + i);
        *(char *)(v4 + (int32_t)buf) = v5;
        v6 = v4 + 1;
        // 0x804e549
        g2 = v7;
        // branch -> 0x804e52a
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/objcode.c
// Address range: 0x804e630 - 0x804e67d
// Line range:    139 - 148
void quantum_objcode_start(void) {
    // 0x804e630
    opstatus = 1;
    allocated = 1;
    char * mem = malloc(0x10000); // 0x804e651
    objcode = (int32_t)mem;
    if (mem == NULL) {
        // 0x804e664
        quantum_error(2);
        // branch -> 0x804e670
    }
    // 0x804e670
    quantum_memman(0x10000);
}

// From module:   /home/naftali/source/libquantum-0.9.1/objcode.c
// Address range: 0x804e6c3 - 0x804ea7c
// Line range:    166 - 261
int32_t quantum_objcode_put(char operation, ...) {
    char v1[80];
    char v2[80];
    char v3[80];
    char v4[80];
    // 0x804e6c3
    int32_t v5;
    int32_t size = v5; // bp-100
    int32_t v6;
    int32_t i = v6; // bp-96
    int32_t v7;
    int32_t v8 = v7;
    int32_t v9;
    float64_t v10 = (int64_t)v9; // bp+12
    int32_t v11;
    float64_t v12 = (int64_t)v11; // bp+16
    int32_t v13 = *(int32_t *)20; // 0x804e6d3
    i = 0;
    int32_t result = 0;
    int32_t v14; // 0x804ea6e
    if (opstatus == 0) {
      lab_0x804ea67:
        // 0x804ea67
        v14 = *(int32_t *)20;
        g6 = v14 ^ v13;
        if (v14 != v13) {
            // 0x804ea76
            __stack_chk_fail();
            // branch -> 0x804ea7b
        }
        // 0x804ea7b
        return result;
    }
    int32_t v15 = &v8; // 0x804e6f9_0
    size = v15;
    v1[4] = operation;
    g6 = operation;
    int32_t v16; // 0x804e9df
    int32_t v17; // 0x804ea4c
    char v18; // 0x804ea54
    int32_t v19; // 0x804ea58_0
    char * mem; // 0x804e9fc
    char v20;
    char v21;
    int32_t v22; // 0x804e808
    uint32_t v23; // 0x804e9bd
    int32_t v24; // 0x804e9ef
    int32_t v25; // 0x804e7fd
    int32_t v26; // 0x804e9c3
    int32_t v27; // 0x804ea5b84
    if (operation > 11) {
        // 0x804e75c
        if (operation == 13) {
            // 0x804e930
            size = &v10;
            char v28 = v7;
            v1[0] = v28;
            quantum_int2char((int32_t)v28, v4);
            size = &v12;
            char v29 = v10;
            v1[0] = v29;
            quantum_int2char((int32_t)v29, v3);
            int32_t v30;
            size = &v30;
            float64_t v31 = v12;
            g20 = v31;
            quantum_double2char(v31, v2);
            i = 17;
            v26 = 17;
            // branch -> 0x804e9bd
            // 0x804e9bd
            v23 = position;
            v27 = v26;
            if ((v23 + v26) / 0x10000 > v23 / 0x10000) {
                // 0x804e9da
                v16 = allocated + 1;
                allocated = v16;
                v24 = objcode;
                g6 = v24;
                mem = realloc((char *)v24, 0x10000 * v16);
                objcode = (int32_t)mem;
                if (mem == NULL) {
                    // 0x804ea0f
                    quantum_error(2);
                    // branch -> 0x804ea1b
                }
                // 0x804ea1b
                quantum_memman(0x10000);
                v27 = i;
                // branch -> 0x804ea27
            }
            // 0x804ea27
            v1[0] = 0;
            if (v27 <= 0) {
                // 0x804ea67
                v14 = *(int32_t *)20;
                g6 = v14 ^ v13;
                if (v14 != v13) {
                    // 0x804ea76
                    __stack_chk_fail();
                    // branch -> 0x804ea7b
                }
                // 0x804ea7b
                return 1;
            }
            // 0x804ea30
            *(char *)(position + objcode) = *(char *)(g2 - 84);
            v17 = position + 1;
            position = v17;
            v18 = v1[0] + 1;
            v1[0] = v18;
            v19 = v18;
            // branch -> 0x804ea30
            while (v19 < i) {
                // 0x804ea30
                *(char *)(v17 + objcode) = *(char *)(v19 - 84 + g2);
                v17 = position + 1;
                position = v17;
                v18 = v1[0] + 1;
                v1[0] = v18;
                v19 = v18;
                // continue -> 0x804ea30
            }
            // 0x804ea67
            v14 = *(int32_t *)20;
            g6 = v14 ^ v13;
            if (v14 != v13) {
                // 0x804ea76
                __stack_chk_fail();
                // branch -> 0x804ea7b
            }
            // 0x804ea7b
            return 1;
        }
        // 0x804e766
        if (operation >= 13) {
            // 0x804e76c
            if (operation == 14) {
                // 0x804e8a9
                size = v15 + 4;
                v21 = v7;
                v1[0] = v21;
                quantum_int2char((int32_t)v21, v4);
                i = 5;
                v26 = 5;
                // branch -> 0x804e9bd
            } else {
                // 0x804e9b1
                quantum_error(0x10001);
                v26 = i;
                // branch -> 0x804e9bd
            }
            // 0x804e9bd
            v23 = position;
            v27 = v26;
            if ((v23 + v26) / 0x10000 > v23 / 0x10000) {
                // 0x804e9da
                v16 = allocated + 1;
                allocated = v16;
                v24 = objcode;
                g6 = v24;
                mem = realloc((char *)v24, 0x10000 * v16);
                objcode = (int32_t)mem;
                if (mem == NULL) {
                    // 0x804ea0f
                    quantum_error(2);
                    // branch -> 0x804ea1b
                }
                // 0x804ea1b
                quantum_memman(0x10000);
                v27 = i;
                // branch -> 0x804ea27
            }
            // 0x804ea27
            v1[0] = 0;
            if (v27 <= 0) {
                // 0x804ea67
                v14 = *(int32_t *)20;
                g6 = v14 ^ v13;
                if (v14 != v13) {
                    // 0x804ea76
                    __stack_chk_fail();
                    // branch -> 0x804ea7b
                }
                // 0x804ea7b
                return 1;
            }
            // 0x804ea30
            *(char *)(position + objcode) = *(char *)(g2 - 84);
            v17 = position + 1;
            position = v17;
            v18 = v1[0] + 1;
            v1[0] = v18;
            v19 = v18;
            // branch -> 0x804ea30
            while (v19 < i) {
                // 0x804ea30
                *(char *)(v17 + objcode) = *(char *)(v19 - 84 + g2);
                v17 = position + 1;
                position = v17;
                v18 = v1[0] + 1;
                v1[0] = v18;
                v19 = v18;
                // continue -> 0x804ea30
            }
            // 0x804ea67
            v14 = *(int32_t *)20;
            g6 = v14 ^ v13;
            if (v14 != v13) {
                // 0x804ea76
                __stack_chk_fail();
                // branch -> 0x804ea7b
            }
            // 0x804ea7b
            return 1;
        }
        // 0x804e7d8
        size = v15 + 4;
        v20 = v7;
        v1[0] = v20;
        quantum_int2char((int32_t)v20, v4);
        v25 = size;
        size = v25 + 4;
        v22 = *(int32_t *)v25;
        v1[0] = v22;
        quantum_int2char(v22, v3);
        i = 9;
        v26 = 9;
        // branch -> 0x804e9bd
        // 0x804e9bd
        v23 = position;
        v27 = v26;
        if ((v23 + v26) / 0x10000 > v23 / 0x10000) {
            // 0x804e9da
            v16 = allocated + 1;
            allocated = v16;
            v24 = objcode;
            g6 = v24;
            mem = realloc((char *)v24, 0x10000 * v16);
            objcode = (int32_t)mem;
            if (mem == NULL) {
                // 0x804ea0f
                quantum_error(2);
                // branch -> 0x804ea1b
            }
            // 0x804ea1b
            quantum_memman(0x10000);
            v27 = i;
            // branch -> 0x804ea27
        }
        // 0x804ea27
        v1[0] = 0;
        if (v27 <= 0) {
            // 0x804ea67
            v14 = *(int32_t *)20;
            g6 = v14 ^ v13;
            if (v14 != v13) {
                // 0x804ea76
                __stack_chk_fail();
                // branch -> 0x804ea7b
            }
            // 0x804ea7b
            return 1;
        }
        // 0x804ea30
        *(char *)(position + objcode) = *(char *)(g2 - 84);
        v17 = position + 1;
        position = v17;
        v18 = v1[0] + 1;
        v1[0] = v18;
        v19 = v18;
        // branch -> 0x804ea30
        while (v19 < i) {
            // 0x804ea30
            *(char *)(v17 + objcode) = *(char *)(v19 - 84 + g2);
            v17 = position + 1;
            position = v17;
            v18 = v1[0] + 1;
            v1[0] = v18;
            v19 = v18;
            // continue -> 0x804ea30
        }
        // 0x804ea67
        v14 = *(int32_t *)20;
        g6 = v14 ^ v13;
        if (v14 != v13) {
            // 0x804ea76
            __stack_chk_fail();
            // branch -> 0x804ea7b
        }
        // 0x804ea7b
        return 1;
    }
    // 0x804e713
    int32_t v32;
    if (operation > 6) {
        char v33 = v7;
        v1[0] = v33;
        size = &v32;
        quantum_int2char((int32_t)v33, v4);
        g20 = (int64_t)v9;
        quantum_double2char((float64_t)(int64_t)v9, v3);
        i = 13;
        v26 = 13;
        // branch -> 0x804e9bd
        // 0x804e9bd
        v23 = position;
        v27 = v26;
        if ((v23 + v26) / 0x10000 > v23 / 0x10000) {
            // 0x804e9da
            v16 = allocated + 1;
            allocated = v16;
            v24 = objcode;
            g6 = v24;
            mem = realloc((char *)v24, 0x10000 * v16);
            objcode = (int32_t)mem;
            if (mem == NULL) {
                // 0x804ea0f
                quantum_error(2);
                // branch -> 0x804ea1b
            }
            // 0x804ea1b
            quantum_memman(0x10000);
            v27 = i;
            // branch -> 0x804ea27
        }
        // 0x804ea27
        v1[0] = 0;
        if (v27 <= 0) {
            // 0x804ea67
            v14 = *(int32_t *)20;
            g6 = v14 ^ v13;
            if (v14 != v13) {
                // 0x804ea76
                __stack_chk_fail();
                // branch -> 0x804ea7b
            }
            // 0x804ea7b
            return 1;
        }
        // 0x804ea30
        *(char *)(position + objcode) = *(char *)(g2 - 84);
        v17 = position + 1;
        position = v17;
        v18 = v1[0] + 1;
        v1[0] = v18;
        v19 = v18;
        // branch -> 0x804ea30
        while (v19 < i) {
            // 0x804ea30
            *(char *)(v17 + objcode) = *(char *)(v19 - 84 + g2);
            v17 = position + 1;
            position = v17;
            v18 = v1[0] + 1;
            v1[0] = v18;
            v19 = v18;
            // continue -> 0x804ea30
        }
        // 0x804ea67
        v14 = *(int32_t *)20;
        g6 = v14 ^ v13;
        if (v14 != v13) {
            // 0x804ea76
            __stack_chk_fail();
            // branch -> 0x804ea7b
        }
        // 0x804ea7b
        return 1;
    }
    // 0x804e71d
    if (operation == 2) {
        // 0x804e82e
        size = &v10;
        char v34 = v7;
        v1[0] = v34;
        quantum_int2char((int32_t)v34, v4);
        size = &v12;
        char v35 = v10;
        v1[0] = v35;
        quantum_int2char((int32_t)v35, v3);
        size = &v32;
        char v36 = v12;
        v1[0] = v36;
        quantum_int2char((int32_t)v36, v2);
        i = 13;
        v26 = 13;
        // branch -> 0x804e9bd
        // 0x804e9bd
        v23 = position;
        v27 = v26;
        if ((v23 + v26) / 0x10000 > v23 / 0x10000) {
            // 0x804e9da
            v16 = allocated + 1;
            allocated = v16;
            v24 = objcode;
            g6 = v24;
            mem = realloc((char *)v24, 0x10000 * v16);
            objcode = (int32_t)mem;
            if (mem == NULL) {
                // 0x804ea0f
                quantum_error(2);
                // branch -> 0x804ea1b
            }
            // 0x804ea1b
            quantum_memman(0x10000);
            v27 = i;
            // branch -> 0x804ea27
        }
        // 0x804ea27
        v1[0] = 0;
        if (v27 <= 0) {
            // 0x804ea67
            v14 = *(int32_t *)20;
            g6 = v14 ^ v13;
            if (v14 != v13) {
                // 0x804ea76
                __stack_chk_fail();
                // branch -> 0x804ea7b
            }
            // 0x804ea7b
            return 1;
        }
        // 0x804ea30
        *(char *)(position + objcode) = *(char *)(g2 - 84);
        v17 = position + 1;
        position = v17;
        v18 = v1[0] + 1;
        v1[0] = v18;
        v19 = v18;
        // branch -> 0x804ea30
        while (v19 < i) {
            // 0x804ea30
            *(char *)(v17 + objcode) = *(char *)(v19 - 84 + g2);
            v17 = position + 1;
            position = v17;
            v18 = v1[0] + 1;
            v1[0] = v18;
            v19 = v18;
            // continue -> 0x804ea30
        }
        // 0x804ea67
        v14 = *(int32_t *)20;
        g6 = v14 ^ v13;
        if (v14 != v13) {
            // 0x804ea76
            __stack_chk_fail();
            // branch -> 0x804ea7b
        }
        // 0x804ea7b
        return 1;
    }
    // 0x804e727
    if (operation > 2) {
        // 0x804e8a9
        size = v15 + 4;
        v21 = v7;
        v1[0] = v21;
        quantum_int2char((int32_t)v21, v4);
        i = 5;
        v26 = 5;
        // branch -> 0x804e9bd
        // 0x804e9bd
        v23 = position;
        v27 = v26;
        if ((v23 + v26) / 0x10000 > v23 / 0x10000) {
            // 0x804e9da
            v16 = allocated + 1;
            allocated = v16;
            v24 = objcode;
            g6 = v24;
            mem = realloc((char *)v24, 0x10000 * v16);
            objcode = (int32_t)mem;
            if (mem == NULL) {
                // 0x804ea0f
                quantum_error(2);
                // branch -> 0x804ea1b
            }
            // 0x804ea1b
            quantum_memman(0x10000);
            v27 = i;
            // branch -> 0x804ea27
        }
        // 0x804ea27
        v1[0] = 0;
        if (v27 <= 0) {
            // 0x804ea67
            v14 = *(int32_t *)20;
            g6 = v14 ^ v13;
            if (v14 != v13) {
                // 0x804ea76
                __stack_chk_fail();
                // branch -> 0x804ea7b
            }
            // 0x804ea7b
            return 1;
        }
        // 0x804ea30
        *(char *)(position + objcode) = *(char *)(g2 - 84);
        v17 = position + 1;
        position = v17;
        v18 = v1[0] + 1;
        v1[0] = v18;
        v19 = v18;
        // branch -> 0x804ea30
        while (v19 < i) {
            // 0x804ea30
            *(char *)(v17 + objcode) = *(char *)(v19 - 84 + g2);
            v17 = position + 1;
            position = v17;
            v18 = v1[0] + 1;
            v1[0] = v18;
            v19 = v18;
            // continue -> 0x804ea30
        }
        // 0x804ea67
        v14 = *(int32_t *)20;
        g6 = v14 ^ v13;
        if (v14 != v13) {
            // 0x804ea76
            __stack_chk_fail();
            // branch -> 0x804ea7b
        }
        // 0x804ea7b
        return 1;
    }
    // 0x804e731
    switch (operation) {
        case 0: {
            // 0x804e79a
            size = &v12;
            quantum_mu2char((int64_t)v7, v4);
            i = 9;
            // branch -> 0x804e9bd
            break;
        }
        case 1: {
            // 0x804e7d8
            size = v15 + 4;
            v20 = v7;
            v1[0] = v20;
            quantum_int2char((int32_t)v20, v4);
            v25 = size;
            size = v25 + 4;
            v22 = *(int32_t *)v25;
            v1[0] = v22;
            quantum_int2char(v22, v3);
            i = 9;
            // branch -> 0x804e9bd
            break;
        }
    }
    // 0x804e9b1
    quantum_error(0x10001);
    v26 = i;
    // branch -> 0x804e9bd
    // 0x804e9bd
    v23 = position;
    v27 = v26;
    if ((v23 + v26) / 0x10000 > v23 / 0x10000) {
        // 0x804e9da
        v16 = allocated + 1;
        allocated = v16;
        v24 = objcode;
        g6 = v24;
        mem = realloc((char *)v24, 0x10000 * v16);
        objcode = (int32_t)mem;
        if (mem == NULL) {
            // 0x804ea0f
            quantum_error(2);
            // branch -> 0x804ea1b
        }
        // 0x804ea1b
        quantum_memman(0x10000);
        v27 = i;
        // branch -> 0x804ea27
    }
    // 0x804ea27
    v1[0] = 0;
    if (v27 > 0) {
        int32_t v37 = position; // 0x804ea36
        int32_t v38 = 0; // bp+086
        // branch -> 0x804ea30
        while (true) {
            // 0x804ea30
            *(char *)(v37 + objcode) = *(char *)(v38 - 84 + g2);
            v17 = position + 1;
            position = v17;
            v18 = v1[0] + 1;
            v1[0] = v18;
            v19 = v18;
            if (v19 >= i) {
                result = 1;
                // break (via goto) -> 0x804ea67
                goto lab_0x804ea67;
            }
            v37 = v17;
            v38 = v19;
            // continue -> 0x804ea30
        }
    }
    // 0x804ea67
    v14 = *(int32_t *)20;
    g6 = v14 ^ v13;
    if (v14 != v13) {
        // 0x804ea76
        __stack_chk_fail();
        // branch -> 0x804ea7b
    }
    // 0x804ea7b
    return 1;
}

// From module:   /home/naftali/source/libquantum-0.9.1/objcode.c
// Address range: 0x804eb2b - 0x804eb37
// Line range:    295 - 297
void quantum_objcode_file(char * file) {
    // 0x804eb2b
    globalfile = (int32_t)file;
}

// From module:   /home/naftali/source/libquantum-0.9.1/objcode.c
// Address range: 0x804eb38 - 0x804eb50
// Line range:    304 - 307
void quantum_objcode_exit(char * file) {
    // 0x804eb38
    abort();
    // UNREACHABLE
}

// From module:   /home/naftali/source/libquantum-0.9.1/omuln.c
// Address range: 0x804f2f4 - 0x804f34b
// Line range:    30 - 36
void emul(int32_t a, int32_t L, int32_t width2, struct quantum_reg_struct_7 * reg) {
    int32_t v1 = width2 - 1; // 0x804f2fd
    if (v1 > 0) {
        int32_t v2 = 2 * width2 + 2; // 0x804f323
        // branch -> 0x804f305
        while (true) {
            // 0x804f305
            g4 = v1;
            if ((a >> v1 % 32) % 2 != 0) {
                // 0x804f314
                g4 = v2;
                quantum_toffoli(v2, L, v1 + width2, (struct quantum_reg_struct_3 *)reg);
                // branch -> 0x804f340
            }
            // 0x804f340
            if (v1 <= 1) {
                // 0x804f344
                // branch -> 0x804f34a
                // 0x804f34a
                return;
            }
            // 0x804f340
            v1--;
            // branch -> 0x804f305
        }
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/omuln.c
// Address range: 0x804f34c - 0x804f471
// Line range:    38 - 55
void muln(int32_t N, uint32_t a, int32_t ctl, uint32_t width2, struct quantum_reg_struct_7 * reg) {
    // 0x804f34c
    int32_t v1;
    int32_t i = v1; // bp-12
    int32_t v2 = 2 * width2; // 0x804f355
    int32_t v3 = v2 | 1; // 0x804f35718
    i = v3;
    int32_t v4 = v2 + 2; // 0x804f363
    quantum_toffoli(ctl, v4, v3, (struct quantum_reg_struct_3 *)reg);
    emul((int32_t)((0x100000000 * (int64_t)(a / 0x80000000) | (int64_t)a) % (int64_t)N), i, width2, reg);
    quantum_toffoli(ctl, v4, i, (struct quantum_reg_struct_3 *)reg);
    for (int32_t j = 1; j < width2; j++) {
        int32_t v5 = j + v4; // 0x804f3e7
        quantum_toffoli(ctl, v5, i, (struct quantum_reg_struct_3 *)reg);
        int32_t v6 = a << j % 32; // 0x804f40f
        add_mod_n(N, (int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % (int64_t)N), width2, (struct quantum_reg_struct_5 *)reg);
        quantum_toffoli(ctl, v5, i, (struct quantum_reg_struct_3 *)reg);
        // continue -> 0x804f3dd
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/omuln.c
// Address range: 0x804f472 - 0x804f5b5
// Line range:    57 - 72
void muln_inv(int32_t N, int32_t a, int32_t ctl, int32_t width2, struct quantum_reg_struct_7 * reg) {
    // 0x804f472
    int32_t v1;
    int32_t i = v1; // bp-12
    int32_t v2 = N;
    i = 2 * width2 | 1;
    int32_t v3 = quantum_inverse_mod(N, a); // 0x804f490
    int32_t v4 = width2 - 1; // 0x804f49b
    int32_t v5 = 2 * (width2 + 1); // 0x804f4ac
    if (v4 > 0) {
        int32_t v6 = v4 + v5; // 0x804f4b0
        quantum_toffoli(ctl, v6, i, (struct quantum_reg_struct_3 *)reg);
        int32_t v7 = v3 << v4 % 32; // 0x804f4d8
        add_mod_n(v2, v2 - (int32_t)((0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % (int64_t)v2), width2, (struct quantum_reg_struct_5 *)reg);
        quantum_toffoli(ctl, v6, i, (struct quantum_reg_struct_3 *)reg);
        while (v4 > 1) {
            // 0x804f4a6
            v4--;
            v6 = v4 + v5;
            quantum_toffoli(ctl, v6, i, (struct quantum_reg_struct_3 *)reg);
            v7 = v3 << v4 % 32;
            add_mod_n(v2, v2 - (int32_t)((0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % (int64_t)v2), width2, (struct quantum_reg_struct_5 *)reg);
            quantum_toffoli(ctl, v6, i, (struct quantum_reg_struct_3 *)reg);
            // continue -> 0x804f4a6
        }
        // 0x804f536
        N = v2;
        // branch -> 0x804f540
    }
    // 0x804f540
    quantum_toffoli(ctl, v5, i, (struct quantum_reg_struct_3 *)reg);
    emul((int32_t)((0x100000000 * (int64_t)(v3 >> 31) | (int64_t)v3) % (int64_t)N), i, width2, reg);
    quantum_toffoli(ctl, v5, i, (struct quantum_reg_struct_3 *)reg);
}

// From module:   /home/naftali/source/libquantum-0.9.1/omuln.c
// Address range: 0x804f5b6 - 0x804f627
// Line range:    76 - 83
void mul_mod_n(int32_t N, int32_t a, int32_t ctl, int32_t width2, struct quantum_reg_struct_7 * reg) {
    // 0x804f5b6
    muln(N, a, ctl, width2, reg);
    quantum_swaptheleads_omuln_controlled(ctl, width2, (struct quantum_reg_struct_3 *)reg);
    muln_inv(N, a, ctl, width2, reg);
}

// From module:   /home/naftali/source/libquantum-0.9.1/qec.c
// Address range: 0x804f628 - 0x804f63c
// Line range:    48 - 51
void quantum_qec_set_status(int32_t stype, int32_t swidth) {
    // 0x804f628
    type = stype;
    width = swidth;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qec.c
// Address range: 0x804f63d - 0x804f663
// Line range:    57 - 62
void quantum_qec_get_status(int32_t * ptype, int32_t * pwidth) {
    // 0x804f63d
    if (ptype != NULL) {
        // 0x804f646
        *ptype = type;
        // branch -> 0x804f651
    }
    // 0x804f651
    if (pwidth != NULL) {
        // 0x804f657
        *pwidth = width;
        // branch -> 0x804f662
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/qec.c
// Address range: 0x804f664 - 0x804f79e
// Line range:    69 - 100
void quantum_qec_encode(int32_t type2, int32_t width2, struct quantum_reg_struct_8 * reg) {
    // 0x804f664
    int32_t v1;
    int32_t i = v1; // bp-12
    quantum_get_decoherence();
    i = (float32_t)g16;
    g1 = 0;
    quantum_set_decoherence(0.0f);
    int32_t v2 = reg->e0; // 0x804f68e35
    struct quantum_reg_struct_8 * v3; // 0x804f78c
    if (reg->e0 <= 0) {
        // 0x804f777
        quantum_qec_set_status(1, v2);
        v3 = reg;
        v3->e0 *= 3;
        return;
    }
    int32_t v4 = v2; // 0x804f68e38
    int32_t v5 = 0;
    int32_t v6; // 0x804f68e
    while (true) {
        struct quantum_reg_struct_8 * v7 = reg; // 0x804f6b5
        if (v4 - 1 == v5) {
            // 0x804f698
            g1 = i;
            quantum_set_decoherence((float32_t)i);
            v7 = reg;
            // branch -> 0x804f6a3
        }
        int32_t v8 = v7->e0 + v5; // 0x804f6b2
        if (v5 < width2) {
            // 0x804f6ab
            quantum_hadamard(v8, (struct quantum_reg_struct_3 *)v7);
            quantum_hadamard(2 * reg->e0 + v5, (struct quantum_reg_struct_3 *)reg);
            quantum_cnot(reg->e0 + v5, v5, (struct quantum_reg_struct_3 *)reg);
            quantum_cnot(2 * reg->e0 + v5, v5, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804f765
        } else {
            // 0x804f723
            quantum_cnot(v5, v8, (struct quantum_reg_struct_3 *)v7);
            quantum_cnot(v5, 2 * reg->e0 + v5, (struct quantum_reg_struct_3 *)reg);
            // branch -> 0x804f765
        }
        int32_t v9 = v5 + 1; // 0x804f765
        v6 = reg->e0;
        if (reg->e0 <= v9) {
            // break -> 0x804f777
            break;
        }
        v4 = v6;
        v5 = v9;
        // continue -> 0x804f68b
    }
    // 0x804f777
    quantum_qec_set_status(1, v6);
    v3 = reg;
    v3->e0 *= 3;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qec.c
// Address range: 0x804f79f - 0x804f96d
// Line range:    107 - 147
void quantum_qec_decode(int32_t type2, int32_t width2, struct quantum_reg_struct_8 * reg) {
    // 0x804f79f
    int32_t v1;
    int32_t b = v1; // bp-20
    int32_t v2;
    int32_t i = v2; // bp-12
    quantum_get_decoherence();
    g1 = 0;
    quantum_set_decoherence(0.0f);
    b = reg->e0 / 3;
    quantum_qec_set_status(0, 0);
    int32_t v3 = reg->e0 / 3 - 1; // 0x804f817
    if (v3 > 0) {
        struct quantum_reg_struct_8 * v4 = reg; // 0x804f845
        while (true) {
            int32_t v5 = 2 * b + v3; // 0x804f842
            if (v3 < width2) {
                // 0x804f83b
                quantum_cnot(v5, v3, (struct quantum_reg_struct_3 *)v4);
                quantum_cnot(b + v3, v3, (struct quantum_reg_struct_3 *)reg);
                quantum_hadamard(2 * b + v3, (struct quantum_reg_struct_3 *)reg);
                quantum_hadamard(b + v3, (struct quantum_reg_struct_3 *)reg);
                // branch -> 0x804f8ec
            } else {
                // 0x804f8ad
                quantum_cnot(v3, v5, (struct quantum_reg_struct_3 *)v4);
                quantum_cnot(v3, b + v3, (struct quantum_reg_struct_3 *)reg);
                // branch -> 0x804f8ec
            }
            // 0x804f8ec
            if (v3 > 1) {
                // 0x804f8ec
                v4 = reg;
                v3--;
                // branch -> 0x804f833
                continue;
            }
        }
    }
    // 0x804f964
    if (b < 1) {
        // 0x804f96c
        return;
    }
    int32_t v6 = 1;
    while (true) {
        // 0x804f903
        i = quantum_bmeasure(b, (struct quantum_reg_struct_4 *)reg);
        if (quantum_bmeasure(2 * b - v6, (struct quantum_reg_struct_4 *)reg) == 1 && i == 1) {
            int32_t v7 = v6 - 1; // 0x804f943
            if (v7 < width2) {
                // 0x804f94b
                quantum_sigma_z(v7, (struct quantum_reg_struct_3 *)reg);
                // branch -> 0x804f960
            }
        }
        int32_t v8 = v6 + 1; // 0x804f960
        if (v8 > b) {
            // break -> 0x804f96c
            break;
        }
        v6 = v8;
        // continue -> 0x804f903
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/qec.c
// Address range: 0x804f96e - 0x804fa04
// Line range:    153 - 173
int32_t quantum_qec_counter(uint32_t inc, int32_t frequency, struct quantum_reg_struct_8 * reg) {
    int32_t v1 = 0; // 0x804f9a7
    if (inc >= 1) {
        // 0x804f97a
        v1 = g15 + inc;
        // branch -> 0x804f999
    }
    // 0x804f999
    g15 = v1;
    int32_t v2; // 0x804f9ad
    if (frequency < 1) {
        // 0x804f999
        v2 = g8;
        // branch -> 0x804f9a7
    } else {
        // 0x804f99f
        g8 = frequency;
        v2 = frequency;
        // branch -> 0x804f9a7
    }
    // 0x804f9a7
    int32_t result; // 0x804f9fe
    if (v1 >= v2) {
        // 0x804f9b6
        g15 = 0;
        int32_t v3 = type; // 0x804f9c6
        g4 = v3;
        quantum_qec_decode(v3, width, reg);
        int32_t v4 = type; // 0x804f9e5
        g4 = v4;
        quantum_qec_encode(v4, width, reg);
        result = g15;
        // branch -> 0x804f9fe
    } else {
        result = v1;
    }
    // 0x804f9fe
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qec.c
// Address range: 0x804fa05 - 0x804faa7
// Line range:    179 - 199
void quantum_sigma_x_ft(int32_t target, struct quantum_reg_struct_8 * reg) {
    // 0x804fa05
    int32_t v1;
    int32_t tmp = v1; // bp-12
    int32_t v2 = type; // 0x804fa0b
    type = 0;
    tmp = quantum_get_decoherence();
    g1 = 0;
    quantum_set_decoherence(0.0f);
    quantum_sigma_x(target, (struct quantum_reg_struct_3 *)reg);
    quantum_sigma_x(width + target, (struct quantum_reg_struct_3 *)reg);
    g1 = tmp;
    quantum_set_decoherence((float32_t)tmp);
    quantum_sigma_x(2 * width + target, (struct quantum_reg_struct_3 *)reg);
    quantum_qec_counter(1, 0, reg);
    type = v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qec.c
// Address range: 0x804faa8 - 0x804fb6f
// Line range:    205 - 226
void quantum_cnot_ft(int32_t control, int32_t target, struct quantum_reg_struct_8 * reg) {
    // 0x804faa8
    int32_t v1;
    int32_t tmp = v1; // bp-12
    int32_t v2 = type; // 0x804faae
    type = 0;
    quantum_get_decoherence();
    tmp = (float32_t)g20;
    g1 = 0;
    quantum_set_decoherence(0.0f);
    quantum_cnot(control, target, (struct quantum_reg_struct_3 *)reg);
    int32_t v3 = width; // 0x804faee
    int32_t v4 = v3 + control; // 0x804faff
    g4 = v4;
    quantum_cnot(v4, v3 + target, (struct quantum_reg_struct_3 *)reg);
    g1 = tmp;
    quantum_set_decoherence((float32_t)tmp);
    int32_t v5 = 2 * width; // 0x804fb25
    int32_t v6 = v5 + target; // 0x804fb29
    g4 = v6;
    quantum_cnot(v5 + control, v6, (struct quantum_reg_struct_3 *)reg);
    quantum_qec_counter(1, 0, reg);
    type = v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qec.c
// Address range: 0x804fb70 - 0x804fde3
// Line range:    232 - 281
void quantum_toffoli_ft(int32_t control1, uint32_t control2, uint32_t target, struct quantum_reg_struct_8 * reg) {
    struct quantum_reg_struct_8 * v1 = reg; // bp+16
    char v2 = 0x1000000 * target / 0x1000000 % 32; // 0x804fb89
    int32_t v3 = 0;
    if (v2 != 0) {
        // if_804fb89_0_true
        v3 = 1 >> 32 - (int32_t)v2;
        // branch -> after_if_804fb89_0
    }
    uint32_t v4 = target % 32; // 0x804fb8c
    int32_t v5 = 1; // 0x804fb93
    if (v4 != 0) {
        // if_804fb8c_0_true
        v5 = 1 << v4;
        // branch -> after_if_804fb8c_0
    }
    int32_t v6 = v5; // 0x804fbb9
    if (target != 32) {
        // 0x804fb93
        v6 = 0;
        v3 = v5;
        // branch -> 0x804fb97
    }
    int32_t v7 = width; // 0x804fb97
    uint32_t v8 = v7 + target; // 0x804fb9e
    char v9 = 0x1000000 * v8 / 0x1000000 % 32; // 0x804fbab
    int32_t v10 = 0;
    if (v9 != 0) {
        // if_804fbab_0_true
        v10 = 1 >> 32 - (int32_t)v9;
        // branch -> after_if_804fbab_0
    }
    uint32_t v11 = v8 % 32; // 0x804fbae
    int32_t v12 = 1; // 0x804fbb5
    if (v11 != 0) {
        // if_804fbae_0_true
        v12 = 1 << v11;
        // branch -> after_if_804fbae_0
    }
    int32_t v13 = v12; // 0x804fbb9
    if (v8 != 32) {
        // 0x804fbb5
        v13 = 0;
        v10 = v12;
        // branch -> 0x804fbb9
    }
    int32_t v14 = v13 + v6; // 0x804fbb9
    g3 = v14;
    int32_t v15 = v10 + v3 + (int32_t)(v14 < v6); // 0x804fbbb
    g7 = v15;
    int32_t v16 = 2 * v7 + target; // 0x804fbc6
    g4 = v16;
    char v17 = 0x1000000 * v16 / 0x1000000 % 32; // 0x804fbd3
    int32_t v18 = 0;
    if (v17 != 0) {
        // if_804fbd3_0_true
        v18 = 1 >> 32 - (int32_t)v17;
        // branch -> after_if_804fbd3_0
    }
    uint32_t v19 = v16 % 32; // 0x804fbd6
    int32_t v20 = 1; // 0x804fbdd
    if (v19 != 0) {
        // if_804fbd6_0_true
        v20 = 1 << v19;
        // branch -> after_if_804fbd6_0
    }
    int32_t v21 = v20; // 0x804fbe1
    if (v16 != 32) {
        // 0x804fbdd
        v21 = 0;
        v18 = v20;
        // branch -> 0x804fbe1
    }
    uint32_t v22 = v21 + v14; // 0x804fbe1
    int32_t v23 = v18 + v15 + (int32_t)(v22 < v21); // 0x804fbe3
    g6 = v23;
    int32_t v24 = 0x1000000 * control2 / 0x1000000 % 32; // 0x804fccb
    int32_t v25 = (int32_t)reg; // 0x0133
    if (*(int32_t *)(v25 + 4) > 0) {
        uint32_t v26 = control2 % 32; // 0x804fcce
        int32_t v27 = control1; // 0x804fc1a
        int32_t v28 = 0;
        // branch -> 0x804fbf7
        while (true) {
            int32_t * v29 = (int32_t *)(v25 + 12); // 0x804fc08_0
            int32_t v30 = 16 * v28; // 0x804fc0e
            int32_t v31 = *v29 + v30; // 0x804fc11
            uint32_t v32 = *(int32_t *)(v31 + 12); // 0x804fc14
            uint32_t v33 = *(int32_t *)(v31 + 8); // 0x804fc17
            char v34 = 0x1000000 * v27 / 0x1000000 % 32; // 0x804fc1d
            int32_t v35 = v33; // 0x804fc2b105
            if (v34 != 0) {
                uint32_t v36 = (int32_t)v34; // 0x804fc1d
                v35 = v32 << 32 - v36 | v33 >> v36;
                // branch -> after_if_804fc1d_0
            }
            uint32_t v37 = v27 % 32; // 0x804fc20
            int32_t v38 = v32; // 0x804fc27
            if (v37 != 0) {
                // if_804fc20_0_true
                v38 = v32 >> v37;
                // branch -> after_if_804fc20_0
            }
            if (v27 != 32) {
                // 0x804fc27
                v35 = v38;
                // branch -> 0x804fc2b
            }
            int32_t v39 = 0; // 0x804fc71
            if (v35 % 2 != 0) {
                // 0x804fc32
                v39 = 1;
                // branch -> 0x804fc39
            }
            int32_t v40 = *v29 + v30; // 0x804fc45
            uint32_t v41 = *(int32_t *)(v40 + 8); // 0x804fc48
            uint32_t v42 = *(int32_t *)(v40 + 12); // 0x804fc4b
            int32_t v43 = width; // 0x804fc4e
            uint32_t v44 = v43 + v27; // 0x804fc55
            char v45 = 0x1000000 * v44 / 0x1000000 % 32; // 0x804fc5c
            int32_t v46 = v41; // 0x804fc6a108
            if (v45 != 0) {
                uint32_t v47 = (int32_t)v45; // 0x804fc5c
                v46 = v42 << 32 - v47 | v41 >> v47;
                // branch -> after_if_804fc5c_0
            }
            uint32_t v48 = v44 % 32; // 0x804fc5f
            int32_t v49 = v42; // 0x804fc66
            if (v48 != 0) {
                // if_804fc5f_0_true
                v49 = v42 >> v48;
                // branch -> after_if_804fc5f_0
            }
            if (v44 != 32) {
                // 0x804fc66
                v46 = v49;
                // branch -> 0x804fc6a
            }
            int32_t v50 = v39; // 0x804fcaf
            if (v46 % 2 != 0) {
                // 0x804fc71
                v50 = v39 ^ 1;
                // branch -> 0x804fc75
            }
            int32_t v51 = *v29 + v30; // 0x804fc81
            uint32_t v52 = *(int32_t *)(v51 + 8); // 0x804fc84
            uint32_t v53 = *(int32_t *)(v51 + 12); // 0x804fc87
            int32_t v54 = 2 * v43; // 0x804fc8f
            uint32_t v55 = v54 + v27; // 0x804fc93
            char v56 = 0x1000000 * v55 / 0x1000000 % 32; // 0x804fc9a
            int32_t v57 = v52; // 0x804fca8112
            if (v56 != 0) {
                uint32_t v58 = (int32_t)v56; // 0x804fc9a
                v57 = v53 << 32 - v58 | v52 >> v58;
                // branch -> after_if_804fc9a_0
            }
            uint32_t v59 = v55 % 32; // 0x804fc9d
            int32_t v60 = v53; // 0x804fca4
            if (v59 != 0) {
                // if_804fc9d_0_true
                v60 = v53 >> v59;
                // branch -> after_if_804fc9d_0
            }
            if (v55 != 32) {
                // 0x804fca4
                v57 = v60;
                // branch -> 0x804fca8
            }
            int32_t v61 = v50; // 0x804fd61
            if (v57 % 2 != 0) {
                // 0x804fcaf
                v61 = v50 ^ 1;
                // branch -> 0x804fcb3
            }
            int32_t v62 = *v29 + v30; // 0x804fcbf
            uint32_t v63 = *(int32_t *)(v62 + 12); // 0x804fcc2
            uint32_t v64 = *(int32_t *)(v62 + 8); // 0x804fcc5
            int32_t v65 = v64; // 0x804fcd9116
            if ((char)v24 != 0) {
                // if_804fccb_0_true
                v65 = v64 >> v24 | v63 << 32 - v24;
                // branch -> after_if_804fccb_0
            }
            int32_t v66 = v63; // 0x804fcd5
            if (v26 != 0) {
                // if_804fcce_0_true
                v66 = v63 >> v26;
                // branch -> after_if_804fcce_0
            }
            if (control2 != 32) {
                // 0x804fcd5
                v65 = v66;
                // branch -> 0x804fcd9
            }
            int32_t v67 = 0; // 0x804fd1f
            if (v65 % 2 != 0) {
                // 0x804fce0
                v67 = 1;
                // branch -> 0x804fce7
            }
            int32_t v68 = *v29 + v30; // 0x804fcf3
            uint32_t v69 = *(int32_t *)(v68 + 8); // 0x804fcf6
            uint32_t v70 = *(int32_t *)(v68 + 12); // 0x804fcf9
            uint32_t v71 = v43 + control2; // 0x804fd03
            char v72 = 0x1000000 * v71 / 0x1000000 % 32; // 0x804fd0a
            int32_t v73 = v69; // 0x804fd18119
            if (v72 != 0) {
                uint32_t v74 = (int32_t)v72; // 0x804fd0a
                v73 = v70 << 32 - v74 | v69 >> v74;
                // branch -> after_if_804fd0a_0
            }
            uint32_t v75 = v71 % 32; // 0x804fd0d
            int32_t v76 = v70; // 0x804fd14
            if (v75 != 0) {
                // if_804fd0d_0_true
                v76 = v70 >> v75;
                // branch -> after_if_804fd0d_0
            }
            if (v71 != 32) {
                // 0x804fd14
                v73 = v76;
                // branch -> 0x804fd18
            }
            int32_t v77 = v67; // 0x804fd5d
            if (v73 % 2 != 0) {
                // 0x804fd1f
                v77 = v67 ^ 1;
                // branch -> 0x804fd23
            }
            int32_t v78 = *v29 + v30; // 0x804fd2f
            int32_t v79 = *(int32_t *)(v78 + 8); // 0x804fd32
            g3 = v79;
            int32_t v80 = *(int32_t *)(v78 + 12); // 0x804fd35
            g7 = v80;
            int32_t v81 = v54 + control2; // 0x804fd41
            g4 = v81;
            g6 = v80;
            char v82 = 0x1000000 * v81 / 0x1000000 % 32; // 0x804fd48
            int32_t v83 = v79; // 0x804fd56123
            if (v82 != 0) {
                uint32_t v84 = (int32_t)v82; // 0x804fd48
                v83 = v80 << 32 - v84 | v79 >> v84;
                // branch -> after_if_804fd48_0
            }
            uint32_t v85 = v81 % 32; // 0x804fd4b
            int32_t v86 = v80; // 0x804fd52
            if (v85 != 0) {
                int32_t v87 = v80 >> v85; // 0x804fd4b
                g6 = v87;
                v86 = v87;
                // branch -> after_if_804fd4b_0
            }
            if (v81 != 32) {
                // 0x804fd52
                g6 = 0;
                v83 = v86;
                // branch -> 0x804fd56
            }
            int32_t v88 = v77; // 0x804fd67
            if (v83 % 2 != 0) {
                // 0x804fd5d
                v88 = v77 ^ 1;
                // branch -> 0x804fd61
            }
            struct quantum_reg_struct_8 * v89 = reg;
            if (v61 == 1 && v88 == 1) {
                int32_t v90 = *v29 + v30; // 0x804fd79
                g7 = v90;
                int32_t v91 = *v29 + v30; // 0x804fd88
                int32_t v92 = *(int32_t *)(v91 + 8); // 0x804fd8b
                g4 = v92;
                int32_t v93 = *(int32_t *)(v91 + 12); // 0x804fd8e
                g3 = v93;
                int32_t v94 = v93 ^ v23; // 0x804fd98
                g6 = v94;
                *(int32_t *)(v90 + 8) = v92 ^ v22;
                *(int32_t *)(g7 + 12) = v94;
                v89 = v1;
                // branch -> 0x804fda1
            }
            int32_t v95 = v28 + 1; // 0x804fda1
            int32_t v96 = (int32_t)v89; // 0x804fda5_0
            if (*(int32_t *)(v96 + 4) > v95) {
                // 0x804fda1
                v27 = control1;
                v25 = v96;
                v28 = v95;
                reg = v89;
                // branch -> 0x804fbf7
                continue;
            } else {
                reg = v89;
            }
        }
    }
    // 0x804fdb4
    quantum_decohere((struct quantum_reg_struct *)reg);
    quantum_qec_counter(1, 0, v1);
}

// From module:   /home/naftali/source/libquantum-0.9.1/qft.c
// Address range: 0x804fde4 - 0x804fe42
// Line range:    32 - 43
void quantum_qft(int32_t width2, struct quantum_reg_struct_9 * reg) {
    // 0x804fde4
    int32_t v1;
    int32_t i = v1; // bp-12
    int32_t v2 = width2 - 1; // 0x804fded
    if (v2 > 0) {
        while (true) {
            int32_t v3 = width2 - 1; // 0x804fdf8
            i = v3;
            struct quantum_reg_struct_9 * v4 = reg;
            if (v3 > v2) {
                quantum_cond_phase(v3, v2, (struct quantum_reg_struct_3 *)reg);
                int32_t v5 = i - 1; // 0x804fe19
                i = v5;
                while (v5 > v2) {
                    // 0x804fe00
                    quantum_cond_phase(v5, v2, (struct quantum_reg_struct_3 *)reg);
                    v5 = i - 1;
                    i = v5;
                    // continue -> 0x804fe00
                }
                // 0x804fe25
                quantum_hadamard(v2, (struct quantum_reg_struct_3 *)reg);
                if (v2 <= 1) {
                    // 0x804fe3b
                    // branch -> 0x804fe41
                    // 0x804fe41
                    return;
                }
              lab_0x804fe25:
                // 0x804fe25
                v2--;
                // branch -> 0x804fdf5
                continue;
            }
            // 0x804fe25
            quantum_hadamard(v2, (struct quantum_reg_struct_3 *)v4);
            if (v2 > 1) {
                goto lab_0x804fe25;
            }
            // 0x804fe3b
            // branch -> 0x804fe41
            // 0x804fe41
            return;
        }
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.c
// Address range: 0x8050d20 - 0x8050e5f
// Line range:    98 - 145
struct quantum_reg_struct_11 quantum_new_qureg(int64_t initval, int32_t width2) {
    struct quantum_reg_struct_11 result; // 0x8050e5d_3
    // 0x8050d20
    char * v1;
    char * c = v1; // bp-12
    int32_t v2;
    int32_t v3 = v2 + 2; // 0x8050d42
    char * mem = calloc(1, 16); // 0x8050d57
    int32_t v4 = (int32_t)mem; // 0x8050d57_5
    if (mem == NULL) {
        // 0x8050d66
        quantum_error(2);
        // branch -> 0x8050d72
    }
    // 0x8050d72
    quantum_memman(16);
    g4 = v3;
    uint32_t v5 = v3 % 32; // 0x8050d86
    char * mem2 = calloc(1 << v5, 4); // 0x8050d93
    c = mem2;
    if (mem2 == NULL) {
        // 0x8050da2
        quantum_error(2);
        // branch -> 0x8050dae
    }
    // 0x8050dae
    quantum_memman(4 << v5);
    g4 = v4;
    int32_t v6;
    *(int32_t *)(v4 + 8) = v6;
    *(int32_t *)(g4 + 12) = width2;
    g6 = v4;
    *(int32_t *)mem = 0x3f800000;
    *(int32_t *)(g6 + 4) = 0;
    char * env_val = getenv("QUOBFILE"); // 0x8050de8
    if (env_val != NULL) {
        // 0x8050df6
        quantum_objcode_start();
        quantum_objcode_file(env_val);
        atexit((void (**)())quantum_objcode_exit);
        // branch -> 0x8050e13
    }
    // 0x8050e13
    quantum_objcode_put(0);
    int32_t v7 = initval; // 0x8050e30_0
    *(int32_t *)v7 = v2;
    *(int32_t *)(v7 + 4) = 1;
    *(int32_t *)(v7 + 8) = v3;
    *(int32_t *)(v7 + 12) = v4;
    *(int32_t *)(v7 + 16) = (int32_t)c;
    result = (struct quantum_reg_struct_11){
        .e0 = 0,
        .e1 = 0,
        .e2 = 0,
        .e3 = NULL,
        .e4 = NULL
    };
    result.e0 = v7;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.c
// Address range: 0x8050f7a - 0x8050fae
// Line range:    191 - 195
void quantum_destroy_hash(struct quantum_reg_struct_11 * reg) {
    // 0x8050f7a
    free((char *)*(int32_t *)((int32_t)reg + 16));
    quantum_memman(-4 << *(int32_t *)((int32_t)reg + 8) % 32);
    *(int32_t *)((int32_t)reg + 16) = 0;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.c
// Address range: 0x8050faf - 0x8051000
// Line range:    201 - 207
void quantum_delete_qureg(struct quantum_reg_struct_11 * reg) {
    int32_t v1 = (int32_t)reg; // 0x8050fb5_0
    if (*(int32_t *)(v1 + 8) == 0) {
        // 0x8050fd4
        free((char *)*(int32_t *)((int32_t)reg + 12));
        quantum_memman(-16 * *(int32_t *)((int32_t)reg + 4));
        *(int32_t *)((int32_t)reg + 12) = 0;
        return;
    }
    // 0x8050fbf
    if (*(int32_t *)(v1 + 16) != 0) {
        // 0x8050fc9
        quantum_destroy_hash(reg);
        // branch -> 0x8050fd4
    }
    // 0x8050fd4
    free((char *)*(int32_t *)((int32_t)reg + 12));
    quantum_memman(-16 * *(int32_t *)((int32_t)reg + 4));
    *(int32_t *)((int32_t)reg + 12) = 0;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.c
// Address range: 0x8051001 - 0x8051033
// Line range:    213 - 217
void quantum_delete_qureg_hashpreserve(struct quantum_reg_struct_11 * reg) {
    // 0x8051001
    free((char *)*(int32_t *)((int32_t)reg + 12));
    quantum_memman(-16 * *(int32_t *)((int32_t)reg + 4));
    *(int32_t *)((int32_t)reg + 12) = 0;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.h
// Address range: 0x805126a - 0x80512a9
// Line range:    57 - 64
float32_t quantum_prob_inline_18(float64_t a) {
    float80_t v1 = quantum_real_20(a); // 0x805127d_4
    float80_t v2 = quantum_imag_19(a); // 0x8051292_4
    return v1 * v1 + v2 * v2;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.h
// Address range: 0x80512aa - 0x80512c5
// Line range:    48 - 51
float32_t quantum_imag_19(float64_t a) {
    // 0x80512aa
    int32_t result;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/complex.h
// Address range: 0x80512c6 - 0x80512de
// Line range:    39 - 42
float32_t quantum_real_20(float64_t a) {
    // 0x80512c6
    return a;
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.c
// Address range: 0x805135c - 0x80513d9
// Line range:    294 - 307
void quantum_addscratch(int32_t bits, struct quantum_reg_struct_11 * reg) {
    int32_t v1 = (int32_t)reg; // 0x8051362_0
    reg->e0 += bits;
    if (*(int32_t *)(v1 + 4) > 0) {
        int32_t v2 = bits; // 0x8051397
        int32_t v3 = 0;
        while (true) {
            int32_t * v4 = (int32_t *)(v1 + 12); // 0x8051385_0
            int32_t v5 = 16 * v3; // 0x805138b
            int32_t v6 = *v4 + v5; // 0x805138e
            int32_t v7 = *(int32_t *)(v6 + 12); // 0x8051391
            uint32_t v8 = *(int32_t *)(v6 + 8); // 0x8051394
            char v9 = 0x1000000 * v2 / 0x1000000 % 32; // 0x805139a
            int32_t v10 = v7; // 0x80513ab15
            if (v9 != 0) {
                uint32_t v11 = (int32_t)v9; // 0x805139a
                v10 = v8 >> 32 - v11 | v7 << v11;
                // branch -> after_if_805139a_0
            }
            uint32_t v12 = v2 % 32; // 0x805139d
            int32_t v13 = v8; // 0x80513a4
            if (v12 != 0) {
                // if_805139d_0_true
                v13 = v8 << v12;
                // branch -> after_if_805139d_0
            }
            int32_t v14 = v13; // 0x80513a8
            if (v2 != 32) {
                // 0x80513a4
                v14 = 0;
                v10 = v13;
                // branch -> 0x80513a8
            }
            int32_t v15 = *v4 + v5; // 0x80513ba
            g4 = v15;
            *(int32_t *)(v15 + 8) = v14;
            *(int32_t *)(g4 + 12) = v10;
            int32_t v16 = v3 + 1; // 0x80513c9
            int32_t v17 = (int32_t)reg; // 0x80513cd_0
            if (*(int32_t *)(v17 + 4) <= v16) {
                // 0x80513cd
                // branch -> 0x80513d8
                // 0x80513d8
                return;
            }
            // 0x80513a8
            v2 = bits;
            v1 = v17;
            v3 = v16;
            // branch -> 0x8051382
        }
    }
}

// From module:   /home/naftali/source/libquantum-0.9.1/qureg.c
// Address range: 0x805165e - 0x80519b8
// Line range:    376 - 438
struct quantum_reg_struct_11 quantum_state_collapse(int32_t pos, int32_t value, struct quantum_reg_struct_11 reg) {
    struct quantum_reg_struct_11 result; // 0x80519b6_3
    // 0x805165e
    int64_t v1;
    int64_t pos2 = v1; // bp-64
    int64_t v2;
    int64_t rpat = v2; // bp-56
    int32_t v3;
    int32_t k = v3; // bp-28
    int32_t v4;
    int32_t i = v4; // bp-20
    k = 0;
    g21 = 0.0L;
    g4 = value;
    char v5 = 0x1000000 * value / 0x1000000 % 32; // 0x805169b
    int32_t v6 = 0;
    if (v5 != 0) {
        // if_805169b_0_true
        v6 = 1 >> 32 - (int32_t)v5;
        // branch -> after_if_805169b_0
    }
    // after_if_805169b_0
    g6 = v6;
    uint32_t v7 = value % 32; // 0x805169e
    int32_t v8 = 1; // 0x80516a5
    if (v7 != 0) {
        // if_805169e_0_true
        v8 = 1 << v7;
        // branch -> after_if_805169e_0
    }
    int32_t v9 = v8; // 0x80516a9
    if (value != 32) {
        // 0x80516a5
        g6 = v8;
        v9 = 0;
        v6 = v8;
        // branch -> 0x80516a9
    }
    int64_t v10 = v6; // 0x80516ac_0
    rpat = v10;
    int32_t v11 = reg.e2; // 0x8051734129
    int32_t nmemb = 0; // 0x8051749
    float64_t v12 = 0.0;
    int32_t v13; // 0x805175d_5
    int32_t * v14; // 0x80517b1_0
    int32_t * v15; // 0x80517b4_0
    char * mem; // 0x805175d
    int32_t v16;
    int32_t v17;
    int32_t v18; // 0x80517ae
    int32_t v19; // 0x80517b1
    uint32_t v20; // 0x80517b4
    int32_t v21; // 0x80518b8
    int32_t v22; // 0x8051975120
    int32_t v23; // 0x8051975159
    int32_t v24; // 0x80517ab
    int64_t v25; // 0x80517be
    int32_t v26; // 0x80517c7
    if (v11 > 0) {
        int32_t v27 = 0; // 0x8051749154
        int32_t v28 = 0;
        float64_t v29 = 0.0;
        // branch -> 0x80516b8
        while (true) {
            int32_t v30 = (int32_t)reg.e4 + 16 * v28; // 0x80516c1
            int32_t * v31 = (int32_t *)(v30 + 8); // 0x80516c4_0
            int32_t v32 = *v31; // 0x80516c4
            g4 = v32;
            int32_t * v33 = (int32_t *)(v30 + 12); // 0x80516c7_0
            uint32_t v34 = *v33; // 0x80516c7
            g3 = v34;
            int32_t v35 = reg.e0; // 0x80516da
            float64_t v36;
            int32_t v37; // 0x8051734
            int32_t v38; // 0x8051749153
            if (v35 == 0 || ((int32_t)((int64_t)v34 & v10) || v32 & v9) == 0) {
                int32_t v39 = *v31; // 0x80516ec
                g4 = v39;
                uint32_t v40 = *v33; // 0x80516ef
                g3 = v40;
                int32_t v41 = (int64_t)v40 & v10; // 0x80516f9_5
                g6 = v41;
                if ((v41 || v39 & v9 || v35) != 0) {
                    v38 = v27;
                    v37 = v11;
                    v36 = v29;
                  lab_0x8051730:;
                    int32_t v42 = v28 + 1; // 0x8051730
                    if (v37 <= v42) {
                        nmemb = v38;
                        v12 = v36;
                        // 0x8051740
                        mem = calloc(nmemb, 16);
                        v13 = (int32_t)mem;
                        if (mem == NULL) {
                            // 0x805176c
                            quantum_error(2);
                            // branch -> 0x8051778
                        }
                        // 0x8051778
                        quantum_memman(16 * k);
                        struct quantum_reg_node_struct_11 * v43 = reg.e3; // 0x8051786
                        pos2 = v16;
                        i = 0;
                        v22 = reg.e2;
                        if (v22 > 0) {
                            // 0x80517a5
                            v23 = v22;
                            v21 = 0;
                            v17 = 0;
                            // branch -> 0x80517a5
                            while (true) {
                                // 0x80517a5
                                v24 = 16 * v17;
                                v18 = (int32_t)reg.e4 + v24;
                                v14 = (int32_t *)(v18 + 8);
                                v19 = *v14;
                                v15 = (int32_t *)(v18 + 12);
                                v20 = *v15;
                                v25 = rpat;
                                v26 = reg.e0;
                                int32_t v44; // 0x80518b8158
                                int32_t v45; // 0x8051975
                                if (v26 == 0 || ((int32_t)(v25 & (int64_t)v20) || v19 & v9) == 0) {
                                  lab_0x80517cd:;
                                    int32_t v46 = *v14; // 0x80517d9
                                    uint32_t v47 = *v15; // 0x80517dc
                                    if (((int32_t)((int64_t)v47 & v25) || v46 & v9 || v26) != 0) {
                                        v45 = v23;
                                        v44 = v21;
                                      lab_0x8051971:;
                                        int32_t v48 = v17 + 1; // 0x8051971
                                        if (v45 <= v48) {
                                            // break -> 0x8051981
                                            break;
                                        }
                                        v23 = v45;
                                        v21 = v44;
                                        v17 = v48;
                                        // continue -> 0x80517a5
                                        continue;
                                    }
                                }
                              lab_0x80517fd:;
                                int32_t v49 = 0;
                                int32_t v50 = 0;
                                if (value > 0) {
                                    int32_t v51 = 0;
                                    int32_t v52 = 0; // 0x805183992
                                    int32_t v53 = 0; // 0x80518d37291
                                    // branch -> 0x8051814
                                    int32_t v54; // 0x805182f
                                    int32_t v55; // 0x8051832
                                    while (true) {
                                        char v56 = 0x1000000 * v52 / 0x1000000 % 32; // 0x8051821
                                        int32_t v57 = 0; // 0x805183297
                                        if (v56 != 0) {
                                            // if_8051821_0_true
                                            v57 = 1 >> 32 - (int32_t)v56;
                                            // branch -> after_if_8051821_0
                                        }
                                        int32_t v58 = 1 << v52 % 32; // 0x8051824
                                        int32_t v59 = v52 == 32 ? v57 : v58; // 0x805183296
                                        v54 = (v52 == 32 ? v58 : 0) + v53;
                                        v55 = (int32_t)(v54 < v53) + v51 + v59;
                                        int32_t v60 = v52 + 1; // 0x8051835
                                        if (v60 >= value) {
                                            // break -> 0x8051839
                                            break;
                                        }
                                        v51 = v55;
                                        v52 = v60;
                                        v53 = v54;
                                        // continue -> 0x8051814
                                    }
                                    // 0x8051839
                                    v49 = v55;
                                    v50 = v54;
                                    // branch -> 0x8051841
                                }
                                int32_t v61 = *v14 & v50; // 0x8051853
                                float64_t v62 = 0.0; // 0x80518b2
                                int32_t v63 = 0;
                                if (value < 63) {
                                    float64_t v64 = 0.0; // 0x12119
                                    int32_t v65 = 63; // 0x8051895113
                                    uint32_t v66 = 0; // 0x80518c173110
                                    // branch -> 0x8051870
                                    uint32_t v67; // 0x805188b
                                    int32_t v68; // 0x805188e117
                                    while (true) {
                                        char v69 = 0x1000000 * v65 / 0x1000000 % 32; // 0x805187d
                                        int32_t v70 = 0; // 0x805188e118
                                        if (v69 != 0) {
                                            // if_805187d_0_true
                                            v70 = 1 >> 32 - (int32_t)v69;
                                            // branch -> after_if_805187d_0
                                        }
                                        int32_t v71 = 1 << v65 % 32; // 0x8051880
                                        v68 = v65 == 32 ? v70 : v71;
                                        v67 = (v65 == 32 ? v71 : 0) + v66;
                                        int32_t v72 = v65 - 1; // 0x8051891
                                        if (v72 <= value) {
                                            // break -> 0x8051895
                                            break;
                                        }
                                        v64 = (int64_t)((int32_t)(v67 < v66) + (int32_t)(float32_t)v64 + v68);
                                        v65 = v72;
                                        v66 = v67;
                                        // continue -> 0x8051870
                                    }
                                    // 0x8051895
                                    v62 = (int64_t)((int32_t)(v67 < v66) + (int32_t)(float32_t)v64 + v68);
                                    v63 = v67;
                                    // branch -> 0x805189d
                                }
                                int32_t v73 = *v14; // 0x80518ac
                                int32_t v74 = (int32_t)(float32_t)v62 & *v15; // 0x80518b2
                                int32_t v75 = 16 * v21 + v13; // 0x80518be
                                *(int32_t *)(v75 + 8) = 0x80000000 * v74 | (v73 & v63) / 2 | v61;
                                *(int32_t *)(v75 + 12) = v74 / 2 | *v15 & v49;
                                int32_t v76 = 16 * i + v13; // 0x80518ea
                                int32_t v77 = (int32_t)reg.e4 + v24; // 0x80518f8
                                float64_t v78 = sqrtl((float80_t)v12);
                                float64_t v79 = v78;
                                if (v78 != v78 || 0.0 != 0.0) {
                                    // 0x805191a
                                    v79 = sqrt(v12);
                                    // branch -> 0x8051928
                                }
                                float32_t v80 = v79;
                                __divsc3(*(float32_t *)v77, *(float32_t *)(v77 + 4), v80, 0.0f);
                                *(int32_t *)v76 = 0;
                                *(int32_t *)(v76 + 4) = (int32_t)v80;
                                int32_t v81 = i + 1; // 0x805196d
                                i = v81;
                                v45 = reg.e2;
                                v44 = v81;
                                // branch -> 0x8051971
                                goto lab_0x8051971;
                            }
                        }
                        // 0x8051981
                        *(int32_t *)pos = reg.e1 - 1;
                        *(int32_t *)(pos + 4) = nmemb;
                        *(int32_t *)(pos + 8) = (int32_t)v43;
                        g4 = pos;
                        *(int32_t *)(pos + 12) = v13;
                        *(int32_t *)(pos + 16) = (int32_t)pos2;
                        result = (struct quantum_reg_struct_11){
                            .e0 = 0,
                            .e1 = 0,
                            .e2 = 0,
                            .e3 = NULL,
                            .e4 = NULL
                        };
                        result.e0 = pos;
                        return result;
                    }
                    // 0x8051730
                    v27 = v38;
                    v11 = v37;
                    v10 = rpat;
                    v28 = v42;
                    v29 = v36;
                    // branch -> 0x80516b8
                    continue;
                }
            }
            // 0x8051708
            g6 = v30;
            int32_t v82 = *(int32_t *)v30; // 0x8051713
            float80_t v83 = v29;
            g20 = v83;
            float80_t v84 = v83 + (float80_t)quantum_prob_inline_18((float64_t)(int64_t)v82); // 0x8051727
            g21 = v84;
            int32_t v85 = k + 1; // 0x805172c
            k = v85;
            v38 = v85;
            v37 = reg.e2;
            v36 = v84;
            // branch -> 0x8051730
            goto lab_0x8051730;
        }
    }
    // 0x8051740
    mem = calloc(nmemb, 16);
    v13 = (int32_t)mem;
    if (mem == NULL) {
        // 0x805176c
        quantum_error(2);
        // branch -> 0x8051778
    }
    // 0x8051778
    quantum_memman(16 * k);
    pos2 = v16;
    i = 0;
    v22 = reg.e2;
    if (v22 > 0) {
        // 0x80517a5
        v23 = v22;
        v21 = 0;
        v17 = 0;
        // branch -> 0x80517a5
        while (true) {
            // 0x80517a5
            v24 = 16 * v17;
            v18 = (int32_t)reg.e4 + v24;
            v14 = (int32_t *)(v18 + 8);
            v19 = *v14;
            v15 = (int32_t *)(v18 + 12);
            v20 = *v15;
            v25 = rpat;
            v26 = reg.e0;
            if (v26 == 0 || ((int32_t)(v25 & (int64_t)v20) || v19 & v9) == 0) {
                goto lab_0x80517cd;
            }
            goto lab_0x80517fd;
        }
    }
    // 0x8051981
    *(int32_t *)pos = reg.e1 - 1;
    *(int32_t *)(pos + 4) = nmemb;
    *(int32_t *)(pos + 8) = (int32_t)reg.e3;
    g4 = pos;
    *(int32_t *)(pos + 12) = v13;
    *(int32_t *)(pos + 16) = (int32_t)pos2;
    result = (struct quantum_reg_struct_11){
        .e0 = 0,
        .e1 = 0,
        .e2 = 0,
        .e3 = NULL,
        .e4 = NULL
    };
    result.e0 = pos;
    return result;
}

// From module:   /home/naftali/source/libquantum-0.9.1/shor.c
// Address range: 0x8052614 - 0x8052b2f
// Line range:    31 - 157
int main(int argc, char ** argv) {
    struct quantum_reg_struct_4 v1; // 0x80528d4
    struct quantum_reg_struct_12 v2;
    int32_t v3;
    int32_t b = v3; // bp-52
    int32_t v4;
    int32_t a = v4; // bp-48
    int32_t v5;
    int32_t q = v5; // bp-44
    int32_t v6;
    int32_t c = v6; // bp-40
    int32_t v7;
    int32_t N = v7; // bp-36
    int32_t v8;
    int32_t x = v8; // bp-32
    int32_t v9;
    int32_t swidth = v9; // bp-28
    int32_t v10;
    int32_t width2 = v10; // bp-24
    int32_t v11;
    int32_t i = v11; // bp-20
    x = 0;
    srand(time(NULL));
    if (argc == 1) {
        // 0x805264e
        puts("Usage: shor [number]\n");
        // branch -> 0x8052b22
    } else {
        int32_t v12 = (int32_t)argv; // 0x8052669_0
        int32_t str_as_i = atoi((char *)*(int32_t *)(v12 + 4)); // 0x8052674
        N = str_as_i;
        if (str_as_i > 14) {
            // 0x805269a
            width2 = quantum_getwidth(str_as_i * str_as_i);
            int32_t v13 = quantum_getwidth(N); // 0x80526b2
            swidth = v13;
            printf("N = %i, %i qubits required\n", N, 3 * v13 + 2 + width2);
            int32_t v14;
            if (argc < 3) {
                // 0x805269a
                v14 = x;
                // branch -> 0x8052712
            } else {
                int32_t str_as_i2 = atoi((char *)*(int32_t *)(v12 + 8)); // 0x80526f6
                x = str_as_i2;
                v14 = str_as_i2;
                // branch -> 0x8052712
            }
            int32_t v15 = v14; // 0x8052712
            // branch -> 0x8052712
            while (true) {
                // 0x8052712
                if (quantum_gcd(N, v15) <= 1) {
                    uint32_t v16 = x; // 0x8052729
                    if (v16 >= 2) {
                        // 0x805272f
                        printf("Random seed: %i\n", v16);
                        int32_t v17;
                        int32_t v18 = &v17; // 0x8052742_0
                        g6 = v18;
                        quantum_new_qureg((int64_t)v18, 0);
                        v2.e0 = v17;
                        int32_t v19;
                        v2.e1 = v19;
                        int32_t v20;
                        v2.e2 = v20;
                        int32_t v21;
                        v2.e3 = (struct quantum_reg_node_struct_12 *)v21;
                        int32_t v22;
                        v2.e4 = (int32_t *)v22;
                        i = 0;
                        int32_t v23; // 0x805280a
                        int32_t v24; // 0x805289d
                        int32_t v25; // 0x80529c7
                        int32_t v26; // 0x80528d4_3
                        int32_t v27; // 0x8052a27
                        int32_t v28; // 0x8052a59
                        int32_t v29; // 0x8052a9a
                        int32_t v30;
                        int32_t v31; // 0x8052850148
                        int32_t v32; // 0x805285b
                        int32_t v33; // 0x805287c
                        int32_t v34; // 0x80528a1
                        int32_t v35; // 0x80528a1143
                        int32_t v36; // 0x805298a
                        int32_t v37; // 0x80529fe
                        int32_t v38; // 0x8052a11
                        int32_t v39; // 0x8052a43
                        int32_t v40; // 0x8052a6a
                        int32_t v41; // 0x8052aa2
                        int32_t v42; // 0x8052abb
                        if (width2 > 0) {
                            quantum_hadamard(0, (struct quantum_reg_struct_3 *)&v2);
                            int32_t v43 = i + 1; // 0x80527a0
                            i = v43;
                            while (v43 < width2) {
                                // 0x805278e
                                quantum_hadamard(v43, (struct quantum_reg_struct_3 *)&v2);
                                v43 = i + 1;
                                i = v43;
                                // continue -> 0x805278e
                            }
                            // 0x80527ac
                            quantum_addscratch(3 * swidth + 2, (struct quantum_reg_struct_11 *)&v2);
                            quantum_exp_mod_n(N, x, width2, swidth, (struct quantum_reg_struct_2 *)&v2);
                            i = 0;
                            if (3 * swidth > -2) {
                                quantum_bmeasure(0, (struct quantum_reg_struct_4 *)&v2);
                                v23 = i + 1;
                                i = v23;
                                while (3 * swidth + 2 > v23) {
                                    // 0x80527f7
                                    quantum_bmeasure(0, (struct quantum_reg_struct_4 *)&v2);
                                    v23 = i + 1;
                                    i = v23;
                                    // continue -> 0x80527f7
                                }
                                // 0x805281f
                                quantum_qft(width2, (struct quantum_reg_struct_9 *)&v2);
                                i = 0;
                                v35 = width2;
                                if ((int32_t)(v35 < 0) + v35 <= 1) {
                                    // 0x80528b2
                                    v1 = (struct quantum_reg_struct_4){
                                        .e0 = 0,
                                        .e1 = 0,
                                        .e2 = 0,
                                        .e3 = NULL,
                                        .e4 = NULL
                                    };
                                    v1.e0 = v2.e0;
                                    v26 = quantum_measure(v1);
                                    c = v26;
                                    if (v26 == -1) {
                                        // 0x80528e4
                                        puts("Impossible Measurement!");
                                        // branch -> 0x8052b22
                                        // 0x8052b22
                                        return 1;
                                    }
                                    // 0x80528fc
                                    if (v26 == 0) {
                                        // 0x8052903
                                        puts("Measured zero, try again.");
                                        // branch -> 0x8052b22
                                        // 0x8052b22
                                        return 2;
                                    }
                                    // 0x805291b
                                    q = 1 << width2 % 32;
                                    printf("Measured %i (%f), ", (int32_t)"Measured %i (%f), ", (float64_t)(int64_t)v26);
                                    quantum_frac_approx(&c, &q, width2);
                                    printf("fractional approximation is %i/%i.\n", c, q);
                                    v36 = q;
                                    v37 = v36;
                                    if (v36 % 2 == 1) {
                                        // 0x80529a4
                                        if (2 * v36 < 1 << width2 % 32) {
                                            // 0x80529b8
                                            puts("Odd denominator, trying to expand by 2.");
                                            v25 = 2 * q;
                                            q = v25;
                                            v37 = v25;
                                            // branch -> 0x80529cc
                                        } else {
                                            v37 = v36;
                                        }
                                    }
                                    // 0x80529cc
                                    if (v37 % 2 == 1) {
                                        // 0x80529e6
                                        puts("Odd period, try again.");
                                        // branch -> 0x8052b22
                                        // 0x8052b22
                                        return 2;
                                    }
                                    // 0x80529fe
                                    printf("Possible period is %i.\n", v37);
                                    v38 = q;
                                    v27 = quantum_ipow(x, ((int32_t)(v38 < 0) + v38) / 2);
                                    a = (int32_t)(1 % (int64_t)N) + v27;
                                    v39 = q;
                                    v28 = quantum_ipow(x, ((int32_t)(v39 < 0) + v39) / 2);
                                    v40 = N;
                                    b = v28 - (int32_t)(1 % (int64_t)v40);
                                    a = quantum_gcd(v40, a);
                                    v29 = quantum_gcd(N, b);
                                    b = v29;
                                    v41 = a;
                                    v30 = v41 > v29 ? v41 : v29;
                                    v42 = N;
                                    if (v30 >= v42 || v30 < 2) {
                                        // 0x8052b0f
                                        puts("Unable to determine factors, try again.");
                                        // branch -> 0x8052b22
                                        // 0x8052b22
                                        return 2;
                                    }
                                    // 0x8052ac6
                                    printf("%i = %i * %i\n", v42, v30, (int32_t)((0x100000000 * (int64_t)(v42 >> 31) | (int64_t)v42) / (int64_t)v30));
                                    quantum_delete_qureg((struct quantum_reg_struct_11 *)&v2);
                                    // branch -> 0x8052b22
                                    // 0x8052b22
                                    return 0;
                                }
                                v31 = 0;
                                quantum_cnot(v31, v35 - v31 - 1, (struct quantum_reg_struct_3 *)&v2);
                                v32 = i;
                                quantum_cnot(width2 - v32 - 1, v32, (struct quantum_reg_struct_3 *)&v2);
                                v33 = i;
                                quantum_cnot(v33, width2 - v33 - 1, (struct quantum_reg_struct_3 *)&v2);
                                v24 = i + 1;
                                i = v24;
                                v34 = width2;
                                while (((int32_t)(v34 < 0) + v34) / 2 > v24) {
                                    // 0x805283a
                                    v31 = v24;
                                    quantum_cnot(v31, v34 - v31 - 1, (struct quantum_reg_struct_3 *)&v2);
                                    v32 = i;
                                    quantum_cnot(width2 - v32 - 1, v32, (struct quantum_reg_struct_3 *)&v2);
                                    v33 = i;
                                    quantum_cnot(v33, width2 - v33 - 1, (struct quantum_reg_struct_3 *)&v2);
                                    v24 = i + 1;
                                    i = v24;
                                    v34 = width2;
                                    // continue -> 0x805283a
                                }
                                // 0x80528b2
                                v1 = (struct quantum_reg_struct_4){
                                    .e0 = 0,
                                    .e1 = 0,
                                    .e2 = 0,
                                    .e3 = NULL,
                                    .e4 = NULL
                                };
                                v1.e0 = v2.e0;
                                v26 = quantum_measure(v1);
                                c = v26;
                                if (v26 == -1) {
                                    // 0x80528e4
                                    puts("Impossible Measurement!");
                                    // branch -> 0x8052b22
                                    // 0x8052b22
                                    return 1;
                                }
                                // 0x80528fc
                                if (v26 == 0) {
                                    // 0x8052903
                                    puts("Measured zero, try again.");
                                    // branch -> 0x8052b22
                                    // 0x8052b22
                                    return 2;
                                }
                                // 0x805291b
                                q = 1 << width2 % 32;
                                printf("Measured %i (%f), ", (int32_t)"Measured %i (%f), ", (float64_t)(int64_t)v26);
                                quantum_frac_approx(&c, &q, width2);
                                printf("fractional approximation is %i/%i.\n", c, q);
                                v36 = q;
                                v37 = v36;
                                if (v36 % 2 == 1) {
                                    // 0x80529a4
                                    if (2 * v36 < 1 << width2 % 32) {
                                        // 0x80529b8
                                        puts("Odd denominator, trying to expand by 2.");
                                        v25 = 2 * q;
                                        q = v25;
                                        v37 = v25;
                                        // branch -> 0x80529cc
                                    } else {
                                        v37 = v36;
                                    }
                                }
                                // 0x80529cc
                                if (v37 % 2 == 1) {
                                    // 0x80529e6
                                    puts("Odd period, try again.");
                                    // branch -> 0x8052b22
                                    // 0x8052b22
                                    return 2;
                                }
                                // 0x80529fe
                                printf("Possible period is %i.\n", v37);
                                v38 = q;
                                v27 = quantum_ipow(x, ((int32_t)(v38 < 0) + v38) / 2);
                                a = (int32_t)(1 % (int64_t)N) + v27;
                                v39 = q;
                                v28 = quantum_ipow(x, ((int32_t)(v39 < 0) + v39) / 2);
                                v40 = N;
                                b = v28 - (int32_t)(1 % (int64_t)v40);
                                a = quantum_gcd(v40, a);
                                v29 = quantum_gcd(N, b);
                                b = v29;
                                v41 = a;
                                v30 = v41 > v29 ? v41 : v29;
                                v42 = N;
                                if (v30 >= v42 || v30 < 2) {
                                    // 0x8052b0f
                                    puts("Unable to determine factors, try again.");
                                    // branch -> 0x8052b22
                                    // 0x8052b22
                                    return 2;
                                }
                                // 0x8052ac6
                                printf("%i = %i * %i\n", v42, v30, (int32_t)((0x100000000 * (int64_t)(v42 >> 31) | (int64_t)v42) / (int64_t)v30));
                                quantum_delete_qureg((struct quantum_reg_struct_11 *)&v2);
                                // branch -> 0x8052b22
                                // 0x8052b22
                                return 0;
                            }
                            // 0x805281f
                            quantum_qft(width2, (struct quantum_reg_struct_9 *)&v2);
                            i = 0;
                            v35 = width2;
                            if ((int32_t)(v35 < 0) + v35 > 1) {
                                v31 = 0;
                                quantum_cnot(v31, v35 - v31 - 1, (struct quantum_reg_struct_3 *)&v2);
                                v32 = i;
                                quantum_cnot(width2 - v32 - 1, v32, (struct quantum_reg_struct_3 *)&v2);
                                v33 = i;
                                quantum_cnot(v33, width2 - v33 - 1, (struct quantum_reg_struct_3 *)&v2);
                                v24 = i + 1;
                                i = v24;
                                v34 = width2;
                                while (((int32_t)(v34 < 0) + v34) / 2 > v24) {
                                    // 0x805283a
                                    v31 = v24;
                                    quantum_cnot(v31, v34 - v31 - 1, (struct quantum_reg_struct_3 *)&v2);
                                    v32 = i;
                                    quantum_cnot(width2 - v32 - 1, v32, (struct quantum_reg_struct_3 *)&v2);
                                    v33 = i;
                                    quantum_cnot(v33, width2 - v33 - 1, (struct quantum_reg_struct_3 *)&v2);
                                    v24 = i + 1;
                                    i = v24;
                                    v34 = width2;
                                    // continue -> 0x805283a
                                }
                                // 0x80528b2
                                v1 = (struct quantum_reg_struct_4){
                                    .e0 = 0,
                                    .e1 = 0,
                                    .e2 = 0,
                                    .e3 = NULL,
                                    .e4 = NULL
                                };
                                v1.e0 = v2.e0;
                                v26 = quantum_measure(v1);
                                c = v26;
                                if (v26 == -1) {
                                    // 0x80528e4
                                    puts("Impossible Measurement!");
                                    // branch -> 0x8052b22
                                    // 0x8052b22
                                    return 1;
                                }
                                // 0x80528fc
                                if (v26 == 0) {
                                    // 0x8052903
                                    puts("Measured zero, try again.");
                                    // branch -> 0x8052b22
                                    // 0x8052b22
                                    return 2;
                                }
                                // 0x805291b
                                q = 1 << width2 % 32;
                                printf("Measured %i (%f), ", (int32_t)"Measured %i (%f), ", (float64_t)(int64_t)v26);
                                quantum_frac_approx(&c, &q, width2);
                                printf("fractional approximation is %i/%i.\n", c, q);
                                v36 = q;
                                v37 = v36;
                                if (v36 % 2 == 1) {
                                    // 0x80529a4
                                    if (2 * v36 < 1 << width2 % 32) {
                                        // 0x80529b8
                                        puts("Odd denominator, trying to expand by 2.");
                                        v25 = 2 * q;
                                        q = v25;
                                        v37 = v25;
                                        // branch -> 0x80529cc
                                    } else {
                                        v37 = v36;
                                    }
                                }
                                // 0x80529cc
                                if (v37 % 2 == 1) {
                                    // 0x80529e6
                                    puts("Odd period, try again.");
                                    // branch -> 0x8052b22
                                    // 0x8052b22
                                    return 2;
                                }
                                // 0x80529fe
                                printf("Possible period is %i.\n", v37);
                                v38 = q;
                                v27 = quantum_ipow(x, ((int32_t)(v38 < 0) + v38) / 2);
                                a = (int32_t)(1 % (int64_t)N) + v27;
                                v39 = q;
                                v28 = quantum_ipow(x, ((int32_t)(v39 < 0) + v39) / 2);
                                v40 = N;
                                b = v28 - (int32_t)(1 % (int64_t)v40);
                                a = quantum_gcd(v40, a);
                                v29 = quantum_gcd(N, b);
                                b = v29;
                                v41 = a;
                                v30 = v41 > v29 ? v41 : v29;
                                v42 = N;
                                if (v30 >= v42 || v30 < 2) {
                                    // 0x8052b0f
                                    puts("Unable to determine factors, try again.");
                                    // branch -> 0x8052b22
                                    // 0x8052b22
                                    return 2;
                                }
                                // 0x8052ac6
                                printf("%i = %i * %i\n", v42, v30, (int32_t)((0x100000000 * (int64_t)(v42 >> 31) | (int64_t)v42) / (int64_t)v30));
                                quantum_delete_qureg((struct quantum_reg_struct_11 *)&v2);
                                // branch -> 0x8052b22
                                // 0x8052b22
                                return 0;
                            }
                            // 0x80528b2
                            v1 = (struct quantum_reg_struct_4){
                                .e0 = 0,
                                .e1 = 0,
                                .e2 = 0,
                                .e3 = NULL,
                                .e4 = NULL
                            };
                            v1.e0 = v2.e0;
                            v26 = quantum_measure(v1);
                            c = v26;
                            if (v26 == -1) {
                                // 0x80528e4
                                puts("Impossible Measurement!");
                                // branch -> 0x8052b22
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x80528fc
                                if (v26 == 0) {
                                    // 0x8052903
                                    puts("Measured zero, try again.");
                                    // branch -> 0x8052b22
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x805291b
                                    q = 1 << width2 % 32;
                                    printf("Measured %i (%f), ", (int32_t)"Measured %i (%f), ", (float64_t)(int64_t)v26);
                                    quantum_frac_approx(&c, &q, width2);
                                    printf("fractional approximation is %i/%i.\n", c, q);
                                    v36 = q;
                                    v37 = v36;
                                    if (v36 % 2 == 1) {
                                        // 0x80529a4
                                        if (2 * v36 < 1 << width2 % 32) {
                                            // 0x80529b8
                                            puts("Odd denominator, trying to expand by 2.");
                                            v25 = 2 * q;
                                            q = v25;
                                            v37 = v25;
                                            // branch -> 0x80529cc
                                        } else {
                                            v37 = v36;
                                        }
                                    }
                                    // 0x80529cc
                                    if (v37 % 2 == 1) {
                                        // 0x80529e6
                                        puts("Odd period, try again.");
                                        // branch -> 0x8052b22
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x80529fe
                                        printf("Possible period is %i.\n", v37);
                                        v38 = q;
                                        v27 = quantum_ipow(x, ((int32_t)(v38 < 0) + v38) / 2);
                                        a = (int32_t)(1 % (int64_t)N) + v27;
                                        v39 = q;
                                        v28 = quantum_ipow(x, ((int32_t)(v39 < 0) + v39) / 2);
                                        v40 = N;
                                        b = v28 - (int32_t)(1 % (int64_t)v40);
                                        a = quantum_gcd(v40, a);
                                        v29 = quantum_gcd(N, b);
                                        b = v29;
                                        v41 = a;
                                        v30 = v41 > v29 ? v41 : v29;
                                        v42 = N;
                                        if (v30 >= v42 || v30 < 2) {
                                            // 0x8052b0f
                                            puts("Unable to determine factors, try again.");
                                            // branch -> 0x8052b22
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x8052ac6
                                            printf("%i = %i * %i\n", v42, v30, (int32_t)((0x100000000 * (int64_t)(v42 >> 31) | (int64_t)v42) / (int64_t)v30));
                                            quantum_delete_qureg((struct quantum_reg_struct_11 *)&v2);
                                            // branch -> 0x8052b22
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x80527ac
                        quantum_addscratch(3 * swidth + 2, (struct quantum_reg_struct_11 *)&v2);
                        quantum_exp_mod_n(N, x, width2, swidth, (struct quantum_reg_struct_2 *)&v2);
                        i = 0;
                        if (3 * swidth > -2) {
                            quantum_bmeasure(0, (struct quantum_reg_struct_4 *)&v2);
                            v23 = i + 1;
                            i = v23;
                            while (3 * swidth + 2 > v23) {
                                // 0x80527f7
                                quantum_bmeasure(0, (struct quantum_reg_struct_4 *)&v2);
                                v23 = i + 1;
                                i = v23;
                                // continue -> 0x80527f7
                            }
                            // 0x805281f
                            quantum_qft(width2, (struct quantum_reg_struct_9 *)&v2);
                            i = 0;
                            v35 = width2;
                            if ((int32_t)(v35 < 0) + v35 > 1) {
                                v31 = 0;
                                quantum_cnot(v31, v35 - v31 - 1, (struct quantum_reg_struct_3 *)&v2);
                                v32 = i;
                                quantum_cnot(width2 - v32 - 1, v32, (struct quantum_reg_struct_3 *)&v2);
                                v33 = i;
                                quantum_cnot(v33, width2 - v33 - 1, (struct quantum_reg_struct_3 *)&v2);
                                v24 = i + 1;
                                i = v24;
                                v34 = width2;
                                while (((int32_t)(v34 < 0) + v34) / 2 > v24) {
                                    // 0x805283a
                                    v31 = v24;
                                    quantum_cnot(v31, v34 - v31 - 1, (struct quantum_reg_struct_3 *)&v2);
                                    v32 = i;
                                    quantum_cnot(width2 - v32 - 1, v32, (struct quantum_reg_struct_3 *)&v2);
                                    v33 = i;
                                    quantum_cnot(v33, width2 - v33 - 1, (struct quantum_reg_struct_3 *)&v2);
                                    v24 = i + 1;
                                    i = v24;
                                    v34 = width2;
                                    // continue -> 0x805283a
                                }
                                // 0x80528b2
                                v1 = (struct quantum_reg_struct_4){
                                    .e0 = 0,
                                    .e1 = 0,
                                    .e2 = 0,
                                    .e3 = NULL,
                                    .e4 = NULL
                                };
                                v1.e0 = v2.e0;
                                v26 = quantum_measure(v1);
                                c = v26;
                                if (v26 == -1) {
                                    // 0x80528e4
                                    puts("Impossible Measurement!");
                                    // branch -> 0x8052b22
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x80528fc
                                    if (v26 == 0) {
                                        // 0x8052903
                                        puts("Measured zero, try again.");
                                        // branch -> 0x8052b22
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x805291b
                                        q = 1 << width2 % 32;
                                        printf("Measured %i (%f), ", (int32_t)"Measured %i (%f), ", (float64_t)(int64_t)v26);
                                        quantum_frac_approx(&c, &q, width2);
                                        printf("fractional approximation is %i/%i.\n", c, q);
                                        v36 = q;
                                        v37 = v36;
                                        if (v36 % 2 == 1) {
                                            // 0x80529a4
                                            if (2 * v36 < 1 << width2 % 32) {
                                                // 0x80529b8
                                                puts("Odd denominator, trying to expand by 2.");
                                                v25 = 2 * q;
                                                q = v25;
                                                v37 = v25;
                                                // branch -> 0x80529cc
                                            } else {
                                                v37 = v36;
                                            }
                                        }
                                        // 0x80529cc
                                        if (v37 % 2 == 1) {
                                            // 0x80529e6
                                            puts("Odd period, try again.");
                                            // branch -> 0x8052b22
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x80529fe
                                            printf("Possible period is %i.\n", v37);
                                            v38 = q;
                                            v27 = quantum_ipow(x, ((int32_t)(v38 < 0) + v38) / 2);
                                            a = (int32_t)(1 % (int64_t)N) + v27;
                                            v39 = q;
                                            v28 = quantum_ipow(x, ((int32_t)(v39 < 0) + v39) / 2);
                                            v40 = N;
                                            b = v28 - (int32_t)(1 % (int64_t)v40);
                                            a = quantum_gcd(v40, a);
                                            v29 = quantum_gcd(N, b);
                                            b = v29;
                                            v41 = a;
                                            v30 = v41 > v29 ? v41 : v29;
                                            v42 = N;
                                            if (v30 >= v42 || v30 < 2) {
                                                // 0x8052b0f
                                                puts("Unable to determine factors, try again.");
                                                // branch -> 0x8052b22
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                // 0x8052ac6
                                                printf("%i = %i * %i\n", v42, v30, (int32_t)((0x100000000 * (int64_t)(v42 >> 31) | (int64_t)v42) / (int64_t)v30));
                                                quantum_delete_qureg((struct quantum_reg_struct_11 *)&v2);
                                                // branch -> 0x8052b22
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x80528b2
                            v1 = (struct quantum_reg_struct_4){
                                .e0 = 0,
                                .e1 = 0,
                                .e2 = 0,
                                .e3 = NULL,
                                .e4 = NULL
                            };
                            v1.e0 = v2.e0;
                            v26 = quantum_measure(v1);
                            c = v26;
                            if (v26 == -1) {
                                // 0x80528e4
                                puts("Impossible Measurement!");
                                // branch -> 0x8052b22
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x80528fc
                                if (v26 == 0) {
                                    // 0x8052903
                                    puts("Measured zero, try again.");
                                    // branch -> 0x8052b22
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x805291b
                                    q = 1 << width2 % 32;
                                    printf("Measured %i (%f), ", (int32_t)"Measured %i (%f), ", (float64_t)(int64_t)v26);
                                    quantum_frac_approx(&c, &q, width2);
                                    printf("fractional approximation is %i/%i.\n", c, q);
                                    v36 = q;
                                    v37 = v36;
                                    if (v36 % 2 == 1) {
                                        // 0x80529a4
                                        if (2 * v36 < 1 << width2 % 32) {
                                            // 0x80529b8
                                            puts("Odd denominator, trying to expand by 2.");
                                            v25 = 2 * q;
                                            q = v25;
                                            v37 = v25;
                                            // branch -> 0x80529cc
                                        } else {
                                            v37 = v36;
                                        }
                                    }
                                    // 0x80529cc
                                    if (v37 % 2 == 1) {
                                        // 0x80529e6
                                        puts("Odd period, try again.");
                                        // branch -> 0x8052b22
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x80529fe
                                        printf("Possible period is %i.\n", v37);
                                        v38 = q;
                                        v27 = quantum_ipow(x, ((int32_t)(v38 < 0) + v38) / 2);
                                        a = (int32_t)(1 % (int64_t)N) + v27;
                                        v39 = q;
                                        v28 = quantum_ipow(x, ((int32_t)(v39 < 0) + v39) / 2);
                                        v40 = N;
                                        b = v28 - (int32_t)(1 % (int64_t)v40);
                                        a = quantum_gcd(v40, a);
                                        v29 = quantum_gcd(N, b);
                                        b = v29;
                                        v41 = a;
                                        v30 = v41 > v29 ? v41 : v29;
                                        v42 = N;
                                        if (v30 >= v42 || v30 < 2) {
                                            // 0x8052b0f
                                            puts("Unable to determine factors, try again.");
                                            // branch -> 0x8052b22
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x8052ac6
                                            printf("%i = %i * %i\n", v42, v30, (int32_t)((0x100000000 * (int64_t)(v42 >> 31) | (int64_t)v42) / (int64_t)v30));
                                            quantum_delete_qureg((struct quantum_reg_struct_11 *)&v2);
                                            // branch -> 0x8052b22
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x805281f
                        quantum_qft(width2, (struct quantum_reg_struct_9 *)&v2);
                        i = 0;
                        v35 = width2;
                        if ((int32_t)(v35 < 0) + v35 > 1) {
                            v31 = 0;
                            quantum_cnot(v31, v35 - v31 - 1, (struct quantum_reg_struct_3 *)&v2);
                            v32 = i;
                            quantum_cnot(width2 - v32 - 1, v32, (struct quantum_reg_struct_3 *)&v2);
                            v33 = i;
                            quantum_cnot(v33, width2 - v33 - 1, (struct quantum_reg_struct_3 *)&v2);
                            v24 = i + 1;
                            i = v24;
                            v34 = width2;
                            while (((int32_t)(v34 < 0) + v34) / 2 > v24) {
                                // 0x805283a
                                v31 = v24;
                                quantum_cnot(v31, v34 - v31 - 1, (struct quantum_reg_struct_3 *)&v2);
                                v32 = i;
                                quantum_cnot(width2 - v32 - 1, v32, (struct quantum_reg_struct_3 *)&v2);
                                v33 = i;
                                quantum_cnot(v33, width2 - v33 - 1, (struct quantum_reg_struct_3 *)&v2);
                                v24 = i + 1;
                                i = v24;
                                v34 = width2;
                                // continue -> 0x805283a
                            }
                            // 0x80528b2
                            v1 = (struct quantum_reg_struct_4){
                                .e0 = 0,
                                .e1 = 0,
                                .e2 = 0,
                                .e3 = NULL,
                                .e4 = NULL
                            };
                            v1.e0 = v2.e0;
                            v26 = quantum_measure(v1);
                            c = v26;
                            if (v26 == -1) {
                                // 0x80528e4
                                puts("Impossible Measurement!");
                                // branch -> 0x8052b22
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x80528fc
                                if (v26 == 0) {
                                    // 0x8052903
                                    puts("Measured zero, try again.");
                                    // branch -> 0x8052b22
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x805291b
                                    q = 1 << width2 % 32;
                                    printf("Measured %i (%f), ", (int32_t)"Measured %i (%f), ", (float64_t)(int64_t)v26);
                                    quantum_frac_approx(&c, &q, width2);
                                    printf("fractional approximation is %i/%i.\n", c, q);
                                    v36 = q;
                                    v37 = v36;
                                    if (v36 % 2 == 1) {
                                        // 0x80529a4
                                        if (2 * v36 < 1 << width2 % 32) {
                                            // 0x80529b8
                                            puts("Odd denominator, trying to expand by 2.");
                                            v25 = 2 * q;
                                            q = v25;
                                            v37 = v25;
                                            // branch -> 0x80529cc
                                        } else {
                                            v37 = v36;
                                        }
                                    }
                                    // 0x80529cc
                                    if (v37 % 2 == 1) {
                                        // 0x80529e6
                                        puts("Odd period, try again.");
                                        // branch -> 0x8052b22
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x80529fe
                                        printf("Possible period is %i.\n", v37);
                                        v38 = q;
                                        v27 = quantum_ipow(x, ((int32_t)(v38 < 0) + v38) / 2);
                                        a = (int32_t)(1 % (int64_t)N) + v27;
                                        v39 = q;
                                        v28 = quantum_ipow(x, ((int32_t)(v39 < 0) + v39) / 2);
                                        v40 = N;
                                        b = v28 - (int32_t)(1 % (int64_t)v40);
                                        a = quantum_gcd(v40, a);
                                        v29 = quantum_gcd(N, b);
                                        b = v29;
                                        v41 = a;
                                        v30 = v41 > v29 ? v41 : v29;
                                        v42 = N;
                                        if (v30 >= v42 || v30 < 2) {
                                            // 0x8052b0f
                                            puts("Unable to determine factors, try again.");
                                            // branch -> 0x8052b22
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x8052ac6
                                            printf("%i = %i * %i\n", v42, v30, (int32_t)((0x100000000 * (int64_t)(v42 >> 31) | (int64_t)v42) / (int64_t)v30));
                                            quantum_delete_qureg((struct quantum_reg_struct_11 *)&v2);
                                            // branch -> 0x8052b22
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x80528b2
                        v1 = (struct quantum_reg_struct_4){
                            .e0 = 0,
                            .e1 = 0,
                            .e2 = 0,
                            .e3 = NULL,
                            .e4 = NULL
                        };
                        v1.e0 = v2.e0;
                        v26 = quantum_measure(v1);
                        c = v26;
                        if (v26 == -1) {
                            // 0x80528e4
                            puts("Impossible Measurement!");
                            // branch -> 0x8052b22
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x80528fc
                            if (v26 == 0) {
                                // 0x8052903
                                puts("Measured zero, try again.");
                                // branch -> 0x8052b22
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x805291b
                                q = 1 << width2 % 32;
                                printf("Measured %i (%f), ", (int32_t)"Measured %i (%f), ", (float64_t)(int64_t)v26);
                                quantum_frac_approx(&c, &q, width2);
                                printf("fractional approximation is %i/%i.\n", c, q);
                                v36 = q;
                                v37 = v36;
                                if (v36 % 2 == 1) {
                                    // 0x80529a4
                                    if (2 * v36 < 1 << width2 % 32) {
                                        // 0x80529b8
                                        puts("Odd denominator, trying to expand by 2.");
                                        v25 = 2 * q;
                                        q = v25;
                                        v37 = v25;
                                        // branch -> 0x80529cc
                                    } else {
                                        v37 = v36;
                                    }
                                }
                                // 0x80529cc
                                if (v37 % 2 == 1) {
                                    // 0x80529e6
                                    puts("Odd period, try again.");
                                    // branch -> 0x8052b22
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x80529fe
                                    printf("Possible period is %i.\n", v37);
                                    v38 = q;
                                    v27 = quantum_ipow(x, ((int32_t)(v38 < 0) + v38) / 2);
                                    a = (int32_t)(1 % (int64_t)N) + v27;
                                    v39 = q;
                                    v28 = quantum_ipow(x, ((int32_t)(v39 < 0) + v39) / 2);
                                    v40 = N;
                                    b = v28 - (int32_t)(1 % (int64_t)v40);
                                    a = quantum_gcd(v40, a);
                                    v29 = quantum_gcd(N, b);
                                    b = v29;
                                    v41 = a;
                                    v30 = v41 > v29 ? v41 : v29;
                                    v42 = N;
                                    if (v30 >= v42 || v30 < 2) {
                                        // 0x8052b0f
                                        puts("Unable to determine factors, try again.");
                                        // branch -> 0x8052b22
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x8052ac6
                                        printf("%i = %i * %i\n", v42, v30, (int32_t)((0x100000000 * (int64_t)(v42 >> 31) | (int64_t)v42) / (int64_t)v30));
                                        quantum_delete_qureg((struct quantum_reg_struct_11 *)&v2);
                                        // branch -> 0x8052b22
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                int32_t v44 = rand(); // 0x8052700
                int32_t v45 = (0x100000000 * (int64_t)(v44 >> 31) | (int64_t)v44) % (int64_t)N; // 0x805270c
                x = v45;
                v15 = v45;
                // branch -> 0x8052712
            }
        } else {
            // 0x8052682
            puts("Invalid number\n");
            // branch -> 0x8052b22
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// --------------- Statically Linked Functions ----------------

// float __divsc3(float a, float b, float c, float d);
// double __muldc3(double a, double b, double c, double d);
// float __mulsc3(float a, float b, float c, float d);
// int atexit(void(* func)(void));

// --------------- Dynamically Linked Functions ---------------

// void __stack_chk_fail(void);
// void abort(void);
// int atoi(const char * nptr);
// void * calloc(size_t nmemb, size_t size);
// double cos(double);
// int fflush(FILE * stream);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// void free(void * ptr);
// char * getenv(const char * name);
// void * malloc(size_t size);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// int rand(void);
// void * realloc(void * ptr, size_t size);
// double sin(double);
// double sqrt(double);
// void srand(unsigned int seed);
// time_t time(time_t * timer);

// --------------- Instruction-Idiom Functions ----------------

// long double fabsl(long double);
// long double sqrtl(long double);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.3.3)
// Detected language: C
// Detected functions: 80
// Decompiler release: VERSION
// Decompilation date: DATE
