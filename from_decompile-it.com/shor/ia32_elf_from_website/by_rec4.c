// Generated by Rec Studio 4 - build Apr 15 2012

_init()
{// addr = 0x080487E4
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0xd7fc)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    return;
}

L080487F0()
{
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0xd7fc)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

void abort()
{// addr = 0x08048824
    goto __imp__abort;
}

void srand(int __seed)
{// addr = 0x08048834
    goto __imp__srand;
}

__cxa_atexit()
{// addr = 0x08048844
    goto __imp____cxa_atexit;
}

__gmon_start__()
{// addr = 0x08048854
    goto __imp____gmon_start__;
}

void* realloc(void* __ptr, int __size)
{// addr = 0x08048864
    goto __imp__realloc;
}

char* getenv(char* __name)
{// addr = 0x08048874
    goto __imp__getenv;
}

void* calloc(int __nmemb, int __size)
{// addr = 0x08048884
    goto __imp__calloc;
}

int putchar(int ch)
{// addr = 0x08048894
    goto __imp__putchar;
}

pow()
{// addr = 0x080488A4
    goto __imp__pow;
}

__libc_start_main()
{// addr = 0x080488B4
    goto __imp____libc_start_main;
}

void perror(char* msg)
{// addr = 0x080488C4
    goto __imp__perror;
}

void free(void* __ptr)
{// addr = 0x080488D4
    goto __imp__free;
}

int fflush(struct _IO_FILE* fp)
{// addr = 0x080488E4
    goto __imp__fflush;
}

sqrt()
{// addr = 0x080488F4
    goto __imp__sqrt;
}

int fclose(struct _IO_FILE* fp)
{// addr = 0x08048904
    goto __imp__fclose;
}

void* memcpy(void* __dest, void* __src, int __n)
{// addr = 0x08048914
    goto __imp__memcpy;
}

struct _IO_FILE* fopen(char* name, char* mode)
{// addr = 0x08048924
    goto __imp__fopen;
}

cos()
{// addr = 0x08048934
    goto __imp__cos;
}

int fgetc(struct _IO_FILE* fp)
{// addr = 0x08048944
    goto __imp__fgetc;
}

int feof(struct _IO_FILE* fp)
{// addr = 0x08048954
    goto __imp__feof;
}

int printf(char* format)
{// addr = 0x08048964
    goto __imp__printf;
}

int atoi(char* __nptr)
{// addr = 0x08048974
    goto __imp__atoi;
}

int fwrite(void* src, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x08048984
    goto __imp__fwrite;
}

int fprintf(struct _IO_FILE* fp, char* format)
{// addr = 0x08048994
    goto __imp__fprintf;
}

time()
{// addr = 0x080489A4
    goto __imp__time;
}

void* malloc(int __size)
{// addr = 0x080489B4
    goto __imp__malloc;
}

__stack_chk_fail()
{// addr = 0x080489C4
    goto __imp____stack_chk_fail;
}

log()
{// addr = 0x080489D4
    goto __imp__log;
}

int puts(char* str)
{// addr = 0x080489E4
    goto __imp__puts;
}

int rand()
{// addr = 0x080489F4
    goto __imp__rand;
}

int fread(_G_va_list dst, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x08048A04
    goto __imp__fread;
}

sin()
{// addr = 0x08048A14
    goto __imp__sin;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x08048A30
    _unknown_ __ebx;                       // r1
    signed int _t10;                       // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    _t6 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & 240;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(_t11);
    _push(main);
    __libc_start_main();
    asm("hlt ");
    0;
    0;
    _push(0);
    _push(__ebx);
    __esp = __esp - 4;
    if(completed.6635 == 0) {
        _t10 = dtor_idx.6637;
        _t6 =  &__DTOR_END__ -  &__DTOR_LIST__ >> 2;
        __ebx = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t10 < __ebx) {
            while(1) {
                _t6 = _t10 + 1;
                dtor_idx.6637 = _t6;
                 *((intOrPtr*)(_t6 * 4 +  &__DTOR_LIST__))();
                _t10 = dtor_idx.6637;
                if(_t10 >= __ebx) {
                    break;
                }
            }
        }
        completed.6635 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
    return;
}

__do_global_dtors_aux(
    _unknown_ __esi                        // r5
)
{// addr = 0x08048A60
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    if(completed.6635 == 0) {
        __edx = dtor_idx.6637;
        _t9 =  &__DTOR_END__ -  &__DTOR_LIST__ >> 2;
        __ebx = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(__edx >= __ebx) {
L4:
            completed.6635 = 1;
            return;
        }
        while(1) {
            _t9 = __edx + 1;
            dtor_idx.6637 = _t9;
             *((intOrPtr*)(_t9 * 4 +  &__DTOR_LIST__))();
            __edx = dtor_idx.6637;
            if(__edx >= __ebx) {
                break;
            }
        }
        goto L4;
    }
    return;
}

frame_dummy()
{// addr = 0x08048AC0
    _unknown_ __ebp;                       // r6

    __eax = __JCR_LIST__;
    if(__JCR_LIST__ != 0) {
        __eax = 0;
        if(__eax == 0) {
        } else {
             *__esp =  &__JCR_LIST__;
             *__eax();
            return;
        }
    }
    return;
}

int quantum_ipow(int a, int b)
{// addr = 0x08048AE4  --  defined in 'classic.c' at line 30
    int i;                                 // _cfa_fffffff8
    int r;                                 // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    r = 1;
    i = 0;
    while(i < b) {
        r = r * a;
        i = i + 1;
    }
    return r;
}

int quantum_gcd(int u, int v)
{// addr = 0x08048B15  --  defined in 'classic.c' at line 44
    int r;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t21;                        // _t21

    while(v != 0) {
        r = u % v;
        u = v;
        v = r;
    }
    return u;
}

quantum_frac_approx(int* a, int* b, int width)
{// addr = 0x08048B42  --  defined in 'classic.c' at line 60
    float f;                               // _cfa_fffffff8
    float g;                               // _cfa_fffffff4
    int i;                                 // _cfa_fffffff0
    int num2;                              // _cfa_ffffffec
    int den2;                              // _cfa_ffffffe8
    int num1;                              // _cfa_ffffffe4
    int den1;                              // _cfa_ffffffe0
    int num;                               // _cfa_ffffffdc
    int den;                               // _cfa_ffffffd8
    signed short _v58;                     // _cfa_ffffffc6
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ __ebp;                       // r6
    _unknown_ _t57;                        // _t57
    _unknown_ _t71;                        // _t71

    _push( *a);
    asm("fild dword [esp]");
    _push( *b);
    asm("fild dword [esp]");
    asm("fdivp st1, st0");
    asm("fstp dword [ebp-0x4]");
    g = f;
    num2 = 0;
    den2 = 1;
    num1 = 1;
    den1 = 0;
    num = 0;
    den = 0;
    asm("fnstcw word [ebp-0x36]");
    _v60 = _v58 & 0xffff;
    while(1) {
        asm("fld dword [ebp-0x8]");
        asm("fld qword [0x8054278]");
        asm("faddp st1, st0");
        asm("fldcw word [ebp-0x38]");
        asm("fistp dword [ebp-0xc]");
        asm("fldcw word [ebp-0x36]");
        asm("fld dword [ebp-0x8]");
        asm("fild dword [ebp-0xc]");
        asm("fld qword [0x8054278]");
        asm("fsubp st1, st0");
        asm("fsubp st1, st0");
        asm("fstp dword [ebp-0x8]");
        asm("fld1 ");
        asm("fdiv dword [ebp-0x8]");
        asm("fstp dword [ebp-0x8]");
        __eflags = i * den1 + den2 - 1 << (width & 255);
        if(__eflags > 0) {
            break;
        }
        num = i * num1 + num2;
        den = i * den1 + den2;
        num2 = num1;
        den2 = den1;
        num1 = num;
        den1 = den;
        asm("fild dword [ebp-0x20]");
        asm("fild dword [ebp-0x24]");
        asm("fdivp st1, st0");
        asm("fld dword [ebp-0x4]");
        asm("fsubp st1, st0");
        asm("fabs ");
        _push(2 << (width & 255));
        asm("fild dword [esp]");
        asm("fld1 ");
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags > 0) {
            continue;
        }
        break;
    }
     *a = num;
     *b = den;
    return;
}

int quantum_getwidth(int n)
{// addr = 0x08048C63  --  defined in 'classic.c' at line 95
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9

    i = 1;
    while(1 << (i & 255) < n) {
        i = i + 1;
    }
    return i;
}

int quantum_inverse_mod(int n, int c)
{// addr = 0x08048C8A  --  defined in 'classic.c' at line 107
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    _unknown_ _t20;                        // _t20

    i = 1;
    while(i * c % n != 1) {
        i = i + 1;
    }
    return i;
}

complex float quantum_conj(complex float a)
{// addr = 0x08048CBC  --  defined in 'complex.c' at line 33
    float r;                               // _cfa_ffffffec
    float i;                               // _cfa_ffffffe8
    complex float _v36;                    // _cfa_ffffffdc
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    complex float _v56;                    // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    complex float _t26;                    // _t26
    _unknown_ _t30;                        // _t30
    _unknown_ _t35;                        // _t35
    _unknown_ _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    _unknown_ _t39;                        // _t39
    _unknown_ _t40;                        // _t40
    float _t41;                            // _t41

     *__esp = a;
    _v56 = _a8;
    quantum_real();
    asm("fstp dword [ebp-0x10]");
     *__esp = a;
    _v56 = _a8;
    quantum_imag();
    asm("fstp dword [ebp-0x14]");
    _t41 = r;
    _v48 = -1082130432;
    _v52 = -2147483648;
    _v56 = 0;
     *__esp = i;
    _t26 = __mulsc3(i, _t41, __eflags);
    _v36 = _t41;
    asm("fld dword [ebp-0x20]");
    _v36 = 0;
    asm("fld dword [ebp-0x20]");
    _v36 = _t26;
    asm("fld dword [ebp-0x20]");
    _v36 = 0;
    asm("fld dword [ebp-0x20]");
    asm("fxch st0, st1");
    asm("faddp st3, st0");
    asm("faddp st1, st0");
    asm("fxch st0, st1");
    asm("fstp dword [ebp-0x20]");
    asm("fstp dword [ebp-0x20]");
    return _v36;
}

float quantum_real(complex float a)
{// addr = 0x08048D63  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t7;                             // _t7

    p =  &a;
    _t7 =  *p;
    _v24 = _t7;
    asm("fld dword [ebp-0x14]");
    return _t7;
}

float quantum_imag(complex float a)
{// addr = 0x08048D7C  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t8;                             // _t8

    p =  &a;
    _t8 = p[1];
    _v24 = _t8;
    asm("fld dword [ebp-0x14]");
    return _t8;
}

float quantum_prob(complex float a)
{// addr = 0x08048D98  --  defined in 'complex.c' at line 46
    float _v8;                             // _cfa_fffffff8
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t8;                             // _t8

     *__esp = a;
    _v24 = _a8;
    quantum_prob_inline();
    asm("fstp dword [ebp-0x4]");
    _t8 = _v8;
    _v8 = _t8;
    asm("fld dword [ebp-0x4]");
    return _t8;
}

float quantum_prob_inline(complex float a)
{// addr = 0x08048DBE  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t10;                            // _t10

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    asm("fstp dword [ebp-0x4]");
     *__esp = a;
    _t10 = _a8;
    _v24 = _t10;
    quantum_imag();
    asm("fstp dword [ebp-0x8]");
    asm("fld dword [ebp-0x4]");
    asm("fmul dword [ebp-0x4]");
    asm("fld dword [ebp-0x8]");
    asm("fmul dword [ebp-0x8]");
    asm("faddp st1, st0");
    return _t10;
}

complex float quantum_cexp(float phi)
{// addr = 0x08048DFE  --  defined in 'complex.c' at line 53
    _unknown_ _v8;                         // _cfa_fffffff8
    char _v28;                             // _cfa_ffffffe4
    complex float _v56;                    // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    _unknown_ _t11;                        // _t11
    _unknown_ _t13;                        // _t13

    _push(__ebx);
    __esp = __esp - 100;
    asm("fld dword [ebp+0x8]");
    asm("fstp qword [esp]");
    cos();
    asm("fstp qword [ebp-0x28]");
    asm("fldz ");
    asm("fstp qword [ebp-0x30]");
    asm("fld dword [ebp+0x8]");
    asm("fstp qword [esp]");
    sin();
    asm("fldz ");
    asm("fld1 ");
    asm("fstp qword [esp+0x1c]");
    asm("fldz ");
    asm("fstp qword [esp+0x14]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    __muldc3(__esi, __eflags,  &_v28);
    asm("fld qword [ebp-0x18]");
    asm("fld qword [ebp-0x10]");
    asm("fld qword [ebp-0x28]");
    asm("fld qword [ebp-0x30]");
    asm("fxch st0, st3");
    asm("faddp st1, st0");
    asm("fxch st0, st1");
    asm("faddp st2, st0");
    asm("fstp dword [ebp-0x1c]");
    asm("fld dword [ebp-0x1c]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp-0x1c]");
    asm("fld dword [ebp-0x1c]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp-0x34]");
    asm("fstp dword [ebp-0x34]");
    return _v56;
}

float quantum_get_decoherence()
{// addr = 0x08048E84  --  defined in 'decoherence.c' at line 46
    float _v8;                             // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    __eax = quantum_lambda;
    _v8 = __eax;
    asm("fld dword [ebp-0x4]");
    return __eax;
}

quantum_set_decoherence(float l)
{// addr = 0x08048E97  --  defined in 'decoherence.c' at line 55
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    __eflags = __eflags;
    asm("fld dword [ebp+0x8]");
    asm("fldz ");
    asm("fxch st0, st1");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags != 0 || __eflags != 0) {
        quantum_status = 1;
        quantum_lambda = l;
        return;
    }
    quantum_status = 0;
    return;
}

quantum_decohere(quantum_reg* reg)
{// addr = 0x08048ECA  --  defined in 'decoherence.c' at line 71
    float u;                               // _cfa_ffffffe8
    float v;                               // _cfa_ffffffe4
    float s;                               // _cfa_ffffffe0
    float x;                               // _cfa_ffffffdc
    float* nrands;                         // _cfa_ffffffd8
    float angle;                           // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffd0
    int j;                                 // _cfa_ffffffcc
    intOrPtr _v60;                         // _cfa_ffffffc4
    quantum_reg_node* _v112;   // _cfa_ffffff90
    complex float _v116;                   // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t60;                        // _t60
    _unknown_ _t61;                        // _t61
    _unknown_ _t69;                        // _t69
    _unknown_ _t74;                        // _t74
    _unknown_ _t77;                        // _t77
    _unknown_ _t83;                        // _t83
    signed int _t84;                       // _t84
    signed int _t85;                       // _t85
    _unknown_ _t88;                        // _t88
    _unknown_ _t91;                        // _t91
    _unknown_ _t106;                       // _t106
    _unknown_ _t111;                       // _t111
    signed int _t115;                      // _t115
    _unknown_ _t119;                       // _t119
    signed int _t122;                      // _t122
    quantum_reg_node* _t124;   // _t124
    complex float _t126;                   // _t126
    _unknown_ _t128;                       // _t128

    quantum_gate_counter(1);
    if(quantum_status == 0) {
        return;
    }
    nrands = calloc(reg->width, 4);
    if(nrands == 0) {
        quantum_error(2);
    }
    quantum_memman(reg->width << 2);
    i = 0;
    while(reg->width > i) {
        while(1) {
            quantum_frand();
            asm("fld st0, st0");
            asm("faddp st1, st0");
            asm("fld1 ");
            asm("fsubp st1, st0");
            asm("fstp dword [ebp-0x14]");
            quantum_frand();
            asm("fld st0, st0");
            asm("faddp st1, st0");
            asm("fld1 ");
            asm("fsubp st1, st0");
            asm("fstp dword [ebp-0x18]");
            asm("fld dword [ebp-0x14]");
            asm("fmul dword [ebp-0x14]");
            asm("fld dword [ebp-0x18]");
            asm("fmul dword [ebp-0x18]");
            asm("faddp st1, st0");
            asm("fstp dword [ebp-0x1c]");
            asm("fld dword [ebp-0x1c]");
            asm("fld1 ");
            asm("fxch st0, st1");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags < 0) {
                break;
            }
        }
        asm("fld dword [ebp-0x14]");
        asm("fstp qword [ebp-0x50]");
        asm("fld dword [ebp-0x1c]");
        asm("fstp qword [esp]");
        log();
        asm("fld qword [0x8054280]");
        asm("fmulp st1, st0");
        asm("fld dword [ebp-0x1c]");
        asm("fdivp st1, st0");
        asm("fstp qword [ebp-0x48]");
        asm("fld qword [ebp-0x48]");
        asm("fsqrt ");
        asm("fstp qword [ebp-0x60]");
        asm("fld qword [ebp-0x60]");
        asm("fucomp st0");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags != 0 || __eflags != 0) {
            asm("fld qword [ebp-0x48]");
            asm("fstp qword [esp]");
            sqrt();
            asm("fstp qword [ebp-0x60]");
        }
        asm("fld qword [ebp-0x60]");
        asm("fmul qword [ebp-0x50]");
        asm("fstp dword [ebp-0x20]");
        asm("fld dword [ebp-0x20]");
        asm("fstp qword [ebp-0x40]");
        asm("fld dword [0x80560d0]");
        asm("fadd st0, st0");
        asm("fstp qword [esp]");
        sqrt();
        asm("fmul qword [ebp-0x40]");
        asm("fstp dword [ebp-0x20]");
        asm("fld dword [ebp-0x20]");
        asm("fld dword [0x8054288]");
        asm("fdivp st1, st0");
        asm("fstp dword [eax]");
        i = i + 1;
    }
    i = 0;
    while(reg->size > i) {
        angle = 0;
        j = 0;
        while(1) {
            __eflags = reg->width - j;
            if(__eflags <= 0) {
                break;
            }
            _t83 = reg->node + (i << 4);
            _t84 =  *(_t83 + 8);
            _t115 = j;
            asm("shrd eax, edx, cl");
            _t122 =  *(_t83 + 12) >> (_t115 & 255);
            __eflags = _t115 & 0x20;
            if((_t115 & 0x20) != 0) {
                _t84 = _t122;
            }
            _t85 = _t84 & 1;
            __eflags = _t85 & 255;
            if((_t85 & 255) == 0) {
                asm("fld dword [eax]");
                asm("fld dword [ebp-0x28]");
                asm("fsubrp st1, st0");
                asm("fstp dword [ebp-0x28]");
            } else {
                asm("fld dword [eax]");
                asm("fld dword [ebp-0x28]");
                asm("faddp st1, st0");
                asm("fstp dword [ebp-0x28]");
            }
            j = j + 1;
        }
        __edi = reg->node + (i << 4);
        _t124 = reg->node;
        __esi =  *((intOrPtr*)(_t124 + (i << 4)));
        asm("fld dword [eax+0x4]");
        asm("fstp dword [ebp-0x38]");
        _t126 = quantum_cexp(angle);
        _v112 = _t124;
        _v116 = _t126;
        _v120 = _v60;
         *__esp = __esi;
         *__edi = __mulsc3(_t124, __esi, __eflags);
         *(__edi + 4) = _t126;
        i = i + 1;
    }
    free(nrands);
    quantum_memman( ~(reg->width << 2));
    return;
}

quantum_density_op quantum_new_density_op(int num, float* prob, quantum_reg* reg)
{// addr = 0x0804911C  --  defined in 'density.c' at line 38
    int i;                                 // _cfa_fffffff8
    int* phash;                            // _cfa_fffffff4
    int hashw;                             // _cfa_fffffff0
    void* _v20;           // _cfa_ffffffec
    void* _v24;           // _cfa_ffffffe8
    quantum_density_op rho;   // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t99;                        // _t99
    void* _t169;          // _t169
    void* _t171;          // _t171
    quantum_reg* _t176;   // _t176
    void* _t182;          // _t182

    rho.num = num;
    _v24 = calloc(num, 4);
    if(_v24 == 0) {
        quantum_error(2);
    }
    _v20 = calloc(num, 20);
    if(_v20 == 0) {
        quantum_error(2);
    }
    quantum_memman(num + num + num << 3);
     *_v24 =  *prob;
    phash = reg->hash;
    hashw = reg->hashw;
    _t169 = _v20;
    _t176 = reg;
     *_t169 = _t176->width;
    _t169[1] = _t176->size;
    _t169[2] = _t176->hashw;
    _t169[3] = _t176->node;
    _t169[4] = _t176->hash;
    reg->size = 0;
    reg->width = 0;
    reg->node = 0;
    reg->hash = 0;
    i = 1;
    while(i < num) {
        _v24[i] = prob[i];
        _t171 =  &(_v20[(i << 2) + i]);
        _t182 = reg + ((i << 2) + i << 2);
         *_t171 =  *_t182;
        _t171[1] = _t182[1];
        _t171[2] = _t182[2];
        _t171[3] = _t182[3];
        _t171[4] = _t182[4];
        ( &(_v20[(i << 2) + i]))[4] = phash;
        ( &(_v20[(i << 2) + i]))[2] = hashw;
        (reg + ((i << 2) + i << 2))[1] = 0;
         *(reg + ((i << 2) + i << 2)) = 0;
        (reg + ((i << 2) + i << 2))[3] = 0;
        (reg + ((i << 2) + i << 2))[4] = 0;
        i = i + 1;
    }
     *(_a4.num) = rho.num;
     *(_a4.num + 4) = _v24;
     *(_a4.num + 8) = _v20;
    return _a4;
}

quantum_density_op quantum_qureg2density_op(quantum_reg* reg)
{// addr = 0x08049315  --  defined in 'density.c' at line 93
    _unknown_ _v8;                         // _cfa_fffffff8
    float f;                               // _cfa_fffffff4
    quantum_reg* _v32;   // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    struct quantum_density_op_struct _t14;   // _t14
    _unknown_ _t15;                        // _t15

    _push(__ebx);
    __esp = __esp - 36;
    _t14 = _a4;
    f = 1065353216;
    _v32 = reg;
    quantum_new_density_op(_t14, 1,  &f);
    __esp = __esp - 4;
    return _t14;
}

quantum_reduced_density_op(int pos, quantum_density_op* rho)
{// addr = 0x08049351  --  defined in 'density.c' at line 105
    double p0;                             // _cfa_ffffffe4
    double ptmp;                           // _cfa_ffffffdc
    _unknown_ _v8;                         // _cfa_fffffff8
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    long long unsigned int _v40;           // _cfa_ffffffd8
    long long unsigned int pos2;           // _cfa_ffffffd4
    float _v48;                            // _cfa_ffffffd0
    float _v52;                            // _cfa_ffffffcc
    float _v56;                            // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    quantum_reg rtmp;   // _cfa_ffffffc0
    float _v108;                           // _cfa_ffffff94
    float _v112;                           // _cfa_ffffff90
    float _v116;                           // _cfa_ffffff8c
    float _v120;                           // _cfa_ffffff88
    float _v124;                           // _cfa_ffffff84
    float _v128;                           // _cfa_ffffff80
    float _v132;                           // _cfa_ffffff7c
    float _v136;                           // _cfa_ffffff78
    int _v140;                             // _cfa_ffffff74
    int _v144;                             // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    int _v152;                             // _cfa_ffffff68
    int _v156;                             // _cfa_ffffff64
    _unknown_ __ebp;                       // r6
    _unknown_ _t172;                       // _t172
    _unknown_ _t173;                       // _t173
    long long unsigned int _t174;          // _t174
    _unknown_ _t177;                       // _t177
    _unknown_ _t179;                       // _t179
    _unknown_ _t180;                       // _t180
    _unknown_ _t220;                       // _t220
    _unknown_ _t222;                       // _t222
    _unknown_ _t223;                       // _t223
    _unknown_ _t224;                       // _t224
    _unknown_ _t228;                       // _t228
    _unknown_ _t229;                       // _t229
    float* _t271;                          // _t271
    float* _t272;                          // _t272
    _unknown_ _t273;                       // _t273
    signed int _t274;                      // _t274
    long long unsigned int _t288;          // _t288
    _unknown_ _t289;                       // _t289
    float* _t291;                          // _t291
    char** _t299;                          // _t299
    _unknown_ _t300;                       // _t300
    _unknown_ _t301;                       // _t301

    _push(__ebx);
    __esp = __esp - 148;
    asm("fldz ");
    asm("fstp qword [ebp-0x18]");
    rho->prob = realloc(rho->prob, rho->num << 3);
    if(rho->prob == 0) {
        quantum_error(2);
    }
    rho->reg = realloc(rho->reg,  &(rho->num[rho->num]) << 3);
    if(rho->reg == 0) {
        quantum_error(2);
    }
    quantum_memman(rho->num + rho->num + rho->num << 3);
    _t274 = pos;
    _t288 = 0;
    asm("shld edx, eax, cl");
    _t174 = 1 << (_t274 & 255);
    if((_t274 & 0x20) != 0) {
        _t288 = _t174;
        _t174 = 0;
    }
    pos2 = _t174;
    _v40 = _t288;
    i = 0;
    while(rho->num > i) {
        asm("fld dword [eax]");
        asm("fstp qword [ebp-0x20]");
        _t291 =  &(rho->reg[(i << 2) + i]);
        rtmp.width =  *_t291;
        _v60 = _t291[1];
        _v56 = _t291[2];
        _v52 = _t291[3];
        _v48 = _t291[4];
        asm("fldz ");
        asm("fstp qword [ebp-0x18]");
        j = 0;
        while(( &(rho->reg[(i << 2) + i]))[1] > j) {
            if(((( &(rho->reg[(i << 2) + i]))[3] + (j << 4))[2] & pos2 | (( &(rho->reg[(i << 2) + i]))[3] + (j << 4))[3] & _v40) == 0) {
                _t299 = ( &(rho->reg[(i << 2) + i]))[3] + (j << 4);
                 *__esp =  *_t299;
                _v152 = _t299[1];
                quantum_prob_inline();
                asm("fld qword [ebp-0x18]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x18]");
            }
            j = j + 1;
        }
        asm("fld qword [ebp-0x20]");
        asm("fmul qword [ebp-0x18]");
        asm("fstp dword [ebp-0x4c]");
        asm("fld dword [ebp-0x4c]");
        asm("fstp dword [eax]");
        asm("fld1 ");
        asm("fsub qword [ebp-0x18]");
        asm("fmul qword [ebp-0x20]");
        asm("fstp dword [ebp-0x4c]");
        asm("fld dword [ebp-0x4c]");
        asm("fstp dword [eax]");
        _t271 =  &(rho->reg[(i << 2) + i]);
        _v144 = rtmp.width;
        _v140 = _v60;
        _v136 = _v56;
        _v132 = _v52;
        _v128 = _v48;
        _v148 = 0;
        _v152 = pos;
         *__esp =  &_v124;
        quantum_state_collapse();
        __esp = __esp - 4;
         *_t271 = _v124;
        _t271[1] = _v120;
        _t271[2] = _v116;
        _t271[3] = _v112;
        _t271[4] = _v108;
        _t272 =  &(rho->reg[(rho->num + i << 2) + rho->num + i]);
        _v148 = rtmp.width;
        _v144 = _v60;
        _v140 = _v56;
        _v136 = _v52;
        _v132 = _v48;
        _v152 = 1;
        _v156 = pos;
         *__esp =  &_v124;
        quantum_state_collapse();
        __esp = __esp - 4;
         *_t272 = _v124;
        _t272[1] = _v120;
        _t272[2] = _v116;
        _t272[3] = _v112;
        _t272[4] = _v108;
        quantum_delete_qureg_hashpreserve( &(rtmp.width));
        i = i + 1;
    }
    rho->num = rho->num + rho->num;
    return;
}

float quantum_prob_inline(complex float a)
{// addr = 0x0804966A  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t10;                            // _t10

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    asm("fstp dword [ebp-0x4]");
     *__esp = a;
    _t10 = _a8;
    _v24 = _t10;
    quantum_imag();
    asm("fstp dword [ebp-0x8]");
    asm("fld dword [ebp-0x4]");
    asm("fmul dword [ebp-0x4]");
    asm("fld dword [ebp-0x8]");
    asm("fmul dword [ebp-0x8]");
    asm("faddp st1, st0");
    return _t10;
}

float quantum_real(complex float a)
{// addr = 0x080496AA  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t7;                             // _t7

    p =  &a;
    _t7 =  *p;
    _v24 = _t7;
    asm("fld dword [ebp-0x14]");
    return _t7;
}

float quantum_imag(complex float a)
{// addr = 0x080496C3  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t8;                             // _t8

    p =  &a;
    _t8 = p[1];
    _v24 = _t8;
    asm("fld dword [ebp-0x14]");
    return _t8;
}

quantum_matrix quantum_density_matrix(quantum_density_op* rho)
{// addr = 0x080496DF  --  defined in 'density.c' at line 157
    char _v16;                             // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int l1;                                // _cfa_ffffffe0
    int l2;                                // _cfa_ffffffdc
    int dim;                               // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    quantum_matrix m;   // _cfa_ffffffcc
    signed int _v68;                       // _cfa_ffffffbc
    complex float _v80;                    // _cfa_ffffffb0
    complex float _v88;                    // _cfa_ffffffa8
    complex float _v92;                    // _cfa_ffffffa4
    complex float _v96;                    // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c
    complex float _v104;                   // _cfa_ffffff98
    signed int _v108;                      // _cfa_ffffff94
    _unknown_ __ebx;                       // r1
    complex float* __edi;                  // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t118;                       // _t118
    _unknown_ _t121;                       // _t121
    signed int _t139;                      // _t139
    signed int _t151;                      // _t151
    _unknown_ _t165;                       // _t165
    _unknown_ _t166;                       // _t166
    signed int* _t180;                     // _t180
    float _t182;                           // _t182
    complex float _t197;                   // _t197
    _unknown_ _t220;                       // _t220
    _unknown_ _t226;                       // _t226
    complex float* _t231;                  // _t231
    complex float* _t233;                  // _t233
    _unknown_ _t238;                       // _t238
    signed int _t242;                      // _t242
    int _t246;                             // _t246
    complex float _t248;                   // _t248
    _unknown_ _t251;                       // _t251

    __esp = __esp - 92;
    dim = 1 << (rho->reg->width & 255);
    if(dim < 0) {
        quantum_error(3);
    }
    _v100 = dim;
    quantum_new_matrix( &(m.rows), dim);
    __esp = __esp - 4;
    k = 0;
    while(rho->num > k) {
        quantum_reconstruct_hash(rho->reg + ((k << 2) + k << 2));
        i = 0;
        while(1) {
            __eflags = i - dim;
            if(i >= dim) {
                break;
            }
            j = 0;
            while(1) {
                __eflags = j - dim;
                if(j >= dim) {
                    break;
                }
                _t231 = rho->reg + ((k << 2) + k << 2);
                _t139 = i;
                _v104 =  *_t231;
                _v100 = _t231[0];
                _v96 = _t231[1];
                _v92 = _t231[1];
                _v88 = _t231[2];
                 *__esp = _t139;
                _v108 = _t139 >> 31;
                l1 = quantum_get_state();
                _t233 = rho->reg + ((k << 2) + k << 2);
                _t151 = j;
                _v104 =  *_t233;
                _v100 = _t233[0];
                _v96 = _t233[1];
                _v92 = _t233[1];
                _v88 = _t233[2];
                 *__esp = _t151;
                _v108 = _t151 >> 31;
                l2 = quantum_get_state();
                __eflags = l1;
                if(l1 < 0) {
                    __eflags = l2;
                    if(__eflags < 0) {
                        __edi = _v44 + (_v48 * j + i << 3);
                        asm("fld dword [eax]");
                        asm("fstp dword [ebp-0x44]");
                        asm("fld dword [eax+0x4]");
                        asm("fstp dword [ebp-0x48]");
                        _t180 = rho->reg + ((k << 2) + k << 2)->node + (l2 << 4);
                        _t242 =  *_t180;
                        _v100 = _t180[1];
                        _v104 = _t242;
                        _v108 = 0;
                         *__esp = rho->prob[k];
                        _t182 = __mulsc3(0, 0, __eflags);
                        _v68 = _t242;
                        _t246 = rho->reg + ((k << 2) + k << 2)->node + (l1 << 4);
                         *__esp =  *_t246;
                        _v108 =  *(_t246 + 4);
                        _t248 = quantum_conj();
                        _v100 = _t246;
                        _v104 = _t248;
                        _v108 = _v68;
                         *__esp = _t182;
                        _t197 = __mulsc3(_t246, _t182, __eflags);
                        asm("fld dword [ebp-0x44]");
                        asm("fld dword [ebp-0x48]");
                        _v80 = _t197;
                        asm("fld dword [ebp-0x4c]");
                        _v80 = _t248;
                        asm("fld dword [ebp-0x4c]");
                        asm("fxch st0, st1");
                        asm("faddp st3, st0");
                        asm("faddp st1, st0");
                        asm("fxch st0, st1");
                        asm("fstp dword [ebp-0x4c]");
                        asm("fstp dword [ebp-0x4c]");
                         *__edi = _v80;
                        (__edi)[0] = _v80;
                    }
                }
                j = j + 1;
            }
            i = i + 1;
        }
        k = k + 1;
    }
     *(_a4.rows) = m.rows;
     *(_a4.rows + 4) = _v48;
     *((intOrPtr*)(_a4.rows + 8)) = _v44;
    __esp =  &_v16;
    return _a4;
}

quantum_reconstruct_hash(quantum_reg* reg)
{// addr = 0x08049996  --  defined in 'qureg.h' at line 159
    int i;                                 // _cfa_fffffff8
    quantum_reg* _v32;   // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    _unknown_ _t42;                        // _t42

    i = 0;
    while(1 << (reg->hashw & 255) > i) {
        reg->hash[i] = 0;
        i = i + 1;
    }
    i = 0;
    while(reg->size > i) {
        _t42 = reg->node + (i << 4);
        _v32 = reg;
        _v36 = i;
         *__esp =  *((intOrPtr*)(_t42 + 8));
        _v40 =  *((intOrPtr*)(_t42 + 12));
        quantum_add_hash();
        i = i + 1;
    }
    return;
}

quantum_add_hash(long long unsigned int a, int pos, quantum_reg* reg)
{// addr = 0x08049A19  --  defined in 'qureg.h' at line 131
    int i;                                 // _cfa_fffffff8
    int mark;                              // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43

    _v28 = _a4;
    _v24 = _a8;
    mark = 0;
    _v36 = reg->hashw;
     *__esp = _v28;
    _v40 = _v24;
    i = quantum_hash64();
    while(reg->hash[i] != 0) {
    }
    reg->hash[i] = pos + 1;
    return;
}

unsigned int quantum_hash64(long long unsigned int key, int width)
{// addr = 0x08049AB8  --  defined in 'qureg.h' at line 91
    unsigned int k32;                      // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    _unknown_ _t19;                        // _t19
    _unknown_ _t24;                        // _t24
    _unknown_ _t27;                        // _t27
    _unknown_ _t30;                        // _t30

    _v28 = _a4;
    _v24 = _a8;
    k32 = _v24 ^ _v28;
    k32 = k32 * k32;
    k32 = k32 >> (32 - width & 255);
    return k32;
}

int quantum_get_state(long long unsigned int a, quantum_reg reg)
{// addr = 0x08049AFA  --  defined in 'qureg.h' at line 106
    int i;                                 // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ __ebp;                       // r6
    _unknown_ _t53;                        // _t53
    _unknown_ _t61;                        // _t61

    _v28 = _a4;
    _v24 = _a8;
    if(_a20 != 0) {
        _v44 = _a20;
         *__esp = _v28;
        _v48 = _v24;
        i = quantum_hash64();
L7:
        while( *((intOrPtr*)(_a28 + (i << 2))) != 0) {
            goto L3;
        }
        _v32 = -1;
        goto L9;
    }
    _v32 = _v28;
L9:
    return _v32;
L3:
    if(( *(_a24 +  ~(1 -  *((intOrPtr*)(_a28 + (i << 2))) << 4) + 8) ^ _v28 |  *(_a24 +  ~(1 -  *((intOrPtr*)(_a28 + (i << 2))) << 4) + 12) ^ _v24) != 0) {
        i = i + 1;
        if(1 << (_a20 & 255) == i) {
            i = 0;
        }
        goto L7;
    }
    _v32 =  *((intOrPtr*)(_a28 + (i << 2))) - 1;
    goto L9;
}

quantum_print_density_matrix(quantum_density_op* rho)
{// addr = 0x08049BC0  --  defined in 'density.c' at line 192
    quantum_density_op* _v16;   // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    quantum_matrix m;   // _cfa_ffffffe8
    quantum_density_op* _v36;   // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    quantum_density_op* _v56;   // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6

    _v56 = rho;
    quantum_density_matrix( &_v44);
    __esp = __esp - 4;
    m.rows = _v44;
    _v20 = _v40;
    _v16 = _v36;
     *__esp = m.rows;
    _v60 = _v20;
    _v56 = _v16;
    quantum_print_matrix();
    quantum_delete_matrix( &(m.rows));
    return;
}

quantum_delete_density_op(quantum_density_op* rho)
{// addr = 0x08049C13  --  defined in 'density.c' at line 205
    int i;                                 // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t33;                        // _t33
    _unknown_ _t36;                        // _t36
    _unknown_ _t40;                        // _t40

    quantum_destroy_hash(rho->reg);
    i = 0;
    while(rho->num > i) {
        quantum_delete_qureg_hashpreserve(rho->reg + ((i << 2) + i << 2));
        i = i + 1;
    }
    free(rho->prob);
    free(rho->reg);
    quantum_memman(rho->num * rho->num);
    rho->prob = 0;
    rho->reg = 0;
    return;
}

float quantum_purity(quantum_density_op* rho)
{// addr = 0x08049C9E  --  defined in 'density.c' at line 228
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    int l;                                 // _cfa_ffffffe0
    float f;                               // _cfa_ffffffdc
    complex float _v40;                    // _cfa_ffffffd8
    complex float g;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    complex float dp;                      // _cfa_ffffffcc
    complex float _v68;                    // _cfa_ffffffbc
    complex float _v84;                    // _cfa_ffffffac
    complex float _v88;                    // _cfa_ffffffa8
    complex float _v92;                    // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    complex float _v100;                   // _cfa_ffffff9c
    complex float _v104;                   // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t113;                       // _t113
    _unknown_ _t114;                       // _t114
    _unknown_ _t117;                       // _t117
    _unknown_ _t119;                       // _t119
    _unknown_ _t120;                       // _t120
    _unknown_ _t121;                       // _t121
    _unknown_ _t123;                       // _t123
    _unknown_ _t124;                       // _t124
    _unknown_ _t146;                       // _t146
    _unknown_ _t161;                       // _t161
    _unknown_ _t168;                       // _t168
    _unknown_ _t169;                       // _t169
    _unknown_ _t172;                       // _t172
    _unknown_ _t174;                       // _t174
    _unknown_ _t175;                       // _t175
    _unknown_ _t176;                       // _t176
    _unknown_ _t178;                       // _t178
    _unknown_ _t179;                       // _t179
    complex float _t182;                   // _t182
    complex float* _t192;                  // _t192
    complex float _t194;                   // _t194
    float _t211;                           // _t211
    complex float* _t228;                  // _t228
    _unknown_ _t229;                       // _t229
    _unknown_ _t238;                       // _t238
    _unknown_ _t239;                       // _t239
    _unknown_ _t240;                       // _t240
    signed int _t242;                      // _t242
    _unknown_ _t248;                       // _t248
    _unknown_ _t249;                       // _t249
    _unknown_ _t250;                       // _t250
    complex float _t251;                   // _t251
    complex float _t255;                   // _t255
    signed int _t259;                      // _t259
    complex float _t261;                   // _t261

    f = 0;
    i = 0;
    while(rho->num > i) {
        asm("fld dword [eax]");
        asm("fld dword [eax]");
        asm("fmulp st1, st0");
        asm("fld dword [ebp-0x20]");
        asm("faddp st1, st0");
        asm("fstp dword [ebp-0x20]");
        i = i + 1;
    }
    i = 0;
    while(rho->num > i) {
        j = 0;
        while(1) {
            __eflags = j - i;
            if(j >= i) {
                break;
            }
            _t242 = i;
            dp = quantum_dot_product(rho->reg + ((_t242 << 2) + _t242 << 2), rho->reg + ((j << 2) + j << 2));
            _v48 = _t242;
            k = 0;
            while(1) {
                _t146 = rho->reg + ((i << 2) + i << 2);
                __eflags =  *((intOrPtr*)(_t146 + 4)) - k;
                if( *((intOrPtr*)(_t146 + 4)) <= k) {
                    break;
                }
                _t228 = rho->reg + ((j << 2) + j << 2);
                _t161 =  *((intOrPtr*)(rho->reg + ((i << 2) + i << 2) + 12)) + (k << 4);
                _t263 =  *(_t161 + 12);
                _v100 =  *_t228;
                _v96 = _t228[0];
                _v92 = _t228[1];
                _v88 = _t228[1];
                _v84 = _t228[2];
                 *__esp =  *(_t161 + 8);
                _v104 =  *(_t161 + 12);
                l = quantum_get_state();
                __eflags = l;
                if(__eflags >= 0) {
                    g = 0;
                    _v40 = 0;
                } else {
                    asm("fld dword [eax]");
                    asm("fld dword [eax]");
                    asm("fmulp st1, st0");
                    asm("fstp dword [ebp-0x40]");
                    _t251 = dp;
                    _v96 = _v48;
                    _v100 = _t251;
                    _v104 = 0;
                     *__esp = _v68;
                    _t182 = __mulsc3(0, _t263, __eflags);
                    _t192 =  *((intOrPtr*)(rho->reg + ((i << 2) + i << 2) + 12)) + (k << 4);
                    _t255 =  *_t192;
                    _v96 = _t192[0];
                    _v100 = _t255;
                    _v104 = _t251;
                     *__esp = _t182;
                    _t194 = __mulsc3(_t251, _t251, __eflags);
                    _t259 = rho->reg + ((j << 2) + j << 2)->node + (l << 4);
                     *__esp =  *_t259;
                    _v104 =  *(_t259 + 4);
                    _t261 = quantum_conj();
                    _v96 = _t259;
                    _v100 = _t261;
                    _v104 = _t255;
                     *__esp = _t194;
                    g = __mulsc3(_t259, _t194, __eflags);
                    _v40 = _t261;
                }
                 *__esp = g;
                _v104 = _v40;
                quantum_real();
                asm("fld st0, st0");
                asm("faddp st1, st0");
                asm("fld dword [ebp-0x20]");
                asm("faddp st1, st0");
                asm("fstp dword [ebp-0x20]");
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    _t211 = f;
    _v68 = _t211;
    asm("fld dword [ebp-0x40]");
    return _t211;
}

_Unknown_base* quantum_error_handler(_None* f)
{// addr = 0x08049F64  --  defined in 'error.c' at line 31
    _unknown_ __ebp;                       // r6

    if(f != 0) {
        errfunc = f;
    }
    return errfunc;
}

const char* quantum_strerr(int errno)
{// addr = 0x08049F7C  --  defined in 'error.c' at line 42
    const char* _v8;   // _cfa_fffffff8
    int _v12;                              // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    _v12 = errno;
    if(_v12 == 3) {
        _v8 = "matrix too large";
    } else {
        if(_v12 > 3) {
            if(_v12 == 5) {
                _v8 = "hash table full";
            } else {
                if(_v12 < 5) {
                    _v8 = "wrong matrix size";
                } else {
                    if(_v12 == 65536) {
                        _v8 = "single-column matrix expected";
                    } else {
                        if(_v12 == 65537) {
                            _v8 = "unknown opcode";
                        } else {
                            goto L19;
                        }
                    }
                }
            }
        } else {
            if(_v12 == 1) {
                _v8 = "failure";
            } else {
                if(_v12 > 1) {
                    _v8 = "malloc failed";
                } else {
                    if(_v12 == 0) {
                        _v8 = "success";
                    } else {
L19:
                        _v8 = "unknown error code";
                    }
                }
            }
        }
    }
    return _v8;
}

quantum_error(int errno)
{// addr = 0x0804A01C  --  defined in 'error.c' at line 68
    signed int _v0;                        // _cfa_0
    _None* p;                              // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    quantum_reg* _v24;   // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    int _v36;                              // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ _v92;                        // _cfa_ffffffa4
    _unknown_ _v96;                        // _cfa_ffffffa0
    _unknown_ _v100;                       // _cfa_ffffff9c
    _unknown_ __ebp;                       // r6
    _unknown_ _t51;                        // _t51
    int _t54;                              // _t54
    _unknown_ _t61;                        // _t61
    _unknown_ _t66;                        // _t66
    _unknown_ _t80;                        // _t80
    _unknown_ _t83;                        // _t83
    _unknown_ _t88;                        // _t88
    _unknown_ _t89;                        // _t89

    p = quantum_error_handler(0);
    if(p == 0) {
        fflush(__imp__stdout);
        _t54 = errno;
        quantum_strerr(_t54);
        _v36 = _t54;
        fprintf(__imp__stderr, "ERROR: %s\n");
        fflush(__imp__stderr);
        abort();
        _push(_t88);
        __esp = __esp - 56;
        quantum_sigma_x(_v28 + 1 + _v28 + 1, _v24);
        _v52 = 1;
        while(_v12 <= _a8) {
            _v20 = errno % _v0;
            _v16 = 1;
            while(_v16 < _v12) {
                _v20 = _v20 * _v20;
                _v20 = _v20 % _v0;
                _v16 = _v16 + 1;
            }
            mul_mod_n(_v0, _v20, _a12 + _a12 + _a12 + 1 + _v12, _a12, _a16);
            _v12 = _v12 + 1;
        }
        return;
L10:
    }
     *__esp = errno;
     *p();
    return;
    goto L10;
}

quantum_exp_mod_n(int N, int x, int width_input, int width, quantum_reg* reg)
{// addr = 0x0804A088  --  defined in 'expn.c' at line 35
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int f;                                 // _cfa_fffffff0
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t49;                        // _t49
    _unknown_ _t54;                        // _t54
    _unknown_ _t65;                        // _t65
    _unknown_ _t68;                        // _t68

    quantum_sigma_x(width + 1 + width + 1, reg);
    i = 1;
    while(i <= width_input) {
        f = x % N;
        j = 1;
        while(j < i) {
            f = f * f;
            f = f % N;
            j = j + 1;
        }
        mul_mod_n(N, f, width + width + width + 1 + i, width, reg);
        i = i + 1;
    }
    return;
}

quantum_cnot(int control, int target, quantum_reg* reg)
{// addr = 0x0804A130  --  defined in 'gates.c' at line 42
    int i;                                 // _cfa_ffffffe8
    int qec;                               // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _v48;                              // _cfa_ffffffd0
    unsigned char _v52;                    // _cfa_ffffffcc
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    signed int __edi;                      // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t69;                        // _t69
    signed int _t70;                       // _t70
    _unknown_ _t78;                        // _t78
    signed int _t80;                       // _t80
    signed int _t87;                       // _t87
    signed int _t88;                       // _t88
    intOrPtr _t90;                         // _t90
    signed int _t93;                       // _t93
    signed int _t97;                       // _t97
    _unknown_ _t100;                       // _t100

    quantum_qec_get_status( &qec, 0);
    if(qec != 0) {
        quantum_cnot_ft(control, target, reg);
        return;
    }
    _v68 = target;
    _v72 = control;
    if(quantum_objcode_put(1) != 0) {
    } else {
        i = 0;
        while(reg->size > i) {
            _t69 = reg->node + (i << 4);
            _t70 =  *(_t69 + 8);
            _t87 = control;
            asm("shrd eax, edx, cl");
            _t93 =  *(_t69 + 12) >> (_t87 & 255);
            if((_t87 & 0x20) != 0) {
                _t70 = _t93;
            }
            if((_t70 & 1) != 0) {
                _v40 = reg->node + (i << 4);
                _t78 = reg->node + (i << 4);
                __esi =  *(_t78 + 8);
                __edi =  *(_t78 + 12);
                _t88 = target;
                _v52 = 1;
                _v48 = 0;
                _t97 = _v48;
                asm("shld edx, eax, cl");
                _t80 = _v52 << (_t88 & 255);
                if((_t88 & 0x20) != 0) {
                    _t97 = _t80;
                    _t80 = 0;
                }
                _t90 = _v40;
                 *(_t90 + 8) = __esi ^ _t80;
                 *(_t90 + 12) = __edi ^ _t97;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
    goto L13;
L14:
L13:
    return;
    goto L14;
}

quantum_toffoli(int control1, int control2, int target, quantum_reg* reg)
{// addr = 0x0804A252  --  defined in 'gates.c' at line 70
    int i;                                 // _cfa_ffffffe8
    int qec;                               // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _v48;                              // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    int _v64;                              // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    signed int __edi;                      // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t89;                        // _t89
    signed int _t90;                       // _t90
    _unknown_ _t95;                        // _t95
    signed int _t96;                       // _t96
    _unknown_ _t104;                       // _t104
    signed int _t106;                      // _t106
    signed int _t114;                      // _t114
    signed int _t115;                      // _t115
    signed int _t116;                      // _t116
    intOrPtr _t118;                        // _t118
    signed int _t121;                      // _t121
    signed int _t124;                      // _t124
    signed int _t128;                      // _t128
    _unknown_ _t131;                       // _t131
    _unknown_ _t132;                       // _t132

    quantum_qec_get_status( &qec, 0);
    if(qec == 0) {
        _v64 = target;
        _v68 = control2;
        _v72 = control1;
        if(quantum_objcode_put(2) != 0) {
            return;
        }
        goto L3;
    }
    quantum_toffoli_ft(control1, control2, target, reg);
    return;
L3:
    i = 0;
    while(reg->size > i) {
        _t89 = reg->node + (i << 4);
        _t90 =  *(_t89 + 8);
        _t114 = control1;
        asm("shrd eax, edx, cl");
        _t121 =  *(_t89 + 12) >> (_t114 & 255);
        if((_t114 & 0x20) != 0) {
            _t90 = _t121;
        }
        if((_t90 & 1) != 0) {
            _t95 = reg->node + (i << 4);
            _t96 =  *(_t95 + 8);
            _t115 = control2;
            asm("shrd eax, edx, cl");
            _t124 =  *(_t95 + 12) >> (_t115 & 255);
            if((_t115 & 0x20) != 0) {
                _t96 = _t124;
            }
            if((_t96 & 1) != 0) {
                _v40 = reg->node + (i << 4);
                _t104 = reg->node + (i << 4);
                __esi =  *(_t104 + 8);
                __edi =  *(_t104 + 12);
                _t116 = target;
                _v52 = 1;
                _v48 = 0;
                _t128 = _v48;
                asm("shld edx, eax, cl");
                _t106 = _v52 << (_t116 & 255);
                if((_t116 & 0x20) != 0) {
                    _t128 = _t106;
                    _t106 = 0;
                }
                _t118 = _v40;
                 *(_t118 + 8) = __esi ^ _t106;
                 *(_t118 + 12) = __edi ^ _t128;
            }
        }
        i = i + 1;
    }
    quantum_decohere(reg);
    return;
}

quantum_unbounded_toffoli(int controlling, quantum_reg* reg)
{// addr = 0x0804A3B3  --  defined in 'gates.c' at line 107
    va_list bits;      // _cfa_ffffffe8
    int target;                            // _cfa_ffffffe4
    int* controls;                         // _cfa_ffffffe0
    int i;                                 // _cfa_ffffffdc
    int j;                                 // _cfa_ffffffd8
    intOrPtr _v56;                         // _cfa_ffffffc8
    int _v64;                              // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t82;                        // _t82
    _unknown_ _t103;                       // _t103
    signed int _t105;                      // _t105
    _unknown_ _t111;                       // _t111
    signed int _t115;                      // _t115
    _unknown_ _t118;                       // _t118
    _unknown_ _t122;                       // _t122
    signed int _t128;                      // _t128
    intOrPtr _t130;                        // _t130
    signed int _t131;                      // _t131
    char* _t132;                           // _t132
    char* _t133;                           // _t133
    signed int _t137;                      // _t137
    signed int _t142;                      // _t142
    _unknown_ _t143;                       // _t143
    signed int _t144;                      // _t144

    controls = malloc(controlling << 2);
    if(controls == 0) {
        quantum_error(2);
    }
    quantum_memman(controlling << 2);
    bits =  &_a12;
    i = 0;
    while(i < controlling) {
        _t132 = bits;
        bits =  &(_t132[4]);
        controls[i] =  *_t132;
        i = i + 1;
    }
    _t133 = bits;
    bits =  &(_t133[4]);
    target =  *_t133;
    i = 0;
    while(reg->size > i) {
        j = 0;
        while(j < controlling) {
            _t111 = reg->node + (i << 4);
            _t131 = controls[j];
            _t115 =  *(_t111 + 8);
            asm("shrd eax, edx, cl");
            _t142 =  *(_t111 + 12) >> (_t131 & 255);
            if((_t131 & 0x20) != 0) {
                _t115 = _t142;
            }
            if((_t115 & 1) != 0) {
                j = j + 1;
                continue;
            }
            break;
        }
        if(j == controlling) {
            _v56 = reg->node + (i << 4);
            _t103 = reg->node + (i << 4);
            _t144 =  *(_t103 + 8);
            __edi =  *(_t103 + 12);
            _t128 = target;
            _v68 = 1;
            _v64 = 0;
            _t137 = _v64;
            asm("shld edx, eax, cl");
            _t105 = _v68 << (_t128 & 255);
            if((_t128 & 0x20) != 0) {
                _t137 = _t105;
                _t105 = 0;
            }
            _t130 = _v56;
             *(_t130 + 8) = _t144 ^ _t105;
             *(_t130 + 12) = __edi ^ _t137;
        }
        i = i + 1;
    }
    free(controls);
    quantum_memman( ~(controlling << 2));
    quantum_decohere(reg);
    return;
}

quantum_sigma_x(int target, quantum_reg* reg)
{// addr = 0x0804A535  --  defined in 'gates.c' at line 150
    int i;                                 // _cfa_ffffffe8
    int qec;                               // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _v48;                              // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    signed int __edi;                      // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t52;                        // _t52
    signed int _t54;                       // _t54
    signed int _t60;                       // _t60
    intOrPtr _t62;                         // _t62
    signed int _t66;                       // _t66

    quantum_qec_get_status( &qec, 0);
    if(qec != 0) {
        quantum_sigma_x_ft(target, reg);
        return;
    }
    _v56 = target;
    if(quantum_objcode_put(3) != 0) {
    } else {
        i = 0;
        while(reg->size > i) {
            _v40 = reg->node + (i << 4);
            _t52 = reg->node + (i << 4);
            __esi =  *(_t52 + 8);
            __edi =  *(_t52 + 12);
            _t60 = target;
            _v52 = 1;
            _v48 = 0;
            _t66 = _v48;
            asm("shld edx, eax, cl");
            _t54 = _v52 << (_t60 & 255);
            if((_t60 & 0x20) != 0) {
                _t66 = _t54;
                _t54 = 0;
            }
            _t62 = _v40;
             *(_t62 + 8) = __esi ^ _t54;
             *(_t62 + 12) = __edi ^ _t66;
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
    goto L9;
L10:
L9:
    return;
    goto L10;
}

quantum_sigma_y(int target, quantum_reg* reg)
{// addr = 0x0804A615  --  defined in 'gates.c' at line 177
    int i;                                 // _cfa_ffffffe8
    intOrPtr _v40;                         // _cfa_ffffffd8
    int _v48;                              // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    intOrPtr _v64;                         // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t75;                        // _t75
    _unknown_ _t86;                        // _t86
    signed int _t88;                       // _t88
    _unknown_ _t94;                        // _t94
    signed int _t95;                       // _t95
    intOrPtr* _t103;                       // _t103
    _unknown_ _t105;                       // _t105
    _unknown_ _t106;                       // _t106
    intOrPtr* _t115;                       // _t115
    _unknown_ _t117;                       // _t117
    _unknown_ _t118;                       // _t118
    signed int _t125;                      // _t125
    intOrPtr _t127;                        // _t127
    signed int _t128;                      // _t128
    _unknown_ _t133;                       // _t133
    signed int _t137;                      // _t137
    signed int _t142;                      // _t142
    int _t146;                             // _t146
    int _t151;                             // _t151
    _unknown_ _t153;                       // _t153
    _unknown_ _t154;                       // _t154
    signed int _t155;                      // _t155
    intOrPtr* _t156;                       // _t156
    intOrPtr* _t157;                       // _t157

    _v72 = target;
    if(quantum_objcode_put(4) == 0) {
        i = 0;
        while(reg->size > i) {
            _v40 = reg->node + (i << 4);
            _t86 = reg->node + (i << 4);
            _t155 =  *(_t86 + 8);
            __edi =  *(_t86 + 12);
            _t125 = target;
            _v52 = 1;
            _v48 = 0;
            _t137 = _v48;
            asm("shld edx, eax, cl");
            _t88 = _v52 << (_t125 & 255);
            __eflags = _t125 & 0x20;
            if((_t125 & 0x20) != 0) {
                _t137 = _t88;
                _t88 = 0;
            }
            _t127 = _v40;
             *(_t127 + 8) = _t155 ^ _t88;
             *(_t127 + 12) = __edi ^ _t137;
            _t94 = reg->node + (i << 4);
            _t95 =  *(_t94 + 8);
            _t128 = target;
            asm("shrd eax, edx, cl");
            _t142 =  *(_t94 + 12) >> (_t128 & 255);
            __eflags = _t128 & 0x20;
            if((_t128 & 0x20) != 0) {
                _t95 = _t142;
            }
            __eflags = _t95 & 1;
            if(__eflags == 0) {
                _t156 = reg->node + (i << 4);
                _t103 = reg->node + (i << 4);
                _t146 =  *(_t103 + 4);
                _v64 = -1082130432;
                _v68 = 0;
                _v72 = _t146;
                 *__esp =  *_t103;
                 *_t156 = __mulsc3( *_t103, _t156, __eflags);
                 *(_t156 + 4) = _t146;
            } else {
                _t157 = reg->node + (i << 4);
                _t115 = reg->node + (i << 4);
                _t151 =  *(_t115 + 4);
                _v64 = 1065353216;
                _v68 = 0;
                _v72 = _t151;
                 *__esp =  *_t115;
                 *_t157 = __mulsc3( *_t115, _t157, __eflags);
                 *(_t157 + 4) = _t151;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
    return;
}

quantum_sigma_z(int target, quantum_reg* reg)
{// addr = 0x0804A79E  --  defined in 'gates.c' at line 203
    int i;                                 // _cfa_fffffff8
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t46;                        // _t46
    signed int _t47;                       // _t47
    intOrPtr* _t55;                        // _t55
    signed int _t59;                       // _t59
    intOrPtr* _t60;                        // _t60
    signed int _t63;                       // _t63
    _unknown_ _t68;                        // _t68

    _v40 = target;
    if(quantum_objcode_put(5) == 0) {
        i = 0;
        while(reg->size > i) {
            _t46 = reg->node + (i << 4);
            _t47 =  *(_t46 + 8);
            _t59 = target;
            asm("shrd eax, edx, cl");
            _t63 =  *(_t46 + 12) >> (_t59 & 255);
            if((_t59 & 0x20) != 0) {
                _t47 = _t63;
            }
            if((_t47 & 1) != 0) {
                _t60 = reg->node + (i << 4);
                _t55 = reg->node + (i << 4);
                _v24 =  *_t55;
                asm("fld dword [ebp-0x14]");
                _v24 =  *((intOrPtr*)(_t55 + 4));
                asm("fld dword [ebp-0x14]");
                asm("fxch st0, st1");
                asm("fchs ");
                asm("fxch st0, st1");
                asm("fchs ");
                asm("fxch st0, st1");
                asm("fstp dword [ebp-0x14]");
                asm("fstp dword [ebp-0x14]");
                 *_t60 = _v24;
                 *((intOrPtr*)(_t60 + 4)) = _v24;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
    return;
}

quantum_swaptheleads(int width, quantum_reg* reg)
{// addr = 0x0804A85F  --  defined in 'gates.c' at line 224
    int i;                                 // _cfa_ffffffe8
    int j;                                 // _cfa_ffffffe4
    int pat1;                              // _cfa_ffffffe0
    int pat2;                              // _cfa_ffffffdc
    int qec;                               // _cfa_ffffffd8
    intOrPtr _v48;                         // _cfa_ffffffd0
    long long unsigned int l;              // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    quantum_reg* _t108;   // _t108
    _unknown_ _t116;                       // _t116
    signed int _t117;                      // _t117
    _unknown_ _t127;                       // _t127
    signed int _t128;                      // _t128
    _unknown_ _t134;                       // _t134
    signed int _t156;                      // _t156
    signed int _t157;                      // _t157
    signed int _t159;                      // _t159
    signed int _t160;                      // _t160
    _unknown_ _t164;                       // _t164
    _unknown_ _t166;                       // _t166
    _unknown_ _t167;                       // _t167
    _unknown_ _t169;                       // _t169
    _unknown_ _t171;                       // _t171
    _unknown_ _t177;                       // _t177
    _unknown_ _t180;                       // _t180
    _unknown_ _t182;                       // _t182
    _unknown_ _t185;                       // _t185
    _unknown_ _t186;                       // _t186

    quantum_qec_get_status( &qec, 0);
    if(qec != 0) {
        i = 0;
        while(i < width) {
            quantum_cnot(i, width + i, reg);
            quantum_cnot(width + i, i, reg);
            quantum_cnot(i, width + i, reg);
            i = i + 1;
        }
        return;
    }
    i = 0;
    while(1) {
L15:
        _t108 = reg;
        _t109 = _t108->size;
        if(_t108->size <= i) {
            break;
        }
        _v72 = width;
        if(quantum_objcode_put(14) != 0) {
        } else {
            _t156 =  *(reg->node + (i << 4) + 8);
            _t159 = width;
            asm("shld edx, eax, cl");
            _t117 = 1 << (_t159 & 255);
            if((_t159 & 0x20) != 0) {
                _t117 = 0;
            }
            pat1 = _t117 - 1 & _t156;
            pat2 = 0;
            j = 0;
            while(j < width) {
                _t157 =  *(reg->node + (i << 4) + 8);
                _t160 = width + j;
                asm("shld edx, eax, cl");
                _t128 = 1 << (_t160 & 255);
                if((_t160 & 0x20) != 0) {
                    _t128 = 0;
                }
                pat2 = (_t157 & _t128) + pat2;
                j = j + 1;
            }
            _t134 = reg->node + (i << 4);
            asm("sbb edi, edx");
            l =  *((intOrPtr*)(_t134 + 8)) - pat1 + pat2;
            _v48 =  *((intOrPtr*)(_t134 + 12));
            l = l + (pat1 << (width & 255));
            asm("adc [ebp-0x2c], edx");
            l = l + (pat2 >> (width & 255));
            asm("adc [ebp-0x2c], edx");
            _t164 = reg->node + (i << 4);
             *(_t164 + 8) = l;
             *((intOrPtr*)(_t164 + 12)) = _v48;
            i = i + 1;
            continue;
        }
        break;
L17:
    }
    return;
    goto L17;
}

quantum_swaptheleads_omuln_controlled(int control, int width, quantum_reg* reg)
{// addr = 0x0804AA4B  --  defined in 'gates.c' at line 275
    int i;                                 // _cfa_fffffff8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    i = 0;
    while(i < width) {
        quantum_toffoli(control, width + i, width + width + i + 2, reg);
        quantum_toffoli(control, width + width + i + 2, width + i, reg);
        quantum_toffoli(control, width + i, width + width + i + 2, reg);
        i = i + 1;
    }
    return;
}

quantum_gate1(int target, quantum_matrix m, quantum_reg* reg)
{// addr = 0x0804AAF9  --  defined in 'gates.c' at line 290
    float limit;                           // _cfa_ffffffc4
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int iset;                              // _cfa_ffffffd4
    int addsize;                           // _cfa_ffffffd0
    int decsize;                           // _cfa_ffffffcc
    int sorted;                            // _cfa_ffffffc8
    char* done;                            // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    complex float t;                       // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    complex float tnot;                    // _cfa_ffffffb0
    intOrPtr _v108;                        // _cfa_ffffff94
    complex float _v112;                   // _cfa_ffffff90
    complex float _v116;                   // _cfa_ffffff8c
    complex float _v120;                   // _cfa_ffffff88
    complex float _v124;                   // _cfa_ffffff84
    signed int _v160;                      // _cfa_ffffff60
    int _v168;                             // _cfa_ffffff58
    int _v172;                             // _cfa_ffffff54
    int* _v180;                            // _cfa_ffffff4c
    quantum_reg_node* _v184;   // _cfa_ffffff48
    int _v188;                             // _cfa_ffffff44
    int _v192;                             // _cfa_ffffff40
    complex float _v196;                   // _cfa_ffffff3c
    complex float _v200;                   // _cfa_ffffff38
    char _v204;                            // _cfa_ffffff34
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t427;                       // _t427
    _unknown_ _t428;                       // _t428
    _unknown_ _t429;                       // _t429
    _unknown_ _t437;                       // _t437
    signed int _t439;                      // _t439
    int _t442;                             // _t442
    _unknown_ _t446;                       // _t446
    _unknown_ _t447;                       // _t447
    _unknown_ _t461;                       // _t461
    _unknown_ _t468;                       // _t468
    _unknown_ _t474;                       // _t474
    _unknown_ _t475;                       // _t475
    _unknown_ _t484;                       // _t484
    _unknown_ _t488;                       // _t488
    signed int _t489;                      // _t489
    signed int _t494;                      // _t494
    _unknown_ _t500;                       // _t500
    signed int _t501;                      // _t501
    _unknown_ _t503;                       // _t503
    _unknown_ _t504;                       // _t504
    _unknown_ _t508;                       // _t508
    signed int _t510;                      // _t510
    complex float* _t517;                  // _t517
    complex float* _t522;                  // _t522
    signed int _t525;                      // _t525
    complex float* _t528;                  // _t528
    complex float* _t535;                  // _t535
    signed int _t536;                      // _t536
    complex float* _t540;                  // _t540
    signed int _t541;                      // _t541
    signed int _t543;                      // _t543
    _unknown_ _t550;                       // _t550
    signed int _t552;                      // _t552
    complex float* _t559;                  // _t559
    complex float* _t570;                  // _t570
    _unknown_ _t579;                       // _t579
    _unknown_ _t583;                       // _t583
    _unknown_ _t599;                       // _t599
    intOrPtr* _t608;                       // _t608
    _unknown_ _t624;                       // _t624
    complex float* _t629;                  // _t629
    signed int _t632;                      // _t632
    complex float* _t635;                  // _t635
    signed int _t638;                      // _t638
    complex float* _t644;                  // _t644
    signed int _t647;                      // _t647
    complex float* _t650;                  // _t650
    signed int _t653;                      // _t653
    complex float* _t660;                  // _t660
    signed int _t663;                      // _t663
    complex float* _t666;                  // _t666
    complex float* _t675;                  // _t675
    quantum_reg* _t679;   // _t679
    signed int _t681;                      // _t681
    quantum_reg* _t683;   // _t683
    signed int _t705;                      // _t705
    signed int _t713;                      // _t713
    _unknown_ _t715;                       // _t715
    intOrPtr* _t717;                       // _t717
    signed int _t718;                      // _t718
    signed int _t719;                      // _t719
    signed int _t729;                      // _t729
    signed int _t730;                      // _t730
    signed int _t732;                      // _t732
    intOrPtr _t734;                        // _t734
    _unknown_ _t750;                       // _t750
    signed int _t752;                      // _t752
    int* _t763;                            // _t763
    int _t765;                             // _t765
    signed int* _t769;                     // _t769
    _unknown_ _t782;                       // _t782
    _unknown_ _t783;                       // _t783
    signed int _t785;                      // _t785
    complex float _t792;                   // _t792
    complex float _t795;                   // _t795
    signed int _t798;                      // _t798
    signed int _t799;                      // _t799
    signed int _t803;                      // _t803
    complex float _t808;                   // _t808
    complex float _t812;                   // _t812
    complex float _t816;                   // _t816
    complex float _t819;                   // _t819
    complex float _t824;                   // _t824
    complex float _t827;                   // _t827
    complex float _t832;                   // _t832
    complex float _t835;                   // _t835
    _unknown_ _t840;                       // _t840
    signed int _t841;                      // _t841
    signed int _t842;                      // _t842
    signed int _t844;                      // _t844
    _unknown_ _t848;                       // _t848
    signed int _t849;                      // _t849
    signed int _t852;                      // _t852
    signed int* _t853;                     // _t853
    signed int _t854;                      // _t854
    intOrPtr* _t855;                       // _t855
    intOrPtr* _t856;                       // _t856
    signed int* _t857;                     // _t857
    signed int* _t858;                     // _t858
    signed int* _t859;                     // _t859

    addsize = 0;
    decsize = 0;
    sorted = 1;
    tnot = 0;
    _v76 = 0;
    if(m.cols != 2 || m.rows != 2) {
        quantum_error(4);
    }
    quantum_reconstruct_hash(reg);
    i = 0;
    while(reg->size > i) {
        _t437 = reg->node + (i << 4);
        _t849 =  *(_t437 + 8);
        _t841 =  *(_t437 + 12);
        _t705 = target;
        _v172 = 1;
        _v168 = 0;
        _t752 = _v168;
        asm("shld edx, eax, cl");
        _t439 = _v172 << (_t705 & 255);
        __eflags = _t705 & 0x20;
        if((_t705 & 0x20) != 0) {
            _t752 = _t439;
            _t439 = 0;
        }
        _t679 = reg;
        _v196 = _t679->width;
        _v192 = _t679->size;
        _v188 = _t679->hashw;
        _v184 = _t679->node;
        _v180 = _t679->hash;
         *__esp = _t849 ^ _t439;
        _v200 = _t841 ^ _t752;
        _t442 = quantum_get_state();
        __eflags = _t442 - 255;
        if(_t442 == 255) {
            addsize = addsize + 1;
        }
        i = i + 1;
    }
    reg->node = realloc(reg->node, reg->size + addsize << 4);
    if(reg->node == 0) {
        quantum_error(2);
    }
    quantum_memman(addsize << 4);
    i = 0;
    while(i < addsize) {
        _t468 = reg->node + (reg->size + i << 4);
         *(_t468 + 8) = 0;
         *(_t468 + 12) = 0;
        _t763 = reg->node + (reg->size + i << 4);
         *_t763 = 0;
        _t763[1] = 0;
        i = i + 1;
    }
    done = calloc(reg->size + addsize, 1);
    if(done == 0) {
        quantum_error(2);
    }
    quantum_memman(reg->size + addsize);
    k = reg->size;
    _t713 = reg->width;
    _t765 = 0;
    asm("shld edx, eax, cl");
    _t489 = 1 << (_t713 & 255);
    if((_t713 & 0x20) != 0) {
        _t765 = _t489;
        _t489 = 0;
    }
    _push(_t765);
    _push(_t489);
    asm("fild qword [esp]");
    __esp =  &_v204;
    asm("fstp tword [ebp+0xffffff78]");
    if(_t765 < 0) {
        asm("fld tword [0x8054330]");
        asm("fld tword [ebp+0xffffff78]");
        asm("faddp st1, st0");
        asm("fstp tword [ebp+0xffffff78]");
    }
    asm("fld tword [ebp+0xffffff78]");
    asm("fstp qword [ebp-0x60]");
    asm("fld qword [ebp-0x60]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fld qword [0x8054340]");
    asm("fmulp st1, st0");
    asm("fstp dword [ebp-0x38]");
    i = 0;
    while(reg->size > i) {
        _t494 = done[i] & 255;
        __eflags = _t494 & 255;
        if((_t494 & 255) != 0) {
L51:
            i = i + 1;
            continue;
        }
        _t681 = (reg->node + (i << 4))[1];
        _t718 = target;
        asm("shld edx, eax, cl");
        _t501 = 1 << (_t718 & 255);
        __eflags = _t718 & 0x20;
        if((_t718 & 0x20) != 0) {
            _t501 = 0;
        }
        iset = _t501 & _t681;
        tnot = 0;
        _v76 = 0;
        _t508 = reg->node + (i << 4);
        _t852 =  *(_t508 + 8);
        _t842 =  *(_t508 + 12);
        _t719 = target;
        _v172 = 1;
        _v168 = 0;
        _t785 = _v168;
        asm("shld edx, eax, cl");
        _t510 = _v172 << (_t719 & 255);
        __eflags = _t719 & 0x20;
        if((_t719 & 0x20) != 0) {
            _t785 = _t510;
            _t510 = 0;
        }
        _t683 = reg;
        _v196 = _t683->width;
        _v192 = _t683->size;
        _v188 = _t683->hashw;
        _v184 = _t683->node;
        _v180 = _t683->hash;
         *__esp = _t852 ^ _t510;
        _v200 = _t842 ^ _t785;
        j = quantum_get_state();
        _t517 = reg->node + (i << 4);
        t =  *_t517;
        _v68 = _t517[0];
        __eflags = j;
        if(j < 0) {
            _t675 = reg->node + (j << 4);
            tnot =  *_t675;
            _v76 = _t675[0];
        }
        __eflags = iset;
        if(__eflags == 0) {
            _t853 = reg->node + (i << 4);
            _t522 = m.t;
            _t792 = t;
            _v192 = _v68;
            _v196 = _t792;
            _v200 = _t522[0];
             *__esp =  *_t522;
            _t525 = __mulsc3(_t522[0], _t853, __eflags);
            _v120 = _t792;
            _t528 =  &(m.t[1]);
            _t795 = tnot;
            _v192 = _v76;
            _v196 = _t795;
            _v200 = _t528[0];
             *__esp =  *_t528;
            _t729 = __mulsc3(_t528[0], _t853, __eflags);
            _v160 = _t525;
            asm("fld dword [ebp+0xffffff64]");
            asm("fld dword [ebp-0x74]");
            _v160 = _t729;
            asm("fld dword [ebp+0xffffff64]");
            _v160 = _t795;
            asm("fld dword [ebp+0xffffff64]");
            asm("fxch st0, st1");
            asm("faddp st3, st0");
            asm("faddp st1, st0");
            asm("fxch st0, st1");
            asm("fstp dword [ebp+0xffffff64]");
            asm("fstp dword [ebp+0xffffff64]");
             *_t853 = _v160;
            _t853[1] = _v160;
        } else {
            _t859 = reg->node + (i << 4);
            _t660 =  &(m.t[2]);
            _t832 = tnot;
            _v192 = _v76;
            _v196 = _t832;
            _v200 = _t660[0];
             *__esp =  *_t660;
            _t663 = __mulsc3(_t660[0], _t859, __eflags);
            _v124 = _t832;
            _t666 =  &(m.t[3]);
            _t835 = t;
            _v192 = _v68;
            _v196 = _t835;
            _v200 = _t666[0];
             *__esp =  *_t666;
            _t729 = __mulsc3(_t666[0], _t859, __eflags);
            _v160 = _t663;
            asm("fld dword [ebp+0xffffff64]");
            asm("fld dword [ebp-0x78]");
            _v160 = _t729;
            asm("fld dword [ebp+0xffffff64]");
            _v160 = _t835;
            asm("fld dword [ebp+0xffffff64]");
            asm("fxch st0, st1");
            asm("faddp st3, st0");
            asm("faddp st1, st0");
            asm("fxch st0, st1");
            asm("fstp dword [ebp+0xffffff64]");
            asm("fstp dword [ebp+0xffffff64]");
             *_t859 = _v160;
            _t859[1] = _v160;
        }
        __eflags = j;
        if(j >= 0) {
            _t535 =  &(m.t[1]);
            _t798 =  *_t535;
            _t536 = _t535[0];
            _v160 = _t798;
            asm("fld dword [ebp+0xffffff64]");
            _v160 = _t536;
            asm("fld dword [ebp+0xffffff64]");
            asm("fldz ");
            asm("fucomp st2");
            asm("fnstsw ax");
            asm("fstp st1");
            asm("sahf ");
            _t730 = _t729 & _t536;
            asm("fldz ");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            __eflags = _t536 & _t798 & _t730 & 255;
            if((_t536 & _t798 & _t730 & 255) == 0) {
L41:
                _t540 =  &(m.t[2]);
                _t799 =  *_t540;
                _t541 = _t540[0];
                _v160 = _t799;
                asm("fld dword [ebp+0xffffff64]");
                _v160 = _t541;
                asm("fld dword [ebp+0xffffff64]");
                asm("fldz ");
                asm("fucomp st2");
                asm("fnstsw ax");
                asm("fstp st1");
                asm("sahf ");
                asm("fldz ");
                asm("fucompp ");
                asm("fnstsw ax");
                asm("sahf ");
                _t543 = _t541 & _t799 & _t730 & _t541;
                __eflags = _t543 & 255;
                if((_t543 & 255) == 0) {
L43:
                    _v108 = reg->node + (k << 4);
                    _t550 = reg->node + (i << 4);
                    _t854 =  *(_t550 + 8);
                    _t844 =  *(_t550 + 12);
                    _t732 = target;
                    _v172 = 1;
                    _v168 = 0;
                    _t803 = _v168;
                    asm("shld edx, eax, cl");
                    _t552 = _v172 << (_t732 & 255);
                    __eflags = _t732 & 0x20;
                    if((_t732 & 0x20) != 0) {
                        _t803 = _t552;
                        _t552 = 0;
                    }
                    _t734 = _v108;
                     *(_t734 + 8) = _t854 ^ _t552;
                     *(_t734 + 12) = _t844 ^ _t803;
                    __eflags = iset;
                    if(__eflags == 0) {
                        _t855 = reg->node + (k << 4);
                        _t559 =  &(m.t[2]);
                        _t808 = t;
                        _v192 = _v68;
                        _v196 = _t808;
                        _v200 = _t559[0];
                         *__esp =  *_t559;
                         *_t855 = __mulsc3(_t559[0], _t855, __eflags);
                         *(_t855 + 4) = _t808;
                    } else {
                        _t856 = reg->node + (k << 4);
                        _t570 =  &(m.t[1]);
                        _t812 = t;
                        _v192 = _v68;
                        _v196 = _t812;
                        _v200 = _t570[0];
                         *__esp =  *_t570;
                         *_t856 = __mulsc3(_t570[0], _t856, __eflags);
                         *(_t856 + 4) = _t812;
                    }
                    k = k + 1;
                    goto L49;
                }
                goto L42;
            }
            goto L40;
L42:
            __eflags = iset;
            if(iset == 0) {
                break;
            }
            goto L43;
L54:
            i = 0;
            j = 0;
            while(reg->size > i) {
                _t769 = reg->node + (i << 4);
                 *__esp =  *_t769;
                _v200 = _t769[1];
                quantum_prob_inline();
                asm("fld dword [ebp-0x38]");
                asm("fucompp ");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags <= 0) {
                    __eflags = j;
                    if(__eflags != 0) {
                        _t715 = reg->node + (i - j << 4);
                        _t599 = reg->node + (i << 4);
                         *((intOrPtr*)(_t715 + 8)) =  *((intOrPtr*)(_t599 + 8));
                         *((intOrPtr*)(_t715 + 12)) =  *((intOrPtr*)(_t599 + 12));
                        _t717 = reg->node + (i - j << 4);
                        _t608 = reg->node + (i << 4);
                         *_t717 =  *_t608;
                         *((intOrPtr*)(_t717 + 4)) =  *((intOrPtr*)(_t608 + 4));
                    }
                } else {
                    j = j + 1;
                    decsize = decsize + 1;
                }
                i = i + 1;
            }
            if(decsize != 0) {
                reg->size = reg->size - decsize;
                reg->node = realloc(reg->node, reg->size << 4);
                if(reg->node == 0) {
                    quantum_error(2);
                }
                quantum_memman( ~(decsize << 4));
            }
L65:
            quantum_decohere(reg);
            return;
        } else {
            __eflags = iset;
            if(__eflags == 0) {
                _t857 = reg->node + (j << 4);
                _t629 =  &(m.t[2]);
                _t816 = t;
                _v192 = _v68;
                _v196 = _t816;
                _v200 = _t629[0];
                 *__esp =  *_t629;
                _t632 = __mulsc3(_t629[0], _t857, __eflags);
                _v112 = _t816;
                _t635 =  &(m.t[3]);
                _t819 = tnot;
                _v192 = _v76;
                _v196 = _t819;
                _v200 = _t635[0];
                 *__esp =  *_t635;
                _t638 = __mulsc3(_t635[0], _t857, __eflags);
                _v160 = _t632;
                asm("fld dword [ebp+0xffffff64]");
                asm("fld dword [ebp-0x6c]");
                _v160 = _t638;
                asm("fld dword [ebp+0xffffff64]");
                _v160 = _t819;
                asm("fld dword [ebp+0xffffff64]");
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp+0xffffff64]");
                asm("fstp dword [ebp+0xffffff64]");
                 *_t857 = _v160;
                _t857[1] = _v160;
            } else {
                _t858 = reg->node + (j << 4);
                _t644 = m.t;
                _t824 = tnot;
                _v192 = _v76;
                _v196 = _t824;
                _v200 = _t644[0];
                 *__esp =  *_t644;
                _t647 = __mulsc3(_t644[0], _t858, __eflags);
                _v116 = _t824;
                _t650 =  &(m.t[1]);
                _t827 = t;
                _v192 = _v68;
                _v196 = _t827;
                _v200 = _t650[0];
                 *__esp =  *_t650;
                _t653 = __mulsc3(_t650[0], _t858, __eflags);
                _v160 = _t647;
                asm("fld dword [ebp+0xffffff64]");
                asm("fld dword [ebp-0x70]");
                _v160 = _t653;
                asm("fld dword [ebp+0xffffff64]");
                _v160 = _t827;
                asm("fld dword [ebp+0xffffff64]");
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp+0xffffff64]");
                asm("fstp dword [ebp+0xffffff64]");
                 *_t858 = _v160;
                _t858[1] = _v160;
            }
L49:
            __eflags = j;
            if(j < 0) {
                done[j] = 1;
            }
            goto L51;
        }
L40:
        __eflags = iset;
        if(iset != 0) {
            break;
        }
        goto L41;
    }
    reg->size = reg->size + addsize;
    free(done);
    quantum_memman( ~(reg->size));
    if(sorted != 0) {
        goto L65;
    }
    goto L54;
}

quantum_reconstruct_hash(quantum_reg* reg)
{// addr = 0x0804B509  --  defined in 'qureg.h' at line 159
    int i;                                 // _cfa_fffffff8
    quantum_reg* _v32;   // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    _unknown_ _t42;                        // _t42

    i = 0;
    while(1 << (reg->hashw & 255) > i) {
        reg->hash[i] = 0;
        i = i + 1;
    }
    i = 0;
    while(reg->size > i) {
        _t42 = reg->node + (i << 4);
        _v32 = reg;
        _v36 = i;
         *__esp =  *((intOrPtr*)(_t42 + 8));
        _v40 =  *((intOrPtr*)(_t42 + 12));
        quantum_add_hash();
        i = i + 1;
    }
    return;
}

quantum_add_hash(long long unsigned int a, int pos, quantum_reg* reg)
{// addr = 0x0804B58C  --  defined in 'qureg.h' at line 131
    int i;                                 // _cfa_fffffff8
    int mark;                              // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43

    _v28 = _a4;
    _v24 = _a8;
    mark = 0;
    _v36 = reg->hashw;
     *__esp = _v28;
    _v40 = _v24;
    i = quantum_hash64();
    while(reg->hash[i] != 0) {
    }
    reg->hash[i] = pos + 1;
    return;
}

unsigned int quantum_hash64(long long unsigned int key, int width)
{// addr = 0x0804B62B  --  defined in 'qureg.h' at line 91
    unsigned int k32;                      // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    _unknown_ _t19;                        // _t19
    _unknown_ _t24;                        // _t24
    _unknown_ _t27;                        // _t27
    _unknown_ _t30;                        // _t30

    _v28 = _a4;
    _v24 = _a8;
    k32 = _v24 ^ _v28;
    k32 = k32 * k32;
    k32 = k32 >> (32 - width & 255);
    return k32;
}

int quantum_get_state(long long unsigned int a, quantum_reg reg)
{// addr = 0x0804B66D  --  defined in 'qureg.h' at line 106
    int i;                                 // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ __ebp;                       // r6
    _unknown_ _t53;                        // _t53
    _unknown_ _t61;                        // _t61

    _v28 = _a4;
    _v24 = _a8;
    if(_a20 != 0) {
        _v44 = _a20;
         *__esp = _v28;
        _v48 = _v24;
        i = quantum_hash64();
L7:
        while( *((intOrPtr*)(_a28 + (i << 2))) != 0) {
            goto L3;
        }
        _v32 = -1;
        goto L9;
    }
    _v32 = _v28;
L9:
    return _v32;
L3:
    if(( *(_a24 +  ~(1 -  *((intOrPtr*)(_a28 + (i << 2))) << 4) + 8) ^ _v28 |  *(_a24 +  ~(1 -  *((intOrPtr*)(_a28 + (i << 2))) << 4) + 12) ^ _v24) != 0) {
        i = i + 1;
        if(1 << (_a20 & 255) == i) {
            i = 0;
        }
        goto L7;
    }
    _v32 =  *((intOrPtr*)(_a28 + (i << 2))) - 1;
    goto L9;
}

float quantum_prob_inline(complex float a)
{// addr = 0x0804B733  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t10;                            // _t10

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    asm("fstp dword [ebp-0x4]");
     *__esp = a;
    _t10 = _a8;
    _v24 = _t10;
    quantum_imag();
    asm("fstp dword [ebp-0x8]");
    asm("fld dword [ebp-0x4]");
    asm("fmul dword [ebp-0x4]");
    asm("fld dword [ebp-0x8]");
    asm("fmul dword [ebp-0x8]");
    asm("faddp st1, st0");
    return _t10;
}

float quantum_real(complex float a)
{// addr = 0x0804B773  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t7;                             // _t7

    p =  &a;
    _t7 =  *p;
    _v24 = _t7;
    asm("fld dword [ebp-0x14]");
    return _t7;
}

float quantum_imag(complex float a)
{// addr = 0x0804B78C  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t8;                             // _t8

    p =  &a;
    _t8 = p[1];
    _v24 = _t8;
    asm("fld dword [ebp-0x14]");
    return _t8;
}

quantum_gate2(int target1, int target2, quantum_matrix m, quantum_reg* reg)
{// addr = 0x0804B7A8  --  defined in 'gates.c' at line 451
    complex float[3] psi_sub;              // _cfa_ffffff8c
    int[3] base;                           // _cfa_ffffffac
    float limit;                           // _cfa_ffffffc8
    int i;                                 // _cfa_ffffffe0
    int j;                                 // _cfa_ffffffdc
    int k;                                 // _cfa_ffffffd8
    int l;                                 // _cfa_ffffffd4
    int addsize;                           // _cfa_ffffffd0
    int decsize;                           // _cfa_ffffffcc
    char* done;                            // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    int[1] bits;                           // _cfa_ffffffbc
    signed int _v148;                      // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    signed int _v156;                      // _cfa_ffffff64
    int _v192;                             // _cfa_ffffff40
    signed int _v200;                      // _cfa_ffffff38
    signed int _v204;                      // _cfa_ffffff34
    int _v208;                             // _cfa_ffffff30
    int _v212;                             // _cfa_ffffff2c
    int _v216;                             // _cfa_ffffff28
    int _v220;                             // _cfa_ffffff24
    int* _v228;                            // _cfa_ffffff1c
    quantum_reg_node* _v232;   // _cfa_ffffff18
    int _v236;                             // _cfa_ffffff14
    int _v240;                             // _cfa_ffffff10
    int _v244;                             // _cfa_ffffff0c
    signed int _v248;                      // _cfa_ffffff08
    char _v252;                            // _cfa_ffffff04
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t449;                       // _t449
    _unknown_ _t452;                       // _t452
    _unknown_ _t463;                       // _t463
    _unknown_ _t471;                       // _t471
    signed int _t473;                      // _t473
    int _t476;                             // _t476
    _unknown_ _t480;                       // _t480
    signed int _t482;                      // _t482
    int _t485;                             // _t485
    _unknown_ _t497;                       // _t497
    _unknown_ _t504;                       // _t504
    _unknown_ _t510;                       // _t510
    _unknown_ _t511;                       // _t511
    _unknown_ _t520;                       // _t520
    _unknown_ _t524;                       // _t524
    signed int _t525;                      // _t525
    signed int _t532;                      // _t532
    _unknown_ _t536;                       // _t536
    _unknown_ _t544;                       // _t544
    signed int _t546;                      // _t546
    _unknown_ _t554;                       // _t554
    signed int _t556;                      // _t556
    _unknown_ _t564;                       // _t564
    signed int _t566;                      // _t566
    signed int _t568;                      // _t568
    signed int _t575;                      // _t575
    intOrPtr* _t581;                       // _t581
    _unknown_ _t587;                       // _t587
    _unknown_ _t588;                       // _t588
    _unknown_ _t593;                       // _t593
    _unknown_ _t594;                       // _t594
    _unknown_ _t596;                       // _t596
    _unknown_ _t597;                       // _t597
    signed int* _t602;                     // _t602
    signed int _t603;                      // _t603
    int _t605;                             // _t605
    _unknown_ _t616;                       // _t616
    _unknown_ _t620;                       // _t620
    _unknown_ _t635;                       // _t635
    intOrPtr* _t644;                       // _t644
    _unknown_ _t661;                       // _t661
    quantum_reg* _t664;   // _t664
    quantum_reg* _t666;   // _t666
    quantum_reg* _t668;   // _t668
    quantum_reg* _t670;   // _t670
    signed int _t673;                      // _t673
    signed int _t680;                      // _t680
    signed int _t687;                      // _t687
    signed int _t694;                      // _t694
    _unknown_ _t696;                       // _t696
    intOrPtr* _t698;                       // _t698
    signed int _t700;                      // _t700
    signed int _t709;                      // _t709
    signed int _t718;                      // _t718
    signed int _t721;                      // _t721
    signed int _t724;                      // _t724
    _unknown_ _t727;                       // _t727
    signed int _t732;                      // _t732
    signed int _t736;                      // _t736
    int* _t744;                            // _t744
    int _t746;                             // _t746
    signed int* _t750;                     // _t750
    signed int _t768;                      // _t768
    signed int _t773;                      // _t773
    signed int _t778;                      // _t778
    signed int _t780;                      // _t780
    quantum_reg* _t781;   // _t781
    int* _t786;                            // _t786
    _unknown_ _t788;                       // _t788
    int _t791;                             // _t791
    signed int _t794;                      // _t794
    signed int _t795;                      // _t795
    signed int _t796;                      // _t796
    signed int _t797;                      // _t797
    signed int _t798;                      // _t798
    int* _t799;                            // _t799
    signed int _t800;                      // _t800
    signed int _t801;                      // _t801
    signed int _t802;                      // _t802
    signed int _t803;                      // _t803
    signed int _t804;                      // _t804
    signed int _t805;                      // _t805

    addsize = 0;
    decsize = 0;
    if(m.cols != 4 || m.rows != 4) {
        quantum_error(4);
    }
    i = 0;
    while(1 << (reg->hashw & 255) > i) {
        reg->hash[i] = 0;
        i = i + 1;
    }
    i = 0;
    while(reg->size > i) {
        _t463 = reg->node + (i << 4);
        _v240 = reg;
        _v244 = i;
         *__esp =  *(_t463 + 8);
        _v248 =  *(_t463 + 12);
        quantum_add_hash();
        i = i + 1;
    }
    i = 0;
    while(reg->size > i) {
        _t471 = reg->node + (i << 4);
        _t800 =  *(_t471 + 8);
        _t794 =  *(_t471 + 12);
        _t680 = target1;
        _v212 = 1;
        _v208 = 0;
        _t732 = _v208;
        asm("shld edx, eax, cl");
        _t473 = _v212 << (_t680 & 255);
        __eflags = _t680 & 0x20;
        if((_t680 & 0x20) != 0) {
            _t732 = _t473;
            _t473 = 0;
        }
        _t664 = reg;
        _v244 = _t664->width;
        _v240 = _t664->size;
        _v236 = _t664->hashw;
        _v232 = _t664->node;
        _v228 = _t664->hash;
         *__esp = _t800 ^ _t473;
        _v248 = _t794 ^ _t732;
        _t476 = quantum_get_state();
        __eflags = _t476 - 255;
        if(_t476 == 255) {
            addsize = addsize + 1;
        }
        _t480 = reg->node + (i << 4);
        _t801 =  *(_t480 + 8);
        _t795 =  *(_t480 + 12);
        _t687 = target2;
        _v212 = 1;
        _v208 = 0;
        _t736 = _v208;
        asm("shld edx, eax, cl");
        _t482 = _v212 << (_t687 & 255);
        __eflags = _t687 & 0x20;
        if((_t687 & 0x20) != 0) {
            _t736 = _t482;
            _t482 = 0;
        }
        _t666 = reg;
        _v244 = _t666->width;
        _v240 = _t666->size;
        _v236 = _t666->hashw;
        _v232 = _t666->node;
        _v228 = _t666->hash;
         *__esp = _t801 ^ _t482;
        _v248 = _t795 ^ _t736;
        _t485 = quantum_get_state();
        __eflags = _t485 - 255;
        if(_t485 == 255) {
            addsize = addsize + 1;
        }
        i = i + 1;
    }
    reg->node = realloc(reg->node, reg->size + addsize << 4);
    if(reg->node == 0) {
        quantum_error(4);
    }
    quantum_memman(addsize << 4);
    i = 0;
    while(i < addsize) {
        _t504 = reg->node + (reg->size + i << 4);
         *(_t504 + 8) = 0;
         *(_t504 + 12) = 0;
        _t744 = reg->node + (reg->size + i << 4);
         *_t744 = 0;
        _t744[1] = 0;
        i = i + 1;
    }
    done = calloc(reg->size + addsize, 1);
    if(done == 0) {
        quantum_error(4);
    }
    quantum_memman(reg->size + addsize);
    l = reg->size;
    _t694 = reg->width;
    _t746 = 0;
    asm("shld edx, eax, cl");
    _t525 = 1 << (_t694 & 255);
    if((_t694 & 0x20) != 0) {
        _t746 = _t525;
        _t525 = 0;
    }
    _push(_t746);
    _push(_t525);
    asm("fild qword [esp]");
    __esp =  &_v252;
    asm("fstp tword [ebp+0xffffff58]");
    if(_t746 < 0) {
        asm("fld tword [0x8054330]");
        asm("fld tword [ebp+0xffffff58]");
        asm("faddp st1, st0");
        asm("fstp tword [ebp+0xffffff58]");
    }
    asm("fld tword [ebp+0xffffff58]");
    asm("fstp qword [ebp-0x80]");
    asm("fld qword [ebp-0x80]");
    asm("fld1 ");
    asm("fdivrp st1, st0");
    asm("fld qword [0x8054348]");
    asm("fdivp st1, st0");
    asm("fstp dword [ebp-0x34]");
    bits = target1;
    _v64 = target2;
    i = 0;
    while(reg->size > i) {
        _t532 = done[i] & 255;
        __eflags = _t532 & 255;
        if((_t532 & 255) != 0) {
L52:
            i = i + 1;
            continue;
        }
        _t536 = reg->node + (i << 4);
        _v240 =  &bits;
        _v244 = 2;
         *__esp =  *(_t536 + 8);
        _v248 =  *(_t536 + 12);
        j = quantum_bitmask();
         *(__ebp + j * 4 - 80) = i;
        _v156 = j ^ 1;
        _t544 = reg->node + (i << 4);
        _t802 =  *(_t544 + 8);
        _t796 =  *(_t544 + 12);
        _t700 = target2;
        _v212 = 1;
        _v208 = 0;
        _t768 = _v208;
        asm("shld edx, eax, cl");
        _t546 = _v212 << (_t700 & 255);
        __eflags = _t700 & 0x20;
        if((_t700 & 0x20) != 0) {
            _t768 = _t546;
            _t546 = 0;
        }
        _t668 = reg;
        _v244 = _t668->width;
        _v240 = _t668->size;
        _v236 = _t668->hashw;
        _v232 = _t668->node;
        _v228 = _t668->hash;
         *__esp = _t802 ^ _t546;
        _v248 = _t796 ^ _t768;
         *(__ebp + _v156 * 4 - 80) = quantum_get_state();
        _v152 = j ^ 2;
        _t554 = reg->node + (i << 4);
        _t803 =  *(_t554 + 8);
        _t797 =  *(_t554 + 12);
        _t709 = target1;
        _v212 = 1;
        _v208 = 0;
        _t773 = _v208;
        asm("shld edx, eax, cl");
        _t556 = _v212 << (_t709 & 255);
        __eflags = _t709 & 0x20;
        if((_t709 & 0x20) != 0) {
            _t773 = _t556;
            _t556 = 0;
        }
        _t670 = reg;
        _v244 = _t670->width;
        _v240 = _t670->size;
        _v236 = _t670->hashw;
        _v232 = _t670->node;
        _v228 = _t670->hash;
         *__esp = _t803 ^ _t556;
        _v248 = _t797 ^ _t773;
         *(__ebp + _v152 * 4 - 80) = quantum_get_state();
        _v148 = j ^ 3;
        _t564 = reg->node + (i << 4);
        _t804 =  *(_t564 + 8);
        _t798 =  *(_t564 + 12);
        _t718 = target1;
        _v212 = 1;
        _v208 = 0;
        _t778 = _v208;
        asm("shld edx, eax, cl");
        _t566 = _v212 << (_t718 & 255);
        __eflags = _t718 & 0x20;
        if((_t718 & 0x20) != 0) {
            _t778 = _t566;
            _t566 = 0;
        }
        _t568 = _t804 ^ _t566;
        _t780 = _t798 ^ _t778;
        _v204 = target2;
        _v220 = 1;
        _v216 = 0;
        _t805 = _v216;
        _t721 = _v204 & 255;
        asm("shld esi, ebx, cl");
        _t673 = _v220 << (_t721 & 255);
        __eflags = _t721 & 0x20;
        if((_t721 & 0x20) != 0) {
            _t805 = _t673;
            _t673 = 0;
        }
        _v204 = _t673;
        _v200 = _t805;
        _t781 = reg;
        _v244 = _t781->width;
        _v240 = _t781->size;
        _v236 = _t781->hashw;
        _v232 = _t781->node;
        _v228 = _t781->hash;
         *__esp = _v204 ^ _t568;
        _v248 = _v200 ^ _t780;
         *(__ebp + _v148 * 4 - 80) = quantum_get_state();
        j = 0;
        while(1) {
            __eflags = j - 3;
            if(j > 3) {
                break;
            }
            _t575 = j;
            __eflags =  *((intOrPtr*)(__ebp + _t575 * 4 - 80)) - 255;
            if( *((intOrPtr*)(__ebp + _t575 * 4 - 80)) == 255) {
                 *(__ebp + j * 4 - 80) = l;
                l = l + 1;
            }
            _t724 = j;
            _t581 = reg->node + ( *(__ebp + j * 4 - 80) << 4);
             *((intOrPtr*)(__ebp + _t724 * 8 - 112)) =  *_t581;
             *((intOrPtr*)(__ebp + _t724 * 8 - 108)) =  *((intOrPtr*)(_t581 + 4));
            j = j + 1;
        }
        j = 0;
        while(1) {
            __eflags = j - 3;
            if(j > 3) {
                break;
            }
            _t786 = reg->node + ( *(__ebp + j * 4 - 80) << 4);
             *_t786 = 0;
            _t786[1] = 0;
            k = 0;
            while(1) {
                __eflags = k - 3;
                if(__eflags > 0) {
                    break;
                }
                _t799 = reg->node + ( *(__ebp + j * 4 - 80) << 4);
                asm("fld dword [eax]");
                asm("fstp dword [ebp+0xffffff78]");
                asm("fld dword [eax+0x4]");
                asm("fstp dword [ebp+0xffffff74]");
                _t602 = m.t + (m.cols * j + k << 3);
                _t603 = k;
                _t791 =  *(__ebp + _t603 * 8 - 112);
                _v240 =  *(__ebp + _t603 * 8 - 108);
                _v244 = _t791;
                _v248 = _t602[1];
                 *__esp =  *_t602;
                _t605 = __mulsc3(_t602[1],  *_t602, __eflags);
                asm("fld dword [ebp+0xffffff78]");
                asm("fld dword [ebp+0xffffff74]");
                _v192 = _t605;
                asm("fld dword [ebp+0xffffff44]");
                _v192 = _t791;
                asm("fld dword [ebp+0xffffff44]");
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp+0xffffff44]");
                asm("fstp dword [ebp+0xffffff44]");
                 *_t799 = _v192;
                _t799[1] = _v192;
                k = k + 1;
            }
            done[ *(__ebp + j * 4 - 80)] = 1;
            j = j + 1;
        }
        goto L52;
    }
    reg->size = reg->size + addsize;
    free(done);
    quantum_memman( ~(reg->size));
    i = 0;
    j = 0;
    while(reg->size > i) {
        _t750 = reg->node + (i << 4);
         *__esp =  *_t750;
        _v248 = _t750[1];
        quantum_prob_inline();
        asm("fld dword [ebp-0x34]");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags <= 0) {
            __eflags = j;
            if(__eflags != 0) {
                _t696 = reg->node + (i - j << 4);
                _t635 = reg->node + (i << 4);
                 *((intOrPtr*)(_t696 + 8)) =  *((intOrPtr*)(_t635 + 8));
                 *((intOrPtr*)(_t696 + 12)) =  *((intOrPtr*)(_t635 + 12));
                _t698 = reg->node + (i - j << 4);
                _t644 = reg->node + (i << 4);
                 *_t698 =  *_t644;
                 *((intOrPtr*)(_t698 + 4)) =  *((intOrPtr*)(_t644 + 4));
            }
        } else {
            j = j + 1;
            decsize = decsize + 1;
        }
        i = i + 1;
    }
    if(decsize != 0) {
        reg->size = reg->size - decsize;
        reg->node = realloc(reg->node, reg->size << 4);
        if(reg->node == 0) {
            quantum_error(2);
        }
        quantum_memman( ~(decsize << 4));
    }
    quantum_decohere(reg);
    return;
}

int quantum_bitmask(long long unsigned int a, int width, int* bits)
{// addr = 0x0804C059  --  defined in 'qureg.h' at line 172
    int i;                                 // _cfa_fffffff8
    int mask;                              // _cfa_fffffff4
    unsigned int _v24;                     // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    signed int _t35;                       // _t35
    _unknown_ _t37;                        // _t37
    signed int _t40;                       // _t40
    signed int _t43;                       // _t43
    _unknown_ _t44;                        // _t44

    _v28 = _a4;
    _v24 = _a8;
    mask = 0;
    i = 0;
    while(i < width) {
        _t40 = bits[i];
        _t35 = _v28;
        asm("shrd eax, edx, cl");
        _t43 = _v24 >> (_t40 & 255);
        if((_t40 & 0x20) != 0) {
            _t35 = _t43;
        }
        if((_t35 & 1) != 0) {
            mask = mask + (1 << (i & 255));
        }
        i = i + 1;
    }
    return mask;
}

quantum_hadamard(int target, quantum_reg* reg)
{// addr = 0x0804C0BF  --  defined in 'gates.c' at line 596
    int _v16;                              // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    quantum_matrix m;   // _cfa_ffffffe8
    int _v36;                              // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    quantum_reg* _v64;   // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39
    _unknown_ _t40;                        // _t40
    _unknown_ _t42;                        // _t42
    _unknown_ _t43;                        // _t43
    _unknown_ _t45;                        // _t45
    _unknown_ _t46;                        // _t46
    _unknown_ _t48;                        // _t48
    _unknown_ _t49;                        // _t49
    int _t56;                              // _t56
    intOrPtr* _t57;                        // _t57
    intOrPtr* _t58;                        // _t58
    intOrPtr* _t59;                        // _t59

    _v72 = target;
    if(quantum_objcode_put(6) == 0) {
        _v68 = 2;
        quantum_new_matrix( &_v44, 2);
        __esp = __esp - 4;
        m.rows = _v44;
        _v20 = _v40;
        _v16 = _v36;
        _t56 = _v16;
         *_t56 = 1060439283;
         *((intOrPtr*)(_t56 + 4)) = 0;
        _t57 = _v16 + 8;
         *_t57 = 1060439283;
         *((intOrPtr*)(_t57 + 4)) = 0;
        _t58 = _v16 + 16;
         *_t58 = 1060439283;
         *((intOrPtr*)(_t58 + 4)) = 0;
        _t59 = _v16 + 24;
         *_t59 = -1087044365;
         *((intOrPtr*)(_t59 + 4)) = 0;
        _v64 = reg;
        _v76 = m.rows;
        _v72 = _v20;
        _v68 = _v16;
         *__esp = target;
        quantum_gate1();
        quantum_delete_matrix( &(m.rows));
        return;
    }
    return;
}

quantum_walsh(int width, quantum_reg* reg)
{// addr = 0x0804C195  --  defined in 'gates.c' at line 617
    int i;                                 // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    i = 0;
    while(i < width) {
        quantum_hadamard(i, reg);
        i = i + 1;
    }
    return;
}

quantum_r_x(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C1C4  --  defined in 'gates.c' at line 629
    _unknown_ _v8;                         // _cfa_fffffff8
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    quantum_matrix m;   // _cfa_ffffffe8
    intOrPtr* _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    char _v68;                             // _cfa_ffffffbc
    intOrPtr _v80;                         // _cfa_ffffffb0
    int _v132;                             // _cfa_ffffff7c
    int _v136;                             // _cfa_ffffff78
    intOrPtr _v140;                        // _cfa_ffffff74
    intOrPtr _v144;                        // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    _unknown_ __ebp;                       // r6
    _unknown_ _t51;                        // _t51
    _unknown_ _t55;                        // _t55
    _unknown_ _t65;                        // _t65
    intOrPtr* _t66;                        // _t66
    intOrPtr* _t67;                        // _t67
    intOrPtr* _t68;                        // _t68
    intOrPtr* _t69;                        // _t69
    _unknown_ _t70;                        // _t70
    _unknown_ _t73;                        // _t73

    _push(__ebx);
    __esp = __esp - 132;
    asm("fld dword [ebp+0xc]");
    asm("fstp qword [esp+0x8]");
    _v136 = target;
    __eflags = quantum_objcode_put(7);
    if(__eflags == 0) {
        _v132 = 2;
        quantum_new_matrix( &_v44, 2);
        __esp = __esp - 4;
        m.rows = _v44;
        _v20 = _v40;
        _v16 = _v36;
        _t66 = _v16;
        asm("fld dword [ebp+0xc]");
        asm("fld dword [0x8054350]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        cos();
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fstp dword [ebp-0x4c]");
         *_t66 = _v80;
         *((intOrPtr*)(_t66 + 4)) = 0;
        _t67 = _v16 + 8;
        asm("fld dword [ebp+0xc]");
        asm("fld dword [0x8054350]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        sin();
        asm("fldz ");
        asm("fld1 ");
        asm("fchs ");
        asm("fstp qword [esp+0x1c]");
        asm("fldz ");
        asm("fstp qword [esp+0x14]");
        asm("fstp qword [esp+0xc]");
        asm("fstp qword [esp+0x4]");
        __muldc3(__esi, __eflags,  &_v68);
        asm("fld qword [ebp-0x40]");
        asm("fld qword [ebp-0x38]");
        asm("fxch st0, st1");
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fxch st0, st1");
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fxch st0, st1");
        asm("fstp dword [ebp-0x4c]");
        asm("fstp dword [ebp-0x4c]");
         *_t67 = _v80;
         *((intOrPtr*)(_t67 + 4)) = _v80;
        _t68 = _v16 + 16;
        asm("fld dword [ebp+0xc]");
        asm("fld dword [0x8054350]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        sin();
        asm("fldz ");
        asm("fld1 ");
        asm("fchs ");
        asm("fstp qword [esp+0x1c]");
        asm("fldz ");
        asm("fstp qword [esp+0x14]");
        asm("fstp qword [esp+0xc]");
        asm("fstp qword [esp+0x4]");
        __muldc3(__esi, __eflags,  &_v68);
        asm("fld qword [ebp-0x40]");
        asm("fld qword [ebp-0x38]");
        asm("fxch st0, st1");
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fxch st0, st1");
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fxch st0, st1");
        asm("fstp dword [ebp-0x4c]");
        asm("fstp dword [ebp-0x4c]");
         *_t68 = _v80;
         *((intOrPtr*)(_t68 + 4)) = _v80;
        _t69 = _v16 + 24;
        asm("fld dword [ebp+0xc]");
        asm("fld dword [0x8054350]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        cos();
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fstp dword [ebp-0x4c]");
         *_t69 = _v80;
         *((intOrPtr*)(_t69 + 4)) = 0;
        _v136 = reg;
        _v148 = m.rows;
        _v144 = _v20;
        _v140 = _v16;
         *__esp = target;
        quantum_gate1();
        _t43 =  &(m.rows);
        quantum_delete_matrix( &(m.rows));
    }
    return;
}

quantum_r_y(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C382  --  defined in 'gates.c' at line 650
    _unknown_ _v8;                         // _cfa_fffffff8
    int _v16;                              // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    quantum_matrix m;   // _cfa_ffffffe8
    int _v36;                              // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v64;                         // _cfa_ffffffc0
    quantum_reg* _v96;   // _cfa_ffffffa0
    int _v100;                             // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    _unknown_ __ebp;                       // r6
    _unknown_ _t57;                        // _t57
    int _t58;                              // _t58
    intOrPtr* _t59;                        // _t59
    intOrPtr* _t60;                        // _t60
    intOrPtr* _t61;                        // _t61
    _unknown_ _t62;                        // _t62
    _unknown_ _t63;                        // _t63
    _unknown_ _t64;                        // _t64
    _unknown_ _t65;                        // _t65

    _push(__ebx);
    __esp = __esp - 100;
    asm("fld dword [ebp+0xc]");
    asm("fstp qword [esp+0x8]");
    _v104 = target;
    if(quantum_objcode_put(8) == 0) {
        _v100 = 2;
        quantum_new_matrix( &_v44, 2);
        __esp = __esp - 4;
        m.rows = _v44;
        _v20 = _v40;
        _v16 = _v36;
        _t58 = _v16;
        asm("fld dword [ebp+0xc]");
        asm("fld dword [0x8054350]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        cos();
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fstp dword [ebp-0x3c]");
         *_t58 = _v64;
         *((intOrPtr*)(_t58 + 4)) = 0;
        _t59 = _v16 + 8;
        asm("fld dword [ebp+0xc]");
        asm("fld dword [0x8054354]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        sin();
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fstp dword [ebp-0x3c]");
         *_t59 = _v64;
         *((intOrPtr*)(_t59 + 4)) = 0;
        _t60 = _v16 + 16;
        asm("fld dword [ebp+0xc]");
        asm("fld dword [0x8054350]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        sin();
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fstp dword [ebp-0x3c]");
         *_t60 = _v64;
         *((intOrPtr*)(_t60 + 4)) = 0;
        _t61 = _v16 + 24;
        asm("fld dword [ebp+0xc]");
        asm("fld dword [0x8054350]");
        asm("fdivp st1, st0");
        asm("fstp qword [esp]");
        cos();
        asm("fstp dword [ebp-0x2c]");
        asm("fld dword [ebp-0x2c]");
        asm("fstp dword [ebp-0x3c]");
         *_t61 = _v64;
         *((intOrPtr*)(_t61 + 4)) = 0;
        _v96 = reg;
        _v108 = m.rows;
        _v104 = _v20;
        _v100 = _v16;
         *__esp = target;
        quantum_gate1();
        _t39 =  &(m.rows);
        quantum_delete_matrix( &(m.rows));
    }
    return;
}

quantum_r_z(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C4CB  --  defined in 'gates.c' at line 671
    int i;                                 // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    intOrPtr _v32;                         // _cfa_ffffffe0
    complex float _v36;                    // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t57;                        // _t57
    _unknown_ _t67;                        // _t67
    signed int _t68;                       // _t68
    intOrPtr* _t76;                        // _t76
    intOrPtr* _t87;                        // _t87
    signed int _t99;                       // _t99
    intOrPtr _t104;                        // _t104
    signed int _t108;                      // _t108
    complex float _t112;                   // _t112
    complex float _t117;                   // _t117
    _unknown_ _t119;                       // _t119
    _unknown_ _t120;                       // _t120
    intOrPtr* _t121;                       // _t121
    intOrPtr* _t122;                       // _t122

    _t104 = __edx;
    asm("fld dword [ebp+0xc]");
    asm("fstp qword [esp+0x8]");
    _v40 = target;
    if(quantum_objcode_put(9) == 0) {
        asm("fld dword [ebp+0xc]");
        asm("fld dword [0x8054350]");
        asm("fdivp st1, st0");
        asm("fstp dword [esp]");
        z = quantum_cexp();
        _v20 = _t104;
        i = 0;
        while(reg->size > i) {
            _t67 = reg->node + (i << 4);
            _t68 =  *(_t67 + 8);
            _t99 = target;
            asm("shrd eax, edx, cl");
            _t108 =  *(_t67 + 12) >> (_t99 & 255);
            __eflags = _t99 & 0x20;
            if((_t99 & 0x20) != 0) {
                _t68 = _t108;
            }
            __eflags = _t68 & 1;
            if(__eflags == 0) {
                _t121 = reg->node + (i << 4);
                _t76 = reg->node + (i << 4);
                _t112 = z;
                _v32 = _v20;
                _v36 = _t112;
                _v40 =  *(_t76 + 4);
                 *__esp =  *_t76;
                 *_t121 = __divsc3( *(_t76 + 4), _t121, __eflags);
                 *(_t121 + 4) = _t112;
            } else {
                _t122 = reg->node + (i << 4);
                _t87 = reg->node + (i << 4);
                _t117 = z;
                _v32 = _v20;
                _v36 = _t117;
                _v40 =  *(_t87 + 4);
                 *__esp =  *_t87;
                 *_t122 = __mulsc3( *(_t87 + 4), _t122, __eflags);
                 *(_t122 + 4) = _t117;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
    return;
}

quantum_phase_scale(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C612  --  defined in 'gates.c' at line 695
    int i;                                 // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    intOrPtr _v32;                         // _cfa_ffffffe0
    complex float _v36;                    // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t28;                        // _t28
    intOrPtr* _t42;                        // _t42
    intOrPtr _t54;                         // _t54
    complex float _t59;                    // _t59
    _unknown_ _t61;                        // _t61
    intOrPtr* _t62;                        // _t62

    _t54 = __edx;
    asm("fld dword [ebp+0xc]");
    asm("fstp qword [esp+0x8]");
    _v40 = target;
    if(quantum_objcode_put(11) == 0) {
        z = quantum_cexp(gamma);
        _v20 = _t54;
        i = 0;
        while(reg->size > i) {
            _t62 = reg->node + (i << 4);
            _t42 = reg->node + (i << 4);
            _t59 = z;
            _v32 = _v20;
            _v36 = _t59;
            _v40 =  *(_t42 + 4);
             *__esp =  *_t42;
             *_t62 = __mulsc3( *(_t42 + 4), _t62, __eflags);
             *(_t62 + 4) = _t59;
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
    return;
}

quantum_phase_kick(int target, float gamma, quantum_reg* reg)
{// addr = 0x0804C6CD  --  defined in 'gates.c' at line 717
    int i;                                 // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    intOrPtr _v32;                         // _cfa_ffffffe0
    complex float _v36;                    // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43
    _unknown_ _t54;                        // _t54
    signed int _t55;                       // _t55
    intOrPtr* _t63;                        // _t63
    signed int _t73;                       // _t73
    intOrPtr _t76;                         // _t76
    signed int _t80;                       // _t80
    complex float _t84;                    // _t84
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87
    intOrPtr* _t88;                        // _t88

    _t76 = __edx;
    asm("fld dword [ebp+0xc]");
    asm("fstp qword [esp+0x8]");
    _v40 = target;
    if(quantum_objcode_put(10) == 0) {
        z = quantum_cexp(gamma);
        _v20 = _t76;
        i = 0;
        while(reg->size > i) {
            _t54 = reg->node + (i << 4);
            _t55 =  *(_t54 + 8);
            _t73 = target;
            asm("shrd eax, edx, cl");
            _t80 =  *(_t54 + 12) >> (_t73 & 255);
            __eflags = _t73 & 0x20;
            if((_t73 & 0x20) != 0) {
                _t55 = _t80;
            }
            __eflags = _t55 & 1;
            if(__eflags != 0) {
                _t88 = reg->node + (i << 4);
                _t63 = reg->node + (i << 4);
                _t84 = z;
                _v32 = _v20;
                _v36 = _t84;
                _v40 =  *(_t63 + 4);
                 *__esp =  *_t63;
                 *_t88 = __mulsc3( *(_t63 + 4), _t88, __eflags);
                 *(_t88 + 4) = _t84;
            }
            i = i + 1;
        }
        quantum_decohere(reg);
        return;
    }
    return;
}

quantum_cond_phase(int control, int target, quantum_reg* reg)
{// addr = 0x0804C7B9  --  defined in 'gates.c' at line 739
    int i;                                 // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    int _v64;                              // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    char _v76;                             // _cfa_ffffffb4
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t68;                        // _t68
    _unknown_ _t73;                        // _t73
    signed int _t74;                       // _t74
    _unknown_ _t82;                        // _t82
    signed int _t83;                       // _t83
    signed int _t84;                       // _t84
    _unknown_ _t88;                        // _t88
    signed int _t89;                       // _t89
    intOrPtr* _t97;                        // _t97
    signed int _t107;                      // _t107
    signed int _t109;                      // _t109
    signed int _t110;                      // _t110
    _unknown_ _t113;                       // _t113
    int _t115;                             // _t115
    signed int _t119;                      // _t119
    signed int _t122;                      // _t122
    complex float _t126;                   // _t126
    _unknown_ _t128;                       // _t128
    _unknown_ _t129;                       // _t129
    _unknown_ _t130;                       // _t130
    intOrPtr* _t131;                       // _t131

    _v68 = target;
    _v72 = control;
    if(quantum_objcode_put(12) != 0) {
        return;
    }
    _t107 = control - target;
    _t115 = 0;
    asm("shld edx, eax, cl");
    _t74 = 1 << (_t107 & 255);
    if((_t107 & 0x20) != 0) {
        _t115 = _t74;
        _t74 = 0;
    }
    _push(_t115);
    _push(_t74);
    asm("fild qword [esp]");
    __esp =  &_v76;
    asm("fstp tword [ebp-0x38]");
    if(_t115 < 0) {
        asm("fld tword [0x8054330]");
        asm("fld tword [ebp-0x38]");
        asm("faddp st1, st0");
        asm("fstp tword [ebp-0x38]");
    }
    asm("fld tword [ebp-0x38]");
    asm("fstp qword [ebp-0x20]");
    asm("fld qword [ebp-0x20]");
    asm("fld qword [0x8054358]");
    asm("fdivrp st1, st0");
    asm("fstp dword [ebp-0x24]");
    asm("fld dword [ebp-0x24]");
    asm("fstp dword [esp]");
    z = quantum_cexp();
    _v20 = _t115;
    i = 0;
    while(reg->size > i) {
        _t82 = reg->node + (i << 4);
        _t83 =  *(_t82 + 8);
        _t109 = control;
        asm("shrd eax, edx, cl");
        _t119 =  *(_t82 + 12) >> (_t109 & 255);
        __eflags = _t109 & 0x20;
        if((_t109 & 0x20) != 0) {
            _t83 = _t119;
        }
        _t84 = _t83 & 1;
        __eflags = _t84 & 255;
        if((_t84 & 255) != 0) {
            _t88 = reg->node + (i << 4);
            _t89 =  *(_t88 + 8);
            _t110 = target;
            asm("shrd eax, edx, cl");
            _t122 =  *(_t88 + 12) >> (_t110 & 255);
            __eflags = _t110 & 0x20;
            if((_t110 & 0x20) != 0) {
                _t89 = _t122;
            }
            __eflags = _t89 & 1;
            if(__eflags != 0) {
                _t131 = reg->node + (i << 4);
                _t97 = reg->node + (i << 4);
                _t126 = z;
                _v64 = _v20;
                _v68 = _t126;
                _v72 =  *(_t97 + 4);
                 *__esp =  *_t97;
                 *_t131 = __mulsc3( *(_t97 + 4), _t131, __eflags);
                 *(_t131 + 4) = _t126;
            }
        }
        i = i + 1;
    }
    quantum_decohere(reg);
    return;
}

quantum_cond_phase_inv(int control, int target, quantum_reg* reg)
{// addr = 0x0804C929  --  defined in 'gates.c' at line 763
    int i;                                 // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    int _v64;                              // _cfa_ffffffc0
    complex float _v68;                    // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    char _v76;                             // _cfa_ffffffb4
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t64;                        // _t64
    _unknown_ _t66;                        // _t66
    signed int _t67;                       // _t67
    _unknown_ _t75;                        // _t75
    signed int _t76;                       // _t76
    signed int _t77;                       // _t77
    _unknown_ _t81;                        // _t81
    signed int _t82;                       // _t82
    intOrPtr* _t90;                        // _t90
    signed int _t100;                      // _t100
    signed int _t102;                      // _t102
    signed int _t103;                      // _t103
    _unknown_ _t106;                       // _t106
    int _t108;                             // _t108
    signed int _t112;                      // _t112
    signed int _t115;                      // _t115
    complex float _t119;                   // _t119
    _unknown_ _t121;                       // _t121
    _unknown_ _t122;                       // _t122
    _unknown_ _t123;                       // _t123
    intOrPtr* _t124;                       // _t124

    _t100 = control - target;
    _t108 = 0;
    asm("shld edx, eax, cl");
    _t67 = 1 << (_t100 & 255);
    if((_t100 & 0x20) != 0) {
        _t108 = _t67;
        _t67 = 0;
    }
    _push(_t108);
    _push(_t67);
    asm("fild qword [esp]");
    __esp =  &_v76;
    asm("fstp tword [ebp-0x38]");
    if(_t108 < 0) {
        asm("fld tword [0x8054330]");
        asm("fld tword [ebp-0x38]");
        asm("faddp st1, st0");
        asm("fstp tword [ebp-0x38]");
    }
    asm("fld tword [ebp-0x38]");
    asm("fstp qword [ebp-0x20]");
    asm("fld qword [ebp-0x20]");
    asm("fld qword [0x8054360]");
    asm("fdivrp st1, st0");
    asm("fstp dword [ebp-0x24]");
    asm("fld dword [ebp-0x24]");
    asm("fstp dword [esp]");
    z = quantum_cexp();
    _v20 = _t108;
    i = 0;
    while(reg->size > i) {
        _t75 = reg->node + (i << 4);
        _t76 =  *(_t75 + 8);
        _t102 = control;
        asm("shrd eax, edx, cl");
        _t112 =  *(_t75 + 12) >> (_t102 & 255);
        __eflags = _t102 & 0x20;
        if((_t102 & 0x20) != 0) {
            _t76 = _t112;
        }
        _t77 = _t76 & 1;
        __eflags = _t77 & 255;
        if((_t77 & 255) != 0) {
            _t81 = reg->node + (i << 4);
            _t82 =  *(_t81 + 8);
            _t103 = target;
            asm("shrd eax, edx, cl");
            _t115 =  *(_t81 + 12) >> (_t103 & 255);
            __eflags = _t103 & 0x20;
            if((_t103 & 0x20) != 0) {
                _t82 = _t115;
            }
            __eflags = _t82 & 1;
            if(__eflags != 0) {
                _t124 = reg->node + (i << 4);
                _t90 = reg->node + (i << 4);
                _t119 = z;
                _v64 = _v20;
                _v68 = _t119;
                _v72 =  *((intOrPtr*)(_t90 + 4));
                 *__esp =  *_t90;
                 *_t124 = __mulsc3( *((intOrPtr*)(_t90 + 4)), _t124, __eflags);
                 *(_t124 + 4) = _t119;
            }
        }
        i = i + 1;
    }
    quantum_decohere(reg);
    return;
}

quantum_cond_phase_kick(int control, int target, float gamma, quantum_reg* reg)
{// addr = 0x0804CA77  --  defined in 'gates.c' at line 784
    int i;                                 // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    complex float z;                       // _cfa_ffffffe8
    intOrPtr _v48;                         // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t60;                        // _t60
    _unknown_ _t72;                        // _t72
    signed int _t73;                       // _t73
    signed int _t74;                       // _t74
    _unknown_ _t78;                        // _t78
    signed int _t79;                       // _t79
    intOrPtr* _t87;                        // _t87
    signed int _t97;                       // _t97
    signed int _t98;                       // _t98
    intOrPtr _t101;                        // _t101
    signed int _t105;                      // _t105
    signed int _t108;                      // _t108
    complex float _t112;                   // _t112
    _unknown_ _t114;                       // _t114
    _unknown_ _t115;                       // _t115
    _unknown_ _t116;                       // _t116
    intOrPtr* _t117;                       // _t117

    _t101 = __edx;
    asm("fld dword [ebp+0x10]");
    asm("fstp qword [esp+0xc]");
    _v52 = target;
    _v56 = control;
    if(quantum_objcode_put(12) != 0) {
        return;
    }
    z = quantum_cexp(gamma);
    _v20 = _t101;
    i = 0;
    while(reg->size > i) {
        _t72 = reg->node + (i << 4);
        _t73 =  *(_t72 + 8);
        _t97 = control;
        asm("shrd eax, edx, cl");
        _t105 =  *(_t72 + 12) >> (_t97 & 255);
        __eflags = _t97 & 0x20;
        if((_t97 & 0x20) != 0) {
            _t73 = _t105;
        }
        _t74 = _t73 & 1;
        __eflags = _t74 & 255;
        if((_t74 & 255) != 0) {
            _t78 = reg->node + (i << 4);
            _t79 =  *(_t78 + 8);
            _t98 = target;
            asm("shrd eax, edx, cl");
            _t108 =  *(_t78 + 12) >> (_t98 & 255);
            __eflags = _t98 & 0x20;
            if((_t98 & 0x20) != 0) {
                _t79 = _t108;
            }
            __eflags = _t79 & 1;
            if(__eflags != 0) {
                _t117 = reg->node + (i << 4);
                _t87 = reg->node + (i << 4);
                _t112 = z;
                _v48 = _v20;
                _v52 = _t112;
                _v56 =  *(_t87 + 4);
                 *__esp =  *_t87;
                 *_t117 = __mulsc3( *(_t87 + 4), _t117, __eflags);
                 *(_t117 + 4) = _t112;
            }
        }
        i = i + 1;
    }
    quantum_decohere(reg);
    return;
}

int quantum_gate_counter(int inc)
{// addr = 0x0804CB9A  --  defined in 'gates.c' at line 810
    _unknown_ __ebp;                       // r6

    if(inc <= 0) {
        if(inc < 0) {
            counter = 0;
        }
    } else {
        counter = counter + inc;
    }
    return counter;
}

long unsigned int quantum_memman(long int change)
{// addr = 0x0804CBCC  --  defined in 'matrix.c' at line 35
    _unknown_ __ebp;                       // r6

    mem = mem + change;
    if(mem > max) {
        max = mem;
    }
    return mem;
}

quantum_matrix quantum_new_matrix(int cols, int rows)
{// addr = 0x0804CBFC  --  defined in 'matrix.c' at line 50
    void* _v8;            // _cfa_fffffff8
    int _v12;                              // _cfa_fffffff4
    quantum_matrix m;   // _cfa_fffffff0
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t30;                        // _t30

    m.rows = rows;
    _v12 = cols;
    _v8 = calloc(cols * rows, 8);
    if(_v8 == 0) {
        quantum_error(2);
    }
    quantum_memman(rows * cols << 3);
     *(_a4.rows) = m.rows;
     *(_a4.rows + 4) = _v12;
     *(_a4.rows + 8) = _v8;
    return _a4;
}

quantum_delete_matrix(quantum_matrix* m)
{// addr = 0x0804CC70  --  defined in 'matrix.c' at line 74
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    _unknown_ _t18;                        // _t18

    free(m->t);
    quantum_memman( ~(m->rows * m->cols << 3));
    m->t = 0;
    return;
}

quantum_print_matrix(quantum_matrix m)
{// addr = 0x0804CCAD  --  defined in 'matrix.c' at line 90
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int z;                                 // _cfa_fffffff0
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t36;                        // _t36
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54
    _unknown_ _t55;                        // _t55
    intOrPtr* _t58;                        // _t58
    intOrPtr* _t60;                        // _t60

    z = 0;
    while(1) {
        z = z + 1;
        if((m.rows & 255) == 0) {
            break;
        }
    }
    z = z - 1;
    i = 0;
    while(m.rows > i) {
        j = 0;
        while(m.cols > j) {
            _t58 = m.t + (m.cols * i + j << 3);
             *__esp =  *_t58;
            _v56 =  *((intOrPtr*)(_t58 + 4));
            quantum_imag();
            asm("fstp qword [ebp-0x18]");
            _t60 = m.t + (m.cols * i + j << 3);
             *__esp =  *_t60;
            _v56 =  *((intOrPtr*)(_t60 + 4));
            quantum_real();
            asm("fld qword [ebp-0x18]");
            asm("fstp qword [esp+0xc]");
            asm("fstp qword [esp+0x4]");
            printf("%g %+gi ");
            j = j + 1;
        }
        putchar(10);
        i = i + 1;
    }
    putchar(10);
    return;
}

float quantum_imag(complex float a)
{// addr = 0x0804CD85  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t8;                             // _t8

    p =  &a;
    _t8 = p[1];
    _v24 = _t8;
    asm("fld dword [ebp-0x14]");
    return _t8;
}

float quantum_real(complex float a)
{// addr = 0x0804CDA1  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t7;                             // _t7

    p =  &a;
    _t7 =  *p;
    _v24 = _t7;
    asm("fld dword [ebp-0x14]");
    return _t7;
}

quantum_matrix quantum_mmult(quantum_matrix A, quantum_matrix B)
{// addr = 0x0804CDBA  --  defined in 'matrix.c' at line 117
    char _v16;                             // _cfa_fffffff0
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    int k;                                 // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    quantum_matrix C;   // _cfa_ffffffd8
    intOrPtr _v56;                         // _cfa_ffffffc8
    int _v68;                              // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t64;                        // _t64
    intOrPtr* _t88;                        // _t88
    intOrPtr _t90;                         // _t90
    _unknown_ _t103;                       // _t103
    intOrPtr _t110;                        // _t110
    _unknown_ _t116;                       // _t116
    intOrPtr* _t117;                       // _t117

    __esp = __esp - 60;
    if(A.cols != B.rows) {
        quantum_error(4);
    }
    _v68 = A.rows;
    quantum_new_matrix( &(C.rows), B.cols);
    __esp = __esp - 4;
    i = 0;
    while(B.cols > i) {
        j = 0;
        while(1) {
            __eflags = A.rows - j;
            if(A.rows <= j) {
                break;
            }
            k = 0;
            while(1) {
                __eflags = B.rows - k;
                if(__eflags <= 0) {
                    break;
                }
                _t117 = _v32 + (_v36 * j + i << 3);
                asm("fld dword [eax+0x4]");
                asm("fstp dword [ebp-0x30]");
                asm("fld dword [eax+0x4]");
                _t88 = B.t + (B.cols * k + i << 3);
                _t110 =  *_t88;
                asm("fstp dword [ebp-0x34]");
                _v68 =  *(_t88 + 4);
                _v72 = _t110;
                _v76 = _v56;
                 *__esp =  *((intOrPtr*)(A.t + (A.cols * j + k << 3)));
                _t90 = __mulsc3(_v56, _t117, __eflags);
                _v56 =  *((intOrPtr*)(_v32 + (_v36 * j + i << 3)));
                asm("fld dword [ebp-0x34]");
                asm("fld dword [ebp-0x30]");
                _v56 = _t90;
                asm("fld dword [ebp-0x34]");
                _v56 = _t110;
                asm("fld dword [ebp-0x34]");
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp-0x34]");
                asm("fstp dword [ebp-0x34]");
                 *_t117 = _v56;
                 *((intOrPtr*)(_t117 + 4)) = _v56;
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
     *(_a4.rows) = C.rows;
     *(_a4.rows + 4) = _v36;
     *((intOrPtr*)(_a4.rows + 8)) = _v32;
    __esp =  &_v16;
    return _a4;
}

double quantum_frand()
{// addr = 0x0804CF20  --  defined in 'measure.c' at line 42
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    double _t3;                            // _t3

    _t3 = rand();
    _push(_t3);
    asm("fild dword [esp]");
    asm("fld qword [0x8054378]");
    asm("fdivp st1, st0");
    return _t3;
}

long long unsigned int quantum_measure(quantum_reg reg)
{// addr = 0x0804CF3D  --  defined in 'measure.c' at line 50
    double r;                              // _cfa_ffffffec
    int i;                                 // _cfa_fffffff8
    long long unsigned int _v24;           // _cfa_ffffffe8
    long long unsigned int _v28;           // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    int _t24;                              // _t24
    _unknown_ _t32;                        // _t32
    intOrPtr* _t35;                        // _t35
    _unknown_ _t36;                        // _t36

    _t24 = quantum_objcode_put(128);
    __eflags = _t24;
    if(_t24 == 0) {
        quantum_frand();
        asm("fstp qword [ebp-0x10]");
        i = 0;
        while(1) {
            __eflags = _a8 - i;
            if(__eflags <= 0) {
                break;
            }
            _t35 = _a16 + (i << 4);
             *__esp =  *_t35;
            _v40 =  *((intOrPtr*)(_t35 + 4));
            quantum_prob_inline();
            asm("fld qword [ebp-0x10]");
            asm("fsubrp st1, st0");
            asm("fstp qword [ebp-0x10]");
            asm("fld qword [ebp-0x10]");
            asm("fldz ");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags < 0) {
                i = i + 1;
                continue;
            }
            _t32 = _a16 + (i << 4);
            _v28 =  *(_t32 + 8);
            _v24 =  *(_t32 + 12);
L8:
            return _v28;
        }
        _v28 = -1;
        _v24 = -1;
        goto L8;
    }
    _v28 = 0;
    _v24 = 0;
    goto L8;
}

float quantum_prob_inline(complex float a)
{// addr = 0x0804CFE0  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t10;                            // _t10

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    asm("fstp dword [ebp-0x4]");
     *__esp = a;
    _t10 = _a8;
    _v24 = _t10;
    quantum_imag();
    asm("fstp dword [ebp-0x8]");
    asm("fld dword [ebp-0x4]");
    asm("fmul dword [ebp-0x4]");
    asm("fld dword [ebp-0x8]");
    asm("fmul dword [ebp-0x8]");
    asm("faddp st1, st0");
    return _t10;
}

float quantum_real(complex float a)
{// addr = 0x0804D020  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t7;                             // _t7

    p =  &a;
    _t7 =  *p;
    _v24 = _t7;
    asm("fld dword [ebp-0x14]");
    return _t7;
}

float quantum_imag(complex float a)
{// addr = 0x0804D039  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t8;                             // _t8

    p =  &a;
    _t8 = p[1];
    _v24 = _t8;
    asm("fld dword [ebp-0x14]");
    return _t8;
}

int quantum_bmeasure(int pos, quantum_reg* reg)
{// addr = 0x0804D055  --  defined in 'measure.c' at line 87
    double pa;                             // _cfa_ffffffe4
    double r;                              // _cfa_ffffffdc
    _unknown_ _v8;                         // _cfa_fffffff8
    int i;                                 // _cfa_fffffff0
    int result;                            // _cfa_ffffffec
    signed int _v40;                       // _cfa_ffffffd8
    long long unsigned int pos2;           // _cfa_ffffffd4
    int* _v48;                             // _cfa_ffffffd0
    quantum_reg_node* _v52;   // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    quantum_reg out;   // _cfa_ffffffc0
    int _v80;                              // _cfa_ffffffb0
    int* _v96;                             // _cfa_ffffffa0
    quantum_reg_node* _v100;   // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    int _v112;                             // _cfa_ffffff90
    int _v116;                             // _cfa_ffffff8c
    int _v120;                             // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    signed int _t65;                       // _t65
    _unknown_ _t66;                        // _t66
    long long unsigned int _t67;           // _t67
    _unknown_ _t73;                        // _t73
    _unknown_ _t99;                        // _t99
    signed int _t100;                      // _t100
    long long unsigned int _t103;          // _t103
    quantum_reg* _t107;   // _t107
    quantum_reg* _t108;   // _t108
    int** _t110;                           // _t110

    _push(__ebx);
    __esp = __esp - 116;
    result = 0;
    asm("fldz ");
    asm("fstp qword [ebp-0x18]");
    _v120 = pos;
    _t65 = quantum_objcode_put(129);
    __eflags = _t65;
    if(_t65 == 0) {
        _t100 = pos;
        _t103 = 0;
        asm("shld edx, eax, cl");
        _t67 = 1 << (_t100 & 255);
        __eflags = _t100 & 0x20;
        if((_t100 & 0x20) != 0) {
            _t103 = _t67;
            _t67 = 0;
        }
        pos2 = _t67;
        _v40 = _t103;
        i = 0;
        while(1) {
            __eflags = reg->size - i;
            if(__eflags <= 0) {
                break;
            }
            _t73 = reg->node + (i << 4);
            __eflags =  *(_t73 + 8) & pos2 |  *(_t73 + 12) & _v40;
            if(( *(_t73 + 8) & pos2 |  *(_t73 + 12) & _v40) == 0) {
                _t110 = reg->node + (i << 4);
                 *__esp =  *_t110;
                _v120 = _t110[1];
                quantum_prob_inline();
                asm("fld qword [ebp-0x18]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x18]");
            }
            i = i + 1;
        }
        quantum_frand();
        asm("fstp qword [ebp-0x20]");
        asm("fld qword [ebp-0x20]");
        asm("fld qword [ebp-0x18]");
        asm("fxch st0, st1");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags > 0) {
            result = 1;
        }
        _t107 = reg;
        _v112 = _t107->width;
        _v108 = _t107->size;
        _v104 = _t107->hashw;
        _v100 = _t107->node;
        _v96 = _t107->hash;
        _v116 = result;
        _v120 = pos;
         *__esp =  &(out.width);
        quantum_state_collapse();
        __esp = __esp - 4;
        quantum_delete_qureg_hashpreserve(reg);
        _t108 = reg;
         *_t108 = out.width;
        _t108->size = _v60;
        _t108->hashw = _v56;
        _t108->node = _v52;
        _t108->hash = _v48;
        _v80 = result;
L12:
        return _v80;
    }
    _v80 = 0;
    goto L12;
}

int quantum_bmeasure_bitpreserve(int pos, quantum_reg* reg)
{// addr = 0x0804D1A8  --  defined in 'measure.c' at line 128
    double d;                              // _cfa_ffffffdc
    double pa;                             // _cfa_ffffffd4
    double r;                              // _cfa_ffffffcc
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int size;                              // _cfa_ffffffe8
    int result;                            // _cfa_ffffffe4
    signed int _v56;                       // _cfa_ffffffc8
    long long unsigned int pos2;           // _cfa_ffffffc4
    int* _v64;                             // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    quantum_reg out;   // _cfa_ffffffb0
    intOrPtr _v100;                        // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    intOrPtr* _v108;                       // _cfa_ffffff94
    intOrPtr _v112;                        // _cfa_ffffff90
    int _v116;                             // _cfa_ffffff8c
    intOrPtr _v136;                        // _cfa_ffffff78
    int _v144;                             // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    int _v152;                             // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t145;                       // _t145
    int _t147;                             // _t147
    _unknown_ _t148;                       // _t148
    long long unsigned int _t149;          // _t149
    _unknown_ _t155;                       // _t155
    quantum_reg* _t164;   // _t164
    _unknown_ _t169;                       // _t169
    _unknown_ _t181;                       // _t181
    _unknown_ _t182;                       // _t182
    _unknown_ _t191;                       // _t191
    _unknown_ _t192;                       // _t192
    _unknown_ _t199;                       // _t199
    intOrPtr* _t211;                       // _t211
    _unknown_ _t218;                       // _t218
    _unknown_ _t222;                       // _t222
    _unknown_ _t224;                       // _t224
    _unknown_ _t225;                       // _t225
    _unknown_ _t227;                       // _t227
    signed int _t242;                      // _t242
    _unknown_ _t245;                       // _t245
    _unknown_ _t246;                       // _t246
    _unknown_ _t250;                       // _t250
    long long unsigned int _t251;          // _t251
    intOrPtr* _t259;                       // _t259
    _unknown_ _t267;                       // _t267
    intOrPtr _t268;                        // _t268
    quantum_reg* _t270;   // _t270
    int* _t272;                            // _t272
    intOrPtr* _t274;                       // _t274
    int* _t276;                            // _t276
    intOrPtr* _t278;                       // _t278

    size = 0;
    result = 0;
    asm("fldz ");
    asm("fstp qword [ebp-0x20]");
    asm("fldz ");
    asm("fstp qword [ebp-0x28]");
    _v152 = pos;
    _t147 = quantum_objcode_put(130);
    __eflags = _t147;
    if(_t147 == 0) {
        _t242 = pos;
        _t251 = 0;
        asm("shld edx, eax, cl");
        _t149 = 1 << (_t242 & 255);
        __eflags = _t242 & 0x20;
        if((_t242 & 0x20) != 0) {
            _t251 = _t149;
            _t149 = 0;
        }
        pos2 = _t149;
        _v56 = _t251;
        i = 0;
        while(1) {
            __eflags = reg->size - i;
            if(__eflags <= 0) {
                break;
            }
            _t155 = reg->node + (i << 4);
            __eflags =  *(_t155 + 8) & pos2 |  *(_t155 + 12) & _v56;
            if(( *(_t155 + 8) & pos2 |  *(_t155 + 12) & _v56) == 0) {
                _t278 = reg->node + (i << 4);
                 *__esp =  *_t278;
                _v152 =  *(_t278 + 4);
                quantum_prob_inline();
                asm("fld qword [ebp-0x28]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x28]");
            }
            i = i + 1;
        }
    } else {
        _v116 = 0;
L35:
        return _v116;
    }
    quantum_frand();
    asm("fstp qword [ebp-0x30]");
    asm("fld qword [ebp-0x30]");
    asm("fld qword [ebp-0x28]");
    asm("fxch st0, st1");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags > 0) {
        result = 1;
    }
    i = 0;
    while(1) {
        _t164 = reg;
        __eflags = _t164->size - i;
        if(_t164->size <= i) {
            break;
        }
        _t169 = reg->node + (i << 4);
        __eflags =  *(_t169 + 8) & pos2 |  *(_t169 + 12) & _v56;
        if(( *(_t169 + 8) & pos2 |  *(_t169 + 12) & _v56) == 0) {
            __eflags = result;
            if(result == 0) {
                _t259 = reg->node + (i << 4);
                 *__esp =  *_t259;
                _v152 =  *(_t259 + 4);
                quantum_prob_inline();
                asm("fld qword [ebp-0x20]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x20]");
                size = size + 1;
            } else {
                _t272 = reg->node + (i << 4);
                 *_t272 = 0;
                _t272[1] = 0;
            }
        } else {
            __eflags = result;
            if(result != 0) {
                _t274 = reg->node + (i << 4);
                 *__esp =  *_t274;
                _v152 =  *(_t274 + 4);
                quantum_prob_inline();
                asm("fld qword [ebp-0x20]");
                asm("faddp st1, st0");
                asm("fstp qword [ebp-0x20]");
                size = size + 1;
            } else {
                _t276 = reg->node + (i << 4);
                 *_t276 = 0;
                _t276[1] = 0;
            }
        }
        i = i + 1;
    }
    _v76 = size;
    _v68 = calloc(size, 16);
    __eflags = _v68;
    if(_v68 == 0) {
        quantum_error(2);
    }
    quantum_memman(size << 4);
    _v72 = reg->hashw;
    _v64 = reg->hash;
    out.width = reg->width;
    i = 0;
    j = 0;
    while(1) {
        __eflags = reg->size - i;
        if(__eflags <= 0) {
            break;
        }
        _t211 = reg->node + (i << 4);
        _v112 =  *((intOrPtr*)(_t211 + 4));
        _v136 =  *_t211;
        asm("fld dword [ebp+0xffffff7c]");
        asm("fldz ");
        asm("fxch st0, st1");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags != 0 || __eflags != 0) {
L28:
            _t245 = _v68 + (j << 4);
            _t218 = reg->node + (i << 4);
             *((intOrPtr*)(_t245 + 8)) =  *((intOrPtr*)(_t218 + 8));
             *((intOrPtr*)(_t245 + 12)) =  *((intOrPtr*)(_t218 + 12));
            _v108 = _v68 + (j << 4);
            asm("fld dword [eax]");
            asm("fstp dword [ebp-0x60]");
            asm("fld dword [eax+0x4]");
            asm("fstp dword [ebp-0x64]");
            asm("fld qword [ebp-0x20]");
            asm("fsqrt ");
            asm("fstp qword [ebp-0x80]");
            asm("fld qword [ebp-0x80]");
            asm("fucomp st0");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0 || __eflags != 0) {
                asm("fld qword [ebp-0x20]");
                asm("fstp qword [esp]");
                sqrt();
                asm("fstp qword [ebp-0x80]");
            }
            asm("fld qword [ebp-0x80]");
            asm("fstp dword [ebp-0x5c]");
            asm("fld dword [ebp-0x5c]");
            asm("fstp dword [ebp+0xffffff7c]");
            __esi = _v100;
            _t268 = _v136;
            _v144 = 0;
            _v148 = _t268;
            _v152 = _v104;
             *__esp = __esi;
             *_v108 = __divsc3(0, __esi, __eflags);
             *((intOrPtr*)(_v108 + 4)) = _t268;
            j = j + 1;
            goto L32;
        } else {
            asm("fld dword [ebp-0x6c]");
            asm("fldz ");
            asm("fxch st0, st1");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0 || __eflags != 0) {
                goto L28;
            }
L32:
            i = i + 1;
            continue;
        }
    }
    quantum_delete_qureg_hashpreserve(reg);
    _t270 = reg;
     *_t270 = out.width;
    _t270->size = _v76;
    _t270->hashw = _v72;
    _t270->node = _v68;
    _t270->hash = _v64;
    _v116 = result;
    goto L35;
}

test_sum(int compare, int width, quantum_reg* reg)
{// addr = 0x0804D538  --  defined in 'oaddn.c' at line 42
    int i;                                 // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t203;                      // _t203
    signed int _t205;                      // _t205
    signed int _t301;                      // _t301
    signed int _t317;                      // _t317
    _unknown_ _t349;                       // _t349

    _t203 = compare;
    _t301 = width - 1;
    _t205 = _t203;
    asm("shrd eax, edx, cl");
    _t317 = _t203 >> 31 >> (_t301 & 255);
    if((_t301 & 0x20) != 0) {
        _t205 = _t317;
    }
    if((_t205 & 1) == 0) {
        quantum_sigma_x(width + width - 1, reg);
        quantum_cnot(width + width - 1, width - 1, reg);
    } else {
        quantum_cnot(width + width - 1, width - 1, reg);
        quantum_sigma_x(width + width - 1, reg);
        quantum_cnot(width + width - 1, 0, reg);
    }
    i = width - 2;
    while(i > 0) {
        if((compare >> (i & 255) & 1) == 0) {
            quantum_sigma_x(width + i, reg);
            quantum_toffoli(i + 1, width + i, i, reg);
        } else {
            quantum_toffoli(i + 1, width + i, i, reg);
            quantum_sigma_x(width + i, reg);
            quantum_toffoli(i + 1, width + i, 0, reg);
        }
        i = i - 1;
    }
    if((compare & 1) != 0) {
        quantum_sigma_x(width, reg);
        quantum_toffoli(width, 1, 0, reg);
    }
    quantum_toffoli(width + width + 1, 0, width + width, reg);
    if((compare & 1) != 0) {
        quantum_toffoli(width, 1, 0, reg);
        quantum_sigma_x(width, reg);
    }
    i = 1;
    while(width - 2 >= i) {
        if((compare >> (i & 255) & 1) == 0) {
            quantum_toffoli(i + 1, width + i, i, reg);
            quantum_sigma_x(width + i, reg);
        } else {
            quantum_toffoli(i + 1, width + i, 0, reg);
            quantum_sigma_x(width + i, reg);
            quantum_toffoli(i + 1, width + i, i, reg);
        }
        i = i + 1;
    }
    if((compare >> (width - 1 & 255) & 1) == 0) {
        quantum_cnot(width + width - 1, width - 1, reg);
        quantum_sigma_x(width + width - 1, reg);
        return;
    }
    quantum_cnot(width + width - 1, 0, reg);
    quantum_sigma_x(width + width - 1, reg);
    quantum_cnot(width + width - 1, width - 1, reg);
    return;
}

muxfa(int a, int b_in, int c_in, int c_out, int xlt_l, int L, int total, quantum_reg* reg)
{// addr = 0x0804D8FE  --  defined in 'oaddn.c' at line 117
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(a == 0) {
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 3) {
        quantum_toffoli(L, c_in, c_out, reg);
        quantum_cnot(L, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 1) {
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 2) {
        quantum_sigma_x(xlt_l, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(b_in, c_in, reg);
        quantum_sigma_x(xlt_l, reg);
        return;
    }
    return;
}

muxfa_inv(int a, int b_in, int c_in, int c_out, int xlt_l, int L, int total, quantum_reg* reg)
{// addr = 0x0804DBA7  --  defined in 'oaddn.c' at line 158
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(a == 0) {
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
    }
    if(a == 3) {
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_cnot(L, c_in, reg);
        quantum_toffoli(L, c_in, c_out, reg);
    }
    if(a == 1) {
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
    }
    if(a == 2) {
        quantum_sigma_x(xlt_l, reg);
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_toffoli(b_in, c_in, c_out, reg);
        quantum_toffoli(L, xlt_l, b_in, reg);
        quantum_sigma_x(xlt_l, reg);
        return;
    }
    return;
}

muxha(int a, int b_in, int c_in, int xlt_l, int L, int total, quantum_reg* reg)
{// addr = 0x0804DE50  --  defined in 'oaddn.c' at line 201
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(a == 0) {
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 3) {
        quantum_cnot(L, c_in, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 1) {
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 2) {
        quantum_sigma_x(xlt_l, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_cnot(b_in, c_in, reg);
        quantum_sigma_x(xlt_l, reg);
        return;
    }
    return;
}

muxha_inv(int a, int b_in, int c_in, int xlt_l, int L, int total, quantum_reg* reg)
{// addr = 0x0804DF51  --  defined in 'oaddn.c' at line 229
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(a == 0) {
        quantum_cnot(b_in, c_in, reg);
    }
    if(a == 3) {
        quantum_cnot(b_in, c_in, reg);
        quantum_cnot(L, c_in, reg);
    }
    if(a == 1) {
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
    }
    if(a == 2) {
        quantum_sigma_x(xlt_l, reg);
        quantum_cnot(b_in, c_in, reg);
        quantum_toffoli(L, xlt_l, c_in, reg);
        quantum_sigma_x(xlt_l, reg);
        return;
    }
    return;
}

madd(int a, int a_inv, int width, quantum_reg* reg)
{// addr = 0x0804E052  --  defined in 'oaddn.c' at line 256
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int total;                             // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6

    total = width + width + 1 + width + width + 1;
    i = 0;
    while(width - 1 > i) {
        if((a >> (i & 255) & 1) == 0) {
            j = 0;
        } else {
            j = 2;
        }
        if((a_inv >> (i & 255) & 1) != 0) {
            j = j + 1;
        }
        muxfa(j, width + i, i, i + 1, width + width, width + width + 1, total, reg);
        i = i + 1;
    }
    j = 0;
    if((a >> (width - 1 & 255) & 1) != 0) {
        j = 2;
    }
    if((a_inv >> (width - 1 & 255) & 1) != 0) {
        j = j + 1;
    }
    muxha(j, width + width - 1, width - 1, width + width, width + width + 1, total, reg);
    return;
}

madd_inv(int a, int a_inv, int width, quantum_reg* reg)
{// addr = 0x0804E187  --  defined in 'oaddn.c' at line 272
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int total;                             // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6

    total = width + width + 1 + width + width + 1;
    j = 0;
    if((a >> (width - 1 & 255) & 1) != 0) {
        j = 2;
    }
    if((a_inv >> (width - 1 & 255) & 1) != 0) {
        j = j + 1;
    }
    muxha_inv(j, width - 1, width + width - 1, width + width, width + width + 1, total, reg);
    i = width - 2;
    while(i >= 0) {
        if((a >> (i & 255) & 1) == 0) {
            j = 0;
        } else {
            j = 2;
        }
        if((a_inv >> (i & 255) & 1) != 0) {
            j = j + 1;
        }
        muxfa_inv(j, i, width + i, width + 1 + i, width + width, width + width + 1, total, reg);
        i = i - 1;
    }
    return;
}

addn(int N, int a, int width, quantum_reg* reg)
{// addr = 0x0804E2BE  --  defined in 'oaddn.c' at line 290
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t21;                        // _t21

    test_sum(N - a, width, reg);
    madd((1 << (width & 255)) + a - N, a, width, reg);
    return;
}

addn_inv(int N, int a, int width, quantum_reg* reg)
{// addr = 0x0804E317  --  defined in 'oaddn.c' at line 297
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32

    quantum_cnot(width + width + 1, width + width, reg);
    madd_inv((1 << (width & 255)) - a, N - a, width, reg);
    quantum_swaptheleads(width, reg);
    test_sum(a, width, reg);
    return;
}

add_mod_n(int N, int a, int width, quantum_reg* reg)
{// addr = 0x0804E3A0  --  defined in 'oaddn.c' at line 307
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    addn(N, a, width, reg);
    addn_inv(N, a, width, reg);
    return;
}

quantum_mu2char(long long unsigned int mu, unsigned char* buf)
{// addr = 0x0804E3E8  --  defined in 'objcode.c' at line 61
    int i;                                 // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t48;                       // _t48
    _unknown_ _t52;                        // _t52
    signed int _t53;                       // _t53
    unsigned char* _t56;                   // _t56
    signed int _t57;                       // _t57
    signed int _t58;                       // _t58
    signed int _t61;                       // _t61
    signed int _t63;                       // _t63
    _unknown_ _t64;                        // _t64

    _v36 = _a4;
    _v32 = _a8;
    size = 8;
    i = 0;
    while(i < size) {
        _t56 =  &(buf[i]);
        _t57 = 0 +  !(i - size) * 8;
        _t48 = _v36;
        asm("shrd eax, edx, cl");
        _t61 = _v32 >> (_t57 & 255);
        if((_t57 & 0x20) != 0) {
            _t48 = _t61;
        }
         *_t56 = _t48 & 255;
        _t58 = 0 +  !(i - size) * 8;
        _t63 = 0;
        asm("shld edx, eax, cl");
        _t53 = 1 << (_t58 & 255);
        if((_t58 & 0x20) != 0) {
            _t63 = _t53;
            _t53 = 0;
        }
        asm("adc edx, 0xff");
        _v36 = _v36 & _t53 + -1;
        _v32 = _v32 & _t63;
        i = i + 1;
    }
    return;
}

quantum_int2char(int j, unsigned char* buf)
{// addr = 0x0804E481  --  defined in 'objcode.c' at line 77
    int i;                                 // _cfa_fffffff4
    int size;                              // _cfa_fffffff0
    signed int _v36;                       // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t44;                        // _t44
    _unknown_ _t51;                        // _t51
    _unknown_ _t53;                        // _t53
    _unknown_ _t62;                        // _t62
    _unknown_ _t63;                        // _t63
    _unknown_ _t65;                        // _t65
    _unknown_ _t68;                        // _t68

    size = 4;
    i = 0;
    while(i < size) {
        _v40 = j;
        buf[i] = _v40 / (1 << (0 +  !(i - size) * 8 & 255)) & 255;
        _v36 = 1 << (0 +  !(i - size) * 8 & 255);
        j = j % _v36;
        i = i + 1;
    }
    return;
}

quantum_double2char(double d, unsigned char* buf)
{// addr = 0x0804E509  --  defined in 'objcode.c' at line 93
    int i;                                 // _cfa_fffffff8
    unsigned char* p;                      // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    char _v28;                             // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6

    _v28 = _a4;
    _v24 = _a8;
    p =  &_v28;
    i = 0;
    while(i <= 7) {
        buf[i] = p[i] & 0xff;
        i = i + 1;
    }
    return;
}

long long unsigned int quantum_char2mu(unsigned char* buf)
{// addr = 0x0804E54B  --  defined in 'objcode.c' at line 102
    int i;                                 // _cfa_fffffff0
    int size;                              // _cfa_ffffffec
    long long unsigned int _v24;           // _cfa_ffffffe8
    long long unsigned int mu;             // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    signed int _t37;                       // _t37
    _unknown_ _t40;                        // _t40
    _unknown_ _t41;                        // _t41
    _unknown_ _t42;                        // _t42

    mu = 0;
    _v24 = 0;
    size = 8;
    i = size - 1;
    while(i >= 0) {
        __ecx = 0 +  !(i - size) * 8;
        asm("shld edx, eax, cl");
        _t37 = (buf[i] & 0xff) << (__ecx & 255);
        if((__ecx & 0x20) != 0) {
            _t37 = 0;
        }
        mu = mu + _t37;
        asm("adc [ebp-0x14], edx");
        i = i - 1;
    }
    return mu;
}

int quantum_char2int(unsigned char* buf)
{// addr = 0x0804E5C6  --  defined in 'objcode.c' at line 115
    int i;                                 // _cfa_fffffff4
    int size;                              // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    _unknown_ __ebp;                       // r6

    j = 0;
    size = 4;
    i = size - 1;
    while(i >= 0) {
        j = j + ((buf[i] & 0xff) << (0 +  !(i - size) * 8 & 255));
        i = i - 1;
    }
    return j;
}

double quantum_char2double(unsigned char* buf)
{// addr = 0x0804E61D  --  defined in 'objcode.c' at line 128
    double* d;                             // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    d = buf;
    asm("fld qword [eax]");
    return d;
}

quantum_objcode_start()
{// addr = 0x0804E630  --  defined in 'objcode.c' at line 139
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t4;                         // _t4

    opstatus = 1;
    allocated = 1;
    objcode = malloc(65536);
    if(objcode == 0) {
        quantum_error(2);
    }
    quantum_memman(65536);
    return;
}

quantum_objcode_stop()
{// addr = 0x0804E67E  --  defined in 'objcode.c' at line 154
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    _unknown_ _t6;                         // _t6

    opstatus = 0;
    free(objcode);
    objcode = 0;
    quantum_memman( ~(allocated << 16));
    allocated = 0;
    return;
}

int quantum_objcode_put(unsigned char operation)
{// addr = 0x0804E6C3  --  defined in 'objcode.c' at line 166
    double d;                              // _cfa_ffffff94
    intOrPtr _v8;                          // _cfa_fffffff8
    unsigned char[79] buf;                 // _cfa_ffffffa8
    int i;                                 // _cfa_ffffffa4
    int size;                              // _cfa_ffffffa0
    va_list args;      // _cfa_ffffff9c
    char _v112;                            // _cfa_ffffff90
    long long unsigned int mu;             // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    unsigned char* _v124;                  // _cfa_ffffff84
    int _v128;                             // _cfa_ffffff80
    intOrPtr _v148;                        // _cfa_ffffff6c
    char _v152;                            // _cfa_ffffff68
    _unknown_ __ebp;                       // r6
    _unknown_ _t138;                       // _t138
    int _t142;                             // _t142
    int _t152;                             // _t152
    _unknown_ _t159;                       // _t159
    _unknown_ _t179;                       // _t179
    _unknown_ _t198;                       // _t198
    char* _t223;                           // _t223
    long unsigned int _t229;               // _t229
    _unknown_ _t235;                       // _t235
    char* _t237;                           // _t237
    char* _t238;                           // _t238
    char* _t239;                           // _t239
    char* _t241;                           // _t241
    char* _t242;                           // _t242
    char* _t243;                           // _t243
    char* _t245;                           // _t245
    char* _t246;                           // _t246
    char* _t247;                           // _t247
    char* _t248;                           // _t248

    _v120 = _a4 & 255;
    _v8 =  *gs:0x14];
    size = 0;
    __eflags = opstatus;
    if(__eflags != 0) {
        args =  &_a8;
        buf = _v120 & 0xff;
        _v124 = _v120 & 255;
        __eflags = _v124 - 11;
        if(_v124 > 11) {
            __eflags = _v124 - 128;
            if(_v124 == 128) {
L24:
                size = 1;
            } else {
                __eflags = _v124 - 128;
                if(_v124 > 128) {
                    __eflags = _v124 - 130;
                    if(_v124 <= 130) {
                        goto L21;
                    } else {
                        __eflags = _v124 - 255;
                        if(_v124 == 255) {
                            goto L24;
                        } else {
                            goto L25;
                        }
                    }
                } else {
                    __eflags = _v124 - 13;
                    if(_v124 == 13) {
                        _t238 = args;
                        args =  &(_t238[4]);
                        i =  *_t238;
                        quantum_int2char(i,  &buf + 1);
                        _t239 = args;
                        args =  &(_t239[4]);
                        i =  *_t239;
                        quantum_int2char(i,  &buf + 5);
                        args =  &(args[8]);
                        asm("fld qword [eax]");
                        asm("fstp qword [ebp-0x68]");
                        _v148 =  &buf + 9;
                        asm("fld qword [ebp-0x68]");
                        asm("fstp qword [esp]");
                        quantum_double2char();
                        size = 17;
                    } else {
                        __eflags = _v124 - 13;
                        if(_v124 < 13) {
                            goto L19;
                        } else {
                            __eflags = _v124 - 14;
                            if(_v124 == 14) {
                                goto L21;
                            } else {
                                goto L25;
                            }
                        }
                    }
                }
            }
        } else {
            __eflags = _v124 - 7;
            if(_v124 >= 7) {
                _t243 = args;
                args =  &(_t243[4]);
                i =  *_t243;
                args =  &(args[8]);
                asm("fld qword [eax]");
                asm("fstp qword [ebp-0x68]");
                quantum_int2char(i,  &buf + 1);
                _v148 =  &buf + 5;
                asm("fld qword [ebp-0x68]");
                asm("fstp qword [esp]");
                quantum_double2char();
                size = 13;
            } else {
                __eflags = _v124 - 2;
                if(_v124 == 2) {
                    _t245 = args;
                    args =  &(_t245[4]);
                    i =  *_t245;
                    quantum_int2char(i,  &buf + 1);
                    _t246 = args;
                    args =  &(_t246[4]);
                    i =  *_t246;
                    quantum_int2char(i,  &buf + 5);
                    _t247 = args;
                    args =  &(_t247[4]);
                    i =  *_t247;
                    quantum_int2char(i,  &buf + 9);
                    size = 13;
                } else {
                    __eflags = _v124 - 2;
                    if(_v124 > 2) {
L21:
                        _t237 = args;
                        args =  &(_t237[4]);
                        i =  *_t237;
                        quantum_int2char(i,  &buf + 1);
                        size = 5;
                    } else {
                        __eflags = _v124;
                        if(_v124 == 0) {
                            _t248 = args;
                            args =  &(_t248[8]);
                            _t223 = _t248;
                            mu =  *_t223;
                            _v112 = _t223[4];
                            _v148 =  &buf + 1;
                             *__esp = mu;
                            _v152 = _v112;
                            quantum_mu2char();
                            size = 9;
                        } else {
                            __eflags = _v124 - 1;
                            if(_v124 == 1) {
L19:
                                _t241 = args;
                                args =  &(_t241[4]);
                                i =  *_t241;
                                quantum_int2char(i,  &buf + 1);
                                _t242 = args;
                                args =  &(_t242[4]);
                                i =  *_t242;
                                quantum_int2char(i,  &buf + 5);
                                size = 9;
                            } else {
L25:
                                quantum_error(65537);
                            }
                        }
                    }
                }
            }
        }
        _t229 = position;
        _t142 = size;
        __eflags = _t229 + _t142 >> 16 - position >> 16;
        if(_t229 + _t142 >> 16 > position >> 16) {
            allocated = allocated + 1;
            objcode = realloc(objcode, allocated << 16);
            __eflags = objcode;
            if(objcode == 0) {
                quantum_error(2);
            }
            quantum_memman(65536);
        }
        i = 0;
        while(1) {
            __eflags = i - size;
            if(__eflags >= 0) {
                break;
            }
            objcode[position] =  *(__ebp + i - 84) & 0xff;
            position = position + 1;
            i = i + 1;
        }
        _v128 = 1;
L34:
        _t152 = _v128;
        if(__eflags != 0) {
            __stack_chk_fail();
            return _t152;
        }
        return _t152;
    }
    _v128 = 0;
    goto L34;
}

int quantum_objcode_write(char* file)
{// addr = 0x0804EA7D  --  defined in 'objcode.c' at line 267
    FILE* fhd;            // _cfa_fffffff8
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t25;                        // _t25
    _unknown_ _t29;                        // _t29

    if(opstatus != 0) {
        if(file == 0) {
            file = globalfile;
        }
        fhd = fopen(file, "w");
        if(fhd != 0) {
            fwrite(objcode, position, 1, fhd);
            fclose(fhd);
            _v24 = 0;
        } else {
            _v24 = -1;
        }
    } else {
        fwrite("Object code generation not active! Forgot to call quantum_objcode_start?\n", 1, 73, __imp__stderr);
        _v24 = 1;
    }
    return _v24;
}

quantum_objcode_file(char* file)
{// addr = 0x0804EB2B  --  defined in 'objcode.c' at line 295
    _unknown_ __ebp;                       // r6

    globalfile = file;
    return;
}

quantum_objcode_exit(char* file)
{// addr = 0x0804EB38  --  defined in 'objcode.c' at line 304
    _unknown_ __ebp;                       // r6

    quantum_objcode_write(0);
    quantum_objcode_stop();
    return;
}

quantum_objcode_run(char* file, quantum_reg* reg)
{// addr = 0x0804EB51  --  defined in 'objcode.c' at line 313
    double d;                              // _cfa_ffffff74
    _unknown_ _v8;                         // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    unsigned char[79] buf;                 // _cfa_ffffffa0
    unsigned char operation;               // _cfa_ffffff9f
    int i;                                 // _cfa_ffffff98
    int j;                                 // _cfa_ffffff94
    int k;                                 // _cfa_ffffff90
    int l;                                 // _cfa_ffffff8c
    FILE* fhd;            // _cfa_ffffff88
    _unknown_ _v128;                       // _cfa_ffffff80
    long long unsigned int mu;             // _cfa_ffffff7c
    char* _v144;                           // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    _unknown_ _v172;                       // _cfa_ffffff54
    _unknown_ _v176;                       // _cfa_ffffff50
    _unknown_ _v180;                       // _cfa_ffffff4c
    _unknown_ _v184;                       // _cfa_ffffff48
    _unknown_ _v188;                       // _cfa_ffffff44
    _unknown_ _v196;                       // _cfa_ffffff3c
    _unknown_ _v200;                       // _cfa_ffffff38
    _unknown_ _v204;                       // _cfa_ffffff34
    _unknown_ _v208;                       // _cfa_ffffff30
    _unknown_ _v236;                       // _cfa_ffffff14
    _unknown_ _v240;                       // _cfa_ffffff10
    char* _v244;                           // _cfa_ffffff0c
    _unknown_ _v248;                       // _cfa_ffffff08
    _unknown_ __ebp;                       // r6
    _unknown_ _t225;                       // _t225
    int _t229;                             // _t229
    _unknown_ _t238;                       // _t238
    _unknown_ _t241;                       // _t241
    _unknown_ _t248;                       // _t248
    _unknown_ _t251;                       // _t251
    _unknown_ _t262;                       // _t262
    signed int _t264;                      // _t264
    _unknown_ _t267;                       // _t267
    _unknown_ _t272;                       // _t272
    _unknown_ _t277;                       // _t277
    _unknown_ _t284;                       // _t284
    _unknown_ _t289;                       // _t289
    _unknown_ _t301;                       // _t301
    _unknown_ _t306;                       // _t306
    _unknown_ _t310;                       // _t310
    _unknown_ _t313;                       // _t313
    _unknown_ _t318;                       // _t318
    _unknown_ _t323;                       // _t323
    _unknown_ _t332;                       // _t332
    _unknown_ _t342;                       // _t342
    _unknown_ _t344;                       // _t344
    _unknown_ _t345;                       // _t345
    _unknown_ _t347;                       // _t347
    _unknown_ _t348;                       // _t348
    _unknown_ _t349;                       // _t349
    _unknown_ _t350;                       // _t350
    _unknown_ _t353;                       // _t353

    _push(__ebx);
    __esp = __esp - 244;
    _v144 = _a4;
    _v148 = _a8;
    _v16 =  *gs:0x14];
    fhd = fopen(_v144, "r");
    __eflags = fhd;
    if(fhd != 0) {
        i = 0;
        while(1) {
            _t229 = feof(fhd);
            __eflags = _t229;
            if(_t229 != 0) {
                break;
            } else {
                j = 0;
                goto L5;
            }
        }
    } else {
        _v244 = _v144;
        fprintf(__imp__stderr, "quantum_objcode_run: Could not open %s: ");
        perror(0);
L54:
        _t264 = _v16 ^  *gs:0x14];
        if(__eflags != 0) {
            __stack_chk_fail();
        }
        return _t264;
    }
    fclose(fhd);
    goto L54;
}

emul(int a, int L, int width, quantum_reg* reg)
{// addr = 0x0804F2F4  --  defined in 'omuln.c' at line 30
    int i;                                 // _cfa_fffffff8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    i = width - 1;
    while(i >= 0) {
        if((a >> (i & 255) & 1) != 0) {
            quantum_toffoli(width + 1 + width + 1, L, width + i, reg);
        }
        i = i - 1;
    }
    return;
}

muln(int N, int a, int ctl, int width, quantum_reg* reg)
{// addr = 0x0804F34C  --  defined in 'omuln.c' at line 38
    int i;                                 // _cfa_fffffff8
    int L;                                 // _cfa_fffffff4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t78;                        // _t78
    _unknown_ _t96;                        // _t96
    _unknown_ _t108;                       // _t108
    _unknown_ _t115;                       // _t115

    L = width + width + 1;
    quantum_toffoli(ctl, width + 1 + width + 1, L, reg);
    emul(a % N, L, width, reg);
    quantum_toffoli(ctl, width + 1 + width + 1, L, reg);
    i = 1;
    while(i < width) {
        quantum_toffoli(ctl, width + 1 + width + 1 + i, L, reg);
        add_mod_n(N, (a << (i & 255)) % N, width, reg);
        quantum_toffoli(ctl, width + 1 + width + 1 + i, L, reg);
        i = i + 1;
    }
    return;
}

muln_inv(int N, int a, int ctl, int width, quantum_reg* reg)
{// addr = 0x0804F472  --  defined in 'omuln.c' at line 57
    int i;                                 // _cfa_fffffff8
    int L;                                 // _cfa_fffffff4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t90;                        // _t90
    _unknown_ _t107;                       // _t107
    _unknown_ _t123;                       // _t123
    _unknown_ _t130;                       // _t130

    L = width + width + 1;
    a = quantum_inverse_mod(N, a);
    i = width - 1;
    while(i > 0) {
        quantum_toffoli(ctl, width + 1 + width + 1 + i, L, reg);
        add_mod_n(N, N - (a << (i & 255)) % N, width, reg);
        quantum_toffoli(ctl, width + 1 + width + 1 + i, L, reg);
        i = i - 1;
    }
    quantum_toffoli(ctl, width + 1 + width + 1, L, reg);
    emul(a % N, L, width, reg);
    quantum_toffoli(ctl, width + 1 + width + 1, L, reg);
    return;
}

mul_mod_n(int N, int a, int ctl, int width, quantum_reg* reg)
{// addr = 0x0804F5B6  --  defined in 'omuln.c' at line 76
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    muln(N, a, ctl, width, reg);
    quantum_swaptheleads_omuln_controlled(ctl, width, reg);
    muln_inv(N, a, ctl, width, reg);
    return;
}

quantum_qec_set_status(int stype, int swidth)
{// addr = 0x0804F628  --  defined in 'qec.c' at line 48
    _unknown_ __ebp;                       // r6

    type = stype;
    width = swidth;
    return;
}

quantum_qec_get_status(int* ptype, int* pwidth)
{// addr = 0x0804F63D  --  defined in 'qec.c' at line 57
    _unknown_ __ebp;                       // r6

    if(ptype != 0) {
         *ptype = type;
    }
    if(pwidth != 0) {
         *pwidth = width;
        return;
    }
    return;
}

quantum_qec_encode(int type, int width, quantum_reg* reg)
{// addr = 0x0804F664  --  defined in 'qec.c' at line 69
    int i;                                 // _cfa_fffffff8
    float lambda;                          // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t48;                        // _t48

    quantum_get_decoherence();
    asm("fstp dword [ebp-0x8]");
    quantum_set_decoherence(0);
    i = 0;
    while(reg->width > i) {
        if(reg->width - 1 == i) {
            quantum_set_decoherence(lambda);
        }
        if(i >= width) {
            quantum_cnot(i, reg->width + i, reg);
            quantum_cnot(i, reg->width + reg->width + i, reg);
        } else {
            quantum_hadamard(reg->width + i, reg);
            quantum_hadamard(reg->width + reg->width + i, reg);
            quantum_cnot(reg->width + i, i, reg);
            quantum_cnot(reg->width + reg->width + i, i, reg);
        }
        i = i + 1;
    }
    quantum_qec_set_status(1, reg->width);
    reg->width = reg->width + reg->width + _t99;
    return;
}

quantum_qec_decode(int type, int width, quantum_reg* reg)
{// addr = 0x0804F79F  --  defined in 'qec.c' at line 107
    int i;                                 // _cfa_fffffff8
    int a;                                 // _cfa_fffffff4
    int b;                                 // _cfa_fffffff0
    int swidth;                            // _cfa_ffffffec
    float lambda;                          // _cfa_ffffffe8
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t90;                        // _t90
    _unknown_ _t94;                        // _t94
    _unknown_ _t101;                       // _t101

    quantum_get_decoherence();
    asm("fstp dword [ebp-0x14]");
    quantum_set_decoherence(0);
    _v40 = reg->width;
    _v44 = 1431655766;
    swidth = (_v44 * _v40 >> 32) - (_v40 >> 31);
    quantum_qec_set_status(0, 0);
    _v40 = reg->width;
    _v44 = 1431655766;
    i = (_v44 * _v40 >> 32) - (_v40 >> 31) - 1;
    while(i >= 0) {
        if(i == 0) {
            quantum_set_decoherence(lambda);
        }
        if(i >= width) {
            quantum_cnot(i, swidth + swidth + i, reg);
            quantum_cnot(i, swidth + i, reg);
        } else {
            quantum_cnot(swidth + swidth + i, i, reg);
            quantum_cnot(swidth + i, i, reg);
            quantum_hadamard(swidth + swidth + i, reg);
            quantum_hadamard(swidth + i, reg);
        }
        i = i - 1;
    }
    i = 1;
    while(i <= swidth) {
        a = quantum_bmeasure(swidth, reg);
        b = quantum_bmeasure(swidth + swidth - i, reg);
        if(a == 1 && b == 1 && i - 1 < width) {
            quantum_sigma_z(i - 1, reg);
        }
        i = i + 1;
    }
    return;
}

int quantum_qec_counter(int inc, int frequency, quantum_reg* reg)
{// addr = 0x0804F96E  --  defined in 'qec.c' at line 153
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(inc <= 0) {
        if(inc < 0) {
            counter.2126 = 0;
        }
    } else {
        counter.2126 = counter.2126 + inc;
    }
    if(frequency > 0) {
        freq = frequency;
    }
    if(counter.2126 >= freq) {
        counter.2126 = 0;
        quantum_qec_decode(type, width, reg);
        quantum_qec_encode(type, width, reg);
    }
    return counter.2126;
}

quantum_sigma_x_ft(int target, quantum_reg* reg)
{// addr = 0x0804FA05  --  defined in 'qec.c' at line 179
    int tmp;                               // _cfa_fffffff8
    float lambda;                          // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t27;                        // _t27

    tmp = type;
    type = 0;
    quantum_get_decoherence();
    asm("fstp dword [ebp-0x8]");
    quantum_set_decoherence(0);
    quantum_sigma_x(target, reg);
    quantum_sigma_x(width + target, reg);
    quantum_set_decoherence(lambda);
    quantum_sigma_x(width + width + target, reg);
    quantum_qec_counter(1, 0, reg);
    type = tmp;
    return;
}

quantum_cnot_ft(int control, int target, quantum_reg* reg)
{// addr = 0x0804FAA8  --  defined in 'qec.c' at line 205
    int tmp;                               // _cfa_fffffff8
    float lambda;                          // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t37;                        // _t37

    tmp = type;
    type = 0;
    quantum_get_decoherence();
    asm("fstp dword [ebp-0x8]");
    quantum_set_decoherence(0);
    quantum_cnot(control, target, reg);
    quantum_cnot(width + control, width + target, reg);
    quantum_set_decoherence(lambda);
    quantum_cnot(width + width + control, width + width + target, reg);
    quantum_qec_counter(1, 0, reg);
    type = tmp;
    return;
}

quantum_toffoli_ft(int control1, int control2, int target, quantum_reg* reg)
{// addr = 0x0804FB70  --  defined in 'qec.c' at line 232
    int i;                                 // _cfa_fffffff0
    int c1;                                // _cfa_ffffffec
    int c2;                                // _cfa_ffffffe8
    int _v32;                              // _cfa_ffffffe0
    long long unsigned int mask;           // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t152;                       // _t152
    _unknown_ _t154;                       // _t154
    signed int _t155;                      // _t155
    _unknown_ _t158;                       // _t158
    signed int _t159;                      // _t159
    _unknown_ _t166;                       // _t166
    signed int _t167;                      // _t167
    _unknown_ _t172;                       // _t172
    signed int _t174;                      // _t174
    _unknown_ _t179;                       // _t179
    signed int _t182;                      // _t182
    _unknown_ _t187;                       // _t187
    signed int _t188;                      // _t188
    _unknown_ _t193;                       // _t193
    signed int _t195;                      // _t195
    _unknown_ _t200;                       // _t200
    signed int _t203;                      // _t203
    _unknown_ _t211;                       // _t211
    _unknown_ _t216;                       // _t216
    _unknown_ _t217;                       // _t217
    signed int _t218;                      // _t218
    _unknown_ _t219;                       // _t219
    signed int _t225;                      // _t225
    signed int _t227;                      // _t227
    signed int _t229;                      // _t229
    signed int _t230;                      // _t230
    signed int _t232;                      // _t232
    signed int _t234;                      // _t234
    signed int _t235;                      // _t235
    signed int _t237;                      // _t237
    signed int _t239;                      // _t239
    _unknown_ _t241;                       // _t241
    _unknown_ _t242;                       // _t242
    int _t243;                             // _t243
    signed int _t246;                      // _t246
    signed int _t249;                      // _t249
    signed int _t252;                      // _t252
    signed int _t255;                      // _t255
    signed int _t258;                      // _t258
    signed int _t261;                      // _t261
    _unknown_ _t266;                       // _t266
    _unknown_ _t267;                       // _t267
    _unknown_ _t268;                       // _t268
    _unknown_ _t269;                       // _t269
    _unknown_ _t270;                       // _t270
    _unknown_ _t271;                       // _t271
    _unknown_ _t272;                       // _t272
    _unknown_ _t273;                       // _t273
    _unknown_ _t278;                       // _t278
    _unknown_ _t279;                       // _t279

    _t225 = target;
    asm("shld esi, ebx, cl");
    _t218 = 1 << (_t225 & 255);
    if((_t225 & 0x20) != 0) {
        _t218 = 0;
    }
    _t227 = width + target;
    asm("shld edx, eax, cl");
    _t155 = 1 << (_t227 & 255);
    if((_t227 & 0x20) != 0) {
        _t155 = 0;
    }
    _t219 = _t218 + _t155;
    asm("adc esi, edx");
    _t229 = width + width + target;
    _t243 = 0;
    asm("shld edx, eax, cl");
    _t159 = 1 << (_t229 & 255);
    if((_t229 & 0x20) != 0) {
        _t243 = _t159;
        _t159 = 0;
    }
    asm("adc edx, esi");
    mask = _t159 + _t219;
    _v32 = _t243;
    i = 0;
    while(reg->size > i) {
        c1 = 0;
        c2 = 0;
        _t166 = reg->node + (i << 4);
        _t167 =  *(_t166 + 8);
        _t230 = control1;
        asm("shrd eax, edx, cl");
        _t246 =  *(_t166 + 12) >> (_t230 & 255);
        if((_t230 & 0x20) != 0) {
            _t167 = _t246;
        }
        if((_t167 & 1) != 0) {
            c1 = 1;
        }
        _t172 = reg->node + (i << 4);
        _t232 = width + control1;
        _t174 =  *(_t172 + 8);
        asm("shrd eax, edx, cl");
        _t249 =  *(_t172 + 12) >> (_t232 & 255);
        if((_t232 & 0x20) != 0) {
            _t174 = _t249;
        }
        if((_t174 & 1) != 0) {
            c1 = c1 ^ 1;
        }
        _t179 = reg->node + (i << 4);
        _t234 = width + width + control1;
        _t182 =  *(_t179 + 8);
        asm("shrd eax, edx, cl");
        _t252 =  *(_t179 + 12) >> (_t234 & 255);
        if((_t234 & 0x20) != 0) {
            _t182 = _t252;
        }
        if((_t182 & 1) != 0) {
            c1 = c1 ^ 1;
        }
        _t187 = reg->node + (i << 4);
        _t188 =  *(_t187 + 8);
        _t235 = control2;
        asm("shrd eax, edx, cl");
        _t255 =  *(_t187 + 12) >> (_t235 & 255);
        if((_t235 & 0x20) != 0) {
            _t188 = _t255;
        }
        if((_t188 & 1) != 0) {
            c2 = 1;
        }
        _t193 = reg->node + (i << 4);
        _t237 = width + control2;
        _t195 =  *(_t193 + 8);
        asm("shrd eax, edx, cl");
        _t258 =  *(_t193 + 12) >> (_t237 & 255);
        if((_t237 & 0x20) != 0) {
            _t195 = _t258;
        }
        if((_t195 & 1) != 0) {
            c2 = c2 ^ 1;
        }
        _t200 = reg->node + (i << 4);
        _t239 = width + width + control2;
        _t203 =  *(_t200 + 8);
        asm("shrd eax, edx, cl");
        _t261 =  *(_t200 + 12) >> (_t239 & 255);
        if((_t239 & 0x20) != 0) {
            _t203 = _t261;
        }
        if((_t203 & 1) != 0) {
            c2 = c2 ^ 1;
        }
        if(c1 == 1 && c2 == 1) {
            _t278 = reg->node + (i << 4);
            _t211 = reg->node + (i << 4);
             *(_t278 + 8) =  *(_t211 + 8) ^ mask;
             *(_t278 + 12) =  *(_t211 + 12) ^ _v32;
        }
        i = i + 1;
    }
    quantum_decohere(reg);
    quantum_qec_counter(1, 0, reg);
    return;
}

quantum_qft(int width, quantum_reg* reg)
{// addr = 0x0804FDE4  --  defined in 'qft.c' at line 32
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    i = width - 1;
    while(i >= 0) {
        j = width - 1;
        while(j > i) {
            quantum_cond_phase(j, i, reg);
            j = j - 1;
        }
        quantum_hadamard(i, reg);
        i = i - 1;
    }
    return;
}

quantum_qft_inv(int width, quantum_reg* reg)
{// addr = 0x0804FE43  --  defined in 'qft.c' at line 47
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    i = 0;
    while(i < width) {
        quantum_hadamard(i, reg);
        j = i + 1;
        while(j < width) {
            quantum_cond_phase_inv(j, i, reg);
            j = j + 1;
        }
        i = i + 1;
    }
    return;
}

quantum_rk4(quantum_reg* reg, double t, double dt, _None* H)
{// addr = 0x0804FEA4  --  defined in 'qtime.c' at line 38
    double r;                              // _cfa_ffffffdc
    int i;                                 // _cfa_fffffff0
    _Unknown_base* hash;                   // _cfa_ffffffec
    int hashw;                             // _cfa_ffffffe8
    _Unknown_base* _v40;                   // _cfa_ffffffd8
    quantum_reg_node* _v44;   // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    quantum_reg k;   // _cfa_ffffffc8
    _Unknown_base* _v60;                   // _cfa_ffffffc4
    quantum_reg_node* _v64;   // _cfa_ffffffc0
    int _v68;                              // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    quantum_reg out;   // _cfa_ffffffb4
    _Unknown_base* _v80;                   // _cfa_ffffffb0
    quantum_reg_node* _v84;   // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    int _v92;                              // _cfa_ffffffa4
    quantum_reg tmp;   // _cfa_ffffffa0
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    _Unknown_base* _v140;                  // _cfa_ffffff74
    quantum_reg_node* _v144;   // _cfa_ffffff70
    int _v148;                             // _cfa_ffffff6c
    int _v152;                             // _cfa_ffffff68
    char _v156;                            // _cfa_ffffff64
    char _v172;                            // _cfa_ffffff54
    int* _v192;                            // _cfa_ffffff40
    quantum_reg* _v236;   // _cfa_ffffff14
    _None* _v248;                          // _cfa_ffffff08
    int* _v256;                            // _cfa_ffffff00
    int* _v260;                            // _cfa_fffffefc
    int _v264;                             // _cfa_fffffef8
    _None* _v268;                          // _cfa_fffffef4
    int* _v272;                            // _cfa_fffffef0
    int* _v276;                            // _cfa_fffffeec
    int* _v280;                            // _cfa_fffffee8
    _None* _v284;                          // _cfa_fffffee4
    int* _v288;                            // _cfa_fffffee0
    quantum_reg* _v292;   // _cfa_fffffedc
    int* _v296;                            // _cfa_fffffed8
    int* _v304;                            // _cfa_fffffed0
    int* _v308;                            // _cfa_fffffecc
    _unknown_ __ebp;                       // r6
    _unknown_ _t233;                       // _t233
    _unknown_ _t235;                       // _t235
    _unknown_ _t263;                       // _t263
    _unknown_ _t265;                       // _t265
    _unknown_ _t288;                       // _t288
    _unknown_ _t311;                       // _t311
    _unknown_ _t313;                       // _t313
    _unknown_ _t333;                       // _t333
    _unknown_ _t335;                       // _t335
    _unknown_ _t337;                       // _t337
    _unknown_ _t342;                       // _t342
    _unknown_ _t347;                       // _t347
    _unknown_ _t351;                       // _t351
    int** _t355;                           // _t355
    quantum_reg* _t356;   // _t356
    _unknown_ _t357;                       // _t357

    _v116 = _a8;
    _v112 = _a12;
    _v124 = _a16;
    _v120 = _a20;
    asm("fldz ");
    asm("fstp qword [ebp-0x20]");
    hash = reg->hash;
    reg->hash = 0;
    hashw = reg->hashw;
    reg->hashw = 0;
    _v236 = reg;
    asm("fld qword [ebp-0x70]");
    asm("fstp qword [esp+0x8]");
    _v248 = H;
     *__esp =  &_v156;
    quantum_matrix_qureg();
    __esp = __esp - 4;
    k.width = _v156;
    _v52 = _v152;
    _v48 = _v148;
    _v44 = _v144;
    _v40 = _v140;
    asm("fld qword [ebp-0x78]");
    asm("fldz ");
    asm("fld1 ");
    asm("fchs ");
    asm("fstp qword [esp+0x1c]");
    asm("fldz ");
    asm("fstp qword [esp+0x14]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    __muldc3(__esi, _t357,  &_v172);
    asm("fld qword [ebp+0xffffff58]");
    asm("fld qword [ebp+0xffffff60]");
    asm("fldz ");
    asm("fstp qword [esp+0x1c]");
    asm("fld qword [0x8054430]");
    asm("fstp qword [esp+0x14]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    __divdc3( &_v156, __esi, _t357,  &_v172);
    asm("fld qword [ebp+0xffffff58]");
    asm("fld qword [ebp+0xffffff60]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff54]");
    asm("fld dword [ebp+0xffffff54]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff54]");
    asm("fld dword [ebp+0xffffff54]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff44]");
    asm("fstp dword [ebp+0xffffff44]");
    _v256 =  &(k.width);
     *__esp = _v192;
    _v260 = _v192;
    quantum_scalar_qureg();
    _v256 =  &(k.width);
    _v260 = reg;
     *__esp =  &_v156;
    quantum_vectoradd();
    __esp = __esp - 4;
    tmp.width = _v156;
    _v92 = _v152;
    _v88 = _v148;
    _v84 = _v144;
    _v80 = _v140;
    _v260 =  &(k.width);
     *__esp = 1051372203;
    _v264 = 0;
    quantum_scalar_qureg();
    _v260 =  &(k.width);
    _v264 = reg;
     *__esp =  &_v156;
    quantum_vectoradd();
    __esp = __esp - 4;
    out.width = _v156;
    _v72 = _v152;
    _v68 = _v148;
    _v64 = _v144;
    _v60 = _v140;
    quantum_delete_qureg( &(k.width));
    asm("fld qword [ebp-0x78]");
    asm("fld qword [0x8054430]");
    asm("fdivp st1, st0");
    asm("fadd qword [ebp-0x70]");
    _v256 =  &(tmp.width);
    asm("fstp qword [esp+0x8]");
    _v268 = H;
     *__esp =  &_v156;
    quantum_matrix_qureg();
    __esp = __esp - 4;
    k.width = _v156;
    _v52 = _v152;
    _v48 = _v148;
    _v44 = _v144;
    _v40 = _v140;
    quantum_delete_qureg( &(tmp.width));
    asm("fld qword [ebp-0x78]");
    asm("fldz ");
    asm("fld1 ");
    asm("fchs ");
    asm("fstp qword [esp+0x1c]");
    asm("fldz ");
    asm("fstp qword [esp+0x14]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    __muldc3(__esi, _t357,  &_v172);
    asm("fld qword [ebp+0xffffff58]");
    asm("fld qword [ebp+0xffffff60]");
    asm("fldz ");
    asm("fstp qword [esp+0x1c]");
    asm("fld qword [0x8054430]");
    asm("fstp qword [esp+0x14]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    __divdc3( &_v156, __esi, _t357,  &_v172);
    asm("fld qword [ebp+0xffffff58]");
    asm("fld qword [ebp+0xffffff60]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff54]");
    asm("fld dword [ebp+0xffffff54]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff54]");
    asm("fld dword [ebp+0xffffff54]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff44]");
    asm("fstp dword [ebp+0xffffff44]");
    _v276 =  &(k.width);
     *__esp = _v192;
    _v280 = _v192;
    quantum_scalar_qureg();
    _v276 =  &(k.width);
    _v280 = reg;
     *__esp =  &_v156;
    quantum_vectoradd();
    __esp = __esp - 4;
    tmp.width = _v156;
    _v92 = _v152;
    _v88 = _v148;
    _v84 = _v144;
    _v80 = _v140;
    _v280 =  &(k.width);
     *__esp = 1059760811;
    _v284 = 0;
    quantum_scalar_qureg();
    _v284 =  &(k.width);
     *__esp =  &(out.width);
    quantum_vectoradd_inplace();
    quantum_delete_qureg( &(k.width));
    asm("fld qword [ebp-0x78]");
    asm("fld qword [0x8054430]");
    asm("fdivp st1, st0");
    asm("fadd qword [ebp-0x70]");
    _v272 =  &(tmp.width);
    asm("fstp qword [esp+0x8]");
    _v284 = H;
     *__esp =  &_v156;
    quantum_matrix_qureg();
    __esp = __esp - 4;
    k.width = _v156;
    _v52 = _v152;
    _v48 = _v148;
    _v44 = _v144;
    _v40 = _v140;
    quantum_delete_qureg( &(tmp.width));
    asm("fld qword [ebp-0x78]");
    asm("fldz ");
    asm("fld1 ");
    asm("fchs ");
    asm("fstp qword [esp+0x1c]");
    asm("fldz ");
    asm("fstp qword [esp+0x14]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    __muldc3(__esi, _t357,  &_v172);
    asm("fld qword [ebp+0xffffff58]");
    asm("fld qword [ebp+0xffffff60]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff54]");
    asm("fld dword [ebp+0xffffff54]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff54]");
    asm("fld dword [ebp+0xffffff54]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff44]");
    asm("fstp dword [ebp+0xffffff44]");
    _v288 =  &(k.width);
     *__esp = _v192;
    _v292 = _v192;
    quantum_scalar_qureg();
    _v288 =  &(k.width);
    _v292 = reg;
     *__esp =  &_v156;
    quantum_vectoradd();
    __esp = __esp - 4;
    tmp.width = _v156;
    _v92 = _v152;
    _v88 = _v148;
    _v84 = _v144;
    _v80 = _v140;
    _v292 =  &(k.width);
     *__esp = 1051372203;
    _v296 = 0;
    quantum_scalar_qureg();
    _v296 =  &(k.width);
     *__esp =  &(out.width);
    quantum_vectoradd_inplace();
    quantum_delete_qureg( &(k.width));
    asm("fld qword [ebp-0x70]");
    asm("fadd qword [ebp-0x78]");
    _v284 =  &(tmp.width);
    asm("fstp qword [esp+0x8]");
    _v296 = H;
     *__esp =  &_v156;
    quantum_matrix_qureg();
    __esp = __esp - 4;
    k.width = _v156;
    _v52 = _v152;
    _v48 = _v148;
    _v44 = _v144;
    _v40 = _v140;
    quantum_delete_qureg( &(tmp.width));
    asm("fld qword [ebp-0x78]");
    asm("fldz ");
    asm("fld1 ");
    asm("fchs ");
    asm("fstp qword [esp+0x1c]");
    asm("fldz ");
    asm("fstp qword [esp+0x14]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    __muldc3(__esi, _t357,  &_v172);
    asm("fld qword [ebp+0xffffff58]");
    asm("fld qword [ebp+0xffffff60]");
    asm("fldz ");
    asm("fstp qword [esp+0x1c]");
    asm("fld qword [0x8054438]");
    asm("fstp qword [esp+0x14]");
    asm("fstp qword [esp+0xc]");
    asm("fstp qword [esp+0x4]");
    __divdc3( &_v156, __esi, _t357,  &_v172);
    asm("fld qword [ebp+0xffffff58]");
    asm("fld qword [ebp+0xffffff60]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff54]");
    asm("fld dword [ebp+0xffffff54]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff54]");
    asm("fld dword [ebp+0xffffff54]");
    asm("fxch st0, st1");
    asm("fstp dword [ebp+0xffffff44]");
    asm("fstp dword [ebp+0xffffff44]");
    _v304 =  &(k.width);
     *__esp = _v192;
    _v308 = _v192;
    quantum_scalar_qureg();
    _v308 =  &(k.width);
     *__esp =  &(out.width);
    quantum_vectoradd_inplace();
    quantum_delete_qureg( &(k.width));
    quantum_delete_qureg(reg);
    i = 0;
    while(_v72 > i) {
        _t355 = _v64 + (i << 4);
         *__esp =  *_t355;
        _v280 = _t355[1];
        quantum_prob();
        asm("fld qword [ebp-0x20]");
        asm("faddp st1, st0");
        asm("fstp qword [ebp-0x20]");
        i = i + 1;
    }
    _v60 = hash;
    _v68 = hashw;
    _t356 = reg;
     *_t356 = out.width;
    _t356->size = _v72;
    _t356->hashw = _v68;
    _t356->node = _v64;
    _t356->hash = _v60;
    return;
}

double quantum_rk4a(quantum_reg* reg, double t, double* dt, double epsilon, _None* H)
{// addr = 0x0805057C  --  defined in 'qtime.c' at line 106
    double delta;                          // _cfa_ffffffdc
    double r;                              // _cfa_ffffffd4
    double dtused;                         // _cfa_ffffffcc
    int i;                                 // _cfa_fffffff0
    _Unknown_base* hash;                   // _cfa_ffffffec
    int hashw;                             // _cfa_ffffffe8
    void* _v60;           // _cfa_ffffffc4
    quantum_reg reg2;   // _cfa_ffffffb8
    int* _v76;                             // _cfa_ffffffb4
    void* _v80;           // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    int _v88;                              // _cfa_ffffffa8
    quantum_reg old;   // _cfa_ffffffa4
    int* _v96;                             // _cfa_ffffffa0
    quantum_reg_node* _v100;   // _cfa_ffffff9c
    int _v104;                             // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    quantum_reg tmp;   // _cfa_ffffff90
    intOrPtr _v128;                        // _cfa_ffffff80
    intOrPtr _v132;                        // _cfa_ffffff7c
    intOrPtr _v136;                        // _cfa_ffffff78
    intOrPtr _v140;                        // _cfa_ffffff74
    int* _v176;                            // _cfa_ffffff50
    _None* _v184;                          // _cfa_ffffff48
    _unknown_ _v196;                       // _cfa_ffffff3c
    int* _v200;                            // _cfa_ffffff38
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t206;                       // _t206
    _unknown_ _t209;                       // _t209
    _unknown_ _t212;                       // _t212
    int** _t220;                           // _t220
    int** _t223;                           // _t223
    int** _t229;                           // _t229
    int** _t232;                           // _t232
    int** _t238;                           // _t238
    int** _t241;                           // _t241
    int** _t247;                           // _t247
    int** _t250;                           // _t250
    int** _t256;                           // _t256
    int** _t259;                           // _t259
    int** _t265;                           // _t265
    int** _t268;                           // _t268
    _unknown_ _t271;                       // _t271
    _unknown_ _t272;                       // _t272
    _unknown_ _t273;                       // _t273
    double _t275;                          // _t275
    _unknown_ _t295;                       // _t295
    _unknown_ _t300;                       // _t300
    quantum_reg* _t333;   // _t333
    quantum_reg* _t334;   // _t334

    _v132 = _a8;
    _v128 = _a12;
    _v140 = _a20;
    _v136 = _a24;
    hash = reg->hash;
    reg->hash = 0;
    hashw = reg->hashw;
    reg->hashw = 0;
    quantum_copy_qureg(reg,  &(old.width));
    quantum_copy_qureg(reg,  &(reg2.width));
    goto L1;
    do {
L1:
        asm("fld qword [eax]");
        _v184 = H;
        asm("fstp qword [esp+0xc]");
        asm("fld qword [ebp-0x80]");
        asm("fstp qword [esp+0x4]");
         *__esp = reg;
        quantum_rk4();
        asm("fld qword [eax]");
        asm("fld qword [0x8054430]");
        asm("fdivp st1, st0");
        _v184 = H;
        asm("fstp qword [esp+0xc]");
        asm("fld qword [ebp-0x80]");
        asm("fstp qword [esp+0x4]");
         *__esp =  &(reg2.width);
        quantum_rk4();
        asm("fld qword [eax]");
        asm("fld qword [0x8054430]");
        asm("fdivp st1, st0");
        _v184 = H;
        asm("fstp qword [esp+0xc]");
        asm("fld qword [ebp-0x80]");
        asm("fstp qword [esp+0x4]");
         *__esp =  &(reg2.width);
        quantum_rk4();
        asm("fldz ");
        asm("fstp qword [ebp-0x20]");
        i = 0;
        while(1) {
            __eflags = reg->size - i;
            if(__eflags <= 0) {
                break;
            }
            _t220 = reg->node + (i << 4);
            _t223 = _v60 + (i << 4);
            _v176 =  *_t220;
            asm("fld dword [ebp+0xffffff54]");
            _v176 = _t220[1];
            asm("fld dword [ebp+0xffffff54]");
            _v176 =  *_t223;
            asm("fld dword [ebp+0xffffff54]");
            _v176 = _t223[1];
            asm("fld dword [ebp+0xffffff54]");
            asm("fxch st0, st1");
            asm("fsubp st3, st0");
            asm("fsubp st1, st0");
            asm("fxch st0, st1");
            asm("fstp dword [ebp+0xffffff54]");
            asm("fstp dword [ebp+0xffffff54]");
             *__esp = _v176;
            _v200 = _v176;
            quantum_real();
            asm("fstp dword [ebp+0xffffff64]");
            _t229 = reg->node + (i << 4);
            _t232 = _v60 + (i << 4);
            _v176 =  *_t229;
            asm("fld dword [ebp+0xffffff54]");
            _v176 = _t229[1];
            asm("fld dword [ebp+0xffffff54]");
            _v176 =  *_t232;
            asm("fld dword [ebp+0xffffff54]");
            _v176 = _t232[1];
            asm("fld dword [ebp+0xffffff54]");
            asm("fxch st0, st1");
            asm("fsubp st3, st0");
            asm("fsubp st1, st0");
            asm("fxch st0, st1");
            asm("fstp dword [ebp+0xffffff54]");
            asm("fstp dword [ebp+0xffffff54]");
             *__esp = _v176;
            _v200 = _v176;
            quantum_imag();
            asm("fld dword [ebp+0xffffff64]");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags <= 0) {
                _t238 = reg->node + (i << 4);
                _t241 = _v60 + (i << 4);
                _v176 =  *_t238;
                asm("fld dword [ebp+0xffffff54]");
                _v176 = _t238[1];
                asm("fld dword [ebp+0xffffff54]");
                _v176 =  *_t241;
                asm("fld dword [ebp+0xffffff54]");
                _v176 = _t241[1];
                asm("fld dword [ebp+0xffffff54]");
                asm("fxch st0, st1");
                asm("fsubp st3, st0");
                asm("fsubp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp+0xffffff54]");
                asm("fstp dword [ebp+0xffffff54]");
                 *__esp = _v176;
                _v200 = _v176;
                quantum_imag();
                asm("fld st0, st0");
                asm("faddp st1, st0");
                asm("fstp dword [ebp+0xffffff6c]");
                _t247 = reg->node + (i << 4);
                _t250 = _v60 + (i << 4);
                _v176 =  *_t247;
                asm("fld dword [ebp+0xffffff54]");
                _v176 = _t247[1];
                asm("fld dword [ebp+0xffffff54]");
                _v176 =  *_t250;
                asm("fld dword [ebp+0xffffff54]");
                _v176 = _t250[1];
                asm("fld dword [ebp+0xffffff54]");
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp+0xffffff54]");
                asm("fstp dword [ebp+0xffffff54]");
                 *__esp = _v176;
                _v200 = _v176;
                quantum_imag();
                asm("fdivr dword [ebp+0xffffff6c]");
                asm("fstp qword [ebp-0x28]");
            } else {
                _t256 = reg->node + (i << 4);
                _t259 = _v60 + (i << 4);
                _v176 =  *_t256;
                asm("fld dword [ebp+0xffffff54]");
                _v176 = _t256[1];
                asm("fld dword [ebp+0xffffff54]");
                _v176 =  *_t259;
                asm("fld dword [ebp+0xffffff54]");
                _v176 = _t259[1];
                asm("fld dword [ebp+0xffffff54]");
                asm("fxch st0, st1");
                asm("fsubp st3, st0");
                asm("fsubp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp+0xffffff54]");
                asm("fstp dword [ebp+0xffffff54]");
                 *__esp = _v176;
                _v200 = _v176;
                quantum_real();
                asm("fld st0, st0");
                asm("faddp st1, st0");
                asm("fstp dword [ebp+0xffffff68]");
                _t265 = reg->node + (i << 4);
                _t268 = _v60 + (i << 4);
                _v176 =  *_t265;
                asm("fld dword [ebp+0xffffff54]");
                _v176 = _t265[1];
                asm("fld dword [ebp+0xffffff54]");
                _v176 =  *_t268;
                asm("fld dword [ebp+0xffffff54]");
                _v176 = _t268[1];
                asm("fld dword [ebp+0xffffff54]");
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp+0xffffff54]");
                asm("fstp dword [ebp+0xffffff54]");
                 *__esp = _v176;
                _v200 = _v176;
                quantum_real();
                asm("fdivr dword [ebp+0xffffff68]");
                asm("fstp qword [ebp-0x28]");
            }
            asm("fld qword [ebp-0x28]");
            asm("fld qword [ebp-0x20]");
            asm("fxch st0, st1");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags > 0) {
                asm("fld qword [ebp-0x28]");
                asm("fstp qword [ebp-0x20]");
            }
            i = i + 1;
        }
        asm("fld qword [eax]");
        asm("fstp qword [ebp-0x30]");
        asm("fld qword [eax]");
        asm("fstp qword [ebp+0xffffff70]");
        asm("fld qword [ebp+0xffffff78]");
        asm("fdiv qword [ebp-0x20]");
        asm("fld qword [0x8054440]");
        asm("fstp qword [esp+0x8]");
        asm("fstp qword [esp]");
        pow();
        asm("fmul qword [ebp+0xffffff70]");
        asm("fstp qword [eax]");
        asm("fld qword [ebp-0x20]");
        asm("fld qword [ebp+0xffffff78]");
        asm("fxch st0, st1");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags > 0) {
            _t333 = reg;
            tmp.width =  *_t333;
            _v108 = _t333->size;
            _v104 = _t333->hashw;
            _v100 = _t333->node;
            _v96 = _t333->hash;
            _t334 = reg;
             *_t334 = old.width;
            _t334->size = _v88;
            _t334->hashw = _v84;
            _t334->node = _v80;
            _t334->hash = _v76;
            old.width = tmp.width;
            _v88 = _v108;
            _v84 = _v104;
            _v80 = _v100;
            _v76 = _v96;
            memcpy(_v60, reg->node, reg->size << 4);
            memcpy(_v80, reg->node, reg->size << 4);
        }
        asm("fld qword [ebp-0x20]");
        asm("fld qword [ebp+0xffffff78]");
        asm("fxch st0, st1");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
    } while(__eflags > 0);
    reg->hash = hash;
    _t275 = hashw;
    reg->hashw = _t275;
    asm("fld qword [ebp-0x30]");
    return _t275;
}

float quantum_real(complex float a)
{// addr = 0x08050B0E  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t7;                             // _t7

    p =  &a;
    _t7 =  *p;
    _v24 = _t7;
    asm("fld dword [ebp-0x14]");
    return _t7;
}

float quantum_imag(complex float a)
{// addr = 0x08050B27  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t8;                             // _t8

    p =  &a;
    _t8 = p[1];
    _v24 = _t8;
    asm("fld dword [ebp-0x14]");
    return _t8;
}

quantum_reg quantum_matrix2qureg(quantum_matrix* m, int width)
{// addr = 0x08050B44  --  defined in 'qureg.c' at line 40
    int i;                                 // _cfa_fffffff8
    int j;                                 // _cfa_fffffff4
    int size;                              // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    quantum_reg reg;   // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t91;                        // _t91
    _unknown_ _t101;                       // _t101
    _unknown_ _t102;                       // _t102
    _unknown_ _t106;                       // _t106
    _unknown_ _t108;                       // _t108
    _unknown_ _t114;                       // _t114
    _unknown_ _t118;                       // _t118
    _unknown_ _t124;                       // _t124
    _unknown_ _t134;                       // _t134
    _unknown_ _t135;                       // _t135

    size = 0;
    if(m->cols != 1) {
        quantum_error(65536);
    }
    reg.width = width;
    i = 0;
    while() {
    }
}

quantum_reg quantum_new_qureg(long long unsigned int initval, int width)
{// addr = 0x08050D20  --  defined in 'qureg.c' at line 98
    char* c;                               // _cfa_fffffff8
    void* _v12;           // _cfa_fffffff4
    void* _v16;           // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    quantum_reg reg;   // _cfa_ffffffe4
    void _v40;                             // _cfa_ffffffd8
    void _v44;                             // _cfa_ffffffd4
    void _v52;                             // _cfa_ffffffcc
    void _v56;                             // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t58;                        // _t58
    _unknown_ _t59;                        // _t59
    _unknown_ _t63;                        // _t63
    _unknown_ _t65;                        // _t65
    _unknown_ _t67;                        // _t67
    _unknown_ _t68;                        // _t68
    _unknown_ _t71;                        // _t71
    _unknown_ _t80;                        // _t80
    void* _t83;           // _t83
    void* _t85;           // _t85

    _v44 = _a8;
    _v40 = _a12;
    reg.width = width;
    _v24 = 1;
    _v20 = width + 2;
    _v16 = calloc(1, 16);
    if(_v16 == 0) {
        quantum_error(2);
    }
    quantum_memman(16);
    _v12 = calloc(1 << (_v20 & 255), 4);
    if(_v12 == 0) {
        quantum_error(2);
    }
    quantum_memman(4 << (_v20 & 255));
    _t83 = _v16;
    _t83[2] = _v44;
    _t83[3] = _v40;
    _t85 = _v16;
     *_t85 = 1065353216;
    _t85[1] = 0;
    c = getenv("QUOBFILE");
    if(c != 0) {
        quantum_objcode_start();
        quantum_objcode_file(c);
        atexit(quantum_objcode_exit);
    }
    _v56 = _v44;
    _v52 = _v40;
    quantum_objcode_put(0);
     *(_a4.width) = reg.width;
     *(_a4.width + 4) = _v24;
     *(_a4.width + 8) = _v20;
     *(_a4.width + 12) = _v16;
     *(_a4.width + 16) = _v12;
    return _a4;
}

quantum_reg quantum_new_qureg_size(int n, int width)
{// addr = 0x08050E60  --  defined in 'qureg.c' at line 151
    intOrPtr _v8;                          // _cfa_fffffff8
    void* _v12;           // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    quantum_reg reg;   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t34;                        // _t34

    reg.width = width;
    _v20 = n;
    _v16 = 0;
    _v8 = 0;
    _v12 = calloc(n, 16);
    if(_v12 == 0) {
        quantum_error(2);
    }
    quantum_memman(n << 4);
     *(_a4.width) = reg.width;
     *(_a4.width + 4) = _v20;
     *((intOrPtr*)(_a4.width + 8)) = _v16;
     *(_a4.width + 12) = _v12;
     *((intOrPtr*)(_a4.width + 16)) = _v8;
    return _a4;
}

quantum_matrix quantum_qureg2matrix(quantum_reg reg)
{// addr = 0x08050EEA  --  defined in 'qureg.c' at line 175
    int i;                                 // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    quantum_matrix m;   // _cfa_ffffffec
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    intOrPtr* _t42;                        // _t42
    intOrPtr* _t50;                        // _t50
    _unknown_ _t53;                        // _t53

    _v36 = 1 << (reg.width & 255);
    quantum_new_matrix( &(m.rows), 1);
    __esp = __esp - 4;
    i = 0;
    while(reg.size > i) {
        _t50 = _v12 + ( *(reg.node + (i << 4) + 8) << 3);
        _t42 = reg.node + (i << 4);
         *_t50 =  *_t42;
         *((intOrPtr*)(_t50 + 4)) =  *((intOrPtr*)(_t42 + 4));
        i = i + 1;
    }
     *(_a4.rows) = m.rows;
     *((intOrPtr*)(_a4.rows + 4)) = _v16;
     *((intOrPtr*)(_a4.rows + 8)) = _v12;
    return _a4;
}

quantum_destroy_hash(quantum_reg* reg)
{// addr = 0x08050F7A  --  defined in 'qureg.c' at line 191
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11
    _unknown_ _t13;                        // _t13
    _unknown_ _t15;                        // _t15

    free(reg->hash);
    quantum_memman(-4 << (reg->hashw & 255));
    reg->hash = 0;
    return;
}

quantum_delete_qureg(quantum_reg* reg)
{// addr = 0x08050FAF  --  defined in 'qureg.c' at line 201
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    _unknown_ _t21;                        // _t21

    if(reg->hashw != 0 && reg->hash != 0) {
        quantum_destroy_hash(reg);
    }
    free(reg->node);
    quantum_memman( ~(reg->size << 4));
    reg->node = 0;
    return;
}

quantum_delete_qureg_hashpreserve(quantum_reg* reg)
{// addr = 0x08051001  --  defined in 'qureg.c' at line 213
    _unknown_ __ebp;                       // r6
    _unknown_ _t9;                         // _t9
    _unknown_ _t14;                        // _t14

    free(reg->node);
    quantum_memman( ~(reg->size << 4));
    reg->node = 0;
    return;
}

quantum_copy_qureg(quantum_reg* src, quantum_reg* dst)
{// addr = 0x08051034  --  defined in 'qureg.c' at line 223
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t57;                        // _t57
    _unknown_ _t65;                        // _t65
    _unknown_ _t67;                        // _t67
    _unknown_ _t74;                        // _t74
    _unknown_ _t76;                        // _t76
    quantum_reg* _t77;   // _t77
    quantum_reg* _t81;   // _t81

    _t77 = dst;
    _t81 = src;
    _t77->width = _t81->width;
    _t77->size = _t81->size;
    _t77->hashw = _t81->hashw;
    _t77->node = _t81->node;
    _t77->hash = _t81->hash;
    dst->node = calloc(dst->size, 16);
    if(dst->node == 0) {
        quantum_error(2);
    }
    quantum_memman(dst->size << 4);
    if(dst->hashw != 0) {
        dst->hash = calloc(1 << (dst->hashw & 255), 4);
        if(dst->hash == 0) {
            quantum_error(2);
        }
        quantum_memman(4 << (dst->hashw & 255));
    }
    memcpy(dst->node, src->node, src->size << 4);
    return;
}

quantum_print_qureg(quantum_reg reg)
{// addr = 0x08051124  --  defined in 'qureg.c' at line 255
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    signed int _v88;                       // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    _unknown_ _t52;                        // _t52
    _unknown_ _t61;                        // _t61
    _unknown_ _t71;                        // _t71
    signed int _t72;                       // _t72
    _unknown_ _t74;                        // _t74
    _unknown_ _t75;                        // _t75
    _unknown_ _t76;                        // _t76
    _unknown_ _t77;                        // _t77
    signed int _t80;                       // _t80
    intOrPtr* _t82;                        // _t82
    intOrPtr* _t85;                        // _t85
    intOrPtr* _t87;                        // _t87
    signed int _t91;                       // _t91
    _unknown_ _t92;                        // _t92

    i = 0;
    while(reg.size > i) {
        _t82 = reg.node + (i << 4);
         *__esp =  *_t82;
        _v88 =  *(_t82 + 4);
        quantum_prob_inline();
        asm("fstp qword [ebp-0x28]");
        _t52 = reg.node + (i << 4);
        _t85 = reg.node + (i << 4);
         *__esp =  *_t85;
        _v88 =  *(_t85 + 4);
        quantum_imag();
        asm("fstp qword [ebp-0x20]");
        _t87 = reg.node + (i << 4);
         *__esp =  *_t87;
        _v88 =  *(_t87 + 4);
        quantum_real();
        asm("fld qword [ebp-0x28]");
        asm("fstp qword [esp+0x1c]");
        _v72 =  *((intOrPtr*)(_t52 + 8));
        _v68 =  *((intOrPtr*)(_t52 + 12));
        asm("fld qword [ebp-0x20]");
        asm("fstp qword [esp+0xc]");
        asm("fstp qword [esp+0x4]");
        printf("% f %+fi|%lli> (%e) (|");
        j = reg.width - 1;
        while(j >= 0) {
            if((j + (j >> 31 >> 30) & 3) - (j >> 31 >> 30) == 3) {
                putchar(32);
            }
            _t71 = reg.node + (i << 4);
            _t72 =  *(_t71 + 8);
            _t80 = j;
            asm("shrd eax, edx, cl");
            _t91 =  *(_t71 + 12) >> (_t80 & 255);
            if((_t80 & 0x20) != 0) {
                _t72 = _t91;
            }
            _v88 = _t72 & 1;
            printf("%i");
            j = j - 1;
        }
        puts(">)");
        i = i + 1;
    }
    putchar(10);
    return;
}

float quantum_prob_inline(complex float a)
{// addr = 0x0805126A  --  defined in 'complex.h' at line 57
    float r;                               // _cfa_fffffff8
    float i;                               // _cfa_fffffff4
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t10;                            // _t10

     *__esp = a;
    _v24 = _a8;
    quantum_real();
    asm("fstp dword [ebp-0x4]");
     *__esp = a;
    _t10 = _a8;
    _v24 = _t10;
    quantum_imag();
    asm("fstp dword [ebp-0x8]");
    asm("fld dword [ebp-0x4]");
    asm("fmul dword [ebp-0x4]");
    asm("fld dword [ebp-0x8]");
    asm("fmul dword [ebp-0x8]");
    asm("faddp st1, st0");
    return _t10;
}

float quantum_imag(complex float a)
{// addr = 0x080512AA  --  defined in 'complex.h' at line 48
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t8;                             // _t8

    p =  &a;
    _t8 = p[1];
    _v24 = _t8;
    asm("fld dword [ebp-0x14]");
    return _t8;
}

float quantum_real(complex float a)
{// addr = 0x080512C6  --  defined in 'complex.h' at line 39
    float* p;                              // _cfa_fffffff8
    float _v24;                            // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    float _t7;                             // _t7

    p =  &a;
    _t7 =  *p;
    _v24 = _t7;
    asm("fld dword [ebp-0x14]");
    return _t7;
}

quantum_print_expn(quantum_reg reg)
{// addr = 0x080512DF  --  defined in 'qureg.c' at line 280
    int i;                                 // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    _unknown_ _t35;                        // _t35
    _unknown_ _t44;                        // _t44

    i = 0;
    while(reg.size > i) {
        _t26 = reg.node + (i << 4);
        _v36 =  *((intOrPtr*)(_t26 + 8));
        _v32 =  *((intOrPtr*)(_t26 + 12));
        asm("sbb ebx, edx");
        _v52 = _v36 - (i << ((reg.width >> 31) + reg.width >> 1 & 255));
        _v48 = _v32;
        _v56 = i;
        printf("%i: %lli\n");
        i = i + 1;
    }
    return;
}

quantum_addscratch(int bits, quantum_reg* reg)
{// addr = 0x0805135C  --  defined in 'qureg.c' at line 294
    int i;                                 // _cfa_fffffff8
    int oldwidth;                          // _cfa_fffffff4
    long long unsigned int _v16;           // _cfa_fffffff0
    long long unsigned int l;              // _cfa_ffffffec
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    long long unsigned int _t47;           // _t47
    signed int _t52;                       // _t52
    _unknown_ _t53;                        // _t53
    long long unsigned int _t57;           // _t57

    oldwidth = reg->width;
    reg->width = reg->width + bits;
    i = 0;
    while(reg->size > i) {
        _t45 = reg->node + (i << 4);
        _t57 =  *(_t45 + 12);
        _t52 = bits;
        asm("shld edx, eax, cl");
        _t47 =  *(_t45 + 8) << (_t52 & 255);
        if((_t52 & 0x20) != 0) {
            _t57 = _t47;
            _t47 = 0;
        }
        l = _t47;
        _v16 = _t57;
        _t53 = reg->node + (i << 4);
         *(_t53 + 8) = l;
         *(_t53 + 12) = _v16;
        i = i + 1;
    }
    return;
}

quantum_print_hash(quantum_reg reg)
{// addr = 0x080513DA  --  defined in 'qureg.c' at line 314
    int i;                                 // _cfa_fffffff4
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24
    _unknown_ _t30;                        // _t30
    _unknown_ _t34;                        // _t34
    _unknown_ _t41;                        // _t41

    i = 0;
    while(1 << (_a12 & 255) > i) {
        if(i != 0) {
            _t34 = _a16 +  ~(1 -  *((intOrPtr*)(_a20 + (i << 2))) << 4);
            _v32 =  *((intOrPtr*)(_t34 + 8));
            _v28 =  *((intOrPtr*)(_t34 + 12));
            _v36 =  *((intOrPtr*)(_a20 + (i << 2))) - 1;
            _v40 = i;
            printf("%i: %i %llu\n");
        }
        i = i + 1;
    }
    return;
}

quantum_reg quantum_kronecker(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x08051461  --  defined in 'qureg.c' at line 330
    int i;                                 // _cfa_ffffffec
    int j;                                 // _cfa_ffffffe8
    void* _v28;           // _cfa_ffffffe4
    void* _v32;           // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    quantum_reg reg;   // _cfa_ffffffd4
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t104;                       // _t104
    _unknown_ _t123;                       // _t123
    _unknown_ _t124;                       // _t124
    _unknown_ _t128;                       // _t128
    _unknown_ _t130;                       // _t130
    quantum_reg* _t133;   // _t133
    _unknown_ _t143;                       // _t143
    _unknown_ _t148;                       // _t148
    intOrPtr* _t159;                       // _t159
    intOrPtr* _t163;                       // _t163
    signed int _t179;                      // _t179
    intOrPtr _t181;                        // _t181
    _unknown_ _t187;                       // _t187
    intOrPtr _t200;                        // _t200
    signed int _t205;                      // _t205
    intOrPtr* _t206;                       // _t206
    signed int _t209;                      // _t209

    reg.width = reg1->width + reg2->width;
    _v40 = reg2->size * reg1->size;
    _v36 = reg2->size * reg1->size + 2;
    _v32 = calloc(_v40, 16);
    if(_v32 == 0) {
        quantum_error(2);
    }
    quantum_memman(_v40 << 4);
    _v28 = calloc(1 << (_v36 & 255), 4);
    if(_v28 == 0) {
        quantum_error(2);
    }
    quantum_memman(4 << (_v36 & 255));
    i = 0;
    while(reg1->size > i) {
        j = 0;
        while(1) {
            _t133 = reg2;
            __eflags = _t133->size - j;
            if(_t133->size <= j) {
                break;
            }
            _v52 = _v32 + (reg2->size * i + j << 4);
            _t143 = reg1->node + (i << 4);
            _t179 = reg2->width;
            _t205 =  *(_t143 + 12);
            asm("shld edi, esi, cl");
            _t209 =  *(_t143 + 8) << (_t179 & 255);
            __eflags = _t179 & 0x20;
            if(__eflags != 0) {
                _t205 = _t209;
                _t209 = 0;
            }
            _t148 = reg2->node + (j << 4);
            _t181 = _v52;
             *(_t181 + 8) = _t209 |  *(_t148 + 8);
             *(_t181 + 12) = _t205 |  *(_t148 + 12);
            _t206 = _v32 + (reg2->size * i + j << 4);
            _t159 = reg1->node + (i << 4);
            _t163 = reg2->node + (j << 4);
            _t200 =  *_t163;
            _v64 =  *((intOrPtr*)(_t163 + 4));
            _v68 = _t200;
            _v72 =  *((intOrPtr*)(_t159 + 4));
             *__esp =  *_t159;
             *_t206 = __mulsc3( *((intOrPtr*)(_t159 + 4)),  *_t159, __eflags);
             *((intOrPtr*)(_t206 + 4)) = _t200;
            j = j + 1;
        }
        i = i + 1;
    }
     *(_a4.width) = reg.width;
     *(_a4.width + 4) = _v40;
     *(_a4.width + 8) = _v36;
     *(_a4.width + 12) = _v32;
     *(_a4.width + 16) = _v28;
    return _a4;
}

quantum_reg quantum_state_collapse(int pos, int value, quantum_reg reg)
{// addr = 0x0805165E  --  defined in 'qureg.c' at line 376
    double d;                              // _cfa_ffffffdc
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int size;                              // _cfa_ffffffe4
    signed int _v40;                       // _cfa_ffffffd8
    long long unsigned int lpat;           // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    long long unsigned int rpat;           // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    long long unsigned int pos2;           // _cfa_ffffffc4
    int* _v64;                             // _cfa_ffffffc0
    void* _v68;           // _cfa_ffffffbc
    int _v72;                              // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    quantum_reg out;   // _cfa_ffffffb0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    intOrPtr* _v108;                       // _cfa_ffffff94
    intOrPtr _v120;                        // _cfa_ffffff88
    long long unsigned int _v128;          // _cfa_ffffff80
    intOrPtr _v132;                        // _cfa_ffffff7c
    intOrPtr _v136;                        // _cfa_ffffff78
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t168;                       // _t168
    _unknown_ _t169;                       // _t169
    long long unsigned int _t170;          // _t170
    _unknown_ _t174;                       // _t174
    _unknown_ _t180;                       // _t180
    _unknown_ _t196;                       // _t196
    _unknown_ _t202;                       // _t202
    _unknown_ _t208;                       // _t208
    _unknown_ _t213;                       // _t213
    signed int _t214;                      // _t214
    _unknown_ _t217;                       // _t217
    _unknown_ _t220;                       // _t220
    signed int _t221;                      // _t221
    _unknown_ _t224;                       // _t224
    _unknown_ _t234;                       // _t234
    _unknown_ _t235;                       // _t235
    _unknown_ _t237;                       // _t237
    signed int _t255;                      // _t255
    signed int _t262;                      // _t262
    signed int _t263;                      // _t263
    _unknown_ _t265;                       // _t265
    _unknown_ _t268;                       // _t268
    long long unsigned int _t269;          // _t269
    _unknown_ _t285;                       // _t285
    _unknown_ _t288;                       // _t288
    _unknown_ _t297;                       // _t297
    intOrPtr _t298;                        // _t298
    _unknown_ _t300;                       // _t300
    _unknown_ _t301;                       // _t301
    intOrPtr* _t303;                       // _t303
    _unknown_ _t304;                       // _t304

    __esp = __esp + -128;
    size = 0;
    asm("fldz ");
    asm("fstp qword [ebp-0x20]");
    lpat = 0;
    _v40 = 0;
    rpat = 0;
    _v48 = 0;
    _t255 = pos;
    _t269 = 0;
    asm("shld edx, eax, cl");
    _t170 = 1 << (_t255 & 255);
    if((_t255 & 0x20) != 0) {
        _t269 = _t170;
        _t170 = 0;
    }
    pos2 = _t170;
    _v56 = _t269;
    i = 0;
    while(reg.size > i) {
        _t174 = reg.node + (i << 4);
        __eflags =  *(_t174 + 8) & pos2 |  *(_t174 + 12) & _v56;
        if(( *(_t174 + 8) & pos2 |  *(_t174 + 12) & _v56) == 0) {
L5:
            _t180 = reg.node + (i << 4);
            __eflags =  *(_t180 + 8) & pos2 |  *(_t180 + 12) & _v56;
            if(( *(_t180 + 8) & pos2 |  *(_t180 + 12) & _v56) != 0) {
                goto L8;
            }
            goto L6;
        }
        __eflags = value;
        if(value != 0) {
L7:
            _t303 = reg.node + (i << 4);
             *__esp =  *_t303;
            _v136 =  *((intOrPtr*)(_t303 + 4));
            quantum_prob_inline();
            asm("fld qword [ebp-0x20]");
            asm("faddp st1, st0");
            asm("fstp qword [ebp-0x20]");
            size = size + 1;
            goto L8;
        }
        goto L5;
L8:
        i = i + 1;
        continue;
L6:
        __eflags = value;
        if(value != 0) {
            goto L8;
        }
        goto L7;
    }
    out.width = reg.width - 1;
    _v76 = size;
    _v68 = calloc(size, 16);
    if(_v68 == 0) {
        quantum_error(2);
    }
    quantum_memman(size << 4);
    _v72 = reg.hashw;
    _v64 = reg.hash;
    i = 0;
    j = 0;
    while(reg.size > i) {
        _t202 = reg.node + (i << 4);
        __eflags =  *(_t202 + 8) & pos2 |  *(_t202 + 12) & _v56;
        if(( *(_t202 + 8) & pos2 |  *(_t202 + 12) & _v56) == 0) {
L15:
            _t208 = reg.node + (i << 4);
            __eflags =  *(_t208 + 8) & pos2 |  *(_t208 + 12) & _v56;
            if(( *(_t208 + 8) & pos2 |  *(_t208 + 12) & _v56) != 0) {
                goto L31;
            }
            goto L16;
        }
        __eflags = value;
        if(value != 0) {
L17:
            k = 0;
            rpat = 0;
            _v48 = 0;
            while(1) {
L21:
                __eflags = k - pos;
                if(k >= pos) {
                    break;
                }
                goto L18;
            }
            _t217 = reg.node + (i << 4);
            rpat = rpat &  *(_t217 + 8);
            _v48 = _v48 &  *(_t217 + 12);
            k = 63;
            lpat = 0;
            _v40 = 0;
            while(1) {
                __eflags = k - pos;
                if(__eflags <= 0) {
                    break;
                }
                _t263 = k;
                asm("shld edx, eax, cl");
                _t221 = 1 << (_t263 & 255);
                __eflags = _t263 & 0x20;
                if((_t263 & 0x20) != 0) {
                    _t221 = 0;
                }
                lpat = lpat + _t221;
                asm("adc [ebp-0x24], edx");
                k = k - 1;
            }
            _t224 = reg.node + (i << 4);
            lpat = lpat &  *(_t224 + 8);
            _v40 = _v40 &  *(_t224 + 12);
            _t304 = _v68 + (j << 4);
            asm("shrd ecx, ebx, 0x1");
             *(_t304 + 8) = lpat | rpat;
             *(_t304 + 12) = _v40 >> 1 | _v48;
            _v108 = _v68 + (j << 4);
            asm("fld dword [eax]");
            asm("fstp dword [ebp-0x60]");
            asm("fld dword [eax+0x4]");
            asm("fstp dword [ebp-0x64]");
            asm("fld qword [ebp-0x20]");
            asm("fsqrt ");
            asm("fstp qword [ebp-0x70]");
            asm("fld qword [ebp-0x70]");
            asm("fucomp st0");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0 || __eflags != 0) {
                asm("fld qword [ebp-0x20]");
                asm("fstp qword [esp]");
                sqrt();
                asm("fstp qword [ebp-0x70]");
            }
            asm("fld qword [ebp-0x70]");
            asm("fstp dword [ebp-0x5c]");
            asm("fld dword [ebp-0x5c]");
            asm("fstp dword [ebp-0x74]");
            _t298 = _v120;
            _v128 = 0;
            _v132 = _t298;
            _v136 = _v104;
             *__esp = _v100;
             *_v108 = __divsc3(0, _v100, __eflags);
             *((intOrPtr*)(_v108 + 4)) = _t298;
            j = j + 1;
L31:
            i = i + 1;
            continue;
        }
        goto L15;
L18:
        _t262 = k;
        asm("shld edx, eax, cl");
        _t214 = 1 << (_t262 & 255);
        __eflags = _t262 & 0x20;
        if((_t262 & 0x20) != 0) {
            _t214 = 0;
        }
        rpat = rpat + _t214;
        asm("adc [ebp-0x2c], edx");
        k = k + 1;
        goto L21;
L16:
        __eflags = value;
        if(value != 0) {
            goto L31;
        }
        goto L17;
    }
     *(_a4.width) = out.width;
     *(_a4.width + 4) = _v76;
     *(_a4.width + 8) = _v72;
     *(_a4.width + 12) = _v68;
     *(_a4.width + 16) = _v64;
    __esp = __esp - 128;
    return _a4;
}

complex float quantum_dot_product(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x080519B9  --  defined in 'qureg.c' at line 444
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    complex float f;                       // _cfa_ffffffe4
    complex float _v32;                    // _cfa_ffffffe0
    int* _v36;                             // _cfa_ffffffdc
    quantum_reg_node* _v40;   // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    complex float _v52;                    // _cfa_ffffffcc
    complex float _v56;                    // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54
    _unknown_ _t62;                        // _t62
    complex float _t74;                    // _t74
    complex float* _t79;                   // _t79
    _unknown_ _t98;                        // _t98
    quantum_reg* _t100;   // _t100
    _unknown_ _t102;                       // _t102
    complex float* _t104;                  // _t104
    complex float _t107;                   // _t107

    f = 0;
    _v24 = 0;
    if(reg2->hashw != 0) {
        quantum_reconstruct_hash(reg2);
    }
    i = 0;
    while(reg1->size > i) {
        _t62 = reg1->node + (i << 4);
        _t100 = reg2;
        _v52 = _t100->width;
        _v48 = _t100->size;
        _v44 = _t100->hashw;
        _v40 = _t100->node;
        _v36 = _t100->hash;
         *__esp =  *(_t62 + 8);
        _v56 =  *(_t62 + 12);
        j = quantum_get_state();
        __eflags = j;
        if(__eflags < 0) {
            _t104 = reg1->node + (i << 4);
             *__esp =  *_t104;
            _v56 = _t104[0];
            _t74 = quantum_conj();
            _t79 = reg2->node + (j << 4);
            _t107 =  *_t79;
            __esi = _t74;
            _v48 = _t79[0];
            _v52 = _t107;
            _v56 = _t104;
             *__esp = __esi;
            _v32 = __mulsc3(_t104, __esi, __eflags);
            asm("fld dword [ebp-0x1c]");
            _v32 = _t107;
            asm("fld dword [ebp-0x1c]");
            asm("fld dword [ebp-0x18]");
            asm("fld dword [ebp-0x14]");
            asm("fxch st0, st1");
            asm("faddp st3, st0");
            asm("faddp st1, st0");
            asm("fxch st0, st1");
            asm("fstp dword [ebp-0x1c]");
            asm("fstp dword [ebp-0x1c]");
            f = _v32;
            _v24 = _v32;
        }
        i = i + 1;
    }
    return f;
}

quantum_reconstruct_hash(quantum_reg* reg)
{// addr = 0x08051AF8  --  defined in 'qureg.h' at line 159
    int i;                                 // _cfa_fffffff8
    quantum_reg* _v32;   // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    _unknown_ _t42;                        // _t42

    i = 0;
    while(1 << (reg->hashw & 255) > i) {
        reg->hash[i] = 0;
        i = i + 1;
    }
    i = 0;
    while(reg->size > i) {
        _t42 = reg->node + (i << 4);
        _v32 = reg;
        _v36 = i;
         *__esp =  *((intOrPtr*)(_t42 + 8));
        _v40 =  *((intOrPtr*)(_t42 + 12));
        quantum_add_hash();
        i = i + 1;
    }
    return;
}

quantum_add_hash(long long unsigned int a, int pos, quantum_reg* reg)
{// addr = 0x08051B7B  --  defined in 'qureg.h' at line 131
    int i;                                 // _cfa_fffffff8
    int mark;                              // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    int _v36;                              // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43

    _v28 = _a4;
    _v24 = _a8;
    mark = 0;
    _v36 = reg->hashw;
     *__esp = _v28;
    _v40 = _v24;
    i = quantum_hash64();
    while(reg->hash[i] != 0) {
    }
    reg->hash[i] = pos + 1;
    return;
}

unsigned int quantum_hash64(long long unsigned int key, int width)
{// addr = 0x08051C1A  --  defined in 'qureg.h' at line 91
    unsigned int k32;                      // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    _unknown_ _t19;                        // _t19
    _unknown_ _t24;                        // _t24
    _unknown_ _t27;                        // _t27
    _unknown_ _t30;                        // _t30

    _v28 = _a4;
    _v24 = _a8;
    k32 = _v24 ^ _v28;
    k32 = k32 * k32;
    k32 = k32 >> (32 - width & 255);
    return k32;
}

int quantum_get_state(long long unsigned int a, quantum_reg reg)
{// addr = 0x08051C5C  --  defined in 'qureg.h' at line 106
    int i;                                 // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ __ebp;                       // r6
    _unknown_ _t53;                        // _t53
    _unknown_ _t61;                        // _t61

    _v28 = _a4;
    _v24 = _a8;
    if(_a20 != 0) {
        _v44 = _a20;
         *__esp = _v28;
        _v48 = _v24;
        i = quantum_hash64();
L7:
        while( *((intOrPtr*)(_a28 + (i << 2))) != 0) {
            goto L3;
        }
        _v32 = -1;
        goto L9;
    }
    _v32 = _v28;
L9:
    return _v32;
L3:
    if(( *(_a24 +  ~(1 -  *((intOrPtr*)(_a28 + (i << 2))) << 4) + 8) ^ _v28 |  *(_a24 +  ~(1 -  *((intOrPtr*)(_a28 + (i << 2))) << 4) + 12) ^ _v24) != 0) {
        i = i + 1;
        if(1 << (_a20 & 255) == i) {
            i = 0;
        }
        goto L7;
    }
    _v32 =  *((intOrPtr*)(_a28 + (i << 2))) - 1;
    goto L9;
}

complex float quantum_dot_product_noconj(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x08051D22  --  defined in 'qureg.c' at line 469
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    complex float f;                       // _cfa_ffffffe4
    complex float _v32;                    // _cfa_ffffffe0
    int* _v36;                             // _cfa_ffffffdc
    quantum_reg_node* _v40;   // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    complex float _v52;                    // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54
    _unknown_ _t62;                        // _t62
    intOrPtr* _t72;                        // _t72
    complex float* _t76;                   // _t76
    _unknown_ _t93;                        // _t93
    quantum_reg* _t95;   // _t95
    _unknown_ _t97;                        // _t97
    complex float _t100;                   // _t100

    f = 0;
    _v24 = 0;
    if(reg2->hashw != 0) {
        quantum_reconstruct_hash(reg2);
    }
    i = 0;
    while(reg1->size > i) {
        _t62 = reg1->node + (i << 4);
        _t95 = reg2;
        _v52 = _t95->width;
        _v48 = _t95->size;
        _v44 = _t95->hashw;
        _v40 = _t95->node;
        _v36 = _t95->hash;
         *__esp =  *((intOrPtr*)(_t62 + 8));
        _v56 =  *((intOrPtr*)(_t62 + 12));
        j = quantum_get_state();
        __eflags = j;
        if(__eflags < 0) {
            _t72 = reg1->node + (i << 4);
            _t76 = reg2->node + (j << 4);
            _t100 =  *_t76;
            __esi =  *_t72;
            _v48 = _t76[0];
            _v52 = _t100;
            _v56 =  *((intOrPtr*)(_t72 + 4));
             *__esp = __esi;
            _v32 = __mulsc3( *((intOrPtr*)(_t72 + 4)), __esi, __eflags);
            asm("fld dword [ebp-0x1c]");
            _v32 = _t100;
            asm("fld dword [ebp-0x1c]");
            asm("fld dword [ebp-0x18]");
            asm("fld dword [ebp-0x14]");
            asm("fxch st0, st1");
            asm("faddp st3, st0");
            asm("faddp st1, st0");
            asm("fxch st0, st1");
            asm("fstp dword [ebp-0x1c]");
            asm("fstp dword [ebp-0x1c]");
            f = _v32;
            _v24 = _v32;
        }
        i = i + 1;
    }
    return f;
}

quantum_reg quantum_vectoradd(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x08051E46  --  defined in 'qureg.c' at line 497
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int addsize;                           // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    void* _v36;           // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    quantum_reg reg;   // _cfa_ffffffd0
    intOrPtr _v64;                         // _cfa_ffffffc0
    int* _v68;                             // _cfa_ffffffbc
    quantum_reg_node* _v72;   // _cfa_ffffffb8
    int _v76;                              // _cfa_ffffffb4
    int _v80;                              // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t143;                       // _t143
    _unknown_ _t158;                       // _t158
    _unknown_ _t166;                       // _t166
    _unknown_ _t178;                       // _t178
    intOrPtr* _t185;                       // _t185
    intOrPtr* _t191;                       // _t191
    intOrPtr* _t195;                       // _t195
    _unknown_ _t211;                       // _t211
    intOrPtr* _t212;                       // _t212
    quantum_reg* _t215;   // _t215
    quantum_reg* _t218;   // _t218

    addsize = 0;
    quantum_copy_qureg(reg1,  &(reg.width));
    if(reg1->hashw != 0 || reg2->hashw != 0) {
        quantum_reconstruct_hash(reg1);
        quantum_copy_qureg(reg1,  &(reg.width));
        i = 0;
L6:
        while(reg2->size > i) {
            goto L3;
        }
        goto L7;
    } else {
L7:
        _v44 = _v44 + addsize;
        _v36 = realloc(_v36, _v44 << 4);
        if(_v36 == 0) {
            quantum_error(2);
        }
        quantum_memman(addsize << 4);
        k = reg1->size;
        i = 0;
        while(reg2->size > i) {
            _t166 = reg2->node + (i << 4);
            _t218 = reg1;
            _v84 = _t218->width;
            _v80 = _t218->size;
            _v76 = _t218->hashw;
            _v72 = _t218->node;
            _v68 = _t218->hash;
             *__esp =  *((intOrPtr*)(_t166 + 8));
            _v88 =  *((intOrPtr*)(_t166 + 12));
            j = quantum_get_state();
            if(j >= 0) {
                _t211 = _v36 + (k << 4);
                _t178 = reg2->node + (i << 4);
                 *((intOrPtr*)(_t211 + 8)) =  *((intOrPtr*)(_t178 + 8));
                 *((intOrPtr*)(_t211 + 12)) =  *((intOrPtr*)(_t178 + 12));
                _t212 = _v36 + (k << 4);
                _t185 = reg2->node + (i << 4);
                 *_t212 =  *_t185;
                 *((intOrPtr*)(_t212 + 4)) =  *((intOrPtr*)(_t185 + 4));
                k = k + 1;
            } else {
                __esi = _v36 + (j << 4);
                _t191 = _v36 + (j << 4);
                _t195 = reg2->node + (i << 4);
                _v64 =  *_t191;
                asm("fld dword [ebp-0x3c]");
                _v64 =  *((intOrPtr*)(_t191 + 4));
                asm("fld dword [ebp-0x3c]");
                _v64 =  *_t195;
                asm("fld dword [ebp-0x3c]");
                _v64 =  *((intOrPtr*)(_t195 + 4));
                asm("fld dword [ebp-0x3c]");
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp-0x3c]");
                asm("fstp dword [ebp-0x3c]");
                 *__esi = _v64;
                 *((intOrPtr*)(__esi + 4)) = _v64;
            }
            i = i + 1;
        }
         *(_a4.width) = reg.width;
         *(_a4.width + 4) = _v44;
         *((intOrPtr*)(_a4.width + 8)) = _v40;
         *(_a4.width + 12) = _v36;
         *((intOrPtr*)(_a4.width + 16)) = _v32;
        return _a4;
    }
L3:
    _t143 = reg2->node + (i << 4);
    _t215 = reg1;
    _v84 = _t215->width;
    _v80 = _t215->size;
    _v76 = _t215->hashw;
    _v72 = _t215->node;
    _v68 = _t215->hash;
     *__esp =  *((intOrPtr*)(_t143 + 8));
    _v88 =  *((intOrPtr*)(_t143 + 12));
    if(quantum_get_state() == 255) {
        addsize = addsize + 1;
    }
    i = i + 1;
    goto L6;
}

quantum_vectoradd_inplace(quantum_reg* reg1, quantum_reg* reg2)
{// addr = 0x080520A8  --  defined in 'qureg.c' at line 550
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    int k;                                 // _cfa_ffffffe8
    int addsize;                           // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    int* _v36;                             // _cfa_ffffffdc
    quantum_reg_node* _v40;   // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    int _v48;                              // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t129;                       // _t129
    _unknown_ _t147;                       // _t147
    _unknown_ _t155;                       // _t155
    _unknown_ _t168;                       // _t168
    intOrPtr* _t176;                       // _t176
    intOrPtr* _t184;                       // _t184
    intOrPtr* _t188;                       // _t188
    _unknown_ _t201;                       // _t201
    intOrPtr* _t202;                       // _t202
    quantum_reg* _t205;   // _t205
    quantum_reg* _t210;   // _t210

    addsize = 0;
    if(reg1->hashw != 0 || reg2->hashw != 0) {
        quantum_reconstruct_hash(reg1);
        i = 0;
L6:
        while(reg2->size > i) {
            goto L3;
        }
        goto L7;
    } else {
L7:
        reg1->node = realloc(reg1->node, reg1->size + addsize << 4);
        if(reg1->node == 0) {
            quantum_error(2);
        }
        quantum_memman(addsize << 4);
        k = reg1->size;
        i = 0;
        while(reg2->size > i) {
            _t155 = reg2->node + (i << 4);
            _t210 = reg1;
            _v52 = _t210->width;
            _v48 = _t210->size;
            _v44 = _t210->hashw;
            _v40 = _t210->node;
            _v36 = _t210->hash;
             *__esp =  *((intOrPtr*)(_t155 + 8));
            _v56 =  *((intOrPtr*)(_t155 + 12));
            j = quantum_get_state();
            if(j >= 0) {
                _t201 = reg1->node + (k << 4);
                _t168 = reg2->node + (i << 4);
                 *((intOrPtr*)(_t201 + 8)) =  *((intOrPtr*)(_t168 + 8));
                 *((intOrPtr*)(_t201 + 12)) =  *((intOrPtr*)(_t168 + 12));
                _t202 = reg1->node + (k << 4);
                _t176 = reg2->node + (i << 4);
                 *_t202 =  *_t176;
                 *((intOrPtr*)(_t202 + 4)) =  *((intOrPtr*)(_t176 + 4));
                k = k + 1;
            } else {
                __esi = reg1->node + (j << 4);
                _t184 = reg1->node + (j << 4);
                _t188 = reg2->node + (i << 4);
                _v32 =  *_t184;
                asm("fld dword [ebp-0x1c]");
                _v32 =  *((intOrPtr*)(_t184 + 4));
                asm("fld dword [ebp-0x1c]");
                _v32 =  *_t188;
                asm("fld dword [ebp-0x1c]");
                _v32 =  *((intOrPtr*)(_t188 + 4));
                asm("fld dword [ebp-0x1c]");
                asm("fxch st0, st1");
                asm("faddp st3, st0");
                asm("faddp st1, st0");
                asm("fxch st0, st1");
                asm("fstp dword [ebp-0x1c]");
                asm("fstp dword [ebp-0x1c]");
                 *__esi = _v32;
                 *((intOrPtr*)(__esi + 4)) = _v32;
            }
            i = i + 1;
        }
        reg1->size = reg1->size + addsize;
        return;
    }
L3:
    _t129 = reg2->node + (i << 4);
    _t205 = reg1;
    _v52 = _t205->width;
    _v48 = _t205->size;
    _v44 = _t205->hashw;
    _v40 = _t205->node;
    _v36 = _t205->hash;
     *__esp =  *((intOrPtr*)(_t129 + 8));
    _v56 =  *((intOrPtr*)(_t129 + 12));
    if(quantum_get_state() == 255) {
        addsize = addsize + 1;
    }
    i = i + 1;
    goto L6;
}

quantum_reg quantum_matrix_qureg(_None* A, double t, quantum_reg* reg)
{// addr = 0x080522D8  --  defined in 'qureg.c' at line 609
    _unknown_ _v12;                        // _cfa_fffffff4
    long long unsigned int _v16;           // _cfa_fffffff0
    long long unsigned int i;              // _cfa_ffffffec
    long long unsigned int _v24;           // _cfa_ffffffe8
    void* _v28;           // _cfa_ffffffe4
    long long unsigned int _v32;           // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    quantum_reg reg2;   // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    quantum_reg tmp;   // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    signed int _v112;                      // _cfa_ffffff90
    signed int _v116;                      // _cfa_ffffff8c
    long long unsigned int _v148;          // _cfa_ffffff6c
    long long unsigned int _v152;          // _cfa_ffffff68
    quantum_reg* _v156;   // _cfa_ffffff64
    int** __esi;                           // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t84;                        // _t84
    _unknown_ _t91;                        // _t91
    _unknown_ _t93;                        // _t93
    signed int _t94;                       // _t94
    int* _t109;                            // _t109
    _unknown_ _t117;                       // _t117
    _unknown_ _t121;                       // _t121
    void* _t129;          // _t129

    _v68 = _a12;
    _v64 = _a16;
    reg2.width = reg->width;
    _v36 = 1 << (reg2.width & 255);
    _v32 = 0;
    _v24 = 0;
    _v28 = calloc(_v36, 16);
    if(_v28 == 0) {
        quantum_error(2);
    }
    quantum_memman(_v36 << 4);
    i = 0;
    _v16 = 0;
    while(1) {
        _t94 = 1 << (reg->width & 255);
        _v116 = _t94;
        _v112 = _t94 >> 31;
        if(_v112 <= _v16 && (_v112 < _v16 || _v116 <= i)) {
            break;
        }
        _t121 = _v28 + (i << 4);
         *(_t121 + 8) = i;
         *(_t121 + 12) = _v16;
        asm("fld qword [ebp-0x40]");
        asm("fstp qword [esp+0xc]");
        _v152 = i;
        _v148 = _v16;
         *__esp =  &_v108;
         *A();
        __esp = __esp - 4;
        tmp.width = _v108;
        _v56 = _v104;
        _v52 = _v100;
        _v48 = _v96;
        _v44 = _v92;
        _t129 = _v28;
        __esi = _t129 + (i << 4);
        _v156 = reg;
        _t109 =  &(tmp.width);
         *__esp = _t109;
        quantum_dot_product_noconj();
         *__esi = _t109;
        (__esi)[1] = _t129;
        quantum_delete_qureg( &(tmp.width));
        i = i + 1;
        asm("adc dword [ebp-0xc], 0x0");
    }
     *_a4 = reg2.width;
    _a4[1] = _v36;
    _a4[2] = _v32;
    _a4[3] = _v28;
    _a4[4] = _v24;
    return;
}

quantum_scalar_qureg(complex float r, quantum_reg* reg)
{// addr = 0x08052462  --  defined in 'qureg.c' at line 644
    int i;                                 // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    complex float _v36;                    // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    intOrPtr* _t31;                        // _t31
    _unknown_ _t40;                        // _t40
    complex float _t44;                    // _t44
    _unknown_ _t46;                        // _t46
    intOrPtr* _t47;                        // _t47

    i = 0;
    while(1) {
        __eflags = reg->size - i;
        if(__eflags <= 0) {
            break;
        }
        _t47 = reg->node + (i << 4);
        _t31 = reg->node + (i << 4);
        _t44 = r;
        _v32 = _a8;
        _v36 = _t44;
        _v40 =  *((intOrPtr*)(_t31 + 4));
         *__esp =  *_t31;
         *_t47 = __mulsc3( *((intOrPtr*)(_t31 + 4)), _t47, __eflags);
         *(_t47 + 4) = _t44;
        i = i + 1;
    }
    return;
}

quantum_print_timeop(int width, _None* f)
{// addr = 0x080524D7  --  defined in 'qureg.c' at line 655
    _unknown_ _v8;                         // _cfa_fffffff8
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    quantum_matrix m;   // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    quantum_reg tmp;   // _cfa_ffffffcc
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    int _v108;                             // _cfa_ffffff94
    signed int _v116;                      // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    signed int _v124;                      // _cfa_ffffff84
    _unknown_ __ebp;                       // r6
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    _unknown_ _t74;                        // _t74
    signed int _t76;                       // _t76
    intOrPtr* _t96;                        // _t96
    _unknown_ _t104;                       // _t104
    _unknown_ _t107;                       // _t107
    intOrPtr* _t114;                       // _t114
    _unknown_ _t118;                       // _t118

    _push(__ebx);
    __esp = __esp - 116;
    _v116 = 1 << (width & 255);
    quantum_new_matrix( &_v76, 1 << (width & 255));
    __esp = __esp - 4;
    m.rows = _v76;
    _v28 = _v72;
    _v24 = _v68;
    i = 0;
    while(1 << (width & 255) > i) {
        _t76 = i;
        _v116 = width;
        _v124 = _t76;
        _v120 = _t76 >> 31;
         *__esp =  &_v108;
        quantum_new_qureg();
        __esp = __esp - 4;
        tmp.width = _v108;
        _v48 = _v104;
        _v44 = _v100;
        _v40 = _v96;
        _v36 = _v92;
         *__esp =  &(tmp.width);
         *f();
        j = 0;
        while(_v48 > j) {
            _t114 = _v24 + ( *((intOrPtr*)(_v40 + (j << 4) + 8)) + _v28 * i << 3);
            _t96 = _v40 + (j << 4);
             *_t114 =  *_t96;
             *((intOrPtr*)(_t114 + 4)) =  *((intOrPtr*)(_t96 + 4));
            j = j + 1;
        }
        quantum_delete_qureg( &(tmp.width));
        i = i + 1;
    }
     *__esp = m.rows;
    _v124 = _v28;
    _v120 = _v24;
    quantum_print_matrix();
    quantum_delete_matrix( &(m.rows));
    return;
}

int main(int argc, char** argv)
{// addr = 0x08052614  --  defined in 'shor.c' at line 31
    int i;                                 // _cfa_fffffff0
    intOrPtr _v12;                         // _cfa_fffffff4
    int width;                             // _cfa_ffffffec
    int swidth;                            // _cfa_ffffffe8
    int x;                                 // _cfa_ffffffe4
    int N;                                 // _cfa_ffffffe0
    int c;                                 // _cfa_ffffffdc
    int q;                                 // _cfa_ffffffd8
    int a;                                 // _cfa_ffffffd4
    int b;                                 // _cfa_ffffffd0
    int factor;                            // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    quantum_reg qr;   // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ _v96;                        // _cfa_ffffffa0
    _unknown_ _v100;                       // _cfa_ffffff9c
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ _v108;                       // _cfa_ffffff94
    _unknown_ _v112;                       // _cfa_ffffff90
    int _v116;                             // _cfa_ffffff8c
    intOrPtr* _v120;                       // _cfa_ffffff88
    _unknown_ _v148;                       // _cfa_ffffff6c
    _unknown_ _v180;                       // _cfa_ffffff4c
    intOrPtr _v184;                        // _cfa_ffffff48
    int _v188;                             // _cfa_ffffff44
    _unknown_ _v192;                       // _cfa_ffffff40
    _unknown_ _v196;                       // _cfa_ffffff3c
    _unknown_ __ebp;                       // r6
    _unknown_ _t217;                       // _t217
    _unknown_ _t234;                       // _t234
    _unknown_ _t241;                       // _t241
    _unknown_ _t243;                       // _t243
    _unknown_ _t267;                       // _t267
    _unknown_ _t294;                       // _t294
    _unknown_ _t299;                       // _t299
    _unknown_ _t304;                       // _t304
    _unknown_ _t316;                       // _t316
    _unknown_ _t323;                       // _t323
    _unknown_ _t324;                       // _t324
    _unknown_ _t333;                       // _t333
    _unknown_ _t334;                       // _t334
    _unknown_ _t346;                       // _t346
    _unknown_ _t353;                       // _t353
    _unknown_ _t356;                       // _t356
    _unknown_ _t358;                       // _t358
    _unknown_ _t360;                       // _t360
    _unknown_ _t363;                       // _t363
    _unknown_ _t364;                       // _t364
    _unknown_ _t369;                       // _t369
    _unknown_ _t370;                       // _t370
    char* _t371;                           // _t371
    _unknown_ _t384;                       // _t384
    _unknown_ _t401;                       // _t401
    _unknown_ _t402;                       // _t402
    _unknown_ _t405;                       // _t405
    _unknown_ _t406;                       // _t406
    _unknown_ _t411;                       // _t411
    _unknown_ _t412;                       // _t412
    _unknown_ _t415;                       // _t415
    signed int _t416;                      // _t416

    _t371 =  &_a4;
    __esp = __esp & 240;
    _push( *((intOrPtr*)(_t371 - 4)));
    _push(_t415);
    _t416 = __esp;
    _push(_t371);
    __esp = __esp - 180;
    _v120 = _t371;
    N = 0;
     *__esp = 0;
    time();
    srand(__eax);
    if( *_v120 != 1) {
        c = atoi( *( *((intOrPtr*)(_v120 + 4)) + 4));
        if(c > 14) {
            swidth = quantum_getwidth(c * c);
            x = quantum_getwidth(c);
            _v184 = x + x + x + swidth + 2;
            _v188 = c;
            printf("N = %i, %i qubits required\n");
            if( *_v120 > 2) {
                N = atoi( *( *((intOrPtr*)(_v120 + 4)) + 8));
            }
            while() {
            }
        } else {
            puts("Invalid number\n");
            _v116 = 3;
        }
    } else {
        puts("Usage: shor [number]\n");
        _v116 = 3;
    }
    __esp = _t416;
    _pop(__ebp);
    __esp = _v12 - 4;
    return _v116;
}

const _None* quantum_get_version()
{// addr = 0x08052B30  --  defined in 'version.c' at line 28
    _unknown_ __ebp;                       // r6

    return 134563284;
}

__mulsc3(
    _unknown_ __ecx,                       // r2
    _unknown_ __esi,                       // r5
    signed int __eflags                    // r9
)
{// addr = 0x08052B40
    _unknown_ _v28;                        // _cfa_ffffffe4
    intOrPtr _v60;                         // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6
    signed int _t66;                       // _t66
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    signed int _t70;                       // _t70
    _unknown_ _t71;                        // _t71
    _unknown_ _t72;                        // _t72
    _unknown_ _t73;                        // _t73
    _unknown_ _t74;                        // _t74
    _unknown_ _t75;                        // _t75
    _unknown_ _t76;                        // _t76

    __eflags = __eflags;
    _t72 = __esi;
    asm("fld dword [ebp+0x8]");
    asm("fld dword [ebp+0xc]");
    asm("fld dword [ebp+0x10]");
    asm("fld dword [ebp+0x14]");
    asm("fld st0, st3");
    asm("fmul st0, st2");
    __i686.get_pc_thunk.cx();
    asm("fstp dword [ebp-0x4]");
    asm("fld st0, st2");
    asm("fmul st0, st1");
    asm("fstp dword [ebp-0x8]");
    asm("fld st0, st3");
    asm("fmul st0, st1");
    asm("fstp dword [ebp-0xc]");
    asm("fld st0, st2");
    asm("fmul st0, st2");
    asm("fstp dword [ebp-0x10]");
    asm("fld dword [ebp-0x4]");
    asm("fld dword [ebp-0x8]");
    asm("fld st0, st1");
    asm("fsub st0, st1");
    asm("fld dword [ebp-0xc]");
    asm("fstp dword [ebp-0x3c]");
    asm("fld dword [ebp-0x10]");
    asm("fst dword [ebp-0x34]");
    asm("fadd dword [ebp-0x3c]");
    asm("fstp dword [ebp-0x18]");
    asm("fucom st0");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags != 0) {
L8:
        asm("fld dword [ebp-0x18]");
        asm("fucomp st0");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags != 0) {
L10:
            asm("fld st0, st6");
            asm("fsub st0, st7");
            asm("fst dword [ebp-0x30]");
            asm("fxch st0, st7");
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0) {
                asm("fstp st7");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
L128:
                asm("fld st0, st6");
                asm("fsub st0, st7");
                asm("fst dword [ebp-0x2c]");
                asm("fxch st0, st7");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    asm("fstp st7");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    goto L139;
                }
                if(__eflags != 0) {
                    goto L138;
                }
                asm("fxch st0, st7");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags == 0) {
L135:
                    if(__eflags != 0) {
                        goto L131;
                    }
                    goto L136;
                }
L131:
                asm("fxam ");
                asm("fnstsw ax");
                asm("fstp st0");
                __eflags = _t66 & 2;
                asm("fldz ");
                if((_t66 & 2) == 0) {
                    asm("fxch st0, st1");
                    asm("fxch st0, st6");
                    asm("fxch st0, st5");
                    asm("fxch st0, st4");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                } else {
                    asm("fstp st0");
                    asm("fldz ");
                    asm("fchs ");
                    asm("fxch st0, st1");
                    asm("fxch st0, st6");
                    asm("fxch st0, st5");
                    asm("fxch st0, st4");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                }
L134:
                asm("fld1 ");
                asm("fstp dword [ebp-0x28]");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
L25:
                asm("fxam ");
                asm("fnstsw ax");
                asm("fstp st0");
                asm("fld dword [ebp-0x28]");
                __eflags = _t66 & 2;
                asm("fabs ");
                if(__eflags == 0) {
                    asm("fxch st0, st5");
                } else {
                    asm("fchs ");
                    asm("fxch st0, st5");
                }
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
L140:
                    asm("fxam ");
                    asm("fnstsw ax");
                    asm("fstp st0");
                    __eflags = _t66 & 2;
                    asm("fldz ");
                    if(__eflags == 0) {
                        asm("fxch st0, st4");
                    } else {
                        asm("fstp st0");
                        asm("fldz ");
                        asm("fchs ");
                        asm("fxch st0, st4");
                    }
L32:
                    asm("fucom st0");
                    asm("fnstsw ax");
                    _t70 = 1;
                    asm("sahf ");
                    asm("o16 nop ");
                    if(__eflags != 0) {
L157:
                        asm("fxam ");
                        asm("fnstsw ax");
                        asm("fstp st0");
                        __eflags = _t66 & 2;
                        asm("fldz ");
                        if(__eflags != 0) {
                            asm("fstp st0");
                            asm("fldz ");
                            asm("fchs ");
                        }
                        asm("fxch st0, st5");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st6");
                        asm("fxch st0, st2");
                        _t70 = 1;
L35:
                        asm("fld st0, st6");
                        asm("fsub st0, st7");
                        asm("fst dword [ebp-0x24]");
                        asm("fxch st0, st7");
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st7");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
                            goto L66;
                        }
                        if(__eflags != 0) {
                            goto L64;
                        }
                        asm("fxch st0, st7");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st3");
                            asm("fstp st3");
                            asm("fstp st0");
                            goto L41;
                        }
                        _t72 = _t72;
                        if(__eflags == 0) {
                            goto L65;
                        }
                        asm("fstp st3");
                        asm("fstp st3");
                        asm("fstp st0");
                        goto L41;
L66:
                        asm("fld st0, st6");
                        asm("fsub st0, st7");
                        asm("fst dword [ebp-0x20]");
                        asm("fxch st0, st7");
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st7");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            asm("fxch st0, st6");
                            goto L76;
                        }
                        if(__eflags != 0) {
                            goto L74;
                        }
                        asm("fxch st0, st7");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st3");
                            asm("fstp st3");
                            asm("fstp st3");
                            goto L72;
                        }
                        if(__eflags == 0) {
                            goto L75;
                        }
                        asm("fstp st3");
                        asm("fstp st3");
                        asm("fstp st3");
                        goto L72;
L76:
                        __eflags = _t70 & 255;
                        if(__eflags != 0) {
                            asm("fstp st6");
                            asm("fstp st3");
                            asm("fstp st3");
                            asm("fxch st0, st3");
                            goto L62;
                        }
                        asm("fld st0, st6");
                        asm("fsub st0, st7");
                        asm("fst dword [ebp-0x1c]");
                        asm("fxch st0, st7");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st6");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            asm("fxch st0, st5");
                            goto L84;
                        }
                        if(__eflags != 0) {
                            goto L83;
                        }
                        asm("fxch st0, st6");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st4");
                            asm("fstp st2");
                            asm("o16 nop ");
                            goto L110;
                        }
                        _t72 = _t72;
                        if(__eflags != 0) {
                            goto L104;
                        }
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        goto L84;
L105:
                        asm("fstp st3");
                        asm("fxch st0, st1");
L110:
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0 || __eflags != 0) {
                            asm("fxam ");
                            asm("fnstsw ax");
                            asm("fstp st0");
                            __eflags = _t66 & 2;
                            asm("fldz ");
                            if(__eflags != 0) {
                                asm("fstp st0");
                                asm("fldz ");
                                asm("fchs ");
                            }
                            asm("fxch st0, st1");
                        } else {
                            asm("fxch st0, st1");
                        }
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
L145:
                            asm("fxam ");
                            asm("fnstsw ax");
                            asm("fstp st0");
                            __eflags = _t66 & 2;
                            asm("fldz ");
                            if(__eflags != 0) {
                                asm("fstp st0");
                                asm("fldz ");
                                asm("fchs ");
                            }
                            asm("fxch st0, st2");
L116:
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf ");
                            if(__eflags != 0 || __eflags != 0) {
                                asm("fxam ");
                                asm("fnstsw ax");
                                asm("fstp st0");
                                __eflags = _t66 & 2;
                                asm("fldz ");
                                if(__eflags != 0) {
                                    asm("fstp st0");
                                    asm("fldz ");
                                    asm("fchs ");
                                }
                                asm("fxch st0, st3");
                            } else {
                                asm("fxch st0, st3");
                            }
                            asm("fucom st0");
                            asm("fnstsw ax");
                            asm("sahf ");
                            if(__eflags != 0 || __eflags != 0) {
                                asm("fxam ");
                                asm("fnstsw ax");
                                asm("fstp st0");
                                __eflags = _t66 & 2;
                                asm("fldz ");
                                if((_t66 & 2) == 0) {
                                    asm("fxch st0, st1");
                                    asm("fxch st0, st2");
                                    asm("fxch st0, st3");
                                    asm("fxch st0, st1");
                                    goto L59;
                                }
                                asm("fstp st0");
                                asm("fldz ");
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
                                asm("fxch st0, st3");
                                asm("fxch st0, st1");
L123:
                                asm("fchs ");
L59:
                                asm("fxch st0, st2");
                                asm("fxch st0, st3");
                                asm("fxch st0, st2");
L62:
                                asm("fld st0, st3");
                                asm("fmul st0, st2");
                                asm("fld st0, st3");
                                asm("fmul st0, st2");
                                asm("fsubp st1, st0");
                                asm("fld dword [ecx+0xffffe5e8]");
                                asm("fmul st1, st0");
                                asm("fxch st0, st5");
                                asm("fmulp st2, st0");
                                asm("fxch st0, st3");
                                asm("fmulp st2, st0");
                                asm("faddp st1, st0");
                                asm("fmulp st2, st0");
                                asm("fxch st0, st1");
                                asm("fstp dword [ebp-0x18]");
                                goto L7;
                            }
                            goto L61;
                        }
                        _t72 = _t72;
                        if(__eflags != 0) {
                            goto L145;
                        }
                        asm("fxch st0, st2");
                        goto L116;
L104:
                        asm("fstp st4");
                        asm("fstp st2");
                        goto L110;
L84:
                        asm("fld st0, st5");
                        asm("fsub st0, st6");
                        asm("fxch st0, st6");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st5");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st4");
                            goto L91;
                        }
                        if(__eflags != 0) {
                            goto L90;
                        }
                        asm("fxch st0, st5");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            goto L105;
                        }
                        if(__eflags != 0) {
                            goto L106;
                        }
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        goto L91;
L107:
                        asm("fstp st4");
                        asm("fxch st0, st2");
                        goto L110;
L106:
                        asm("fstp st3");
                        asm("fxch st0, st1");
                        goto L110;
L91:
                        asm("fld dword [ebp-0x3c]");
                        asm("fsub st0, st0");
                        asm("fld dword [ebp-0x3c]");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st0");
                            _t72 = _t72;
                            goto L98;
                        }
                        if(__eflags != 0) {
                            goto L97;
                        }
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            goto L107;
                        }
                        asm("o16 nop ");
                        if(__eflags != 0) {
                            goto L98;
                        }
                        _t72 = _t72;
                        asm("fstp st4");
                        asm("fxch st0, st2");
                        goto L110;
L99:
                        if(__eflags != 0) {
                            asm("fstp st0");
                            asm("fstp st0");
                            asm("fstp st0");
                            asm("fstp st0");
                            asm("fstp st0");
                            goto L7;
                        }
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st4");
                            asm("fxch st0, st2");
                            goto L110;
                        }
                        _t74 = _t72;
                        if(__eflags == 0) {
                            asm("fstp st0");
                            asm("fstp st0");
                            asm("fstp st0");
                            asm("fstp st0");
                            goto L7;
                        }
                        asm("fstp st4");
                        asm("fxch st0, st2");
                        _t72 = _t74;
                        goto L110;
L98:
                        asm("fld dword [ebp-0x34]");
                        asm("fsub st0, st0");
                        asm("fld dword [ebp-0x34]");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fstp st0");
                            asm("fstp st0");
                            asm("fstp st0");
                            asm("fstp st0");
                            asm("fstp st0");
                            goto L7;
                        }
                        goto L99;
L97:
                        asm("fstp st0");
                        goto L98;
L90:
                        asm("fstp st5");
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        goto L91;
L83:
                        asm("fstp st6");
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        goto L84;
L61:
                        asm("fxch st0, st1");
                        asm("fxch st0, st3");
                        asm("fxch st0, st1");
                        goto L62;
L72:
                        asm("fld1 ");
                        asm("fldz ");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st2");
                        asm("fxch st0, st5");
                        asm("fxch st0, st2");
L48:
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0 || __eflags != 0) {
                            asm("fxam ");
                            asm("fnstsw ax");
                            asm("fstp st0");
                            __eflags = _t66 & 2;
                            asm("fldz ");
                            if(__eflags != 0) {
                                asm("fstp st0");
                                asm("fldz ");
                                asm("fchs ");
                            }
                            asm("fxch st0, st4");
                        } else {
                            asm("fxch st0, st4");
                        }
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0 || __eflags != 0) {
                            asm("fxam ");
                            asm("fnstsw ax");
                            asm("fstp st0");
                            __eflags = _t66 & 2;
                            asm("fldz ");
                            if((_t66 & 2) != 0) {
                                asm("fstp st0");
                                asm("fldz ");
                                asm("fchs ");
                            }
                            asm("fxch st0, st5");
                        } else {
                            asm("fxch st0, st5");
                        }
                        asm("fxam ");
                        asm("fnstsw ax");
                        asm("fstp st0");
                        asm("fxch st0, st2");
                        __eflags = _t66 & 2;
                        asm("fabs ");
                        if((_t66 & 2) != 0) {
                            asm("fchs ");
                        }
                        asm("fxch st0, st1");
                        asm("fxam ");
                        asm("fnstsw ax");
                        asm("fstp st0");
                        asm("fxch st0, st1");
                        __eflags = _t66 & 2;
                        asm("fabs ");
                        if((_t66 & 2) != 0) {
                            goto L123;
                        }
                        goto L59;
L75:
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L76;
L74:
                        asm("fstp st7");
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L76;
L41:
                        asm("fld st0, st2");
                        asm("fsub st0, st3");
                        asm("fucomp st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fxch st0, st2");
                            goto L45;
                        }
                        if(__eflags == 0) {
L162:
                            asm("fldz ");
                            asm("fld1 ");
                            asm("fxch st0, st3");
                            asm("fxch st0, st2");
                            asm("fxch st0, st4");
                            asm("fxch st0, st2");
                            goto L48;
                        }
                        asm("fxch st0, st2");
L45:
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0) {
                            asm("fxch st0, st2");
                            goto L162;
                        }
                        asm("o16 nop ");
                        if(__eflags != 0) {
                            goto L161;
                        }
                        asm("fld1 ");
                        asm("fld st0, st0");
                        asm("fxch st0, st3");
                        goto L48;
L161:
                        asm("fxch st0, st2");
                        goto L162;
L65:
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L66;
L64:
                        asm("fstp st7");
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L66;
                    }
                    asm("o16 nop ");
                    if(__eflags != 0) {
                        goto L157;
                    }
                    asm("fxch st0, st5");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st6");
                    asm("fxch st0, st2");
                    goto L35;
                }
                _t72 = _t72;
                if(__eflags != 0) {
                    goto L140;
                }
                asm("fxch st0, st4");
                goto L32;
L136:
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
L139:
                _t70 = 0;
                goto L35;
L138:
                asm("fstp st7");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
                goto L139;
            }
            goto L11;
L127:
            asm("fstp st7");
            asm("fxch st0, st1");
            asm("fxch st0, st2");
            asm("fxch st0, st3");
            asm("fxch st0, st4");
            asm("fxch st0, st5");
            asm("fxch st0, st6");
            goto L128;
        }
        goto L9;
L11:
        if(__eflags != 0) {
            goto L127;
        }
        asm("fxch st0, st7");
        asm("fucomp st0");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags == 0) {
            if(__eflags != 0) {
                asm("fxch st0, st6");
L15:
                asm("fxam ");
                asm("fnstsw ax");
                asm("fstp st0");
                __eflags = _t66 & 2;
                asm("fld1 ");
                if(__eflags != 0) {
                    asm("fstp st0");
                    asm("fld1 ");
                    asm("fchs ");
                }
                asm("fld st0, st5");
                asm("fsub st0, st6");
                asm("fst dword [ebp-0x14]");
                asm("fxch st0, st6");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    asm("fstp st6");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    goto L24;
                } else {
                    if(__eflags != 0) {
                        goto L23;
                    }
                    asm("fxch st0, st6");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        goto L134;
                    }
                    asm("o16 nop ");
                    if(__eflags != 0) {
                        goto L134;
                    }
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    goto L24;
L24:
                    asm("fldz ");
                    asm("fstp dword [ebp-0x28]");
                    goto L25;
                }
L23:
                asm("fstp st6");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                goto L24;
            }
            asm("fxch st0, st1");
            asm("fxch st0, st2");
            asm("fxch st0, st3");
            asm("fxch st0, st4");
            asm("fxch st0, st5");
            asm("fxch st0, st6");
            goto L128;
        }
        asm("fxch st0, st6");
        goto L15;
    }
    if(__eflags != 0) {
        goto L8;
    } else {
        asm("fstp st5");
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st1");
L7:
        asm("fstp dword [ebp-0x38]");
        return _v60;
    }
L9:
    if(__eflags == 0) {
        asm("fstp st5");
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st1");
        goto L7;
    }
    goto L10;
}

__i686.get_pc_thunk.cx()
{// addr = 0x080531D5
    return;
}

__muldc3(
    _unknown_ __esi,                       // r5
    signed int __eflags,                   // r9
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080531E0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t68;                       // _t68
    _unknown_ _t70;                        // _t70
    _unknown_ _t71;                        // _t71
    _unknown_ _t72;                        // _t72
    _unknown_ _t73;                        // _t73
    _unknown_ _t74;                        // _t74
    _unknown_ _t75;                        // _t75

    __eflags = __eflags;
    _t72 = __esi;
    __edx = _a4;
    asm("fld qword [ebp+0xc]");
    asm("fld qword [ebp+0x14]");
    asm("fld qword [ebp+0x1c]");
    asm("fld qword [ebp+0x24]");
    asm("fld st0, st3");
    asm("fmul st0, st2");
    __i686.get_pc_thunk.bx();
    asm("fstp qword [ebp-0x10]");
    asm("fld st0, st2");
    asm("fmul st0, st1");
    asm("fstp qword [ebp-0x18]");
    asm("fld st0, st3");
    asm("fmul st0, st1");
    asm("fstp qword [ebp-0x20]");
    asm("fld st0, st2");
    asm("fmul st0, st2");
    asm("fstp qword [ebp-0x28]");
    asm("fld qword [ebp-0x10]");
    asm("fld qword [ebp-0x18]");
    asm("fst qword [ebp-0x78]");
    asm("fsubr st0, st1");
    asm("fld qword [ebp-0x20]");
    asm("fst qword [ebp-0x70]");
    asm("fld qword [ebp-0x28]");
    asm("fst qword [ebp-0x68]");
    asm("faddp st1, st0");
    asm("fxch st0, st1");
    asm("fucom st0");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags != 0) {
        asm("fxch st0, st1");
        goto L10;
    }
    if(__eflags != 0) {
        goto L9;
    } else {
        asm("fstp st5");
        asm("fstp st5");
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st0");
L7:
        asm("fstp qword [edx]");
        asm("fstp qword [edx+0x8]");
        return __edx;
    }
L10:
    asm("fucom st0");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags != 0) {
L12:
        asm("fld st0, st6");
        asm("fsub st0, st7");
        asm("fst qword [ebp-0x60]");
        asm("fxch st0, st7");
        asm("fucom st0");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags != 0) {
            asm("fstp st7");
            asm("fxch st0, st1");
            asm("fxch st0, st2");
            asm("fxch st0, st3");
            asm("fxch st0, st4");
            asm("fxch st0, st5");
            asm("fxch st0, st6");
L130:
            asm("fld st0, st6");
            asm("fsub st0, st7");
            asm("fst qword [ebp-0x58]");
            asm("fxch st0, st7");
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0) {
                asm("fstp st7");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st6");
                goto L141;
            }
            if(__eflags != 0) {
                goto L140;
            }
            asm("fxch st0, st7");
            asm("fucomp st0");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags == 0) {
L137:
                if(__eflags != 0) {
                    goto L133;
                }
                goto L138;
            }
L133:
            asm("fxam ");
            asm("fnstsw ax");
            asm("fstp st0");
            __eflags = _t68 & 2;
            asm("fldz ");
            if((_t68 & 2) == 0) {
                asm("fxch st0, st1");
                asm("fxch st0, st6");
                asm("fxch st0, st5");
                asm("fxch st0, st4");
                asm("fxch st0, st3");
                asm("fxch st0, st2");
                asm("fxch st0, st1");
            } else {
                asm("fstp st0");
                asm("fldz ");
                asm("fchs ");
                asm("fxch st0, st1");
                asm("fxch st0, st6");
                asm("fxch st0, st5");
                asm("fxch st0, st4");
                asm("fxch st0, st3");
                asm("fxch st0, st2");
                asm("fxch st0, st1");
            }
L136:
            asm("fld1 ");
            asm("fstp qword [ebp-0x50]");
            asm("fxch st0, st1");
            asm("fxch st0, st2");
            asm("fxch st0, st3");
            asm("fxch st0, st4");
            asm("fxch st0, st5");
L27:
            asm("fxam ");
            asm("fnstsw ax");
            asm("fstp st0");
            asm("fld qword [ebp-0x50]");
            __eflags = _t68 & 2;
            asm("fabs ");
            if(__eflags == 0) {
                asm("fxch st0, st5");
            } else {
                asm("fchs ");
                asm("fxch st0, st5");
            }
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0) {
L142:
                asm("fxam ");
                asm("fnstsw ax");
                asm("fstp st0");
                __eflags = _t68 & 2;
                asm("fldz ");
                if(__eflags == 0) {
                    asm("fxch st0, st4");
                } else {
                    asm("fstp st0");
                    asm("fldz ");
                    asm("fchs ");
                    asm("fxch st0, st4");
                }
L34:
                asm("fucom st0");
                asm("fnstsw ax");
                __ecx = 1;
                asm("sahf ");
                asm("o16 nop ");
                if(__eflags != 0) {
L159:
                    asm("fxam ");
                    asm("fnstsw ax");
                    asm("fstp st0");
                    __eflags = _t68 & 2;
                    asm("fldz ");
                    if(__eflags != 0) {
                        asm("fstp st0");
                        asm("fldz ");
                        asm("fchs ");
                    }
                    asm("fxch st0, st5");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st6");
                    asm("fxch st0, st2");
                    __ecx = 1;
L37:
                    asm("fld st0, st6");
                    asm("fsub st0, st7");
                    asm("fst qword [ebp-0x48]");
                    asm("fxch st0, st7");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st7");
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L68;
                    }
                    if(__eflags != 0) {
                        goto L66;
                    }
                    asm("fxch st0, st7");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st3");
                        asm("fstp st3");
                        asm("fstp st0");
                        goto L43;
                    }
                    _t72 = _t72;
                    if(__eflags == 0) {
                        goto L67;
                    }
                    asm("fstp st3");
                    asm("fstp st3");
                    asm("fstp st0");
                    goto L43;
L68:
                    asm("fld st0, st6");
                    asm("fsub st0, st7");
                    asm("fst qword [ebp-0x40]");
                    asm("fxch st0, st7");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st7");
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st6");
                        goto L78;
                    }
                    if(__eflags != 0) {
                        goto L76;
                    }
                    asm("fxch st0, st7");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st3");
                        asm("fstp st3");
                        asm("fstp st3");
                        goto L74;
                    }
                    if(__eflags == 0) {
                        goto L77;
                    }
                    asm("fstp st3");
                    asm("fstp st3");
                    asm("fstp st3");
                    goto L74;
L78:
                    __eflags = __ecx & 255;
                    if(__eflags != 0) {
                        asm("fstp st6");
                        asm("fstp st3");
                        asm("fstp st3");
                        asm("fxch st0, st3");
                        goto L64;
                    }
                    asm("fld st0, st6");
                    asm("fsub st0, st7");
                    asm("fst qword [ebp-0x38]");
                    asm("fxch st0, st7");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st6");
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        goto L86;
                    }
                    if(__eflags != 0) {
                        goto L85;
                    }
                    asm("fxch st0, st6");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st4");
                        asm("fstp st2");
                        goto L112;
                    }
                    _t72 = _t72;
                    if(__eflags != 0) {
                        goto L106;
                    }
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    goto L86;
L107:
                    asm("fstp st5");
                    asm("fstp st3");
                    asm("fxch st0, st1");
L112:
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0 || __eflags != 0) {
                        asm("fxam ");
                        asm("fnstsw ax");
                        asm("fstp st0");
                        __eflags = _t68 & 2;
                        asm("fldz ");
                        if(__eflags != 0) {
                            asm("fstp st0");
                            asm("fldz ");
                            asm("fchs ");
                        }
                        asm("fxch st0, st1");
                    } else {
                        asm("fxch st0, st1");
                    }
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
L147:
                        asm("fxam ");
                        asm("fnstsw ax");
                        asm("fstp st0");
                        __eflags = _t68 & 2;
                        asm("fldz ");
                        if(__eflags != 0) {
                            asm("fstp st0");
                            asm("fldz ");
                            asm("fchs ");
                        }
                        asm("fxch st0, st2");
L118:
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0 || __eflags != 0) {
                            asm("fxam ");
                            asm("fnstsw ax");
                            asm("fstp st0");
                            __eflags = _t68 & 2;
                            asm("fldz ");
                            if(__eflags != 0) {
                                asm("fstp st0");
                                asm("fldz ");
                                asm("fchs ");
                            }
                            asm("fxch st0, st3");
                        } else {
                            asm("fxch st0, st3");
                        }
                        asm("fucom st0");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags != 0 || __eflags != 0) {
                            asm("fxam ");
                            asm("fnstsw ax");
                            asm("fstp st0");
                            __eflags = _t68 & 2;
                            asm("fldz ");
                            if((_t68 & 2) == 0) {
                                asm("fxch st0, st1");
                                asm("fxch st0, st2");
                                asm("fxch st0, st3");
                                asm("fxch st0, st1");
                                goto L61;
                            }
                            asm("fstp st0");
                            asm("fldz ");
                            asm("fxch st0, st1");
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st1");
L125:
                            asm("fchs ");
L61:
                            asm("fxch st0, st2");
                            asm("fxch st0, st3");
                            asm("fxch st0, st2");
L64:
                            asm("fld st0, st3");
                            asm("fmul st0, st2");
                            asm("fld st0, st3");
                            asm("fmul st0, st2");
                            asm("fsubp st1, st0");
                            asm("fld dword [ebx+0xffffe5e8]");
                            asm("fmul st1, st0");
                            asm("fxch st0, st5");
                            asm("fmulp st2, st0");
                            asm("fxch st0, st3");
                            asm("fmulp st2, st0");
                            asm("faddp st1, st0");
                            asm("fmulp st2, st0");
                            goto L7;
                        }
                        goto L63;
                    }
                    _t72 = _t72;
                    if(__eflags != 0) {
                        goto L147;
                    }
                    asm("fxch st0, st2");
                    goto L118;
L106:
                    asm("fstp st4");
                    asm("fstp st2");
                    goto L112;
L86:
                    asm("fld qword [ebp-0x78]");
                    asm("fsub st0, st0");
                    asm("fld qword [ebp-0x78]");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st0");
                        goto L93;
                    }
                    if(__eflags != 0) {
                        goto L92;
                    }
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        goto L107;
                    }
                    if(__eflags != 0) {
                        goto L93;
                    }
                    _t72 = _t72;
                    asm("fstp st5");
                    asm("fstp st3");
                    asm("fxch st0, st1");
                    goto L112;
L94:
                    if(__eflags != 0) {
L99:
                        asm("fstp st0");
                        goto L100;
                    }
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st5");
                        asm("fstp st3");
                        asm("fxch st0, st1");
                        goto L112;
                    }
                    _t72 = _t72;
                    if(__eflags != 0) {
                        goto L100;
                    }
                    _t72 = _t72;
                    asm("fstp st5");
                    asm("fstp st3");
                    asm("fxch st0, st1");
                    goto L112;
L101:
                    if(__eflags != 0) {
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fxch st0, st1");
                        goto L7;
                    }
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st5");
                        asm("fstp st3");
                        asm("fxch st0, st1");
                        goto L112;
                    }
                    _t74 = _t72;
                    if(__eflags == 0) {
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fxch st0, st1");
                        goto L7;
                    }
                    asm("fstp st5");
                    asm("fstp st3");
                    asm("fxch st0, st1");
                    _t72 = _t74;
                    goto L112;
L100:
                    asm("fld qword [ebp-0x68]");
                    asm("fsub st0, st0");
                    asm("fld qword [ebp-0x68]");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fstp st0");
                        asm("fxch st0, st1");
                        goto L7;
                    }
                    goto L101;
L93:
                    asm("fld qword [ebp-0x70]");
                    asm("fsub st0, st0");
                    asm("fld qword [ebp-0x70]");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fstp st0");
                        _t72 = _t72;
                        goto L100;
                    }
                    goto L94;
L92:
                    asm("fstp st0");
                    goto L93;
L85:
                    asm("fstp st6");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    goto L86;
L63:
                    asm("fxch st0, st1");
                    asm("fxch st0, st3");
                    asm("fxch st0, st1");
                    goto L64;
L74:
                    asm("fld1 ");
                    asm("fldz ");
                    asm("fxch st0, st1");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st2");
                    asm("fxch st0, st5");
                    asm("fxch st0, st2");
L50:
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0 || __eflags != 0) {
                        asm("fxam ");
                        asm("fnstsw ax");
                        asm("fstp st0");
                        __eflags = _t68 & 2;
                        asm("fldz ");
                        if(__eflags != 0) {
                            asm("fstp st0");
                            asm("fldz ");
                            asm("fchs ");
                        }
                        asm("fxch st0, st4");
                    } else {
                        asm("fxch st0, st4");
                    }
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0 || __eflags != 0) {
                        asm("fxam ");
                        asm("fnstsw ax");
                        asm("fstp st0");
                        __eflags = _t68 & 2;
                        asm("fldz ");
                        if((_t68 & 2) != 0) {
                            asm("fstp st0");
                            asm("fldz ");
                            asm("fchs ");
                        }
                        asm("fxch st0, st5");
                    } else {
                        asm("fxch st0, st5");
                    }
                    asm("fxam ");
                    asm("fnstsw ax");
                    asm("fstp st0");
                    __eflags = _t68 & 2;
                    asm("fabs ");
                    if((_t68 & 2) != 0) {
                        asm("fchs ");
                    }
                    asm("fxch st0, st1");
                    asm("fxam ");
                    asm("fnstsw ax");
                    asm("fstp st0");
                    asm("fxch st0, st1");
                    __eflags = _t68 & 2;
                    asm("fabs ");
                    if((_t68 & 2) != 0) {
                        goto L125;
                    }
                    goto L61;
L77:
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    goto L78;
L76:
                    asm("fstp st7");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    goto L78;
L43:
                    asm("fld st0, st2");
                    asm("fsub st0, st3");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fxch st0, st2");
                        goto L47;
                    }
                    if(__eflags == 0) {
L164:
                        asm("fldz ");
                        asm("fld1 ");
                        asm("fxch st0, st1");
                        asm("fxch st0, st3");
                        asm("fxch st0, st2");
                        asm("fxch st0, st4");
                        asm("fxch st0, st2");
                        goto L50;
                    }
                    asm("fxch st0, st2");
L47:
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        asm("fxch st0, st2");
                        goto L164;
                    }
                    asm("o16 nop ");
                    if(__eflags != 0) {
                        goto L163;
                    }
                    asm("fld1 ");
                    asm("fld st0, st0");
                    asm("fxch st0, st3");
                    goto L50;
L163:
                    asm("fxch st0, st2");
                    goto L164;
L67:
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    goto L68;
L66:
                    asm("fstp st7");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    goto L68;
                }
                asm("o16 nop ");
                if(__eflags != 0) {
                    goto L159;
                }
                asm("fxch st0, st5");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st6");
                asm("fxch st0, st2");
                goto L37;
            }
            _t72 = _t72;
            if(__eflags != 0) {
                goto L142;
            }
            asm("fxch st0, st4");
            goto L34;
L138:
            asm("fxch st0, st1");
            asm("fxch st0, st2");
            asm("fxch st0, st3");
            asm("fxch st0, st4");
            asm("fxch st0, st5");
            asm("fxch st0, st6");
L141:
            __ecx = 0;
            goto L37;
L140:
            asm("fstp st7");
            asm("fxch st0, st1");
            asm("fxch st0, st2");
            asm("fxch st0, st3");
            asm("fxch st0, st4");
            asm("fxch st0, st5");
            asm("fxch st0, st6");
            goto L141;
        }
        goto L13;
L129:
        asm("fstp st7");
        asm("fxch st0, st1");
        asm("fxch st0, st2");
        asm("fxch st0, st3");
        asm("fxch st0, st4");
        asm("fxch st0, st5");
        asm("fxch st0, st6");
        goto L130;
    }
    _t72 = _t72;
    if(__eflags == 0) {
        asm("fstp st6");
        asm("fstp st4");
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st0");
        goto L7;
    }
    goto L12;
L13:
    if(__eflags != 0) {
        goto L129;
    }
    asm("fxch st0, st7");
    asm("fucomp st0");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags == 0) {
        if(__eflags != 0) {
            asm("fxch st0, st6");
L17:
            asm("fxam ");
            asm("fnstsw ax");
            asm("fstp st0");
            __eflags = _t68 & 2;
            asm("fld1 ");
            if(__eflags != 0) {
                asm("fstp st0");
                asm("fld1 ");
                asm("fchs ");
            }
            asm("fld st0, st5");
            asm("fsub st0, st6");
            asm("fst qword [ebp-0x30]");
            asm("fxch st0, st6");
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0) {
                asm("fstp st6");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                goto L26;
            } else {
                if(__eflags != 0) {
                    goto L25;
                }
                asm("fxch st0, st6");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L136;
                }
                asm("o16 nop ");
                if(__eflags != 0) {
                    goto L136;
                }
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                goto L26;
L26:
                asm("fldz ");
                asm("fstp qword [ebp-0x50]");
                goto L27;
            }
L25:
            asm("fstp st6");
            asm("fxch st0, st1");
            asm("fxch st0, st2");
            asm("fxch st0, st3");
            asm("fxch st0, st4");
            asm("fxch st0, st5");
            goto L26;
        }
        asm("fxch st0, st1");
        asm("fxch st0, st2");
        asm("fxch st0, st3");
        asm("fxch st0, st4");
        asm("fxch st0, st5");
        asm("fxch st0, st6");
        goto L130;
    }
    asm("fxch st0, st6");
    _t72 = _t72;
    goto L17;
L9:
    asm("fxch st0, st1");
    goto L10;
}

__i686.get_pc_thunk.bx()
{// addr = 0x08053887
    return;
}

__divsc3(
    _unknown_ __ecx,                       // r2
    _unknown_ __esi,                       // r5
    signed int __eflags                    // r9
)
{// addr = 0x08053890
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    signed int _t55;                       // _t55
    _unknown_ _t57;                        // _t57
    _unknown_ _t58;                        // _t58
    signed int _t59;                       // _t59
    _unknown_ _t60;                        // _t60
    _unknown_ _t61;                        // _t61
    _unknown_ _t62;                        // _t62
    _unknown_ _t63;                        // _t63
    _unknown_ _t64;                        // _t64

    __eflags = __eflags;
    _t61 = __esi;
    asm("fld dword [ebp+0x8]");
    asm("fld dword [ebp+0xc]");
    asm("fld dword [ebp+0x10]");
    asm("fld dword [ebp+0x14]");
    asm("fld st0, st1");
    asm("fabs ");
    asm("fld st0, st1");
    asm("fabs ");
    asm("fucompp ");
    asm("fnstsw ax");
    __i686.get_pc_thunk.cx();
    asm("sahf ");
    if(__eflags <= 0) {
        asm("fld st0, st0");
        asm("fdiv st0, st2");
        asm("fld st0, st1");
        asm("fmul st0, st1");
        asm("fadd st0, st3");
        asm("fld st0, st4");
        asm("fmul st0, st2");
        asm("fadd st0, st6");
        asm("fdiv st0, st1");
        asm("fxch st0, st2");
        asm("fmul st0, st6");
        asm("fld st0, st5");
        asm("fsubrp st1, st0");
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
    } else {
        asm("fld st0, st1");
        asm("fdiv st0, st1");
        asm("fld st0, st2");
        asm("fmul st0, st1");
        asm("fadd st0, st2");
        asm("fld st0, st5");
        asm("fmul st0, st2");
        asm("fadd st0, st5");
        asm("fdiv st0, st1");
        asm("fld st0, st5");
        asm("fmulp st3, st0");
        asm("fxch st0, st2");
        asm("fsub st0, st6");
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
    }
    asm("fucom st0");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags != 0) {
        asm("fxch st0, st1");
L17:
        asm("fucom st0");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags != 0) {
L19:
            asm("fldz ");
            asm("fxch st0, st4");
            asm("fucom st4");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0) {
                asm("fstp st4");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st2");
L25:
                asm("fld st0, st5");
                asm("fsub st0, st6");
                asm("fst dword [ebp-0x4]");
                asm("fxch st0, st6");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("fxch st0, st6");
                asm("sahf ");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
L30:
                    asm("fld st0, st2");
                    asm("fsub st0, st3");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
L51:
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        goto L55;
                    }
                    goto L31;
L52:
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    goto L55;
                }
L26:
                asm("fld st0, st4");
                asm("fsub st0, st5");
                asm("fxch st0, st5");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    asm("fstp st5");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    goto L79;
                }
                if(__eflags != 0) {
                    goto L77;
                }
                asm("fxch st0, st5");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L30;
                }
                asm("o16 nop ");
                if(__eflags == 0) {
                    goto L78;
                }
                goto L30;
L78:
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
L79:
                asm("fld st0, st3");
                asm("fsub st0, st4");
                asm("fxch st0, st4");
L55:
                asm("fucom st0");
                asm("fnstsw ax");
                asm("fxch st0, st4");
                asm("sahf ");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
L60:
                    asm("fld dword [ebp-0x4]");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        goto L9;
                    }
                    goto L61;
L10:
                    asm("fstp st0");
                    asm("fstp st4");
                    asm("fstp st2");
                    asm("fstp st0");
                    goto L13;
                }
                asm("fld st0, st4");
                asm("fsub st0, st5");
                asm("fxch st0, st5");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L6;
                }
                if(__eflags != 0) {
                    goto L7;
                }
                asm("fxch st0, st5");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L60;
                }
                _t61 = _t61;
                if(__eflags == 0) {
                    goto L8;
                }
                goto L60;
L9:
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L8:
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L7:
                asm("fstp st0");
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L61:
                if(__eflags != 0) {
                    goto L10;
                }
                asm("fld st0, st0");
                asm("fsub st0, st1");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L11;
                }
                if(__eflags != 0) {
                    goto L12;
                }
                asm("fstp st2");
                asm("fstp st0");
                __eflags = _t59 & 255;
                if((_t59 & 255) != 0) {
                    asm("fld1 ");
                    asm("fxch st0, st2");
                } else {
                    asm("fldz ");
                    asm("fxch st0, st2");
                }
                asm("fxam ");
                asm("fnstsw ax");
                asm("fstp st0");
                asm("fxch st0, st1");
                __eflags = _t55 & 2;
                asm("fabs ");
                if(__eflags != 0) {
                    asm("fchs ");
                }
                asm("fld st0, st2");
                asm("fsub st0, st3");
                asm("fxch st0, st3");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    asm("fstp st3");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    goto L91;
                } else {
                    if(__eflags != 0) {
                        goto L89;
                    }
                    asm("fxch st0, st3");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0 || __eflags != 0) {
                        asm("fld1 ");
                        asm("fxch st0, st3");
                    } else {
                        goto L90;
                    }
L73:
                    asm("fxam ");
                    asm("fnstsw ax");
                    asm("fstp st0");
                    asm("fxch st0, st2");
                    __eflags = _t55 & 2;
                    asm("fabs ");
                    if((_t55 & 2) != 0) {
                        asm("fchs ");
                    }
                    asm("fld st0, st3");
                    asm("fmul st0, st3");
                    asm("fld st0, st2");
                    asm("fmul st0, st2");
                    asm("faddp st1, st0");
                    asm("fldz ");
                    asm("fmul st1, st0");
                    asm("fxch st0, st4");
                    asm("fmulp st3, st0");
                    asm("fxch st0, st4");
                    asm("fmulp st1, st0");
                    asm("fsubp st1, st0");
                    asm("fmulp st1, st0");
                    asm("fxch st0, st1");
                    goto L13;
L90:
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
L91:
                    asm("fldz ");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                    goto L73;
                }
L89:
                asm("fstp st3");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                goto L91;
L12:
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L11:
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L77:
                asm("fstp st5");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                goto L79;
L31:
                _t61 = _t61;
                if(__eflags != 0) {
                    goto L52;
                }
                asm("fld st0, st4");
                asm("fsub st0, st5");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L53;
                }
                _t61 = _t61;
                if(__eflags != 0) {
                    goto L54;
                }
                asm("fstp st0");
                asm("fstp st0");
                asm("fstp st0");
                __eflags = _t59 & 255;
                if((_t59 & 255) != 0) {
                    asm("fld1 ");
                    asm("fxch st0, st4");
                } else {
                    asm("fldz ");
                    asm("fxch st0, st4");
                }
                asm("fxam ");
                asm("fnstsw ax");
                asm("fstp st0");
                asm("fxch st0, st3");
                __eflags = _t55 & 2;
                asm("fabs ");
                if(__eflags != 0) {
                    asm("fchs ");
                }
                asm("fld st0, st2");
                asm("fsub st0, st3");
                asm("fxch st0, st3");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    asm("fstp st3");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    goto L96;
                } else {
                    if(__eflags != 0) {
                        goto L94;
                    }
                    asm("fxch st0, st3");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0 || __eflags != 0) {
                        asm("fld1 ");
                        asm("fxch st0, st3");
                    } else {
                        goto L95;
                    }
L43:
                    asm("fxam ");
                    asm("fnstsw ax");
                    asm("fstp st0");
                    asm("fxch st0, st2");
                    __eflags = _t55 & 2;
                    asm("fabs ");
                    if((_t55 & 2) != 0) {
                        asm("fchs ");
                    }
                    asm("fld st0, st2");
                    asm("fmul st0, st4");
                    asm("fld st0, st1");
                    asm("fmul st0, st3");
                    asm("faddp st1, st0");
                    asm("fld dword [ecx+0xffffe5e8]");
                    asm("fmul st1, st0");
                    asm("fxch st0, st2");
                    asm("fmulp st5, st0");
                    asm("fxch st0, st3");
                    asm("fmulp st2, st0");
                    asm("fxch st0, st3");
                    asm("fsubrp st1, st0");
                    asm("fmulp st2, st0");
                    goto L13;
L95:
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
L96:
                    asm("fldz ");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                    goto L43;
                }
L94:
                asm("fstp st3");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                goto L96;
L54:
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                goto L55;
L53:
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                goto L55;
            }
            goto L20;
L24:
            asm("fstp st4");
            asm("fxch st0, st2");
            asm("fxch st0, st3");
            asm("fxch st0, st2");
            goto L25;
        }
        _t61 = _t61;
        if(__eflags == 0) {
            asm("fstp st5");
            asm("fstp st3");
            asm("fstp st0");
            asm("fstp st0");
            goto L13;
        }
        goto L19;
L6:
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st4");
        asm("fstp st2");
        asm("fstp st0");
        goto L13;
L20:
        _t61 = _t61;
        if(__eflags != 0) {
            goto L24;
        }
        asm("fxch st0, st3");
        asm("fucom st4");
        asm("fnstsw ax");
        asm("fstp st4");
        asm("sahf ");
        if(__eflags != 0) {
            goto L25;
        }
        _t61 = _t61;
        if(__eflags != 0) {
            goto L25;
        } else {
            asm("fxch st0, st5");
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0) {
                asm("fxch st0, st4");
L48:
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
L50:
                    asm("fld st0, st4");
                    asm("fsub st0, st5");
                    asm("fstp dword [ebp-0x4]");
                    asm("fld st0, st2");
                    asm("fsub st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    goto L55;
                }
                _t61 = _t61;
                if(__eflags != 0) {
                    asm("fstp st3");
                    asm("fstp st0");
                    asm("fstp st3");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    goto L85;
                }
                goto L50;
            }
            asm("o16 nop ");
            if(__eflags != 0) {
                goto L47;
            }
            asm("fstp st5");
            asm("fstp st0");
            asm("fstp st1");
L85:
            asm("fxam ");
            asm("fnstsw ax");
            asm("fstp st0");
            __eflags = _t55 & 2;
            asm("fld dword [ecx+0xffffe5e8]");
            if((_t55 & 2) != 0) {
                asm("fstp st0");
                asm("fld dword [ecx+0xffffe5ec]");
            }
            asm("fld st0, st0");
            asm("fmulp st3, st0");
            asm("fmulp st1, st0");
            asm("fxch st0, st1");
            goto L13;
L47:
            asm("fxch st0, st4");
            goto L48;
        }
        goto L26;
    } else {
        if(__eflags != 0) {
            goto L16;
        }
        asm("fstp st4");
        asm("fstp st4");
        asm("fstp st0");
        asm("fstp st0");
L13:
        asm("fstp dword [ebp-0x8]");
        asm("fstp dword [ebp-0x8]");
        return _v12;
    }
L16:
    asm("fxch st0, st1");
    goto L17;
}

__divdc3(
    signed int __edx,                      // r3
    _unknown_ __esi,                       // r5
    signed int __eflags,                   // r9
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08053D00
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t54;                       // _t54
    _unknown_ _t56;                        // _t56
    _unknown_ _t57;                        // _t57
    _unknown_ _t58;                        // _t58
    _unknown_ _t59;                        // _t59
    _unknown_ _t60;                        // _t60
    _unknown_ _t61;                        // _t61

    __eflags = __eflags;
    _t58 = __esi;
    __edx = __edx;
    __ecx = _a4;
    asm("fld qword [ebp+0xc]");
    asm("fld qword [ebp+0x14]");
    asm("fld qword [ebp+0x1c]");
    asm("fld qword [ebp+0x24]");
    asm("fld st0, st1");
    asm("fabs ");
    asm("fld st0, st1");
    asm("fabs ");
    asm("fucompp ");
    asm("fnstsw ax");
    __i686.get_pc_thunk.bx();
    asm("sahf ");
    if(__eflags <= 0) {
        asm("fld st0, st0");
        asm("fdiv st0, st2");
        asm("fld st0, st1");
        asm("fmul st0, st1");
        asm("fadd st0, st3");
        asm("fld st0, st4");
        asm("fmul st0, st2");
        asm("fadd st0, st6");
        asm("fdiv st0, st1");
        asm("fxch st0, st2");
        asm("fmul st0, st6");
        asm("fld st0, st5");
        asm("fsubrp st1, st0");
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
    } else {
        asm("fld st0, st1");
        asm("fdiv st0, st1");
        asm("fld st0, st2");
        asm("fmul st0, st1");
        asm("fadd st0, st2");
        asm("fld st0, st5");
        asm("fmul st0, st2");
        asm("fadd st0, st5");
        asm("fdiv st0, st1");
        asm("fld st0, st5");
        asm("fmulp st3, st0");
        asm("fxch st0, st2");
        asm("fsub st0, st6");
        asm("fdivrp st1, st0");
        asm("fxch st0, st1");
    }
    asm("fucom st0");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags != 0) {
        asm("fxch st0, st1");
L17:
        asm("fucom st0");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags != 0) {
L19:
            asm("fldz ");
            asm("fxch st0, st4");
            asm("fucom st4");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0) {
                asm("fstp st4");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st2");
L25:
                asm("fld st0, st5");
                asm("fsub st0, st6");
                asm("fst qword [ebp-0x10]");
                asm("fxch st0, st6");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("fxch st0, st6");
                asm("sahf ");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
L30:
                    asm("fld st0, st2");
                    asm("fsub st0, st3");
                    asm("fucom st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
L51:
                        asm("fxch st0, st4");
                        asm("fxch st0, st5");
                        asm("fxch st0, st1");
                        asm("fxch st0, st2");
                        asm("fxch st0, st3");
                        goto L55;
                    }
                    goto L31;
L52:
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    goto L55;
                }
L26:
                asm("fld st0, st4");
                asm("fsub st0, st5");
                asm("fxch st0, st5");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    asm("fstp st5");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    asm("fxch st0, st4");
                    goto L79;
                }
                if(__eflags != 0) {
                    goto L77;
                }
                asm("fxch st0, st5");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L30;
                }
                asm("o16 nop ");
                if(__eflags == 0) {
                    goto L78;
                }
                goto L30;
L78:
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
L79:
                asm("fld st0, st3");
                asm("fsub st0, st4");
                asm("fxch st0, st4");
L55:
                asm("fucom st0");
                asm("fnstsw ax");
                asm("fxch st0, st4");
                asm("sahf ");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
L60:
                    asm("fld qword [ebp-0x10]");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0) {
                        goto L9;
                    }
                    goto L61;
L10:
                    asm("fstp st0");
                    asm("fstp st4");
                    asm("fstp st2");
                    asm("fstp st0");
                    goto L13;
                }
                asm("fld st0, st4");
                asm("fsub st0, st5");
                asm("fxch st0, st5");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L6;
                }
                if(__eflags != 0) {
                    goto L7;
                }
                asm("fxch st0, st5");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L60;
                }
                _t58 = _t58;
                if(__eflags == 0) {
                    goto L8;
                }
                goto L60;
L9:
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L8:
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L7:
                asm("fstp st0");
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L61:
                if(__eflags != 0) {
                    goto L10;
                }
                asm("fld st0, st0");
                asm("fsub st0, st1");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L11;
                }
                if(__eflags != 0) {
                    goto L12;
                }
                asm("fstp st2");
                asm("fstp st0");
                __eflags = __edx & 255;
                if((__edx & 255) != 0) {
                    asm("fld1 ");
                    asm("fxch st0, st2");
                } else {
                    asm("fldz ");
                    asm("fxch st0, st2");
                }
                asm("fxam ");
                asm("fnstsw ax");
                asm("fstp st0");
                asm("fxch st0, st1");
                __eflags = _t54 & 2;
                asm("fabs ");
                if(__eflags != 0) {
                    asm("fchs ");
                }
                asm("fld st0, st2");
                asm("fsub st0, st3");
                asm("fxch st0, st3");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    asm("fstp st3");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    goto L91;
                } else {
                    if(__eflags != 0) {
                        goto L89;
                    }
                    asm("fxch st0, st3");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0 || __eflags != 0) {
                        asm("fld1 ");
                        asm("fxch st0, st3");
                    } else {
                        goto L90;
                    }
L73:
                    asm("fxam ");
                    asm("fnstsw ax");
                    asm("fstp st0");
                    asm("fxch st0, st2");
                    __eflags = _t54 & 2;
                    asm("fabs ");
                    if((_t54 & 2) != 0) {
                        asm("fchs ");
                    }
                    asm("fld st0, st3");
                    asm("fmul st0, st3");
                    asm("fld st0, st2");
                    asm("fmul st0, st2");
                    asm("faddp st1, st0");
                    asm("fldz ");
                    asm("fmul st1, st0");
                    asm("fxch st0, st4");
                    asm("fmulp st3, st0");
                    asm("fxch st0, st4");
                    asm("fmulp st1, st0");
                    asm("fsubp st1, st0");
                    asm("fmulp st1, st0");
                    asm("fxch st0, st1");
                    goto L13;
L90:
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
L91:
                    asm("fldz ");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                    goto L73;
                }
L89:
                asm("fstp st3");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                goto L91;
L12:
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L11:
                asm("fstp st0");
                asm("fstp st4");
                asm("fstp st2");
                asm("fstp st0");
                goto L13;
L77:
                asm("fstp st5");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                asm("fxch st0, st4");
                goto L79;
L31:
                _t58 = _t58;
                if(__eflags != 0) {
                    goto L52;
                }
                asm("fld st0, st4");
                asm("fsub st0, st5");
                asm("fucomp st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    goto L53;
                }
                _t58 = _t58;
                if(__eflags != 0) {
                    goto L54;
                }
                asm("fstp st0");
                asm("fstp st0");
                asm("fstp st0");
                __eflags = __edx & 255;
                if((__edx & 255) != 0) {
                    asm("fld1 ");
                    asm("fxch st0, st4");
                } else {
                    asm("fldz ");
                    asm("fxch st0, st4");
                }
                asm("fxam ");
                asm("fnstsw ax");
                asm("fstp st0");
                asm("fxch st0, st3");
                __eflags = _t54 & 2;
                asm("fabs ");
                if(__eflags != 0) {
                    asm("fchs ");
                }
                asm("fld st0, st2");
                asm("fsub st0, st3");
                asm("fxch st0, st3");
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
                    asm("fstp st3");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    goto L96;
                } else {
                    if(__eflags != 0) {
                        goto L94;
                    }
                    asm("fxch st0, st3");
                    asm("fucomp st0");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags != 0 || __eflags != 0) {
                        asm("fld1 ");
                        asm("fxch st0, st3");
                    } else {
                        goto L95;
                    }
L43:
                    asm("fxam ");
                    asm("fnstsw ax");
                    asm("fstp st0");
                    asm("fxch st0, st2");
                    __eflags = _t54 & 2;
                    asm("fabs ");
                    if((_t54 & 2) != 0) {
                        asm("fchs ");
                    }
                    asm("fld st0, st2");
                    asm("fmul st0, st4");
                    asm("fld st0, st1");
                    asm("fmul st0, st3");
                    asm("faddp st1, st0");
                    asm("fld dword [ebx+0xffffe5e8]");
                    asm("fmul st1, st0");
                    asm("fxch st0, st2");
                    asm("fmulp st5, st0");
                    asm("fxch st0, st3");
                    asm("fmulp st2, st0");
                    asm("fxch st0, st3");
                    asm("fsubrp st1, st0");
                    asm("fmulp st2, st0");
                    goto L13;
L95:
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
L96:
                    asm("fldz ");
                    asm("fxch st0, st3");
                    asm("fxch st0, st2");
                    asm("fxch st0, st1");
                    goto L43;
                }
L94:
                asm("fstp st3");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                goto L96;
L54:
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                goto L55;
L53:
                asm("fxch st0, st4");
                asm("fxch st0, st5");
                asm("fxch st0, st1");
                asm("fxch st0, st2");
                asm("fxch st0, st3");
                goto L55;
            }
            goto L20;
L24:
            asm("fstp st4");
            asm("fxch st0, st2");
            asm("fxch st0, st3");
            asm("fxch st0, st2");
            goto L25;
        }
        _t58 = _t58;
        if(__eflags == 0) {
            asm("fstp st5");
            asm("fstp st3");
            asm("fstp st0");
            asm("fstp st0");
            goto L13;
        }
        goto L19;
L6:
        asm("fstp st0");
        asm("fstp st0");
        asm("fstp st4");
        asm("fstp st2");
        asm("fstp st0");
        goto L13;
L20:
        _t58 = _t58;
        if(__eflags != 0) {
            goto L24;
        }
        asm("fxch st0, st3");
        asm("fucom st4");
        asm("fnstsw ax");
        asm("fstp st4");
        asm("sahf ");
        if(__eflags != 0) {
            goto L25;
        }
        _t58 = _t58;
        if(__eflags != 0) {
            goto L25;
        } else {
            asm("fxch st0, st5");
            asm("fucom st0");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags != 0) {
                asm("fxch st0, st4");
L48:
                asm("fucom st0");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags != 0) {
L50:
                    asm("fld st0, st4");
                    asm("fsub st0, st5");
                    asm("fstp qword [ebp-0x10]");
                    asm("fld st0, st2");
                    asm("fsub st0, st3");
                    asm("fxch st0, st4");
                    asm("fxch st0, st5");
                    asm("fxch st0, st6");
                    asm("fxch st0, st2");
                    asm("fxch st0, st3");
                    goto L55;
                }
                _t58 = _t58;
                if(__eflags != 0) {
                    asm("fstp st3");
                    asm("fstp st0");
                    asm("fstp st3");
                    asm("fxch st0, st1");
                    asm("fxch st0, st2");
                    goto L85;
                }
                goto L50;
            }
            asm("o16 nop ");
            if(__eflags != 0) {
                goto L47;
            }
            asm("fstp st5");
            asm("fstp st0");
            asm("fstp st1");
L85:
            asm("fxam ");
            asm("fnstsw ax");
            asm("fstp st0");
            __eflags = _t54 & 2;
            asm("fld dword [ebx+0xffffe5e8]");
            if((_t54 & 2) != 0) {
                asm("fstp st0");
                asm("fld dword [ebx+0xffffe5ec]");
            }
            asm("fld st0, st0");
            asm("fmulp st3, st0");
            asm("fmulp st1, st0");
            asm("fxch st0, st1");
            goto L13;
L47:
            asm("fxch st0, st4");
            goto L48;
        }
        goto L26;
    } else {
        if(__eflags != 0) {
            goto L16;
        }
        asm("fstp st4");
        asm("fstp st4");
        asm("fstp st0");
        asm("fstp st0");
L13:
        asm("fstp qword [ecx]");
        asm("fstp qword [ecx+0x8]");
        return __ecx;
    }
L16:
    asm("fxch st0, st1");
    goto L17;
}

__libc_csu_fini()
{// addr = 0x08054170
    _unknown_ __ebp;                       // r6

    return;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x08054180
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    signed int _t18;                       // _t18

    __i686.get_pc_thunk.bx();
    _t15 = _t14 + 7785;
    __esp = __esp - 12;
    _init();
    _t18 = _t15 + -244 - _t15 + -244 >> 2;
    if(_t18 != 0) {
        __esi = 0;
        while(1) {
            _v20 = _a12;
            _v24 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t15 + -244 + __esi * 4))();
            __esi = __esi + 1;
            if(__esi >= _t18) {
                break;
            }
        }
    }
    __esp = __esp + 12;
    return;
}

int atexit(_Unknown_base(*)()* __func)
{// addr = 0x080541E0
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t5;                          // _t5
    int _t6;                               // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    _t5 = 0;
    __i686.get_pc_thunk.bx();
    _t8 = _t7 + 7689;
    __esp = __esp - 12;
    __edx =  *((intOrPtr*)(_t8 + -4));
    if(__edx != 0) {
        _t5 =  *__edx;
    }
    _v12 = _t5;
    _t6 = _a4;
    _v16 = 0;
     *__esp = _t6;
    __cxa_atexit();
    __esp =  &((__esp)[3]);
    return _t6;
}

__do_global_ctors_aux()
{// addr = 0x08054220
    intOrPtr* __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    __eax = __CTOR_LIST__;
    if(__eax != 255) {
        __ebx =  &__CTOR_LIST__;
        asm("o16 nop ");
        while(1) {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
            if(__eax == 255) {
                break;
            }
        }
    }
    return;
}

_fini()
{// addr = 0x0805424C
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    return;
}

L08054258()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

L08054258()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    @rec __do_global_dtors_aux@__do_global_dtors_aux@(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

// Statistics:
//     888 Register nodes
//    2040 Temporaries nodes
//     139 Casts
//    6429 Statements
//     470 Labels
//     346 Gotos
//     195 Blocks
//   23075 Nodes
//    2785 Assembly nodes
//     967 Unknown Types


Total time: 4 seconds.
