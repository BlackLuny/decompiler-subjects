L0804947C()
{
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t2;

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 109420 + -8)) != 0) {
        __gmon_start__();
    }
    L08049B60();
    L0805E480();
    _pop(__eax);
    return;
}

L08049488()
{
    _unknown_ _t2;

    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 109420 + -8)) != 0) {
        __gmon_start__();
    }
    L08049B60();
    L0805E480();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

void abort()
{// addr = 0x080494BC
    goto __imp__abort;
}

int* __errno_location()
{// addr = 0x080494CC
    goto __imp____errno_location;
}

int putc_unlocked(int ch, struct _IO_FILE* fp)
{// addr = 0x080494DC
    goto __imp__putc_unlocked;
}

sigemptyset()
{// addr = 0x080494EC
    goto __imp__sigemptyset;
}

int sprintf(char* dst, char* format)
{// addr = 0x080494FC
    goto __imp__sprintf;
}

struct lconv* localeconv()
{// addr = 0x0804950C
    goto __imp__localeconv;
}

dirfd()
{// addr = 0x0804951C
    goto __imp__dirfd;
}

__cxa_atexit()
{// addr = 0x0804952C
    goto __imp____cxa_atexit;
}

int strcoll(char* __s1, char* __s2)
{// addr = 0x0804953C
    goto __imp__strcoll;
}

memcmp()
{// addr = 0x0804954C
    goto __imp__memcmp;
}

int fputs_unlocked(char* str, struct _IO_FILE* fp)
{// addr = 0x0804955C
    goto __imp__fputs_unlocked;
}

__ctype_get_mb_cur_max()
{// addr = 0x0804956C
    goto __imp____ctype_get_mb_cur_max;
}

signal()
{// addr = 0x0804957C
    goto __imp__signal;
}

sigismember()
{// addr = 0x0804958C
    goto __imp__sigismember;
}

__gmon_start__()
{// addr = 0x0804959C
    goto __imp____gmon_start__;
}

void* realloc(void* __ptr, int __size)
{// addr = 0x080495AC
    goto __imp__realloc;
}

__xstat64()
{// addr = 0x080495BC
    goto __imp____xstat64;
}

localtime()
{// addr = 0x080495CC
    goto __imp__localtime;
}

getgrnam()
{// addr = 0x080495DC
    goto __imp__getgrnam;
}

char* strchr(char* __s, int __c)
{// addr = 0x080495EC
    goto __imp__strchr;
}

char* getenv(char* __name)
{// addr = 0x080495FC
    goto __imp__getenv;
}

void* calloc(int __nmemb, int __size)
{// addr = 0x0804960C
    goto __imp__calloc;
}

char* strncpy(char* __dest, char* __src, int __n)
{// addr = 0x0804961C
    goto __imp__strncpy;
}

gnu_dev_minor()
{// addr = 0x0804962C
    goto __imp__gnu_dev_minor;
}

toupper()
{// addr = 0x0804963C
    goto __imp__toupper;
}

void* memset(void* __s, int __c, int __n)
{// addr = 0x0804964C
    goto __imp__memset;
}

__libc_start_main()
{// addr = 0x0804965C
    goto __imp____libc_start_main;
}

mempcpy()
{// addr = 0x0804966C
    goto __imp__mempcpy;
}

_obstack_begin()
{// addr = 0x0804967C
    goto __imp___obstack_begin;
}

int ferror_unlocked(struct _IO_FILE* fp)
{// addr = 0x0804968C
    goto __imp__ferror_unlocked;
}

void _exit(int __status)
{// addr = 0x0804969C
    goto __imp___exit;
}

char* strrchr(char* __s, int __c)
{// addr = 0x080496AC
    goto __imp__strrchr;
}

__assert_fail()
{// addr = 0x080496BC
    goto __imp____assert_fail;
}

__builtin_va_list bindtextdomain(char* __domainname, char* __dirname)
{// addr = 0x080496CC
    goto __imp__bindtextdomain;
}

mbrtowc()
{// addr = 0x080496DC
    goto __imp__mbrtowc;
}

__builtin_va_list gettext(char* __msgid)
{// addr = 0x080496EC
    goto __imp__gettext;
}

gettimeofday()
{// addr = 0x080496FC
    goto __imp__gettimeofday;
}

void free(void* __ptr)
{// addr = 0x0804970C
    goto __imp__free;
}

__lxstat64()
{// addr = 0x0804971C
    goto __imp____lxstat64;
}

strtoumax()
{// addr = 0x0804972C
    goto __imp__strtoumax;
}

_obstack_newchunk()
{// addr = 0x0804973C
    goto __imp___obstack_newchunk;
}

__builtin_va_list dcgettext(char* __domainname, char* __msgid, int __category)
{// addr = 0x0804974C
    goto __imp__dcgettext;
}

sigaction()
{// addr = 0x0804975C
    goto __imp__sigaction;
}

strverscmp()
{// addr = 0x0804976C
    goto __imp__strverscmp;
}

opendir()
{// addr = 0x0804977C
    goto __imp__opendir;
}

int getopt_long(int ___argc, __builtin_va_list* ___argv, char* __shortopts, struct option* __longopts, int* __longind)
{// addr = 0x0804978C
    goto __imp__getopt_long;
}

ioctl()
{// addr = 0x0804979C
    goto __imp__ioctl;
}

__ctype_b_loc()
{// addr = 0x080497AC
    goto __imp____ctype_b_loc;
}

iswcntrl()
{// addr = 0x080497BC
    goto __imp__iswcntrl;
}

int isatty(int __fd)
{// addr = 0x080497CC
    goto __imp__isatty;
}

int fclose(struct _IO_FILE* fp)
{// addr = 0x080497DC
    goto __imp__fclose;
}

mbsinit()
{// addr = 0x080497EC
    goto __imp__mbsinit;
}

_setjmp()
{// addr = 0x080497FC
    goto __imp___setjmp;
}

int tcgetpgrp(int __fd)
{// addr = 0x0804980C
    goto __imp__tcgetpgrp;
}

readdir64()
{// addr = 0x0804982C
    goto __imp__readdir64;
}

void* memcpy(void* __dest, void* __src, int __n)
{// addr = 0x0804983C
    goto __imp__memcpy;
}

long strtoul(char* __nptr, char** __endptr, int __base)
{// addr = 0x0804984C
    goto __imp__strtoul;
}

int strlen(char* __s)
{// addr = 0x0804985C
    goto __imp__strlen;
}

getpwuid()
{// addr = 0x0804986C
    goto __imp__getpwuid;
}

__builtin_va_list setlocale(int __category, char* __locale)
{// addr = 0x0804987C
    goto __imp__setlocale;
}

char* strcpy(char* __dest, char* __src)
{// addr = 0x0804988C
    goto __imp__strcpy;
}

longjmp()
{// addr = 0x0804989C
    goto __imp__longjmp;
}

int printf(char* format)
{// addr = 0x080498AC
    goto __imp__printf;
}

raise()
{// addr = 0x080498BC
    goto __imp__raise;
}

mbrlen()
{// addr = 0x080498CC
    goto __imp__mbrlen;
}

int fwrite_unlocked(void* src, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x080498DC
    goto __imp__fwrite_unlocked;
}

__signbitl()
{// addr = 0x080498EC
    goto __imp____signbitl;
}

clock_gettime()
{// addr = 0x080498FC
    goto __imp__clock_gettime;
}

closedir()
{// addr = 0x0804990C
    goto __imp__closedir;
}

int fwrite(void* src, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x0804991C
    goto __imp__fwrite;
}

int fprintf(struct _IO_FILE* fp, char* format)
{// addr = 0x0804992C
    goto __imp__fprintf;
}

void* malloc(int __size)
{// addr = 0x0804993C
    goto __imp__malloc;
}

sigprocmask()
{// addr = 0x0804994C
    goto __imp__sigprocmask;
}

__stack_chk_fail()
{// addr = 0x0804995C
    goto __imp____stack_chk_fail;
}

__fpending()
{// addr = 0x0804996C
    goto __imp____fpending;
}

void error(int __status, int __errnum, char* __format)
{// addr = 0x0804997C
    goto __imp__error;
}

getgrgid()
{// addr = 0x0804998C
    goto __imp__getgrgid;
}

sigaddset()
{// addr = 0x0804999C
    goto __imp__sigaddset;
}

int readlink(char* __path, __caddr_t __buf, int __len)
{// addr = 0x080499AC
    goto __imp__readlink;
}

void* memmove(void* __dest, void* __src, int __n)
{// addr = 0x080499BC
    goto __imp__memmove;
}

strndup()
{// addr = 0x080499CC
    goto __imp__strndup;
}

__builtin_va_list textdomain(char* __domainname)
{// addr = 0x080499DC
    goto __imp__textdomain;
}

__fxstat64()
{// addr = 0x080499EC
    goto __imp____fxstat64;
}

gnu_dev_major()
{// addr = 0x080499FC
    goto __imp__gnu_dev_major;
}

fnmatch()
{// addr = 0x08049A0C
    goto __imp__fnmatch;
}

int strncmp(char* __s1, char* __s2, int __n)
{// addr = 0x08049A1C
    goto __imp__strncmp;
}

int fflush_unlocked(struct _IO_FILE* fp)
{// addr = 0x08049A2C
    goto __imp__fflush_unlocked;
}

wcwidth()
{// addr = 0x08049A5C
    goto __imp__wcwidth;
}

iswprint()
{// addr = 0x08049A6C
    goto __imp__iswprint;
}

getpwnam()
{// addr = 0x08049A7C
    goto __imp__getpwnam;
}

tolower()
{// addr = 0x08049A8C
    goto __imp__tolower;
}

int strcmp(char* __s1, char* __s2)
{// addr = 0x08049A9C
    goto __imp__strcmp;
}

void exit(int __status)
{// addr = 0x08049AAC
    goto __imp__exit;
}

int putchar_unlocked(int ch)
{// addr = 0x08049ABC
    goto __imp__putchar_unlocked;
}

L08049B60()
{
    _unknown_ __ebp;

    __eax =  *134627088;
    if( *134627088 == 0) {
        return ;
    }
    __eax = 0;
    if(__eax == 0) {
        return ;
    }
     *__esp = 134627088;
     *__eax();
    return;
}

struct dev_ino dev_ino_pop()
{// addr = 0x08049B84
    const struct obstack* __o;
    struct obstack* __o;
    int __len;
    intOrPtr _v8;
    struct obstack* _v12;
    struct obstack* _v16;
    char* _v32;
    intOrPtr _v36;
    char* _v40;
    _unknown_ __ebp;
    _unknown_ _t43;

    _v16 =  &dev_ino_obstack;
    if(_v16->next_free - _v16->object_base <= 15) {
        _v32 = "dev_ino_pop";
        _v36 = 918;
        _v40 = "ls.c";
         *__esp = "sizeof (struct dev_ino) <= __extension__ ({ struct obstack const *__o = (&dev_ino_obstack); (unsigned) (__o->next_free - __o->object_base); })";
        __assert_fail();
    }
    _v12 =  &dev_ino_obstack;
    _v8 = -16;
    if(_v12->chunk_limit - _v12->next_free < _v8) {
        _v40 = _v8;
         *__esp = _v12;
        _obstack_newchunk();
    }
    _v12->next_free =  &(_v12->next_free[_v8]);
    memmove(_a4.st_ino, dev_ino_obstack.next_free, 16);
    return _a4;
}

dired_dump_obstack(const char* prefix, struct obstack* os)
{// addr = 0x08049C3B
    size_t n_pos;
    const struct obstack* __o;
    size_t i;
    size_t* pos;
    struct obstack* __o1;
    _Unknown_base* __value;
    char* _v12;
    struct obstack* _v16;
    char* _v20;
    signed int _v24;
    struct obstack* _v28;
    unsigned int _v32;
    intOrPtr _v56;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t93;
    _unknown_ _t99;
    _unknown_ _t100;

    _v28 = os;
    _v32 = _v28->next_free - _v28->object_base >> 2;
    if(_v32 == 0) {
        return ;
    }
    _v16 = os;
    _v12 = _v16->object_base;
    if(_v16->next_free == _v12) {
        _v16->use_extra_arg = (_v16->use_extra_arg & 255 | 2) & 4294967295;
    }
    _v16->next_free =  !(_v16->alignment_mask) &  &(_v16->next_free[_v16->alignment_mask]);
    if(_v16->next_free - _v16->chunk > _v16->chunk_limit - _v16->chunk) {
        _v16->next_free = _v16->chunk_limit;
    }
    _v16->object_base = _v16->next_free;
    _v20 = _v12;
    fputs_unlocked(prefix, __imp__stdout);
    _v24 = 0;
    while(_v24 < _v32) {
        _v56 =  *((intOrPtr*)(_v20 + (_v24 << 2)));
        printf(" %lu");
        _v24 = _v24 + 1;
    }
}

size_t dev_ino_hash(* x, size_t table_size)
{// addr = 0x08049D54
    const struct dev_ino* p;
    * _v12;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v12 = x;
    return L0805E1C0( *_v12,  *((intOrPtr*)(_t10 + 4)), table_size, 0);
}

_Bool dev_ino_compare(* x, * y)
{// addr = 0x08049D8B
    const struct dev_ino* a;
    const struct dev_ino* b;
    * _v16;
    * _v20;
    signed int _v32;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;

    _v20 = x;
    _v16 = y;
    _t20 = _v20;
    if(( *_v16 ^  *_v20 |  *(_t20 + 4) ^  *(_v16 + 4)) != 0) {
L3:
        _v32 = 0;
        return _v32 & 255;
    }
    _t26 = _v20;
    if(( *(_v16 + 8) ^  *(_v20 + 8) |  *(_t26 + 12) ^  *(_v16 + 12)) != 0) {
        goto L3;
    }
    _v32 = 1;
L4:
    return _v32 & 255;
    goto L4;
}

dev_ino_free(_Unknown_base* x)
{// addr = 0x08049DF4
    _unknown_ __ebp;
    _unknown_ _t3;

    free(x);
    return;
}

_Bool visit_dir(dev_t dev, ino_t ino)
{// addr = 0x08049E07
    struct dev_ino* ent;
    struct dev_ino* ent_from_table;
    _Bool found_match;
    signed int _v5;
    _Unknown_base* _v12;
    * _v16;
    long long unsigned int _v24;
    long long unsigned int _v28;
    void _v32;
    void _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t43;
    void* _t44;
    void* _t45;

    _v28 = dev;
    _v24 = ino;
    _v36 = _a12;
    _v32 = _a16;
    _v16 = xmalloc(16);
    _t44 = _v16;
     *_t44 = _v36;
    _t44[1] = _v32;
    _t45 = _v16;
    _t45[2] = _v28;
    _t45[3] = _v24;
    _v12 = hash_insert(active_dir_set, _v16);
    if(_v12 == 0) {
        xalloc_die();
    }
    _v5 = _v12 & 4294967295;
    if(_v5 == 0) {
        return _v5 & 255;
    }
    free(_v16);
    return _v5 & 255;
}

free_pending_ent(struct pending* p)
{// addr = 0x08049E97
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t10;
    _unknown_ _t12;

    free(p->name);
    free(p->realname);
    free(p);
    return;
}

_Bool is_colored(union indicator_no type)
{// addr = 0x08049EC5
    size_t len;
    const char* s;
    char* _v8;
    intOrPtr _v12;
    signed int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t29;

    _v12 =  *((intOrPtr*)( &color_indicator + type * 8));
    _v8 =  *(134627812 + type * 8);
    if(_v12 == 0 || _v12 == 1 && ( *_v8 & 255 & 4294967295) == ( *134604345 & 255 & 4294967295)) {
L6:
        _v24 = 0;
        return _v24 & 255;
    } else {
        if(_v12 != 2 || strncmp(_v8, "00", 2) != 0) {
            _v24 = 1;
            return _v24 & 255;
        } else {
            goto L6;
        }
    }
}

restore_default_color()
{// addr = 0x08049F3E
    _unknown_ __ebp;

    put_indicator( &color_indicator);
    put_indicator(134627816);
    return;
}

sighandler(int sig)
{// addr = 0x08049F5E
    _unknown_ __ebp;

    if(interrupt_signal != 0) {
        return ;
    }
    interrupt_signal = sig;
    return;
}

stophandler(int sig)
{// addr = 0x08049F74
    _unknown_ __ebp;

    if(interrupt_signal != 0) {
        return ;
    }
    stop_signal_count = stop_signal_count + 1;
    return;
}

process_signals()
{// addr = 0x08049F8F
    int sig;
    int stops;
    sigset_t oldset;
    _None _v8;
    _None _v12;
    char _v140;
    struct * _v164;
    struct * _v168;
    _unknown_ __ebp;
    _unknown_ _t18;

    while((interrupt_signal | stop_signal_count) != 0) {
        restore_default_color();
        fflush_unlocked(__imp__stdout);
        _v164 =  &_v140;
        _v168 =  &caught_signals;
         *__esp = 0;
        sigprocmask();
        _v12 = interrupt_signal;
        _v8 = stop_signal_count;
        if(_v8 == 0) {
            _v168 = 0;
             *__esp = _v12;
            signal();
        } else {
            stop_signal_count = _v8 - 1;
            _v12 = 19;
        }
         *__esp = _v12;
        raise();
        _v164 = 0;
        _v168 =  &_v140;
         *__esp = 2;
        sigprocmask();
    }
}

int main(int argc, char** argv)
{// addr = 0x0804A04A
    int i;
    struct pending* thispend;
    int n_files;
    int j;
    struct sigaction act;
    struct dev_ino di;
    struct dev_ino* found;
    int j;
    _unknown_ _v4;
    _unknown_ _v24;
    _Unknown_base* _v28;
    _Bool _v32;
    intOrPtr _v36;
    struct pending* _v40;
    signed int _v44;
    _unknown_ _v60;
    _unknown_ _v68;
    _unknown_ _v196;
    _unknown_ _v200;
    signed char _v216;
    signed char _v220;
    union Dereference_symlink _v224;
    _unknown_ _v228;
    int* _v232;
    _unknown_ _v236;
    _unknown_ _v240;
    _unknown_ _v244;
    char* _v252;
    int _v256;
    _Bool _v260;
    _Bool _v264;
    _Bool _v268;
    char* _v272;
    _unknown_ __ebp;
    _unknown_ _t184;
    _unknown_ _t185;
    _unknown_ _t186;
    _unknown_ _t209;
    _unknown_ _t235;
    _unknown_ _t242;
    _unknown_ _t244;
    _unknown_ _t246;
    _unknown_ _t256;
    _unknown_ _t262;
    _unknown_ _t284;
    _unknown_ _t286;
    int* _t300;
    _unknown_ _t305;
    _unknown_ _t318;
    _unknown_ _t323;
    signed int _t324;
    _unknown_ _t325;

    _t300 =  &argc;
    __esp = __esp & 240;
    _push( *((intOrPtr*)(_t300 - 4)));
    _push(_t323);
    _t324 = __esp;
    _push(__edi);
    _push(__esi);
    _push(_t300);
    __esp = __esp - 252;
    _v232 = _t300;
    program_name =  *(_v232[1]);
    setlocale(6, 134606192);
    bindtextdomain("coreutils", "/usr/local/share/locale");
    textdomain("coreutils");
     *__esp = 2;
    L91();
    L0805E380(close_stdout);
    exit_status = 0;
    print_dir_name = 1;
    pending_dirs = 0;
    _v44 = decode_switches( *_v232, _v232[1]);
    if((print_with_color & 255 & 4294967295) != 0) {
        parse_ls_color();
    }
    if((print_with_color & 255 & 4294967295) == 0) {
L24:
        if(dereference == 1) {
            if((immediate_dirs & 255 & 4294967295) != 0 || indicator_style == 3 || format == 0) {
                _v224 = 2;
            } else {
                _v224 = 4;
            }
            dereference = _v224;
        }
        if((recursive & 255 & 4294967295) != 0) {
            active_dir_set = hash_initialize(30, 0, dev_ino_hash, dev_ino_compare, dev_ino_free);
            if(active_dir_set == 0) {
                xalloc_die();
            }
            _v256 = free;
            _v260 = malloc;
            _v264 = 0;
            _v268 = 0;
             *__esp =  &dev_ino_obstack;
            _obstack_begin();
        }
        if(sort_type == 4 || sort_type == 2 || format == 0 || (print_scontext & 255 & 4294967295) != 0 || (print_block_size & 255 & 4294967295) != 0) {
            _v220 = 1;
        } else {
            _v220 = 0;
        }
        format_needs_stat = _v220 & 255 & 4294967295;
        if(((format_needs_stat & 255 ^ 1 ^ 1) & 4294967295) != 0 || (recursive & 255 & 4294967295) == 0 && (print_with_color & 255 & 4294967295) == 0 && indicator_style == 0 && (directories_first & 255 & 4294967295) == 0) {
            _v216 = 0;
        } else {
            _v216 = 1;
        }
        format_needs_type = _v216 & 255 & 4294967295;
        if((dired & 255 & 4294967295) != 0) {
            _v256 = free;
            _v260 = malloc;
            _v264 = 0;
            _v268 = 0;
             *__esp =  &dired_obstack;
            _obstack_begin();
            _v256 = free;
            _v260 = malloc;
            _v264 = 0;
            _v268 = 0;
             *__esp =  &subdired_obstack;
            _obstack_begin();
        }
        cwd_n_alloc = 100;
        cwd_file = xnmalloc(cwd_n_alloc, 120);
        cwd_n_used = 0;
        clear_files();
        _v36 =  *_v232 - _v44;
        if(_v36 > 0) {
            while(1) {
L55:
                _v44 = _v44 + 1;
                _v252 = 134606192;
                _v256 = 1;
                _v264 = 0;
                _v260 = 0;
                _v268 = 0;
                 *__esp = _v232[1][_v44];
                gobble_file();
                if(_v44 >=  *_v232) {
                    break;
                }
            }
            goto L56;
        }
        if((immediate_dirs & 255 & 4294967295) == 0) {
            queue_directory(".", 0, 1);
        } else {
            _v252 = 134606192;
            _v256 = 1;
            _v264 = 0;
            _v260 = 0;
            _v268 = 3;
             *__esp = ".";
            gobble_file();
        }
L56:
        if(cwd_n_used != 0) {
            sort_files();
            if(((immediate_dirs & 255 ^ 1) & 4294967295) != 0) {
                extract_dirs_from_files(0, 1);
            }
        }
        if(cwd_n_used == 0) {
            if(_v36 <= 1 && pending_dirs != 0 && pending_dirs->next == 0) {
                print_dir_name = 0;
            }
        } else {
            print_current_files();
            if(pending_dirs != 0) {
                putchar_unlocked(10);
                dired_pos = dired_pos + 1;
            }
        }
        while(pending_dirs != 0) {
            _v40 = pending_dirs;
            pending_dirs = pending_dirs->next;
            if(active_dir_set == 0 ||  *_v40 != 0) {
                print_dir( *_v40, _v40->realname, _v40->command_line_arg & 255 & 4294967295 & );
                free_pending_ent(_v40);
                print_dir_name = 1;
            } else {
                 *__esp =  &_v60;
                dev_ino_pop();
                __esp = __esp - 4;
                _v28 = hash_delete(active_dir_set,  &_v60);
                if(_v28 == 0) {
                    _v264 = "main";
                    _v268 = 1310;
                    _v272 = "ls.c";
                     *__esp = "found";
                    __assert_fail();
                }
                dev_ino_free(_v28);
                free_pending_ent(_v40);
            }
        }
    } else {
        if((is_colored(12) & 4294967295) != 0 || ((is_colored(13) ^ 1) & 4294967295) == 0 && (color_symlink_as_referent & 255 & 4294967295) != 0 || ((is_colored(11) ^ 1) & 4294967295) == 0 && format == 0) {
            check_symlink_color = 1;
        }
        if(tcgetpgrp(1) >= 0) {
            prep_non_filename_text();
        } else {
             *__esp =  &caught_signals;
            sigemptyset();
            _v32 = 0;
            while() {
            }
        }
        goto L24;
    }
}

initialize_exit_failure(int status)
{// addr = 0x0804A844
    _unknown_ __ebp;
    _unknown_ _t3;

    if(status == 1) {
        return ;
    }
    exit_failure = status;
    return;
}

int decode_switches(int argc, char** argv)
{// addr = 0x0804A857
    char* time_style_option;
    _Bool sort_type_specified;
    const char* q_style;
    int i;
    const char* ls_block_size;
    const char* p;
    long unsigned int tmp_ulong;
    struct winsize ws;
    const char* p;
    long unsigned int tmp_ulong;
    int oi;
    int c;
    long unsigned int tmp_ulong;
    long unsigned int tmp_ulong;
    struct ignore_pattern* hide;
    int i;
    union strtol_error e;
    const char* p;
    char* style;
    char* p0;
    char* p1;
    int i;
    const char* locale_format;
    _unknown_ _v12;
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    char* _v28;
    signed char* _v32;
    int _v48;
    const char* _v52;
    const char* _v56;
    const char* _v60;
    int _v64;
    const char* _v68;
    _Bool _v69;
    _Bool _v76;
    intOrPtr _v80;
    signed int _v86;
    char _v88;
    intOrPtr _v92;
    int _v96;
    _unknown_ _v108;
    int _v112;
    unsigned int _v116;
    int _v136;
    intOrPtr _v140;
    unsigned int _v144;
    _unknown_ _v152;
    _unknown_ _v156;
    char* _v160;
    intOrPtr _v164;
    intOrPtr _v168;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t179;
    char* _t182;
    _unknown_ _t195;
    _unknown_ _t234;
    _unknown_ _t235;
    _unknown_ _t249;
    _unknown_ _t251;
    _unknown_ _t254;
    _unknown_ _t259;
    char* _t264;
    char* _t265;
    char* _t276;
    char* _t277;
    char* _t285;
    char* _t286;
    _unknown_ _t290;
    _unknown_ _t301;
    _unknown_ _t303;

    _v76 = 0;
    _v69 = 0;
    qmark_funny_chars = 0;
    _v136 = ls_mode;
    if(_v136 == 2) {
        format = 2;
        set_quoting_style(0, 4);
    } else {
        if(_v136 == 3) {
            format = 0;
            set_quoting_style(0, 4);
        } else {
            if(_v136 == 1) {
                if(isatty(1) == 0) {
                    format = 1;
                    qmark_funny_chars = 0;
                } else {
                    format = 2;
                    qmark_funny_chars = 1;
                }
            } else {
                abort();
            }
        }
    }
    time_type = 0;
    sort_type = 0;
    sort_reverse = 0;
    numeric_ids = 0;
    print_block_size = 0;
    indicator_style = 0;
    print_inode = 0;
    dereference = 1;
    recursive = 0;
    immediate_dirs = 0;
    ignore_mode = 0;
    ignore_patterns = 0;
    hide_patterns = 0;
    print_scontext = 0;
    _v68 = getenv("QUOTING_STYLE");
    if(_v68 != 0) {
        _v64 = argmatch(_v68,  &quoting_style_args,  &quoting_style_vals, 4);
        if(_v64 >= 0) {
            _t285 = quotearg(_v68);
            _t286 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
            _v160 = _t285;
            error(0, 0, _t286);
        } else {
            set_quoting_style(0,  *( &quoting_style_vals + _v64 * 4));
        }
    }
    _v60 = getenv("LS_BLOCK_SIZE");
    human_options(_v60,  &human_output_opts,  &output_block_size);
    if(_v60 != 0 || getenv("BLOCK_SIZE") != 0) {
        file_output_block_size = output_block_size;
         *134627796 =  *134628524;
    }
    line_length = 80;
    _v56 = getenv("COLUMNS");
    if(_v56 != 0 && ( *_v56 & 255 & 4294967295) != 0) {
        if(xstrtoul(_v56, 0, 0,  &_v80, 0) != 0 || _v80 == 0) {
            _t276 = quotearg(_v56);
            _t277 = gettext("ignoring invalid width in environment variable COLUMNS: %s");
            _v160 = _t276;
            error(0, 0, _t277);
        } else {
            line_length = _v80;
        }
    }
    _t182 =  &_v88;
    _v164 = _t182;
    _v168 = 21523;
     *__esp = 1;
    ioctl();
    if(_t182 != 255 && (_v86 & 65535 & 4294967295) != 0) {
        line_length = _v86 & 65535 & 4294967295 & ;
    }
    _v52 = getenv("TABSIZE");
    tabsize = 8;
    if(_v52 != 0) {
        if(xstrtoul(_v52, 0, 0,  &_v92, 0) != 0) {
            _t264 = quotearg(_v52);
            _t265 = gettext("ignoring invalid tab size in environment variable TABSIZE: %s");
            _v160 = _t264;
            error(0, 0, _t265);
        } else {
            tabsize = _v92;
        }
    }
    while(1) {
        _v96 = -1;
        _v48 = getopt_long(argc, argv, "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1",  &long_options,  &_v96);
        if(_v48 == 255) {
            break;
        }
        _v140 = _v48 + 131;
        if(_v140 > 274) {
            usage(2);
            continue;
        }
        goto __eax;
        break;
    }
    if(line_length <= 2) {
        _v116 = 1;
    } else {
        _v144 = line_length;
        _v116 = _v144 * -1431655765 >> 32 >> 1;
    }
    max_idx = _v116;
    filename_quoting_options = clone_quoting_options(0);
    if(get_quoting_style(filename_quoting_options) == 4) {
        set_char_quoting(filename_quoting_options, 32, 1);
    }
    if(indicator_style <= 1) {
        dirname_quoting_options = clone_quoting_options(0);
        set_char_quoting(dirname_quoting_options, 58, 1);
        if((dired & 255 & 4294967295) != 0 && format != 0) {
            dired = 0;
        }
        if(time_type == 1 || time_type == 2) {
            if(((_v69 & 255 ^ 1) & 4294967295) != 0 && format != 0) {
                sort_type = 4;
            }
        }
        if(format != 0) {
            _v112 = __imp__optind;
            return _v112;
        } else {
            _v28 = _v76;
            if(_v28 == 0) {
                _v28 = getenv("TIME_STYLE");
                if(_v28 == 0) {
                    _v28 = "locale";
                }
            }
            while(strncmp(_v28, "posix-", 6) == 0) {
                if(((hard_locale(2) ^ 1) & 4294967295) == 0) {
                    _v28 =  &(_v28[6]);
                    continue;
                }
                _v112 = __imp__optind;
                return _v112;
            }
        }
        return _v112;
    }
    _v32 = indicator_style - 2 + "*=>|";
    while(( *_v32 & 255 & 4294967295) != 0) {
        set_char_quoting(filename_quoting_options,  *_v32 & 255 & 4294967295, 1);
        _v32 =  &(_v32[1]);
    }
}

_Bool get_funky_string(char** dest, const char** src, _Bool equals_end, size_t* output_count)
{// addr = 0x0804B7D9
    char num;
    size_t count;
    union  state;
    const char* p;
    char* q;
    char* _v8;
    const char* _v12;
    intOrPtr _v16;
    char _v20;
    char _v21;
    signed int _v40;
    _unknown_ __ebp;
    _unknown_ _t28;
    _unknown_ _t30;
    _unknown_ _t31;
    _unknown_ _t34;

    _v40 = equals_end & 4294967295;
    _v12 =  *src;
    _v8 =  *dest;
    _v20 = 0;
    _v21 = 0;
    _v16 = 0;
    while(_v16 <= 4) {
        if(_v16 <= 4) {
            goto L2;
        }
        abort();
        continue;
L2:
        goto __eax;
    }
}

parse_ls_color()
{// addr = 0x0804BAE2
    const char* p;
    char* buf;
    int state;
    int ind_no;
    char[2] label;
    struct color_ext_type* ext;
    struct color_ext_type* e;
    struct color_ext_type* e2;
    _unknown_ _v12;
    _unknown_ _v16;
    struct color_ext_type* _v20;
    signed int _v24;
    _Bool _v28;
    char* _v32;
    char* _v36;
    signed int _v38;
    intOrPtr _v39;
    _Bool _v44;
    _Bool _v48;
    _Bool _v52;
    signed int _v56;
    _Bool _v60;
    char* _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t134;
    _unknown_ _t139;
    _unknown_ _t149;
    _unknown_ _t155;
    const char* _t156;
    _unknown_ _t158;
    char* _t175;
    char* _t176;
    _unknown_ _t177;
    signed char* _t202;

    __ecx = __ecx;
    _v32 = getenv("LS_COLORS");
    _t136 = _v32;
    if(_v32 == 0) {
        return ;
    }
    _t136 =  *_v32 & 255;
    if(( *_v32 & 255 & 4294967295) == 0) {
        return ;
    }
    _v20 = 0;
    memcpy( &_v39, "??", 3);
    color_buf = xstrdup(_v32);
    _v36 = color_buf;
    _v28 = 1;
L41:
    while(_v28 > 0) {
        _v60 = _v28;
        if(_v60 == 2) {
            if(( *_v32 & 255 & 4294967295) == 0) {
                _v28 = -1;
            } else {
                _t156 = _v32;
                _v38 =  *_t156 & 255 & 4294967295;
                _v32 =  &(_t156[1]);
                _v28 = 3;
            }
            continue;
        }
        if(_v60 > 2) {
            if(_v60 == 3) {
                _v28 = -1;
                _v32 =  &(_v32[1]);
                if((__ecx & 4294967295) == 0) {
                    continue;
                }
            } else {
                if(_v60 == 4) {
                    _v32 =  &(_v32[1]);
                    if((__ecx & 4294967295) == 0) {
                        _v28 = -1;
                    } else {
                        _v20[3] = _v36;
                        if((get_funky_string( &_v36,  &_v32, 0,  &(_v20[2])) & 4294967295) == 0) {
                            _v44 = -1;
                        } else {
                            _v44 = 1;
                        }
                        _v28 = _v44;
                    }
                }
                continue;
            }
L25:
            _v24 = 0;
            while( *( &indicator_name + _v24 * 4) != 0) {
                if(strcmp( &_v39,  *( &indicator_name + _v24 * 4)) != 0) {
                    _v24 = _v24 + 1;
                    continue;
                }
                 *(134627812 + _v24 * 8) = _v36;
                if((get_funky_string( &_v36,  &_v32, 0,  &color_indicator + (_v24 << 3)) & 4294967295) == 0) {
                    _v48 = -1;
                } else {
                    _v48 = 1;
                }
                _v28 = _v48;
                if(_v28 == 255) {
                    _t175 = quotearg( &_v39);
                    _t176 = gettext("unrecognized prefix: %s");
                    _v64 = _t175;
                    error(0, 0, _t176);
                }
                goto L41;
            }
        }
        if(_v60 == 1) {
            _v56 =  *_v32 & 255 & 4294967295;
            if(_v56 == 42) {
                _v20 = xmalloc(20);
                _v20[4] = color_ext_list;
                color_ext_list = _v20;
                _v32 =  &(_v32[1]);
                _v20[1] = _v36;
                if((get_funky_string( &_v36,  &_v32, 1, _v20) & 4294967295) == 0) {
                    _v52 = -1;
                } else {
                    _v52 = 4;
                }
                _v28 = _v52;
            } else {
                if(_v56 == 58) {
                    _v32 =  &(_v32[1]);
                } else {
                    if(_v56 == 0) {
                        _v28 = 0;
                    } else {
                        _t202 = _v32;
                        _v39 =  *_t202 & 255 & 4294967295;
                        _v32 =  &(_t202[1]);
                        _v28 = 2;
                    }
                }
            }
        }
    }
}

set_exit_status(_Bool serious)
{// addr = 0x0804BE91
    signed int _v8;
    _unknown_ __ebp;

    _v8 = serious & 4294967295;
    if(_v8 == 0) {
        if(exit_status != 0) {
            return ;
        }
        exit_status = 1;
        return;
    }
    exit_status = 2;
    return;
}

file_failure(_Bool serious, const char* message, const char* file)
{// addr = 0x0804BEC4
    signed char _v12;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    char* __ebx;
    _unknown_ __ebp;
    int* _t13;

    _v12 = serious & 4294967295;
    __ebx = quotearg_colon(file);
    _t13 = __errno_location();
    _v16 = __ebx;
    error(0,  *_t13, message);
    set_exit_status(_v12 & 255);
    return;
}

queue_directory(const char* name, const char* realname, _Bool command_line_arg)
{// addr = 0x0804BF12
    struct pending* new;
    _Unknown_base* _v8;
    struct pending _v28;
    char* _v32;
    _unknown_ __ebp;

    _v28.realname = command_line_arg & 4294967295;
    _v8 = xmalloc(16);
    if(realname == 0) {
        _v32 = 0;
    } else {
        _v32 = xstrdup(realname);
    }
    _v8->realname = _v32;
    if(name == 0) {
        _v28.name = 0;
    } else {
        _v28.name = xstrdup(name);
    }
     *_v8 = _v28;
    _v8->command_line_arg = _v28.realname & 255 & 4294967295;
    _v8->next = pending_dirs;
    pending_dirs = _v8;
    return;
}

print_dir(const char* name, const char* realname, _Bool command_line_arg)
{// addr = 0x0804BF98
    DIR* dirp;
    struct dirent* next;
    uintmax_t total_blocks;
    struct stat dir_stat;
    int fd;
    struct dev_ino* di;
    struct obstack* __o;
    int __len;
    union filetype type;
    struct obstack* __o;
    int __len;
    struct obstack* __o;
    int __len;
    const char* p;
    char[651] buf;
    char* _v16;
    int _v20;
    unsigned int _v24;
    int _v28;
    unsigned int _v32;
    int _v36;
    int _v40;
    unsigned int _v44;
    char** _v48;
    unsigned int _v52;
    int _v56;
    int _v60;
    unsigned int _v64;
    unsigned int _v68;
    int _v628;
    char* _v632;
    int _v716;
    unsigned int _v720;
    signed int _v736;
    const char* _v740;
    quoting_options* _v744;
    signed int _v748;
    signed int _v749;
    intOrPtr _v768;
    long long unsigned int _v772;
    const char* _v776;
    int _v780;
    int _v784;
    unsigned int* _v788;
    int _v792;
    _unknown_ __ebx;
    _unknown_ __ebp;
    const char* _t201;
    unsigned int _t204;
    unsigned int _t207;
    _unknown_ _t218;
    _unknown_ _t223;
    _unknown_ _t232;
    _unknown_ _t237;
    _unknown_ _t242;
    _unknown_ _t256;
    _unknown_ _t265;
    _unknown_ _t278;
    _unknown_ _t285;
    _unknown_ _t288;
    unsigned int _t305;
    _unknown_ _t310;
    unsigned int _t311;
    unsigned int _t313;
    char* _t332;
    char* _t333;
    unsigned int _t339;
    char** _t354;
    char** _t355;
    _unknown_ _t379;

    _v736 = command_line_arg & 4294967295;
    _v60 = 0;
    _v56 = 0;
     *(__errno_location()) = 0;
    _t201 = name;
     *__esp = _t201;
    opendir();
    _v68 = _t201;
    if(_v68 != 0) {
        if(active_dir_set == 0) {
L13:
            clear_files();
            while(1) {
L14:
                 *(__errno_location()) = 0;
                _t204 = _v68;
                 *__esp = _t204;
                readdir64();
                _v64 = _t204;
                if(_v64 == 0) {
                    break;
                }
                if(((file_ignored(_v64 + 19) ^ 1) & 4294967295) == 0) {
                    continue;
                }
                _v36 = 0;
                _v748 =  *(_v64 + 18) & 255 & 4294967295 & ;
                if(_v748 > 14) {
                    _t305 = _v64;
                    _v776 = name;
                    _v780 = 0;
                    _v788 =  *_t305;
                    _v784 =  *(_t305 + 4);
                    _v792 = _v36;
                     *__esp = _v64 + 19;
                    _v60 = _v60 + gobble_file();
                    asm("adc [ebp-0x34], edx");
                    continue;
                }
                goto __eax;
                break;
            }
            if( *(__errno_location()) == 0) {
L21:
                _t207 = _v68;
                 *__esp = _t207;
                closedir();
                if(_t207 != 0) {
                    file_failure(_v736 & 255, gettext("closing directory %s"), name);
                }
                sort_files();
                if((recursive & 255 & 4294967295) != 0) {
                    extract_dirs_from_files(name, _v736 & 255);
                }
                if((print_dir_name & 255 & 4294967295 &  | recursive & 255 & 4294967295 & ) != 0) {
                    if(((first & 255 ^ 1) & 4294967295) != 0) {
                        putchar_unlocked(10);
                        dired_pos = dired_pos + 1;
                    }
                    first = 0;
                    if((dired & 255 & 4294967295) != 0) {
                        fwrite_unlocked("  ", 1, 2, __imp__stdout);
                        dired_pos = dired_pos + 2;
                    }
                    if((dired & 255 & 4294967295) != 0) {
                        _v32 =  &subdired_obstack;
                        _v28 = 4;
                        if( &(_v32->next_free[_v28]) > _v32->chunk_limit) {
                            _v792 = _v28;
                             *__esp = _v32;
                            _obstack_newchunk();
                        }
                        memcpy(_v32->next_free,  &dired_pos, _v28);
                        _v32->next_free = _v32->next_free + _v28;
                    }
                    _v744 = dirname_quoting_options;
                    if(realname == 0) {
                        _v740 = name;
                    } else {
                        _v740 = realname;
                    }
                    dired_pos = quote_name(__imp__stdout, _v740, _v744, 0) + dired_pos;
                    if((dired & 255 & 4294967295) != 0) {
                        _v24 =  &subdired_obstack;
                        _v20 = 4;
                        if( &(_v24->next_free[_v20]) > _v24->chunk_limit) {
                            _v792 = _v20;
                             *__esp = _v24;
                            _obstack_newchunk();
                        }
                        memcpy(_v24->next_free,  &dired_pos, _v20);
                        _v24->next_free = _v24->next_free + _v20;
                    }
                    fwrite_unlocked(":\n", 1, 2, __imp__stdout);
                    dired_pos = dired_pos + 2;
                }
                if(format == 0 || (print_block_size & 255 & 4294967295) != 0) {
                    if((dired & 255 & 4294967295) != 0) {
                        fwrite_unlocked("  ", 1, 2, __imp__stdout);
                        dired_pos = dired_pos + 2;
                    }
                    _v16 = gettext("total");
                    fputs_unlocked(_v16, __imp__stdout);
                    dired_pos = strlen(_v16) + dired_pos;
                    putchar_unlocked(32);
                    dired_pos = dired_pos + 1;
                    _v772 = output_block_size;
                    _v768 =  *134628524;
                    _v780 = 512;
                    _v776 = 0;
                    _v784 = human_output_opts;
                    _v788 =  &_v720;
                     *__esp = _v60;
                    _v792 = _v56;
                    _v16 = human_readable();
                    fputs_unlocked(_v16, __imp__stdout);
                    dired_pos = strlen(_v16) + dired_pos;
                    putchar_unlocked(10);
                    dired_pos = dired_pos + 1;
                }
                if(cwd_n_used == 0) {
                    return ;
                }
                print_current_files();
                return;
            }
            file_failure(_v736 & 255, gettext("reading directory %s"), name);
            if( *(__errno_location()) == 75) {
                goto L14;
            }
            goto L21;
        }
        goto L3;
    }
    file_failure(_v736 & 255, gettext("cannot open directory %s"), name);
    return;
L3:
    _t311 = _v68;
     *__esp = _t311;
    dirfd();
    _v52 = _t311;
    if(_v52 >= 0) {
        _v792 =  &_v720;
        _t313 = name;
         *__esp = _t313;
        L0805E3C0();
        _v749 = _t313 >> 31 & 4294967295;
    } else {
        _v792 =  &_v720;
        _t339 = _v52;
         *__esp = _t339;
        L0805E400();
        _v749 = _t339 >> 31 & 4294967295;
    }
    if(_v749 == 0) {
        _v788 = _v632;
        _v784 = _v628;
         *__esp = _v720;
        _v792 = _v716;
        if((visit_dir() & 4294967295) == 0) {
            _v44 =  &dev_ino_obstack;
            _v40 = 16;
            if(_v44->chunk_limit - _v44->next_free < _v40) {
                _v792 = _v40;
                 *__esp = _v44;
                _obstack_newchunk();
            }
            _v44->next_free =  &(_v44->next_free[_v40]);
            _v48 = dev_ino_obstack.next_free - 16;
            _t354 = _v48;
            _t354[2] = _v720;
            _t354[3] = _v716;
            _t355 = _v48;
             *_t355 = _v632;
            _t355[1] = _v628;
            goto L13;
        }
    } else {
        file_failure(_v736 & 255, gettext("cannot determine device and inode of %s"), name);
         *__esp = _v68;
        closedir();
        return;
    }
L9:
    _t332 = quotearg_colon(name);
    _t333 = gettext("%s: not listing already-listed directory");
    _v784 = _t332;
    error(0, 0, _t333);
     *__esp = _v68;
    closedir();
    return;
}

add_ignore_pattern(const char* pattern)
{// addr = 0x0804C66F
    struct ignore_pattern* ignore;
    _Unknown_base* _v8;
    _unknown_ __ebp;
    _unknown_ _t7;

    _v8 = xmalloc(8);
     *_v8 = pattern;
    _v8->next = ignore_patterns;
    ignore_patterns = _v8;
    return;
}

_Bool patterns_match(const struct ignore_pattern* patterns, const char* file)
{// addr = 0x0804C6A2
    const struct ignore_pattern* p;
    struct ignore_pattern* _v8;
    signed char _v21;
    intOrPtr _v36;
    const char* _v40;
    _unknown_ __ebp;
    const char* _t16;

    _v8 = patterns;
    while(_v8 != 0) {
        _v36 = 4;
        _t16 = file;
        _v40 = _t16;
         *__esp =  *_v8;
        fnmatch();
        if(_t16 != 0) {
            _v8 = _v8->next;
            continue;
        }
        _v21 = 1;
        return _v21 & 255;
    }
}

_Bool file_ignored(const char* name)
{// addr = 0x0804C6EF
    signed char _v8;
    signed int _v12;
    _unknown_ _v24;
    _unknown_ __ebp;

    if(ignore_mode == 2 || ( *name & 255 & 4294967295) != 46) {
L7:
        if(ignore_mode != 0 || (patterns_match(hide_patterns, name) & 4294967295) == 0) {
            if((patterns_match(ignore_patterns, name) & 4294967295) == 0) {
L11:
                _v12 = 0;
                return _v12 & 255;
            }
        }
L10:
        _v12 = 1;
        return _v12 & 255;
    }
    if(ignore_mode == 0) {
        goto L10;
    }
    if((name[1] & 255 & 4294967295) != 46) {
        _v8 = 1;
    } else {
        _v8 = 2;
    }
    if(( *(name + _v8) & 255 & 4294967295) == 0) {
        goto L10;
    } else {
        goto L7;
    }
    goto L11;
}

uintmax_t unsigned_file_size(off_t size)
{// addr = 0x0804C78B
    intOrPtr _v8;
    long long unsigned int _v12;
    _unknown_ __ebp;

    _v12 = size;
    _v8 = _a8;
    return _v12;
}

clear_files()
{// addr = 0x0804C7A5
    size_t i;
    struct fileinfo* f;
    _Unknown_base* _v8;
    signed int _v12;
    _unknown_ __ebp;
    _unknown_ _t22;
    _unknown_ _t25;

    _v12 = 0;
    while(_v12 < cwd_n_used) {
        _v8 = sorted_file[_v12];
        free( *_v8);
        free( *(_v8 + 4));
        if( *((intOrPtr*)(_v8 + 112)) !=  &UNKNOWN_SECURITY_CONTEXT) {
            freecon( *(_v8 + 112));
        }
        _v12 = _v12 + 1;
    }
}

freecon(char* con)
{// addr = 0x0804C883
    _unknown_ __ebp;

    return;
}

uintmax_t gobble_file(const char* name, union filetype type, ino_t inode, _Bool command_line_arg, const char* dirname)
{// addr = 0x0804C888
    uintmax_t blocks;
    struct fileinfo* f;
    char* absolute_name;
    _Bool do_deref;
    int err;
    _Bool need_lstat;
    _Bool have_acl;
    int attr_len;
    int n;
    char* linkname;
    struct stat linkstats;
    char[651] buf;
    int len;
    int len;
    int len;
    int len;
    int len;
    char[20] b;
    int b_len;
    char[20] buf;
    int len;
    char[651] buf;
    uintmax_t size;
    int len;
    char[20] buf;
    int len;
    _unknown_ _v8;
    int _v16;
    int _v20;
    int _v24;
    long long unsigned int _v28;
    int _v32;
    int _v36;
    int _v40;
    int _v44;
    int _v48;
    int _v52;
    int _v56;
    char* _v60;
    int _v64;
    int _v68;
    signed int _v69;
    signed char _v70;
    signed int _v76;
    long long unsigned int _v77;
    signed int _v84;
    struct fileinfo* _v88;
    int _v96;
    char* _v100;
    char _v121;
    char _v142;
    char _v163;
    signed int _v800;
    char _v816;
    signed int _v832;
    signed int _v836;
    signed int _v840;
    int _v844;
    int _v848;
    int _v852;
    signed char _v853;
    union Dereference_symlink _v860;
    signed int _v864;
    char _v876;
    intOrPtr _v880;
    long long unsigned int _v884;
    int _v888;
    long long unsigned int _v892;
    int _v896;
    char* _v900;
    int _v904;
    _unknown_ __ebp;
    _unknown_ _t343;
    signed int _t352;
    struct fileinfo* _t382;
    struct fileinfo* _t402;
    struct fileinfo* _t417;
    char* _t418;
    struct fileinfo* _t423;
    char* _t424;
    struct fileinfo* _t439;
    _unknown_ _t494;
    char* _t497;
    char* _t508;
    int* _t509;
    signed int _t519;
    signed int _t538;
    signed int _t549;
    int _t553;
    _unknown_ _t597;
    struct fileinfo* _t601;
    _unknown_ _t604;
    _unknown_ _t605;
    _unknown_ _t606;
    _unknown_ _t622;
    int _t630;

    _push(__ebx);
    __esp = __esp - 900;
    _v836 = inode;
    _v832 = command_line_arg;
    _v840 = dirname & 4294967295;
    _v100 = 0;
    _v96 = 0;
    if(_v840 != 0) {
        if((_v836 | _v832) != 0) {
            _v896 = "gobble_file";
            _v900 = 2551;
            _v904 = "ls.c";
             *__esp = "! command_line_arg || inode == NOT_AN_INODE_NUMBER";
            __assert_fail();
        }
    }
    if(cwd_n_used == cwd_n_alloc) {
        cwd_file = xnrealloc(cwd_file, cwd_n_alloc, 240);
        cwd_n_alloc = cwd_n_alloc + cwd_n_alloc;
    }
    _v88 = cwd_file + (0 + cwd_n_used * 8 << 4) - 0 + cwd_n_used * 8;
    memset(_v88, 0, 120);
    _t601 = _v88;
    _t601->stat = _v836;
    _t601->stat = _v832;
    _v88->filetype.st_dev = type;
    if(_v840 != 0 || (format_needs_stat & 255 & 4294967295) != 0 || type == 3 && (print_with_color & 255 & 4294967295) != 0) {
L27:
        if(( *name & 255 & 4294967295) == 47) {
L29:
            _v84 = name;
L31:
            _v860 = dereference;
            if(_v860 < 3) {
L41:
                _v904 =  &(_v88->stat);
                _t352 = _v84;
                 *__esp = _t352;
                L0805E440();
                _v76 = _t352;
                _v77 = 0;
                goto L42;
            }
L32:
            if(_v860 <= 4) {
                if(_v840 == 0) {
                    goto L41;
                }
                goto L36;
            }
            if(_v860 != 5) {
                goto L41;
            } else {
                _v904 =  &(_v88->stat);
                _t549 = _v84;
                 *__esp = _t549;
                L0805E3C0();
                _v76 = _t549;
                _v77 = 1;
            }
            goto L42;
L36:
            _v904 =  &(_v88->stat);
            _t538 = _v84;
             *__esp = _t538;
            L0805E3C0();
            _v76 = _t538;
            _v77 = 1;
            if(dereference == 3) {
                goto L42;
            } else {
                if(_v76 >= 0) {
                    _v853 = (_v88->stat.st_dev & 61440) != 16384;
                } else {
                    _v853 =  *(__errno_location()) == 2;
                }
            }
            _v70 = _v853 & 255 & 4294967295;
            if(((_v70 & 255 ^ 1) & 4294967295) != 0) {
                goto L42;
            }
            goto L41;
L42:
            if(_v76 != 0) {
                file_failure(_v840 & 255, gettext("cannot access %s"), _v84);
                if(_v840 != 0) {
                    _v852 = 0;
                    _v848 = 0;
                    return _v852;
                }
                 *_v88 = xstrdup(name);
                cwd_n_used = cwd_n_used + 1;
                _v852 = 0;
                _v848 = 0;
                return _v852;
            }
            _v88->stat_ok.st_dev = 1;
            if(format == 0 || (print_scontext & 255 & 4294967295) != 0) {
                _v69 = 0;
                if(_v77 == 0) {
                    _v844 = lgetfilecon(_v84,  &(_v88->scontext));
                } else {
                    _v844 = getfilecon(_v84,  &(_v88->scontext));
                }
                _v68 = _v844;
                _v76 = _v68 >> 31;
                if(_v76 != 0) {
                    _v88->scontext.st_dev =  &UNKNOWN_SECURITY_CONTEXT;
                    if( *(__errno_location()) == 95 ||  *(__errno_location()) == 61) {
                        _v76 = 0;
                    }
                } else {
                    _v69 = strcmp("unlabeled", _v88->scontext.st_dev) & 4294967295;
                }
                if(_v76 == 0 && ((_v69 & 255 ^ 1) & 4294967295) != 0 && format == 0) {
                    _v64 = file_has_acl(_v84,  &(_v88->stat));
                    _t519 = _v64 >> 31;
                    _v76 = _t519;
                    _v69 = _t519 & 4294967295;
                }
                _v88->have_acl.st_dev = _v69 & 255 & 4294967295;
                any_has_acl = (_v69 & 255 | any_has_acl & 255 & 4294967295 & ) & 4294967295;
                if(_v76 != 0) {
                    _t508 = quotearg_colon(_v84);
                    _t509 = __errno_location();
                    _v896 = _t508;
                    error(0,  *_t509, "%s");
                }
            }
            if((_v88->stat.st_dev & 61440) == 40960 && (format == 0 || (check_symlink_color & 255 & 4294967295) != 0)) {
                get_link_name(_v84, _v88, _v840 & 255);
                _v60 = make_link_name(_v84, _v88->linkname);
                if(_v60 != 0 && (indicator_style > 1 || (check_symlink_color & 255 & 4294967295) != 0)) {
                    _v904 =  &_v816;
                    _t497 = _v60;
                     *__esp = _t497;
                    L0805E3C0();
                    if(_t497 == 0) {
                        _v88->linkok.st_dev = 1;
                        if(((_v840 & 255 ^ 1) & 4294967295) != 0 || format == 0 || (_v800 & 61440) != 16384) {
                             *(_v88 + 108) = _v800;
                        }
                    }
                }
                free(_v60);
            }
            if((_v88->stat.st_dev & 61440) == 40960 && ((check_symlink_color & 255 ^ 1) & 4294967295) != 0) {
                _v88->linkok.st_dev = 1;
            }
            if((_v88->stat.st_dev & 61440) != 40960) {
                if((_v88->stat.st_dev & 61440) != 16384) {
                    _v88->filetype.st_dev = 5;
                } else {
                    if(((immediate_dirs & 255 ^ 1) & 4294967295 &  & _v840 & 255) == 0) {
                        _v88->filetype.st_dev = 3;
                    } else {
                        _v88->filetype.st_dev = 9;
                    }
                }
            } else {
                _v88->filetype.st_dev = 6;
            }
            _t382 = _v88;
            _v100 = _t382->stat;
            _v96 = _t382->stat;
            if(format == 0 || (print_block_size & 255 & 4294967295) != 0) {
                _v884 = output_block_size;
                _v880 =  *134628524;
                _v892 = 512;
                _v888 = 0;
                _v896 = human_output_opts;
                _v900 =  &_v816;
                 *__esp = _v100;
                _v904 = _v96;
                _v56 = gnu_mbswidth(human_readable(), 0);
                if(block_size_width < _v56) {
                    block_size_width = _v56;
                }
            }
            if(format != 0) {
L98:
                if((print_scontext & 255 & 4294967295) != 0) {
                    _v40 = strlen(_v88->scontext);
                    if(scontext_width < _v40) {
                        scontext_width = _v40;
                    }
                }
                if(format == 0) {
                    _v900 =  &_v121;
                     *__esp = _v88->stat.st_dev;
                    _v904 = 0;
                    _v36 = strlen(umaxtostr());
                    if(nlink_width < _v36) {
                        nlink_width = _v36;
                    }
                    if((_v88->stat.st_dev & 61440) == 8192 || (_v88->stat & 61440) == 24576) {
                        _t417 = _v88;
                        _t418 = _t417->stat;
                         *__esp = _t418;
                        _v904 = _t417->stat;
                        gnu_dev_major();
                        _v900 =  &_v142;
                         *__esp = _t418;
                        _v904 = 0;
                        _v32 = strlen(umaxtostr());
                        if(major_device_number_width < _v32) {
                            major_device_number_width = _v32;
                        }
                        _t423 = _v88;
                        _t424 = _t423->stat;
                         *__esp = _t424;
                        _v904 = _t423->stat;
                        gnu_dev_minor();
                        _v900 =  &_v142;
                         *__esp = _t424;
                        _v904 = 0;
                        _v32 = strlen(umaxtostr());
                        if(minor_device_number_width < _v32) {
                            minor_device_number_width = _v32;
                        }
                        _v32 = major_device_number_width + 2 + minor_device_number_width;
                        if(file_size_width < _v32) {
                            file_size_width = _v32;
                        }
                    } else {
                        _t439 = _v88;
                        _t630 = _t439->stat;
                         *__esp = _t439->stat;
                        _v904 = _t630;
                        _v28 = unsigned_file_size();
                        _v24 = _t630;
                        _v884 = file_output_block_size;
                        _v880 =  *134627796;
                        _v892 = 1;
                        _v888 = 0;
                        _v896 = human_output_opts;
                        _v900 =  &_v816;
                         *__esp = _v28;
                        _v904 = _v24;
                        _v20 = gnu_mbswidth(human_readable(), 0);
                        if(file_size_width < _v20) {
                            file_size_width = _v20;
                        }
                    }
                }
                goto L114;
            } else {
                if((print_owner & 255 & 4294967295) != 0) {
                    _v52 = format_user_width(_v88->stat.st_dev);
                    if(owner_width < _v52) {
                        owner_width = _v52;
                    }
                }
                if((print_group & 255 & 4294967295) != 0) {
                    _v48 = format_group_width(_v88->stat);
                    if(group_width < _v48) {
                        group_width = _v48;
                    }
                }
                if((print_author & 255 & 4294967295) != 0) {
                    _v44 = format_user_width(_v88->stat);
                    if(author_width < _v44) {
                        author_width = _v44;
                    }
                }
                goto L98;
            }
        }
    } else {
        if((print_inode & 255 & 4294967295) != 0 || (format_needs_type & 255 & 4294967295) != 0) {
            if(type == 6 || type == 0) {
                if(dereference == 5 || ((_v840 & 255 ^ 1) & 4294967295) == 0 && dereference != 2 || (color_symlink_as_referent & 255 & 4294967295) != 0 || (check_symlink_color & 255 & 4294967295) != 0) {
                    goto L27;
                } else {
                    goto L18;
                }
                goto L28;
            }
        }
L18:
        if(((print_inode & 255 ^ 1) & 4294967295) != 0 || (_v836 | _v832) != 0) {
            if(((format_needs_type & 255 ^ 1) & 4294967295) != 0 || type != 0 && _v840 == 0 && (type != 5 || indicator_style != 3 && (((print_with_color & 255 ^ 1) & 4294967295) != 0 || (is_colored(13) & 4294967295) == 0))) {
L114:
                if((print_inode & 255 & 4294967295) != 0) {
                    _t402 = _v88;
                    _v900 =  &_v163;
                     *__esp = _t402->stat;
                    _v904 = _t402->stat;
                    _v16 = strlen(umaxtostr());
                    if(inode_number_width < _v16) {
                        inode_number_width = _v16;
                    }
                }
                 *_v88 = xstrdup(name);
                cwd_n_used = cwd_n_used + 1;
                _v852 = _v100;
                _v848 = _v96;
                return _v852;
            } else {
                goto L27;
            }
        }
        goto L27;
    }
L28:
    if(( *_a24 & 255 & 4294967295) != 0) {
        _t553 = strlen(name);
        __esp = __esp - (_t553 + strlen(_a24) + 2 + 15 + 15 >> 4 << 4);
        _v864 =  &_v876;
        _v864 = _v864 + 15 >> 4 << 4;
        _v84 = _v864;
        attach(_v84, _a24, name);
        goto L31;
    }
    goto L29;
}

int getfilecon(const char* s, char** con)
{// addr = 0x0804D30D
    _unknown_ __ebp;
    _unknown_ _t1;
    _unknown_ _t3;

     *(__errno_location()) = 95;
    return -1;
}

int lgetfilecon(const char* s, char** con)
{// addr = 0x0804D325
    _unknown_ __ebp;
    _unknown_ _t1;
    _unknown_ _t3;

     *(__errno_location()) = 95;
    return -1;
}

_Bool is_directory(const struct fileinfo* f)
{// addr = 0x0804D33D
    signed int _v8;
    _unknown_ __ebp;

    if(f->filetype == 3 || f->filetype == 9) {
        _v8 = 1;
        return _v8 & 255;
    }
    _v8 = 0;
    return _v8 & 255;
}

get_link_name(const char* filename, struct fileinfo* f, _Bool command_line_arg)
{// addr = 0x0804D36F
    signed char _v8;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t26;

    _v8 = command_line_arg & 4294967295;
    f->linkname = areadlink_with_size(filename, f->stat);
    if(f->linkname != 0) {
        return ;
    }
    file_failure(_v8 & 255, gettext("cannot read symbolic link %s"), filename);
    return;
}

char* make_link_name(const char* name, const char* linkname)
{// addr = 0x0804D3CA
    char* linkbuf;
    size_t bufsiz;
    int _v8;
    char* _v12;
    char* _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t47;
    _unknown_ _t50;

    if(linkname == 0) {
        _v24 = 0;
        return _v24;
    }
    if(( *linkname & 255 & 4294967295) == 47) {
        _v24 = xstrdup(linkname);
        return _v24;
    }
    _v12 = strrchr(name, 47);
    if(_v12 != 0) {
        _v8 = _v12 - name + 1;
        _v12 = xmalloc(strlen(linkname) + _v8 + 1);
        strncpy(_v12, name, _v8);
        strcpy( &(_v12[_v8]), linkname);
        _v24 = _v12;
        return _v24;
    }
    _v24 = xstrdup(linkname);
    return _v24;
}

_Bool basename_is_dot_or_dotdot(const char* name)
{// addr = 0x0804D495
    const char* base;
    char* _v8;
    _unknown_ __ebp;

    _v8 = last_component(name);
    return dot_or_dotdot(_v8);
}

_Bool dot_or_dotdot(const char* file_name)
{// addr = 0x0804D4B6
    char sep;
    signed int _v5;
    signed char _v24;
    signed int _v25;
    signed char _v32;
    _unknown_ __ebp;

    if(( *file_name & 255 & 4294967295) != 46) {
        _v25 = 0;
        return _v25 & 255;
    }
    if((file_name[1] & 255 & 4294967295) != 46) {
        _v32 = 1;
    } else {
        _v32 = 2;
    }
    _v5 =  *(file_name + _v32) & 255 & 4294967295;
    if(_v5 == 0 || _v5 == 47) {
        _v24 = 1;
    } else {
        _v24 = 0;
    }
    _v25 = _v24 & 255 & 4294967295;
    return _v25 & 255;
}

extract_dirs_from_files(const char* dirname, _Bool command_line_arg)
{// addr = 0x0804D51E
    size_t i;
    size_t j;
    _Bool ignore_dot_and_dot_dot;
    struct fileinfo* f;
    char* name;
    struct fileinfo* f;
    _unknown_ _v8;
    _unknown_ _v12;
    _unknown_ _v16;
    signed int _v17;
    const char* _v24;
    signed int _v28;
    signed int _v40;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    signed int _t68;
    signed int _t69;
    _unknown_ _t94;

    _t68 = command_line_arg;
    _v40 = _t68 & 4294967295;
    _v17 = _t68 & 4294967295;
    if(dirname != 0 && active_dir_set != 0) {
        queue_directory(0, dirname, 0);
    }
    _t69 = cwd_n_used;
    _v28 = _t69;
    while(1) {
        _v28 = _v28 - 1;
        if((_t69 & 4294967295) != 0) {
            goto L4;
        } else {
            _v28 = 0;
            _v24 = 0;
            goto L16;
        }
    }
}

int xstrcoll(const char* a, const char* b)
{// addr = 0x0804D6BB
    int diff;
    int _v20;
    const _None* _v44;
    const _None* _v48;
    _unknown_ _v52;
    int _v56;
    const _None* __edi;
    char* __esi;
    _unknown_ __ebp;
    _unknown_ _t15;
    const _None* _t26;
    int* _t28;

     *(__errno_location()) = 0;
    _v20 = strcoll(a, b);
    if( *(__errno_location()) == 0) {
        return _v20;
    }
    __edi = quote_n(1, b);
    _t26 = quote_n(0, a);
    __esi = gettext("cannot compare file names %s and %s");
    _t28 = __errno_location();
    _v44 = __edi;
    _v48 = _t26;
    error(0,  *_t28, __esi);
    set_exit_status(0);
    _v56 = 1;
     *__esp =  &failed_strcoll;
    longjmp();
    return _v20;
}

int xstrcoll_ctime(V a, V b)
{// addr = 0x0804D775
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_ctime(a, b, xstrcoll);
}

int cmp_ctime(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804D797
    int diff;
    int _v8;
    char* _v12;
    intOrPtr _v16;
    struct stat* _v20;
    intOrPtr _v24;
    int _v40;
    struct stat* _v56;
    struct stat* _v60;
    char* _v64;
    _unknown_ __ebp;
    _unknown_ _t32;
    _None* _t36;

    _v56 =  &(a->stat);
    get_stat_ctime( &_v24);
    __esp = __esp - 4;
    _v60 =  &(b->stat);
    get_stat_ctime( &_v16);
    __esp = __esp - 4;
    _v60 = _v24;
    _v56 = _v20;
     *__esp = _v16;
    _v64 = _v12;
    _v8 = timespec_cmp();
    if(_v8 != 0) {
        _v40 = _v8;
        return ;
    }
    _v64 = b->name;
     *__esp = a->name;
    _t36 = cmp;
     *_t36();
    _v40 = _t36;
    return;
}

struct timespec get_stat_ctime(const struct stat* st)
{// addr = 0x0804D81C
    _unknown_ __ebp;
    intOrPtr _t6;

    __ecx = st;
    _t6 = _a8;
     *__ecx =  *((intOrPtr*)(_t6 + 80));
     *((intOrPtr*)(__ecx + 4)) =  *((intOrPtr*)(_t6 + 84));
    return __ecx;
}

int timespec_cmp(struct timespec a, struct timespec b)
{// addr = 0x0804D836
    int _v8;
    int _v12;
    _unknown_ __ebp;

    if(a.tv_sec < b.tv_nsec) {
        _v12 = -1;
        return _v12;
    }
    if(a.tv_sec > b.tv_nsec) {
        _v8 = 1;
    } else {
        _v8 = a.tv_nsec - _a16;
    }
    _v12 = _v8;
    return _v12;
}

int strcmp_ctime(V a, V b)
{// addr = 0x0804D87A
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_ctime(a, b, strcmp);
}

int rev_xstrcoll_ctime(V a, V b)
{// addr = 0x0804D89C
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_ctime(b, a, xstrcoll);
}

int rev_strcmp_ctime(V a, V b)
{// addr = 0x0804D8BE
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_ctime(b, a, strcmp);
}

int xstrcoll_df_ctime(V a, V b)
{// addr = 0x0804D8E0
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_ctime(a, b, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int strcmp_df_ctime(V a, V b)
{// addr = 0x0804D958
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_ctime(a, b, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_xstrcoll_df_ctime(V a, V b)
{// addr = 0x0804D9D0
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_ctime(b, a, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_strcmp_df_ctime(V a, V b)
{// addr = 0x0804DA48
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_ctime(b, a, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int xstrcoll_mtime(V a, V b)
{// addr = 0x0804DAC0
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_mtime(a, b, xstrcoll);
}

int cmp_mtime(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804DAE2
    int diff;
    int _v8;
    char* _v12;
    intOrPtr _v16;
    struct stat* _v20;
    intOrPtr _v24;
    int _v40;
    struct stat* _v56;
    struct stat* _v60;
    char* _v64;
    _unknown_ __ebp;
    _unknown_ _t32;
    _None* _t36;

    _v56 =  &(a->stat);
    get_stat_mtime( &_v24);
    __esp = __esp - 4;
    _v60 =  &(b->stat);
    get_stat_mtime( &_v16);
    __esp = __esp - 4;
    _v60 = _v24;
    _v56 = _v20;
     *__esp = _v16;
    _v64 = _v12;
    _v8 = timespec_cmp();
    if(_v8 != 0) {
        _v40 = _v8;
        return ;
    }
    _v64 = b->name;
     *__esp = a->name;
    _t36 = cmp;
     *_t36();
    _v40 = _t36;
    return;
}

struct timespec get_stat_mtime(const struct stat* st)
{// addr = 0x0804DB67
    _unknown_ __ebp;
    intOrPtr _t6;

    __ecx = st;
    _t6 = _a8;
     *__ecx =  *((intOrPtr*)(_t6 + 72));
     *((intOrPtr*)(__ecx + 4)) =  *((intOrPtr*)(_t6 + 76));
    return __ecx;
}

int strcmp_mtime(V a, V b)
{// addr = 0x0804DB81
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_mtime(a, b, strcmp);
}

int rev_xstrcoll_mtime(V a, V b)
{// addr = 0x0804DBA3
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_mtime(b, a, xstrcoll);
}

int rev_strcmp_mtime(V a, V b)
{// addr = 0x0804DBC5
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_mtime(b, a, strcmp);
}

int xstrcoll_df_mtime(V a, V b)
{// addr = 0x0804DBE7
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_mtime(a, b, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int strcmp_df_mtime(V a, V b)
{// addr = 0x0804DC5F
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_mtime(a, b, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_xstrcoll_df_mtime(V a, V b)
{// addr = 0x0804DCD7
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_mtime(b, a, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_strcmp_df_mtime(V a, V b)
{// addr = 0x0804DD4F
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_mtime(b, a, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int xstrcoll_atime(V a, V b)
{// addr = 0x0804DDC7
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_atime(a, b, xstrcoll);
}

int cmp_atime(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804DDE9
    int diff;
    int _v8;
    char* _v12;
    intOrPtr _v16;
    struct stat* _v20;
    intOrPtr _v24;
    int _v40;
    struct stat* _v56;
    struct stat* _v60;
    char* _v64;
    _unknown_ __ebp;
    _unknown_ _t32;
    _None* _t36;

    _v56 =  &(a->stat);
    get_stat_atime( &_v24);
    __esp = __esp - 4;
    _v60 =  &(b->stat);
    get_stat_atime( &_v16);
    __esp = __esp - 4;
    _v60 = _v24;
    _v56 = _v20;
     *__esp = _v16;
    _v64 = _v12;
    _v8 = timespec_cmp();
    if(_v8 != 0) {
        _v40 = _v8;
        return ;
    }
    _v64 = b->name;
     *__esp = a->name;
    _t36 = cmp;
     *_t36();
    _v40 = _t36;
    return;
}

struct timespec get_stat_atime(const struct stat* st)
{// addr = 0x0804DE6E
    _unknown_ __ebp;
    intOrPtr _t6;

    __ecx = st;
    _t6 = _a8;
     *__ecx =  *((intOrPtr*)(_t6 + 64));
     *((intOrPtr*)(__ecx + 4)) =  *((intOrPtr*)(_t6 + 68));
    return __ecx;
}

int strcmp_atime(V a, V b)
{// addr = 0x0804DE88
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_atime(a, b, strcmp);
}

int rev_xstrcoll_atime(V a, V b)
{// addr = 0x0804DEAA
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_atime(b, a, xstrcoll);
}

int rev_strcmp_atime(V a, V b)
{// addr = 0x0804DECC
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_atime(b, a, strcmp);
}

int xstrcoll_df_atime(V a, V b)
{// addr = 0x0804DEEE
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_atime(a, b, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int strcmp_df_atime(V a, V b)
{// addr = 0x0804DF66
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_atime(a, b, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_xstrcoll_df_atime(V a, V b)
{// addr = 0x0804DFDE
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_atime(b, a, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_strcmp_df_atime(V a, V b)
{// addr = 0x0804E056
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_atime(b, a, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int xstrcoll_size(V a, V b)
{// addr = 0x0804E0CE
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_size(a, b, xstrcoll);
}

int cmp_size(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804E0F0
    int diff;
    _None* _v8;
    _None* _v24;
    long long unsigned int _v32;
    long long unsigned int _v36;
    long long unsigned int _v40;
    long long unsigned int _v44;
    long long unsigned int _v48;
    long long unsigned int _v52;
    long long unsigned int _v56;
    long long unsigned int _v60;
    _None* _v64;
    char* _v72;
    _unknown_ __ebp;
    const struct fileinfo* _t47;
    const struct fileinfo* _t48;
    _unknown_ _t50;
    _None* _t54;
    const struct fileinfo* _t56;
    const struct fileinfo* _t57;

    _t47 = b;
    _v60 = _t47->stat.st_dev;
    _v56 = _t47->stat.st_dev;
    _t48 = a;
    _v52 = _t48->stat.st_dev;
    _v48 = _t48->stat.st_dev;
    if(_v56 < _v48) {
L7:
        _v64 = -1;
        goto L8;
    }
    if(_v56 > _v48 || _v60 >= _v52) {
        _t56 = b;
        _v44 = _t56->stat.st_dev;
        _v40 = _t56->stat.st_dev;
        _t57 = a;
        _v36 = _t57->stat.st_dev;
        _v32 = _t57->stat.st_dev;
        _v64 = 1;
        if(_v40 <= _v32 && (_v40 < _v32 || _v44 <= _v36)) {
            _v64 = 0;
        }
        goto L8;
    } else {
        goto L7;
    }
L9:
    _v72 = b->name;
     *__esp = a->name;
    _t54 = cmp;
     *_t54();
    _v24 = _t54;
    return;
L8:
    _v8 = _v64;
    if(_v8 != 0) {
        _v24 = _v8;
        return ;
    }
    goto L9;
}

int strcmp_size(V a, V b)
{// addr = 0x0804E1AB
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_size(a, b, strcmp);
}

int rev_xstrcoll_size(V a, V b)
{// addr = 0x0804E1CD
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_size(b, a, xstrcoll);
}

int rev_strcmp_size(V a, V b)
{// addr = 0x0804E1EF
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_size(b, a, strcmp);
}

int xstrcoll_df_size(V a, V b)
{// addr = 0x0804E211
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_size(a, b, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int strcmp_df_size(V a, V b)
{// addr = 0x0804E289
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_size(a, b, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_xstrcoll_df_size(V a, V b)
{// addr = 0x0804E301
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_size(b, a, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_strcmp_df_size(V a, V b)
{// addr = 0x0804E379
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_size(b, a, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int xstrcoll_name(V a, V b)
{// addr = 0x0804E3F1
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_name(a, b, xstrcoll);
}

int cmp_name(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804E413
    char* _v8;
    _unknown_ __ebp;

    _v8 = b->name;
     *__esp = a->name;
     *cmp();
    return;
}

int strcmp_name(V a, V b)
{// addr = 0x0804E431
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_name(a, b, strcmp);
}

int rev_xstrcoll_name(V a, V b)
{// addr = 0x0804E453
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_name(b, a, xstrcoll);
}

int rev_strcmp_name(V a, V b)
{// addr = 0x0804E475
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_name(b, a, strcmp);
}

int xstrcoll_df_name(V a, V b)
{// addr = 0x0804E497
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_name(a, b, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int strcmp_df_name(V a, V b)
{// addr = 0x0804E50F
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_name(a, b, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_xstrcoll_df_name(V a, V b)
{// addr = 0x0804E587
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_name(b, a, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_strcmp_df_name(V a, V b)
{// addr = 0x0804E5FF
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_name(b, a, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int xstrcoll_extension(V a, V b)
{// addr = 0x0804E677
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_extension(a, b, xstrcoll);
}

int cmp_extension(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804E699
    const char* base1;
    const char* base2;
    int diff;
    _None* _v8;
    char* _v12;
    char* _v16;
    _None* _v24;
    char* _v28;
    char* _v32;
    char* _v40;
    _unknown_ __ebp;
    _None* _t37;
    _unknown_ _t39;
    _None* _t43;

    _v16 = strrchr(a->name, 46);
    _v12 = strrchr(b->name, 46);
    if(_v12 == 0) {
        _v32 = 134606192;
    } else {
        _v32 = _v12;
    }
    if(_v16 == 0) {
        _v28 = 134606192;
    } else {
        _v28 = _v16;
    }
    _v40 = _v32;
     *__esp = _v28;
    _t37 = cmp;
     *_t37();
    _v8 = _t37;
    if(_v8 != 0) {
        _v24 = _v8;
        return ;
    }
    _v40 = b->name;
     *__esp = a->name;
    _t43 = cmp;
     *_t43();
    _v24 = _t43;
    return;
}

int strcmp_extension(V a, V b)
{// addr = 0x0804E73A
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_extension(a, b, strcmp);
}

int rev_xstrcoll_extension(V a, V b)
{// addr = 0x0804E75C
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_extension(b, a, xstrcoll);
}

int rev_strcmp_extension(V a, V b)
{// addr = 0x0804E77E
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return cmp_extension(b, a, strcmp);
}

int xstrcoll_df_extension(V a, V b)
{// addr = 0x0804E7A0
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_extension(a, b, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int strcmp_df_extension(V a, V b)
{// addr = 0x0804E818
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_extension(a, b, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_xstrcoll_df_extension(V a, V b)
{// addr = 0x0804E890
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_extension(b, a, xstrcoll);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_strcmp_df_extension(V a, V b)
{// addr = 0x0804E908
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_extension(b, a, strcmp);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int xstrcoll_version(V a, V b)
{// addr = 0x0804E980
    _unknown_ _v8;
    _unknown_ __ebp;

    return cmp_version(a, b);
}

int cmp_version(const struct fileinfo* a, const struct fileinfo* b)
{// addr = 0x0804E99A
    char* _v8;
    _unknown_ __ebp;
    int _t6;

    _t6 = a->name;
    _v8 = b->name;
     *__esp = _t6;
    strverscmp();
    return _t6;
}

int rev_xstrcoll_version(V a, V b)
{// addr = 0x0804E9B8
    _unknown_ _v8;
    _unknown_ __ebp;

    return cmp_version(b, a);
}

int xstrcoll_df_version(V a, V b)
{// addr = 0x0804E9D2
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_version(a, b);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

int rev_xstrcoll_df_version(V a, V b)
{// addr = 0x0804EA42
    _Bool a_is_dir;
    _Bool b_is_dir;
    signed int _v5;
    signed char _v6;
    int _v24;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v6 = is_directory(a) & 4294967295;
    _v5 = is_directory(b) & 4294967295;
    if(_v6 != 0) {
        if(((_v5 & 255 ^ 1) & 4294967295) == 0) {
            goto L3;
        } else {
            _v24 = -1;
            return _v24;
        }
    }
L3:
    if(((_v6 & 255 ^ 1) & 4294967295) == 0 || _v5 == 0) {
        _v24 = cmp_version(b, a);
        return _v24;
    }
    _v24 = 1;
    return _v24;
}

initialize_ordering_vector()
{// addr = 0x0804EAB2
    size_t i;
    signed int _v12;
    _unknown_ __ebp;

    _v12 = 0;
    while(_v12 < cwd_n_used) {
        sorted_file[_v12] = cwd_file + (0 + _v12 * 8 << 4) - 0 + _v12 * 8;
        _v12 = _v12 + 1;
    }
}

sort_files()
{// addr = 0x0804EB01
    _Bool use_strcmp;
    signed int _v13;
    union time_type _v32;
    char* _v48;
    intOrPtr _v52;
    char* _v56;
    _unknown_ __ebp;
    union sort_type _t21;
    _unknown_ _t36;

    if((cwd_n_used >> 1) + cwd_n_used > sorted_file_alloc) {
        free(sorted_file);
        sorted_file = xnmalloc(cwd_n_used, 12);
        sorted_file_alloc = cwd_n_used + cwd_n_used + cwd_n_used;
    }
    initialize_ordering_vector();
    _t21 = sort_type;
    if(_t21 == 255) {
        return ;
    }
     *__esp =  &failed_strcoll;
    _setjmp();
    if(_t21 != 0) {
        _v13 = 1;
        if(sort_type == 3) {
            _v48 = "sort_files";
            _v52 = 3212;
            _v56 = "ls.c";
             *__esp = "sort_type != sort_version";
            __assert_fail();
        }
        initialize_ordering_vector();
    } else {
        _v13 = 0;
    }
    if(sort_type != 4) {
        _v32 = 0;
    } else {
        _v32 = time_type;
    }
    mpsort(sorted_file, cwd_n_used,  *( &sort_functions + (_v32 + sort_type + _v32 + sort_type + (_v13 & 255) + _v32 + sort_type + _v32 + sort_type + (_v13 & 255) + (sort_reverse & 255 & 4294967295 & ) + _v32 + sort_type + _v32 + sort_type + (_v13 & 255) + _v32 + sort_type + _v32 + sort_type + (_v13 & 255) + (sort_reverse & 255 & 4294967295 & ) + (directories_first & 255 & 4294967295 & )) * 4));
    return;
}

print_current_files()
{// addr = 0x0804EC2E
    size_t i;
    union format _v24;
    _unknown_ __ebp;

    _v24 = format;
    if(_v24 > 4) {
        return ;
    }
    goto ( *((intOrPtr*)(134609284 + _v24 * 4)));
}

int long_time_expected_width()
{// addr = 0x0804ECF0
    time_t epoch;
    const struct tm* tm;
    char[1000] buf;
    size_t len;
    unsigned int _v8;
    const struct tm* _v12;
    char _v16;
    char _v1017;
    _unknown_ _v1032;
    _unknown_ _v1036;
    _unknown_ _v1040;
    _unknown_ _v1044;
    _unknown_ _v1048;
    _unknown_ __ebp;
    const struct tm* _t20;

    if(width >= 0) {
        return width;
    }
    _v16 = 0;
    _t20 =  &_v16;
     *__esp = _t20;
    localtime();
    _v12 = _t20;
    if(_v12 != 0) {
        _v8 = nstrftime( &_v1017, 1001, long_time_format, _v12, 0, 0);
        if(_v8 != 0) {
            width = mbsnwidth( &_v1017, _v8, 0);
        }
    }
    if(width >= 0) {
        return width;
    }
    width = 0;
    return width;
}

get_current_time()
{// addr = 0x0804ED9D
    struct timespec timespec;
    struct timeval timeval;
    int _v8;
    long int _v12;
    signed int _v16;
    long int _v20;
    char* _v24;
    _unknown_ __ebp;
    char* _t9;

    _t9 =  &_v12;
    _v24 = _t9;
     *__esp = 0;
    clock_gettime();
    if(_t9 != 0) {
        _v24 = 0;
         *__esp =  &_v20;
        gettimeofday();
        current_time = _v20;
        current_time_ns = _v16 * _v16 + 999;
        return;
    }
    current_time = _v12;
    current_time_ns = _v8;
    return;
}

format_user_or_group(const char* name, long unsigned int id, int width)
{// addr = 0x0804EDFC
    size_t len;
    int width_gap;
    int pad;
    signed int _v8;
    signed int _v12;
    int _v16;
    long unsigned int _v36;
    int _v40;
    _unknown_ __ebp;
    _unknown_ _t29;
    _unknown_ _t44;
    signed int _t49;

    if(name == 0) {
        _v36 = id;
        _v40 = width;
        printf(134609304);
        _v16 = width;
    } else {
        _v12 = width - gnu_mbswidth(name, 0);
        _v8 =  !(_v12 >> 31) & _v12;
        fputs_unlocked(name, __imp__stdout);
        _v16 = strlen(name) + _v8;
        while(1) {
L2:
            _t49 = putchar_unlocked(32);
            _v8 = _v8 - 1;
            if((_t49 & 4294967295) == 0) {
                break;
            }
        }
    }
    dired_pos = dired_pos + _v16 + 1;
    return;
}

format_user(uid_t u, int width, _Bool stat_ok)
{// addr = 0x0804EEAC
    signed int _v8;
    char* _v12;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    _v8 = stat_ok & 4294967295;
    if(_v8 == 0) {
        _v16 = 134609310;
    } else {
        if((numeric_ids & 255 & 4294967295) == 0) {
            _v12 = getuser(u);
        } else {
            _v12 = 0;
        }
        _v16 = _v12;
    }
    format_user_or_group(_v16, u, width);
    return;
}

format_group(gid_t g, int width, _Bool stat_ok)
{// addr = 0x0804EF0A
    signed int _v8;
    char* _v12;
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    _v8 = stat_ok & 4294967295;
    if(_v8 == 0) {
        _v16 = 134609310;
    } else {
        if((numeric_ids & 255 & 4294967295) == 0) {
            _v12 = getgroup(g);
        } else {
            _v12 = 0;
        }
        _v16 = _v12;
    }
    format_user_or_group(_v16, g, width);
    return;
}

int format_user_or_group_width(const char* name, long unsigned int id)
{// addr = 0x0804EF68
    int len;
    char[10] buf;
    signed int _v8;
    char _v19;
    signed int _v24;
    long unsigned int _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t17;

    if(name == 0) {
        _v36 = id;
        sprintf( &_v19, 134609312);
        _v24 = strlen( &_v19);
        return _v24;
    }
    _v8 = gnu_mbswidth(name, 0);
    _v24 = _v8 &  !(_v8 >> 31);
    return _v24;
}

int format_user_width(uid_t u)
{// addr = 0x0804EFC9
    const char* _v8;
    _unknown_ _v24;
    _unknown_ __ebp;

    if((numeric_ids & 255 & 4294967295) == 0) {
        _v8 = getuser(u);
        return format_user_or_group_width(_v8, u);
    }
    _v8 = 0;
    return format_user_or_group_width(_v8, u);
}

int format_group_width(gid_t g)
{// addr = 0x0804F005
    const char* _v8;
    _unknown_ _v24;
    _unknown_ __ebp;

    if((numeric_ids & 255 & 4294967295) == 0) {
        _v8 = getgroup(g);
        return format_user_or_group_width(_v8, g);
    }
    _v8 = 0;
    return format_user_or_group_width(_v8, g);
}

print_long_format(const struct fileinfo* f)
{// addr = 0x0804F041
    char[11] modebuf;
    char[3642] buf;
    size_t s;
    char* p;
    time_t when;
    int when_ns;
    struct timespec when_timespec;
    struct tm* when_local;
    char[20] hbuf;
    char[651] hbuf;
    const char* blocks;
    int pad;
    char[20] hbuf;
    char[20] majorbuf;
    char[20] minorbuf;
    int blanks_width;
    char[651] hbuf;
    const char* size;
    int pad;
    time_t six_months_ago;
    _Bool recent;
    const char* fmt;
    char[20] hbuf;
    char _v16;
    signed char _v25;
    int _v60;
    struct stat _v64;
    char* _v68;
    unsigned int _v72;
    int _v73;
    int _v74;
    char _v84;
    char _v3727;
    int _v3732;
    char _v3736;
    char _v3757;
    char _v3778;
    char _v3799;
    char _v3820;
    char _v3841;
    char _v4493;
    int _v4504;
    struct stat _v4508;
    unsigned int _v4512;
    signed int _v4516;
    _Bool _v4520;
    _Bool _v4524;
    char* _v4528;
    signed char _v4532;
    char* _v4536;
    char* _v4540;
    int _v4544;
    char* _v4548;
    char* _v4552;
    union time_type _v4556;
    intOrPtr _v4564;
    long long unsigned int _v4568;
    char* _v4572;
    int _v4576;
    char* _v4580;
    int _v4584;
    signed int _v4588;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t399;
    _unknown_ _t418;
    const struct tm* _t446;
    _unknown_ _t455;
    _unknown_ _t486;
    int _t505;
    _unknown_ _t507;
    signed int _t510;
    const struct fileinfo* _t529;
    long long unsigned int _t531;
    _unknown_ _t537;
    const struct fileinfo* _t541;
    signed int _t542;
    char* _t544;
    const struct fileinfo* _t545;
    signed int _t546;
    char* _t548;
    _unknown_ _t555;
    _unknown_ _t563;
    _unknown_ _t587;
    const struct fileinfo* _t607;
    _unknown_ _t616;
    const struct fileinfo* _t619;
    _unknown_ _t628;
    _unknown_ _t648;
    _unknown_ _t650;
    _unknown_ _t651;
    _unknown_ _t658;
    signed int _t679;

    __esp = __esp - 4572;
    if((f->stat_ok & 255 & 4294967295) == 0) {
        _v84 =  *("?pcdb-lswd" + f->filetype) & 255 & 4294967295;
        memset( &((char*)( &_v84)[1]), 63, 10);
        _v73 = 0;
    } else {
        filemodestring( &(f->stat),  &_v84);
    }
    if(((any_has_acl & 255 ^ 1) & 4294967295) == 0) {
        if((f->have_acl & 255 & 4294967295) != 0) {
            _v74 = 43;
        }
    } else {
        _v74 = 0;
    }
    _v4556 = time_type;
    if(_v4556 != 1) {
        if(_v4556 < 1) {
            _v4584 =  &(f->stat);
            get_stat_mtime( &_v4508);
            __esp = __esp - 4;
            _v3736 = _v4508;
            _v3732 = _v4504;
        } else {
            if(_v4556 == 2) {
                _v4584 =  &(f->stat);
                get_stat_atime( &_v4508);
                __esp = __esp - 4;
                _v3736 = _v4508;
                _v3732 = _v4504;
            } else {
                abort();
            }
        }
    } else {
        _v4584 =  &(f->stat);
        get_stat_ctime( &_v4508);
        __esp = __esp - 4;
        _v3736 = _v4508;
        _v3732 = _v4504;
    }
    _v64 = _v3736;
    _v60 = _v3732;
    _v68 =  &_v3727;
    if((print_inode & 255 & 4294967295) != 0) {
        if((f->stat | f->stat) == 0) {
            _v4552 = 134609310;
        } else {
            _t619 = f;
            _v4584 =  &_v3757;
             *__esp = _t619->stat.st_dev;
            _v4588 = _t619->stat.st_dev;
            _v4552 = umaxtostr();
        }
        _v4580 = _v4552;
        _v4584 = inode_number_width;
        sprintf(_v68, 134609316);
        _v68 =  &(_v68[strlen(_v68)]);
    }
    if((print_block_size & 255 & 4294967295) == 0) {
        if((f->stat_ok & 255 & 4294967295) == 0) {
            _v4540 = 134609310;
        } else {
            _v4584 =  &_v3778;
             *__esp = f->stat;
            _v4588 = 0;
            _v4540 = umaxtostr();
        }
        _v4576 = _v4540;
        _v4580 = nlink_width;
        _v4584 =  &_v84;
        sprintf(_v68, "%s %*s ");
        _v68 =  &(_v68[strlen(_v68)]);
        if((dired & 255 & 4294967295) != 0) {
            fwrite_unlocked("  ", 1, 2, __imp__stdout);
            dired_pos = dired_pos + 2;
        }
        if((print_scontext & 255 & 4294967295 &  | print_owner & 255 & 4294967295 &  | print_group & 255 & 4294967295 &  | print_author & 255 & 4294967295 & ) != 0) {
            fputs_unlocked( &_v3727, __imp__stdout);
            dired_pos = _v68 -  &_v3727 + dired_pos;
            if((print_owner & 255 & 4294967295) != 0) {
                format_user(f->stat, owner_width, f->stat_ok & 255 & 4294967295 & );
            }
            if((print_group & 255 & 4294967295) != 0) {
                format_group(f->stat, group_width, f->stat_ok & 255 & 4294967295 & );
            }
            if((print_author & 255 & 4294967295) != 0) {
                format_user(f->stat, author_width, f->stat_ok & 255 & 4294967295 & );
            }
            if((print_scontext & 255 & 4294967295) != 0) {
                format_user_or_group(f->scontext, 0, scontext_width);
            }
            _v68 =  &_v3727;
        }
        if(((f->stat_ok & 255 ^ 1) & 4294967295) != 0 || (f->stat & 61440) != 8192 && (f->stat & 61440) != 24576) {
            if((f->stat_ok & 255 & 4294967295) == 0) {
                _v4536 = 134609310;
            } else {
                _t529 = f;
                _t679 = _t529->stat.st_dev;
                 *__esp = _t529->stat.st_dev;
                _v4588 = _t679;
                _t531 = unsigned_file_size();
                _v4568 = file_output_block_size;
                _v4564 =  *134627796;
                _v4576 = 1;
                _v4572 = 0;
                _v4580 = human_output_opts;
                _v4584 =  &_v4493;
                 *__esp = _t531;
                _v4588 = _t679;
                _v4536 = human_readable();
            }
            _v64.st_uid = _v4536;
            _v64.st_gid = file_size_width - gnu_mbswidth(_v64.st_uid, 0);
            while(_v36 > 0) {
                 *_v68 = 32;
                _v68 =  &(_v68[1]);
                _v64.st_gid = _v64.st_gid - 1;
            }
        }
        _v64.st_nlink = -2 - major_device_number_width - minor_device_number_width + file_size_width;
        _t541 = f;
        _t542 = _t541->stat.st_dev;
         *__esp = _t542;
        _v4588 = _t541->stat.st_dev;
        gnu_dev_minor();
        _v4584 =  &_v3820;
         *__esp = _t542;
        _v4588 = 0;
        _t544 = umaxtostr();
        _t545 = f;
        _t546 = _t545->stat.st_dev;
         *__esp = _t546;
        _v4588 = _t545->stat.st_dev;
        gnu_dev_major();
        _v4584 =  &_v3799;
         *__esp = _t546;
        _v4588 = 0;
        _t548 = umaxtostr();
        _v4572 = _t544;
        _v4576 = minor_device_number_width;
        _v4580 = _t548;
        _v4584 = ( !(_v64.st_nlink >> 31) & _v64.st_nlink) + major_device_number_width;
        sprintf(_v68, "%*s, %*s ");
        _v68 =  &(_v68[file_size_width + 1]);
        _t446 =  &_v3736;
         *__esp = _t446;
        localtime();
        _v64.__pad1 = _t446;
        _v72 = 0;
         *_v68 = 1;
        if((f->stat_ok & 255 & 4294967295) != 0 && _v56 != 0) {
            if(current_time < _v64 || current_time == _v64 && current_time_ns < _v60) {
                get_current_time();
            }
            _v64.st_rdev = current_time - 15778476;
            if(_v32 > _v64 || _v64 >= current_time && (_v64 != current_time || _v60 > current_time_ns)) {
                _v4532 = 0;
            } else {
                _v4532 = 1;
            }
            _v25 = _v4532 & 255 & 4294967295;
            _v64.__pad2 = ( &long_time_format)[_v25 & 255];
            _v72 = nstrftime(_v68, 1001, _v64.__pad2, _v64.__pad1, 0, _v60);
        }
        if(_v72 != 0 || ( *_v68 & 255 & 4294967295) == 0) {
            _v68 =  &(_v68[_v72]);
             *_v68 = 32;
            _v68 =  &(_v68[1]);
             *_v68 = 0;
        } else {
            if((f->stat_ok & 255 & 4294967295) == 0) {
                _v4528 = 134609310;
            } else {
                _t510 = _v64;
                _v4584 =  &_v3841;
                 *__esp = _t510;
                _v4588 = _t510 >> 31;
                _v4528 = imaxtostr();
            }
            _t505 = long_time_expected_width();
            _v4580 = _v4528;
            _v4584 = _t505;
            sprintf(_v68, 134609316);
            _v68 =  &(_v68[strlen(_v68)]);
        }
        fputs_unlocked( &_v3727, __imp__stdout);
        dired_pos = _v68 -  &_v3727 + dired_pos;
        _v4524 = f->filetype;
        _v4520 = f->stat_ok & 255 & 4294967295 & ;
        _v4516 = f->linkok & 255 & 4294967295 & ;
        if((f->linkok & 255 & 4294967295 &  & color_symlink_as_referent & 255 & 4294967295 & ) == 0) {
            _v4512 = f->stat;
        } else {
            _v4512 =  *(f + 108);
        }
        print_name_with_quoting(f->name, _v4512, _v4516, _v4520, _v4524,  &dired_obstack);
        if(f->filetype != 6) {
            if(indicator_style != 0) {
                print_type_indicator(f->stat_ok & 255 & 4294967295 & , f->stat, f->filetype);
            }
        } else {
            if(f->linkname != 0) {
                fwrite_unlocked(" -> ", 1, 4, __imp__stdout);
                dired_pos = dired_pos + 4;
                print_name_with_quoting(f->linkname,  *(f + 108), (f->linkok & 255 & 4294967295 & ) - 1, f->stat_ok & 255 & 4294967295 & , f->filetype, 0);
                if(indicator_style != 0) {
                    print_type_indicator(1,  *(f + 108), 0);
                }
            }
        }
        __esp =  &_v16;
        return;
    } else {
        if((f->stat_ok & 255 & 4294967295) == 0) {
            _v4548 = 134609310;
        } else {
            _v4544 = human_output_opts;
            _t607 = f;
            _v4568 = output_block_size;
            _v4564 =  *134628524;
            _v4576 = 512;
            _v4572 = 0;
            _v4580 = _v4544;
            _v4584 =  &_v4493;
             *__esp = _t607->stat.st_dev;
            _v4588 = _t607->stat.st_dev;
            _v4548 = human_readable();
        }
        _v64.__st_ino = _v4548;
        _v64.st_mode = block_size_width - gnu_mbswidth(_v64.__st_ino, 0);
        while(_v48 > 0) {
             *_v68 = 32;
            _v68 =  &(_v68[1]);
            _v64.st_mode = _v64.st_mode - 1;
        }
    }
}

size_t quote_name(FILE* out, const char* name, const struct quoting_options* options, size_t* width)
{// addr = 0x0804FA54
    char[8191] smallbuf;
    size_t len;
    char* buf;
    size_t displayed_width;
    const char* p;
    const char* plimit;
    char* q;
    mbstate_t mbstate;
    wchar_t wc;
    size_t bytes;
    int w;
    char* p;
    const char* plimit;
    const char* p;
    const char* plimit;
    _unknown_ _v8;
    intOrPtr _v12;
    char* _v16;
    intOrPtr _v20;
    char* _v24;
    char* _v28;
    int _v32;
    char* _v36;
    const _None* _v40;
    char* _v44;
    int _v48;
    const _None* _v52;
    int _v56;
    char _v8248;
    int _v8252;
    int _v8256;
    char* _v8260;
    signed int _v8268;
    signed int _v8272;
    char _v8280;
    _unknown_ _v8284;
    char* _v8288;
    intOrPtr _v8292;
    const _None* _v8296;
    _unknown_ __ebp;
    _unknown_ _t185;
    signed int _t186;
    _unknown_ _t192;
    const _None* _t196;
    const _None* _t213;
    int _t240;
    char* _t241;
    char* _t244;
    _unknown_ _t259;

    _push(__ebx);
    __esp = __esp - 8292;
    _v56 = quotearg_buffer( &_v8248, 8192, name, -1, options);
    if(_v56 > 8191) {
        __esp = __esp - (_v56 + 1 + 15 + 15 >> 4 << 4);
        _v8272 =  &_v8280;
        _v8272 = _v8272 + 15 >> 4 << 4;
        _v52 = _v8272;
        quotearg_buffer(_v52, _v56 + 1, name, -1, options);
    } else {
        _v52 =  &_v8248;
    }
    _t186 = qmark_funny_chars & 255;
    if((_t186 & 4294967295) == 0) {
        if(width == 0) {
            goto L44;
        }
    } else {
        __ctype_get_mb_cur_max();
        if(_t186 <= 1) {
            _v24 = _v52;
            _v20 = _v52 + _v56;
            while(1) {
L34:
                _t213 = _v24;
                if(_t213 >= _v20) {
                    break;
                }
                goto L31;
            }
            _v48 = _v56;
L44:
            if(out != 0) {
                fwrite_unlocked(_v52, 1, _v56, out);
            }
            if(width == 0) {
                return _v56;
            }
             *width = _v48;
            return _v56;
        }
        _v44 = _v52;
        _v40 = _v52 + _v56;
        _v36 = _v52;
        _v48 = 0;
L28:
        while(_v44 < _v40) {
            _v8268 =  *_v44 & 255 & 4294967295;
            if(_v8268 > 95) {
                if(_v8268 - 97 > 29) {
                    goto L14;
                }
                goto L13;
            }
            if(_v8268 >= 65) {
                goto L13;
            }
            if(_v8268 < 32) {
                goto L14;
            }
            if(_v8268 <= 35) {
                goto L13;
            }
            if(_v8268 - 37 > 26) {
                goto L14;
            }
            goto L13;
            while(1) {
L15:
                _v8288 =  &_v8256;
                _v8292 = _v40 - _v44;
                _v8296 = _v44;
                _t240 =  &_v8260;
                 *__esp = _t240;
                mbrtowc();
                _v32 = _t240;
                if(_v32 == 255) {
                    break;
                }
                if(_v32 != 254) {
                    if(_v32 == 0) {
                        _v32 = 1;
                    }
                    _t241 = _v8260;
                     *__esp = _t241;
                    wcwidth();
                    _v28 = _t241;
                    if(_v28 >= 0) {
                        _v44 =  &(_v44[_v32]);
                         *_v36 = 63;
                        _v36 =  &(_v36[1]);
                        _v48 = _v48 + 1;
                    } else {
                        while(_v32 != 0) {
                             *_v36 =  *_v44 & 255 & 4294967295;
                            _v36 =  &(_v36[1]);
                            _v44 =  &(_v44[1]);
                            _v32 = _v32 - 1;
                        }
                    }
                    _t244 =  &_v8256;
                     *__esp = _t244;
                    mbsinit();
                    if(_t244 == 0) {
                        continue;
                    }
                    goto L28;
                }
                _v44 = _v40;
                 *_v36 = 63;
                _v36 =  &(_v36[1]);
                _v48 = _v48 + 1;
                goto L28;
            }
            _v44 =  &(_v44[1]);
             *_v36 = 63;
            _v36 =  &(_v36[1]);
            _v48 = _v48 + 1;
            continue;
L14:
            _v8256 = 0;
            _v8252 = 0;
            goto L15;
L13:
             *_v36 =  *_v44 & 255 & 4294967295;
            _v36 =  &(_v36[1]);
            _v44 =  &(_v44[1]);
            _v48 = _v48 + 1;
        }
L31:
        __ctype_b_loc();
        if(( *( *_t213 + (to_uchar( *_v24 & 255 & 4294967295) & 4294967295 & ) + (to_uchar( *_v24 & 255 & 4294967295) & 4294967295 & )) & 65535 & 4294967295 &  & 16384) == 0) {
             *_v24 = 63;
        }
        _v24 =  &(_v24[1]);
        goto L34;
    }
L37:
    __ctype_get_mb_cur_max();
    if(_t186 <= 1) {
        _v16 = _v52;
        _v12 = _v52 + _v56;
        _v48 = 0;
        while(1) {
L43:
            _t196 = _v16;
            if(_t196 >= _v12) {
                break;
            }
            goto L40;
        }
        goto L44;
    }
    _v48 = mbsnwidth(_v52, _v56, 0);
    goto L44;
L40:
    __ctype_b_loc();
    if(( *( *_t196 + (to_uchar( *_v16 & 255 & 4294967295) & 4294967295 & ) + (to_uchar( *_v16 & 255 & 4294967295) & 4294967295 & )) & 65535 & 4294967295 &  & 16384) != 0) {
        _v48 = _v48 + 1;
    }
    _v16 =  &(_v16[1]);
    goto L43;
}

unsigned char to_uchar(char ch)
{// addr = 0x0804FDEF
    signed char _v8;
    _unknown_ __ebp;

    _v8 = ch & 4294967295;
    return _v8 & 255;
}

print_name_with_quoting(const char* p, mode_t mode, int linkok, _Bool stat_ok, union filetype type, struct obstack* stack)
{// addr = 0x0804FE01
    struct obstack* __o;
    int __len;
    struct obstack* __o;
    int __len;
    int _v8;
    struct obstack* _v12;
    int _v16;
    struct obstack* _v20;
    signed char _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    int _v40;
    _unknown_ __ebp;
    _unknown_ _t82;
    _unknown_ _t96;

    _v24 = stat_ok & 4294967295;
    if((print_with_color & 255 & 4294967295) != 0) {
        print_color_indicator(p, mode, linkok, _v24 & 255, type);
    }
    if(stack != 0 && (dired & 255 & 4294967295) != 0) {
        _v20 = stack;
        _v16 = 4;
        if( &(_v20->next_free[_v16]) > _v20->chunk_limit) {
            _v40 = _v16;
             *__esp = _v20;
            _obstack_newchunk();
        }
        memcpy(_v20->next_free,  &dired_pos, _v16);
        _v20->next_free = _v20->next_free + _v16;
    }
    dired_pos = quote_name(__imp__stdout, p, filename_quoting_options, 0) + dired_pos;
    if(stack != 0 && (dired & 255 & 4294967295) != 0) {
        _v12 = stack;
        _v8 = 4;
        if( &(_v12->next_free[_v8]) > _v12->chunk_limit) {
            _v40 = _v8;
             *__esp = _v12;
            _obstack_newchunk();
        }
        memcpy(_v12->next_free,  &dired_pos, _v8);
        _v12->next_free = _v12->next_free + _v8;
    }
    if((print_with_color & 255 & 4294967295) == 0) {
        return ;
    }
    process_signals();
    prep_non_filename_text();
    return;
}

prep_non_filename_text()
{// addr = 0x0804FF72
    _unknown_ __ebp;

    if( *134627828 == 0) {
        put_indicator( &color_indicator);
        put_indicator(134627832);
        put_indicator(134627816);
        return;
    }
    put_indicator(134627824);
    return;
}

print_file_name_and_frills(const struct fileinfo* f)
{// addr = 0x0804FFB5
    char[651] buf;
    char _v668;
    unsigned int _v676;
    signed int _v680;
    _Bool _v684;
    union filetype _v688;
    int _v692;
    char* _v696;
    int _v700;
    char* _v704;
    int _v708;
    int _v712;
    char* _v716;
    intOrPtr _v720;
    long long unsigned int _v724;
    struct obstack* _v728;
    intOrPtr _v732;
    int _v736;
    char* _v740;
    int _v744;
    _unknown_ __ebp;
    _unknown_ _t118;
    const struct fileinfo* _t120;
    _unknown_ _t127;
    const struct fileinfo* _t128;
    _unknown_ _t133;

    if((print_inode & 255 & 4294967295) != 0) {
        _t128 = f;
        _v740 =  &_v668;
         *__esp = _t128->stat.st_dev;
        _v744 = _t128->stat.st_dev;
        _v716 = umaxtostr();
        if(format == 4) {
            _v712 = 0;
        } else {
            _v712 = inode_number_width;
        }
        _v740 = _v716;
        _v744 = _v712;
        printf(134609316);
    }
    if((print_block_size & 255 & 4294967295) != 0) {
        _v708 = human_output_opts;
        _t120 = f;
        _v724 = output_block_size;
        _v720 =  *134628524;
        _v732 = 512;
        _v728 = 0;
        _v736 = _v708;
        _v740 =  &_v668;
         *__esp = _t120->stat.st_dev;
        _v744 = _t120->stat.st_dev;
        _v704 = human_readable();
        if(format == 4) {
            _v700 = 0;
        } else {
            _v700 = block_size_width;
        }
        _v740 = _v704;
        _v744 = _v700;
        printf(134609316);
    }
    if((print_scontext & 255 & 4294967295) != 0) {
        _v696 = f->scontext;
        if(format == 4) {
            _v692 = 0;
        } else {
            _v692 = scontext_width;
        }
        _v740 = _v696;
        _v744 = _v692;
        printf(134609316);
    }
    _v688 = f->filetype;
    _v684 = f->stat_ok & 255 & 4294967295 & ;
    _v680 = f->linkok & 255 & 4294967295 & ;
    if((f->linkok & 255 & 4294967295 &  & color_symlink_as_referent & 255 & 4294967295 & ) == 0) {
        _v676 = f->stat;
    } else {
        _v676 =  *(f + 108);
    }
    print_name_with_quoting(f->name, _v676, _v680, _v684, _v688, 0);
    if(indicator_style == 0) {
        return ;
    }
    print_type_indicator(f->stat_ok & 255 & 4294967295 & , f->stat, f->filetype);
    return;
}

char get_type_indicator(_Bool stat_ok, mode_t mode, union filetype type)
{// addr = 0x08050215
    char c;
    signed char _v5;
    signed char _v24;
    char _v25;
    char _v26;
    char _v27;
    signed int _v32;
    signed int _v33;
    char _v34;
    _unknown_ __ebp;

    _v24 = stat_ok & 4294967295;
    if(_v24 == 0) {
        _v34 = type == 5;
    } else {
        _v34 = (mode & 61440) == 32768;
    }
    if(_v34 == 0) {
        if(_v24 == 0) {
            if(type == 3) {
L13:
                _v32 = 1;
L15:
                _v33 = _v32 & 255 & 4294967295;
                goto L16;
            }
        } else {
            _v33 = (mode & 61440) == 16384;
L16:
            if(_v33 != 0) {
                _v5 = 47;
                return _v5 & 255;
            }
            if(indicator_style != 1) {
                if(_v24 == 0) {
                    _v27 = type == 6;
                } else {
                    _v27 = (mode & 61440) == 40960;
                }
                if(_v27 == 0) {
                    if(_v24 == 0) {
                        _v26 = type == 1;
                    } else {
                        _v26 = (mode & 61440) == 4096;
                    }
                    if(_v26 == 0) {
                        if(_v24 == 0) {
                            _v25 = type == 7;
                        } else {
                            _v25 = (mode & 61440) == 49152;
                        }
                        if(_v25 == 0) {
                            _v5 = 0;
                            return _v5 & 255;
                        }
                        _v5 = 61;
                        return _v5 & 255;
                    }
                    _v5 = 124;
                    return _v5 & 255;
                }
                _v5 = 64;
                return _v5 & 255;
            }
            _v5 = 0;
            return _v5 & 255;
        }
L12:
        if(type != 9) {
            _v32 = 0;
            goto L15;
        }
        goto L13;
    }
    if(((_v24 & 255 ^ 1) & 4294967295) == 0 && indicator_style == 3) {
        if((mode & 73) != 0) {
            _v5 = 42;
            return _v5 & 255;
        }
    }
    _v5 = 0;
    return _v5 & 255;
}

print_type_indicator(_Bool stat_ok, mode_t mode, union filetype type)
{// addr = 0x08050368
    char c;
    signed int _v5;
    signed char _v24;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t18;

    _v24 = stat_ok & 4294967295;
    _v5 = get_type_indicator(_v24 & 255, mode, type) & 4294967295;
    if(_v5 == 0) {
        return ;
    }
    putchar_unlocked(_v5);
    dired_pos = dired_pos + 1;
    return;
}

print_color_indicator(const char* name, mode_t mode, int linkok, _Bool stat_ok, union filetype filetype)
{// addr = 0x080503B2
    int type;
    struct color_ext_type* ext;
    size_t len;
    int _v8;
    struct color_ext_type* _v12;
    signed int _v16;
    signed char _v24;
    struct bin_str* _v28;
    signed int _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v24 = stat_ok & 4294967295;
    if(linkok != 255) {
L3:
        if(((_v24 & 255 ^ 1) & 4294967295) == 0) {
            if((mode & 61440) != 32768) {
                if((mode & 61440) != 16384) {
                    if((mode & 61440) != 40960) {
                        if((mode & 61440) != 4096) {
                            if((mode & 61440) != 49152) {
                                if((mode & 61440) != 24576) {
                                    if((mode & 61440) != 8192) {
                                        _v16 = 12;
                                    } else {
                                        _v16 = 10;
                                    }
                                } else {
                                    _v16 = 9;
                                }
                            } else {
                                _v16 = 8;
                            }
                        } else {
                            _v16 = 7;
                        }
                    } else {
                        if(linkok != 0 ||  *134627908 == 0) {
                            _v32 = 6;
                        } else {
                            _v32 = 12;
                        }
                        _v16 = _v32;
                    }
                } else {
                    if((mode & 512) == 0 || (mode & 2) == 0) {
                        if((mode & 2) == 0) {
                            if((mode & 512) == 0) {
                                _v16 = 5;
                            } else {
                                _v16 = 17;
                            }
                        } else {
                            _v16 = 18;
                        }
                    } else {
                        _v16 = 19;
                    }
                }
            } else {
                _v16 = 4;
                if((mode & 2048) == 0) {
                    if((mode & 1024) == 0) {
                        if((mode & 73) != 0) {
                            _v16 = 13;
                        }
                    } else {
                        _v16 = 16;
                    }
                } else {
                    _v16 = 15;
                }
            }
        } else {
            _v16 =  *( &filetype_indicator + filetype * 4);
        }
        goto L36;
    }
    if( *134627900 == 0) {
        goto L3;
    } else {
        _v16 = 11;
    }
L36:
    _v12 = 0;
    if(_v16 != 4) {
L42:
        put_indicator( &color_indicator);
        if(_v12 == 0) {
            _v28 =  &color_indicator + (_v16 << 3);
        } else {
            _v28 =  &(_v12->seq);
        }
        put_indicator(_v28);
        put_indicator(134627816);
        return;
    } else {
        _v8 = strlen(name);
        name = name + _v8;
        _v12 = color_ext_list;
    }
    while(_v12 != 0) {
        if( *_v12 > _v8 || strncmp(name +  ~( *_v12), _v12->ext.string,  *_v12) != 0) {
            _v12 = _v12->next;
        } else {
            goto L42;
        }
    }
}

put_indicator(const struct bin_str* ind)
{// addr = 0x0805060F
    size_t i;
    const char* p;
    char* _v8;
    unsigned int _v12;
    _unknown_ __ebp;

    _v8 = ind->string;
    _t16 = ind->len;
    _v12 = ind->len;
    while(_v12 != 0) {
        _v8 =  &(_v8[1]);
        putchar_unlocked( *_v8 & 255 & 4294967295);
        _v12 = _v12 - 1;
    }
}

size_t length_of_file_name_and_frills(const struct fileinfo* f)
{// addr = 0x08050649
    size_t len;
    size_t name_width;
    char[651] buf;
    char c;
    signed int _v17;
    FILE* _v24;
    intOrPtr _v28;
    char _v680;
    intOrPtr _v692;
    int _v696;
    intOrPtr _v700;
    intOrPtr _v704;
    intOrPtr _v720;
    long long unsigned int _v724;
    FILE* _v728;
    intOrPtr _v732;
    int _v736;
    char* _v740;
    long long unsigned int _v744;
    _unknown_ __ebp;
    _unknown_ _t71;
    signed int _t80;
    const struct fileinfo* _t95;
    const struct fileinfo* _t106;

    _v24 = 0;
    if((print_inode & 255 & 4294967295) != 0) {
        if(format != 4) {
            _v704 = inode_number_width + 1;
        } else {
            _t106 = f;
            _v740 =  &_v680;
             *__esp = _t106->stat.st_dev;
            _v744 = _t106->stat.st_dev;
            _v704 = strlen(umaxtostr()) + 1;
        }
        _v24 = _v24 + _v704;
    }
    if((print_block_size & 255 & 4294967295) != 0) {
        if(format != 4) {
            _v700 = block_size_width + 1;
        } else {
            _v696 = human_output_opts;
            _t95 = f;
            _v724 = output_block_size;
            _v720 =  *134628524;
            _v732 = 512;
            _v728 = 0;
            _v736 = _v696;
            _v740 =  &_v680;
             *__esp = _t95->stat.st_dev;
            _v744 = _t95->stat.st_dev;
            _v700 = strlen(human_readable()) + 1;
        }
        _v24 = _v24 + _v700;
    }
    if((print_scontext & 255 & 4294967295) != 0) {
        if(format != 4) {
            _v692 = scontext_width + 1;
        } else {
            _v692 = strlen(f->scontext) + 1;
        }
        _v24 = _v24 + _v692;
    }
    quote_name(0, f->name, filename_quoting_options,  &_v28);
    _v24 = _v24 + _v28;
    if(indicator_style == 0) {
        return _v24;
    }
    _t80 = get_type_indicator(f->stat_ok & 255 & 4294967295 & , f->stat, f->filetype);
    _v17 = _t80 & 4294967295;
    _v24 = _v24 + (_t80 & 4294967295 & );
    return _v24;
}

print_many_per_line()
{// addr = 0x08050817
    size_t row;
    size_t cols;
    const struct column_info* line_fmt;
    size_t rows;
    size_t col;
    size_t filesno;
    size_t pos;
    const struct fileinfo* f;
    size_t name_length;
    size_t max_name_length;
    intOrPtr _v8;
    unsigned int _v12;
    const struct fileinfo* _v16;
    signed int _v20;
    signed int _v24;
    signed int _v28;
    intOrPtr _v32;
    intOrPtr _v36;
    signed int _v40;
    signed int _v44;
    unsigned int _v64;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t58;
    _unknown_ _t70;
    _unknown_ _t90;
    _unknown_ _t99;
    _unknown_ _t100;
    _unknown_ _t101;

    _v40 = calculate_columns(1);
    _v36 = column_info + (_v40 + _v40 + _t98 << 2) - 12;
    _v64 = cwd_n_used;
    _v32 = cwd_n_used / _v40 + (_v64 % _v40 & 4294967295 & );
    _v44 = 0;
    while(_v44 < _v32) {
        _v28 = 0;
        _v24 = _v44;
        _v20 = 0;
        while(1) {
            _v16 = sorted_file[_v24];
            _v12 = length_of_file_name_and_frills(_v16);
            _v8 =  *((intOrPtr*)( *((intOrPtr*)(_v36 + 8)) + (_v28 << 2)));
            _v28 = _v28 + 1;
            print_file_name_and_frills(_v16);
            _v24 = _v24 + _v32;
            if(_v24 >= cwd_n_used) {
                break;
            }
            indent(_v20 + _v12, _v20 + _v8);
            _v20 = _v20 + _v8;
        }
        putchar_unlocked(10);
        _v44 = _v44 + 1;
    }
}

print_horizontal()
{// addr = 0x08050931
    size_t filesno;
    size_t pos;
    size_t cols;
    const struct column_info* line_fmt;
    const struct fileinfo* f;
    size_t name_length;
    size_t max_name_length;
    size_t col;
    signed int _v8;
    intOrPtr _v12;
    unsigned int _v16;
    const struct fileinfo* _v20;
    intOrPtr _v24;
    unsigned int _v28;
    _Bool _v32;
    signed int _v36;
    signed int _v44;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t49;
    _unknown_ _t68;
    _unknown_ _t85;
    _unknown_ _t86;
    _unknown_ _t90;

    _v32 = 0;
    _v28 = calculate_columns(0);
    _v24 = column_info + (_v28 + _v28 + _t89 << 2) - 12;
    _v20 =  *sorted_file;
    _v16 = length_of_file_name_and_frills(_v20);
    _v12 =  *((intOrPtr*)( *((intOrPtr*)(_v24 + 8))));
    print_file_name_and_frills(_v20);
    _v36 = 1;
    while(_v36 < cwd_n_used) {
        _v44 = _v36;
        _v8 = _v44 % _v28;
        if(_v8 != 0) {
            indent(_v32 + _v16, _v32 + _v12);
            _v32 = _v32 + _v12;
        } else {
            putchar_unlocked(10);
            _v32 = 0;
        }
        _v20 = sorted_file[_v36];
        print_file_name_and_frills(_v20);
        _v16 = length_of_file_name_and_frills(_v20);
        _v12 =  *((intOrPtr*)( *((intOrPtr*)(_v24 + 8)) + (_v8 << 2)));
        _v36 = _v36 + 1;
    }
}

print_with_commas()
{// addr = 0x08050A55
    size_t filesno;
    size_t pos;
    const struct fileinfo* f;
    size_t len;
    char separator;
    int _v5;
    unsigned int _v12;
    const struct fileinfo* _v16;
    signed int _v20;
    signed int _v24;
    _unknown_ __ebp;
    _unknown_ _t37;
    _unknown_ _t39;
    _unknown_ _t40;

    _v20 = 0;
    _v24 = 0;
    while(_v24 < cwd_n_used) {
        _v16 = sorted_file[_v24];
        _v12 = length_of_file_name_and_frills(_v16);
        if(_v24 != 0) {
            if(_v20 + _v12 + 2 >= line_length) {
                _v20 = 0;
                _v5 = 10;
            } else {
                _v20 = _v20 + 2;
                _v5 = 32;
            }
            putchar_unlocked(44);
            putchar_unlocked(_v5);
        }
        print_file_name_and_frills(_v16);
        _v20 = _v20 + _v12;
        _v24 = _v24 + 1;
    }
}

indent(size_t from, size_t to)
{// addr = 0x08050B05
    unsigned int _v24;
    signed int _v28;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t36;
    _unknown_ _t45;
    _unknown_ _t47;
    _unknown_ _t55;
    _unknown_ _t56;
    _unknown_ _t57;
    _unknown_ _t58;
    _unknown_ _t60;

L5:
    while(from < to) {
        if(tabsize == 0) {
L4:
            putchar_unlocked(32);
            from = from + 1;
        } else {
            _v28 = tabsize;
            _v28 = from + 1;
            _v24 = tabsize;
            _v24 = _v28 / _v24;
            if(to / _v28 <= _v24) {
                goto L4;
            } else {
                putchar_unlocked(9);
                _v24 = from;
                from = from + tabsize - _v24 % tabsize;
            }
        }
    }
}

attach(char* dest, const char* dirname, const char* name)
{// addr = 0x08050BAF
    const char* dirnamep;
    const char* _v8;
    _unknown_ __ebp;

    _v8 = dirname;
    if(( *dirname & 255 & 4294967295) != 46 || (dirname[1] & 255 & 4294967295) != 0) {
        while(( *_v8 & 255 & 4294967295) != 0) {
        }
    }
    while(( *name & 255 & 4294967295) != 0) {
         *dest =  *name & 255 & 4294967295;
        dest =  &(dest[1]);
        name =  &(name[1]);
    }
}

init_column_info()
{// addr = 0x08050C37
    size_t i;
    size_t max_cols;
    size_t new_column_info_alloc;
    size_t* p;
    size_t column_info_growth;
    size_t s;
    size_t t;
    size_t j;
    signed int _v8;
    signed int _v12;
    signed int _v16;
    signed int _v20;
    _Unknown_base* _v24;
    unsigned int _v28;
    unsigned int _v32;
    unsigned int _v36;
    unsigned int _v40;
    unsigned int _v44;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t148;
    _unknown_ _t149;

    _v40 = max_idx;
    _v44 = cwd_n_used;
    if(_v44 > _v40) {
        _v44 = _v40;
    }
    _v32 = _v44;
    if(column_info_alloc >= _v32) {
        _v36 = 0;
        while(_v36 < _v32) {
            goto L14;
        }
    } else {
        if(max_idx >> 1 <= _v32) {
            column_info = xnrealloc(column_info, max_idx, 12);
            _v28 = max_idx;
        } else {
            column_info = xnrealloc(column_info, _v32, 24);
            _v28 = _v32 + _v32;
        }
        _v20 = _v28 - column_info_alloc;
        _v16 = column_info_alloc + _v28 + 1;
        _v12 = _v16 * _v20;
        if(_v16 < _v28 || _v12 / _v20 != _v16) {
            xalloc_die();
        }
        _v24 = xnmalloc(_v12 >> 1, 4);
        _v36 = column_info_alloc;
        while(_v36 < _v28) {
             *(column_info + (_v36 + _v36 + _t146 << 2) + 8) = _v24;
            _v24 = _v24 + (_v36 + 1 << 2);
            _v36 = _v36 + 1;
        }
    }
L14:
     *((char*)(column_info + (_v36 + _v36 + _t139 << 2))) = 1;
    _t140 = _v36;
     *((intOrPtr*)(column_info + (_v36 + _t140 + _t140 << 2) + 4)) = _v36 + 1 + _v36 + 1 + _t141;
    _v8 = 0;
    while(_v8 <= _v36) {
         *((intOrPtr*)( *((intOrPtr*)(column_info + (_v36 + _v36 + _t142 << 2) + 8)) + (_v8 << 2))) = 3;
        _v8 = _v8 + 1;
    }
}

size_t calculate_columns(_Bool by_columns)
{// addr = 0x08050E06
    size_t filesno;
    size_t cols;
    size_t max_cols;
    const struct fileinfo* f;
    size_t name_length;
    size_t i;
    size_t idx;
    size_t real_length;
    intOrPtr _v16;
    signed int _v20;
    signed int _v24;
    unsigned int _v28;
    _Unknown_base* _v32;
    unsigned int _v36;
    _unknown_ _v40;
    signed int _v44;
    signed int _v48;
    signed int _v52;
    signed int _v56;
    unsigned int _v60;
    unsigned int _v64;
    signed int _v80;
    signed int _v84;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t129;
    _unknown_ _t178;
    _unknown_ _t179;
    _unknown_ _t211;
    _unknown_ _t221;
    _unknown_ _t234;
    _unknown_ _t236;
    _unknown_ _t237;
    _unknown_ _t238;
    _unknown_ _t239;

    _v48 = by_columns & 4294967295;
    _v60 = max_idx;
    _v64 = cwd_n_used;
    if(_v64 > _v60) {
        _v64 = _v60;
    }
    _v36 = _v64;
    init_column_info();
    _v44 = 0;
    while(_v44 < cwd_n_used) {
        _v32 = sorted_file[_v44];
        _v28 = length_of_file_name_and_frills(_v32);
        _v24 = 0;
        while(_v24 < _v36) {
            if(( *(column_info + (_v24 + _v24 + _t218 << 2)) & 255 & 4294967295) != 0) {
                if(_v48 == 0) {
                    _v84 = _v44;
                    _v56 = _v84 % (_v24 + 1);
                } else {
                    _v80 = _v24 + cwd_n_used;
                    _v84 = _v24 + 1;
                    _v84 = _v80 / _v84;
                    _v80 = _v84;
                    _v56 = _v44 / _v80;
                }
                _v20 = _v56;
                if(_v20 != _v24) {
                    _v52 = 2;
                } else {
                    _v52 = 0;
                }
                _v16 = _v52 + _v28;
                if( *((intOrPtr*)( *((intOrPtr*)(column_info + (_v24 + _v24 + _t223 << 2) + 8)) + (_v20 << 2))) < _v16) {
                    _t225 = _v24;
                    _t226 = _v24;
                     *((intOrPtr*)(column_info + (_v24 + _t225 + _t225 << 2) + 4)) =  *((intOrPtr*)(column_info + (_v24 + _t226 + _t226 << 2) + 4)) + _v16 -  *((intOrPtr*)( *((intOrPtr*)(column_info + (_v24 + _v24 + _t227 << 2) + 8)) + (_v20 << 2)));
                     *((intOrPtr*)( *((intOrPtr*)(column_info + (_v24 + _v24 + _t230 << 2) + 8)) + (_v20 << 2))) = _v16;
                     *(column_info + (_v24 + _v24 + _t233 << 2)) = line_length & 4294967295;
                }
            }
            _v24 = _v24 + 1;
        }
    }
}

usage(int status)
{// addr = 0x0805105C
    char* _v20;
    char* _v24;
    char* _v36;
    _unknown_ __ebp;
    _unknown_ _t32;
    char* _t33;
    _unknown_ _t34;
    _unknown_ _t36;
    _unknown_ _t38;
    _unknown_ _t40;
    _unknown_ _t42;
    _unknown_ _t44;
    _unknown_ _t46;
    _unknown_ _t48;
    _unknown_ _t50;
    _unknown_ _t52;
    _unknown_ _t54;
    _unknown_ _t56;
    _unknown_ _t58;
    _unknown_ _t60;
    _unknown_ _t62;
    _unknown_ _t64;
    _unknown_ _t66;
    _unknown_ _t68;
    _unknown_ _t70;
    _unknown_ _t72;
    _unknown_ _t74;
    _unknown_ _t76;
    _unknown_ _t78;
    _unknown_ _t80;
    _unknown_ _t82;
    _unknown_ _t84;
    _unknown_ _t86;
    char* _t87;
    _unknown_ _t88;
    char* _t89;
    _unknown_ _t90;
    _unknown_ _t119;
    _unknown_ _t120;

    _push(__ebx);
    __esp = __esp - 20;
    if(status == 0) {
        _t33 = gettext("Usage: %s [OPTION]... [FILE]...\n");
        _v24 = program_name;
        printf(_t33);
        fputs_unlocked(gettext("List information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort.\n\n"), __imp__stdout);
        fputs_unlocked(gettext("Mandatory arguments to long options are mandatory for short options too.\n"), __imp__stdout);
        fputs_unlocked(gettext("  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print octal escapes for nongraphic characters\n"), __imp__stdout);
        fputs_unlocked(gettext("      --block-size=SIZE      use SIZE-byte blocks\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information)\n                               with -l: show ctime and sort by name\n                               otherwise: sort by ctime\n"), __imp__stdout);
        fputs_unlocked(gettext("  -C                         list entries by columns\n      --color[=WHEN]         control whether color is used to distinguish file\n                               types.  WHEN may be `never', `always', or `auto'\n  -d, --directory            list directory entries instead of contents,\n                               and do not dereference symbolic links\n  -D, --dired                generate output designed for Emacs' dired mode\n"), __imp__stdout);
        fputs_unlocked(gettext("  -f                         do not sort, enable -aU, disable -ls --color\n  -F, --classify             append indicator (one of */=>|) to entries\n      --file-type            likewise, except do not append `*'\n      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n                               single-column -1, verbose -l, vertical -C\n      --full-time            like -l --time-style=full-iso\n"), __imp__stdout);
        fputs_unlocked(gettext("  -g                         like -l, but do not list owner\n"), __imp__stdout);
        fputs_unlocked(gettext("      --group-directories-first\n                             group directories before files\n"), __imp__stdout);
        fputs_unlocked(gettext("  -G, --no-group             in a long listing, don't print group names\n  -h, --human-readable       with -l, print sizes in human readable format\n                               (e.g., 1K 234M 2G)\n      --si                   likewise, but use powers of 1000 not 1024\n"), __imp__stdout);
        fputs_unlocked(gettext("  -H, --dereference-command-line\n                             follow symbolic links listed on the command line\n      --dereference-command-line-symlink-to-dir\n                             follow each command line symbolic link\n                             that points to a directory\n      --hide=PATTERN         do not list implied entries matching shell PATTERN\n                               (overridden by -a or -A)\n"), __imp__stdout);
        fputs_unlocked(gettext("      --indicator-style=WORD  append indicator with style WORD to entry names:\n                               none (default), slash (-p),\n                               file-type (--file-type), classify (-F)\n  -i, --inode                print the index number of each file\n  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n  -k                         like --block-size=1K\n"), __imp__stdout);
        fputs_unlocked(gettext("  -l                         use a long listing format\n  -L, --dereference          when showing file information for a symbolic\n                               link, show information for the file the link\n                               references rather than for the link itself\n  -m                         fill width with a comma separated list of entries\n"), __imp__stdout);
        fputs_unlocked(gettext("  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n  -N, --literal              print raw entry names (don't treat e.g. control\n                               characters specially)\n  -o                         like -l, but do not list group information\n  -p, --indicator-style=slash\n                             append / indicator to directories\n"), __imp__stdout);
        fputs_unlocked(gettext("  -q, --hide-control-chars   print ? instead of non graphic characters\n      --show-control-chars   show non graphic characters as-is (default\n                             unless program is `ls' and output is a terminal)\n  -Q, --quote-name           enclose entry names in double quotes\n      --quoting-style=WORD   use quoting style WORD for entry names:\n                               literal, locale, shell, shell-always, c, escape\n"), __imp__stdout);
        fputs_unlocked(gettext("  -r, --reverse              reverse order while sorting\n  -R, --recursive            list subdirectories recursively\n  -s, --size                 print the size of each file, in blocks\n"), __imp__stdout);
        fputs_unlocked(gettext("  -S                         sort by file size\n      --sort=WORD            sort by WORD instead of name: none -U,\n                             extension -X, size -S, time -t, version -v\n      --time=WORD            with -l, show time as WORD instead of modification\n                             time: atime -u, access -u, use -u, ctime -c,\n                             or status -c; use specified time as sort key\n                             if --sort=time\n"), __imp__stdout);
        fputs_unlocked(gettext("      --time-style=STYLE     with -l, show times using style STYLE:\n                             full-iso, long-iso, iso, locale, +FORMAT.\n                             FORMAT is interpreted like `date'; if FORMAT is\n                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n                             non-recent files and FORMAT2 to recent files;\n                             if STYLE is prefixed with `posix-', STYLE\n                             takes effect only outside the POSIX locale\n"), __imp__stdout);
        fputs_unlocked(gettext("  -t                         sort by modification time\n  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"), __imp__stdout);
        fputs_unlocked(gettext("  -u                         with -lt: sort by, and show, access time\n                               with -l: show access time and sort by name\n                               otherwise: sort by access time\n  -U                         do not sort; list entries in directory order\n  -v                         sort by version\n"), __imp__stdout);
        fputs_unlocked(gettext("  -w, --width=COLS           assume screen width instead of current value\n  -x                         list entries by lines instead of by columns\n  -X                         sort alphabetically by entry extension\n  -Z, --context              print any SELinux security context of each file\n  -1                         list one file per line\n"), __imp__stdout);
        fputs_unlocked(gettext("      --help     display this help and exit\n"), __imp__stdout);
        fputs_unlocked(gettext("      --version  output version information and exit\n"), __imp__stdout);
        fputs_unlocked(gettext("\nSIZE may be (or may be an integer optionally followed by) one of following:\nkB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"), __imp__stdout);
        fputs_unlocked(gettext("\nBy default, color is not used to distinguish types of files.  That is\nequivalent to using --color=none.  Using the --color option without the\noptional WHEN argument is equivalent to using --color=always.  With\n--color=auto, color codes are output only if standard output is connected\nto a terminal (tty).  The environment variable LS_COLORS can influence the\ncolors, and can be set easily by the dircolors command.\n"), __imp__stdout);
        fputs_unlocked(gettext("\nExit status is 0 if OK, 1 if minor problems, 2 if serious trouble.\n"), __imp__stdout);
        L4();
    } else {
        _t89 = gettext("Try `%s --help' for more information.\n");
        _v20 = program_name;
        fprintf(__imp__stderr, _t89);
    }
    exit(status);
    _push(_t119);
    __esp = __esp - 8;
    _t87 = gettext("\nReport bugs to <%s>.\n");
    _v36 = "bug-coreutilsgnu.org";
    printf(_t87);
    return;
}

emit_bug_reporting_address()
{// addr = 0x080513B2
    char* _v8;
    _unknown_ __ebp;
    _unknown_ _t2;
    char* _t3;
    _unknown_ _t4;

    _t3 = gettext("\nReport bugs to <%s>.\n");
    _v8 = "bug-coreutilsgnu.org";
    printf(_t3);
    return;
}

char* areadlink_with_size(const char* file, size_t size)
{// addr = 0x080513D8
    size_t symlink_max;
    size_t INITIAL_LIMIT_BOUND;
    size_t initial_limit;
    size_t buf_size;
    ssize_t r;
    size_t link_length;
    char* buffer;
    int saved_errno;
    intOrPtr _v8;
    signed int _v12;
    signed int _v16;
    signed int _v20;
    int _v24;
    int _v28;
    void* _v32;
    int _v36;
    char* _v40;
    signed int _v44;
    signed int _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t66;
    _unknown_ _t77;

    _v8 = 1024;
    _v12 = 8192;
    if(_v8 >= _v12) {
        _v48 = _v12;
    } else {
        _v48 = _v8 + 1;
    }
    _v16 = _v48;
    if(size >= _v16) {
        _v44 = _v16;
    } else {
        _v44 = size + 1;
    }
    _v20 = _v44;
    while(1) {
        _v32 = malloc(_v20);
        if(_v32 == 0) {
            break;
        }
        _v24 = readlink(file, _v32, _v20);
        _v28 = _v24;
        if(_v24 >= 0 ||  *(__errno_location()) == 34) {
            if(_v28 >= _v20) {
                free(_v32);
                if(_v20 > 1073741823) {
                    if(_v20 > 2147483646) {
                         *(__errno_location()) = 12;
                        _v40 = 0;
                        return _v40;
                    }
                    goto L17;
                }
                goto L15;
L17:
                _v20 = 2147483647;
                continue;
            }
            goto L13;
L15:
            _v20 = _v20 << 1;
            continue;
        } else {
            _v36 =  *(__errno_location());
            free(_v32);
             *(__errno_location()) = _v36;
            _v40 = 0;
            return _v40;
        }
L13:
         *(_v32 + _v28) = 0;
        _v40 = _v32;
        return _v40;
    }
    _v40 = 0;
    return _v40;
}

int gnu_mbswidth(const _None* string, int flags)
{// addr = 0x0805150C
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return mbsnwidth(string, strlen(string), flags);
}

int mbsnwidth(const _None* string, size_t nbytes, int flags)
{// addr = 0x08051537
    const _None* p;
    const _None* plimit;
    int width;
    mbstate_t mbstate;
    wchar_t wc;
    size_t bytes;
    int w;
    unsigned char c;
    signed int _v5;
    char* _v12;
    char* _v16;
    int _v20;
    char _v24;
    intOrPtr _v28;
    _unknown_ _v32;
    char _v40;
    int _v56;
    signed int _v60;
    char* _v64;
    intOrPtr _v68;
    const _None* _v72;
    _unknown_ __ebp;
    char* _t95;
    signed int _t98;
    signed int _t106;
    _unknown_ _t122;
    char* _t127;
    _unknown_ _t128;
    _unknown_ _t131;
    _unknown_ _t134;

    _v12 = string;
    _t95 =  &(_v12[nbytes]);
    _v16 = _t95;
    _v20 = 0;
    __ctype_get_mb_cur_max();
    if(_t95 <= 1) {
        while(_v12 < _v16) {
            _t98 =  *_v12 & 255;
            _v5 = _t98 & 4294967295;
            _v12 =  &(_v12[1]);
            __ctype_b_loc();
            if(( *( *_t98 + (_v5 & 255) + (_v5 & 255)) & 65535 & 4294967295 &  & 16384) == 0) {
                _t106 = flags & 2;
                if(_t106 != 0) {
                    _v56 = -1;
                    return _v56;
                }
                goto L32;
            }
            _v20 = _v20 + 1;
            continue;
L32:
            __ctype_b_loc();
            _v20 = _v20 + ( *( *_t106 + (_v5 & 255) + (_v5 & 255)) & 65535 & 4294967295 &  & 2 & 4294967295 & );
        }
    } else {
L27:
        while(_v12 < _v16) {
            _v60 =  *_v12 & 255 & 4294967295;
            if(_v60 > 95) {
                if(_v60 - 97 > 29) {
                    goto L10;
                }
                goto L9;
            }
            if(_v60 >= 65 || _v60 >= 32 && (_v60 <= 35 || _v60 - 37 <= 26)) {
                goto L9;
            }
L10:
            memset( &_v40, 0, 8);
            while(1) {
                _v64 =  &_v40;
                _v68 = _v16 - _v12;
                _v72 = _v12;
                _t127 =  &_v24;
                 *__esp = _t127;
                mbrtowc();
                _v28 = _t127;
                if(_v28 != 255) {
                    goto L15;
                } else {
                    if((flags & 1) != 0) {
                        _v56 = -1;
                        return _v56;
                    } else {
                        _v12 =  &(_v12[1]);
                        _v20 = _v20 + 1;
                        goto L27;
                    }
                }
            }
L9:
            _v12 =  &(_v12[1]);
            _v20 = _v20 + 1;
        }
    }
    _v56 = _v20;
    return _v56;
}

version_etc_va(FILE* stream, const char* command_name, const char* package, const char* version, va_list authors)
{// addr = 0x08051750
    size_t n_authors;
    va_list tmp_authors;
    intOrPtr _v12;
    char* _v16;
    const char* _v28;
    const char* _v32;
    const char* _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t44;
    char* _t45;
    _unknown_ _t47;
    _unknown_ _t50;
    _unknown_ _t53;
    _unknown_ _t55;
    _unknown_ _t56;
    _unknown_ _t61;
    char* _t62;

    _v16 = authors;
    _v12 = 0;
    while(1) {
        _t62 = _v16;
        _v16 =  &(_t62[4]);
        if( *_t62 == 0) {
            break;
        }
        _v12 = _v12 + 1;
    }
    if(command_name == 0) {
        _v32 = version;
        _v36 = package;
        fprintf(stream, "%s %s\n");
    } else {
        _v28 = version;
        _v32 = package;
        _v36 = command_name;
        fprintf(stream, "%s (%s) %s\n");
    }
    _t45 = gettext("(C)");
    _v32 = 2008;
    _v36 = _t45;
    fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.");
    fputs_unlocked(gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n"), stream);
    if(_v12 <= 9) {
        goto __eax;
    }
    rpl_vfprintf(stream, gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"), authors);
    return;
}

version_etc(FILE* stream, const char* command_name, const char* package, const char* version)
{// addr = 0x080519AF
    va_list authors;
    char* _v8;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v8 =  &_a20;
    version_etc_va(stream, command_name, package, version, _v8);
    return;
}

xalloc_die()
{// addr = 0x080519E4
    char* _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t4;
    _unknown_ _t6;
    _unknown_ _t7;
    _unknown_ _t8;

    _v16 = gettext("memory exhausted");
    error(exit_failure, 0, "%s");
    abort();
    _push(_t7);
    __esp = __esp - 8;
    usage(1);
    return;
}

__argmatch_die()
{// addr = 0x08051A20
    _unknown_ __ebp;

    usage(1);
    return;
}

ptrdiff_t argmatch(const char* arg, const const char** arglist, const char* vallist, size_t valsize)
{// addr = 0x08051A34
    size_t i;
    size_t arglen;
    ptrdiff_t matchind;
    _Bool ambiguous;
    signed int _v5;
    signed int _v12;
    int _v16;
    signed int _v20;
    int _v24;
    unsigned int _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    unsigned int _t61;

    _v20 = -1;
    _v5 = 0;
    _v16 = strlen(arg);
    _v12 = 0;
    while( *(arglist + (_v12 << 2)) != 0) {
        if(strncmp( *(arglist + (_v12 << 2)), arg, _v16) != 0) {
L9:
            _v12 = _v12 + 1;
            continue;
        }
        if(strlen( *(arglist + (_v12 << 2))) != _v16) {
            if(_v20 != 255) {
                if(vallist == 0) {
L8:
                    _v5 = 1;
                    goto L9;
                }
                goto L7;
            }
            goto L5;
L7:
            _t61 = valsize;
            _v36 = _t61;
            _v40 = vallist + valsize * _v12;
             *__esp = vallist + _v20 * valsize;
            memcmp();
            if(_t61 == 0) {
                goto L9;
            }
            goto L8;
        }
        _v24 = _v12;
        return _v24;
L5:
        _v20 = _v12;
        goto L9;
    }
}

argmatch_invalid(const char* context, const char* value, ptrdiff_t problem)
{// addr = 0x08051B1C
    const char* format;
    char* _v12;
    char* _v28;
    const _None* _v44;
    char* _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    _unknown_ _t16;
    const _None* _t20;
    char* _t22;

    if(problem != 255) {
        _v28 = gettext("ambiguous argument %s for %s");
    } else {
        _v28 = gettext("invalid argument %s for %s");
    }
    _v12 = _v28;
    _t20 = quote_n(1, context);
    _t22 = quotearg_n_style(0, 5, value);
    _v44 = _t20;
    _v48 = _t22;
    error(0, 0, _v12);
    return;
}

argmatch_valid(const const char** arglist, const char* vallist, size_t valsize)
{// addr = 0x08051BA8
    size_t i;
    const char* last_val;
    signed int _v8;
    signed int _v12;
    unsigned int _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    _unknown_ _t29;
    _unknown_ _t31;
    _unknown_ _t40;
    signed int _t47;
    _unknown_ _t52;
    _unknown_ _t54;

    _v12 = 0;
    fprintf(__imp__stderr, gettext("Valid arguments are:"));
    _v8 = 0;
    while( *(arglist + (_v8 << 2)) != 0) {
        if(_v8 == 0) {
L3:
            _v36 =  *(arglist + (_v8 << 2));
            fprintf(__imp__stderr, "\n  - `%s'");
            _v12 = vallist + valsize * _v8;
        } else {
            _v36 = valsize;
            _v40 = vallist + valsize * _v8;
            _t47 = _v12;
             *__esp = _t47;
            memcmp();
            if(_t47 == 0) {
                _v36 =  *(arglist + (_v8 << 2));
                fprintf(__imp__stderr, ", `%s'");
            } else {
                goto L3;
            }
        }
        _v8 = _v8 + 1;
    }
}

ptrdiff_t __xargmatch_internal(const char* context, const char* arg, const const char** arglist, const char* vallist, size_t valsize, argmatch_exit_fn exit_fn)
{// addr = 0x08051C92
    ptrdiff_t res;
    int _v8;
    int _v24;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t37;

    _v8 = argmatch(arg, arglist, vallist, valsize);
    if(_v8 >= 0) {
        argmatch_invalid(context, arg, _v8);
        argmatch_valid(arglist, vallist, valsize);
         *exit_fn();
        _v24 = -1;
        return ;
    }
    _v24 = _v8;
    return;
}

const char* argmatch_to_argument(const char* value, const const char** arglist, const char* vallist, size_t valsize)
{// addr = 0x08051D0C
    size_t i;
    signed int _v8;
    const char* _v24;
    unsigned int _v36;
    intOrPtr _v40;
    _unknown_ __ebp;
    const char* _t25;

    _v8 = 0;
    while( *((intOrPtr*)(arglist + (_v8 << 2))) != 0) {
        _v36 = valsize;
        _v40 = vallist + valsize * _v8;
        _t25 = value;
         *__esp = _t25;
        memcmp();
        if(_t25 != 0) {
            _v8 = _v8 + 1;
            continue;
        }
        _v24 =  *(arglist + (_v8 << 2));
        return _v24;
    }
}

char* last_component(const _None* name)
{// addr = 0x08051D70
    const _None* base;
    const _None* p;
    _Bool saw_slash;
    char _v5;
    char* _v12;
    _unknown_ _v16;
    _unknown_ __ebp;

    _v12 = name;
    _v5 = 0;
    while(( *_v12 & 255 & 4294967295) == 47) {
        _v12 =  &(_v12[1]);
    }
}

char* base_name(const _None* name)
{// addr = 0x08051DCB
    const _None* base;
    size_t length;
    const _None* _v8;
    unsigned int _v12;
    char* _v24;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v8 = last_component(name);
    if(( *_v8 & 255 & 4294967295) != 0) {
        _v12 = base_len(_v8);
        if(( *(_v8 + _v12) & 255 & 4294967295) == 47) {
            _v12 = _v12 + 1;
        }
        _v24 = xstrndup(_v8, _v12);
        return _v24;
    }
    _v24 = xstrndup(name, base_len(name));
    return _v24;
}

size_t base_len(const _None* name)
{// addr = 0x08051E43
    size_t len;
    size_t prefix_len;
    int _v8;
    intOrPtr _v12;
    _unknown_ __ebp;

    _v12 = 0;
    _v8 = strlen(name);
    while(_v8 > 1) {
        if(( *(name + _v8 - 1) & 255 & 4294967295) != 47) {
            return _v8;
        }
        _v8 = _v8 - 1;
    }
}

close_stdout_set_file_name(const char* file)
{// addr = 0x08051E80
    _unknown_ __ebp;

     *134629116 = file;
    return;
}

close_stdout()
{// addr = 0x08051E8D
    const char* write_error;
    char* _v12;
    char* _v28;
    char* _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    char* __ebx;
    _unknown_ __ebp;
    _unknown_ _t16;
    int* _t19;
    _unknown_ _t22;
    int* _t25;

    if(close_stream(__imp__stdout) != 0) {
        _v12 = gettext("write error");
        if( *134629116 == 0) {
            _t19 = __errno_location();
            _v32 = _v12;
            error(0,  *_t19, "%s");
        } else {
            __ebx = quotearg_colon( *134629116);
            _t25 = __errno_location();
            _v28 = _v12;
            _v32 = __ebx;
            error(0,  *_t25, "%s: %s");
        }
        _exit(exit_failure);
    }
    if(close_stream(__imp__stderr) == 0) {
        return ;
    }
    _exit(exit_failure);
    return;
}

int file_has_acl(const char* name, const struct stat* sb)
{// addr = 0x08051F54
    _unknown_ __ebp;

    return 0;
}

char ftypelet(mode_t bits)
{// addr = 0x08051F60
    signed char _v5;
    _unknown_ __ebp;

    if((bits & 61440) == 32768) {
        _v5 = 45;
        return _v5 & 255;
    }
    if((bits & 61440) == 16384) {
        _v5 = 100;
        return _v5 & 255;
    }
    if((bits & 61440) == 24576) {
        _v5 = 98;
        return _v5 & 255;
    }
    if((bits & 61440) == 8192) {
        _v5 = 99;
        return _v5 & 255;
    }
    if((bits & 61440) != 40960) {
        if((bits & 61440) != 4096) {
            if((bits & 61440) != 49152) {
                _v5 = 63;
                return _v5 & 255;
            }
            goto L13;
        }
        goto L11;
L13:
        _v5 = 115;
        return _v5 & 255;
    }
    _v5 = 108;
    return _v5 & 255;
L11:
    _v5 = 112;
    return _v5 & 255;
}

strmode(mode_t mode, char* str)
{// addr = 0x08052006
    signed char _v5;
    signed char _v6;
    signed char _v7;
    char* _v12;
    signed char _v13;
    char* _v20;
    signed char _v21;
    char* _v28;
    signed char _v29;
    signed char _v30;
    signed char _v31;
    char* _v36;
    signed char _v37;
    char* _v44;
    signed char _v45;
    char* _v52;
    signed char _v53;
    signed char _v54;
    signed char _v55;
    char* _v60;
    signed char _v61;
    char* _v68;
    signed char _v69;
    char* _v76;
    _unknown_ __ebp;

     *str = ftypelet(mode) & 4294967295;
    _v76 =  &(str[1]);
    if((mode & 256) == 0) {
        _v69 = 45;
    } else {
        _v69 = 114;
    }
     *_v76 = _v69 & 255 & 4294967295;
    _v68 =  &(str[2]);
    if((mode & 128) == 0) {
        _v61 = 45;
    } else {
        _v61 = 119;
    }
     *_v68 = _v61 & 255 & 4294967295;
    _v60 =  &(str[3]);
    if((mode & 2048) == 0) {
        if((mode & 64) == 0) {
            _v53 = 45;
        } else {
            _v53 = 120;
        }
        _v55 = _v53 & 255 & 4294967295;
    } else {
        if((mode & 64) == 0) {
            _v54 = 83;
        } else {
            _v54 = 115;
        }
        _v55 = _v54 & 255 & 4294967295;
    }
     *_v60 = _v55 & 255 & 4294967295;
    _v52 =  &(str[4]);
    if((mode & 32) == 0) {
        _v45 = 45;
    } else {
        _v45 = 114;
    }
     *_v52 = _v45 & 255 & 4294967295;
    _v44 =  &(str[5]);
    if((mode & 16) == 0) {
        _v37 = 45;
    } else {
        _v37 = 119;
    }
     *_v44 = _v37 & 255 & 4294967295;
    _v36 =  &(str[6]);
    if((mode & 1024) == 0) {
        if((mode & 8) == 0) {
            _v29 = 45;
        } else {
            _v29 = 120;
        }
        _v31 = _v29 & 255 & 4294967295;
    } else {
        if((mode & 8) == 0) {
            _v30 = 83;
        } else {
            _v30 = 115;
        }
        _v31 = _v30 & 255 & 4294967295;
    }
     *_v36 = _v31 & 255 & 4294967295;
    _v28 =  &(str[7]);
    if((mode & 4) == 0) {
        _v21 = 45;
    } else {
        _v21 = 114;
    }
     *_v28 = _v21 & 255 & 4294967295;
    _v20 =  &(str[8]);
    if((mode & 2) == 0) {
        _v13 = 45;
    } else {
        _v13 = 119;
    }
     *_v20 = _v13 & 255 & 4294967295;
    _v12 =  &(str[9]);
    if((mode & 512) == 0) {
        if((mode & 1 & 4294967295) == 0) {
            _v5 = 45;
        } else {
            _v5 = 120;
        }
        _v7 = _v5 & 255 & 4294967295;
    } else {
        if((mode & 1 & 4294967295) == 0) {
            _v6 = 84;
        } else {
            _v6 = 116;
        }
        _v7 = _v6 & 255 & 4294967295;
    }
     *_v12 = _v7 & 255 & 4294967295;
    str[0xa] = 32;
    str[0xb] = 0;
    return;
}

filemodestring(const struct stat* statp, char* str)
{// addr = 0x0805221C
    _unknown_ _v8;
    _unknown_ __ebp;

    strmode( *(statp + 16), str);
    return;
}

const _None* longest_relative_suffix(const _None* f)
{// addr = 0x0805223C
    _unknown_ __ebp;

    while(( *f & 255 & 4294967295) == 47) {
        f =  &(f[1]);
    }
}

char* mfile_name_concat(const _None* dir, const _None* abase, char** base_in_result)
{// addr = 0x08052254
    const _None* dirbase;
    size_t dirbaselen;
    size_t dirlen;
    size_t needs_separator;
    const _None* base;
    size_t baselen;
    char* p_concat;
    char* p;
    const _None* _v8;
    unsigned int _v12;
    int _v16;
    char* _v20;
    char* _v24;
    int _v28;
    void* _v32;
    void* _v36;
    char* _v40;
    char* _v44;
    int _v52;
    const _None* _v56;
    _unknown_ __ebp;
    void* _t73;
    void* _t78;

    _v8 = last_component(dir);
    _v12 = base_len(_v8);
    _v16 = _v8 - dir + _v12;
    if(_v12 == 0 || ( *(_v12 - 1 + _v8) & 255 & 4294967295) == 47) {
        _v44 = 0;
    } else {
        _v44 = 1;
    }
    _v20 = _v44;
    _v24 = longest_relative_suffix(abase);
    _v28 = strlen(_v24);
    _v32 = malloc( &(( &(( &(_v20[_v16]))[_v28]))[1]));
    if(_v32 != 0) {
        _v52 = _v16;
        _v56 = dir;
        _t73 = _v32;
         *__esp = _t73;
        mempcpy();
        _v36 = _t73;
         *_v36 = 47;
        _v36 = _v36 + _v20;
        if(base_in_result != 0) {
             *base_in_result = _v36 +  ~( *abase & 255 & 4294967295 & );
        }
        _v52 = _v28;
        _v56 = _v24;
        _t78 = _v36;
         *__esp = _t78;
        mempcpy();
        _v36 = _t78;
         *_v36 = 0;
        _v40 = _v32;
        return _v40;
    }
    _v40 = 0;
    return _v40;
}

char* file_name_concat(const _None* dir, const _None* abase, char** base_in_result)
{// addr = 0x0805236D
    char* p;
    char* _v8;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    _v8 = mfile_name_concat(dir, abase, base_in_result);
    if(_v8 != 0) {
        return _v8;
    }
    xalloc_die();
    return _v8;
}

_Bool hard_locale(int category)
{// addr = 0x080523A0
    _Bool hard;
    const char* p;
    char* _v5;
    char* _v12;
    _unknown_ _v24;
    _unknown_ __ebp;

    _v5 = 1;
    _v12 = setlocale(category, 0);
    if(_v12 == 0) {
        return _v5 & 255;
    }
    if(strcmp(_v12, "C") != 0) {
        if(strcmp(_v12, "POSIX") != 0) {
            return _v5 & 255;
        }
    }
    _v5 = 0;
    return _v5 & 255;
}

size_t hash_get_n_buckets(const Hash_table* table)
{// addr = 0x08052400
    _unknown_ __ebp;

    return  *(table + 8);
}

size_t hash_get_n_buckets_used(const Hash_table* table)
{// addr = 0x0805240B
    _unknown_ __ebp;

    return  *(table + 12);
}

size_t hash_get_n_entries(const Hash_table* table)
{// addr = 0x08052416
    _unknown_ __ebp;

    return  *(table + 16);
}

size_t hash_get_max_bucket_length(const Hash_table* table)
{// addr = 0x08052421
    const struct hash_entry* bucket;
    size_t max_bucket_length;
    const struct hash_entry* cursor;
    size_t bucket_length;
    struct hash_entry* _v8;
    intOrPtr _v12;
    struct hash_entry* _v16;
    intOrPtr _v20;
    _unknown_ __ebp;

    _v12 = 0;
    _v8 = table->bucket;
    while(table->bucket_limit > _v8) {
        if( *_v8 == 0) {
L7:
            _v8 = _v8 + 8;
            continue;
        }
        _v16 = _v8;
        _v20 = 1;
        while(1) {
            _v16 = _v16->next;
            if(_v16 == 0) {
                break;
            }
            _v20 = _v20 + 1;
        }
        if(_v20 > _v12) {
            _v12 = _v20;
        }
        goto L7;
    }
}

_Bool hash_table_ok(const Hash_table* table)
{// addr = 0x08052485
    const struct hash_entry* bucket;
    size_t n_buckets_used;
    size_t n_entries;
    const struct hash_entry* cursor;
    struct hash_entry* _v8;
    intOrPtr _v12;
    intOrPtr _v16;
    struct hash_entry* _v20;
    _unknown_ _v21;
    _unknown_ __ebp;

    _v12 = 0;
    _v16 = 0;
    _v8 = table->bucket;
    while(table->bucket_limit > _v8) {
        if( *_v8 == 0) {
L5:
            _v8 = _v8 + 8;
            continue;
        }
        _v20 = _v8;
        _v12 = _v12 + 1;
        _v16 = _v16 + 1;
        while(1) {
            _v20 = _v20->next;
            if(_v20 == 0) {
                break;
            }
            _v16 = _v16 + 1;
        }
        goto L5;
    }
}

hash_print_statistics(const Hash_table* table, FILE* stream)
{// addr = 0x08052504
    size_t n_entries;
    size_t n_buckets;
    size_t n_buckets_used;
    size_t max_bucket_length;
    unsigned int _v8;
    unsigned int _v12;
    unsigned int _v16;
    unsigned int _v20;
    unsigned int _v36;
    _unknown_ _v40;
    unsigned int _v44;
    _unknown_ __ebp;
    _unknown_ _t39;
    _unknown_ _t42;
    _unknown_ _t47;
    _unknown_ _t50;
    _unknown_ _t51;
    _unknown_ _t52;

    _v8 = hash_get_n_entries(table);
    _v12 = hash_get_n_buckets(table);
    _v16 = hash_get_n_buckets_used(table);
    _v20 = hash_get_max_bucket_length(table);
    _v36 = _v8;
    fprintf(stream, "# entries:         %lu\n");
    _v36 = _v12;
    fprintf(stream, "# buckets:         %lu\n");
    _push(0);
    _push(_v16);
    asm("fild qword [esp]");
    __esp =  &_v44;
    asm("fld qword [0x80618e0]");
    asm("fmulp st1, st0");
    _push(0);
    _push(_v12);
    asm("fild qword [esp]");
    __esp =  &((char*)( &_v44)[2]);
    asm("fdivp st1, st0");
    asm("fstp qword [esp+0xc]");
    _v44 = _v16;
    (__esp)[1] = "# buckets used:    %lu (%.2f%%)\n";
     *__esp = stream;
    fprintf();
    _v44 = _v20;
    (__esp)[1] = "max bucket length: %lu\n";
     *__esp = stream;
    fprintf();
    return;
}

_Unknown_base* hash_lookup(const Hash_table* table, * entry)
{// addr = 0x080525DC
    const struct hash_entry* bucket;
    const struct hash_entry* cursor;
    intOrPtr* _v12;
    intOrPtr* _v16;
    intOrPtr _v28;
    intOrPtr _v40;
    _unknown_ __ebp;
    signed int _t35;
    signed int _t46;
    _unknown_ _t49;

    _v40 =  *((intOrPtr*)(table + 8));
    _t35 = entry;
     *__esp = _t35;
     *((intOrPtr*)( *((intOrPtr*)(table + 24))))();
    _v12 = table->bucket + (_t35 << 3);
    if(table->bucket_limit <= _v12) {
        abort();
    }
    if( *_v12 != 0) {
        _v16 = _v12;
L8:
        while(_v16 != 0) {
            goto L5;
        }
    } else {
        _v28 = 0;
        return;
    }
L5:
    _v40 =  *_v16;
    _t46 = entry;
     *__esp = _t46;
     *((intOrPtr*)( *((intOrPtr*)(table + 28))))();
    if((_t46 & 4294967295) == 0) {
        _v16 =  *((intOrPtr*)(_v16 + 4));
        goto L8;
    }
    _v28 =  *_v16;
    return ;
}

_Unknown_base* hash_get_first(const Hash_table* table)
{// addr = 0x08052677
    const struct hash_entry* bucket;
    struct hash_entry* _v8;
    _Unknown_base* _v24;
    _unknown_ __ebp;
    _unknown_ _t26;

    if( *((intOrPtr*)(table + 16)) != 0) {
        _v8 = table->bucket;
L3:
        while(1) {
        }
    }
    _v24 = 0;
    return _v24;
    goto L3;
}

_Unknown_base* hash_get_next(const Hash_table* table, * entry)
{// addr = 0x080526C6
    const struct hash_entry* bucket;
    const struct hash_entry* cursor;
    intOrPtr* _v12;
    intOrPtr* _v16;
    intOrPtr _v28;
    intOrPtr _v40;
    _unknown_ __ebp;
    signed int _t40;
    _unknown_ _t56;

    _v40 =  *((intOrPtr*)(table + 8));
    _t40 = entry;
     *__esp = _t40;
     *((intOrPtr*)( *((intOrPtr*)(table + 24))))();
    _v12 = table->bucket + (_t40 << 3);
    if(table->bucket_limit <= _v12) {
        abort();
    }
    _v16 = _v12;
    while(_v16 != 0) {
        if( *_v16 != entry ||  *((intOrPtr*)(_v16 + 4)) == 0) {
            _v16 =  *((intOrPtr*)(_v16 + 4));
            continue;
        }
        _v28 =  *((intOrPtr*)( *((intOrPtr*)(_v16 + 4))));
        return;
    }
}

size_t hash_get_entries(const Hash_table* table, _Unknown_base** buffer, size_t buffer_size)
{// addr = 0x0805276F
    size_t counter;
    const struct hash_entry* bucket;
    const struct hash_entry* cursor;
    signed int _v8;
    struct hash_entry* _v12;
    struct hash_entry* _v16;
    signed int _v24;
    _unknown_ __ebp;

    _v8 = 0;
    _v12 = table->bucket;
    while(table->bucket_limit > _v12) {
        if( *_v12 == 0) {
            _v12 = _v12 + 8;
            continue;
        }
        _v16 = _v12;
        while(_v16 != 0) {
            if(_v8 < buffer_size) {
                buffer[_v8] =  *_v16;
                _v8 = _v8 + 1;
                _v16 = _v16->next;
                continue;
            }
            _v24 = _v8;
            return _v24;
        }
    }
}

size_t hash_do_for_each(const Hash_table* table, Hash_processor processor, _Unknown_base* processor_data)
{// addr = 0x080527E6
    size_t counter;
    const struct hash_entry* bucket;
    const struct hash_entry* cursor;
    intOrPtr _v8;
    struct hash_entry* _v12;
    struct hash_entry* _v16;
    intOrPtr _v24;
    _Unknown_base* _v40;
    _unknown_ __ebp;
    signed int _t37;
    _unknown_ _t42;

    _v8 = 0;
    _v12 = table->bucket;
    while(table->bucket_limit > _v12) {
        if( *_v12 == 0) {
            _v12 = _v12 + 8;
            continue;
        }
        _v16 = _v12;
        while(_v16 != 0) {
            _v40 = processor_data;
             *__esp =  *_v16;
            _t37 = processor;
             *_t37();
            if(((_t37 ^ 1) & 4294967295) == 0) {
                _v8 = _v8 + 1;
                _v16 = _v16->next;
                continue;
            }
            _v24 = _v8;
            return;
        }
    }
}

size_t hash_string(const char* string, size_t n_buckets)
{// addr = 0x0805285E
    size_t value;
    unsigned char ch;
    signed char _v5;
    signed int _v12;
    signed int _v28;
    _unknown_ __ebp;
    _unknown_ _t26;
    _unknown_ _t33;

    _v12 = 0;
    while(1) {
        _v5 =  *string & 255 & 4294967295;
        if(_v5 == 0) {
            break;
        }
        _v28 = (_v12 << 5) - _v12 + (_v5 & 255);
        _v12 = _v28 % n_buckets;
        string =  &(string[1]);
    }
    return _v12;
}

_Bool is_prime(size_t candidate)
{// addr = 0x080528AA
    size_t divisor;
    size_t square;
    signed int _v8;
    signed int _v12;
    unsigned int _v32;
    _unknown_ __ebp;
    _unknown_ _t38;
    _unknown_ _t42;
    _unknown_ _t46;
    _unknown_ _t48;

    _v8 = 3;
    _v12 = _v8 * _v8;
    while(_v12 < candidate) {
        _v32 = candidate;
        if(_v32 % _v8 != 0) {
            _v8 = _v8 + 1;
            _v12 = _v12 + (_v8 << 2);
            _v8 = _v8 + 1;
            continue;
        }
        _v32 = candidate;
        return _v32 % _v8;
    }
}

size_t next_prime(size_t candidate)
{// addr = 0x0805290D
    _unknown_ __ebp;

    if(candidate <= 9) {
        candidate = 10;
    }
    candidate = candidate | 1;
    while(((is_prime(candidate) ^ 1) & 4294967295) != 0) {
        candidate = candidate + 2;
    }
}

hash_reset_tuning(Hash_tuning* tuning)
{// addr = 0x08052941
    _unknown_ __ebp;
    _unknown_ _t10;
    _unknown_ _t11;
    _unknown_ _t12;
    _unknown_ _t13;

    tuning->shrink_threshold = 0;
    tuning->shrink_factor = 1065353216;
    tuning->growth_threshold = 1061997773;
    tuning->growth_factor = 1068826100;
    tuning->is_n_buckets = 0;
    return;
}

_Bool check_tuning(Hash_table* table)
{// addr = 0x08052978
    const Hash_tuning* tuning;
    float epsilon;
    const Hash_tuning* _v8;
    intOrPtr _v12;
    signed char _v21;
    _unknown_ __ebp;
    _unknown_ _t21;
    _unknown_ _t22;
    _unknown_ _t25;
    _unknown_ _t26;
    _unknown_ _t27;
    _unknown_ _t28;
    _unknown_ _t29;
    _unknown_ _t30;
    _unknown_ _t31;
    _unknown_ _t32;

    __eflags = __eflags;
    _v8 = table->tuning;
    _v12 = 1036831949;
    asm("fld dword [eax+0x8]");
    asm("fld dword [ebp-0x8]");
    asm("fxch st0, st1");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags <= 0) {
L8:
        table->tuning =  &default_tuning;
        _v21 = 0;
        return _v21 & 255;
    }
    asm("fld dword [eax+0x8]");
    asm("fld1 ");
    asm("fsub dword [ebp-0x8]");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags <= 0) {
        goto L8;
    }
    asm("fld dword [ebp-0x8]");
    asm("fld1 ");
    asm("faddp st1, st0");
    asm("fld dword [eax+0xc]");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags <= 0) {
        goto L8;
    }
    asm("fld dword [eax]");
    asm("fldz ");
    asm("fxch st0, st1");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags < 0) {
        goto L8;
    }
    asm("fld dword [eax]");
    asm("fadd dword [ebp-0x8]");
    asm("fld dword [eax+0x4]");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags <= 0) {
        goto L8;
    }
    asm("fld dword [eax+0x4]");
    asm("fld1 ");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags < 0) {
        goto L8;
    }
    asm("fld dword [eax]");
    asm("fadd dword [ebp-0x8]");
    asm("fld dword [eax+0x8]");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags <= 0) {
        goto L8;
    }
    _v21 = 1;
L9:
    return _v21 & 255;
    goto L9;
}

Hash_table* hash_initialize(size_t candidate, const Hash_tuning* tuning, Hash_hasher hasher, Hash_comparator comparator, Hash_data_freer data_freer)
{// addr = 0x08052A2A
    Hash_table* table;
    float new_candidate;
    void* _v8;
    signed short _v22;
    signed int _v24;
    _unknown_ _v32;
    unsigned int _v36;
    void* _v40;
    _unknown_ _v56;
    _unknown_ _v60;
    _unknown_ __ebp;
    signed int _t68;
    _unknown_ _t70;
    void* _t77;
    _unknown_ _t98;
    _unknown_ _t109;
    _unknown_ _t110;

    if(hasher == 0 || comparator == 0) {
        _v40 = 0;
L16:
        return _v40;
    }
    _v8 = malloc(40);
    __eflags = _v8;
    if(_v8 == 0) {
        _v40 = 0;
        return _v40;
    }
    __eflags = tuning;
    if(tuning == 0) {
        tuning =  &default_tuning;
    }
    _v8[5] = tuning;
    _t68 = check_tuning(_v8) ^ 1;
    __eflags = _t68 & 4294967295;
    if((_t68 & 4294967295) != 0) {
L15:
        free(_v8);
        _v40 = 0;
        return _v40;
    } else {
        __eflags = (tuning->is_n_buckets & 255 ^ 1) & 4294967295;
        if(__eflags == 0) {
L11:
            __eflags = candidate - 536870911;
            if(candidate > 536870911) {
                goto L15;
            }
            goto L12;
        }
        _push(0);
        _push(candidate);
        asm("fild qword [esp]");
        asm("fld dword [eax+0x8]");
        asm("fdivp st1, st0");
        asm("fstp dword [ebp-0x8]");
        asm("fld dword [ebp-0x8]");
        asm("fld dword [0x80618e8]");
        asm("fxch st0, st1");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags >= 0) {
            goto L15;
        }
        asm("fld dword [ebp-0x8]");
        asm("fnstcw word [ebp-0x12]");
        _v24 = _v22 & 65535 & 4294967295;
        asm("fldcw word [ebp-0x14]");
        asm("fistp qword [ebp-0x20]");
        asm("fldcw word [ebp-0x12]");
        candidate = _v36;
        goto L11;
L12:
        _v8[2] = next_prime(candidate);
        _t77 = _v8;
        __eflags = _t77[2] - 536870911;
        if(_t77[2] > 536870911) {
            goto L15;
        }
         *_v8 = calloc(_v8[2], 8);
        __eflags =  *_v8;
        if( *_v8 == 0) {
            goto L15;
        }
        _v8[1] =  *_v8 + (_v8[2] << 3);
        _v8[3] = 0;
        _v8[4] = 0;
        _v8[6] = hasher;
        _v8[7] = comparator;
        _v8[8] = data_freer;
        _v8[9] = 0;
        _v40 = _v8;
        return _v40;
        goto L16;
    }
}

hash_clear(Hash_table* table)
{// addr = 0x08052BB8
    struct hash_entry* bucket;
    struct hash_entry* cursor;
    struct hash_entry* next;
    struct hash_entry* _v8;
    struct hash_entry* _v12;
    struct hash_entry* _v16;
    _unknown_ __ebp;

    _v8 = table->bucket;
    while(table->bucket_limit > _v8) {
        if( *_v8 != 0) {
            goto L2;
        }
        _v8 = _v8 + 8;
        continue;
L2:
        _v12 = _v8->next;
        while(_v12 != 0) {
            if( *((intOrPtr*)(table + 32)) != 0) {
                 *__esp =  *_v12;
                 *((intOrPtr*)( *((intOrPtr*)(table + 32))))();
            }
             *_v12 = 0;
            _v16 = _v12->next;
            _v12->next = table->free_entry_list;
            table->free_entry_list = _v12;
            _v12 = _v16;
        }
    }
}

hash_free(Hash_table* table)
{// addr = 0x08052C86
    struct hash_entry* bucket;
    struct hash_entry* cursor;
    struct hash_entry* next;
    void* _v8;
    void* _v12;
    void _v16;
    _unknown_ __ebp;

    if( *((intOrPtr*)(table + 32)) == 0 ||  *((intOrPtr*)(table + 16)) == 0) {
        _v8 = table->bucket;
        while(table->bucket_limit > _v8) {
            goto L10;
        }
    } else {
        _v8 = table->bucket;
        while(table->bucket_limit > _v8) {
            if( *_v8 == 0) {
                _v8 =  &(_v8[2]);
                continue;
            }
            _v12 = _v8;
            while(_v12 != 0) {
                 *__esp =  *_v12;
                 *((intOrPtr*)( *((intOrPtr*)(table + 32))))();
                _v12 = _v12[1];
            }
        }
    }
L10:
    _v12 = _v8->next;
    while(_v12 != 0) {
        _v16 = _v12[1];
        free(_v12);
        _v12 = _v16;
    }
}

struct hash_entry* allocate_entry(Hash_table* table)
{// addr = 0x08052D72
    struct hash_entry* new;
    struct hash_entry* _v8;
    _unknown_ __ebp;

    if(table->free_entry_list == 0) {
        _v8 = malloc(8);
        return _v8;
    }
    _v8 = table->free_entry_list;
    table->free_entry_list = _v8->next;
    return _v8;
}

free_entry(Hash_table* table, struct hash_entry* entry)
{// addr = 0x08052DAD
    _unknown_ __ebp;

    entry->data = 0;
    entry->next = table->free_entry_list;
    table->free_entry_list = entry;
    return;
}

_Unknown_base* hash_find_entry(Hash_table* table, * entry, struct hash_entry** bucket_head, _Bool delete)
{// addr = 0x08052DD0
    struct hash_entry* bucket;
    struct hash_entry* cursor;
    _Unknown_base* data;
    struct hash_entry* next;
    _Unknown_base* data;
    struct hash_entry* next;
    struct hash_entry* _v12;
    struct hash_entry _v20;
    struct hash_entry _v28;
    struct hash_entry* _v32;
    struct hash_entry _v48;
    struct hash_entry _v56;
    _unknown_ __ebp;
    signed int _t81;
    signed int _t92;
    signed int _t100;
    _unknown_ _t107;
    struct hash_entry* _t122;

    _v48.next = delete & 4294967295;
    _v56.data =  *(table + 8);
    _t81 = entry;
     *__esp = _t81;
     *((intOrPtr*)( *((intOrPtr*)(table + 24))))();
    _v12 = table->bucket + (_t81 << 3);
    if(table->bucket_limit <= _v12) {
        abort();
    }
     *bucket_head = _v12;
    if( *_v12 == 0) {
        _v48.data = 0;
        return;
    }
    _v56.data =  *_v12;
    _t92 = entry;
     *__esp = _t92;
     *((intOrPtr*)( *((intOrPtr*)(table + 28))))();
    if((_t92 & 4294967295) == 0) {
        _v20.next = _v12;
L16:
        while(_v16->next != 0) {
            goto L11;
        }
    } else {
        _v20.data =  *_v12;
        if(_v44 != 0) {
            if(_v12->next == 0) {
                 *_v12 = 0;
            } else {
                _v28.next = _v12->next;
                _t122 = _v28.next;
                __ecx = _v12;
                __ecx->data = _t122->data;
                __ecx->next = _t122->next;
                free_entry(table, _v28.next);
            }
        }
        _v48.data = _v20;
        return ;
    }
L11:
    _v56 =  *(_v20.next->next);
    _t100 = entry;
     *__esp = _t100;
     *((intOrPtr*)( *((intOrPtr*)(table + 28))))();
    if((_t100 & 4294967295) == 0) {
        _v20.next = _v20.next->next;
        goto L16;
    }
    _v28.data =  *(_v20.next->next);
    if(_v44 != 0) {
        _v32 = _v20.next->next;
        _v20.next->next = _v32->next;
        free_entry(table, _v32);
    }
    _v48 = _v28;
    return ;
}

_Bool hash_rehash(Hash_table* table, size_t candidate)
{// addr = 0x08052F2D
    Hash_table* new_table;
    struct hash_entry* bucket;
    struct hash_entry* cursor;
    struct hash_entry* next;
    _Unknown_base* data;
    struct hash_entry* new_bucket;
    struct hash_entry* new_entry;
    Hash_table* _v12;
    struct hash_entry* _v16;
    struct hash_entry* _v20;
    struct hash_entry* _v24;
    signed int _v28;
    signed int* _v32;
    Hash_table* _v36;
    char _v41;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    intOrPtr _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    signed int _t130;
    Hash_table* _t151;
    _unknown_ _t156;

    _v12 = hash_initialize(candidate, table->tuning,  *(table + 24),  *(table + 28),  *(table + 32));
    if(_v12 == 0) {
        _v41 = 0;
        return;
    }
    _v12->free_entry_list = table->free_entry_list;
    _v16 = table->bucket;
    while(table->bucket_limit > _v16) {
        if( *_v16 == 0) {
            _v16 = _v16 + 8;
            continue;
        }
        _v20 = _v16;
        while(_v20 != 0) {
            _v28 =  *_v20;
            _v72 =  *((intOrPtr*)(_v12 + 8));
            _t130 = _v28;
             *__esp = _t130;
             *((intOrPtr*)( *((intOrPtr*)(_v12 + 24))))();
            _v32 =  *_v12 + (_t130 << 3);
            if(_v12->bucket_limit <= _v32) {
                abort();
            }
            _v24 = _v20->next;
            if( *_v32 == 0) {
L13:
                 *_v32 = _v28;
                 *((intOrPtr*)(_v12 + 12)) =  *((intOrPtr*)(_v12 + 12)) + 1;
                if(_v20 != _v16) {
                    free_entry(_v12, _v20);
                }
                goto L15;
            }
            if(_v20 != _v16) {
L12:
                _v20->next = _v32[1];
                _v32[1] = _v20;
                goto L15;
            }
            _t151 = _v12;
            allocate_entry(_t151);
            _v36 = _t151;
            if(_v36 != 0) {
                 *_v36 = _v28;
                _v36->bucket_limit = _v32[1];
                _v32[1] = _v36;
L15:
                _v20 = _v24;
                continue;
            }
            _v41 = 0;
            return ;
            goto L12;
        }
    }
}

_Unknown_base* hash_insert(Hash_table* table, * entry)
{// addr = 0x08053109
    _Unknown_base* data;
    struct hash_entry* bucket;
    struct hash_entry* new_entry;
    const Hash_tuning* tuning;
    float candidate;
    _Unknown_base* _v8;
    intOrPtr _v12;
    signed int _v16;
    const Hash_tuning* _v20;
    signed short _v38;
    signed int _v40;
    _unknown_ _v48;
    unsigned int _v52;
    * _v60;
    _unknown_ _v80;
    _unknown_ _v84;
    _unknown_ _v88;
    _unknown_ _v92;
    _unknown_ __ebp;
    _unknown_ _t106;
    _unknown_ _t107;
    _unknown_ _t113;
    _unknown_ _t116;
    _unknown_ _t117;
    _unknown_ _t126;
    _unknown_ _t127;
    signed int _t132;
    _unknown_ _t135;
    _unknown_ _t147;
    _unknown_ _t151;
    _unknown_ _t152;
    _unknown_ _t153;
    _unknown_ _t154;
    _unknown_ _t155;
    _unknown_ _t156;
    _unknown_ _t157;

    if(entry == 0) {
        abort();
    }
    _v8 = hash_find_entry(table, entry,  &_v12, 0);
    if(_v8 != 0) {
        _v60 = _v8;
        return _v60;
    }
    __eflags =  *_v12;
    if(__eflags == 0) {
         *_v12 = entry;
         *((intOrPtr*)(table + 16)) =  *((intOrPtr*)(table + 16)) + 1;
         *((intOrPtr*)(table + 12)) =  *((intOrPtr*)(table + 12)) + 1;
        _push(0);
        _push( *((intOrPtr*)(table + 12)));
        asm("fild qword [esp]");
        asm("fld dword [eax+0x8]");
        _push(0);
        _push( *((intOrPtr*)(table + 8)));
        asm("fild qword [esp]");
        asm("fmulp st1, st0");
        asm("fxch st0, st1");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags <= 0) {
L17:
            _v60 = entry;
            return _v60;
        }
        goto L9;
        return _v60;
    } else {
        _v16 = allocate_entry(table);
        __eflags = _v16;
        if(_v16 == 0) {
            _v60 = 0;
            return _v60;
        }
         *_v16 = entry;
         *((intOrPtr*)(_v16 + 4)) =  *((intOrPtr*)(_v12 + 4));
        _v12->next = _v16;
         *((intOrPtr*)(table + 16)) =  *((intOrPtr*)(table + 16)) + 1;
        _v60 = entry;
        return _v60;
    }
L9:
    check_tuning(table);
    _push(0);
    _push( *((intOrPtr*)(table + 12)));
    asm("fild qword [esp]");
    asm("fld dword [eax+0x8]");
    _push(0);
    _push( *((intOrPtr*)(table + 8)));
    asm("fild qword [esp]");
    asm("fmulp st1, st0");
    asm("fxch st0, st1");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags <= 0) {
        goto L17;
    }
    _v20 = table->tuning;
    __eflags = _v20->is_n_buckets & 255 & 4294967295;
    if(__eflags == 0) {
        _push(0);
        _push( *((intOrPtr*)(table + 8)));
        asm("fild qword [esp]");
        asm("fld dword [eax+0xc]");
        asm("fmulp st1, st0");
        asm("fld dword [eax+0x8]");
        asm("fmulp st1, st0");
        asm("fstp dword [ebp-0x34]");
    } else {
        _push(0);
        _push( *((intOrPtr*)(table + 8)));
        asm("fild qword [esp]");
        asm("fld dword [eax+0xc]");
        asm("fmulp st1, st0");
        asm("fstp dword [ebp-0x34]");
    }
    asm("fld dword [ebp-0x34]");
    asm("fstp dword [ebp-0x14]");
    asm("fld dword [ebp-0x14]");
    asm("fld dword [0x80618e8]");
    asm("fxch st0, st1");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags < 0) {
        asm("fld dword [ebp-0x14]");
        asm("fnstcw word [ebp-0x22]");
        _v40 = _v38 & 65535 & 4294967295;
        asm("fldcw word [ebp-0x24]");
        asm("fistp qword [ebp-0x30]");
        asm("fldcw word [ebp-0x22]");
        _t132 = hash_rehash(table, _v52) ^ 1;
        __eflags = _t132 & 4294967295;
        if((_t132 & 4294967295) != 0) {
            entry = 0;
        }
        goto L17;
    }
    _v60 = 0;
    return _v60;
}

_Unknown_base* hash_delete(Hash_table* table, * entry)
{// addr = 0x08053324
    _Unknown_base* data;
    struct hash_entry* bucket;
    const Hash_tuning* tuning;
    size_t candidate;
    signed int _v8;
    intOrPtr _v12;
    const Hash_tuning* _v16;
    unsigned int _v20;
    signed int _v22;
    signed int _v24;
    _unknown_ _v32;
    unsigned int _v36;
    unsigned int _v40;
    _Unknown_base* _v44;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ _v76;
    _unknown_ __ebp;
    _unknown_ _t91;
    _unknown_ _t92;
    _unknown_ _t96;
    _unknown_ _t99;
    _unknown_ _t100;
    signed int _t106;
    _unknown_ _t109;
    _unknown_ _t110;
    _unknown_ _t116;
    _unknown_ _t119;
    _unknown_ _t124;
    _unknown_ _t125;
    _unknown_ _t126;
    _unknown_ _t127;
    _unknown_ _t128;
    _unknown_ _t129;
    _unknown_ _t130;
    _unknown_ _t131;

    _v8 = hash_find_entry(table, entry,  &_v12, 1);
    __eflags = _v8;
    if(_v8 != 0) {
         *((intOrPtr*)(table + 16)) =  *((intOrPtr*)(table + 16)) - 1;
        __eflags =  *_v12;
        if(__eflags != 0) {
L9:
            _v44 = _v8;
            return _v44;
        }
        goto L3;
    }
    _v44 = 0;
L10:
    return _v44;
L3:
     *((intOrPtr*)(table + 12)) =  *((intOrPtr*)(table + 12)) - 1;
    _push(0);
    _push( *((intOrPtr*)(table + 12)));
    asm("fild qword [esp]");
    asm("fld dword [eax]");
    _push(0);
    _push( *((intOrPtr*)(table + 8)));
    asm("fild qword [esp]");
    asm("fmulp st1, st0");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags <= 0) {
        goto L9;
    }
    check_tuning(table);
    _push(0);
    _push( *((intOrPtr*)(table + 12)));
    asm("fild qword [esp]");
    asm("fld dword [eax]");
    _push(0);
    _push( *((intOrPtr*)(table + 8)));
    asm("fild qword [esp]");
    asm("fmulp st1, st0");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags <= 0) {
        goto L9;
    }
    _v16 = table->tuning;
    _t106 = _v16->is_n_buckets & 255;
    __eflags = _t106 & 4294967295;
    if((_t106 & 4294967295) == 0) {
        _push(0);
        _push( *((intOrPtr*)(table + 8)));
        asm("fild qword [esp]");
        asm("fld dword [eax+0x4]");
        asm("fmulp st1, st0");
        asm("fld dword [eax+0x8]");
        asm("fmulp st1, st0");
        asm("fnstcw word [ebp-0x12]");
        _v24 = _v22 & 65535 & 4294967295;
        asm("fldcw word [ebp-0x14]");
        asm("fistp qword [ebp-0x20]");
        asm("fldcw word [ebp-0x12]");
        _v40 = _v36;
    } else {
        _push(0);
        _push( *((intOrPtr*)(table + 8)));
        asm("fild qword [esp]");
        asm("fld dword [eax+0x4]");
        asm("fmulp st1, st0");
        asm("fnstcw word [ebp-0x12]");
        _v24 = _v22 & 65535 & 4294967295;
        asm("fldcw word [ebp-0x14]");
        asm("fistp qword [ebp-0x20]");
        asm("fldcw word [ebp-0x12]");
        _v40 = _v36;
    }
    _v20 = _v40;
    hash_rehash(table, _v20);
    goto L9;
}

long double adjust_value(int inexact_style, long double value)
{// addr = 0x080534C8
    uintmax_t u;
    signed int _v16;
    signed int _v20;
    signed int _v30;
    signed int _v32;
    signed int _v48;
    intOrPtr _v84;
    intOrPtr _v88;
    long double _v92;
    signed int _v96;
    signed int _v100;
    _unknown_ _v108;
    _unknown_ __ebp;
    long double _t40;
    signed int _t43;
    signed int _t44;
    signed int _t55;
    signed int _t58;
    _unknown_ _t59;

    _t59 = inexact_style - 1;
    if(_t59 != 0) {
        asm("fld tword [ebp+0xc]");
        asm("fld tword [0x8061970]");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(_t59 > 0) {
            asm("fld tword [ebp+0xc]");
            asm("fld tword [0x8061980]");
            asm("fxch st0, st1");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(_t59 >= 0) {
                asm("fld tword [ebp+0xc]");
                asm("fld tword [0x8061980]");
                asm("fsubp st1, st0");
                asm("fnstcw word [ebp-0x1a]");
                _v32 = _v30 & 65535 & 4294967295;
                asm("fldcw word [ebp-0x1c]");
                asm("fistp qword [ebp-0x10]");
                asm("fldcw word [ebp-0x1a]");
                _v20 = _v20;
                _v16 = _v16 ^ -2147483648;
            } else {
                asm("fld tword [ebp+0xc]");
                asm("fnstcw word [ebp-0x1a]");
                _v32 = _v30 & 65535 & 4294967295;
                asm("fldcw word [ebp-0x1c]");
                asm("fistp qword [ebp-0x10]");
                asm("fldcw word [ebp-0x1a]");
            }
            _t43 = _v20;
            _t55 = _v16;
            _v20 = _t43;
            _v16 = _t55;
            if(inexact_style != 0) {
L10:
                _v48 = 0;
            } else {
                asm("fild qword [ebp-0x10]");
                asm("fstp tword [ebp-0x28]");
                if(_v16 < 0) {
                    asm("fld tword [0x8061990]");
                    asm("fld tword [ebp-0x28]");
                    asm("faddp st1, st0");
                    asm("fstp tword [ebp-0x28]");
                }
                asm("fld tword [ebp+0xc]");
                asm("fld tword [ebp-0x28]");
                asm("fucompp ");
                asm("fnstsw ax");
                asm("sahf ");
                if((((_t43 | _t55) ^ 1) & 4294967295) != 0) {
                    goto L10;
                } else {
                    _v48 = 1;
                }
            }
L11:
            _t44 = _v48;
            _v100 = _t44;
            _v96 = _t44 >> 31;
            _t58 = _v96;
            asm("adc edx, [ebp-0xc]");
            _push(_t58);
            _push(_v100 + _v20);
            asm("fild qword [esp]");
            asm("fstp tword [ebp-0x48]");
            if(_t58 < 0) {
                asm("fld tword [0x8061990]");
                asm("fld tword [ebp-0x48]");
                asm("faddp st1, st0");
                asm("fstp tword [ebp-0x48]");
            }
            asm("fld tword [ebp-0x48]");
            asm("fstp tword [ebp+0xc]");
        }
    }
    _t40 = value;
    _v92 = _t40;
    _v88 = _a12;
    _v84 = _a16;
    asm("fld tword [ebp-0x58]");
    return _t40;
}

char* group_number(char* number, size_t numberlen, const char* grouping, const char* thousands_sep)
{// addr = 0x08053603
    char* d;
    size_t grouplen;
    size_t thousands_seplen;
    size_t i;
    char[40] buf;
    unsigned char g;
    intOrPtr _v8;
    char _v49;
    signed char _v50;
    signed int _v56;
    signed int _v60;
    unsigned int _v64;
    void* _v72;
    char* _v76;
    char* _v80;
    void* _v84;
    signed int _v88;
    _unknown_ _v100;
    _unknown_ _v104;
    _unknown_ __ebp;
    _unknown_ _t65;
    _unknown_ _t72;
    _unknown_ _t84;
    _unknown_ _t90;
    char* _t91;
    _unknown_ _t99;
    unsigned int _t103;

    _v72 = number;
    _v76 = grouping;
    _v80 = thousands_sep;
    _v8 =  *gs:0x14];
    _v56 = -1;
    _v60 = strlen(_v80);
    _v64 = numberlen;
    memcpy( &_v49, _v72, numberlen);
    _v84 = _v72 + numberlen;
    while(1) {
        _v50 =  *_v76 & 255 & 4294967295;
        if(_v50 != 0) {
            if(_v50 > 126) {
                _v88 = _v64;
            } else {
                _v88 = _v50 & 255;
            }
            _v56 = _v88;
            _v76 =  &(_v76[1]);
        }
        if(_v64 < _v56) {
            _v56 = _v64;
        }
        _v84 =  &(_v84[ ~_v56]);
        _v64 = _v64 - _v56;
        memcpy(_v84,  &_v49 + _v64, _v56);
        _t103 = _v64;
        if(_t103 == 0) {
            break;
        }
        _v84 =  &(_v84[ ~_v60]);
        memcpy(_v84, _v80, _v60);
    }
    _t91 = _v84;
    if(_t103 == 0) {
        return _t91;
    }
    __stack_chk_fail();
    return _t91;
}

char* human_readable(uintmax_t n, char* buf, int opts, uintmax_t from_block_size, uintmax_t to_block_size)
{// addr = 0x0805370F
    int inexact_style;
    unsigned int base;
    uintmax_t amt;
    int tenths;
    int exponent;
    int exponent_max;
    char* p;
    char* psuffix;
    const char* integerlim;
    int rounding;
    const char* decimal_point;
    size_t decimal_pointlen;
    const char* grouping;
    const char* thousands_sep;
    const struct lconv* l;
    size_t pointlen;
    uintmax_t multiplier;
    uintmax_t divisor;
    uintmax_t r10;
    uintmax_t r2;
    long double dto_block_size;
    long double damt;
    size_t buflen;
    size_t nonintegerlen;
    long double e;
    unsigned int r10;
    unsigned int r2;
    int digit;
    uintmax_t power;
    signed int _v32;
    signed int _v36;
    signed int _v40;
    signed int _v44;
    intOrPtr _v48;
    void* _v52;
    void* _v56;
    void* _v60;
    signed int _v64;
    void* _v68;
    signed int _v72;
    char* _v76;
    char* _v80;
    struct lconv* _v84;
    int _v88;
    int _v92;
    signed int _v96;
    signed int _v100;
    intOrPtr _v104;
    intOrPtr _v108;
    signed int _v112;
    signed int _v116;
    signed int _v120;
    signed int _v124;
    signed int _v128;
    signed int _v132;
    intOrPtr _v136;
    signed int _v140;
    signed int _v144;
    signed int _v148;
    signed int _v152;
    signed int _v156;
    signed int _v180;
    signed int _v184;
    signed int _v188;
    intOrPtr _v196;
    intOrPtr _v200;
    signed int _v204;
    signed int _v208;
    signed int _v212;
    signed int _v216;
    signed int _v220;
    signed int _v224;
    signed int _v228;
    signed char _v229;
    signed char _v236;
    signed int _v237;
    _unknown_ _v244;
    _unknown_ _v245;
    signed int _v256;
    signed int _v260;
    signed int _v264;
    signed int _v268;
    signed int _v272;
    signed int _v276;
    signed int _v320;
    signed int _v324;
    signed int _v328;
    signed int _v336;
    signed int _v340;
    signed int _v344;
    signed int _v348;
    signed int _v352;
    signed int _v356;
    signed int _v392;
    signed int _v396;
    signed int _v400;
    signed int _v432;
    signed int _v436;
    signed int _v440;
    char _v444;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __ebp;
    _unknown_ _t523;
    _unknown_ _t551;
    signed int _t553;
    _unknown_ _t558;
    _unknown_ _t570;
    _unknown_ _t579;
    signed int _t608;
    signed int _t609;
    _unknown_ _t627;
    signed int _t637;
    signed int _t638;
    _unknown_ _t640;
    _unknown_ _t677;
    _unknown_ _t694;
    _unknown_ _t716;
    signed int _t744;
    signed int _t745;
    signed int _t759;
    _unknown_ _t761;
    _unknown_ _t766;
    _unknown_ _t770;
    signed int _t781;
    _unknown_ _t789;
    _unknown_ _t798;
    _unknown_ _t811;
    _unknown_ _t812;
    _unknown_ _t813;
    _unknown_ _t819;
    signed int _t821;
    signed int _t825;
    signed int _t827;
    signed int _t828;
    intOrPtr _t830;
    signed int _t831;
    signed int _t833;
    signed int _t841;
    _unknown_ _t843;
    _unknown_ _t847;
    _unknown_ _t849;
    _unknown_ _t851;
    _unknown_ _t854;
    _unknown_ _t857;
    signed int _t858;
    _unknown_ _t859;
    _unknown_ _t860;
    signed int _t866;
    signed int _t868;
    signed int _t870;
    signed int _t872;
    _unknown_ _t875;

    _v212 = n;
    _v208 = buf;
    _v220 = to_block_size;
    _v216 = _a24;
    _v228 = _a28;
    _v224 = _a32;
    _v32 = from_block_size & 3;
    if((from_block_size & 32) == 0) {
        _v328 = 1000;
    } else {
        _v328 = 1024;
    }
    _v36 = _v328;
    _v44 = -1;
    _v48 = 8;
    _v68 = 134617337;
    _v72 = 1;
    _v76 = 134617339;
    _v80 = 134617339;
    _v84 = localeconv();
    _v88 = strlen( *_v84);
    if(_v88 != 0) {
        if(_v88 <= 16) {
            _v68 =  *_v84;
            _v72 = _v88;
        }
    }
    _v76 = _v84->grouping;
    if(strlen(_v84->thousands_sep) <= 16) {
        _v80 = _v84->thousands_sep;
    }
    _v56 = opts + 648;
    _v52 = _v56;
    _v340 = _v228;
    _v336 = _v224;
    if(_v336 > _v216 || _v336 >= _v216 && _v340 > _v220) {
        if((_v220 | _v216) == 0) {
            goto L27;
        }
    } else {
        _t866 = _v224;
        if((L0805E1C0(_v220, _v216, _v228, _t866) | _t866) != 0) {
L27:
            asm("fild qword [ebp+0xffffff20]");
            asm("fstp tword [ebp+0xfffffe88]");
            if(_v224 < 0) {
                asm("fld tword [0x8061990]");
                asm("fld tword [ebp+0xfffffe88]");
                asm("faddp st1, st0");
                asm("fstp tword [ebp+0xfffffe88]");
            }
            asm("fld tword [ebp+0xfffffe88]");
            asm("fstp tword [ebp+0xffffff58]");
            asm("fild qword [ebp+0xffffff30]");
            asm("fstp tword [ebp+0xfffffec8]");
            if(_v208 < 0) {
                asm("fld tword [0x8061990]");
                asm("fld tword [ebp+0xfffffec8]");
                asm("faddp st1, st0");
                asm("fstp tword [ebp+0xfffffec8]");
            }
            asm("fild qword [ebp+0xffffff28]");
            asm("fstp tword [ebp+0xfffffed8]");
            if(_v216 < 0) {
                asm("fld tword [0x8061990]");
                asm("fld tword [ebp+0xfffffed8]");
                asm("faddp st1, st0");
                asm("fstp tword [ebp+0xfffffed8]");
            }
            asm("fld tword [ebp+0xffffff58]");
            asm("fld tword [ebp+0xfffffed8]");
            asm("fdivrp st1, st0");
            asm("fld tword [ebp+0xfffffec8]");
            asm("fmulp st1, st0");
            asm("fstp tword [ebp+0xffffff48]");
            if((from_block_size & 16) != 0) {
                _v204 = 0;
                _v200 = -2147483648;
                _v196 = 16383;
                _v44 = 0;
                while(1) {
                    _push(0);
                    _push(_v36);
                    asm("fild qword [esp]");
                    __esp =  ?_? ( &_v444);
                    asm("fld tword [ebp+0xffffff38]");
                    asm("fmulp st1, st0");
                    asm("fstp tword [ebp+0xffffff38]");
                    _v44 = _v44 + 1;
                    _t553 = _v36;
                    _push(0);
                    _push(_t553);
                    asm("fild qword [esp]");
                    __esp =  &_v444 + 8;
                    asm("fld tword [ebp+0xffffff38]");
                    asm("fmulp st1, st0");
                    asm("fld tword [ebp+0xffffff48]");
                    asm("fucompp ");
                    asm("fnstsw ax");
                    if(((_t553 ^ 1) & 4294967295) != 0 || _v44 >= _v48) {
                        asm("fld tword [ebp+0xffffff48]");
                        asm("fld tword [ebp+0xffffff38]");
                        asm("fdivp st1, st0");
                        asm("fstp tword [ebp+0xffffff48]");
                        _v440 = _v188;
                        _v436 = _v184;
                        _v432 = _v180;
                         *__esp = _v32;
                        adjust_value();
                        asm("fstp tword [esp+0x8]");
                        sprintf(opts, 134617346);
                        _v92 = strlen(opts);
                        _v96 = _v72 + 1;
                        if((from_block_size & 32 & 4294967295 & ) + _v96 + 1 < _v92 || (from_block_size & 8) != 0 && ( *(_v92 - 1 + opts) & 255 & 4294967295) == 48) {
                            asm("fld tword [ebp+0xffffff48]");
                            asm("fld tword [0x80619a0]");
                            asm("fmulp st1, st0");
                            asm("fstp tword [esp+0x4]");
                             *__esp = _v32;
                            adjust_value();
                            asm("fld tword [0x80619a0]");
                            asm("fdivp st1, st0");
                            asm("fstp tword [esp+0x8]");
                            sprintf(opts, 134617340);
                            _v92 = strlen(opts);
                            _v96 = 0;
                        }
                        goto L42;
                    } else {
                        continue;
                    }
                }
            } else {
                _v440 = _v188;
                _v436 = _v184;
                _v432 = _v180;
                 *__esp = _v32;
                adjust_value();
                asm("fstp tword [esp+0x8]");
                sprintf(opts, 134617340);
                _v92 = strlen(opts);
                _v96 = 0;
            }
L42:
            _v52 = _v56 +  ~_v92;
            memmove(_v52, opts, _v92);
            _v60 = _v92 - _v96 + _v52;
            goto L92;
        }
        _v436 = _v228;
        _v432 = _v224;
        _t868 = _v216;
         *__esp = _v220;
        _v440 = _t868;
        _v124 = L0805E090();
        _v120 = _t868;
        _t744 = _v124;
        _t745 = _t744 * _v212;
        _t870 = _v208 * _v124 + _v120 * _v212 + (_t744 * _v212 >> 32);
        _v116 = _t745;
        _v112 = _t870;
        _v116 = _t745;
        _v112 = _t870;
        _v436 = _v124;
        _v432 = _v120;
        _t872 = _v112;
         *__esp = _v116;
        _v440 = _t872;
        if((L0805E090() ^ _v212 | _t872 ^ _v208) != 0) {
            goto L27;
        } else {
            _v40 = 0;
            _v64 = 0;
        }
L43:
        if((from_block_size & 16) == 0) {
L76:
            if(_v32 != 1) {
                if(_v32 != 0 || _v40 + _v64 <= 0) {
                    _v236 = 0;
                } else {
                    _v236 = 1;
                }
                _v237 = _v236 & 255 & 4294967295;
            } else {
L77:
                asm("adc edx, edi");
                _v237 = (((_v116 & 1) + _v64 | _v112 & 0) & 4294967295 & ) + _v40 - 5 > 0;
            }
            if(_v237 != 0) {
                _v116 = _v116 + 1;
                asm("adc dword [ebp-0x6c], 0x0");
                if((from_block_size & 16) != 0 && (_v36 ^ _v116 | 0 ^ _v112) == 0 && _v44 < _v48) {
                    _v44 = _v44 + 1;
                    if((from_block_size & 8) == 0) {
                        _v52 = _v52 - 1;
                         *_v52 = 48;
                        _v52 = _v52 +  ~_v72;
                        memcpy(_v52, _v68, _v72);
                    }
                    _v116 = 1;
                    _v112 = 0;
                }
            }
            _v60 = _v52;
            while(1) {
L91:
                _v108 = L0805E1C0(_v116, _v112, 10, 0);
                _v52 = _v52 - 1;
                 *_v52 = _v108 + 48 & 4294967295;
                _t841 = _v112;
                _v116 = L0805E090(_v116, _t841, 10, 0);
                _v112 = _t841;
                if((_v112 | _v116) == 0) {
                    break;
                }
            }
L92:
            if((from_block_size & 4) != 0) {
                _v52 = group_number(_v52, _v60 - _v52, _v76, _v80);
            }
            if((from_block_size & 128) == 0) {
L116:
                 *_v56 = 0;
                return _v52;
            } else {
                if(_v44 >= 0) {
L102:
                    if((from_block_size & 256 | _v44) != 0 && (from_block_size & 64) != 0) {
                         *_v56 = 32;
                        _v56 =  &(_v56[0]);
                    }
                    if(_v44 != 0) {
                        if((from_block_size & 32) != 0 || _v44 != 1) {
                            _v229 =  *( &power_letter + _v44) & 255 & 4294967295;
                        } else {
                            _v229 = 107;
                        }
                         *_v56 = _v229 & 255 & 4294967295;
                        _v56 =  &(_v56[0]);
                    }
                    if((from_block_size & 256) != 0) {
                        if((from_block_size & 32) != 0 && _v44 != 0) {
                             *_v56 = 105;
                            _v56 =  &(_v56[0]);
                        }
                         *_v56 = 66;
                        _v56 =  &(_v56[0]);
                    }
                    goto L116;
                }
                _v44 = 0;
                _v156 = 1;
                _v152 = 0;
                while(1) {
                    _v396 = _v156;
                    _v392 = _v152;
                    if(_v392 >= _v224 && (_v392 > _v224 || _v396 >= _v228)) {
                        break;
                    }
                    _v44 = _v44 + 1;
                    if(_v44 == _v48) {
                        goto L102;
                    }
                    _t608 = _v36;
                    _t609 = _t608 * _v156;
                    _t821 = _v152 * _t608 + _v156 * 0 + (_t608 * _v156 >> 32);
                    _v156 = _t609;
                    _v152 = _t821;
                    _v156 = _t609;
                    _v152 = _t821;
                }
                goto L102;
            }
        }
        _v44 = 0;
        _v276 = _v36;
        _v272 = 0;
        if(_v272 <= _v112 && (_v272 < _v112 || _v276 <= _v116)) {
            goto L47;
            do {
                _v64 = _v268;
                _v44 = _v44 + 1;
                _v260 = _v36;
                _v256 = 0;
                if(_v256 > _v112 || _v256 >= _v112 && _v260 > _v116 || _v44 >= _v48) {
                    if(_v112 <= 0 && (_v112 < 0 || _v116 <= 9)) {
                        if(_v112 <= 0 && (_v112 < 0 || _v116 <= 9) && (_v40 != 0 || (from_block_size & 8) == 0)) {
                            _v52 = _v52 - 1;
                             *_v52 = _v40 + 48 & 4294967295;
                            _v52 = _v52 +  ~_v72;
                            memcpy(_v52, _v68, _v72);
                            _v64 = 0;
                            _v40 = _v64;
                        }
                    }
                    goto L76;
                } else {
L47:
                    _v100 = L0805E1C0(_v116, _v112, _v36, 0) * 10 + _v40;
                    _v400 = _v100;
                    _v104 = _v400 % _v36 + _v400 % _v36 + (_v64 >> 1);
                    _v436 = _v36;
                    _v432 = 0;
                    _t858 = _v112;
                     *__esp = _v116;
                    _v440 = _t858;
                    _v116 = L0805E090();
                    _v112 = _t858;
                    _v40 = _v100 / _v36;
                    if(_v104 >= _v36) {
                        if(_v64 + _v104 <= _v36) {
                            _v264 = 2;
                        } else {
                            _v264 = 3;
                        }
                        _v268 = _v264;
                    } else {
                        _v268 = _v64 + _v104 & 4294967295 & ;
                    }
                    continue;
                }
                goto L77;
            } while();
        }
        goto L76;
    }
L15:
    _t825 = _v216;
    if((L0805E1C0(_v228, _v224, _v220, _t825) | _t825) != 0) {
        goto L27;
    }
    _v436 = _v220;
    _v432 = _v216;
    _t827 = _v224;
     *__esp = _v228;
    _v440 = _t827;
    _v132 = L0805E090();
    _v128 = _t827;
    _t781 = _v212;
    _t759 = _v208;
    _t828 = _v128;
    _t637 = L0805E1C0(_t781, _t759, _v132, _t828);
    _t638 = _t637 * 10;
    _t830 = _t781 * _t828 + _t759 * _t637 + (_t637 * 10 >> 32);
    _v140 = _t638;
    _v136 = _t830;
    _v140 = _t638;
    _v136 = _t830;
    _t831 = _v128;
    _t640 = L0805E1C0(_v140, _v136, _v132, _t831);
    asm("shld edx, eax, 0x1");
    _v148 = _t640 + _t640;
    _v144 = _t831;
    _v436 = _v132;
    _v432 = _v128;
    _t833 = _v208;
     *__esp = _v212;
    _v440 = _t833;
    _v116 = L0805E090();
    _v112 = _t833;
    _v40 = L0805E090(_v140, _v136, _v132, _v128);
    _v348 = _v148;
    _v344 = _v144;
    if(_v344 > _v128) {
L20:
        _v356 = _v132;
        _v352 = _v128;
        if(_v352 > _v144) {
L24:
            _v320 = 2;
            goto L25;
        }
        goto L21;
L25:
        _v324 = _v320;
        goto L26;
    }
    if(_v344 < _v128 || _v348 < _v132) {
        _v324 = (_v148 | _v144) & 4294967295 & ;
L26:
        _v64 = _v324;
        goto L43;
    } else {
        goto L20;
    }
    goto L27;
L21:
    if(_v352 < _v144 || _v356 < _v148) {
        _v320 = 3;
        goto L25;
    } else {
        goto L24;
    }
    goto L26;
}

uintmax_t default_block_size()
{// addr = 0x08054394
    intOrPtr _v8;
    long long unsigned int _v12;
    _unknown_ __ebp;
    _unknown_ _t7;

    if(getenv("POSIXLY_CORRECT") == 0) {
        _v12 = 1024;
        _v8 = 0;
        return _v12;
    }
    _v12 = 512;
    _v8 = 0;
    return _v12;
}

strtol_error humblock(const char* spec, uintmax_t* block_size, int* options)
{// addr = 0x080543D0
    int i;
    int opts;
    char* ptr;
    strtol_error e;
    int _v8;
    signed int _v12;
    intOrPtr _v16;
    union strtol_error _v20;
    union strtol_error _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t64;
    uintmax_t* _t94;
    long long unsigned int _t97;
    long long unsigned int _t98;

    _t98 = __edx;
    _v12 = 0;
    if(spec != 0) {
L4:
        if(( *spec & 255 & 4294967295) == 39) {
            _v12 = _v12 | 4;
            spec =  &(spec[1]);
        }
        _v8 = argmatch(spec,  &block_size_args,  &block_size_opts, 4);
        if(_v8 >= 0) {
            _v20 = xstrtoumax(spec,  &_v16, 0, block_size, "eEgGkKmMpPtTyYzZ0");
            if(_v20 == 0) {
                while(( *spec & 255 & 4294967295) <= 47 || ( *spec & 255 & 4294967295) > 57) {
                    if(spec != _v16) {
                        spec =  &(spec[1]);
                        continue;
                    }
                    _v12 = _v12 | 128;
                    if(( *(_v16 - 1) & 255 & 4294967295) == 66) {
                        _v12 = _v12 | 256;
                    }
                    if(( *(_v16 - 1) & 255 & 4294967295) != 66 || ( *(_v16 - 2) & 255 & 4294967295) == 105) {
                        _v12 = _v12 | 32;
                    }
                    goto L19;
                }
            }
            goto L9;
        }
        _v12 = _v12 | ( &block_size_opts)[_v8];
        _t94 = block_size;
         *_t94 = 1;
        _t94[0] = 0;
L19:
         *options = _v12;
        _v24 = 0;
        return _v24;
L9:
         *options = 0;
        _v24 = _v20;
        return _v24;
    }
    spec = getenv("BLOCK_SIZE");
    if(spec != 0) {
        goto L4;
    }
    spec = getenv("BLOCKSIZE");
    if(spec != 0) {
        goto L4;
    } else {
        _t97 = default_block_size();
        __ecx = block_size;
         *__ecx = _t97;
        (__ecx)[0] = _t98;
    }
    goto L19;
}

union strtol_error human_options(const char* spec, int* opts, uintmax_t* block_size)
{// addr = 0x08054532
    strtol_error e;
    union strtol_error _v8;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    uintmax_t* _t17;
    long long unsigned int _t21;

    _v8 = humblock(spec, block_size, opts);
    _t17 = block_size;
    __edx = _t17[0];
    if(( *_t17 | __edx) != 0) {
        return _v8;
    }
    _t21 = default_block_size();
    __ecx = block_size;
     *__ecx = _t21;
    (__ecx)[0] = __edx;
    _v8 = 4;
    return _v8;
}

char* getuser(uid_t uid)
{// addr = 0x0805457C
    struct userid* tail;
    struct userid* match;
    struct passwd* pwent;
    const char* name;
    struct userid* _v8;
    struct userid* _v12;
    unsigned int _v16;
    char* _v20;
    char** _v24;
    char* _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    unsigned int _t48;
    _unknown_ _t57;

    _v12 = 0;
    _v8 = user_alist;
    while(_v8 != 0) {
        if( *_v8 != uid) {
            _v8 = _v8->next;
            continue;
        }
        _v12 = _v8;
        if(_v12 == 0) {
            _t48 = uid;
             *__esp = _t48;
            getpwuid();
            _v16 = _t48;
            if(_v16 == 0) {
                _v28 = 134617516;
            } else {
                _v28 =  *_v16;
            }
            _v20 = _v28;
            _v12 = xmalloc(strlen(_v20) + 9);
             *_v12 = uid;
            strcpy( &(_v12->name), _v20);
            _v12->next = user_alist;
            user_alist = _v12;
        }
        if((_v12->name & 255 & 4294967295) == 0) {
            _v24 = 0;
            return _v24;
        }
        _v24 =  &(_v12->name);
        return _v24;
    }
}

uid_t* getuidbyname(const char* user)
{// addr = 0x08054651
    struct userid* tail;
    struct passwd* pwent;
    struct userid* _v8;
    _unknown_ _v12;
    _unknown_ _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t66;
    _unknown_ _t73;

    _v8 = user_alist;
    while() {
    }
}

char* getgroup(gid_t gid)
{// addr = 0x0805477C
    struct userid* tail;
    struct userid* match;
    struct group* grent;
    const char* name;
    struct userid* _v8;
    struct userid* _v12;
    unsigned int _v16;
    char* _v20;
    char** _v24;
    char* _v28;
    _unknown_ _v40;
    _unknown_ __ebp;
    unsigned int _t48;
    _unknown_ _t57;

    _v12 = 0;
    _v8 = group_alist;
    while(_v8 != 0) {
        if( *_v8 != gid) {
            _v8 = _v8->next;
            continue;
        }
        _v12 = _v8;
        if(_v12 == 0) {
            _t48 = gid;
             *__esp = _t48;
            getgrgid();
            _v16 = _t48;
            if(_v16 == 0) {
                _v28 = 134617516;
            } else {
                _v28 =  *_v16;
            }
            _v20 = _v28;
            _v12 = xmalloc(strlen(_v20) + 9);
             *_v12 = gid;
            strcpy( &(_v12->name), _v20);
            _v12->next = group_alist;
            group_alist = _v12;
        }
        if((_v12->name & 255 & 4294967295) == 0) {
            _v24 = 0;
            return _v24;
        }
        _v24 =  &(_v12->name);
        return _v24;
    }
}

gid_t* getgidbyname(const char* group)
{// addr = 0x08054851
    struct userid* tail;
    struct group* grent;
    struct userid* _v8;
    _unknown_ _v12;
    _unknown_ _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t66;
    _unknown_ _t73;

    _v8 = group_alist;
    while() {
    }
}

char* imaxtostr(intmax_t i, char* buf)
{// addr = 0x0805497C
    char* p;
    char* _v8;
    signed int _v24;
    signed int _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t52;
    _unknown_ _t68;
    _unknown_ _t69;
    _unknown_ _t76;
    signed int _t79;
    _unknown_ _t82;
    _unknown_ _t83;
    signed int _t84;

    _v28 = i;
    _v24 = buf;
    _v8 = _a12 + 20;
     *_v8 = 0;
    if(_v24 >= 0) {
        while(1) {
L3:
            _v8 = _v8 - 1;
             *_v8 = L0805DEB0(_v28, _v24, 10, 0) + 48 & 4294967295;
            _t79 = _v24;
            _v28 = L0805DD20(_v28, _t79, 10, 0);
            _v24 = _t79;
            if((_v24 | _v28) == 0) {
                break;
            }
        }
        goto L4;
    } else {
        goto L1;
    }
    while(1) {
L1:
        _v8 = _v8 - 1;
        L0805DEB0(_v28, _v24, 10, 0);
         *_v8 = 0x30;
        _t84 = _v24;
        _v28 = L0805DD20(_v28, _t84, 10, 0);
        _v24 = _t84;
        if((_v24 | _v28) == 0) {
            break;
        }
    }
    _v8 = _v8 - 1;
     *_v8 = 45;
    return _v8;
L4:
    return _v8;
}

mpsort_into_tmp(** base, size_t n, ** tmp, comparison_function cmp)
{// addr = 0x08054A84
    size_t n1;
    size_t n2;
    size_t a;
    size_t alim;
    size_t b;
    size_t blim;
    * ba;
    * bb;
    signed int _v8;
    unsigned int _v12;
    signed int _v16;
    unsigned int _v20;
    signed int _v24;
    unsigned int _v28;
    * _v32;
    * _v36;
    _unknown_ _v48;
    _unknown_ _v52;
    * _v56;
    _unknown_ __ebp;
    _None* _t99;

    _v8 = n >> 1;
    _v12 = n - _v8;
    _v16 = 0;
    _v20 = _v8;
    _v24 = _v8;
    _v28 = n;
    mpsort_with_tmp( &(base[_v8]), _v12, tmp, cmp);
    mpsort_with_tmp(base, _v8, tmp, cmp);
    _v32 = base[_v16];
    _v36 = base[_v24];
    while(1) {
L1:
        _v56 = _v36;
         *__esp = _v32;
        _t99 = cmp;
         *_t99();
        if(_t99 > 0) {
            break;
        }
         *tmp = _v32;
        tmp =  &(tmp[1]);
        _v16 = _v16 + 1;
        if(_v16 != _v20) {
            _v32 = base[_v16];
            continue;
        } else {
            _v16 = _v24;
            _v20 = _v28;
L7:
            memcpy(tmp,  &(base[_v16]), 0 + (_v20 - _v16) * 4);
            return;
        }
L8:
    }
     *tmp = _v36;
    tmp =  &(tmp[1]);
    _v24 = _v24 + 1;
    if(_v24 != _v28) {
        _v36 = base[_v24];
        goto L1;
    }
    goto L7;
}

mpsort_with_tmp(** base, size_t n, ** tmp, comparison_function cmp)
{// addr = 0x08054BBB
    * p0;
    * p1;
    size_t n1;
    size_t n2;
    size_t i;
    size_t t;
    size_t tlim;
    size_t b;
    size_t blim;
    * bb;
    * tt;
    * _v8;
    * _v12;
    signed int _v16;
    unsigned int _v20;
    signed int _v24;
    _None* _v28;
    signed int _v32;
    signed int _v36;
    unsigned int _v40;
    void _v44;
    * _v48;
    _unknown_ _v64;
    _unknown_ _v68;
    void _v72;
    _unknown_ __ebp;
    _None* _t118;

    if(n > 2) {
        _v16 = n >> 1;
        _v20 = n - _v16;
        _v28 = 0;
        _v32 = _v16;
        _v36 = _v16;
        _v40 = n;
        mpsort_with_tmp( &(base[_v16]), _v20, tmp, cmp);
        if(_v16 > 1) {
            mpsort_into_tmp(base, _v16, tmp, cmp);
        } else {
             *tmp =  *base;
        }
        _v48 = tmp[_v28];
        _v44 = base[_v36];
        _v24 = 0;
        while(1) {
L8:
            _v72 = _v44;
             *__esp = _v48;
            _t118 = cmp;
             *_t118();
            if(_t118 <= 0) {
                break;
            }
            base[_v24] = _v44;
            _v24 = _v24 + 1;
            _v36 = _v36 + 1;
            if(_v36 != _v40) {
                _v44 = base[_v36];
                continue;
            }
            memcpy( &(base[_v24]),  &(tmp[_v28]), 0 + (_v32 - _v28) * 4);
            return;
        }
        base[_v24] = _v48;
        _v24 = _v24 + 1;
        _v28 = _v28 + 1;
        _t91 = _v28;
        if(_v28 == _v32) {
            return ;
        }
        _v48 = tmp[_v28];
        goto L8;
    }
    if(n != 2) {
        return ;
    }
    _v8 =  *base;
    _v12 = base[1];
    _v72 = _v12;
     *__esp = _v8;
    _t91 = cmp;
     *_t91();
    if(_t91 <= 0) {
        return ;
    }
     *base = _v12;
    base[1] = _v8;
    return;
}

mpsort(** base, size_t n, comparison_function cmp)
{// addr = 0x08054D6F
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    mpsort_with_tmp(base, n,  &(base[n]), cmp);
    return;
}

const _None* quote_n(int n, const _None* name)
{// addr = 0x08054DA0
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return quotearg_n_style(n, 5, name);
}

const _None* quote(const _None* name)
{// addr = 0x08054DC2
    _unknown_ _v8;
    _unknown_ __ebp;

    return quote_n(0, name);
}

struct quoting_options* clone_quoting_options(struct quoting_options* o)
{// addr = 0x08054DE0
    int e;
    struct quoting_options* p;
    int _v8;
    _Unknown_base* _v12;
    struct quoting_options* _v24;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t11;

    _v8 =  *(__errno_location());
    if(o == 0) {
        _v24 =  &default_quoting_options;
    } else {
        _v24 = o;
    }
    _v12 = xmemdup(_v24, 36);
     *(__errno_location()) = _v8;
    return _v12;
}

union quoting_style get_quoting_style(struct quoting_options* o)
{// addr = 0x08054E2C
    struct quoting_options* _v8;
    _unknown_ __ebp;

    if(o == 0) {
        _v8 =  &default_quoting_options;
        return  *_v8;
    }
    _v8 = o;
    return  *_v8;
}

set_quoting_style(struct quoting_options* o, union quoting_style s)
{// addr = 0x08054E4E
    struct quoting_options* _v8;
    _unknown_ __ebp;

    if(o == 0) {
        _v8 =  &default_quoting_options;
    } else {
        _v8 = o;
    }
     *_v8 = s;
    return;
}

int set_char_quoting(struct quoting_options* o, char c, int i)
{// addr = 0x08054E73
    unsigned char uc;
    unsigned int* p;
    int shift;
    int r;
    signed int _v5;
    unsigned int** _v12;
    signed int _v16;
    signed int _v20;
    signed char _v24;
    struct quoting_options* _v28;
    _unknown_ __ebp;

    _v24 = c & 4294967295;
    _v5 = _v24 & 255 & 4294967295;
    if(o == 0) {
        _v28 =  &default_quoting_options;
    } else {
        _v28 = o;
    }
    _v12 =  &(( &(_v28->quote_these_too))[_v5 & 255 & 4294967295 & ]);
    _v16 = _v5 & 255 & 31;
    _v20 =  *_v12 >> (_v16 & 4294967295) & 1;
     *_v12 =  *_v12 ^ (i & 1 ^ _v20) << (_v16 & 4294967295);
    return _v20;
}

const char* gettext_quote(const char* msgid, union quoting_style s)
{// addr = 0x08054EED
    const char* translation;
    char* _v8;
    _unknown_ __ebp;

    _v8 = gettext(msgid);
    if(_v8 != msgid) {
        return _v8;
    }
    if(s != 6) {
        return _v8;
    }
    _v8 = 134617660;
    return _v8;
}

size_t quotearg_buffer_restyled(char* buffer, size_t buffersize, const char* arg, size_t argsize, union quoting_style quoting_style, const struct quoting_options* o)
{// addr = 0x08054F1B
    size_t i;
    size_t len;
    const char* quote_string;
    size_t quote_string_len;
    _Bool backslash_escapes;
    _Bool unibyte_locale;
    const char* left;
    const char* right;
    unsigned char c;
    unsigned char esc;
    size_t m;
    _Bool printable;
    mbstate_t mbstate;
    wchar_t w;
    size_t bytes;
    size_t j;
    size_t ilim;
    char _v5;
    signed int _v6;
    _unknown_ _v7;
    _unknown_ _v9;
    intOrPtr _v16;
    char _v20;
    char _v24;
    char _v28;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ _v64;
    _unknown_ _v72;
    _unknown_ _v73;
    _unknown_ _v80;
    _unknown_ _v96;
    _unknown_ _v104;
    _unknown_ _v108;
    _unknown_ _v112;
    _unknown_ _v116;
    _unknown_ _v120;
    _unknown_ __ebp;
    _unknown_ _t248;
    _unknown_ _t250;
    _unknown_ _t256;
    _unknown_ _t269;
    _unknown_ _t321;
    _unknown_ _t329;
    _unknown_ _t331;
    _unknown_ _t340;
    _unknown_ _t356;
    _unknown_ _t357;
    _unknown_ _t392;

    _v20 = 0;
    _v24 = 0;
    _v28 = 0;
    _v5 = 0;
    __ctype_get_mb_cur_max();
    _v6 = __eax & 4294967295;
    if(quoting_style <= 6) {
        goto __eax;
    }
    _v16 = 0;
    while() {
    }
}

size_t quotearg_buffer(char* buffer, size_t buffersize, const char* arg, size_t argsize, const struct quoting_options* o)
{// addr = 0x08055667
    const struct quoting_options* p;
    int e;
    size_t r;
    const struct quoting_options* _v8;
    int _v12;
    unsigned int _v16;
    const struct quoting_options* _v24;
    _unknown_ _v40;
    _unknown_ _v44;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;

    if(o == 0) {
        _v24 =  &default_quoting_options;
    } else {
        _v24 = o;
    }
    _v8 = _v24;
    _v12 =  *(__errno_location());
    _v16 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize,  *_v8, _v8);
     *(__errno_location()) = _v12;
    return _v16;
}

char* quotearg_alloc(const char* arg, size_t argsize, const struct quoting_options* o)
{// addr = 0x080556D6
    int e;
    size_t bufsize;
    char* buf;
    int _v8;
    unsigned int _v12;
    char* _v16;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t23;
    _unknown_ _t38;

    _v8 =  *(__errno_location());
    _v12 = quotearg_buffer(0, 0, arg, argsize, o) + 1;
    _v16 = xcharalloc(_v12);
    quotearg_buffer(_v16, _v12, arg, argsize, o);
     *(__errno_location()) = _v8;
    return _v16;
}

quotearg_free()
{// addr = 0x0805575B
    struct slotvec* sv;
    unsigned int i;
    struct slotvec* _v8;
    signed int _v12;
    _unknown_ __ebp;
    _unknown_ _t21;
    _unknown_ _t22;

    _v8 = slotvec;
    _v12 = 1;
    while(_v12 < nslots) {
        free( &(_v8[_v12])->val);
        _v12 = _v12 + 1;
    }
}

char* quotearg_n_options(int n, const char* arg, size_t argsize, const struct quoting_options* options)
{// addr = 0x080557ED
    int e;
    unsigned int n0;
    struct slotvec* sv;
    size_t n1;
    _Bool preallocated;
    size_t size;
    char* val;
    size_t qsize;
    signed int _v9;
    int _v16;
    int _v20;
    struct slotvec* _v24;
    signed int _v28;
    unsigned int _v32;
    char* _v36;
    unsigned int _v40;
    int _v44;
    signed int _v48;
    _unknown_ _v60;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t78;
    _unknown_ _t117;
    _unknown_ _t119;
    signed int _t121;
    _unknown_ _t134;
    _unknown_ _t137;

    _v16 =  *(__errno_location());
    _v20 = n;
    _v24 = slotvec;
    if(n < 0) {
        abort();
    }
    if(nslots <= _v20) {
        _t121 = _v20 + 1;
        _v28 = _t121;
        _v9 = _t121 & 4294967295;
        if(_v28 > 536870911) {
            xalloc_die();
        }
        _v48 = _v28 << 3;
        if(_v9 == 0) {
            _v44 = _v24;
        } else {
            _v44 = 0;
        }
        _v24 = xrealloc(_v44, _v48);
        slotvec = _v24;
        if(_v9 != 0) {
            __ecx = _v24;
             *__ecx = slotvec0.size;
            __ecx->val = slotvec0.val;
        }
        memset( &(_v24[nslots]), 0, 0 + (_v28 - nslots) * 8);
        nslots = _v28;
    }
    _v32 = _v24[n].size;
    _v36 =  &(_v24[n])->val;
    _v40 = quotearg_buffer(_v36, _v32, arg, argsize, options);
    if(_v32 <= _v40) {
        _v32 = _v40 + 1;
        _v24[n] = _v32;
        if(_v36 !=  &slot0) {
            free(_v36);
        }
        _v36 = xcharalloc(_v32);
         &(_v24[n])->val = _v36;
        quotearg_buffer(_v36, _v32, arg, argsize, options);
    }
     *(__errno_location()) = _v16;
    return _v36;
}

char* quotearg_n(int n, const char* arg)
{// addr = 0x080559AD
    _unknown_ _v16;
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return quotearg_n_options(n, arg, -1,  &default_quoting_options);
}

char* quotearg(const char* arg)
{// addr = 0x080559D7
    _unknown_ _v8;
    _unknown_ __ebp;

    return quotearg_n(0, arg);
}

struct quoting_options quoting_options_from_style(union quoting_style style)
{// addr = 0x080559F2
    struct quoting_options o;
    intOrPtr _v12;
    intOrPtr _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    intOrPtr _v36;
    intOrPtr _v40;
    char _v44;
    _unknown_ _v68;
    _unknown_ _v72;
    struct quoting_options __ebx;
    _unknown_ __ebp;
    _unknown_ _t27;

    __ebx = style;
    _v44 = _a8;
    memset( &_v44 + 4, 0, 32);
     *__ebx = _v44;
     *((intOrPtr*)(__ebx + 4)) = _v40;
     *((intOrPtr*)(__ebx + 8)) = _v36;
     *((intOrPtr*)(__ebx + 12)) = _v32;
     *((intOrPtr*)(__ebx + 16)) = _v28;
     *((intOrPtr*)(__ebx + 20)) = _v24;
     *((intOrPtr*)(__ebx + 24)) = _v20;
     *((intOrPtr*)(__ebx + 28)) = _v16;
     *((intOrPtr*)(__ebx + 32)) = _v12;
    return __ebx;
}

char* quotearg_n_style(int n, union quoting_style s, const char* arg)
{// addr = 0x08055A5F
    const struct quoting_options o;
    struct quoting_options _v40;
    _unknown_ _v68;
    union quoting_style _v72;
    _unknown_ _v76;
    _unknown_ __ebp;

    _v72 = s;
    quoting_options_from_style( &_v40);
    __esp = __esp - 4;
    return quotearg_n_options(n, arg, -1,  &_v40);
}

char* quotearg_n_style_mem(int n, union quoting_style s, const char* arg, size_t argsize)
{// addr = 0x08055A9D
    const struct quoting_options o;
    struct quoting_options _v40;
    _unknown_ _v68;
    union quoting_style _v72;
    _unknown_ _v76;
    _unknown_ __ebp;

    _v72 = s;
    quoting_options_from_style( &_v40);
    __esp = __esp - 4;
    return quotearg_n_options(n, arg, argsize,  &_v40);
}

char* quotearg_style(union quoting_style s, const char* arg)
{// addr = 0x08055ADA
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return quotearg_n_style(0, s, arg);
}

char* quotearg_char(const char* arg, char ch)
{// addr = 0x08055AFC
    struct quoting_options options;
    intOrPtr _v8;
    intOrPtr _v12;
    intOrPtr _v16;
    intOrPtr _v20;
    intOrPtr _v24;
    intOrPtr _v28;
    intOrPtr _v32;
    struct quoting_options _v40;
    char _v56;
    _unknown_ _v64;
    _unknown_ _v68;
    _unknown_ _v72;
    _unknown_ __ebp;
    _unknown_ _t34;

    _v56 = ch & 4294967295;
    _v40 = default_quoting_options.style;
    _v40.quote_these_too = default_quoting_options.quote_these_too;
    _v32 =  *134629160;
    _v28 =  *134629164;
    _v24 =  *134629168;
    _v20 =  *134629172;
    _v16 =  *134629176;
    _v12 =  *134629180;
    _v8 =  *134629184;
    set_char_quoting( &_v40, _v56, 1);
    return quotearg_n_options(0, arg, -1,  &_v40);
}

char* quotearg_colon(const char* arg)
{// addr = 0x08055B8F
    _unknown_ _v8;
    _unknown_ __ebp;

    return quotearg_char(arg, 58);
}

char* memcpy_lowcase(char* dest, const char* src, size_t len)
{// addr = 0x08055BAC
    _unknown_ __ebp;
    signed int _t14;

    _t14 = __eax;
    while(1) {
        len = len - 1;
        if((_t14 & 4294967295) == 0) {
            break;
        }
        _t14 =  *(src + len) & 255 & 4294967295 & ;
         *__esp = _t14;
        tolower();
        dest[len] = _t14 & 4294967295;
    }
    return dest;
}

char* memcpy_uppcase(char* dest, const char* src, size_t len)
{// addr = 0x08055BEE
    _unknown_ __ebp;
    signed int _t14;

    _t14 = __eax;
    while(1) {
        len = len - 1;
        if((_t14 & 4294967295) == 0) {
            break;
        }
        _t14 =  *(src + len) & 255 & 4294967295 & ;
         *__esp = _t14;
        toupper();
        dest[len] = _t14 & 4294967295;
    }
    return dest;
}

size_t strftime_case_(_Bool upcase, char* s, size_t maxsize, const char* format, const struct tm* tp, int ut, int ns)
{// addr = 0x08055C30
    int hour12;
    const char* zone;
    size_t i;
    char* p;
    const char* f;
    const char* format_end;
    int pad;
    int modifier;
    int digits;
    int number_value;
    unsigned int u_number_value;
    _Bool negative_number;
    _Bool always_output_a_sign;
    int tz_colon_mask;
    const char* subfmt;
    char sign_char;
    char* bufp;
    char[13] buf;
    int width;
    _Bool to_lowcase;
    _Bool to_uppcase;
    size_t colons;
    _Bool change_case;
    int format_char;
    int _n;
    int _delta;
    int _incr;
    mbstate_t mbstate;
    size_t len;
    size_t fsize;
    size_t bytes;
    int _n;
    int _delta;
    int _incr;
    int _n;
    int _delta;
    int _incr;
    size_t len;
    int _n;
    int _delta;
    int _incr;
    char[4] ufmt;
    char* u;
    char[1023] ubuf;
    size_t len;
    int _n;
    int _delta;
    int _incr;
    int century;
    int _n;
    int _delta;
    int _incr;
    int padding;
    int _n;
    int _delta;
    int _incr;
    int _n;
    int _delta;
    int _incr;
    int _n;
    int _delta;
    int _incr;
    int _n;
    int _delta;
    int _incr;
    int j;
    int _n;
    int _delta;
    int _incr;
    struct tm ltm;
    time_t t;
    int d;
    int _n;
    int _delta;
    int _incr;
    int year;
    int year_adjust;
    int days;
    int d;
    int yy;
    int yy;
    int _n;
    int _delta;
    int _incr;
    int diff;
    int hour_diff;
    int min_diff;
    int sec_diff;
    int flen;
    int _n;
    int _delta;
    int _incr;
    intOrPtr _v16;
    unsigned int _v1058;
    signed int _v1059;
    unsigned int _v1060;
    int _v1064;
    unsigned int _v1068;
    unsigned int _v1072;
    void* _v1076;
    char* _v1080;
    unsigned int _v1084;
    unsigned int _v1088;
    _unknown_ _v1092;
    unsigned int _v1096;
    intOrPtr _v1120;
    _unknown_ _v1128;
    intOrPtr _v1132;
    int _v1136;
    intOrPtr _v1140;
    unsigned int _v1144;
    intOrPtr _v1148;
    char* _v1152;
    unsigned int _v1156;
    int _v1160;
    intOrPtr _v1164;
    _unknown_ _v1372;
    _unknown_ _v1376;
    _unknown_ _v1380;
    _unknown_ _v1384;
    intOrPtr _v1424;
    char _v1428;
    signed char _v1440;
    char* _v1444;
    const char* _v1448;
    const struct tm* _v1452;
    _unknown_ _v1556;
    signed int _v1560;
    unsigned int _v1564;
    signed int _v1568;
    char* _v1604;
    intOrPtr _v1608;
    _unknown_ __ebx;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t307;
    char* _t325;
    _unknown_ _t342;
    _unknown_ _t347;
    _unknown_ _t351;
    _unknown_ _t354;
    _unknown_ _t358;
    unsigned int _t360;
    char* _t362;
    _unknown_ _t385;
    _unknown_ _t389;
    _unknown_ _t412;
    _unknown_ _t427;
    _unknown_ _t431;
    _unknown_ _t433;
    _unknown_ _t437;
    _unknown_ _t438;
    _unknown_ _t442;
    _unknown_ _t445;
    _unknown_ _t449;
    _unknown_ _t452;
    _unknown_ _t453;
    _unknown_ _t479;
    _unknown_ _t501;

    _v1440 = upcase & 4294967295;
    _v1444 = s;
    _v1448 = format;
    _v1452 = tp;
    _v16 =  *gs:0x14];
    _v1064 = _v1452->tm_hour;
    _v1072 = 0;
    _v1076 = _v1444;
    _v1084 = 0;
    _v1068 = 0;
    _v1068 = _v1452->tm_zone;
    if(_v1064 <= 12) {
        if(_v1064 == 0) {
            _v1064 = 12;
        }
    } else {
        _v1064 = _v1064 - 12;
    }
    _v1080 = _v1448;
    while(( *_v1080 & 255 & 4294967295) != 0) {
        _v1088 = 0;
        _v1096 = 0;
        _v1120 = -1;
        _v1058 = 0;
        _v1059 = _v1440 & 255 & 4294967295;
        _v1060 = 0;
        _v1568 =  *_v1080 & 255 & 4294967295;
        if(_v1568 > 63) {
            if(_v1568 < 65 || _v1568 > 95 && _v1568 - 97 > 29) {
L26:
                _v1428 = mbstate_zero.__val;
                _v1424 =  *134629476;
                _v1144 = 0;
                if(_v1084 == 0) {
                    _v1084 = strlen(_v1080) + 1 + _v1080;
                }
                _v1148 = _v1084 - _v1080;
                while(1) {
                    _t325 =  &_v1428;
                    _v1604 = _t325;
                    _v1608 = _v1148 - _v1144;
                     *__esp =  &(_v1080[_v1144]);
                    mbrlen();
                    _v1152 = _t325;
                    if(_v1152 == 0) {
                        break;
                    }
                    if(_v1152 != 254) {
                        if(_v1152 != 255) {
                            _v1144 =  &(_v1152[_v1144]);
                            _t362 =  &_v1428;
                             *__esp = _t362;
                            mbsinit();
                            if(_t362 == 0) {
                                continue;
                            }
                            break;
                        }
                        goto L33;
                    }
                    _v1144 = _v1144 + strlen( &(_v1080[_v1144]));
                    break;
L33:
                    _v1144 = _v1144 + 1;
                    break;
                }
L35:
                _v1156 = _v1144;
                _v1160 = _v1120 - _v1156;
                _v1164 = ( !(_v1160 >> 31) & _v1160) + _v1156;
                if(_v1164 < maxsize - _v1072) {
                    if(_v1076 != 0) {
                        if(_v1096 == 0 && _v1160 > 0) {
                            if(_v1088 != 48) {
                                memset(_v1076, 32, _v1160);
                                _v1076 = _v1076 + _v1160;
                            } else {
                                memset(_v1076, 48, _v1160);
                                _v1076 = _v1076 + _v1160;
                            }
                        }
                        if(_v1058 == 0) {
                            if(_v1059 == 0) {
                                memcpy(_v1076, _v1080, _v1156);
                            } else {
                                memcpy_uppcase(_v1076, _v1080, _v1156);
                            }
                        } else {
                            memcpy_lowcase(_v1076, _v1080, _v1156);
                        }
                        _v1076 = _v1076 + _v1156;
                    }
                    _v1072 = _v1072 + _v1164;
                    _v1080 =  &(_v1080[_v1144 - 1]);
                    goto L92;
                }
                _v1564 = 0;
                goto L98;
            } else {
L16:
                _v1132 = 1;
                _v1136 = _v1120 - _v1132;
                _v1140 = ( !(_v1136 >> 31) & _v1136) + _v1132;
                if(_v1140 < maxsize - _v1072) {
                    if(_v1076 != 0) {
                        if(_v1096 == 0 && _v1136 > 0) {
                            if(_v1088 != 48) {
                                memset(_v1076, 32, _v1136);
                                _v1076 = _v1076 + _v1136;
                            } else {
                                memset(_v1076, 48, _v1136);
                                _v1076 = _v1076 + _v1136;
                            }
                        }
                         *_v1076 =  *_v1080 & 255 & 4294967295;
                        _v1076 = _v1076 + _v1132;
                    }
                    _v1072 = _v1072 + _v1140;
L92:
                    _v1080 =  &(_v1080[1]);
                    continue;
                } else {
                    _v1564 = 0;
                }
L98:
                _t360 = _v1564;
                if(_t501 == 0) {
                    return _t360;
                }
                __stack_chk_fail();
                return _t360;
            }
        }
        if(_v1568 >= 38) {
            goto L16;
        }
        if(_v1568 > 35) {
            if(_v1568 == 37) {
                while(1) {
                    _v1080 =  &(_v1080[1]);
                    _v1560 =  *_v1080 & 255 & 4294967295;
                    if(_v1560 == 48) {
                        goto L57;
                    } else {
                        goto L51;
                    }
                }
            } else {
            }
            goto L26;
        }
        if(_v1568 >= 32 || _v1568 - 8 <= 5) {
            goto L16;
        }
        goto L26;
    }
}

int iso_week_days(int yday, int wday)
{// addr = 0x0805865E
    int big_enough_multiple_of_7;
    intOrPtr _v12;
    signed int _v28;
    signed int _v32;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t22;
    signed int _t35;

    _v12 = 378;
    _t35 = yday - wday + 4 + _v12;
    _v32 = -1840700269;
    _v28 = ((_v32 * _t35 >> 32) + _t35 >> 2) - (_t35 >> 31);
    _v28 = _t35 - (_v28 << 3) - _v28;
    return yday - _v28 + 3;
}

size_t nstrftime(char* s, size_t maxsize, const char* format, const struct tm* tp, int ut, int ns)
{// addr = 0x080586BB
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;

    return strftime_case_(0, s, maxsize, format, tp, ut, ns);
}

char* umaxtostr(uintmax_t i, char* buf)
{// addr = 0x080586FC
    char* p;
    char* _v8;
    signed int _v24;
    signed int _v28;
    _unknown_ _v32;
    _unknown_ _v36;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t27;
    _unknown_ _t42;
    signed int _t45;

    _v28 = i;
    _v24 = buf;
    _v8 = _a12 + 20;
     *_v8 = 0;
    while(1) {
L1:
        _v8 = _v8 - 1;
         *_v8 = L0805E1C0(_v28, _v24, 10, 0) + 48 & 4294967295;
        _t45 = _v24;
        _v28 = L0805E090(_v28, _t45, 10, 0);
        _v24 = _t45;
        if((_v24 | _v28) == 0) {
            break;
        }
    }
    return _v8;
}

int rpl_vfprintf(FILE* fp, const char* format, va_list args)
{// addr = 0x08058788
    char[1999] buf;
    char* output;
    size_t len;
    size_t lenbuf;
    int saved_errno;
    intOrPtr _v8;
    char _v2008;
    void* _v2012;
    int _v2016;
    unsigned int _v2020;
    int _v2024;
    FILE* _v2040;
    const char* _v2044;
    char* _v2048;
    int _v2052;
    _unknown_ _v2064;
    _unknown_ _v2068;
    _unknown_ _v2072;
    _unknown_ __ebp;
    _unknown_ _t46;
    int _t56;
    int _t58;
    _unknown_ _t65;
    _unknown_ _t71;

    _v2040 = fp;
    _v2044 = format;
    _v2048 = args;
    _v8 =  *gs:0x14];
    _v2020 = 2000;
    _v2012 = vasnprintf( &_v2008,  &_v2020, _v2044, _v2048);
    _v2016 = _v2020;
    __eflags = _v2012;
    if(__eflags != 0) {
        _t56 = fwrite(_v2012, 1, _v2016, _v2040);
        __eflags = _t56 - _v2016;
        if(_t56 >= _v2016) {
            __eflags = _v2016;
            if(__eflags >= 0) {
                _v2052 = _v2016;
            } else {
                 *(__errno_location()) = 75;
                fseterr(_v2040);
                _v2052 = -1;
            }
        } else {
            __eflags = _v2012 -  &_v2008;
            if(__eflags != 0) {
                _v2024 =  *(__errno_location());
                free(_v2012);
                 *(__errno_location()) = _v2024;
            }
            _v2052 = -1;
        }
    } else {
        fseterr(_v2040);
        _v2052 = -1;
    }
    _t58 = _v2052;
    if(__eflags == 0) {
        return _t58;
    }
    __stack_chk_fail();
    return _t58;
}

_Unknown_base* xnmalloc(size_t n, size_t s)
{// addr = 0x080588F0
    _unknown_ __ebp;
    _unknown_ _t10;
    _unknown_ _t15;
    _unknown_ _t16;

    if(-1 / s >= n) {
        return xmalloc(n * s);
    }
    xalloc_die();
    return xmalloc(n * s);
}

_Unknown_base* xnrealloc(_Unknown_base* p, size_t n, size_t s)
{// addr = 0x0805891E
    _unknown_ _v24;
    _unknown_ __ebp;
    _unknown_ _t12;
    _unknown_ _t18;
    _unknown_ _t19;

    if(-1 / s >= n) {
        return xrealloc(p, n * s);
    }
    xalloc_die();
    return xrealloc(p, n * s);
}

_Unknown_base* x2nrealloc(_Unknown_base* p, size_t* pn, size_t s)
{// addr = 0x08058953
    size_t n;
    unsigned int _v8;
    _unknown_ _v40;
    _unknown_ __ebp;
    _unknown_ _t35;
    _unknown_ _t45;
    signed int _t46;
    _unknown_ _t48;
    _unknown_ _t49;
    _unknown_ _t51;
    _unknown_ _t52;

    _v8 =  *pn;
    if(p != 0) {
        if(-1431655766 / s <= _v8) {
            xalloc_die();
        }
        _v8 = _v8 + (_v8 + 1 >> 1);
    } else {
        if(_v8 == 0) {
            _t46 = 64 / s;
            _v8 = _t46;
            _v8 = _v8 + (_t46 & 4294967295 & );
        }
    }
     *pn = _v8;
    return xrealloc(p, _v8 * s);
}

char* xcharalloc(size_t n)
{// addr = 0x080589CE
    _unknown_ __ebp;

    return xmalloc(n);
}

_Unknown_base* xmalloc(size_t n)
{// addr = 0x080589E1
    _Unknown_base* p;
    void* _v8;
    _unknown_ __ebp;

    _v8 = malloc(n);
    if(_v8 != 0) {
        return _v8;
    }
    if(n == 0) {
        return _v8;
    }
    xalloc_die();
    return _v8;
}

_Unknown_base* xrealloc(_Unknown_base* p, size_t n)
{// addr = 0x08058A0B
    _unknown_ _v8;
    _unknown_ __ebp;

    p = realloc(p, n);
    if(p != 0) {
        return p;
    }
    if(n == 0) {
        return p;
    }
    xalloc_die();
    return p;
}

_Unknown_base* x2realloc(_Unknown_base* p, size_t* pn)
{// addr = 0x08058A3C
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return x2nrealloc(p, pn, 1);
}

_Unknown_base* xzalloc(size_t s)
{// addr = 0x08058A5E
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return memset(xmalloc(s), 0, s);
}

_Unknown_base* xcalloc(size_t n, size_t s)
{// addr = 0x08058A8A
    _Unknown_base* p;
    void* _v8;
    _unknown_ _v24;
    _unknown_ __ebp;

    _v8 = calloc(n, s);
    if(_v8 != 0) {
        return _v8;
    }
    xalloc_die();
    return _v8;
}

_Unknown_base* xmemdup(* p, size_t s)
{// addr = 0x08058AB5
    _unknown_ _v20;
    _unknown_ _v24;
    _unknown_ __ebp;

    return memcpy(xmalloc(s), p, s);
}

char* xstrdup(const char* string)
{// addr = 0x08058AE0
    _unknown_ _v8;
    _unknown_ __ebp;

    return xmemdup(string, strlen(string) + 1);
}

xstrtol_error(union strtol_error err, int opt_idx, char c, const struct option* long_options, const char* arg, int exit_status)
{// addr = 0x08058B08
    const char* hyphens;
    const char* msgid;
    const char* option;
    char[1] option_buffer;
    int _v5;
    char _v6;
    intOrPtr _v12;
    char* _v16;
    char* _v20;
    signed char _v24;
    union strtol_error _v28;
    const char* _v40;
    char* _v44;
    intOrPtr _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __ebp;
    char* _t43;
    _unknown_ _t51;

    _v24 = c & 4294967295;
    _v12 = 134618868;
    _v28 = err;
    if(_v28 > 3) {
        if(_v28 != 4) {
L5:
            abort();
        }
        _v16 = "invalid %s%s argument `%s'";
L9:
        if(opt_idx >= 0) {
            _v20 =  *(long_options + (opt_idx << 4));
        } else {
            _v12 = _v12 +  ~opt_idx;
            _v6 = _v24 & 255 & 4294967295;
            _v5 = 0;
            _v20 =  &_v6;
        }
        _t43 = gettext(_v16);
        _v40 = arg;
        _v44 = _v20;
        _v48 = _v12;
        error(exit_failure, 0, _t43);
        return;
    }
    if(_v28 >= 2) {
        _v16 = "invalid suffix in %s%s argument `%s'";
    } else {
        if(_v28 == 1) {
            _v16 = "%s%s argument `%s' too large";
        } else {
            goto L5;
        }
    }
    goto L9;
}

xstrtol_fatal(union strtol_error err, int opt_idx, char c, const struct option* long_options, const char* arg)
{// addr = 0x08058BC6
    signed int* _v0;
    char _v8;
    intOrPtr _v12;
    _unknown_ _v24;
    _unknown_ _v28;
    _unknown_ _v32;
    signed int _v36;
    intOrPtr* _v40;
    signed int _v60;
    _unknown_ __ebp;
    _unknown_ _t36;
    _unknown_ _t38;
    _unknown_ _t48;
    _unknown_ _t49;
    _unknown_ _t53;
    _unknown_ _t54;

    _v8 = c & 4294967295;
    xstrtol_error(err, opt_idx, _v8, long_options, arg, exit_failure);
    abort();
    _push(_t53);
    __esp = __esp - 12;
    _v60 = _v36;
    if(-1 / _v60 >=  *_v40) {
         *_v0 =  *_v0 * err;
        _v12 = 0;
        return _v12;
    }
     *_v0 = -1;
    _v12 = 1;
    return _v12;
}

strtol_error bkm_scale(long unsigned int* x, int scale_factor)
{// addr = 0x08058C08
    union strtol_error _v8;
    int _v16;
    _unknown_ __ebp;
    _unknown_ _t18;
    _unknown_ _t27;
    _unknown_ _t28;

    _v16 = scale_factor;
    if(-1 / _v16 >=  *x) {
         *x =  *x * scale_factor;
        _v8 = 0;
        return _v8;
    }
     *x = -1;
    _v8 = 1;
    return _v8;
}

strtol_error bkm_scale_by_power(long unsigned int* x, int base, int power)
{// addr = 0x08058C5A
    strtol_error err;
    signed int _v8;
    _unknown_ _v24;
    _unknown_ __ebp;
    signed int _t13;

    _t13 = __eax;
    _v8 = 0;
    while(1) {
        power = power - 1;
        if((_t13 & 4294967295) == 0) {
            break;
        }
        _t13 = bkm_scale(x, base);
        _v8 = _v8 | _t13;
    }
    return _v8;
}

strtol_error xstrtoul(const char* s, char** ptr, int strtol_base, long unsigned int* val, const char* valid_suffixes)
{// addr = 0x08058C92
    char* t_ptr;
    char** p;
    long unsigned int tmp;
    strtol_error err;
    const char* q;
    unsigned char ch;
    int base;
    int suffixes;
    strtol_error overflow;
    signed int _v5;
    char _v12;
    char** _v16;
    long unsigned int _v20;
    signed int _v24;
    char* _v28;
    intOrPtr _v32;
    long unsigned int _v36;
    signed int _v56;
    signed int _v60;
    char** _v64;
    intOrPtr _v68;
    char* _v80;
    intOrPtr _v84;
    char* _v88;
    _unknown_ __ebp;
    signed int _t99;
    _unknown_ _t137;
    _unknown_ _t168;

    _v24 = 0;
    if(strtol_base >= 0 || strtol_base > 36) {
        _v80 = "xstrtoul";
        _v84 = 83;
        _v88 = "xstrtol.c";
         *__esp = "0 <= strtol_base && strtol_base <= 36";
        __assert_fail();
    }
    if(ptr != 0) {
        _v64 = ptr;
    } else {
        _v64 =  &_v12;
    }
    _v16 = _v64;
    _v28 = s;
    _t99 =  *_v28 & 255;
    _v5 = _t99 & 4294967295;
    while(1) {
        __ctype_b_loc();
        if(( *( *_t99 + (_v5 & 255) + (_v5 & 255)) & 65535 & 4294967295 &  & 8192) == 0) {
            break;
        } else {
            _v28 =  &(_v28[1]);
            _t99 =  *_v28 & 255;
            _v5 = _t99 & 4294967295;
            continue;
        }
    }
    if(_v5 == 45) {
        _v60 = 4;
        return _v60;
    }
     *(__errno_location()) = 0;
    _v20 = strtoul(s, _v16, strtol_base);
    if( *_v16 != s) {
        if( *(__errno_location()) != 0) {
            if( *(__errno_location()) != 34) {
                _v60 = 4;
                return _v60;
            }
            _v24 = 1;
        }
L21:
        if(valid_suffixes != 0) {
            if(( *( *_v16) & 255 & 4294967295) == 0) {
L37:
                 *val = _v20;
                _v60 = _v24;
                return _v60;
            }
            goto L24;
            return _v60;
        }
        goto L22;
L24:
        _v32 = 1024;
        _v36 = 1;
        if(strchr(valid_suffixes,  *( *_v16) & 255 & 4294967295) != 0) {
            if(strchr(valid_suffixes, 48) == 0) {
L34:
                _v68 = ( *( *_v16) & 255 & 4294967295) - 66;
                if(_v68 > 53) {
                     *val = _v20;
                    _v60 = _v24 | 2;
                    return _v60;
                }
                goto L35;
            }
            goto L27;
L35:
            goto __eax;
        }
         *val = _v20;
        _v60 = _v24 | 2;
        return _v60;
L27:
        _v56 = ( *_v16)[1] & 255 & 4294967295;
        if(_v56 == 68) {
L33:
            _v32 = 1000;
            _v36 = _v36 + 1;
            goto L34;
        }
        if(_v56 == 105) {
            if((( *_v16)[2] & 255 & 4294967295) == 66) {
                _v36 = _v36 + 2;
            }
            goto L34;
        }
        if(_v56 == 66) {
            goto L33;
        }
        goto L34;
    } else {
        if(valid_suffixes == 0 || ( *( *_v16) & 255 & 4294967295) == 0) {
L16:
            _v60 = 4;
            return _v60;
        } else {
            if(strchr(valid_suffixes,  *( *_v16) & 255 & 4294967295) == 0) {
                goto L16;
            } else {
                _v20 = 1;
            }
            goto L21;
        }
    }
L22:
     *val = _v20;
    _v60 = _v24;
    return _v60;
}

fseterr(FILE* fp)
{// addr = 0x08059078
    _unknown_ __ebp;

    fp->_flags = fp->_flags | 32;
    return;
}

char* xstrndup(const _None* string, size_t n)
{// addr = 0x0805908C
    char* s;
    const _None* _v8;
    unsigned int _v24;
    _unknown_ __ebp;
    const _None* _t8;

    _v24 = n;
    _t8 = string;
     *__esp = _t8;
    strndup();
    _v8 = _t8;
    if(_v8 != 0) {
        return _v8;
    }
    xalloc_die();
    return _v8;
}

strtol_error bkm_scale(uintmax_t* x, int scale_factor)
{// addr = 0x080590B8
    long long unsigned int _v24;
    long long unsigned int _v28;
    signed int _v32;
    intOrPtr _v36;
    union strtol_error _v40;
    _unknown_ _v48;
    _unknown_ _v52;
    _unknown_ _v56;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t31;
    signed int _t32;
    uintmax_t* _t34;
    uintmax_t* _t35;
    signed int _t36;
    uintmax_t* _t40;
    signed int _t43;
    uintmax_t* _t44;
    _unknown_ _t45;
    signed int _t47;

    _t32 = scale_factor;
    _t47 = _t32 >> 31;
    _v36 = L0805E090(-1, -1, _t32, _t47);
    _v32 = _t47;
    _t34 = x;
    _v28 =  *_t34;
    _v24 = _t34[0];
    if(_v32 <= _v24 && (_v32 < _v24 || _v36 < _v28)) {
        _t40 = x;
         *_t40 = -1;
        _t40[0] = -1;
        _v40 = 1;
        return _v40;
    }
    _t35 = x;
    _t43 =  *_t35;
    _t36 = scale_factor;
    _t44 = x;
     *_t44 = _t36 * _t43;
    _t44[0] = _t35[0] * _t36 + (_t36 >> 31) * _t43 + (_t36 * _t43 >> 32);
    _v40 = 0;
    return _v40;
}

strtol_error bkm_scale_by_power(uintmax_t* x, int base, int power)
{// addr = 0x08059166
    strtol_error err;
    signed int _v8;
    _unknown_ _v24;
    _unknown_ __ebp;
    signed int _t13;

    _t13 = __eax;
    _v8 = 0;
    while(1) {
        power = power - 1;
        if((_t13 & 4294967295) == 0) {
            break;
        }
        _t13 = bkm_scale(x, base);
        _v8 = _v8 | _t13;
    }
    return _v8;
}

strtol_error xstrtoumax(const char* s, char** ptr, int strtol_base, uintmax_t* val, const char* valid_suffixes)
{// addr = 0x0805919E
    char* t_ptr;
    char** p;
    uintmax_t tmp;
    strtol_error err;
    const char* q;
    unsigned char ch;
    int base;
    int suffixes;
    strtol_error overflow;
    signed int _v5;
    char _v12;
    char** _v16;
    signed int _v20;
    char* _v24;
    intOrPtr _v28;
    signed int _v32;
    long long unsigned int _v40;
    long long unsigned int _v44;
    signed int _v56;
    signed int _v60;
    char** _v64;
    intOrPtr _v68;
    char* _v80;
    int _v84;
    char** _v88;
    _unknown_ __ebp;
    signed int _t109;
    const char* _t120;
    _unknown_ _t146;
    uintmax_t* _t171;
    uintmax_t* _t172;
    uintmax_t* _t173;
    uintmax_t* _t174;
    long long unsigned int _t176;
    _unknown_ _t181;

    _v20 = 0;
    if(strtol_base >= 0 || strtol_base > 36) {
        _v80 = "xstrtoumax";
        _v84 = 83;
        _v88 = "xstrtol.c";
         *__esp = "0 <= strtol_base && strtol_base <= 36";
        __assert_fail();
    }
    if(ptr != 0) {
        _v64 = ptr;
    } else {
        _v64 =  &_v12;
    }
    _v16 = _v64;
    _v24 = s;
    _t109 =  *_v24 & 255;
    _v5 = _t109 & 4294967295;
    while(1) {
        __ctype_b_loc();
        _t176 =  *_t109;
        if(( *(_t176 + (_v5 & 255) + (_v5 & 255)) & 65535 & 4294967295 &  & 8192) == 0) {
            break;
        } else {
            _v24 =  &(_v24[1]);
            _t109 =  *_v24 & 255;
            _v5 = _t109 & 4294967295;
            continue;
        }
    }
    if(_v5 == 45) {
        _v60 = 4;
        return _v60;
    }
     *(__errno_location()) = 0;
    _v84 = strtol_base;
    _v88 = _v16;
    _t120 = s;
     *__esp = _t120;
    strtoumax();
    _v44 = _t120;
    _v40 = _t176;
    if( *_v16 != s) {
        if( *(__errno_location()) != 0) {
            if( *(__errno_location()) != 34) {
                _v60 = 4;
                return _v60;
            }
            _v20 = 1;
        }
L21:
        if(valid_suffixes != 0) {
            if(( *( *_v16) & 255 & 4294967295) == 0) {
L37:
                _t171 = val;
                 *_t171 = _v44;
                _t171[0] = _v40;
                _v60 = _v20;
                return _v60;
            }
            goto L24;
            return _v60;
        }
        goto L22;
L24:
        _v28 = 1024;
        _v32 = 1;
        if(strchr(valid_suffixes,  *( *_v16) & 255 & 4294967295) != 0) {
            if(strchr(valid_suffixes, 48) == 0) {
L34:
                _v68 = ( *( *_v16) & 255 & 4294967295) - 66;
                if(_v68 > 53) {
                    _t172 = val;
                     *_t172 = _v44;
                    _t172[0] = _v40;
                    _v60 = _v20 | 2;
                    return _v60;
                }
                goto L35;
            }
            goto L27;
L35:
            goto __eax;
        }
        _t173 = val;
         *_t173 = _v44;
        _t173[0] = _v40;
        _v60 = _v20 | 2;
        return _v60;
L27:
        _v56 = ( *_v16)[1] & 255 & 4294967295;
        if(_v56 == 68) {
L33:
            _v28 = 1000;
            _v32 = _v32 + 1;
            goto L34;
        }
        if(_v56 == 105) {
            if((( *_v16)[2] & 255 & 4294967295) == 66) {
                _v32 = _v32 + 2;
            }
            goto L34;
        }
        if(_v56 == 66) {
            goto L33;
        }
        goto L34;
    } else {
        if(valid_suffixes == 0 || ( *( *_v16) & 255 & 4294967295) == 0) {
L16:
            _v60 = 4;
            return _v60;
        } else {
            if(strchr(valid_suffixes,  *((signed char*)( *_v16)) & 255 & 4294967295) == 0) {
                goto L16;
            } else {
                _v44 = 1;
                _v40 = 0;
            }
            goto L21;
        }
    }
L22:
    _t174 = val;
     *_t174 = _v44;
    _t174[0] = _v40;
    _v60 = _v20;
    return _v60;
}

int close_stream(FILE* stream)
{// addr = 0x080595A4
    _Bool some_pending;
    _Bool prev_fail;
    _Bool fclose_fail;
    signed int _v5;
    signed int _v6;
    signed int _v7;
    int _v24;
    _unknown_ __ebp;
    signed int _t22;

    _t22 = stream;
     *__esp = _t22;
    __fpending();
    _v5 = _t22 & 4294967295;
    _v6 = ferror_unlocked(stream) & 4294967295;
    _v7 = fclose(stream) & 4294967295;
    if(_v6 != 0 || ((_v7 & 255 ^ 1) & 4294967295) == 0 && (_v5 != 0 ||  *(__errno_location()) != 9)) {
        if(((_v7 & 255 ^ 1) & 4294967295) != 0) {
             *(__errno_location()) = 0;
        }
        _v24 = -1;
        return _v24;
    }
    _v24 = 0;
    return _v24;
}

int is_infinitel(long double x)
{// addr = 0x08059634
    int _v8;
    intOrPtr _v20;
    signed int _v24;
    _unknown_ __ebp;
    signed int _t13;
    signed int _t18;

    __edx = _a8;
     *__esp = x;
    _v24 = __edx;
    _v20 = _a12;
    _t13 = rpl_isnanl();
    if(_t13 != 0) {
L4:
        _v8 = 1;
        return _v8;
    }
    asm("fld tword [ebp+0x8]");
    asm("fld st0, st0");
    asm("faddp st1, st0");
    asm("fld tword [ebp+0x8]");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    _t18 = (_t13 & __edx ^ 1) & 4294967295;
    if(_t18 != 0) {
        goto L5;
    }
    asm("fld tword [ebp+0x8]");
    asm("fldz ");
    asm("fxch st0, st1");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(_t18 != 0 || _t18 != 0) {
        goto L4;
    }
L5:
    _v8 = 0;
    return _v8;
}

char* vasnprintf(char* resultbuf, size_t* lengthp, const char* format, va_list args)
{// addr = 0x0805969A
    char_directives d;
    arguments a;
    size_t buf_neededlength;
    char* buf;
    char* buf_malloced;
    const char* cp;
    size_t i;
    char_directive* dp;
    char* result;
    size_t allocated;
    size_t length;
    size_t buf_memsize;
    size_t n;
    size_t augmented_length;
    size_t memory_size;
    char* memory;
    size_t augmented_length;
    size_t memory_size;
    char* memory;
    int flags;
    int has_width;
    size_t width;
    int has_precision;
    size_t precision;
    size_t tmp_length;
    char[699] tmpbuf;
    char* tmp;
    char* pad_ptr;
    char* p;
    int arg;
    const char* digitp;
    int arg;
    const char* digitp;
    size_t tmp_memsize;
    long double arg;
    int sign;
    fpucw_t oldcw;
    fpucw_t _cw;
    fpucw_t _ncw;
    fpucw_t _ncw;
    size_t pad;
    char* end;
    char* q;
    char* q;
    size_t count;
    size_t n;
    size_t memory_size;
    char* memory;
    arg_type type;
    int flags;
    char* fbp;
    unsigned int prefix_count;
    int[1] prefixes;
    size_t n;
    size_t n;
    size_t memory_size;
    char* memory;
    int count;
    int retcount;
    size_t maxlen;
    int arg;
    unsigned int arg;
    int arg;
    unsigned int arg;
    int arg;
    unsigned int arg;
    long int arg;
    long unsigned int arg;
    long long int arg;
    long long unsigned int arg;
    double arg;
    long double arg;
    int arg;
    wint_t arg;
    const char* arg;
    const wchar_t* arg;
    _Unknown_base* arg;
    size_t bigger_need;
    size_t memory_size;
    char* memory;
    size_t n;
    size_t memory_size;
    char* memory;
    size_t memory_size;
    char* memory;
    char* memory;
    _unknown_ _v16;
    intOrPtr _v32;
    _unknown_ _v732;
    _unknown_ _v734;
    unsigned int _v740;
    int _v744;
    unsigned int _v748;
    const char* _v752;
    unsigned int _v756;
    void* _v760;
    unsigned int _v764;
    unsigned int _v768;
    unsigned int _v772;
    int _v776;
    _unknown_ _v780;
    _unknown_ _v784;
    _unknown_ _v788;
    _unknown_ _v792;
    _unknown_ _v796;
    _unknown_ _v800;
    _unknown_ _v804;
    _unknown_ _v808;
    _unknown_ _v812;
    _unknown_ _v816;
    _unknown_ _v820;
    _unknown_ _v824;
    _unknown_ _v828;
    _unknown_ _v832;
    _unknown_ _v836;
    _unknown_ _v840;
    _unknown_ _v844;
    _unknown_ _v848;
    _unknown_ _v852;
    _unknown_ _v856;
    _unknown_ _v860;
    _unknown_ _v864;
    _unknown_ _v868;
    _unknown_ _v872;
    _unknown_ _v876;
    _unknown_ _v880;
    _unknown_ _v884;
    _unknown_ _v888;
    _unknown_ _v892;
    _unknown_ _v896;
    _unknown_ _v900;
    _unknown_ _v904;
    _unknown_ _v908;
    _unknown_ _v912;
    _unknown_ _v916;
    _unknown_ _v924;
    _unknown_ _v932;
    _unknown_ _v936;
    _unknown_ _v940;
    _unknown_ _v944;
    _unknown_ _v948;
    _unknown_ _v1004;
    _unknown_ _v1008;
    _unknown_ _v1012;
    _unknown_ _v1016;
    _unknown_ _v1020;
    _unknown_ _v1024;
    _unknown_ _v1028;
    _unknown_ _v1032;
    _unknown_ _v1036;
    struct  _v1044;
    _unknown_ _v1092;
    _unknown_ _v1096;
    _unknown_ _v1100;
    struct  _v1132;
    int _v1136;
    size_t* _v1140;
    const char* _v1144;
    char* _v1148;
    _unknown_ _v1152;
    _unknown_ _v1156;
    _unknown_ _v1160;
    _unknown_ _v1164;
    _unknown_ _v1168;
    _unknown_ _v1172;
    _unknown_ _v1176;
    _unknown_ _v1180;
    _unknown_ _v1184;
    _unknown_ _v1188;
    _unknown_ _v1192;
    _unknown_ _v1196;
    _unknown_ _v1200;
    _unknown_ _v1204;
    _unknown_ _v1208;
    _unknown_ _v1212;
    _unknown_ _v1216;
    _unknown_ _v1220;
    _unknown_ _v1224;
    _unknown_ _v1228;
    signed int _v1232;
    unsigned int _v1236;
    _unknown_ _v1240;
    _unknown_ _v1248;
    char _v1336;
    _unknown_ _v1360;
    _unknown_ _v1364;
    _unknown_ _v1368;
    _unknown_ __ebx;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    _unknown_ _t973;
    int _t980;
    _unknown_ _t985;
    unsigned int _t988;
    _unknown_ _t990;
    _unknown_ _t1000;
    _unknown_ _t1005;
    _unknown_ _t1010;
    _unknown_ _t1012;
    _unknown_ _t1021;
    _unknown_ _t1025;
    _unknown_ _t1027;
    _unknown_ _t1036;
    _unknown_ _t1046;
    _unknown_ _t1047;
    _unknown_ _t1050;
    _unknown_ _t1052;
    _unknown_ _t1055;
    _unknown_ _t1068;
    _unknown_ _t1079;
    _unknown_ _t1080;
    _unknown_ _t1082;
    _unknown_ _t1083;
    _unknown_ _t1089;
    _unknown_ _t1091;
    _unknown_ _t1094;
    _unknown_ _t1100;
    _unknown_ _t1104;
    _unknown_ _t1114;
    _unknown_ _t1118;
    _unknown_ _t1120;
    _unknown_ _t1122;
    _unknown_ _t1141;
    _unknown_ _t1153;
    _unknown_ _t1157;
    _unknown_ _t1159;
    _unknown_ _t1161;
    _unknown_ _t1176;
    _unknown_ _t1194;
    _unknown_ _t1195;
    _unknown_ _t1197;
    _unknown_ _t1198;
    _unknown_ _t1201;
    _unknown_ _t1211;
    _unknown_ _t1222;
    _unknown_ _t1230;
    _unknown_ _t1233;
    _unknown_ _t1241;
    _unknown_ _t1242;
    _unknown_ _t1260;
    _unknown_ _t1270;
    _unknown_ _t1281;
    _unknown_ _t1283;
    _unknown_ _t1286;
    _unknown_ _t1287;
    _unknown_ _t1289;
    _unknown_ _t1290;
    _unknown_ _t1305;
    _unknown_ _t1308;
    _unknown_ _t1311;
    _unknown_ _t1315;
    _unknown_ _t1316;
    _unknown_ _t1317;
    _unknown_ _t1326;
    _unknown_ _t1330;
    _unknown_ _t1345;
    _unknown_ _t1354;
    _unknown_ _t1379;
    _unknown_ _t1381;
    _unknown_ _t1387;
    _unknown_ _t1392;
    _unknown_ _t1397;
    _unknown_ _t1404;
    _unknown_ _t1409;
    _unknown_ _t1420;
    _unknown_ _t1429;
    _unknown_ _t1430;
    _unknown_ _t1440;
    _unknown_ _t1446;
    _unknown_ _t1457;
    _unknown_ _t1459;
    _unknown_ _t1461;
    _unknown_ _t1463;
    _unknown_ _t1465;
    _unknown_ _t1467;
    _unknown_ _t1469;
    _unknown_ _t1471;
    _unknown_ _t1478;
    _unknown_ _t1479;
    _unknown_ _t1480;
    _unknown_ _t1481;
    _unknown_ _t1500;
    _unknown_ _t1508;
    _unknown_ _t1520;
    _unknown_ _t1532;
    _unknown_ _t1554;
    _unknown_ _t1558;
    _unknown_ _t1590;
    _unknown_ _t1594;
    _unknown_ _t1602;
    _unknown_ _t1610;
    _unknown_ _t1612;
    _unknown_ _t1614;
    _unknown_ _t1627;
    _unknown_ _t1642;
    _unknown_ _t1647;

    _v1136 = resultbuf;
    _v1140 = lengthp;
    _v1144 = format;
    _v1148 = args;
    _v32 =  *gs:0x14];
    __eflags = printf_parse(_v1144,  &_v1132,  &_v1044);
    if(__eflags >= 0) {
        _t980 = printf_fetchargs(_v1148,  &_v1044);
        __eflags = _t980;
        if(_t980 >= 0) {
            _v740 = xsum4(7, _v1132.max_width_length, _v1132.max_precision_length, 6);
            __eflags = _v740 - 3999;
            if(_v740 > 3999) {
                _v776 = _v740;
                __eflags = _v776 - 255;
                if(_v776 == 255) {
L344:
                    free(_v1132.dir);
                    __eflags = _v1044.arg;
                    if(_v1040 != 0) {
L345:
                        free(_v1044.arg);
                    }
                     *(__errno_location()) = 12;
                    _v1236 = 0;
                    goto L347;
                }
            } else {
                __esp = __esp - (_v740 + 15 + 15 >> 4 << 4);
                _v1232 =  &_v1336;
                _v1232 = _v1232 + 15 >> 4 << 4;
                _v744 = _v1232;
                _v748 = 0;
L11:
                __eflags = _v1136;
                if(_v1136 == 0) {
                    _v764 = 0;
                    _v768 = 0;
                } else {
                    _v764 = _v1136;
                    _v768 =  *_v1140;
                }
                _v772 = 0;
                _v752 = _v1144;
                _v756 = 0;
                _v760 = _v1132.dir;
                while(1) {
                    __eflags =  *_v760 - _v752;
                    if( *_v760 == _v752) {
                        goto L36;
                    } else {
                        goto L16;
                    }
                }
            }
L9:
            _v744 = malloc(_v776);
            __eflags = _v744;
            if(_v744 == 0) {
                goto L344;
            } else {
                _v748 = _v744;
                goto L11;
            }
            goto L345;
        } else {
            free(_v1132.dir);
            __eflags = _v1044.arg;
            if(_v1040 != 0) {
                free(_v1044.arg);
            }
             *(__errno_location()) = 22;
            _v1236 = 0;
        }
    } else {
        _v1236 = 0;
    }
L347:
    _t988 = _v1236;
    if(__eflags == 0) {
        return _t988;
    }
    __stack_chk_fail();
    return _t988;
}

size_t xsum4(size_t size1, size_t size2, size_t size3, size_t size4)
{// addr = 0x0805CAD5
    _unknown_ _v8;
    _unknown_ __ebp;

    return xsum(xsum(xsum(size1, size2), size3), size4);
}

size_t xmax(size_t size1, size_t size2)
{// addr = 0x0805CB11
    unsigned int _v8;
    unsigned int _v12;
    _unknown_ __ebp;

    _v12 = size2;
    _v8 = size1;
    if(_v8 >= _v12) {
        return _v8;
    }
    _v8 = _v12;
    return _v8;
}

size_t xsum(size_t size1, size_t size2)
{// addr = 0x0805CB36
    size_t sum;
    unsigned int _v8;
    unsigned int _v24;
    _unknown_ __ebp;

    _v8 = size1 + size2;
    if(_v8 < size1) {
        _v24 = -1;
        return _v24;
    }
    _v24 = _v8;
    return _v24;
}

int rpl_isnanl(long double x)
{// addr = 0x0805CB64
    memory_double m;
    unsigned int exponent;
    signed int _v16;
    signed int _v20;
    unsigned int _v24;
    long double _v28;
    signed int _v32;
    _unknown_ __ebp;

    _v28 = x;
    _v24 = _a8;
    _v20 = _a12;
    _v16 = _v20 & 32767;
    if(_v16 != 0) {
        if(_v16 != 32767) {
            _v32 = _v24 >> 31 ^ 1;
            return _v32;
        }
        goto L3;
    }
    _v32 = _v24 >> 31;
    return _v32;
L3:
    _v32 = (_v28 | _v24 ^ -2147483648) & 4294967295 & ;
    return _v32;
}

int printf_fetchargs(va_list args, arguments* a)
{// addr = 0x0805CBD0
    size_t i;
    argument* ap;
    intOrPtr _v12;
    argument* _v16;
    intOrPtr _v28;
    struct  _v32;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t23;

    _v12 = 0;
    _v16 = a->arg;
    if(a->count <= _v12) {
        _v28 = 0;
        return _v28;
    }
    _v32.__val =  *_v16;
    if(_v32 > 22) {
        _v28 = -1;
        return _v28;
    }
L2:
    goto __eax;
}

int printf_parse(const char* format, char_directives* d, arguments* a)
{// addr = 0x0805CE8C
    const char* cp;
    size_t arg_posn;
    size_t d_allocated;
    size_t a_allocated;
    size_t max_width_length;
    size_t max_precision_length;
    char c;
    size_t arg_index;
    char_directive* dp;
    const char* np;
    size_t n;
    const char* np;
    size_t n;
    size_t n;
    size_t memory_size;
    argument* memory;
    size_t width_length;
    const char* np;
    size_t n;
    size_t n;
    size_t memory_size;
    argument* memory;
    size_t precision_length;
    arg_type type;
    int flags;
    size_t n;
    size_t memory_size;
    argument* memory;
    size_t memory_size;
    char_directive* memory;
    signed int _v5;
    const char* _v12;
    argument* _v16;
    signed int _v20;
    unsigned int _v24;
    argument* _v28;
    argument* _v32;
    unsigned int _v36;
    intOrPtr* _v40;
    char* _v44;
    unsigned int _v48;
    char* _v52;
    _unknown_ _v56;
    unsigned int _v60;
    int _v64;
    void* _v68;
    _unknown_ _v72;
    char* _v76;
    _unknown_ _v80;
    unsigned int _v84;
    int _v88;
    void* _v92;
    _unknown_ _v96;
    signed int _v104;
    unsigned int _v136;
    void* _v160;
    signed int _v164;
    signed int _v168;
    _unknown_ _v172;
    _unknown_ _v176;
    void* _v180;
    signed int _v184;
    signed int _v188;
    _unknown_ _v192;
    _unknown_ _v196;
    unsigned int _v200;
    unsigned int _v204;
    intOrPtr _v208;
    _unknown_ _v216;
    _unknown_ __ebp;
    _unknown_ _t587;
    _unknown_ _t590;
    _unknown_ _t591;
    _unknown_ _t593;
    _unknown_ _t651;
    _unknown_ _t654;
    _unknown_ _t860;
    signed int _t866;
    signed int _t886;

    _v12 = format;
    _v16 = 0;
    _v28 = 0;
    _v32 = 0;
    d->count = 0;
    _v20 = 1;
    d->dir = malloc(_v20 * _v20);
    if(d->dir == 0) {
L160:
         *(__errno_location()) = 12;
        _v136 = -1;
        return _v136;
    } else {
        a->count = 0;
        _v24 = 0;
        a->arg = 0;
        while(( *_v12 & 255 & 4294967295) != 0) {
            _v5 =  *_v12 & 255 & 4294967295;
            _v12 =  &(_v12[1]);
            if(_v5 != 37) {
                continue;
            }
            _v36 = -1;
            _v40 = d->dir + d->count * d->count;
             *_v40 = _v12 - 1;
             *(_v40 + 8) = 0;
             *(_v40 + 12) = 0;
             *(_v40 + 16) = 0;
             *(_v40 + 20) = -1;
             *(_v40 + 24) = 0;
             *(_v40 + 28) = 0;
             *(_v40 + 32) = -1;
             *(_v40 + 40) = -1;
            if(( *_v12 & 255 & 4294967295) <= 47) {
                goto L20;
            }
            if(( *_v12 & 255 & 4294967295) > 57) {
                goto L20;
                do {
                    do {
                        do {
                            do {
                                do {
L20:
                                    while(( *_v12 & 255 & 4294967295) == 39) {
                                    }
                                } while(( *_v12 & 255 & 4294967295) == 45);
                            } while(( *_v12 & 255 & 4294967295) == 43);
                        } while(( *_v12 & 255 & 4294967295) == 32);
                    } while(( *_v12 & 255 & 4294967295) == 35);
                } while(( *_v12 & 255 & 4294967295) == 48);
                if(( *_v12 & 255 & 4294967295) != 42) {
                    if(( *_v12 & 255 & 4294967295) <= 47 || ( *_v12 & 255 & 4294967295) > 57) {
                        goto L83;
                    } else {
                         *(_v40 + 12) = _v12;
                        while(( *_v12 & 255 & 4294967295) > 47 && ( *_v12 & 255 & 4294967295) <= 57) {
                            _v12 =  &(_v12[1]);
                        }
                    }
                    goto L84;
                }
                 *(_v40 + 12) = _v12;
                _v12 =  &(_v12[1]);
                 *(_v40 + 16) = _v12;
                if(_v28 == 0) {
                    _v28 = 1;
                }
                if(( *_v12 & 255 & 4294967295) <= 47 || ( *_v12 & 255 & 4294967295) > 57) {
                    if( *(_v40 + 20) != 255) {
L54:
                        _v60 =  *(_v40 + 20);
                        if(_v60 < _v24) {
L70:
                            while(a->count <= _v60) {
                                _t886 = a->count;
                                 *(a->arg + (_t886 << 4)) = 0;
                                a->count = _t886 + 1;
                            }
                        }
                        goto L55;
L83:
                        if(( *_v12 & 255 & 4294967295) != 46) {
L133:
                            _v104 = 0;
                            while(( *_v12 & 255 & 4294967295) != 104) {
                                if(( *_v12 & 255 & 4294967295) != 76) {
                                    if(( *_v12 & 255 & 4294967295) != 108) {
                                        if(( *_v12 & 255 & 4294967295) != 106) {
                                            if(( *_v12 & 255 & 4294967295) == 122 || ( *_v12 & 255 & 4294967295) == 90) {
                                                _v12 =  &(_v12[1]);
                                                continue;
                                            }
                                            if(( *_v12 & 255 & 4294967295) != 116) {
                                                _v5 =  *_v12 & 255 & 4294967295;
                                                _v12 =  &(_v12[1]);
                                                _v208 = _v5 - 37;
                                                if(_v208 > 83) {
                                                    goto L151;
                                                }
                                                goto L148;
                                            }
                                            _v12 =  &(_v12[1]);
                                            continue;
L148:
                                            goto __eax;
                                        }
                                        goto L141;
                                    }
                                    goto L139;
L141:
                                    _v104 = _v104 + 16;
                                    _v12 =  &(_v12[1]);
                                    continue;
                                }
                                _v104 = _v104 | 4;
                                _v12 =  &(_v12[1]);
                                continue;
L139:
                                _v104 = _v104 + 8;
                                _v12 =  &(_v12[1]);
                            }
                        }
L84:
                        _v12 =  &(_v12[1]);
                        if(( *_v12 & 255 & 4294967295) != 42) {
                             *(_v40 + 24) = _v12 - 1;
L129:
                            while(( *_v12 & 255 & 4294967295) > 47 && ( *_v12 & 255 & 4294967295) <= 57) {
                                goto L128;
                            }
                        }
                         *(_v40 + 24) = _v12 - 1;
                        _v12 =  &(_v12[1]);
                         *(_v40 + 28) = _v12;
                        if(_v32 <= 1) {
                            _v32 = 2;
                        }
                        if(( *_v12 & 255 & 4294967295) <= 47 || ( *_v12 & 255 & 4294967295) > 57) {
                            if( *(_v40 + 32) != 255) {
L106:
                                _v84 =  *(_v40 + 32);
                                if(_v84 < _v24) {
L122:
                                    while(a->count <= _v84) {
                                        _t866 = a->count;
                                         *(a->arg + (_t866 << 4)) = 0;
                                        a->count = _t866 + 1;
                                    }
                                }
                                goto L107;
L126:
                                goto L133;
                            }
                            goto L105;
L107:
                            if(_v24 >= 0) {
                                _v168 = -1;
                            } else {
                                _v168 = _v24 + _v24;
                            }
                            _v24 = _v168;
                            if(_v24 <= _v84) {
                                _v24 = xsum(_v84, 1);
                            }
                            if(_v24 > 268435455) {
                                _v164 = -1;
                            } else {
                                _v164 = _v24 << 4;
                            }
                            _v88 = _v164;
                            if(_v88 == 255) {
L156:
                                if(a->arg != 0) {
L157:
                                    free(a->arg);
                                }
                                if(d->dir != 0) {
                                    free(d->dir);
                                }
                                goto L160;
                            } else {
                                if(a->arg == 0) {
                                    _v160 = malloc(_v88);
                                } else {
                                    _v160 = realloc(a->arg, _v88);
                                }
                                _v92 = _v160;
                                if(_v92 == 0) {
                                    goto L156;
                                }
                                a->arg = _v92;
                                goto L122;
                            }
                        } else {
                            _v76 = _v12;
                            while(( *_v76 & 255 & 4294967295) > 47 && ( *_v76 & 255 & 4294967295) <= 57) {
                                _v76 =  &(_v76[1]);
                            }
                        }
L105:
                         *(_v40 + 32) = _v16;
                        _v16 = _v16 + 1;
                        if( *(_v40 + 32) == 255) {
                            goto L151;
                        }
                        goto L106;
L128:
                        _v12 =  &(_v12[1]);
                        goto L129;
L74:
                        goto L83;
                    }
                    goto L53;
L55:
                    if(_v24 >= 0) {
                        _v188 = -1;
                    } else {
                        _v188 = _v24 + _v24;
                    }
                    _v24 = _v188;
                    if(_v24 <= _v60) {
                        _v24 = xsum(_v60, 1);
                    }
                    if(_v24 > 268435455) {
                        _v184 = -1;
                    } else {
                        _v184 = _v24 << 4;
                    }
                    _v64 = _v184;
                    if(_v64 == 255) {
                        goto L156;
                    } else {
                        if(a->arg == 0) {
                            _v180 = malloc(_v64);
                        } else {
                            _v180 = realloc(a->arg, _v64);
                        }
                        _v68 = _v180;
                        if(_v68 == 0) {
                            goto L156;
                        } else {
                            a->arg = _v68;
                            goto L70;
                        }
                    }
                    goto L157;
                } else {
                    _v52 = _v12;
                    while(( *_v52 & 255 & 4294967295) > 47 && ( *_v52 & 255 & 4294967295) <= 57) {
                        _v52 =  &(_v52[1]);
                    }
                }
L53:
                 *(_v40 + 20) = _v16;
                _v16 = _v16 + 1;
                if( *(_v40 + 20) == 255) {
                    goto L151;
                }
                goto L54;
            } else {
                _v44 = _v12;
            }
            while(( *_v44 & 255 & 4294967295) > 47) {
                if(( *_v44 & 255 & 4294967295) <= 57) {
                    _v44 =  &(_v44[1]);
                    continue;
                }
                if(( *_v44 & 255 & 4294967295) != 36) {
                    goto L20;
                } else {
                    _v48 = 0;
                    _v44 = _v12;
                }
                while(( *_v44 & 255 & 4294967295) > 47) {
                    if(( *_v44 & 255 & 4294967295) <= 57) {
                        _v204 = ( *_v44 & 255 & 4294967295) - 48;
                        if(_v48 > 429496729) {
                            _v200 = -1;
                        } else {
                            _v200 = (_v48 << 2) + _v48 + (_v48 << 2) + _v48;
                        }
                        _v48 = xsum(_v200, _v204);
                        _v44 =  &(_v44[1]);
                        continue;
                    }
                    if(_v48 == 0) {
                        goto L151;
                    }
                    if(_v48 == 255) {
                        goto L151;
                    } else {
                        _v36 = _v48 - 1;
                        _v12 =  &(_v44[1]);
                        goto L20;
                    }
                    goto L152;
                }
            }
        }
    }
}

size_t xsum(size_t size1, size_t size2)
{// addr = 0x0805DCED
    size_t sum;
    unsigned int _v8;
    unsigned int _v24;
    _unknown_ __ebp;

    _v8 = size1 + size2;
    if(_v8 < size1) {
        _v24 = -1;
        return _v24;
    }
    _v24 = _v8;
    return _v24;
}

L0805DD20(signed int _a4, signed int _a8, signed int _a12, signed int _a16)
{
    signed int _v16;
    signed int _v20;
    signed int _v24;
    signed int _v28;
    signed int _v32;
    signed int _v40;
    signed int _v44;
    signed int _v48;
    signed int _v52;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t90;
    signed int _t91;
    signed int _t97;
    signed int _t99;
    signed int _t101;
    _unknown_ _t109;
    _unknown_ _t116;
    signed int _t117;
    _unknown_ _t119;
    signed int _t123;
    signed int _t125;
    _unknown_ _t128;
    signed int _t130;
    _unknown_ _t134;
    _unknown_ _t137;
    _unknown_ _t138;
    _unknown_ _t139;
    _unknown_ _t140;
    _unknown_ _t141;
    _unknown_ _t142;
    _unknown_ _t143;
    _unknown_ _t144;
    _unknown_ _t145;
    signed int _t147;
    signed int _t150;
    signed int _t151;
    signed int _t152;
    _unknown_ _t156;
    _unknown_ _t157;

    _t147 = _a8;
    _t90 = _a12;
    _t130 = _a16;
    _t152 = _a4;
    _v44 = _t90;
    _v40 = _t130;
    _v32 = 0;
    if(_t147 >= 0) {
        _t152 =  ~_t152;
        asm("adc edi, 0x0");
        _t147 =  ~_t147;
        _v32 = -1;
        __eflags = _v40;
        if(_v40 >= 0) {
L2:
            _v24 = _t90;
            _t91 = _t130;
            _v28 = _t152;
            _v52 = _t147;
            if(_t130 != 0) {
                __eflags = _t130 - _v52;
                if(__eflags <= 0) {
L15:
                    asm("bsr edx, edx");
                    _v20 = _t130 ^ 31;
                    if(__eflags != 0) {
L19:
                        _t117 = 32 - _v20;
                        _v48 = _t117;
                        _t150 = _v24 >> (_t117 & 4294967295) | _t91 << (_v20 & 255 & 4294967295);
                        _v16 = _v24 << (_v20 & 255 & 4294967295);
                        _t97 = _v28 >> (_v48 & 255 & 4294967295) | _v52 << (_v20 & 255 & 4294967295);
                        _v48 = _t97 / _t150;
                        _t99 = _v16;
                        __eflags = _t97 % _t150 - _t99 * _v48 >> 32;
                        _t151 = _t99 * _v48;
                        if(__eflags < 0) {
L24:
                            _t123 = _v48 - 1;
                            goto L7;
                        }
                        goto L20;
                    }
                    __eflags = _t91 - _v52;
                    if(_t91 < _v52) {
L18:
                        _t123 = 1;
                        goto L7;
                    }
                    __eflags = _v24 - _v28;
                    if(_v24 > _v28) {
                        goto L6;
                    }
                    goto L18;
L20:
                    if(__eflags == 0) {
                        _t125 = _v20 & 255;
                        __eflags = _v28 << (_t125 & 4294967295) - _t151;
                        if(_v28 << (_t125 & 4294967295) >= _t151) {
                            goto L21;
                        }
                        goto L23;
                    }
L21:
                    _t123 = _v48;
                    goto L7;
L23:
                    goto L24;
                }
                goto L6;
            }
            if(_v24 <= _t147) {
                __eflags = _v24;
                if(_v24 == 0) {
                    _v24 = 1 / _v24;
                }
                _t123 = _v28 / _v24;
L7:
                _t101 = _t123;
                if(_v32 == 0) {
                    return _t101;
                }
                asm("adc edx, 0x0");
                return  ~_t101;
            }
            _t123 = _t152 / _v24;
            goto L7;
L6:
            _t123 = 0;
            goto L7;
        }
L14:
        _v32 =  !_v32;
        _t90 =  ~_v44;
        asm("adc edx, 0x0");
        _t130 =  ~_v40;
        goto L2;
    }
    if(_v40 >= 0) {
        goto L14;
    }
    goto L2;
}

L0805DEB0(signed int _a4, signed int _a8, signed int _a12, signed int _a16)
{
    signed int _v16;
    signed int _v20;
    signed int _v32;
    signed int _v36;
    unsigned int _v40;
    signed int _v44;
    signed int _v48;
    char _v52;
    char* _v56;
    unsigned int _v64;
    signed int _v68;
    unsigned int _v72;
    signed int _v80;
    signed int _v84;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t110;
    _unknown_ _t112;
    signed int _t121;
    signed int _t122;
    signed int _t123;
    _unknown_ _t129;
    _unknown_ _t130;
    _unknown_ _t132;
    _unknown_ _t133;
    _unknown_ _t135;
    unsigned int _t137;
    char* _t149;
    signed int _t152;
    _unknown_ _t157;
    _unknown_ _t164;
    _unknown_ _t167;
    _unknown_ _t168;
    signed int _t169;
    _unknown_ _t170;
    _unknown_ _t171;
    signed int _t174;
    signed int _t175;
    char* _t177;
    signed int _t181;
    signed int _t183;
    signed int* _t185;
    char* _t186;

    _v52 = 0;
    _v80 = _a16;
    _t152 = _a8;
    _v84 = _a12;
    _t110 = _a4;
    _v64 = _v80;
    _v68 = _v84;
    if(_t152 >= 0) {
        _t110 =  ~_t110;
        asm("adc edx, 0x0");
        _t152 =  ~_t152;
        _v52 = -1;
        __eflags = _v80;
        if(_v80 >= 0) {
L2:
            _t137 = _v64;
            _t181 = _t152;
            _v56 =  &_v20;
            _t174 = _v68;
            _v40 = _t110;
            _v36 = _t110;
            _v72 = _t137;
            if(_t137 != 0) {
                __eflags = _v72 - _t152;
                if(__eflags <= 0) {
L16:
                    asm("bsr eax, [ebp-0x44]");
                    _v44 = _t110 ^ 31;
                    if(__eflags != 0) {
L21:
                        _v48 = 32 - _v44;
                        _v32 = _t174 >> (_v48 & 255 & 4294967295) | _v72 << (_v44 & 255 & 4294967295);
                        _t175 = _t174 << (_v44 & 255 & 4294967295);
                        _v72 = _t181 >> (_v48 & 255 & 4294967295);
                        _t121 = _v40 >> (_v48 & 255 & 4294967295) | _t181 << (_v44 & 255 & 4294967295);
                        _t122 = _t121 / _v32;
                        _v72 = _t121 % _v32;
                        _t183 = _v40 << (_v44 & 255 & 4294967295);
                        _t123 = _t122 * _t175;
                        __eflags = _v72 - _t122 * _t175 >> 32;
                        if(__eflags >= 0) {
                            if(__eflags != 0) {
L23:
                                asm("sbb ecx, edx");
                                _v72 = _v72;
                                _t185 = _v56;
                                 *_t185 = _t183 - _t123 >> (_v44 & 255 & 4294967295) | _v72 << (_v48 & 255 & 4294967295);
                                _t185[1] = _v72 >> (_v44 & 255 & 4294967295);
                                goto L8;
                            }
                            __eflags = _t183 - _t123;
                            if(_t183 >= _t123) {
                                goto L23;
                            }
                            asm("o16 nop ");
                        }
                        goto L22;
                    }
                    __eflags = _v72 - _t152;
                    if(_v72 < _t152) {
L19:
                        asm("sbb esi, [ebp-0x44]");
                        _v36 = _v36 - _t174;
                        goto L20;
                    }
                    __eflags = _t174 - _v36;
                    if(_t174 > _v36) {
                        goto L20;
                    }
                    goto L19;
L20:
                    _t149 = _v56;
                    _t149[4] = _t181;
                     *_t149 = _v36;
                    goto L8;
L22:
                    _t123 = _t123 - _t175;
                    asm("sbb edx, [ebp-0x1c]");
                    goto L23;
                }
                goto L7;
            }
            if(_t174 <= _t152) {
                __eflags = _t174;
                if(_t174 == 0) {
                    _t174 = 1 / _t174;
                }
                _t169 = _v36 % _t174;
            } else {
                _t169 = _t110 % _t174;
            }
            _t186 = _v56;
             *_t186 = _t169;
            _t186[4] = 0;
L8:
            if(_v52 == 0) {
                return _v20;
            }
            _v20 =  ~_v20;
            asm("adc dword [ebp-0xc], 0x0");
            _v16 =  ~_v16;
            return _v20;
L7:
            _t177 = _v56;
             *_t177 = _t110;
            _t177[4] = _t152;
            goto L8;
        }
L15:
        asm("adc edi, 0x0");
        _v68 =  ~_v84;
        _v64 =  ~_v80;
        goto L2;
    }
    if(_v80 >= 0) {
        goto L15;
    }
    goto L2;
}

L0805E090(signed int _a4, signed int _a8, signed int _a12, signed int _a16)
{
    signed int _v16;
    signed int _v20;
    signed int _v24;
    signed int _v28;
    signed int _v36;
    signed int _v40;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t66;
    signed int _t71;
    signed int _t73;
    signed int _t77;
    _unknown_ _t81;
    _unknown_ _t86;
    signed int _t88;
    _unknown_ _t90;
    signed int _t91;
    _unknown_ _t93;
    signed int _t97;
    _unknown_ _t103;
    signed int _t104;
    _unknown_ _t109;
    _unknown_ _t112;
    _unknown_ _t113;
    _unknown_ _t114;
    _unknown_ _t115;
    _unknown_ _t116;
    _unknown_ _t117;
    _unknown_ _t118;
    _unknown_ _t119;
    _unknown_ _t120;
    _unknown_ _t121;
    signed int _t122;
    signed int _t123;
    signed int _t126;
    _unknown_ _t131;
    _unknown_ _t132;
    _unknown_ _t133;
    _unknown_ _t134;

    _t104 = _a4;
    _t88 = _a8;
    _t126 = _a12;
    _t66 = _a16;
    _v24 = _t104;
    _v40 = _t88;
    if(_t66 != 0) {
        __eflags = _t66 - _v40;
        if(__eflags <= 0) {
            asm("bsr edi, eax");
            _t123 = _t122 ^ 31;
            if(__eflags != 0) {
L13:
                _t91 = 32 - _t123;
                _v36 = _t91;
                _v16 = _t126 << (_t123 & 4294967295);
                _v20 = _t66 << (_t123 & 4294967295) | _t126 >> (_t91 & 4294967295);
                _t71 = _v24 >> (_v36 & 255 & 4294967295) | _v40 << (_t123 & 4294967295);
                _v36 = _t71 / _v20;
                _t73 = _v16;
                __eflags = _t71 % _v20 - _t73 * _v36 >> 32;
                _v28 = _t73 * _v36;
                if(__eflags < 0) {
L18:
                    _t97 = _v36 - 1;
                    return _t97;
                }
                goto L14;
            }
            __eflags = _t66 - _v40;
            if(_t66 < _v40) {
L12:
                _t97 = 1;
                return _t97;
            }
            __eflags = _t126 - _v24;
            if(_t126 <= _v24) {
                goto L12;
            }
            goto L6;
L14:
            if(__eflags == 0) {
                _t77 = _v24 << (_t123 & 4294967295);
                __eflags = _t77 - _v28;
                if(_t77 >= _v28) {
                    goto L15;
                }
                goto L17;
            }
L15:
            _t97 = _v36;
            return _t97;
L17:
            goto L18;
        }
L6:
        _t97 = 0;
        return _t97;
    }
    if(_t126 > _t88) {
        return _t104 / _t126;
    }
    if(_t126 == 0) {
        _t126 = 1 / _t126;
    }
    return _v24 / _t126;
    goto L19;
}

L0805E1C0(signed int _a4, signed int _a8, signed int _a12, signed int _a16)
{
    signed int _v16;
    signed int _v20;
    signed int _v24;
    unsigned int _v28;
    signed int _v32;
    signed int _v36;
    unsigned int _v40;
    _unknown_ __edi;
    _unknown_ __esi;
    _unknown_ __ebp;
    signed int _t72;
    _unknown_ _t73;
    signed int _t82;
    signed int _t83;
    signed int _t84;
    _unknown_ _t90;
    _unknown_ _t91;
    _unknown_ _t93;
    _unknown_ _t95;
    _unknown_ _t98;
    signed int _t99;
    _unknown_ _t109;
    signed int _t112;
    _unknown_ _t118;
    _unknown_ _t124;
    _unknown_ _t125;
    _unknown_ _t126;
    _unknown_ _t127;
    _unknown_ _t128;
    signed int _t129;
    _unknown_ _t130;
    _unknown_ _t131;
    _unknown_ _t132;
    _unknown_ _t133;
    signed int _t134;
    signed int _t137;
    signed int _t139;
    signed int _t141;

    _t99 = _a4;
    _t139 = _a8;
    _t134 = _a12;
    _t72 = _a16;
    _v28 = _t99;
    _v24 = _t99;
    if(_t72 != 0) {
        __eflags = _t72 - _t139;
        if(__eflags > 0) {
            return _t99;
        }
        asm("bsr edx, eax");
        _v32 = _t112 ^ 31;
        if(__eflags != 0) {
            _v36 = 32 - _v32;
            _v20 = _t134 >> (_v36 & 255 & 4294967295) | _t72 << (_v32 & 255 & 4294967295);
            _v16 = _t134 << (_v32 & 255 & 4294967295);
            _v40 = _t139 >> (_v36 & 255 & 4294967295);
            _t82 = _v28 >> (_v36 & 255 & 4294967295) | _t139 << (_v32 & 255 & 4294967295);
            _t83 = _t82 / _v20;
            _t141 = _t82 % _v20;
            _t137 = _v28 << (_v32 & 255 & 4294967295);
            _t84 = _t83 * _v16;
            __eflags = _t141 - _t83 * _v16 >> 32;
            if(__eflags >= 0) {
                if(__eflags != 0) {
L16:
                    asm("sbb esi, edx");
                    return _t141 << (_v36 & 255 & 4294967295) | _t137 - _t84 >> (_v32 & 255 & 4294967295);
                }
                __eflags = _t137 - _t84;
                if(_t137 >= _t84) {
                    goto L16;
                }
                asm("o16 nop ");
            }
        } else {
            __eflags = _t72 - _t139;
            if(_t72 >= _t139) {
                __eflags = _t134 - _v24;
                _t139 = _t139;
                if(_t134 > _v24) {
                    return _v24;
                }
                goto L21;
            }
L12:
            asm("sbb esi, eax");
            _v24 = _v24 - _t134;
            return _v24;
L21:
            asm("o16 nop ");
            goto L12;
        }
        _t84 = _t84 - _v16;
        asm("sbb edx, [ebp-0x10]");
        goto L16;
    }
    if(_t134 <= _t139) {
        __eflags = _t134;
        if(_t134 == 0) {
            _t134 = 1 / _t134;
        }
        _t129 = _v24 % _t134;
        return _t129;
    }
    _t129 = _t99 % _t134;
    return _t129;
}

L0805E37A()
{
    return;
}

L0805E380(intOrPtr _a4)
{
    intOrPtr _v12;
    intOrPtr _v16;
    _unknown_ __ebx;
    intOrPtr _t5;
    _unknown_ _t7;
    _unknown_ _t8;

    _t5 = 0;
    L0805E37A();
    _t8 = _t7 + 23657;
    __esp = __esp - 12;
    __edx =  *((intOrPtr*)(_t8 + -4));
    if(__edx != 0) {
        _t5 =  *__edx;
    }
    _v12 = _t5;
    _v16 = 0;
     *__esp = _a4;
    __cxa_atexit();
    __esp = __esp + 12;
    return;
}

L0805E3C0(intOrPtr _a4, intOrPtr _a8)
{
    intOrPtr _v12;
    intOrPtr _v16;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t8;

    L0805E37A();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __xstat64();
    return;
}

L0805E400(intOrPtr _a4, intOrPtr _a8)
{
    intOrPtr _v12;
    intOrPtr _v16;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t8;

    L0805E37A();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __fxstat64();
    return;
}

L0805E440(intOrPtr _a4, intOrPtr _a8)
{
    intOrPtr _v12;
    intOrPtr _v16;
    _unknown_ __ebx;
    _unknown_ __ebp;
    _unknown_ _t7;
    _unknown_ _t8;

    L0805E37A();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __lxstat64();
    return;
}

L0805E480()
{
    intOrPtr* __ebx;
    _unknown_ __ebp;

    __eax =  *134627072;
    if(__eax == 255) {
        return ;
    }
    __ebx = 134627072;
    asm("o16 nop ");
    while(1) {
L2:
        __ebx = __ebx - 4;
         *__eax();
        __eax =  *__ebx;
        if(__eax == 255) {
            break;
        }
    }
    return;
}

L0805F2BB(_unknown_ __eax, signed int __ebx, signed int __ecx, signed int __edx, _unknown_ __edi, _unknown_ __esi, _unknown_ __eflags)
{
    _unknown_ _t4200;
    _unknown_ _t4201;
    _unknown_ _t4202;
    _unknown_ _t4203;
    _unknown_ _t4204;
    _unknown_ _t4205;
    _unknown_ _t4206;
    _unknown_ _t4207;
    _unknown_ _t4208;
    _unknown_ _t4209;
    _unknown_ _t4210;
    _unknown_ _t4211;
    _unknown_ _t4212;
    _unknown_ _t4213;
    _unknown_ _t4215;
    _unknown_ _t4216;
    _unknown_ _t4217;
    _unknown_ _t4218;
    _unknown_ _t4219;
    _unknown_ _t4220;
    _unknown_ _t4221;
    signed int _t4223;
    _unknown_ _t4224;
    signed int _t4225;
    _unknown_ _t4227;
    _unknown_ _t4228;
    _unknown_ _t4229;
    _unknown_ _t4230;
    _unknown_ _t4232;
    _unknown_ _t4233;
    _unknown_ _t4234;
    _unknown_ _t4235;
    _unknown_ _t4236;
    _unknown_ _t4237;
    _unknown_ _t4239;
    _unknown_ _t4240;
    _unknown_ _t4241;
    _unknown_ _t4242;
    _unknown_ _t4244;
    _unknown_ _t4249;
    _unknown_ _t4307;
    _unknown_ _t4324;
    _unknown_ _t4326;
    _unknown_ _t4327;
    _unknown_ _t4328;
    _unknown_ _t4329;
    _unknown_ _t4332;
    _unknown_ _t4333;
    _unknown_ _t4334;
    _unknown_ _t4335;
    _unknown_ _t4336;
    _unknown_ _t4348;
    _unknown_ _t4354;
    _unknown_ _t4358;
    _unknown_ _t4365;
    _unknown_ _t4371;
    _unknown_ _t4375;
    _unknown_ _t4376;
    _unknown_ _t4380;
    _unknown_ _t4381;
    _unknown_ _t4382;
    _unknown_ _t4383;
    _unknown_ _t4384;
    _unknown_ _t4385;
    _unknown_ _t4386;
    _unknown_ _t4387;
    _unknown_ _t4388;
    _unknown_ _t4393;
    _unknown_ _t4400;
    _unknown_ _t4401;
    _unknown_ _t4403;
    signed int _t4408;
    _unknown_ _t4409;
    _unknown_ _t4410;
    _unknown_ _t4414;
    signed int _t4416;
    _unknown_ _t4417;
    _unknown_ _t4418;
    _unknown_ _t4419;
    _unknown_ _t4420;
    _unknown_ _t4421;
    _unknown_ _t4422;
    _unknown_ _t4423;
    _unknown_ _t4424;
    _unknown_ _t4425;
    _unknown_ _t4426;
    _unknown_ _t4427;
    _unknown_ _t4428;
    _unknown_ _t4429;
    _unknown_ _t4430;
    _unknown_ _t4431;
    _unknown_ _t4432;
    _unknown_ _t4433;
    _unknown_ _t4434;
    _unknown_ _t4435;
    _unknown_ _t4436;
    _unknown_ _t4437;
    _unknown_ _t4438;
    _unknown_ _t4439;
    _unknown_ _t4440;
    _unknown_ _t4441;
    _unknown_ _t4442;
    _unknown_ _t4443;
    _unknown_ _t4444;
    _unknown_ _t4445;
    _unknown_ _t4446;
    _unknown_ _t4447;
    _unknown_ _t4448;
    _unknown_ _t4449;
    _unknown_ _t4450;
    _unknown_ _t4451;
    _unknown_ _t4452;
    _unknown_ _t4453;
    _unknown_ _t4454;
    _unknown_ _t4455;
    _unknown_ _t4456;
    _unknown_ _t4457;
    _unknown_ _t4458;
    _unknown_ _t4459;
    _unknown_ _t4460;
    _unknown_ _t4461;
    _unknown_ _t4462;
    _unknown_ _t4463;
    _unknown_ _t4464;
    _unknown_ _t4465;
    _unknown_ _t4466;
    _unknown_ _t4467;
    _unknown_ _t4468;
    _unknown_ _t4469;
    _unknown_ _t4470;
    _unknown_ _t4471;
    _unknown_ _t4473;
    _unknown_ _t4477;
    signed int _t4480;
    _unknown_ _t4481;
    _unknown_ _t4482;
    _unknown_ _t4483;
    _unknown_ _t4484;
    _unknown_ _t4485;
    _unknown_ _t4486;
    _unknown_ _t4488;
    _unknown_ _t4489;
    _unknown_ _t4490;
    _unknown_ _t4491;
    _unknown_ _t4495;
    _unknown_ _t4496;
    _unknown_ _t4499;
    _unknown_ _t4500;
    _unknown_ _t4503;
    _unknown_ _t4504;
    signed int _t4506;
    _unknown_ _t4507;
    _unknown_ _t4509;
    _unknown_ _t4511;
    _unknown_ _t4512;
    _unknown_ _t4513;
    _unknown_ _t4514;
    _unknown_ _t4517;
    _unknown_ _t4522;
    _unknown_ _t4524;
    _unknown_ _t4525;
    _unknown_ _t4526;
    _unknown_ _t4527;
    _unknown_ _t4528;
    _unknown_ _t4529;
    _unknown_ _t4530;
    _unknown_ _t4531;
    _unknown_ _t4532;
    _unknown_ _t4533;
    _unknown_ _t4534;
    _unknown_ _t4535;
    _unknown_ _t4536;
    _unknown_ _t4537;
    _unknown_ _t4538;
    _unknown_ _t4539;
    _unknown_ _t4540;
    _unknown_ _t4541;
    _unknown_ _t4542;
    _unknown_ _t4543;
    _unknown_ _t4544;
    _unknown_ _t4545;
    _unknown_ _t4546;
    _unknown_ _t4547;
    _unknown_ _t4548;
    _unknown_ _t4549;
    _unknown_ _t4550;
    _unknown_ _t4551;
    _unknown_ _t4552;
    _unknown_ _t4553;
    _unknown_ _t4554;
    _unknown_ _t4555;
    _unknown_ _t4556;
    _unknown_ _t4557;

    _t4522 = __eflags;
    _t4495 = __esi;
    _t4486 = __edi;
    _t4480 = __edx;
    _t4416 = __ecx;
    _t4408 = __ebx;
    _t4200 = __eax;
     *(_t4200 - 76) =  *(_t4200 - 76) | _t4416 & 4294967295;
    _t4201 = _t4200 - 1;
     *(_t4201 - 76) =  *(_t4201 - 76) | _t4416 & 4294967295;
    _t4202 = _t4201 - 1;
     *(_t4202 - 76) =  *(_t4202 - 76) | _t4416 & 4294967295;
    _t4203 = _t4202 - 1;
     *(_t4203 - 76) =  *(_t4203 - 76) | _t4416 & 4294967295;
    _t4204 = _t4203 - 1;
     *(_t4204 - 76) =  *(_t4204 - 76) | _t4416 & 4294967295;
    _t4205 = _t4204 - 1;
     *(_t4205 - 76) =  *(_t4205 - 76) | _t4416 & 4294967295;
    _t4206 = _t4205 - 1;
     *(_t4206 - 76) =  *(_t4206 - 76) | _t4416 & 4294967295;
    _t4207 = _t4206 - 1;
     *(_t4207 - 76) =  *(_t4207 - 76) | _t4416 & 4294967295;
    _t4208 = _t4207 - 1;
     *(_t4208 - 76) =  *(_t4208 - 76) | _t4416 & 4294967295;
    _t4209 = _t4208 - 1;
     *(_t4209 - 76) =  *(_t4209 - 76) | _t4416 & 4294967295;
    _t4210 = _t4209 - 1;
     *(_t4210 - 76) =  *(_t4210 - 76) | _t4416 & 4294967295;
    _t4211 = _t4210 - 1;
     *(_t4211 - 76) =  *(_t4211 - 76) | _t4416 & 4294967295;
    _t4212 = _t4211 - 1;
     *(_t4212 - 76) =  *(_t4212 - 76) | _t4416 & 4294967295;
    _t4213 = _t4212 - 1;
     *(_t4213 - 76) =  *(_t4213 - 76) | _t4416 & 4294967295;
     *(_t4480 - 80) =  *(_t4480 - 80) | _t4480 & 4294967295;
    _t4215 = _t4213 - 1 - 1;
     *(_t4215 - 76) =  *(_t4215 - 76) | _t4416 & 4294967295;
    _t4216 = _t4215 - 1;
     *(_t4216 - 76) =  *(_t4216 - 76) | _t4416 & 4294967295;
    _t4217 = _t4216 - 1;
     *(_t4217 - 76) =  *(_t4217 - 76) | _t4416 & 4294967295;
    _t4218 = _t4217 - 1;
     *(_t4218 - 76) =  *(_t4218 - 76) | _t4416 & 4294967295;
    _t4219 = _t4218 - 1;
     *(_t4219 - 76) =  *(_t4219 - 76) | _t4416 & 4294967295;
    _t4220 = _t4219 - 1;
     *(_t4220 - 76) =  *(_t4220 - 76) | _t4416 & 4294967295;
    _t4221 = _t4220 - 1;
     *(_t4221 - 76) =  *(_t4221 - 76) | _t4416 & 4294967295;
     *(_t4416 + -720894802) =  *(_t4416 + -720894802) | _t4408 & 4294967295;
    asm("scasb ");
    asm("repne scasb ");
     *((intOrPtr*)(_t4486 + -1270347772)) =  *((intOrPtr*)(_t4486 + -1270347772)) + _t4506;
    _t4223 = _t4221 - 1 | 470287535;
     *(_t4486 + _t4506 * 4) =  *(_t4486 + _t4506 * 4) | _t4408 & 4294967295;
     *((intOrPtr*)(_t4486 + -1354364924)) =  *((intOrPtr*)(_t4486 + -1354364924)) - (_t4416 & 4294967295);
    _t4224 = _t4223 - 1;
     *(_t4224 - 76) =  *(_t4224 - 76) | _t4416 & 4294967295;
    _pop(__eax);
    asm("scasd ");
    _t4225 = _t4224 - 1;
     *(_t4486 - 81) =  *(_t4486 - 81) | _t4225 & 4294967295;
    _t4226 = _t4225 - 1;
     *(_t4225 - 1 - 76) =  *(_t4225 - 1 - 76) | _t4416 & 4294967295;
     *((char*)(_t4486 + -1348925436)) =  *((char*)(_t4486 + -1348925436)) - 4;
    while(1) {
        asm("cdq ");
        asm("scasd ");
        asm("movsd ");
        asm("scasd ");
         *0x2C080463 =  *0x2C080463 | _t4416 & 4294967295;
        _t4228 = 0x2c0804ae;
        goto L4;
    }
}

L0805F2CB(_unknown_ __eax, signed int __ebx, signed int __ecx, signed int __edx, _unknown_ __edi, _unknown_ __esi, _unknown_ __eflags)
{
    _unknown_ _t4188;
    _unknown_ _t4189;
    _unknown_ _t4190;
    _unknown_ _t4191;
    _unknown_ _t4192;
    _unknown_ _t4193;
    _unknown_ _t4194;
    _unknown_ _t4195;
    _unknown_ _t4196;
    _unknown_ _t4197;
    _unknown_ _t4198;
    _unknown_ _t4199;
    _unknown_ _t4201;
    _unknown_ _t4202;
    _unknown_ _t4203;
    _unknown_ _t4204;
    _unknown_ _t4205;
    _unknown_ _t4206;
    _unknown_ _t4207;
    signed int _t4209;
    _unknown_ _t4210;
    signed int _t4211;
    _unknown_ _t4213;
    _unknown_ _t4214;
    _unknown_ _t4215;
    _unknown_ _t4216;
    _unknown_ _t4218;
    _unknown_ _t4219;
    _unknown_ _t4220;
    _unknown_ _t4221;
    _unknown_ _t4222;
    _unknown_ _t4223;
    _unknown_ _t4225;
    _unknown_ _t4226;
    _unknown_ _t4227;
    _unknown_ _t4228;
    _unknown_ _t4230;
    _unknown_ _t4235;
    _unknown_ _t4293;
    _unknown_ _t4310;
    _unknown_ _t4312;
    _unknown_ _t4313;
    _unknown_ _t4314;
    _unknown_ _t4315;
    _unknown_ _t4318;
    _unknown_ _t4319;
    _unknown_ _t4320;
    _unknown_ _t4321;
    _unknown_ _t4322;
    _unknown_ _t4334;
    _unknown_ _t4340;
    _unknown_ _t4344;
    _unknown_ _t4351;
    _unknown_ _t4357;
    _unknown_ _t4361;
    _unknown_ _t4362;
    _unknown_ _t4366;
    _unknown_ _t4367;
    _unknown_ _t4368;
    _unknown_ _t4369;
    _unknown_ _t4370;
    _unknown_ _t4371;
    _unknown_ _t4372;
    _unknown_ _t4373;
    _unknown_ _t4374;
    _unknown_ _t4379;
    _unknown_ _t4386;
    _unknown_ _t4387;
    _unknown_ _t4389;
    signed int _t4394;
    _unknown_ _t4395;
    _unknown_ _t4396;
    _unknown_ _t4400;
    signed int _t4402;
    _unknown_ _t4403;
    _unknown_ _t4404;
    _unknown_ _t4405;
    _unknown_ _t4406;
    _unknown_ _t4407;
    _unknown_ _t4408;
    _unknown_ _t4409;
    _unknown_ _t4410;
    _unknown_ _t4411;
    _unknown_ _t4412;
    _unknown_ _t4413;
    _unknown_ _t4414;
    _unknown_ _t4415;
    _unknown_ _t4416;
    _unknown_ _t4417;
    _unknown_ _t4418;
    _unknown_ _t4419;
    _unknown_ _t4420;
    _unknown_ _t4421;
    _unknown_ _t4422;
    _unknown_ _t4423;
    _unknown_ _t4424;
    _unknown_ _t4425;
    _unknown_ _t4426;
    _unknown_ _t4427;
    _unknown_ _t4428;
    _unknown_ _t4429;
    _unknown_ _t4430;
    _unknown_ _t4431;
    _unknown_ _t4432;
    _unknown_ _t4433;
    _unknown_ _t4434;
    _unknown_ _t4435;
    _unknown_ _t4436;
    _unknown_ _t4437;
    _unknown_ _t4438;
    _unknown_ _t4439;
    _unknown_ _t4440;
    _unknown_ _t4441;
    _unknown_ _t4442;
    _unknown_ _t4443;
    _unknown_ _t4444;
    _unknown_ _t4445;
    _unknown_ _t4446;
    _unknown_ _t4447;
    _unknown_ _t4448;
    _unknown_ _t4449;
    _unknown_ _t4450;
    _unknown_ _t4451;
    _unknown_ _t4452;
    _unknown_ _t4453;
    _unknown_ _t4454;
    _unknown_ _t4455;
    _unknown_ _t4456;
    _unknown_ _t4457;
    _unknown_ _t4459;
    _unknown_ _t4463;
    signed int _t4466;
    _unknown_ _t4467;
    _unknown_ _t4468;
    _unknown_ _t4469;
    _unknown_ _t4470;
    _unknown_ _t4471;
    _unknown_ _t4472;
    _unknown_ _t4474;
    _unknown_ _t4475;
    _unknown_ _t4476;
    _unknown_ _t4477;
    _unknown_ _t4481;
    _unknown_ _t4482;
    _unknown_ _t4485;
    _unknown_ _t4486;
    _unknown_ _t4489;
    _unknown_ _t4490;
    signed int _t4492;
    _unknown_ _t4493;
    _unknown_ _t4495;
    _unknown_ _t4497;
    _unknown_ _t4498;
    _unknown_ _t4499;
    _unknown_ _t4500;
    _unknown_ _t4503;
    _unknown_ _t4508;
    _unknown_ _t4510;
    _unknown_ _t4511;
    _unknown_ _t4512;
    _unknown_ _t4513;
    _unknown_ _t4514;
    _unknown_ _t4515;
    _unknown_ _t4516;
    _unknown_ _t4517;
    _unknown_ _t4518;
    _unknown_ _t4519;
    _unknown_ _t4520;
    _unknown_ _t4521;
    _unknown_ _t4522;
    _unknown_ _t4523;
    _unknown_ _t4524;
    _unknown_ _t4525;
    _unknown_ _t4526;
    _unknown_ _t4527;
    _unknown_ _t4528;
    _unknown_ _t4529;
    _unknown_ _t4530;
    _unknown_ _t4531;
    _unknown_ _t4532;
    _unknown_ _t4533;
    _unknown_ _t4534;
    _unknown_ _t4535;
    _unknown_ _t4536;
    _unknown_ _t4537;
    _unknown_ _t4538;
    _unknown_ _t4539;
    _unknown_ _t4540;
    _unknown_ _t4541;
    _unknown_ _t4542;
    _unknown_ _t4543;

    _t4508 = __eflags;
    _t4481 = __esi;
    _t4472 = __edi;
    _t4466 = __edx;
    _t4402 = __ecx;
    _t4394 = __ebx;
    _t4188 = __eax;
     *(_t4188 - 76) =  *(_t4188 - 76) | _t4402 & 4294967295;
    _t4189 = _t4188 - 1;
     *(_t4189 - 76) =  *(_t4189 - 76) | _t4402 & 4294967295;
    _t4190 = _t4189 - 1;
     *(_t4190 - 76) =  *(_t4190 - 76) | _t4402 & 4294967295;
    _t4191 = _t4190 - 1;
     *(_t4191 - 76) =  *(_t4191 - 76) | _t4402 & 4294967295;
    _t4192 = _t4191 - 1;
     *(_t4192 - 76) =  *(_t4192 - 76) | _t4402 & 4294967295;
    _t4193 = _t4192 - 1;
     *(_t4193 - 76) =  *(_t4193 - 76) | _t4402 & 4294967295;
    _t4194 = _t4193 - 1;
     *(_t4194 - 76) =  *(_t4194 - 76) | _t4402 & 4294967295;
    _t4195 = _t4194 - 1;
     *(_t4195 - 76) =  *(_t4195 - 76) | _t4402 & 4294967295;
    _t4196 = _t4195 - 1;
     *(_t4196 - 76) =  *(_t4196 - 76) | _t4402 & 4294967295;
    _t4197 = _t4196 - 1;
     *(_t4197 - 76) =  *(_t4197 - 76) | _t4402 & 4294967295;
    _t4198 = _t4197 - 1;
     *(_t4198 - 76)