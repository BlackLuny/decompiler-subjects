// Generated by Rec Studio 4 - build Apr 15 2012

_init()
{// addr = 0x0804947C
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0x1ab64)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    return;
}

L08049488()
{
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0x1ab64)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

void abort()
{// addr = 0x080494BC
    goto __imp__abort;
}

int* __errno_location()
{// addr = 0x080494CC
    goto __imp____errno_location;
}

int putc_unlocked(int ch, struct _IO_FILE* fp)
{// addr = 0x080494DC
    goto __imp__putc_unlocked;
}

sigemptyset()
{// addr = 0x080494EC
    goto __imp__sigemptyset;
}

int sprintf(char* dst, char* format)
{// addr = 0x080494FC
    goto __imp__sprintf;
}

struct lconv* localeconv()
{// addr = 0x0804950C
    goto __imp__localeconv;
}

dirfd()
{// addr = 0x0804951C
    goto __imp__dirfd;
}

__cxa_atexit()
{// addr = 0x0804952C
    goto __imp____cxa_atexit;
}

int strcoll(char* __s1, char* __s2)
{// addr = 0x0804953C
    goto __imp__strcoll;
}

memcmp()
{// addr = 0x0804954C
    goto __imp__memcmp;
}

int fputs_unlocked(char* str, struct _IO_FILE* fp)
{// addr = 0x0804955C
    goto __imp__fputs_unlocked;
}

__ctype_get_mb_cur_max()
{// addr = 0x0804956C
    goto __imp____ctype_get_mb_cur_max;
}

signal()
{// addr = 0x0804957C
    goto __imp__signal;
}

sigismember()
{// addr = 0x0804958C
    goto __imp__sigismember;
}

__gmon_start__()
{// addr = 0x0804959C
    goto __imp____gmon_start__;
}

void* realloc(void* __ptr, int __size)
{// addr = 0x080495AC
    goto __imp__realloc;
}

__xstat64()
{// addr = 0x080495BC
    goto __imp____xstat64;
}

localtime()
{// addr = 0x080495CC
    goto __imp__localtime;
}

getgrnam()
{// addr = 0x080495DC
    goto __imp__getgrnam;
}

char* strchr(char* __s, int __c)
{// addr = 0x080495EC
    goto __imp__strchr;
}

char* getenv(char* __name)
{// addr = 0x080495FC
    goto __imp__getenv;
}

void* calloc(int __nmemb, int __size)
{// addr = 0x0804960C
    goto __imp__calloc;
}

char* strncpy(char* __dest, char* __src, int __n)
{// addr = 0x0804961C
    goto __imp__strncpy;
}

gnu_dev_minor()
{// addr = 0x0804962C
    goto __imp__gnu_dev_minor;
}

toupper()
{// addr = 0x0804963C
    goto __imp__toupper;
}

void* memset(void* __s, int __c, int __n)
{// addr = 0x0804964C
    goto __imp__memset;
}

__libc_start_main()
{// addr = 0x0804965C
    goto __imp____libc_start_main;
}

mempcpy()
{// addr = 0x0804966C
    goto __imp__mempcpy;
}

_obstack_begin()
{// addr = 0x0804967C
    goto __imp___obstack_begin;
}

int ferror_unlocked(struct _IO_FILE* fp)
{// addr = 0x0804968C
    goto __imp__ferror_unlocked;
}

void _exit(int __status)
{// addr = 0x0804969C
    goto __imp___exit;
}

char* strrchr(char* __s, int __c)
{// addr = 0x080496AC
    goto __imp__strrchr;
}

__assert_fail()
{// addr = 0x080496BC
    goto __imp____assert_fail;
}

__builtin_va_list bindtextdomain(char* __domainname, char* __dirname)
{// addr = 0x080496CC
    goto __imp__bindtextdomain;
}

mbrtowc()
{// addr = 0x080496DC
    goto __imp__mbrtowc;
}

__builtin_va_list gettext(char* __msgid)
{// addr = 0x080496EC
    goto __imp__gettext;
}

gettimeofday()
{// addr = 0x080496FC
    goto __imp__gettimeofday;
}

void free(void* __ptr)
{// addr = 0x0804970C
    goto __imp__free;
}

__lxstat64()
{// addr = 0x0804971C
    goto __imp____lxstat64;
}

strtoumax()
{// addr = 0x0804972C
    goto __imp__strtoumax;
}

_obstack_newchunk()
{// addr = 0x0804973C
    goto __imp___obstack_newchunk;
}

__builtin_va_list dcgettext(char* __domainname, char* __msgid, int __category)
{// addr = 0x0804974C
    goto __imp__dcgettext;
}

sigaction()
{// addr = 0x0804975C
    goto __imp__sigaction;
}

strverscmp()
{// addr = 0x0804976C
    goto __imp__strverscmp;
}

opendir()
{// addr = 0x0804977C
    goto __imp__opendir;
}

int getopt_long(int ___argc, __builtin_va_list* ___argv, char* __shortopts, struct option* __longopts, int* __longind)
{// addr = 0x0804978C
    goto __imp__getopt_long;
}

ioctl()
{// addr = 0x0804979C
    goto __imp__ioctl;
}

__ctype_b_loc()
{// addr = 0x080497AC
    goto __imp____ctype_b_loc;
}

iswcntrl()
{// addr = 0x080497BC
    goto __imp__iswcntrl;
}

int isatty(int __fd)
{// addr = 0x080497CC
    goto __imp__isatty;
}

int fclose(struct _IO_FILE* fp)
{// addr = 0x080497DC
    goto __imp__fclose;
}

mbsinit()
{// addr = 0x080497EC
    goto __imp__mbsinit;
}

_setjmp()
{// addr = 0x080497FC
    goto __imp___setjmp;
}

int tcgetpgrp(int __fd)
{// addr = 0x0804980C
    goto __imp__tcgetpgrp;
}

readdir64()
{// addr = 0x0804982C
    goto __imp__readdir64;
}

void* memcpy(void* __dest, void* __src, int __n)
{// addr = 0x0804983C
    goto __imp__memcpy;
}

long strtoul(char* __nptr, char** __endptr, int __base)
{// addr = 0x0804984C
    goto __imp__strtoul;
}

int strlen(char* __s)
{// addr = 0x0804985C
    goto __imp__strlen;
}

getpwuid()
{// addr = 0x0804986C
    goto __imp__getpwuid;
}

__builtin_va_list setlocale(int __category, char* __locale)
{// addr = 0x0804987C
    goto __imp__setlocale;
}

char* strcpy(char* __dest, char* __src)
{// addr = 0x0804988C
    goto __imp__strcpy;
}

longjmp()
{// addr = 0x0804989C
    goto __imp__longjmp;
}

int printf(char* format)
{// addr = 0x080498AC
    goto __imp__printf;
}

raise()
{// addr = 0x080498BC
    goto __imp__raise;
}

mbrlen()
{// addr = 0x080498CC
    goto __imp__mbrlen;
}

int fwrite_unlocked(void* src, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x080498DC
    goto __imp__fwrite_unlocked;
}

__signbitl()
{// addr = 0x080498EC
    goto __imp____signbitl;
}

clock_gettime()
{// addr = 0x080498FC
    goto __imp__clock_gettime;
}

closedir()
{// addr = 0x0804990C
    goto __imp__closedir;
}

int fwrite(void* src, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x0804991C
    goto __imp__fwrite;
}

int fprintf(struct _IO_FILE* fp, char* format)
{// addr = 0x0804992C
    goto __imp__fprintf;
}

void* malloc(int __size)
{// addr = 0x0804993C
    goto __imp__malloc;
}

sigprocmask()
{// addr = 0x0804994C
    goto __imp__sigprocmask;
}

__stack_chk_fail()
{// addr = 0x0804995C
    goto __imp____stack_chk_fail;
}

__fpending()
{// addr = 0x0804996C
    goto __imp____fpending;
}

void error(int __status, int __errnum, char* __format)
{// addr = 0x0804997C
    goto __imp__error;
}

getgrgid()
{// addr = 0x0804998C
    goto __imp__getgrgid;
}

sigaddset()
{// addr = 0x0804999C
    goto __imp__sigaddset;
}

int readlink(char* __path, __caddr_t __buf, int __len)
{// addr = 0x080499AC
    goto __imp__readlink;
}

void* memmove(void* __dest, void* __src, int __n)
{// addr = 0x080499BC
    goto __imp__memmove;
}

strndup()
{// addr = 0x080499CC
    goto __imp__strndup;
}

__builtin_va_list textdomain(char* __domainname)
{// addr = 0x080499DC
    goto __imp__textdomain;
}

__fxstat64()
{// addr = 0x080499EC
    goto __imp____fxstat64;
}

gnu_dev_major()
{// addr = 0x080499FC
    goto __imp__gnu_dev_major;
}

fnmatch()
{// addr = 0x08049A0C
    goto __imp__fnmatch;
}

int strncmp(char* __s1, char* __s2, int __n)
{// addr = 0x08049A1C
    goto __imp__strncmp;
}

int fflush_unlocked(struct _IO_FILE* fp)
{// addr = 0x08049A2C
    goto __imp__fflush_unlocked;
}

wcwidth()
{// addr = 0x08049A5C
    goto __imp__wcwidth;
}

iswprint()
{// addr = 0x08049A6C
    goto __imp__iswprint;
}

getpwnam()
{// addr = 0x08049A7C
    goto __imp__getpwnam;
}

tolower()
{// addr = 0x08049A8C
    goto __imp__tolower;
}

int strcmp(char* __s1, char* __s2)
{// addr = 0x08049A9C
    goto __imp__strcmp;
}

void exit(int __status)
{// addr = 0x08049AAC
    goto __imp__exit;
}

int putchar_unlocked(int ch)
{// addr = 0x08049ABC
    goto __imp__putchar_unlocked;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x08049AD0
    _unknown_ __ebx;                       // r1
    signed int _t10;                       // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    _t6 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & 240;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(_t11);
    _push(main);
    __libc_start_main();
    asm("hlt ");
    0;
    0;
    _push(0);
    _push(__ebx);
    __esp = __esp - 4;
    if(completed.6635 == 0) {
        _t10 = dtor_idx.6637;
        _t6 =  &__DTOR_END__ -  &__DTOR_LIST__ >> 2;
        __ebx = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t10 < __ebx) {
            while(1) {
                _t6 = _t10 + 1;
                dtor_idx.6637 = _t6;
                 *((intOrPtr*)(_t6 * 4 +  &__DTOR_LIST__))();
                _t10 = dtor_idx.6637;
                if(_t10 >= __ebx) {
                    break;
                }
            }
        }
        completed.6635 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
    return;
}

__do_global_dtors_aux(
    _unknown_ __esi                        // r5
)
{// addr = 0x08049B00
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t6;                         // _t6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11

    if(completed.6635 == 0) {
        __edx = dtor_idx.6637;
        _t9 =  &__DTOR_END__ -  &__DTOR_LIST__ >> 2;
        __ebx = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(__edx >= __ebx) {
L4:
            completed.6635 = 1;
            return;
        }
        while(1) {
            _t9 = __edx + 1;
            dtor_idx.6637 = _t9;
             *((intOrPtr*)(_t9 * 4 +  &__DTOR_LIST__))();
            __edx = dtor_idx.6637;
            if(__edx >= __ebx) {
                break;
            }
        }
        goto L4;
    }
    return;
}

frame_dummy()
{// addr = 0x08049B60
    _unknown_ __ebp;                       // r6

    __eax = __JCR_LIST__;
    if(__JCR_LIST__ != 0) {
        __eax = 0;
        if(__eax == 0) {
        } else {
             *__esp =  &__JCR_LIST__;
             *__eax();
            return;
        }
    }
    return;
}

struct dev_ino dev_ino_pop()
{// addr = 0x08049B84  --  defined in 'ls.c' at line 917
    int __len;                             // _cfa_fffffff8
    struct obstack* __o;   // _cfa_fffffff4
    const struct obstack* __o;   // _cfa_fffffff0
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t43;                        // _t43

    __o =  &dev_ino_obstack;
    if(__o->next_free - __o->object_base <= 15) {
        _v32 = "dev_ino_pop";
        _v36 = 918;
        _v40 = "ls.c";
         *__esp = "sizeof (struct dev_ino) <= __extension__ ({ struct obstack const *__o = (&dev_ino_obstack); (unsigned) (__o->next_free - __o->object_base); })";
        __assert_fail();
    }
    __o =  &dev_ino_obstack;
    __len = -16;
    if(__o->chunk_limit - __o->next_free < __len) {
        _v40 = __len;
         *__esp = __o;
        _obstack_newchunk();
    }
    __o->next_free =  &(__o->next_free[__len]);
    memmove(_a4.st_ino, dev_ino_obstack.next_free, 16);
    return _a4;
}

dired_dump_obstack(const char* prefix, struct obstack* os)
{// addr = 0x08049C3B  --  defined in 'ls.c' at line 940
    _Unknown_base* __value;                // _cfa_fffffff4
    struct obstack* __o1;   // _cfa_fffffff0
    size_t* pos;        // _cfa_ffffffec
    size_t i;           // _cfa_ffffffe8
    const struct obstack* __o;   // _cfa_ffffffe4
    size_t n_pos;       // _cfa_ffffffe0
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t94;                        // _t94
    _unknown_ _t100;                       // _t100
    _unknown_ _t101;                       // _t101

    __o = os;
    n_pos = __o->next_free - __o->object_base >> 2;
    if(n_pos != 0) {
        __o1 = os;
        __value = __o1->object_base;
        if(__o1->next_free == __value) {
            __o1->use_extra_arg = (__o1->use_extra_arg & 255 | 2) & 255;
        }
        __o1->next_free =  !(__o1->alignment_mask) &  &(__o1->next_free[__o1->alignment_mask]);
        if(__o1->next_free - __o1->chunk > __o1->chunk_limit - __o1->chunk) {
            __o1->next_free = __o1->chunk_limit;
        }
        __o1->object_base = __o1->next_free;
        pos = __value;
        fputs_unlocked(prefix, __imp__stdout);
        i = 0;
        while(i < n_pos) {
            _v56 =  *((intOrPtr*)(pos + (i << 2)));
            printf(" %lu");
            i = i + 1;
        }
        putchar_unlocked(10);
        return;
    }
    return;
}

size_t dev_ino_hash(* x, size_t table_size)
{// addr = 0x08049D54  --  defined in 'ls.c' at line 959
    const struct dev_ino* p;   // _cfa_fffffff4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    p = x;
    return __umoddi3(p->st_ino,  *((intOrPtr*)(_t10 + 4)), table_size, 0);
}

_Bool dev_ino_compare(* x, * y)
{// addr = 0x08049D8B  --  defined in 'ls.c' at line 966
    const struct dev_ino* b;   // _cfa_fffffff0
    const struct dev_ino* a;   // _cfa_ffffffec
    signed char _v32;                      // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6

    a = x;
    b = y;
    _t20 = a;
    if((b->st_ino ^ a->st_ino |  *(_t20 + 4) ^  *(b + 4)) != 0) {
L3:
        _v32 = 0;
    } else {
        _t26 = a;
        if(( *(b + 8) ^  *(a + 8) |  *(_t26 + 12) ^  *(b + 12)) != 0) {
            goto L3;
        } else {
            _v32 = 1;
        }
    }
    return _v32 & 255;
}

dev_ino_free(_Unknown_base* x)
{// addr = 0x08049DF4  --  defined in 'ls.c' at line 974
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    free(x);
    return;
}

_Bool visit_dir(dev_t dev, ino_t ino)
{// addr = 0x08049E07  --  defined in 'ls.c' at line 984
    _Bool found_match;                     // _cfa_fffffffb
    struct dev_ino* ent_from_table;   // _cfa_fffffff4
    struct dev_ino* ent;   // _cfa_fffffff0
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    long long unsigned int _v36;           // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    struct dev_ino* _t46;   // _t46
    struct dev_ino* _t47;   // _t47

    _v28 = _a4;
    _v24 = _a8;
    _v36 = _a12;
    _v32 = _a16;
    ent = xmalloc(16);
    _t46 = ent;
    _t46->st_ino = _v36;
     *((intOrPtr*)(_t46 + 4)) = _v32;
    _t47 = ent;
     *((intOrPtr*)(_t47 + 8)) = _v28;
     *((intOrPtr*)(_t47 + 12)) = _v24;
    ent_from_table = hash_insert(active_dir_set, ent);
    if(ent_from_table == 0) {
        xalloc_die();
    }
    found_match = ent_from_table & 255;
    if(found_match != 0) {
        free(ent);
    }
    return found_match & 255;
}

free_pending_ent(struct pending* p)
{// addr = 0x08049E97  --  defined in 'ls.c' at line 1015
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t10;                        // _t10
    _unknown_ _t12;                        // _t12

    free(p->name);
    free(p->realname);
    free(p);
    return;
}

_Bool is_colored(union indicator_no type)
{// addr = 0x08049EC5  --  defined in 'ls.c' at line 1023
    const char* s;   // _cfa_fffffff8
    size_t len;         // _cfa_fffffff4
    signed char _v24;                      // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31

    len =  *( &color_indicator + type * 8);
    s =  *(134627812 + type * 8);
    if(len == 0 || len == 1 && ( *s & 0xff) == ( *134604345 & 0xff)) {
L6:
        _v24 = 0;
    } else {
        if(len != 2 || strncmp(s, "00", 2) != 0) {
            _v24 = 1;
            goto L7;
        } else {
            goto L6;
        }
    }
L7:
    return _v24 & 255;
}

restore_default_color()
{// addr = 0x08049F3E  --  defined in 'ls.c' at line 1033
    _unknown_ __ebp;                       // r6

    put_indicator( &color_indicator);
    put_indicator(134627816);
    return;
}

sighandler(int sig)
{// addr = 0x08049F5E  --  defined in 'ls.c' at line 1042
    _unknown_ __ebp;                       // r6

    if(interrupt_signal == 0) {
        interrupt_signal = sig;
        return;
    }
    return;
}

stophandler(int sig)
{// addr = 0x08049F74  --  defined in 'ls.c' at line 1053
    _unknown_ __ebp;                       // r6

    if(interrupt_signal == 0) {
        stop_signal_count = stop_signal_count + 1;
        return;
    }
    return;
}

process_signals()
{// addr = 0x08049F8F  --  defined in 'ls.c' at line 1068
    int stops;                             // _cfa_fffffff8
    int sig;                               // _cfa_fffffff4
    sigset_t oldset;   // _cfa_ffffff74
    long unsigned int[31]* _v164;          // _cfa_ffffff5c
    long unsigned int[31]* _v168;          // _cfa_ffffff58
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18

    while((interrupt_signal | stop_signal_count) != 0) {
        restore_default_color();
        fflush_unlocked(__imp__stdout);
        _v164 =  &(oldset.__val);
        _v168 =  &caught_signals;
         *__esp = 0;
        sigprocmask();
        sig = interrupt_signal;
        stops = stop_signal_count;
        if(stops == 0) {
            _v168 = 0;
             *__esp = sig;
            signal();
        } else {
            stop_signal_count = stops - 1;
            sig = 19;
        }
         *__esp = sig;
        raise();
        _v164 = 0;
        _v168 =  &(oldset.__val);
         *__esp = 2;
        sigprocmask();
    }
    return;
}

int main(int argc, char** argv)
{// addr = 0x0804A04A  --  defined in 'ls.c' at line 1107
    struct dev_ino di;   // _cfa_ffffffc8
    int j;                                 // _cfa_ffffffec
    int _v4;                               // _cfa_fffffffc
    struct dev_ino* found;   // _cfa_ffffffe8
    int j;                                 // _cfa_ffffffe4
    int n_files;                           // _cfa_ffffffe0
    struct pending* thispend;   // _cfa_ffffffdc
    int i;                                 // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    _unknown_ _v68;                        // _cfa_ffffffbc
    struct sigaction act;   // _cfa_ffffff3c
    _unknown_ _v200;                       // _cfa_ffffff38
    signed char _v216;                     // _cfa_ffffff28
    signed char _v220;                     // _cfa_ffffff24
    union Dereference_symlink _v224;   // _cfa_ffffff20
    _unknown_ _v228;                       // _cfa_ffffff1c
    int* _v232;                            // _cfa_ffffff18
    _unknown_ _v236;                       // _cfa_ffffff14
    _unknown_ _v240;                       // _cfa_ffffff10
    _unknown_ _v244;                       // _cfa_ffffff0c
    char* _v252;                           // _cfa_ffffff04
    int _v256;                             // _cfa_ffffff00
    int _v260;                             // _cfa_fffffefc
    char* _v264;                           // _cfa_fffffef8
    int _v268;                             // _cfa_fffffef4
    char* _v272;                           // _cfa_fffffef0
    _unknown_ __ebp;                       // r6
    _unknown_ _t206;                       // _t206
    _unknown_ _t207;                       // _t207
    _unknown_ _t208;                       // _t208
    _unknown_ _t209;                       // _t209
    _unknown_ _t232;                       // _t232
    int _t258;                             // _t258
    _unknown_ _t265;                       // _t265
    _unknown_ _t267;                       // _t267
    int _t269;                             // _t269
    _unknown_ _t279;                       // _t279
    _unknown_ _t285;                       // _t285
    _unknown_ _t307;                       // _t307
    _unknown_ _t309;                       // _t309
    int* _t323;                            // _t323
    _unknown_ _t328;                       // _t328
    _unknown_ _t341;                       // _t341
    _unknown_ _t346;                       // _t346
    signed int _t347;                      // _t347
    _unknown_ _t348;                       // _t348

    _t323 =  &_a4;
    __esp = __esp & 240;
    _push( *((intOrPtr*)(_t323 - 4)));
    _push(_t346);
    _t347 = __esp;
    _push(__edi);
    _push(__esi);
    _push(_t323);
    __esp = __esp - 252;
    _v232 = _t323;
    program_name =  *(_v232[1]);
    setlocale(6, 134606192);
    bindtextdomain("coreutils", "/usr/local/share/locale");
    textdomain("coreutils");
     *__esp = 2;
    L91();
    atexit(close_stdout);
    exit_status = 0;
    print_dir_name = 1;
    pending_dirs = 0;
    _v44 = decode_switches( *_v232, _v232[1]);
    if((print_with_color & 0xff) != 0) {
        parse_ls_color();
    }
    if((print_with_color & 0xff) == 0) {
L24:
        if(dereference == 1) {
            if((immediate_dirs & 0xff) != 0 || indicator_style == 3 || format == 0) {
                _v224 = 2;
            } else {
                _v224 = 4;
            }
            dereference = _v224;
        }
        if((recursive & 0xff) != 0) {
            active_dir_set = hash_initialize(30, 0, dev_ino_hash, dev_ino_compare, dev_ino_free);
            if(active_dir_set == 0) {
                xalloc_die();
            }
            _v256 = free;
            _v260 = malloc;
            _v264 = 0;
            _v268 = 0;
             *__esp =  &dev_ino_obstack;
            _obstack_begin();
        }
        if(sort_type == 4 || sort_type == 2 || format == 0 || (print_scontext & 0xff) != 0 || (print_block_size & 0xff) != 0) {
            _v220 = 1;
        } else {
            _v220 = 0;
        }
        format_needs_stat = _v220 & 0xff;
        if(((format_needs_stat & 255 ^ 0) & 255) != 0 || (recursive & 0xff) == 0 && (print_with_color & 0xff) == 0 && indicator_style == 0 && (directories_first & 0xff) == 0) {
            _v216 = 0;
        } else {
            _v216 = 1;
        }
        format_needs_type = _v216 & 0xff;
        if((dired & 0xff) != 0) {
            _v256 = free;
            _v260 = malloc;
            _v264 = 0;
            _v268 = 0;
             *__esp =  &dired_obstack;
            _obstack_begin();
            _v256 = free;
            _v260 = malloc;
            _v264 = 0;
            _v268 = 0;
             *__esp =  &subdired_obstack;
            _obstack_begin();
        }
        cwd_n_alloc = 100;
        cwd_file = xnmalloc(cwd_n_alloc, 120);
        cwd_n_used = 0;
        clear_files();
        thispend =  *_v232 - _v44;
        if(thispend > 0) {
            while(1) {
                _v44 = _v44 + 1;
                _v252 = 134606192;
                _v256 = 1;
                _v264 = 0;
                _v260 = 0;
                _v268 = 0;
                 *__esp = _v232[1][_v44];
                gobble_file();
                if(_v44 >=  *_v232) {
                    break;
                }
            }
            goto L56;
        }
        if((immediate_dirs & 0xff) == 0) {
            queue_directory(".", 0, 1);
        } else {
            _v252 = 134606192;
            _v256 = 1;
            _v264 = 0;
            _v260 = 0;
            _v268 = 3;
             *__esp = ".";
            gobble_file();
        }
L56:
        if(cwd_n_used != 0) {
            sort_files();
            if(((immediate_dirs & 255 ^ 1) & 255) != 0) {
                extract_dirs_from_files(0, 1);
            }
        }
        if(cwd_n_used == 0) {
            if(thispend <= 1 && pending_dirs != 0 && pending_dirs->next == 0) {
                print_dir_name = 0;
            }
        } else {
            print_current_files();
            if(pending_dirs != 0) {
                putchar_unlocked(10);
                dired_pos = dired_pos + 1;
            }
        }
        while(pending_dirs != 0) {
            i = pending_dirs;
            pending_dirs = pending_dirs->next;
            if(active_dir_set == 0 ||  *i != 0) {
                print_dir( *i,  *(i + 4),  *(i + 8) & 0xff);
                free_pending_ent(i);
                print_dir_name = 1;
            } else {
                 *__esp =  &(act.sa_restorer);
                dev_ino_pop();
                __esp = __esp - 4;
                j = hash_delete(active_dir_set,  &(act.sa_restorer));
                if(j == 0) {
                    _v264 = "main";
                    _v268 = 1310;
                    _v272 = "ls.c";
                     *__esp = "found";
                    __assert_fail();
                }
                dev_ino_free(j);
                free_pending_ent(i);
            }
        }
        if((print_with_color & 0xff) == 0) {
L84:
            if((dired & 0xff) != 0) {
                dired_dump_obstack("//DIRED//",  &dired_obstack);
                dired_dump_obstack("//SUBDIRED//",  &subdired_obstack);
                _v268 =  *( &quoting_style_args + get_quoting_style(filename_quoting_options) * 4);
                printf("//DIRED-OPTIONS// --quoting-style=%s\n");
            }
            if(active_dir_set != 0) {
                if(hash_get_n_entries(active_dir_set) != 0) {
                    _v260 = "main";
                    _v264 = 1364;
                    _v268 = "ls.c";
                     *__esp = "hash_get_n_entries (active_dir_set) == 0";
                    __assert_fail();
                }
                hash_free(active_dir_set);
            }
            _t258 = exit(exit_status);
            _push(_t347);
            if(_v268 != 1) {
                _t258 = _v4;
                exit_failure = _t258;
            }
            _pop(__ebp);
            return _t258;
        }
        restore_default_color();
        fflush_unlocked(__imp__stdout);
        found = 0;
        while(found <= 11) {
            _t269 =  *(found * 4 +  &sig.6258);
            _v268 = _t269;
             *__esp =  &caught_signals;
            sigismember();
            if(_t269 != 0) {
                _v268 = 0;
                 *__esp =  *(found * 4 +  &sig.6258);
                signal();
            }
            found = found + 1;
        }
        found = stop_signal_count;
        while(found != 0) {
             *__esp = 19;
            raise();
            found = found - 1;
        }
        found = interrupt_signal;
        if(found != 0) {
             *__esp = found;
            raise();
        }
        goto L84;
    } else {
        if((is_colored(12) & 255) != 0 || ((is_colored(13) ^ 1) & 255) == 0 && (color_symlink_as_referent & 0xff) != 0 || ((is_colored(11) ^ 1) & 255) == 0 && format == 0) {
            check_symlink_color = 1;
        }
        if(tcgetpgrp(1) >= 0) {
            prep_non_filename_text();
        } else {
             *__esp =  &caught_signals;
            sigemptyset();
            n_files = 0;
            while() {
            }
        }
        goto L24;
    }
}

initialize_exit_failure(int status)
{// addr = 0x0804A844  --  defined in 'system.h' at line 131
    _unknown_ __ebp;                       // r6
    _unknown_ _t3;                         // _t3

    if(status != 1) {
        exit_failure = status;
        return;
    }
    return;
}

int decode_switches(int argc, char** argv)
{// addr = 0x0804A857  --  defined in 'ls.c' at line 1376
    long unsigned int tmp_ulong;           // _cfa_ffffff9c
    long unsigned int tmp_ulong;           // _cfa_ffffff98
    struct ignore_pattern* hide;   // _cfa_ffffffd4
    int i;                                 // _cfa_ffffffd8
    union strtol_error e;   // _cfa_ffffffdc
    const char* locale_format;   // _cfa_fffffff4
    int i;                                 // _cfa_fffffff0
    char* p1;                              // _cfa_ffffffec
    char* p0;                              // _cfa_ffffffe8
    char* style;                           // _cfa_ffffffe4
    const char* p;   // _cfa_ffffffe0
    int c;                                 // _cfa_ffffffd0
    const char* p;   // _cfa_ffffffcc
    const char* p;   // _cfa_ffffffc8
    const char* ls_block_size;   // _cfa_ffffffc4
    int i;                                 // _cfa_ffffffc0
    const char* q_style;   // _cfa_ffffffbc
    _Bool sort_type_specified;             // _cfa_ffffffbb
    char* time_style_option;               // _cfa_ffffffb4
    long unsigned int tmp_ulong;           // _cfa_ffffffb0
    struct winsize ws;   // _cfa_ffffffa8
    long unsigned int tmp_ulong;           // _cfa_ffffffa4
    int oi;                                // _cfa_ffffffa0
    intOrPtr _v108;                        // _cfa_ffffff94
    int _v112;                             // _cfa_ffffff90
    unsigned int _v116;                    // _cfa_ffffff8c
    int _v136;                             // _cfa_ffffff78
    intOrPtr _v140;                        // _cfa_ffffff74
    unsigned int _v144;                    // _cfa_ffffff70
    _unknown_ _v152;                       // _cfa_ffffff68
    _unknown_ _v156;                       // _cfa_ffffff64
    char* _v160;                           // _cfa_ffffff60
    short unsigned int* _v164;             // _cfa_ffffff5c
    intOrPtr _v168;                        // _cfa_ffffff58
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t189;                       // _t189
    short unsigned int* _t192;             // _t192
    _unknown_ _t205;                       // _t205
    const _None* _t244;   // _t244
    char* _t245;                           // _t245
    _unknown_ _t259;                       // _t259
    _unknown_ _t261;                       // _t261
    _unknown_ _t264;                       // _t264
    _unknown_ _t269;                       // _t269
    char* _t274;                           // _t274
    char* _t275;                           // _t275
    char* _t286;                           // _t286
    char* _t287;                           // _t287
    char* _t295;                           // _t295
    char* _t296;                           // _t296
    _unknown_ _t300;                       // _t300
    _unknown_ _t311;                       // _t311
    _unknown_ _t313;                       // _t313

    time_style_option = 0;
    sort_type_specified = 0;
    qmark_funny_chars = 0;
    _v136 = ls_mode;
    if(_v136 == 2) {
        format = 2;
        set_quoting_style(0, 4);
    } else {
        if(_v136 == 3) {
            format = 0;
            set_quoting_style(0, 4);
        } else {
            if(_v136 == 1) {
                if(isatty(1) == 0) {
                    format = 1;
                    qmark_funny_chars = 0;
                } else {
                    format = 2;
                    qmark_funny_chars = 1;
                }
            } else {
                abort();
            }
        }
    }
    time_type = 0;
    sort_type = 0;
    sort_reverse = 0;
    numeric_ids = 0;
    print_block_size = 0;
    indicator_style = 0;
    print_inode = 0;
    dereference = 1;
    recursive = 0;
    immediate_dirs = 0;
    ignore_mode = 0;
    ignore_patterns = 0;
    hide_patterns = 0;
    print_scontext = 0;
    q_style = getenv("QUOTING_STYLE");
    if(q_style != 0) {
        i = argmatch(q_style,  &quoting_style_args,  &quoting_style_vals, 4);
        if(i >= 0) {
            _t295 = quotearg(q_style);
            _t296 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
            _v160 = _t295;
            error(0, 0, _t296);
        } else {
            set_quoting_style(0,  *( &quoting_style_vals + i * 4));
        }
    }
    ls_block_size = getenv("LS_BLOCK_SIZE");
    human_options(ls_block_size,  &human_output_opts,  &output_block_size);
    if(ls_block_size != 0 || getenv("BLOCK_SIZE") != 0) {
        file_output_block_size = output_block_size;
         *134627796 =  *134628524;
    }
    line_length = 80;
    p = getenv("COLUMNS");
    if(p != 0 && ( *p & 0xff) != 0) {
        if(xstrtoul(p, 0, 0,  &tmp_ulong, 0) != 0 || tmp_ulong == 0) {
            _t286 = quotearg(p);
            _t287 = gettext("ignoring invalid width in environment variable COLUMNS: %s");
            _v160 = _t286;
            error(0, 0, _t287);
        } else {
            line_length = tmp_ulong;
        }
    }
    _t192 =  &(ws.ws_row);
    _v164 = _t192;
    _v168 = 21523;
     *__esp = 1;
    ioctl();
    if(_t192 != 255 && (_v86 & 0xffff) != 0) {
        line_length = ws.ws_col & 0xffff;
    }
    p = getenv("TABSIZE");
    tabsize = 8;
    if(p != 0) {
        if(xstrtoul(p, 0, 0,  &tmp_ulong, 0) != 0) {
            _t274 = quotearg(p);
            _t275 = gettext("ignoring invalid tab size in environment variable TABSIZE: %s");
            _v160 = _t274;
            error(0, 0, _t275);
        } else {
            tabsize = tmp_ulong;
        }
    }
    while(1) {
        oi = -1;
        c = getopt_long(argc, argv, "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1",  &long_options,  &oi);
        if(c == 255) {
            break;
        }
        _v140 = c + 131;
        if(_v140 > 274) {
            usage(2);
            continue;
        }
        goto __eax;
        break;
    }
    if(line_length <= 2) {
        _v116 = 1;
    } else {
        _v144 = line_length;
        _v116 = _v144 * -1431655765 >> 32 >> 1;
    }
    max_idx = _v116;
    filename_quoting_options = clone_quoting_options(0);
    if(get_quoting_style(filename_quoting_options) == 4) {
        set_char_quoting(filename_quoting_options, 32, 1);
    }
    if(indicator_style <= 1) {
L43:
        dirname_quoting_options = clone_quoting_options(0);
        set_char_quoting(dirname_quoting_options, 58, 1);
        if((dired & 0xff) != 0 && format != 0) {
            dired = 0;
        }
        if(time_type == 1 || time_type == 2) {
            if(((sort_type_specified & 255 ^ 1) & 255) != 0 && format != 0) {
                sort_type = 4;
            }
        }
        if(format != 0) {
L79:
            _v112 = __imp__optind;
        } else {
            style = time_style_option;
            if(style == 0) {
                style = getenv("TIME_STYLE");
                if(style == 0) {
                    style = "locale";
                }
            }
            while(strncmp(style, "posix-", 6) == 0) {
                if(((hard_locale(2) ^ 1) & 255) == 0) {
                    style =  &(style[6]);
                    continue;
                }
                _v112 = __imp__optind;
                goto L80;
            }
            if(( *style & 0xff) != 43) {
                _v108 =  *((intOrPtr*)( &time_style_types + __xargmatch_internal("time style", style,  &time_style_args,  &time_style_types, 4, argmatch_die) * 4));
                if(_v108 == 1) {
L72:
                    (134627972)[0] = "%Y-%m-%d %H:%M";
                    long_time_format = (134627972)[0];
                    goto L79;
                }
                goto L67;
L73:
                long_time_format = "%Y-%m-%d ";
                (134627972)[0] = "%m-%d %H:%M";
                goto L79;
            }
            p0 =  &(style[1]);
            p1 = strchr(p0, 10);
            if(p1 != 0) {
                if(strchr( &(p1[1]), 10) != 0) {
                    _t244 = quote(p0);
                    _t245 = gettext("invalid time style format %s");
                    _v160 = _t244;
                    error(2, 0, _t245);
                }
                 *p1 = 0;
                p1 =  &(p1[1]);
            } else {
                p1 = p0;
            }
            long_time_format = p0;
            (134627972)[0] = p1;
            goto L79;
L67:
            if(_v108 < 1) {
                (134627972)[0] = "%Y-%m-%d %H:%M:%S.%N %z";
                long_time_format =  *134627972;
                goto L79;
            }
            if(_v108 == 2) {
                goto L73;
            }
            if(_v108 == 3) {
                goto L74;
            }
            goto L79;
L74:
            if((hard_locale(2) & 255) == 0) {
                goto L79;
            }
            i = 0;
            while(i <= 1) {
                locale_format = dcgettext(0, ( &long_time_format)[i], 2);
                if(( &long_time_format)[i] == locale_format) {
                    goto L72;
                }
                ( &long_time_format)[i] = locale_format;
                i = i + 1;
            }
            goto L79;
        }
L80:
        return _v112;
    }
    p = indicator_style - 2 + "*=>|";
    while(( *p & 0xff) != 0) {
        set_char_quoting(filename_quoting_options,  *p & 0xff, 1);
        p =  &(p[1]);
    }
    goto L43;
}

_Bool get_funky_string(char** dest, const char** src, _Bool equals_end, size_t* output_count)
{// addr = 0x0804B7D9  --  defined in 'ls.c' at line 1950
    char* q;                               // _cfa_fffffff8
    const char* p;   // _cfa_fffffff4
    union  state;                          // _cfa_fffffff0
    size_t count;       // _cfa_ffffffec
    char num;                              // _cfa_ffffffeb
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32
    _Bool _t35;                            // _t35

    _v40 = _a12 & 255;
    p =  *src;
    q =  *dest;
    count = 0;
    num = 0;
    state = 0;
    while(state <= 4) {
        if(state <= 4) {
            goto L2;
        }
        abort();
        continue;
L2:
        goto __eax;
    }
     *dest = q;
     *src = p;
    _t35 = count;
     *output_count = _t35;
    return _t35;
}

parse_ls_color()
{// addr = 0x0804BAE2  --  defined in 'ls.c' at line 2144
    struct color_ext_type* e2;   // _cfa_fffffff4
    struct color_ext_type* e;   // _cfa_fffffff0
    struct color_ext_type* ext;   // _cfa_ffffffec
    int ind_no;                            // _cfa_ffffffe8
    int state;                             // _cfa_ffffffe4
    const char* p;   // _cfa_ffffffe0
    char* buf;                             // _cfa_ffffffdc
    signed int _v38;                       // _cfa_ffffffda
    char[2] label;                         // _cfa_ffffffd9
    _Bool _v44;                            // _cfa_ffffffd4
    _Bool _v48;                            // _cfa_ffffffd0
    int _v52;                              // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    int _v60;                              // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t148;                       // _t148
    _unknown_ _t153;                       // _t153
    _unknown_ _t163;                       // _t163
    _unknown_ _t169;                       // _t169
    const char* _t170;   // _t170
    _unknown_ _t172;                       // _t172
    char* _t189;                           // _t189
    char* _t190;                           // _t190
    _unknown_ _t191;                       // _t191
    const char* _t216;   // _t216

    __ecx = __ecx;
    p = getenv("LS_COLORS");
    _t150 = p;
    if(p == 0) {
L50:
        return;
L51:
    }
    _t150 =  *p & 255;
    if(( *p & 0xff) == 0) {
        goto L50;
    } else {
        ext = 0;
        memcpy( &label, "??", 3);
        color_buf = xstrdup(p);
        buf = color_buf;
        state = 1;
        while(state > 0) {
            _v60 = state;
            if(_v60 == 2) {
                if(( *p & 0xff) == 0) {
                    state = -1;
                } else {
                    _t170 = p;
                    _v38 =  *_t170 & 0xff;
                    p =  &(_t170[1]);
                    state = 3;
                }
                continue;
            }
            if(_v60 > 2) {
                if(_v60 == 3) {
                    state = -1;
                    p =  &(p[1]);
                    if((__ecx & 255) == 0) {
                        continue;
                    }
                } else {
                    if(_v60 == 4) {
                        p =  &(p[1]);
                        if((__ecx & 255) == 0) {
                            state = -1;
                        } else {
                            ext->seq.string = buf;
                            if((get_funky_string( &buf,  &p, 0,  &(ext->seq)) & 255) == 0) {
                                _v44 = -1;
                            } else {
                                _v44 = 1;
                            }
                            state = _v44;
                        }
                    }
                    continue;
                }
                ind_no = 0;
                while( *( &indicator_name + ind_no * 4) != 0) {
                    if(strcmp( &label,  *( &indicator_name + ind_no * 4)) != 0) {
                        ind_no = ind_no + 1;
                        continue;
                    }
                     *(134627812 + ind_no * 8) = buf;
                    if((get_funky_string( &buf,  &p, 0,  &color_indicator + (ind_no << 3)) & 255) == 0) {
                        _v48 = -1;
                    } else {
                        _v48 = 1;
                    }
                    state = _v48;
                    break;
                }
                if(state == 255) {
                    _t189 = quotearg( &label);
                    _t190 = gettext("unrecognized prefix: %s");
                    _v64 = _t189;
                    error(0, 0, _t190);
                }
                continue;
            }
            if(_v60 == 1) {
                _v56 =  *p & 0xff;
                if(_v56 == 42) {
                    ext = xmalloc(20);
                    ext->next = color_ext_list;
                    color_ext_list = ext;
                    p =  &(p[1]);
                    ext->ext.string = buf;
                    if((get_funky_string( &buf,  &p, 1, ext) & 255) == 0) {
                        _v52 = -1;
                    } else {
                        _v52 = 4;
                    }
                    state = _v52;
                } else {
                    if(_v56 == 58) {
                        p =  &(p[1]);
                    } else {
                        if(_v56 == 0) {
                            state = 0;
                        } else {
                            _t216 = p;
                            label =  *_t216 & 0xff;
                            p =  &(_t216[1]);
                            state = 2;
                        }
                    }
                }
            }
        }
        if(state >= 0) {
L47:
            _t150 =  *134627856;
            if( *134627856 != 6 || strncmp( *134627860, "target", 6) != 0) {
                goto L50;
            } else {
                color_symlink_as_referent = 1;
                return;
            }
            goto L51;
        }
        error(0, 0, gettext("unparsable value for LS_COLORS environment variable"));
        free(color_buf);
        e = color_ext_list;
        while(e != 0) {
            e2 = e;
            e = e->next;
            free(e2);
        }
        print_with_color = 0;
        goto L47;
    }
    goto L51;
}

set_exit_status(_Bool serious)
{// addr = 0x0804BE91  --  defined in 'ls.c' at line 2274
    signed int _v8;                        // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    _v8 = _a4 & 255;
    if(_v8 != 0) {
        exit_status = 2;
        return;
    }
    if(exit_status != 0) {
    } else {
        exit_status = 1;
        return;
    }
    goto L4;
L5:
L4:
    return;
    goto L5;
}

file_failure(_Bool serious, const char* message, const char* file)
{// addr = 0x0804BEC4  --  defined in 'ls.c' at line 2287
    signed char _v12;                      // _cfa_fffffff4
    char* _v16;                            // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    char* __ebx;                           // r1
    _unknown_ __ebp;                       // r6
    int* _t14;                             // _t14

    _v12 = _a4 & 255;
    __ebx = quotearg_colon(file);
    _t14 = __errno_location();
    _v16 = __ebx;
    error(0,  *_t14, message);
    set_exit_status(_v12 & 255);
    return;
}

queue_directory(const char* name, const char* realname, _Bool command_line_arg)
{// addr = 0x0804BF12  --  defined in 'ls.c' at line 2304
    struct pending* new;   // _cfa_fffffff8
    signed char _v24;                      // _cfa_ffffffe8
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    _unknown_ __ebp;                       // r6

    _v24 = _a12 & 255;
    new = xmalloc(16);
    if(realname == 0) {
        _v32 = 0;
    } else {
        _v32 = xstrdup(realname);
    }
    new->realname = _v32;
    if(name == 0) {
        _v28 = 0;
    } else {
        _v28 = xstrdup(name);
    }
    new->name = _v28;
    new->command_line_arg = _v24 & 0xff;
    new->next = pending_dirs;
    pending_dirs = new;
    return;
}

print_dir(const char* name, const char* realname, _Bool command_line_arg)
{// addr = 0x0804BF98  --  defined in 'ls.c' at line 2320
    char[651] buf;                         // _cfa_fffffd30
    const char* p;   // _cfa_fffffff0
    int __len;                             // _cfa_ffffffec
    struct obstack* __o;   // _cfa_ffffffe8
    int __len;                             // _cfa_ffffffe4
    struct obstack* __o;   // _cfa_ffffffe0
    union filetype type;   // _cfa_ffffffdc
    int __len;                             // _cfa_ffffffd8
    struct obstack* __o;   // _cfa_ffffffd4
    struct dev_ino* di;   // _cfa_ffffffd0
    int fd;                                // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    uintmax_t total_blocks;   // _cfa_ffffffc4
    struct dirent* next;   // _cfa_ffffffc0
    DIR* dirp;             // _cfa_ffffffbc
    int _v628;                             // _cfa_fffffd8c
    int _v716;                             // _cfa_fffffd34
    struct stat dir_stat;   // _cfa_fffffd30
    signed int _v736;                      // _cfa_fffffd20
    const char* _v740;   // _cfa_fffffd1c
    quoting_options* _v744;   // _cfa_fffffd18
    signed int _v748;                      // _cfa_fffffd14
    signed int _v749;                      // _cfa_fffffd13
    intOrPtr _v768;                        // _cfa_fffffd00
    long long unsigned int _v772;          // _cfa_fffffcfc
    const char* _v776;   // _cfa_fffffcf8
    int _v780;                             // _cfa_fffffcf4
    int _v784;                             // _cfa_fffffcf0
    long long unsigned int* _v788;         // _cfa_fffffcec
    int _v792;                             // _cfa_fffffce8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    DIR* _t216;            // _t216
    struct dirent* _t219;   // _t219
    DIR* _t222;            // _t222
    _unknown_ _t233;                       // _t233
    _unknown_ _t238;                       // _t238
    _unknown_ _t247;                       // _t247
    _unknown_ _t252;                       // _t252
    _unknown_ _t257;                       // _t257
    _unknown_ _t271;                       // _t271
    _unknown_ _t280;                       // _t280
    _unknown_ _t293;                       // _t293
    _unknown_ _t300;                       // _t300
    _unknown_ _t303;                       // _t303
    struct dirent* _t320;   // _t320
    _unknown_ _t325;                       // _t325
    int _t326;                             // _t326
    unsigned int _t328;                    // _t328
    char* _t347;                           // _t347
    char* _t348;                           // _t348
    unsigned int _t354;                    // _t354
    struct dev_ino* _t369;   // _t369
    struct dev_ino* _t370;   // _t370
    _unknown_ _t394;                       // _t394

    _v736 = _a12 & 255;
    total_blocks = 0;
    _v56 = 0;
     *(__errno_location()) = 0;
    _t216 = name;
     *__esp = _t216;
    opendir();
    dirp = _t216;
    if(dirp != 0) {
        if(active_dir_set == 0) {
L13:
            clear_files();
            while(1) {
L14:
                 *(__errno_location()) = 0;
                _t219 = dirp;
                 *__esp = _t219;
                readdir64();
                next = _t219;
                if(next == 0) {
                    break;
                }
L15:
                if(((file_ignored( &(next->d_name)) ^ 1) & 255) == 0) {
                    continue;
                }
                type = 0;
                _v748 = next->d_type & 0xff;
                if(_v748 > 14) {
                    _t320 = next;
                    _v776 = name;
                    _v780 = 0;
                    _v788 = _t320->d_ino;
                    _v784 =  *(_t320 + 4);
                    _v792 = type;
                     *__esp =  &(next->d_name);
                    total_blocks = total_blocks + gobble_file();
                    asm("adc [ebp-0x34], edx");
                    continue;
                }
                goto __eax;
                break;
            }
            if( *(__errno_location()) == 0) {
L21:
                _t222 = dirp;
                 *__esp = _t222;
                closedir();
                if(_t222 != 0) {
                    file_failure(_v736 & 255, gettext("closing directory %s"), name);
                }
                sort_files();
                if((recursive & 0xff) != 0) {
                    extract_dirs_from_files(name, _v736 & 255);
                }
                if((print_dir_name & 0xff | recursive & 0xff) != 0) {
                    if(((first & 255 ^ 1) & 255) != 0) {
                        putchar_unlocked(10);
                        dired_pos = dired_pos + 1;
                    }
                    first = 0;
                    if((dired & 0xff) != 0) {
                        fwrite_unlocked("  ", 1, 2, __imp__stdout);
                        dired_pos = dired_pos + 2;
                    }
                    if((dired & 0xff) != 0) {
                        __o =  &subdired_obstack;
                        __len = 4;
                        if( &(__o->next_free[__len]) > __o->chunk_limit) {
                            _v792 = __len;
                             *__esp = __o;
                            _obstack_newchunk();
                        }
                        memcpy(__o->next_free,  &dired_pos, __len);
                        __o->next_free =  &(__o->next_free[__len]);
                    }
                    _v744 = dirname_quoting_options;
                    if(realname == 0) {
                        _v740 = name;
                    } else {
                        _v740 = realname;
                    }
                    dired_pos = quote_name(__imp__stdout, _v740, _v744, 0) + dired_pos;
                    if((dired & 0xff) != 0) {
                        __o =  &subdired_obstack;
                        __len = 4;
                        if( &(__o->next_free[__len]) > __o->chunk_limit) {
                            _v792 = __len;
                             *__esp = __o;
                            _obstack_newchunk();
                        }
                        memcpy(__o->next_free,  &dired_pos, __len);
                        __o->next_free =  &(__o->next_free[__len]);
                    }
                    fwrite_unlocked(":\n", 1, 2, __imp__stdout);
                    dired_pos = dired_pos + 2;
                }
                if(format == 0 || (print_block_size & 0xff) != 0) {
                    if((dired & 0xff) != 0) {
                        fwrite_unlocked("  ", 1, 2, __imp__stdout);
                        dired_pos = dired_pos + 2;
                    }
                    p = gettext("total");
                    fputs_unlocked(p, __imp__stdout);
                    dired_pos = strlen(p) + dired_pos;
                    putchar_unlocked(32);
                    dired_pos = dired_pos + 1;
                    _v772 = output_block_size;
                    _v768 =  *134628524;
                    _v780 = 512;
                    _v776 = 0;
                    _v784 = human_output_opts;
                    _v788 =  &(dir_stat.st_dev);
                     *__esp = total_blocks;
                    _v792 = _v56;
                    p = human_readable();
                    fputs_unlocked(p, __imp__stdout);
                    dired_pos = strlen(p) + dired_pos;
                    putchar_unlocked(10);
                    dired_pos = dired_pos + 1;
                }
                if(cwd_n_used == 0) {
                    return;
                } else {
                    print_current_files();
                    return;
                }
            }
            file_failure(_v736 & 255, gettext("reading directory %s"), name);
            if( *(__errno_location()) == 75) {
                goto L14;
            }
            goto L21;
        }
        goto L3;
    }
    file_failure(_v736 & 255, gettext("cannot open directory %s"), name);
    return;
L3:
    _t326 = dirp;
     *__esp = _t326;
    dirfd();
    fd = _t326;
    if(fd >= 0) {
        _v792 =  &(dir_stat.st_dev);
        _t328 = name;
         *__esp = _t328;
        stat64();
        _v749 = _t328 >> 31 & 255;
    } else {
        _v792 =  &(dir_stat.st_dev);
        _t354 = fd;
         *__esp = _t354;
        fstat64();
        _v749 = _t354 >> 31 & 255;
    }
    if(_v749 == 0) {
        _v788 = dir_stat.st_ino;
        _v784 = _v628;
         *__esp = dir_stat.st_dev;
        _v792 = _v716;
        if((visit_dir() & 255) == 0) {
            __o =  &dev_ino_obstack;
            __len = 16;
            if(__o->chunk_limit - __o->next_free < __len) {
                _v792 = __len;
                 *__esp = __o;
                _obstack_newchunk();
            }
            __o->next_free =  &(__o->next_free[__len]);
            di = dev_ino_obstack.next_free - 16;
            _t369 = di;
             *(_t369 + 8) = dir_stat.st_dev;
             *(_t369 + 12) = _v716;
            _t370 = di;
            _t370->st_ino = dir_stat.st_ino;
             *(_t370 + 4) = _v628;
            goto L13;
        }
    } else {
        file_failure(_v736 & 255, gettext("cannot determine device and inode of %s"), name);
         *__esp = dirp;
        closedir();
        return;
    }
    _t347 = quotearg_colon(name);
    _t348 = gettext("%s: not listing already-listed directory");
    _v784 = _t347;
    error(0, 0, _t348);
     *__esp = dirp;
    closedir();
    return;
}

add_ignore_pattern(const char* pattern)
{// addr = 0x0804C66F  --  defined in 'ls.c' at line 2461
    struct ignore_pattern* ignore;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    ignore = xmalloc(8);
    ignore->pattern = pattern;
    ignore->next = ignore_patterns;
    ignore_patterns = ignore;
    return;
}

_Bool patterns_match(const struct ignore_pattern* patterns, const char* file)
{// addr = 0x0804C6A2  --  defined in 'ls.c' at line 2475
    const struct ignore_pattern* p;   // _cfa_fffffff8
    signed int _v21;                       // _cfa_ffffffeb
    intOrPtr _v36;                         // _cfa_ffffffdc
    const char* _v40;   // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    const char* _t16;   // _t16

    p = patterns;
    while(p != 0) {
        _v36 = 4;
        _t16 = file;
        _v40 = _t16;
         *__esp = p->pattern;
        fnmatch();
        if(_t16 != 0) {
            p = p->next;
            continue;
        }
        _v21 = 1;
L6:
        return _v21 & 255;
    }
    _v21 = 0;
    goto L6;
}

_Bool file_ignored(const char* name)
{// addr = 0x0804C6EF  --  defined in 'ls.c' at line 2487
    signed char _v8;                       // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if(ignore_mode == 2 || ( *name & 0xff) != 46) {
L7:
        if(ignore_mode != 0 || (patterns_match(hide_patterns, name) & 255) == 0) {
            if((patterns_match(ignore_patterns, name) & 255) == 0) {
                goto L11;
            }
        }
        goto L10;
    } else {
        if(ignore_mode == 0) {
L10:
            _v12 = 1;
L12:
            return _v12 & 255;
        }
        if((name[1] & 0xff) != 46) {
            _v8 = 1;
        } else {
            _v8 = 2;
        }
        if(( *(name + _v8) & 0xff) == 0) {
            goto L10;
        } else {
            goto L7;
        }
L11:
        _v12 = 0;
        goto L12;
    }
}

uintmax_t unsigned_file_size(off_t size)
{// addr = 0x0804C78B  --  defined in 'ls.c' at line 2502
    intOrPtr _v8;                          // _cfa_fffffff8
    long long unsigned int _v12;           // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    _v12 = _a4;
    _v8 = _a8;
    return _v12;
}

clear_files()
{// addr = 0x0804C7A5  --  defined in 'ls.c' at line 2512
    struct fileinfo* f;   // _cfa_fffffff8
    size_t i;           // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    _unknown_ _t25;                        // _t25

    i = 0;
    while(i < cwd_n_used) {
        f = sorted_file[i];
        free(f->name);
        free(f->linkname);
        if(f->scontext !=  &UNKNOWN_SECURITY_CONTEXT) {
            freecon(f->scontext);
        }
        i = i + 1;
    }
    cwd_n_used = 0;
    any_has_acl = 0;
    inode_number_width = 0;
    block_size_width = 0;
    nlink_width = 0;
    owner_width = 0;
    group_width = 0;
    author_width = 0;
    scontext_width = 0;
    major_device_number_width = 0;
    minor_device_number_width = 0;
    file_size_width = 0;
    return;
}

freecon(char* con)
{// addr = 0x0804C883  --  defined in 'selinux.h' at line 21
    _unknown_ __ebp;                       // r6

    return;
}

uintmax_t gobble_file(const char* name, union filetype type, ino_t inode, _Bool command_line_arg, const char* dirname)
{// addr = 0x0804C888  --  defined in 'ls.c' at line 2545
    char[651] buf;                         // _cfa_fffffcd0
    char[651] buf;                         // _cfa_fffffcd0
    _unknown_ _v8;                         // _cfa_fffffff8
    int len;                               // _cfa_fffffff0
    int len;                               // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    uintmax_t size;   // _cfa_ffffffe4
    int len;                               // _cfa_ffffffe0
    int b_len;                             // _cfa_ffffffdc
    int len;                               // _cfa_ffffffd8
    int len;                               // _cfa_ffffffd4
    int len;                               // _cfa_ffffffd0
    int len;                               // _cfa_ffffffcc
    int len;                               // _cfa_ffffffc8
    char* linkname;                        // _cfa_ffffffc4
    int n;                                 // _cfa_ffffffc0
    int attr_len;                          // _cfa_ffffffbc
    _Bool have_acl;                        // _cfa_ffffffbb
    _Bool need_lstat;                      // _cfa_ffffffba
    int err;                               // _cfa_ffffffb4
    _Bool do_deref;                        // _cfa_ffffffb3
    char* absolute_name;                   // _cfa_ffffffac
    struct fileinfo* f;   // _cfa_ffffffa8
    int _v96;                              // _cfa_ffffffa0
    uintmax_t blocks;   // _cfa_ffffff9c
    char[20] b;                            // _cfa_ffffff87
    char[20] buf;                          // _cfa_ffffff72
    char[20] buf;                          // _cfa_ffffff5d
    struct stat linkstats;   // _cfa_fffffcd0
    long long unsigned int _v832;          // _cfa_fffffcc0
    long long unsigned int _v836;          // _cfa_fffffcbc
    signed int _v840;                      // _cfa_fffffcb8
    int _v844;                             // _cfa_fffffcb4
    int _v848;                             // _cfa_fffffcb0
    long long unsigned int _v852;          // _cfa_fffffcac
    signed char _v853;                     // _cfa_fffffcab
    union Dereference_symlink _v860;   // _cfa_fffffca4
    signed int _v864;                      // _cfa_fffffca0
    char _v876;                            // _cfa_fffffc94
    intOrPtr _v880;                        // _cfa_fffffc90
    long long unsigned int _v884;          // _cfa_fffffc8c
    int _v888;                             // _cfa_fffffc88
    long long unsigned int _v892;          // _cfa_fffffc84
    int _v896;                             // _cfa_fffffc80
    long long unsigned int* _v900;         // _cfa_fffffc7c
    int _v904;                             // _cfa_fffffc78
    _unknown_ __ebp;                       // r6
    _unknown_ _t380;                       // _t380
    int _t389;                             // _t389
    struct fileinfo* _t419;   // _t419
    struct fileinfo* _t439;   // _t439
    struct fileinfo* _t454;   // _t454
    long long unsigned int _t455;          // _t455
    struct fileinfo* _t460;   // _t460
    long long unsigned int _t461;          // _t461
    struct fileinfo* _t476;   // _t476
    _unknown_ _t531;                       // _t531
    char* _t534;                           // _t534
    char* _t545;                           // _t545
    int* _t546;                            // _t546
    signed int _t556;                      // _t556
    int _t575;                             // _t575
    int _t586;                             // _t586
    int _t590;                             // _t590
    _unknown_ _t634;                       // _t634
    struct fileinfo* _t638;   // _t638
    _unknown_ _t641;                       // _t641
    _unknown_ _t642;                       // _t642
    _unknown_ _t643;                       // _t643
    _unknown_ _t659;                       // _t659
    int _t667;                             // _t667

    _push(__ebx);
    __esp = __esp - 900;
    _v836 = _a12;
    _v832 = _a16;
    _v840 = _a20 & 255;
    blocks = 0;
    _v96 = 0;
    if(_v840 != 0) {
        if((_v836 | _v832) != 0) {
            _v896 = "gobble_file";
            _v900 = 2551;
            _v904 = "ls.c";
             *__esp = "! command_line_arg || inode == NOT_AN_INODE_NUMBER";
            __assert_fail();
        }
    }
    if(cwd_n_used == cwd_n_alloc) {
        cwd_file = xnrealloc(cwd_file, cwd_n_alloc, 240);
        cwd_n_alloc = cwd_n_alloc + cwd_n_alloc;
    }
    f = cwd_file + (0 + cwd_n_used * 8 << 4) - 0 + cwd_n_used * 8;
    memset(f, 0, 120);
    _t638 = f;
    _t638->stat.st_dev = _v836;
    _t638->stat.st_dev = _v832;
    f->filetype.st_dev = type;
    if(_v840 != 0 || (format_needs_stat & 0xff) != 0 || type == 3 && (print_with_color & 0xff) != 0) {
L27:
        if(( *name & 0xff) == 47) {
L29:
            absolute_name = name;
L31:
            _v860 = dereference;
            if(_v860 < 3) {
L41:
                _v904 =  &(f->stat);
                _t389 = absolute_name;
                 *__esp = _t389;
                lstat64();
                err = _t389;
                do_deref = 0;
                goto L42;
            }
L32:
            if(_v860 <= 4) {
                if(_v840 == 0) {
                    goto L41;
                }
                goto L36;
            }
            if(_v860 != 5) {
                goto L41;
            } else {
                _v904 =  &(f->stat);
                _t586 = absolute_name;
                 *__esp = _t586;
                stat64();
                err = _t586;
                do_deref = 1;
            }
            goto L42;
L36:
            _v904 =  &(f->stat);
            _t575 = absolute_name;
             *__esp = _t575;
            stat64();
            err = _t575;
            do_deref = 1;
            if(dereference == 3) {
                goto L42;
            } else {
                if(err >= 0) {
                    _v853 = (f->stat.st_dev & 61440) != 16384;
                } else {
                    _v853 =  *(__errno_location()) == 2;
                }
            }
            need_lstat = _v853 & 0xff;
            if(((need_lstat & 255 ^ 1) & 255) != 0) {
                goto L42;
            }
            goto L41;
L42:
            if(err == 0) {
                f->stat_ok.st_dev = 1;
                if(format == 0 || (print_scontext & 0xff) != 0) {
                    have_acl = 0;
                    if(do_deref == 0) {
                        _v844 = lgetfilecon(absolute_name,  &(f->scontext));
                    } else {
                        _v844 = getfilecon(absolute_name,  &(f->scontext));
                    }
                    attr_len = _v844;
                    err = attr_len >> 31;
                    if(err != 0) {
                        f->scontext.st_dev =  &UNKNOWN_SECURITY_CONTEXT;
                        if( *(__errno_location()) == 95 ||  *(__errno_location()) == 61) {
                            err = 0;
                        }
                    } else {
                        have_acl = strcmp("unlabeled", f->scontext.st_dev) & 255;
                    }
                    if(err == 0 && ((have_acl & 255 ^ 1) & 255) != 0 && format == 0) {
                        n = file_has_acl(absolute_name,  &(f->stat));
                        _t556 = n >> 31;
                        err = _t556;
                        have_acl = _t556 & 255;
                    }
                    f->have_acl.st_dev = have_acl & 0xff;
                    any_has_acl = (have_acl & 255 | any_has_acl & 0xff) & 255;
                    if(err != 0) {
                        _t545 = quotearg_colon(absolute_name);
                        _t546 = __errno_location();
                        _v896 = _t545;
                        error(0,  *_t546, "%s");
                    }
                }
                if((f->stat.st_dev & 61440) == 40960 && (format == 0 || (check_symlink_color & 0xff) != 0)) {
                    get_link_name(absolute_name, f, _v840 & 255);
                    linkname = make_link_name(absolute_name, f->linkname.st_dev);
                    if(linkname != 0 && (indicator_style > 1 || (check_symlink_color & 0xff) != 0)) {
                        _v904 =  &(linkstats.st_dev);
                        _t534 = linkname;
                         *__esp = _t534;
                        stat64();
                        if(_t534 == 0) {
                            f->linkok.st_dev = 1;
                            if(((_v840 & 255 ^ 1) & 255) != 0 || format == 0 || (_v800 & 61440) != 16384) {
                                 *(f + 108) = linkstats.st_mode;
                            }
                        }
                    }
                    free(linkname);
                }
                if((f->stat.st_dev & 61440) == 40960 && ((check_symlink_color & 255 ^ 1) & 255) != 0) {
                    f->linkok.st_dev = 1;
                }
                if((f->stat.st_dev & 61440) != 40960) {
                    if((f->stat.st_dev & 61440) != 16384) {
                        f->filetype.st_dev = 5;
                    } else {
                        if(((immediate_dirs & 255 ^ 1) & 0xff & _v840 & 255) == 0) {
                            f->filetype.st_dev = 3;
                        } else {
                            f->filetype.st_dev = 9;
                        }
                    }
                } else {
                    f->filetype.st_dev = 6;
                }
                _t419 = f;
                blocks = _t419->stat;
                _v96 = _t419->stat.st_dev;
                if(format == 0 || (print_block_size & 0xff) != 0) {
                    _v884 = output_block_size;
                    _v880 =  *134628524;
                    _v892 = 512;
                    _v888 = 0;
                    _v896 = human_output_opts;
                    _v900 =  &(linkstats.st_dev);
                     *__esp = blocks;
                    _v904 = _v96;
                    len = gnu_mbswidth(human_readable(), 0);
                    if(block_size_width < len) {
                        block_size_width = len;
                    }
                }
                if(format != 0) {
L98:
                    if((print_scontext & 0xff) != 0) {
                        len = strlen(f->scontext.st_dev);
                        if(scontext_width < len) {
                            scontext_width = len;
                        }
                    }
                    if(format == 0) {
                        _v900 =  &b;
                         *__esp = f->stat.st_dev;
                        _v904 = 0;
                        b_len = strlen(umaxtostr());
                        if(nlink_width < b_len) {
                            nlink_width = b_len;
                        }
                        if((f->stat.st_dev & 61440) == 8192 || (f->stat.st_dev & 61440) == 24576) {
                            _t454 = f;
                            _t455 = _t454->stat.st_dev;
                             *__esp = _t455;
                            _v904 = _t454->stat.st_dev;
                            gnu_dev_major();
                            _v900 =  &buf;
                             *__esp = _t455;
                            _v904 = 0;
                            len = strlen(umaxtostr());
                            if(major_device_number_width < len) {
                                major_device_number_width = len;
                            }
                            _t460 = f;
                            _t461 = _t460->stat.st_dev;
                             *__esp = _t461;
                            _v904 = _t460->stat.st_dev;
                            gnu_dev_minor();
                            _v900 =  &buf;
                             *__esp = _t461;
                            _v904 = 0;
                            len = strlen(umaxtostr());
                            if(minor_device_number_width < len) {
                                minor_device_number_width = len;
                            }
                            len = major_device_number_width + 2 + minor_device_number_width;
                            if(file_size_width < len) {
                                file_size_width = len;
                            }
                        } else {
                            _t476 = f;
                            _t667 = _t476->stat.st_dev;
                             *__esp = _t476->stat.st_dev;
                            _v904 = _t667;
                            size = unsigned_file_size();
                            _v24 = _t667;
                            _v884 = file_output_block_size;
                            _v880 =  *134627796;
                            _v892 = 1;
                            _v888 = 0;
                            _v896 = human_output_opts;
                            _v900 =  &(linkstats.st_dev);
                             *__esp = size;
                            _v904 = _v24;
                            len = gnu_mbswidth(human_readable(), 0);
                            if(file_size_width < len) {
                                file_size_width = len;
                            }
                        }
                    }
                    goto L114;
                } else {
                    if((print_owner & 0xff) != 0) {
                        len = format_user_width(f->stat.st_dev);
                        if(owner_width < len) {
                            owner_width = len;
                        }
                    }
                    if((print_group & 0xff) != 0) {
                        len = format_group_width(f->stat.st_dev);
                        if(group_width < len) {
                            group_width = len;
                        }
                    }
                    if((print_author & 0xff) != 0) {
                        len = format_user_width(f->stat.st_dev);
                        if(author_width < len) {
                            author_width = len;
                        }
                    }
                    goto L98;
                }
            } else {
                file_failure(_v840 & 255, gettext("cannot access %s"), absolute_name);
                if(_v840 == 0) {
                    f->name = xstrdup(name);
                    cwd_n_used = cwd_n_used + 1;
                    _v852 = 0;
                    _v848 = 0;
                } else {
                    _v852 = 0;
                    _v848 = 0;
                }
            }
            goto L118;
        }
    } else {
        if((print_inode & 0xff) != 0 || (format_needs_type & 0xff) != 0) {
            if(type == 6 || type == 0) {
                if(dereference == 5 || ((_v840 & 255 ^ 1) & 255) == 0 && dereference != 2 || (color_symlink_as_referent & 0xff) != 0 || (check_symlink_color & 0xff) != 0) {
                    goto L27;
                } else {
                    goto L18;
                }
                goto L28;
            }
        }
L18:
        if(((print_inode & 255 ^ 1) & 255) != 0 || (_v836 | _v832) != 0) {
            if(((format_needs_type & 255 ^ 1) & 255) != 0 || type != 0 && _v840 == 0 && (type != 5 || indicator_style != 3 && (((print_with_color & 255 ^ 1) & 255) != 0 || (is_colored(13) & 255) == 0))) {
L114:
                if((print_inode & 0xff) != 0) {
                    _t439 = f;
                    _v900 =  &buf;
                     *__esp = _t439->stat.st_dev;
                    _v904 = _t439->stat.st_dev;
                    len = strlen(umaxtostr());
                    if(inode_number_width < len) {
                        inode_number_width = len;
                    }
                }
                f->name = xstrdup(name);
                cwd_n_used = cwd_n_used + 1;
                _v852 = blocks;
                _v848 = _v96;
L118:
                return _v852;
            } else {
                goto L27;
            }
        }
        goto L27;
    }
L28:
    if(( *dirname & 0xff) != 0) {
        _t590 = strlen(name);
        __esp = __esp - (_t590 + strlen(dirname) + 0x20 >> 4 << 4);
        _v864 =  &_v876;
        _v864 =  &(_v864[0xf]) >> 4 << 4;
        absolute_name = _v864;
        attach(absolute_name, dirname, name);
        goto L31;
    }
    goto L29;
}

int getfilecon(const char* s, char** con)
{// addr = 0x0804D30D  --  defined in 'selinux.h' at line 33
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3

     *(__errno_location()) = 95;
    return -1;
}

int lgetfilecon(const char* s, char** con)
{// addr = 0x0804D325  --  defined in 'selinux.h' at line 35
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t3;                         // _t3

     *(__errno_location()) = 95;
    return -1;
}

_Bool is_directory(const struct fileinfo* f)
{// addr = 0x0804D33D  --  defined in 'ls.c' at line 2839
    signed char _v8;                       // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    if(f->filetype == 3 || f->filetype == 9) {
        _v8 = 1;
    } else {
        _v8 = 0;
    }
    return _v8 & 255;
}

get_link_name(const char* filename, struct fileinfo* f, _Bool command_line_arg)
{// addr = 0x0804D36F  --  defined in 'ls.c' at line 2849
    signed char _v8;                       // _cfa_fffffff8
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27

    _v8 = _a12 & 255;
    f->linkname = areadlink_with_size(filename, f->stat);
    if(f->linkname == 0) {
        file_failure(_v8 & 255, gettext("cannot read symbolic link %s"), filename);
        return;
    }
    return;
}

char* make_link_name(const char* name, const char* linkname)
{// addr = 0x0804D3CA  --  defined in 'ls.c' at line 2863
    size_t bufsiz;      // _cfa_fffffff8
    char* linkbuf;                         // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t48;                        // _t48
    _unknown_ _t51;                        // _t51

    if(linkname != 0) {
        if(( *linkname & 0xff) != 47) {
            linkbuf = strrchr(name, 47);
            if(linkbuf != 0) {
                bufsiz = linkbuf - name + 1;
                linkbuf = xmalloc(strlen(linkname) + bufsiz + 1);
                strncpy(linkbuf, name, bufsiz);
                strcpy( &(linkbuf[bufsiz]), linkname);
                _v24 = linkbuf;
            } else {
                _v24 = xstrdup(linkname);
            }
        } else {
            _v24 = xstrdup(linkname);
        }
    } else {
        _v24 = 0;
    }
    return _v24;
}

_Bool basename_is_dot_or_dotdot(const char* name)
{// addr = 0x0804D495  --  defined in 'ls.c' at line 2891
    const char* base;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    base = last_component(name);
    return dot_or_dotdot(base);
}

_Bool dot_or_dotdot(const char* file_name)
{// addr = 0x0804D4B6  --  defined in 'system.h' at line 365
    char sep;                              // _cfa_fffffffb
    signed char _v24;                      // _cfa_ffffffe8
    signed char _v25;                      // _cfa_ffffffe7
    signed char _v32;                      // _cfa_ffffffe0
    _unknown_ __ebp;                       // r6

    if(( *file_name & 0xff) != 46) {
        _v25 = 0;
    } else {
        if((file_name[1] & 0xff) != 46) {
            _v32 = 1;
        } else {
            _v32 = 2;
        }
        sep =  *(file_name + _v32) & 0xff;
        if(sep == 0 || sep == 47) {
            _v24 = 1;
        } else {
            _v24 = 0;
        }
        _v25 = _v24 & 0xff;
    }
    return _v25 & 255;
}

extract_dirs_from_files(const char* dirname, _Bool command_line_arg)
{// addr = 0x0804D51E  --  defined in 'ls.c' at line 2906
    struct fileinfo* f;   // _cfa_fffffff8
    char* name;                            // _cfa_fffffff4
    struct fileinfo* f;   // _cfa_fffffff0
    _Bool ignore_dot_and_dot_dot;          // _cfa_ffffffef
    size_t j;           // _cfa_ffffffe8
    size_t i;           // _cfa_ffffffe4
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t79;                       // _t79
    signed int _t80;                       // _t80
    _unknown_ _t105;                       // _t105

    _t79 = _a8;
    _v40 = _t79 & 255;
    ignore_dot_and_dot_dot = _t79 & 255;
    if(dirname != 0 && active_dir_set != 0) {
        queue_directory(0, dirname, 0);
    }
    _t80 = cwd_n_used;
    i = _t80;
    while(1) {
        i = i - 1;
        if((_t80 & 255) != 0) {
            goto L4;
        } else {
            i = 0;
            j = 0;
            goto L16;
        }
    }
}

int xstrcoll(const char* a, const char* b)
{// addr = 0x0804D6BB  --  defined in 'ls.c' at line 2961
    int diff;                              // _cfa_ffffffec
    const _None* _v44;   // _cfa_ffffffd4
    const _None* _v48;   // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    int _v56;                              // _cfa_ffffffc8
    const _None* __edi;   // r4
    char* __esi;                           // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t15;                        // _t15
    const _None* _t26;   // _t26
    int* _t28;                             // _t28

     *(__errno_location()) = 0;
    diff = strcoll(a, b);
    if( *(__errno_location()) != 0) {
        __edi = quote_n(1, b);
        _t26 = quote_n(0, a);
        __esi = gettext("cannot compare file names %s and %s");
        _t28 = __errno_location();
        _v44 = __edi;
        _v48 = _t26;
        error(0,  *_t28, __esi);
        set_exit_status(0);
        _v56 = 1;
         *__esp =  &failed_strcoll;
        longjmp();
    }
    return diff;
}

int xstrcoll_ctime(V a, V b)
{// addr = 0x0804D775  --  defined in 'ls.c' at line 3080
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_ctime(a, b, xstrcoll);
}

int cmp_ctime(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804D797  --  defined in 'ls.c' at line 3028
    int diff;                              // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    struct stat* _v20;    // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _v40;                              // _cfa_ffffffd8
    struct stat* _v56;    // _cfa_ffffffc8
    struct stat* _v60;    // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    _None* _t36;                           // _t36

    _v56 =  &(a->stat);
    get_stat_ctime( &_v24);
    __esp = __esp - 4;
    _v60 =  &(b->stat);
    get_stat_ctime( &_v16);
    __esp = __esp - 4;
    _v60 = _v24;
    _v56 = _v20;
     *__esp = _v16;
    _v64 = _v12;
    diff = timespec_cmp();
    if(diff != 0) {
        _v40 = diff;
    } else {
        _v64 = b->name;
         *__esp = a->name;
        _t36 = cmp;
         *_t36();
        _v40 = _t36;
    }
    return;
}

struct timespec get_stat_ctime(const struct stat* st)
{// addr = 0x0804D81C  --  defined in 'stat-time.h' at line 117
    _unknown_ __ebp;                       // r6
    const struct stat* _t6;   // _t6

    __ecx = _a4;
    _t6 = st;
     *__ecx = _t6->st_ctim.tv_sec;
     *(__ecx + 4) = _t6->st_ctim.tv_nsec;
    return __ecx;
}

int timespec_cmp(struct timespec a, struct timespec b)
{// addr = 0x0804D836  --  defined in 'timespec.h' at line 27
    int _v8;                               // _cfa_fffffff8
    int _v12;                              // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    if(a.tv_sec < b.tv_sec) {
        _v12 = -1;
    } else {
        if(a.tv_sec > b.tv_sec) {
            _v8 = 1;
        } else {
            _v8 = a.tv_nsec - b.tv_nsec;
        }
        _v12 = _v8;
    }
    return _v12;
}

int strcmp_ctime(V a, V b)
{// addr = 0x0804D87A  --  defined in 'ls.c' at line 3080
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_ctime(a, b, strcmp);
}

int rev_xstrcoll_ctime(V a, V b)
{// addr = 0x0804D89C  --  defined in 'ls.c' at line 3080
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_ctime(b, a, xstrcoll);
}

int rev_strcmp_ctime(V a, V b)
{// addr = 0x0804D8BE  --  defined in 'ls.c' at line 3080
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_ctime(b, a, strcmp);
}

int xstrcoll_df_ctime(V a, V b)
{// addr = 0x0804D8E0  --  defined in 'ls.c' at line 3080
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_ctime(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_ctime(V a, V b)
{// addr = 0x0804D958  --  defined in 'ls.c' at line 3080
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_ctime(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_ctime(V a, V b)
{// addr = 0x0804D9D0  --  defined in 'ls.c' at line 3080
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_ctime(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_ctime(V a, V b)
{// addr = 0x0804DA48  --  defined in 'ls.c' at line 3080
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_ctime(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_mtime(V a, V b)
{// addr = 0x0804DAC0  --  defined in 'ls.c' at line 3081
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_mtime(a, b, xstrcoll);
}

int cmp_mtime(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804DAE2  --  defined in 'ls.c' at line 3037
    int diff;                              // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    struct stat* _v20;    // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _v40;                              // _cfa_ffffffd8
    struct stat* _v56;    // _cfa_ffffffc8
    struct stat* _v60;    // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    _None* _t36;                           // _t36

    _v56 =  &(a->stat);
    get_stat_mtime( &_v24);
    __esp = __esp - 4;
    _v60 =  &(b->stat);
    get_stat_mtime( &_v16);
    __esp = __esp - 4;
    _v60 = _v24;
    _v56 = _v20;
     *__esp = _v16;
    _v64 = _v12;
    diff = timespec_cmp();
    if(diff != 0) {
        _v40 = diff;
    } else {
        _v64 = b->name;
         *__esp = a->name;
        _t36 = cmp;
         *_t36();
        _v40 = _t36;
    }
    return;
}

struct timespec get_stat_mtime(const struct stat* st)
{// addr = 0x0804DB67  --  defined in 'stat-time.h' at line 131
    _unknown_ __ebp;                       // r6
    const struct stat* _t6;   // _t6

    __ecx = _a4;
    _t6 = st;
     *__ecx = _t6->st_mtim.tv_sec;
     *(__ecx + 4) = _t6->st_mtim.tv_nsec;
    return __ecx;
}

int strcmp_mtime(V a, V b)
{// addr = 0x0804DB81  --  defined in 'ls.c' at line 3081
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_mtime(a, b, strcmp);
}

int rev_xstrcoll_mtime(V a, V b)
{// addr = 0x0804DBA3  --  defined in 'ls.c' at line 3081
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_mtime(b, a, xstrcoll);
}

int rev_strcmp_mtime(V a, V b)
{// addr = 0x0804DBC5  --  defined in 'ls.c' at line 3081
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_mtime(b, a, strcmp);
}

int xstrcoll_df_mtime(V a, V b)
{// addr = 0x0804DBE7  --  defined in 'ls.c' at line 3081
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_mtime(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_mtime(V a, V b)
{// addr = 0x0804DC5F  --  defined in 'ls.c' at line 3081
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_mtime(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_mtime(V a, V b)
{// addr = 0x0804DCD7  --  defined in 'ls.c' at line 3081
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_mtime(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_mtime(V a, V b)
{// addr = 0x0804DD4F  --  defined in 'ls.c' at line 3081
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_mtime(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_atime(V a, V b)
{// addr = 0x0804DDC7  --  defined in 'ls.c' at line 3082
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_atime(a, b, xstrcoll);
}

int cmp_atime(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804DDE9  --  defined in 'ls.c' at line 3046
    int diff;                              // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    struct stat* _v20;    // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    int _v40;                              // _cfa_ffffffd8
    struct stat* _v56;    // _cfa_ffffffc8
    struct stat* _v60;    // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    _None* _t36;                           // _t36

    _v56 =  &(a->stat);
    get_stat_atime( &_v24);
    __esp = __esp - 4;
    _v60 =  &(b->stat);
    get_stat_atime( &_v16);
    __esp = __esp - 4;
    _v60 = _v24;
    _v56 = _v20;
     *__esp = _v16;
    _v64 = _v12;
    diff = timespec_cmp();
    if(diff != 0) {
        _v40 = diff;
    } else {
        _v64 = b->name;
         *__esp = a->name;
        _t36 = cmp;
         *_t36();
        _v40 = _t36;
    }
    return;
}

struct timespec get_stat_atime(const struct stat* st)
{// addr = 0x0804DE6E  --  defined in 'stat-time.h' at line 103
    _unknown_ __ebp;                       // r6
    const struct stat* _t6;   // _t6

    __ecx = _a4;
    _t6 = st;
     *__ecx = _t6->st_atim.tv_sec;
     *(__ecx + 4) = _t6->st_atim.tv_nsec;
    return __ecx;
}

int strcmp_atime(V a, V b)
{// addr = 0x0804DE88  --  defined in 'ls.c' at line 3082
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_atime(a, b, strcmp);
}

int rev_xstrcoll_atime(V a, V b)
{// addr = 0x0804DEAA  --  defined in 'ls.c' at line 3082
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_atime(b, a, xstrcoll);
}

int rev_strcmp_atime(V a, V b)
{// addr = 0x0804DECC  --  defined in 'ls.c' at line 3082
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_atime(b, a, strcmp);
}

int xstrcoll_df_atime(V a, V b)
{// addr = 0x0804DEEE  --  defined in 'ls.c' at line 3082
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_atime(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_atime(V a, V b)
{// addr = 0x0804DF66  --  defined in 'ls.c' at line 3082
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_atime(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_atime(V a, V b)
{// addr = 0x0804DFDE  --  defined in 'ls.c' at line 3082
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_atime(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_atime(V a, V b)
{// addr = 0x0804E056  --  defined in 'ls.c' at line 3082
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_atime(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_size(V a, V b)
{// addr = 0x0804E0CE  --  defined in 'ls.c' at line 3083
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_size(a, b, xstrcoll);
}

int cmp_size(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804E0F0  --  defined in 'ls.c' at line 3055
    int diff;                              // _cfa_fffffff8
    int _v24;                              // _cfa_ffffffe8
    long long unsigned int _v32;           // _cfa_ffffffe0
    long long unsigned int _v36;           // _cfa_ffffffdc
    long long unsigned int _v40;           // _cfa_ffffffd8
    long long unsigned int _v44;           // _cfa_ffffffd4
    long long unsigned int _v48;           // _cfa_ffffffd0
    long long unsigned int _v52;           // _cfa_ffffffcc
    long long unsigned int _v56;           // _cfa_ffffffc8
    long long unsigned int _v60;           // _cfa_ffffffc4
    int _v64;                              // _cfa_ffffffc0
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    const struct fileinfo* _t47;   // _t47
    const struct fileinfo* _t48;   // _t48
    _unknown_ _t50;                        // _t50
    _None* _t54;                           // _t54
    const struct fileinfo* _t56;   // _t56
    const struct fileinfo* _t57;   // _t57

    _t47 = b;
    _v60 = _t47->stat.st_dev;
    _v56 = _t47->stat.st_dev;
    _t48 = a;
    _v52 = _t48->stat.st_dev;
    _v48 = _t48->stat.st_dev;
    if(_v56 < _v48) {
L7:
        _v64 = -1;
        goto L8;
    }
    if(_v56 > _v48 || _v60 >= _v52) {
        _t56 = b;
        _v44 = _t56->stat.st_dev;
        _v40 = _t56->stat.st_dev;
        _t57 = a;
        _v36 = _t57->stat.st_dev;
        _v32 = _t57->stat.st_dev;
        _v64 = 1;
        if(_v40 <= _v32 && (_v40 < _v32 || _v44 <= _v36)) {
            _v64 = 0;
        }
        goto L8;
    }
    goto L7;
L8:
    diff = _v64;
    if(diff != 0) {
        _v24 = diff;
    } else {
        _v72 = b->name;
         *__esp = a->name;
        _t54 = cmp;
         *_t54();
        _v24 = _t54;
    }
    return;
}

int strcmp_size(V a, V b)
{// addr = 0x0804E1AB  --  defined in 'ls.c' at line 3083
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_size(a, b, strcmp);
}

int rev_xstrcoll_size(V a, V b)
{// addr = 0x0804E1CD  --  defined in 'ls.c' at line 3083
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_size(b, a, xstrcoll);
}

int rev_strcmp_size(V a, V b)
{// addr = 0x0804E1EF  --  defined in 'ls.c' at line 3083
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_size(b, a, strcmp);
}

int xstrcoll_df_size(V a, V b)
{// addr = 0x0804E211  --  defined in 'ls.c' at line 3083
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_size(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_size(V a, V b)
{// addr = 0x0804E289  --  defined in 'ls.c' at line 3083
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_size(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_size(V a, V b)
{// addr = 0x0804E301  --  defined in 'ls.c' at line 3083
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_size(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_size(V a, V b)
{// addr = 0x0804E379  --  defined in 'ls.c' at line 3083
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_size(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_name(V a, V b)
{// addr = 0x0804E3F1  --  defined in 'ls.c' at line 3084
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_name(a, b, xstrcoll);
}

int cmp_name(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804E413  --  defined in 'ls.c' at line 3063
    char* _v8;                             // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    _v8 = b->name;
     *__esp = a->name;
     *cmp();
    return;
}

int strcmp_name(V a, V b)
{// addr = 0x0804E431  --  defined in 'ls.c' at line 3084
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_name(a, b, strcmp);
}

int rev_xstrcoll_name(V a, V b)
{// addr = 0x0804E453  --  defined in 'ls.c' at line 3084
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_name(b, a, xstrcoll);
}

int rev_strcmp_name(V a, V b)
{// addr = 0x0804E475  --  defined in 'ls.c' at line 3084
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_name(b, a, strcmp);
}

int xstrcoll_df_name(V a, V b)
{// addr = 0x0804E497  --  defined in 'ls.c' at line 3084
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_name(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_name(V a, V b)
{// addr = 0x0804E50F  --  defined in 'ls.c' at line 3084
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_name(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_name(V a, V b)
{// addr = 0x0804E587  --  defined in 'ls.c' at line 3084
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_name(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_name(V a, V b)
{// addr = 0x0804E5FF  --  defined in 'ls.c' at line 3084
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_name(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_extension(V a, V b)
{// addr = 0x0804E677  --  defined in 'ls.c' at line 3085
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_extension(a, b, xstrcoll);
}

int cmp_extension(const struct fileinfo* a, const struct fileinfo* b, _None* cmp)
{// addr = 0x0804E699  --  defined in 'ls.c' at line 3073
    int diff;                              // _cfa_fffffff8
    const char* base2;   // _cfa_fffffff4
    const char* base1;   // _cfa_fffffff0
    int _v24;                              // _cfa_ffffffe8
    const char* _v28;   // _cfa_ffffffe4
    const char* _v32;   // _cfa_ffffffe0
    const char* _v40;   // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    int _t37;                              // _t37
    _unknown_ _t39;                        // _t39
    _None* _t43;                           // _t43

    base1 = strrchr(a->name, 46);
    base2 = strrchr(b->name, 46);
    if(base2 == 0) {
        _v32 = 134606192;
    } else {
        _v32 = base2;
    }
    if(base1 == 0) {
        _v28 = 134606192;
    } else {
        _v28 = base1;
    }
    _v40 = _v32;
     *__esp = _v28;
    _t37 = cmp;
     *_t37();
    diff = _t37;
    if(diff != 0) {
        _v24 = diff;
    } else {
        _v40 = b->name;
         *__esp = a->name;
        _t43 = cmp;
         *_t43();
        _v24 = _t43;
    }
    return;
}

int strcmp_extension(V a, V b)
{// addr = 0x0804E73A  --  defined in 'ls.c' at line 3085
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_extension(a, b, strcmp);
}

int rev_xstrcoll_extension(V a, V b)
{// addr = 0x0804E75C  --  defined in 'ls.c' at line 3085
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_extension(b, a, xstrcoll);
}

int rev_strcmp_extension(V a, V b)
{// addr = 0x0804E77E  --  defined in 'ls.c' at line 3085
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return cmp_extension(b, a, strcmp);
}

int xstrcoll_df_extension(V a, V b)
{// addr = 0x0804E7A0  --  defined in 'ls.c' at line 3085
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_extension(a, b, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int strcmp_df_extension(V a, V b)
{// addr = 0x0804E818  --  defined in 'ls.c' at line 3085
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_extension(a, b, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_extension(V a, V b)
{// addr = 0x0804E890  --  defined in 'ls.c' at line 3085
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_extension(b, a, xstrcoll);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_strcmp_df_extension(V a, V b)
{// addr = 0x0804E908  --  defined in 'ls.c' at line 3085
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_extension(b, a, strcmp);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int xstrcoll_version(V a, V b)
{// addr = 0x0804E980  --  defined in 'ls.c' at line 3103
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return cmp_version(a, b);
}

int cmp_version(const struct fileinfo* a, const struct fileinfo* b)
{// addr = 0x0804E99A  --  defined in 'ls.c' at line 3098
    char* _v8;                             // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    int _t6;                               // _t6

    _t6 = a->name;
    _v8 = b->name;
     *__esp = _t6;
    strverscmp();
    return _t6;
}

int rev_xstrcoll_version(V a, V b)
{// addr = 0x0804E9B8  --  defined in 'ls.c' at line 3105
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return cmp_version(b, a);
}

int xstrcoll_df_version(V a, V b)
{// addr = 0x0804E9D2  --  defined in 'ls.c' at line 3107
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_version(a, b);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

int rev_xstrcoll_df_version(V a, V b)
{// addr = 0x0804EA42  --  defined in 'ls.c' at line 3109
    _Bool b_is_dir;                        // _cfa_fffffffb
    _Bool a_is_dir;                        // _cfa_fffffffa
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    a_is_dir = is_directory(a) & 255;
    b_is_dir = is_directory(b) & 255;
    if(a_is_dir == 0 || ((b_is_dir & 255 ^ 1) & 255) == 0) {
        if(((a_is_dir & 255 ^ 1) & 255) == 0 || b_is_dir == 0) {
            _v24 = cmp_version(b, a);
        } else {
            _v24 = 1;
        }
    } else {
        _v24 = -1;
    }
    return _v24;
}

initialize_ordering_vector()
{// addr = 0x0804EAB2  --  defined in 'ls.c' at line 3177
    size_t i;           // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    i = 0;
    while(i < cwd_n_used) {
        sorted_file[i] = cwd_file + (0 + i * 8 << 4) - 0 + i * 8;
        i = i + 1;
    }
    return;
}

sort_files()
{// addr = 0x0804EB01  --  defined in 'ls.c' at line 3187
    _Bool use_strcmp;                      // _cfa_fffffff3
    union time_type _v32;   // _cfa_ffffffe0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    union sort_type _t23;   // _t23
    _unknown_ _t38;                        // _t38

    if((cwd_n_used >> 1) + cwd_n_used > sorted_file_alloc) {
        free(sorted_file);
        sorted_file = xnmalloc(cwd_n_used, 12);
        sorted_file_alloc = cwd_n_used + cwd_n_used + cwd_n_used;
    }
    initialize_ordering_vector();
    _t23 = sort_type;
    if(_t23 != 255) {
         *__esp =  &failed_strcoll;
        _setjmp();
        if(_t23 != 0) {
            use_strcmp = 1;
            if(sort_type == 3) {
                _v48 = "sort_files";
                _v52 = 3212;
                _v56 = "ls.c";
                 *__esp = "sort_type != sort_version";
                __assert_fail();
            }
            initialize_ordering_vector();
        } else {
            use_strcmp = 0;
        }
        if(sort_type != 4) {
            _v32 = 0;
        } else {
            _v32 = time_type;
        }
        mpsort(sorted_file, cwd_n_used,  *( &sort_functions + (_v32 + sort_type + _v32 + sort_type + (use_strcmp & 255) + _v32 + sort_type + _v32 + sort_type + (use_strcmp & 255) + (sort_reverse & 0xff) + _v32 + sort_type + _v32 + sort_type + (use_strcmp & 255) + _v32 + sort_type + _v32 + sort_type + (use_strcmp & 255) + (sort_reverse & 0xff) + (directories_first & 0xff)) * 4));
        return;
    }
    return;
}

print_current_files()
{// addr = 0x0804EC2E  --  defined in 'ls.c' at line 3227
    size_t i;           // _cfa_fffffff8
    union format _v24;   // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _v24 = format;
    if(_v24 <= 4) {
        goto ( *((intOrPtr*)(134609284 + _v24 * 4)));
    }
    return;
}

int long_time_expected_width()
{// addr = 0x0804ECF0  --  defined in 'ls.c' at line 3267
    size_t len;         // _cfa_fffffff8
    const struct tm* tm;   // _cfa_fffffff4
    time_t epoch;       // _cfa_fffffff0
    char[1000] buf;                        // _cfa_fffffc07
    _unknown_ _v1032;                      // _cfa_fffffbf8
    _unknown_ _v1036;                      // _cfa_fffffbf4
    _unknown_ _v1040;                      // _cfa_fffffbf0
    _unknown_ _v1044;                      // _cfa_fffffbec
    _unknown_ _v1048;                      // _cfa_fffffbe8
    _unknown_ __ebp;                       // r6
    const struct tm* _t20;   // _t20

    if(width >= 0) {
L6:
        return width;
    }
    epoch = 0;
    _t20 =  &epoch;
     *__esp = _t20;
    localtime();
    tm = _t20;
    if(tm != 0) {
        len = nstrftime( &buf, 1001, long_time_format, tm, 0, 0);
        if(len != 0) {
            width = mbsnwidth( &buf, len, 0);
        }
    }
    if(width < 0) {
        width = 0;
    }
    goto L6;
}

get_current_time()
{// addr = 0x0804ED9D  --  defined in 'ls.c' at line 3302
    struct timespec timespec;   // _cfa_fffffff4
    struct timeval timeval;   // _cfa_ffffffec
    long int* _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    long int* _t9;                         // _t9

    _t9 =  &(timespec.tv_sec);
    _v24 = _t9;
     *__esp = 0;
    clock_gettime();
    if(_t9 != 0) {
        _v24 = 0;
         *__esp =  &(timeval.tv_sec);
        gettimeofday();
        current_time = timeval.tv_sec;
        current_time_ns = timeval.tv_usec * timeval.tv_usec + 999;
        return;
    }
    current_time = timespec.tv_sec;
    current_time_ns = timespec.tv_nsec;
    return;
}

format_user_or_group(const char* name, long unsigned int id, int width)
{// addr = 0x0804EDFC  --  defined in 'ls.c' at line 3339
    int pad;                               // _cfa_fffffff8
    int width_gap;                         // _cfa_fffffff4
    size_t len;         // _cfa_fffffff0
    long unsigned int _v36;                // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    _unknown_ _t46;                        // _t46
    signed int _t51;                       // _t51

    if(name == 0) {
        _v36 = id;
        _v40 = width;
        printf(134609304);
        len = width;
    } else {
        width_gap = width - gnu_mbswidth(name, 0);
        pad =  !(width_gap >> 31) & width_gap;
        fputs_unlocked(name, __imp__stdout);
        len = strlen(name) + pad;
        while(1) {
            _t51 = putchar_unlocked(32);
            pad = pad - 1;
            if((_t51 & 255) == 0) {
                break;
            }
        }
    }
    dired_pos = dired_pos + len + 1;
    return;
}

format_user(uid_t u, int width, _Bool stat_ok)
{// addr = 0x0804EEAC  --  defined in 'ls.c' at line 3367
    signed int _v8;                        // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    char* _v16;                            // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _v8 = _a12 & 255;
    if(_v8 == 0) {
        _v16 = 134609310;
    } else {
        if((numeric_ids & 0xff) == 0) {
            _v12 = getuser(u);
        } else {
            _v12 = 0;
        }
        _v16 = _v12;
    }
    format_user_or_group(_v16, u, width);
    return;
}

format_group(gid_t g, int width, _Bool stat_ok)
{// addr = 0x0804EF0A  --  defined in 'ls.c' at line 3376
    signed int _v8;                        // _cfa_fffffff8
    char* _v12;                            // _cfa_fffffff4
    char* _v16;                            // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    _v8 = _a12 & 255;
    if(_v8 == 0) {
        _v16 = 134609310;
    } else {
        if((numeric_ids & 0xff) == 0) {
            _v12 = getgroup(g);
        } else {
            _v12 = 0;
        }
        _v16 = _v12;
    }
    format_user_or_group(_v16, g, width);
    return;
}

int format_user_or_group_width(const char* name, long unsigned int id)
{// addr = 0x0804EF68  --  defined in 'ls.c' at line 3385
    int len;                               // _cfa_fffffff8
    char[10] buf;                          // _cfa_ffffffed
    signed int _v24;                       // _cfa_ffffffe8
    long unsigned int _v36;                // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17

    if(name == 0) {
        _v36 = id;
        sprintf( &buf, 134609312);
        _v24 = strlen( &buf);
    } else {
        len = gnu_mbswidth(name, 0);
        _v24 = len &  !(len >> 31);
    }
    return _v24;
}

int format_user_width(uid_t u)
{// addr = 0x0804EFC9  --  defined in 'ls.c' at line 3403
    const char* _v8;   // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if((numeric_ids & 0xff) == 0) {
        _v8 = getuser(u);
    } else {
        _v8 = 0;
    }
    return format_user_or_group_width(_v8, u);
}

int format_group_width(gid_t g)
{// addr = 0x0804F005  --  defined in 'ls.c' at line 3411
    const char* _v8;   // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    if((numeric_ids & 0xff) == 0) {
        _v8 = getgroup(g);
    } else {
        _v8 = 0;
    }
    return format_user_or_group_width(_v8, g);
}

print_long_format(const struct fileinfo* f)
{// addr = 0x0804F041  --  defined in 'ls.c' at line 3420
    char[651] hbuf;                        // _cfa_ffffee73
    char _v16;                             // _cfa_fffffff0
    const char* fmt;   // _cfa_ffffffe8
    _Bool recent;                          // _cfa_ffffffe7
    time_t six_months_ago;   // _cfa_ffffffe0
    int pad;                               // _cfa_ffffffdc
    const char* size;   // _cfa_ffffffd8
    int blanks_width;                      // _cfa_ffffffd4
    int pad;                               // _cfa_ffffffd0
    const char* blocks;   // _cfa_ffffffcc
    struct tm* when_local;   // _cfa_ffffffc8
    int when_ns;                           // _cfa_ffffffc4
    time_t when;        // _cfa_ffffffc0
    char* p;                               // _cfa_ffffffbc
    size_t s;           // _cfa_ffffffb8
    int _v73;                              // _cfa_ffffffb7
    int _v74;                              // _cfa_ffffffb6
    char[11] modebuf;                      // _cfa_ffffffac
    char[3642] buf;                        // _cfa_fffff171
    struct timespec when_timespec;   // _cfa_fffff168
    char[20] hbuf;                         // _cfa_fffff153
    char[20] hbuf;                         // _cfa_fffff13e
    char[20] majorbuf;                     // _cfa_fffff129
    char[20] minorbuf;                     // _cfa_fffff114
    char[20] hbuf;                         // _cfa_fffff0ff
    char[651] hbuf;                        // _cfa_ffffee73
    int _v4504;                            // _cfa_ffffee68
    long int _v4508;                       // _cfa_ffffee64
    unsigned int _v4512;                   // _cfa_ffffee60
    signed int _v4516;                     // _cfa_ffffee5c
    _Bool _v4520;                          // _cfa_ffffee58
    _Bool _v4524;                          // _cfa_ffffee54
    char* _v4528;                          // _cfa_ffffee50
    signed char _v4532;                    // _cfa_ffffee4c
    char* _v4536;                          // _cfa_ffffee48
    char* _v4540;                          // _cfa_ffffee44
    int _v4544;                            // _cfa_ffffee40
    char* _v4548;                          // _cfa_ffffee3c
    char* _v4552;                          // _cfa_ffffee38
    union time_type _v4556;   // _cfa_ffffee34
    intOrPtr _v4564;                       // _cfa_ffffee2c
    long long unsigned int _v4568;         // _cfa_ffffee28
    char* _v4572;                          // _cfa_ffffee24
    int _v4576;                            // _cfa_ffffee20
    char* _v4580;                          // _cfa_ffffee1c
    char[651]* _v4584;                     // _cfa_ffffee18
    int _v4588;                            // _cfa_ffffee14
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t440;                       // _t440
    _unknown_ _t459;                       // _t459
    struct tm* _t487;       // _t487
    _unknown_ _t496;                       // _t496
    _unknown_ _t527;                       // _t527
    int _t546;                             // _t546
    _unknown_ _t548;                       // _t548
    signed int _t551;                      // _t551
    const struct fileinfo* _t570;   // _t570
    long long unsigned int _t572;          // _t572
    _unknown_ _t578;                       // _t578
    const struct fileinfo* _t582;   // _t582
    signed int _t583;                      // _t583
    char* _t585;                           // _t585
    const struct fileinfo* _t586;   // _t586
    signed int _t587;                      // _t587
    char* _t589;                           // _t589
    _unknown_ _t596;                       // _t596
    _unknown_ _t604;                       // _t604
    _unknown_ _t628;                       // _t628
    const struct fileinfo* _t648;   // _t648
    _unknown_ _t657;                       // _t657
    const struct fileinfo* _t660;   // _t660
    _unknown_ _t669;                       // _t669
    _unknown_ _t689;                       // _t689
    _unknown_ _t691;                       // _t691
    _unknown_ _t692;                       // _t692
    _unknown_ _t699;                       // _t699
    int _t720;                             // _t720

    __esp = __esp - 4572;
    if((f->stat_ok & 0xff) == 0) {
        modebuf = ("?pcdb-lswd")[f->filetype] & 0xff;
        memset( &modebuf + 1, 63, 10);
        _v73 = 0;
    } else {
        filemodestring( &(f->stat),  &modebuf);
    }
    if(((any_has_acl & 255 ^ 1) & 255) == 0) {
        if((f->have_acl & 0xff) != 0) {
            _v74 = 43;
        }
    } else {
        _v74 = 0;
    }
    _v4556 = time_type;
    if(_v4556 != 1) {
        if(_v4556 < 1) {
            _v4584 =  &(f->stat);
            get_stat_mtime( &_v4508);
            __esp = __esp - 4;
            when_timespec.tv_sec = _v4508;
            when_timespec.tv_nsec = _v4504;
        } else {
            if(_v4556 == 2) {
                _v4584 =  &(f->stat);
                get_stat_atime( &_v4508);
                __esp = __esp - 4;
                when_timespec.tv_sec = _v4508;
                when_timespec.tv_nsec = _v4504;
            } else {
                abort();
            }
        }
    } else {
        _v4584 =  &(f->stat);
        get_stat_ctime( &_v4508);
        __esp = __esp - 4;
        when_timespec.tv_sec = _v4508;
        when_timespec.tv_nsec = _v4504;
    }
    when = when_timespec.tv_sec;
    when_ns = when_timespec.tv_nsec;
    p =  &buf;
    if((print_inode & 0xff) != 0) {
        if((f->stat | f->stat) == 0) {
            _v4552 = 134609310;
        } else {
            _t660 = f;
            _v4584 =  &hbuf;
             *__esp = _t660->stat.st_dev;
            _v4588 = _t660->stat.st_dev;
            _v4552 = umaxtostr();
        }
        _v4580 = _v4552;
        _v4584 = inode_number_width;
        sprintf(p, 134609316);
        p =  &(p[strlen(p)]);
    }
    if((print_block_size & 0xff) == 0) {
L29:
        if((f->stat_ok & 0xff) == 0) {
            _v4540 = 134609310;
        } else {
            _v4584 =  &hbuf;
             *__esp = f->stat;
            _v4588 = 0;
            _v4540 = umaxtostr();
        }
        _v4576 = _v4540;
        _v4580 = nlink_width;
        _v4584 =  &modebuf;
        sprintf(p, "%s %*s ");
        p =  &(p[strlen(p)]);
        if((dired & 0xff) != 0) {
            fwrite_unlocked("  ", 1, 2, __imp__stdout);
            dired_pos = dired_pos + 2;
        }
        if((print_scontext & 0xff | print_owner & 0xff | print_group & 0xff | print_author & 0xff) != 0) {
            fputs_unlocked( &buf, __imp__stdout);
            dired_pos = p -  &buf + dired_pos;
            if((print_owner & 0xff) != 0) {
                format_user(f->stat, owner_width, f->stat_ok & 0xff);
            }
            if((print_group & 0xff) != 0) {
                format_group(f->stat, group_width, f->stat_ok & 0xff);
            }
            if((print_author & 0xff) != 0) {
                format_user(f->stat, author_width, f->stat_ok & 0xff);
            }
            if((print_scontext & 0xff) != 0) {
                format_user_or_group(f->scontext, 0, scontext_width);
            }
            p =  &buf;
        }
        if(((f->stat_ok & 255 ^ 1) & 255) != 0 || (f->stat & 61440) != 8192 && (f->stat & 61440) != 24576) {
            if((f->stat_ok & 0xff) == 0) {
                _v4536 = 134609310;
            } else {
                _t570 = f;
                _t720 = _t570->stat.st_dev;
                 *__esp = _t570->stat.st_dev;
                _v4588 = _t720;
                _t572 = unsigned_file_size();
                _v4568 = file_output_block_size;
                _v4564 =  *134627796;
                _v4576 = 1;
                _v4572 = 0;
                _v4580 = human_output_opts;
                _v4584 =  &hbuf;
                 *__esp = _t572;
                _v4588 = _t720;
                _v4536 = human_readable();
            }
            size = _v4536;
            pad = file_size_width - gnu_mbswidth(size, 0);
            while(pad > 0) {
                 *p = 32;
                p =  &(p[1]);
                pad = pad - 1;
            }
            while(1) {
                 *p =  *size & 0xff;
                p =  &(p[1]);
                size =  &(size[1]);
                if(( *p & 0xff) == 0) {
                    break;
                }
            }
             *(p - 1) = 32;
L56:
            _t487 =  &(when_timespec.tv_sec);
             *__esp = _t487;
            localtime();
            when_local = _t487;
            s = 0;
             *p = 1;
            if((f->stat_ok & 0xff) != 0 && when_local != 0) {
                if(current_time < when || current_time == when && current_time_ns < when_ns) {
                    get_current_time();
                }
                six_months_ago = current_time - 15778476;
                if(six_months_ago > when || when >= current_time && (when != current_time || when_ns > current_time_ns)) {
                    _v4532 = 0;
                } else {
                    _v4532 = 1;
                }
                recent = _v4532 & 0xff;
                fmt = ( &long_time_format)[recent & 255];
                s = nstrftime(p, 1001, fmt, when_local, 0, when_ns);
            }
            if(s != 0 || ( *p & 0xff) == 0) {
                p =  &(p[s]);
                 *p = 32;
                p =  &(p[1]);
                 *p = 0;
            } else {
                if((f->stat_ok & 0xff) == 0) {
                    _v4528 = 134609310;
                } else {
                    _t551 = when;
                    _v4584 =  &hbuf;
                     *__esp = _t551;
                    _v4588 = _t551 >> 31;
                    _v4528 = imaxtostr();
                }
                _t546 = long_time_expected_width();
                _v4580 = _v4528;
                _v4584 = _t546;
                sprintf(p, 134609316);
                p =  &(p[strlen(p)]);
            }
            fputs_unlocked( &buf, __imp__stdout);
            dired_pos = p -  &buf + dired_pos;
            _v4524 = f->filetype;
            _v4520 = f->stat_ok & 0xff;
            _v4516 = f->linkok & 0xff;
            if((f->linkok & 0xff & color_symlink_as_referent & 0xff) == 0) {
                _v4512 = f->stat;
            } else {
                _v4512 =  *(f + 108);
            }
            print_name_with_quoting(f->name, _v4512, _v4516, _v4520, _v4524,  &dired_obstack);
            if(f->filetype != 6) {
                if(indicator_style != 0) {
                    print_type_indicator(f->stat_ok & 0xff, f->stat, f->filetype);
                }
            } else {
                if(f->linkname != 0) {
                    fwrite_unlocked(" -> ", 1, 4, __imp__stdout);
                    dired_pos = dired_pos + 4;
                    print_name_with_quoting(f->linkname,  *(f + 108), (f->linkok & 0xff) - 1, f->stat_ok & 0xff, f->filetype, 0);
                    if(indicator_style != 0) {
                        print_type_indicator(1,  *(f + 108), 0);
                    }
                }
            }
            __esp =  &_v16;
            return;
        }
        blanks_width = -2 - major_device_number_width - minor_device_number_width + file_size_width;
        _t582 = f;
        _t583 = _t582->stat.st_dev;
         *__esp = _t583;
        _v4588 = _t582->stat.st_dev;
        gnu_dev_minor();
        _v4584 =  &minorbuf;
         *__esp = _t583;
        _v4588 = 0;
        _t585 = umaxtostr();
        _t586 = f;
        _t587 = _t586->stat.st_dev;
         *__esp = _t587;
        _v4588 = _t586->stat.st_dev;
        gnu_dev_major();
        _v4584 =  &majorbuf;
         *__esp = _t587;
        _v4588 = 0;
        _t589 = umaxtostr();
        _v4572 = _t585;
        _v4576 = minor_device_number_width;
        _v4580 = _t589;
        _v4584 = ( !(blanks_width >> 31) & blanks_width) + major_device_number_width;
        sprintf(p, "%*s, %*s ");
        p =  &(p[file_size_width + 1]);
        goto L56;
    } else {
        if((f->stat_ok & 0xff) == 0) {
            _v4548 = 134609310;
        } else {
            _v4544 = human_output_opts;
            _t648 = f;
            _v4568 = output_block_size;
            _v4564 =  *134628524;
            _v4576 = 512;
            _v4572 = 0;
            _v4580 = _v4544;
            _v4584 =  &hbuf;
             *__esp = _t648->stat.st_dev;
            _v4588 = _t648->stat.st_dev;
            _v4548 = human_readable();
        }
        blocks = _v4548;
        pad = block_size_width - gnu_mbswidth(blocks, 0);
        while(pad > 0) {
             *p = 32;
            p =  &(p[1]);
            pad = pad - 1;
        }
        while(1) {
             *p =  *blocks & 0xff;
            p =  &(p[1]);
            blocks =  &(blocks[1]);
            if(( *p & 0xff) == 0) {
                break;
            }
        }
         *(p - 1) = 32;
        goto L29;
    }
}

size_t quote_name(FILE* out, const char* name, const struct quoting_options* options, size_t* width)
{// addr = 0x0804FA54  --  defined in 'ls.c' at line 3652
    _unknown_ _v8;                         // _cfa_fffffff8
    const char* plimit;   // _cfa_fffffff4
    const char* p;   // _cfa_fffffff0
    const char* plimit;   // _cfa_ffffffec
    char* p;                               // _cfa_ffffffe8
    int w;                                 // _cfa_ffffffe4
    size_t bytes;       // _cfa_ffffffe0
    char* q;                               // _cfa_ffffffdc
    const char* plimit;   // _cfa_ffffffd8
    const char* p;   // _cfa_ffffffd4
    size_t displayed_width;   // _cfa_ffffffd0
    char* buf;                             // _cfa_ffffffcc
    size_t len;         // _cfa_ffffffc8
    char[8191] smallbuf;                   // _cfa_ffffdfc8
    int _v8252;                            // _cfa_ffffdfc4
    mbstate_t mbstate;   // _cfa_ffffdfc0
    wchar_t wc;        // _cfa_ffffdfbc
    signed int _v8268;                     // _cfa_ffffdfb4
    signed int _v8272;                     // _cfa_ffffdfb0
    char _v8280;                           // _cfa_ffffdfa8
    _unknown_ _v8284;                      // _cfa_ffffdfa4
    int* _v8288;                           // _cfa_ffffdfa0
    intOrPtr _v8292;                       // _cfa_ffffdf9c
    const char* _v8296;   // _cfa_ffffdf98
    _unknown_ __ebp;                       // r6
    _unknown_ _t195;                       // _t195
    signed int _t196;                      // _t196
    _unknown_ _t202;                       // _t202
    const char* _t206;   // _t206
    char* _t223;                           // _t223
    unsigned int _t250;                    // _t250
    int _t251;                             // _t251
    int* _t254;                            // _t254
    _unknown_ _t269;                       // _t269

    _push(__ebx);
    __esp = __esp - 8292;
    len = quotearg_buffer( &smallbuf, 8192, name, -1, options);
    if(len > 8191) {
        __esp = __esp - (len + 0x1f >> 4 << 4);
        _v8272 =  &_v8280;
        _v8272 =  &(_v8272[0xf]) >> 4 << 4;
        buf = _v8272;
        quotearg_buffer(buf, len + 1, name, -1, options);
    } else {
        buf =  &smallbuf;
    }
    _t196 = qmark_funny_chars & 255;
    if((_t196 & 255) == 0) {
        if(width == 0) {
        } else {
            __ctype_get_mb_cur_max();
            if(_t196 <= 1) {
                p = buf;
                plimit =  &(buf[len]);
                displayed_width = 0;
                while(1) {
                    _t206 = p;
                    if(_t206 >= plimit) {
                        break;
                    }
                    __ctype_b_loc();
                    if(( *( *_t206 + (to_uchar( *p & 0xff) & 0xff) + (to_uchar( *p & 0xff) & 0xff)) & 0x4000) != 0) {
                        displayed_width = displayed_width + 1;
                    }
                    p =  &(p[1]);
                }
                goto L44;
            }
            displayed_width = mbsnwidth(buf, len, 0);
        }
L49:
    } else {
        __ctype_get_mb_cur_max();
        if(_t196 <= 1) {
            p = buf;
            plimit =  &(buf[len]);
            while(1) {
L34:
                _t223 = p;
                if(_t223 >= plimit) {
                    break;
                }
                __ctype_b_loc();
                if(( *( *_t223 + (to_uchar( *p & 0xff) & 0xff) + (to_uchar( *p & 0xff) & 0xff)) & 0x4000) == 0) {
                     *p = 63;
                }
                p =  &(p[1]);
            }
            displayed_width = len;
        } else {
            p = buf;
            plimit =  &(buf[len]);
            q = buf;
            displayed_width = 0;
L28:
            while(p < plimit) {
                _v8268 =  *p & 0xff;
                if(_v8268 > 95) {
                    if(_v8268 - 97 > 29) {
                        goto L14;
                    } else {
                        goto L13;
                    }
                    goto L15;
                } else {
                    if(_v8268 >= 65) {
L13:
                         *q =  *p & 0xff;
                        q =  &(q[1]);
                        p =  &(p[1]);
                        displayed_width = displayed_width + 1;
                    } else {
                        if(_v8268 < 32) {
L14:
                            mbstate.__count = 0;
                            _v8252 = 0;
                        } else {
                            if(_v8268 <= 35) {
                                goto L13;
                            } else {
                                if(_v8268 - 37 > 26) {
                                    goto L14;
                                } else {
                                    goto L13;
                                }
                                while(1) {
L15:
                                    _v8288 =  &(mbstate.__count);
                                    _v8292 = plimit - p;
                                    _v8296 = p;
                                    _t250 =  &wc;
                                     *__esp = _t250;
                                    mbrtowc();
                                    bytes = _t250;
                                    if(bytes == 255) {
                                        break;
                                    }
                                    if(bytes != 254) {
                                        if(bytes == 0) {
                                            bytes = 1;
                                        }
                                        _t251 = wc;
                                         *__esp = _t251;
                                        wcwidth();
                                        w = _t251;
                                        if(w >= 0) {
                                            p = p + bytes;
                                             *q = 63;
                                            q =  &(q[1]);
                                            displayed_width = displayed_width + 1;
                                        } else {
                                            while(bytes != 0) {
                                                 *q =  *p & 0xff;
                                                q =  &(q[1]);
                                                p =  &(p[1]);
                                                bytes = bytes - 1;
                                            }
                                            displayed_width = displayed_width + w;
                                        }
                                    } else {
                                        p = plimit;
                                         *q = 63;
                                        q =  &(q[1]);
                                        displayed_width = displayed_width + 1;
                                        goto L28;
                                    }
                                    _t254 =  &(mbstate.__count);
                                     *__esp = _t254;
                                    mbsinit();
                                    if(_t254 == 0) {
                                        continue;
                                    }
                                    goto L28;
                                }
                                p =  &(p[1]);
                                 *q = 63;
                                q =  &(q[1]);
                                displayed_width = displayed_width + 1;
                            }
                            continue;
                        }
                        goto L15;
                    }
                }
            }
            len = q - buf;
        }
    }
L44:
    if(out != 0) {
        fwrite_unlocked(buf, 1, len, out);
    }
    if(width != 0) {
         *width = displayed_width;
    }
    return len;
    goto L49;
}

unsigned char to_uchar(char ch)
{// addr = 0x0804FDEF  --  defined in 'system.h' at line 263
    signed char _v8;                       // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    _v8 = _a4 & 255;
    return _v8 & 255;
}

print_name_with_quoting(const char* p, mode_t mode, int linkok, _Bool stat_ok, union filetype type, struct obstack* stack)
{// addr = 0x0804FE01  --  defined in 'ls.c' at line 3817
    int __len;                             // _cfa_fffffff8
    struct obstack* __o;   // _cfa_fffffff4
    int __len;                             // _cfa_fffffff0
    struct obstack* __o;   // _cfa_ffffffec
    signed char _v24;                      // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    int _v40;                              // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t86;                        // _t86
    _unknown_ _t100;                       // _t100

    _v24 = _a16 & 255;
    if((print_with_color & 0xff) != 0) {
        print_color_indicator(p, mode, linkok, _v24 & 255, type);
    }
    if(stack != 0 && (dired & 0xff) != 0) {
        __o = stack;
        __len = 4;
        if( &(__o->next_free[__len]) > __o->chunk_limit) {
            _v40 = __len;
             *__esp = __o;
            _obstack_newchunk();
        }
        memcpy(__o->next_free,  &dired_pos, __len);
        __o->next_free =  &(__o->next_free[__len]);
    }
    dired_pos = quote_name(__imp__stdout, p, filename_quoting_options, 0) + dired_pos;
    if(stack != 0 && (dired & 0xff) != 0) {
        __o = stack;
        __len = 4;
        if( &(__o->next_free[__len]) > __o->chunk_limit) {
            _v40 = __len;
             *__esp = __o;
            _obstack_newchunk();
        }
        memcpy(__o->next_free,  &dired_pos, __len);
        __o->next_free =  &(__o->next_free[__len]);
    }
    if((print_with_color & 0xff) == 0) {
        return;
    } else {
        process_signals();
        prep_non_filename_text();
        return;
    }
}

prep_non_filename_text()
{// addr = 0x0804FF72  --  defined in 'ls.c' at line 3838
    _unknown_ __ebp;                       // r6

    if( *134627828 == 0) {
        put_indicator( &color_indicator);
        put_indicator(134627832);
        put_indicator(134627816);
        return;
    }
    put_indicator(134627824);
    return;
}

print_file_name_and_frills(const struct fileinfo* f)
{// addr = 0x0804FFB5  --  defined in 'ls.c' at line 3855
    char[651] buf;                         // _cfa_fffffd64
    unsigned int _v676;                    // _cfa_fffffd5c
    signed int _v680;                      // _cfa_fffffd58
    _Bool _v684;                           // _cfa_fffffd54
    union filetype _v688;   // _cfa_fffffd50
    int _v692;                             // _cfa_fffffd4c
    char* _v696;                           // _cfa_fffffd48
    int _v700;                             // _cfa_fffffd44
    char* _v704;                           // _cfa_fffffd40
    int _v708;                             // _cfa_fffffd3c
    int _v712;                             // _cfa_fffffd38
    char* _v716;                           // _cfa_fffffd34
    intOrPtr _v720;                        // _cfa_fffffd30
    long long unsigned int _v724;          // _cfa_fffffd2c
    struct obstack* _v728;   // _cfa_fffffd28
    intOrPtr _v732;                        // _cfa_fffffd24
    int _v736;                             // _cfa_fffffd20
    char* _v740;                           // _cfa_fffffd1c
    int _v744;                             // _cfa_fffffd18
    _unknown_ __ebp;                       // r6
    _unknown_ _t126;                       // _t126
    const struct fileinfo* _t128;   // _t128
    _unknown_ _t135;                       // _t135
    const struct fileinfo* _t136;   // _t136
    _unknown_ _t141;                       // _t141

    if((print_inode & 0xff) != 0) {
        _t136 = f;
        _v740 =  &buf;
         *__esp = _t136->stat.st_dev;
        _v744 = _t136->stat.st_dev;
        _v716 = umaxtostr();
        if(format == 4) {
            _v712 = 0;
        } else {
            _v712 = inode_number_width;
        }
        _v740 = _v716;
        _v744 = _v712;
        printf(134609316);
    }
    if((print_block_size & 0xff) != 0) {
        _v708 = human_output_opts;
        _t128 = f;
        _v724 = output_block_size;
        _v720 =  *134628524;
        _v732 = 512;
        _v728 = 0;
        _v736 = _v708;
        _v740 =  &buf;
         *__esp = _t128->stat.st_dev;
        _v744 = _t128->stat.st_dev;
        _v704 = human_readable();
        if(format == 4) {
            _v700 = 0;
        } else {
            _v700 = block_size_width;
        }
        _v740 = _v704;
        _v744 = _v700;
        printf(134609316);
    }
    if((print_scontext & 0xff) != 0) {
        _v696 = f->scontext;
        if(format == 4) {
            _v692 = 0;
        } else {
            _v692 = scontext_width;
        }
        _v740 = _v696;
        _v744 = _v692;
        printf(134609316);
    }
    _v688 = f->filetype;
    _v684 = f->stat_ok & 0xff;
    _v680 = f->linkok & 0xff;
    if((f->linkok & 0xff & color_symlink_as_referent & 0xff) == 0) {
        _v676 = f->stat;
    } else {
        _v676 =  *(f + 108);
    }
    print_name_with_quoting(f->name, _v676, _v680, _v684, _v688, 0);
    if(indicator_style != 0) {
        print_type_indicator(f->stat_ok & 0xff, f->stat, f->filetype);
        return;
    }
    return;
}

char get_type_indicator(_Bool stat_ok, mode_t mode, union filetype type)
{// addr = 0x08050215  --  defined in 'ls.c' at line 3881
    char c;                                // _cfa_fffffffb
    signed char _v24;                      // _cfa_ffffffe8
    char _v25;                             // _cfa_ffffffe7
    char _v26;                             // _cfa_ffffffe6
    char _v27;                             // _cfa_ffffffe5
    signed char _v32;                      // _cfa_ffffffe0
    signed int _v33;                       // _cfa_ffffffdf
    char _v34;                             // _cfa_ffffffde
    _unknown_ __ebp;                       // r6

    _v24 = _a4 & 255;
    if(_v24 == 0) {
        _v34 = type == 5;
    } else {
        _v34 = (mode & 61440) == 32768;
    }
    if(_v34 == 0) {
        if(_v24 == 0) {
            if(type == 3 || type == 9) {
                _v32 = 1;
            } else {
                _v32 = 0;
            }
            _v33 = _v32 & 0xff;
        } else {
            _v33 = (mode & 61440) == 16384;
        }
        if(_v33 == 0) {
            if(indicator_style != 1) {
                if(_v24 == 0) {
                    _v27 = type == 6;
                } else {
                    _v27 = (mode & 61440) == 40960;
                }
                if(_v27 == 0) {
                    if(_v24 == 0) {
                        _v26 = type == 1;
                    } else {
                        _v26 = (mode & 61440) == 4096;
                    }
                    if(_v26 == 0) {
                        if(_v24 == 0) {
                            _v25 = type == 7;
                        } else {
                            _v25 = (mode & 61440) == 49152;
                        }
                        if(_v25 == 0) {
                            c = 0;
                        } else {
                            c = 61;
                        }
                    } else {
                        c = 124;
                    }
                } else {
                    c = 64;
                }
            } else {
                c = 0;
            }
        } else {
            c = 47;
        }
    } else {
        if(((_v24 & 255 ^ 1) & 255) != 0 || indicator_style != 3 || (mode & 73) == 0) {
            c = 0;
        } else {
            c = 42;
        }
    }
    return c & 255;
}

print_type_indicator(_Bool stat_ok, mode_t mode, union filetype type)
{// addr = 0x08050368  --  defined in 'ls.c' at line 3913
    char c;                                // _cfa_fffffffb
    signed char _v24;                      // _cfa_ffffffe8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t20;                        // _t20

    _v24 = _a4 & 255;
    c = get_type_indicator(_v24 & 255, mode, type) & 255;
    if(c != 0) {
        putchar_unlocked(c);
        dired_pos = dired_pos + 1;
        return;
    }
    return;
}

print_color_indicator(const char* name, mode_t mode, int linkok, _Bool stat_ok, union filetype filetype)
{// addr = 0x080503B2  --  defined in 'ls.c' at line 3922
    size_t len;         // _cfa_fffffff8
    struct color_ext_type* ext;   // _cfa_fffffff4
    int type;                              // _cfa_fffffff0
    signed char _v24;                      // _cfa_ffffffe8
    struct bin_str* _v28;   // _cfa_ffffffe4
    int _v32;                              // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    _v24 = _a16 & 255;
    if(linkok != 255) {
L3:
        if(((_v24 & 255 ^ 1) & 255) == 0) {
            if((mode & 61440) != 32768) {
                if((mode & 61440) != 16384) {
                    if((mode & 61440) != 40960) {
                        if((mode & 61440) != 4096) {
                            if((mode & 61440) != 49152) {
                                if((mode & 61440) != 24576) {
                                    if((mode & 61440) != 8192) {
                                        type = 12;
                                    } else {
                                        type = 10;
                                    }
                                } else {
                                    type = 9;
                                }
                            } else {
                                type = 8;
                            }
                        } else {
                            type = 7;
                        }
                    } else {
                        if(linkok != 0 ||  *134627908 == 0) {
                            _v32 = 6;
                        } else {
                            _v32 = 12;
                        }
                        type = _v32;
                    }
                } else {
                    if((mode & 512) == 0 || (mode & 2) == 0) {
                        if((mode & 2) == 0) {
                            if((mode & 512) == 0) {
                                type = 5;
                            } else {
                                type = 17;
                            }
                        } else {
                            type = 18;
                        }
                    } else {
                        type = 19;
                    }
                }
            } else {
                type = 4;
                if((mode & 2048) == 0) {
                    if((mode & 1024) == 0) {
                        if((mode & 73) != 0) {
                            type = 13;
                        }
                    } else {
                        type = 16;
                    }
                } else {
                    type = 15;
                }
            }
        } else {
            type =  *( &filetype_indicator + filetype * 4);
        }
        goto L36;
    }
    if( *134627900 == 0) {
        goto L3;
    } else {
        type = 11;
    }
L36:
    ext = 0;
    if(type != 4) {
L42:
        put_indicator( &color_indicator);
        if(ext == 0) {
            _v28 =  &color_indicator + (type << 3);
        } else {
            _v28 =  &(ext->seq);
        }
        put_indicator(_v28);
        put_indicator(134627816);
        return;
    } else {
        len = strlen(name);
        name = name + len;
        ext = color_ext_list;
    }
    while(ext != 0) {
        if(ext->ext > len || strncmp(name +  ~(ext->ext), ext->ext.string, ext->ext) != 0) {
            ext = ext->next;
        } else {
            goto L42;
        }
    }
    goto L42;
}

put_indicator(const struct bin_str* ind)
{// addr = 0x0805060F  --  defined in 'ls.c' at line 4004
    const char* p;   // _cfa_fffffff8
    size_t i;           // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    p = ind->string;
    _t17 = ind->len;
    i = ind->len;
    while(i != 0) {
        p =  &(p[1]);
        putchar_unlocked( *p & 0xff);
        i = i - 1;
    }
    return;
}

size_t length_of_file_name_and_frills(const struct fileinfo* f)
{// addr = 0x08050649  --  defined in 'ls.c' at line 4016
    char c;                                // _cfa_ffffffef
    size_t len;         // _cfa_ffffffe8
    size_t name_width;   // _cfa_ffffffe4
    char[651] buf;                         // _cfa_fffffd58
    intOrPtr _v692;                        // _cfa_fffffd4c
    int _v696;                             // _cfa_fffffd48
    intOrPtr _v700;                        // _cfa_fffffd44
    intOrPtr _v704;                        // _cfa_fffffd40
    intOrPtr _v720;                        // _cfa_fffffd30
    long long unsigned int _v724;          // _cfa_fffffd2c
    FILE* _v728;          // _cfa_fffffd28
    intOrPtr _v732;                        // _cfa_fffffd24
    int _v736;                             // _cfa_fffffd20
    char[651]* _v740;                      // _cfa_fffffd1c
    long long unsigned int _v744;          // _cfa_fffffd18
    _unknown_ __ebp;                       // r6
    _unknown_ _t78;                        // _t78
    signed int _t87;                       // _t87
    const struct fileinfo* _t102;   // _t102
    const struct fileinfo* _t113;   // _t113

    len = 0;
    if((print_inode & 0xff) != 0) {
        if(format != 4) {
            _v704 = inode_number_width + 1;
        } else {
            _t113 = f;
            _v740 =  &buf;
             *__esp = _t113->stat.st_dev;
            _v744 = _t113->stat.st_dev;
            _v704 = strlen(umaxtostr()) + 1;
        }
        len = len + _v704;
    }
    if((print_block_size & 0xff) != 0) {
        if(format != 4) {
            _v700 = block_size_width + 1;
        } else {
            _v696 = human_output_opts;
            _t102 = f;
            _v724 = output_block_size;
            _v720 =  *134628524;
            _v732 = 512;
            _v728 = 0;
            _v736 = _v696;
            _v740 =  &buf;
             *__esp = _t102->stat.st_dev;
            _v744 = _t102->stat.st_dev;
            _v700 = strlen(human_readable()) + 1;
        }
        len = len + _v700;
    }
    if((print_scontext & 0xff) != 0) {
        if(format != 4) {
            _v692 = scontext_width + 1;
        } else {
            _v692 = strlen(f->scontext) + 1;
        }
        len = len + _v692;
    }
    quote_name(0, f->name, filename_quoting_options,  &name_width);
    len = len + name_width;
    if(indicator_style != 0) {
        _t87 = get_type_indicator(f->stat_ok & 0xff, f->stat, f->filetype);
        c = _t87 & 255;
        len = len + (_t87 & 0xff);
    }
    return len;
}

print_many_per_line()
{// addr = 0x08050817  --  defined in 'ls.c' at line 4050
    size_t max_name_length;   // _cfa_fffffff8
    size_t name_length;   // _cfa_fffffff4
    const struct fileinfo* f;   // _cfa_fffffff0
    size_t pos;         // _cfa_ffffffec
    size_t filesno;     // _cfa_ffffffe8
    size_t col;         // _cfa_ffffffe4
    size_t rows;        // _cfa_ffffffe0
    const struct column_info* line_fmt;   // _cfa_ffffffdc
    size_t cols;        // _cfa_ffffffd8
    size_t row;         // _cfa_ffffffd4
    unsigned int _v64;                     // _cfa_ffffffc0
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t60;                        // _t60
    _unknown_ _t72;                        // _t72
    _unknown_ _t92;                        // _t92
    _unknown_ _t101;                       // _t101
    _unknown_ _t102;                       // _t102
    _unknown_ _t103;                       // _t103

    cols = calculate_columns(1);
    line_fmt = column_info + (cols + cols + _t100 << 2) - 12;
    _v64 = cwd_n_used;
    rows = cwd_n_used / cols + (_v64 % cols & 0xff);
    row = 0;
    while(row < rows) {
        col = 0;
        filesno = row;
        pos = 0;
        while(1) {
            f = sorted_file[filesno];
            name_length = length_of_file_name_and_frills(f);
            max_name_length =  *(line_fmt->col_arr + (col << 2));
            col = col + 1;
            print_file_name_and_frills(f);
            filesno = filesno + rows;
            if(filesno >= cwd_n_used) {
                break;
            }
            indent(pos + name_length, pos + max_name_length);
            pos = pos + max_name_length;
        }
        putchar_unlocked(10);
        row = row + 1;
    }
    return;
}

print_horizontal()
{// addr = 0x08050931  --  defined in 'ls.c' at line 4086
    size_t col;         // _cfa_fffffff8
    size_t max_name_length;   // _cfa_fffffff4
    size_t name_length;   // _cfa_fffffff0
    const struct fileinfo* f;   // _cfa_ffffffec
    const struct column_info* line_fmt;   // _cfa_ffffffe8
    size_t cols;        // _cfa_ffffffe4
    size_t pos;         // _cfa_ffffffe0
    size_t filesno;     // _cfa_ffffffdc
    unsigned int _v44;                     // _cfa_ffffffd4
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t49;                        // _t49
    _unknown_ _t68;                        // _t68
    _unknown_ _t85;                        // _t85
    _unknown_ _t86;                        // _t86
    _unknown_ _t90;                        // _t90

    pos = 0;
    cols = calculate_columns(0);
    line_fmt = column_info + (cols + cols + _t89 << 2) - 12;
    f =  *sorted_file;
    name_length = length_of_file_name_and_frills(f);
    max_name_length = line_fmt;
    print_file_name_and_frills(f);
    filesno = 1;
    while(filesno < cwd_n_used) {
        _v44 = filesno;
        col = _v44 % cols;
        if(col != 0) {
            indent(pos + name_length, pos + max_name_length);
            pos = pos + max_name_length;
        } else {
            putchar_unlocked(10);
            pos = 0;
        }
        f = sorted_file[filesno];
        print_file_name_and_frills(f);
        name_length = length_of_file_name_and_frills(f);
        max_name_length =  *(line_fmt->col_arr + (col << 2));
        filesno = filesno + 1;
    }
    putchar_unlocked(10);
    return;
}

print_with_commas()
{// addr = 0x08050A55  --  defined in 'ls.c' at line 4125
    char separator;                        // _cfa_fffffffb
    size_t len;         // _cfa_fffffff4
    const struct fileinfo* f;   // _cfa_fffffff0
    size_t pos;         // _cfa_ffffffec
    size_t filesno;     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37
    _unknown_ _t39;                        // _t39
    _unknown_ _t40;                        // _t40

    pos = 0;
    filesno = 0;
    while(filesno < cwd_n_used) {
        f = sorted_file[filesno];
        len = length_of_file_name_and_frills(f);
        if(filesno != 0) {
            if(pos + len + 2 >= line_length) {
                pos = 0;
                separator = 10;
            } else {
                pos = pos + 2;
                separator = 32;
            }
            putchar_unlocked(44);
            putchar_unlocked(separator);
        }
        print_file_name_and_frills(f);
        pos = pos + len;
        filesno = filesno + 1;
    }
    putchar_unlocked(10);
    return;
}

indent(size_t from, size_t to)
{// addr = 0x08050B05  --  defined in 'ls.c' at line 4164
    unsigned int _v24;                     // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t36;                        // _t36
    _unknown_ _t45;                        // _t45
    _unknown_ _t47;                        // _t47
    _unknown_ _t55;                        // _t55
    _unknown_ _t56;                        // _t56
    _unknown_ _t57;                        // _t57
    _unknown_ _t58;                        // _t58
    _unknown_ _t60;                        // _t60

    while(from < to) {
        if(tabsize == 0) {
L4:
            putchar_unlocked(32);
            from = from + 1;
        } else {
            _v28 = tabsize;
            _v28 = from + 1;
            _v24 = tabsize;
            _v24 = _v28 / _v24;
            if(to / _v28 <= _v24) {
                goto L4;
            } else {
                putchar_unlocked(9);
                _v24 = from;
                from = from + tabsize - _v24 % tabsize;
            }
        }
    }
    return;
}

attach(char* dest, const char* dirname, const char* name)
{// addr = 0x08050BAF  --  defined in 'ls.c' at line 4186
    const char* dirnamep;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    dirnamep = dirname;
    if(( *dirname & 0xff) != 46 || (dirname[1] & 0xff) != 0) {
        while(( *dirnamep & 0xff) != 0) {
        }
        if(dirnamep > dirname && ( *(dirnamep - 1) & 0xff) != 47) {
             *dest = 47;
            dest =  &(dest[1]);
        }
L9:
        while(( *name & 0xff) != 0) {
             *dest =  *name & 0xff;
            dest =  &(dest[1]);
            name =  &(name[1]);
        }
         *dest = 0;
        return;
    }
    goto L9;
}

init_column_info()
{// addr = 0x08050C37  --  defined in 'ls.c' at line 4209
    size_t j;           // _cfa_fffffff8
    size_t t;           // _cfa_fffffff4
    size_t s;           // _cfa_fffffff0
    size_t column_info_growth;   // _cfa_ffffffec
    size_t* p;          // _cfa_ffffffe8
    size_t new_column_info_alloc;   // _cfa_ffffffe4
    size_t max_cols;    // _cfa_ffffffe0
    size_t i;           // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t148;                       // _t148
    _unknown_ _t149;                       // _t149

    _v40 = max_idx;
    _v44 = cwd_n_used;
    if(_v44 > _v40) {
        _v44 = _v40;
    }
    max_cols = _v44;
    if(column_info_alloc >= max_cols) {
L13:
        i = 0;
L18:
        while(i < max_cols) {
            goto L14;
        }
        return;
    } else {
        if(max_idx >> 1 <= max_cols) {
            column_info = xnrealloc(column_info, max_idx, 12);
            new_column_info_alloc = max_idx;
        } else {
            column_info = xnrealloc(column_info, max_cols, 24);
            new_column_info_alloc = max_cols + max_cols;
        }
        column_info_growth = new_column_info_alloc - column_info_alloc;
        s = column_info_alloc + new_column_info_alloc + 1;
        t = s * column_info_growth;
        if(s < new_column_info_alloc || t / column_info_growth != s) {
            xalloc_die();
        }
        p = xnmalloc(t >> 1, 4);
        i = column_info_alloc;
        while(i < new_column_info_alloc) {
             *(column_info + (i + i + _t146 << 2) + 8) = p;
            p = p + (i + 1 << 2);
            i = i + 1;
        }
        column_info_alloc = new_column_info_alloc;
        goto L13;
    }
L14:
     *((char*)(column_info + (i + i + _t139 << 2))) = 1;
    _t140 = i;
     *((intOrPtr*)(column_info + (i + _t140 + _t140 << 2) + 4)) = i + 1 + i + 1 + _t141;
    j = 0;
    while(j <= i) {
         *((intOrPtr*)( *((intOrPtr*)(column_info + (i + i + _t142 << 2) + 8)) + (j << 2))) = 3;
        j = j + 1;
    }
    i = i + 1;
    goto L18;
}

size_t calculate_columns(_Bool by_columns)
{// addr = 0x08050E06  --  defined in 'ls.c' at line 4277
    size_t real_length;   // _cfa_fffffff0
    size_t idx;         // _cfa_ffffffec
    size_t i;           // _cfa_ffffffe8
    size_t name_length;   // _cfa_ffffffe4
    const struct fileinfo* f;   // _cfa_ffffffe0
    size_t max_cols;    // _cfa_ffffffdc
    size_t cols;        // _cfa_ffffffd8
    size_t filesno;     // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    unsigned int _v60;                     // _cfa_ffffffc4
    unsigned int _v64;                     // _cfa_ffffffc0
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t134;                       // _t134
    _unknown_ _t183;                       // _t183
    _unknown_ _t184;                       // _t184
    _unknown_ _t216;                       // _t216
    _unknown_ _t226;                       // _t226
    _unknown_ _t239;                       // _t239
    _unknown_ _t241;                       // _t241
    _unknown_ _t242;                       // _t242
    _unknown_ _t243;                       // _t243
    _unknown_ _t244;                       // _t244

    _v48 = _a4 & 255;
    _v60 = max_idx;
    _v64 = cwd_n_used;
    if(_v64 > _v60) {
        _v64 = _v60;
    }
    max_cols = _v64;
    init_column_info();
    filesno = 0;
    while(filesno < cwd_n_used) {
        f = sorted_file[filesno];
        name_length = length_of_file_name_and_frills(f);
        i = 0;
        while(i < max_cols) {
            if(( *(column_info + (i + i + _t223 << 2)) & 0xff) != 0) {
                if(_v48 == 0) {
                    _v84 = filesno;
                    _v56 = _v84 % (i + 1);
                } else {
                    _v80 = i + cwd_n_used;
                    _v84 = i + 1;
                    _v84 = _v80 / _v84;
                    _v80 = _v84;
                    _v56 = filesno / _v80;
                }
                idx = _v56;
                if(idx != i) {
                    _v52 = 2;
                } else {
                    _v52 = 0;
                }
                real_length = _v52 + name_length;
                if( *((intOrPtr*)( *((intOrPtr*)(column_info + (i + i + _t228 << 2) + 8)) + (idx << 2))) < real_length) {
                    _t230 = i;
                    _t231 = i;
                     *((intOrPtr*)(column_info + (i + _t230 + _t230 << 2) + 4)) =  *((intOrPtr*)(column_info + (i + _t231 + _t231 << 2) + 4)) + real_length -  *((intOrPtr*)( *((intOrPtr*)(column_info + (i + i + _t232 << 2) + 8)) + (idx << 2)));
                     *( *((intOrPtr*)(column_info + (i + i + _t235 << 2) + 8)) + (idx << 2)) = real_length;
                     *(column_info + (i + i + _t238 << 2)) = line_length & 255;
                }
            }
            i = i + 1;
        }
        filesno = filesno + 1;
    }
    cols = max_cols;
    while(cols > 1) {
        if(( *(column_info + (cols + cols + _t224 << 2) - 12) & 0xff) != 0) {
            break;
        }
        cols = cols - 1;
    }
    return cols;
}

usage(int status)
{// addr = 0x0805105C  --  defined in 'ls.c' at line 4328
    char* _v20;                            // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    char* _v36;                            // _cfa_ffffffdc
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    char* _t33;                            // _t33
    _unknown_ _t34;                        // _t34
    _unknown_ _t36;                        // _t36
    _unknown_ _t38;                        // _t38
    _unknown_ _t40;                        // _t40
    _unknown_ _t42;                        // _t42
    _unknown_ _t44;                        // _t44
    _unknown_ _t46;                        // _t46
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    _unknown_ _t52;                        // _t52
    _unknown_ _t54;                        // _t54
    _unknown_ _t56;                        // _t56
    _unknown_ _t58;                        // _t58
    _unknown_ _t60;                        // _t60
    _unknown_ _t62;                        // _t62
    _unknown_ _t64;                        // _t64
    _unknown_ _t66;                        // _t66
    _unknown_ _t68;                        // _t68
    _unknown_ _t70;                        // _t70
    _unknown_ _t72;                        // _t72
    _unknown_ _t74;                        // _t74
    _unknown_ _t76;                        // _t76
    _unknown_ _t78;                        // _t78
    _unknown_ _t80;                        // _t80
    _unknown_ _t82;                        // _t82
    _unknown_ _t84;                        // _t84
    _unknown_ _t86;                        // _t86
    char* _t87;                            // _t87
    _unknown_ _t88;                        // _t88
    char* _t89;                            // _t89
    _unknown_ _t90;                        // _t90
    _unknown_ _t119;                       // _t119
    _unknown_ _t120;                       // _t120

    _push(__ebx);
    __esp = __esp - 20;
    if(status == 0) {
        _t33 = gettext("Usage: %s [OPTION]... [FILE]...\n");
        _v24 = program_name;
        printf(_t33);
        fputs_unlocked(gettext("List information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort.\n\n"), __imp__stdout);
        fputs_unlocked(gettext("Mandatory arguments to long options are mandatory for short options too.\n"), __imp__stdout);
        fputs_unlocked(gettext("  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print octal escapes for nongraphic characters\n"), __imp__stdout);
        fputs_unlocked(gettext("      --block-size=SIZE      use SIZE-byte blocks\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information)\n                               with -l: show ctime and sort by name\n                               otherwise: sort by ctime\n"), __imp__stdout);
        fputs_unlocked(gettext("  -C                         list entries by columns\n      --color[=WHEN]         control whether color is used to distinguish file\n                               types.  WHEN may be `never', `always', or `auto'\n  -d, --directory            list directory entries instead of contents,\n                               and do not dereference symbolic links\n  -D, --dired                generate output designed for Emacs' dired mode\n"), __imp__stdout);
        fputs_unlocked(gettext("  -f                         do not sort, enable -aU, disable -ls --color\n  -F, --classify             append indicator (one of */=>|) to entries\n      --file-type            likewise, except do not append `*'\n      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n                               single-column -1, verbose -l, vertical -C\n      --full-time            like -l --time-style=full-iso\n"), __imp__stdout);
        fputs_unlocked(gettext("  -g                         like -l, but do not list owner\n"), __imp__stdout);
        fputs_unlocked(gettext("      --group-directories-first\n                             group directories before files\n"), __imp__stdout);
        fputs_unlocked(gettext("  -G, --no-group             in a long listing, don't print group names\n  -h, --human-readable       with -l, print sizes in human readable format\n                               (e.g., 1K 234M 2G)\n      --si                   likewise, but use powers of 1000 not 1024\n"), __imp__stdout);
        fputs_unlocked(gettext("  -H, --dereference-command-line\n                             follow symbolic links listed on the command line\n      --dereference-command-line-symlink-to-dir\n                             follow each command line symbolic link\n                             that points to a directory\n      --hide=PATTERN         do not list implied entries matching shell PATTERN\n                               (overridden by -a or -A)\n"), __imp__stdout);
        fputs_unlocked(gettext("      --indicator-style=WORD  append indicator with style WORD to entry names:\n                               none (default), slash (-p),\n                               file-type (--file-type), classify (-F)\n  -i, --inode                print the index number of each file\n  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n  -k                         like --block-size=1K\n"), __imp__stdout);
        fputs_unlocked(gettext("  -l                         use a long listing format\n  -L, --dereference          when showing file information for a symbolic\n                               link, show information for the file the link\n                               references rather than for the link itself\n  -m                         fill width with a comma separated list of entries\n"), __imp__stdout);
        fputs_unlocked(gettext("  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n  -N, --literal              print raw entry names (don't treat e.g. control\n                               characters specially)\n  -o                         like -l, but do not list group information\n  -p, --indicator-style=slash\n                             append / indicator to directories\n"), __imp__stdout);
        fputs_unlocked(gettext("  -q, --hide-control-chars   print ? instead of non graphic characters\n      --show-control-chars   show non graphic characters as-is (default\n                             unless program is `ls' and output is a terminal)\n  -Q, --quote-name           enclose entry names in double quotes\n      --quoting-style=WORD   use quoting style WORD for entry names:\n                               literal, locale, shell, shell-always, c, escape\n"), __imp__stdout);
        fputs_unlocked(gettext("  -r, --reverse              reverse order while sorting\n  -R, --recursive            list subdirectories recursively\n  -s, --size                 print the size of each file, in blocks\n"), __imp__stdout);
        fputs_unlocked(gettext("  -S                         sort by file size\n      --sort=WORD            sort by WORD instead of name: none -U,\n                             extension -X, size -S, time -t, version -v\n      --time=WORD            with -l, show time as WORD instead of modification\n                             time: atime -u, access -u, use -u, ctime -c,\n                             or status -c; use specified time as sort key\n                             if --sort=time\n"), __imp__stdout);
        fputs_unlocked(gettext("      --time-style=STYLE     with -l, show times using style STYLE:\n                             full-iso, long-iso, iso, locale, +FORMAT.\n                             FORMAT is interpreted like `date'; if FORMAT is\n                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n                             non-recent files and FORMAT2 to recent files;\n                             if STYLE is prefixed with `posix-', STYLE\n                             takes effect only outside the POSIX locale\n"), __imp__stdout);
        fputs_unlocked(gettext("  -t                         sort by modification time\n  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"), __imp__stdout);
        fputs_unlocked(gettext("  -u                         with -lt: sort by, and show, access time\n                               with -l: show access time and sort by name\n                               otherwise: sort by access time\n  -U                         do not sort; list entries in directory order\n  -v                         sort by version\n"), __imp__stdout);
        fputs_unlocked(gettext("  -w, --width=COLS           assume screen width instead of current value\n  -x                         list entries by lines instead of by columns\n  -X                         sort alphabetically by entry extension\n  -Z, --context              print any SELinux security context of each file\n  -1                         list one file per line\n"), __imp__stdout);
        fputs_unlocked(gettext("      --help     display this help and exit\n"), __imp__stdout);
        fputs_unlocked(gettext("      --version  output version information and exit\n"), __imp__stdout);
        fputs_unlocked(gettext("\nSIZE may be (or may be an integer optionally followed by) one of following:\nkB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"), __imp__stdout);
        fputs_unlocked(gettext("\nBy default, color is not used to distinguish types of files.  That is\nequivalent to using --color=none.  Using the --color option without the\noptional WHEN argument is equivalent to using --color=always.  With\n--color=auto, color codes are output only if standard output is connected\nto a terminal (tty).  The environment variable LS_COLORS can influence the\ncolors, and can be set easily by the dircolors command.\n"), __imp__stdout);
        fputs_unlocked(gettext("\nExit status is 0 if OK, 1 if minor problems, 2 if serious trouble.\n"), __imp__stdout);
        L4();
    } else {
        _t89 = gettext("Try `%s --help' for more information.\n");
        _v20 = program_name;
        fprintf(__imp__stderr, _t89);
    }
    exit(status);
    _push(_t119);
    __esp = __esp - 8;
    _t87 = gettext("\nReport bugs to <%s>.\n");
    _v36 = "bug-coreutilsgnu.org";
    printf(_t87);
    return;
}

emit_bug_reporting_address()
{// addr = 0x080513B2  --  defined in 'system.h' at line 575
    char* _v8;                             // _cfa_fffffff8
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2
    char* _t3;                             // _t3
    _unknown_ _t4;                         // _t4

    _t3 = gettext("\nReport bugs to <%s>.\n");
    _v8 = "bug-coreutilsgnu.org";
    printf(_t3);
    return;
}

char* areadlink_with_size(const char* file, size_t size)
{// addr = 0x080513D8  --  defined in 'areadlink-with-size.c' at line 57
    size_t symlink_max;   // _cfa_fffffff8
    size_t INITIAL_LIMIT_BOUND;   // _cfa_fffffff4
    size_t initial_limit;   // _cfa_fffffff0
    size_t buf_size;    // _cfa_ffffffec
    ssize_t r;         // _cfa_ffffffe8
    size_t link_length;   // _cfa_ffffffe4
    char* buffer;                          // _cfa_ffffffe0
    int saved_errno;                       // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t66;                        // _t66
    _unknown_ _t77;                        // _t77

    symlink_max = 1024;
    INITIAL_LIMIT_BOUND = 8192;
    if(symlink_max >= INITIAL_LIMIT_BOUND) {
        _v48 = INITIAL_LIMIT_BOUND;
    } else {
        _v48 = symlink_max + 1;
    }
    initial_limit = _v48;
    if(size >= initial_limit) {
        _v44 = initial_limit;
    } else {
        _v44 = size + 1;
    }
    buf_size = _v44;
    while(1) {
        buffer = malloc(buf_size);
        if(buffer == 0) {
            break;
        }
        r = readlink(file, buffer, buf_size);
        link_length = r;
        if(r >= 0 ||  *(__errno_location()) == 34) {
            if(link_length >= buf_size) {
                free(buffer);
                if(buf_size > 1073741823) {
                    if(buf_size > 2147483646) {
                         *(__errno_location()) = 12;
                        _v40 = 0;
                        goto L19;
                    }
                    goto L17;
                }
                goto L15;
L17:
                buf_size = 2147483647;
                continue;
            }
            goto L13;
L15:
            buf_size = buf_size << 1;
            continue;
        } else {
            saved_errno =  *(__errno_location());
            free(buffer);
             *(__errno_location()) = saved_errno;
            _v40 = 0;
L19:
            return _v40;
        }
L13:
        buffer[link_length] = 0;
        _v40 = buffer;
        goto L19;
    }
    _v40 = 0;
    goto L19;
}

int gnu_mbswidth(const _None* string, int flags)
{// addr = 0x0805150C  --  defined in 'mbswidth.c' at line 52
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return mbsnwidth(string, strlen(string), flags);
}

int mbsnwidth(const _None* string, size_t nbytes, int flags)
{// addr = 0x08051537  --  defined in 'mbswidth.c' at line 63
    unsigned char c;                       // _cfa_fffffffb
    const _None* p;   // _cfa_fffffff4
    const _None* plimit;   // _cfa_fffffff0
    int width;                             // _cfa_ffffffec
    wchar_t wc;        // _cfa_ffffffe8
    size_t bytes;       // _cfa_ffffffe4
    int w;                                 // _cfa_ffffffe0
    mbstate_t mbstate;   // _cfa_ffffffd8
    int _v56;                              // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    int* _v64;                             // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    const _None* _v72;   // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    const _None* _t103;   // _t103
    signed int _t106;                      // _t106
    signed int _t114;                      // _t114
    _unknown_ _t130;                       // _t130
    unsigned int _t135;                    // _t135
    int _t136;                             // _t136
    signed int _t139;                      // _t139
    int* _t142;                            // _t142

    p = string;
    _t103 = p + nbytes;
    plimit = _t103;
    width = 0;
    __ctype_get_mb_cur_max();
    if(_t103 <= 1) {
        while(p < plimit) {
            _t106 =  *p & 255;
            c = _t106 & 255;
            p =  &(p[1]);
            __ctype_b_loc();
            if(( *( *_t106 + (c & 255) + (c & 255)) & 0x4000) == 0) {
                _t114 = flags & 2;
                if(_t114 != 0) {
                    _v56 = -1;
                } else {
                    __ctype_b_loc();
                    width = width + ( *( *_t114 + (c & 255) + (c & 255)) & 2);
                    continue;
                }
            } else {
                width = width + 1;
                continue;
            }
            goto L36;
        }
        _v56 = width;
    } else {
L27:
        while(p < plimit) {
            _v60 =  *p & 0xff;
            if(_v60 > 95) {
                if(_v60 - 97 > 29) {
                    goto L10;
                } else {
                    goto L9;
                }
            } else {
                if(_v60 >= 65) {
L9:
                    p =  &(p[1]);
                    width = width + 1;
                    continue;
                }
                if(_v60 < 32) {
L10:
                    memset( &(mbstate.__count), 0, 8);
                    while(1) {
L11:
                        _v64 =  &(mbstate.__count);
                        _v68 = plimit - p;
                        _v72 = p;
                        _t135 =  &wc;
                         *__esp = _t135;
                        mbrtowc();
                        bytes = _t135;
                        if(bytes == 255) {
                            break;
                        }
                        if(bytes != 254) {
                            if(bytes == 0) {
                                bytes = 1;
                            }
                            _t136 = wc;
                             *__esp = _t136;
                            wcwidth();
                            w = _t136;
                            if(w >= 0) {
                                if((flags & 2) != 0) {
                                    _v56 = -1;
                                } else {
                                    _t139 = wc;
                                     *__esp = _t139;
                                    iswcntrl();
                                    width = width + (_t139 & 0xff);
                                    goto L26;
                                }
                            } else {
                                width = width + w;
L26:
                                p = p + bytes;
                                _t142 =  &(mbstate.__count);
                                 *__esp = _t142;
                                mbsinit();
                                if(_t142 == 0) {
                                    continue;
                                } else {
                                    goto L27;
                                }
                            }
                        } else {
                            if((flags & 1) != 0) {
                                _v56 = -1;
                            } else {
                                p = plimit;
                                width = width + 1;
                                goto L27;
                            }
                        }
                        goto L36;
                    }
                    if((flags & 1) != 0) {
                        _v56 = -1;
                    } else {
                        p =  &(p[1]);
                        width = width + 1;
                        continue;
                    }
                    goto L36;
                }
                if(_v60 <= 35) {
                    goto L9;
                }
                if(_v60 - 37 > 26) {
                    goto L10;
                } else {
                    goto L9;
                }
            }
            goto L11;
        }
        _v56 = width;
    }
L36:
    return _v56;
}

version_etc_va(FILE* stream, const char* command_name, const char* package, const char* version, va_list authors)
{// addr = 0x08051750  --  defined in 'version-etc.c' at line 43
    size_t n_authors;   // _cfa_fffffff4
    va_list tmp_authors;   // _cfa_fffffff0
    const char* _v28;   // _cfa_ffffffe4
    const char* _v32;   // _cfa_ffffffe0
    const char* _v36;   // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t44;                        // _t44
    char* _t45;                            // _t45
    _unknown_ _t47;                        // _t47
    _unknown_ _t50;                        // _t50
    _unknown_ _t53;                        // _t53
    _unknown_ _t55;                        // _t55
    _unknown_ _t56;                        // _t56
    _unknown_ _t61;                        // _t61
    char* _t62;                            // _t62

    tmp_authors = authors;
    n_authors = 0;
    while(1) {
        _t62 = tmp_authors;
        tmp_authors =  &(_t62[4]);
        if( *_t62 == 0) {
            break;
        }
        n_authors = n_authors + 1;
    }
    if(command_name == 0) {
        _v32 = version;
        _v36 = package;
        fprintf(stream, "%s %s\n");
    } else {
        _v28 = version;
        _v32 = package;
        _v36 = command_name;
        fprintf(stream, "%s (%s) %s\n");
    }
    _t45 = gettext("(C)");
    _v32 = 2008;
    _v36 = _t45;
    fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.");
    fputs_unlocked(gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n"), stream);
    if(n_authors <= 9) {
        goto __eax;
    }
    rpl_vfprintf(stream, gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"), authors);
    return;
}

version_etc(FILE* stream, const char* command_name, const char* package, const char* version)
{// addr = 0x080519AF  --  defined in 'version-etc.c' at line 167
    va_list authors;   // _cfa_fffffff8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    authors =  &_a20;
    version_etc_va(stream, command_name, package, version, authors);
    return;
}

xalloc_die()
{// addr = 0x080519E4  --  defined in 'xalloc-die.c' at line 33
    char* _v16;                            // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    _v16 = gettext("memory exhausted");
    error(exit_failure, 0, "%s");
    abort();
    _push(_t7);
    __esp = __esp - 8;
    usage(1);
    return;
}

__argmatch_die()
{// addr = 0x08051A20  --  defined in 'argmatch.c' at line 62
    _unknown_ __ebp;                       // r6

    usage(1);
    return;
}

ptrdiff_t argmatch(const char* arg, const const char** arglist, const char* vallist, size_t valsize)
{// addr = 0x08051A34  --  defined in 'argmatch.c' at line 85
    _Bool ambiguous;                       // _cfa_fffffffb
    size_t i;           // _cfa_fffffff4
    size_t arglen;      // _cfa_fffffff0
    ptrdiff_t matchind;   // _cfa_ffffffec
    int _v24;                              // _cfa_ffffffe8
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    unsigned int _t61;                     // _t61

    matchind = -1;
    ambiguous = 0;
    arglen = strlen(arg);
    i = 0;
    while( *(arglist + (i << 2)) != 0) {
        if(strncmp( *(arglist + (i << 2)), arg, arglen) != 0) {
L9:
            i = i + 1;
            continue;
        }
        if(strlen( *(arglist + (i << 2))) != arglen) {
            if(matchind != 255) {
                if(vallist == 0) {
L8:
                    ambiguous = 1;
                    goto L9;
                }
                goto L7;
            }
            goto L5;
L7:
            _t61 = valsize;
            _v36 = _t61;
            _v40 = vallist + valsize * i;
             *__esp = vallist + matchind * valsize;
            memcmp();
            if(_t61 == 0) {
                goto L9;
            }
            goto L8;
        }
        _v24 = i;
L14:
        return _v24;
L5:
        matchind = i;
        goto L9;
    }
    if(ambiguous == 0) {
        _v24 = matchind;
    } else {
        _v24 = -2;
    }
    goto L14;
}

argmatch_invalid(const char* context, const char* value, ptrdiff_t problem)
{// addr = 0x08051B1C  --  defined in 'argmatch.c' at line 131
    const char* format;   // _cfa_fffffff4
    char* _v28;                            // _cfa_ffffffe4
    const _None* _v44;   // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    const _None* _t20;   // _t20
    char* _t22;                            // _t22

    if(problem != 255) {
        _v28 = gettext("ambiguous argument %s for %s");
    } else {
        _v28 = gettext("invalid argument %s for %s");
    }
    format = _v28;
    _t20 = quote_n(1, context);
    _t22 = quotearg_n_style(0, 5, value);
    _v44 = _t20;
    _v48 = _t22;
    error(0, 0, format);
    return;
}

argmatch_valid(const const char** arglist, const char* vallist, size_t valsize)
{// addr = 0x08051BA8  --  defined in 'argmatch.c' at line 147
    size_t i;           // _cfa_fffffff8
    const char* last_val;   // _cfa_fffffff4
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29
    _unknown_ _t31;                        // _t31
    _unknown_ _t40;                        // _t40
    const char* _t47;   // _t47
    _unknown_ _t52;                        // _t52
    _unknown_ _t54;                        // _t54

    last_val = 0;
    fprintf(__imp__stderr, gettext("Valid arguments are:"));
    i = 0;
    while( *(arglist + (i << 2)) != 0) {
        if(i == 0) {
L3:
            _v36 =  *(arglist + (i << 2));
            fprintf(__imp__stderr, "\n  - `%s'");
            last_val = vallist + valsize * i;
        } else {
            _v36 = valsize;
            _v40 = vallist + valsize * i;
            _t47 = last_val;
             *__esp = _t47;
            memcmp();
            if(_t47 == 0) {
                _v36 =  *(arglist + (i << 2));
                fprintf(__imp__stderr, ", `%s'");
            } else {
                goto L3;
            }
        }
        i = i + 1;
    }
    putc_unlocked(10, __imp__stderr);
    return;
}

ptrdiff_t __xargmatch_internal(const char* context, const char* arg, const const char** arglist, const char* vallist, size_t valsize, argmatch_exit_fn exit_fn)
{// addr = 0x08051C92  --  defined in 'argmatch.c' at line 179
    ptrdiff_t res;   // _cfa_fffffff8
    int _v24;                              // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37

    res = argmatch(arg, arglist, vallist, valsize);
    if(res >= 0) {
        argmatch_invalid(context, arg, res);
        argmatch_valid(arglist, vallist, valsize);
         *exit_fn();
        _v24 = -1;
    } else {
        _v24 = res;
    }
    return;
}

const char* argmatch_to_argument(const char* value, const const char** arglist, const char* vallist, size_t valsize)
{// addr = 0x08051D0C  --  defined in 'argmatch.c' at line 199
    size_t i;           // _cfa_fffffff8
    const char* _v24;   // _cfa_ffffffe8
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    const char* _t25;   // _t25

    i = 0;
    while( *(arglist + (i << 2)) != 0) {
        _v36 = valsize;
        _v40 = vallist + valsize * i;
        _t25 = value;
         *__esp = _t25;
        memcmp();
        if(_t25 != 0) {
            i = i + 1;
            continue;
        }
        _v24 =  *(arglist + (i << 2));
L6:
        return _v24;
    }
    _v24 = 0;
    goto L6;
}

char* last_component(const _None* name)
{// addr = 0x08051D70  --  defined in 'basename.c' at line 33
    _Bool saw_slash;                       // _cfa_fffffffb
    const _None* base;   // _cfa_fffffff4
    const _None* p;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    base = name;
    saw_slash = 0;
    while(( *base & 0xff) == 47) {
        base =  &(base[1]);
    }
    p = base;
    while(( *p & 0xff) != 0) {
        if(( *p & 0xff) != 47) {
            if(saw_slash != 0) {
                base = p;
                saw_slash = 0;
            }
        } else {
            saw_slash = 1;
        }
        p =  &(p[1]);
    }
    return base;
}

char* base_name(const _None* name)
{// addr = 0x08051DCB  --  defined in 'basename.c' at line 75
    const _None* base;   // _cfa_fffffff8
    size_t length;      // _cfa_fffffff4
    char* _v24;                            // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    base = last_component(name);
    if(( *base & 0xff) != 0) {
        length = base_len(base);
        if(( *(base + length) & 0xff) == 47) {
            length = length + 1;
        }
        _v24 = xstrndup(base, length);
    } else {
        _v24 = xstrndup(name, base_len(name));
    }
    return _v24;
}

size_t base_len(const _None* name)
{// addr = 0x08051E43  --  defined in 'basename.c' at line 112
    size_t len;         // _cfa_fffffff8
    size_t prefix_len;   // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    prefix_len = 0;
    len = strlen(name);
    while(len > 1 && ( *(name + len - 1) & 0xff) == 47) {
        len = len - 1;
    }
    return len;
}

close_stdout_set_file_name(const char* file)
{// addr = 0x08051E80  --  defined in 'closeout.c' at line 41
    _unknown_ __ebp;                       // r6

    file_name = file;
    return;
}

close_stdout()
{// addr = 0x08051E8D  --  defined in 'closeout.c' at line 70
    const char* write_error;   // _cfa_fffffff4
    const char* _v28;   // _cfa_ffffffe4
    const char* _v32;   // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    char* __ebx;                           // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t16;                        // _t16
    int* _t19;                             // _t19
    _unknown_ _t22;                        // _t22
    int* _t25;                             // _t25

    if(close_stream(__imp__stdout) != 0) {
        write_error = gettext("write error");
        if(file_name == 0) {
            _t19 = __errno_location();
            _v32 = write_error;
            error(0,  *_t19, "%s");
        } else {
            __ebx = quotearg_colon(file_name);
            _t25 = __errno_location();
            _v28 = write_error;
            _v32 = __ebx;
            error(0,  *_t25, "%s: %s");
        }
        _exit(exit_failure);
    }
    if(close_stream(__imp__stderr) != 0) {
        _exit(exit_failure);
        return;
    }
    return;
}

int file_has_acl(const char* name, const struct stat* sb)
{// addr = 0x08051F54  --  defined in 'file-has-acl.c' at line 32
    _unknown_ __ebp;                       // r6

    return 0;
}

char ftypelet(mode_t bits)
{// addr = 0x08051F60  --  defined in 'filemode.c' at line 55
    signed char _v5;                       // _cfa_fffffffb
    _unknown_ __ebp;                       // r6

    if((bits & 61440) != 32768) {
        if((bits & 61440) != 16384) {
            if((bits & 61440) != 24576) {
                if((bits & 61440) != 8192) {
                    if((bits & 61440) != 40960) {
                        if((bits & 61440) != 4096) {
                            if((bits & 61440) != 49152) {
                                _v5 = 63;
                            } else {
                                _v5 = 115;
                            }
                        } else {
                            _v5 = 112;
                        }
                    } else {
                        _v5 = 108;
                    }
                } else {
                    _v5 = 99;
                }
            } else {
                _v5 = 98;
            }
        } else {
            _v5 = 100;
        }
    } else {
        _v5 = 45;
    }
    return _v5 & 255;
}

strmode(mode_t mode, char* str)
{// addr = 0x08052006  --  defined in 'filemode.c' at line 97
    signed char _v5;                       // _cfa_fffffffb
    signed char _v6;                       // _cfa_fffffffa
    signed char _v7;                       // _cfa_fffffff9
    char* _v12;                            // _cfa_fffffff4
    signed char _v13;                      // _cfa_fffffff3
    char* _v20;                            // _cfa_ffffffec
    signed char _v21;                      // _cfa_ffffffeb
    char* _v28;                            // _cfa_ffffffe4
    signed char _v29;                      // _cfa_ffffffe3
    signed char _v30;                      // _cfa_ffffffe2
    signed char _v31;                      // _cfa_ffffffe1
    char* _v36;                            // _cfa_ffffffdc
    signed char _v37;                      // _cfa_ffffffdb
    char* _v44;                            // _cfa_ffffffd4
    signed char _v45;                      // _cfa_ffffffd3
    char* _v52;                            // _cfa_ffffffcc
    signed char _v53;                      // _cfa_ffffffcb
    signed char _v54;                      // _cfa_ffffffca
    signed char _v55;                      // _cfa_ffffffc9
    char* _v60;                            // _cfa_ffffffc4
    signed char _v61;                      // _cfa_ffffffc3
    char* _v68;                            // _cfa_ffffffbc
    signed char _v69;                      // _cfa_ffffffbb
    char* _v76;                            // _cfa_ffffffb4
    _unknown_ __ebp;                       // r6

     *str = ftypelet(mode) & 255;
    _v76 =  &(str[1]);
    if((mode & 256) == 0) {
        _v69 = 45;
    } else {
        _v69 = 114;
    }
     *_v76 = _v69 & 0xff;
    _v68 =  &(str[2]);
    if((mode & 128) == 0) {
        _v61 = 45;
    } else {
        _v61 = 119;
    }
     *_v68 = _v61 & 0xff;
    _v60 =  &(str[3]);
    if((mode & 2048) == 0) {
        if((mode & 64) == 0) {
            _v53 = 45;
        } else {
            _v53 = 120;
        }
        _v55 = _v53 & 0xff;
    } else {
        if((mode & 64) == 0) {
            _v54 = 83;
        } else {
            _v54 = 115;
        }
        _v55 = _v54 & 0xff;
    }
     *_v60 = _v55 & 0xff;
    _v52 =  &(str[4]);
    if((mode & 32) == 0) {
        _v45 = 45;
    } else {
        _v45 = 114;
    }
     *_v52 = _v45 & 0xff;
    _v44 =  &(str[5]);
    if((mode & 16) == 0) {
        _v37 = 45;
    } else {
        _v37 = 119;
    }
     *_v44 = _v37 & 0xff;
    _v36 =  &(str[6]);
    if((mode & 1024) == 0) {
        if((mode & 8) == 0) {
            _v29 = 45;
        } else {
            _v29 = 120;
        }
        _v31 = _v29 & 0xff;
    } else {
        if((mode & 8) == 0) {
            _v30 = 83;
        } else {
            _v30 = 115;
        }
        _v31 = _v30 & 0xff;
    }
     *_v36 = _v31 & 0xff;
    _v28 =  &(str[7]);
    if((mode & 4) == 0) {
        _v21 = 45;
    } else {
        _v21 = 114;
    }
     *_v28 = _v21 & 0xff;
    _v20 =  &(str[8]);
    if((mode & 2) == 0) {
        _v13 = 45;
    } else {
        _v13 = 119;
    }
     *_v20 = _v13 & 0xff;
    _v12 =  &(str[9]);
    if((mode & 512) == 0) {
        if((mode & 1) == 0) {
            _v5 = 45;
        } else {
            _v5 = 120;
        }
        _v7 = _v5 & 0xff;
    } else {
        if((mode & 1) == 0) {
            _v6 = 84;
        } else {
            _v6 = 116;
        }
        _v7 = _v6 & 0xff;
    }
     *_v12 = _v7 & 0xff;
    str[0xa] = 32;
    str[0xb] = 0;
    return;
}

filemodestring(const struct stat* statp, char* str)
{// addr = 0x0805221C  --  defined in 'filemode.c' at line 167
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    strmode( *(statp + 16), str);
    return;
}

const _None* longest_relative_suffix(const _None* f)
{// addr = 0x0805223C  --  defined in 'filenamecat.c' at line 40
    _unknown_ __ebp;                       // r6

    while(( *f & 0xff) == 47) {
        f =  &(f[1]);
    }
    return f;
}

char* mfile_name_concat(const _None* dir, const _None* abase, char** base_in_result)
{// addr = 0x08052254  --  defined in 'filenamecat.c' at line 63
    const _None* dirbase;   // _cfa_fffffff8
    size_t dirbaselen;   // _cfa_fffffff4
    size_t dirlen;      // _cfa_fffffff0
    size_t needs_separator;   // _cfa_ffffffec
    const _None* base;   // _cfa_ffffffe8
    size_t baselen;     // _cfa_ffffffe4
    char* p_concat;                        // _cfa_ffffffe0
    char* p;                               // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    unsigned int _v52;                     // _cfa_ffffffcc
    const _None* _v56;   // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    char* _t77;                            // _t77
    char* _t82;                            // _t82

    dirbase = last_component(dir);
    dirbaselen = base_len(dirbase);
    dirlen = dirbase - dir + dirbaselen;
    if(dirbaselen == 0 || ( *(dirbaselen - 1 + dirbase) & 0xff) == 47) {
        _v44 = 0;
    } else {
        _v44 = 1;
    }
    needs_separator = _v44;
    base = longest_relative_suffix(abase);
    baselen = strlen(base);
    p_concat = malloc(dirlen + needs_separator + baselen + 1);
    if(p_concat != 0) {
        _v52 = dirlen;
        _v56 = dir;
        _t77 = p_concat;
         *__esp = _t77;
        mempcpy();
        p = _t77;
         *p = 47;
        p =  &(p[needs_separator]);
        if(base_in_result != 0) {
             *base_in_result =  &(p[ ~( *abase & 0xff)]);
        }
        _v52 = baselen;
        _v56 = base;
        _t82 = p;
         *__esp = _t82;
        mempcpy();
        p = _t82;
         *p = 0;
        _v40 = p_concat;
    } else {
        _v40 = 0;
    }
    return _v40;
}

char* file_name_concat(const _None* dir, const _None* abase, char** base_in_result)
{// addr = 0x0805236D  --  defined in 'filenamecat.c' at line 97
    char* p;                               // _cfa_fffffff8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    p = mfile_name_concat(dir, abase, base_in_result);
    if(p == 0) {
        xalloc_die();
    }
    return p;
}

_Bool hard_locale(int category)
{// addr = 0x080523A0  --  defined in 'hard-locale.c' at line 37
    _Bool hard;                            // _cfa_fffffffb
    const char* p;   // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    hard = 1;
    p = setlocale(category, 0);
    if(p != 0 && (strcmp(p, "C") == 0 || strcmp(p, "POSIX") == 0)) {
        hard = 0;
    }
    return hard & 255;
}

size_t hash_get_n_buckets(const Hash_table* table)
{// addr = 0x08052400  --  defined in 'hash.c' at line 148
    _unknown_ __ebp;                       // r6

    return  *(table + 8);
}

size_t hash_get_n_buckets_used(const Hash_table* table)
{// addr = 0x0805240B  --  defined in 'hash.c' at line 156
    _unknown_ __ebp;                       // r6

    return  *(table + 12);
}

size_t hash_get_n_entries(const Hash_table* table)
{// addr = 0x08052416  --  defined in 'hash.c' at line 164
    _unknown_ __ebp;                       // r6

    return  *(table + 16);
}

size_t hash_get_max_bucket_length(const Hash_table* table)
{// addr = 0x08052421  --  defined in 'hash.c' at line 172
    const struct hash_entry* bucket;   // _cfa_fffffff8
    size_t max_bucket_length;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    size_t bucket_length;   // _cfa_ffffffec
    _unknown_ __ebp;                       // r6

    max_bucket_length = 0;
    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data == 0) {
L7:
            bucket = bucket + 8;
            continue;
        }
        cursor = bucket;
        bucket_length = 1;
        while(1) {
            cursor = cursor->next;
            if(cursor == 0) {
                break;
            }
            bucket_length = bucket_length + 1;
        }
        if(bucket_length > max_bucket_length) {
            max_bucket_length = bucket_length;
        }
        goto L7;
    }
    return max_bucket_length;
}

_Bool hash_table_ok(const Hash_table* table)
{// addr = 0x08052485  --  defined in 'hash.c' at line 199
    const struct hash_entry* bucket;   // _cfa_fffffff8
    size_t n_buckets_used;   // _cfa_fffffff4
    size_t n_entries;   // _cfa_fffffff0
    const struct hash_entry* cursor;   // _cfa_ffffffec
    signed char _v21;                      // _cfa_ffffffeb
    _unknown_ __ebp;                       // r6

    n_buckets_used = 0;
    n_entries = 0;
    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data == 0) {
L5:
            bucket = bucket + 8;
            continue;
        }
        cursor = bucket;
        n_buckets_used = n_buckets_used + 1;
        n_entries = n_entries + 1;
        while(1) {
            cursor = cursor->next;
            if(cursor == 0) {
                break;
            }
            n_entries = n_entries + 1;
        }
        goto L5;
    }
    if( *((intOrPtr*)(table + 12)) != n_buckets_used ||  *((intOrPtr*)(table + 16)) != n_entries) {
        _v21 = 0;
    } else {
        _v21 = 1;
    }
    return _v21 & 255;
}

hash_print_statistics(const Hash_table* table, FILE* stream)
{// addr = 0x08052504  --  defined in 'hash.c' at line 228
    size_t n_entries;   // _cfa_fffffff8
    size_t n_buckets;   // _cfa_fffffff4
    size_t n_buckets_used;   // _cfa_fffffff0
    size_t max_bucket_length;   // _cfa_ffffffec
    unsigned int _v36;                     // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39
    _unknown_ _t42;                        // _t42
    _unknown_ _t47;                        // _t47
    _unknown_ _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    _unknown_ _t52;                        // _t52

    n_entries = hash_get_n_entries(table);
    n_buckets = hash_get_n_buckets(table);
    n_buckets_used = hash_get_n_buckets_used(table);
    max_bucket_length = hash_get_max_bucket_length(table);
    _v36 = n_entries;
    fprintf(stream, "# entries:         %lu\n");
    _v36 = n_buckets;
    fprintf(stream, "# buckets:         %lu\n");
    _push(0);
    _push(n_buckets_used);
    asm("fild qword [esp]");
    __esp =  &_v44;
    asm("fld qword [0x80618e0]");
    asm("fmulp st1, st0");
    _push(0);
    _push(n_buckets);
    asm("fild qword [esp]");
    __esp =  &((char*)( &_v44)[2]);
    asm("fdivp st1, st0");
    asm("fstp qword [esp+0xc]");
    _v44 = n_buckets_used;
    (__esp)[1] = "# buckets used:    %lu (%.2f%%)\n";
     *__esp = stream;
    fprintf();
    _v44 = max_bucket_length;
    (__esp)[1] = "max bucket length: %lu\n";
     *__esp = stream;
    fprintf();
    return;
}

_Unknown_base* hash_lookup(const Hash_table* table, * entry)
{// addr = 0x080525DC  --  defined in 'hash.c' at line 248
    const struct hash_entry* bucket;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    _Unknown_base* _v28;                   // _cfa_ffffffe4
    _Unknown_base* _v40;                   // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t36;                       // _t36
    signed int _t47;                       // _t47
    _unknown_ _t50;                        // _t50

    _v40 =  *(table + 8);
    _t36 = entry;
     *__esp = _t36;
     *((intOrPtr*)( *((intOrPtr*)(table + 24))))();
    bucket = table->bucket + (_t36 << 3);
    if(table->bucket_limit <= bucket) {
        abort();
    }
    if(bucket->data != 0) {
        cursor = bucket;
        while(cursor != 0) {
            _v40 = cursor->data;
            _t47 = entry;
             *__esp = _t47;
             *((intOrPtr*)( *((intOrPtr*)(table + 28))))();
            if((_t47 & 255) == 0) {
                cursor = cursor->next;
                continue;
            }
            _v28 = cursor->data;
L10:
            return;
        }
        _v28 = 0;
        goto L10;
    }
    _v28 = 0;
    goto L10;
}

_Unknown_base* hash_get_first(const Hash_table* table)
{// addr = 0x08052677  --  defined in 'hash.c' at line 277
    const struct hash_entry* bucket;   // _cfa_fffffff8
    _Unknown_base* _v24;                   // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26

    if( *((intOrPtr*)(table + 16)) != 0) {
        bucket = table->bucket;
        while() {
        }
    }
    _v24 = 0;
    return _v24;
}

_Unknown_base* hash_get_next(const Hash_table* table, * entry)
{// addr = 0x080526C6  --  defined in 'hash.c' at line 296
    const struct hash_entry* bucket;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    _Unknown_base* _v28;                   // _cfa_ffffffe4
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t40;                       // _t40
    _unknown_ _t56;                        // _t56

    _v40 =  *((intOrPtr*)(table + 8));
    _t40 = entry;
     *__esp = _t40;
     *((intOrPtr*)( *((intOrPtr*)(table + 24))))();
    bucket = table->bucket + (_t40 << 3);
    if(table->bucket_limit <= bucket) {
        abort();
    }
    cursor = bucket;
    while(cursor != 0) {
        if(cursor->data != entry || cursor->next == 0) {
            cursor = cursor->next;
            continue;
        }
        _v28 = cursor->next->data;
L13:
        return;
    }
    while(1) {
        bucket = bucket + 8;
        if(bucket >= table->bucket_limit) {
            break;
        }
        if(bucket->data == 0) {
            continue;
        }
        _v28 = bucket->data;
        goto L13;
    }
    _v28 = 0;
    goto L13;
}

size_t hash_get_entries(const Hash_table* table, _Unknown_base** buffer, size_t buffer_size)
{// addr = 0x0805276F  --  defined in 'hash.c' at line 325
    size_t counter;     // _cfa_fffffff8
    const struct hash_entry* bucket;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    unsigned int _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    counter = 0;
    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data == 0) {
L7:
            bucket = bucket + 8;
            continue;
        }
        cursor = bucket;
        while(cursor != 0) {
            if(counter < buffer_size) {
                buffer[counter] = cursor->data;
                counter = counter + 1;
                cursor = cursor->next;
                continue;
            }
            _v24 = counter;
L10:
            return _v24;
        }
        goto L7;
    }
    _v24 = counter;
    goto L10;
}

size_t hash_do_for_each(const Hash_table* table, Hash_processor processor, _Unknown_base* processor_data)
{// addr = 0x080527E6  --  defined in 'hash.c' at line 357
    size_t counter;     // _cfa_fffffff8
    const struct hash_entry* bucket;   // _cfa_fffffff4
    const struct hash_entry* cursor;   // _cfa_fffffff0
    unsigned int _v24;                     // _cfa_ffffffe8
    _Unknown_base* _v40;                   // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    signed int _t38;                       // _t38
    _unknown_ _t43;                        // _t43

    counter = 0;
    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data == 0) {
L7:
            bucket = bucket + 8;
            continue;
        }
        cursor = bucket;
        while(cursor != 0) {
            _v40 = processor_data;
             *__esp = cursor->data;
            _t38 = processor;
             *_t38();
            if(((_t38 ^ 1) & 255) == 0) {
                counter = counter + 1;
                cursor = cursor->next;
                continue;
            }
            _v24 = counter;
L10:
            return;
        }
        goto L7;
    }
    _v24 = counter;
    goto L10;
}

size_t hash_string(const char* string, size_t n_buckets)
{// addr = 0x0805285E  --  defined in 'hash.c' at line 419
    unsigned char ch;                      // _cfa_fffffffb
    size_t value;       // _cfa_fffffff4
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27
    _unknown_ _t34;                        // _t34

    value = 0;
    while(1) {
        ch =  *string & 0xff;
        if(ch == 0) {
            break;
        }
        _v28 = (value << 5) - value + (ch & 255);
        value = _v28 % n_buckets;
        string =  &(string[1]);
    }
    return value;
}

_Bool is_prime(size_t candidate)
{// addr = 0x080528AA  --  defined in 'hash.c' at line 435
    size_t divisor;     // _cfa_fffffff8
    size_t square;      // _cfa_fffffff4
    unsigned int _v32;                     // _cfa_ffffffe0
    _unknown_ __ebp;                       // r6
    _unknown_ _t38;                        // _t38
    _unknown_ _t42;                        // _t42
    _unknown_ _t46;                        // _t46
    _unknown_ _t48;                        // _t48

    divisor = 3;
    square = divisor * divisor;
    while(square < candidate) {
        _v32 = candidate;
        if(_v32 % divisor != 0) {
            divisor = divisor + 1;
            square = square + (divisor << 2);
            divisor = divisor + 1;
            continue;
        }
        break;
    }
    _v32 = candidate;
    return _v32 % divisor;
}

size_t next_prime(size_t candidate)
{// addr = 0x0805290D  --  defined in 'hash.c' at line 454
    _unknown_ __ebp;                       // r6

    if(candidate <= 9) {
        candidate = 10;
    }
    candidate = candidate | 1;
    while(((is_prime(candidate) ^ 1) & 255) != 0) {
        candidate = candidate + 2;
    }
    return candidate;
}

hash_reset_tuning(Hash_tuning* tuning)
{// addr = 0x08052941  --  defined in 'hash.c' at line 470
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    tuning->shrink_threshold = 0;
    tuning->shrink_factor = 1065353216;
    tuning->growth_threshold = 1061997773;
    tuning->growth_factor = 1068826100;
    tuning->is_n_buckets = 0;
    return;
}

_Bool check_tuning(Hash_table* table)
{// addr = 0x08052978  --  defined in 'hash.c' at line 482
    const Hash_tuning* tuning;   // _cfa_fffffff8
    float epsilon;                         // _cfa_fffffff4
    signed char _v21;                      // _cfa_ffffffeb
    _unknown_ __ebp;                       // r6
    _unknown_ _t21;                        // _t21
    _unknown_ _t22;                        // _t22
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32

    __eflags = __eflags;
    tuning = table->tuning;
    epsilon = 1036831949;
    asm("fld dword [eax+0x8]");
    asm("fld dword [ebp-0x8]");
    asm("fxch st0, st1");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(__eflags <= 0) {
L8:
        table->tuning =  &default_tuning;
        _v21 = 0;
    } else {
        asm("fld dword [eax+0x8]");
        asm("fld1 ");
        asm("fsub dword [ebp-0x8]");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags <= 0) {
            goto L8;
        } else {
            asm("fld dword [ebp-0x8]");
            asm("fld1 ");
            asm("faddp st1, st0");
            asm("fld dword [eax+0xc]");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags <= 0) {
                goto L8;
            } else {
                asm("fld dword [eax]");
                asm("fldz ");
                asm("fxch st0, st1");
                asm("fucompp ");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags < 0) {
                    goto L8;
                } else {
                    asm("fld dword [eax]");
                    asm("fadd dword [ebp-0x8]");
                    asm("fld dword [eax+0x4]");
                    asm("fucompp ");
                    asm("fnstsw ax");
                    asm("sahf ");
                    if(__eflags <= 0) {
                        goto L8;
                    } else {
                        asm("fld dword [eax+0x4]");
                        asm("fld1 ");
                        asm("fucompp ");
                        asm("fnstsw ax");
                        asm("sahf ");
                        if(__eflags < 0) {
                            goto L8;
                        } else {
                            asm("fld dword [eax]");
                            asm("fadd dword [ebp-0x8]");
                            asm("fld dword [eax+0x8]");
                            asm("fucompp ");
                            asm("fnstsw ax");
                            asm("sahf ");
                            if(__eflags <= 0) {
                                goto L8;
                            } else {
                                _v21 = 1;
                            }
                        }
                    }
                }
            }
        }
    }
    return _v21 & 255;
}

Hash_table* hash_initialize(size_t candidate, const Hash_tuning* tuning, Hash_hasher hasher, Hash_comparator comparator, Hash_data_freer data_freer)
{// addr = 0x08052A2A  --  defined in 'hash.c' at line 540
    float new_candidate;                   // _cfa_fffffff4
    Hash_table* table;   // _cfa_fffffff8
    signed short _v22;                     // _cfa_ffffffea
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    Hash_table* _v40;   // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6
    signed int _t72;                       // _t72
    _unknown_ _t74;                        // _t74
    Hash_table* _t81;   // _t81
    _unknown_ _t102;                       // _t102
    _unknown_ _t113;                       // _t113
    _unknown_ _t114;                       // _t114

    if(hasher == 0 || comparator == 0) {
        _v40 = 0;
L16:
        return _v40;
    }
    table = malloc(40);
    __eflags = table;
    if(table != 0) {
        __eflags = tuning;
        if(tuning == 0) {
            tuning =  &default_tuning;
        }
        table->tuning = tuning;
        _t72 = check_tuning(table) ^ 1;
        __eflags = _t72 & 255;
        if((_t72 & 255) != 0) {
L15:
            free(table);
            _v40 = 0;
        } else {
            __eflags = (tuning->is_n_buckets & 255 ^ 1) & 255;
            if(__eflags == 0) {
L11:
                __eflags = candidate - 536870911;
                if(candidate > 536870911) {
                    goto L15;
                }
                goto L12;
            }
            _push(0);
            _push(candidate);
            asm("fild qword [esp]");
            asm("fld dword [eax+0x8]");
            asm("fdivp st1, st0");
            asm("fstp dword [ebp-0x8]");
            asm("fld dword [ebp-0x8]");
            asm("fld dword [0x80618e8]");
            asm("fxch st0, st1");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags >= 0) {
                goto L15;
            }
            asm("fld dword [ebp-0x8]");
            asm("fnstcw word [ebp-0x12]");
            _v24 = _v22 & 0xffff;
            asm("fldcw word [ebp-0x14]");
            asm("fistp qword [ebp-0x20]");
            asm("fldcw word [ebp-0x12]");
            candidate = _v36;
            goto L11;
L12:
             *(table + 8) = next_prime(candidate);
            _t81 = table;
            __eflags =  *((intOrPtr*)(_t81 + 8)) - 536870911;
            if( *((intOrPtr*)(_t81 + 8)) > 536870911) {
                goto L15;
            }
            table->bucket = calloc( *(table + 8), 8);
            __eflags = table->bucket;
            if(table->bucket == 0) {
                goto L15;
            }
            table->bucket_limit =  &(table->bucket[ *(table + 8)]);
             *(table + 12) = 0;
             *(table + 16) = 0;
             *(table + 24) = hasher;
             *(table + 28) = comparator;
             *(table + 32) = data_freer;
            table->free_entry_list = 0;
            _v40 = table;
        }
        goto L16;
    }
    _v40 = 0;
    goto L16;
}

hash_clear(Hash_table* table)
{// addr = 0x08052BB8  --  defined in 'hash.c' at line 605
    struct hash_entry* bucket;   // _cfa_fffffff8
    struct hash_entry* cursor;   // _cfa_fffffff4
    struct hash_entry* next;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    bucket = table->bucket;
    while(table->bucket_limit > bucket) {
        if(bucket->data != 0) {
            goto L2;
        }
L10:
        bucket = bucket + 8;
        continue;
L2:
        cursor = bucket->next;
        while(cursor != 0) {
            if( *((intOrPtr*)(table + 32)) != 0) {
                 *__esp = cursor->data;
                 *((intOrPtr*)( *((intOrPtr*)(table + 32))))();
            }
            cursor->data = 0;
            next = cursor->next;
            cursor->next = table->free_entry_list;
            table->free_entry_list = cursor;
            cursor = next;
        }
        if( *((intOrPtr*)(table + 32)) != 0) {
             *__esp = bucket->data;
             *((intOrPtr*)( *((intOrPtr*)(table + 32))))();
        }
        bucket->data = 0;
        bucket->next = 0;
        goto L10;
    }
     *(table + 12) = 0;
     *(table + 16) = 0;
    return;
}

hash_free(Hash_table* table)
{// addr = 0x08052C86  --  defined in 'hash.c' at line 648
    struct hash_entry* bucket;   // _cfa_fffffff8
    struct hash_entry* cursor;   // _cfa_fffffff4
    struct hash_entry* next;   // _cfa_fffffff0
    _unknown_ __ebp;                       // r6

    if( *((intOrPtr*)(table + 32)) == 0 ||  *((intOrPtr*)(table + 16)) == 0) {
L9:
        bucket = table->bucket;
L14:
        while(table->bucket_limit > bucket) {
            goto L10;
        }
        cursor = table->free_entry_list;
        while(cursor != 0) {
            next = cursor->next;
            free(cursor);
            cursor = next;
        }
        free(table->bucket);
        free(table);
        return;
    } else {
        bucket = table->bucket;
        while(table->bucket_limit > bucket) {
            if(bucket->data == 0) {
L7:
                bucket = bucket + 8;
                continue;
            }
            cursor = bucket;
            while(cursor != 0) {
                 *__esp = cursor->data;
                 *((intOrPtr*)( *((intOrPtr*)(table + 32))))();
                cursor = cursor->next;
            }
            goto L7;
        }
        goto L9;
    }
L10:
    cursor = bucket->next;
    while(cursor != 0) {
        next = cursor->next;
        free(cursor);
        cursor = next;
    }
    bucket = bucket + 8;
    goto L14;
}

struct hash_entry* allocate_entry(Hash_table* table)
{// addr = 0x08052D72  --  defined in 'hash.c' at line 705
    struct hash_entry* new;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    if(table->free_entry_list == 0) {
        new = malloc(8);
    } else {
        new = table->free_entry_list;
        table->free_entry_list = new->next;
    }
    return new;
}

free_entry(Hash_table* table, struct hash_entry* entry)
{// addr = 0x08052DAD  --  defined in 'hash.c' at line 730
    _unknown_ __ebp;                       // r6

    entry->data = 0;
    entry->next = table->free_entry_list;
    table->free_entry_list = entry;
    return;
}

_Unknown_base* hash_find_entry(Hash_table* table, * entry, struct hash_entry** bucket_head, _Bool delete)
{// addr = 0x08052DD0  --  defined in 'hash.c' at line 745
    struct hash_entry* bucket;   // _cfa_fffffff4
    struct hash_entry* cursor;   // _cfa_fffffff0
    _Unknown_base* data;                   // _cfa_ffffffec
    struct hash_entry* next;   // _cfa_ffffffe8
    _Unknown_base* data;                   // _cfa_ffffffe4
    struct hash_entry* next;   // _cfa_ffffffe0
    signed int _v44;                       // _cfa_ffffffd4
    _Unknown_base* _v48;                   // _cfa_ffffffd0
    _Unknown_base* _v56;                   // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    signed int _t84;                       // _t84
    signed int _t95;                       // _t95
    signed int _t103;                      // _t103
    _unknown_ _t110;                       // _t110
    struct hash_entry* _t125;   // _t125

    _v44 = _a16 & 255;
    _v56 =  *(table + 8);
    _t84 = entry;
     *__esp = _t84;
     *((intOrPtr*)( *((intOrPtr*)(table + 24))))();
    bucket = table->bucket + (_t84 << 3);
    if(table->bucket_limit <= bucket) {
        abort();
    }
     *bucket_head = bucket;
    if(bucket->data != 0) {
        _v56 = bucket->data;
        _t95 = entry;
         *__esp = _t95;
         *((intOrPtr*)( *((intOrPtr*)(table + 28))))();
        if((_t95 & 255) == 0) {
            cursor = bucket;
L16:
            while(cursor->next != 0) {
                goto L11;
            }
            _v48 = 0;
            goto L18;
        }
        goto L5;
L11:
        _v56 = cursor->next->data;
        _t103 = entry;
         *__esp = _t103;
         *((intOrPtr*)( *((intOrPtr*)(table + 28))))();
        if((_t103 & 255) == 0) {
            cursor = cursor->next;
            goto L16;
        }
        data = cursor->next->data;
        if(_v44 != 0) {
            next = cursor->next;
            cursor->next = next->next;
            free_entry(table, next);
        }
        _v48 = data;
        goto L18;
    } else {
        _v48 = 0;
L18:
        return;
    }
L5:
    data = bucket->data;
    if(_v44 != 0) {
        if(bucket->next == 0) {
            bucket->data = 0;
        } else {
            next = bucket->next;
            _t125 = next;
            __ecx = bucket;
            __ecx->data = _t125->data;
            __ecx->next = _t125->next;
            free_entry(table, next);
        }
    }
    _v48 = data;
    goto L18;
}

_Bool hash_rehash(Hash_table* table, size_t candidate)
{// addr = 0x08052F2D  --  defined in 'hash.c' at line 819
    Hash_table* new_table;   // _cfa_fffffff4
    struct hash_entry* bucket;   // _cfa_fffffff0
    struct hash_entry* cursor;   // _cfa_ffffffec
    struct hash_entry* next;   // _cfa_ffffffe8
    _Unknown_base* data;                   // _cfa_ffffffe4
    struct hash_entry* new_bucket;   // _cfa_ffffffe0
    struct hash_entry* new_entry;   // _cfa_ffffffdc
    char _v41;                             // _cfa_ffffffd7
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    signed int _t130;                      // _t130
    struct hash_entry* _t151;   // _t151
    _unknown_ _t156;                       // _t156

    new_table = hash_initialize(candidate, table->tuning,  *(table + 24),  *(table + 28),  *(table + 32));
    if(new_table != 0) {
        new_table->free_entry_list = table->free_entry_list;
        bucket = table->bucket;
L18:
        while(table->bucket_limit > bucket) {
            goto L3;
        }
        free(table->bucket);
        table->bucket = new_table->bucket;
        table->bucket_limit = new_table->bucket_limit;
         *((intOrPtr*)(table + 8)) =  *((intOrPtr*)(new_table + 8));
         *((intOrPtr*)(table + 12)) =  *((intOrPtr*)(new_table + 12));
        table->free_entry_list = new_table->free_entry_list;
        free(new_table);
        _v41 = 1;
        goto L20;
    }
    _v41 = 0;
L20:
    return;
L3:
    if(bucket->data == 0) {
L17:
        bucket = bucket + 8;
        goto L18;
    }
    cursor = bucket;
    while(cursor != 0) {
        data = cursor->data;
        _v72 =  *((intOrPtr*)(new_table + 8));
        _t130 = data;
         *__esp = _t130;
         *((intOrPtr*)( *((intOrPtr*)(new_table + 24))))();
        new_bucket =  &(new_table->bucket[_t130]);
        if(new_table->bucket_limit <= new_bucket) {
            abort();
        }
        next = cursor->next;
        if(new_bucket->data == 0) {
            new_bucket->data = data;
             *((intOrPtr*)(new_table + 12)) =  *((intOrPtr*)(new_table + 12)) + 1;
            if(cursor != bucket) {
                free_entry(new_table, cursor);
            }
            goto L15;
        } else {
            if(cursor != bucket) {
L12:
                cursor->next = new_bucket->next;
                new_bucket->next = cursor;
                goto L15;
            }
            _t151 = new_table;
            allocate_entry(_t151);
            new_entry = _t151;
            if(new_entry != 0) {
                new_entry->data = data;
                new_entry->next = new_bucket->next;
                new_bucket->next = new_entry;
L15:
                cursor = next;
                continue;
            }
            _v41 = 0;
            goto L20;
        }
    }
    goto L17;
}

_Unknown_base* hash_insert(Hash_table* table, * entry)
{// addr = 0x08053109  --  defined in 'hash.c' at line 908
    float candidate;                       // _cfa_ffffffe8
    _Unknown_base* data;                   // _cfa_fffffff8
    struct hash_entry* bucket;   // _cfa_fffffff4
    struct hash_entry* new_entry;   // _cfa_fffffff0
    const Hash_tuning* tuning;   // _cfa_ffffffec
    signed short _v38;                     // _cfa_ffffffda
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    * _v60;                   // _cfa_ffffffc4
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v84;                        // _cfa_ffffffac
    _unknown_ _v88;                        // _cfa_ffffffa8
    _unknown_ _v92;                        // _cfa_ffffffa4
    _unknown_ __ebp;                       // r6
    _unknown_ _t110;                       // _t110
    _unknown_ _t111;                       // _t111
    _unknown_ _t117;                       // _t117
    _unknown_ _t120;                       // _t120
    _unknown_ _t121;                       // _t121
    _unknown_ _t130;                       // _t130
    _unknown_ _t131;                       // _t131
    signed int _t136;                      // _t136
    _unknown_ _t139;                       // _t139
    _unknown_ _t151;                       // _t151
    _unknown_ _t155;                       // _t155
    _unknown_ _t156;                       // _t156
    _unknown_ _t157;                       // _t157
    _unknown_ _t158;                       // _t158
    _unknown_ _t159;                       // _t159
    _unknown_ _t160;                       // _t160
    _unknown_ _t161;                       // _t161

    if(entry == 0) {
        abort();
    }
    data = hash_find_entry(table, entry,  &bucket, 0);
    if(data == 0) {
        __eflags = bucket->data;
        if(__eflags == 0) {
            bucket->data = entry;
             *((intOrPtr*)(table + 16)) =  *((intOrPtr*)(table + 16)) + 1;
             *((intOrPtr*)(table + 12)) =  *((intOrPtr*)(table + 12)) + 1;
            _push(0);
            _push( *((intOrPtr*)(table + 12)));
            asm("fild qword [esp]");
            asm("fld dword [eax+0x8]");
            _push(0);
            _push( *((intOrPtr*)(table + 8)));
            asm("fild qword [esp]");
            asm("fmulp st1, st0");
            asm("fxch st0, st1");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags <= 0) {
L17:
                _v60 = entry;
                goto L18;
            }
            goto L9;
        }
        goto L5;
L9:
        check_tuning(table);
        _push(0);
        _push( *((intOrPtr*)(table + 12)));
        asm("fild qword [esp]");
        asm("fld dword [eax+0x8]");
        _push(0);
        _push( *((intOrPtr*)(table + 8)));
        asm("fild qword [esp]");
        asm("fmulp st1, st0");
        asm("fxch st0, st1");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags <= 0) {
            goto L17;
        }
        tuning = table->tuning;
        __eflags = tuning->is_n_buckets & 0xff;
        if(__eflags == 0) {
            _push(0);
            _push( *((intOrPtr*)(table + 8)));
            asm("fild qword [esp]");
            asm("fld dword [eax+0xc]");
            asm("fmulp st1, st0");
            asm("fld dword [eax+0x8]");
            asm("fmulp st1, st0");
            asm("fstp dword [ebp-0x34]");
        } else {
            _push(0);
            _push( *((intOrPtr*)(table + 8)));
            asm("fild qword [esp]");
            asm("fld dword [eax+0xc]");
            asm("fmulp st1, st0");
            asm("fstp dword [ebp-0x34]");
        }
        asm("fld dword [ebp-0x34]");
        asm("fstp dword [ebp-0x14]");
        asm("fld dword [ebp-0x14]");
        asm("fld dword [0x80618e8]");
        asm("fxch st0, st1");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(__eflags < 0) {
            asm("fld dword [ebp-0x14]");
            asm("fnstcw word [ebp-0x22]");
            _v40 = _v38 & 0xffff;
            asm("fldcw word [ebp-0x24]");
            asm("fistp qword [ebp-0x30]");
            asm("fldcw word [ebp-0x22]");
            _t136 = hash_rehash(table, _v52) ^ 1;
            __eflags = _t136 & 255;
            if((_t136 & 255) != 0) {
                entry = 0;
            }
            goto L17;
        }
        _v60 = 0;
        goto L18;
    }
    _v60 = data;
L18:
    return _v60;
L5:
    new_entry = allocate_entry(table);
    __eflags = new_entry;
    if(new_entry != 0) {
        new_entry->data = entry;
        new_entry->next = bucket->next;
        bucket->next = new_entry;
         *((intOrPtr*)(table + 16)) =  *((intOrPtr*)(table + 16)) + 1;
        _v60 = entry;
    } else {
        _v60 = 0;
    }
    goto L18;
}

_Unknown_base* hash_delete(Hash_table* table, * entry)
{// addr = 0x08053324  --  defined in 'hash.c' at line 983
    _Unknown_base* data;                   // _cfa_fffffff8
    struct hash_entry* bucket;   // _cfa_fffffff4
    const Hash_tuning* tuning;   // _cfa_fffffff0
    size_t candidate;   // _cfa_ffffffec
    signed int _v22;                       // _cfa_ffffffea
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _v32;                        // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _Unknown_base* _v44;                   // _cfa_ffffffd4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ __ebp;                       // r6
    _unknown_ _t96;                        // _t96
    _unknown_ _t97;                        // _t97
    _unknown_ _t101;                       // _t101
    _unknown_ _t104;                       // _t104
    _unknown_ _t105;                       // _t105
    signed int _t111;                      // _t111
    _unknown_ _t114;                       // _t114
    _unknown_ _t115;                       // _t115
    _unknown_ _t121;                       // _t121
    _unknown_ _t124;                       // _t124
    _unknown_ _t129;                       // _t129
    _unknown_ _t130;                       // _t130
    _unknown_ _t131;                       // _t131
    _unknown_ _t132;                       // _t132
    _unknown_ _t133;                       // _t133
    _unknown_ _t134;                       // _t134
    _unknown_ _t135;                       // _t135
    _unknown_ _t136;                       // _t136

    data = hash_find_entry(table, entry,  &bucket, 1);
    __eflags = data;
    if(data != 0) {
         *((intOrPtr*)(table + 16)) =  *((intOrPtr*)(table + 16)) - 1;
        __eflags = bucket->data;
        if(__eflags == 0) {
             *((intOrPtr*)(table + 12)) =  *((intOrPtr*)(table + 12)) - 1;
            _push(0);
            _push( *((intOrPtr*)(table + 12)));
            asm("fild qword [esp]");
            asm("fld dword [eax]");
            _push(0);
            _push( *((intOrPtr*)(table + 8)));
            asm("fild qword [esp]");
            asm("fmulp st1, st0");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(__eflags > 0) {
                check_tuning(table);
                _push(0);
                _push( *((intOrPtr*)(table + 12)));
                asm("fild qword [esp]");
                asm("fld dword [eax]");
                _push(0);
                _push( *((intOrPtr*)(table + 8)));
                asm("fild qword [esp]");
                asm("fmulp st1, st0");
                asm("fucompp ");
                asm("fnstsw ax");
                asm("sahf ");
                if(__eflags > 0) {
                    tuning = table->tuning;
                    _t111 = tuning->is_n_buckets & 255;
                    __eflags = _t111 & 255;
                    if((_t111 & 255) == 0) {
                        _push(0);
                        _push( *((intOrPtr*)(table + 8)));
                        asm("fild qword [esp]");
                        asm("fld dword [eax+0x4]");
                        asm("fmulp st1, st0");
                        asm("fld dword [eax+0x8]");
                        asm("fmulp st1, st0");
                        asm("fnstcw word [ebp-0x12]");
                        _v24 = _v22 & 0xffff;
                        asm("fldcw word [ebp-0x14]");
                        asm("fistp qword [ebp-0x20]");
                        asm("fldcw word [ebp-0x12]");
                        _v40 = _v36;
                    } else {
                        _push(0);
                        _push( *((intOrPtr*)(table + 8)));
                        asm("fild qword [esp]");
                        asm("fld dword [eax+0x4]");
                        asm("fmulp st1, st0");
                        asm("fnstcw word [ebp-0x12]");
                        _v24 = _v22 & 0xffff;
                        asm("fldcw word [ebp-0x14]");
                        asm("fistp qword [ebp-0x20]");
                        asm("fldcw word [ebp-0x12]");
                        _v40 = _v36;
                    }
                    candidate = _v40;
                    hash_rehash(table, candidate);
                }
            }
        }
        _v44 = data;
    } else {
        _v44 = 0;
    }
    return _v44;
}

long double adjust_value(int inexact_style, long double value)
{// addr = 0x080534C8  --  defined in 'human.c' at line 56
    signed int _v16;                       // _cfa_fffffff0
    uintmax_t u;     // _cfa_ffffffec
    signed int _v30;                       // _cfa_ffffffe2
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    long double _v92;                      // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    _unknown_ _v108;                       // _cfa_ffffff94
    _unknown_ __ebp;                       // r6
    long double _t49;                      // _t49
    signed int _t52;                       // _t52
    signed int _t53;                       // _t53
    signed int _t64;                       // _t64
    signed int _t67;                       // _t67
    _unknown_ _t68;                        // _t68

    _t68 = inexact_style - 1;
    if(_t68 != 0) {
        asm("fld tword [ebp+0xc]");
        asm("fld tword [0x8061970]");
        asm("fucompp ");
        asm("fnstsw ax");
        asm("sahf ");
        if(_t68 <= 0) {
        } else {
            asm("fld tword [ebp+0xc]");
            asm("fld tword [0x8061980]");
            asm("fxch st0, st1");
            asm("fucompp ");
            asm("fnstsw ax");
            asm("sahf ");
            if(_t68 >= 0) {
                asm("fld tword [ebp+0xc]");
                asm("fld tword [0x8061980]");
                asm("fsubp st1, st0");
                asm("fnstcw word [ebp-0x1a]");
                _v32 = _v30 & 0xffff;
                asm("fldcw word [ebp-0x1c]");
                asm("fistp qword [ebp-0x10]");
                asm("fldcw word [ebp-0x1a]");
                u = u;
                _v16 = _v16 ^ -2147483648;
            } else {
                asm("fld tword [ebp+0xc]");
                asm("fnstcw word [ebp-0x1a]");
                _v32 = _v30 & 0xffff;
                asm("fldcw word [ebp-0x1c]");
                asm("fistp qword [ebp-0x10]");
                asm("fldcw word [ebp-0x1a]");
            }
            _t52 = u;
            _t64 = _v16;
            u = _t52;
            _v16 = _t64;
            if(inexact_style != 0) {
L10:
                _v48 = 0;
            } else {
                asm("fild qword [ebp-0x10]");
                asm("fstp tword [ebp-0x28]");
                if(_v16 < 0) {
                    asm("fld tword [0x8061990]");
                    asm("fld tword [ebp-0x28]");
                    asm("faddp st1, st0");
                    asm("fstp tword [ebp-0x28]");
                }
                asm("fld tword [ebp+0xc]");
                asm("fld tword [ebp-0x28]");
                asm("fucompp ");
                asm("fnstsw ax");
                asm("sahf ");
                if((((_t52 | _t64) ^ 1) & 255) != 0) {
                    goto L10;
                } else {
                    _v48 = 1;
                }
            }
            _t53 = _v48;
            _v100 = _t53;
            _v96 = _t53 >> 31;
            _t67 = _v96;
            asm("adc edx, [ebp-0xc]");
            _push(_t67);
            _push(_v100 + u);
            asm("fild qword [esp]");
            asm("fstp tword [ebp-0x48]");
            if(_t67 < 0) {
                asm("fld tword [0x8061990]");
                asm("fld tword [ebp-0x48]");
                asm("faddp st1, st0");
                asm("fstp tword [ebp-0x48]");
            }
            asm("fld tword [ebp-0x48]");
            asm("fstp tword [ebp+0xc]");
        }
    }
    _t49 = value;
    _v92 = _t49;
    _v88 = _a12;
    _v84 = _a16;
    asm("fld tword [ebp-0x58]");
    return _t49;
}

char* group_number(char* number, size_t numberlen, const char* grouping, const char* thousands_sep)
{// addr = 0x08053603  --  defined in 'human.c' at line 82
    char* d;                               // r5+4294967216
    intOrPtr _v8;                          // _cfa_fffffff8
    char[40] buf;                          // _cfa_ffffffcf
    unsigned char g;                       // _cfa_ffffffce
    size_t grouplen;    // _cfa_ffffffc8
    size_t thousands_seplen;   // _cfa_ffffffc4
    size_t i;           // _cfa_ffffffc0
    void* _v72;           // _cfa_ffffffb8
    signed char* _v76;                     // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    void* _v84;           // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8
    _unknown_ _v100;                       // _cfa_ffffff9c
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ __ebp;                       // r6
    _unknown_ _t66;                        // _t66
    _unknown_ _t73;                        // _t73
    _unknown_ _t85;                        // _t85
    _unknown_ _t91;                        // _t91
    char* _t92;                            // _t92
    _unknown_ _t100;                       // _t100
    unsigned int _t104;                    // _t104

    _v72 = _a4;
    _v76 = _a12;
    _v80 = _a16;
    _v8 =  *gs:0x14];
    grouplen = -1;
    thousands_seplen = strlen(_v80);
    i = numberlen;
    memcpy( &buf, _v72, numberlen);
    _v84 = _v72 + numberlen;
    while(1) {
        g =  *_v76 & 0xff;
        if(g != 0) {
            if(g > 126) {
                _v88 = i;
            } else {
                _v88 = g & 255;
            }
            grouplen = _v88;
            _v76 =  &(_v76[1]);
        }
        if(i < grouplen) {
            grouplen = i;
        }
        _v84 =  &(_v84[ ~grouplen]);
        i = i - grouplen;
        memcpy(_v84,  &buf + i, grouplen);
        _t104 = i;
        if(_t104 == 0) {
            break;
        }
        _v84 =  &(_v84[ ~thousands_seplen]);
        memcpy(_v84, _v80, thousands_seplen);
    }
    _t92 = _v84;
    if(_t104 != 0) {
        __stack_chk_fail();
        return _t92;
    }
    return _t92;
}

char* human_readable(uintmax_t n, char* buf, int opts, uintmax_t from_block_size, uintmax_t to_block_size)
{// addr = 0x0805370F  --  defined in 'human.c' at line 156
    long double dto_block_size;            // _cfa_ffffff54
    int inexact_style;                     // _cfa_ffffffe0
    unsigned int base;                     // _cfa_ffffffdc
    int tenths;                            // _cfa_ffffffd8
    int exponent;                          // _cfa_ffffffd4
    int exponent_max;                      // _cfa_ffffffd0
    char* p;                               // _cfa_ffffffcc
    char* psuffix;                         // _cfa_ffffffc8
    const char* integerlim;   // _cfa_ffffffc4
    int rounding;                          // _cfa_ffffffc0
    const char* decimal_point;   // _cfa_ffffffbc
    size_t decimal_pointlen;   // _cfa_ffffffb8
    const char* grouping;   // _cfa_ffffffb4
    const char* thousands_sep;   // _cfa_ffffffb0
    const struct lconv* l;   // _cfa_ffffffac
    size_t pointlen;    // _cfa_ffffffa8
    size_t buflen;      // _cfa_ffffffa4
    size_t nonintegerlen;   // _cfa_ffffffa0
    unsigned int r10;                      // _cfa_ffffff9c
    unsigned int r2;                       // _cfa_ffffff98
    int digit;                             // _cfa_ffffff94
    signed int _v112;                      // _cfa_ffffff90
    uintmax_t amt;   // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    uintmax_t multiplier;   // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    uintmax_t divisor;   // _cfa_ffffff7c
    intOrPtr _v136;                        // _cfa_ffffff78
    uintmax_t r10;   // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    uintmax_t r2;    // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    uintmax_t power;   // _cfa_ffffff64
    signed int _v180;                      // _cfa_ffffff4c
    long long unsigned int _v184;          // _cfa_ffffff48
    long double damt;                      // _cfa_ffffff44
    intOrPtr _v196;                        // _cfa_ffffff3c
    intOrPtr _v200;                        // _cfa_ffffff38
    long double e;                         // _cfa_ffffff34
    signed int _v208;                      // _cfa_ffffff30
    signed int _v212;                      // _cfa_ffffff2c
    signed int _v216;                      // _cfa_ffffff28
    long long unsigned int _v220;          // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    long long unsigned int _v228;          // _cfa_ffffff1c
    signed char _v229;                     // _cfa_ffffff1b
    signed char _v236;                     // _cfa_ffffff14
    signed int _v237;                      // _cfa_ffffff13
    _unknown_ _v244;                       // _cfa_ffffff0c
    _unknown_ _v245;                       // _cfa_ffffff0b
    int _v256;                             // _cfa_ffffff00
    unsigned int _v260;                    // _cfa_fffffefc
    int _v264;                             // _cfa_fffffef8
    signed int _v268;                      // _cfa_fffffef4
    int _v272;                             // _cfa_fffffef0
    unsigned int _v276;                    // _cfa_fffffeec
    signed int _v320;                      // _cfa_fffffec0
    signed int _v324;                      // _cfa_fffffebc
    unsigned int _v328;                    // _cfa_fffffeb8
    signed int _v336;                      // _cfa_fffffeb0
    long long unsigned int _v340;          // _cfa_fffffeac
    signed int _v344;                      // _cfa_fffffea8
    long long unsigned int _v348;          // _cfa_fffffea4
    signed int _v352;                      // _cfa_fffffea0
    long long unsigned int _v356;          // _cfa_fffffe9c
    signed int _v392;                      // _cfa_fffffe78
    long long unsigned int _v396;          // _cfa_fffffe74
    signed int _v400;                      // _cfa_fffffe70
    signed int _v432;                      // _cfa_fffffe50
    long long unsigned int _v436;          // _cfa_fffffe4c
    signed int _v440;                      // _cfa_fffffe48
    char _v444;                            // _cfa_fffffe44
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t541;                       // _t541
    _unknown_ _t569;                       // _t569
    signed int _t571;                      // _t571
    _unknown_ _t576;                       // _t576
    _unknown_ _t588;                       // _t588
    _unknown_ _t597;                       // _t597
    signed int _t626;                      // _t626
    long long unsigned int _t627;          // _t627
    _unknown_ _t645;                       // _t645
    signed int _t655;                      // _t655
    long long unsigned int _t656;          // _t656
    _unknown_ _t658;                       // _t658
    _unknown_ _t695;                       // _t695
    _unknown_ _t712;                       // _t712
    _unknown_ _t734;                       // _t734
    signed int _t762;                      // _t762
    long long unsigned int _t763;          // _t763
    signed int _t777;                      // _t777
    _unknown_ _t779;                       // _t779
    _unknown_ _t784;                       // _t784
    _unknown_ _t788;                       // _t788
    signed int _t799;                      // _t799
    _unknown_ _t807;                       // _t807
    _unknown_ _t816;                       // _t816
    _unknown_ _t829;                       // _t829
    _unknown_ _t830;                       // _t830
    _unknown_ _t831;                       // _t831
    _unknown_ _t837;                       // _t837
    signed int _t839;                      // _t839
    signed int _t843;                      // _t843
    signed int _t845;                      // _t845
    signed int _t846;                      // _t846
    intOrPtr _t848;                        // _t848
    signed int _t849;                      // _t849
    signed int _t851;                      // _t851
    signed int _t859;                      // _t859
    _unknown_ _t861;                       // _t861
    _unknown_ _t865;                       // _t865
    _unknown_ _t867;                       // _t867
    _unknown_ _t869;                       // _t869
    _unknown_ _t872;                       // _t872
    _unknown_ _t875;                       // _t875
    signed int _t876;                      // _t876
    _unknown_ _t877;                       // _t877
    _unknown_ _t878;                       // _t878
    signed int _t884;                      // _t884
    signed int _t886;                      // _t886
    signed int _t888;                      // _t888
    signed int _t890;                      // _t890
    _unknown_ _t893;                       // _t893

    _v212 = _a4;
    _v208 = _a8;
    _v220 = _a20;
    _v216 = _a24;
    _v228 = _a28;
    _v224 = _a32;
    inexact_style = opts & 3;
    if((opts & 32) == 0) {
        _v328 = 1000;
    } else {
        _v328 = 1024;
    }
    base = _v328;
    exponent = -1;
    exponent_max = 8;
    decimal_point = 134617337;
    decimal_pointlen = 1;
    grouping = 134617339;
    thousands_sep = 134617339;
    l = localeconv();
    pointlen = strlen(l->decimal_point);
    if(pointlen != 0) {
        if(pointlen <= 16) {
            decimal_point = l->decimal_point;
            decimal_pointlen = pointlen;
        }
    }
    grouping = l->grouping;
    if(strlen(l->thousands_sep) <= 16) {
        thousands_sep = l->thousands_sep;
    }
    psuffix =  &(buf[0x288]);
    p = psuffix;
    _v340 = _v228;
    _v336 = _v224;
    if(_v336 > _v216 || _v336 >= _v216 && _v340 > _v220) {
        if((_v220 | _v216) == 0) {
            goto L27;
        }
    } else {
        _t884 = _v224;
        if((__umoddi3(_v220, _v216, _v228, _t884) | _t884) != 0) {
L27:
            asm("fild qword [ebp+0xffffff20]");
            asm("fstp tword [ebp+0xfffffe88]");
            if(_v224 < 0) {
                asm("fld tword [0x8061990]");
                asm("fld tword [ebp+0xfffffe88]");
                asm("faddp st1, st0");
                asm("fstp tword [ebp+0xfffffe88]");
            }
            asm("fld tword [ebp+0xfffffe88]");
            asm("fstp tword [ebp+0xffffff58]");
            asm("fild qword [ebp+0xffffff30]");
            asm("fstp tword [ebp+0xfffffec8]");
            if(_v208 < 0) {
                asm("fld tword [0x8061990]");
                asm("fld tword [ebp+0xfffffec8]");
                asm("faddp st1, st0");
                asm("fstp tword [ebp+0xfffffec8]");
            }
            asm("fild qword [ebp+0xffffff28]");
            asm("fstp tword [ebp+0xfffffed8]");
            if(_v216 < 0) {
                asm("fld tword [0x8061990]");
                asm("fld tword [ebp+0xfffffed8]");
                asm("faddp st1, st0");
                asm("fstp tword [ebp+0xfffffed8]");
            }
            asm("fld tword [ebp+0xffffff58]");
            asm("fld tword [ebp+0xfffffed8]");
            asm("fdivrp st1, st0");
            asm("fld tword [ebp+0xfffffec8]");
            asm("fmulp st1, st0");
            asm("fstp tword [ebp+0xffffff48]");
            if((opts & 16) != 0) {
                e = 0;
                _v200 = -2147483648;
                _v196 = 16383;
                exponent = 0;
                while(1) {
                    _push(0);
                    _push(base);
                    asm("fild qword [esp]");
                    __esp =  ?_? ( &_v444);
                    asm("fld tword [ebp+0xffffff38]");
                    asm("fmulp st1, st0");
                    asm("fstp tword [ebp+0xffffff38]");
                    exponent = exponent + 1;
                    _t571 = base;
                    _push(0);
                    _push(_t571);
                    asm("fild qword [esp]");
                    __esp =  &_v444 + 8;
                    asm("fld tword [ebp+0xffffff38]");
                    asm("fmulp st1, st0");
                    asm("fld tword [ebp+0xffffff48]");
                    asm("fucompp ");
                    asm("fnstsw ax");
                    if(((_t571 ^ 1) & 255) != 0 || exponent >= exponent_max) {
                        asm("fld tword [ebp+0xffffff48]");
                        asm("fld tword [ebp+0xffffff38]");
                        asm("fdivp st1, st0");
                        asm("fstp tword [ebp+0xffffff48]");
                        _v440 = damt;
                        _v436 = _v184;
                        _v432 = _v180;
                         *__esp = inexact_style;
                        adjust_value();
                        asm("fstp tword [esp+0x8]");
                        sprintf(buf, 134617346);
                        buflen = strlen(buf);
                        nonintegerlen = decimal_pointlen + 1;
                        if((opts & 0x20) + nonintegerlen + 1 < buflen || (opts & 8) != 0 && ( *(buflen - 1 + buf) & 0xff) == 48) {
                            asm("fld tword [ebp+0xffffff48]");
                            asm("fld tword [0x80619a0]");
                            asm("fmulp st1, st0");
                            asm("fstp tword [esp+0x4]");
                             *__esp = inexact_style;
                            adjust_value();
                            asm("fld tword [0x80619a0]");
                            asm("fdivp st1, st0");
                            asm("fstp tword [esp+0x8]");
                            sprintf(buf, 134617340);
                            buflen = strlen(buf);
                            nonintegerlen = 0;
                        }
                        goto L42;
                    } else {
                        continue;
                    }
                }
            } else {
                _v440 = damt;
                _v436 = _v184;
                _v432 = _v180;
                 *__esp = inexact_style;
                adjust_value();
                asm("fstp tword [esp+0x8]");
                sprintf(buf, 134617340);
                buflen = strlen(buf);
                nonintegerlen = 0;
            }
L42:
            p =  &(psuffix[ ~buflen]);
            memmove(p, buf, buflen);
            integerlim = buflen - nonintegerlen + p;
            goto L92;
        }
        _v436 = _v228;
        _v432 = _v224;
        _t886 = _v216;
         *__esp = _v220;
        _v440 = _t886;
        multiplier = __udivdi3();
        _v120 = _t886;
        _t762 = multiplier;
        _t763 = _t762 * _v212;
        _t888 = _v208 * multiplier + _v120 * _v212 + (_t762 * _v212 >> 32);
        amt = _t763;
        _v112 = _t888;
        amt = _t763;
        _v112 = _t888;
        _v436 = multiplier;
        _v432 = _v120;
        _t890 = _v112;
         *__esp = amt;
        _v440 = _t890;
        if((__udivdi3() ^ _v212 | _t890 ^ _v208) != 0) {
            goto L27;
        } else {
            tenths = 0;
            rounding = 0;
        }
L43:
        if((opts & 16) == 0) {
L76:
            if(inexact_style != 1) {
                if(inexact_style != 0 || tenths + rounding <= 0) {
                    _v236 = 0;
                } else {
                    _v236 = 1;
                }
                _v237 = _v236 & 0xff;
            } else {
L77:
                asm("adc edx, edi");
                _v237 = (((amt & 1) + rounding | _v112 & 0) & 0xff) + tenths - 5 > 0;
            }
            if(_v237 != 0) {
                amt = amt + 1;
                asm("adc dword [ebp-0x6c], 0x0");
                if((opts & 16) != 0 && (base ^ amt | 0 ^ _v112) == 0 && exponent < exponent_max) {
                    exponent = exponent + 1;
                    if((opts & 8) == 0) {
                        p = p - 1;
                         *p = 48;
                        p =  &(p[ ~decimal_pointlen]);
                        memcpy(p, decimal_point, decimal_pointlen);
                    }
                    amt = 1;
                    _v112 = 0;
                }
            }
            integerlim = p;
            while(1) {
                digit = __umoddi3(amt, _v112, 10, 0);
                p = p - 1;
                 *p = digit + 48 & 255;
                _t859 = _v112;
                amt = __udivdi3(amt, _t859, 10, 0);
                _v112 = _t859;
                if((_v112 | amt) == 0) {
                    break;
                }
            }
L92:
            if((opts & 4) != 0) {
                p = group_number(p, integerlim - p, grouping, thousands_sep);
            }
            if((opts & 128) == 0) {
L116:
                 *psuffix = 0;
                return p;
            } else {
                if(exponent >= 0) {
L102:
                    if((opts & 256 | exponent) != 0 && (opts & 64) != 0) {
                         *psuffix = 32;
                        psuffix =  &(psuffix[1]);
                    }
                    if(exponent != 0) {
                        if((opts & 32) != 0 || exponent != 1) {
                            _v229 =  *( &power_letter + exponent) & 0xff;
                        } else {
                            _v229 = 107;
                        }
                         *psuffix = _v229 & 0xff;
                        psuffix =  &(psuffix[1]);
                    }
                    if((opts & 256) != 0) {
                        if((opts & 32) != 0 && exponent != 0) {
                             *psuffix = 105;
                            psuffix =  &(psuffix[1]);
                        }
                         *psuffix = 66;
                        psuffix =  &(psuffix[1]);
                    }
                    goto L116;
                }
                exponent = 0;
                power = 1;
                _v152 = 0;
                while(1) {
                    _v396 = power;
                    _v392 = _v152;
                    if(_v392 >= _v224 && (_v392 > _v224 || _v396 >= _v228)) {
                        break;
                    }
                    exponent = exponent + 1;
                    if(exponent == exponent_max) {
                        goto L102;
                    }
                    _t626 = base;
                    _t627 = _t626 * power;
                    _t839 = _v152 * _t626 + power * 0 + (_t626 * power >> 32);
                    power = _t627;
                    _v152 = _t839;
                    power = _t627;
                    _v152 = _t839;
                }
                goto L102;
            }
        }
        exponent = 0;
        _v276 = base;
        _v272 = 0;
        if(_v272 > _v112 || _v272 >= _v112 && _v276 > amt) {
        } else {
            goto L47;
            do {
                rounding = _v268;
                exponent = exponent + 1;
                _v260 = base;
                _v256 = 0;
                if(_v256 > _v112 || _v256 >= _v112 && _v260 > amt || exponent >= exponent_max) {
                    if(_v112 <= 0 && (_v112 < 0 || amt <= 9)) {
                        if(_v112 <= 0 && (_v112 < 0 || amt <= 9) && (tenths != 0 || (opts & 8) == 0)) {
                            p = p - 1;
                             *p = tenths + 48 & 255;
                            p =  &(p[ ~decimal_pointlen]);
                            memcpy(p, decimal_point, decimal_pointlen);
                            rounding = 0;
                            tenths = rounding;
                        }
                    }
                    goto L76;
                } else {
L47:
                    r10 = __umoddi3(amt, _v112, base, 0) * 10 + tenths;
                    _v400 = r10;
                    r2 = _v400 % base + _v400 % base + (rounding >> 1);
                    _v436 = base;
                    _v432 = 0;
                    _t876 = _v112;
                     *__esp = amt;
                    _v440 = _t876;
                    amt = __udivdi3();
                    _v112 = _t876;
                    tenths = r10 / base;
                    if(r2 >= base) {
                        if(rounding + r2 <= base) {
                            _v264 = 2;
                        } else {
                            _v264 = 3;
                        }
                        _v268 = _v264;
                    } else {
                        _v268 = rounding + r2 & 0xff;
                    }
                    continue;
                }
                goto L77;
            } while();
        }
        goto L76;
    }
    _t843 = _v216;
    if((__umoddi3(_v228, _v224, _v220, _t843) | _t843) != 0) {
        goto L27;
    }
    _v436 = _v220;
    _v432 = _v216;
    _t845 = _v224;
     *__esp = _v228;
    _v440 = _t845;
    divisor = __udivdi3();
    _v128 = _t845;
    _t799 = _v212;
    _t777 = _v208;
    _t846 = _v128;
    _t655 = __umoddi3(_t799, _t777, divisor, _t846);
    _t656 = _t655 * 10;
    _t848 = _t799 * _t846 + _t777 * _t655 + (_t655 * 10 >> 32);
    r10 = _t656;
    _v136 = _t848;
    r10 = _t656;
    _v136 = _t848;
    _t849 = _v128;
    _t658 = __umoddi3(r10, _v136, divisor, _t849);
    asm("shld edx, eax, 0x1");
    r2 = _t658 + _t658;
    _v144 = _t849;
    _v436 = divisor;
    _v432 = _v128;
    _t851 = _v208;
     *__esp = _v212;
    _v440 = _t851;
    amt = __udivdi3();
    _v112 = _t851;
    tenths = __udivdi3(r10, _v136, divisor, _v128);
    _v348 = r2;
    _v344 = _v144;
    if(_v344 > _v128) {
L20:
        _v356 = divisor;
        _v352 = _v128;
        if(_v352 > _v144) {
L24:
            _v320 = 2;
            goto L25;
        }
        goto L21;
L25:
        _v324 = _v320;
        goto L26;
    }
    if(_v344 < _v128 || _v348 < divisor) {
        _v324 = (r2 | _v144) & 0xff;
L26:
        rounding = _v324;
        goto L43;
    } else {
        goto L20;
    }
    goto L27;
L21:
    if(_v352 < _v144 || _v356 < r2) {
        _v320 = 3;
        goto L25;
    } else {
        goto L24;
    }
    goto L26;
}

uintmax_t default_block_size()
{// addr = 0x08054394  --  defined in 'human.c' at line 407
    intOrPtr _v8;                          // _cfa_fffffff8
    long long unsigned int _v12;           // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7

    if(getenv("POSIXLY_CORRECT") == 0) {
        _v12 = 1024;
        _v8 = 0;
    } else {
        _v12 = 512;
        _v8 = 0;
    }
    return _v12;
}

strtol_error humblock(const char* spec, uintmax_t* block_size, int* options)
{// addr = 0x080543D0  --  defined in 'human.c' at line 413
    int i;                                 // _cfa_fffffff8
    int opts;                              // _cfa_fffffff4
    char* ptr;                             // _cfa_fffffff0
    strtol_error e;   // _cfa_ffffffec
    union strtol_error _v24;   // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t70;                        // _t70
    uintmax_t* _t100;   // _t100
    long long unsigned int _t103;          // _t103
    long long unsigned int _t104;          // _t104

    _t104 = __edx;
    opts = 0;
    if(spec != 0) {
L4:
        if(( *spec & 0xff) == 39) {
            opts = opts | 4;
            spec =  &(spec[1]);
        }
        i = argmatch(spec,  &block_size_args,  &block_size_opts, 4);
        if(i >= 0) {
            e = xstrtoumax(spec,  &ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
            if(e == 0) {
                while(( *spec & 0xff) <= 47 || ( *spec & 0xff) > 57) {
                    if(spec != ptr) {
                        spec =  &(spec[1]);
                        continue;
                    }
                    opts = opts | 128;
                    if(( *(ptr - 1) & 0xff) == 66) {
                        opts = opts | 256;
                    }
                    if(( *(ptr - 1) & 0xff) != 66 || ( *(ptr - 2) & 0xff) == 105) {
                        opts = opts | 32;
                    }
                    goto L19;
                }
                goto L19;
            }
            goto L9;
        }
        opts = opts | ( &block_size_opts)[i];
        _t100 = block_size;
         *_t100 = 1;
        _t100[0] = 0;
L19:
         *options = opts;
        _v24 = 0;
L20:
        return _v24;
L9:
         *options = 0;
        _v24 = e;
        goto L20;
    }
    spec = getenv("BLOCK_SIZE");
    if(spec != 0) {
        goto L4;
    }
    spec = getenv("BLOCKSIZE");
    if(spec != 0) {
        goto L4;
    } else {
        _t103 = default_block_size();
        __ecx = block_size;
         *__ecx = _t103;
        (__ecx)[0] = _t104;
    }
    goto L19;
}

union strtol_error human_options(const char* spec, int* opts, uintmax_t* block_size)
{// addr = 0x08054532  --  defined in 'human.c' at line 463
    strtol_error e;   // _cfa_fffffff8
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    uintmax_t* _t17;   // _t17
    long long unsigned int _t21;           // _t21

    e = humblock(spec, block_size, opts);
    _t17 = block_size;
    __edx = _t17[0];
    if(( *_t17 | __edx) == 0) {
        _t21 = default_block_size();
        __ecx = block_size;
         *__ecx = _t21;
        (__ecx)[0] = __edx;
        e = 4;
    }
    return e;
}

char* getuser(uid_t uid)
{// addr = 0x0805457C  --  defined in 'idcache.c' at line 69
    struct userid* tail;   // _cfa_fffffff8
    struct userid* match;   // _cfa_fffffff4
    struct passwd* pwent;   // _cfa_fffffff0
    const char* name;   // _cfa_ffffffec
    char** _v24;                           // _cfa_ffffffe8
    char* _v28;                            // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct passwd* _t49;   // _t49
    _unknown_ _t58;                        // _t58

    match = 0;
    tail = user_alist;
    while(tail != 0) {
        if(tail->id != uid) {
            tail = tail->next;
            continue;
        }
        match = tail;
        break;
    }
    if(match == 0) {
        _t49 = uid;
         *__esp = _t49;
        getpwuid();
        pwent = _t49;
        if(pwent == 0) {
            _v28 = 134617516;
        } else {
            _v28 = pwent->pw_name;
        }
        name = _v28;
        match = xmalloc(strlen(name) + 9);
        match->id = uid;
        strcpy( &(match->name), name);
        match->next = user_alist;
        user_alist = match;
    }
    if((match->name & 0xff) == 0) {
        _v24 = 0;
    } else {
        _v24 =  &(match->name);
    }
    return _v24;
}

uid_t* getuidbyname(const char* user)
{// addr = 0x08054651  --  defined in 'idcache.c' at line 105
    struct userid* tail;   // _cfa_fffffff8
    struct passwd* pwent;   // _cfa_fffffff4
    struct userid* _v24;   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct passwd* _t70;   // _t70
    _unknown_ _t77;                        // _t77

    tail = user_alist;
    while(tail != 0) {
        if((tail->name & 0xff) != ( *user & 0xff) || strcmp( &(tail->name), user) != 0) {
            tail = tail->next;
            continue;
        } else {
            _v24 = tail;
        }
L15:
        return _v24;
    }
    tail = nouser_alist;
    while(tail != 0) {
        if((tail->name & 0xff) != ( *user & 0xff) || strcmp( &(tail->name), user) != 0) {
            tail = tail->next;
            continue;
        }
        _v24 = 0;
        goto L15;
    }
    _t70 = user;
     *__esp = _t70;
    getpwnam();
    pwent = _t70;
    tail = xmalloc(strlen(user) + 9);
    strcpy( &(tail->name), user);
    if(pwent == 0) {
        tail->next = nouser_alist;
        nouser_alist = tail;
        _v24 = 0;
    } else {
        tail->id =  *(pwent + 8);
        tail->next = user_alist;
        user_alist = tail;
        _v24 = tail;
    }
    goto L15;
}

char* getgroup(gid_t gid)
{// addr = 0x0805477C  --  defined in 'idcache.c' at line 151
    struct userid* tail;   // _cfa_fffffff8
    struct userid* match;   // _cfa_fffffff4
    struct group* grent;   // _cfa_fffffff0
    const char* name;   // _cfa_ffffffec
    char** _v24;                           // _cfa_ffffffe8
    char* _v28;                            // _cfa_ffffffe4
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct group* _t49;   // _t49
    _unknown_ _t58;                        // _t58

    match = 0;
    tail = group_alist;
    while(tail != 0) {
        if(tail->id != gid) {
            tail = tail->next;
            continue;
        }
        match = tail;
        break;
    }
    if(match == 0) {
        _t49 = gid;
         *__esp = _t49;
        getgrgid();
        grent = _t49;
        if(grent == 0) {
            _v28 = 134617516;
        } else {
            _v28 = grent->gr_name;
        }
        name = _v28;
        match = xmalloc(strlen(name) + 9);
        match->id = gid;
        strcpy( &(match->name), name);
        match->next = group_alist;
        group_alist = match;
    }
    if((match->name & 0xff) == 0) {
        _v24 = 0;
    } else {
        _v24 =  &(match->name);
    }
    return _v24;
}

gid_t* getgidbyname(const char* group)
{// addr = 0x08054851  --  defined in 'idcache.c' at line 187
    struct userid* tail;   // _cfa_fffffff8
    struct group* grent;   // _cfa_fffffff4
    struct userid* _v24;   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    struct group* _t70;   // _t70
    _unknown_ _t77;                        // _t77

    tail = group_alist;
    while(tail != 0) {
        if((tail->name & 0xff) != ( *group & 0xff) || strcmp( &(tail->name), group) != 0) {
            tail = tail->next;
            continue;
        } else {
            _v24 = tail;
        }
L15:
        return _v24;
    }
    tail = nogroup_alist;
    while(tail != 0) {
        if((tail->name & 0xff) != ( *group & 0xff) || strcmp( &(tail->name), group) != 0) {
            tail = tail->next;
            continue;
        }
        _v24 = 0;
        goto L15;
    }
    _t70 = group;
     *__esp = _t70;
    getgrnam();
    grent = _t70;
    tail = xmalloc(strlen(group) + 9);
    strcpy( &(tail->name), group);
    if(grent == 0) {
        tail->next = nogroup_alist;
        nogroup_alist = tail;
        _v24 = 0;
    } else {
        tail->id =  *(grent + 8);
        tail->next = group_alist;
        group_alist = tail;
        _v24 = tail;
    }
    goto L15;
}

char* imaxtostr(intmax_t i, char* buf)
{// addr = 0x0805497C  --  defined in 'inttostr.c' at line 30
    char* p;                               // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t57;                        // _t57
    _unknown_ _t73;                        // _t73
    _unknown_ _t74;                        // _t74
    _unknown_ _t81;                        // _t81
    signed int _t84;                       // _t84
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    signed int _t89;                       // _t89

    _v28 = _a4;
    _v24 = _a8;
    p =  &(buf[0x14]);
     *p = 0;
    if(_v24 >= 0) {
        while(1) {
            p = p - 1;
             *p = __moddi3(_v28, _v24, 10, 0) + 48 & 255;
            _t84 = _v24;
            _v28 = __divdi3(_v28, _t84, 10, 0);
            _v24 = _t84;
            if((_v24 | _v28) == 0) {
                break;
            }
        }
    } else {
        while(1) {
            p = p - 1;
            __moddi3(_v28, _v24, 10, 0);
             *p = 0x30;
            _t89 = _v24;
            _v28 = __divdi3(_v28, _t89, 10, 0);
            _v24 = _t89;
            if((_v24 | _v28) == 0) {
                break;
            }
        }
        p = p - 1;
         *p = 45;
    }
    return p;
}

mpsort_into_tmp(** base, size_t n, ** tmp, comparison_function cmp)
{// addr = 0x08054A84  --  defined in 'mpsort.c' at line 40
    size_t n1;          // _cfa_fffffff8
    size_t n2;          // _cfa_fffffff4
    size_t a;           // _cfa_fffffff0
    size_t alim;        // _cfa_ffffffec
    size_t b;           // _cfa_ffffffe8
    size_t blim;        // _cfa_ffffffe4
    * ba;                     // _cfa_ffffffe0
    * bb;                     // _cfa_ffffffdc
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    * _v56;                   // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    _None* _t99;                           // _t99

    n1 = n >> 1;
    n2 = n - n1;
    a = 0;
    alim = n1;
    b = n1;
    blim = n;
    mpsort_with_tmp( &(base[n1]), n2, tmp, cmp);
    mpsort_with_tmp(base, n1, tmp, cmp);
    ba = base[a];
    bb = base[b];
    while(1) {
L1:
        _v56 = bb;
         *__esp = ba;
        _t99 = cmp;
         *_t99();
        if(_t99 > 0) {
            break;
        }
         *tmp = ba;
        tmp =  &(tmp[1]);
        a = a + 1;
        if(a != alim) {
            ba = base[a];
            continue;
        } else {
            a = b;
            alim = blim;
L7:
            memcpy(tmp,  &(base[a]), 0 + (alim - a) * 4);
            return;
        }
L8:
    }
     *tmp = bb;
    tmp =  &(tmp[1]);
    b = b + 1;
    if(b == blim) {
    } else {
        bb = base[b];
        goto L1;
    }
    goto L7;
}

mpsort_with_tmp(** base, size_t n, ** tmp, comparison_function cmp)
{// addr = 0x08054BBB  --  defined in 'mpsort.c' at line 89
    * p0;                     // _cfa_fffffff8
    * p1;                     // _cfa_fffffff4
    size_t n1;          // _cfa_fffffff0
    size_t n2;          // _cfa_ffffffec
    size_t i;           // _cfa_ffffffe8
    size_t t;           // _cfa_ffffffe4
    size_t tlim;        // _cfa_ffffffe0
    size_t b;           // _cfa_ffffffdc
    size_t blim;        // _cfa_ffffffd8
    * bb;                     // _cfa_ffffffd4
    * tt;                     // _cfa_ffffffd0
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    * _v72;                   // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _None* _t118;                          // _t118

    if(n > 2) {
        n1 = n >> 1;
        n2 = n - n1;
        t = 0;
        tlim = n1;
        b = n1;
        blim = n;
        mpsort_with_tmp( &(base[n1]), n2, tmp, cmp);
        if(n1 > 1) {
            mpsort_into_tmp(base, n1, tmp, cmp);
        } else {
             *tmp =  *base;
        }
        tt = tmp[t];
        bb = base[b];
        i = 0;
        while(1) {
L8:
            _v72 = bb;
             *__esp = tt;
            _t118 = cmp;
             *_t118();
            if(_t118 > 0) {
                break;
            }
            base[i] = tt;
            i = i + 1;
            t = t + 1;
            _t91 = t;
            if(t != tlim) {
                tt = tmp[t];
                continue;
            }
L14:
            return;
L15:
        }
        base[i] = bb;
        i = i + 1;
        b = b + 1;
        if(b == blim) {
            goto L12;
        }
        bb = base[b];
        goto L8;
L12:
        memcpy( &(base[i]),  &(tmp[t]), 0 + (tlim - t) * 4);
        return;
    }
    if(n != 2) {
    } else {
        p0 =  *base;
        p1 = base[1];
        _v72 = p1;
         *__esp = p0;
        _t91 = cmp;
         *_t91();
        if(_t91 <= 0) {
        } else {
             *base = p1;
            base[1] = p0;
            return;
        }
    }
    goto L14;
}

mpsort(** base, size_t n, comparison_function cmp)
{// addr = 0x08054D6F  --  defined in 'mpsort.c' at line 154
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    mpsort_with_tmp(base, n,  &(base[n]), cmp);
    return;
}

const _None* quote_n(int n, const _None* name)
{// addr = 0x08054DA0  --  defined in 'quote.c' at line 30
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return quotearg_n_style(n, 5, name);
}

const _None* quote(const _None* name)
{// addr = 0x08054DC2  --  defined in 'quote.c' at line 38
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return quote_n(0, name);
}

struct quoting_options* clone_quoting_options(struct quoting_options* o)
{// addr = 0x08054DE0  --  defined in 'quotearg.c' at line 106
    int e;                                 // _cfa_fffffff8
    struct quoting_options* p;   // _cfa_fffffff4
    struct quoting_options* _v24;   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t11;                        // _t11

    e =  *(__errno_location());
    if(o == 0) {
        _v24 =  &default_quoting_options;
    } else {
        _v24 = o;
    }
    p = xmemdup(_v24, 36);
     *(__errno_location()) = e;
    return p;
}

union quoting_style get_quoting_style(struct quoting_options* o)
{// addr = 0x08054E2C  --  defined in 'quotearg.c' at line 117
    struct quoting_options* _v8;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    if(o == 0) {
        _v8 =  &default_quoting_options;
    } else {
        _v8 = o;
    }
    return  *_v8;
}

set_quoting_style(struct quoting_options* o, union quoting_style s)
{// addr = 0x08054E4E  --  defined in 'quotearg.c' at line 125
    struct quoting_options* _v8;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    if(o == 0) {
        _v8 =  &default_quoting_options;
    } else {
        _v8 = o;
    }
     *_v8 = s;
    return;
}

int set_char_quoting(struct quoting_options* o, char c, int i)
{// addr = 0x08054E73  --  defined in 'quotearg.c' at line 136
    unsigned char uc;                      // _cfa_fffffffb
    unsigned int* p;                       // _cfa_fffffff4
    int shift;                             // _cfa_fffffff0
    int r;                                 // _cfa_ffffffec
    signed char _v24;                      // _cfa_ffffffe8
    struct quoting_options* _v28;   // _cfa_ffffffe4
    _unknown_ __ebp;                       // r6

    _v24 = _a8 & 255;
    uc = _v24 & 0xff;
    if(o == 0) {
        _v28 =  &default_quoting_options;
    } else {
        _v28 = o;
    }
    p =  &(( &(_v28->quote_these_too))[uc & 0xff]);
    shift = uc & 0x1f;
    r =  *p >> (shift & 255) & 1;
     *p =  *p ^ (i & 1 ^ r) << (shift & 255);
    return r;
}

const char* gettext_quote(const char* msgid, union quoting_style s)
{// addr = 0x08054EED  --  defined in 'quotearg.c' at line 150
    const char* translation;   // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    translation = gettext(msgid);
    if(translation == msgid && s == 6) {
        translation = 134617660;
    }
    return translation;
}

size_t quotearg_buffer_restyled(char* buffer, size_t buffersize, const char* arg, size_t argsize, union quoting_style quoting_style, const struct quoting_options* o)
{// addr = 0x08054F1B  --  defined in 'quotearg.c' at line 175
    const char* left;   // _cfa_ffffffe0
    const char* right;   // _cfa_ffffffdc
    unsigned char esc;                     // _cfa_fffffff8
    _Bool backslash_escapes;               // _cfa_fffffffb
    _Bool unibyte_locale;                  // _cfa_fffffffa
    unsigned char c;                       // _cfa_fffffff9
    _Bool printable;                       // _cfa_fffffff7
    size_t i;           // _cfa_fffffff0
    size_t len;         // _cfa_ffffffec
    const char* quote_string;   // _cfa_ffffffe8
    size_t quote_string_len;   // _cfa_ffffffe4
    size_t m;           // _cfa_ffffffd8
    wchar_t w;         // _cfa_ffffffd4
    size_t bytes;       // _cfa_ffffffd0
    size_t j;           // _cfa_ffffffcc
    size_t ilim;        // _cfa_ffffffc8
    mbstate_t mbstate;   // _cfa_ffffffc0
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ _v73;                        // _cfa_ffffffb7
    _unknown_ _v80;                        // _cfa_ffffffb0
    _unknown_ _v96;                        // _cfa_ffffffa0
    _unknown_ _v104;                       // _cfa_ffffff98
    _unknown_ _v108;                       // _cfa_ffffff94
    _unknown_ _v112;                       // _cfa_ffffff90
    _unknown_ _v116;                       // _cfa_ffffff8c
    _unknown_ _v120;                       // _cfa_ffffff88
    _unknown_ __ebp;                       // r6
    _unknown_ _t277;                       // _t277
    _unknown_ _t279;                       // _t279
    _unknown_ _t285;                       // _t285
    _unknown_ _t298;                       // _t298
    _unknown_ _t350;                       // _t350
    _unknown_ _t358;                       // _t358
    _unknown_ _t360;                       // _t360
    _unknown_ _t369;                       // _t369
    _unknown_ _t385;                       // _t385
    _unknown_ _t386;                       // _t386
    _unknown_ _t421;                       // _t421

    len = 0;
    quote_string = 0;
    quote_string_len = 0;
    backslash_escapes = 0;
    __ctype_get_mb_cur_max();
    unibyte_locale = __eax & 255;
    if(quoting_style <= 6) {
        goto __eax;
    }
    i = 0;
    while() {
    }
}

size_t quotearg_buffer(char* buffer, size_t buffersize, const char* arg, size_t argsize, const struct quoting_options* o)
{// addr = 0x08055667  --  defined in 'quotearg.c' at line 523
    const struct quoting_options* p;   // _cfa_fffffff8
    int e;                                 // _cfa_fffffff4
    size_t r;           // _cfa_fffffff0
    const struct quoting_options* _v24;   // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6

    if(o == 0) {
        _v24 =  &default_quoting_options;
    } else {
        _v24 = o;
    }
    p = _v24;
    e =  *(__errno_location());
    r = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, p->style, p);
     *(__errno_location()) = e;
    return r;
}

char* quotearg_alloc(const char* arg, size_t argsize, const struct quoting_options* o)
{// addr = 0x080556D6  --  defined in 'quotearg.c' at line 537
    int e;                                 // _cfa_fffffff8
    size_t bufsize;     // _cfa_fffffff4
    char* buf;                             // _cfa_fffffff0
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23
    _unknown_ _t38;                        // _t38

    e =  *(__errno_location());
    bufsize = quotearg_buffer(0, 0, arg, argsize, o) + 1;
    buf = xcharalloc(bufsize);
    quotearg_buffer(buf, bufsize, arg, argsize, o);
     *(__errno_location()) = e;
    return buf;
}

quotearg_free()
{// addr = 0x0805575B  --  defined in 'quotearg.c' at line 562
    struct slotvec* sv;   // _cfa_fffffff8
    unsigned int i;                        // _cfa_fffffff4
    _unknown_ __ebp;                       // r6
    _unknown_ _t21;                        // _t21
    struct slotvec* _t22;   // _t22

    sv = slotvec;
    i = 1;
    while(i < nslots) {
        free( &(sv[i])->val);
        i = i + 1;
    }
    _t22 = sv;
    _t23 = _t22->val;
    if(_t22->val !=  &slot0) {
        _t23 = free(sv->val);
        slotvec0.size = 256;
        slotvec0.val =  &slot0;
    }
    if(sv !=  &slotvec0) {
        free(sv);
        slotvec =  &slotvec0;
    }
    nslots = 1;
    return;
}

char* quotearg_n_options(int n, const char* arg, size_t argsize, const struct quoting_options* options)
{// addr = 0x080557ED  --  defined in 'quotearg.c' at line 592
    _Bool preallocated;                    // _cfa_fffffff7
    int e;                                 // _cfa_fffffff0
    unsigned int n0;                       // _cfa_ffffffec
    struct slotvec* sv;   // _cfa_ffffffe8
    size_t n1;          // _cfa_ffffffe4
    size_t size;        // _cfa_ffffffe0
    char* val;                             // _cfa_ffffffdc
    size_t qsize;       // _cfa_ffffffd8
    int _v44;                              // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ _v60;                        // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t80;                        // _t80
    _unknown_ _t119;                       // _t119
    _unknown_ _t121;                       // _t121
    signed int _t123;                      // _t123
    _unknown_ _t136;                       // _t136
    _unknown_ _t139;                       // _t139

    e =  *(__errno_location());
    n0 = n;
    sv = slotvec;
    if(n < 0) {
        abort();
    }
    if(nslots <= n0) {
        _t123 = n0 + 1;
        n1 = _t123;
        preallocated = _t123 & 255;
        if(n1 > 536870911) {
            xalloc_die();
        }
        _v48 = n1 << 3;
        if(preallocated == 0) {
            _v44 = sv;
        } else {
            _v44 = 0;
        }
        sv = xrealloc(_v44, _v48);
        slotvec = sv;
        if(preallocated != 0) {
            __ecx = sv;
             *__ecx = slotvec0.size;
            __ecx->val = slotvec0.val;
        }
        memset( &(sv[nslots]), 0, 0 + (n1 - nslots) * 8);
        nslots = n1;
    }
    size = sv[n].size;
    val =  &(sv[n])->val;
    qsize = quotearg_buffer(val, size, arg, argsize, options);
    if(size <= qsize) {
        size = qsize + 1;
        sv[n] = size;
        if(val !=  &slot0) {
            free(val);
        }
        val = xcharalloc(size);
         &(sv[n])->val = val;
        quotearg_buffer(val, size, arg, argsize, options);
    }
     *(__errno_location()) = e;
    return val;
}

char* quotearg_n(int n, const char* arg)
{// addr = 0x080559AD  --  defined in 'quotearg.c' at line 642
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return quotearg_n_options(n, arg, -1,  &default_quoting_options);
}

char* quotearg(const char* arg)
{// addr = 0x080559D7  --  defined in 'quotearg.c' at line 648
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return quotearg_n(0, arg);
}

struct quoting_options quoting_options_from_style(union quoting_style style)
{// addr = 0x080559F2  --  defined in 'quotearg.c' at line 655
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    struct quoting_options o;   // _cfa_ffffffd4
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    struct quoting_options __ebx;   // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27

    __ebx = _a4;
    o.style = style;
    memset( &(( &(o.style))[1]), 0, 32);
     *__ebx = o.style;
     *((intOrPtr*)(__ebx + 4)) = o.quote_these_too;
     *((intOrPtr*)(__ebx + 8)) = _v36;
     *((intOrPtr*)(__ebx + 12)) = _v32;
     *((intOrPtr*)(__ebx + 16)) = _v28;
     *((intOrPtr*)(__ebx + 20)) = _v24;
     *((intOrPtr*)(__ebx + 24)) = _v20;
     *((intOrPtr*)(__ebx + 28)) = _v16;
     *((intOrPtr*)(__ebx + 32)) = _v12;
    return __ebx;
}

char* quotearg_n_style(int n, union quoting_style s, const char* arg)
{// addr = 0x08055A5F  --  defined in 'quotearg.c' at line 664
    const struct quoting_options o;   // _cfa_ffffffd8
    _unknown_ _v68;                        // _cfa_ffffffbc
    union quoting_style _v72;   // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ __ebp;                       // r6

    _v72 = s;
    quoting_options_from_style( &(o.style));
    __esp = __esp - 4;
    return quotearg_n_options(n, arg, -1,  &(o.style));
}

char* quotearg_n_style_mem(int n, union quoting_style s, const char* arg, size_t argsize)
{// addr = 0x08055A9D  --  defined in 'quotearg.c' at line 672
    const struct quoting_options o;   // _cfa_ffffffd8
    _unknown_ _v68;                        // _cfa_ffffffbc
    union quoting_style _v72;   // _cfa_ffffffb8
    _unknown_ _v76;                        // _cfa_ffffffb4
    _unknown_ __ebp;                       // r6

    _v72 = s;
    quoting_options_from_style( &(o.style));
    __esp = __esp - 4;
    return quotearg_n_options(n, arg, argsize,  &(o.style));
}

char* quotearg_style(union quoting_style s, const char* arg)
{// addr = 0x08055ADA  --  defined in 'quotearg.c' at line 679
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return quotearg_n_style(0, s, arg);
}

char* quotearg_char(const char* arg, char ch)
{// addr = 0x08055AFC  --  defined in 'quotearg.c' at line 685
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    struct quoting_options options;   // _cfa_ffffffd8
    char _v56;                             // _cfa_ffffffc8
    _unknown_ _v64;                        // _cfa_ffffffc0
    _unknown_ _v68;                        // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t35;                        // _t35

    _v56 = _a8 & 255;
    options.style = default_quoting_options.style;
    options.quote_these_too = default_quoting_options.quote_these_too;
    _v32 =  *134629160;
    _v28 =  *134629164;
    _v24 =  *134629168;
    _v20 =  *134629172;
    _v16 =  *134629176;
    _v12 =  *134629180;
    _v8 =  *134629184;
    set_char_quoting( &(options.style), _v56, 1);
    return quotearg_n_options(0, arg, -1,  &(options.style));
}

char* quotearg_colon(const char* arg)
{// addr = 0x08055B8F  --  defined in 'quotearg.c' at line 694
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return quotearg_char(arg, 58);
}

char* memcpy_lowcase(char* dest, const char* src, size_t len)
{// addr = 0x08055BAC  --  defined in 'strftime.c' at line 314
    _unknown_ __ebp;                       // r6
    signed int _t18;                       // _t18

    _t18 = __eax;
    while(1) {
        len = len - 1;
        if((_t18 & 255) == 0) {
            break;
        }
        _t18 =  *(src + len) & 0xff;
         *__esp = _t18;
        tolower();
        dest[len] = _t18 & 255;
    }
    return dest;
}

char* memcpy_uppcase(char* dest, const char* src, size_t len)
{// addr = 0x08055BEE  --  defined in 'strftime.c' at line 323
    _unknown_ __ebp;                       // r6
    signed int _t18;                       // _t18

    _t18 = __eax;
    while(1) {
        len = len - 1;
        if((_t18 & 255) == 0) {
            break;
        }
        _t18 =  *(src + len) & 0xff;
         *__esp = _t18;
        toupper();
        dest[len] = _t18 & 255;
    }
    return dest;
}

size_t strftime_case_(_Bool upcase, char* s, size_t maxsize, const char* format, const struct tm* tp, int ut, int ns)
{// addr = 0x08055C30  --  defined in 'strftime.c' at line 420
    int number_value;                      // _cfa_fffffbb4
    unsigned int u_number_value;           // _cfa_fffffbb0
    _Bool negative_number;                 // _cfa_fffffbe1
    _Bool always_output_a_sign;            // _cfa_fffffbe0
    int tz_colon_mask;                     // _cfa_fffffbac
    const char* subfmt;   // _cfa_fffffba8
    char sign_char;                        // _cfa_fffffbdf
    char* bufp;                            // _cfa_fffffba4
    char[13] buf;                          // _cfa_ffffffe2
    size_t colons;      // _cfa_fffffb9c
    int _n;                                // _cfa_fffffb70
    int _delta;                            // _cfa_fffffb6c
    int _incr;                             // _cfa_fffffb68
    size_t len;         // _cfa_fffffb64
    int _n;                                // _cfa_fffffb60
    int _delta;                            // _cfa_fffffb5c
    int _incr;                             // _cfa_fffffb58
    char[4] ufmt;                          // _cfa_fffffa6c
    char* u;                               // _cfa_fffffb54
    char[1023] ubuf;                       // _cfa_fffffbe2
    size_t len;         // _cfa_fffffb50
    int _n;                                // _cfa_fffffb4c
    int _delta;                            // _cfa_fffffb48
    int _incr;                             // _cfa_fffffb44
    int century;                           // _cfa_fffffb40
    int _n;                                // _cfa_fffffb3c
    int _delta;                            // _cfa_fffffb38
    int _incr;                             // _cfa_fffffb34
    int padding;                           // _cfa_fffffb30
    int _n;                                // _cfa_fffffb2c
    int _delta;                            // _cfa_fffffb28
    int _incr;                             // _cfa_fffffb24
    int _n;                                // _cfa_fffffb20
    int _delta;                            // _cfa_fffffb1c
    int _incr;                             // _cfa_fffffb18
    int _n;                                // _cfa_fffffb14
    int _delta;                            // _cfa_fffffb10
    int _incr;                             // _cfa_fffffb0c
    int _n;                                // _cfa_fffffb08
    int _delta;                            // _cfa_fffffb04
    int _incr;                             // _cfa_fffffb00
    int j;                                 // _cfa_fffffafc
    int _n;                                // _cfa_fffffaf8
    int _delta;                            // _cfa_fffffaf4
    int _incr;                             // _cfa_fffffaf0
    struct tm ltm;          // _cfa_fffffa6c
    time_t t;           // _cfa_fffffaec
    int d;                                 // _cfa_fffffae8
    int _n;                                // _cfa_fffffae4
    int _delta;                            // _cfa_fffffae0
    int _incr;                             // _cfa_fffffadc
    int year;                              // _cfa_fffffad8
    int year_adjust;                       // _cfa_fffffad4
    int days;                              // _cfa_fffffad0
    int d;                                 // _cfa_fffffacc
    int yy;                                // _cfa_fffffac8
    int yy;                                // _cfa_fffffac4
    int _n;                                // _cfa_fffffac0
    int _delta;                            // _cfa_fffffabc
    int _incr;                             // _cfa_fffffab8
    int diff;                              // _cfa_fffffab4
    int hour_diff;                         // _cfa_fffffab0
    int min_diff;                          // _cfa_fffffaac
    int sec_diff;                          // _cfa_fffffaa8
    intOrPtr _v16;                         // _cfa_fffffff0
    _Bool to_lowcase;                      // _cfa_fffffbde
    _Bool to_uppcase;                      // _cfa_fffffbdd
    _Bool change_case;                     // _cfa_fffffbdc
    int hour12;                            // _cfa_fffffbd8
    const char* zone;   // _cfa_fffffbd4
    size_t i;           // _cfa_fffffbd0
    char* p;                               // _cfa_fffffbcc
    const char* f;   // _cfa_fffffbc8
    const char* format_end;   // _cfa_fffffbc4
    int pad;                               // _cfa_fffffbc0
    int modifier;                          // _cfa_fffffbbc
    int digits;                            // _cfa_fffffbb8
    int width;                             // _cfa_fffffba0
    int format_char;                       // _cfa_fffffb98
    int _n;                                // _cfa_fffffb94
    int _delta;                            // _cfa_fffffb90
    int _incr;                             // _cfa_fffffb8c
    size_t len;         // _cfa_fffffb88
    size_t fsize;       // _cfa_fffffb84
    size_t bytes;       // _cfa_fffffb80
    int _n;                                // _cfa_fffffb7c
    int _delta;                            // _cfa_fffffb78
    int _incr;                             // _cfa_fffffb74
    int flen;                              // _cfa_fffffaa4
    int _n;                                // _cfa_fffffaa0
    int _delta;                            // _cfa_fffffa9c
    int _incr;                             // _cfa_fffffa98
    intOrPtr _v1424;                       // _cfa_fffffa70
    mbstate_t mbstate;   // _cfa_fffffa6c
    signed char _v1440;                    // _cfa_fffffa60
    char* _v1444;                          // _cfa_fffffa5c
    const char* _v1448;   // _cfa_fffffa58
    intOrPtr _v1452;                       // _cfa_fffffa54
    _unknown_ _v1556;                      // _cfa_fffff9ec
    signed int _v1560;                     // _cfa_fffff9e8
    unsigned int _v1564;                   // _cfa_fffff9e4
    signed int _v1568;                     // _cfa_fffff9e0
    unsigned int _v1604;                   // _cfa_fffff9bc
    intOrPtr _v1608;                       // _cfa_fffff9b8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t322;                       // _t322
    unsigned int _t340;                    // _t340
    _unknown_ _t357;                       // _t357
    _unknown_ _t362;                       // _t362
    _unknown_ _t366;                       // _t366
    _unknown_ _t369;                       // _t369
    _unknown_ _t373;                       // _t373
    unsigned int _t375;                    // _t375
    int* _t377;                            // _t377
    _unknown_ _t400;                       // _t400
    _unknown_ _t404;                       // _t404
    _unknown_ _t427;                       // _t427
    _unknown_ _t442;                       // _t442
    _unknown_ _t446;                       // _t446
    _unknown_ _t448;                       // _t448
    _unknown_ _t452;                       // _t452
    _unknown_ _t453;                       // _t453
    _unknown_ _t457;                       // _t457
    _unknown_ _t460;                       // _t460
    _unknown_ _t464;                       // _t464
    _unknown_ _t467;                       // _t467
    _unknown_ _t468;                       // _t468
    _unknown_ _t494;                       // _t494
    unsigned int _t516;                    // _t516

    _v1440 = _a4 & 255;
    _v1444 = _a8;
    _v1448 = _a16;
    _v1452 = _a20;
    _v16 =  *gs:0x14];
    hour12 =  *(_v1452 + 8);
    i = 0;
    p = _v1444;
    format_end = 0;
    zone = 0;
    zone =  *(_v1452 + 40);
    if(hour12 <= 12) {
        if(hour12 == 0) {
            hour12 = 12;
        }
    } else {
        hour12 = hour12 - 12;
    }
    f = _v1448;
    while(( *f & 0xff) != 0) {
        pad = 0;
        digits = 0;
        width = -1;
        to_lowcase = 0;
        to_uppcase = _v1440 & 0xff;
        change_case = 0;
        _v1568 =  *f & 0xff;
        if(_v1568 > 63) {
            if(_v1568 < 65 || _v1568 > 95 && _v1568 - 97 > 29) {
L26:
                mbstate.__count = mbstate_zero.__val;
                _v1424 =  *134629476;
                len = 0;
                if(format_end == 0) {
                    format_end = strlen(f) + 1 + f;
                }
                fsize = format_end - f;
                while(1) {
                    _t340 =  &(mbstate.__count);
                    _v1604 = _t340;
                    _v1608 = fsize - len;
                     *__esp = f + len;
                    mbrlen();
                    bytes = _t340;
                    if(bytes == 0) {
                        break;
                    }
                    if(bytes != 254) {
                        if(bytes != 255) {
                            len = len + bytes;
                            _t377 =  &(mbstate.__count);
                             *__esp = _t377;
                            mbsinit();
                            if(_t377 == 0) {
                                continue;
                            }
                            break;
                        }
                        goto L33;
                    }
                    len = len + strlen(f + len);
                    break;
L33:
                    len = len + 1;
                    break;
                }
                _n = len;
                _delta = width - _n;
                _incr = ( !(_delta >> 31) & _delta) + _n;
                if(_incr < maxsize - i) {
                    if(p != 0) {
                        if(digits == 0 && _delta > 0) {
                            if(pad != 48) {
                                memset(p, 32, _delta);
                                p =  &(p[_delta]);
                            } else {
                                memset(p, 48, _delta);
                                p =  &(p[_delta]);
                            }
                        }
                        if(to_lowcase == 0) {
                            if(to_uppcase == 0) {
                                memcpy(p, f, _n);
                            } else {
                                memcpy_uppcase(p, f, _n);
                            }
                        } else {
                            memcpy_lowcase(p, f, _n);
                        }
                        p =  &(p[_n]);
                    }
                    i = i + _incr;
                    f = f + len - 1;
                    goto L92;
                }
                _v1564 = 0;
                goto L98;
            } else {
L16:
                _n = 1;
                _delta = width - _n;
                _incr = ( !(_delta >> 31) & _delta) + _n;
                if(_incr < maxsize - i) {
                    if(p != 0) {
                        if(digits == 0 && _delta > 0) {
                            if(pad != 48) {
                                memset(p, 32, _delta);
                                p =  &(p[_delta]);
                            } else {
                                memset(p, 48, _delta);
                                p =  &(p[_delta]);
                            }
                        }
                         *p =  *f & 0xff;
                        p =  &(p[_n]);
                    }
                    i = i + _incr;
L92:
                    f =  &(f[1]);
                    continue;
                } else {
                    _v1564 = 0;
                }
L98:
                _t375 = _v1564;
                if(_t516 == 0) {
                    return _t375;
                }
                __stack_chk_fail();
                return _t375;
            }
        }
        if(_v1568 >= 38) {
            goto L16;
        }
        if(_v1568 > 35) {
            if(_v1568 == 37) {
                while(1) {
                    f =  &(f[1]);
                    _v1560 =  *f & 0xff;
                    if(_v1560 == 48) {
                        goto L57;
                    } else {
                        goto L51;
                    }
                }
            } else {
            }
            goto L26;
        }
        if(_v1568 >= 32 || _v1568 - 8 <= 5) {
            goto L16;
        }
        goto L26;
    }
    if(p != 0) {
        _t516 = maxsize;
        if(_t516 != 0) {
             *p = 0;
        }
    }
    _v1564 = i;
    goto L98;
}

int iso_week_days(int yday, int wday)
{// addr = 0x0805865E  --  defined in 'strftime.c' at line 371
    int big_enough_multiple_of_7;          // _cfa_fffffff4
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    signed int _t35;                       // _t35

    big_enough_multiple_of_7 = 378;
    _t35 = yday - wday + 4 + big_enough_multiple_of_7;
    _v32 = -1840700269;
    _v28 = ((_v32 * _t35 >> 32) + _t35 >> 2) - (_t35 >> 31);
    _v28 = _t35 - (_v28 << 3) - _v28;
    return yday - _v28 + 3;
}

size_t nstrftime(char* s, size_t maxsize, const char* format, const struct tm* tp, int ut, int ns)
{// addr = 0x080586BB  --  defined in 'strftime.c' at line 1442
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6

    return strftime_case_(0, s, maxsize, format, tp, ut, ns);
}

char* umaxtostr(uintmax_t i, char* buf)
{// addr = 0x080586FC  --  defined in 'inttostr.c' at line 30
    char* p;                               // _cfa_fffffff8
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t28;                        // _t28
    _unknown_ _t43;                        // _t43
    signed int _t46;                       // _t46

    _v28 = _a4;
    _v24 = _a8;
    p =  &(buf[0x14]);
     *p = 0;
    while(1) {
        p = p - 1;
         *p = __umoddi3(_v28, _v24, 10, 0) + 48 & 255;
        _t46 = _v24;
        _v28 = __udivdi3(_v28, _t46, 10, 0);
        _v24 = _t46;
        if((_v24 | _v28) == 0) {
            break;
        }
    }
    return p;
}

int rpl_vfprintf(FILE* fp, const char* format, va_list args)
{// addr = 0x08058788  --  defined in 'vfprintf.c' at line 44
    intOrPtr _v8;                          // _cfa_fffffff8
    char[1999] buf;                        // _cfa_fffff828
    char* output;                          // _cfa_fffff824
    size_t len;         // _cfa_fffff820
    size_t lenbuf;      // _cfa_fffff81c
    int saved_errno;                       // _cfa_fffff818
    FILE* _v2040;         // _cfa_fffff808
    const char* _v2044;   // _cfa_fffff804
    char* _v2048;                          // _cfa_fffff800
    int _v2052;                            // _cfa_fffff7fc
    _unknown_ _v2064;                      // _cfa_fffff7f0
    _unknown_ _v2068;                      // _cfa_fffff7ec
    _unknown_ _v2072;                      // _cfa_fffff7e8
    _unknown_ __ebp;                       // r6
    _unknown_ _t46;                        // _t46
    int _t56;                              // _t56
    int _t58;                              // _t58
    _unknown_ _t65;                        // _t65
    _unknown_ _t71;                        // _t71

    _v2040 = _a4;
    _v2044 = _a8;
    _v2048 = _a12;
    _v8 =  *gs:0x14];
    lenbuf = 2000;
    output = vasnprintf( &buf,  &lenbuf, _v2044, _v2048);
    len = lenbuf;
    __eflags = output;
    if(__eflags != 0) {
        _t56 = fwrite(output, 1, len, _v2040);
        __eflags = _t56 - len;
        if(_t56 >= len) {
            __eflags = len;
            if(__eflags >= 0) {
                _v2052 = len;
            } else {
                 *(__errno_location()) = 75;
                fseterr(_v2040);
                _v2052 = -1;
            }
        } else {
            __eflags = output -  &buf;
            if(__eflags != 0) {
                saved_errno =  *(__errno_location());
                free(output);
                 *(__errno_location()) = saved_errno;
            }
            _v2052 = -1;
        }
    } else {
        fseterr(_v2040);
        _v2052 = -1;
    }
    _t58 = _v2052;
    if(__eflags == 0) {
        return _t58;
    } else {
        __stack_chk_fail();
        return _t58;
    }
}

_Unknown_base* xnmalloc(size_t n, size_t s)
{// addr = 0x080588F0  --  defined in 'xalloc.h' at line 113
    _unknown_ __ebp;                       // r6
    _unknown_ _t10;                        // _t10
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    if(-1 / s < n) {
        xalloc_die();
    }
    return xmalloc(n * s);
}

_Unknown_base* xnrealloc(_Unknown_base* p, size_t n, size_t s)
{// addr = 0x0805891E  --  defined in 'xalloc.h' at line 124
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19

    if(-1 / s < n) {
        xalloc_die();
    }
    return xrealloc(p, n * s);
}

_Unknown_base* x2nrealloc(_Unknown_base* p, size_t* pn, size_t s)
{// addr = 0x08058953  --  defined in 'xalloc.h' at line 187
    size_t n;           // _cfa_fffffff8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37
    _unknown_ _t47;                        // _t47
    signed int _t48;                       // _t48
    _unknown_ _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    _unknown_ _t53;                        // _t53
    _unknown_ _t54;                        // _t54

    n =  *pn;
    if(p != 0) {
        if(-1431655766 / s <= n) {
            xalloc_die();
        }
        n = n + (n + 1 >> 1);
    } else {
        if(n == 0) {
            _t48 = 64 / s;
            n = _t48;
            n = n + (_t48 & 0xff);
        }
    }
     *pn = n;
    return xrealloc(p, n * s);
}

char* xcharalloc(size_t n)
{// addr = 0x080589CE  --  defined in 'xalloc.h' at line 224
    _unknown_ __ebp;                       // r6

    return xmalloc(n);
}

_Unknown_base* xmalloc(size_t n)
{// addr = 0x080589E1  --  defined in 'xmalloc.c' at line 48
    _Unknown_base* p;                      // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    p = malloc(n);
    if(p == 0 && n != 0) {
        xalloc_die();
    }
    return p;
}

_Unknown_base* xrealloc(_Unknown_base* p, size_t n)
{// addr = 0x08058A0B  --  defined in 'xmalloc.c' at line 60
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    p = realloc(p, n);
    if(p == 0 && n != 0) {
        xalloc_die();
    }
    return p;
}

_Unknown_base* x2realloc(_Unknown_base* p, size_t* pn)
{// addr = 0x08058A3C  --  defined in 'xmalloc.c' at line 75
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return x2nrealloc(p, pn, 1);
}

_Unknown_base* xzalloc(size_t s)
{// addr = 0x08058A5E  --  defined in 'xmalloc.c' at line 85
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return memset(xmalloc(s), 0, s);
}

_Unknown_base* xcalloc(size_t n, size_t s)
{// addr = 0x08058A8A  --  defined in 'xmalloc.c' at line 94
    _Unknown_base* p;                      // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    p = calloc(n, s);
    if(p == 0) {
        xalloc_die();
    }
    return p;
}

_Unknown_base* xmemdup(* p, size_t s)
{// addr = 0x08058AB5  --  defined in 'xmalloc.c' at line 112
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    return memcpy(xmalloc(s), p, s);
}

char* xstrdup(const char* string)
{// addr = 0x08058AE0  --  defined in 'xmalloc.c' at line 120
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return xmemdup(string, strlen(string) + 1);
}

xstrtol_error(union strtol_error err, int opt_idx, char c, const struct option* long_options, const char* arg, int exit_status)
{// addr = 0x08058B08  --  defined in 'xstrtol-error.c' at line 51
    int _v5;                               // _cfa_fffffffb
    char[1] option_buffer;                 // _cfa_fffffffa
    const char* hyphens;   // _cfa_fffffff4
    const char* msgid;   // _cfa_fffffff0
    const char* option;   // _cfa_ffffffec
    signed char _v24;                      // _cfa_ffffffe8
    union strtol_error _v28;   // _cfa_ffffffe4
    const char* _v40;   // _cfa_ffffffd8
    const char* _v44;   // _cfa_ffffffd4
    const char* _v48;   // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __ebp;                       // r6
    char* _t45;                            // _t45
    _unknown_ _t53;                        // _t53

    _v24 = _a12 & 255;
    hyphens = 134618868;
    _v28 = err;
    if(_v28 > 3) {
        if(_v28 != 4) {
L5:
            abort();
        }
        msgid = "invalid %s%s argument `%s'";
L9:
        if(opt_idx >= 0) {
            option =  *(long_options + (opt_idx << 4));
        } else {
            hyphens = hyphens +  ~opt_idx;
            option_buffer = _v24 & 0xff;
            _v5 = 0;
            option =  &option_buffer;
        }
        _t45 = gettext(msgid);
        _v40 = arg;
        _v44 = option;
        _v48 = hyphens;
        error(exit_failure, 0, _t45);
        return;
    }
    if(_v28 >= 2) {
        msgid = "invalid suffix in %s%s argument `%s'";
    } else {
        if(_v28 == 1) {
            msgid = "%s%s argument `%s' too large";
        } else {
            goto L5;
        }
    }
    goto L9;
}

xstrtol_fatal(union strtol_error err, int opt_idx, char c, const struct option* long_options, const char* arg)
{// addr = 0x08058BC6  --  defined in 'xstrtol-error.c' at line 95
    signed int* _v0;                       // _cfa_0
    char _v8;                              // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    _unknown_ _v32;                        // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr* _v40;                        // _cfa_ffffffd8
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37
    _unknown_ _t39;                        // _t39
    _unknown_ _t49;                        // _t49
    _unknown_ _t50;                        // _t50
    _unknown_ _t54;                        // _t54
    _unknown_ _t55;                        // _t55

    _v8 = _a12 & 255;
    xstrtol_error(err, opt_idx, _v8, long_options, arg, exit_failure);
    abort();
    _push(_t54);
    __esp = __esp - 12;
    _v60 = _v36;
    if(-1 / _v60 >=  *_v40) {
         *_v0 =  *_v0 * err;
        _v12 = 0;
    } else {
         *_v0 = -1;
        _v12 = 1;
    }
    return _v12;
}

strtol_error bkm_scale(long unsigned int* x, int scale_factor)
{// addr = 0x08058C08  --  defined in 'xstrtol.c' at line 48
    union strtol_error _v8;   // _cfa_fffffff8
    int _v16;                              // _cfa_fffffff0
    _unknown_ __ebp;                       // r6
    _unknown_ _t18;                        // _t18
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28

    _v16 = scale_factor;
    if(-1 / _v16 >=  *x) {
         *x =  *x * scale_factor;
        _v8 = 0;
    } else {
         *x = -1;
        _v8 = 1;
    }
    return _v8;
}

strtol_error bkm_scale_by_power(long unsigned int* x, int base, int power)
{// addr = 0x08058C5A  --  defined in 'xstrtol.c' at line 65
    strtol_error err;   // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t15;                       // _t15

    _t15 = __eax;
    err = 0;
    while(1) {
        power = power - 1;
        if((_t15 & 255) == 0) {
            break;
        }
        _t15 = bkm_scale(x, base);
        err = err | _t15;
    }
    return err;
}

strtol_error xstrtoul(const char* s, char** ptr, int strtol_base, long unsigned int* val, const char* valid_suffixes)
{// addr = 0x08058C92  --  defined in 'xstrtol.c' at line 77
    strtol_error overflow;   // _cfa_ffffffd8
    unsigned char ch;                      // _cfa_fffffffb
    char* t_ptr;                           // _cfa_fffffff4
    char** p;                              // _cfa_fffffff0
    long unsigned int tmp;                 // _cfa_ffffffec
    strtol_error err;   // _cfa_ffffffe8
    const char* q;   // _cfa_ffffffe4
    int base;                              // _cfa_ffffffe0
    int suffixes;                          // _cfa_ffffffdc
    signed int _v56;                       // _cfa_ffffffc8
    union strtol_error _v60;   // _cfa_ffffffc4
    char** _v64;                           // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char* _v80;                            // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    signed int _t109;                      // _t109
    _unknown_ _t147;                       // _t147
    _unknown_ _t178;                       // _t178

    err = 0;
    if(strtol_base >= 0 || strtol_base > 36) {
        _v80 = "xstrtoul";
        _v84 = 83;
        _v88 = "xstrtol.c";
         *__esp = "0 <= strtol_base && strtol_base <= 36";
        __assert_fail();
    }
    if(ptr != 0) {
        _v64 = ptr;
    } else {
        _v64 =  &t_ptr;
    }
    p = _v64;
    q = s;
    _t109 =  *q & 255;
    ch = _t109 & 255;
    while(1) {
        __ctype_b_loc();
        if(( *( *_t109 + (ch & 255) + (ch & 255)) & 0x2000) == 0) {
            break;
        }
        q =  &(q[1]);
        _t109 =  *q & 255;
        ch = _t109 & 255;
    }
    if(ch != 45) {
         *(__errno_location()) = 0;
        tmp = strtoul(s, p, strtol_base);
        if( *p != s) {
L17:
            if( *(__errno_location()) == 0) {
L21:
                if(valid_suffixes != 0) {
                    if(( *( *p) & 0xff) == 0) {
L37:
                         *val = tmp;
                        _v60 = err;
                        goto L38;
                    }
                    goto L24;
                }
                goto L22;
L24:
                base = 1024;
                suffixes = 1;
                if(strchr(valid_suffixes,  *( *p) & 0xff) != 0) {
                    if(strchr(valid_suffixes, 48) == 0) {
L34:
                        _v68 = ( *( *p) & 0xff) - 66;
                        if(_v68 > 53) {
                             *val = tmp;
                            _v60 = err | 2;
                            goto L38;
                        }
                        goto L35;
                    }
                    goto L27;
L35:
                    goto __eax;
                }
                 *val = tmp;
                _v60 = err | 2;
                goto L38;
L27:
                _v56 = ( *p)[1] & 0xff;
                if(_v56 == 68) {
L33:
                    base = 1000;
                    suffixes = suffixes + 1;
                    goto L34;
                }
                if(_v56 == 105) {
                    if((( *p)[2] & 0xff) == 66) {
                        suffixes = suffixes + 2;
                    }
                    goto L34;
                }
                if(_v56 == 66) {
                    goto L33;
                }
                goto L34;
            }
            goto L18;
L22:
             *val = tmp;
            _v60 = err;
            goto L38;
        }
        goto L12;
L18:
        if( *(__errno_location()) == 34) {
            err = 1;
            goto L21;
        }
        _v60 = 4;
        goto L38;
    }
    _v60 = 4;
L38:
    return _v60;
L12:
    if(valid_suffixes == 0 || ( *( *p) & 0xff) == 0 || strchr(valid_suffixes,  *( *p) & 0xff) == 0) {
        _v60 = 4;
        goto L38;
    } else {
        tmp = 1;
        goto L21;
    }
    goto L17;
}

fseterr(FILE* fp)
{// addr = 0x08059078  --  defined in 'fseterr.c' at line 26
    _unknown_ __ebp;                       // r6

    fp->_flags = fp->_flags | 32;
    return;
}

char* xstrndup(const _None* string, size_t n)
{// addr = 0x0805908C  --  defined in 'xstrndup.c' at line 31
    char* s;                               // _cfa_fffffff8
    unsigned int _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    char* _t8;                             // _t8

    _v24 = n;
    _t8 = string;
     *__esp = _t8;
    strndup();
    s = _t8;
    if(s == 0) {
        xalloc_die();
    }
    return s;
}

strtol_error bkm_scale(uintmax_t* x, int scale_factor)
{// addr = 0x080590B8  --  defined in 'xstrtol.c' at line 48
    long long unsigned int _v24;           // _cfa_ffffffe8
    long long unsigned int _v28;           // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    union strtol_error _v40;   // _cfa_ffffffd8
    _unknown_ _v48;                        // _cfa_ffffffd0
    _unknown_ _v52;                        // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    signed int _t32;                       // _t32
    uintmax_t* _t34;   // _t34
    uintmax_t* _t35;   // _t35
    signed int _t36;                       // _t36
    uintmax_t* _t40;   // _t40
    signed int _t43;                       // _t43
    uintmax_t* _t44;   // _t44
    _unknown_ _t45;                        // _t45
    signed int _t47;                       // _t47

    _t32 = scale_factor;
    _t47 = _t32 >> 31;
    _v36 = __udivdi3(-1, -1, _t32, _t47);
    _v32 = _t47;
    _t34 = x;
    _v28 =  *_t34;
    _v24 = _t34[0];
    if(_v32 > _v24 || _v32 >= _v24 && _v36 >= _v28) {
        _t35 = x;
        _t43 =  *_t35;
        _t36 = scale_factor;
        _t44 = x;
         *_t44 = _t36 * _t43;
        _t44[0] = _t35[0] * _t36 + (_t36 >> 31) * _t43 + (_t36 * _t43 >> 32);
        _v40 = 0;
    } else {
        _t40 = x;
         *_t40 = -1;
        _t40[0] = -1;
        _v40 = 1;
    }
    return _v40;
}

strtol_error bkm_scale_by_power(uintmax_t* x, int base, int power)
{// addr = 0x08059166  --  defined in 'xstrtol.c' at line 65
    strtol_error err;   // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t15;                       // _t15

    _t15 = __eax;
    err = 0;
    while(1) {
        power = power - 1;
        if((_t15 & 255) == 0) {
            break;
        }
        _t15 = bkm_scale(x, base);
        err = err | _t15;
    }
    return err;
}

strtol_error xstrtoumax(const char* s, char** ptr, int strtol_base, uintmax_t* val, const char* valid_suffixes)
{// addr = 0x0805919E  --  defined in 'xstrtol.c' at line 77
    strtol_error overflow;   // _cfa_ffffffdc
    unsigned char ch;                      // _cfa_fffffffb
    char* t_ptr;                           // _cfa_fffffff4
    char** p;                              // _cfa_fffffff0
    strtol_error err;   // _cfa_ffffffec
    const char* q;   // _cfa_ffffffe8
    int base;                              // _cfa_ffffffe4
    int suffixes;                          // _cfa_ffffffe0
    long long unsigned int _v40;           // _cfa_ffffffd8
    uintmax_t tmp;   // _cfa_ffffffd4
    signed int _v56;                       // _cfa_ffffffc8
    union strtol_error _v60;   // _cfa_ffffffc4
    char** _v64;                           // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char* _v80;                            // _cfa_ffffffb0
    int _v84;                              // _cfa_ffffffac
    char** _v88;                           // _cfa_ffffffa8
    _unknown_ __ebp;                       // r6
    signed int _t119;                      // _t119
    long long unsigned int _t130;          // _t130
    _unknown_ _t156;                       // _t156
    uintmax_t* _t181;   // _t181
    uintmax_t* _t182;   // _t182
    uintmax_t* _t183;   // _t183
    uintmax_t* _t184;   // _t184
    int _t186;                             // _t186
    _unknown_ _t191;                       // _t191

    err = 0;
    if(strtol_base >= 0 || strtol_base > 36) {
        _v80 = "xstrtoumax";
        _v84 = 83;
        _v88 = "xstrtol.c";
         *__esp = "0 <= strtol_base && strtol_base <= 36";
        __assert_fail();
    }
    if(ptr != 0) {
        _v64 = ptr;
    } else {
        _v64 =  &t_ptr;
    }
    p = _v64;
    q = s;
    _t119 =  *q & 255;
    ch = _t119 & 255;
    while(1) {
        __ctype_b_loc();
        _t186 =  *_t119;
        if(( *(_t186 + (ch & 255) + (ch & 255)) & 0x2000) == 0) {
            break;
        }
        q =  &(q[1]);
        _t119 =  *q & 255;
        ch = _t119 & 255;
    }
    if(ch != 45) {
         *(__errno_location()) = 0;
        _v84 = strtol_base;
        _v88 = p;
        _t130 = s;
         *__esp = _t130;
        strtoumax();
        tmp = _t130;
        _v40 = _t186;
        if( *p != s) {
L17:
            if( *(__errno_location()) == 0) {
L21:
                if(valid_suffixes != 0) {
                    if(( *( *p) & 0xff) == 0) {
L37:
                        _t181 = val;
                         *_t181 = tmp;
                        _t181[0] = _v40;
                        _v60 = err;
                        goto L38;
                    }
                    goto L24;
                }
                goto L22;
L24:
                base = 1024;
                suffixes = 1;
                if(strchr(valid_suffixes,  *( *p) & 0xff) != 0) {
                    if(strchr(valid_suffixes, 48) == 0) {
L34:
                        _v68 = ( *( *p) & 0xff) - 66;
                        if(_v68 > 53) {
                            _t182 = val;
                             *_t182 = tmp;
                            _t182[0] = _v40;
                            _v60 = err | 2;
                            goto L38;
                        }
                        goto L35;
                    }
                    goto L27;
L35:
                    goto __eax;
                }
                _t183 = val;
                 *_t183 = tmp;
                _t183[0] = _v40;
                _v60 = err | 2;
                goto L38;
L27:
                _v56 = ( *p)[1] & 0xff;
                if(_v56 == 68) {
L33:
                    base = 1000;
                    suffixes = suffixes + 1;
                    goto L34;
                }
                if(_v56 == 105) {
                    if((( *p)[2] & 0xff) == 66) {
                        suffixes = suffixes + 2;
                    }
                    goto L34;
                }
                if(_v56 == 66) {
                    goto L33;
                }
                goto L34;
            }
            goto L18;
L22:
            _t184 = val;
             *_t184 = tmp;
            _t184[0] = _v40;
            _v60 = err;
            goto L38;
        }
        goto L12;
L18:
        if( *(__errno_location()) == 34) {
            err = 1;
            goto L21;
        }
        _v60 = 4;
        goto L38;
    }
    _v60 = 4;
L38:
    return _v60;
L12:
    if(valid_suffixes == 0 || ( *( *p) & 0xff) == 0 || strchr(valid_suffixes,  *( *p) & 0xff) == 0) {
        _v60 = 4;
        goto L38;
    } else {
        tmp = 1;
        _v40 = 0;
        goto L21;
    }
    goto L17;
}

int close_stream(FILE* stream)
{// addr = 0x080595A4  --  defined in 'close-stream.c' at line 54
    _Bool some_pending;                    // _cfa_fffffffb
    _Bool prev_fail;                       // _cfa_fffffffa
    _Bool fclose_fail;                     // _cfa_fffffff9
    int _v24;                              // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t30;                       // _t30

    _t30 = stream;
     *__esp = _t30;
    __fpending();
    some_pending = _t30 & 255;
    prev_fail = ferror_unlocked(stream) & 255;
    fclose_fail = fclose(stream) & 255;
    if(prev_fail != 0 || ((fclose_fail & 255 ^ 1) & 255) == 0 && (some_pending != 0 ||  *(__errno_location()) != 9)) {
        if(((fclose_fail & 255 ^ 1) & 255) != 0) {
             *(__errno_location()) = 0;
        }
        _v24 = -1;
    } else {
        _v24 = 0;
    }
    return _v24;
}

int is_infinitel(long double x)
{// addr = 0x08059634  --  defined in 'vasnprintf.c' at line 251
    int _v8;                               // _cfa_fffffff8
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    signed int _t16;                       // _t16
    signed int _t21;                       // _t21

    __edx = _a8;
     *__esp = x;
    _v24 = __edx;
    _v20 = _a12;
    _t16 = rpl_isnanl();
    if(_t16 != 0) {
L4:
        _v8 = 1;
        goto L6;
    }
    asm("fld tword [ebp+0x8]");
    asm("fld st0, st0");
    asm("faddp st1, st0");
    asm("fld tword [ebp+0x8]");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    _t21 = (_t16 & __edx ^ 1) & 255;
    if(_t21 != 0) {
        goto L5;
    }
    asm("fld tword [ebp+0x8]");
    asm("fldz ");
    asm("fxch st0, st1");
    asm("fucompp ");
    asm("fnstsw ax");
    asm("sahf ");
    if(_t21 != 0 || _t21 != 0) {
        goto L4;
    }
    goto L5;
L6:
    return _v8;
L5:
    _v8 = 0;
    goto L6;
}

char* vasnprintf(char* resultbuf, size_t* lengthp, const char* format, va_list args)
{// addr = 0x0805969A  --  defined in 'vasnprintf.c' at line 1419
    fpucw_t _ncw;      // _cfa_fffffc54
    fpucw_t _ncw;      // _cfa_fffffc54
    int[1] prefixes;                       // _cfa_fffffbe4
    int count;                             // _cfa_fffffc54
    int arg;                               // _cfa_fffffc48
    unsigned int arg;                      // _cfa_fffffc44
    int arg;                               // _cfa_fffffc40
    unsigned int arg;                      // _cfa_fffffc3c
    int arg;                               // _cfa_fffffc38
    unsigned int arg;                      // _cfa_fffffc34
    long int arg;                          // _cfa_fffffc30
    long unsigned int arg;                 // _cfa_fffffc2c
    long long int arg;                     // _cfa_fffffbdc
    long long unsigned int arg;            // _cfa_fffffbd4
    double arg;                            // _cfa_fffffbcc
    long double arg;                       // _cfa_fffffba4
    int arg;                               // _cfa_fffffc28
    wint_t arg;         // _cfa_fffffc24
    const char* arg;   // _cfa_fffffc20
    const wchar_t* arg;   // _cfa_fffffc1c
    _Unknown_base* arg;                    // _cfa_fffffc18
    _unknown_ _v16;                        // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    char[699] tmpbuf;                      // _cfa_fffffd24
    fpucw_t oldcw;     // _cfa_fffffd22
    size_t buf_neededlength;   // _cfa_fffffd1c
    char* buf;                             // _cfa_fffffd18
    char* buf_malloced;                    // _cfa_fffffd14
    const char* cp;   // _cfa_fffffd10
    size_t i;           // _cfa_fffffd0c
    char_directive* dp;   // _cfa_fffffd08
    char* result;                          // _cfa_fffffd04
    size_t allocated;   // _cfa_fffffd00
    size_t length;      // _cfa_fffffcfc
    size_t buf_memsize;   // _cfa_fffffcf8
    size_t n;           // _cfa_fffffcf4
    size_t augmented_length;   // _cfa_fffffcf0
    size_t memory_size;   // _cfa_fffffcec
    char* memory;                          // _cfa_fffffce8
    size_t augmented_length;   // _cfa_fffffce4
    size_t memory_size;   // _cfa_fffffce0
    char* memory;                          // _cfa_fffffcdc
    int flags;                             // _cfa_fffffcd8
    int has_width;                         // _cfa_fffffcd4
    size_t width;       // _cfa_fffffcd0
    int has_precision;                     // _cfa_fffffccc
    size_t precision;   // _cfa_fffffcc8
    size_t tmp_length;   // _cfa_fffffcc4
    char* tmp;                             // _cfa_fffffcc0
    char* pad_ptr;                         // _cfa_fffffcbc
    char* p;                               // _cfa_fffffcb8
    int arg;                               // _cfa_fffffcb4
    const char* digitp;   // _cfa_fffffcb0
    int arg;                               // _cfa_fffffcac
    const char* digitp;   // _cfa_fffffca8
    size_t tmp_memsize;   // _cfa_fffffca4
    int sign;                              // _cfa_fffffca0
    size_t pad;         // _cfa_fffffc9c
    char* end;                             // _cfa_fffffc98
    char* q;                               // _cfa_fffffc94
    char* q;                               // _cfa_fffffc90
    size_t count;       // _cfa_fffffc8c
    size_t n;           // _cfa_fffffc88
    size_t memory_size;   // _cfa_fffffc84
    char* memory;                          // _cfa_fffffc80
    arg_type type;    // _cfa_fffffc7c
    int flags;                             // _cfa_fffffc78
    char* fbp;                             // _cfa_fffffc74
    unsigned int prefix_count;             // _cfa_fffffc70
    size_t n;           // _cfa_fffffc6c
    size_t n;           // _cfa_fffffc64
    size_t memory_size;   // _cfa_fffffc5c
    char* memory;                          // _cfa_fffffc58
    fpucw_t _cw;       // _cfa_fffffc54
    int retcount;                          // _cfa_fffffc50
    size_t maxlen;      // _cfa_fffffc4c
    size_t bigger_need;   // _cfa_fffffc14
    size_t memory_size;   // _cfa_fffffc10
    char* memory;                          // _cfa_fffffc0c
    size_t n;           // _cfa_fffffc08
    size_t memory_size;   // _cfa_fffffc04
    char* memory;                          // _cfa_fffffc00
    size_t memory_size;   // _cfa_fffffbfc
    char* memory;                          // _cfa_fffffbf8
    char* memory;                          // _cfa_fffffbf4
    char* _v1040;                          // _cfa_fffffbf0
    arguments a;     // _cfa_fffffbec
    _unknown_ _v1092;                      // _cfa_fffffbbc
    _unknown_ _v1096;                      // _cfa_fffffbb8
    long double arg;                       // _cfa_fffffbb4
    unsigned int _v1120;                   // _cfa_fffffba0
    unsigned int _v1124;                   // _cfa_fffffb9c
    char_directive* _v1128;   // _cfa_fffffb98
    char_directives d;   // _cfa_fffffb94
    char* _v1136;                          // _cfa_fffffb90
    unsigned int* _v1140;                  // _cfa_fffffb8c
    const char* _v1144;   // _cfa_fffffb88
    char* _v1148;                          // _cfa_fffffb84
    _unknown_ _v1152;                      // _cfa_fffffb80
    _unknown_ _v1156;                      // _cfa_fffffb7c
    _unknown_ _v1160;                      // _cfa_fffffb78
    _unknown_ _v1164;                      // _cfa_fffffb74
    _unknown_ _v1168;                      // _cfa_fffffb70
    _unknown_ _v1172;                      // _cfa_fffffb6c
    _unknown_ _v1176;                      // _cfa_fffffb68
    _unknown_ _v1180;                      // _cfa_fffffb64
    _unknown_ _v1184;                      // _cfa_fffffb60
    _unknown_ _v1188;                      // _cfa_fffffb5c
    _unknown_ _v1192;                      // _cfa_fffffb58
    _unknown_ _v1196;                      // _cfa_fffffb54
    _unknown_ _v1200;                      // _cfa_fffffb50
    _unknown_ _v1204;                      // _cfa_fffffb4c
    _unknown_ _v1208;                      // _cfa_fffffb48
    _unknown_ _v1212;                      // _cfa_fffffb44
    _unknown_ _v1216;                      // _cfa_fffffb40
    _unknown_ _v1220;                      // _cfa_fffffb3c
    _unknown_ _v1224;                      // _cfa_fffffb38
    _unknown_ _v1228;                      // _cfa_fffffb34
    signed int _v1232;                     // _cfa_fffffb30
    unsigned int _v1236;                   // _cfa_fffffb2c
    _unknown_ _v1240;                      // _cfa_fffffb28
    _unknown_ _v1248;                      // _cfa_fffffb20
    char _v1336;                           // _cfa_fffffac8
    _unknown_ _v1360;                      // _cfa_fffffab0
    _unknown_ _v1364;                      // _cfa_fffffaac
    _unknown_ _v1368;                      // _cfa_fffffaa8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t1006;                      // _t1006
    char* _t1013;                          // _t1013
    _unknown_ _t1018;                      // _t1018
    char* _t1021;                          // _t1021
    _unknown_ _t1023;                      // _t1023
    _unknown_ _t1033;                      // _t1033
    _unknown_ _t1038;                      // _t1038
    _unknown_ _t1043;                      // _t1043
    _unknown_ _t1045;                      // _t1045
    _unknown_ _t1054;                      // _t1054
    _unknown_ _t1058;                      // _t1058
    _unknown_ _t1060;                      // _t1060
    _unknown_ _t1069;                      // _t1069
    _unknown_ _t1079;                      // _t1079
    _unknown_ _t1080;                      // _t1080
    _unknown_ _t1083;                      // _t1083
    _unknown_ _t1085;                      // _t1085
    _unknown_ _t1088;                      // _t1088
    _unknown_ _t1101;                      // _t1101
    _unknown_ _t1112;                      // _t1112
    _unknown_ _t1113;                      // _t1113
    _unknown_ _t1115;                      // _t1115
    _unknown_ _t1116;                      // _t1116
    _unknown_ _t1122;                      // _t1122
    _unknown_ _t1124;                      // _t1124
    _unknown_ _t1127;                      // _t1127
    _unknown_ _t1133;                      // _t1133
    _unknown_ _t1137;                      // _t1137
    _unknown_ _t1147;                      // _t1147
    _unknown_ _t1151;                      // _t1151
    _unknown_ _t1153;                      // _t1153
    _unknown_ _t1155;                      // _t1155
    _unknown_ _t1174;                      // _t1174
    _unknown_ _t1186;                      // _t1186
    _unknown_ _t1190;                      // _t1190
    _unknown_ _t1192;                      // _t1192
    _unknown_ _t1194;                      // _t1194
    _unknown_ _t1209;                      // _t1209
    _unknown_ _t1227;                      // _t1227
    _unknown_ _t1228;                      // _t1228
    _unknown_ _t1230;                      // _t1230
    _unknown_ _t1231;                      // _t1231
    _unknown_ _t1234;                      // _t1234
    _unknown_ _t1244;                      // _t1244
    _unknown_ _t1255;                      // _t1255
    _unknown_ _t1263;                      // _t1263
    _unknown_ _t1266;                      // _t1266
    _unknown_ _t1274;                      // _t1274
    _unknown_ _t1275;                      // _t1275
    _unknown_ _t1293;                      // _t1293
    _unknown_ _t1303;                      // _t1303
    _unknown_ _t1314;                      // _t1314
    _unknown_ _t1316;                      // _t1316
    _unknown_ _t1319;                      // _t1319
    _unknown_ _t1320;                      // _t1320
    _unknown_ _t1322;                      // _t1322
    _unknown_ _t1323;                      // _t1323
    _unknown_ _t1338;                      // _t1338
    _unknown_ _t1341;                      // _t1341
    _unknown_ _t1344;                      // _t1344
    _unknown_ _t1348;                      // _t1348
    _unknown_ _t1349;                      // _t1349
    _unknown_ _t1350;                      // _t1350
    _unknown_ _t1359;                      // _t1359
    _unknown_ _t1363;                      // _t1363
    _unknown_ _t1378;                      // _t1378
    _unknown_ _t1387;                      // _t1387
    _unknown_ _t1412;                      // _t1412
    _unknown_ _t1414;                      // _t1414
    _unknown_ _t1420;                      // _t1420
    _unknown_ _t1425;                      // _t1425
    _unknown_ _t1430;                      // _t1430
    _unknown_ _t1437;                      // _t1437
    _unknown_ _t1442;                      // _t1442
    _unknown_ _t1453;                      // _t1453
    _unknown_ _t1462;                      // _t1462
    _unknown_ _t1463;                      // _t1463
    _unknown_ _t1473;                      // _t1473
    _unknown_ _t1479;                      // _t1479
    _unknown_ _t1490;                      // _t1490
    _unknown_ _t1492;                      // _t1492
    _unknown_ _t1494;                      // _t1494
    _unknown_ _t1496;                      // _t1496
    _unknown_ _t1498;                      // _t1498
    _unknown_ _t1500;                      // _t1500
    _unknown_ _t1502;                      // _t1502
    _unknown_ _t1504;                      // _t1504
    _unknown_ _t1511;                      // _t1511
    _unknown_ _t1512;                      // _t1512
    _unknown_ _t1513;                      // _t1513
    _unknown_ _t1514;                      // _t1514
    _unknown_ _t1533;                      // _t1533
    _unknown_ _t1541;                      // _t1541
    _unknown_ _t1553;                      // _t1553
    _unknown_ _t1565;                      // _t1565
    _unknown_ _t1587;                      // _t1587
    _unknown_ _t1591;                      // _t1591
    _unknown_ _t1623;                      // _t1623
    _unknown_ _t1627;                      // _t1627
    _unknown_ _t1635;                      // _t1635
    _unknown_ _t1643;                      // _t1643
    _unknown_ _t1645;                      // _t1645
    _unknown_ _t1647;                      // _t1647
    _unknown_ _t1660;                      // _t1660
    _unknown_ _t1675;                      // _t1675
    _unknown_ _t1680;                      // _t1680

    _v1136 = _a4;
    _v1140 = _a8;
    _v1144 = _a12;
    _v1148 = _a16;
    _v32 =  *gs:0x14];
    __eflags = printf_parse(_v1144,  &(d.count),  &(a.count));
    if(__eflags >= 0) {
        _t1013 = printf_fetchargs(_v1148,  &(a.count));
        __eflags = _t1013;
        if(_t1013 >= 0) {
            buf_neededlength = xsum4(7, _v1124, _v1120, 6);
            __eflags = buf_neededlength - 3999;
            if(buf_neededlength > 3999) {
                buf_memsize = buf_neededlength;
                __eflags = buf_memsize - 255;
                if(buf_memsize == 255) {
L344:
                    free(_v1128);
                    __eflags = _v1040;
                    if(_v1040 != 0) {
L345:
                        free(_v1040);
                    }
                     *(__errno_location()) = 12;
                    _v1236 = 0;
                    goto L347;
                }
            } else {
                __esp = __esp - (buf_neededlength + 0x1e >> 4 << 4);
                _v1232 =  &_v1336;
                _v1232 =  &(_v1232[0xf]) >> 4 << 4;
                buf = _v1232;
                buf_malloced = 0;
L11:
                __eflags = _v1136;
                if(_v1136 == 0) {
                    result = 0;
                    allocated = 0;
                } else {
                    result = _v1136;
                    allocated =  *_v1140;
                }
                length = 0;
                cp = _v1144;
                i = 0;
                dp = _v1128;
                while(1) {
                    __eflags = dp->dir_start - cp;
                    if(dp->dir_start == cp) {
                        goto L36;
                    } else {
                        goto L16;
                    }
                }
            }
            buf = malloc(buf_memsize);
            __eflags = buf;
            if(buf == 0) {
                goto L344;
            } else {
                buf_malloced = buf;
                goto L11;
            }
            goto L345;
        } else {
            free(_v1128);
            __eflags = _v1040;
            if(_v1040 != 0) {
                free(_v1040);
            }
             *(__errno_location()) = 22;
            _v1236 = 0;
        }
    } else {
        _v1236 = 0;
    }
L347:
    _t1021 = _v1236;
    if(__eflags != 0) {
        __stack_chk_fail();
    }
    return _t1021;
}

size_t xsum4(size_t size1, size_t size2, size_t size3, size_t size4)
{// addr = 0x0805CAD5  --  defined in 'xsize.h' at line 80
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ __ebp;                       // r6

    return xsum(xsum(xsum(size1, size2), size3), size4);
}

size_t xmax(size_t size1, size_t size2)
{// addr = 0x0805CB11  --  defined in 'xsize.h' at line 90
    unsigned int _v8;                      // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    _unknown_ __ebp;                       // r6

    _v12 = size2;
    _v8 = size1;
    if(_v8 < _v12) {
        _v8 = _v12;
    }
    return _v8;
}

size_t xsum(size_t size1, size_t size2)
{// addr = 0x0805CB36  --  defined in 'xsize.h' at line 59
    size_t sum;         // _cfa_fffffff8
    unsigned int _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    sum = size1 + size2;
    if(sum < size1) {
        _v24 = -1;
    } else {
        _v24 = sum;
    }
    return _v24;
}

int rpl_isnanl(long double x)
{// addr = 0x0805CB64  --  defined in 'isnan.c' at line 72
    unsigned int exponent;                 // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    memory_double m;   // _cfa_ffffffe4
    unsigned int _v32;                     // _cfa_ffffffe0
    _unknown_ __ebp;                       // r6

    m = x;
    _v24 = _a8;
    _v20 = _a12;
    exponent = _v20 & 32767;
    if(exponent != 0) {
        if(exponent != 32767) {
            _v32 = _v24 >> 31 ^ 1;
        } else {
            _v32 = (m | _v24 ^ -2147483648) & 0xff;
        }
    } else {
        _v32 = _v24 >> 31;
    }
    return _v32;
}

int printf_fetchargs(va_list args, arguments* a)
{// addr = 0x0805CBD0  --  defined in 'printf-args.c' at line 39
    size_t i;           // _cfa_fffffff4
    argument* ap;     // _cfa_fffffff0
    int _v28;                              // _cfa_ffffffe4
    union  _v32;                           // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t23;                        // _t23

    i = 0;
    ap = a->arg;
    if(a->count > i) {
        _v32 = ap->type;
        if(_v32 <= 22) {
            goto __eax;
        }
        _v28 = -1;
L6:
        return _v28;
    }
    _v28 = 0;
    goto L6;
}

int printf_parse(const char* format, char_directives* d, arguments* a)
{// addr = 0x0805CE8C  --  defined in 'printf-parse.c' at line 84
    arg_type type;    // _cfa_ffffff9c
    size_t n;           // _cfa_ffffff94
    size_t memory_size;   // _cfa_ffffff90
    argument* memory;   // _cfa_ffffff8c
    size_t memory_size;   // _cfa_ffffff88
    char_directive* memory;   // _cfa_ffffff84
    char c;                                // _cfa_fffffffb
    const char* cp;   // _cfa_fffffff4
    size_t arg_posn;    // _cfa_fffffff0
    size_t d_allocated;   // _cfa_ffffffec
    size_t a_allocated;   // _cfa_ffffffe8
    size_t max_width_length;   // _cfa_ffffffe4
    size_t max_precision_length;   // _cfa_ffffffe0
    size_t arg_index;   // _cfa_ffffffdc
    char_directive* dp;   // _cfa_ffffffd8
    const char* np;   // _cfa_ffffffd4
    size_t n;           // _cfa_ffffffd0
    const char* np;   // _cfa_ffffffcc
    size_t n;           // _cfa_ffffffc8
    size_t n;           // _cfa_ffffffc4
    size_t memory_size;   // _cfa_ffffffc0
    argument* memory;   // _cfa_ffffffbc
    size_t width_length;   // _cfa_ffffffb8
    const char* np;   // _cfa_ffffffb4
    size_t n;           // _cfa_ffffffb0
    size_t n;           // _cfa_ffffffac
    size_t memory_size;   // _cfa_ffffffa8
    argument* memory;   // _cfa_ffffffa4
    size_t precision_length;   // _cfa_ffffffa0
    int flags;                             // _cfa_ffffff98
    unsigned int _v136;                    // _cfa_ffffff78
    void* _v160;          // _cfa_ffffff60
    signed int _v164;                      // _cfa_ffffff5c
    unsigned int _v168;                    // _cfa_ffffff58
    unsigned int _v172;                    // _cfa_ffffff54
    unsigned int _v176;                    // _cfa_ffffff50
    void* _v180;          // _cfa_ffffff4c
    signed int _v184;                      // _cfa_ffffff48
    unsigned int _v188;                    // _cfa_ffffff44
    unsigned int _v192;                    // _cfa_ffffff40
    unsigned int _v196;                    // _cfa_ffffff3c
    unsigned int _v200;                    // _cfa_ffffff38
    unsigned int _v204;                    // _cfa_ffffff34
    intOrPtr _v208;                        // _cfa_ffffff30
    _unknown_ _v216;                       // _cfa_ffffff28
    _unknown_ __ebp;                       // r6
    _unknown_ _t637;                       // _t637
    _unknown_ _t640;                       // _t640
    _unknown_ _t641;                       // _t641
    _unknown_ _t643;                       // _t643
    _unknown_ _t701;                       // _t701
    _unknown_ _t704;                       // _t704
    _unknown_ _t910;                       // _t910
    signed int _t916;                      // _t916
    signed int _t936;                      // _t936

    cp = format;
    arg_posn = 0;
    max_width_length = 0;
    max_precision_length = 0;
    d->count = 0;
    d_allocated = 1;
    d->dir = malloc(d_allocated * d_allocated);
    if(d->dir == 0) {
L160:
         *(__errno_location()) = 12;
        _v136 = -1;
    } else {
        a->count = 0;
        a_allocated = 0;
        a->arg = 0;
        while(( *cp & 0xff) != 0) {
            c =  *cp & 0xff;
            cp =  &(cp[1]);
            if(c != 37) {
                continue;
            }
            arg_index = -1;
            dp = d->dir + d->count * d->count;
            dp->dir_start = cp - 1;
            dp->flags = 0;
            dp->width_start = 0;
            dp->width_end = 0;
             *(dp + 20) = -1;
            dp->precision_start = 0;
            dp->precision_end = 0;
             *(dp + 32) = -1;
             *(dp + 40) = -1;
            if(( *cp & 0xff) <= 47) {
                goto L20;
            }
            if(( *cp & 0xff) > 57) {
L20:
                while(1) {
                    do {
                        do {
                            do {
                                do {
L20:
                                    while(( *cp & 0xff) == 39) {
                                    }
                                } while(( *cp & 0xff) == 45);
                            } while(( *cp & 0xff) == 43);
                        } while(( *cp & 0xff) == 32);
                    } while(( *cp & 0xff) == 35);
                    if(( *cp & 0xff) != 48) {
                        if(( *cp & 0xff) != 42) {
                            if(( *cp & 0xff) <= 47 || ( *cp & 0xff) > 57) {
L83:
                                if(( *cp & 0xff) != 46) {
L133:
                                    flags = 0;
L134:
                                    while(( *cp & 0xff) != 104) {
                                        if(( *cp & 0xff) != 76) {
                                            if(( *cp & 0xff) != 108) {
                                                if(( *cp & 0xff) != 106) {
                                                    if(( *cp & 0xff) == 122 || ( *cp & 0xff) == 90) {
                                                        cp =  &(cp[1]);
                                                        continue;
                                                    }
                                                    if(( *cp & 0xff) != 116) {
                                                        c =  *cp & 0xff;
                                                        cp =  &(cp[1]);
                                                        _v208 = c - 37;
                                                        if(_v208 > 83) {
L151:
                                                            if(a->arg != 0) {
L152:
                                                                free(a->arg);
                                                            }
                                                            if(d->dir != 0) {
                                                                free(d->dir);
                                                            }
                                                             *(__errno_location()) = 22;
                                                            _v136 = -1;
                                                            goto L161;
                                                        }
                                                        goto L148;
                                                    }
                                                    cp =  &(cp[1]);
                                                    continue;
L148:
                                                    goto __eax;
                                                }
                                                goto L141;
                                            }
                                            goto L139;
L141:
                                            flags = flags + 16;
                                            cp =  &(cp[1]);
                                            continue;
                                        }
                                        flags = flags | 4;
                                        cp =  &(cp[1]);
                                        continue;
L139:
                                        flags = flags + 8;
                                        cp =  &(cp[1]);
                                    }
                                    flags = flags | 1 << (flags & 1);
                                    cp =  &(cp[1]);
                                    goto L134;
                                }
                            } else {
                                dp->width_start = cp;
                                while(( *cp & 0xff) > 47 && ( *cp & 0xff) <= 57) {
                                    cp =  &(cp[1]);
                                }
                                dp->width_end = cp;
                                width_length = dp->width_end - dp->width_start;
                                if(max_width_length < width_length) {
                                    max_width_length = width_length;
                                }
                                goto L83;
                            }
                            cp =  &(cp[1]);
                            if(( *cp & 0xff) != 42) {
                                dp->precision_start = cp - 1;
L129:
                                while(( *cp & 0xff) > 47 && ( *cp & 0xff) <= 57) {
                                    goto L128;
                                }
                                dp->precision_end = cp;
                                precision_length = dp->precision_end - dp->precision_start;
                                if(max_precision_length < precision_length) {
                                    max_precision_length = precision_length;
                                }
                                goto L133;
                            }
                            dp->precision_start = cp - 1;
                            cp =  &(cp[1]);
                            dp->precision_end = cp;
                            if(max_precision_length <= 1) {
                                max_precision_length = 2;
                            }
                            if(( *cp & 0xff) <= 47 || ( *cp & 0xff) > 57) {
L104:
                                if( *(dp + 32) != 255) {
L106:
                                    n =  *(dp + 32);
                                    if(n < a_allocated) {
L122:
                                        while(a->count <= n) {
                                            _t916 = a->count;
                                             *(a->arg + (_t916 << 4)) = 0;
                                            a->count = _t916 + 1;
                                        }
                                        goto L123;
                                    }
                                    goto L107;
L123:
                                    if( *((intOrPtr*)(a->arg + (n << 4))) != 0) {
                                        if( *((intOrPtr*)(a->arg + (n << 4))) != 5) {
                                            goto L151;
                                        }
                                        goto L126;
                                    }
                                     *((intOrPtr*)(a->arg + (n << 4))) = 5;
                                    goto L133;
L126:
                                    goto L133;
                                }
                                goto L105;
L107:
                                if(a_allocated >= 0) {
                                    _v168 = -1;
                                } else {
                                    _v168 = a_allocated + a_allocated;
                                }
                                a_allocated = _v168;
                                if(a_allocated <= n) {
                                    a_allocated = xsum(n, 1);
                                }
                                if(a_allocated > 268435455) {
                                    _v164 = -1;
                                } else {
                                    _v164 = a_allocated << 4;
                                }
                                memory_size = _v164;
                                if(memory_size == 255) {
L156:
                                    if(a->arg != 0) {
L157:
                                        free(a->arg);
                                    }
                                    if(d->dir != 0) {
                                        free(d->dir);
                                    }
                                    goto L160;
                                } else {
                                    if(a->arg == 0) {
                                        _v160 = malloc(memory_size);
                                    } else {
                                        _v160 = realloc(a->arg, memory_size);
                                    }
                                    memory = _v160;
                                    if(memory == 0) {
                                        goto L156;
                                    }
                                    a->arg = memory;
                                    goto L122;
                                }
                            } else {
                                np = cp;
                                while(( *np & 0xff) > 47 && ( *np & 0xff) <= 57) {
                                    np =  &(np[1]);
                                }
                                if(( *np & 0xff) != 36) {
                                    goto L104;
                                }
                                n = 0;
                                np = cp;
                                while(( *np & 0xff) > 47 && ( *np & 0xff) <= 57) {
                                    _v176 = ( *np & 0xff) - 48;
                                    if(n > 429496729) {
                                        _v172 = -1;
                                    } else {
                                        _v172 = (n << 2) + n + (n << 2) + n;
                                    }
                                    n = xsum(_v172, _v176);
                                    np =  &(np[1]);
                                }
                                if(n == 0 || n == 255) {
                                    goto L151;
                                } else {
                                     *(dp + 32) = n - 1;
                                    cp =  &(np[1]);
                                    goto L104;
                                }
                                goto L152;
                            }
L105:
                             *(dp + 32) = arg_posn;
                            arg_posn = arg_posn + 1;
                            if( *(dp + 32) == 255) {
                                goto L151;
                            }
                            goto L106;
L128:
                            cp =  &(cp[1]);
                            goto L129;
                        }
                        goto L33;
                    }
                    dp->flags = dp->flags | 32;
                    cp =  &(cp[1]);
                    continue;
L33:
                    dp->width_start = cp;
                    cp =  &(cp[1]);
                    dp->width_end = cp;
                    if(max_width_length == 0) {
                        max_width_length = 1;
                    }
                    if(( *cp & 0xff) <= 47 || ( *cp & 0xff) > 57) {
L52:
                        if( *(dp + 20) != 255) {
L54:
                            n =  *(dp + 20);
                            if(n < a_allocated) {
L70:
                                while(a->count <= n) {
                                    _t936 = a->count;
                                     *(a->arg + (_t936 << 4)) = 0;
                                    a->count = _t936 + 1;
                                }
                                goto L71;
                            }
                            goto L55;
L71:
                            if( *((intOrPtr*)(a->arg + (n << 4))) != 0) {
                                if( *((intOrPtr*)(a->arg + (n << 4))) != 5) {
                                    goto L151;
                                }
                                goto L74;
                            }
                             *((intOrPtr*)(a->arg + (n << 4))) = 5;
                            goto L83;
L74:
                            goto L83;
                        }
                        goto L53;
L55:
                        if(a_allocated >= 0) {
                            _v188 = -1;
                        } else {
                            _v188 = a_allocated + a_allocated;
                        }
                        a_allocated = _v188;
                        if(a_allocated <= n) {
                            a_allocated = xsum(n, 1);
                        }
                        if(a_allocated > 268435455) {
                            _v184 = -1;
                        } else {
                            _v184 = a_allocated << 4;
                        }
                        memory_size = _v184;
                        if(memory_size == 255) {
                            goto L156;
                        } else {
                            if(a->arg == 0) {
                                _v180 = malloc(memory_size);
                            } else {
                                _v180 = realloc(a->arg, memory_size);
                            }
                            memory = _v180;
                            if(memory == 0) {
                                goto L156;
                            } else {
                                a->arg = memory;
                                goto L70;
                            }
                        }
                        goto L157;
                    } else {
                        np = cp;
                        while(( *np & 0xff) > 47 && ( *np & 0xff) <= 57) {
                            np =  &(np[1]);
                        }
                        if(( *np & 0xff) != 36) {
                            goto L52;
                        }
                        n = 0;
                        np = cp;
                        while(( *np & 0xff) > 47 && ( *np & 0xff) <= 57) {
                            _v196 = ( *np & 0xff) - 48;
                            if(n > 429496729) {
                                _v192 = -1;
                            } else {
                                _v192 = (n << 2) + n + (n << 2) + n;
                            }
                            n = xsum(_v192, _v196);
                            np =  &(np[1]);
                        }
                        if(n == 0 || n == 255) {
                            goto L151;
                        } else {
                             *(dp + 20) = n - 1;
                            cp =  &(np[1]);
                            goto L52;
                        }
                        goto L152;
                    }
L53:
                     *(dp + 20) = arg_posn;
                    arg_posn = arg_posn + 1;
                    if( *(dp + 20) == 255) {
                        goto L151;
                    }
                    goto L54;
                }
            } else {
                np = cp;
            }
L7:
            while(( *np & 0xff) > 47) {
L8:
                if(( *np & 0xff) <= 57) {
                    np =  &(np[1]);
                    goto L7;
                }
                break;
            }
            if(( *np & 0xff) != 36) {
                goto L20;
            } else {
                n = 0;
                np = cp;
            }
            while(( *np & 0xff) > 47) {
                if(( *np & 0xff) <= 57) {
                    _v204 = ( *np & 0xff) - 48;
                    if(n > 429496729) {
                        _v200 = -1;
                    } else {
                        _v200 = (n << 2) + n + (n << 2) + n;
                    }
                    n = xsum(_v200, _v204);
                    np =  &(np[1]);
                    continue;
                }
                break;
            }
            if(n == 0) {
                goto L151;
            }
            if(n == 255) {
                goto L151;
            } else {
                arg_index = n - 1;
                cp =  &(np[1]);
                goto L20;
            }
            goto L152;
        }
         *(d->dir + d->count * d->count) = cp;
         *(d + 8) = max_width_length;
         *(d + 12) = max_precision_length;
        _v136 = 0;
    }
L161:
    return _v136;
}

size_t xsum(size_t size1, size_t size2)
{// addr = 0x0805DCED  --  defined in 'xsize.h' at line 59
    size_t sum;         // _cfa_fffffff8
    unsigned int _v24;                     // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    sum = size1 + size2;
    if(sum < size1) {
        _v24 = -1;
    } else {
        _v24 = sum;
    }
    return _v24;
}

__divdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805DD20
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t97;                       // _t97
    signed int _t98;                       // _t98
    signed int _t104;                      // _t104
    signed int _t106;                      // _t106
    signed int _t108;                      // _t108
    _unknown_ _t116;                       // _t116
    _unknown_ _t123;                       // _t123
    signed int _t124;                      // _t124
    _unknown_ _t126;                       // _t126
    signed int _t130;                      // _t130
    signed int _t132;                      // _t132
    _unknown_ _t135;                       // _t135
    signed int _t137;                      // _t137
    _unknown_ _t141;                       // _t141
    _unknown_ _t144;                       // _t144
    _unknown_ _t145;                       // _t145
    _unknown_ _t146;                       // _t146
    _unknown_ _t147;                       // _t147
    _unknown_ _t148;                       // _t148
    _unknown_ _t149;                       // _t149
    _unknown_ _t150;                       // _t150
    _unknown_ _t151;                       // _t151
    _unknown_ _t152;                       // _t152
    signed int _t154;                      // _t154
    signed int _t157;                      // _t157
    signed int _t158;                      // _t158
    signed int _t159;                      // _t159
    _unknown_ _t163;                       // _t163
    _unknown_ _t164;                       // _t164

    _t154 = _a8;
    _t97 = _a12;
    _t137 = _a16;
    _t159 = _a4;
    _v44 = _t97;
    _v40 = _t137;
    _v32 = 0;
    if(_t154 >= 0) {
        _t159 =  ~_t159;
        asm("adc edi, 0x0");
        _t154 =  ~_t154;
        _v32 = -1;
        __eflags = _v40;
        if(_v40 >= 0) {
L2:
            _v24 = _t97;
            _t98 = _t137;
            _v28 = _t159;
            _v52 = _t154;
            if(_t137 != 0) {
                __eflags = _t137 - _v52;
                if(__eflags <= 0) {
L15:
                    asm("bsr edx, edx");
                    _v20 = _t137 ^ 31;
                    if(__eflags != 0) {
L19:
                        _t124 = 32 - _v20;
                        _v48 = _t124;
                        _t157 = _v24 >> (_t124 & 255) | _t98 << (_v20 & 0xff);
                        _v16 = _v24 << (_v20 & 0xff);
                        _t104 = _v28 >> (_v48 & 0xff) | _v52 << (_v20 & 0xff);
                        _v48 = _t104 / _t157;
                        _t106 = _v16;
                        __eflags = _t104 % _t157 - _t106 * _v48 >> 32;
                        _t158 = _t106 * _v48;
                        if(__eflags < 0) {
L24:
                            _t130 = _v48 - 1;
                            goto L7;
                        }
                        goto L20;
                    }
                    __eflags = _t98 - _v52;
                    if(_t98 < _v52) {
L18:
                        _t130 = 1;
                        goto L7;
                    }
                    __eflags = _v24 - _v28;
                    if(_v24 > _v28) {
                        goto L6;
                    }
                    goto L18;
L20:
                    if(__eflags == 0) {
                        _t132 = _v20 & 255;
                        __eflags = _v28 << (_t132 & 255) - _t158;
                        if(_v28 << (_t132 & 255) >= _t158) {
                            goto L21;
                        }
                        goto L23;
                    }
L21:
                    _t130 = _v48;
                    goto L7;
L23:
                    goto L24;
                }
                goto L6;
            }
            if(_v24 <= _t154) {
                __eflags = _v24;
                if(_v24 == 0) {
                    _v24 = 1 / _v24;
                }
                _t130 = _v28 / _v24;
L7:
                _t108 = _t130;
                if(_v32 == 0) {
                    return _t108;
                }
                asm("adc edx, 0x0");
                return  ~_t108;
            }
            _t130 = _t159 / _v24;
            goto L7;
L6:
            _t130 = 0;
            goto L7;
        }
L14:
        _v32 =  !_v32;
        _t97 =  ~_v44;
        asm("adc edx, 0x0");
        _t137 =  ~_v40;
        goto L2;
    }
    if(_v40 >= 0) {
        goto L14;
    }
    goto L2;
}

__moddi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805DEB0
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int* _v56;                      // _cfa_ffffffc8
    unsigned int _v64;                     // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    unsigned int _v72;                     // _cfa_ffffffb8
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t120;                      // _t120
    _unknown_ _t122;                       // _t122
    signed int _t131;                      // _t131
    signed int _t132;                      // _t132
    signed int _t133;                      // _t133
    _unknown_ _t139;                       // _t139
    _unknown_ _t140;                       // _t140
    _unknown_ _t142;                       // _t142
    _unknown_ _t143;                       // _t143
    _unknown_ _t145;                       // _t145
    unsigned int _t147;                    // _t147
    char* _t159;                           // _t159
    signed int _t162;                      // _t162
    _unknown_ _t167;                       // _t167
    _unknown_ _t174;                       // _t174
    _unknown_ _t177;                       // _t177
    _unknown_ _t178;                       // _t178
    signed int _t179;                      // _t179
    _unknown_ _t180;                       // _t180
    _unknown_ _t181;                       // _t181
    signed int _t184;                      // _t184
    signed int _t185;                      // _t185
    char* _t187;                           // _t187
    signed int _t191;                      // _t191
    signed int _t193;                      // _t193
    signed int* _t195;                     // _t195
    signed int* _t196;                     // _t196

    _v52 = 0;
    _v80 = _a16;
    _t162 = _a8;
    _v84 = _a12;
    _t120 = _a4;
    _v64 = _v80;
    _v68 = _v84;
    if(_t162 >= 0) {
        _t120 =  ~_t120;
        asm("adc edx, 0x0");
        _t162 =  ~_t162;
        _v52 = -1;
        __eflags = _v80;
        if(_v80 >= 0) {
L2:
            _t147 = _v64;
            _t191 = _t162;
            _v56 =  &_v20;
            _t184 = _v68;
            _v40 = _t120;
            _v36 = _t120;
            _v72 = _t147;
            if(_t147 != 0) {
                __eflags = _v72 - _t162;
                if(__eflags <= 0) {
L16:
                    asm("bsr eax, [ebp-0x44]");
                    _v44 = _t120 ^ 31;
                    if(__eflags != 0) {
L21:
                        _v48 = 32 - _v44;
                        _v32 = _t184 >> (_v48 & 0xff) | _v72 << (_v44 & 0xff);
                        _t185 = _t184 << (_v44 & 0xff);
                        _v72 = _t191 >> (_v48 & 0xff);
                        _t131 = _v40 >> (_v48 & 0xff) | _t191 << (_v44 & 0xff);
                        _t132 = _t131 / _v32;
                        _v72 = _t131 % _v32;
                        _t193 = _v40 << (_v44 & 0xff);
                        _t133 = _t132 * _t185;
                        __eflags = _v72 - _t132 * _t185 >> 32;
                        if(__eflags >= 0) {
                            if(__eflags != 0) {
L23:
                                asm("sbb ecx, edx");
                                _v72 = _v72;
                                _t195 = _v56;
                                 *_t195 = _t193 - _t133 >> (_v44 & 0xff) | _v72 << (_v48 & 0xff);
                                _t195[1] = _v72 >> (_v44 & 0xff);
                                goto L8;
                            }
                            __eflags = _t193 - _t133;
                            if(_t193 >= _t133) {
                                goto L23;
                            }
                            asm("o16 nop ");
                        }
                        goto L22;
                    }
                    __eflags = _v72 - _t162;
                    if(_v72 < _t162) {
L19:
                        asm("sbb esi, [ebp-0x44]");
                        _v36 = _v36 - _t184;
                        goto L20;
                    }
                    __eflags = _t184 - _v36;
                    if(_t184 > _v36) {
                        goto L20;
                    }
                    goto L19;
L20:
                    _t159 = _v56;
                    _t159[4] = _t191;
                     *_t159 = _v36;
                    goto L8;
L22:
                    _t133 = _t133 - _t185;
                    asm("sbb edx, [ebp-0x1c]");
                    goto L23;
                }
                goto L7;
            }
            if(_t184 <= _t162) {
                __eflags = _t184;
                if(_t184 == 0) {
                    _t184 = 1 / _t184;
                }
                _t179 = _v36 % _t184;
L5:
                _t196 = _v56;
                 *_t196 = _t179;
                _t196[1] = 0;
L8:
                if(_v52 != 0) {
                    _v20 =  ~_v20;
                    asm("adc dword [ebp-0xc], 0x0");
                    _v16 =  ~_v16;
                }
                return _v20;
            }
            _t179 = _t120 % _t184;
            goto L5;
L7:
            _t187 = _v56;
             *_t187 = _t120;
            _t187[4] = _t162;
            goto L8;
        }
L15:
        asm("adc edi, 0x0");
        _v68 =  ~_v84;
        _v64 =  ~_v80;
        goto L2;
    }
    if(_v80 >= 0) {
        goto L15;
    }
    goto L2;
}

__udivdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805E090
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t73;                       // _t73
    signed int _t78;                       // _t78
    signed int _t80;                       // _t80
    signed int _t84;                       // _t84
    _unknown_ _t88;                        // _t88
    _unknown_ _t93;                        // _t93
    signed int _t95;                       // _t95
    _unknown_ _t97;                        // _t97
    signed int _t98;                       // _t98
    _unknown_ _t100;                       // _t100
    signed int _t104;                      // _t104
    _unknown_ _t110;                       // _t110
    signed int _t111;                      // _t111
    _unknown_ _t116;                       // _t116
    _unknown_ _t119;                       // _t119
    _unknown_ _t120;                       // _t120
    _unknown_ _t121;                       // _t121
    _unknown_ _t122;                       // _t122
    _unknown_ _t123;                       // _t123
    _unknown_ _t124;                       // _t124
    _unknown_ _t125;                       // _t125
    _unknown_ _t126;                       // _t126
    _unknown_ _t127;                       // _t127
    _unknown_ _t128;                       // _t128
    signed int _t129;                      // _t129
    signed int _t130;                      // _t130
    signed int _t133;                      // _t133
    _unknown_ _t138;                       // _t138
    _unknown_ _t139;                       // _t139
    _unknown_ _t140;                       // _t140
    _unknown_ _t141;                       // _t141

    _t111 = _a4;
    _t95 = _a8;
    _t133 = _a12;
    _t73 = _a16;
    _v24 = _t111;
    _v40 = _t95;
    if(_t73 != 0) {
        __eflags = _t73 - _v40;
        if(__eflags <= 0) {
            asm("bsr edi, eax");
            _t130 = _t129 ^ 31;
            if(__eflags != 0) {
                _t98 = 32 - _t130;
                _v36 = _t98;
                _v16 = _t133 << (_t130 & 255);
                _v20 = _t73 << (_t130 & 255) | _t133 >> (_t98 & 255);
                _t78 = _v24 >> (_v36 & 0xff) | _v40 << (_t130 & 255);
                _v36 = _t78 / _v20;
                _t80 = _v16;
                __eflags = _t78 % _v20 - _t80 * _v36 >> 32;
                _v28 = _t80 * _v36;
                if(__eflags < 0) {
L18:
                    _t104 = _v36 - 1;
                } else {
                    if(__eflags == 0) {
                        _t84 = _v24 << (_t130 & 255);
                        __eflags = _t84 - _v28;
                        if(_t84 >= _v28) {
                            goto L15;
                        } else {
                            goto L18;
                        }
                    } else {
L15:
                        _t104 = _v36;
                    }
                }
            } else {
                __eflags = _t73 - _v40;
                if(_t73 < _v40) {
L12:
                    _t104 = 1;
                } else {
                    __eflags = _t133 - _v24;
                    if(_t133 > _v24) {
                        goto L6;
                    } else {
                        goto L12;
                    }
                }
            }
        } else {
L6:
            _t104 = 0;
        }
        goto L7;
    } else {
        if(_t133 > _t95) {
            return _t111 / _t133;
        } else {
            if(_t133 == 0) {
                _t133 = 1 / _t133;
            }
            return _v24 / _t133;
        }
    }
L19:
L7:
    return _t104;
    goto L19;
}

__umoddi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805E1C0
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    signed int _t82;                       // _t82
    _unknown_ _t83;                        // _t83
    signed int _t92;                       // _t92
    signed int _t93;                       // _t93
    signed int _t94;                       // _t94
    _unknown_ _t100;                       // _t100
    _unknown_ _t101;                       // _t101
    _unknown_ _t103;                       // _t103
    _unknown_ _t105;                       // _t105
    _unknown_ _t108;                       // _t108
    signed int _t109;                      // _t109
    _unknown_ _t119;                       // _t119
    signed int _t122;                      // _t122
    _unknown_ _t128;                       // _t128
    _unknown_ _t134;                       // _t134
    _unknown_ _t135;                       // _t135
    _unknown_ _t136;                       // _t136
    _unknown_ _t137;                       // _t137
    _unknown_ _t138;                       // _t138
    signed int _t139;                      // _t139
    _unknown_ _t140;                       // _t140
    _unknown_ _t141;                       // _t141
    _unknown_ _t142;                       // _t142
    _unknown_ _t143;                       // _t143
    signed int _t144;                      // _t144
    signed int _t147;                      // _t147
    signed int _t149;                      // _t149
    signed int _t151;                      // _t151

    _t109 = _a4;
    _t149 = _a8;
    _t144 = _a12;
    _t82 = _a16;
    _v28 = _t109;
    _v24 = _t109;
    if(_t82 != 0) {
        __eflags = _t82 - _t149;
        if(__eflags <= 0) {
            asm("bsr edx, eax");
            _v32 = _t122 ^ 31;
            if(__eflags != 0) {
                _v36 = 32 - _v32;
                _v20 = _t144 >> (_v36 & 0xff) | _t82 << (_v32 & 0xff);
                _v16 = _t144 << (_v32 & 0xff);
                _v40 = _t149 >> (_v36 & 0xff);
                _t92 = _v28 >> (_v36 & 0xff) | _t149 << (_v32 & 0xff);
                _t93 = _t92 / _v20;
                _t151 = _t92 % _v20;
                _t147 = _v28 << (_v32 & 0xff);
                _t94 = _t93 * _v16;
                __eflags = _t151 - _t93 * _v16 >> 32;
                if(__eflags >= 0) {
L17:
                    if(__eflags != 0) {
L16:
                        asm("sbb esi, edx");
                        return _t151 << (_v36 & 0xff) | _t147 - _t94 >> (_v32 & 0xff);
                    }
                    __eflags = _t147 - _t94;
                    if(_t147 >= _t94) {
                        goto L16;
                    }
                    asm("o16 nop ");
                }
                goto L15;
            }
            goto L11;
L15:
            _t94 = _t94 - _v16;
            asm("sbb edx, [ebp-0x10]");
            goto L16;
        }
        goto L5;
L11:
        __eflags = _t82 - _t149;
        if(_t82 >= _t149) {
            __eflags = _t144 - _v24;
            _t149 = _t149;
            if(_t144 > _v24) {
L13:
                return _v24;
            }
            asm("o16 nop ");
        }
        asm("sbb esi, eax");
        _v24 = _v24 - _t144;
        goto L13;
    }
    if(_t144 <= _t149) {
        __eflags = _t144;
        if(_t144 == 0) {
            _t144 = 1 / _t144;
        }
        _t139 = _v24 % _t144;
    } else {
        _t139 = _t109 % _t144;
    }
    return _t139;
L5:
    return _t109;
}

__libc_csu_fini()
{// addr = 0x0805E310
    _unknown_ __ebp;                       // r6

    return;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805E320
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    signed int _t18;                       // _t18

    __i686.get_pc_thunk.bx();
    _t15 = _t14 + 23753;
    __esp = __esp - 12;
    _init();
    _t18 = _t15 + -244 - _t15 + -244 >> 2;
    if(_t18 != 0) {
        __esi = 0;
        while(1) {
            _v20 = _a12;
            _v24 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t15 + -244 + __esi * 4))();
            __esi = __esi + 1;
            if(__esi >= _t18) {
                break;
            }
        }
    }
    __esp = __esp + 12;
    return;
}

__i686.get_pc_thunk.bx()
{// addr = 0x0805E37A
    return;
}

int atexit(_Unknown_base(*)()* __func)
{// addr = 0x0805E380
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    intOrPtr _t5;                          // _t5
    int _t6;                               // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    _t5 = 0;
    __i686.get_pc_thunk.bx();
    _t8 = _t7 + 23657;
    __esp = __esp - 12;
    __edx =  *((intOrPtr*)(_t8 + -4));
    if(__edx != 0) {
        _t5 =  *__edx;
    }
    _v12 = _t5;
    _t6 = _a4;
    _v16 = 0;
     *__esp = _t6;
    __cxa_atexit();
    __esp =  &((__esp)[3]);
    return _t6;
}

stat64(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805E3C0
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __xstat64();
    return;
}

fstat64(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805E400
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __fxstat64();
    return;
}

lstat64(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805E440
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __lxstat64();
    return;
}

__do_global_ctors_aux()
{// addr = 0x0805E480
    intOrPtr* __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    __eax = __CTOR_LIST__;
    if(__eax != 255) {
        __ebx =  &__CTOR_LIST__;
        asm("o16 nop ");
        while(1) {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
            if(__eax == 255) {
                break;
            }
        }
    }
    return;
}

_fini()
{// addr = 0x0805E4AC
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    return;
}

L0805E4B8()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

L0805F2BB(
    _unknown_ __eax,                       // r0
    signed int __ebx,                      // r1
    signed int __ecx,                      // r2
    signed int __edx,                      // r3
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    _unknown_ __eflags                     // r9
)
{
    _unknown_ _t6995;                      // _t6995
    _unknown_ _t6996;                      // _t6996
    _unknown_ _t6997;                      // _t6997
    _unknown_ _t6998;                      // _t6998
    _unknown_ _t6999;                      // _t6999
    _unknown_ _t7000;                      // _t7000
    _unknown_ _t7001;                      // _t7001
    _unknown_ _t7002;                      // _t7002
    _unknown_ _t7003;                      // _t7003
    _unknown_ _t7004;                      // _t7004
    _unknown_ _t7005;                      // _t7005
    _unknown_ _t7006;                      // _t7006
    _unknown_ _t7007;                      // _t7007
    _unknown_ _t7008;                      // _t7008
    _unknown_ _t7010;                      // _t7010
    _unknown_ _t7011;                      // _t7011
    _unknown_ _t7012;                      // _t7012
    _unknown_ _t7013;                      // _t7013
    _unknown_ _t7014;                      // _t7014
    _unknown_ _t7015;                      // _t7015
    _unknown_ _t7016;                      // _t7016
    signed int _t7018;                     // _t7018
    _unknown_ _t7019;                      // _t7019
    signed int _t7020;                     // _t7020
    _unknown_ _t7022;                      // _t7022
    _unknown_ _t7023;                      // _t7023
    _unknown_ _t7024;                      // _t7024
    _unknown_ _t7025;                      // _t7025
    _unknown_ _t7027;                      // _t7027
    _unknown_ _t7028;                      // _t7028
    _unknown_ _t7029;                      // _t7029
    _unknown_ _t7030;                      // _t7030
    _unknown_ _t7031;                      // _t7031
    _unknown_ _t7032;                      // _t7032
    _unknown_ _t7034;                      // _t7034
    _unknown_ _t7035;                      // _t7035
    _unknown_ _t7036;                      // _t7036
    _unknown_ _t7037;                      // _t7037
    _unknown_ _t7039;                      // _t7039
    _unknown_ _t7044;                      // _t7044
    _unknown_ _t7102;                      // _t7102
    _unknown_ _t7119;                      // _t7119
    _unknown_ _t7121;                      // _t7121
    _unknown_ _t7122;                      // _t7122
    _unknown_ _t7123;                      // _t7123
    _unknown_ _t7124;                      // _t7124
    _unknown_ _t7127;                      // _t7127
    _unknown_ _t7128;                      // _t7128
    _unknown_ _t7129;                      // _t7129
    _unknown_ _t7130;                      // _t7130
    _unknown_ _t7131;                      // _t7131
    _unknown_ _t7143;                      // _t7143
    _unknown_ _t7144;                      // _t7144
    _unknown_ _t7150;                      // _t7150
    _unknown_ _t7154;                      // _t7154
    _unknown_ _t7161;                      // _t7161
    _unknown_ _t7167;                      // _t7167
    _unknown_ _t7171;                      // _t7171
    _unknown_ _t7172;                      // _t7172
    _unknown_ _t7176;                      // _t7176
    _unknown_ _t7177;                      // _t7177
    _unknown_ _t7178;                      // _t7178
    _unknown_ _t7179;                      // _t7179
    _unknown_ _t7180;                      // _t7180
    _unknown_ _t7181;                      // _t7181
    _unknown_ _t7182;                      // _t7182
    _unknown_ _t7183;                      // _t7183
    _unknown_ _t7184;                      // _t7184
    _unknown_ _t7189;                      // _t7189
    _unknown_ _t7196;                      // _t7196
    _unknown_ _t7197;                      // _t7197
    _unknown_ _t7199;                      // _t7199
    signed int _t7204;                     // _t7204
    _unknown_ _t7205;                      // _t7205
    _unknown_ _t7206;                      // _t7206
    _unknown_ _t7210;                      // _t7210
    signed int _t7212;                     // _t7212
    _unknown_ _t7213;                      // _t7213
    _unknown_ _t7214;                      // _t7214
    _unknown_ _t7215;                      // _t7215
    _unknown_ _t7216;                      // _t7216
    _unknown_ _t7217;                      // _t7217
    _unknown_ _t7218;                      // _t7218
    _unknown_ _t7219;                      // _t7219
    _unknown_ _t7220;                      // _t7220
    _unknown_ _t7221;                      // _t7221
    _unknown_ _t7222;                      // _t7222
    _unknown_ _t7223;                      // _t7223
    _unknown_ _t7224;                      // _t7224
    _unknown_ _t7225;                      // _t7225
    _unknown_ _t7226;                      // _t7226
    _unknown_ _t7227;                      // _t7227
    _unknown_ _t7228;                      // _t7228
    _unknown_ _t7229;                      // _t7229
    _unknown_ _t7230;                      // _t7230
    _unknown_ _t7231;                      // _t7231
    _unknown_ _t7232;                      // _t7232
    _unknown_ _t7233;                      // _t7233
    _unknown_ _t7234;                      // _t7234
    _unknown_ _t7235;                      // _t7235
    _unknown_ _t7236;                      // _t7236
    _unknown_ _t7237;                      // _t7237
    _unknown_ _t7238;                      // _t7238
    _unknown_ _t7239;                      // _t7239
    _unknown_ _t7240;                      // _t7240
    _unknown_ _t7241;                      // _t7241
    _unknown_ _t7242;                      // _t7242
    _unknown_ _t7243;                      // _t7243
    _unknown_ _t7244;                      // _t7244
    _unknown_ _t7245;                      // _t7245
    _unknown_ _t7246;                      // _t7246
    _unknown_ _t7247;                      // _t7247
    _unknown_ _t7248;                      // _t7248
    _unknown_ _t7249;                      // _t7249
    _unknown_ _t7250;                      // _t7250
    _unknown_ _t7251;                      // _t7251
    _unknown_ _t7252;                      // _t7252
    _unknown_ _t7253;                      // _t7253
    _unknown_ _t7254;                      // _t7254
    _unknown_ _t7255;                      // _t7255
    _unknown_ _t7256;                      // _t7256
    _unknown_ _t7257;                      // _t7257
    _unknown_ _t7258;                      // _t7258
    _unknown_ _t7259;                      // _t7259
    _unknown_ _t7260;                      // _t7260
    _unknown_ _t7261;                      // _t7261
    _unknown_ _t7262;                      // _t7262
    _unknown_ _t7263;                      // _t7263
    _unknown_ _t7264;                      // _t7264
    _unknown_ _t7265;                      // _t7265
    _unknown_ _t7266;                      // _t7266
    _unknown_ _t7267;                      // _t7267
    _unknown_ _t7269;                      // _t7269
    _unknown_ _t7273;                      // _t7273
    signed int _t7276;                     // _t7276
    _unknown_ _t7277;                      // _t7277
    _unknown_ _t7278;                      // _t7278
    _unknown_ _t7279;                      // _t7279
    _unknown_ _t7280;                      // _t7280
    _unknown_ _t7281;                      // _t7281
    _unknown_ _t7282;                      // _t7282
    _unknown_ _t7284;                      // _t7284
    _unknown_ _t7285;                      // _t7285
    _unknown_ _t7286;                      // _t7286
    _unknown_ _t7287;                      // _t7287
    _unknown_ _t7291;                      // _t7291
    _unknown_ _t7292;                      // _t7292
    _unknown_ _t7295;                      // _t7295
    _unknown_ _t7296;                      // _t7296
    _unknown_ _t7299;                      // _t7299
    _unknown_ _t7300;                      // _t7300
    signed int _t7302;                     // _t7302
    _unknown_ _t7303;                      // _t7303
    _unknown_ _t7305;                      // _t7305
    _unknown_ _t7307;                      // _t7307
    _unknown_ _t7308;                      // _t7308
    _unknown_ _t7309;                      // _t7309
    _unknown_ _t7310;                      // _t7310
    _unknown_ _t7313;                      // _t7313
    _unknown_ _t7318;                      // _t7318
    _unknown_ _t7320;                      // _t7320
    _unknown_ _t7321;                      // _t7321
    _unknown_ _t7322;                      // _t7322
    _unknown_ _t7323;                      // _t7323
    _unknown_ _t7324;                      // _t7324
    _unknown_ _t7325;                      // _t7325
    _unknown_ _t7326;                      // _t7326
    _unknown_ _t7327;                      // _t7327
    _unknown_ _t7328;                      // _t7328
    _unknown_ _t7329;                      // _t7329
    _unknown_ _t7330;                      // _t7330
    _unknown_ _t7331;                      // _t7331
    _unknown_ _t7332;                      // _t7332
    _unknown_ _t7333;                      // _t7333
    _unknown_ _t7334;                      // _t7334
    _unknown_ _t7335;                      // _t7335
    _unknown_ _t7336;                      // _t7336
    _unknown_ _t7337;                      // _t7337
    _unknown_ _t7338;                      // _t7338
    _unknown_ _t7339;                      // _t7339
    _unknown_ _t7340;                      // _t7340
    _unknown_ _t7341;                      // _t7341
    _unknown_ _t7342;                      // _t7342
    _unknown_ _t7343;                      // _t7343
    _unknown_ _t7344;                      // _t7344
    _unknown_ _t7345;                      // _t7345
    _unknown_ _t7346;                      // _t7346
    _unknown_ _t7347;                      // _t7347
    _unknown_ _t7348;                      // _t7348
    _unknown_ _t7349;                      // _t7349
    _unknown_ _t7350;                      // _t7350
    _unknown_ _t7351;                      // _t7351
    _unknown_ _t7352;                      // _t7352
    _unknown_ _t7353;                      // _t7353

    _t7318 = __eflags;
    _t7291 = __esi;
    _t7282 = __edi;
    _t7276 = __edx;
    _t7212 = __ecx;
    _t7204 = __ebx;
    _t6995 = __eax;
     *(_t6995 - 76) =  *(_t6995 - 76) | _t7212 & 255;
    _t6996 = _t6995 - 1;
     *(_t6996 - 76) =  *(_t6996 - 76) | _t7212 & 255;
    _t6997 = _t6996 - 1;
     *(_t6997 - 76) =  *(_t6997 - 76) | _t7212 & 255;
    _t6998 = _t6997 - 1;
     *(_t6998 - 76) =  *(_t6998 - 76) | _t7212 & 255;
    _t6999 = _t6998 - 1;
     *(_t6999 - 76) =  *(_t6999 - 76) | _t7212 & 255;
    _t7000 = _t6999 - 1;
     *(_t7000 - 76) =  *(_t7000 - 76) | _t7212 & 255;
    _t7001 = _t7000 - 1;
     *(_t7001 - 76) =  *(_t7001 - 76) | _t7212 & 255;
    _t7002 = _t7001 - 1;
     *(_t7002 - 76) =  *(_t7002 - 76) | _t7212 & 255;
    _t7003 = _t7002 - 1;
     *(_t7003 - 76) =  *(_t7003 - 76) | _t7212 & 255;
    _t7004 = _t7003 - 1;
     *(_t7004 - 76) =  *(_t7004 - 76) | _t7212 & 255;
    _t7005 = _t7004 - 1;
     *(_t7005 - 76) =  *(_t7005 - 76) | _t7212 & 255;
    _t7006 = _t7005 - 1;
     *(_t7006 - 76) =  *(_t7006 - 76) | _t7212 & 255;
    _t7007 = _t7006 - 1;
     *(_t7007 - 76) =  *(_t7007 - 76) | _t7212 & 255;
    _t7008 = _t7007 - 1;
     *(_t7008 - 76) =  *(_t7008 - 76) | _t7212 & 255;
     *(_t7276 - 80) =  *(_t7276 - 80) | _t7276 & 255;
    _t7010 = _t7008;
     *(_t7010 - 76) =  *(_t7010 - 76) | _t7212 & 255;
    _t7011 = _t7010 - 1;
     *(_t7011 - 76) =  *(_t7011 - 76) | _t7212 & 255;
    _t7012 = _t7011 - 1;
     *(_t7012 - 76) =  *(_t7012 - 76) | _t7212 & 255;
    _t7013 = _t7012 - 1;
     *(_t7013 - 76) =  *(_t7013 - 76) | _t7212 & 255;
    _t7014 = _t7013 - 1;
     *(_t7014 - 76) =  *(_t7014 - 76) | _t7212 & 255;
    _t7015 = _t7014 - 1;
     *(_t7015 - 76) =  *(_t7015 - 76) | _t7212 & 255;
    _t7016 = _t7015 - 1;
     *(_t7016 - 76) =  *(_t7016 - 76) | _t7212 & 255;
     *(_t7212 + -720894802) =  *(_t7212 + -720894802) | _t7204 & 255;
    asm("scasb ");
    asm("repne scasb ");
     *((intOrPtr*)(_t7282 + -1270347772)) =  *((intOrPtr*)(_t7282 + -1270347772)) + _t7302;
    _t7018 = _t7016 - 1 | 470287535;
     *(_t7282 + _t7302 * 4) =  *(_t7282 + _t7302 * 4) | _t7204 & 255;
     *((intOrPtr*)(_t7282 + -1354364924)) =  *((intOrPtr*)(_t7282 + -1354364924)) - (_t7212 & 255);
    _t7019 = _t7018 - 1;
     *(_t7019 - 76) =  *(_t7019 - 76) | _t7212 & 255;
    _pop(__eax);
    asm("scasd ");
    _t7020 = _t7019 - 1;
     *(_t7282 - 81) =  *(_t7282 - 81) | _t7020 & 255;
    _t7021 = _t7020 - 1;
     *(_t7020 - 0xffffffffffffffb5) =  *(_t7020 - 0xffffffffffffffb5) | _t7212 & 255;
     *((char*)(_t7282 + -1348925436)) =  *((char*)(_t7282 + -1348925436)) - 4;
    while(1) {
        asm("cdq ");
        asm("scasd ");
        asm("movsd ");
        asm("scasd ");
         *0x2C080463 =  *0x2C080463 | _t7212 & 255;
        _t7023 = 0x2c0804ae;
        goto L4;
    }
}

L0805F2CB(
    _unknown_ __eax,                       // r0
    signed int __ebx,                      // r1
    signed int __ecx,                      // r2
    signed int __edx,                      // r3
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    _unknown_ __eflags                     // r9
)
{
    _unknown_ _t6975;                      // _t6975
    _unknown_ _t6976;                      // _t6976
    _unknown_ _t6977;                      // _t6977
    _unknown_ _t6978;                      // _t6978
    _unknown_ _t6979;                      // _t6979
    _unknown_ _t6980;                      // _t6980
    _unknown_ _t6981;                      // _t6981
    _unknown_ _t6982;                      // _t6982
    _unknown_ _t6983;                      // _t6983
    _unknown_ _t6984;                      // _t6984
    _unknown_ _t6985;                      // _t6985
    _unknown_ _t6986;                      // _t6986
    _unknown_ _t6988;                      // _t6988
    _unknown_ _t6989;                      // _t6989
    _unknown_ _t6990;                      // _t6990
    _unknown_ _t6991;                      // _t6991
    _unknown_ _t6992;                      // _t6992
    _unknown_ _t6993;                      // _t6993
    _unknown_ _t6994;                      // _t6994
    signed int _t6996;                     // _t6996
    _unknown_ _t6997;                      // _t6997
    signed int _t6998;                     // _t6998
    _unknown_ _t7000;                      // _t7000
    _unknown_ _t7001;                      // _t7001
    _unknown_ _t7002;                      // _t7002
    _unknown_ _t7003;                      // _t7003
    _unknown_ _t7005;                      // _t7005
    _unknown_ _t7006;                      // _t7006
    _unknown_ _t7007;                      // _t7007
    _unknown_ _t7008;                      // _t7008
    _unknown_ _t7009;                      // _t7009
    _unknown_ _t7010;                      // _t7010
    _unknown_ _t7012;                      // _t7012
    _unknown_ _t7013;                      // _t7013
    _unknown_ _t7014;                      // _t7014
    _unknown_ _t7015;                      // _t7015
    _unknown_ _t7017;                      // _t7017
    _unknown_ _t7022;                      // _t7022
    _unknown_ _t7080;                      // _t7080
    _unknown_ _t7097;                      // _t7097
    _unknown_ _t7099;                      // _t7099
    _unknown_ _t7100;                      // _t7100
    _unknown_ _t7101;                      // _t7101
    _unknown_ _t7102;                      // _t7102
    _unknown_ _t7105;                      // _t7105
    _unknown_ _t7106;                      // _t7106
    _unknown_ _t7107;                      // _t7107
    _unknown_ _t7108;                      // _t7108
    _unknown_ _t7109;                      // _t7109
    _unknown_ _t7121;                      // _t7121
    _unknown_ _t7122;                      // _t7122
    _unknown_ _t7128;                      // _t7128
    _unknown_ _t7132;                      // _t7132
    _unknown_ _t7139;                      // _t7139
    _unknown_ _t7145;                      // _t7145
    _unknown_ _t7149;                      // _t7149
    _unknown_ _t7150;                      // _t7150
    _unknown_ _t7154;                      // _t7154
    _unknown_ _t7155;                      // _t7155
    _unknown_ _t7156;                      // _t7156
    _unknown_ _t7157;                      // _t7157
    _unknown_ _t7158;                      // _t7158
    _unknown_ _t7159;                      // _t7159
    _unknown_ _t7160;                      // _t7160
    _unknown_ _t7161;                      // _t7161
    _unknown_ _t7162;                      // _t7162
    _unknown_ _t7167;                      // _t7167
    _unknown_ _t7174;                      // _t7174
    _unknown_ _t7175;                      // _t7175
    _unknown_ _t7177;                      // _t7177
    signed int _t7182;                     // _t7182
    _unknown_ _t7183;                      // _t7183
    _unknown_ _t7184;                      // _t7184
    _unknown_ _t7188;                      // _t7188
    signed int _t7190;                     // _t7190
    _unknown_ _t7191;                      // _t7191
    _unknown_ _t7192;                      // _t7192
    _unknown_ _t7193;                      // _t7193
    _unknown_ _t7194;                      // _t7194
    _unknown_ _t7195;                      // _t7195
    _unknown_ _t7196;                      // _t7196
    _unknown_ _t7197;                      // _t7197
    _unknown_ _t7198;                      // _t7198
    _unknown_ _t7199;                      // _t7199
    _unknown_ _t7200;                      // _t7200
    _unknown_ _t7201;                      // _t7201
    _unknown_ _t7202;                      // _t7202
    _unknown_ _t7203;                      // _t7203
    _unknown_ _t7204;                      // _t7204
    _unknown_ _t7205;                      // _t7205
    _unknown_ _t7206;                      // _t7206
    _unknown_ _t7207;                      // _t7207
    _unknown_ _t7208;                      // _t7208
    _unknown_ _t7209;                      // _t7209
    _unknown_ _t7210;                      // _t7210
    _unknown_ _t7211;                      // _t7211
    _unknown_ _t7212;                      // _t7212
    _unknown_ _t7213;                      // _t7213
    _unknown_ _t7214;                      // _t7214
    _unknown_ _t7215;                      // _t7215
    _unknown_ _t7216;                      // _t7216
    _unknown_ _t7217;                      // _t7217
    _unknown_ _t7218;                      // _t7218
    _unknown_ _t7219;                      // _t7219
    _unknown_ _t7220;                      // _t7220
    _unknown_ _t7221;                      // _t7221
    _unknown_ _t7222;                      // _t7222
    _unknown_ _t7223;                      // _t7223
    _unknown_ _t7224;                      // _t7224
    _unknown_ _t7225;                      // _t7225
    _unknown_ _t7226;                      // _t7226
    _unknown_ _t7227;                      // _t7227
    _unknown_ _t7228;                      // _t7228
    _unknown_ _t7229;                      // _t7229
    _unknown_ _t7230;                      // _t7230
    _unknown_ _t7231;                      // _t7231
    _unknown_ _t7232;                      // _t7232
    _unknown_ _t7233;                      // _t7233
    _unknown_ _t7234;                      // _t7234
    _unknown_ _t7235;                      // _t7235
    _unknown_ _t7236;                      // _t7236
    _unknown_ _t7237;                      // _t7237
    _unknown_ _t7238;                      // _t7238
    _unknown_ _t7239;                      // _t7239
    _unknown_ _t7240;                      // _t7240
    _unknown_ _t7241;                      // _t7241
    _unknown_ _t7242;                      // _t7242
    _unknown_ _t7243;                      // _t7243
    _unknown_ _t7244;                      // _t7244
    _unknown_ _t7245;                      // _t7245
    _unknown_ _t7247;                      // _t7247
    _unknown_ _t7251;                      // _t7251
    signed int _t7254;                     // _t7254
    _unknown_ _t7255;                      // _t7255
    _unknown_ _t7256;                      // _t7256
    _unknown_ _t7257;                      // _t7257
    _unknown_ _t7258;                      // _t7258
    _unknown_ _t7259;                      // _t7259
    _unknown_ _t7260;                      // _t7260
    _unknown_ _t7262;                      // _t7262
    _unknown_ _t7263;                      // _t7263
    _unknown_ _t7264;                      // _t7264
    _unknown_ _t7265;                      // _t7265
    _unknown_ _t7269;                      // _t7269
    _unknown_ _t7270;                      // _t7270
    _unknown_ _t7273;                      // _t7273
    _unknown_ _t7274;                      // _t7274
    _unknown_ _t7277;                      // _t7277
    _unknown_ _t7278;                      // _t7278
    signed int _t7280;                     // _t7280
    _unknown_ _t7281;                      // _t7281
    _unknown_ _t7283;                      // _t7283
    _unknown_ _t7285;                      // _t7285
    _unknown_ _t7286;                      // _t7286
    _unknown_ _t7287;                      // _t7287
    _unknown_ _t7288;                      // _t7288
    _unknown_ _t7291;                      // _t7291
    _unknown_ _t7296;                      // _t7296
    _unknown_ _t7298;                      // _t7298
    _unknown_ _t7299;                      // _t7299
    _unknown_ _t7300;                      // _t7300
    _unknown_ _t7301;                      // _t7301
    _unknown_ _t7302;                      // _t7302
    _unknown_ _t7303;                      // _t7303
    _unknown_ _t7304;                      // _t7304
    _unknown_ _t7305;                      // _t7305
    _unknown_ _t7306;                      // _t7306
    _unknown_ _t7307;                      // _t7307
    _unknown_ _t7308;                      // _t7308
    _unknown_ _t7309;                      // _t7309
    _unknown_ _t7310;                      // _t7310
    _unknown_ _t7311;                      // _t7311
    _unknown_ _t7312;                      // _t7312
    _unknown_ _t7313;                      // _t7313
    _unknown_ _t7314;                      // _t7314
    _unknown_ _t7315;                      // _t7315
    _unknown_ _t7316;                      // _t7316
    _unknown_ _t7317;                      // _t7317
    _unknown_ _t7318;                      // _t7318
    _unknown_ _t7319;                      // _t7319
    _unknown_ _t7320;                      // _t7320
    _unknown_ _t7321;                      // _t7321
    _unknown_ _t7322;                      // _t7322
    _unknown_ _t7323;                      // _t7323
    _unknown_ _t7324;                      // _t7324
    _unknown_ _t7325;                      // _t7325
    _unknown_ _t7326;                      // _t7326
    _unknown_ _t7327;                      // _t7327
    _unknown_ _t7328;                      // _t7328
    _unknown_ _t7329;                      // _t7329
    _unknown_ _t7330;                      // _t7330
    _unknown_ _t7331;                      // _t7331

    _t7296 = __eflags;
    _t7269 = __esi;
    _t7260 = __edi;
    _t7254 = __edx;
    _t7190 = __ecx;
    _t7182 = __ebx;
    _t6975 = __eax;
     *(_t6975 - 76) =  *(_t6975 - 76) | _t7190 & 255;
    _t6976 = _t6975 - 1;
     *(_t6976 - 76) =  *(_t6976 - 76) | _t7190 & 255;
    _t6977 = _t6976 - 1;
     *(_t6977 - 76) =  *(_t6977 - 76) | _t7190 & 255;
    _t6978 = _t6977 - 1;
     *(_t6978 - 76) =  *(_t6978 - 76) | _t7190 & 255;
    _t6979 = _t6978 - 1;
     *(_t6979 - 76) =  *(_t6979 - 76) | _t7190 & 255;
    _t6980 = _t6979 - 1;
     *(_t6980 - 76) =  *(_t6980 - 76) | _t7190 & 255;
    _t6981 = _t6980 - 1;
     *(_t6981 - 76) =  *(_t6981 - 76) | _t7190 & 255;
    _t6982 = _