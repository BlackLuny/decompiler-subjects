//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker * e12;
    struct _IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_2 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_2 * e12;
    struct _IO_FILE_2 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_3 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_3 * e12;
    struct _IO_FILE_3 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_4 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_4 * e12;
    struct _IO_FILE_4 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_5 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_5 * e12;
    struct _IO_FILE_5 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_6 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_6 * e12;
    struct _IO_FILE_6 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_7 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_7 * e12;
    struct _IO_FILE_7 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_marker {
    struct _IO_marker * e0;
    struct _IO_FILE * e1;
    int32_t e2;
};

struct _IO_marker_2 {
    struct _IO_marker_2 * e0;
    struct _IO_FILE_2 * e1;
    int32_t e2;
};

struct _IO_marker_3 {
    struct _IO_marker_3 * e0;
    struct _IO_FILE_3 * e1;
    int32_t e2;
};

struct _IO_marker_4 {
    struct _IO_marker_4 * e0;
    struct _IO_FILE_4 * e1;
    int32_t e2;
};

struct _IO_marker_5 {
    struct _IO_marker_5 * e0;
    struct _IO_FILE_5 * e1;
    int32_t e2;
};

struct _IO_marker_6 {
    struct _IO_marker_6 * e0;
    struct _IO_FILE_6 * e1;
    int32_t e2;
};

struct _IO_marker_7 {
    struct _IO_marker_7 * e0;
    struct _IO_FILE_7 * e1;
    int32_t e2;
};

struct __dirstream {
    int32_t e0;
};

struct __dirstream_1 {
    int32_t e0;
};

struct __dirstream_2 {
    int32_t e0;
};

struct __dirstream_3 {
    int32_t e0;
};

struct __dirstream_4 {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct dirent_1 {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct dirent_2 {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct dirent_3 {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct option {
    char * e0;
    int32_t e1;
    int32_t * e2;
    int32_t e3;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct timespec_1 {
    int32_t e0;
    int32_t e1;
};

struct stat_1 {
    int64_t e0;
    int16_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int64_t e7;
    int16_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    struct timespec_1 e12;
    struct timespec_1 e13;
    struct timespec_1 e14;
    int32_t e15;
    int32_t e16;
};

struct timespec_2 {
    int32_t e0;
    int32_t e1;
};

struct stat_2 {
    int64_t e0;
    int16_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int64_t e7;
    int16_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    struct timespec_2 e12;
    struct timespec_2 e13;
    struct timespec_2 e14;
    int32_t e15;
    int32_t e16;
};

// ------------------- Function Prototypes --------------------

void basename(void);
void bin_install(char * package, char * gisbase, char * bins, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version);
int32_t binaries_exist(char * package, char * binaries);
void check_dependencies(char * package, char * gisbase, char * grass_version);
int32_t check_ext_menu(char ** tcl_lines);
void check_extension(char * package, char * name, int32_t * major, int32_t * minor, int32_t * revision);
int32_t check_filetype(char * myfile);
int32_t chop(char * string);
void delete_ext_html(char * ext, char * gisbase, char ** html);
int32_t delete_str(int32_t pos, char ** strarr);
char * depstr(char * package, char * gisbase);
int32_t deregister_entries_gisman(char * pkg_short_name, char * gisbase);
void deregister_entries_gisman2(char * pkg_short_name, char * gisbase);
void deregister_extension(char * package, char * pkg_short_name, char * gisbase);
void deregister_html(char * pkg_short_name, char * gisbase);
void dump_ascii(char * file, char * heading);
void dump_html(char * file, char * tmpfile);
void dump_plain(char * file, char * tmpfile);
void exit_db(void);
void exit_msg(void);
void exit_tmp(void);
int32_t find_pos(char * str, char ** strarr, int32_t start);
void get_package_name(char * path, char * name);
int32_t insert_str(char * str, int32_t pos, char ** strarr);
int32_t is_submenu(char * item);
int32_t is_text(char * s);
void list_binaries(char * package);
void list_extensions(char * gisbase);
void mkdir_s(char * pathname, char * mode);
char * nc_fgets(char * s, int32_t size, struct _IO_FILE_2 * stream);
char * nc_fgets_html(char * s, int32_t size, struct _IO_FILE_2 * stream);
char * nc_fgets_nb(char * s, int32_t size, struct _IO_FILE_2 * stream);
void new_ext_html(char * ext, char * gisbase, char ** html, int32_t major, int32_t minor, int32_t revision);
int32_t new_item(char * item, char * menu, char ** tcl_lines, int32_t line_no);
int32_t new_submenu(char * pkg_short_name, char * menu, char ** tcl_lines);
void print_cfg(void);
void print_done(void);
void print_error(int32_t err_code, char * msg, ...);
void print_warning(char * msg, ...);
void query_extension(char * package, char * name, int32_t major, int32_t minor, int32_t revision, char * short_name, char * invocation, char * org_name);
void register_entries_gisman(char * pkg_short_name, char * gisbase);
void register_entries_gisman2(char * pkg_short_name, char * gisbase);
void register_extension(char * gisbase, char * bins, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision);
void register_html(char * pkg_short_name, char * gisbase, int32_t major, int32_t minor, int32_t revision);
void restore(char * gisbase, char * grass_version);
int32_t restore_entries_gisman(char * gisbase);
int32_t restore_html(char * gisbase);
void run_post(char * package, int32_t action, char * bins, char * gisbase);
void show_details(char * package);
void show_help(void);
void show_license(char * package);
void show_version(void);
int32_t source_clean(char * package);
void source_install(char * package, char * gisbase, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version);
void su(char * gisbase, char * cmd);
void test_install(char * package, char * gisbase, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version);
void uninstall(char * package, char * pkg_short_name, char * gisbase, char * grass_version);
void unpack_extension(char * package);
int32_t vercmp(int32_t major, int32_t minor, int32_t revision, int32_t major2, int32_t minor2, int32_t revision2);
void wget_extension(char * url);

// --------------------- Global Variables ---------------------

char CONFIG_CMD[2048];
char CONFIG_OPTS[2048];
char CWD[2048];
int32_t ERROR = 0;
char EXT_BASE[2048];
int32_t FORCE = 0;
char GEM_ACTION[2048];
char GEM_C_OPTS[2048];
char GEM_EXT_AUTHORS[2048];
char GEM_EXT_BUGS[2048];
char GEM_EXT_DEPS[2048];
char GEM_EXT_DESCR[2048];
char GEM_EXT_INFO[2048];
char GEM_EXT_NAME[2048];
char GEM_EXT_VERSION[2048];
char GEM_FORCE[2048];
char GEM_GRASS_DIR[2048];
char GEM_GUI[2048];
char GEM_VERBOSE[2048];
char GINSTALL_DST[2048];
char GINSTALL_INC[2048];
char GINSTALL_LIB[2048];
char GISMAN2_CMD[2048];
char GISMAN_CMD[2048];
char HTML_CMD[2048];
char INSTALL_BASE[2048];
char INSTALL_TYPE[2048];
char MAKE_CMD[2048];
char QGIS_CMD[2048];
int32_t SKIP_CFG = 0;
int32_t TMPCLEAN = 0;
char TMPDB[2048];
int32_t TMPDBCLEAN = 0;
char TMPDIR[2048];
char TMP_AUTHORS[2048];
char TMP_BUGS[2048];
char TMP_DEPS[2048];
char TMP_DESCR[2048];
char TMP_GISMAN[2048];
char TMP_HTML[2048];
char TMP_INFO[2048];
char TMP_NULL[2048];
char UNINSTALL_BASE[2048];
char UNINSTALL_CMD[2048];
int32_t UPGRADE = 0;
int32_t VERBOSE = 0;
int32_t WARNINGS = 0;
int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
char * g4 = "\x1b\x5b\x31\x3b\x33\x31\x6d\x0a\x45\x52\x52\x4f\x52\x3a\x1b\x5b\x30\x6d\x20\x25\x73"; // 0x80549c0
char * g5 = "\x1b\x5b\x30\x3b\x33\x33\x6d\x0a\x57\x41\x52\x4e\x49\x4e\x47\x3a\x1b\x5b\x30\x6d\x20\x25\x73"; // 0x80549d6
char * g6 = "\x1b\x5b\x30\x3b\x33\x32\x6d\x44\x4f\x4e\x45\x2e\x0a\x1b\x5b\x30\x6d"; // 0x80549ee
char * g7; // 0x8054d15
int32_t g8 = 0x2f2e2e00; // 0x8055722
int32_t g9 = 0; // 0x805698c
int32_t g10 = 0x6e6f6300; // 0x8057925
int32_t g11 = 0x6d305b1b; // 0x8057935
char (*g12)[8] = "install"; // 0x8059100
int32_t g13 = 0; // 0x8059240
struct _IO_FILE * g14 = NULL; // 0x8059244
void (**g15)() = NULL; // 0x8059260
int32_t g16 = 0; // 0x8059264
int32_t g17 = 0; // 0x8059280
struct _IO_FILE * g18 = NULL; // 0x805928c

// ------------------------ Functions -------------------------

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/at_exit_funcs.c
// Address range: 0x8048e89 - 0x8048fc1
// Line range:    62 - 103
void exit_tmp(void) {
    char str[2048];
    char v1[2048];
    // 0x8048e89
    if (TMPDIR[0] == 0) {
        // 0x8048ea9
        TMPCLEAN = 1;
        // branch -> 0x8048faf
    } else {
        // 0x8048eb8
        if (TMPCLEAN == 0) {
            // 0x8048ec5
            chdir(CWD);
            sprintf(str, "rm -rf %s/*", TMPDIR);
            if (VERBOSE != 0) {
                // 0x8048ef9
                fwrite("Removing temporary extension files...", 1, 37, (struct _IO_FILE *)g15);
                // branch -> 0x8048f21
            }
            // 0x8048f21
            v1[0] = system(str);
            sprintf(str, "rmdir %s", TMPDIR);
            v1[0] = system(str);
            if (opendir(TMPDIR) != NULL) {
                // 0x8048f83
                print_warning("could not remove temporary directory %s.\nPlease remove manually.\n");
                // branch -> 0x8048f97
            }
            // 0x8048f97
            if (VERBOSE != 0) {
                // 0x8048fa0
                print_done();
                // branch -> 0x8048fa5
            }
            // 0x8048fa5
            TMPCLEAN = 1;
            // branch -> 0x8048faf
        }
    }
    // 0x8048faf
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8048fbb
        __stack_chk_fail();
        // branch -> 0x8048fc0
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/at_exit_funcs.c
// Address range: 0x8048fc2 - 0x804938f
// Line range:    106 - 218
void exit_db(void) {
    char str[2048];
    char v1[2048];
    // 0x8048fc2
    if (TMPDBCLEAN == 0) {
        // 0x8048fe3
        chdir(CWD);
        if (VERBOSE != 0) {
            // 0x8048ff8
            fwrite("Removing temporary registration files...", 1, 40, (struct _IO_FILE *)g15);
            // branch -> 0x8049020
        }
        // 0x8049020
        if (TMPDB[0] != 0) {
            // 0x804902c
            sprintf(str, "rm -rf %s", TMPDB);
            char system_rc = system(str);
            v1[0] = system_rc;
            if (system_rc != 0) {
                // 0x8049068
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
                // branch -> 0x804907c
            }
        }
        // 0x804907c
        if (TMP_GISMAN[0] != 0) {
            // 0x8049088
            sprintf(str, "rm -f %s", TMP_GISMAN);
            char system_rc2 = system(str);
            v1[0] = system_rc2;
            if (system_rc2 != 0) {
                // 0x80490c4
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
                // branch -> 0x80490d8
            }
        }
        // 0x80490d8
        if (TMP_DESCR[0] != 0) {
            // 0x80490e4
            sprintf(str, "rm -f %s", TMP_DESCR);
            char system_rc3 = system(str);
            v1[0] = system_rc3;
            if (system_rc3 != 0) {
                // 0x8049120
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
                // branch -> 0x8049134
            }
        }
        // 0x8049134
        if (TMP_INFO[0] != 0) {
            // 0x8049140
            sprintf(str, "rm -f %s", TMP_INFO);
            char system_rc4 = system(str);
            v1[0] = system_rc4;
            if (system_rc4 != 0) {
                // 0x804917c
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
                // branch -> 0x8049190
            }
        }
        // 0x8049190
        if (TMP_DEPS[0] != 0) {
            // 0x804919c
            sprintf(str, "rm -f %s", TMP_DEPS);
            char system_rc5 = system(str);
            v1[0] = system_rc5;
            if (system_rc5 != 0) {
                // 0x80491d8
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
                // branch -> 0x80491ec
            }
        }
        // 0x80491ec
        if (TMP_BUGS[0] != 0) {
            // 0x80491f8
            sprintf(str, "rm -f %s", TMP_BUGS);
            char system_rc6 = system(str);
            v1[0] = system_rc6;
            if (system_rc6 != 0) {
                // 0x8049234
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
                // branch -> 0x8049248
            }
        }
        // 0x8049248
        if (TMP_AUTHORS[0] != 0) {
            // 0x8049254
            sprintf(str, "rm -f %s", TMP_AUTHORS);
            char system_rc7 = system(str);
            v1[0] = system_rc7;
            if (system_rc7 != 0) {
                // 0x8049290
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
                // branch -> 0x80492a4
            }
        }
        // 0x80492a4
        if (TMP_HTML[0] != 0) {
            // 0x80492b0
            sprintf(str, "rm -f %s", TMP_HTML);
            char system_rc8 = system(str);
            v1[0] = system_rc8;
            if (system_rc8 != 0) {
                // 0x80492ec
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
                // branch -> 0x8049300
            }
        }
        // 0x8049300
        if (VERBOSE == 0) {
            // 0x8049309
            if (TMP_NULL[0] != 0) {
                // 0x8049315
                sprintf(str, "rm -f %s", TMP_NULL);
                char system_rc9 = system(str);
                v1[0] = system_rc9;
                if (system_rc9 != 0) {
                    // 0x8049351
                    print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
                    // branch -> 0x8049365
                }
            }
            // 0x8049365
            if (VERBOSE != 0) {
                // 0x804936e
                print_done();
                // branch -> 0x8049373
            }
        } else {
            // 0x8049365
            // branch -> 0x804936e
            // 0x804936e
            print_done();
            // branch -> 0x8049373
        }
        // 0x8049373
        TMPDBCLEAN = 1;
        // branch -> 0x804937d
    }
    // 0x804937d
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8049389
        __stack_chk_fail();
        // branch -> 0x804938e
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/at_exit_funcs.c
// Address range: 0x8049390 - 0x804941f
// Line range:    221 - 239
void exit_msg(void) {
    // 0x8049390
    if (ERROR <= 0) {
        // 0x804939f
        fprintf((struct _IO_FILE *)g15, "Program exited with an error (code %i). Operation aborted.\n", ERROR);
        // branch -> 0x804941d
        // 0x804941d
        return;
    }
    int32_t v1 = WARNINGS; // 0x80493fd
    if (WARNINGS == 1) {
        // 0x80493cb
        fwrite("Job done but there was one warning. Please check.\n", 1, 50, (struct _IO_FILE *)g15);
        v1 = WARNINGS;
        // branch -> 0x80493f3
    }
    // 0x80493f3
    if (v1 >= 2) {
        // 0x80493fd
        fprintf((struct _IO_FILE *)g15, "Job done but there were %i warnings. Please check.\n", v1);
        // branch -> 0x804941d
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/error.c
// Address range: 0x8049420 - 0x804949a
// Line range:    32 - 45
void print_error(int32_t err_code, char * msg, ...) {
    char v1[2048];
    char str[2048];
    int32_t v2;
    int32_t v3 = &v2; // 0x804943d_0
    v1[0] = v3;
    vsprintf(str, msg, v3);
    fprintf(g14, (char *)&g4);
    ERROR = err_code;
    exit(err_code);
    // UNREACHABLE
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/error.c
// Address range: 0x804949b - 0x8049522
// Line range:    52 - 64
void print_warning(char * msg, ...) {
    char v1[2048];
    char str[2048];
    int32_t v2;
    int32_t v3 = &v2; // 0x80494b8_0
    v1[0] = v3;
    vsprintf(str, msg, v3);
    fprintf(g14, (char *)&g5);
    WARNINGS++;
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x804951c
        __stack_chk_fail();
        // branch -> 0x8049521
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/error.c
// Address range: 0x8049523 - 0x8049553
// Line range:    70 - 73
void print_done(void) {
    // 0x8049523
    fwrite((char *)&g6, 1, 17, (struct _IO_FILE *)g15);
}

// Address range: 0x8049554 - 0x804961c
void basename(void) {
    // 0x8049554
    int32_t str;
    char * str2 = strdup((char *)str); // 0x8049560
    char * next_token = strtok(str2, "/"); // 0x804957e
    if (next_token == NULL) {
        // 0x804958c
        if (str2 != NULL) {
            // 0x8049592
            free(str2);
            // branch -> 0x804961b
        }
        // 0x804961b
        g1 = 0;
        return;
    }
    char * v1 = strdup(next_token);
    // branch -> 0x80495b4
    while (true) {
        int32_t v2 = (int32_t)v1; // 0x80495aa_3
        // branch -> 0x80495b4
        char * next_token2; // 0x80495c4
        while (true) {
            // 0x80495b4
            next_token2 = strtok(NULL, "/");
            if (v1 != NULL && next_token2 != NULL) {
                // 0x80495d8
                free(v1);
                // branch -> 0x80495e3
            }
            // 0x80495e3
            if (next_token2 == NULL) {
                // 0x8049607
                if (str2 != NULL) {
                    // 0x804960d
                    free(str2);
                    // branch -> 0x804961b
                }
                // 0x804961b
                g1 = v2;
                return;
            }
            // 0x80495e9
            if (*next_token2 != 0) {
                // break -> 0x80495f3
                break;
            }
            // continue -> 0x80495b4
        }
        // 0x80495f3
        v1 = strdup(next_token2);
        // branch -> 0x80495b4
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804961d - 0x804968e
// Line range:    73 - 80
void mkdir_s(char * pathname, char * mode) {
    int32_t str;
    sprintf((char *)&str, "mkdir %s --mode=%s -p", pathname, mode);
    system((char *)&str);
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8049688
        __stack_chk_fail();
        // branch -> 0x804968d
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804968f - 0x8049736
// Line range:    86 - 113
int32_t chop(char * string) {
    // 0x804968f
    int32_t v1;
    int32_t i = v1; // bp-20
    i = 0;
    int32_t v2 = (int32_t)string; // 0x80496a3_0
    int32_t v3 = strlen(string) - 1; // 0x80496ae
    if (v3 <= 0) {
        // 0x804971c
        *(char *)(strlen(string) + v2 - i) = 0;
        return i;
    }
    while (true) {
        char * v4 = (char *)(v3 + v2);
        if (*v4 != 10) {
            // 0x80496ca
            if (*v4 != 9) {
                // 0x80496d7
                if (*v4 != 32) {
                    // 0x80496e4
                    if (*v4 != 12) {
                        // 0x80496f1
                        if (*v4 != 13) {
                            // 0x804971c
                            *(char *)(strlen(string) + v2 - i) = 0;
                            return i;
                        }
                    }
                }
            }
        }
        // 0x804970f
        i++;
        if (v3 <= 1) {
            // break -> 0x804971c
            break;
        }
        v3--;
        // continue -> 0x80496b6
    }
    // 0x804971c
    *(char *)(strlen(string) + v2 - i) = 0;
    return i;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049737 - 0x8049a5d
// Line range:    125 - 180
int32_t insert_str(char * str, int32_t pos, char ** strarr) {
    char v1[2048];
    char str3[2048];
    // 0x8049737
    int32_t v2;
    int32_t len = v2; // bp-6176
    int32_t v3;
    int32_t n = v3; // bp-6168
    len = (int32_t)str;
    int32_t v4 = (int32_t)strarr; // 0x804974a_0
    int32_t v5 = *(int32_t *)20; // 0x8049754
    v1[0] = 0;
    char v6 = 0; // 0x804978f
    int32_t v7; // 0x80499b4
    char v8; // 0x804981c
    char v9; // 0x8049a1f
    int32_t v10; // 0x80497b5_2
    int32_t * str5; // 0x8049878_0
    int32_t len2; // 0x80497ca
    char * mem; // 0x80497f2
    int32_t len3; // 0x80498b9
    int32_t len4; // 0x8049944
    int32_t len5; // 0x80499ea
    char * mem2; // 0x80499f5
    int32_t str6;
    int32_t str4;
    int32_t str2; // 0x804980e
    int32_t str7; // 0x804990b
    int32_t str8; // 0x804998e
    int32_t str9; // 0x8049a11
    char v11; // 0x80497d8
    char v12; // 0x80499bb
    char v13; // 0x80499bb60
    int32_t v14; // 0x804984f
    int32_t v15; // 0x8049902
    if (*(int32_t *)strarr != 0) {
        char v16 = 1; // 0x804976a
        v1[0] = v16;
        v6 = v16;
        while (*(int32_t *)(4 * (int32_t)v16 + v4) != 0) {
            // 0x804976a
            v16++;
            v1[0] = v16;
            v6 = v16;
            // continue -> 0x804976a
        }
        // 0x8049786
        if (pos >= 0) {
            // 0x804978c
            if ((int32_t)v6 >= pos) {
                // 0x80497b2
                v10 = v6;
                if (v10 == pos) {
                    // 0x80497c1
                    len2 = strlen((char *)len);
                    v11 = v1[0];
                    mem = malloc(len2 + 1);
                    *(int32_t *)(4 * (int32_t)v11 + v4) = (int32_t)mem;
                    str2 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
                    strcpy((char *)str2, (char *)len);
                    v8 = v1[0] + 2;
                    v1[0] = v8;
                    *(int32_t *)(v4 - 4 + 4 * (int32_t)v8) = 0;
                    // branch -> 0x8049a44
                } else {
                    // 0x8049846
                    v14 = v4 - 4;
                    strcpy(str3, (char *)*(int32_t *)(4 * v10 + v14));
                    str5 = (int32_t *)(v4 + 4 * pos);
                    strcpy((char *)&str4, (char *)*str5);
                    free((char *)*str5);
                    len3 = strlen((char *)len);
                    *str5 = (int32_t)malloc(len3 + 1);
                    strcpy((char *)*str5, (char *)len);
                    n = pos;
                    v13 = v1[0];
                    if ((int32_t)v13 - 1 > pos) {
                        // 0x80498f9
                        v15 = v4 + 4;
                        str7 = *(int32_t *)(4 * pos + v15);
                        strcpy((char *)&str6, (char *)str7);
                        free((char *)*(int32_t *)(4 * n + v15));
                        len4 = strlen((char *)&str4);
                        *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
                        str8 = *(int32_t *)(4 * n + v15);
                        strcpy((char *)str8, (char *)&str4);
                        strcpy((char *)&str4, (char *)&str6);
                        v7 = n + 1;
                        n = v7;
                        v12 = v1[0];
                        // branch -> 0x80498f9
                        while ((int32_t)v12 - 1 > v7) {
                            // 0x80498f9
                            str7 = *(int32_t *)(4 * v7 + v15);
                            strcpy((char *)&str6, (char *)str7);
                            free((char *)*(int32_t *)(4 * n + v15));
                            len4 = strlen((char *)&str4);
                            *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
                            str8 = *(int32_t *)(4 * n + v15);
                            strcpy((char *)str8, (char *)&str4);
                            strcpy((char *)&str4, (char *)&str6);
                            v7 = n + 1;
                            n = v7;
                            v12 = v1[0];
                            // continue -> 0x80498f9
                        }
                        // 0x80499d0
                        len5 = strlen(str3);
                        mem2 = malloc(len5 + 1);
                        *(int32_t *)(4 * (int32_t)v12 + v4) = (int32_t)mem2;
                        str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
                        strcpy((char *)str9, str3);
                        v9 = v1[0] + 2;
                        v1[0] = v9;
                        *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
                        // branch -> 0x8049a44
                        // 0x8049a44
                        if (*(int32_t *)20 != v5) {
                            // 0x8049a50
                            __stack_chk_fail();
                            // branch -> 0x8049a55
                        }
                        // 0x8049a55
                        return v1[0];
                    }
                    // 0x80499d0
                    len5 = strlen(str3);
                    mem2 = malloc(len5 + 1);
                    *(int32_t *)(4 * (int32_t)v13 + v4) = (int32_t)mem2;
                    str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
                    strcpy((char *)str9, str3);
                    v9 = v1[0] + 2;
                    v1[0] = v9;
                    *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
                    // branch -> 0x8049a44
                }
                // 0x8049a44
                if (*(int32_t *)20 != v5) {
                    // 0x8049a50
                    __stack_chk_fail();
                    // branch -> 0x8049a55
                }
                // 0x8049a55
                return v1[0];
            }
        }
        // 0x8049797
        print_error(-21, "insert: invalid line number %i.\n");
        // branch -> 0x80497b2
        // 0x80497b2
        v10 = v1[0];
        if (v10 == pos) {
            // 0x80497c1
            len2 = strlen((char *)len);
            v11 = v1[0];
            mem = malloc(len2 + 1);
            *(int32_t *)(4 * (int32_t)v11 + v4) = (int32_t)mem;
            str2 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
            strcpy((char *)str2, (char *)len);
            v8 = v1[0] + 2;
            v1[0] = v8;
            *(int32_t *)(v4 - 4 + 4 * (int32_t)v8) = 0;
            // branch -> 0x8049a44
        } else {
            // 0x8049846
            v14 = v4 - 4;
            strcpy(str3, (char *)*(int32_t *)(4 * v10 + v14));
            str5 = (int32_t *)(v4 + 4 * pos);
            strcpy((char *)&str4, (char *)*str5);
            free((char *)*str5);
            len3 = strlen((char *)len);
            *str5 = (int32_t)malloc(len3 + 1);
            strcpy((char *)*str5, (char *)len);
            n = pos;
            v13 = v1[0];
            if ((int32_t)v13 - 1 > pos) {
                // 0x80498f9
                v15 = v4 + 4;
                str7 = *(int32_t *)(4 * pos + v15);
                strcpy((char *)&str6, (char *)str7);
                free((char *)*(int32_t *)(4 * n + v15));
                len4 = strlen((char *)&str4);
                *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
                str8 = *(int32_t *)(4 * n + v15);
                strcpy((char *)str8, (char *)&str4);
                strcpy((char *)&str4, (char *)&str6);
                v7 = n + 1;
                n = v7;
                v12 = v1[0];
                // branch -> 0x80498f9
                while ((int32_t)v12 - 1 > v7) {
                    // 0x80498f9
                    str7 = *(int32_t *)(4 * v7 + v15);
                    strcpy((char *)&str6, (char *)str7);
                    free((char *)*(int32_t *)(4 * n + v15));
                    len4 = strlen((char *)&str4);
                    *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
                    str8 = *(int32_t *)(4 * n + v15);
                    strcpy((char *)str8, (char *)&str4);
                    strcpy((char *)&str4, (char *)&str6);
                    v7 = n + 1;
                    n = v7;
                    v12 = v1[0];
                    // continue -> 0x80498f9
                }
                // 0x80499d0
                len5 = strlen(str3);
                mem2 = malloc(len5 + 1);
                *(int32_t *)(4 * (int32_t)v12 + v4) = (int32_t)mem2;
                str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
                strcpy((char *)str9, str3);
                v9 = v1[0] + 2;
                v1[0] = v9;
                *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
                // branch -> 0x8049a44
                // 0x8049a44
                if (*(int32_t *)20 != v5) {
                    // 0x8049a50
                    __stack_chk_fail();
                    // branch -> 0x8049a55
                }
                // 0x8049a55
                return v1[0];
            }
            // 0x80499d0
            len5 = strlen(str3);
            mem2 = malloc(len5 + 1);
            *(int32_t *)(4 * (int32_t)v13 + v4) = (int32_t)mem2;
            str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
            strcpy((char *)str9, str3);
            v9 = v1[0] + 2;
            v1[0] = v9;
            *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
            // branch -> 0x8049a44
        }
        // 0x8049a44
        if (*(int32_t *)20 != v5) {
            // 0x8049a50
            __stack_chk_fail();
            // branch -> 0x8049a55
        }
        // 0x8049a55
        return v1[0];
    }
    // 0x8049786
    if (pos < 0) {
        // 0x8049797
        print_error(-21, "insert: invalid line number %i.\n");
        // branch -> 0x80497b2
        // 0x80497b2
        v10 = v1[0];
        if (v10 == pos) {
            // 0x80497c1
            len2 = strlen((char *)len);
            v11 = v1[0];
            mem = malloc(len2 + 1);
            *(int32_t *)(4 * (int32_t)v11 + v4) = (int32_t)mem;
            str2 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
            strcpy((char *)str2, (char *)len);
            v8 = v1[0] + 2;
            v1[0] = v8;
            *(int32_t *)(v4 - 4 + 4 * (int32_t)v8) = 0;
            // branch -> 0x8049a44
        } else {
            // 0x8049846
            v14 = v4 - 4;
            strcpy(str3, (char *)*(int32_t *)(4 * v10 + v14));
            str5 = (int32_t *)(v4 + 4 * pos);
            strcpy((char *)&str4, (char *)*str5);
            free((char *)*str5);
            len3 = strlen((char *)len);
            *str5 = (int32_t)malloc(len3 + 1);
            strcpy((char *)*str5, (char *)len);
            n = pos;
            v13 = v1[0];
            if ((int32_t)v13 - 1 > pos) {
                // 0x80498f9
                v15 = v4 + 4;
                str7 = *(int32_t *)(4 * pos + v15);
                strcpy((char *)&str6, (char *)str7);
                free((char *)*(int32_t *)(4 * n + v15));
                len4 = strlen((char *)&str4);
                *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
                str8 = *(int32_t *)(4 * n + v15);
                strcpy((char *)str8, (char *)&str4);
                strcpy((char *)&str4, (char *)&str6);
                v7 = n + 1;
                n = v7;
                v12 = v1[0];
                // branch -> 0x80498f9
                while ((int32_t)v12 - 1 > v7) {
                    // 0x80498f9
                    str7 = *(int32_t *)(4 * v7 + v15);
                    strcpy((char *)&str6, (char *)str7);
                    free((char *)*(int32_t *)(4 * n + v15));
                    len4 = strlen((char *)&str4);
                    *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
                    str8 = *(int32_t *)(4 * n + v15);
                    strcpy((char *)str8, (char *)&str4);
                    strcpy((char *)&str4, (char *)&str6);
                    v7 = n + 1;
                    n = v7;
                    v12 = v1[0];
                    // continue -> 0x80498f9
                }
                // 0x80499d0
                len5 = strlen(str3);
                mem2 = malloc(len5 + 1);
                *(int32_t *)(4 * (int32_t)v12 + v4) = (int32_t)mem2;
                str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
                strcpy((char *)str9, str3);
                v9 = v1[0] + 2;
                v1[0] = v9;
                *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
                // branch -> 0x8049a44
                // 0x8049a44
                if (*(int32_t *)20 != v5) {
                    // 0x8049a50
                    __stack_chk_fail();
                    // branch -> 0x8049a55
                }
                // 0x8049a55
                return v1[0];
            }
            // 0x80499d0
            len5 = strlen(str3);
            mem2 = malloc(len5 + 1);
            *(int32_t *)(4 * (int32_t)v13 + v4) = (int32_t)mem2;
            str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
            strcpy((char *)str9, str3);
            v9 = v1[0] + 2;
            v1[0] = v9;
            *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
            // branch -> 0x8049a44
        }
        // 0x8049a44
        if (*(int32_t *)20 != v5) {
            // 0x8049a50
            __stack_chk_fail();
            // branch -> 0x8049a55
        }
        // 0x8049a55
        return v1[0];
    }
    // 0x804978c
    if ((int32_t)v6 >= pos) {
        // 0x80497b2
        v10 = v6;
        if (v10 == pos) {
            // 0x80497c1
            len2 = strlen((char *)len);
            v11 = v1[0];
            mem = malloc(len2 + 1);
            *(int32_t *)(4 * (int32_t)v11 + v4) = (int32_t)mem;
            str2 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
            strcpy((char *)str2, (char *)len);
            v8 = v1[0] + 2;
            v1[0] = v8;
            *(int32_t *)(v4 - 4 + 4 * (int32_t)v8) = 0;
            // branch -> 0x8049a44
        } else {
            // 0x8049846
            v14 = v4 - 4;
            strcpy(str3, (char *)*(int32_t *)(4 * v10 + v14));
            str5 = (int32_t *)(v4 + 4 * pos);
            strcpy((char *)&str4, (char *)*str5);
            free((char *)*str5);
            len3 = strlen((char *)len);
            *str5 = (int32_t)malloc(len3 + 1);
            strcpy((char *)*str5, (char *)len);
            n = pos;
            v13 = v1[0];
            if ((int32_t)v13 - 1 > pos) {
                // 0x80498f9
                v15 = v4 + 4;
                str7 = *(int32_t *)(4 * pos + v15);
                strcpy((char *)&str6, (char *)str7);
                free((char *)*(int32_t *)(4 * n + v15));
                len4 = strlen((char *)&str4);
                *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
                str8 = *(int32_t *)(4 * n + v15);
                strcpy((char *)str8, (char *)&str4);
                strcpy((char *)&str4, (char *)&str6);
                v7 = n + 1;
                n = v7;
                v12 = v1[0];
                // branch -> 0x80498f9
                while ((int32_t)v12 - 1 > v7) {
                    // 0x80498f9
                    str7 = *(int32_t *)(4 * v7 + v15);
                    strcpy((char *)&str6, (char *)str7);
                    free((char *)*(int32_t *)(4 * n + v15));
                    len4 = strlen((char *)&str4);
                    *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
                    str8 = *(int32_t *)(4 * n + v15);
                    strcpy((char *)str8, (char *)&str4);
                    strcpy((char *)&str4, (char *)&str6);
                    v7 = n + 1;
                    n = v7;
                    v12 = v1[0];
                    // continue -> 0x80498f9
                }
                // 0x80499d0
                len5 = strlen(str3);
                mem2 = malloc(len5 + 1);
                *(int32_t *)(4 * (int32_t)v12 + v4) = (int32_t)mem2;
                str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
                strcpy((char *)str9, str3);
                v9 = v1[0] + 2;
                v1[0] = v9;
                *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
                // branch -> 0x8049a44
                // 0x8049a44
                if (*(int32_t *)20 != v5) {
                    // 0x8049a50
                    __stack_chk_fail();
                    // branch -> 0x8049a55
                }
                // 0x8049a55
                return v1[0];
            }
            // 0x80499d0
            len5 = strlen(str3);
            mem2 = malloc(len5 + 1);
            *(int32_t *)(4 * (int32_t)v13 + v4) = (int32_t)mem2;
            str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
            strcpy((char *)str9, str3);
            v9 = v1[0] + 2;
            v1[0] = v9;
            *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
            // branch -> 0x8049a44
        }
        // 0x8049a44
        if (*(int32_t *)20 != v5) {
            // 0x8049a50
            __stack_chk_fail();
            // branch -> 0x8049a55
        }
        // 0x8049a55
        return v1[0];
    }
    // 0x8049797
    print_error(-21, "insert: invalid line number %i.\n");
    // branch -> 0x80497b2
    // 0x80497b2
    v10 = v1[0];
    if (v10 == pos) {
        // 0x80497c1
        len2 = strlen((char *)len);
        v11 = v1[0];
        mem = malloc(len2 + 1);
        *(int32_t *)(4 * (int32_t)v11 + v4) = (int32_t)mem;
        str2 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
        strcpy((char *)str2, (char *)len);
        v8 = v1[0] + 2;
        v1[0] = v8;
        *(int32_t *)(v4 - 4 + 4 * (int32_t)v8) = 0;
        // branch -> 0x8049a44
    } else {
        // 0x8049846
        v14 = v4 - 4;
        strcpy(str3, (char *)*(int32_t *)(4 * v10 + v14));
        str5 = (int32_t *)(v4 + 4 * pos);
        strcpy((char *)&str4, (char *)*str5);
        free((char *)*str5);
        len3 = strlen((char *)len);
        *str5 = (int32_t)malloc(len3 + 1);
        strcpy((char *)*str5, (char *)len);
        n = pos;
        v13 = v1[0];
        if ((int32_t)v13 - 1 > pos) {
            // 0x80498f9
            v15 = v4 + 4;
            str7 = *(int32_t *)(4 * pos + v15);
            strcpy((char *)&str6, (char *)str7);
            free((char *)*(int32_t *)(4 * n + v15));
            len4 = strlen((char *)&str4);
            *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
            str8 = *(int32_t *)(4 * n + v15);
            strcpy((char *)str8, (char *)&str4);
            strcpy((char *)&str4, (char *)&str6);
            v7 = n + 1;
            n = v7;
            v12 = v1[0];
            // branch -> 0x80498f9
            while ((int32_t)v12 - 1 > v7) {
                // 0x80498f9
                str7 = *(int32_t *)(4 * v7 + v15);
                strcpy((char *)&str6, (char *)str7);
                free((char *)*(int32_t *)(4 * n + v15));
                len4 = strlen((char *)&str4);
                *(int32_t *)(v15 + 4 * n) = (int32_t)malloc(len4 + 1);
                str8 = *(int32_t *)(4 * n + v15);
                strcpy((char *)str8, (char *)&str4);
                strcpy((char *)&str4, (char *)&str6);
                v7 = n + 1;
                n = v7;
                v12 = v1[0];
                // continue -> 0x80498f9
            }
            // 0x80499d0
            len5 = strlen(str3);
            mem2 = malloc(len5 + 1);
            *(int32_t *)(4 * (int32_t)v12 + v4) = (int32_t)mem2;
            str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
            strcpy((char *)str9, str3);
            v9 = v1[0] + 2;
            v1[0] = v9;
            *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
            // branch -> 0x8049a44
            // 0x8049a44
            if (*(int32_t *)20 != v5) {
                // 0x8049a50
                __stack_chk_fail();
                // branch -> 0x8049a55
            }
            // 0x8049a55
            return v1[0];
        }
        // 0x80499d0
        len5 = strlen(str3);
        mem2 = malloc(len5 + 1);
        *(int32_t *)(4 * (int32_t)v13 + v4) = (int32_t)mem2;
        str9 = *(int32_t *)(4 * (int32_t)v1[0] + v4);
        strcpy((char *)str9, str3);
        v9 = v1[0] + 2;
        v1[0] = v9;
        *(int32_t *)(4 * (int32_t)v9 + v14) = 0;
        // branch -> 0x8049a44
    }
    // 0x8049a44
    if (*(int32_t *)20 != v5) {
        // 0x8049a50
        __stack_chk_fail();
        // branch -> 0x8049a55
    }
    // 0x8049a55
    return v1[0];
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049a5e - 0x8049b5e
// Line range:    190 - 221
int32_t delete_str(int32_t pos, char ** strarr) {
    int32_t v1 = (int32_t)strarr; // 0x8049a78_0
    int32_t v2 = 0;
    // branch -> 0x8049a72
    while (*(int32_t *)(4 * v2 + v1) != 0) {
        // 0x8049a72
        v2++;
        // continue -> 0x8049a72
    }
    // 0x8049a81
    int32_t v3; // 0x8049ac8
    int32_t * str; // 0x8049ad1_0
    int32_t * v4; // bp+035
    int32_t * str2; // bp+041
    int32_t result; // 0x8049b43
    if (pos >= 0) {
        // 0x8049a87
        if (v2 >= pos) {
            // 0x8049aaa
            v4 = (int32_t *)(v1 + 4 * pos);
            if (*v4 == 0) {
                // 0x8049b43
                result = pos - 1;
                *(int32_t *)(4 * result + v1) = 0;
                return result;
            }
            str2 = v4;
            int32_t v5 = pos;
            while (true) {
                // 0x8049ab2
                free((char *)*str2);
                v3 = v5 + 1;
                str = (int32_t *)(4 * v3 + v1);
                if (*str != 0) {
                  lab_0x8049ad7_2:
                    // 0x8049ad7
                    *str2 = (int32_t)malloc(strlen((char *)*str) + 1);
                    strcpy((char *)*str2, (char *)*str);
                    // branch -> 0x8049b30
                }
              lab_0x8049b30_2:
                // 0x8049b30
                if (*str == 0) {
                    // break -> 0x8049b43
                    break;
                }
                str2 = str;
                v5 = v3;
                // continue -> 0x8049ab2
            }
            // 0x8049b43
            result = v3 - 1;
            *(int32_t *)(4 * result + v1) = 0;
            return result;
        }
        // 0x8049a8f
        print_error(-21, "delete: invalid line number %i.\n");
        // branch -> 0x8049aaa
        // 0x8049aaa
        v4 = (int32_t *)(v1 + 4 * pos);
        if (*v4 == 0) {
            // 0x8049b43
            result = pos - 1;
            *(int32_t *)(4 * result + v1) = 0;
            return result;
        }
        str2 = v4;
        while (true) {
            // 0x8049ab2
            free((char *)*str2);
            v3 = pos + 1;
            str = (int32_t *)(4 * v3 + v1);
            if (*str == 0) {
                goto lab_0x8049b30_2;
            }
            goto lab_0x8049ad7_2;
        }
    }
    // 0x8049a8f
    print_error(-21, "delete: invalid line number %i.\n");
    // branch -> 0x8049aaa
    // 0x8049aaa
    v4 = (int32_t *)(v1 + 4 * pos);
    if (*v4 == 0) {
        // 0x8049b43
        result = pos - 1;
        *(int32_t *)(4 * result + v1) = 0;
        return result;
    }
    str2 = v4;
    while (true) {
        // 0x8049ab2
        free((char *)*str2);
        v3 = pos + 1;
        str = (int32_t *)(4 * v3 + v1);
        if (*str == 0) {
            goto lab_0x8049b30_2;
        }
        goto lab_0x8049ad7_2;
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049b5f - 0x8049bd8
// Line range:    230 - 251
int32_t find_pos(char * str, char ** strarr, int32_t start) {
    // 0x8049b5f
    int32_t v1;
    int32_t i = v1; // bp-20
    int32_t v2;
    g2 = &v2;
    int32_t v3 = (int32_t)strarr; // 0x8049b78_0
    int32_t v4 = 0;
    // branch -> 0x8049b72
    while (*(int32_t *)(4 * v4 + v3) != 0) {
        // 0x8049b72
        v4++;
        // continue -> 0x8049b72
    }
    // 0x8049b81
    if (start < 0 || v4 < start) {
        // 0x8049b8f
        exit(-21);
        // UNREACHABLE
    }
    // 0x8049b9b
    i = start;
    if (v4 > start) {
        while (true) {
            int32_t v5 = i; // 0x8049bc6
            int32_t result = v5;
            if (strstr((char *)*(int32_t *)(4 * start + v3), str) == NULL) {
                int32_t v6 = v5 + 1; // 0x8049bc6
                i = v6;
                if (v6 >= v4) {
                    // break -> 0x8049bd7
                    break;
                }
                start = v6;
                // continue -> 0x8049ba3
                continue;
            }
            // 0x8049bd7
            // branch -> 0x8049bd7
            // 0x8049bd7
            g2 = v2;
            return result;
        }
        // 0x8049bd7
        // branch -> 0x8049bd7
    }
    // 0x8049bd7
    g2 = v2;
    return -1;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049c27 - 0x8049d40
// Line range:    273 - 298
void get_package_name(char * path, char * name) {
    char str2[2048];
    char v1[2048];
    int32_t v2 = *(int32_t *)20; // 0x8049c43
    int32_t str;
    sprintf((char *)&str, "%s/%s", path, "name");
    char file = (int32_t)fopen((char *)&str, "r");
    v1[0] = file;
    if (file == 0) {
        // 0x8049c9c
        print_error(-6, "'name' file not readable.\n");
        // branch -> 0x8049d20
        // 0x8049d20
        fclose((struct _IO_FILE *)(int32_t)v1[0]);
        if (*(int32_t *)20 != v2) {
            // 0x8049d3a
            __stack_chk_fail();
            // branch -> 0x8049d3f
        }
        // 0x8049d3f
        return;
    }
    // 0x8049cb2
    if (nc_fgets_nb(str2, 2048, (struct _IO_FILE_2 *)(int32_t)file) == NULL) {
        // 0x8049cd6
        fclose((struct _IO_FILE *)(int32_t)v1[0]);
        print_error(-6, "invalid or missing extension name.\n");
        // branch -> 0x8049d20
    } else {
        // 0x8049cfa
        chop(str2);
        strcpy(name, str2);
        // branch -> 0x8049d20
    }
    // 0x8049d20
    fclose((struct _IO_FILE *)(int32_t)v1[0]);
    if (*(int32_t *)20 != v2) {
        // 0x8049d3a
        __stack_chk_fail();
        // branch -> 0x8049d3f
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049d41 - 0x8049e13
// Line range:    307 - 333
char * nc_fgets(char * s, int32_t size, struct _IO_FILE_2 * stream) {
    // 0x8049d41
    char * v1;
    char * hashmark = v1; // bp-20
    int32_t v2 = (int32_t)s; // 0x8049d55_0
    if (fgets(s, size, (struct _IO_FILE *)stream) == NULL) {
        // 0x8049d64
        // branch -> 0x8049e12
        // 0x8049e12
        return (char *)0;
    }
    char * found_char_pos = strchr(s, 35); // 0x8049d7c
    if (found_char_pos == NULL) {
        // 0x8049e0f
        // branch -> 0x8049e12
        // 0x8049e12
        return (char *)v2;
    }
    // 0x8049d8e
    int32_t v3; // 0x8049e13_2
    if (found_char_pos == s) {
        // 0x8049d96
        v3 = (int32_t)nc_fgets(s, size, stream);
        // branch -> 0x8049e12
    } else {
        char * mem = malloc(2048); // 0x8049db8
        hashmark = mem;
        strcpy(mem, s);
        char * next_token = strtok(hashmark, "#"); // 0x8049de1
        hashmark = next_token;
        sprintf(s, "%s\n", next_token);
        free(hashmark);
        // branch -> 0x8049e0f
        // 0x8049e0f
        v3 = v2;
        // branch -> 0x8049e12
    }
    // 0x8049e12
    return (char *)v3;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049e14 - 0x804a145
// Line range:    339 - 467
char * nc_fgets_html(char * s, int32_t size, struct _IO_FILE_2 * stream) {
    // 0x8049e14
    char * v1;
    char * insert = v1; // bp-48
    char * v2;
    char * pos = v2; // bp-44
    char * v3;
    char * tag_content = v3; // bp-40
    char * v4;
    char * tag_insert = v4; // bp-36
    char * v5;
    char * tag_2 = v5; // bp-32
    char * v6;
    char * tmp = v6; // bp-24
    char * v7;
    char * hashmark = v7; // bp-20
    int32_t v8 = (int32_t)s; // 0x8049e28_0
    if (fgets(s, size, (struct _IO_FILE *)stream) == NULL) {
        // 0x8049e37
        // branch -> 0x804a144
        // 0x804a144
        return (char *)0;
    }
    // 0x8049e41
    hashmark = malloc(strlen(s) + 1);
    tag_insert = malloc(strlen(s) + 1);
    char * v9 = hashmark; // 0x8049e73
    pos = v9;
    tag_content = s;
    char * found_char_pos; // 0x804a0ae
    char * mem; // 0x804a0ea
    char * next_token; // 0x804a113
    int32_t v10; // 0x804a145_2
    if (*s != 0) {
        char * v11 = s; // 0x804a03330
      lab_0x8049e84:
        while (true) {
            int32_t v12 = (int32_t)v11; // 0x8049e84_0
            char * v13 = v11; // 0x804a051
            char * v14; // 0x804a060
            if (*v11 == 60) {
                // 0x8049e92
                tmp = v11;
                tag_2 = tag_insert;
                uint32_t v15 = v12 - 1; // 0x8049e9e
                char * v16 = (char *)v15; // 0x8049e9e_7
                tag_content = v16;
                char * v17; // 0x8049ed0
                char * v18; // 0x8049ed6
                if (v15 >= v8) {
                    // 0x8049eae
                    if (*v16 == 32) {
                        // 0x8049eb8
                        insert = (char *)1;
                        // branch -> 0x804a033
                    } else {
                        // 0x8049ec4
                        insert = NULL;
                        // branch -> 0x804a033
                    }
                    // 0x804a033
                    v13 = v16;
                    if (*v11 != 0) {
                        v18 = tag_insert;
                        v17 = v11;
                      lab_0x8049ed0:
                        while (true) {
                            // 0x8049ed0
                            *v18 = *v17;
                            char * v19 = tag_2; // 0x8049edb
                            *v19 = *v19 + 1;
                            char * v20 = tmp; // 0x8049ee9
                            int32_t v21 = (int32_t)v20; // 0x8049ee9_0
                            if (*v20 == 62) {
                                // 0x8049ef7
                                *tag_2 = 0;
                                if (*(char *)((int32_t)tmp + 1) != 10) {
                                    // 0x8049f15
                                    if (strstr(tag_insert, "<br>") != NULL) {
                                        char * v22 = pos; // 0x8049f2c
                                        if (v22 > hashmark) {
                                            // 0x8049f34
                                            *v22 = 10;
                                            char * v23 = pos; // 0x8049f3a
                                            *v23 = *v23 + 1;
                                            // branch -> 0x8049f48
                                        }
                                    }
                                    // 0x8049f48
                                    if (strstr(tag_insert, "<BR>") != NULL) {
                                        char * v24 = pos; // 0x8049f5f
                                        if (v24 > hashmark) {
                                            // 0x8049f67
                                            *v24 = 10;
                                            char * v25 = pos; // 0x8049f6d
                                            *v25 = *v25 + 1;
                                            // branch -> 0x8049f7b
                                        }
                                    }
                                    // 0x8049f7b
                                    if (strstr(tag_insert, "<p>") != NULL) {
                                        char * v26 = pos; // 0x8049f92
                                        char * v27 = v26; // 0x8049fae
                                        if (v26 > hashmark) {
                                            // 0x8049f9a
                                            *v26 = 10;
                                            char * v28 = pos; // 0x8049fa0
                                            *v28 = *v28 + 1;
                                            v27 = pos;
                                            // branch -> 0x8049fae
                                        }
                                        // 0x8049fae
                                        *v27 = 10;
                                        char * v29 = pos; // 0x8049fb4
                                        *v29 = *v29 + 1;
                                        // branch -> 0x8049fc2
                                    }
                                    // 0x8049fc2
                                    if (strstr(tag_insert, "<P>") != NULL) {
                                        char * v30 = pos; // 0x8049fd9
                                        char * v31 = v30; // 0x8049ff5
                                        if (v30 > hashmark) {
                                            // 0x8049fe1
                                            *v30 = 10;
                                            char * v32 = pos; // 0x8049fe7
                                            *v32 = *v32 + 1;
                                            v31 = pos;
                                            // branch -> 0x8049ff5
                                        }
                                        // 0x8049ff5
                                        *v31 = 10;
                                        char * v33 = pos; // 0x8049ffb
                                        *v33 = *v33 + 1;
                                        // branch -> 0x804a009
                                    }
                                }
                                char * v34 = tmp; // 0x804a009
                                int32_t v35 = (int32_t)v34; // 0x804a009_0
                                tag_content = v34;
                                if (*v34 == 32 && insert == (char *)1) {
                                    char * v36 = (char *)(v35 + 1); // 0x804a01f_8
                                    tag_content = v36;
                                    insert = NULL;
                                    v13 = v36;
                                    // branch -> 0x804a047
                                } else {
                                    v13 = v34;
                                }
                            } else {
                                char * v37 = (char *)(v21 + 1); // 0x804a02c_8
                                tmp = v37;
                                if (*v37 == 0) {
                                    // 0x804a033
                                    v13 = tag_content;
                                    // branch -> 0x804a047
                                    // 0x804a047
                                    v14 = v13;
                                    if (*v13 != 62) {
                                      lab_0x804a051_3:
                                        // 0x804a051
                                        *pos = *v13;
                                        pos = (char *)((int32_t)pos + 1);
                                        v14 = tag_content;
                                        // branch -> 0x804a060
                                    }
                                  lab_0x804a060_3:;
                                    char * v38 = (char *)((int32_t)v14 + 1); // 0x804a060_8
                                    tag_content = v38;
                                    if (*v38 == 0) {
                                        // break (via goto) -> 0x804a064
                                        goto lab_0x804a064;
                                    }
                                    v11 = v38;
                                    // continue (via goto) -> 0x8049e84
                                    goto lab_0x8049e84;
                                } else {
                                    // 0x804a02c
                                    v18 = tag_2;
                                    v17 = v37;
                                    // branch -> 0x8049ed0
                                    continue;
                                }
                            }
                            // 0x804a047
                            if (*v13 == 62) {
                                v14 = v13;
                                goto lab_0x804a060_3;
                            }
                            goto lab_0x804a051_3;
                        }
                      lab_0x804a064:
                        // 0x804a064
                        // branch -> 0x804a072
                        // 0x804a072
                        *pos = 0;
                        strcpy(s, hashmark);
                        free(hashmark);
                        free(tag_insert);
                        found_char_pos = strchr(s, 35);
                        if (found_char_pos == NULL) {
                            // 0x804a141
                            // branch -> 0x804a144
                            // 0x804a144
                            return (char *)v8;
                        }
                        // 0x804a0c0
                        if (found_char_pos == s) {
                            // 0x804a0c8
                            v10 = (int32_t)nc_fgets_html(s, size, stream);
                            // branch -> 0x804a144
                            // 0x804a144
                            return (char *)v10;
                        }
                        // 0x804a0e3
                        mem = malloc(2048);
                        hashmark = mem;
                        strcpy(mem, s);
                        next_token = strtok(hashmark, "#");
                        hashmark = next_token;
                        sprintf(s, "%s\n", next_token);
                        free(hashmark);
                        // branch -> 0x804a141
                        // 0x804a141
                        // branch -> 0x804a144
                        // 0x804a144
                        return (char *)v8;
                    }
                  lab_0x804a047:
                    // 0x804a047
                    if (*v13 == 62) {
                        v14 = v13;
                        goto lab_0x804a060_3;
                    }
                    goto lab_0x804a051_3;
                }
                // 0x804a033
                if (*v11 == 0) {
                    v13 = v16;
                    goto lab_0x804a047;
                }
                v18 = tag_insert;
                v17 = v11;
                goto lab_0x8049ed0;
            }
            // 0x804a047
            if (*v13 == 62) {
                v14 = v13;
                goto lab_0x804a060_3;
            }
            goto lab_0x804a051_3;
        }
    }
    // 0x804a072
    *v9 = 0;
    strcpy(s, hashmark);
    free(hashmark);
    free(tag_insert);
    found_char_pos = strchr(s, 35);
    if (found_char_pos == NULL) {
        // 0x804a141
        // branch -> 0x804a144
        // 0x804a144
        return (char *)v8;
    }
    // 0x804a0c0
    if (found_char_pos == s) {
        // 0x804a0c8
        v10 = (int32_t)nc_fgets_html(s, size, stream);
        // branch -> 0x804a144
    } else {
        // 0x804a0e3
        mem = malloc(2048);
        hashmark = mem;
        strcpy(mem, s);
        next_token = strtok(hashmark, "#");
        hashmark = next_token;
        sprintf(s, "%s\n", next_token);
        free(hashmark);
        // branch -> 0x804a141
        // 0x804a141
        v10 = v8;
        // branch -> 0x804a144
    }
    // 0x804a144
    return (char *)v10;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a146 - 0x804a1c7
// Line range:    474 - 493
int32_t is_text(char * s) {
    // 0x804a146
    int32_t v1;
    int32_t i = v1; // bp-20
    i = 0;
    int32_t v2 = strlen(s) - 1; // 0x804a15e
    if (v2 <= 0) {
        // 0x804a146
        // branch -> 0x804a1c3
        // 0x804a1c3
        return i;
    }
    while (true) {
        char * v3 = (char *)(v2 + (int32_t)s);
        if (*v3 != 32) {
            // 0x804a173
            if (*v3 != 9) {
                // 0x804a180
                if (*v3 != 10) {
                    // 0x804a18d
                    if (*v3 != 12) {
                        // 0x804a19a
                        if (*v3 != 13) {
                            // 0x804a1b4
                            i = 1;
                            // branch -> 0x804a1c3
                            // 0x804a1c3
                            return 1;
                        }
                    }
                }
            }
        }
        // 0x804a1a7
        i = 0;
        if (v2 <= 1) {
            // break -> 0x804a1c3
            break;
        }
        v2--;
        // continue -> 0x804a166
    }
    // 0x804a1c3
    return 0;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a1c8 - 0x804a2c7
// Line range:    500 - 532
char * nc_fgets_nb(char * s, int32_t size, struct _IO_FILE_2 * stream) {
    // 0x804a1c8
    char * v1;
    char * hashmark = v1; // bp-20
    int32_t v2 = (int32_t)s; // 0x804a1dc_0
    if (fgets(s, size, (struct _IO_FILE *)stream) == NULL) {
        // 0x804a1eb
        // branch -> 0x804a2c6
        // 0x804a2c6
        return (char *)0;
    }
    // 0x804a1f5
    int32_t v3; // 0x804a2c7_2
    if (is_text(s) == 0) {
        // 0x804a204
        v3 = (int32_t)nc_fgets_nb(s, size, stream);
        // branch -> 0x804a2c6
        // 0x804a2c6
        return (char *)v3;
    }
    char * found_char_pos = strchr(s, 35); // 0x804a230
    if (found_char_pos == NULL) {
        // 0x804a2c3
        // branch -> 0x804a2c6
        // 0x804a2c6
        return (char *)v2;
    }
    // 0x804a242
    if (found_char_pos == s) {
        // 0x804a24a
        v3 = (int32_t)nc_fgets_nb(s, size, stream);
        // branch -> 0x804a2c6
    } else {
        char * mem = malloc(2048); // 0x804a26c
        hashmark = mem;
        strcpy(mem, s);
        char * next_token = strtok(hashmark, "#"); // 0x804a295
        hashmark = next_token;
        sprintf(s, "%s\n", next_token);
        free(hashmark);
        // branch -> 0x804a2c3
        // 0x804a2c3
        v3 = v2;
        // branch -> 0x804a2c6
    }
    // 0x804a2c6
    return (char *)v3;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a2c8 - 0x804a3da
// Line range:    539 - 556
void dump_ascii(char * file, char * heading) {
    char v1[2048];
    char v2[2048];
    int32_t v3 = *(int32_t *)20; // 0x804a2e4
    fprintf((struct _IO_FILE *)g15, "%s\n", heading);
    char file2 = (int32_t)fopen(file, "r");
    v2[0] = file2;
    if (file2 == 0) {
        // 0x804a334
        fwrite("  No information available.\n", 1, 28, (struct _IO_FILE *)g15);
        // branch -> 0x804a3c8
    } else {
        // 0x804a381
        if (nc_fgets_html(v1, 2048, (struct _IO_FILE_2 *)(int32_t)file2) != NULL) {
            fprintf((struct _IO_FILE *)g15, "  %s", v1);
            char v4 = v2[0]; // 0x804a381
            while (nc_fgets_html(v1, 2048, (struct _IO_FILE_2 *)(int32_t)v4) != NULL) {
                // 0x804a35e
                fprintf((struct _IO_FILE *)g15, "  %s", v1);
                v4 = v2[0];
                // continue -> 0x804a35e
            }
            // 0x804a3a5
            fputc(10, (struct _IO_FILE *)g15);
            fclose((struct _IO_FILE *)(int32_t)v2[0]);
            // branch -> 0x804a3c8
            // 0x804a3c8
            if (*(int32_t *)20 != v3) {
                // 0x804a3d4
                __stack_chk_fail();
                // branch -> 0x804a3d9
            }
            // 0x804a3d9
            return;
        }
        // 0x804a3a5
        fputc(10, (struct _IO_FILE *)g15);
        fclose((struct _IO_FILE *)(int32_t)v2[0]);
        // branch -> 0x804a3c8
    }
    // 0x804a3c8
    if (*(int32_t *)20 != v3) {
        // 0x804a3d4
        __stack_chk_fail();
        // branch -> 0x804a3d9
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a3db - 0x804a51a
// Line range:    563 - 590
void dump_plain(char * file, char * tmpfile) {
    char format[2048];
    char v1[2048];
    // 0x804a3db
    struct _IO_FILE_2 * v2;
    struct _IO_FILE_2 * f_in = v2; // bp-2072
    int32_t v3 = *(int32_t *)20; // 0x804a3f7
    memcpy(tmpfile, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(tmpfile);
    struct _IO_FILE * file2 = fopen(tmpfile, "w+"); // 0x804a440
    f_in = (struct _IO_FILE_2 *)file2;
    if (file2 == NULL) {
        int32_t err_num = *__errno_location(); // 0x804a459
        strerror(err_num);
        print_error(-23, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        // branch -> 0x804a485
    }
    // 0x804a485
    atexit((void (**)())exit_db);
    struct _IO_FILE * file3 = fopen(file, "r"); // 0x804a4a3
    v1[0] = (int32_t)file3;
    if (nc_fgets(format, 2048, (struct _IO_FILE_2 *)file3) == NULL) {
        // 0x804a4ec
        fclose((struct _IO_FILE *)(int32_t)v1[0]);
        fclose((struct _IO_FILE *)f_in);
        if (*(int32_t *)20 != v3) {
            // 0x804a514
            __stack_chk_fail();
            // branch -> 0x804a519
        }
        // 0x804a519
        return;
    }
    fprintf((struct _IO_FILE *)f_in, format);
    char v4 = v1[0]; // 0x804a4c8
    while (nc_fgets(format, 2048, (struct _IO_FILE_2 *)(int32_t)v4) != NULL) {
        // 0x804a4b0
        fprintf((struct _IO_FILE *)f_in, format);
        v4 = v1[0];
        // continue -> 0x804a4b0
    }
    // 0x804a4ec
    fclose((struct _IO_FILE *)(int32_t)v1[0]);
    fclose((struct _IO_FILE *)f_in);
    if (*(int32_t *)20 != v3) {
        // 0x804a514
        __stack_chk_fail();
        // branch -> 0x804a519
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a51b - 0x804a6d9
// Line range:    597 - 634
void dump_html(char * file, char * tmpfile) {
    char v1[2048];
    char v2[2048];
    // 0x804a51b
    int32_t v3;
    int32_t fd = v3; // bp-4128
    struct _IO_FILE_2 * v4;
    struct _IO_FILE_2 * f_out = v4; // bp-4124
    struct _IO_FILE_2 * v5;
    struct _IO_FILE_2 * f_in = v5; // bp-4120
    fd = (int32_t)file;
    int32_t v6 = *(int32_t *)20; // 0x804a537
    memcpy(tmpfile, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(tmpfile);
    struct _IO_FILE * file2 = fopen(tmpfile, "w+"); // 0x804a580
    f_in = (struct _IO_FILE_2 *)file2;
    if (file2 == NULL) {
        int32_t err_num = *__errno_location(); // 0x804a599
        strerror(err_num);
        print_error(-23, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        // branch -> 0x804a5c5
    }
    // 0x804a5c5
    atexit((void (**)())exit_db);
    struct _IO_FILE * file3 = fopen((char *)fd, "r"); // 0x804a5e3
    v1[0] = (int32_t)file3;
    if (nc_fgets(v2, 2048, (struct _IO_FILE_2 *)file3) == NULL) {
        // 0x804a69d
        fclose((struct _IO_FILE *)(int32_t)v1[0]);
        fclose((struct _IO_FILE *)f_in);
        close((int32_t)f_out);
        if (*(int32_t *)20 != v6) {
            // 0x804a6d3
            __stack_chk_fail();
            // branch -> 0x804a6d8
        }
        // 0x804a6d8
        return;
    }
    // 0x804a5f3
    // branch -> 0x804a5f3
    while (true) {
        // 0x804a5f3
        chop(v2);
        if (is_text(v2) == 0) {
            // 0x804a613
            fwrite("<p>\n", 1, 4, (struct _IO_FILE *)f_in);
            // branch -> 0x804a675
        } else {
            // 0x804a63c
            int32_t str;
            sprintf((char *)&str, "%s <br>\n", v2);
            fprintf((struct _IO_FILE *)f_in, (char *)&str);
            // branch -> 0x804a675
        }
        // 0x804a675
        if (nc_fgets(v2, 2048, (struct _IO_FILE_2 *)(int32_t)v1[0]) == NULL) {
            // break -> 0x804a69d
            break;
        }
        // continue -> 0x804a5f3
    }
    // 0x804a69d
    fclose((struct _IO_FILE *)(int32_t)v1[0]);
    fclose((struct _IO_FILE *)f_in);
    close((int32_t)f_out);
    if (*(int32_t *)20 != v6) {
        // 0x804a6d3
        __stack_chk_fail();
        // branch -> 0x804a6d8
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a6da - 0x804a92b
// Line range:    642 - 683
void list_binaries(char * package) {
    char str[2048];
    char v1[2048];
    struct dirent * v2;
    struct dirent * dir_entry = v2; // bp-2076
    struct __dirstream_1 * v3;
    struct __dirstream_1 * dir = v3; // bp-2072
    int32_t v4 = *(int32_t *)20; // 0x804a6ed
    dir_entry = NULL;
    fwrite("Binary installation files\n", 1, 26, (struct _IO_FILE *)g15);
    char dirp = (int32_t)opendir(package);
    v1[0] = dirp;
    if (dirp == 0) {
        // 0x804a746
        fwrite("  None.\n\n", 1, 9, (struct _IO_FILE *)g15);
        // branch -> 0x804a919
    } else {
        struct dirent * v5 = readdir((struct __dirstream *)(int32_t)dirp); // 0x804a77c
        dir = (struct __dirstream_1 *)v5;
        if (v5 != NULL) {
            // branch -> 0x804a78c
            while (true) {
                // 0x804a78c
                if (strcmp((char *)((int32_t)v5 + 11), ".") != 0) {
                    // 0x804a7ad
                    if (strcmp((char *)((int32_t)dir + 11), "..") != 0) {
                        // 0x804a7ce
                        if (strcmp((char *)((int32_t)dir + 11), "src") != 0) {
                            // 0x804a7ef
                            sprintf(str, "%s/%s", package, (void (**)())((int32_t)dir + 11));
                            int32_t buf;
                            stat(str, (struct stat *)&buf);
                            int32_t v6;
                            if ((v6 & 0xf000) == 0x4000) {
                                char * v7 = (char *)((int32_t)dir + 11);
                                if (dir_entry == NULL) {
                                    // 0x804a850
                                    fprintf((struct _IO_FILE *)g15, "  %s", v7);
                                    // branch -> 0x804a898
                                } else {
                                    // 0x804a875
                                    fprintf((struct _IO_FILE *)g15, ", %s", v7);
                                    // branch -> 0x804a898
                                }
                                // 0x804a898
                                dir_entry = (struct dirent *)((int32_t)dir_entry + 1);
                                // branch -> 0x804a89f
                            }
                        }
                    }
                }
                struct dirent * v8 = readdir((struct __dirstream *)(int32_t)v1[0]); // 0x804a8a8
                dir = (struct __dirstream_1 *)v8;
                if (v8 == NULL) {
                    // break -> 0x804a8c0
                    break;
                }
                v5 = v8;
                // continue -> 0x804a78c
            }
            // 0x804a8c0
            if (dir_entry == NULL) {
                // 0x804a8c9
                fwrite("  None.", 1, 7, (struct _IO_FILE *)g15);
                // branch -> 0x804a8f1
            }
            // 0x804a8f1
            fwrite("\n\n", 1, 2, (struct _IO_FILE *)g15);
            // branch -> 0x804a919
            // 0x804a919
            if (*(int32_t *)20 != v4) {
                // 0x804a925
                __stack_chk_fail();
                // branch -> 0x804a92a
            }
            // 0x804a92a
            return;
        }
        // 0x804a8c0
        if (dir_entry == NULL) {
            // 0x804a8c9
            fwrite("  None.", 1, 7, (struct _IO_FILE *)g15);
            // branch -> 0x804a8f1
        }
        // 0x804a8f1
        fwrite("\n\n", 1, 2, (struct _IO_FILE *)g15);
        // branch -> 0x804a919
    }
    // 0x804a919
    if (*(int32_t *)20 != v4) {
        // 0x804a925
        __stack_chk_fail();
        // branch -> 0x804a92a
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a92c - 0x804aaa7
// Line range:    690 - 720
int32_t binaries_exist(char * package, char * binaries) {
    char str[2048];
    char v1[2048];
    struct __dirstream_1 * v2;
    struct __dirstream_1 * dir = v2; // bp-2072
    int32_t v3 = *(int32_t *)20; // 0x804a948
    char dirp = (int32_t)opendir(package);
    v1[0] = dirp;
    if (dirp == 0) {
        // 0x804a96f
        // branch -> 0x804aa95
    } else {
        struct dirent * v4 = readdir((struct __dirstream *)(int32_t)dirp); // 0x804a982
        dir = (struct __dirstream_1 *)v4;
        if (v4 != NULL) {
            // branch -> 0x804a992
            while (true) {
                // 0x804a992
                if (strcmp((char *)((int32_t)v4 + 11), ".") != 0) {
                    // 0x804a9b3
                    if (strcmp((char *)((int32_t)dir + 11), "..") != 0) {
                        // 0x804a9d4
                        if (strcmp((char *)((int32_t)dir + 11), "src") != 0) {
                            // 0x804a9f1
                            sprintf(str, "%s/%s", package, (char *)((int32_t)dir + 11));
                            int32_t buf;
                            stat(str, (struct stat *)&buf);
                            int32_t v5;
                            if ((v5 & 0xf000) == 0x4000) {
                                // 0x804aa49
                                if (strcmp((char *)((int32_t)dir + 11), binaries) == 0) {
                                    // 0x804aa68
                                    // branch -> 0x804aa95
                                    // 0x804aa95
                                    if (*(int32_t *)20 != v3) {
                                        // 0x804aaa1
                                        __stack_chk_fail();
                                        // branch -> 0x804aaa6
                                    }
                                    // 0x804aaa6
                                    return 1;
                                }
                            }
                        }
                    }
                }
                struct dirent * v6 = readdir((struct __dirstream *)(int32_t)v1[0]); // 0x804aa78
                dir = (struct __dirstream_1 *)v6;
                if (v6 == NULL) {
                    // break -> 0x804aa90
                    break;
                }
                v4 = v6;
                // continue -> 0x804a992
            }
            // 0x804aa90
            // branch -> 0x804aa95
            // 0x804aa95
            if (*(int32_t *)20 != v3) {
                // 0x804aaa1
                __stack_chk_fail();
                // branch -> 0x804aaa6
            }
            // 0x804aaa6
            return 0;
        }
        // 0x804aa90
        // branch -> 0x804aa95
    }
    // 0x804aa95
    if (*(int32_t *)20 != v3) {
        // 0x804aaa1
        __stack_chk_fail();
        // branch -> 0x804aaa6
    }
    // 0x804aaa6
    return 0;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804aaa8 - 0x804ab6b
// Line range:    737 - 760
int32_t check_filetype(char * myfile) {
    // 0x804aaa8
    if (strstr(myfile, ".tar.gz") != NULL || strstr(myfile, ".tgz") != NULL) {
        // 0x804aac5
        // branch -> 0x804ab6a
        // 0x804ab6a
        return 1;
    }
    // 0x804aaed
    if (strstr(myfile, ".tar.bz2") != NULL || strstr(myfile, ".tbz") != NULL) {
        // 0x804ab04
        // branch -> 0x804ab6a
        // 0x804ab6a
        return 2;
    }
    // 0x804ab29
    if (strstr(myfile, ".zip") != NULL) {
        // 0x804ab40
        // branch -> 0x804ab6a
        // 0x804ab6a
        return 3;
    }
    // 0x804ab47
    int32_t result; // 0x804ab6b_2
    if (strstr(myfile, ".tar") == NULL) {
        // 0x804ab65
        result = 0;
        // branch -> 0x804ab6a
    } else {
        // 0x804ab5e
        result = 4;
        // branch -> 0x804ab6a
    }
    // 0x804ab6a
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804ab6c - 0x804ac6d
// Line range:    766 - 789
void wget_extension(char * url) {
    char str[2048];
    char v1[2048];
    // 0x804ab6c
    fwrite("Downloading...", 1, 14, (struct _IO_FILE *)g15);
    if (VERBOSE == 0) {
        // 0x804abdd
        sprintf(str, "wget -N -q %s", url);
        // branch -> 0x804abfe
    } else {
        // 0x804abba
        sprintf(str, "wget -N %s", url);
        // branch -> 0x804abfe
    }
    char system_rc = system(str);
    v1[0] = system_rc;
    char v2 = system_rc; // 0x804ac2f
    if (system_rc == -1) {
        // 0x804ac1b
        print_error(-20, "could not run 'wget' to download extension. Is it installed?\n");
        v2 = v1[0];
        // branch -> 0x804ac2f
    }
    // 0x804ac2f
    if (v2 >= 1) {
        // 0x804ac38
        print_error(-20, "running command '%s'.\n");
        // branch -> 0x804ac56
    }
    // 0x804ac56
    print_done();
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x804ac67
        __stack_chk_fail();
        // branch -> 0x804ac6c
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804ac6e - 0x804ad9a
// Line range:    796 - 823
void su(char * gisbase, char * cmd) {
    char str[2048];
    char v1[2048];
    // 0x804ac6e
    int32_t v2;
    int32_t error = v2; // bp-2072
    int32_t v3 = *(int32_t *)20; // 0x804ac8a
    uint32_t seed = (0x41c64e6d * (int32_t)g18 + 0xd431) / 0x10000 % 0x8000; // 0x804acb1
    g18 = (struct _IO_FILE *)seed;
    srand(seed);
    int32_t v4 = rand(); // 0x804acc8
    sprintf(str, "%s/gem.test.%i", gisbase, v4);
    error = (int32_t)fopen(str, "w+");
    if (*__errno_location() == 13) {
        // 0x804ad1b
        print_error(-5, "You don't have write access to your local GRASS installation.\nPlease consult your system administrator.\n");
        // branch -> 0x804ad88
        // 0x804ad88
        if (*(int32_t *)20 != v3) {
            // 0x804ad94
            __stack_chk_fail();
            // branch -> 0x804ad99
        }
        // 0x804ad99
        return;
    }
    // 0x804ad31
    remove(str);
    fclose((struct _IO_FILE *)error);
    char system_rc = system(cmd);
    v1[0] = system_rc;
    if (system_rc != 0) {
        // 0x804ad6a
        print_error(-9, "could not run '%s'.\n");
        // branch -> 0x804ad88
    }
    // 0x804ad88
    if (*(int32_t *)20 != v3) {
        // 0x804ad94
        __stack_chk_fail();
        // branch -> 0x804ad99
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804ad9b - 0x804ae1f
// Line range:    832 - 858
int32_t vercmp(int32_t major, int32_t minor, int32_t revision, int32_t major2, int32_t minor2, int32_t revision2) {
    // 0x804ad9b
    if (major == major2) {
        // 0x804ada6
        if (minor == minor2) {
            // 0x804adae
            if (revision == revision2) {
                // 0x804adb6
                // branch -> 0x804ae1c
                // 0x804ae1c
                return 0;
            }
        }
    }
    // 0x804adbd
    if (major < major2) {
        // 0x804adc5
        // branch -> 0x804ae1c
        // 0x804ae1c
        return -1;
    }
    // 0x804adcc
    if (major > major2) {
        // 0x804add4
        // branch -> 0x804ae1c
        // 0x804ae1c
        return 1;
    }
    // 0x804addb
    if (minor < minor2) {
        // 0x804ade3
        // branch -> 0x804ae1c
        // 0x804ae1c
        return -1;
    }
    // 0x804adea
    if (minor > minor2) {
        // 0x804adf2
        // branch -> 0x804ae1c
        // 0x804ae1c
        return 1;
    }
    // 0x804adf9
    if (revision < revision2) {
        // 0x804ae01
        // branch -> 0x804ae1c
        // 0x804ae1c
        return -1;
    }
    // 0x804ae08
    int32_t result; // 0x804ae1d_2
    if (revision > revision2) {
        // 0x804ae10
        result = 1;
        // branch -> 0x804ae1c
    } else {
        // 0x804ae17
        result = 0;
        // branch -> 0x804ae1c
    }
    // 0x804ae1c
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_deps.c
// Address range: 0x804ae20 - 0x804b013
// Line range:    32 - 79
char * depstr(char * package, char * gisbase) {
    char v1[2048];
    char str3[2048];
    // 0x804ae20
    int32_t v2;
    int32_t error = v2; // bp-6176
    char * v3;
    char * str = v3; // bp-6168
    int32_t v4 = *(int32_t *)20; // 0x804ae3c
    int32_t file_path;
    memcpy((char *)&file_path, "../depends", 11);
    struct _IO_FILE * file = fopen((char *)&file_path, "r"); // 0x804ae77
    error = (int32_t)file;
    int32_t str2;
    if (file != NULL) {
        // 0x804aed2
        str = (char *)1;
        v1[0] = (int32_t)malloc(2048);
        if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)error) != NULL) {
            // 0x804aef3
            // branch -> 0x804aef3
            while (true) {
                // 0x804aef3
                if (str2 % 256 == 0) {
                    goto lab_0x804afc5;
                }
                goto lab_0x804af04;
            }
        }
        // 0x804afed
        fclose((struct _IO_FILE *)error);
        // branch -> 0x804b001
        // 0x804b001
        if (*(int32_t *)20 != v4) {
            // 0x804b00d
            __stack_chk_fail();
            // branch -> 0x804b012
        }
        // 0x804b012
        return (char *)(int32_t)v1[0];
    }
    // 0x804ae8b
    int32_t v5;
    if (*__errno_location() != 2) {
        int32_t err_num = *__errno_location(); // 0x804aea6
        strerror(err_num);
        print_error(-17, "checking for file '%s': %s\n");
        // branch -> 0x804aed2
        // 0x804aed2
        str = (char *)1;
        v1[0] = (int32_t)malloc(2048);
        if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)error) != NULL) {
            // 0x804aef3
            // branch -> 0x804aef3
            while (true) {
                // 0x804aef3
                if (str2 % 256 != 0) {
                  lab_0x804af04:
                    // 0x804af04
                    if (sscanf((char *)&str2, "%s", &str3) >= 1) {
                        // 0x804af38
                        if (strcmp("GRASS", str3) != 0) {
                            char * str4 = (char *)(int32_t)v1[0];
                            if (str == NULL) {
                                // 0x804af96
                                strcat(str4, ",");
                                strcat((char *)(int32_t)v1[0], str3);
                                // branch -> 0x804afc5
                            } else {
                                // 0x804af5b
                                strcat(str4, "\t");
                                strcat((char *)(int32_t)v1[0], str3);
                                str = NULL;
                                // branch -> 0x804afc5
                            }
                            // 0x804afc5
                            if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)error) == NULL) {
                                // break -> 0x804afed
                                break;
                            }
                            // continue -> 0x804aef3
                            continue;
                        }
                    }
                }
              lab_0x804afc5:
                // 0x804afc5
                if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)error) == NULL) {
                    // break -> 0x804afed
                    break;
                }
                // continue -> 0x804aef3
            }
            // 0x804afed
            fclose((struct _IO_FILE *)error);
            // branch -> 0x804b001
            // 0x804b001
            if (*(int32_t *)20 != v4) {
                // 0x804b00d
                __stack_chk_fail();
                // branch -> 0x804b012
            }
            // 0x804b012
            return (char *)(int32_t)v1[0];
        }
        // 0x804afed
        fclose((struct _IO_FILE *)error);
        v5 = v1[0];
        // branch -> 0x804b001
    } else {
        v5 = (int32_t)&g7;
    }
    // 0x804b001
    if (*(int32_t *)20 != v4) {
        // 0x804b00d
        __stack_chk_fail();
        // branch -> 0x804b012
    }
    // 0x804b012
    return (char *)v5;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_deps.c
// Address range: 0x804b014 - 0x804b5e2
// Line range:    87 - 229
void register_extension(char * gisbase, char * bins, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision) {
    char v1[2048];
    char str2[2048];
    // 0x804b014
    int32_t v2;
    int32_t revision = v2; // bp-10304
    int32_t v3;
    int32_t minor = v3; // bp-10300
    int32_t v4;
    int32_t major = v4; // bp-10296
    struct _IO_FILE_3 * v5;
    struct _IO_FILE_3 * f_out = v5; // bp-10292
    struct _IO_FILE_3 * v6;
    struct _IO_FILE_3 * f_in = v6; // bp-10288
    int32_t v7;
    int32_t ext_exists = v7; // bp-10284
    int32_t v8;
    int32_t copy_thru = v8; // bp-10280
    int32_t v9;
    int32_t must_register = v9; // bp-10276
    int32_t v10;
    int32_t db_exists = v10; // bp-10272
    int32_t v11;
    int32_t error = v11; // bp-10268
    int32_t v12;
    int32_t n_lines = v12; // bp-10264
    revision = (int32_t)gisbase;
    int32_t v13 = *(int32_t *)20; // 0x804b03a
    error = 1;
    int32_t str;
    sprintf((char *)&str, "%s/etc/extensions.db", gisbase);
    struct _IO_FILE * file = fopen((char *)&str, "r"); // 0x804b081
    ext_exists = (int32_t)file;
    struct _IO_FILE * file3; // 0x804b133
    char * str6; // 0x804b3b2
    struct _IO_FILE * file2; // 0x804b4f5
    char * str3; // 0x804b559
    int32_t str4;
    int32_t str5;
    int32_t v14;
    int32_t err_num2; // 0x804b14c
    int32_t err_num; // 0x804b50e
    struct _IO_FILE_3 * stream; // 0x804b405
    if (file != NULL) {
        // 0x804b0ec
        if (error == 0) {
            // 0x804b4bb
            memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMPDB);
            file2 = fopen(TMPDB, "w+");
            f_in = (struct _IO_FILE_3 *)file2;
            if (file2 == NULL) {
                // 0x804b509
                err_num = *__errno_location();
                strerror(err_num);
                print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804b53a
            }
            // 0x804b53a
            atexit((void (**)())exit_db);
            str3 = depstr(pkg_short_name, (char *)revision);
            strcpy(str2, str3);
            fprintf((struct _IO_FILE *)f_in, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
            fclose((struct _IO_FILE *)f_in);
            // branch -> 0x804b5c9
            // 0x804b5c9
            if (*(int32_t *)20 != v13) {
                // 0x804b5d5
                __stack_chk_fail();
                // branch -> 0x804b5da
            }
            // 0x804b5da
            return;
        }
        // 0x804b0f9
        memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMPDB);
        file3 = fopen(TMPDB, "w+");
        f_in = (struct _IO_FILE_3 *)file3;
        if (file3 == NULL) {
            // 0x804b147
            err_num2 = *__errno_location();
            strerror(err_num2);
            print_error(-15, "could not create temp file '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
            // branch -> 0x804b176
        }
        // 0x804b176
        atexit((void (**)())exit_db);
        v1[0] = 0;
        db_exists = 1;
        copy_thru = 0;
        if (nc_fgets_nb((char *)&str4, 2048, (struct _IO_FILE_2 *)ext_exists) != NULL) {
            // 0x804b1a5
            // branch -> 0x804b1a5
            while (true) {
                // 0x804b1a5
                v1[0]++;
                must_register = 1;
                sscanf((char *)&str4, "%s\t%i.%i.%i\t%s\t%s", &str5, &f_out, &major, &minor, &v14, &str2);
                if (strcmp((char *)&str5, pkg_short_name) == 0) {
                    goto lab_0x804b229;
                }
                goto lab_0x804b332;
            }
        }
        // 0x804b389
        if (db_exists == 0) {
            // 0x804b4a5
            fclose((struct _IO_FILE *)f_in);
            fclose((struct _IO_FILE *)ext_exists);
            if (!((error == 0 | v1[0] == 0))) {
                // 0x804b5c9
                if (*(int32_t *)20 != v13) {
                    // 0x804b5d5
                    __stack_chk_fail();
                    // branch -> 0x804b5da
                }
                // 0x804b5da
                return;
            }
            // 0x804b4bb
            memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMPDB);
            file2 = fopen(TMPDB, "w+");
            f_in = (struct _IO_FILE_3 *)file2;
            if (file2 == NULL) {
                // 0x804b509
                err_num = *__errno_location();
                strerror(err_num);
                print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804b53a
            }
            // 0x804b53a
            atexit((void (**)())exit_db);
            str3 = depstr(pkg_short_name, (char *)revision);
            strcpy(str2, str3);
            fprintf((struct _IO_FILE *)f_in, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
            fclose((struct _IO_FILE *)f_in);
            // branch -> 0x804b5c9
            // 0x804b5c9
            if (*(int32_t *)20 != v13) {
                // 0x804b5d5
                __stack_chk_fail();
                // branch -> 0x804b5da
            }
            // 0x804b5da
            return;
        }
        // 0x804b396
        str6 = depstr(pkg_short_name, (char *)revision);
        strcpy(str2, str6);
        stream = f_in;
        if (copy_thru == 0) {
            // 0x804b39f
            fprintf((struct _IO_FILE *)stream, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
            // branch -> 0x804b4a5
        } else {
            // 0x804b415
            fprintf((struct _IO_FILE *)stream, "%s\t%i.%i.%i\t%s\t%s\n", &str5, pkg_major, pkg_minor, pkg_revision, &v14, &str2);
            // branch -> 0x804b4a5
        }
        // 0x804b4a5
        fclose((struct _IO_FILE *)f_in);
        fclose((struct _IO_FILE *)ext_exists);
        if (error == 0 | v1[0] == 0) {
            // 0x804b4bb
            memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMPDB);
            file2 = fopen(TMPDB, "w+");
            f_in = (struct _IO_FILE_3 *)file2;
            if (file2 == NULL) {
                // 0x804b509
                err_num = *__errno_location();
                strerror(err_num);
                print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804b53a
            }
            // 0x804b53a
            atexit((void (**)())exit_db);
            str3 = depstr(pkg_short_name, (char *)revision);
            strcpy(str2, str3);
            fprintf((struct _IO_FILE *)f_in, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
            fclose((struct _IO_FILE *)f_in);
            // branch -> 0x804b5c9
        }
        // 0x804b5c9
        if (*(int32_t *)20 != v13) {
            // 0x804b5d5
            __stack_chk_fail();
            // branch -> 0x804b5da
        }
        // 0x804b5da
        return;
    }
    // 0x804b095
    if (*__errno_location() == 2) {
        // 0x804b0ec
        error = 0;
        // branch -> 0x804b4bb
    } else {
        // 0x804b0ad
        fclose((struct _IO_FILE *)ext_exists);
        int32_t err_num3 = *__errno_location(); // 0x804b0c0
        strerror(err_num3);
        print_error(-15, "checking for file '%s': %s\n");
        // branch -> 0x804b0ec
        // 0x804b0ec
        if (error != 0) {
            // 0x804b0f9
            memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMPDB);
            file3 = fopen(TMPDB, "w+");
            f_in = (struct _IO_FILE_3 *)file3;
            if (file3 == NULL) {
                // 0x804b147
                err_num2 = *__errno_location();
                strerror(err_num2);
                print_error(-15, "could not create temp file '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804b176
            }
            // 0x804b176
            atexit((void (**)())exit_db);
            v1[0] = 0;
            db_exists = 1;
            copy_thru = 0;
            if (nc_fgets_nb((char *)&str4, 2048, (struct _IO_FILE_2 *)ext_exists) != NULL) {
                // 0x804b1a5
                // branch -> 0x804b1a5
                while (true) {
                    // 0x804b1a5
                    v1[0]++;
                    must_register = 1;
                    sscanf((char *)&str4, "%s\t%i.%i.%i\t%s\t%s", &str5, &f_out, &major, &minor, &v14, &str2);
                    if (strcmp((char *)&str5, pkg_short_name) == 0) {
                      lab_0x804b229:
                        // 0x804b229
                        copy_thru = 1;
                        int32_t v15 = vercmp((int32_t)f_out, major, minor, pkg_major, pkg_minor, pkg_revision); // 0x804b265
                        n_lines = v15;
                        if (FORCE == 0) {
                            // 0x804b27d
                            if (v15 > 0) {
                                // 0x804b2c4
                                print_error(-16, "Extension '%s' with same or higher version (%i.%i.%i) already installed. You can use -f to overwrite this version, if you know what you are doing.\n");
                                // branch -> 0x804b300
                            } else {
                                // 0x804b286
                                print_error(-16, "Extension '%s' with lower version (%i.%i.%i) already installed. You can use -f to overwrite this version, if you know what you are doing.\n");
                                // branch -> 0x804b300
                            }
                            // 0x804b300
                            if (FORCE != 0) {
                                // branch -> 0x804b309
                              lab_0x804b309:
                                // 0x804b309
                                if (n_lines == 0) {
                                    // 0x804b312
                                    db_exists = 0;
                                    // branch -> 0x804b332
                                    // 0x804b332
                                    if (must_register != 0) {
                                      lab_0x804b33b_2:
                                        // 0x804b33b
                                        fprintf((struct _IO_FILE *)f_in, (char *)&str4);
                                        fflush((struct _IO_FILE *)f_in);
                                        // branch -> 0x804b361
                                    }
                                } else {
                                    // 0x804b332
                                    db_exists = 1;
                                    must_register = 0;
                                    // branch -> 0x804b361
                                }
                              lab_0x804b361_2:
                                // 0x804b361
                                if (nc_fgets_nb((char *)&str4, 2048, (struct _IO_FILE_2 *)ext_exists) == NULL) {
                                    // break -> 0x804b389
                                    break;
                                }
                                // continue -> 0x804b1a5
                                continue;
                            }
                        } else {
                            // 0x804b300
                            n_lines = v15;
                            // branch -> 0x804b309
                            goto lab_0x804b309;
                        }
                        // 0x804b332
                        if (must_register == 0) {
                            goto lab_0x804b361_2;
                        }
                        goto lab_0x804b33b_2;
                    }
                  lab_0x804b332:
                    // 0x804b332
                    if (must_register == 0) {
                        goto lab_0x804b361_2;
                    }
                    goto lab_0x804b33b_2;
                }
                // 0x804b389
                if (db_exists == 0) {
                    // 0x804b4a5
                    fclose((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)ext_exists);
                    if (error == 0 | v1[0] == 0) {
                        // 0x804b4bb
                        memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
                        mkstemp(TMPDB);
                        file2 = fopen(TMPDB, "w+");
                        f_in = (struct _IO_FILE_3 *)file2;
                        if (file2 == NULL) {
                            // 0x804b509
                            err_num = *__errno_location();
                            strerror(err_num);
                            print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                            // branch -> 0x804b53a
                        }
                        // 0x804b53a
                        atexit((void (**)())exit_db);
                        str3 = depstr(pkg_short_name, (char *)revision);
                        strcpy(str2, str3);
                        fprintf((struct _IO_FILE *)f_in, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
                        fclose((struct _IO_FILE *)f_in);
                        // branch -> 0x804b5c9
                    }
                    // 0x804b5c9
                    if (*(int32_t *)20 != v13) {
                        // 0x804b5d5
                        __stack_chk_fail();
                        // branch -> 0x804b5da
                    }
                    // 0x804b5da
                    return;
                }
                // 0x804b396
                str6 = depstr(pkg_short_name, (char *)revision);
                strcpy(str2, str6);
                stream = f_in;
                if (copy_thru == 0) {
                    // 0x804b39f
                    fprintf((struct _IO_FILE *)stream, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
                    // branch -> 0x804b4a5
                } else {
                    // 0x804b415
                    fprintf((struct _IO_FILE *)stream, "%s\t%i.%i.%i\t%s\t%s\n", &str5, pkg_major, pkg_minor, pkg_revision, &v14, &str2);
                    // branch -> 0x804b4a5
                }
                // 0x804b4a5
                fclose((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)ext_exists);
                if (error == 0 | v1[0] == 0) {
                    // 0x804b4bb
                    memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
                    mkstemp(TMPDB);
                    file2 = fopen(TMPDB, "w+");
                    f_in = (struct _IO_FILE_3 *)file2;
                    if (file2 == NULL) {
                        // 0x804b509
                        err_num = *__errno_location();
                        strerror(err_num);
                        print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                        // branch -> 0x804b53a
                    }
                    // 0x804b53a
                    atexit((void (**)())exit_db);
                    str3 = depstr(pkg_short_name, (char *)revision);
                    strcpy(str2, str3);
                    fprintf((struct _IO_FILE *)f_in, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
                    fclose((struct _IO_FILE *)f_in);
                    // branch -> 0x804b5c9
                }
                // 0x804b5c9
                if (*(int32_t *)20 != v13) {
                    // 0x804b5d5
                    __stack_chk_fail();
                    // branch -> 0x804b5da
                }
                // 0x804b5da
                return;
            }
            // 0x804b389
            if (db_exists != 0) {
                // 0x804b396
                str6 = depstr(pkg_short_name, (char *)revision);
                strcpy(str2, str6);
                stream = f_in;
                if (copy_thru == 0) {
                    // 0x804b39f
                    fprintf((struct _IO_FILE *)stream, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
                    // branch -> 0x804b4a5
                } else {
                    // 0x804b415
                    fprintf((struct _IO_FILE *)stream, "%s\t%i.%i.%i\t%s\t%s\n", &str5, pkg_major, pkg_minor, pkg_revision, &v14, &str2);
                    // branch -> 0x804b4a5
                }
                // 0x804b4a5
                fclose((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)ext_exists);
                if (error == 0 | v1[0] == 0) {
                    // 0x804b4bb
                    memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
                    mkstemp(TMPDB);
                    file2 = fopen(TMPDB, "w+");
                    f_in = (struct _IO_FILE_3 *)file2;
                    if (file2 == NULL) {
                        // 0x804b509
                        err_num = *__errno_location();
                        strerror(err_num);
                        print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                        // branch -> 0x804b53a
                    }
                    // 0x804b53a
                    atexit((void (**)())exit_db);
                    str3 = depstr(pkg_short_name, (char *)revision);
                    strcpy(str2, str3);
                    fprintf((struct _IO_FILE *)f_in, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
                    fclose((struct _IO_FILE *)f_in);
                    // branch -> 0x804b5c9
                }
                // 0x804b5c9
                if (*(int32_t *)20 != v13) {
                    // 0x804b5d5
                    __stack_chk_fail();
                    // branch -> 0x804b5da
                }
                // 0x804b5da
                return;
            }
            // 0x804b4a5
            fclose((struct _IO_FILE *)f_in);
            fclose((struct _IO_FILE *)ext_exists);
            if (!((error == 0 | v1[0] == 0))) {
                // 0x804b5c9
                if (*(int32_t *)20 != v13) {
                    // 0x804b5d5
                    __stack_chk_fail();
                    // branch -> 0x804b5da
                }
                // 0x804b5da
                return;
            }
        }
    }
    // 0x804b4bb
    memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(TMPDB);
    file2 = fopen(TMPDB, "w+");
    f_in = (struct _IO_FILE_3 *)file2;
    if (file2 == NULL) {
        // 0x804b509
        err_num = *__errno_location();
        strerror(err_num);
        print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        // branch -> 0x804b53a
    }
    // 0x804b53a
    atexit((void (**)())exit_db);
    str3 = depstr(pkg_short_name, (char *)revision);
    strcpy(str2, str3);
    fprintf((struct _IO_FILE *)f_in, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str2);
    fclose((struct _IO_FILE *)f_in);
    // branch -> 0x804b5c9
    // 0x804b5c9
    if (*(int32_t *)20 != v13) {
        // 0x804b5d5
        __stack_chk_fail();
        // branch -> 0x804b5da
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_deps.c
// Address range: 0x804b5e3 - 0x804b960
// Line range:    235 - 332
void deregister_extension(char * package, char * pkg_short_name, char * gisbase) {
    char v1[2048];
    char str4[2048];
    // 0x804b5e3
    int32_t v2;
    int32_t minor = v2; // bp-10292
    int32_t v3;
    int32_t major = v3; // bp-10288
    int32_t v4;
    int32_t found_ext = v4; // bp-10284
    struct _IO_FILE_3 * v5;
    struct _IO_FILE_3 * f_out = v5; // bp-10280
    struct _IO_FILE_3 * v6;
    struct _IO_FILE_3 * f_in = v6; // bp-10276
    int32_t v7;
    int32_t copy_thru = v7; // bp-10272
    int32_t v8;
    int32_t db_exists = v8; // bp-10268
    int32_t v9;
    int32_t error = v9; // bp-10264
    int32_t v10 = *(int32_t *)20; // 0x804b608
    error = 0;
    int32_t str;
    sprintf((char *)&str, "%s/etc/extensions.db", gisbase);
    struct _IO_FILE * file = fopen((char *)&str, "r"); // 0x804b64f
    copy_thru = (int32_t)file;
    struct _IO_FILE * file2; // 0x804b749
    int32_t str2;
    int32_t str3;
    int32_t v11;
    int32_t items_assigned;
    char v12;
    int32_t err_num; // 0x804b76b
    if (file != NULL) {
        // 0x804b6f8
        error = 1;
        // branch -> 0x804b705
        // 0x804b705
        error = 0;
        memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMPDB);
        file2 = fopen(TMPDB, "w+");
        f_in = (struct _IO_FILE_3 *)file2;
        if (file2 == NULL) {
            // 0x804b75d
            if (FORCE == 0) {
                // 0x804b766
                err_num = *__errno_location();
                strerror(err_num);
                print_error(-19, "could not create temp db '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804b7af
                // 0x804b7af
                if (error != 0) {
                    // 0x804b7bc
                    f_out = NULL;
                    if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)copy_thru) != NULL) {
                        // 0x804b7cb
                        // branch -> 0x804b7cb
                        while (true) {
                            // 0x804b7cb
                            items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i\t%s\t%s", &str3, &found_ext, &major, &minor, &v11, &str4);
                            v12 = items_assigned;
                            v1[0] = v12;
                            if (v12 < 1) {
                                goto lab_0x804b8d9_5;
                            }
                            goto lab_0x804b831_5;
                        }
                    }
                    // 0x804b901
                    if (f_out == NULL) {
                        // 0x804b90a
                        print_error(-19, "no extension '%s' registered/installed in '%s'.\n");
                        // branch -> 0x804b932
                    }
                    // 0x804b932
                    fclose((struct _IO_FILE *)copy_thru);
                    fclose((struct _IO_FILE *)f_in);
                    // branch -> 0x804b94e
                }
                // 0x804b94e
                if (*(int32_t *)20 != v10) {
                    // 0x804b95a
                    __stack_chk_fail();
                    // branch -> 0x804b95f
                }
                // 0x804b95f
                return;
            }
        }
        // 0x804b799
        error = 1;
        atexit((void (**)())exit_db);
        // branch -> 0x804b7af
        // 0x804b7af
        if (error != 0) {
            // 0x804b7bc
            f_out = NULL;
            if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)copy_thru) != NULL) {
                // 0x804b7cb
                // branch -> 0x804b7cb
                while (true) {
                    // 0x804b7cb
                    items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i\t%s\t%s", &str3, &found_ext, &major, &minor, &v11, &str4);
                    v12 = items_assigned;
                    v1[0] = v12;
                    if (v12 < 1) {
                        goto lab_0x804b8d9_5;
                    }
                    goto lab_0x804b831_5;
                }
            }
            // 0x804b901
            if (f_out == NULL) {
                // 0x804b90a
                print_error(-19, "no extension '%s' registered/installed in '%s'.\n");
                // branch -> 0x804b932
            }
            // 0x804b932
            fclose((struct _IO_FILE *)copy_thru);
            fclose((struct _IO_FILE *)f_in);
            // branch -> 0x804b94e
        }
        // 0x804b94e
        if (*(int32_t *)20 != v10) {
            // 0x804b95a
            __stack_chk_fail();
            // branch -> 0x804b95f
        }
        // 0x804b95f
        return;
    }
    // 0x804b667
    if (*__errno_location() != 2) {
        // 0x804b6a1
        if (FORCE == 0) {
            // 0x804b6aa
            fclose((struct _IO_FILE *)copy_thru);
            int32_t err_num2 = *__errno_location(); // 0x804b6bd
            strerror(err_num2);
            print_error(-19, "checking for file '%s': %s\n");
            // branch -> 0x804b6f8
        }
        // 0x804b6f8
        if (error == 0) {
            // 0x804b94e
            if (*(int32_t *)20 != v10) {
                // 0x804b95a
                __stack_chk_fail();
                // branch -> 0x804b95f
            }
            // 0x804b95f
            return;
        }
        // 0x804b705
        error = 0;
        memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMPDB);
        file2 = fopen(TMPDB, "w+");
        f_in = (struct _IO_FILE_3 *)file2;
        if (file2 == NULL) {
            // 0x804b75d
            if (FORCE == 0) {
                // 0x804b766
                err_num = *__errno_location();
                strerror(err_num);
                print_error(-19, "could not create temp db '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804b7af
                // 0x804b7af
                if (error != 0) {
                    // 0x804b7bc
                    f_out = NULL;
                    if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)copy_thru) != NULL) {
                        // 0x804b7cb
                        // branch -> 0x804b7cb
                        while (true) {
                            // 0x804b7cb
                            items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i\t%s\t%s", &str3, &found_ext, &major, &minor, &v11, &str4);
                            v12 = items_assigned;
                            v1[0] = v12;
                            if (v12 < 1) {
                                goto lab_0x804b8d9_5;
                            }
                            goto lab_0x804b831_5;
                        }
                    }
                    // 0x804b901
                    if (f_out == NULL) {
                        // 0x804b90a
                        print_error(-19, "no extension '%s' registered/installed in '%s'.\n");
                        // branch -> 0x804b932
                    }
                    // 0x804b932
                    fclose((struct _IO_FILE *)copy_thru);
                    fclose((struct _IO_FILE *)f_in);
                    // branch -> 0x804b94e
                }
                // 0x804b94e
                if (*(int32_t *)20 != v10) {
                    // 0x804b95a
                    __stack_chk_fail();
                    // branch -> 0x804b95f
                }
                // 0x804b95f
                return;
            }
        }
        // 0x804b799
        error = 1;
        atexit((void (**)())exit_db);
        // branch -> 0x804b7af
        // 0x804b7af
        if (error != 0) {
            // 0x804b7bc
            f_out = NULL;
            if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)copy_thru) != NULL) {
                // 0x804b7cb
                // branch -> 0x804b7cb
                while (true) {
                    // 0x804b7cb
                    items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i\t%s\t%s", &str3, &found_ext, &major, &minor, &v11, &str4);
                    v12 = items_assigned;
                    v1[0] = v12;
                    if (v12 < 1) {
                        goto lab_0x804b8d9_5;
                    }
                    goto lab_0x804b831_5;
                }
            }
            // 0x804b901
            if (f_out == NULL) {
                // 0x804b90a
                print_error(-19, "no extension '%s' registered/installed in '%s'.\n");
                // branch -> 0x804b932
            }
            // 0x804b932
            fclose((struct _IO_FILE *)copy_thru);
            fclose((struct _IO_FILE *)f_in);
            // branch -> 0x804b94e
        }
        // 0x804b94e
        if (*(int32_t *)20 != v10) {
            // 0x804b95a
            __stack_chk_fail();
            // branch -> 0x804b95f
        }
        // 0x804b95f
        return;
    }
    // 0x804b673
    if (FORCE == 0) {
        // 0x804b67c
        fclose((struct _IO_FILE *)copy_thru);
        print_error(-19, "could not deregister: no extensions installed\n");
        // branch -> 0x804b6f8
    }
    // 0x804b6f8
    if (error != 0) {
        // 0x804b705
        error = 0;
        memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMPDB);
        file2 = fopen(TMPDB, "w+");
        f_in = (struct _IO_FILE_3 *)file2;
        if (file2 == NULL) {
            // 0x804b75d
            if (FORCE == 0) {
                // 0x804b766
                err_num = *__errno_location();
                strerror(err_num);
                print_error(-19, "could not create temp db '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804b7af
                // 0x804b7af
                if (error != 0) {
                    // 0x804b7bc
                    f_out = NULL;
                    if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)copy_thru) != NULL) {
                        // 0x804b7cb
                        // branch -> 0x804b7cb
                        while (true) {
                            // 0x804b7cb
                            items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i\t%s\t%s", &str3, &found_ext, &major, &minor, &v11, &str4);
                            v12 = items_assigned;
                            v1[0] = v12;
                            if (v12 >= 1) {
                              lab_0x804b831_5:
                                // 0x804b831
                                db_exists = 1;
                                if (strcmp(pkg_short_name, (char *)&str3) == 0) {
                                    // 0x804b86b
                                    db_exists = 0;
                                    f_out = (struct _IO_FILE_3 *)1;
                                    // branch -> 0x804b8d9
                                } else {
                                    // 0x804b86b
                                    if (db_exists != 0) {
                                        // 0x804b874
                                        if (strstr(str4, pkg_short_name) != NULL) {
                                            // 0x804b890
                                            if (FORCE == 0) {
                                                // 0x804b899
                                                print_error(-19, "cannot uninstall extension '%s' it is needed by '%s'.\n");
                                                // branch -> 0x804b8c1
                                            }
                                        }
                                        // 0x804b8c1
                                        fprintf((struct _IO_FILE *)f_in, (char *)&str2);
                                        // branch -> 0x804b8d9
                                    }
                                }
                                // 0x804b8d9
                                if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)copy_thru) == NULL) {
                                    // break -> 0x804b901
                                    break;
                                }
                                // continue -> 0x804b7cb
                                continue;
                            }
                          lab_0x804b8d9_5:
                            // 0x804b8d9
                            if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)copy_thru) == NULL) {
                                // break -> 0x804b901
                                break;
                            }
                            // continue -> 0x804b7cb
                        }
                        // 0x804b901
                        if (f_out == NULL) {
                            // 0x804b90a
                            print_error(-19, "no extension '%s' registered/installed in '%s'.\n");
                            // branch -> 0x804b932
                        }
                        // 0x804b932
                        fclose((struct _IO_FILE *)copy_thru);
                        fclose((struct _IO_FILE *)f_in);
                        // branch -> 0x804b94e
                        // 0x804b94e
                        if (*(int32_t *)20 != v10) {
                            // 0x804b95a
                            __stack_chk_fail();
                            // branch -> 0x804b95f
                        }
                        // 0x804b95f
                        return;
                    }
                    // 0x804b901
                    if (f_out == NULL) {
                        // 0x804b90a
                        print_error(-19, "no extension '%s' registered/installed in '%s'.\n");
                        // branch -> 0x804b932
                    }
                    // 0x804b932
                    fclose((struct _IO_FILE *)copy_thru);
                    fclose((struct _IO_FILE *)f_in);
                    // branch -> 0x804b94e
                }
                // 0x804b94e
                if (*(int32_t *)20 != v10) {
                    // 0x804b95a
                    __stack_chk_fail();
                    // branch -> 0x804b95f
                }
                // 0x804b95f
                return;
            }
        }
        // 0x804b799
        error = 1;
        atexit((void (**)())exit_db);
        // branch -> 0x804b7af
        // 0x804b7af
        if (error != 0) {
            // 0x804b7bc
            f_out = NULL;
            if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)copy_thru) != NULL) {
                // 0x804b7cb
                // branch -> 0x804b7cb
                while (true) {
                    // 0x804b7cb
                    items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i\t%s\t%s", &str3, &found_ext, &major, &minor, &v11, &str4);
                    v12 = items_assigned;
                    v1[0] = v12;
                    if (v12 < 1) {
                        goto lab_0x804b8d9_5;
                    }
                    goto lab_0x804b831_5;
                }
            }
            // 0x804b901
            if (f_out == NULL) {
                // 0x804b90a
                print_error(-19, "no extension '%s' registered/installed in '%s'.\n");
                // branch -> 0x804b932
            }
            // 0x804b932
            fclose((struct _IO_FILE *)copy_thru);
            fclose((struct _IO_FILE *)f_in);
            // branch -> 0x804b94e
        }
    }
    // 0x804b94e
    if (*(int32_t *)20 != v10) {
        // 0x804b95a
        __stack_chk_fail();
        // branch -> 0x804b95f
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_deps.c
// Address range: 0x804b961 - 0x804be83
// Line range:    340 - 462
void check_dependencies(char * package, char * gisbase, char * grass_version) {
    char v1[2048];
    char str3[2048];
    // 0x804b961
    int32_t v2;
    int32_t dep_revision = v2; // bp-10320
    int32_t v3;
    int32_t dep_minor = v3; // bp-10316
    int32_t v4;
    int32_t dep_major = v4; // bp-10312
    int32_t v5;
    int32_t revision = v5; // bp-10308
    int32_t v6;
    int32_t minor = v6; // bp-10304
    int32_t v7;
    int32_t major = v7; // bp-10300
    struct _IO_FILE_3 * v8;
    struct _IO_FILE_3 * f_db = v8; // bp-10296
    struct _IO_FILE_3 * v9;
    struct _IO_FILE_3 * f_deps = v9; // bp-10292
    int32_t v10;
    int32_t satisfied = v10; // bp-10288
    int32_t v11;
    int32_t db_exists = v11; // bp-10284
    int32_t v12;
    int32_t error = v12; // bp-10280
    dep_revision = (int32_t)package;
    int32_t v13 = *(int32_t *)20; // 0x804b989
    if (FORCE == 0) {
        struct _IO_FILE * file = fopen("../depends", "r"); // 0x804b9b1
        satisfied = (int32_t)file;
        struct _IO_FILE * file2; // 0x804ba72
        int32_t str;
        int32_t str2;
        int32_t items_assigned;
        char v14;
        int32_t err_num2; // 0x804bab1
        if (file == NULL) {
            // 0x804b9c5
            if (*__errno_location() == 2) {
                // 0x804b9d1
                fprintf(g14, "\n%s/depends ENOENT\n", (char *)dep_revision);
                // branch -> 0x804be67
            } else {
                // 0x804b9f6
                fclose((struct _IO_FILE *)satisfied);
                int32_t err_num = *__errno_location(); // 0x804ba09
                strerror(err_num);
                print_error(-17, "checking for file '%s': %s\n");
                // branch -> 0x804ba35
                // 0x804ba35
                error = 1;
                sprintf((char *)&str, "%s/etc/extensions.db", gisbase);
                file2 = fopen((char *)&str, "r");
                f_deps = (struct _IO_FILE_3 *)file2;
                if (file2 == NULL) {
                    // 0x804ba86
                    if (*__errno_location() == 2) {
                        // 0x804ba92
                        error = 0;
                        // branch -> 0x804badd
                    } else {
                        // 0x804ba9e
                        fclose((struct _IO_FILE *)f_deps);
                        err_num2 = *__errno_location();
                        strerror(err_num2);
                        print_error(-17, "checking for file '%s': %s\n");
                        // branch -> 0x804badd
                    }
                    // 0x804badd
                    db_exists = 0;
                    if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)satisfied) == NULL) {
                        // 0x804be3f
                        if (error != 0) {
                            // 0x804be48
                            fclose((struct _IO_FILE *)f_deps);
                            // branch -> 0x804be56
                        }
                        // 0x804be56
                        fclose((struct _IO_FILE *)satisfied);
                        // branch -> 0x804be67
                        // 0x804be67
                        if (*(int32_t *)20 != v13) {
                            // 0x804be73
                            __stack_chk_fail();
                            // branch -> 0x804be78
                        }
                        // 0x804be78
                        return;
                    }
                    // 0x804baec
                    // branch -> 0x804baec
                    while (true) {
                        // 0x804baec
                        f_db = NULL;
                        major = 0;
                        minor = 0;
                        revision = 0;
                        dep_major = 0;
                        dep_minor = 0;
                        items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i", str3, &revision, &dep_major, &dep_minor);
                        v14 = items_assigned;
                        v1[0] = v14;
                        if (v14 >= 1) {
                          lab_0x804bb7a_3:
                            // 0x804bb7a
                            if (strcmp(str3, "GRASS") == 0) {
                                // 0x804bb98
                                sscanf(grass_version, "%i.%i.%i", &f_db, &major, &minor);
                                if (vercmp((int32_t)f_db, major, minor, revision, dep_major, dep_minor) <= 0) {
                                    // 0x804bc11
                                    print_error(-18, "installed version (%s) of GRASS is too low. Required version is %i.%i.%i\n");
                                    // branch -> 0x804bc4d
                                }
                                // 0x804bc4d
                                db_exists = 1;
                                // branch -> 0x804be17
                            } else {
                                // 0x804bc5c
                                if (error != 0) {
                                    // 0x804bc69
                                    db_exists = 0;
                                    rewind((struct _IO_FILE *)f_deps);
                                    int32_t str4;
                                    if (nc_fgets_nb((char *)&str4, 2048, (struct _IO_FILE_2 *)f_deps) != NULL) {
                                        while (true) {
                                            // 0x804bc86
                                            f_db = NULL;
                                            major = 0;
                                            minor = 0;
                                            int32_t str5;
                                            int32_t items_assigned2 = sscanf((char *)&str4, "%s\t%i.%i.%i", &str5, &f_db, &major, &minor);
                                            char v15 = items_assigned2;
                                            v1[0] = v15;
                                            if (v15 >= 1) {
                                                // 0x804bcf6
                                                if (strcmp((char *)&str5, str3) == 0) {
                                                    // 0x804bd16
                                                    if (vercmp((int32_t)f_db, major, minor, revision, dep_major, dep_minor) <= 0) {
                                                        // 0x804bd5a
                                                        print_error(-18, "installed version %i.%i.%i of required extension '%s' is too low.\n \t\t\t\t\t\t\t\t\t\t\t\t\tRequired version is %i.%i.%i\n");
                                                        // branch -> 0x804bdb4
                                                    }
                                                    // 0x804bdb4
                                                    db_exists = 1;
                                                    // branch -> 0x804bdbe
                                                }
                                            }
                                            // 0x804bdbe
                                            if (nc_fgets_nb((char *)&str4, 2048, (struct _IO_FILE_2 *)f_deps) == NULL) {
                                                // break -> 0x804bde6
                                                break;
                                            }
                                            // continue -> 0x804bc86
                                        }
                                        // 0x804bde6
                                        if (db_exists == 0) {
                                          lab_0x804bdef:
                                            // 0x804bdef
                                            print_error(-18, "required extension '%s' not found in '%s'.\n");
                                            // branch -> 0x804be17
                                        }
                                      lab_0x804be17:
                                        // 0x804be17
                                        if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)satisfied) == NULL) {
                                            // break -> 0x804be3f
                                            break;
                                        }
                                        // continue -> 0x804baec
                                        continue;
                                    }
                                    // 0x804bde6
                                    if (db_exists == 0) {
                                        goto lab_0x804bdef;
                                    }
                                    goto lab_0x804be17;
                                }
                            }
                            // 0x804be17
                            if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)satisfied) == NULL) {
                                // break -> 0x804be3f
                                break;
                            }
                            // continue -> 0x804baec
                            continue;
                        }
                      lab_0x804be17_4:
                        // 0x804be17
                        if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)satisfied) == NULL) {
                            // break -> 0x804be3f
                            break;
                        }
                        // continue -> 0x804baec
                    }
                    // 0x804be3f
                    if (error != 0) {
                        // 0x804be48
                        fclose((struct _IO_FILE *)f_deps);
                        // branch -> 0x804be56
                    }
                    // 0x804be56
                    fclose((struct _IO_FILE *)satisfied);
                    // branch -> 0x804be67
                    // 0x804be67
                    if (*(int32_t *)20 != v13) {
                        // 0x804be73
                        __stack_chk_fail();
                        // branch -> 0x804be78
                    }
                    // 0x804be78
                    return;
                }
                // 0x804badd
                db_exists = 0;
                if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)satisfied) != NULL) {
                    // 0x804baec
                    // branch -> 0x804baec
                    while (true) {
                        // 0x804baec
                        f_db = NULL;
                        major = 0;
                        minor = 0;
                        revision = 0;
                        dep_major = 0;
                        dep_minor = 0;
                        items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i", str3, &revision, &dep_major, &dep_minor);
                        v14 = items_assigned;
                        v1[0] = v14;
                        if (v14 < 1) {
                            goto lab_0x804be17_4;
                        }
                        goto lab_0x804bb7a_3;
                    }
                }
                // 0x804be3f
                if (error != 0) {
                    // 0x804be48
                    fclose((struct _IO_FILE *)f_deps);
                    // branch -> 0x804be56
                }
                // 0x804be56
                fclose((struct _IO_FILE *)satisfied);
                // branch -> 0x804be67
            }
            // 0x804be67
            if (*(int32_t *)20 != v13) {
                // 0x804be73
                __stack_chk_fail();
                // branch -> 0x804be78
            }
            // 0x804be78
            return;
        }
        // 0x804b9a0
        // branch -> 0x804ba35
        // 0x804ba35
        error = 1;
        sprintf((char *)&str, "%s/etc/extensions.db", gisbase);
        file2 = fopen((char *)&str, "r");
        f_deps = (struct _IO_FILE_3 *)file2;
        if (file2 == NULL) {
            // 0x804ba86
            if (*__errno_location() == 2) {
                // 0x804ba92
                error = 0;
                // branch -> 0x804badd
            } else {
                // 0x804ba9e
                fclose((struct _IO_FILE *)f_deps);
                err_num2 = *__errno_location();
                strerror(err_num2);
                print_error(-17, "checking for file '%s': %s\n");
                // branch -> 0x804badd
            }
            // 0x804badd
            db_exists = 0;
            if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)satisfied) != NULL) {
                // 0x804baec
                // branch -> 0x804baec
                while (true) {
                    // 0x804baec
                    f_db = NULL;
                    major = 0;
                    minor = 0;
                    revision = 0;
                    dep_major = 0;
                    dep_minor = 0;
                    items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i", str3, &revision, &dep_major, &dep_minor);
                    v14 = items_assigned;
                    v1[0] = v14;
                    if (v14 < 1) {
                        goto lab_0x804be17_4;
                    }
                    goto lab_0x804bb7a_3;
                }
            }
            // 0x804be3f
            if (error != 0) {
                // 0x804be48
                fclose((struct _IO_FILE *)f_deps);
                // branch -> 0x804be56
            }
            // 0x804be56
            fclose((struct _IO_FILE *)satisfied);
            // branch -> 0x804be67
            // 0x804be67
            if (*(int32_t *)20 != v13) {
                // 0x804be73
                __stack_chk_fail();
                // branch -> 0x804be78
            }
            // 0x804be78
            return;
        }
        // 0x804badd
        db_exists = 0;
        if (nc_fgets_nb((char *)&str2, 2048, (struct _IO_FILE_2 *)satisfied) != NULL) {
            // 0x804baec
            // branch -> 0x804baec
            while (true) {
                // 0x804baec
                f_db = NULL;
                major = 0;
                minor = 0;
                revision = 0;
                dep_major = 0;
                dep_minor = 0;
                items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i", str3, &revision, &dep_major, &dep_minor);
                v14 = items_assigned;
                v1[0] = v14;
                if (v14 < 1) {
                    goto lab_0x804be17_4;
                }
                goto lab_0x804bb7a_3;
            }
        }
        // 0x804be3f
        if (error != 0) {
            // 0x804be48
            fclose((struct _IO_FILE *)f_deps);
            // branch -> 0x804be56
        }
        // 0x804be56
        fclose((struct _IO_FILE *)satisfied);
        // branch -> 0x804be67
    }
    // 0x804be67
    if (*(int32_t *)20 != v13) {
        // 0x804be73
        __stack_chk_fail();
        // branch -> 0x804be78
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804be84 - 0x804bf04
// Line range:    36 - 48
int32_t is_submenu(char * item) {
    // 0x804be84
    int32_t v1;
    if (strchr(item, 91) == NULL || strrchr(item, 93) == NULL) {
        // 0x804bea2
        // branch -> 0x804beff
        // 0x804beff
        g2 = v1;
        return 0;
    }
    char * found_char_pos = strchr(item, 91); // 0x804bed5
    int32_t result; // 0x804bf04_2
    if (found_char_pos > strrchr(item, 93)) {
        // 0x804bef3
        result = 0;
        // branch -> 0x804beff
    } else {
        // 0x804befa
        result = 1;
        // branch -> 0x804beff
    }
    // 0x804beff
    g2 = v1;
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804bf05 - 0x804c008
// Line range:    57 - 81
int32_t check_ext_menu(char ** tcl_lines) {
    int32_t result = find_pos("\"&Xtns\" all options 1", tcl_lines, 0); // 0x804bf21
    if (result != -1) {
        // 0x804c007
        return result;
    }
    int32_t v1 = find_pos("\"&Help\" all options", tcl_lines, 0); // 0x804bf49
    int32_t v2 = v1 + 1; // 0x804bf51
    int32_t result2; // 0x804bf75
    if (v1 == -1) {
        int32_t v3 = find_pos("}]", tcl_lines, 0); // 0x804bf6d
        result2 = v3 + 1;
        if (v3 == -1) {
            // 0x804bf7b
            print_error(-21, "could not parse 'menu.tcl'.\n");
            // branch -> 0x804bf8f
        }
        // 0x804bf8f
        insert_str(" \"&Xtns\" all options 1 {\n", v3, tcl_lines);
        insert_str(" }\n", result2, tcl_lines);
        // branch -> 0x804c007
    } else {
        // 0x804bfcc
        insert_str(" \"&Xtns\" all options 1 {\n", v1, tcl_lines);
        insert_str(" }\n", v2, tcl_lines);
        result2 = v2;
        // branch -> 0x804c007
    }
    // 0x804c007
    return result2;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804c009 - 0x804c41a
// Line range:    90 - 165
int32_t new_submenu(char * pkg_short_name, char * menu, char ** tcl_lines) {
    char v1[2048];
    char str2[2048];
    // 0x804c009
    int32_t v2;
    int32_t len = v2; // bp-6192
    char * v3;
    char * second_quote = v3; // bp-6188
    int32_t v4;
    int32_t last = v4; // bp-6180
    int32_t v5;
    int32_t insert_here = v5; // bp-6176
    int32_t v6;
    int32_t idx2 = v6; // bp-6172
    int32_t v7;
    int32_t idx = v7; // bp-6168
    int32_t v8 = g3; // 0x804c00c
    int32_t v9 = *(int32_t *)20; // 0x804c02f
    int32_t v10 = find_pos("\"&Xtns\" all options", tcl_lines, 0); // 0x804c052
    v1[0] = v10;
    int32_t v11 = find_pos("\" all options", tcl_lines, v10 + 1); // 0x804c07b
    insert_here = v11 - 1;
    if (v11 == 0) {
        // 0x804c092
        insert_here = find_pos("}]", tcl_lines, 0);
        // branch -> 0x804c0b6
    }
    // 0x804c0b6
    int32_t v12; // eax
    int32_t v13; // bp+228
    if (is_submenu(menu) == 0) {
        // 0x804c0c8
        print_warning("first line not a submenu specifier in 'entries-gisman'.\n");
        v12 = -1;
        v13 = -1;
        // branch -> 0x804c401
    } else {
        char * found_char_pos = strrchr(menu, 93); // 0x804c0ef
        int32_t n = (int32_t)found_char_pos - (int32_t)strchr(menu, 91); // 0x804c10e
        second_quote = (char *)n;
        g3 = n;
        char * found_char_pos2 = strchr(menu, 91); // 0x804c12f
        int32_t str;
        strncpy((char *)&str, (char *)((int32_t)found_char_pos2 + 1), n);
        *(char *)((int32_t)second_quote - 2061 + g2) = 0;
        sprintf(str2, "{cascad \"%s\"", &str);
        int32_t v14 = find_pos(str2, tcl_lines, (int32_t)v1[0]); // 0x804c19c
        idx = v14;
        if (v14 != -1) {
            // 0x804c1b0
            if (v14 < insert_here) {
                // 0x804c1be
                print_warning("submenu '%s' exists in GIS Manager's Xtns menu.\n");
                // branch -> 0x804c401
                // 0x804c401
                if (*(int32_t *)20 != v9) {
                    // 0x804c40d
                    __stack_chk_fail();
                    // branch -> 0x804c412
                }
                // 0x804c412
                g3 = v8;
                return -1;
            }
        }
        int32_t v15 = v1[0]; // 0x804c1de_0
        idx2 = v15 + 1;
        int32_t v16 = find_pos("{cascad ", tcl_lines, v15); // 0x804c208
        idx = v16;
        if (v16 != -1) {
            // branch -> 0x804c30c
            while (true) {
                // 0x804c30c
                if (v16 < insert_here) {
                    int32_t str3 = *(int32_t *)(4 * v16 + (int32_t)tcl_lines); // 0x804c227
                    int32_t found_char_pos3 = (int32_t)strchr((char *)str3, 34); // 0x804c234_4
                    last = found_char_pos3;
                    int32_t n2 = (int32_t)strchr((char *)(found_char_pos3 + 1), 34) - last; // 0x804c26c
                    second_quote = (char *)n2;
                    int32_t str4;
                    strncpy((char *)&str4, (char *)(last + 1), n2);
                    *(char *)((int32_t)second_quote - 0x100d + g2) = 0;
                    if (strcmp((char *)&str, (char *)&str4) > 0) {
                        char v17 = v1[0] + 1; // 0x804c2d6
                        v1[0] = v17;
                        int32_t v18 = find_pos("{cascad ", tcl_lines, (int32_t)v17); // 0x804c2f8
                        idx = v18;
                        if (v18 == -1) {
                            // break -> 0x804c31e
                            break;
                        }
                        v16 = v18;
                        // continue -> 0x804c30c
                        continue;
                    } else {
                        // 0x804c2c8
                        idx2 = idx;
                        // branch -> 0x804c31e
                    }
                    // 0x804c31e
                    sprintf((char *)&str, " \t\t\t%s {} \"\" 1 {\n", str2);
                    insert_str((char *)&str, idx2, tcl_lines);
                    insert_str(" \t\t\t}}\n", idx2 + 1, tcl_lines);
                    len = find_pos("}]", tcl_lines, 0);
                    sprintf((char *)&str, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} \"\" 1 {\n", pkg_short_name, str2);
                    insert_str((char *)&str, len + 1, tcl_lines);
                    // branch -> 0x804c401
                    // 0x804c401
                    if (*(int32_t *)20 != v9) {
                        // 0x804c40d
                        __stack_chk_fail();
                        // branch -> 0x804c412
                    }
                    // 0x804c412
                    g3 = v8;
                    return idx2 + 1;
                }
            }
            // 0x804c31e
            sprintf((char *)&str, " \t\t\t%s {} \"\" 1 {\n", str2);
            insert_str((char *)&str, idx2, tcl_lines);
            insert_str(" \t\t\t}}\n", idx2 + 1, tcl_lines);
            len = find_pos("}]", tcl_lines, 0);
            sprintf((char *)&str, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} \"\" 1 {\n", pkg_short_name, str2);
            insert_str((char *)&str, len + 1, tcl_lines);
            // branch -> 0x804c401
            // 0x804c401
            if (*(int32_t *)20 != v9) {
                // 0x804c40d
                __stack_chk_fail();
                // branch -> 0x804c412
            }
            // 0x804c412
            g3 = v8;
            return idx2 + 1;
        }
        // 0x804c31e
        sprintf((char *)&str, " \t\t\t%s {} \"\" 1 {\n", str2);
        insert_str((char *)&str, idx2, tcl_lines);
        insert_str(" \t\t\t}}\n", idx2 + 1, tcl_lines);
        len = find_pos("}]", tcl_lines, 0);
        sprintf((char *)&str, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} \"\" 1 {\n", pkg_short_name, str2);
        insert_str((char *)&str, len + 1, tcl_lines);
        int32_t v19 = idx2 + 1; // 0x804c3fe
        v12 = v19;
        v13 = v19;
        // branch -> 0x804c401
    }
    // 0x804c401
    int32_t result; // 0x804c41a_2
    if (*(int32_t *)20 != v9) {
        // 0x804c40d
        __stack_chk_fail();
        result = v12;
        // branch -> 0x804c412
    } else {
        result = v13;
    }
    // 0x804c412
    g3 = v8;
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804c41b - 0x804c5ef
// Line range:    173 - 221
int32_t new_item(char * item, char * menu, char ** tcl_lines, int32_t line_no) {
    char str2[2048];
    char v1[2048];
    // 0x804c41b
    char * v2;
    char * token = v2; // bp-6168
    int32_t v3 = *(int32_t *)20; // 0x804c440
    chop(item);
    char next_token = (int32_t)strtok(item, ";");
    v1[0] = next_token;
    if (next_token == 0) {
        // 0x804c47e
        print_warning("invalid token in 'entries-gisman'.\n");
        // branch -> 0x804c5dd
        // 0x804c5dd
        if (*(int32_t *)20 != v3) {
            // 0x804c5e9
            __stack_chk_fail();
            // branch -> 0x804c5ee
        }
        // 0x804c5ee
        return -1;
    }
    // 0x804c494
    int32_t str;
    strcpy((char *)&str, (char *)(int32_t)next_token);
    token = NULL;
    int32_t v4; // 0x804c5d6
    int32_t v5; // eax
    int32_t result; // 0x804c5ef_2
    int32_t v6; // bp+212
    int32_t str3;
    if (v1[0] == 0) {
        // 0x804c504
        if (NULL < (char *)3) {
            // 0x804c52d
            if (strcmp((char *)&str, "-") == 0) {
                // 0x804c547
                if (strcmp((char *)&str, "-") == 0) {
                    // 0x804c561
                    memcpy(str2, " \t\t\t {separator}\n", 18);
                    // branch -> 0x804c5b7
                    // 0x804c5b7
                    insert_str(str2, line_no, tcl_lines);
                    // branch -> 0x804c5dd
                    // 0x804c5dd
                    if (*(int32_t *)20 != v3) {
                        // 0x804c5e9
                        __stack_chk_fail();
                        // branch -> 0x804c5ee
                    }
                    // 0x804c5ee
                    return line_no + 1;
                }
            }
            // 0x804c582
            sprintf(str2, " \t\t\t {command \"%s\" {} \"%s\" {} -command {%s }}\n", &str, &str3, &str3);
            // branch -> 0x804c5b7
            // 0x804c5b7
            insert_str(str2, line_no, tcl_lines);
            v4 = line_no + 1;
            v5 = v4;
            v6 = v4;
            // branch -> 0x804c5dd
        } else {
            // 0x804c50d
            print_warning("invalid number of tokens (%i) in 'entries-gisman'.\n");
            v5 = -1;
            v6 = -1;
            // branch -> 0x804c5dd
        }
        // 0x804c5dd
        if (*(int32_t *)20 != v3) {
            // 0x804c5e9
            __stack_chk_fail();
            result = v5;
            // branch -> 0x804c5ee
        } else {
            result = v6;
        }
        // 0x804c5ee
        return result;
    }
    // 0x804c4b8
    // branch -> 0x804c4b8
    char * v7; // 0x804c4f4_8
    while (true) {
        char next_token2 = (int32_t)strtok(NULL, ";");
        v1[0] = next_token2;
        char * v8; // bp+816
        if (next_token2 == 0) {
            // 0x804c4f4
            v8 = (char *)((int32_t)token + 1);
            token = v8;
            // branch -> 0x804c504
        } else {
            // 0x804c4f4
            strcpy((char *)&str3, (char *)(int32_t)next_token2);
            v7 = (char *)((int32_t)token + 1);
            token = v7;
            if (v1[0] == 0) {
                // break -> 0x804c504
                break;
            }
            // continue -> 0x804c4b8
            continue;
        }
        // 0x804c504
        if (v8 < (char *)3) {
            // 0x804c52d
            if (strcmp((char *)&str, "-") == 0) {
                // 0x804c547
                if (strcmp((char *)&str, "-") == 0) {
                    // 0x804c561
                    memcpy(str2, " \t\t\t {separator}\n", 18);
                    // branch -> 0x804c5b7
                    // 0x804c5b7
                    insert_str(str2, line_no, tcl_lines);
                    // branch -> 0x804c5dd
                    // 0x804c5dd
                    if (*(int32_t *)20 != v3) {
                        // 0x804c5e9
                        __stack_chk_fail();
                        // branch -> 0x804c5ee
                    }
                    // 0x804c5ee
                    return line_no + 1;
                }
            }
            // 0x804c582
            sprintf(str2, " \t\t\t {command \"%s\" {} \"%s\" {} -command {%s }}\n", &str, &str3, &str3);
            // branch -> 0x804c5b7
            // 0x804c5b7
            insert_str(str2, line_no, tcl_lines);
            v4 = line_no + 1;
            v5 = v4;
            v6 = v4;
            // branch -> 0x804c5dd
        } else {
            // 0x804c50d
            print_warning("invalid number of tokens (%i) in 'entries-gisman'.\n");
            v5 = -1;
            v6 = -1;
            // branch -> 0x804c5dd
        }
        // 0x804c5dd
        if (*(int32_t *)20 != v3) {
            // 0x804c5e9
            __stack_chk_fail();
            result = v5;
            // branch -> 0x804c5ee
        } else {
            result = v6;
        }
        // 0x804c5ee
        return result;
    }
    // 0x804c504
    if (v7 < (char *)3) {
        // 0x804c52d
        if (strcmp((char *)&str, "-") == 0) {
            // 0x804c547
            if (strcmp((char *)&str, "-") == 0) {
                // 0x804c561
                memcpy(str2, " \t\t\t {separator}\n", 18);
                // branch -> 0x804c5b7
                // 0x804c5b7
                insert_str(str2, line_no, tcl_lines);
                // branch -> 0x804c5dd
                // 0x804c5dd
                if (*(int32_t *)20 != v3) {
                    // 0x804c5e9
                    __stack_chk_fail();
                    // branch -> 0x804c5ee
                }
                // 0x804c5ee
                return line_no + 1;
            }
        }
        // 0x804c582
        sprintf(str2, " \t\t\t {command \"%s\" {} \"%s\" {} -command {%s }}\n", &str, &str3, &str3);
        // branch -> 0x804c5b7
        // 0x804c5b7
        insert_str(str2, line_no, tcl_lines);
        v4 = line_no + 1;
        v5 = v4;
        v6 = v4;
        // branch -> 0x804c5dd
    } else {
        // 0x804c50d
        print_warning("invalid number of tokens (%i) in 'entries-gisman'.\n");
        v5 = -1;
        v6 = -1;
        // branch -> 0x804c5dd
    }
    // 0x804c5dd
    if (*(int32_t *)20 != v3) {
        // 0x804c5e9
        __stack_chk_fail();
        result = v5;
        // branch -> 0x804c5ee
    } else {
        result = v6;
    }
    // 0x804c5ee
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804c5f0 - 0x804cd6b
// Line range:    232 - 404
void register_entries_gisman(char * pkg_short_name, char * gisbase) {
    char v1[2048];
    char str7[2048];
    // 0x804c5f0
    struct _IO_FILE_4 * v2;
    struct _IO_FILE_4 * f_out = v2; // bp-6208
    struct _IO_FILE_4 * v3;
    struct _IO_FILE_4 * f_in = v3; // bp-6204
    struct _IO_FILE_4 * v4;
    struct _IO_FILE_4 * f_gisman = v4; // bp-6200
    int32_t v5;
    int32_t line_no = v5; // bp-6196
    int32_t v6;
    int32_t n_lines_new = v6; // bp-6192
    int32_t v7;
    int32_t n_lines_org = v7; // bp-6188
    int32_t v8;
    int32_t i = v8; // bp-6184
    int32_t v9;
    int32_t n_lines = v9; // bp-6180
    int32_t v10;
    int32_t n_entries = v10; // bp-6176
    char ** v11;
    char ** line = v11; // bp-6172
    int32_t v12;
    int32_t len = v12; // bp-6168
    int32_t v13 = g3; // 0x804c5f3
    f_out = (struct _IO_FILE_4 *)pkg_short_name;
    int32_t v14 = *(int32_t *)20; // 0x804c60d
    int32_t file_path;
    memcpy((char *)&file_path, "../entries-gisman", 18);
    struct _IO_FILE * file = fopen((char *)&file_path, "r"); // 0x804c648
    line_no = (int32_t)file;
    int32_t v15; // 0x804c9d8
    int32_t v16; // 0x804c9d8164
    int32_t v17; // 0x804cc1a
    int32_t v18; // 0x804ca0f
    struct _IO_FILE * file2; // 0x804c6de
    struct _IO_FILE * file3; // 0x804c77b
    char * str2; // 0x804c90e
    char * str; // 0x804c90e96
    char * str3; // 0x804c960
    char * mem; // 0x804c9ac
    int32_t len2; // 0x804ca1e
    int32_t str5;
    int32_t err_num2; // 0x804c715
    int32_t err_num3; // 0x804c794
    int32_t str6; // 0x804ca45
    struct _IO_FILE_4 * v19; // 0x804c892
    int32_t v20; // 0x804cc2a
    int32_t format; // 0x804cc2a74
    char ** v21; // 0x804c917
    char ** v22; // 0x804c91799
    char ** v23;
    int32_t v24; // 0x804c969
    if (file == NULL) {
        // 0x804c65c
        if (*__errno_location() != 2) {
            // 0x804c66c
            fclose((struct _IO_FILE *)line_no);
            int32_t err_num = *__errno_location(); // 0x804c67f
            strerror(err_num);
            print_error(-21, "checking for file '%s': %s\n");
            // branch -> 0x804c6ab
            // 0x804c6ab
            sprintf((char *)&file_path, "%s/etc/dm/menu.tcl", gisbase);
            file2 = fopen((char *)&file_path, "r");
            f_gisman = (struct _IO_FILE_4 *)file2;
            char * str4; // 0x804cc80
            uint32_t v25; // 0x804cc89
            if (file2 == NULL) {
                // 0x804c6f2
                if (*__errno_location() != 2) {
                    // 0x804c702
                    fclose((struct _IO_FILE *)f_gisman);
                    err_num2 = *__errno_location();
                    strerror(err_num2);
                    print_error(-21, "checking for file '%s': %s\n");
                    // branch -> 0x804c741
                    // 0x804c741
                    memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
                    mkstemp(TMP_GISMAN);
                    file3 = fopen(TMP_GISMAN, "w+");
                    f_in = (struct _IO_FILE_4 *)file3;
                    if (file3 == NULL) {
                        // 0x804c78f
                        err_num3 = *__errno_location();
                        strerror(err_num3);
                        print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                        // branch -> 0x804c7be
                    }
                    // 0x804c7be
                    atexit((void (**)())exit_db);
                    v19 = f_out;
                    if (VERBOSE == 0) {
                        // 0x804c83d
                        sprintf((char *)&str5, "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, TMP_NULL, gisbase, v19, TMP_NULL, gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
                        // branch -> 0x804c8ca
                    } else {
                        // 0x804c7d3
                        sprintf((char *)&str5, "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, v19, gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
                        // branch -> 0x804c8ca
                    }
                    // 0x804c8ca
                    strcpy(GISMAN_CMD, (char *)&str5);
                    line = NULL;
                    str = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
                    v22 = line;
                    v23 = v22;
                    if (str != NULL) {
                        line = (char **)((int32_t)v22 + 1);
                        str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
                        v21 = line;
                        v23 = v21;
                        while (str2 != NULL) {
                            // 0x804c8ec
                            line = (char **)((int32_t)v21 + 1);
                            str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
                            v21 = line;
                            v23 = v21;
                            // continue -> 0x804c8ec
                        }
                        // 0x804c917
                        if (v23 != NULL) {
                            // 0x804c924
                            rewind((struct _IO_FILE *)line_no);
                            n_entries = 0;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                            v24 = n_entries;
                            // branch -> 0x804c945
                            while (str3 != NULL) {
                                // 0x804c945
                                n_entries = v24 + 1;
                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                                v24 = n_entries;
                                // continue -> 0x804c945
                            }
                            // 0x804c969
                            if (v24 != 0) {
                                // 0x804c976
                                i = v24;
                                rewind((struct _IO_FILE *)f_gisman);
                                mem = calloc(n_entries + 6 + 2 * (int32_t)line, 4);
                                len = (int32_t)mem;
                                n_lines = 0;
                                int32_t v26; // 0x804cd18
                                if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                    // 0x804c9c3
                                    *(int32_t *)mem = 0;
                                    v16 = n_lines + 1;
                                    n_lines = v16;
                                    if (n_entries + 6 + 2 * (int32_t)line > v16) {
                                        *(int32_t *)(4 * v16 + len) = 0;
                                        v15 = n_lines + 1;
                                        n_lines = v15;
                                        while (n_entries + 6 + 2 * (int32_t)line > v15) {
                                            // 0x804c9c3
                                            *(int32_t *)(4 * v15 + len) = 0;
                                            v15 = n_lines + 1;
                                            n_lines = v15;
                                            // continue -> 0x804c9c3
                                        }
                                        // 0x804ca5a
                                        n_lines = 0;
                                        if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                            v18 = len + 4 * n_lines;
                                            g3 = v18;
                                            len2 = strlen((char *)&str5);
                                            *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                            str6 = *(int32_t *)(len + 4 * n_lines);
                                            strcpy((char *)str6, (char *)&str5);
                                            n_lines++;
                                            while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                                // 0x804ca04
                                                v18 = len + 4 * n_lines;
                                                g3 = v18;
                                                len2 = strlen((char *)&str5);
                                                *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                                str6 = *(int32_t *)(len + 4 * n_lines);
                                                strcpy((char *)str6, (char *)&str5);
                                                n_lines++;
                                                // continue -> 0x804ca04
                                            }
                                            // 0x804ca7e
                                            check_ext_menu((char **)len);
                                            n_lines = 1;
                                            if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                                // 0x804ca9b
                                                // branch -> 0x804ca9b
                                                while (true) {
                                                    // 0x804ca9b
                                                    if (n_lines == 1) {
                                                      lab_0x804caa8_24:;
                                                        char * found_char_pos = strrchr((char *)&str5, 93); // 0x804cab9
                                                        char * found_char_pos2 = strchr((char *)&str5, 91); // 0x804cad1
                                                        int32_t n = (int32_t)found_char_pos - (int32_t)found_char_pos2; // 0x804cad8
                                                        v1[0] = n;
                                                        g3 = n;
                                                        char * found_char_pos3 = strchr((char *)&str5, 91); // 0x804caf9
                                                        strncpy(str7, (char *)((int32_t)found_char_pos3 + 1), n);
                                                        v1[3] = 0;
                                                        int32_t v27 = new_submenu((char *)f_out, (char *)&str5, (char **)len); // 0x804cb45
                                                        n_lines_new = v27;
                                                        if (v27 <= 0) {
                                                            // 0x804cb59
                                                            print_warning("no GIS Manager menu entries created.\n");
                                                            // branch -> 0x804cc21
                                                            // 0x804cc21
                                                            n_lines = 0;
                                                            format = len;
                                                            if (*(int32_t *)format == 0) {
                                                                // 0x804cc36
                                                                fflush((struct _IO_FILE *)f_in);
                                                                rewind((struct _IO_FILE *)f_in);
                                                                n_lines_org = 0;
                                                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v25 = n_lines_org;
                                                                // branch -> 0x804cc65
                                                                while (str4 != NULL) {
                                                                    // 0x804cc65
                                                                    n_lines_org = v25 + 1;
                                                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                    v25 = n_lines_org;
                                                                    // continue -> 0x804cc65
                                                                }
                                                                // 0x804cc89
                                                                if (v25 != 0) {
                                                                    // 0x804cc92
                                                                    if (v25 >= i) {
                                                                        // 0x804ccc9
                                                                        fclose((struct _IO_FILE *)f_gisman);
                                                                        fclose((struct _IO_FILE *)line_no);
                                                                        fclose((struct _IO_FILE *)f_in);
                                                                        n_lines = 0;
                                                                        if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                                            // 0x804cd38
                                                                            free((char *)len);
                                                                            // branch -> 0x804cd52
                                                                            // 0x804cd52
                                                                            if (*(int32_t *)20 != v14) {
                                                                                // 0x804cd5e
                                                                                __stack_chk_fail();
                                                                                // branch -> 0x804cd63
                                                                            }
                                                                            // 0x804cd63
                                                                            g3 = v13;
                                                                            return;
                                                                        }
                                                                        free((char *)*(int32_t *)len);
                                                                        v26 = n_lines + 1;
                                                                        n_lines = v26;
                                                                        while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                            // 0x804ccff
                                                                            free((char *)*(int32_t *)(len + 4 * v26));
                                                                            v26 = n_lines + 1;
                                                                            n_lines = v26;
                                                                            // continue -> 0x804ccff
                                                                        }
                                                                        // 0x804cd38
                                                                        free((char *)len);
                                                                        // branch -> 0x804cd52
                                                                        // 0x804cd52
                                                                        if (*(int32_t *)20 != v14) {
                                                                            // 0x804cd5e
                                                                            __stack_chk_fail();
                                                                            // branch -> 0x804cd63
                                                                        }
                                                                        // 0x804cd63
                                                                        g3 = v13;
                                                                        return;
                                                                    }
                                                                }
                                                                // 0x804cca0
                                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                // branch -> 0x804ccc9
                                                                // 0x804ccc9
                                                                fclose((struct _IO_FILE *)f_gisman);
                                                                fclose((struct _IO_FILE *)line_no);
                                                                fclose((struct _IO_FILE *)f_in);
                                                                n_lines = 0;
                                                                if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                                    // 0x804cd38
                                                                    free((char *)len);
                                                                    // branch -> 0x804cd52
                                                                    // 0x804cd52
                                                                    if (*(int32_t *)20 != v14) {
                                                                        // 0x804cd5e
                                                                        __stack_chk_fail();
                                                                        // branch -> 0x804cd63
                                                                    }
                                                                    // 0x804cd63
                                                                    g3 = v13;
                                                                    return;
                                                                }
                                                                free((char *)*(int32_t *)len);
                                                                v26 = n_lines + 1;
                                                                n_lines = v26;
                                                                while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                    // 0x804ccff
                                                                    free((char *)*(int32_t *)(len + 4 * v26));
                                                                    v26 = n_lines + 1;
                                                                    n_lines = v26;
                                                                    // continue -> 0x804ccff
                                                                }
                                                                // 0x804cd38
                                                                free((char *)len);
                                                                // branch -> 0x804cd52
                                                                // 0x804cd52
                                                                if (*(int32_t *)20 != v14) {
                                                                    // 0x804cd5e
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804cd63
                                                                }
                                                                // 0x804cd63
                                                                g3 = v13;
                                                                return;
                                                            }
                                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                                            v17 = n_lines + 1;
                                                            n_lines = v17;
                                                            v20 = len;
                                                            while (*(int32_t *)(4 * v17 + v20) != 0) {
                                                                // 0x804cbf7
                                                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                                                v17 = n_lines + 1;
                                                                n_lines = v17;
                                                                v20 = len;
                                                                // continue -> 0x804cbf7
                                                            }
                                                            // 0x804cc36
                                                            fflush((struct _IO_FILE *)f_in);
                                                            rewind((struct _IO_FILE *)f_in);
                                                            n_lines_org = 0;
                                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v25 = n_lines_org;
                                                            // branch -> 0x804cc65
                                                            while (str4 != NULL) {
                                                                // 0x804cc65
                                                                n_lines_org = v25 + 1;
                                                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v25 = n_lines_org;
                                                                // continue -> 0x804cc65
                                                            }
                                                            // 0x804cc89
                                                            if (v25 != 0) {
                                                                // 0x804cc92
                                                                if (v25 >= i) {
                                                                    // 0x804ccc9
                                                                    fclose((struct _IO_FILE *)f_gisman);
                                                                    fclose((struct _IO_FILE *)line_no);
                                                                    fclose((struct _IO_FILE *)f_in);
                                                                    n_lines = 0;
                                                                    if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                                        // 0x804cd38
                                                                        free((char *)len);
                                                                        // branch -> 0x804cd52
                                                                        // 0x804cd52
                                                                        if (*(int32_t *)20 != v14) {
                                                                            // 0x804cd5e
                                                                            __stack_chk_fail();
                                                                            // branch -> 0x804cd63
                                                                        }
                                                                        // 0x804cd63
                                                                        g3 = v13;
                                                                        return;
                                                                    }
                                                                    free((char *)*(int32_t *)len);
                                                                    v26 = n_lines + 1;
                                                                    n_lines = v26;
                                                                    while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                        // 0x804ccff
                                                                        free((char *)*(int32_t *)(len + 4 * v26));
                                                                        v26 = n_lines + 1;
                                                                        n_lines = v26;
                                                                        // continue -> 0x804ccff
                                                                    }
                                                                    // 0x804cd38
                                                                    free((char *)len);
                                                                    // branch -> 0x804cd52
                                                                    // 0x804cd52
                                                                    if (*(int32_t *)20 != v14) {
                                                                        // 0x804cd5e
                                                                        __stack_chk_fail();
                                                                        // branch -> 0x804cd63
                                                                    }
                                                                    // 0x804cd63
                                                                    g3 = v13;
                                                                    return;
                                                                }
                                                            }
                                                            // 0x804cca0
                                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                            // branch -> 0x804ccc9
                                                            // 0x804ccc9
                                                            fclose((struct _IO_FILE *)f_gisman);
                                                            fclose((struct _IO_FILE *)line_no);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                                // 0x804cd38
                                                                free((char *)len);
                                                                // branch -> 0x804cd52
                                                                // 0x804cd52
                                                                if (*(int32_t *)20 != v14) {
                                                                    // 0x804cd5e
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804cd63
                                                                }
                                                                // 0x804cd63
                                                                g3 = v13;
                                                                return;
                                                            }
                                                            free((char *)*(int32_t *)len);
                                                            v26 = n_lines + 1;
                                                            n_lines = v26;
                                                            while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                // 0x804ccff
                                                                free((char *)*(int32_t *)(len + 4 * v26));
                                                                v26 = n_lines + 1;
                                                                n_lines = v26;
                                                                // continue -> 0x804ccff
                                                            }
                                                            // 0x804cd38
                                                            free((char *)len);
                                                            // branch -> 0x804cd52
                                                            // 0x804cd52
                                                            if (*(int32_t *)20 != v14) {
                                                                // 0x804cd5e
                                                                __stack_chk_fail();
                                                                // branch -> 0x804cd63
                                                            }
                                                            // 0x804cd63
                                                            g3 = v13;
                                                            return;
                                                        }
                                                    } else {
                                                      lab_0x804cb73_24:;
                                                        int32_t v28 = new_item((char *)&str5, str7, (char **)len, n_lines_new); // 0x804cb9a
                                                        n_lines_new = v28;
                                                        if (v28 <= 0) {
                                                            // 0x804cbae
                                                            print_warning("error creating GIS Manager menu entries.\n");
                                                            // branch -> 0x804cc21
                                                            // 0x804cc21
                                                            n_lines = 0;
                                                            format = len;
                                                            if (*(int32_t *)format == 0) {
                                                                // 0x804cc36
                                                                fflush((struct _IO_FILE *)f_in);
                                                                rewind((struct _IO_FILE *)f_in);
                                                                n_lines_org = 0;
                                                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v25 = n_lines_org;
                                                                // branch -> 0x804cc65
                                                                while (str4 != NULL) {
                                                                    // 0x804cc65
                                                                    n_lines_org = v25 + 1;
                                                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                    v25 = n_lines_org;
                                                                    // continue -> 0x804cc65
                                                                }
                                                                // 0x804cc89
                                                                if (v25 != 0) {
                                                                    // 0x804cc92
                                                                    if (v25 >= i) {
                                                                        // 0x804ccc9
                                                                        fclose((struct _IO_FILE *)f_gisman);
                                                                        fclose((struct _IO_FILE *)line_no);
                                                                        fclose((struct _IO_FILE *)f_in);
                                                                        n_lines = 0;
                                                                        if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                                            // 0x804cd38
                                                                            free((char *)len);
                                                                            // branch -> 0x804cd52
                                                                            // 0x804cd52
                                                                            if (*(int32_t *)20 != v14) {
                                                                                // 0x804cd5e
                                                                                __stack_chk_fail();
                                                                                // branch -> 0x804cd63
                                                                            }
                                                                            // 0x804cd63
                                                                            g3 = v13;
                                                                            return;
                                                                        }
                                                                        free((char *)*(int32_t *)len);
                                                                        v26 = n_lines + 1;
                                                                        n_lines = v26;
                                                                        while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                            // 0x804ccff
                                                                            free((char *)*(int32_t *)(len + 4 * v26));
                                                                            v26 = n_lines + 1;
                                                                            n_lines = v26;
                                                                            // continue -> 0x804ccff
                                                                        }
                                                                        // 0x804cd38
                                                                        free((char *)len);
                                                                        // branch -> 0x804cd52
                                                                        // 0x804cd52
                                                                        if (*(int32_t *)20 != v14) {
                                                                            // 0x804cd5e
                                                                            __stack_chk_fail();
                                                                            // branch -> 0x804cd63
                                                                        }
                                                                        // 0x804cd63
                                                                        g3 = v13;
                                                                        return;
                                                                    }
                                                                }
                                                                // 0x804cca0
                                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                // branch -> 0x804ccc9
                                                                // 0x804ccc9
                                                                fclose((struct _IO_FILE *)f_gisman);
                                                                fclose((struct _IO_FILE *)line_no);
                                                                fclose((struct _IO_FILE *)f_in);
                                                                n_lines = 0;
                                                                if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                                    // 0x804cd38
                                                                    free((char *)len);
                                                                    // branch -> 0x804cd52
                                                                    // 0x804cd52
                                                                    if (*(int32_t *)20 != v14) {
                                                                        // 0x804cd5e
                                                                        __stack_chk_fail();
                                                                        // branch -> 0x804cd63
                                                                    }
                                                                    // 0x804cd63
                                                                    g3 = v13;
                                                                    return;
                                                                }
                                                                free((char *)*(int32_t *)len);
                                                                v26 = n_lines + 1;
                                                                n_lines = v26;
                                                                while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                    // 0x804ccff
                                                                    free((char *)*(int32_t *)(len + 4 * v26));
                                                                    v26 = n_lines + 1;
                                                                    n_lines = v26;
                                                                    // continue -> 0x804ccff
                                                                }
                                                                // 0x804cd38
                                                                free((char *)len);
                                                                // branch -> 0x804cd52
                                                                // 0x804cd52
                                                                if (*(int32_t *)20 != v14) {
                                                                    // 0x804cd5e
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804cd63
                                                                }
                                                                // 0x804cd63
                                                                g3 = v13;
                                                                return;
                                                            }
                                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                                            v17 = n_lines + 1;
                                                            n_lines = v17;
                                                            v20 = len;
                                                            while (*(int32_t *)(4 * v17 + v20) != 0) {
                                                                // 0x804cbf7
                                                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                                                v17 = n_lines + 1;
                                                                n_lines = v17;
                                                                v20 = len;
                                                                // continue -> 0x804cbf7
                                                            }
                                                            // 0x804cc36
                                                            fflush((struct _IO_FILE *)f_in);
                                                            rewind((struct _IO_FILE *)f_in);
                                                            n_lines_org = 0;
                                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v25 = n_lines_org;
                                                            // branch -> 0x804cc65
                                                            while (str4 != NULL) {
                                                                // 0x804cc65
                                                                n_lines_org = v25 + 1;
                                                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v25 = n_lines_org;
                                                                // continue -> 0x804cc65
                                                            }
                                                            // 0x804cc89
                                                            if (v25 != 0) {
                                                                // 0x804cc92
                                                                if (v25 >= i) {
                                                                    // 0x804ccc9
                                                                    fclose((struct _IO_FILE *)f_gisman);
                                                                    fclose((struct _IO_FILE *)line_no);
                                                                    fclose((struct _IO_FILE *)f_in);
                                                                    n_lines = 0;
                                                                    if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                                        // 0x804cd38
                                                                        free((char *)len);
                                                                        // branch -> 0x804cd52
                                                                        // 0x804cd52
                                                                        if (*(int32_t *)20 != v14) {
                                                                            // 0x804cd5e
                                                                            __stack_chk_fail();
                                                                            // branch -> 0x804cd63
                                                                        }
                                                                        // 0x804cd63
                                                                        g3 = v13;
                                                                        return;
                                                                    }
                                                                    free((char *)*(int32_t *)len);
                                                                    v26 = n_lines + 1;
                                                                    n_lines = v26;
                                                                    while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                        // 0x804ccff
                                                                        free((char *)*(int32_t *)(len + 4 * v26));
                                                                        v26 = n_lines + 1;
                                                                        n_lines = v26;
                                                                        // continue -> 0x804ccff
                                                                    }
                                                                    // 0x804cd38
                                                                    free((char *)len);
                                                                    // branch -> 0x804cd52
                                                                    // 0x804cd52
                                                                    if (*(int32_t *)20 != v14) {
                                                                        // 0x804cd5e
                                                                        __stack_chk_fail();
                                                                        // branch -> 0x804cd63
                                                                    }
                                                                    // 0x804cd63
                                                                    g3 = v13;
                                                                    return;
                                                                }
                                                            }
                                                            // 0x804cca0
                                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                            // branch -> 0x804ccc9
                                                            // 0x804ccc9
                                                            fclose((struct _IO_FILE *)f_gisman);
                                                            fclose((struct _IO_FILE *)line_no);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                                // 0x804cd38
                                                                free((char *)len);
                                                                // branch -> 0x804cd52
                                                                // 0x804cd52
                                                                if (*(int32_t *)20 != v14) {
                                                                    // 0x804cd5e
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804cd63
                                                                }
                                                                // 0x804cd63
                                                                g3 = v13;
                                                                return;
                                                            }
                                                            free((char *)*(int32_t *)len);
                                                            v26 = n_lines + 1;
                                                            n_lines = v26;
                                                            while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                // 0x804ccff
                                                                free((char *)*(int32_t *)(len + 4 * v26));
                                                                v26 = n_lines + 1;
                                                                n_lines = v26;
                                                                // continue -> 0x804ccff
                                                            }
                                                            // 0x804cd38
                                                            free((char *)len);
                                                            // branch -> 0x804cd52
                                                            // 0x804cd52
                                                            if (*(int32_t *)20 != v14) {
                                                                // 0x804cd5e
                                                                __stack_chk_fail();
                                                                // branch -> 0x804cd63
                                                            }
                                                            // 0x804cd63
                                                            g3 = v13;
                                                            return;
                                                        }
                                                    }
                                                    // 0x804cbc3
                                                    n_lines++;
                                                    if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) == NULL) {
                                                        // break -> 0x804cc21
                                                        break;
                                                    }
                                                    // continue -> 0x804ca9b
                                                }
                                                // 0x804cc21
                                                n_lines = 0;
                                                format = len;
                                                if (*(int32_t *)format == 0) {
                                                    // 0x804cc36
                                                    fflush((struct _IO_FILE *)f_in);
                                                    rewind((struct _IO_FILE *)f_in);
                                                    n_lines_org = 0;
                                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                    v25 = n_lines_org;
                                                    // branch -> 0x804cc65
                                                    while (str4 != NULL) {
                                                        // 0x804cc65
                                                        n_lines_org = v25 + 1;
                                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v25 = n_lines_org;
                                                        // continue -> 0x804cc65
                                                    }
                                                    // 0x804cc89
                                                    if (v25 != 0) {
                                                        // 0x804cc92
                                                        if (v25 >= i) {
                                                            // 0x804ccc9
                                                            fclose((struct _IO_FILE *)f_gisman);
                                                            fclose((struct _IO_FILE *)line_no);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                                // 0x804cd38
                                                                free((char *)len);
                                                                // branch -> 0x804cd52
                                                                // 0x804cd52
                                                                if (*(int32_t *)20 != v14) {
                                                                    // 0x804cd5e
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804cd63
                                                                }
                                                                // 0x804cd63
                                                                g3 = v13;
                                                                return;
                                                            }
                                                            free((char *)*(int32_t *)len);
                                                            v26 = n_lines + 1;
                                                            n_lines = v26;
                                                            while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                // 0x804ccff
                                                                free((char *)*(int32_t *)(len + 4 * v26));
                                                                v26 = n_lines + 1;
                                                                n_lines = v26;
                                                                // continue -> 0x804ccff
                                                            }
                                                            // 0x804cd38
                                                            free((char *)len);
                                                            // branch -> 0x804cd52
                                                            // 0x804cd52
                                                            if (*(int32_t *)20 != v14) {
                                                                // 0x804cd5e
                                                                __stack_chk_fail();
                                                                // branch -> 0x804cd63
                                                            }
                                                            // 0x804cd63
                                                            g3 = v13;
                                                            return;
                                                        }
                                                    }
                                                    // 0x804cca0
                                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                    // branch -> 0x804ccc9
                                                    // 0x804ccc9
                                                    fclose((struct _IO_FILE *)f_gisman);
                                                    fclose((struct _IO_FILE *)line_no);
                                                    fclose((struct _IO_FILE *)f_in);
                                                    n_lines = 0;
                                                    if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                        // 0x804cd38
                                                        free((char *)len);
                                                        // branch -> 0x804cd52
                                                        // 0x804cd52
                                                        if (*(int32_t *)20 != v14) {
                                                            // 0x804cd5e
                                                            __stack_chk_fail();
                                                            // branch -> 0x804cd63
                                                        }
                                                        // 0x804cd63
                                                        g3 = v13;
                                                        return;
                                                    }
                                                    free((char *)*(int32_t *)len);
                                                    v26 = n_lines + 1;
                                                    n_lines = v26;
                                                    while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                        // 0x804ccff
                                                        free((char *)*(int32_t *)(len + 4 * v26));
                                                        v26 = n_lines + 1;
                                                        n_lines = v26;
                                                        // continue -> 0x804ccff
                                                    }
                                                    // 0x804cd38
                                                    free((char *)len);
                                                    // branch -> 0x804cd52
                                                    // 0x804cd52
                                                    if (*(int32_t *)20 != v14) {
                                                        // 0x804cd5e
                                                        __stack_chk_fail();
                                                        // branch -> 0x804cd63
                                                    }
                                                    // 0x804cd63
                                                    g3 = v13;
                                                    return;
                                                }
                                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                                v17 = n_lines + 1;
                                                n_lines = v17;
                                                v20 = len;
                                                while (*(int32_t *)(4 * v17 + v20) != 0) {
                                                    // 0x804cbf7
                                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                                    v17 = n_lines + 1;
                                                    n_lines = v17;
                                                    v20 = len;
                                                    // continue -> 0x804cbf7
                                                }
                                                // 0x804cc36
                                                fflush((struct _IO_FILE *)f_in);
                                                rewind((struct _IO_FILE *)f_in);
                                                n_lines_org = 0;
                                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                v25 = n_lines_org;
                                                // branch -> 0x804cc65
                                                while (str4 != NULL) {
                                                    // 0x804cc65
                                                    n_lines_org = v25 + 1;
                                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                    v25 = n_lines_org;
                                                    // continue -> 0x804cc65
                                                }
                                                // 0x804cc89
                                                if (v25 != 0) {
                                                    // 0x804cc92
                                                    if (v25 >= i) {
                                                        // 0x804ccc9
                                                        fclose((struct _IO_FILE *)f_gisman);
                                                        fclose((struct _IO_FILE *)line_no);
                                                        fclose((struct _IO_FILE *)f_in);
                                                        n_lines = 0;
                                                        if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                            // 0x804cd38
                                                            free((char *)len);
                                                            // branch -> 0x804cd52
                                                            // 0x804cd52
                                                            if (*(int32_t *)20 != v14) {
                                                                // 0x804cd5e
                                                                __stack_chk_fail();
                                                                // branch -> 0x804cd63
                                                            }
                                                            // 0x804cd63
                                                            g3 = v13;
                                                            return;
                                                        }
                                                        free((char *)*(int32_t *)len);
                                                        v26 = n_lines + 1;
                                                        n_lines = v26;
                                                        while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                            // 0x804ccff
                                                            free((char *)*(int32_t *)(len + 4 * v26));
                                                            v26 = n_lines + 1;
                                                            n_lines = v26;
                                                            // continue -> 0x804ccff
                                                        }
                                                        // 0x804cd38
                                                        free((char *)len);
                                                        // branch -> 0x804cd52
                                                        // 0x804cd52
                                                        if (*(int32_t *)20 != v14) {
                                                            // 0x804cd5e
                                                            __stack_chk_fail();
                                                            // branch -> 0x804cd63
                                                        }
                                                        // 0x804cd63
                                                        g3 = v13;
                                                        return;
                                                    }
                                                }
                                                // 0x804cca0
                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                // branch -> 0x804ccc9
                                                // 0x804ccc9
                                                fclose((struct _IO_FILE *)f_gisman);
                                                fclose((struct _IO_FILE *)line_no);
                                                fclose((struct _IO_FILE *)f_in);
                                                n_lines = 0;
                                                if (n_entries + 6 + 2 * (int32_t)line <= 0) {
                                                    // 0x804cd38
                                                    free((char *)len);
                                                    // branch -> 0x804cd52
                                                    // 0x804cd52
                                                    if (*(int32_t *)20 != v14) {
                                                        // 0x804cd5e
                                                        __stack_chk_fail();
                                                        // branch -> 0x804cd63
                                                    }
                                                    // 0x804cd63
                                                    g3 = v13;
                                                    return;
                                                }
                                                free((char *)*(int32_t *)len);
                                                v26 = n_lines + 1;
                                                n_lines = v26;
                                                while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                    // 0x804ccff
                                                    free((char *)*(int32_t *)(len + 4 * v26));
                                                    v26 = n_lines + 1;
                                                    n_lines = v26;
                                                    // continue -> 0x804ccff
                                                }
                                                // 0x804cd38
                                                free((char *)len);
                                                // branch -> 0x804cd52
                                                // 0x804cd52
                                                if (*(int32_t *)20 != v14) {
                                                    // 0x804cd5e
                                                    __stack_chk_fail();
                                                    // branch -> 0x804cd63
                                                }
                                                // 0x804cd63
                                                g3 = v13;
                                                return;
                                            }
                                            // 0x804cc21
                                            n_lines = 0;
                                            format = len;
                                            if (*(int32_t *)format != 0) {
                                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                                v17 = n_lines + 1;
                                                n_lines = v17;
                                                v20 = len;
                                                while (*(int32_t *)(4 * v17 + v20) != 0) {
                                                    // 0x804cbf7
                                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                                    v17 = n_lines + 1;
                                                    n_lines = v17;
                                                    v20 = len;
                                                    // continue -> 0x804cbf7
                                                }
                                                // 0x804cc36
                                                fflush((struct _IO_FILE *)f_in);
                                                rewind((struct _IO_FILE *)f_in);
                                                n_lines_org = 0;
                                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                v25 = n_lines_org;
                                                // branch -> 0x804cc65
                                                while (str4 != NULL) {
                                                    // 0x804cc65
                                                    n_lines_org = v25 + 1;
                                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                    v25 = n_lines_org;
                                                    // continue -> 0x804cc65
                                                }
                                                // 0x804cc89
                                                if (v25 != 0) {
                                                    // 0x804cc92
                                                    if (v25 >= i) {
                                                        // 0x804ccc9
                                                        fclose((struct _IO_FILE *)f_gisman);
                                                        fclose((struct _IO_FILE *)line_no);
                                                        fclose((struct _IO_FILE *)f_in);
                                                        n_lines = 0;
                                                        if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                            free((char *)*(int32_t *)len);
                                                            v26 = n_lines + 1;
                                                            n_lines = v26;
                                                            while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                                // 0x804ccff
                                                                free((char *)*(int32_t *)(len + 4 * v26));
                                                                v26 = n_lines + 1;
                                                                n_lines = v26;
                                                                // continue -> 0x804ccff
                                                            }
                                                            // 0x804cd38
                                                            free((char *)len);
                                                            // branch -> 0x804cd52
                                                            // 0x804cd52
                                                            if (*(int32_t *)20 != v14) {
                                                                // 0x804cd5e
                                                                __stack_chk_fail();
                                                                // branch -> 0x804cd63
                                                            }
                                                            // 0x804cd63
                                                            g3 = v13;
                                                            return;
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // 0x804cca0
                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                // branch -> 0x804ccc9
                                                // 0x804ccc9
                                                fclose((struct _IO_FILE *)f_gisman);
                                                fclose((struct _IO_FILE *)line_no);
                                                fclose((struct _IO_FILE *)f_in);
                                                n_lines = 0;
                                                if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                    free((char *)*(int32_t *)len);
                                                    v26 = n_lines + 1;
                                                    n_lines = v26;
                                                    while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                        // 0x804ccff
                                                        free((char *)*(int32_t *)(len + 4 * v26));
                                                        v26 = n_lines + 1;
                                                        n_lines = v26;
                                                        // continue -> 0x804ccff
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // 0x804cc36
                                            fflush((struct _IO_FILE *)f_in);
                                            rewind((struct _IO_FILE *)f_in);
                                            n_lines_org = 0;
                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                            v25 = n_lines_org;
                                            // branch -> 0x804cc65
                                            while (str4 != NULL) {
                                                // 0x804cc65
                                                n_lines_org = v25 + 1;
                                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                v25 = n_lines_org;
                                                // continue -> 0x804cc65
                                            }
                                            // 0x804cc89
                                            if (v25 != 0) {
                                                // 0x804cc92
                                                if (v25 >= i) {
                                                    // 0x804ccc9
                                                    fclose((struct _IO_FILE *)f_gisman);
                                                    fclose((struct _IO_FILE *)line_no);
                                                    fclose((struct _IO_FILE *)f_in);
                                                    n_lines = 0;
                                                    if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                        free((char *)*(int32_t *)len);
                                                        v26 = n_lines + 1;
                                                        n_lines = v26;
                                                        while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                            // 0x804ccff
                                                            free((char *)*(int32_t *)(len + 4 * v26));
                                                            v26 = n_lines + 1;
                                                            n_lines = v26;
                                                            // continue -> 0x804ccff
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x804cca0
                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                            // branch -> 0x804ccc9
                                            // 0x804ccc9
                                            fclose((struct _IO_FILE *)f_gisman);
                                            fclose((struct _IO_FILE *)line_no);
                                            fclose((struct _IO_FILE *)f_in);
                                            n_lines = 0;
                                            if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                free((char *)*(int32_t *)len);
                                                v26 = n_lines + 1;
                                                n_lines = v26;
                                                while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                    // 0x804ccff
                                                    free((char *)*(int32_t *)(len + 4 * v26));
                                                    v26 = n_lines + 1;
                                                    n_lines = v26;
                                                    // continue -> 0x804ccff
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x804ca7e
                                        check_ext_menu((char **)len);
                                        n_lines = 1;
                                        if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                            // 0x804ca9b
                                            // branch -> 0x804ca9b
                                            while (true) {
                                                // 0x804ca9b
                                                if (n_lines == 1) {
                                                    goto lab_0x804caa8_24;
                                                }
                                                goto lab_0x804cb73_24;
                                            }
                                        }
                                        // 0x804cc21
                                        n_lines = 0;
                                        format = len;
                                        if (*(int32_t *)format != 0) {
                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                            v17 = n_lines + 1;
                                            n_lines = v17;
                                            v20 = len;
                                            while (*(int32_t *)(4 * v17 + v20) != 0) {
                                                // 0x804cbf7
                                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                                v17 = n_lines + 1;
                                                n_lines = v17;
                                                v20 = len;
                                                // continue -> 0x804cbf7
                                            }
                                            // 0x804cc36
                                            fflush((struct _IO_FILE *)f_in);
                                            rewind((struct _IO_FILE *)f_in);
                                            n_lines_org = 0;
                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                            v25 = n_lines_org;
                                            // branch -> 0x804cc65
                                            while (str4 != NULL) {
                                                // 0x804cc65
                                                n_lines_org = v25 + 1;
                                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                v25 = n_lines_org;
                                                // continue -> 0x804cc65
                                            }
                                            // 0x804cc89
                                            if (v25 != 0) {
                                                // 0x804cc92
                                                if (v25 >= i) {
                                                    // 0x804ccc9
                                                    fclose((struct _IO_FILE *)f_gisman);
                                                    fclose((struct _IO_FILE *)line_no);
                                                    fclose((struct _IO_FILE *)f_in);
                                                    n_lines = 0;
                                                    if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                        free((char *)*(int32_t *)len);
                                                        v26 = n_lines + 1;
                                                        n_lines = v26;
                                                        while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                            // 0x804ccff
                                                            free((char *)*(int32_t *)(len + 4 * v26));
                                                            v26 = n_lines + 1;
                                                            n_lines = v26;
                                                            // continue -> 0x804ccff
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x804cca0
                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                            // branch -> 0x804ccc9
                                            // 0x804ccc9
                                            fclose((struct _IO_FILE *)f_gisman);
                                            fclose((struct _IO_FILE *)line_no);
                                            fclose((struct _IO_FILE *)f_in);
                                            n_lines = 0;
                                            if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                free((char *)*(int32_t *)len);
                                                v26 = n_lines + 1;
                                                n_lines = v26;
                                                while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                    // 0x804ccff
                                                    free((char *)*(int32_t *)(len + 4 * v26));
                                                    v26 = n_lines + 1;
                                                    n_lines = v26;
                                                    // continue -> 0x804ccff
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x804cc36
                                        fflush((struct _IO_FILE *)f_in);
                                        rewind((struct _IO_FILE *)f_in);
                                        n_lines_org = 0;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // branch -> 0x804cc65
                                        while (str4 != NULL) {
                                            // 0x804cc65
                                            n_lines_org = v25 + 1;
                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                            v25 = n_lines_org;
                                            // continue -> 0x804cc65
                                        }
                                        // 0x804cc89
                                        if (v25 != 0) {
                                            // 0x804cc92
                                            if (v25 >= i) {
                                                // 0x804ccc9
                                                fclose((struct _IO_FILE *)f_gisman);
                                                fclose((struct _IO_FILE *)line_no);
                                                fclose((struct _IO_FILE *)f_in);
                                                n_lines = 0;
                                                if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                    free((char *)*(int32_t *)len);
                                                    v26 = n_lines + 1;
                                                    n_lines = v26;
                                                    while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                        // 0x804ccff
                                                        free((char *)*(int32_t *)(len + 4 * v26));
                                                        v26 = n_lines + 1;
                                                        n_lines = v26;
                                                        // continue -> 0x804ccff
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804cca0
                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                        // branch -> 0x804ccc9
                                        // 0x804ccc9
                                        fclose((struct _IO_FILE *)f_gisman);
                                        fclose((struct _IO_FILE *)line_no);
                                        fclose((struct _IO_FILE *)f_in);
                                        n_lines = 0;
                                        if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                            free((char *)*(int32_t *)len);
                                            v26 = n_lines + 1;
                                            n_lines = v26;
                                            while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                // 0x804ccff
                                                free((char *)*(int32_t *)(len + 4 * v26));
                                                v26 = n_lines + 1;
                                                n_lines = v26;
                                                // continue -> 0x804ccff
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804ca5a
                                n_lines = 0;
                                if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                    v18 = len + 4 * n_lines;
                                    g3 = v18;
                                    len2 = strlen((char *)&str5);
                                    *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                    str6 = *(int32_t *)(len + 4 * n_lines);
                                    strcpy((char *)str6, (char *)&str5);
                                    n_lines++;
                                    while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                        // 0x804ca04
                                        v18 = len + 4 * n_lines;
                                        g3 = v18;
                                        len2 = strlen((char *)&str5);
                                        *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                        str6 = *(int32_t *)(len + 4 * n_lines);
                                        strcpy((char *)str6, (char *)&str5);
                                        n_lines++;
                                        // continue -> 0x804ca04
                                    }
                                    // 0x804ca7e
                                    check_ext_menu((char **)len);
                                    n_lines = 1;
                                    if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                        // 0x804ca9b
                                        // branch -> 0x804ca9b
                                        while (true) {
                                            // 0x804ca9b
                                            if (n_lines == 1) {
                                                goto lab_0x804caa8_24;
                                            }
                                            goto lab_0x804cb73_24;
                                        }
                                    }
                                    // 0x804cc21
                                    n_lines = 0;
                                    format = len;
                                    if (*(int32_t *)format != 0) {
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        while (*(int32_t *)(4 * v17 + v20) != 0) {
                                            // 0x804cbf7
                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                            v17 = n_lines + 1;
                                            n_lines = v17;
                                            v20 = len;
                                            // continue -> 0x804cbf7
                                        }
                                        // 0x804cc36
                                        fflush((struct _IO_FILE *)f_in);
                                        rewind((struct _IO_FILE *)f_in);
                                        n_lines_org = 0;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // branch -> 0x804cc65
                                        while (str4 != NULL) {
                                            // 0x804cc65
                                            n_lines_org = v25 + 1;
                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                            v25 = n_lines_org;
                                            // continue -> 0x804cc65
                                        }
                                        // 0x804cc89
                                        if (v25 != 0) {
                                            // 0x804cc92
                                            if (v25 >= i) {
                                                // 0x804ccc9
                                                fclose((struct _IO_FILE *)f_gisman);
                                                fclose((struct _IO_FILE *)line_no);
                                                fclose((struct _IO_FILE *)f_in);
                                                n_lines = 0;
                                                if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                    free((char *)*(int32_t *)len);
                                                    v26 = n_lines + 1;
                                                    n_lines = v26;
                                                    while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                        // 0x804ccff
                                                        free((char *)*(int32_t *)(len + 4 * v26));
                                                        v26 = n_lines + 1;
                                                        n_lines = v26;
                                                        // continue -> 0x804ccff
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804cca0
                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                        // branch -> 0x804ccc9
                                        // 0x804ccc9
                                        fclose((struct _IO_FILE *)f_gisman);
                                        fclose((struct _IO_FILE *)line_no);
                                        fclose((struct _IO_FILE *)f_in);
                                        n_lines = 0;
                                        if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                            free((char *)*(int32_t *)len);
                                            v26 = n_lines + 1;
                                            n_lines = v26;
                                            while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                // 0x804ccff
                                                free((char *)*(int32_t *)(len + 4 * v26));
                                                v26 = n_lines + 1;
                                                n_lines = v26;
                                                // continue -> 0x804ccff
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804cc36
                                    fflush((struct _IO_FILE *)f_in);
                                    rewind((struct _IO_FILE *)f_in);
                                    n_lines_org = 0;
                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                    v25 = n_lines_org;
                                    // branch -> 0x804cc65
                                    while (str4 != NULL) {
                                        // 0x804cc65
                                        n_lines_org = v25 + 1;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // continue -> 0x804cc65
                                    }
                                    // 0x804cc89
                                    if (v25 != 0) {
                                        // 0x804cc92
                                        if (v25 >= i) {
                                            // 0x804ccc9
                                            fclose((struct _IO_FILE *)f_gisman);
                                            fclose((struct _IO_FILE *)line_no);
                                            fclose((struct _IO_FILE *)f_in);
                                            n_lines = 0;
                                            if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                free((char *)*(int32_t *)len);
                                                v26 = n_lines + 1;
                                                n_lines = v26;
                                                while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                    // 0x804ccff
                                                    free((char *)*(int32_t *)(len + 4 * v26));
                                                    v26 = n_lines + 1;
                                                    n_lines = v26;
                                                    // continue -> 0x804ccff
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804cca0
                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                    // branch -> 0x804ccc9
                                    // 0x804ccc9
                                    fclose((struct _IO_FILE *)f_gisman);
                                    fclose((struct _IO_FILE *)line_no);
                                    fclose((struct _IO_FILE *)f_in);
                                    n_lines = 0;
                                    if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                        free((char *)*(int32_t *)len);
                                        v26 = n_lines + 1;
                                        n_lines = v26;
                                        while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                            // 0x804ccff
                                            free((char *)*(int32_t *)(len + 4 * v26));
                                            v26 = n_lines + 1;
                                            n_lines = v26;
                                            // continue -> 0x804ccff
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x804ca7e
                                check_ext_menu((char **)len);
                                n_lines = 1;
                                if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                    // 0x804ca9b
                                    // branch -> 0x804ca9b
                                    while (true) {
                                        // 0x804ca9b
                                        if (n_lines == 1) {
                                            goto lab_0x804caa8_24;
                                        }
                                        goto lab_0x804cb73_24;
                                    }
                                }
                                // 0x804cc21
                                n_lines = 0;
                                format = len;
                                if (*(int32_t *)format != 0) {
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    while (*(int32_t *)(4 * v17 + v20) != 0) {
                                        // 0x804cbf7
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        // continue -> 0x804cbf7
                                    }
                                    // 0x804cc36
                                    fflush((struct _IO_FILE *)f_in);
                                    rewind((struct _IO_FILE *)f_in);
                                    n_lines_org = 0;
                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                    v25 = n_lines_org;
                                    // branch -> 0x804cc65
                                    while (str4 != NULL) {
                                        // 0x804cc65
                                        n_lines_org = v25 + 1;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // continue -> 0x804cc65
                                    }
                                    // 0x804cc89
                                    if (v25 != 0) {
                                        // 0x804cc92
                                        if (v25 >= i) {
                                            // 0x804ccc9
                                            fclose((struct _IO_FILE *)f_gisman);
                                            fclose((struct _IO_FILE *)line_no);
                                            fclose((struct _IO_FILE *)f_in);
                                            n_lines = 0;
                                            if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                                free((char *)*(int32_t *)len);
                                                v26 = n_lines + 1;
                                                n_lines = v26;
                                                while (n_entries + 6 + 2 * (int32_t)line > v26) {
                                                    // 0x804ccff
                                                    free((char *)*(int32_t *)(len + 4 * v26));
                                                    v26 = n_lines + 1;
                                                    n_lines = v26;
                                                    // continue -> 0x804ccff
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804cca0
                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                    // branch -> 0x804ccc9
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x804cc36
                                fflush((struct _IO_FILE *)f_in);
                                rewind((struct _IO_FILE *)f_in);
                                n_lines_org = 0;
                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                v25 = n_lines_org;
                                // branch -> 0x804cc65
                                while (str4 != NULL) {
                                    // 0x804cc65
                                    n_lines_org = v25 + 1;
                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                    v25 = n_lines_org;
                                    // continue -> 0x804cc65
                                }
                                // 0x804cc89
                                if (v25 != 0) {
                                    // 0x804cc92
                                    if (v25 >= i) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804cca0
                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                // branch -> 0x804ccc9
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804c917
                    if (v23 != NULL) {
                        // 0x804c924
                        rewind((struct _IO_FILE *)line_no);
                        n_entries = 0;
                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                        v24 = n_entries;
                        // branch -> 0x804c945
                        while (str3 != NULL) {
                            // 0x804c945
                            n_entries = v24 + 1;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                            v24 = n_entries;
                            // continue -> 0x804c945
                        }
                        // 0x804c969
                        if (v24 != 0) {
                            // 0x804c976
                            i = v24;
                            rewind((struct _IO_FILE *)f_gisman);
                            mem = calloc(n_entries + 6 + 2 * (int32_t)line, 4);
                            len = (int32_t)mem;
                            n_lines = 0;
                            if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                // 0x804c9c3
                                *(int32_t *)mem = 0;
                                v16 = n_lines + 1;
                                n_lines = v16;
                                if (n_entries + 6 + 2 * (int32_t)line > v16) {
                                    *(int32_t *)(4 * v16 + len) = 0;
                                    v15 = n_lines + 1;
                                    n_lines = v15;
                                    while (n_entries + 6 + 2 * (int32_t)line > v15) {
                                        // 0x804c9c3
                                        *(int32_t *)(4 * v15 + len) = 0;
                                        v15 = n_lines + 1;
                                        n_lines = v15;
                                        // continue -> 0x804c9c3
                                    }
                                    // 0x804ca5a
                                    n_lines = 0;
                                    if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                        v18 = len + 4 * n_lines;
                                        g3 = v18;
                                        len2 = strlen((char *)&str5);
                                        *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                        str6 = *(int32_t *)(len + 4 * n_lines);
                                        strcpy((char *)str6, (char *)&str5);
                                        n_lines++;
                                        while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                            // 0x804ca04
                                            v18 = len + 4 * n_lines;
                                            g3 = v18;
                                            len2 = strlen((char *)&str5);
                                            *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                            str6 = *(int32_t *)(len + 4 * n_lines);
                                            strcpy((char *)str6, (char *)&str5);
                                            n_lines++;
                                            // continue -> 0x804ca04
                                        }
                                        // 0x804ca7e
                                        check_ext_menu((char **)len);
                                        n_lines = 1;
                                        if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                            // 0x804ca9b
                                            // branch -> 0x804ca9b
                                            while (true) {
                                                // 0x804ca9b
                                                if (n_lines == 1) {
                                                    goto lab_0x804caa8_24;
                                                }
                                                goto lab_0x804cb73_24;
                                            }
                                        }
                                        // 0x804cc21
                                        n_lines = 0;
                                        format = len;
                                        if (*(int32_t *)format != 0) {
                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                            v17 = n_lines + 1;
                                            n_lines = v17;
                                            v20 = len;
                                            while (*(int32_t *)(4 * v17 + v20) != 0) {
                                                // 0x804cbf7
                                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                                v17 = n_lines + 1;
                                                n_lines = v17;
                                                v20 = len;
                                                // continue -> 0x804cbf7
                                            }
                                            // 0x804cc36
                                            fflush((struct _IO_FILE *)f_in);
                                            rewind((struct _IO_FILE *)f_in);
                                            n_lines_org = 0;
                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                            v25 = n_lines_org;
                                            // branch -> 0x804cc65
                                            while (str4 != NULL) {
                                                // 0x804cc65
                                                n_lines_org = v25 + 1;
                                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                v25 = n_lines_org;
                                                // continue -> 0x804cc65
                                            }
                                            // 0x804cc89
                                            if (v25 != 0) {
                                                // 0x804cc92
                                                if (v25 >= i) {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x804cca0
                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                            // branch -> 0x804ccc9
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x804cc36
                                        fflush((struct _IO_FILE *)f_in);
                                        rewind((struct _IO_FILE *)f_in);
                                        n_lines_org = 0;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // branch -> 0x804cc65
                                        while (str4 != NULL) {
                                            // 0x804cc65
                                            n_lines_org = v25 + 1;
                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                            v25 = n_lines_org;
                                            // continue -> 0x804cc65
                                        }
                                        // 0x804cc89
                                        if (v25 != 0) {
                                            // 0x804cc92
                                            if (v25 >= i) {
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804cca0
                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                        // branch -> 0x804ccc9
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804ca7e
                                    check_ext_menu((char **)len);
                                    n_lines = 1;
                                    if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                        // 0x804ca9b
                                        // branch -> 0x804ca9b
                                        while (true) {
                                            // 0x804ca9b
                                            if (n_lines == 1) {
                                                goto lab_0x804caa8_24;
                                            }
                                            goto lab_0x804cb73_24;
                                        }
                                    }
                                    // 0x804cc21
                                    n_lines = 0;
                                    format = len;
                                    if (*(int32_t *)format != 0) {
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        while (*(int32_t *)(4 * v17 + v20) != 0) {
                                            // 0x804cbf7
                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                            v17 = n_lines + 1;
                                            n_lines = v17;
                                            v20 = len;
                                            // continue -> 0x804cbf7
                                        }
                                        // 0x804cc36
                                        fflush((struct _IO_FILE *)f_in);
                                        rewind((struct _IO_FILE *)f_in);
                                        n_lines_org = 0;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // branch -> 0x804cc65
                                        while (str4 != NULL) {
                                            // 0x804cc65
                                            n_lines_org = v25 + 1;
                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                            v25 = n_lines_org;
                                            // continue -> 0x804cc65
                                        }
                                        // 0x804cc89
                                        if (v25 != 0) {
                                            // 0x804cc92
                                            if (v25 >= i) {
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804cca0
                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                        // branch -> 0x804ccc9
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804cc36
                                    fflush((struct _IO_FILE *)f_in);
                                    rewind((struct _IO_FILE *)f_in);
                                    n_lines_org = 0;
                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                    v25 = n_lines_org;
                                    // branch -> 0x804cc65
                                    while (str4 != NULL) {
                                        // 0x804cc65
                                        n_lines_org = v25 + 1;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // continue -> 0x804cc65
                                    }
                                    // 0x804cc89
                                    if (v25 != 0) {
                                        // 0x804cc92
                                        if (v25 >= i) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804cca0
                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                    // branch -> 0x804ccc9
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804ca5a
                            n_lines = 0;
                            if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                v18 = len + 4 * n_lines;
                                g3 = v18;
                                len2 = strlen((char *)&str5);
                                *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                str6 = *(int32_t *)(len + 4 * n_lines);
                                strcpy((char *)str6, (char *)&str5);
                                n_lines++;
                                while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                    // 0x804ca04
                                    v18 = len + 4 * n_lines;
                                    g3 = v18;
                                    len2 = strlen((char *)&str5);
                                    *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                    str6 = *(int32_t *)(len + 4 * n_lines);
                                    strcpy((char *)str6, (char *)&str5);
                                    n_lines++;
                                    // continue -> 0x804ca04
                                }
                                // 0x804ca7e
                                check_ext_menu((char **)len);
                                n_lines = 1;
                                if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                    // 0x804ca9b
                                    // branch -> 0x804ca9b
                                    while (true) {
                                        // 0x804ca9b
                                        if (n_lines == 1) {
                                            goto lab_0x804caa8_24;
                                        }
                                        goto lab_0x804cb73_24;
                                    }
                                }
                                // 0x804cc21
                                n_lines = 0;
                                format = len;
                                if (*(int32_t *)format != 0) {
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    while (*(int32_t *)(4 * v17 + v20) != 0) {
                                        // 0x804cbf7
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        // continue -> 0x804cbf7
                                    }
                                    // 0x804cc36
                                    fflush((struct _IO_FILE *)f_in);
                                    rewind((struct _IO_FILE *)f_in);
                                    n_lines_org = 0;
                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                    v25 = n_lines_org;
                                    // branch -> 0x804cc65
                                    while (str4 != NULL) {
                                        // 0x804cc65
                                        n_lines_org = v25 + 1;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // continue -> 0x804cc65
                                    }
                                    // 0x804cc89
                                    if (v25 != 0) {
                                        // 0x804cc92
                                        if (v25 >= i) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804cca0
                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                    // branch -> 0x804ccc9
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x804cc36
                                fflush((struct _IO_FILE *)f_in);
                                rewind((struct _IO_FILE *)f_in);
                                n_lines_org = 0;
                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                v25 = n_lines_org;
                                // branch -> 0x804cc65
                                while (str4 != NULL) {
                                    // 0x804cc65
                                    n_lines_org = v25 + 1;
                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                    v25 = n_lines_org;
                                    // continue -> 0x804cc65
                                }
                                // 0x804cc89
                                if (v25 != 0) {
                                    // 0x804cc92
                                    if (v25 >= i) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804cca0
                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                // branch -> 0x804ccc9
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804ca7e
                            check_ext_menu((char **)len);
                            n_lines = 1;
                            if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                // 0x804ca9b
                                // branch -> 0x804ca9b
                                while (true) {
                                    // 0x804ca9b
                                    if (n_lines == 1) {
                                        goto lab_0x804caa8_24;
                                    }
                                    goto lab_0x804cb73_24;
                                }
                            }
                            // 0x804cc21
                            n_lines = 0;
                            format = len;
                            if (*(int32_t *)format != 0) {
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                v17 = n_lines + 1;
                                n_lines = v17;
                                v20 = len;
                                while (*(int32_t *)(4 * v17 + v20) != 0) {
                                    // 0x804cbf7
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    // continue -> 0x804cbf7
                                }
                                // 0x804cc36
                                fflush((struct _IO_FILE *)f_in);
                                rewind((struct _IO_FILE *)f_in);
                                n_lines_org = 0;
                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                v25 = n_lines_org;
                                // branch -> 0x804cc65
                                while (str4 != NULL) {
                                    // 0x804cc65
                                    n_lines_org = v25 + 1;
                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                    v25 = n_lines_org;
                                    // continue -> 0x804cc65
                                }
                                // 0x804cc89
                                if (v25 != 0) {
                                    // 0x804cc92
                                    if (v25 >= i) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804cca0
                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                // branch -> 0x804ccc9
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804cc36
                            fflush((struct _IO_FILE *)f_in);
                            rewind((struct _IO_FILE *)f_in);
                            n_lines_org = 0;
                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                            v25 = n_lines_org;
                            // branch -> 0x804cc65
                            while (str4 != NULL) {
                                // 0x804cc65
                                n_lines_org = v25 + 1;
                                str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                v25 = n_lines_org;
                                // continue -> 0x804cc65
                            }
                            // 0x804cc89
                            if (v25 != 0) {
                                // 0x804cc92
                                if (v25 >= i) {
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804cca0
                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                            // branch -> 0x804ccc9
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804c741
            memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMP_GISMAN);
            file3 = fopen(TMP_GISMAN, "w+");
            f_in = (struct _IO_FILE_4 *)file3;
            if (file3 == NULL) {
                // 0x804c78f
                err_num3 = *__errno_location();
                strerror(err_num3);
                print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804c7be
            }
            // 0x804c7be
            atexit((void (**)())exit_db);
            v19 = f_out;
            if (VERBOSE == 0) {
                // 0x804c83d
                sprintf((char *)&str5, "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, TMP_NULL, gisbase, v19, TMP_NULL, gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
                // branch -> 0x804c8ca
            } else {
                // 0x804c7d3
                sprintf((char *)&str5, "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, v19, gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
                // branch -> 0x804c8ca
            }
            // 0x804c8ca
            strcpy(GISMAN_CMD, (char *)&str5);
            line = NULL;
            str = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
            v22 = line;
            v23 = v22;
            if (str != NULL) {
                line = (char **)((int32_t)v22 + 1);
                str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
                v21 = line;
                v23 = v21;
                while (str2 != NULL) {
                    // 0x804c8ec
                    line = (char **)((int32_t)v21 + 1);
                    str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
                    v21 = line;
                    v23 = v21;
                    // continue -> 0x804c8ec
                }
                // 0x804c917
                if (v23 != NULL) {
                    // 0x804c924
                    rewind((struct _IO_FILE *)line_no);
                    n_entries = 0;
                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                    v24 = n_entries;
                    // branch -> 0x804c945
                    while (str3 != NULL) {
                        // 0x804c945
                        n_entries = v24 + 1;
                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                        v24 = n_entries;
                        // continue -> 0x804c945
                    }
                    // 0x804c969
                    if (v24 != 0) {
                        // 0x804c976
                        i = v24;
                        rewind((struct _IO_FILE *)f_gisman);
                        mem = calloc(n_entries + 6 + 2 * (int32_t)line, 4);
                        len = (int32_t)mem;
                        n_lines = 0;
                        if (n_entries + 6 + 2 * (int32_t)line > 0) {
                            // 0x804c9c3
                            *(int32_t *)mem = 0;
                            v16 = n_lines + 1;
                            n_lines = v16;
                            if (n_entries + 6 + 2 * (int32_t)line > v16) {
                                *(int32_t *)(4 * v16 + len) = 0;
                                v15 = n_lines + 1;
                                n_lines = v15;
                                while (n_entries + 6 + 2 * (int32_t)line > v15) {
                                    // 0x804c9c3
                                    *(int32_t *)(4 * v15 + len) = 0;
                                    v15 = n_lines + 1;
                                    n_lines = v15;
                                    // continue -> 0x804c9c3
                                }
                                // 0x804ca5a
                                n_lines = 0;
                                if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                    v18 = len + 4 * n_lines;
                                    g3 = v18;
                                    len2 = strlen((char *)&str5);
                                    *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                    str6 = *(int32_t *)(len + 4 * n_lines);
                                    strcpy((char *)str6, (char *)&str5);
                                    n_lines++;
                                    while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                        // 0x804ca04
                                        v18 = len + 4 * n_lines;
                                        g3 = v18;
                                        len2 = strlen((char *)&str5);
                                        *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                        str6 = *(int32_t *)(len + 4 * n_lines);
                                        strcpy((char *)str6, (char *)&str5);
                                        n_lines++;
                                        // continue -> 0x804ca04
                                    }
                                    // 0x804ca7e
                                    check_ext_menu((char **)len);
                                    n_lines = 1;
                                    if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                        // 0x804ca9b
                                        // branch -> 0x804ca9b
                                        while (true) {
                                            // 0x804ca9b
                                            if (n_lines == 1) {
                                                goto lab_0x804caa8_24;
                                            }
                                            goto lab_0x804cb73_24;
                                        }
                                    }
                                    // 0x804cc21
                                    n_lines = 0;
                                    format = len;
                                    if (*(int32_t *)format != 0) {
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        while (*(int32_t *)(4 * v17 + v20) != 0) {
                                            // 0x804cbf7
                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                            v17 = n_lines + 1;
                                            n_lines = v17;
                                            v20 = len;
                                            // continue -> 0x804cbf7
                                        }
                                        // 0x804cc36
                                        fflush((struct _IO_FILE *)f_in);
                                        rewind((struct _IO_FILE *)f_in);
                                        n_lines_org = 0;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // branch -> 0x804cc65
                                        while (str4 != NULL) {
                                            // 0x804cc65
                                            n_lines_org = v25 + 1;
                                            str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                            v25 = n_lines_org;
                                            // continue -> 0x804cc65
                                        }
                                        // 0x804cc89
                                        if (v25 != 0) {
                                            // 0x804cc92
                                            if (v25 >= i) {
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804cca0
                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                        // branch -> 0x804ccc9
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804cc36
                                    fflush((struct _IO_FILE *)f_in);
                                    rewind((struct _IO_FILE *)f_in);
                                    n_lines_org = 0;
                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                    v25 = n_lines_org;
                                    // branch -> 0x804cc65
                                    while (str4 != NULL) {
                                        // 0x804cc65
                                        n_lines_org = v25 + 1;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // continue -> 0x804cc65
                                    }
                                    // 0x804cc89
                                    if (v25 != 0) {
                                        // 0x804cc92
                                        if (v25 >= i) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804cca0
                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                    // branch -> 0x804ccc9
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x804ca7e
                                check_ext_menu((char **)len);
                                n_lines = 1;
                                if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                    // 0x804ca9b
                                    // branch -> 0x804ca9b
                                    while (true) {
                                        // 0x804ca9b
                                        if (n_lines == 1) {
                                            goto lab_0x804caa8_24;
                                        }
                                        goto lab_0x804cb73_24;
                                    }
                                }
                                // 0x804cc21
                                n_lines = 0;
                                format = len;
                                if (*(int32_t *)format != 0) {
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    while (*(int32_t *)(4 * v17 + v20) != 0) {
                                        // 0x804cbf7
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        // continue -> 0x804cbf7
                                    }
                                    // 0x804cc36
                                    fflush((struct _IO_FILE *)f_in);
                                    rewind((struct _IO_FILE *)f_in);
                                    n_lines_org = 0;
                                    str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                    v25 = n_lines_org;
                                    // branch -> 0x804cc65
                                    while (str4 != NULL) {
                                        // 0x804cc65
                                        n_lines_org = v25 + 1;
                                        str4 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                        v25 = n_lines_org;
                                        // continue -> 0x804cc65
                                    }
                                    // 0x804cc89
                                    if (v25 != 0) {
                                        // 0x804cc92
                                        if (v25 >= i) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804cca0
                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                    // branch -> 0x804ccc9
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804ca5a
                        n_lines = 0;
                        if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                            v18 = len + 4 * n_lines;
                            g3 = v18;
                            len2 = strlen((char *)&str5);
                            *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                            str6 = *(int32_t *)(len + 4 * n_lines);
                            strcpy((char *)str6, (char *)&str5);
                            n_lines++;
                            while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                // 0x804ca04
                                v18 = len + 4 * n_lines;
                                g3 = v18;
                                len2 = strlen((char *)&str5);
                                *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                str6 = *(int32_t *)(len + 4 * n_lines);
                                strcpy((char *)str6, (char *)&str5);
                                n_lines++;
                                // continue -> 0x804ca04
                            }
                            // 0x804ca7e
                            check_ext_menu((char **)len);
                            n_lines = 1;
                            if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                // 0x804ca9b
                                // branch -> 0x804ca9b
                                while (true) {
                                    // 0x804ca9b
                                    if (n_lines == 1) {
                                        goto lab_0x804caa8_24;
                                    }
                                    goto lab_0x804cb73_24;
                                }
                            }
                            // 0x804cc21
                            n_lines = 0;
                            format = len;
                            if (*(int32_t *)format != 0) {
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                v17 = n_lines + 1;
                                n_lines = v17;
                                v20 = len;
                                while (*(int32_t *)(4 * v17 + v20) != 0) {
                                    // 0x804cbf7
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    // continue -> 0x804cbf7
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804ca7e
                        check_ext_menu((char **)len);
                        n_lines = 1;
                        if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                            // 0x804ca9b
                            // branch -> 0x804ca9b
                            while (true) {
                                // 0x804ca9b
                                if (n_lines == 1) {
                                    goto lab_0x804caa8_24;
                                }
                                goto lab_0x804cb73_24;
                            }
                        }
                        // 0x804cc21
                        n_lines = 0;
                        format = len;
                        if (*(int32_t *)format != 0) {
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                            v17 = n_lines + 1;
                            n_lines = v17;
                            v20 = len;
                            while (*(int32_t *)(4 * v17 + v20) != 0) {
                                // 0x804cbf7
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                v17 = n_lines + 1;
                                n_lines = v17;
                                v20 = len;
                                // continue -> 0x804cbf7
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804c917
            if (v23 != NULL) {
                // 0x804c924
                rewind((struct _IO_FILE *)line_no);
                n_entries = 0;
                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                v24 = n_entries;
                // branch -> 0x804c945
                while (str3 != NULL) {
                    // 0x804c945
                    n_entries = v24 + 1;
                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                    v24 = n_entries;
                    // continue -> 0x804c945
                }
                // 0x804c969
                if (v24 != 0) {
                    // 0x804c976
                    i = v24;
                    rewind((struct _IO_FILE *)f_gisman);
                    mem = calloc(n_entries + 6 + 2 * (int32_t)line, 4);
                    len = (int32_t)mem;
                    n_lines = 0;
                    if (n_entries + 6 + 2 * (int32_t)line > 0) {
                        // 0x804c9c3
                        *(int32_t *)mem = 0;
                        v16 = n_lines + 1;
                        n_lines = v16;
                        if (n_entries + 6 + 2 * (int32_t)line > v16) {
                            *(int32_t *)(4 * v16 + len) = 0;
                            v15 = n_lines + 1;
                            n_lines = v15;
                            while (n_entries + 6 + 2 * (int32_t)line > v15) {
                                // 0x804c9c3
                                *(int32_t *)(4 * v15 + len) = 0;
                                v15 = n_lines + 1;
                                n_lines = v15;
                                // continue -> 0x804c9c3
                            }
                            // 0x804ca5a
                            n_lines = 0;
                            if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                v18 = len + 4 * n_lines;
                                g3 = v18;
                                len2 = strlen((char *)&str5);
                                *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                str6 = *(int32_t *)(len + 4 * n_lines);
                                strcpy((char *)str6, (char *)&str5);
                                n_lines++;
                                while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                    // 0x804ca04
                                    v18 = len + 4 * n_lines;
                                    g3 = v18;
                                    len2 = strlen((char *)&str5);
                                    *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                    str6 = *(int32_t *)(len + 4 * n_lines);
                                    strcpy((char *)str6, (char *)&str5);
                                    n_lines++;
                                    // continue -> 0x804ca04
                                }
                                // 0x804ca7e
                                check_ext_menu((char **)len);
                                n_lines = 1;
                                if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                    // 0x804ca9b
                                    // branch -> 0x804ca9b
                                    while (true) {
                                        // 0x804ca9b
                                        if (n_lines == 1) {
                                            goto lab_0x804caa8_24;
                                        }
                                        goto lab_0x804cb73_24;
                                    }
                                }
                                // 0x804cc21
                                n_lines = 0;
                                format = len;
                                if (*(int32_t *)format != 0) {
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    while (*(int32_t *)(4 * v17 + v20) != 0) {
                                        // 0x804cbf7
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        // continue -> 0x804cbf7
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804ca7e
                            check_ext_menu((char **)len);
                            n_lines = 1;
                            if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                // 0x804ca9b
                                // branch -> 0x804ca9b
                                while (true) {
                                    // 0x804ca9b
                                    if (n_lines == 1) {
                                        goto lab_0x804caa8_24;
                                    }
                                    goto lab_0x804cb73_24;
                                }
                            }
                            // 0x804cc21
                            n_lines = 0;
                            format = len;
                            if (*(int32_t *)format != 0) {
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                v17 = n_lines + 1;
                                n_lines = v17;
                                v20 = len;
                                while (*(int32_t *)(4 * v17 + v20) != 0) {
                                    // 0x804cbf7
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    // continue -> 0x804cbf7
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804ca5a
                    n_lines = 0;
                    if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                        v18 = len + 4 * n_lines;
                        g3 = v18;
                        len2 = strlen((char *)&str5);
                        *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                        str6 = *(int32_t *)(len + 4 * n_lines);
                        strcpy((char *)str6, (char *)&str5);
                        n_lines++;
                        while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                            // 0x804ca04
                            v18 = len + 4 * n_lines;
                            g3 = v18;
                            len2 = strlen((char *)&str5);
                            *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                            str6 = *(int32_t *)(len + 4 * n_lines);
                            strcpy((char *)str6, (char *)&str5);
                            n_lines++;
                            // continue -> 0x804ca04
                        }
                        // 0x804ca7e
                        check_ext_menu((char **)len);
                        n_lines = 1;
                        if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                            // 0x804ca9b
                            // branch -> 0x804ca9b
                            while (true) {
                                // 0x804ca9b
                                if (n_lines == 1) {
                                    goto lab_0x804caa8_24;
                                }
                                goto lab_0x804cb73_24;
                            }
                        }
                        // 0x804cc21
                        n_lines = 0;
                        format = len;
                        if (*(int32_t *)format != 0) {
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                            v17 = n_lines + 1;
                            n_lines = v17;
                            v20 = len;
                            while (*(int32_t *)(4 * v17 + v20) != 0) {
                                // 0x804cbf7
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                v17 = n_lines + 1;
                                n_lines = v17;
                                v20 = len;
                                // continue -> 0x804cbf7
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804ca7e
                    check_ext_menu((char **)len);
                    n_lines = 1;
                    if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                        // 0x804ca9b
                        // branch -> 0x804ca9b
                        while (true) {
                            // 0x804ca9b
                            if (n_lines == 1) {
                                goto lab_0x804caa8_24;
                            }
                            goto lab_0x804cb73_24;
                        }
                    }
                    // 0x804cc21
                    n_lines = 0;
                    format = len;
                    if (*(int32_t *)format != 0) {
                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                        v17 = n_lines + 1;
                        n_lines = v17;
                        v20 = len;
                        while (*(int32_t *)(4 * v17 + v20) != 0) {
                            // 0x804cbf7
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                            v17 = n_lines + 1;
                            n_lines = v17;
                            v20 = len;
                            // continue -> 0x804cbf7
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    } else {
        // 0x804c6ab
        sprintf((char *)&file_path, "%s/etc/dm/menu.tcl", gisbase);
        file2 = fopen((char *)&file_path, "r");
        f_gisman = (struct _IO_FILE_4 *)file2;
        if (file2 == NULL) {
            // 0x804c6f2
            if (*__errno_location() != 2) {
                // 0x804c702
                fclose((struct _IO_FILE *)f_gisman);
                err_num2 = *__errno_location();
                strerror(err_num2);
                print_error(-21, "checking for file '%s': %s\n");
                // branch -> 0x804c741
                // 0x804c741
                memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
                mkstemp(TMP_GISMAN);
                file3 = fopen(TMP_GISMAN, "w+");
                f_in = (struct _IO_FILE_4 *)file3;
                if (file3 == NULL) {
                    // 0x804c78f
                    err_num3 = *__errno_location();
                    strerror(err_num3);
                    print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                    // branch -> 0x804c7be
                }
                // 0x804c7be
                atexit((void (**)())exit_db);
                v19 = f_out;
                if (VERBOSE == 0) {
                    // 0x804c83d
                    sprintf((char *)&str5, "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, TMP_NULL, gisbase, v19, TMP_NULL, gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
                    // branch -> 0x804c8ca
                } else {
                    // 0x804c7d3
                    sprintf((char *)&str5, "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, v19, gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
                    // branch -> 0x804c8ca
                }
                // 0x804c8ca
                strcpy(GISMAN_CMD, (char *)&str5);
                line = NULL;
                str = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
                v22 = line;
                v23 = v22;
                if (str != NULL) {
                    line = (char **)((int32_t)v22 + 1);
                    str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
                    v21 = line;
                    v23 = v21;
                    while (str2 != NULL) {
                        // 0x804c8ec
                        line = (char **)((int32_t)v21 + 1);
                        str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
                        v21 = line;
                        v23 = v21;
                        // continue -> 0x804c8ec
                    }
                    // 0x804c917
                    if (v23 != NULL) {
                        // 0x804c924
                        rewind((struct _IO_FILE *)line_no);
                        n_entries = 0;
                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                        v24 = n_entries;
                        // branch -> 0x804c945
                        while (str3 != NULL) {
                            // 0x804c945
                            n_entries = v24 + 1;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                            v24 = n_entries;
                            // continue -> 0x804c945
                        }
                        // 0x804c969
                        if (v24 != 0) {
                            // 0x804c976
                            i = v24;
                            rewind((struct _IO_FILE *)f_gisman);
                            mem = calloc(n_entries + 6 + 2 * (int32_t)line, 4);
                            len = (int32_t)mem;
                            n_lines = 0;
                            if (n_entries + 6 + 2 * (int32_t)line > 0) {
                                // 0x804c9c3
                                *(int32_t *)mem = 0;
                                v16 = n_lines + 1;
                                n_lines = v16;
                                if (n_entries + 6 + 2 * (int32_t)line > v16) {
                                    *(int32_t *)(4 * v16 + len) = 0;
                                    v15 = n_lines + 1;
                                    n_lines = v15;
                                    while (n_entries + 6 + 2 * (int32_t)line > v15) {
                                        // 0x804c9c3
                                        *(int32_t *)(4 * v15 + len) = 0;
                                        v15 = n_lines + 1;
                                        n_lines = v15;
                                        // continue -> 0x804c9c3
                                    }
                                    // 0x804ca5a
                                    n_lines = 0;
                                    if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                        v18 = len + 4 * n_lines;
                                        g3 = v18;
                                        len2 = strlen((char *)&str5);
                                        *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                        str6 = *(int32_t *)(len + 4 * n_lines);
                                        strcpy((char *)str6, (char *)&str5);
                                        n_lines++;
                                        while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                            // 0x804ca04
                                            v18 = len + 4 * n_lines;
                                            g3 = v18;
                                            len2 = strlen((char *)&str5);
                                            *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                            str6 = *(int32_t *)(len + 4 * n_lines);
                                            strcpy((char *)str6, (char *)&str5);
                                            n_lines++;
                                            // continue -> 0x804ca04
                                        }
                                        // 0x804ca7e
                                        check_ext_menu((char **)len);
                                        n_lines = 1;
                                        if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                            // 0x804ca9b
                                            // branch -> 0x804ca9b
                                            while (true) {
                                                // 0x804ca9b
                                                if (n_lines == 1) {
                                                    goto lab_0x804caa8_24;
                                                }
                                                goto lab_0x804cb73_24;
                                            }
                                        }
                                        // 0x804cc21
                                        n_lines = 0;
                                        format = len;
                                        if (*(int32_t *)format != 0) {
                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                            v17 = n_lines + 1;
                                            n_lines = v17;
                                            v20 = len;
                                            while (*(int32_t *)(4 * v17 + v20) != 0) {
                                                // 0x804cbf7
                                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                                v17 = n_lines + 1;
                                                n_lines = v17;
                                                v20 = len;
                                                // continue -> 0x804cbf7
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804ca7e
                                    check_ext_menu((char **)len);
                                    n_lines = 1;
                                    if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                        // 0x804ca9b
                                        // branch -> 0x804ca9b
                                        while (true) {
                                            // 0x804ca9b
                                            if (n_lines == 1) {
                                                goto lab_0x804caa8_24;
                                            }
                                            goto lab_0x804cb73_24;
                                        }
                                    }
                                    // 0x804cc21
                                    n_lines = 0;
                                    format = len;
                                    if (*(int32_t *)format != 0) {
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        while (*(int32_t *)(4 * v17 + v20) != 0) {
                                            // 0x804cbf7
                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                            v17 = n_lines + 1;
                                            n_lines = v17;
                                            v20 = len;
                                            // continue -> 0x804cbf7
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804ca5a
                            n_lines = 0;
                            if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                v18 = len + 4 * n_lines;
                                g3 = v18;
                                len2 = strlen((char *)&str5);
                                *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                str6 = *(int32_t *)(len + 4 * n_lines);
                                strcpy((char *)str6, (char *)&str5);
                                n_lines++;
                                while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                    // 0x804ca04
                                    v18 = len + 4 * n_lines;
                                    g3 = v18;
                                    len2 = strlen((char *)&str5);
                                    *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                    str6 = *(int32_t *)(len + 4 * n_lines);
                                    strcpy((char *)str6, (char *)&str5);
                                    n_lines++;
                                    // continue -> 0x804ca04
                                }
                                // 0x804ca7e
                                check_ext_menu((char **)len);
                                n_lines = 1;
                                if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                    // 0x804ca9b
                                    // branch -> 0x804ca9b
                                    while (true) {
                                        // 0x804ca9b
                                        if (n_lines == 1) {
                                            goto lab_0x804caa8_24;
                                        }
                                        goto lab_0x804cb73_24;
                                    }
                                }
                                // 0x804cc21
                                n_lines = 0;
                                format = len;
                                if (*(int32_t *)format != 0) {
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    while (*(int32_t *)(4 * v17 + v20) != 0) {
                                        // 0x804cbf7
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        // continue -> 0x804cbf7
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804ca7e
                            check_ext_menu((char **)len);
                            n_lines = 1;
                            if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                // 0x804ca9b
                                // branch -> 0x804ca9b
                                while (true) {
                                    // 0x804ca9b
                                    if (n_lines == 1) {
                                        goto lab_0x804caa8_24;
                                    }
                                    goto lab_0x804cb73_24;
                                }
                            }
                            // 0x804cc21
                            n_lines = 0;
                            format = len;
                            if (*(int32_t *)format != 0) {
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                v17 = n_lines + 1;
                                n_lines = v17;
                                v20 = len;
                                while (*(int32_t *)(4 * v17 + v20) != 0) {
                                    // 0x804cbf7
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    // continue -> 0x804cbf7
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804c917
                if (v23 != NULL) {
                    // 0x804c924
                    rewind((struct _IO_FILE *)line_no);
                    n_entries = 0;
                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                    v24 = n_entries;
                    // branch -> 0x804c945
                    while (str3 != NULL) {
                        // 0x804c945
                        n_entries = v24 + 1;
                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                        v24 = n_entries;
                        // continue -> 0x804c945
                    }
                    // 0x804c969
                    if (v24 != 0) {
                        // 0x804c976
                        i = v24;
                        rewind((struct _IO_FILE *)f_gisman);
                        mem = calloc(n_entries + 6 + 2 * (int32_t)line, 4);
                        len = (int32_t)mem;
                        n_lines = 0;
                        if (n_entries + 6 + 2 * (int32_t)line > 0) {
                            // 0x804c9c3
                            *(int32_t *)mem = 0;
                            v16 = n_lines + 1;
                            n_lines = v16;
                            if (n_entries + 6 + 2 * (int32_t)line > v16) {
                                *(int32_t *)(4 * v16 + len) = 0;
                                v15 = n_lines + 1;
                                n_lines = v15;
                                while (n_entries + 6 + 2 * (int32_t)line > v15) {
                                    // 0x804c9c3
                                    *(int32_t *)(4 * v15 + len) = 0;
                                    v15 = n_lines + 1;
                                    n_lines = v15;
                                    // continue -> 0x804c9c3
                                }
                                // 0x804ca5a
                                n_lines = 0;
                                if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                    v18 = len + 4 * n_lines;
                                    g3 = v18;
                                    len2 = strlen((char *)&str5);
                                    *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                    str6 = *(int32_t *)(len + 4 * n_lines);
                                    strcpy((char *)str6, (char *)&str5);
                                    n_lines++;
                                    while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                        // 0x804ca04
                                        v18 = len + 4 * n_lines;
                                        g3 = v18;
                                        len2 = strlen((char *)&str5);
                                        *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                        str6 = *(int32_t *)(len + 4 * n_lines);
                                        strcpy((char *)str6, (char *)&str5);
                                        n_lines++;
                                        // continue -> 0x804ca04
                                    }
                                    // 0x804ca7e
                                    check_ext_menu((char **)len);
                                    n_lines = 1;
                                    if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                        // 0x804ca9b
                                        // branch -> 0x804ca9b
                                        while (true) {
                                            // 0x804ca9b
                                            if (n_lines == 1) {
                                                goto lab_0x804caa8_24;
                                            }
                                            goto lab_0x804cb73_24;
                                        }
                                    }
                                    // 0x804cc21
                                    n_lines = 0;
                                    format = len;
                                    if (*(int32_t *)format != 0) {
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        while (*(int32_t *)(4 * v17 + v20) != 0) {
                                            // 0x804cbf7
                                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                            v17 = n_lines + 1;
                                            n_lines = v17;
                                            v20 = len;
                                            // continue -> 0x804cbf7
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x804ca7e
                                check_ext_menu((char **)len);
                                n_lines = 1;
                                if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                    // 0x804ca9b
                                    // branch -> 0x804ca9b
                                    while (true) {
                                        // 0x804ca9b
                                        if (n_lines == 1) {
                                            goto lab_0x804caa8_24;
                                        }
                                        goto lab_0x804cb73_24;
                                    }
                                }
                                // 0x804cc21
                                n_lines = 0;
                                format = len;
                                if (*(int32_t *)format != 0) {
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                    v17 = n_lines + 1;
                                    n_lines = v17;
                                    v20 = len;
                                    while (*(int32_t *)(4 * v17 + v20) != 0) {
                                        // 0x804cbf7
                                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v17 + v20));
                                        v17 = n_lines + 1;
                                        n_lines = v17;
                                        v20 = len;
                                        // continue -> 0x804cbf7
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804ca5a
                        n_lines = 0;
                        if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                            v18 = len + 4 * n_lines;
                            g3 = v18;
                            len2 = strlen((char *)&str5);
                            *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                            str6 = *(int32_t *)(len + 4 * n_lines);
                            strcpy((char *)str6, (char *)&str5);
                            n_lines++;
                            while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                // 0x804ca04
                                v18 = len + 4 * n_lines;
                                g3 = v18;
                                len2 = strlen((char *)&str5);
                                *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                str6 = *(int32_t *)(len + 4 * n_lines);
                                strcpy((char *)str6, (char *)&str5);
                                n_lines++;
                                // continue -> 0x804ca04
                            }
                            // 0x804ca7e
                            check_ext_menu((char **)len);
                            n_lines = 1;
                            if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                // 0x804ca9b
                                // branch -> 0x804ca9b
                                while (true) {
                                    // 0x804ca9b
                                    if (n_lines == 1) {
                                        goto lab_0x804caa8_24;
                                    }
                                    goto lab_0x804cb73_24;
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804ca7e
                        check_ext_menu((char **)len);
                        n_lines = 1;
                        if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                            // 0x804ca9b
                            // branch -> 0x804ca9b
                            while (true) {
                                // 0x804ca9b
                                if (n_lines == 1) {
                                    goto lab_0x804caa8_24;
                                }
                                goto lab_0x804cb73_24;
                            }
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x804c741
        memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMP_GISMAN);
        file3 = fopen(TMP_GISMAN, "w+");
        f_in = (struct _IO_FILE_4 *)file3;
        if (file3 == NULL) {
            // 0x804c78f
            err_num3 = *__errno_location();
            strerror(err_num3);
            print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
            // branch -> 0x804c7be
        }
        // 0x804c7be
        atexit((void (**)())exit_db);
        v19 = f_out;
        if (VERBOSE == 0) {
            // 0x804c83d
            sprintf((char *)&str5, "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, TMP_NULL, gisbase, v19, TMP_NULL, gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
            // branch -> 0x804c8ca
        } else {
            // 0x804c7d3
            sprintf((char *)&str5, "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, v19, gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
            // branch -> 0x804c8ca
        }
        // 0x804c8ca
        strcpy(GISMAN_CMD, (char *)&str5);
        line = NULL;
        str = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
        v22 = line;
        v23 = v22;
        if (str != NULL) {
            line = (char **)((int32_t)v22 + 1);
            str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
            v21 = line;
            v23 = v21;
            while (str2 != NULL) {
                // 0x804c8ec
                line = (char **)((int32_t)v21 + 1);
                str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no);
                v21 = line;
                v23 = v21;
                // continue -> 0x804c8ec
            }
            // 0x804c917
            if (v23 != NULL) {
                // 0x804c924
                rewind((struct _IO_FILE *)line_no);
                n_entries = 0;
                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                v24 = n_entries;
                // branch -> 0x804c945
                while (str3 != NULL) {
                    // 0x804c945
                    n_entries = v24 + 1;
                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                    v24 = n_entries;
                    // continue -> 0x804c945
                }
                // 0x804c969
                if (v24 != 0) {
                    // 0x804c976
                    i = v24;
                    rewind((struct _IO_FILE *)f_gisman);
                    mem = calloc(n_entries + 6 + 2 * (int32_t)line, 4);
                    len = (int32_t)mem;
                    n_lines = 0;
                    if (n_entries + 6 + 2 * (int32_t)line > 0) {
                        // 0x804c9c3
                        *(int32_t *)mem = 0;
                        v16 = n_lines + 1;
                        n_lines = v16;
                        if (n_entries + 6 + 2 * (int32_t)line > v16) {
                            *(int32_t *)(4 * v16 + len) = 0;
                            v15 = n_lines + 1;
                            n_lines = v15;
                            while (n_entries + 6 + 2 * (int32_t)line > v15) {
                                // 0x804c9c3
                                *(int32_t *)(4 * v15 + len) = 0;
                                v15 = n_lines + 1;
                                n_lines = v15;
                                // continue -> 0x804c9c3
                            }
                            // 0x804ca5a
                            n_lines = 0;
                            if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                v18 = len + 4 * n_lines;
                                g3 = v18;
                                len2 = strlen((char *)&str5);
                                *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                str6 = *(int32_t *)(len + 4 * n_lines);
                                strcpy((char *)str6, (char *)&str5);
                                n_lines++;
                                while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                    // 0x804ca04
                                    v18 = len + 4 * n_lines;
                                    g3 = v18;
                                    len2 = strlen((char *)&str5);
                                    *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                    str6 = *(int32_t *)(len + 4 * n_lines);
                                    strcpy((char *)str6, (char *)&str5);
                                    n_lines++;
                                    // continue -> 0x804ca04
                                }
                                // 0x804ca7e
                                check_ext_menu((char **)len);
                                n_lines = 1;
                                if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) != NULL) {
                                    // 0x804ca9b
                                    // branch -> 0x804ca9b
                                    while (true) {
                                        // 0x804ca9b
                                        if (n_lines == 1) {
                                            goto lab_0x804caa8_24;
                                        }
                                        goto lab_0x804cb73_24;
                                    }
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804ca5a
                    n_lines = 0;
                    if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                        v18 = len + 4 * n_lines;
                        g3 = v18;
                        len2 = strlen((char *)&str5);
                        *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                        str6 = *(int32_t *)(len + 4 * n_lines);
                        strcpy((char *)str6, (char *)&str5);
                        n_lines++;
                        while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                            // 0x804ca04
                            v18 = len + 4 * n_lines;
                            g3 = v18;
                            len2 = strlen((char *)&str5);
                            *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                            str6 = *(int32_t *)(len + 4 * n_lines);
                            strcpy((char *)str6, (char *)&str5);
                            n_lines++;
                            // continue -> 0x804ca04
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x804c917
        if (v23 != NULL) {
            // 0x804c924
            rewind((struct _IO_FILE *)line_no);
            n_entries = 0;
            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
            v24 = n_entries;
            // branch -> 0x804c945
            while (str3 != NULL) {
                // 0x804c945
                n_entries = v24 + 1;
                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                v24 = n_entries;
                // continue -> 0x804c945
            }
            // 0x804c969
            if (v24 != 0) {
                // 0x804c976
                i = v24;
                rewind((struct _IO_FILE *)f_gisman);
                mem = calloc(n_entries + 6 + 2 * (int32_t)line, 4);
                len = (int32_t)mem;
                n_lines = 0;
                if (n_entries + 6 + 2 * (int32_t)line > 0) {
                    // 0x804c9c3
                    *(int32_t *)mem = 0;
                    v16 = n_lines + 1;
                    n_lines = v16;
                    if (n_entries + 6 + 2 * (int32_t)line > v16) {
                        *(int32_t *)(4 * v16 + len) = 0;
                        v15 = n_lines + 1;
                        n_lines = v15;
                        while (n_entries + 6 + 2 * (int32_t)line > v15) {
                            // 0x804c9c3
                            *(int32_t *)(4 * v15 + len) = 0;
                            v15 = n_lines + 1;
                            n_lines = v15;
                            // continue -> 0x804c9c3
                        }
                        // 0x804ca5a
                        n_lines = 0;
                        if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                            v18 = len + 4 * n_lines;
                            g3 = v18;
                            len2 = strlen((char *)&str5);
                            *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                            str6 = *(int32_t *)(len + 4 * n_lines);
                            strcpy((char *)str6, (char *)&str5);
                            n_lines++;
                            while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                                // 0x804ca04
                                v18 = len + 4 * n_lines;
                                g3 = v18;
                                len2 = strlen((char *)&str5);
                                *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                                str6 = *(int32_t *)(len + 4 * n_lines);
                                strcpy((char *)str6, (char *)&str5);
                                n_lines++;
                                // continue -> 0x804ca04
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x804ca5a
                n_lines = 0;
                if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                    v18 = len + 4 * n_lines;
                    g3 = v18;
                    len2 = strlen((char *)&str5);
                    *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                    str6 = *(int32_t *)(len + 4 * n_lines);
                    strcpy((char *)str6, (char *)&str5);
                    n_lines++;
                    while (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman) != NULL) {
                        // 0x804ca04
                        v18 = len + 4 * n_lines;
                        g3 = v18;
                        len2 = strlen((char *)&str5);
                        *(int32_t *)v18 = (int32_t)malloc(len2 + 1);
                        str6 = *(int32_t *)(len + 4 * n_lines);
                        strcpy((char *)str6, (char *)&str5);
                        n_lines++;
                        // continue -> 0x804ca04
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804cd6c - 0x804cec6
// Line range:    415 - 451
void register_entries_gisman2(char * pkg_short_name, char * gisbase) {
    char str[2048];
    char v1[2048];
    int32_t v2 = *(int32_t *)20; // 0x804cd88
    int32_t file_path;
    memcpy((char *)&file_path, "../entries-gisman2", 19);
    char file = (int32_t)fopen((char *)&file_path, "r");
    v1[0] = file;
    if (file != 0) {
        // 0x804ce26
        if (VERBOSE == 0) {
            // 0x804ce66
            sprintf(str, "mkdir -p %s/etc/gm/Xtns ; cp -f ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", gisbase, gisbase, pkg_short_name);
            // branch -> 0x804ce9b
        } else {
            // 0x804ce2f
            sprintf(str, "mkdir --verbose -p %s/etc/gm/Xtns ; cp -fv ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", gisbase, gisbase, pkg_short_name);
            // branch -> 0x804ce9b
        }
        // 0x804ce9b
        strcpy(GISMAN2_CMD, str);
        // branch -> 0x804ceb4
        // 0x804ceb4
        if (*(int32_t *)20 != v2) {
            // 0x804cec0
            __stack_chk_fail();
            // branch -> 0x804cec5
        }
        // 0x804cec5
        return;
    }
    // 0x804cdd7
    if (*__errno_location() != 2) {
        // 0x804cde7
        fclose((struct _IO_FILE *)(int32_t)v1[0]);
        int32_t err_num = *__errno_location(); // 0x804cdfa
        strerror(err_num);
        print_error(-32, "checking for file '%s': %s\n");
        // branch -> 0x804ce26
        // 0x804ce26
        if (VERBOSE == 0) {
            // 0x804ce66
            sprintf(str, "mkdir -p %s/etc/gm/Xtns ; cp -f ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", gisbase, gisbase, pkg_short_name);
            // branch -> 0x804ce9b
        } else {
            // 0x804ce2f
            sprintf(str, "mkdir --verbose -p %s/etc/gm/Xtns ; cp -fv ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", gisbase, gisbase, pkg_short_name);
            // branch -> 0x804ce9b
        }
        // 0x804ce9b
        strcpy(GISMAN2_CMD, str);
        // branch -> 0x804ceb4
    }
    // 0x804ceb4
    if (*(int32_t *)20 != v2) {
        // 0x804cec0
        __stack_chk_fail();
        // branch -> 0x804cec5
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804cec7 - 0x804d742
// Line range:    461 - 646
int32_t deregister_entries_gisman(char * pkg_short_name, char * gisbase) {
    char str9[2048];
    char v1[2048];
    // 0x804cec7
    int32_t v2;
    int32_t num_removed = v2; // bp-6224
    char * v3;
    char * rq = v3; // bp-6220
    int32_t v4;
    int32_t end_sub = v4; // bp-6212
    int32_t v5;
    int32_t start_sub = v5; // bp-6208
    int32_t v6;
    int32_t end = v6; // bp-6204
    int32_t v7;
    int32_t start = v7; // bp-6200
    int32_t v8;
    int32_t pos = v8; // bp-6196
    struct _IO_FILE_4 * v9;
    struct _IO_FILE_4 * f_in = v9; // bp-6188
    int32_t v10;
    int32_t n_lines_new = v10; // bp-6184
    int32_t v11;
    int32_t n_lines_org = v11; // bp-6180
    int32_t v12;
    int32_t n_lines = v12; // bp-6172
    char ** v13;
    char ** line = v13; // bp-6168
    int32_t v14 = g3; // 0x804ceca
    num_removed = (int32_t)pkg_short_name;
    int32_t v15 = *(int32_t *)20; // 0x804cee4
    int32_t str4;
    sprintf((char *)&str4, "%s/etc/dm/menu.tcl", gisbase);
    struct _IO_FILE * file = fopen((char *)&str4, "r"); // 0x804cf21
    n_lines_new = (int32_t)file;
    int32_t v16; // 0x804d17e
    int32_t v17; // 0x804d17e185
    int32_t str8; // 0x804d2a9
    int32_t v18; // 0x804d4ac
    int32_t v19; // 0x804d5c8
    int32_t v20; // 0x804d1ad_11
    struct _IO_FILE * file2; // 0x804cfc4
    char * str2; // 0x804d108
    char * str; // 0x804d10896
    int32_t len; // 0x804d1bc
    int32_t v21; // 0x804d258
    int32_t v22; // 0x804d317
    int32_t v23; // 0x804d340
    int32_t v24; // 0x804d3d8
    int32_t v25; // 0x804d435
    int32_t v26; // 0x804d50c
    int32_t v27; // 0x804d54f
    int32_t str5;
    uint32_t v28; // 0x804d594
    char mem;
    int32_t err_num2; // 0x804cfdd
    int32_t str6; // 0x804d1e3
    int32_t str7; // 0x804d291
    char v29; // 0x804d245
    char v30; // 0x804d32f
    char v31; // 0x804d3c5
    int32_t v32; // 0x804d4b3
    int32_t v33; // 0x804d4b381
    char v34; // 0x804d4f9
    char v35; // 0x804d567
    int32_t v36; // 0x804d586
    int32_t v37; // 0x804d5cf
    char v38; // 0x804d1dd
    char ** v39; // 0x804d111
    char ** v40; // 0x804d11199
    char ** v41;
    int32_t v42; // 0x804d57d
    if (file == NULL) {
        // 0x804cf35
        if (*__errno_location() == 2) {
            // 0x804cf41
            // branch -> 0x804d729
        } else {
            // 0x804cf4b
            fclose((struct _IO_FILE *)n_lines_new);
            int32_t err_num = *__errno_location(); // 0x804cf5e
            strerror(err_num);
            print_error(-22, "checking for file '%s': %s\n");
            // branch -> 0x804cf8a
            // 0x804cf8a
            memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMP_GISMAN);
            file2 = fopen(TMP_GISMAN, "w+");
            f_in = (struct _IO_FILE_4 *)file2;
            if (file2 == NULL) {
                // 0x804cfd8
                err_num2 = *__errno_location();
                strerror(err_num2);
                print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804d007
            }
            // 0x804d007
            atexit((void (**)())exit_db);
            if (VERBOSE == 0) {
                // 0x804d065
                sprintf((char *)&str5, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
                // branch -> 0x804d0c4
            } else {
                // 0x804d01c
                sprintf((char *)&str5, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
                // branch -> 0x804d0c4
            }
            // 0x804d0c4
            strcpy(GISMAN_CMD, (char *)&str5);
            line = NULL;
            str = fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new);
            v40 = line;
            v41 = v40;
            int32_t v43; // 0x804d61b
            int32_t format; // 0x804d607
            char v44; // 0x804d62b
            char v45; // 0x804d62b70
            if (str != NULL) {
                line = (char **)((int32_t)v40 + 1);
                str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new);
                v39 = line;
                v41 = v39;
                while (str2 != NULL) {
                    // 0x804d0e6
                    line = (char **)((int32_t)v39 + 1);
                    str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new);
                    v39 = line;
                    v41 = v39;
                    // continue -> 0x804d0e6
                }
                // 0x804d111
                if (v41 == NULL) {
                    // 0x804d11a
                    // branch -> 0x804d729
                } else {
                    // 0x804d124
                    rewind((struct _IO_FILE *)n_lines_new);
                    mem = (int32_t)calloc((int32_t)line + 1, 4);
                    v1[0] = mem;
                    n_lines = 0;
                    int32_t v46; // 0x804d6fd
                    char * str3; // 0x804d681
                    int32_t v47; // 0x804d6f3
                    char v48; // 0x804d6ed
                    int32_t v49; // 0x804d68a
                    if ((int32_t)line > -1) {
                        // 0x804d169
                        *(int32_t *)(int32_t)mem = 0;
                        v17 = n_lines + 1;
                        n_lines = v17;
                        if ((int32_t)line + 1 > v17) {
                            *(int32_t *)(int32_t)((char)(4 * v17) + v1[0]) = 0;
                            v16 = n_lines + 1;
                            n_lines = v16;
                            while ((int32_t)line + 1 > v16) {
                                // 0x804d169
                                *(int32_t *)(int32_t)((char)(4 * v16) + v1[0]) = 0;
                                v16 = n_lines + 1;
                                n_lines = v16;
                                // continue -> 0x804d169
                            }
                            // 0x804d1f8
                            n_lines = 0;
                            if (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                                v20 = (char)(4 * n_lines) + v1[0];
                                g3 = v20;
                                len = strlen((char *)&str5);
                                *(int32_t *)v20 = (int32_t)malloc(len + 1);
                                v38 = v1[0];
                                str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                                strcpy((char *)str6, (char *)&str5);
                                n_lines++;
                                while (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                                    // 0x804d1a2
                                    v20 = (char)(4 * n_lines) + v1[0];
                                    g3 = v20;
                                    len = strlen((char *)&str5);
                                    *(int32_t *)v20 = (int32_t)malloc(len + 1);
                                    v38 = v1[0];
                                    str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                                    strcpy((char *)str6, (char *)&str5);
                                    n_lines++;
                                    // continue -> 0x804d1a2
                                }
                                // 0x804d21c
                                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                v29 = v1[0];
                                v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                                if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                                    // 0x804d26c
                                    print_warning("could not find uninstall information in 'menu.tcl'.\n");
                                    // branch -> 0x804d729
                                    // 0x804d729
                                    if (*(int32_t *)20 != v15) {
                                        // 0x804d735
                                        __stack_chk_fail();
                                        // branch -> 0x804d73a
                                    }
                                    // 0x804d73a
                                    g3 = v14;
                                    return -1;
                                }
                                // 0x804d282
                                str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                                str8 = (int32_t)strchr((char *)str7, 34) + 1;
                                end_sub = str8;
                                strchr((char *)str8, 34);
                                strchr((char *)str8, 34);
                                strcpy(str9, (char *)end_sub);
                                v1[3] = 0;
                                v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                pos = v22;
                                v30 = v1[0];
                                v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                                start = v23 - 1;
                                if (v23 == 0) {
                                    // 0x804d357
                                    start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                                    // branch -> 0x804d37b
                                }
                                // 0x804d37b
                                if (pos == -1) {
                                    // 0x804d384
                                    print_warning("menu 'Xtns' does not exist.\n");
                                    // branch -> 0x804d729
                                } else {
                                    // 0x804d39a
                                    sprintf((char *)&str5, "{cascad \"%s\"", str9);
                                    v31 = v1[0];
                                    v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                                    end = v24;
                                    if (v24 != -1) {
                                        // 0x804d3ec
                                        if (v24 <= start) {
                                            // 0x804d41a
                                            v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                            start_sub = v25;
                                            if (v25 != -1) {
                                                // 0x804d449
                                                if (v25 <= start) {
                                                    // 0x804d477
                                                    rq = NULL;
                                                    n_lines = 0;
                                                    v33 = end;
                                                    if (v25 - v33 <= -1) {
                                                        // 0x804d4d0
                                                        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                        v34 = v1[0];
                                                        v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                        delete_str(v26, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                        pos = v27;
                                                        v35 = v1[0];
                                                        v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                        start = v42;
                                                        v36 = pos;
                                                        v28 = v42 - v36;
                                                        if (v28 <= 2) {
                                                            // 0x804d5cf
                                                            n_lines = 0;
                                                            if (v28 > -1) {
                                                                delete_str(v36, (char **)(int32_t)v1[0]);
                                                                rq = (char *)((int32_t)rq + 1);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                v37 = pos;
                                                                while (start - v37 + 1 > v19) {
                                                                    // 0x804d5a9
                                                                    delete_str(v37, (char **)(int32_t)v1[0]);
                                                                    rq = (char *)((int32_t)rq + 1);
                                                                    v19 = n_lines + 1;
                                                                    n_lines = v19;
                                                                    v37 = pos;
                                                                    // continue -> 0x804d5a9
                                                                }
                                                                // 0x804d622
                                                                n_lines = 0;
                                                                v45 = v1[0];
                                                                if (*(int32_t *)(int32_t)v45 == 0) {
                                                                    // 0x804d637
                                                                    fflush((struct _IO_FILE *)f_in);
                                                                    rewind((struct _IO_FILE *)f_in);
                                                                    n_lines_org = 0;
                                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                    v49 = n_lines_org;
                                                                    // branch -> 0x804d666
                                                                    while (str3 != NULL) {
                                                                        // 0x804d666
                                                                        n_lines_org = v49 + 1;
                                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                        v49 = n_lines_org;
                                                                        // continue -> 0x804d666
                                                                    }
                                                                    // 0x804d68a
                                                                    if (v49 == 0) {
                                                                        // 0x804d693
                                                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                        // branch -> 0x804d6bc
                                                                    }
                                                                    // 0x804d6bc
                                                                    fclose((struct _IO_FILE *)n_lines_new);
                                                                    fclose((struct _IO_FILE *)f_in);
                                                                    n_lines = 0;
                                                                    if ((int32_t)line <= -1) {
                                                                        // 0x804d715
                                                                        free((char *)(int32_t)v1[0]);
                                                                        // branch -> 0x804d729
                                                                        // 0x804d729
                                                                        if (*(int32_t *)20 != v15) {
                                                                            // 0x804d735
                                                                            __stack_chk_fail();
                                                                            // branch -> 0x804d73a
                                                                        }
                                                                        // 0x804d73a
                                                                        g3 = v14;
                                                                        return (int32_t)rq;
                                                                    }
                                                                    v48 = v1[0];
                                                                    free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    while ((int32_t)line + 1 > v46) {
                                                                        // 0x804d6e4
                                                                        v48 = v1[0];
                                                                        v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                        free((char *)v47);
                                                                        v46 = n_lines + 1;
                                                                        n_lines = v46;
                                                                        // continue -> 0x804d6e4
                                                                    }
                                                                    // 0x804d715
                                                                    free((char *)(int32_t)v1[0]);
                                                                    // branch -> 0x804d729
                                                                    // 0x804d729
                                                                    if (*(int32_t *)20 != v15) {
                                                                        // 0x804d735
                                                                        __stack_chk_fail();
                                                                        // branch -> 0x804d73a
                                                                    }
                                                                    // 0x804d73a
                                                                    g3 = v14;
                                                                    return (int32_t)rq;
                                                                }
                                                                format = *(int32_t *)(int32_t)((char)0 + v45);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                    // 0x804d5f8
                                                                    format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                    v43 = n_lines + 1;
                                                                    n_lines = v43;
                                                                    v44 = v1[0];
                                                                    // continue -> 0x804d5f8
                                                                }
                                                                // 0x804d637
                                                                fflush((struct _IO_FILE *)f_in);
                                                                rewind((struct _IO_FILE *)f_in);
                                                                n_lines_org = 0;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // branch -> 0x804d666
                                                                while (str3 != NULL) {
                                                                    // 0x804d666
                                                                    n_lines_org = v49 + 1;
                                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                    v49 = n_lines_org;
                                                                    // continue -> 0x804d666
                                                                }
                                                                // 0x804d68a
                                                                if (v49 == 0) {
                                                                    // 0x804d693
                                                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                    // branch -> 0x804d6bc
                                                                }
                                                                // 0x804d6bc
                                                                fclose((struct _IO_FILE *)n_lines_new);
                                                                fclose((struct _IO_FILE *)f_in);
                                                                n_lines = 0;
                                                                if ((int32_t)line <= -1) {
                                                                    // 0x804d715
                                                                    free((char *)(int32_t)v1[0]);
                                                                    // branch -> 0x804d729
                                                                    // 0x804d729
                                                                    if (*(int32_t *)20 != v15) {
                                                                        // 0x804d735
                                                                        __stack_chk_fail();
                                                                        // branch -> 0x804d73a
                                                                    }
                                                                    // 0x804d73a
                                                                    g3 = v14;
                                                                    return (int32_t)rq;
                                                                }
                                                                v48 = v1[0];
                                                                free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                while ((int32_t)line + 1 > v46) {
                                                                    // 0x804d6e4
                                                                    v48 = v1[0];
                                                                    v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                    free((char *)v47);
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    // continue -> 0x804d6e4
                                                                }
                                                                // 0x804d715
                                                                free((char *)(int32_t)v1[0]);
                                                                // branch -> 0x804d729
                                                                // 0x804d729
                                                                if (*(int32_t *)20 != v15) {
                                                                    // 0x804d735
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804d73a
                                                                }
                                                                // 0x804d73a
                                                                g3 = v14;
                                                                return (int32_t)rq;
                                                            }
                                                        }
                                                        // 0x804d622
                                                        n_lines = 0;
                                                        v45 = v1[0];
                                                        if (*(int32_t *)(int32_t)v45 == 0) {
                                                            // 0x804d637
                                                            fflush((struct _IO_FILE *)f_in);
                                                            rewind((struct _IO_FILE *)f_in);
                                                            n_lines_org = 0;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // branch -> 0x804d666
                                                            while (str3 != NULL) {
                                                                // 0x804d666
                                                                n_lines_org = v49 + 1;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // continue -> 0x804d666
                                                            }
                                                            // 0x804d68a
                                                            if (v49 == 0) {
                                                                // 0x804d693
                                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                // branch -> 0x804d6bc
                                                            }
                                                            // 0x804d6bc
                                                            fclose((struct _IO_FILE *)n_lines_new);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if ((int32_t)line <= -1) {
                                                                // 0x804d715
                                                                free((char *)(int32_t)v1[0]);
                                                                // branch -> 0x804d729
                                                                // 0x804d729
                                                                if (*(int32_t *)20 != v15) {
                                                                    // 0x804d735
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804d73a
                                                                }
                                                                // 0x804d73a
                                                                g3 = v14;
                                                                return (int32_t)rq;
                                                            }
                                                            v48 = v1[0];
                                                            free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            while ((int32_t)line + 1 > v46) {
                                                                // 0x804d6e4
                                                                v48 = v1[0];
                                                                v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                free((char *)v47);
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                // continue -> 0x804d6e4
                                                            }
                                                            // 0x804d715
                                                            free((char *)(int32_t)v1[0]);
                                                            // branch -> 0x804d729
                                                            // 0x804d729
                                                            if (*(int32_t *)20 != v15) {
                                                                // 0x804d735
                                                                __stack_chk_fail();
                                                                // branch -> 0x804d73a
                                                            }
                                                            // 0x804d73a
                                                            g3 = v14;
                                                            return (int32_t)rq;
                                                        }
                                                        format = *(int32_t *)(int32_t)((char)0 + v45);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                            // 0x804d5f8
                                                            format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            // continue -> 0x804d5f8
                                                        }
                                                        // 0x804d637
                                                        fflush((struct _IO_FILE *)f_in);
                                                        rewind((struct _IO_FILE *)f_in);
                                                        n_lines_org = 0;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // branch -> 0x804d666
                                                        while (str3 != NULL) {
                                                            // 0x804d666
                                                            n_lines_org = v49 + 1;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // continue -> 0x804d666
                                                        }
                                                        // 0x804d68a
                                                        if (v49 == 0) {
                                                            // 0x804d693
                                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                            // branch -> 0x804d6bc
                                                        }
                                                        // 0x804d6bc
                                                        fclose((struct _IO_FILE *)n_lines_new);
                                                        fclose((struct _IO_FILE *)f_in);
                                                        n_lines = 0;
                                                        if ((int32_t)line <= -1) {
                                                            // 0x804d715
                                                            free((char *)(int32_t)v1[0]);
                                                            // branch -> 0x804d729
                                                            // 0x804d729
                                                            if (*(int32_t *)20 != v15) {
                                                                // 0x804d735
                                                                __stack_chk_fail();
                                                                // branch -> 0x804d73a
                                                            }
                                                            // 0x804d73a
                                                            g3 = v14;
                                                            return (int32_t)rq;
                                                        }
                                                        v48 = v1[0];
                                                        free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                        v46 = n_lines + 1;
                                                        n_lines = v46;
                                                        while ((int32_t)line + 1 > v46) {
                                                            // 0x804d6e4
                                                            v48 = v1[0];
                                                            v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                            free((char *)v47);
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            // continue -> 0x804d6e4
                                                        }
                                                        // 0x804d715
                                                        free((char *)(int32_t)v1[0]);
                                                        // branch -> 0x804d729
                                                        // 0x804d729
                                                        if (*(int32_t *)20 != v15) {
                                                            // 0x804d735
                                                            __stack_chk_fail();
                                                            // branch -> 0x804d73a
                                                        }
                                                        // 0x804d73a
                                                        g3 = v14;
                                                        return (int32_t)rq;
                                                    }
                                                    delete_str(v33, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v18 = n_lines + 1;
                                                    n_lines = v18;
                                                    v32 = end;
                                                    while (start_sub - v32 + 1 > v18) {
                                                        // 0x804d48d
                                                        delete_str(v32, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v18 = n_lines + 1;
                                                        n_lines = v18;
                                                        v32 = end;
                                                        // continue -> 0x804d48d
                                                    }
                                                    // 0x804d4d0
                                                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                    v34 = v1[0];
                                                    v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                    delete_str(v26, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                    pos = v27;
                                                    v35 = v1[0];
                                                    v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                    start = v42;
                                                    v36 = pos;
                                                    v28 = v42 - v36;
                                                    if (v28 <= 2) {
                                                        // 0x804d5cf
                                                        n_lines = 0;
                                                        if (v28 > -1) {
                                                            delete_str(v36, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            while (start - v37 + 1 > v19) {
                                                                // 0x804d5a9
                                                                delete_str(v37, (char **)(int32_t)v1[0]);
                                                                rq = (char *)((int32_t)rq + 1);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                v37 = pos;
                                                                // continue -> 0x804d5a9
                                                            }
                                                            // 0x804d622
                                                            n_lines = 0;
                                                            v45 = v1[0];
                                                            if (*(int32_t *)(int32_t)v45 == 0) {
                                                                // 0x804d637
                                                                fflush((struct _IO_FILE *)f_in);
                                                                rewind((struct _IO_FILE *)f_in);
                                                                n_lines_org = 0;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // branch -> 0x804d666
                                                                while (str3 != NULL) {
                                                                    // 0x804d666
                                                                    n_lines_org = v49 + 1;
                                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                    v49 = n_lines_org;
                                                                    // continue -> 0x804d666
                                                                }
                                                                // 0x804d68a
                                                                if (v49 == 0) {
                                                                    // 0x804d693
                                                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                    // branch -> 0x804d6bc
                                                                }
                                                                // 0x804d6bc
                                                                fclose((struct _IO_FILE *)n_lines_new);
                                                                fclose((struct _IO_FILE *)f_in);
                                                                n_lines = 0;
                                                                if ((int32_t)line <= -1) {
                                                                    // 0x804d715
                                                                    free((char *)(int32_t)v1[0]);
                                                                    // branch -> 0x804d729
                                                                    // 0x804d729
                                                                    if (*(int32_t *)20 != v15) {
                                                                        // 0x804d735
                                                                        __stack_chk_fail();
                                                                        // branch -> 0x804d73a
                                                                    }
                                                                    // 0x804d73a
                                                                    g3 = v14;
                                                                    return (int32_t)rq;
                                                                }
                                                                v48 = v1[0];
                                                                free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                while ((int32_t)line + 1 > v46) {
                                                                    // 0x804d6e4
                                                                    v48 = v1[0];
                                                                    v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                    free((char *)v47);
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    // continue -> 0x804d6e4
                                                                }
                                                                // 0x804d715
                                                                free((char *)(int32_t)v1[0]);
                                                                // branch -> 0x804d729
                                                                // 0x804d729
                                                                if (*(int32_t *)20 != v15) {
                                                                    // 0x804d735
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804d73a
                                                                }
                                                                // 0x804d73a
                                                                g3 = v14;
                                                                return (int32_t)rq;
                                                            }
                                                            format = *(int32_t *)(int32_t)((char)0 + v45);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                // 0x804d5f8
                                                                format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                // continue -> 0x804d5f8
                                                            }
                                                            // 0x804d637
                                                            fflush((struct _IO_FILE *)f_in);
                                                            rewind((struct _IO_FILE *)f_in);
                                                            n_lines_org = 0;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // branch -> 0x804d666
                                                            while (str3 != NULL) {
                                                                // 0x804d666
                                                                n_lines_org = v49 + 1;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // continue -> 0x804d666
                                                            }
                                                            // 0x804d68a
                                                            if (v49 == 0) {
                                                                // 0x804d693
                                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                // branch -> 0x804d6bc
                                                            }
                                                            // 0x804d6bc
                                                            fclose((struct _IO_FILE *)n_lines_new);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if ((int32_t)line <= -1) {
                                                                // 0x804d715
                                                                free((char *)(int32_t)v1[0]);
                                                                // branch -> 0x804d729
                                                                // 0x804d729
                                                                if (*(int32_t *)20 != v15) {
                                                                    // 0x804d735
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804d73a
                                                                }
                                                                // 0x804d73a
                                                                g3 = v14;
                                                                return (int32_t)rq;
                                                            }
                                                            v48 = v1[0];
                                                            free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            while ((int32_t)line + 1 > v46) {
                                                                // 0x804d6e4
                                                                v48 = v1[0];
                                                                v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                free((char *)v47);
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                // continue -> 0x804d6e4
                                                            }
                                                            // 0x804d715
                                                            free((char *)(int32_t)v1[0]);
                                                            // branch -> 0x804d729
                                                            // 0x804d729
                                                            if (*(int32_t *)20 != v15) {
                                                                // 0x804d735
                                                                __stack_chk_fail();
                                                                // branch -> 0x804d73a
                                                            }
                                                            // 0x804d73a
                                                            g3 = v14;
                                                            return (int32_t)rq;
                                                        }
                                                    }
                                                    // 0x804d622
                                                    n_lines = 0;
                                                    v45 = v1[0];
                                                    if (*(int32_t *)(int32_t)v45 == 0) {
                                                        // 0x804d637
                                                        fflush((struct _IO_FILE *)f_in);
                                                        rewind((struct _IO_FILE *)f_in);
                                                        n_lines_org = 0;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // branch -> 0x804d666
                                                        while (str3 != NULL) {
                                                            // 0x804d666
                                                            n_lines_org = v49 + 1;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // continue -> 0x804d666
                                                        }
                                                        // 0x804d68a
                                                        if (v49 == 0) {
                                                            // 0x804d693
                                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                            // branch -> 0x804d6bc
                                                        }
                                                        // 0x804d6bc
                                                        fclose((struct _IO_FILE *)n_lines_new);
                                                        fclose((struct _IO_FILE *)f_in);
                                                        n_lines = 0;
                                                        if ((int32_t)line <= -1) {
                                                            // 0x804d715
                                                            free((char *)(int32_t)v1[0]);
                                                            // branch -> 0x804d729
                                                            // 0x804d729
                                                            if (*(int32_t *)20 != v15) {
                                                                // 0x804d735
                                                                __stack_chk_fail();
                                                                // branch -> 0x804d73a
                                                            }
                                                            // 0x804d73a
                                                            g3 = v14;
                                                            return (int32_t)rq;
                                                        }
                                                        v48 = v1[0];
                                                        free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                        v46 = n_lines + 1;
                                                        n_lines = v46;
                                                        while ((int32_t)line + 1 > v46) {
                                                            // 0x804d6e4
                                                            v48 = v1[0];
                                                            v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                            free((char *)v47);
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            // continue -> 0x804d6e4
                                                        }
                                                        // 0x804d715
                                                        free((char *)(int32_t)v1[0]);
                                                        // branch -> 0x804d729
                                                        // 0x804d729
                                                        if (*(int32_t *)20 != v15) {
                                                            // 0x804d735
                                                            __stack_chk_fail();
                                                            // branch -> 0x804d73a
                                                        }
                                                        // 0x804d73a
                                                        g3 = v14;
                                                        return (int32_t)rq;
                                                    }
                                                    format = *(int32_t *)(int32_t)((char)0 + v45);
                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                    v43 = n_lines + 1;
                                                    n_lines = v43;
                                                    v44 = v1[0];
                                                    while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                        // 0x804d5f8
                                                        format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        // continue -> 0x804d5f8
                                                    }
                                                    // 0x804d637
                                                    fflush((struct _IO_FILE *)f_in);
                                                    rewind((struct _IO_FILE *)f_in);
                                                    n_lines_org = 0;
                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                    v49 = n_lines_org;
                                                    // branch -> 0x804d666
                                                    while (str3 != NULL) {
                                                        // 0x804d666
                                                        n_lines_org = v49 + 1;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // continue -> 0x804d666
                                                    }
                                                    // 0x804d68a
                                                    if (v49 == 0) {
                                                        // 0x804d693
                                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                        // branch -> 0x804d6bc
                                                    }
                                                    // 0x804d6bc
                                                    fclose((struct _IO_FILE *)n_lines_new);
                                                    fclose((struct _IO_FILE *)f_in);
                                                    n_lines = 0;
                                                    if ((int32_t)line <= -1) {
                                                        // 0x804d715
                                                        free((char *)(int32_t)v1[0]);
                                                        // branch -> 0x804d729
                                                        // 0x804d729
                                                        if (*(int32_t *)20 != v15) {
                                                            // 0x804d735
                                                            __stack_chk_fail();
                                                            // branch -> 0x804d73a
                                                        }
                                                        // 0x804d73a
                                                        g3 = v14;
                                                        return (int32_t)rq;
                                                    }
                                                    v48 = v1[0];
                                                    free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                    v46 = n_lines + 1;
                                                    n_lines = v46;
                                                    while ((int32_t)line + 1 > v46) {
                                                        // 0x804d6e4
                                                        v48 = v1[0];
                                                        v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                        free((char *)v47);
                                                        v46 = n_lines + 1;
                                                        n_lines = v46;
                                                        // continue -> 0x804d6e4
                                                    }
                                                    // 0x804d715
                                                    free((char *)(int32_t)v1[0]);
                                                    // branch -> 0x804d729
                                                    // 0x804d729
                                                    if (*(int32_t *)20 != v15) {
                                                        // 0x804d735
                                                        __stack_chk_fail();
                                                        // branch -> 0x804d73a
                                                    }
                                                    // 0x804d73a
                                                    g3 = v14;
                                                    return (int32_t)rq;
                                                }
                                            }
                                            // 0x804d457
                                            print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                            // branch -> 0x804d729
                                            // 0x804d729
                                            if (*(int32_t *)20 != v15) {
                                                // 0x804d735
                                                __stack_chk_fail();
                                                // branch -> 0x804d73a
                                            }
                                            // 0x804d73a
                                            g3 = v14;
                                            return -1;
                                        }
                                    }
                                    // 0x804d3fa
                                    print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                                    // branch -> 0x804d729
                                }
                                // 0x804d729
                                if (*(int32_t *)20 != v15) {
                                    // 0x804d735
                                    __stack_chk_fail();
                                    // branch -> 0x804d73a
                                }
                                // 0x804d73a
                                g3 = v14;
                                return -1;
                            }
                            // 0x804d21c
                            sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                            v29 = v1[0];
                            v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                            if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                                // 0x804d26c
                                print_warning("could not find uninstall information in 'menu.tcl'.\n");
                                // branch -> 0x804d729
                            } else {
                                // 0x804d282
                                str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                                str8 = (int32_t)strchr((char *)str7, 34) + 1;
                                end_sub = str8;
                                strchr((char *)str8, 34);
                                strchr((char *)str8, 34);
                                strcpy(str9, (char *)end_sub);
                                v1[3] = 0;
                                v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                pos = v22;
                                v30 = v1[0];
                                v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                                start = v23 - 1;
                                if (v23 == 0) {
                                    // 0x804d357
                                    start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                                    // branch -> 0x804d37b
                                }
                                // 0x804d37b
                                if (pos == -1) {
                                    // 0x804d384
                                    print_warning("menu 'Xtns' does not exist.\n");
                                    // branch -> 0x804d729
                                } else {
                                    // 0x804d39a
                                    sprintf((char *)&str5, "{cascad \"%s\"", str9);
                                    v31 = v1[0];
                                    v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                                    end = v24;
                                    if (v24 != -1) {
                                        // 0x804d3ec
                                        if (v24 <= start) {
                                            // 0x804d41a
                                            v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                            start_sub = v25;
                                            if (v25 != -1) {
                                                // 0x804d449
                                                if (v25 <= start) {
                                                    // 0x804d477
                                                    rq = NULL;
                                                    n_lines = 0;
                                                    v33 = end;
                                                    if (v25 - v33 > -1) {
                                                        delete_str(v33, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v18 = n_lines + 1;
                                                        n_lines = v18;
                                                        v32 = end;
                                                        while (start_sub - v32 + 1 > v18) {
                                                            // 0x804d48d
                                                            delete_str(v32, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v18 = n_lines + 1;
                                                            n_lines = v18;
                                                            v32 = end;
                                                            // continue -> 0x804d48d
                                                        }
                                                        // 0x804d4d0
                                                        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                        v34 = v1[0];
                                                        v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                        delete_str(v26, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                        pos = v27;
                                                        v35 = v1[0];
                                                        v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                        start = v42;
                                                        v36 = pos;
                                                        v28 = v42 - v36;
                                                        if (v28 <= 2) {
                                                            // 0x804d5cf
                                                            n_lines = 0;
                                                            if (v28 > -1) {
                                                                delete_str(v36, (char **)(int32_t)v1[0]);
                                                                rq = (char *)((int32_t)rq + 1);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                v37 = pos;
                                                                while (start - v37 + 1 > v19) {
                                                                    // 0x804d5a9
                                                                    delete_str(v37, (char **)(int32_t)v1[0]);
                                                                    rq = (char *)((int32_t)rq + 1);
                                                                    v19 = n_lines + 1;
                                                                    n_lines = v19;
                                                                    v37 = pos;
                                                                    // continue -> 0x804d5a9
                                                                }
                                                                // 0x804d622
                                                                n_lines = 0;
                                                                v45 = v1[0];
                                                                if (*(int32_t *)(int32_t)v45 == 0) {
                                                                    // 0x804d637
                                                                    fflush((struct _IO_FILE *)f_in);
                                                                    rewind((struct _IO_FILE *)f_in);
                                                                    n_lines_org = 0;
                                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                    v49 = n_lines_org;
                                                                    // branch -> 0x804d666
                                                                    while (str3 != NULL) {
                                                                        // 0x804d666
                                                                        n_lines_org = v49 + 1;
                                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                        v49 = n_lines_org;
                                                                        // continue -> 0x804d666
                                                                    }
                                                                    // 0x804d68a
                                                                    if (v49 == 0) {
                                                                        // 0x804d693
                                                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                        // branch -> 0x804d6bc
                                                                    }
                                                                    // 0x804d6bc
                                                                    fclose((struct _IO_FILE *)n_lines_new);
                                                                    fclose((struct _IO_FILE *)f_in);
                                                                    n_lines = 0;
                                                                    if ((int32_t)line <= -1) {
                                                                        // 0x804d715
                                                                        free((char *)(int32_t)v1[0]);
                                                                        // branch -> 0x804d729
                                                                        // 0x804d729
                                                                        if (*(int32_t *)20 != v15) {
                                                                            // 0x804d735
                                                                            __stack_chk_fail();
                                                                            // branch -> 0x804d73a
                                                                        }
                                                                        // 0x804d73a
                                                                        g3 = v14;
                                                                        return (int32_t)rq;
                                                                    }
                                                                    v48 = v1[0];
                                                                    free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    while ((int32_t)line + 1 > v46) {
                                                                        // 0x804d6e4
                                                                        v48 = v1[0];
                                                                        v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                        free((char *)v47);
                                                                        v46 = n_lines + 1;
                                                                        n_lines = v46;
                                                                        // continue -> 0x804d6e4
                                                                    }
                                                                    // 0x804d715
                                                                    free((char *)(int32_t)v1[0]);
                                                                    // branch -> 0x804d729
                                                                    // 0x804d729
                                                                    if (*(int32_t *)20 != v15) {
                                                                        // 0x804d735
                                                                        __stack_chk_fail();
                                                                        // branch -> 0x804d73a
                                                                    }
                                                                    // 0x804d73a
                                                                    g3 = v14;
                                                                    return (int32_t)rq;
                                                                }
                                                                format = *(int32_t *)(int32_t)((char)0 + v45);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                    // 0x804d5f8
                                                                    format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                    v43 = n_lines + 1;
                                                                    n_lines = v43;
                                                                    v44 = v1[0];
                                                                    // continue -> 0x804d5f8
                                                                }
                                                                // 0x804d637
                                                                fflush((struct _IO_FILE *)f_in);
                                                                rewind((struct _IO_FILE *)f_in);
                                                                n_lines_org = 0;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // branch -> 0x804d666
                                                                while (str3 != NULL) {
                                                                    // 0x804d666
                                                                    n_lines_org = v49 + 1;
                                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                    v49 = n_lines_org;
                                                                    // continue -> 0x804d666
                                                                }
                                                                // 0x804d68a
                                                                if (v49 == 0) {
                                                                    // 0x804d693
                                                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                    // branch -> 0x804d6bc
                                                                }
                                                                // 0x804d6bc
                                                                fclose((struct _IO_FILE *)n_lines_new);
                                                                fclose((struct _IO_FILE *)f_in);
                                                                n_lines = 0;
                                                                if ((int32_t)line <= -1) {
                                                                    // 0x804d715
                                                                    free((char *)(int32_t)v1[0]);
                                                                    // branch -> 0x804d729
                                                                    // 0x804d729
                                                                    if (*(int32_t *)20 != v15) {
                                                                        // 0x804d735
                                                                        __stack_chk_fail();
                                                                        // branch -> 0x804d73a
                                                                    }
                                                                    // 0x804d73a
                                                                    g3 = v14;
                                                                    return (int32_t)rq;
                                                                }
                                                                v48 = v1[0];
                                                                free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                while ((int32_t)line + 1 > v46) {
                                                                    // 0x804d6e4
                                                                    v48 = v1[0];
                                                                    v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                    free((char *)v47);
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    // continue -> 0x804d6e4
                                                                }
                                                                // 0x804d715
                                                                free((char *)(int32_t)v1[0]);
                                                                // branch -> 0x804d729
                                                                // 0x804d729
                                                                if (*(int32_t *)20 != v15) {
                                                                    // 0x804d735
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804d73a
                                                                }
                                                                // 0x804d73a
                                                                g3 = v14;
                                                                return (int32_t)rq;
                                                            }
                                                        }
                                                        // 0x804d622
                                                        n_lines = 0;
                                                        v45 = v1[0];
                                                        if (*(int32_t *)(int32_t)v45 != 0) {
                                                            format = *(int32_t *)(int32_t)((char)0 + v45);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                // 0x804d5f8
                                                                format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                // continue -> 0x804d5f8
                                                            }
                                                            // 0x804d637
                                                            fflush((struct _IO_FILE *)f_in);
                                                            rewind((struct _IO_FILE *)f_in);
                                                            n_lines_org = 0;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // branch -> 0x804d666
                                                            while (str3 != NULL) {
                                                                // 0x804d666
                                                                n_lines_org = v49 + 1;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // continue -> 0x804d666
                                                            }
                                                            // 0x804d68a
                                                            if (v49 == 0) {
                                                                // 0x804d693
                                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                // branch -> 0x804d6bc
                                                            }
                                                            // 0x804d6bc
                                                            fclose((struct _IO_FILE *)n_lines_new);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if ((int32_t)line <= -1) {
                                                                // 0x804d715
                                                                free((char *)(int32_t)v1[0]);
                                                                // branch -> 0x804d729
                                                                // 0x804d729
                                                                if (*(int32_t *)20 != v15) {
                                                                    // 0x804d735
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804d73a
                                                                }
                                                                // 0x804d73a
                                                                g3 = v14;
                                                                return (int32_t)rq;
                                                            }
                                                            v48 = v1[0];
                                                            free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            while ((int32_t)line + 1 > v46) {
                                                                // 0x804d6e4
                                                                v48 = v1[0];
                                                                v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                free((char *)v47);
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                // continue -> 0x804d6e4
                                                            }
                                                            // 0x804d715
                                                            free((char *)(int32_t)v1[0]);
                                                            // branch -> 0x804d729
                                                            // 0x804d729
                                                            if (*(int32_t *)20 != v15) {
                                                                // 0x804d735
                                                                __stack_chk_fail();
                                                                // branch -> 0x804d73a
                                                            }
                                                            // 0x804d73a
                                                            g3 = v14;
                                                            return (int32_t)rq;
                                                        }
                                                        // 0x804d637
                                                        fflush((struct _IO_FILE *)f_in);
                                                        rewind((struct _IO_FILE *)f_in);
                                                        n_lines_org = 0;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // branch -> 0x804d666
                                                        while (str3 != NULL) {
                                                            // 0x804d666
                                                            n_lines_org = v49 + 1;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // continue -> 0x804d666
                                                        }
                                                        // 0x804d68a
                                                        if (v49 == 0) {
                                                            // 0x804d693
                                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                            // branch -> 0x804d6bc
                                                        }
                                                        // 0x804d6bc
                                                        fclose((struct _IO_FILE *)n_lines_new);
                                                        fclose((struct _IO_FILE *)f_in);
                                                        n_lines = 0;
                                                        if ((int32_t)line > -1) {
                                                            v48 = v1[0];
                                                            free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            while ((int32_t)line + 1 > v46) {
                                                                // 0x804d6e4
                                                                v48 = v1[0];
                                                                v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                free((char *)v47);
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                // continue -> 0x804d6e4
                                                            }
                                                            // 0x804d715
                                                            free((char *)(int32_t)v1[0]);
                                                            // branch -> 0x804d729
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // 0x804d715
                                                        free((char *)(int32_t)v1[0]);
                                                        // branch -> 0x804d729
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x804d4d0
                                                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                    v34 = v1[0];
                                                    v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                    delete_str(v26, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                    pos = v27;
                                                    v35 = v1[0];
                                                    v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                    start = v42;
                                                    v36 = pos;
                                                    v28 = v42 - v36;
                                                    if (v28 <= 2) {
                                                        // 0x804d5cf
                                                        n_lines = 0;
                                                        if (v28 > -1) {
                                                            delete_str(v36, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            while (start - v37 + 1 > v19) {
                                                                // 0x804d5a9
                                                                delete_str(v37, (char **)(int32_t)v1[0]);
                                                                rq = (char *)((int32_t)rq + 1);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                v37 = pos;
                                                                // continue -> 0x804d5a9
                                                            }
                                                            // 0x804d622
                                                            n_lines = 0;
                                                            v45 = v1[0];
                                                            if (*(int32_t *)(int32_t)v45 != 0) {
                                                                format = *(int32_t *)(int32_t)((char)0 + v45);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                    // 0x804d5f8
                                                                    format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                    v43 = n_lines + 1;
                                                                    n_lines = v43;
                                                                    v44 = v1[0];
                                                                    // continue -> 0x804d5f8
                                                                }
                                                                // 0x804d637
                                                                fflush((struct _IO_FILE *)f_in);
                                                                rewind((struct _IO_FILE *)f_in);
                                                                n_lines_org = 0;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // branch -> 0x804d666
                                                                while (str3 != NULL) {
                                                                    // 0x804d666
                                                                    n_lines_org = v49 + 1;
                                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                    v49 = n_lines_org;
                                                                    // continue -> 0x804d666
                                                                }
                                                                // 0x804d68a
                                                                if (v49 == 0) {
                                                                    // 0x804d693
                                                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                    // branch -> 0x804d6bc
                                                                }
                                                                // 0x804d6bc
                                                                fclose((struct _IO_FILE *)n_lines_new);
                                                                fclose((struct _IO_FILE *)f_in);
                                                                n_lines = 0;
                                                                if ((int32_t)line > -1) {
                                                                    v48 = v1[0];
                                                                    free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    while ((int32_t)line + 1 > v46) {
                                                                        // 0x804d6e4
                                                                        v48 = v1[0];
                                                                        v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                        free((char *)v47);
                                                                        v46 = n_lines + 1;
                                                                        n_lines = v46;
                                                                        // continue -> 0x804d6e4
                                                                    }
                                                                    // 0x804d715
                                                                    free((char *)(int32_t)v1[0]);
                                                                    // branch -> 0x804d729
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // 0x804d637
                                                            fflush((struct _IO_FILE *)f_in);
                                                            rewind((struct _IO_FILE *)f_in);
                                                            n_lines_org = 0;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // branch -> 0x804d666
                                                            while (str3 != NULL) {
                                                                // 0x804d666
                                                                n_lines_org = v49 + 1;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // continue -> 0x804d666
                                                            }
                                                            // 0x804d68a
                                                            if (v49 == 0) {
                                                                // 0x804d693
                                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                // branch -> 0x804d6bc
                                                            }
                                                            // 0x804d6bc
                                                            fclose((struct _IO_FILE *)n_lines_new);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if ((int32_t)line > -1) {
                                                                v48 = v1[0];
                                                                free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                while ((int32_t)line + 1 > v46) {
                                                                    // 0x804d6e4
                                                                    v48 = v1[0];
                                                                    v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                    free((char *)v47);
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    // continue -> 0x804d6e4
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                    // 0x804d622
                                                    n_lines = 0;
                                                    v45 = v1[0];
                                                    if (*(int32_t *)(int32_t)v45 != 0) {
                                                        format = *(int32_t *)(int32_t)((char)0 + v45);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                            // 0x804d5f8
                                                            format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            // continue -> 0x804d5f8
                                                        }
                                                        // 0x804d637
                                                        fflush((struct _IO_FILE *)f_in);
                                                        rewind((struct _IO_FILE *)f_in);
                                                        n_lines_org = 0;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // branch -> 0x804d666
                                                        while (str3 != NULL) {
                                                            // 0x804d666
                                                            n_lines_org = v49 + 1;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // continue -> 0x804d666
                                                        }
                                                        // 0x804d68a
                                                        if (v49 == 0) {
                                                            // 0x804d693
                                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                            // branch -> 0x804d6bc
                                                        }
                                                        // 0x804d6bc
                                                        fclose((struct _IO_FILE *)n_lines_new);
                                                        fclose((struct _IO_FILE *)f_in);
                                                        n_lines = 0;
                                                        if ((int32_t)line > -1) {
                                                            v48 = v1[0];
                                                            free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            while ((int32_t)line + 1 > v46) {
                                                                // 0x804d6e4
                                                                v48 = v1[0];
                                                                v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                free((char *)v47);
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                // continue -> 0x804d6e4
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x804d637
                                                    fflush((struct _IO_FILE *)f_in);
                                                    rewind((struct _IO_FILE *)f_in);
                                                    n_lines_org = 0;
                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                    v49 = n_lines_org;
                                                    // branch -> 0x804d666
                                                    while (str3 != NULL) {
                                                        // 0x804d666
                                                        n_lines_org = v49 + 1;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // continue -> 0x804d666
                                                    }
                                                    // 0x804d68a
                                                    if (v49 == 0) {
                                                        // 0x804d693
                                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                        // branch -> 0x804d6bc
                                                    }
                                                    // 0x804d6bc
                                                    fclose((struct _IO_FILE *)n_lines_new);
                                                    fclose((struct _IO_FILE *)f_in);
                                                    n_lines = 0;
                                                    if ((int32_t)line > -1) {
                                                        v48 = v1[0];
                                                        free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                        v46 = n_lines + 1;
                                                        n_lines = v46;
                                                        while ((int32_t)line + 1 > v46) {
                                                            // 0x804d6e4
                                                            v48 = v1[0];
                                                            v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                            free((char *)v47);
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            // continue -> 0x804d6e4
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x804d457
                                            print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                            // branch -> 0x804d729
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d3fa
                                    print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                                    // branch -> 0x804d729
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804d1f8
                    n_lines = 0;
                    if (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                        v20 = (char)(4 * n_lines) + v1[0];
                        g3 = v20;
                        len = strlen((char *)&str5);
                        *(int32_t *)v20 = (int32_t)malloc(len + 1);
                        v38 = v1[0];
                        str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                        strcpy((char *)str6, (char *)&str5);
                        n_lines++;
                        while (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                            // 0x804d1a2
                            v20 = (char)(4 * n_lines) + v1[0];
                            g3 = v20;
                            len = strlen((char *)&str5);
                            *(int32_t *)v20 = (int32_t)malloc(len + 1);
                            v38 = v1[0];
                            str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                            strcpy((char *)str6, (char *)&str5);
                            n_lines++;
                            // continue -> 0x804d1a2
                        }
                        // 0x804d21c
                        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                        v29 = v1[0];
                        v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                        if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                            // 0x804d26c
                            print_warning("could not find uninstall information in 'menu.tcl'.\n");
                            // branch -> 0x804d729
                        } else {
                            // 0x804d282
                            str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                            str8 = (int32_t)strchr((char *)str7, 34) + 1;
                            end_sub = str8;
                            strchr((char *)str8, 34);
                            strchr((char *)str8, 34);
                            strcpy(str9, (char *)end_sub);
                            v1[3] = 0;
                            v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                            pos = v22;
                            v30 = v1[0];
                            v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                            start = v23 - 1;
                            if (v23 == 0) {
                                // 0x804d357
                                start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                                // branch -> 0x804d37b
                            }
                            // 0x804d37b
                            if (pos == -1) {
                                // 0x804d384
                                print_warning("menu 'Xtns' does not exist.\n");
                                // branch -> 0x804d729
                            } else {
                                // 0x804d39a
                                sprintf((char *)&str5, "{cascad \"%s\"", str9);
                                v31 = v1[0];
                                v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                                end = v24;
                                if (v24 != -1) {
                                    // 0x804d3ec
                                    if (v24 <= start) {
                                        // 0x804d41a
                                        v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                        start_sub = v25;
                                        if (v25 != -1) {
                                            // 0x804d449
                                            if (v25 <= start) {
                                                // 0x804d477
                                                rq = NULL;
                                                n_lines = 0;
                                                v33 = end;
                                                if (v25 - v33 > -1) {
                                                    delete_str(v33, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v18 = n_lines + 1;
                                                    n_lines = v18;
                                                    v32 = end;
                                                    while (start_sub - v32 + 1 > v18) {
                                                        // 0x804d48d
                                                        delete_str(v32, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v18 = n_lines + 1;
                                                        n_lines = v18;
                                                        v32 = end;
                                                        // continue -> 0x804d48d
                                                    }
                                                    // 0x804d4d0
                                                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                    v34 = v1[0];
                                                    v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                    delete_str(v26, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                    pos = v27;
                                                    v35 = v1[0];
                                                    v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                    start = v42;
                                                    v36 = pos;
                                                    v28 = v42 - v36;
                                                    if (v28 <= 2) {
                                                        // 0x804d5cf
                                                        n_lines = 0;
                                                        if (v28 > -1) {
                                                            delete_str(v36, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            while (start - v37 + 1 > v19) {
                                                                // 0x804d5a9
                                                                delete_str(v37, (char **)(int32_t)v1[0]);
                                                                rq = (char *)((int32_t)rq + 1);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                v37 = pos;
                                                                // continue -> 0x804d5a9
                                                            }
                                                            // 0x804d622
                                                            n_lines = 0;
                                                            v45 = v1[0];
                                                            if (*(int32_t *)(int32_t)v45 != 0) {
                                                                format = *(int32_t *)(int32_t)((char)0 + v45);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                    // 0x804d5f8
                                                                    format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                    v43 = n_lines + 1;
                                                                    n_lines = v43;
                                                                    v44 = v1[0];
                                                                    // continue -> 0x804d5f8
                                                                }
                                                                // 0x804d637
                                                                fflush((struct _IO_FILE *)f_in);
                                                                rewind((struct _IO_FILE *)f_in);
                                                                n_lines_org = 0;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // branch -> 0x804d666
                                                                while (str3 != NULL) {
                                                                    // 0x804d666
                                                                    n_lines_org = v49 + 1;
                                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                    v49 = n_lines_org;
                                                                    // continue -> 0x804d666
                                                                }
                                                                // 0x804d68a
                                                                if (v49 == 0) {
                                                                    // 0x804d693
                                                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                    // branch -> 0x804d6bc
                                                                }
                                                                // 0x804d6bc
                                                                fclose((struct _IO_FILE *)n_lines_new);
                                                                fclose((struct _IO_FILE *)f_in);
                                                                n_lines = 0;
                                                                if ((int32_t)line > -1) {
                                                                    v48 = v1[0];
                                                                    free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    while ((int32_t)line + 1 > v46) {
                                                                        // 0x804d6e4
                                                                        v48 = v1[0];
                                                                        v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                        free((char *)v47);
                                                                        v46 = n_lines + 1;
                                                                        n_lines = v46;
                                                                        // continue -> 0x804d6e4
                                                                    }
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // 0x804d637
                                                            fflush((struct _IO_FILE *)f_in);
                                                            rewind((struct _IO_FILE *)f_in);
                                                            n_lines_org = 0;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // branch -> 0x804d666
                                                            while (str3 != NULL) {
                                                                // 0x804d666
                                                                n_lines_org = v49 + 1;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // continue -> 0x804d666
                                                            }
                                                            // 0x804d68a
                                                            if (v49 == 0) {
                                                                // 0x804d693
                                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                // branch -> 0x804d6bc
                                                            }
                                                            // 0x804d6bc
                                                            fclose((struct _IO_FILE *)n_lines_new);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if ((int32_t)line > -1) {
                                                                v48 = v1[0];
                                                                free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                while ((int32_t)line + 1 > v46) {
                                                                    // 0x804d6e4
                                                                    v48 = v1[0];
                                                                    v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                    free((char *)v47);
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    // continue -> 0x804d6e4
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                    // 0x804d622
                                                    n_lines = 0;
                                                    v45 = v1[0];
                                                    if (*(int32_t *)(int32_t)v45 != 0) {
                                                        format = *(int32_t *)(int32_t)((char)0 + v45);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                            // 0x804d5f8
                                                            format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            // continue -> 0x804d5f8
                                                        }
                                                        // 0x804d637
                                                        fflush((struct _IO_FILE *)f_in);
                                                        rewind((struct _IO_FILE *)f_in);
                                                        n_lines_org = 0;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // branch -> 0x804d666
                                                        while (str3 != NULL) {
                                                            // 0x804d666
                                                            n_lines_org = v49 + 1;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // continue -> 0x804d666
                                                        }
                                                        // 0x804d68a
                                                        if (v49 == 0) {
                                                            // 0x804d693
                                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                            // branch -> 0x804d6bc
                                                        }
                                                        // 0x804d6bc
                                                        fclose((struct _IO_FILE *)n_lines_new);
                                                        fclose((struct _IO_FILE *)f_in);
                                                        n_lines = 0;
                                                        if ((int32_t)line > -1) {
                                                            v48 = v1[0];
                                                            free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            while ((int32_t)line + 1 > v46) {
                                                                // 0x804d6e4
                                                                v48 = v1[0];
                                                                v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                free((char *)v47);
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                // continue -> 0x804d6e4
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x804d637
                                                    fflush((struct _IO_FILE *)f_in);
                                                    rewind((struct _IO_FILE *)f_in);
                                                    n_lines_org = 0;
                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                    v49 = n_lines_org;
                                                    // branch -> 0x804d666
                                                    while (str3 != NULL) {
                                                        // 0x804d666
                                                        n_lines_org = v49 + 1;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // continue -> 0x804d666
                                                    }
                                                    // 0x804d68a
                                                    if (v49 == 0) {
                                                        // 0x804d693
                                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                        // branch -> 0x804d6bc
                                                    }
                                                    // 0x804d6bc
                                                    fclose((struct _IO_FILE *)n_lines_new);
                                                    fclose((struct _IO_FILE *)f_in);
                                                    n_lines = 0;
                                                    if ((int32_t)line > -1) {
                                                        v48 = v1[0];
                                                        free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                        v46 = n_lines + 1;
                                                        n_lines = v46;
                                                        while ((int32_t)line + 1 > v46) {
                                                            // 0x804d6e4
                                                            v48 = v1[0];
                                                            v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                            free((char *)v47);
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            // continue -> 0x804d6e4
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x804d4d0
                                                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                v34 = v1[0];
                                                v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                delete_str(v26, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                pos = v27;
                                                v35 = v1[0];
                                                v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                start = v42;
                                                v36 = pos;
                                                v28 = v42 - v36;
                                                if (v28 <= 2) {
                                                    // 0x804d5cf
                                                    n_lines = 0;
                                                    if (v28 > -1) {
                                                        delete_str(v36, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        while (start - v37 + 1 > v19) {
                                                            // 0x804d5a9
                                                            delete_str(v37, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            // continue -> 0x804d5a9
                                                        }
                                                        // 0x804d622
                                                        n_lines = 0;
                                                        v45 = v1[0];
                                                        if (*(int32_t *)(int32_t)v45 != 0) {
                                                            format = *(int32_t *)(int32_t)((char)0 + v45);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                // 0x804d5f8
                                                                format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                // continue -> 0x804d5f8
                                                            }
                                                            // 0x804d637
                                                            fflush((struct _IO_FILE *)f_in);
                                                            rewind((struct _IO_FILE *)f_in);
                                                            n_lines_org = 0;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // branch -> 0x804d666
                                                            while (str3 != NULL) {
                                                                // 0x804d666
                                                                n_lines_org = v49 + 1;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // continue -> 0x804d666
                                                            }
                                                            // 0x804d68a
                                                            if (v49 == 0) {
                                                                // 0x804d693
                                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                // branch -> 0x804d6bc
                                                            }
                                                            // 0x804d6bc
                                                            fclose((struct _IO_FILE *)n_lines_new);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if ((int32_t)line > -1) {
                                                                v48 = v1[0];
                                                                free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                while ((int32_t)line + 1 > v46) {
                                                                    // 0x804d6e4
                                                                    v48 = v1[0];
                                                                    v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                    free((char *)v47);
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    // continue -> 0x804d6e4
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // 0x804d637
                                                        fflush((struct _IO_FILE *)f_in);
                                                        rewind((struct _IO_FILE *)f_in);
                                                        n_lines_org = 0;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // branch -> 0x804d666
                                                        while (str3 != NULL) {
                                                            // 0x804d666
                                                            n_lines_org = v49 + 1;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // continue -> 0x804d666
                                                        }
                                                        // 0x804d68a
                                                        if (v49 == 0) {
                                                            // 0x804d693
                                                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                            memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                            // branch -> 0x804d6bc
                                                        }
                                                        // 0x804d6bc
                                                        fclose((struct _IO_FILE *)n_lines_new);
                                                        fclose((struct _IO_FILE *)f_in);
                                                        n_lines = 0;
                                                        if ((int32_t)line > -1) {
                                                            v48 = v1[0];
                                                            free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            while ((int32_t)line + 1 > v46) {
                                                                // 0x804d6e4
                                                                v48 = v1[0];
                                                                v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                free((char *)v47);
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                // continue -> 0x804d6e4
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // 0x804d622
                                                n_lines = 0;
                                                v45 = v1[0];
                                                if (*(int32_t *)(int32_t)v45 != 0) {
                                                    format = *(int32_t *)(int32_t)((char)0 + v45);
                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                    v43 = n_lines + 1;
                                                    n_lines = v43;
                                                    v44 = v1[0];
                                                    while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                        // 0x804d5f8
                                                        format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        // continue -> 0x804d5f8
                                                    }
                                                    // 0x804d637
                                                    fflush((struct _IO_FILE *)f_in);
                                                    rewind((struct _IO_FILE *)f_in);
                                                    n_lines_org = 0;
                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                    v49 = n_lines_org;
                                                    // branch -> 0x804d666
                                                    while (str3 != NULL) {
                                                        // 0x804d666
                                                        n_lines_org = v49 + 1;
                                                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                        v49 = n_lines_org;
                                                        // continue -> 0x804d666
                                                    }
                                                    // 0x804d68a
                                                    if (v49 == 0) {
                                                        // 0x804d693
                                                        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                        memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                        // branch -> 0x804d6bc
                                                    }
                                                    // 0x804d6bc
                                                    fclose((struct _IO_FILE *)n_lines_new);
                                                    fclose((struct _IO_FILE *)f_in);
                                                    n_lines = 0;
                                                    if ((int32_t)line > -1) {
                                                        v48 = v1[0];
                                                        free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                        v46 = n_lines + 1;
                                                        n_lines = v46;
                                                        while ((int32_t)line + 1 > v46) {
                                                            // 0x804d6e4
                                                            v48 = v1[0];
                                                            v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                            free((char *)v47);
                                                            v46 = n_lines + 1;
                                                            n_lines = v46;
                                                            // continue -> 0x804d6e4
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x804d637
                                                fflush((struct _IO_FILE *)f_in);
                                                rewind((struct _IO_FILE *)f_in);
                                                n_lines_org = 0;
                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                v49 = n_lines_org;
                                                // branch -> 0x804d666
                                                while (str3 != NULL) {
                                                    // 0x804d666
                                                    n_lines_org = v49 + 1;
                                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                    v49 = n_lines_org;
                                                    // continue -> 0x804d666
                                                }
                                                // 0x804d68a
                                                if (v49 == 0) {
                                                    // 0x804d693
                                                    print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                    memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                    // branch -> 0x804d6bc
                                                }
                                                // 0x804d6bc
                                                fclose((struct _IO_FILE *)n_lines_new);
                                                fclose((struct _IO_FILE *)f_in);
                                                n_lines = 0;
                                                if ((int32_t)line > -1) {
                                                    v48 = v1[0];
                                                    free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                    v46 = n_lines + 1;
                                                    n_lines = v46;
                                                    while ((int32_t)line + 1 > v46) {
                                                        // 0x804d6e4
                                                        v48 = v1[0];
                                                        v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                        free((char *)v47);
                                                        v46 = n_lines + 1;
                                                        n_lines = v46;
                                                        // continue -> 0x804d6e4
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804d457
                                        print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                        // branch -> 0x804d729
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804d3fa
                                print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                                // branch -> 0x804d729
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804d21c
                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                    v29 = v1[0];
                    v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                    if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                        // 0x804d26c
                        print_warning("could not find uninstall information in 'menu.tcl'.\n");
                        // branch -> 0x804d729
                    } else {
                        // 0x804d282
                        str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                        str8 = (int32_t)strchr((char *)str7, 34) + 1;
                        end_sub = str8;
                        strchr((char *)str8, 34);
                        strchr((char *)str8, 34);
                        strcpy(str9, (char *)end_sub);
                        v1[3] = 0;
                        v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                        pos = v22;
                        v30 = v1[0];
                        v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                        start = v23 - 1;
                        if (v23 == 0) {
                            // 0x804d357
                            start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                            // branch -> 0x804d37b
                        }
                        // 0x804d37b
                        if (pos == -1) {
                            // 0x804d384
                            print_warning("menu 'Xtns' does not exist.\n");
                            // branch -> 0x804d729
                        } else {
                            // 0x804d39a
                            sprintf((char *)&str5, "{cascad \"%s\"", str9);
                            v31 = v1[0];
                            v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                            end = v24;
                            if (v24 != -1) {
                                // 0x804d3ec
                                if (v24 <= start) {
                                    // 0x804d41a
                                    v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                    start_sub = v25;
                                    if (v25 != -1) {
                                        // 0x804d449
                                        if (v25 <= start) {
                                            // 0x804d477
                                            rq = NULL;
                                            n_lines = 0;
                                            v33 = end;
                                            if (v25 - v33 > -1) {
                                                delete_str(v33, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v18 = n_lines + 1;
                                                n_lines = v18;
                                                v32 = end;
                                                while (start_sub - v32 + 1 > v18) {
                                                    // 0x804d48d
                                                    delete_str(v32, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v18 = n_lines + 1;
                                                    n_lines = v18;
                                                    v32 = end;
                                                    // continue -> 0x804d48d
                                                }
                                                // 0x804d4d0
                                                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                v34 = v1[0];
                                                v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                delete_str(v26, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                pos = v27;
                                                v35 = v1[0];
                                                v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                start = v42;
                                                v36 = pos;
                                                v28 = v42 - v36;
                                                if (v28 <= 2) {
                                                    // 0x804d5cf
                                                    n_lines = 0;
                                                    if (v28 > -1) {
                                                        delete_str(v36, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        while (start - v37 + 1 > v19) {
                                                            // 0x804d5a9
                                                            delete_str(v37, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            // continue -> 0x804d5a9
                                                        }
                                                        // 0x804d622
                                                        n_lines = 0;
                                                        v45 = v1[0];
                                                        if (*(int32_t *)(int32_t)v45 != 0) {
                                                            format = *(int32_t *)(int32_t)((char)0 + v45);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                // 0x804d5f8
                                                                format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                // continue -> 0x804d5f8
                                                            }
                                                            // 0x804d637
                                                            fflush((struct _IO_FILE *)f_in);
                                                            rewind((struct _IO_FILE *)f_in);
                                                            n_lines_org = 0;
                                                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                            v49 = n_lines_org;
                                                            // branch -> 0x804d666
                                                            while (str3 != NULL) {
                                                                // 0x804d666
                                                                n_lines_org = v49 + 1;
                                                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_in);
                                                                v49 = n_lines_org;
                                                                // continue -> 0x804d666
                                                            }
                                                            // 0x804d68a
                                                            if (v49 == 0) {
                                                                // 0x804d693
                                                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                                                memcpy(GISMAN_CMD, (char *)&g8, 1);
                                                                // branch -> 0x804d6bc
                                                            }
                                                            // 0x804d6bc
                                                            fclose((struct _IO_FILE *)n_lines_new);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if ((int32_t)line > -1) {
                                                                v48 = v1[0];
                                                                free((char *)*(int32_t *)(int32_t)((char)0 + v48));
                                                                v46 = n_lines + 1;
                                                                n_lines = v46;
                                                                while ((int32_t)line + 1 > v46) {
                                                                    // 0x804d6e4
                                                                    v48 = v1[0];
                                                                    v47 = *(int32_t *)(int32_t)((char)(4 * v46) + v48);
                                                                    free((char *)v47);
                                                                    v46 = n_lines + 1;
                                                                    n_lines = v46;
                                                                    // continue -> 0x804d6e4
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // 0x804d622
                                                n_lines = 0;
                                                v45 = v1[0];
                                                if (*(int32_t *)(int32_t)v45 != 0) {
                                                    format = *(int32_t *)(int32_t)((char)0 + v45);
                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                    v43 = n_lines + 1;
                                                    n_lines = v43;
                                                    v44 = v1[0];
                                                    while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                        // 0x804d5f8
                                                        format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        // continue -> 0x804d5f8
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // 0x804d4d0
                                            sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                            v34 = v1[0];
                                            v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                            delete_str(v26, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                            pos = v27;
                                            v35 = v1[0];
                                            v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                            start = v42;
                                            v36 = pos;
                                            v28 = v42 - v36;
                                            if (v28 <= 2) {
                                                // 0x804d5cf
                                                n_lines = 0;
                                                if (v28 > -1) {
                                                    delete_str(v36, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    v37 = pos;
                                                    while (start - v37 + 1 > v19) {
                                                        // 0x804d5a9
                                                        delete_str(v37, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        // continue -> 0x804d5a9
                                                    }
                                                    // 0x804d622
                                                    n_lines = 0;
                                                    v45 = v1[0];
                                                    if (*(int32_t *)(int32_t)v45 != 0) {
                                                        format = *(int32_t *)(int32_t)((char)0 + v45);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                            // 0x804d5f8
                                                            format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            // continue -> 0x804d5f8
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x804d622
                                            n_lines = 0;
                                            v45 = v1[0];
                                            if (*(int32_t *)(int32_t)v45 != 0) {
                                                format = *(int32_t *)(int32_t)((char)0 + v45);
                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                v43 = n_lines + 1;
                                                n_lines = v43;
                                                v44 = v1[0];
                                                while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                    // 0x804d5f8
                                                    format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                    v43 = n_lines + 1;
                                                    n_lines = v43;
                                                    v44 = v1[0];
                                                    // continue -> 0x804d5f8
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d457
                                    print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                    // branch -> 0x804d729
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804d3fa
                            print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                            // branch -> 0x804d729
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804d111
            if (v41 == NULL) {
                // 0x804d11a
                // branch -> 0x804d729
            } else {
                // 0x804d124
                rewind((struct _IO_FILE *)n_lines_new);
                mem = (int32_t)calloc((int32_t)line + 1, 4);
                v1[0] = mem;
                n_lines = 0;
                if ((int32_t)line > -1) {
                    // 0x804d169
                    *(int32_t *)(int32_t)mem = 0;
                    v17 = n_lines + 1;
                    n_lines = v17;
                    if ((int32_t)line + 1 > v17) {
                        *(int32_t *)(int32_t)((char)(4 * v17) + v1[0]) = 0;
                        v16 = n_lines + 1;
                        n_lines = v16;
                        while ((int32_t)line + 1 > v16) {
                            // 0x804d169
                            *(int32_t *)(int32_t)((char)(4 * v16) + v1[0]) = 0;
                            v16 = n_lines + 1;
                            n_lines = v16;
                            // continue -> 0x804d169
                        }
                        // 0x804d1f8
                        n_lines = 0;
                        if (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                            v20 = (char)(4 * n_lines) + v1[0];
                            g3 = v20;
                            len = strlen((char *)&str5);
                            *(int32_t *)v20 = (int32_t)malloc(len + 1);
                            v38 = v1[0];
                            str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                            strcpy((char *)str6, (char *)&str5);
                            n_lines++;
                            while (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                                // 0x804d1a2
                                v20 = (char)(4 * n_lines) + v1[0];
                                g3 = v20;
                                len = strlen((char *)&str5);
                                *(int32_t *)v20 = (int32_t)malloc(len + 1);
                                v38 = v1[0];
                                str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                                strcpy((char *)str6, (char *)&str5);
                                n_lines++;
                                // continue -> 0x804d1a2
                            }
                            // 0x804d21c
                            sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                            v29 = v1[0];
                            v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                            if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                                // 0x804d26c
                                print_warning("could not find uninstall information in 'menu.tcl'.\n");
                                // branch -> 0x804d729
                            } else {
                                // 0x804d282
                                str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                                str8 = (int32_t)strchr((char *)str7, 34) + 1;
                                end_sub = str8;
                                strchr((char *)str8, 34);
                                strchr((char *)str8, 34);
                                strcpy(str9, (char *)end_sub);
                                v1[3] = 0;
                                v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                pos = v22;
                                v30 = v1[0];
                                v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                                start = v23 - 1;
                                if (v23 == 0) {
                                    // 0x804d357
                                    start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                                    // branch -> 0x804d37b
                                }
                                // 0x804d37b
                                if (pos == -1) {
                                    // 0x804d384
                                    print_warning("menu 'Xtns' does not exist.\n");
                                    // branch -> 0x804d729
                                } else {
                                    // 0x804d39a
                                    sprintf((char *)&str5, "{cascad \"%s\"", str9);
                                    v31 = v1[0];
                                    v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                                    end = v24;
                                    if (v24 != -1) {
                                        // 0x804d3ec
                                        if (v24 <= start) {
                                            // 0x804d41a
                                            v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                            start_sub = v25;
                                            if (v25 != -1) {
                                                // 0x804d449
                                                if (v25 <= start) {
                                                    // 0x804d477
                                                    rq = NULL;
                                                    n_lines = 0;
                                                    v33 = end;
                                                    if (v25 - v33 > -1) {
                                                        delete_str(v33, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v18 = n_lines + 1;
                                                        n_lines = v18;
                                                        v32 = end;
                                                        while (start_sub - v32 + 1 > v18) {
                                                            // 0x804d48d
                                                            delete_str(v32, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v18 = n_lines + 1;
                                                            n_lines = v18;
                                                            v32 = end;
                                                            // continue -> 0x804d48d
                                                        }
                                                        // 0x804d4d0
                                                        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                        v34 = v1[0];
                                                        v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                        delete_str(v26, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                        pos = v27;
                                                        v35 = v1[0];
                                                        v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                        start = v42;
                                                        v36 = pos;
                                                        v28 = v42 - v36;
                                                        if (v28 <= 2) {
                                                            // 0x804d5cf
                                                            n_lines = 0;
                                                            if (v28 > -1) {
                                                                delete_str(v36, (char **)(int32_t)v1[0]);
                                                                rq = (char *)((int32_t)rq + 1);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                v37 = pos;
                                                                while (start - v37 + 1 > v19) {
                                                                    // 0x804d5a9
                                                                    delete_str(v37, (char **)(int32_t)v1[0]);
                                                                    rq = (char *)((int32_t)rq + 1);
                                                                    v19 = n_lines + 1;
                                                                    n_lines = v19;
                                                                    v37 = pos;
                                                                    // continue -> 0x804d5a9
                                                                }
                                                                // 0x804d622
                                                                n_lines = 0;
                                                                v45 = v1[0];
                                                                if (*(int32_t *)(int32_t)v45 != 0) {
                                                                    format = *(int32_t *)(int32_t)((char)0 + v45);
                                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                    v43 = n_lines + 1;
                                                                    n_lines = v43;
                                                                    v44 = v1[0];
                                                                    while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                        // 0x804d5f8
                                                                        format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                        v43 = n_lines + 1;
                                                                        n_lines = v43;
                                                                        v44 = v1[0];
                                                                        // continue -> 0x804d5f8
                                                                    }
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                        // 0x804d622
                                                        n_lines = 0;
                                                        v45 = v1[0];
                                                        if (*(int32_t *)(int32_t)v45 != 0) {
                                                            format = *(int32_t *)(int32_t)((char)0 + v45);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                // 0x804d5f8
                                                                format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                // continue -> 0x804d5f8
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x804d4d0
                                                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                    v34 = v1[0];
                                                    v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                    delete_str(v26, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                    pos = v27;
                                                    v35 = v1[0];
                                                    v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                    start = v42;
                                                    v36 = pos;
                                                    v28 = v42 - v36;
                                                    if (v28 <= 2) {
                                                        // 0x804d5cf
                                                        n_lines = 0;
                                                        if (v28 > -1) {
                                                            delete_str(v36, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            while (start - v37 + 1 > v19) {
                                                                // 0x804d5a9
                                                                delete_str(v37, (char **)(int32_t)v1[0]);
                                                                rq = (char *)((int32_t)rq + 1);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                v37 = pos;
                                                                // continue -> 0x804d5a9
                                                            }
                                                            // 0x804d622
                                                            n_lines = 0;
                                                            v45 = v1[0];
                                                            if (*(int32_t *)(int32_t)v45 != 0) {
                                                                format = *(int32_t *)(int32_t)((char)0 + v45);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                    // 0x804d5f8
                                                                    format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                    v43 = n_lines + 1;
                                                                    n_lines = v43;
                                                                    v44 = v1[0];
                                                                    // continue -> 0x804d5f8
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                    // 0x804d622
                                                    n_lines = 0;
                                                    v45 = v1[0];
                                                    if (*(int32_t *)(int32_t)v45 != 0) {
                                                        format = *(int32_t *)(int32_t)((char)0 + v45);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                            // 0x804d5f8
                                                            format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            // continue -> 0x804d5f8
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x804d457
                                            print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                            // branch -> 0x804d729
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d3fa
                                    print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                                    // branch -> 0x804d729
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804d21c
                        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                        v29 = v1[0];
                        v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                        if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                            // 0x804d26c
                            print_warning("could not find uninstall information in 'menu.tcl'.\n");
                            // branch -> 0x804d729
                        } else {
                            // 0x804d282
                            str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                            str8 = (int32_t)strchr((char *)str7, 34) + 1;
                            end_sub = str8;
                            strchr((char *)str8, 34);
                            strchr((char *)str8, 34);
                            strcpy(str9, (char *)end_sub);
                            v1[3] = 0;
                            v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                            pos = v22;
                            v30 = v1[0];
                            v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                            start = v23 - 1;
                            if (v23 == 0) {
                                // 0x804d357
                                start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                                // branch -> 0x804d37b
                            }
                            // 0x804d37b
                            if (pos == -1) {
                                // 0x804d384
                                print_warning("menu 'Xtns' does not exist.\n");
                                // branch -> 0x804d729
                            } else {
                                // 0x804d39a
                                sprintf((char *)&str5, "{cascad \"%s\"", str9);
                                v31 = v1[0];
                                v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                                end = v24;
                                if (v24 != -1) {
                                    // 0x804d3ec
                                    if (v24 <= start) {
                                        // 0x804d41a
                                        v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                        start_sub = v25;
                                        if (v25 != -1) {
                                            // 0x804d449
                                            if (v25 <= start) {
                                                // 0x804d477
                                                rq = NULL;
                                                n_lines = 0;
                                                v33 = end;
                                                if (v25 - v33 > -1) {
                                                    delete_str(v33, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v18 = n_lines + 1;
                                                    n_lines = v18;
                                                    v32 = end;
                                                    while (start_sub - v32 + 1 > v18) {
                                                        // 0x804d48d
                                                        delete_str(v32, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v18 = n_lines + 1;
                                                        n_lines = v18;
                                                        v32 = end;
                                                        // continue -> 0x804d48d
                                                    }
                                                    // 0x804d4d0
                                                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                    v34 = v1[0];
                                                    v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                    delete_str(v26, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                    pos = v27;
                                                    v35 = v1[0];
                                                    v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                    start = v42;
                                                    v36 = pos;
                                                    v28 = v42 - v36;
                                                    if (v28 <= 2) {
                                                        // 0x804d5cf
                                                        n_lines = 0;
                                                        if (v28 > -1) {
                                                            delete_str(v36, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            while (start - v37 + 1 > v19) {
                                                                // 0x804d5a9
                                                                delete_str(v37, (char **)(int32_t)v1[0]);
                                                                rq = (char *)((int32_t)rq + 1);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                v37 = pos;
                                                                // continue -> 0x804d5a9
                                                            }
                                                            // 0x804d622
                                                            n_lines = 0;
                                                            v45 = v1[0];
                                                            if (*(int32_t *)(int32_t)v45 != 0) {
                                                                format = *(int32_t *)(int32_t)((char)0 + v45);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                    // 0x804d5f8
                                                                    format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                    v43 = n_lines + 1;
                                                                    n_lines = v43;
                                                                    v44 = v1[0];
                                                                    // continue -> 0x804d5f8
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                    // 0x804d622
                                                    n_lines = 0;
                                                    v45 = v1[0];
                                                    if (*(int32_t *)(int32_t)v45 != 0) {
                                                        format = *(int32_t *)(int32_t)((char)0 + v45);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                            // 0x804d5f8
                                                            format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            // continue -> 0x804d5f8
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x804d4d0
                                                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                v34 = v1[0];
                                                v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                delete_str(v26, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                pos = v27;
                                                v35 = v1[0];
                                                v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                start = v42;
                                                v36 = pos;
                                                v28 = v42 - v36;
                                                if (v28 <= 2) {
                                                    // 0x804d5cf
                                                    n_lines = 0;
                                                    if (v28 > -1) {
                                                        delete_str(v36, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        while (start - v37 + 1 > v19) {
                                                            // 0x804d5a9
                                                            delete_str(v37, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            // continue -> 0x804d5a9
                                                        }
                                                        // 0x804d622
                                                        n_lines = 0;
                                                        v45 = v1[0];
                                                        if (*(int32_t *)(int32_t)v45 != 0) {
                                                            format = *(int32_t *)(int32_t)((char)0 + v45);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                // 0x804d5f8
                                                                format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                // continue -> 0x804d5f8
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // 0x804d622
                                                n_lines = 0;
                                                v45 = v1[0];
                                                if (*(int32_t *)(int32_t)v45 != 0) {
                                                    format = *(int32_t *)(int32_t)((char)0 + v45);
                                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                    v43 = n_lines + 1;
                                                    n_lines = v43;
                                                    v44 = v1[0];
                                                    while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                        // 0x804d5f8
                                                        format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v43 = n_lines + 1;
                                                        n_lines = v43;
                                                        v44 = v1[0];
                                                        // continue -> 0x804d5f8
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804d457
                                        print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                        // branch -> 0x804d729
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804d3fa
                                print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                                // branch -> 0x804d729
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x804d1f8
                n_lines = 0;
                if (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                    v20 = (char)(4 * n_lines) + v1[0];
                    g3 = v20;
                    len = strlen((char *)&str5);
                    *(int32_t *)v20 = (int32_t)malloc(len + 1);
                    v38 = v1[0];
                    str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                    strcpy((char *)str6, (char *)&str5);
                    n_lines++;
                    while (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                        // 0x804d1a2
                        v20 = (char)(4 * n_lines) + v1[0];
                        g3 = v20;
                        len = strlen((char *)&str5);
                        *(int32_t *)v20 = (int32_t)malloc(len + 1);
                        v38 = v1[0];
                        str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                        strcpy((char *)str6, (char *)&str5);
                        n_lines++;
                        // continue -> 0x804d1a2
                    }
                    // 0x804d21c
                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                    v29 = v1[0];
                    v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                    if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                        // 0x804d26c
                        print_warning("could not find uninstall information in 'menu.tcl'.\n");
                        // branch -> 0x804d729
                    } else {
                        // 0x804d282
                        str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                        str8 = (int32_t)strchr((char *)str7, 34) + 1;
                        end_sub = str8;
                        strchr((char *)str8, 34);
                        strchr((char *)str8, 34);
                        strcpy(str9, (char *)end_sub);
                        v1[3] = 0;
                        v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                        pos = v22;
                        v30 = v1[0];
                        v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                        start = v23 - 1;
                        if (v23 == 0) {
                            // 0x804d357
                            start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                            // branch -> 0x804d37b
                        }
                        // 0x804d37b
                        if (pos == -1) {
                            // 0x804d384
                            print_warning("menu 'Xtns' does not exist.\n");
                            // branch -> 0x804d729
                        } else {
                            // 0x804d39a
                            sprintf((char *)&str5, "{cascad \"%s\"", str9);
                            v31 = v1[0];
                            v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                            end = v24;
                            if (v24 != -1) {
                                // 0x804d3ec
                                if (v24 <= start) {
                                    // 0x804d41a
                                    v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                    start_sub = v25;
                                    if (v25 != -1) {
                                        // 0x804d449
                                        if (v25 <= start) {
                                            // 0x804d477
                                            rq = NULL;
                                            n_lines = 0;
                                            v33 = end;
                                            if (v25 - v33 > -1) {
                                                delete_str(v33, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v18 = n_lines + 1;
                                                n_lines = v18;
                                                v32 = end;
                                                while (start_sub - v32 + 1 > v18) {
                                                    // 0x804d48d
                                                    delete_str(v32, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v18 = n_lines + 1;
                                                    n_lines = v18;
                                                    v32 = end;
                                                    // continue -> 0x804d48d
                                                }
                                                // 0x804d4d0
                                                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                v34 = v1[0];
                                                v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                delete_str(v26, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                pos = v27;
                                                v35 = v1[0];
                                                v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                start = v42;
                                                v36 = pos;
                                                v28 = v42 - v36;
                                                if (v28 <= 2) {
                                                    // 0x804d5cf
                                                    n_lines = 0;
                                                    if (v28 > -1) {
                                                        delete_str(v36, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        while (start - v37 + 1 > v19) {
                                                            // 0x804d5a9
                                                            delete_str(v37, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            // continue -> 0x804d5a9
                                                        }
                                                        // 0x804d622
                                                        n_lines = 0;
                                                        v45 = v1[0];
                                                        if (*(int32_t *)(int32_t)v45 != 0) {
                                                            format = *(int32_t *)(int32_t)((char)0 + v45);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v43 = n_lines + 1;
                                                            n_lines = v43;
                                                            v44 = v1[0];
                                                            while (*(int32_t *)(int32_t)((char)(4 * v43) + v44) != 0) {
                                                                // 0x804d5f8
                                                                format = *(int32_t *)(int32_t)((char)(4 * v43) + v44);
                                                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                                v43 = n_lines + 1;
                                                                n_lines = v43;
                                                                v44 = v1[0];
                                                                // continue -> 0x804d5f8
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // 0x804d4d0
                                            sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                            v34 = v1[0];
                                            v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                            delete_str(v26, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                            pos = v27;
                                            v35 = v1[0];
                                            v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                            start = v42;
                                            v36 = pos;
                                            v28 = v42 - v36;
                                            if (v28 <= 2) {
                                                // 0x804d5cf
                                                n_lines = 0;
                                                if (v28 > -1) {
                                                    delete_str(v36, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    v37 = pos;
                                                    while (start - v37 + 1 > v19) {
                                                        // 0x804d5a9
                                                        delete_str(v37, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        // continue -> 0x804d5a9
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d457
                                    print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                    // branch -> 0x804d729
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804d3fa
                            print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                            // branch -> 0x804d729
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804d21c
                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                v29 = v1[0];
                v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                    // 0x804d26c
                    print_warning("could not find uninstall information in 'menu.tcl'.\n");
                    // branch -> 0x804d729
                } else {
                    // 0x804d282
                    str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                    str8 = (int32_t)strchr((char *)str7, 34) + 1;
                    end_sub = str8;
                    strchr((char *)str8, 34);
                    strchr((char *)str8, 34);
                    strcpy(str9, (char *)end_sub);
                    v1[3] = 0;
                    v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                    pos = v22;
                    v30 = v1[0];
                    v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                    start = v23 - 1;
                    if (v23 == 0) {
                        // 0x804d357
                        start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                        // branch -> 0x804d37b
                    }
                    // 0x804d37b
                    if (pos == -1) {
                        // 0x804d384
                        print_warning("menu 'Xtns' does not exist.\n");
                        // branch -> 0x804d729
                    } else {
                        // 0x804d39a
                        sprintf((char *)&str5, "{cascad \"%s\"", str9);
                        v31 = v1[0];
                        v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                        end = v24;
                        if (v24 != -1) {
                            // 0x804d3ec
                            if (v24 <= start) {
                                // 0x804d41a
                                v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                start_sub = v25;
                                if (v25 != -1) {
                                    // 0x804d449
                                    if (v25 <= start) {
                                        // 0x804d477
                                        rq = NULL;
                                        n_lines = 0;
                                        v33 = end;
                                        if (v25 - v33 > -1) {
                                            delete_str(v33, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v18 = n_lines + 1;
                                            n_lines = v18;
                                            v32 = end;
                                            while (start_sub - v32 + 1 > v18) {
                                                // 0x804d48d
                                                delete_str(v32, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v18 = n_lines + 1;
                                                n_lines = v18;
                                                v32 = end;
                                                // continue -> 0x804d48d
                                            }
                                            // 0x804d4d0
                                            sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                            v34 = v1[0];
                                            v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                            delete_str(v26, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                            pos = v27;
                                            v35 = v1[0];
                                            v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                            start = v42;
                                            v36 = pos;
                                            v28 = v42 - v36;
                                            if (v28 <= 2) {
                                                // 0x804d5cf
                                                n_lines = 0;
                                                if (v28 > -1) {
                                                    delete_str(v36, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    v37 = pos;
                                                    while (start - v37 + 1 > v19) {
                                                        // 0x804d5a9
                                                        delete_str(v37, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        // continue -> 0x804d5a9
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x804d4d0
                                        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                        v34 = v1[0];
                                        v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                        delete_str(v26, (char **)(int32_t)v1[0]);
                                        rq = (char *)((int32_t)rq + 1);
                                        v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                        pos = v27;
                                        v35 = v1[0];
                                        v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                        start = v42;
                                        v36 = pos;
                                        v28 = v42 - v36;
                                        if (v28 <= 2) {
                                            // 0x804d5cf
                                            n_lines = 0;
                                            if (v28 > -1) {
                                                delete_str(v36, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v19 = n_lines + 1;
                                                n_lines = v19;
                                                v37 = pos;
                                                while (start - v37 + 1 > v19) {
                                                    // 0x804d5a9
                                                    delete_str(v37, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    v37 = pos;
                                                    // continue -> 0x804d5a9
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804d457
                                print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                // branch -> 0x804d729
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804d3fa
                        print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                        // branch -> 0x804d729
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804cf8a
    memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(TMP_GISMAN);
    file2 = fopen(TMP_GISMAN, "w+");
    f_in = (struct _IO_FILE_4 *)file2;
    if (file2 == NULL) {
        // 0x804cfd8
        err_num2 = *__errno_location();
        strerror(err_num2);
        print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        // branch -> 0x804d007
    }
    // 0x804d007
    atexit((void (**)())exit_db);
    if (VERBOSE == 0) {
        // 0x804d065
        sprintf((char *)&str5, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
        // branch -> 0x804d0c4
    } else {
        // 0x804d01c
        sprintf((char *)&str5, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
        // branch -> 0x804d0c4
    }
    // 0x804d0c4
    strcpy(GISMAN_CMD, (char *)&str5);
    line = NULL;
    str = fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new);
    v40 = line;
    v41 = v40;
    if (str != NULL) {
        line = (char **)((int32_t)v40 + 1);
        str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new);
        v39 = line;
        v41 = v39;
        while (str2 != NULL) {
            // 0x804d0e6
            line = (char **)((int32_t)v39 + 1);
            str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new);
            v39 = line;
            v41 = v39;
            // continue -> 0x804d0e6
        }
        // 0x804d111
        if (v41 == NULL) {
            // 0x804d11a
            // branch -> 0x804d729
        } else {
            // 0x804d124
            rewind((struct _IO_FILE *)n_lines_new);
            mem = (int32_t)calloc((int32_t)line + 1, 4);
            v1[0] = mem;
            n_lines = 0;
            if ((int32_t)line > -1) {
                // 0x804d169
                *(int32_t *)(int32_t)mem = 0;
                v17 = n_lines + 1;
                n_lines = v17;
                if ((int32_t)line + 1 > v17) {
                    *(int32_t *)(int32_t)((char)(4 * v17) + v1[0]) = 0;
                    v16 = n_lines + 1;
                    n_lines = v16;
                    while ((int32_t)line + 1 > v16) {
                        // 0x804d169
                        *(int32_t *)(int32_t)((char)(4 * v16) + v1[0]) = 0;
                        v16 = n_lines + 1;
                        n_lines = v16;
                        // continue -> 0x804d169
                    }
                    // 0x804d1f8
                    n_lines = 0;
                    if (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                        v20 = (char)(4 * n_lines) + v1[0];
                        g3 = v20;
                        len = strlen((char *)&str5);
                        *(int32_t *)v20 = (int32_t)malloc(len + 1);
                        v38 = v1[0];
                        str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                        strcpy((char *)str6, (char *)&str5);
                        n_lines++;
                        while (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                            // 0x804d1a2
                            v20 = (char)(4 * n_lines) + v1[0];
                            g3 = v20;
                            len = strlen((char *)&str5);
                            *(int32_t *)v20 = (int32_t)malloc(len + 1);
                            v38 = v1[0];
                            str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                            strcpy((char *)str6, (char *)&str5);
                            n_lines++;
                            // continue -> 0x804d1a2
                        }
                        // 0x804d21c
                        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                        v29 = v1[0];
                        v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                        if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                            // 0x804d26c
                            print_warning("could not find uninstall information in 'menu.tcl'.\n");
                            // branch -> 0x804d729
                        } else {
                            // 0x804d282
                            str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                            str8 = (int32_t)strchr((char *)str7, 34) + 1;
                            end_sub = str8;
                            strchr((char *)str8, 34);
                            strchr((char *)str8, 34);
                            strcpy(str9, (char *)end_sub);
                            v1[3] = 0;
                            v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                            pos = v22;
                            v30 = v1[0];
                            v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                            start = v23 - 1;
                            if (v23 == 0) {
                                // 0x804d357
                                start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                                // branch -> 0x804d37b
                            }
                            // 0x804d37b
                            if (pos == -1) {
                                // 0x804d384
                                print_warning("menu 'Xtns' does not exist.\n");
                                // branch -> 0x804d729
                            } else {
                                // 0x804d39a
                                sprintf((char *)&str5, "{cascad \"%s\"", str9);
                                v31 = v1[0];
                                v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                                end = v24;
                                if (v24 != -1) {
                                    // 0x804d3ec
                                    if (v24 <= start) {
                                        // 0x804d41a
                                        v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                        start_sub = v25;
                                        if (v25 != -1) {
                                            // 0x804d449
                                            if (v25 <= start) {
                                                // 0x804d477
                                                rq = NULL;
                                                n_lines = 0;
                                                v33 = end;
                                                if (v25 - v33 > -1) {
                                                    delete_str(v33, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v18 = n_lines + 1;
                                                    n_lines = v18;
                                                    v32 = end;
                                                    while (start_sub - v32 + 1 > v18) {
                                                        // 0x804d48d
                                                        delete_str(v32, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v18 = n_lines + 1;
                                                        n_lines = v18;
                                                        v32 = end;
                                                        // continue -> 0x804d48d
                                                    }
                                                    // 0x804d4d0
                                                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                    v34 = v1[0];
                                                    v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                    delete_str(v26, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                    pos = v27;
                                                    v35 = v1[0];
                                                    v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                    start = v42;
                                                    v36 = pos;
                                                    v28 = v42 - v36;
                                                    if (v28 <= 2) {
                                                        // 0x804d5cf
                                                        n_lines = 0;
                                                        if (v28 > -1) {
                                                            delete_str(v36, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            while (start - v37 + 1 > v19) {
                                                                // 0x804d5a9
                                                                delete_str(v37, (char **)(int32_t)v1[0]);
                                                                rq = (char *)((int32_t)rq + 1);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                v37 = pos;
                                                                // continue -> 0x804d5a9
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x804d4d0
                                                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                v34 = v1[0];
                                                v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                delete_str(v26, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                pos = v27;
                                                v35 = v1[0];
                                                v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                start = v42;
                                                v36 = pos;
                                                v28 = v42 - v36;
                                                if (v28 <= 2) {
                                                    // 0x804d5cf
                                                    n_lines = 0;
                                                    if (v28 > -1) {
                                                        delete_str(v36, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        while (start - v37 + 1 > v19) {
                                                            // 0x804d5a9
                                                            delete_str(v37, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            // continue -> 0x804d5a9
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x804d457
                                        print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                        // branch -> 0x804d729
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804d3fa
                                print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                                // branch -> 0x804d729
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804d21c
                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                    v29 = v1[0];
                    v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                    if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                        // 0x804d26c
                        print_warning("could not find uninstall information in 'menu.tcl'.\n");
                        // branch -> 0x804d729
                    } else {
                        // 0x804d282
                        str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                        str8 = (int32_t)strchr((char *)str7, 34) + 1;
                        end_sub = str8;
                        strchr((char *)str8, 34);
                        strchr((char *)str8, 34);
                        strcpy(str9, (char *)end_sub);
                        v1[3] = 0;
                        v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                        pos = v22;
                        v30 = v1[0];
                        v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                        start = v23 - 1;
                        if (v23 == 0) {
                            // 0x804d357
                            start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                            // branch -> 0x804d37b
                        }
                        // 0x804d37b
                        if (pos == -1) {
                            // 0x804d384
                            print_warning("menu 'Xtns' does not exist.\n");
                            // branch -> 0x804d729
                        } else {
                            // 0x804d39a
                            sprintf((char *)&str5, "{cascad \"%s\"", str9);
                            v31 = v1[0];
                            v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                            end = v24;
                            if (v24 != -1) {
                                // 0x804d3ec
                                if (v24 <= start) {
                                    // 0x804d41a
                                    v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                    start_sub = v25;
                                    if (v25 != -1) {
                                        // 0x804d449
                                        if (v25 <= start) {
                                            // 0x804d477
                                            rq = NULL;
                                            n_lines = 0;
                                            v33 = end;
                                            if (v25 - v33 > -1) {
                                                delete_str(v33, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v18 = n_lines + 1;
                                                n_lines = v18;
                                                v32 = end;
                                                while (start_sub - v32 + 1 > v18) {
                                                    // 0x804d48d
                                                    delete_str(v32, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v18 = n_lines + 1;
                                                    n_lines = v18;
                                                    v32 = end;
                                                    // continue -> 0x804d48d
                                                }
                                                // 0x804d4d0
                                                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                v34 = v1[0];
                                                v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                delete_str(v26, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                pos = v27;
                                                v35 = v1[0];
                                                v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                start = v42;
                                                v36 = pos;
                                                v28 = v42 - v36;
                                                if (v28 <= 2) {
                                                    // 0x804d5cf
                                                    n_lines = 0;
                                                    if (v28 > -1) {
                                                        delete_str(v36, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        while (start - v37 + 1 > v19) {
                                                            // 0x804d5a9
                                                            delete_str(v37, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            // continue -> 0x804d5a9
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // 0x804d4d0
                                            sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                            v34 = v1[0];
                                            v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                            delete_str(v26, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                            pos = v27;
                                            v35 = v1[0];
                                            v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                            start = v42;
                                            v36 = pos;
                                            v28 = v42 - v36;
                                            if (v28 <= 2) {
                                                // 0x804d5cf
                                                n_lines = 0;
                                                if (v28 > -1) {
                                                    delete_str(v36, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    v37 = pos;
                                                    while (start - v37 + 1 > v19) {
                                                        // 0x804d5a9
                                                        delete_str(v37, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        // continue -> 0x804d5a9
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d457
                                    print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                    // branch -> 0x804d729
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804d3fa
                            print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                            // branch -> 0x804d729
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // 0x804d1f8
            n_lines = 0;
            if (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                v20 = (char)(4 * n_lines) + v1[0];
                g3 = v20;
                len = strlen((char *)&str5);
                *(int32_t *)v20 = (int32_t)malloc(len + 1);
                v38 = v1[0];
                str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                strcpy((char *)str6, (char *)&str5);
                n_lines++;
                while (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                    // 0x804d1a2
                    v20 = (char)(4 * n_lines) + v1[0];
                    g3 = v20;
                    len = strlen((char *)&str5);
                    *(int32_t *)v20 = (int32_t)malloc(len + 1);
                    v38 = v1[0];
                    str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                    strcpy((char *)str6, (char *)&str5);
                    n_lines++;
                    // continue -> 0x804d1a2
                }
                // 0x804d21c
                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                v29 = v1[0];
                v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                    // 0x804d26c
                    print_warning("could not find uninstall information in 'menu.tcl'.\n");
                    // branch -> 0x804d729
                } else {
                    // 0x804d282
                    str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                    str8 = (int32_t)strchr((char *)str7, 34) + 1;
                    end_sub = str8;
                    strchr((char *)str8, 34);
                    strchr((char *)str8, 34);
                    strcpy(str9, (char *)end_sub);
                    v1[3] = 0;
                    v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                    pos = v22;
                    v30 = v1[0];
                    v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                    start = v23 - 1;
                    if (v23 == 0) {
                        // 0x804d357
                        start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                        // branch -> 0x804d37b
                    }
                    // 0x804d37b
                    if (pos == -1) {
                        // 0x804d384
                        print_warning("menu 'Xtns' does not exist.\n");
                        // branch -> 0x804d729
                    } else {
                        // 0x804d39a
                        sprintf((char *)&str5, "{cascad \"%s\"", str9);
                        v31 = v1[0];
                        v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                        end = v24;
                        if (v24 != -1) {
                            // 0x804d3ec
                            if (v24 <= start) {
                                // 0x804d41a
                                v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                start_sub = v25;
                                if (v25 != -1) {
                                    // 0x804d449
                                    if (v25 <= start) {
                                        // 0x804d477
                                        rq = NULL;
                                        n_lines = 0;
                                        v33 = end;
                                        if (v25 - v33 > -1) {
                                            delete_str(v33, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v18 = n_lines + 1;
                                            n_lines = v18;
                                            v32 = end;
                                            while (start_sub - v32 + 1 > v18) {
                                                // 0x804d48d
                                                delete_str(v32, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v18 = n_lines + 1;
                                                n_lines = v18;
                                                v32 = end;
                                                // continue -> 0x804d48d
                                            }
                                            // 0x804d4d0
                                            sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                            v34 = v1[0];
                                            v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                            delete_str(v26, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                            pos = v27;
                                            v35 = v1[0];
                                            v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                            start = v42;
                                            v36 = pos;
                                            v28 = v42 - v36;
                                            if (v28 <= 2) {
                                                // 0x804d5cf
                                                n_lines = 0;
                                                if (v28 > -1) {
                                                    delete_str(v36, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    v37 = pos;
                                                    while (start - v37 + 1 > v19) {
                                                        // 0x804d5a9
                                                        delete_str(v37, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        // continue -> 0x804d5a9
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x804d4d0
                                        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                        v34 = v1[0];
                                        v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                        delete_str(v26, (char **)(int32_t)v1[0]);
                                        rq = (char *)((int32_t)rq + 1);
                                        v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                        pos = v27;
                                        v35 = v1[0];
                                        v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                        start = v42;
                                        v36 = pos;
                                        v28 = v42 - v36;
                                        if (v28 <= 2) {
                                            // 0x804d5cf
                                            n_lines = 0;
                                            if (v28 > -1) {
                                                delete_str(v36, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v19 = n_lines + 1;
                                                n_lines = v19;
                                                v37 = pos;
                                                while (start - v37 + 1 > v19) {
                                                    // 0x804d5a9
                                                    delete_str(v37, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    v37 = pos;
                                                    // continue -> 0x804d5a9
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804d457
                                print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                // branch -> 0x804d729
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804d3fa
                        print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                        // branch -> 0x804d729
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804d21c
            sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
            v29 = v1[0];
            v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
            if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                // 0x804d26c
                print_warning("could not find uninstall information in 'menu.tcl'.\n");
                // branch -> 0x804d729
            } else {
                // 0x804d282
                str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                str8 = (int32_t)strchr((char *)str7, 34) + 1;
                end_sub = str8;
                strchr((char *)str8, 34);
                strchr((char *)str8, 34);
                strcpy(str9, (char *)end_sub);
                v1[3] = 0;
                v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                pos = v22;
                v30 = v1[0];
                v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                start = v23 - 1;
                if (v23 == 0) {
                    // 0x804d357
                    start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                    // branch -> 0x804d37b
                }
                // 0x804d37b
                if (pos == -1) {
                    // 0x804d384
                    print_warning("menu 'Xtns' does not exist.\n");
                    // branch -> 0x804d729
                } else {
                    // 0x804d39a
                    sprintf((char *)&str5, "{cascad \"%s\"", str9);
                    v31 = v1[0];
                    v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                    end = v24;
                    if (v24 != -1) {
                        // 0x804d3ec
                        if (v24 <= start) {
                            // 0x804d41a
                            v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                            start_sub = v25;
                            if (v25 != -1) {
                                // 0x804d449
                                if (v25 <= start) {
                                    // 0x804d477
                                    rq = NULL;
                                    n_lines = 0;
                                    v33 = end;
                                    if (v25 - v33 > -1) {
                                        delete_str(v33, (char **)(int32_t)v1[0]);
                                        rq = (char *)((int32_t)rq + 1);
                                        v18 = n_lines + 1;
                                        n_lines = v18;
                                        v32 = end;
                                        while (start_sub - v32 + 1 > v18) {
                                            // 0x804d48d
                                            delete_str(v32, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v18 = n_lines + 1;
                                            n_lines = v18;
                                            v32 = end;
                                            // continue -> 0x804d48d
                                        }
                                        // 0x804d4d0
                                        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                        v34 = v1[0];
                                        v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                        delete_str(v26, (char **)(int32_t)v1[0]);
                                        rq = (char *)((int32_t)rq + 1);
                                        v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                        pos = v27;
                                        v35 = v1[0];
                                        v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                        start = v42;
                                        v36 = pos;
                                        v28 = v42 - v36;
                                        if (v28 <= 2) {
                                            // 0x804d5cf
                                            n_lines = 0;
                                            if (v28 > -1) {
                                                delete_str(v36, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v19 = n_lines + 1;
                                                n_lines = v19;
                                                v37 = pos;
                                                while (start - v37 + 1 > v19) {
                                                    // 0x804d5a9
                                                    delete_str(v37, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    v37 = pos;
                                                    // continue -> 0x804d5a9
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804d4d0
                                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                    v34 = v1[0];
                                    v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                    delete_str(v26, (char **)(int32_t)v1[0]);
                                    rq = (char *)((int32_t)rq + 1);
                                    v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                    pos = v27;
                                    v35 = v1[0];
                                    v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                    start = v42;
                                    v36 = pos;
                                    v28 = v42 - v36;
                                    if (v28 <= 2) {
                                        // 0x804d5cf
                                        n_lines = 0;
                                        if (v28 > -1) {
                                            delete_str(v36, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v19 = n_lines + 1;
                                            n_lines = v19;
                                            v37 = pos;
                                            while (start - v37 + 1 > v19) {
                                                // 0x804d5a9
                                                delete_str(v37, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v19 = n_lines + 1;
                                                n_lines = v19;
                                                v37 = pos;
                                                // continue -> 0x804d5a9
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804d457
                            print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                            // branch -> 0x804d729
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804d3fa
                    print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                    // branch -> 0x804d729
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804d111
    if (v41 == NULL) {
        // 0x804d11a
        // branch -> 0x804d729
    } else {
        // 0x804d124
        rewind((struct _IO_FILE *)n_lines_new);
        mem = (int32_t)calloc((int32_t)line + 1, 4);
        v1[0] = mem;
        n_lines = 0;
        if ((int32_t)line > -1) {
            // 0x804d169
            *(int32_t *)(int32_t)mem = 0;
            v17 = n_lines + 1;
            n_lines = v17;
            if ((int32_t)line + 1 > v17) {
                *(int32_t *)(int32_t)((char)(4 * v17) + v1[0]) = 0;
                v16 = n_lines + 1;
                n_lines = v16;
                while ((int32_t)line + 1 > v16) {
                    // 0x804d169
                    *(int32_t *)(int32_t)((char)(4 * v16) + v1[0]) = 0;
                    v16 = n_lines + 1;
                    n_lines = v16;
                    // continue -> 0x804d169
                }
                // 0x804d1f8
                n_lines = 0;
                if (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                    v20 = (char)(4 * n_lines) + v1[0];
                    g3 = v20;
                    len = strlen((char *)&str5);
                    *(int32_t *)v20 = (int32_t)malloc(len + 1);
                    v38 = v1[0];
                    str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                    strcpy((char *)str6, (char *)&str5);
                    n_lines++;
                    while (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                        // 0x804d1a2
                        v20 = (char)(4 * n_lines) + v1[0];
                        g3 = v20;
                        len = strlen((char *)&str5);
                        *(int32_t *)v20 = (int32_t)malloc(len + 1);
                        v38 = v1[0];
                        str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                        strcpy((char *)str6, (char *)&str5);
                        n_lines++;
                        // continue -> 0x804d1a2
                    }
                    // 0x804d21c
                    sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                    v29 = v1[0];
                    v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                    if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                        // 0x804d26c
                        print_warning("could not find uninstall information in 'menu.tcl'.\n");
                        // branch -> 0x804d729
                    } else {
                        // 0x804d282
                        str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                        str8 = (int32_t)strchr((char *)str7, 34) + 1;
                        end_sub = str8;
                        strchr((char *)str8, 34);
                        strchr((char *)str8, 34);
                        strcpy(str9, (char *)end_sub);
                        v1[3] = 0;
                        v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                        pos = v22;
                        v30 = v1[0];
                        v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                        start = v23 - 1;
                        if (v23 == 0) {
                            // 0x804d357
                            start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                            // branch -> 0x804d37b
                        }
                        // 0x804d37b
                        if (pos == -1) {
                            // 0x804d384
                            print_warning("menu 'Xtns' does not exist.\n");
                            // branch -> 0x804d729
                        } else {
                            // 0x804d39a
                            sprintf((char *)&str5, "{cascad \"%s\"", str9);
                            v31 = v1[0];
                            v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                            end = v24;
                            if (v24 != -1) {
                                // 0x804d3ec
                                if (v24 <= start) {
                                    // 0x804d41a
                                    v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                    start_sub = v25;
                                    if (v25 != -1) {
                                        // 0x804d449
                                        if (v25 <= start) {
                                            // 0x804d477
                                            rq = NULL;
                                            n_lines = 0;
                                            v33 = end;
                                            if (v25 - v33 > -1) {
                                                delete_str(v33, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v18 = n_lines + 1;
                                                n_lines = v18;
                                                v32 = end;
                                                while (start_sub - v32 + 1 > v18) {
                                                    // 0x804d48d
                                                    delete_str(v32, (char **)(int32_t)v1[0]);
                                                    rq = (char *)((int32_t)rq + 1);
                                                    v18 = n_lines + 1;
                                                    n_lines = v18;
                                                    v32 = end;
                                                    // continue -> 0x804d48d
                                                }
                                                // 0x804d4d0
                                                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                                                v34 = v1[0];
                                                v26 = find_pos((char *)&str5, (char **)(int32_t)v34, 0);
                                                delete_str(v26, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v27 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                                                pos = v27;
                                                v35 = v1[0];
                                                v42 = find_pos("\" all options", (char **)(int32_t)v35, v27 + 1) - 1;
                                                start = v42;
                                                v36 = pos;
                                                v28 = v42 - v36;
                                                if (v28 <= 2) {
                                                    // 0x804d5cf
                                                    n_lines = 0;
                                                    if (v28 > -1) {
                                                        delete_str(v36, (char **)(int32_t)v1[0]);
                                                        rq = (char *)((int32_t)rq + 1);
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        v37 = pos;
                                                        while (start - v37 + 1 > v19) {
                                                            // 0x804d5a9
                                                            delete_str(v37, (char **)(int32_t)v1[0]);
                                                            rq = (char *)((int32_t)rq + 1);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            v37 = pos;
                                                            // continue -> 0x804d5a9
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x804d457
                                    print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                    // branch -> 0x804d729
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804d3fa
                            print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                            // branch -> 0x804d729
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804d21c
                sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
                v29 = v1[0];
                v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
                if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                    // 0x804d26c
                    print_warning("could not find uninstall information in 'menu.tcl'.\n");
                    // branch -> 0x804d729
                } else {
                    // 0x804d282
                    str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                    str8 = (int32_t)strchr((char *)str7, 34) + 1;
                    end_sub = str8;
                    strchr((char *)str8, 34);
                    strchr((char *)str8, 34);
                    strcpy(str9, (char *)end_sub);
                    v1[3] = 0;
                    v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                    pos = v22;
                    v30 = v1[0];
                    v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                    start = v23 - 1;
                    if (v23 == 0) {
                        // 0x804d357
                        start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                        // branch -> 0x804d37b
                    }
                    // 0x804d37b
                    if (pos == -1) {
                        // 0x804d384
                        print_warning("menu 'Xtns' does not exist.\n");
                        // branch -> 0x804d729
                    } else {
                        // 0x804d39a
                        sprintf((char *)&str5, "{cascad \"%s\"", str9);
                        v31 = v1[0];
                        v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                        end = v24;
                        if (v24 != -1) {
                            // 0x804d3ec
                            if (v24 <= start) {
                                // 0x804d41a
                                v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                                start_sub = v25;
                                if (v25 != -1) {
                                    // 0x804d449
                                    if (v25 <= start) {
                                        // 0x804d477
                                        rq = NULL;
                                        n_lines = 0;
                                        v33 = end;
                                        if (v25 - v33 > -1) {
                                            delete_str(v33, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v18 = n_lines + 1;
                                            n_lines = v18;
                                            v32 = end;
                                            while (start_sub - v32 + 1 > v18) {
                                                // 0x804d48d
                                                delete_str(v32, (char **)(int32_t)v1[0]);
                                                rq = (char *)((int32_t)rq + 1);
                                                v18 = n_lines + 1;
                                                n_lines = v18;
                                                v32 = end;
                                                // continue -> 0x804d48d
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x804d457
                                print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                                // branch -> 0x804d729
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804d3fa
                        print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                        // branch -> 0x804d729
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        }
        // 0x804d1f8
        n_lines = 0;
        if (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
            v20 = (char)(4 * n_lines) + v1[0];
            g3 = v20;
            len = strlen((char *)&str5);
            *(int32_t *)v20 = (int32_t)malloc(len + 1);
            v38 = v1[0];
            str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
            strcpy((char *)str6, (char *)&str5);
            n_lines++;
            while (fgets((char *)&str5, 2048, (struct _IO_FILE *)n_lines_new) != NULL) {
                // 0x804d1a2
                v20 = (char)(4 * n_lines) + v1[0];
                g3 = v20;
                len = strlen((char *)&str5);
                *(int32_t *)v20 = (int32_t)malloc(len + 1);
                v38 = v1[0];
                str6 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v38);
                strcpy((char *)str6, (char *)&str5);
                n_lines++;
                // continue -> 0x804d1a2
            }
            // 0x804d21c
            sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
            v29 = v1[0];
            v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
            if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
                // 0x804d26c
                print_warning("could not find uninstall information in 'menu.tcl'.\n");
                // branch -> 0x804d729
            } else {
                // 0x804d282
                str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
                str8 = (int32_t)strchr((char *)str7, 34) + 1;
                end_sub = str8;
                strchr((char *)str8, 34);
                strchr((char *)str8, 34);
                strcpy(str9, (char *)end_sub);
                v1[3] = 0;
                v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
                pos = v22;
                v30 = v1[0];
                v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
                start = v23 - 1;
                if (v23 == 0) {
                    // 0x804d357
                    start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                    // branch -> 0x804d37b
                }
                // 0x804d37b
                if (pos == -1) {
                    // 0x804d384
                    print_warning("menu 'Xtns' does not exist.\n");
                    // branch -> 0x804d729
                } else {
                    // 0x804d39a
                    sprintf((char *)&str5, "{cascad \"%s\"", str9);
                    v31 = v1[0];
                    v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                    end = v24;
                    if (v24 != -1) {
                        // 0x804d3ec
                        if (v24 <= start) {
                            // 0x804d41a
                            v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                            start_sub = v25;
                            if (v25 != -1) {
                                // 0x804d449
                                if (v25 <= start) {
                                    // 0x804d477
                                    rq = NULL;
                                    n_lines = 0;
                                    v33 = end;
                                    if (v25 - v33 > -1) {
                                        delete_str(v33, (char **)(int32_t)v1[0]);
                                        rq = (char *)((int32_t)rq + 1);
                                        v18 = n_lines + 1;
                                        n_lines = v18;
                                        v32 = end;
                                        while (start_sub - v32 + 1 > v18) {
                                            // 0x804d48d
                                            delete_str(v32, (char **)(int32_t)v1[0]);
                                            rq = (char *)((int32_t)rq + 1);
                                            v18 = n_lines + 1;
                                            n_lines = v18;
                                            v32 = end;
                                            // continue -> 0x804d48d
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x804d457
                            print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                            // branch -> 0x804d729
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804d3fa
                    print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                    // branch -> 0x804d729
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x804d21c
        sprintf((char *)&str5, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", (char *)num_removed);
        v29 = v1[0];
        v21 = find_pos((char *)&str5, (char **)(int32_t)v29, 0);
        if ((struct _IO_FILE_4 *)v21 == (struct _IO_FILE_4 *)-1) {
            // 0x804d26c
            print_warning("could not find uninstall information in 'menu.tcl'.\n");
            // branch -> 0x804d729
        } else {
            // 0x804d282
            str7 = *(int32_t *)(int32_t)(v1[0] + (char)(4 * v21));
            str8 = (int32_t)strchr((char *)str7, 34) + 1;
            end_sub = str8;
            strchr((char *)str8, 34);
            strchr((char *)str8, 34);
            strcpy(str9, (char *)end_sub);
            v1[3] = 0;
            v22 = find_pos("\"&Xtns\" all options 1", (char **)(int32_t)v1[0], 0);
            pos = v22;
            v30 = v1[0];
            v23 = find_pos("\" all options", (char **)(int32_t)v30, v22 + 1);
            start = v23 - 1;
            if (v23 == 0) {
                // 0x804d357
                start = find_pos("}]", (char **)(int32_t)v1[0], 0);
                // branch -> 0x804d37b
            }
            // 0x804d37b
            if (pos == -1) {
                // 0x804d384
                print_warning("menu 'Xtns' does not exist.\n");
                // branch -> 0x804d729
            } else {
                // 0x804d39a
                sprintf((char *)&str5, "{cascad \"%s\"", str9);
                v31 = v1[0];
                v24 = find_pos((char *)&str5, (char **)(int32_t)v31, pos);
                end = v24;
                if (v24 != -1) {
                    // 0x804d3ec
                    if (v24 <= start) {
                        // 0x804d41a
                        v25 = find_pos(" \t\t\t}}", (char **)(int32_t)v1[0], v24);
                        start_sub = v25;
                        if (v25 != -1) {
                            // 0x804d449
                            if (v25 <= start) {
                                // 0x804d477
                                rq = NULL;
                                n_lines = 0;
                                v33 = end;
                                if (v25 - v33 > -1) {
                                    delete_str(v33, (char **)(int32_t)v1[0]);
                                    rq = (char *)((int32_t)rq + 1);
                                    v18 = n_lines + 1;
                                    n_lines = v18;
                                    v32 = end;
                                    while (start_sub - v32 + 1 > v18) {
                                        // 0x804d48d
                                        delete_str(v32, (char **)(int32_t)v1[0]);
                                        rq = (char *)((int32_t)rq + 1);
                                        v18 = n_lines + 1;
                                        n_lines = v18;
                                        v32 = end;
                                        // continue -> 0x804d48d
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x804d457
                        print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                        // branch -> 0x804d729
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x804d3fa
                print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                // branch -> 0x804d729
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804d743 - 0x804d895
// Line range:    653 - 686
void deregister_entries_gisman2(char * pkg_short_name, char * gisbase) {
    char str2[2048];
    char v1[2048];
    int32_t v2 = *(int32_t *)20; // 0x804d75f
    int32_t str;
    sprintf((char *)&str, "%s/etc/gm/Xtns/%s.gem", gisbase, pkg_short_name);
    char file = (int32_t)fopen((char *)&str, "r");
    v1[0] = file;
    if (file != 0) {
        // 0x804d809
        if (VERBOSE == 0) {
            // 0x804d83f
            sprintf(str2, "rm -f %s/etc/gm/Xtns/%s.gem ; ", gisbase, pkg_short_name);
            // branch -> 0x804d86a
        } else {
            // 0x804d812
            sprintf(str2, "rm -vf %s/etc/gm/Xtns/%s.gem ; ", gisbase, pkg_short_name);
            // branch -> 0x804d86a
        }
        // 0x804d86a
        strcpy(GISMAN_CMD, str2);
        // branch -> 0x804d883
        // 0x804d883
        if (*(int32_t *)20 != v2) {
            // 0x804d88f
            __stack_chk_fail();
            // branch -> 0x804d894
        }
        // 0x804d894
        return;
    }
    // 0x804d7ba
    if (*__errno_location() != 2) {
        // 0x804d7ca
        fclose((struct _IO_FILE *)(int32_t)v1[0]);
        int32_t err_num = *__errno_location(); // 0x804d7dd
        strerror(err_num);
        print_error(-33, "checking for file '%s': %s\n");
        // branch -> 0x804d809
        // 0x804d809
        if (VERBOSE == 0) {
            // 0x804d83f
            sprintf(str2, "rm -f %s/etc/gm/Xtns/%s.gem ; ", gisbase, pkg_short_name);
            // branch -> 0x804d86a
        } else {
            // 0x804d812
            sprintf(str2, "rm -vf %s/etc/gm/Xtns/%s.gem ; ", gisbase, pkg_short_name);
            // branch -> 0x804d86a
        }
        // 0x804d86a
        strcpy(GISMAN_CMD, str2);
        // branch -> 0x804d883
    }
    // 0x804d883
    if (*(int32_t *)20 != v2) {
        // 0x804d88f
        __stack_chk_fail();
        // branch -> 0x804d894
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804d896 - 0x804e0ff
// Line range:    692 - 873
int32_t restore_entries_gisman(char * gisbase) {
    char v1[2048];
    char v2[2048];
    // 0x804d896
    int32_t v3;
    int32_t num_restored = v3; // bp-10308
    struct dirent_1 * v4;
    struct dirent_1 * ep = v4; // bp-10304
    struct __dirstream_2 * v5;
    struct __dirstream_2 * dirp = v5; // bp-10300
    struct _IO_FILE_4 * v6;
    struct _IO_FILE_4 * f_out = v6; // bp-10296
    struct _IO_FILE_4 * v7;
    struct _IO_FILE_4 * f_in = v7; // bp-10292
    struct _IO_FILE_4 * v8;
    struct _IO_FILE_4 * f_gisman = v8; // bp-10288
    int32_t v9;
    int32_t line_no = v9; // bp-10284
    int32_t v10;
    int32_t i = v10; // bp-10280
    int32_t v11;
    int32_t n_lines = v11; // bp-10276
    int32_t v12;
    int32_t n_entries = v12; // bp-10272
    char ** v13;
    char ** line = v13; // bp-10268
    int32_t v14;
    int32_t len = v14; // bp-10264
    int32_t v15 = g3; // 0x804d899
    int32_t v16 = *(int32_t *)20; // 0x804d8aa
    int32_t str4;
    sprintf((char *)&str4, "%s/etc/dm/menu.tcl", gisbase);
    struct _IO_FILE * file = fopen((char *)&str4, "r"); // 0x804d8e7
    f_gisman = (struct _IO_FILE_4 *)file;
    int32_t v17; // 0x804dcd2
    int32_t v18; // 0x804e036
    int32_t v19; // 0x804e0a1
    int32_t v20; // 0x804dd1a
    int32_t v21; // 0x804dca6_5
    struct _IO_FILE * file2; // 0x804d98a
    struct __dirstream * dirp2; // 0x804daca
    struct dirent * v22; // 0x804dbfb104
    char * str; // 0x804dc4f
    char * mem; // 0x804dca6
    int32_t len2; // 0x804dd29
    char * str3; // 0x804dd80
    char * str2; // 0x804dd8092
    struct __dirstream * dirp3; // 0x804ddb5
    struct dirent * v23; // 0x804dfe187
    struct dirent * v24; // 0x804dfe190
    int32_t str5;
    int32_t str6;
    int32_t err_num2; // 0x804d9a3
    int32_t str7; // 0x804dd50
    int32_t v25; // 0x804e046
    int32_t format; // 0x804e04677
    int32_t v26; // 0x804dc58
    int32_t v27; // 0x804dd8f
    int32_t v28; // 0x804dd8f96
    int32_t v29;
    if (file == NULL) {
        // 0x804d8fb
        if (*__errno_location() == 2) {
            // 0x804d907
            // branch -> 0x804e0e6
        } else {
            // 0x804d911
            fclose((struct _IO_FILE *)f_gisman);
            int32_t err_num = *__errno_location(); // 0x804d924
            strerror(err_num);
            print_error(-21, "checking for file '%s': %s\n");
            // branch -> 0x804d950
            // 0x804d950
            memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMP_GISMAN);
            file2 = fopen(TMP_GISMAN, "w+");
            f_in = (struct _IO_FILE_4 *)file2;
            if (file2 == NULL) {
                // 0x804d99e
                err_num2 = *__errno_location();
                strerror(err_num2);
                print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804d9cd
            }
            // 0x804d9cd
            atexit((void (**)())exit_db);
            if (VERBOSE == 0) {
                // 0x804da2b
                sprintf((char *)&str5, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
                // branch -> 0x804da8a
            } else {
                // 0x804d9e2
                sprintf((char *)&str5, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
                // branch -> 0x804da8a
            }
            // 0x804da8a
            strcpy(GISMAN_CMD, (char *)&str5);
            sprintf((char *)&str6, "%s/etc/dm/gem-entries", gisbase);
            dirp2 = opendir((char *)&str6);
            f_out = (struct _IO_FILE_4 *)dirp2;
            if (dirp2 == NULL) {
                // 0x804dade
                // branch -> 0x804e0e6
            } else {
                // 0x804dae8
                line = NULL;
                num_restored = 0;
                v22 = readdir(dirp2);
                dirp = (struct __dirstream_2 *)v22;
                if (v22 != NULL) {
                    struct dirent * v30 = v22; // 0x804dbfb107
                    while (true) {
                        // 0x804db01
                        sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v30 + 11));
                        line_no = (int32_t)fopen((char *)&str4, "r");
                        if (strcmp((char *)((int32_t)dirp + 11), ".") != 0) {
                          lab_0x804db69:
                            // 0x804db69
                            if (strcmp((char *)((int32_t)dirp + 11), "..") != 0) {
                                int32_t stream = line_no; // 0x804db96
                                struct dirent * v31; // 0x804dbfb
                                if (stream == 0) {
                                    // 0x804db9f
                                    fclose(NULL);
                                    // branch -> 0x804dbf2
                                } else {
                                    // 0x804dbb9
                                    if (fgets((char *)&str5, 2048, (struct _IO_FILE *)stream) != NULL) {
                                        line = (char **)((int32_t)line + 1);
                                        while (fgets((char *)&str5, 2048, (struct _IO_FILE *)line_no) != NULL) {
                                            // 0x804dbaf
                                            line = (char **)((int32_t)line + 1);
                                            // continue -> 0x804dbaf
                                        }
                                        // 0x804dbdd
                                        num_restored++;
                                        fclose((struct _IO_FILE *)line_no);
                                        // branch -> 0x804dbf2
                                      lab_0x804dbf2:
                                        // 0x804dbf2
                                        v31 = readdir((struct __dirstream *)f_out);
                                        dirp = (struct __dirstream_2 *)v31;
                                        if (v31 == NULL) {
                                            // break -> 0x804dc13
                                            break;
                                        }
                                        v30 = v31;
                                        // continue -> 0x804db01
                                        continue;
                                    }
                                    // 0x804dbdd
                                    num_restored++;
                                    fclose((struct _IO_FILE *)line_no);
                                    // branch -> 0x804dbf2
                                    goto lab_0x804dbf2;
                                }
                              lab_0x804dbf2_2:
                                // 0x804dbf2
                                v31 = readdir((struct __dirstream *)f_out);
                                dirp = (struct __dirstream_2 *)v31;
                                if (v31 == NULL) {
                                    // break -> 0x804dc13
                                    break;
                                }
                                v30 = v31;
                                // continue -> 0x804db01
                                continue;
                            }
                        }
                      lab_0x804db86:
                        // 0x804db86
                        fclose((struct _IO_FILE *)line_no);
                        // branch -> 0x804dbf2
                        goto lab_0x804dbf2_2;
                    }
                    // 0x804dc13
                    closedir((struct __dirstream *)f_out);
                    n_entries = 0;
                    str = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                    v26 = n_entries;
                    // branch -> 0x804dc34
                    while (str != NULL) {
                        // 0x804dc34
                        n_entries = v26 + 1;
                        str = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                        v26 = n_entries;
                        // continue -> 0x804dc34
                    }
                    // 0x804dc58
                    int32_t v32; // eax
                    int32_t v33; // 0x2113
                    if (v26 == 0) {
                        // 0x804dc61
                        v32 = 0;
                        v33 = 0;
                        // branch -> 0x804e0e6
                    } else {
                        // 0x804dc6b
                        rewind((struct _IO_FILE *)f_gisman);
                        mem = calloc(n_entries + 1 + 2 * (int32_t)line + 5 * num_restored, 4);
                        v21 = (int32_t)mem;
                        len = v21;
                        n_lines = 0;
                        if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                            int32_t v34 = v21; // 0x804dcc6
                            int32_t v35 = 0;
                            while (true) {
                                // 0x804dcbd
                                *(int32_t *)(v34 + 4 * v35) = 0;
                                v17 = n_lines + 1;
                                n_lines = v17;
                                if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v17) {
                                  lab_0x804dcbd_2:
                                    // 0x804dcbd
                                    v34 = len;
                                    v35 = v17;
                                    // branch -> 0x804dcbd
                                    continue;
                                }
                            }
                        }
                        // 0x804dd65
                        n_lines = 0;
                        str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                        v28 = 4 * n_lines;
                        if (str2 != NULL) {
                            v20 = len + v28;
                            g3 = v20;
                            len2 = strlen((char *)&str5);
                            *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                            str7 = *(int32_t *)(len + 4 * n_lines);
                            strcpy((char *)str7, (char *)&str5);
                            n_lines++;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                            v27 = 4 * n_lines;
                            while (str3 != NULL) {
                                // 0x804dd0f
                                v20 = len + v27;
                                g3 = v20;
                                len2 = strlen((char *)&str5);
                                *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                                str7 = *(int32_t *)(len + 4 * n_lines);
                                strcpy((char *)str7, (char *)&str5);
                                n_lines++;
                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                                v27 = 4 * n_lines;
                                // continue -> 0x804dd0f
                            }
                            // 0x804dd89
                            *(int32_t *)(len + v27) = 0;
                            check_ext_menu((char **)len);
                            dirp3 = opendir((char *)&str6);
                            f_out = (struct _IO_FILE_4 *)dirp3;
                            ep = NULL;
                            v23 = readdir(dirp3);
                            dirp = (struct __dirstream_2 *)v23;
                            if (v23 == NULL) {
                                // 0x804dff9
                                closedir((struct __dirstream *)f_out);
                                n_lines = 0;
                                format = len;
                                if (*(int32_t *)format == 0) {
                                    // 0x804e052
                                    fflush((struct _IO_FILE *)f_in);
                                    fclose((struct _IO_FILE *)f_gisman);
                                    fclose((struct _IO_FILE *)f_in);
                                    n_lines = 0;
                                    if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                        // 0x804e0d2
                                        free((char *)len);
                                        // branch -> 0x804e0e6
                                        // 0x804e0e6
                                        if (*(int32_t *)20 != v16) {
                                            // 0x804e0f2
                                            __stack_chk_fail();
                                            // branch -> 0x804e0f7
                                        }
                                        // 0x804e0f7
                                        g3 = v15;
                                        return (int32_t)ep;
                                    }
                                    free((char *)*(int32_t *)len);
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                        // 0x804e088
                                        free((char *)*(int32_t *)(len + 4 * v19));
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        // continue -> 0x804e088
                                    }
                                    // 0x804e0d2
                                    free((char *)len);
                                    // branch -> 0x804e0e6
                                    // 0x804e0e6
                                    if (*(int32_t *)20 != v16) {
                                        // 0x804e0f2
                                        __stack_chk_fail();
                                        // branch -> 0x804e0f7
                                    }
                                    // 0x804e0f7
                                    g3 = v15;
                                    return (int32_t)ep;
                                }
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v25 = len;
                                while (*(int32_t *)(4 * v18 + v25) != 0) {
                                    // 0x804e013
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                                    v18 = n_lines + 1;
                                    n_lines = v18;
                                    v25 = len;
                                    // continue -> 0x804e013
                                }
                                // 0x804e052
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)f_gisman);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                    // 0x804e0d2
                                    free((char *)len);
                                    // branch -> 0x804e0e6
                                    // 0x804e0e6
                                    if (*(int32_t *)20 != v16) {
                                        // 0x804e0f2
                                        __stack_chk_fail();
                                        // branch -> 0x804e0f7
                                    }
                                    // 0x804e0f7
                                    g3 = v15;
                                    return (int32_t)ep;
                                }
                                free((char *)*(int32_t *)len);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                    // 0x804e088
                                    free((char *)*(int32_t *)(len + 4 * v19));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804e088
                                }
                                // 0x804e0d2
                                free((char *)len);
                                // branch -> 0x804e0e6
                                // 0x804e0e6
                                if (*(int32_t *)20 != v16) {
                                    // 0x804e0f2
                                    __stack_chk_fail();
                                    // branch -> 0x804e0f7
                                }
                                // 0x804e0f7
                                g3 = v15;
                                return (int32_t)ep;
                            }
                            // 0x804ddcf
                            v24 = v23;
                            // branch -> 0x804ddcf
                            while (true) {
                                // 0x804ddcf
                                sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v24 + 11));
                                struct dirent * v36; // 0x804dfe1
                                if (strcmp((char *)((int32_t)dirp + 11), ".") != 0) {
                                  lab_0x804de1e_9:
                                    // 0x804de1e
                                    if (strcmp((char *)((int32_t)dirp + 11), "..") != 0) {
                                        struct _IO_FILE * file3 = fopen((char *)&str4, "r"); // 0x804de51
                                        line_no = (int32_t)file3;
                                        if (file3 != NULL) {
                                            // 0x804de69
                                            n_lines = 1;
                                            if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)file3) != NULL) {
                                                while (true) {
                                                    // 0x804de78
                                                    int32_t str8;
                                                    if (n_lines == 1) {
                                                        char * found_char_pos = strrchr((char *)&str5, 93); // 0x804de96
                                                        char * found_char_pos2 = strchr((char *)&str5, 91); // 0x804deae
                                                        int32_t n = (int32_t)found_char_pos - (int32_t)found_char_pos2; // 0x804deb5
                                                        v1[0] = n;
                                                        g3 = n;
                                                        char * found_char_pos3 = strchr((char *)&str5, 91); // 0x804ded6
                                                        strncpy((char *)&str8, (char *)((int32_t)found_char_pos3 + 1), n);
                                                        int32_t v37 = new_submenu(v2, (char *)&str5, (char **)len); // 0x804df22
                                                        i = v37;
                                                        if (v37 >= 0) {
                                                          lab_0x804df93:
                                                            // 0x804df93
                                                            n_lines++;
                                                            ep = (struct dirent_1 *)((int32_t)ep + 1);
                                                            if (nc_fgets_nb((char *)&str5, 2048, (struct _IO_FILE_2 *)line_no) == NULL) {
                                                                // break -> 0x804dfc1
                                                                break;
                                                            }
                                                            // continue -> 0x804de78
                                                            continue;
                                                        }
                                                    } else {
                                                        int32_t v38 = new_item((char *)&str5, (char *)&str8, (char **)len, i); // 0x804df71
                                                        i = v38;
                                                        if (v38 >= 0) {
                                                            goto lab_0x804df93;
                                                        }
                                                        // 0x804dfc1
                                                        fclose((struct _IO_FILE *)line_no);
                                                        // branch -> 0x804dfd8
                                                      lab_0x804dfd8_2:
                                                        // 0x804dfd8
                                                        v36 = readdir((struct __dirstream *)f_out);
                                                        dirp = (struct __dirstream_2 *)v36;
                                                        if (v36 == NULL) {
                                                            // break (via goto) -> 0x804dff9
                                                            goto lab_0x804dff9;
                                                        }
                                                        v24 = v36;
                                                        // continue (via goto) -> 0x804ddcf
                                                        goto lab_0x804ddcf;
                                                    }
                                                    // 0x804dfc1
                                                    fclose((struct _IO_FILE *)line_no);
                                                    // branch -> 0x804dfd8
                                                    goto lab_0x804dfd8_2;
                                                }
                                                // 0x804dff9
                                                closedir((struct __dirstream *)f_out);
                                                n_lines = 0;
                                                format = len;
                                                if (*(int32_t *)format == 0) {
                                                    // 0x804e052
                                                    fflush((struct _IO_FILE *)f_in);
                                                    fclose((struct _IO_FILE *)f_gisman);
                                                    fclose((struct _IO_FILE *)f_in);
                                                    n_lines = 0;
                                                    if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                                        // 0x804e0d2
                                                        free((char *)len);
                                                        // branch -> 0x804e0e6
                                                        // 0x804e0e6
                                                        if (*(int32_t *)20 != v16) {
                                                            // 0x804e0f2
                                                            __stack_chk_fail();
                                                            // branch -> 0x804e0f7
                                                        }
                                                        // 0x804e0f7
                                                        g3 = v15;
                                                        return (int32_t)ep;
                                                    }
                                                    free((char *)*(int32_t *)len);
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                                        // 0x804e088
                                                        free((char *)*(int32_t *)(len + 4 * v19));
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        // continue -> 0x804e088
                                                    }
                                                    // 0x804e0d2
                                                    free((char *)len);
                                                    // branch -> 0x804e0e6
                                                    // 0x804e0e6
                                                    if (*(int32_t *)20 != v16) {
                                                        // 0x804e0f2
                                                        __stack_chk_fail();
                                                        // branch -> 0x804e0f7
                                                    }
                                                    // 0x804e0f7
                                                    g3 = v15;
                                                    return (int32_t)ep;
                                                }
                                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                                v18 = n_lines + 1;
                                                n_lines = v18;
                                                v25 = len;
                                                while (*(int32_t *)(4 * v18 + v25) != 0) {
                                                    // 0x804e013
                                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                                                    v18 = n_lines + 1;
                                                    n_lines = v18;
                                                    v25 = len;
                                                    // continue -> 0x804e013
                                                }
                                                // 0x804e052
                                                fflush((struct _IO_FILE *)f_in);
                                                fclose((struct _IO_FILE *)f_gisman);
                                                fclose((struct _IO_FILE *)f_in);
                                                n_lines = 0;
                                                if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                                    // 0x804e0d2
                                                    free((char *)len);
                                                    // branch -> 0x804e0e6
                                                    // 0x804e0e6
                                                    if (*(int32_t *)20 != v16) {
                                                        // 0x804e0f2
                                                        __stack_chk_fail();
                                                        // branch -> 0x804e0f7
                                                    }
                                                    // 0x804e0f7
                                                    g3 = v15;
                                                    return (int32_t)ep;
                                                }
                                                free((char *)*(int32_t *)len);
                                                v19 = n_lines + 1;
                                                n_lines = v19;
                                                while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                                    // 0x804e088
                                                    free((char *)*(int32_t *)(len + 4 * v19));
                                                    v19 = n_lines + 1;
                                                    n_lines = v19;
                                                    // continue -> 0x804e088
                                                }
                                                // 0x804e0d2
                                                free((char *)len);
                                                // branch -> 0x804e0e6
                                                // 0x804e0e6
                                                if (*(int32_t *)20 != v16) {
                                                    // 0x804e0f2
                                                    __stack_chk_fail();
                                                    // branch -> 0x804e0f7
                                                }
                                                // 0x804e0f7
                                                g3 = v15;
                                                return (int32_t)ep;
                                            }
                                            // 0x804dfc1
                                            fclose((struct _IO_FILE *)line_no);
                                            // branch -> 0x804dfd8
                                            goto lab_0x804dfd8_2;
                                        }
                                    }
                                }
                              lab_0x804dfd8_11:
                                // 0x804dfd8
                                v36 = readdir((struct __dirstream *)f_out);
                                dirp = (struct __dirstream_2 *)v36;
                                if (v36 == NULL) {
                                    // break -> 0x804dff9
                                    break;
                                }
                                v24 = v36;
                                // continue -> 0x804ddcf
                            }
                            // 0x804dff9
                            closedir((struct __dirstream *)f_out);
                            n_lines = 0;
                            format = len;
                            if (*(int32_t *)format == 0) {
                                // 0x804e052
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)f_gisman);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                    // 0x804e0d2
                                    free((char *)len);
                                    // branch -> 0x804e0e6
                                    // 0x804e0e6
                                    if (*(int32_t *)20 != v16) {
                                        // 0x804e0f2
                                        __stack_chk_fail();
                                        // branch -> 0x804e0f7
                                    }
                                    // 0x804e0f7
                                    g3 = v15;
                                    return (int32_t)ep;
                                }
                                free((char *)*(int32_t *)len);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                    // 0x804e088
                                    free((char *)*(int32_t *)(len + 4 * v19));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804e088
                                }
                                // 0x804e0d2
                                free((char *)len);
                                // branch -> 0x804e0e6
                                // 0x804e0e6
                                if (*(int32_t *)20 != v16) {
                                    // 0x804e0f2
                                    __stack_chk_fail();
                                    // branch -> 0x804e0f7
                                }
                                // 0x804e0f7
                                g3 = v15;
                                return (int32_t)ep;
                            }
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v25 = len;
                            while (*(int32_t *)(4 * v18 + v25) != 0) {
                                // 0x804e013
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v25 = len;
                                // continue -> 0x804e013
                            }
                            // 0x804e052
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)f_gisman);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                // 0x804e0d2
                                free((char *)len);
                                // branch -> 0x804e0e6
                                // 0x804e0e6
                                if (*(int32_t *)20 != v16) {
                                    // 0x804e0f2
                                    __stack_chk_fail();
                                    // branch -> 0x804e0f7
                                }
                                // 0x804e0f7
                                g3 = v15;
                                return (int32_t)ep;
                            }
                            free((char *)*(int32_t *)len);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                // 0x804e088
                                free((char *)*(int32_t *)(len + 4 * v19));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804e088
                            }
                            // 0x804e0d2
                            free((char *)len);
                            // branch -> 0x804e0e6
                            // 0x804e0e6
                            if (*(int32_t *)20 != v16) {
                                // 0x804e0f2
                                __stack_chk_fail();
                                // branch -> 0x804e0f7
                            }
                            // 0x804e0f7
                            g3 = v15;
                            return (int32_t)ep;
                        }
                        // 0x804dd89
                        *(int32_t *)(len + v28) = 0;
                        check_ext_menu((char **)len);
                        dirp3 = opendir((char *)&str6);
                        f_out = (struct _IO_FILE_4 *)dirp3;
                        ep = NULL;
                        v23 = readdir(dirp3);
                        dirp = (struct __dirstream_2 *)v23;
                        if (v23 != NULL) {
                            // 0x804ddcf
                            // branch -> 0x804ddcf
                            while (true) {
                                // 0x804ddcf
                                sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v23 + 11));
                                if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                                    goto lab_0x804dfd8_11;
                                }
                                goto lab_0x804de1e_9;
                            }
                        }
                        // 0x804dff9
                        closedir((struct __dirstream *)f_out);
                        n_lines = 0;
                        format = len;
                        if (*(int32_t *)format != 0) {
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v25 = len;
                            while (*(int32_t *)(4 * v18 + v25) != 0) {
                                // 0x804e013
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v25 = len;
                                // continue -> 0x804e013
                            }
                            // 0x804e052
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)f_gisman);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                // 0x804e0d2
                                free((char *)len);
                                // branch -> 0x804e0e6
                                // 0x804e0e6
                                if (*(int32_t *)20 != v16) {
                                    // 0x804e0f2
                                    __stack_chk_fail();
                                    // branch -> 0x804e0f7
                                }
                                // 0x804e0f7
                                g3 = v15;
                                return (int32_t)ep;
                            }
                            free((char *)*(int32_t *)len);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                // 0x804e088
                                free((char *)*(int32_t *)(len + 4 * v19));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804e088
                            }
                            // 0x804e0d2
                            free((char *)len);
                            // branch -> 0x804e0e6
                            // 0x804e0e6
                            if (*(int32_t *)20 != v16) {
                                // 0x804e0f2
                                __stack_chk_fail();
                                // branch -> 0x804e0f7
                            }
                            // 0x804e0f7
                            g3 = v15;
                            return (int32_t)ep;
                        }
                        // 0x804e052
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)f_gisman);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                            free((char *)*(int32_t *)len);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                // 0x804e088
                                free((char *)*(int32_t *)(len + 4 * v19));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804e088
                            }
                            // 0x804e0d2
                            free((char *)len);
                            // branch -> 0x804e0e6
                            // 0x804e0e6
                            if (*(int32_t *)20 != v16) {
                                // 0x804e0f2
                                __stack_chk_fail();
                                // branch -> 0x804e0f7
                            }
                            // 0x804e0f7
                            g3 = v15;
                            return (int32_t)ep;
                        }
                        // 0x804e0d2
                        free((char *)len);
                        int32_t v39 = (int32_t)ep; // 0x804e0e0_0
                        v32 = v39;
                        v33 = v39;
                        // branch -> 0x804e0e6
                    }
                    // 0x804e0e6
                    int32_t result; // 0x804e0ff_2
                    if (*(int32_t *)20 != v16) {
                        // 0x804e0f2
                        __stack_chk_fail();
                        result = v32;
                        // branch -> 0x804e0f7
                    } else {
                        result = v33;
                    }
                    // 0x804e0f7
                    g3 = v15;
                    return result;
                }
                // 0x804dc13
                closedir((struct __dirstream *)f_out);
                n_entries = 0;
                str = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                v26 = n_entries;
                // branch -> 0x804dc34
                while (str != NULL) {
                    // 0x804dc34
                    n_entries = v26 + 1;
                    str = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                    v26 = n_entries;
                    // continue -> 0x804dc34
                }
                // 0x804dc58
                if (v26 == 0) {
                    // 0x804dc61
                    // branch -> 0x804e0e6
                } else {
                    // 0x804dc6b
                    rewind((struct _IO_FILE *)f_gisman);
                    mem = calloc(n_entries + 1 + 2 * (int32_t)line + 5 * num_restored, 4);
                    v21 = (int32_t)mem;
                    len = v21;
                    n_lines = 0;
                    if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                        while (true) {
                            // 0x804dcbd
                            *(int32_t *)v21 = 0;
                            v17 = n_lines + 1;
                            n_lines = v17;
                            if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v17) {
                                goto lab_0x804dcbd_2;
                            }
                            // 0x804dd65
                            n_lines = 0;
                            str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                            v28 = 4 * n_lines;
                            if (str2 == NULL) {
                                // 0x804dd89
                                *(int32_t *)(len + v28) = 0;
                                check_ext_menu((char **)len);
                                dirp3 = opendir((char *)&str6);
                                f_out = (struct _IO_FILE_4 *)dirp3;
                                ep = NULL;
                                v23 = readdir(dirp3);
                                dirp = (struct __dirstream_2 *)v23;
                                if (v23 != NULL) {
                                    // 0x804ddcf
                                    // branch -> 0x804ddcf
                                    while (true) {
                                        // 0x804ddcf
                                        sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v23 + 11));
                                        if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                                            goto lab_0x804dfd8_11;
                                        }
                                        goto lab_0x804de1e_9;
                                    }
                                }
                                // 0x804dff9
                                closedir((struct __dirstream *)f_out);
                                n_lines = 0;
                                format = len;
                                if (*(int32_t *)format == 0) {
                                    // 0x804e052
                                    fflush((struct _IO_FILE *)f_in);
                                    fclose((struct _IO_FILE *)f_gisman);
                                    fclose((struct _IO_FILE *)f_in);
                                    n_lines = 0;
                                    if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                        // 0x804e0d2
                                        free((char *)len);
                                        // branch -> 0x804e0e6
                                        // 0x804e0e6
                                        if (*(int32_t *)20 != v16) {
                                            // 0x804e0f2
                                            __stack_chk_fail();
                                            // branch -> 0x804e0f7
                                        }
                                        // 0x804e0f7
                                        g3 = v15;
                                        return (int32_t)ep;
                                    }
                                    free((char *)*(int32_t *)len);
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                        // 0x804e088
                                        free((char *)*(int32_t *)(len + 4 * v19));
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        // continue -> 0x804e088
                                    }
                                    // 0x804e0d2
                                    free((char *)len);
                                    // branch -> 0x804e0e6
                                    // 0x804e0e6
                                    if (*(int32_t *)20 != v16) {
                                        // 0x804e0f2
                                        __stack_chk_fail();
                                        // branch -> 0x804e0f7
                                    }
                                    // 0x804e0f7
                                    g3 = v15;
                                    return (int32_t)ep;
                                }
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v25 = len;
                                while (*(int32_t *)(4 * v18 + v25) != 0) {
                                    // 0x804e013
                                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                                    v18 = n_lines + 1;
                                    n_lines = v18;
                                    v25 = len;
                                    // continue -> 0x804e013
                                }
                                // 0x804e052
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)f_gisman);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                    // 0x804e0d2
                                    free((char *)len);
                                    // branch -> 0x804e0e6
                                    // 0x804e0e6
                                    if (*(int32_t *)20 != v16) {
                                        // 0x804e0f2
                                        __stack_chk_fail();
                                        // branch -> 0x804e0f7
                                    }
                                    // 0x804e0f7
                                    g3 = v15;
                                    return (int32_t)ep;
                                }
                                free((char *)*(int32_t *)len);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                    // 0x804e088
                                    free((char *)*(int32_t *)(len + 4 * v19));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804e088
                                }
                                // 0x804e0d2
                                free((char *)len);
                                // branch -> 0x804e0e6
                                // 0x804e0e6
                                if (*(int32_t *)20 != v16) {
                                    // 0x804e0f2
                                    __stack_chk_fail();
                                    // branch -> 0x804e0f7
                                }
                                // 0x804e0f7
                                g3 = v15;
                                return (int32_t)ep;
                            }
                            v20 = len + v28;
                            g3 = v20;
                            len2 = strlen((char *)&str5);
                            *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                            str7 = *(int32_t *)(len + 4 * n_lines);
                            strcpy((char *)str7, (char *)&str5);
                            n_lines++;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                            v27 = 4 * n_lines;
                            while (str3 != NULL) {
                                // 0x804dd0f
                                v20 = len + v27;
                                g3 = v20;
                                len2 = strlen((char *)&str5);
                                *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                                str7 = *(int32_t *)(len + 4 * n_lines);
                                strcpy((char *)str7, (char *)&str5);
                                n_lines++;
                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                                v27 = 4 * n_lines;
                                // continue -> 0x804dd0f
                            }
                            // 0x804dd89
                            *(int32_t *)(len + v27) = 0;
                            check_ext_menu((char **)len);
                            dirp3 = opendir((char *)&str6);
                            f_out = (struct _IO_FILE_4 *)dirp3;
                            ep = NULL;
                            v23 = readdir(dirp3);
                            dirp = (struct __dirstream_2 *)v23;
                            if (v23 != NULL) {
                                // 0x804ddcf
                                // branch -> 0x804ddcf
                                while (true) {
                                    // 0x804ddcf
                                    sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v23 + 11));
                                    if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                                        goto lab_0x804dfd8_11;
                                    }
                                    goto lab_0x804de1e_9;
                                }
                            }
                            // 0x804dff9
                            closedir((struct __dirstream *)f_out);
                            n_lines = 0;
                            format = len;
                            if (*(int32_t *)format == 0) {
                                // 0x804e052
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)f_gisman);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                    // 0x804e0d2
                                    free((char *)len);
                                    // branch -> 0x804e0e6
                                    // 0x804e0e6
                                    if (*(int32_t *)20 != v16) {
                                        // 0x804e0f2
                                        __stack_chk_fail();
                                        // branch -> 0x804e0f7
                                    }
                                    // 0x804e0f7
                                    g3 = v15;
                                    return (int32_t)ep;
                                }
                                free((char *)*(int32_t *)len);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                    // 0x804e088
                                    free((char *)*(int32_t *)(len + 4 * v19));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804e088
                                }
                                // 0x804e0d2
                                free((char *)len);
                                // branch -> 0x804e0e6
                                // 0x804e0e6
                                if (*(int32_t *)20 != v16) {
                                    // 0x804e0f2
                                    __stack_chk_fail();
                                    // branch -> 0x804e0f7
                                }
                                // 0x804e0f7
                                g3 = v15;
                                return (int32_t)ep;
                            }
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v25 = len;
                            while (*(int32_t *)(4 * v18 + v25) != 0) {
                                // 0x804e013
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v25 = len;
                                // continue -> 0x804e013
                            }
                            // 0x804e052
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)f_gisman);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored <= 0) {
                                // 0x804e0d2
                                free((char *)len);
                                // branch -> 0x804e0e6
                                // 0x804e0e6
                                if (*(int32_t *)20 != v16) {
                                    // 0x804e0f2
                                    __stack_chk_fail();
                                    // branch -> 0x804e0f7
                                }
                                // 0x804e0f7
                                g3 = v15;
                                return (int32_t)ep;
                            }
                            free((char *)*(int32_t *)len);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                // 0x804e088
                                free((char *)*(int32_t *)(len + 4 * v19));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804e088
                            }
                            // 0x804e0d2
                            free((char *)len);
                            // branch -> 0x804e0e6
                            // 0x804e0e6
                            if (*(int32_t *)20 != v16) {
                                // 0x804e0f2
                                __stack_chk_fail();
                                // branch -> 0x804e0f7
                            }
                            // 0x804e0f7
                            g3 = v15;
                            return (int32_t)ep;
                        }
                    }
                    // 0x804dd65
                    n_lines = 0;
                    str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                    v28 = 4 * n_lines;
                    v29 = v28;
                    if (str2 != NULL) {
                        v20 = len + v28;
                        g3 = v20;
                        len2 = strlen((char *)&str5);
                        *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                        str7 = *(int32_t *)(len + 4 * n_lines);
                        strcpy((char *)str7, (char *)&str5);
                        n_lines++;
                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                        v27 = 4 * n_lines;
                        v29 = v27;
                        while (str3 != NULL) {
                            // 0x804dd0f
                            v20 = len + v27;
                            g3 = v20;
                            len2 = strlen((char *)&str5);
                            *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                            str7 = *(int32_t *)(len + 4 * n_lines);
                            strcpy((char *)str7, (char *)&str5);
                            n_lines++;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                            v27 = 4 * n_lines;
                            v29 = v27;
                            // continue -> 0x804dd0f
                        }
                        // 0x804dd89
                        *(int32_t *)(len + v29) = 0;
                        check_ext_menu((char **)len);
                        dirp3 = opendir((char *)&str6);
                        f_out = (struct _IO_FILE_4 *)dirp3;
                        ep = NULL;
                        v23 = readdir(dirp3);
                        dirp = (struct __dirstream_2 *)v23;
                        if (v23 != NULL) {
                            // 0x804ddcf
                            // branch -> 0x804ddcf
                            while (true) {
                                // 0x804ddcf
                                sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v23 + 11));
                                if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                                    goto lab_0x804dfd8_11;
                                }
                                goto lab_0x804de1e_9;
                            }
                        }
                        // 0x804dff9
                        closedir((struct __dirstream *)f_out);
                        n_lines = 0;
                        format = len;
                        if (*(int32_t *)format != 0) {
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v25 = len;
                            while (*(int32_t *)(4 * v18 + v25) != 0) {
                                // 0x804e013
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v25 = len;
                                // continue -> 0x804e013
                            }
                            // 0x804e052
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)f_gisman);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                                free((char *)*(int32_t *)len);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                    // 0x804e088
                                    free((char *)*(int32_t *)(len + 4 * v19));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804e088
                                }
                                // 0x804e0d2
                                free((char *)len);
                                // branch -> 0x804e0e6
                                // 0x804e0e6
                                if (*(int32_t *)20 != v16) {
                                    // 0x804e0f2
                                    __stack_chk_fail();
                                    // branch -> 0x804e0f7
                                }
                                // 0x804e0f7
                                g3 = v15;
                                return (int32_t)ep;
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804e052
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)f_gisman);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                            free((char *)*(int32_t *)len);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                // 0x804e088
                                free((char *)*(int32_t *)(len + 4 * v19));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804e088
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804dd89
                    *(int32_t *)(len + v29) = 0;
                    check_ext_menu((char **)len);
                    dirp3 = opendir((char *)&str6);
                    f_out = (struct _IO_FILE_4 *)dirp3;
                    ep = NULL;
                    v23 = readdir(dirp3);
                    dirp = (struct __dirstream_2 *)v23;
                    if (v23 != NULL) {
                        // 0x804ddcf
                        // branch -> 0x804ddcf
                        while (true) {
                            // 0x804ddcf
                            sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v23 + 11));
                            if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                                goto lab_0x804dfd8_11;
                            }
                            goto lab_0x804de1e_9;
                        }
                    }
                    // 0x804dff9
                    closedir((struct __dirstream *)f_out);
                    n_lines = 0;
                    format = len;
                    if (*(int32_t *)format != 0) {
                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                        v18 = n_lines + 1;
                        n_lines = v18;
                        v25 = len;
                        while (*(int32_t *)(4 * v18 + v25) != 0) {
                            // 0x804e013
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v25 = len;
                            // continue -> 0x804e013
                        }
                        // 0x804e052
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)f_gisman);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                            free((char *)*(int32_t *)len);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                // 0x804e088
                                free((char *)*(int32_t *)(len + 4 * v19));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804e088
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804e052
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)f_gisman);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                        free((char *)*(int32_t *)len);
                        v19 = n_lines + 1;
                        n_lines = v19;
                        while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                            // 0x804e088
                            free((char *)*(int32_t *)(len + 4 * v19));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            // continue -> 0x804e088
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804d950
    memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(TMP_GISMAN);
    file2 = fopen(TMP_GISMAN, "w+");
    f_in = (struct _IO_FILE_4 *)file2;
    if (file2 == NULL) {
        // 0x804d99e
        err_num2 = *__errno_location();
        strerror(err_num2);
        print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        // branch -> 0x804d9cd
    }
    // 0x804d9cd
    atexit((void (**)())exit_db);
    if (VERBOSE == 0) {
        // 0x804da2b
        sprintf((char *)&str5, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
        // branch -> 0x804da8a
    } else {
        // 0x804d9e2
        sprintf((char *)&str5, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
        // branch -> 0x804da8a
    }
    // 0x804da8a
    strcpy(GISMAN_CMD, (char *)&str5);
    sprintf((char *)&str6, "%s/etc/dm/gem-entries", gisbase);
    dirp2 = opendir((char *)&str6);
    f_out = (struct _IO_FILE_4 *)dirp2;
    if (dirp2 == NULL) {
        // 0x804dade
        // branch -> 0x804e0e6
    } else {
        // 0x804dae8
        line = NULL;
        num_restored = 0;
        v22 = readdir(dirp2);
        dirp = (struct __dirstream_2 *)v22;
        if (v22 != NULL) {
            while (true) {
                // 0x804db01
                sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v22 + 11));
                line_no = (int32_t)fopen((char *)&str4, "r");
                if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                    goto lab_0x804db86;
                }
                goto lab_0x804db69;
            }
        }
        // 0x804dc13
        closedir((struct __dirstream *)f_out);
        n_entries = 0;
        str = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
        v26 = n_entries;
        // branch -> 0x804dc34
        while (str != NULL) {
            // 0x804dc34
            n_entries = v26 + 1;
            str = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
            v26 = n_entries;
            // continue -> 0x804dc34
        }
        // 0x804dc58
        if (v26 == 0) {
            // 0x804dc61
            // branch -> 0x804e0e6
        } else {
            // 0x804dc6b
            rewind((struct _IO_FILE *)f_gisman);
            mem = calloc(n_entries + 1 + 2 * (int32_t)line + 5 * num_restored, 4);
            v21 = (int32_t)mem;
            len = v21;
            n_lines = 0;
            if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                while (true) {
                    // 0x804dcbd
                    *(int32_t *)v21 = 0;
                    v17 = n_lines + 1;
                    n_lines = v17;
                    if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v17) {
                        goto lab_0x804dcbd_2;
                    }
                    // 0x804dd65
                    n_lines = 0;
                    str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                    v28 = 4 * n_lines;
                    v29 = v28;
                    if (str2 != NULL) {
                        v20 = len + v28;
                        g3 = v20;
                        len2 = strlen((char *)&str5);
                        *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                        str7 = *(int32_t *)(len + 4 * n_lines);
                        strcpy((char *)str7, (char *)&str5);
                        n_lines++;
                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                        v27 = 4 * n_lines;
                        v29 = v27;
                        while (str3 != NULL) {
                            // 0x804dd0f
                            v20 = len + v27;
                            g3 = v20;
                            len2 = strlen((char *)&str5);
                            *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                            str7 = *(int32_t *)(len + 4 * n_lines);
                            strcpy((char *)str7, (char *)&str5);
                            n_lines++;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                            v27 = 4 * n_lines;
                            v29 = v27;
                            // continue -> 0x804dd0f
                        }
                        // 0x804dd89
                        *(int32_t *)(len + v29) = 0;
                        check_ext_menu((char **)len);
                        dirp3 = opendir((char *)&str6);
                        f_out = (struct _IO_FILE_4 *)dirp3;
                        ep = NULL;
                        v23 = readdir(dirp3);
                        dirp = (struct __dirstream_2 *)v23;
                        if (v23 != NULL) {
                            // 0x804ddcf
                            // branch -> 0x804ddcf
                            while (true) {
                                // 0x804ddcf
                                sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v23 + 11));
                                if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                                    goto lab_0x804dfd8_11;
                                }
                                goto lab_0x804de1e_9;
                            }
                        }
                        // 0x804dff9
                        closedir((struct __dirstream *)f_out);
                        n_lines = 0;
                        format = len;
                        if (*(int32_t *)format != 0) {
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v25 = len;
                            while (*(int32_t *)(4 * v18 + v25) != 0) {
                                // 0x804e013
                                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v25 = len;
                                // continue -> 0x804e013
                            }
                            // 0x804e052
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)f_gisman);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                                free((char *)*(int32_t *)len);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                    // 0x804e088
                                    free((char *)*(int32_t *)(len + 4 * v19));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804e088
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804e052
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)f_gisman);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                            free((char *)*(int32_t *)len);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                // 0x804e088
                                free((char *)*(int32_t *)(len + 4 * v19));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804e088
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804dd89
                    *(int32_t *)(len + v29) = 0;
                    check_ext_menu((char **)len);
                    dirp3 = opendir((char *)&str6);
                    f_out = (struct _IO_FILE_4 *)dirp3;
                    ep = NULL;
                    v23 = readdir(dirp3);
                    dirp = (struct __dirstream_2 *)v23;
                    if (v23 != NULL) {
                        // 0x804ddcf
                        // branch -> 0x804ddcf
                        while (true) {
                            // 0x804ddcf
                            sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v23 + 11));
                            if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                                goto lab_0x804dfd8_11;
                            }
                            goto lab_0x804de1e_9;
                        }
                    }
                    // 0x804dff9
                    closedir((struct __dirstream *)f_out);
                    n_lines = 0;
                    format = len;
                    if (*(int32_t *)format != 0) {
                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                        v18 = n_lines + 1;
                        n_lines = v18;
                        v25 = len;
                        while (*(int32_t *)(4 * v18 + v25) != 0) {
                            // 0x804e013
                            fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v25 = len;
                            // continue -> 0x804e013
                        }
                        // 0x804e052
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)f_gisman);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                            free((char *)*(int32_t *)len);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                                // 0x804e088
                                free((char *)*(int32_t *)(len + 4 * v19));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804e088
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804e052
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)f_gisman);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                        free((char *)*(int32_t *)len);
                        v19 = n_lines + 1;
                        n_lines = v19;
                        while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                            // 0x804e088
                            free((char *)*(int32_t *)(len + 4 * v19));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            // continue -> 0x804e088
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // 0x804dd65
            n_lines = 0;
            str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
            v28 = 4 * n_lines;
            v29 = v28;
            if (str2 != NULL) {
                v20 = len + v28;
                g3 = v20;
                len2 = strlen((char *)&str5);
                *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                str7 = *(int32_t *)(len + 4 * n_lines);
                strcpy((char *)str7, (char *)&str5);
                n_lines++;
                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                v27 = 4 * n_lines;
                v29 = v27;
                while (str3 != NULL) {
                    // 0x804dd0f
                    v20 = len + v27;
                    g3 = v20;
                    len2 = strlen((char *)&str5);
                    *(int32_t *)v20 = (int32_t)malloc(len2 + 1);
                    str7 = *(int32_t *)(len + 4 * n_lines);
                    strcpy((char *)str7, (char *)&str5);
                    n_lines++;
                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)f_gisman);
                    v27 = 4 * n_lines;
                    v29 = v27;
                    // continue -> 0x804dd0f
                }
                // 0x804dd89
                *(int32_t *)(len + v29) = 0;
                check_ext_menu((char **)len);
                dirp3 = opendir((char *)&str6);
                f_out = (struct _IO_FILE_4 *)dirp3;
                ep = NULL;
                v23 = readdir(dirp3);
                dirp = (struct __dirstream_2 *)v23;
                if (v23 != NULL) {
                    // 0x804ddcf
                    // branch -> 0x804ddcf
                    while (true) {
                        // 0x804ddcf
                        sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v23 + 11));
                        if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                            goto lab_0x804dfd8_11;
                        }
                        goto lab_0x804de1e_9;
                    }
                }
                // 0x804dff9
                closedir((struct __dirstream *)f_out);
                n_lines = 0;
                format = len;
                if (*(int32_t *)format != 0) {
                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                    v18 = n_lines + 1;
                    n_lines = v18;
                    v25 = len;
                    while (*(int32_t *)(4 * v18 + v25) != 0) {
                        // 0x804e013
                        fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                        v18 = n_lines + 1;
                        n_lines = v18;
                        v25 = len;
                        // continue -> 0x804e013
                    }
                    // 0x804e052
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)f_gisman);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                        free((char *)*(int32_t *)len);
                        v19 = n_lines + 1;
                        n_lines = v19;
                        while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                            // 0x804e088
                            free((char *)*(int32_t *)(len + 4 * v19));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            // continue -> 0x804e088
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804e052
                fflush((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)f_gisman);
                fclose((struct _IO_FILE *)f_in);
                n_lines = 0;
                if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                    free((char *)*(int32_t *)len);
                    v19 = n_lines + 1;
                    n_lines = v19;
                    while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                        // 0x804e088
                        free((char *)*(int32_t *)(len + 4 * v19));
                        v19 = n_lines + 1;
                        n_lines = v19;
                        // continue -> 0x804e088
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804dd89
            *(int32_t *)(len + v29) = 0;
            check_ext_menu((char **)len);
            dirp3 = opendir((char *)&str6);
            f_out = (struct _IO_FILE_4 *)dirp3;
            ep = NULL;
            v23 = readdir(dirp3);
            dirp = (struct __dirstream_2 *)v23;
            if (v23 != NULL) {
                // 0x804ddcf
                v24 = v23;
                // branch -> 0x804ddcf
              lab_0x804ddcf:
                while (true) {
                    // 0x804ddcf
                    sprintf((char *)&str4, "%s/%s", &str6, (char *)((int32_t)v24 + 11));
                    if (strcmp((char *)((int32_t)dirp + 11), ".") == 0) {
                        goto lab_0x804dfd8_11;
                    }
                    goto lab_0x804de1e_9;
                }
            }
          lab_0x804dff9:
            // 0x804dff9
            closedir((struct __dirstream *)f_out);
            n_lines = 0;
            format = len;
            if (*(int32_t *)format != 0) {
                fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)format);
                v18 = n_lines + 1;
                n_lines = v18;
                v25 = len;
                while (*(int32_t *)(4 * v18 + v25) != 0) {
                    // 0x804e013
                    fprintf((struct _IO_FILE *)f_in, (char *)*(int32_t *)(4 * v18 + v25));
                    v18 = n_lines + 1;
                    n_lines = v18;
                    v25 = len;
                    // continue -> 0x804e013
                }
                // 0x804e052
                fflush((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)f_gisman);
                fclose((struct _IO_FILE *)f_in);
                n_lines = 0;
                if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                    free((char *)*(int32_t *)len);
                    v19 = n_lines + 1;
                    n_lines = v19;
                    while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                        // 0x804e088
                        free((char *)*(int32_t *)(len + 4 * v19));
                        v19 = n_lines + 1;
                        n_lines = v19;
                        // continue -> 0x804e088
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804e052
            fflush((struct _IO_FILE *)f_in);
            fclose((struct _IO_FILE *)f_gisman);
            fclose((struct _IO_FILE *)f_in);
            n_lines = 0;
            if (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > 0) {
                free((char *)*(int32_t *)len);
                v19 = n_lines + 1;
                n_lines = v19;
                while (n_entries + 1 + 2 * (int32_t)line + 5 * num_restored > v19) {
                    // 0x804e088
                    free((char *)*(int32_t *)(len + 4 * v19));
                    v19 = n_lines + 1;
                    n_lines = v19;
                    // continue -> 0x804e088
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804e100 - 0x804e56e
// Line range:    29 - 107
void new_ext_html(char * ext, char * gisbase, char ** html, int32_t major, int32_t minor, int32_t revision) {
    char v1[2048];
    char str[2048];
    // 0x804e100
    char * v2;
    char * last_char = v2; // bp-2100
    int32_t v3;
    int32_t insert_here = v3; // bp-2092
    int32_t v4;
    int32_t end = v4; // bp-2088
    int32_t v5;
    int32_t start = v5; // bp-2084
    int32_t v6;
    int32_t pos3 = v6; // bp-2080
    int32_t v7;
    int32_t pos2 = v7; // bp-2076
    int32_t v8;
    int32_t pos1 = v8; // bp-2072
    int32_t v9 = (int32_t)html; // 0x804e11b_0
    int32_t v10 = *(int32_t *)20; // 0x804e125
    char v11 = find_pos("<b>Drivers sections:</b>", html, 0);
    v1[0] = v11;
    int32_t v12; // 0x804e28d
    int32_t v13; // 0x804e30b
    int32_t v14; // 0x804e3d6
    int32_t v15; // 0x804e3e6
    if (v11 > 0) {
        // 0x804e19a
        pos1 = find_pos("<hr>", html, (int32_t)v11);
        if (find_pos("<h3>Installed extensions:</h3>", html, (int32_t)v1[0]) == -1) {
            // 0x804e1e9
            insert_str("<h3>Installed extensions:</h3>\n", pos1, html);
            insert_str("<ul>\n", pos1 + 1, html);
            insert_str("</ul>\n", pos1 + 2, html);
            insert_str("<p>\n", pos1 + 3, html);
            // branch -> 0x804e272
        }
        // 0x804e272
        v12 = find_pos("<h3>Installed extensions:</h3>", html, (int32_t)v1[0]);
        pos3 = v12;
        start = find_pos("</ul>", html, v12);
        end = pos3 + 2;
        sprintf(str, "\">%s", ext);
        v13 = find_pos(str, html, end);
        pos2 = v13;
        if (v13 != -1) {
            // 0x804e323
            print_warning("list item '%s' exists in index.html.\n");
            if (FORCE == 0) {
                // 0x804e55c
                if (*(int32_t *)20 != v10) {
                    // 0x804e568
                    __stack_chk_fail();
                    // branch -> 0x804e56d
                }
                // 0x804e56d
                return;
            }
            // 0x804e346
            if (UPGRADE != 0) {
                // 0x804e353
                sprintf(str, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", ext, ext, major, minor, revision);
                strcpy((char *)*(int32_t *)(4 * pos2 + v9), str);
                // branch -> 0x804e55c
            }
            // 0x804e55c
            if (*(int32_t *)20 != v10) {
                // 0x804e568
                __stack_chk_fail();
                // branch -> 0x804e56d
            }
            // 0x804e56d
            return;
        }
        // 0x804e3bb
        v14 = find_pos("<li><a href=", html, pos3);
        pos2 = v14;
        if (v14 != -1) {
            v15 = v14;
            while (true) {
                // 0x804e4e2
                if (v15 < start) {
                    goto lab_0x804e3e6;
                }
                // 0x804e4f4
                sprintf(str, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", ext, ext, major, minor, revision);
                insert_str(str, end, html);
                // branch -> 0x804e55c
                // 0x804e55c
                if (*(int32_t *)20 != v10) {
                    // 0x804e568
                    __stack_chk_fail();
                    // branch -> 0x804e56d
                }
                // 0x804e56d
                return;
            }
        }
        // 0x804e4f4
        sprintf(str, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", ext, ext, major, minor, revision);
        insert_str(str, end, html);
        // branch -> 0x804e55c
        // 0x804e55c
        if (*(int32_t *)20 != v10) {
            // 0x804e568
            __stack_chk_fail();
            // branch -> 0x804e56d
        }
        // 0x804e56d
        return;
    }
    char v16 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", html, 0);
    v1[0] = v16;
    if (v16 <= 0) {
        // 0x804e189
        print_warning("Unknown format of index.html. Unable to register HTML man pages.\n");
        // branch -> 0x804e55c
        // 0x804e55c
        if (*(int32_t *)20 != v10) {
            // 0x804e568
            __stack_chk_fail();
            // branch -> 0x804e56d
        }
        // 0x804e56d
        return;
    }
    // 0x804e19a
    pos1 = find_pos("<hr>", html, (int32_t)v16);
    if (find_pos("<h3>Installed extensions:</h3>", html, (int32_t)v1[0]) == -1) {
        // 0x804e1e9
        insert_str("<h3>Installed extensions:</h3>\n", pos1, html);
        insert_str("<ul>\n", pos1 + 1, html);
        insert_str("</ul>\n", pos1 + 2, html);
        insert_str("<p>\n", pos1 + 3, html);
        // branch -> 0x804e272
    }
    // 0x804e272
    v12 = find_pos("<h3>Installed extensions:</h3>", html, (int32_t)v1[0]);
    pos3 = v12;
    start = find_pos("</ul>", html, v12);
    end = pos3 + 2;
    sprintf(str, "\">%s", ext);
    v13 = find_pos(str, html, end);
    pos2 = v13;
    if (v13 == -1) {
        // 0x804e3bb
        v14 = find_pos("<li><a href=", html, pos3);
        pos2 = v14;
        if (v14 != -1) {
            v15 = v14;
            while (true) {
                // 0x804e4e2
                if (v15 < start) {
                  lab_0x804e3e6:;
                    int32_t str2 = *(int32_t *)(4 * v15 + v9); // 0x804e3f5
                    insert_here = (int32_t)strrchr((char *)str2, 34);
                    int32_t str3 = *(int32_t *)(4 * pos2 + v9); // 0x804e41c
                    int32_t n = (int32_t)strrchr((char *)str3, 60) - insert_here; // 0x804e442
                    last_char = (char *)n;
                    strncpy(str, (char *)(insert_here + 2), n);
                    *(char *)((int32_t)last_char - 2061 + g2) = 0;
                    if (strcmp(ext, str) > 0) {
                        int32_t v17 = pos3 + 1; // 0x804e4ac
                        pos3 = v17;
                        int32_t v18 = find_pos("<li><a href=", html, v17); // 0x804e4ce
                        pos2 = v18;
                        if (v18 == -1) {
                            // break -> 0x804e4f4
                            break;
                        }
                        v15 = v18;
                        // continue -> 0x804e4e2
                        continue;
                    } else {
                        // 0x804e49e
                        end = pos2;
                        // branch -> 0x804e4f4
                    }
                    // 0x804e4f4
                    sprintf(str, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", ext, ext, major, minor, revision);
                    insert_str(str, end, html);
                    // branch -> 0x804e55c
                    // 0x804e55c
                    if (*(int32_t *)20 != v10) {
                        // 0x804e568
                        __stack_chk_fail();
                        // branch -> 0x804e56d
                    }
                    // 0x804e56d
                    return;
                }
            }
            // 0x804e4f4
            sprintf(str, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", ext, ext, major, minor, revision);
            insert_str(str, end, html);
            // branch -> 0x804e55c
            // 0x804e55c
            if (*(int32_t *)20 != v10) {
                // 0x804e568
                __stack_chk_fail();
                // branch -> 0x804e56d
            }
            // 0x804e56d
            return;
        }
        // 0x804e4f4
        sprintf(str, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", ext, ext, major, minor, revision);
        insert_str(str, end, html);
        // branch -> 0x804e55c
    } else {
        // 0x804e323
        print_warning("list item '%s' exists in index.html.\n");
        if (FORCE != 0) {
            // 0x804e346
            if (UPGRADE != 0) {
                // 0x804e353
                sprintf(str, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", ext, ext, major, minor, revision);
                strcpy((char *)*(int32_t *)(4 * pos2 + v9), str);
                // branch -> 0x804e55c
            }
        }
    }
    // 0x804e55c
    if (*(int32_t *)20 != v10) {
        // 0x804e568
        __stack_chk_fail();
        // branch -> 0x804e56d
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804e56f - 0x804e7f2
// Line range:    110 - 166
void delete_ext_html(char * ext, char * gisbase, char ** html) {
    char v1[2048];
    char str[2048];
    // 0x804e56f
    int32_t v2;
    int32_t i = v2; // bp-2096
    int32_t v3;
    int32_t found = v3; // bp-2092
    int32_t v4;
    int32_t start = v4; // bp-2084
    int32_t v5;
    int32_t pos3 = v5; // bp-2080
    int32_t v6;
    int32_t pos2 = v6; // bp-2076
    i = (int32_t)ext;
    int32_t v7 = *(int32_t *)20; // 0x804e594
    char v8 = find_pos("<b>Drivers sections:</b>", html, 0);
    v1[0] = v8;
    char v9 = v8; // 0x804e609
    int32_t v10; // 0x804e7d0
    int32_t v11; // 0x804e7d025
    int32_t v12; // 0x804e680
    int32_t v13; // 0x804e6f9
    int32_t v14; // 0x804e770
    int32_t v15; // 0x804e784
    int32_t v16; // 0x804e72e
    int32_t v17; // 0x804e74e
    if (v8 > 0) {
        // 0x804e609
        find_pos("<hr>", html, (int32_t)v9);
        find_pos("<hr>", html, (int32_t)v9);
        if (find_pos("<h3>Installed extensions:</h3>", html, (int32_t)v1[0]) == -1) {
            // 0x804e654
            print_warning("no extensions section found in index.html.\n");
            // branch -> 0x804e7e0
            // 0x804e7e0
            if (*(int32_t *)20 != v7) {
                // 0x804e7ec
                __stack_chk_fail();
                // branch -> 0x804e7f1
            }
            // 0x804e7f1
            return;
        }
        // 0x804e665
        v12 = find_pos("<h3>Installed extensions:</h3>", html, (int32_t)v1[0]);
        pos3 = v12;
        start = find_pos("</ul>", html, v12);
        sprintf(str, "\">%s", (char *)i);
        v13 = find_pos(str, html, pos3);
        pos2 = v13;
        if (v13 == -1) {
            // 0x804e70d
            print_warning("extension '%s' not listed in index.html.\n");
            // branch -> 0x804e7e0
        } else {
            // 0x804e728
            v16 = start;
            v17 = v16;
            if (v13 < v16) {
                // 0x804e736
                delete_str(v13, html);
                v17 = start;
                // branch -> 0x804e74e
            }
            // 0x804e74e
            start = v17 - 1;
            v14 = find_pos("<ul>", html, pos3);
            pos2 = v14;
            if (v14 != -1) {
                // 0x804e784
                v15 = start;
                if (v15 > v14) {
                    // 0x804e792
                    if (v15 - v14 <= 1) {
                        // 0x804e7d7
                        found = 0;
                        delete_str(v14 - 1, html);
                        v11 = found + 1;
                        found = v11;
                        if (v11 < 4) {
                            delete_str(pos2 - 1, html);
                            v10 = found + 1;
                            found = v10;
                            while (v10 < 4) {
                                // 0x804e7b5
                                delete_str(pos2 - 1, html);
                                v10 = found + 1;
                                found = v10;
                                // continue -> 0x804e7b5
                            }
                            // 0x804e7e0
                            if (*(int32_t *)20 != v7) {
                                // 0x804e7ec
                                __stack_chk_fail();
                                // branch -> 0x804e7f1
                            }
                            // 0x804e7f1
                            return;
                        }
                    }
                }
            }
        }
        // 0x804e7e0
        if (*(int32_t *)20 != v7) {
            // 0x804e7ec
            __stack_chk_fail();
            // branch -> 0x804e7f1
        }
        // 0x804e7f1
        return;
    }
    char v18 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", html, 0);
    v1[0] = v18;
    if (v18 <= 0) {
        // 0x804e5f8
        print_warning("Unknown format of index.html. Unable to de-register HTML man pages.\n");
        // branch -> 0x804e7e0
        // 0x804e7e0
        if (*(int32_t *)20 != v7) {
            // 0x804e7ec
            __stack_chk_fail();
            // branch -> 0x804e7f1
        }
        // 0x804e7f1
        return;
    }
    v9 = v18;
    // 0x804e609
    find_pos("<hr>", html, (int32_t)v9);
    find_pos("<hr>", html, (int32_t)v9);
    if (find_pos("<h3>Installed extensions:</h3>", html, (int32_t)v1[0]) == -1) {
        // 0x804e654
        print_warning("no extensions section found in index.html.\n");
        // branch -> 0x804e7e0
        // 0x804e7e0
        if (*(int32_t *)20 != v7) {
            // 0x804e7ec
            __stack_chk_fail();
            // branch -> 0x804e7f1
        }
        // 0x804e7f1
        return;
    }
    // 0x804e665
    v12 = find_pos("<h3>Installed extensions:</h3>", html, (int32_t)v1[0]);
    pos3 = v12;
    start = find_pos("</ul>", html, v12);
    sprintf(str, "\">%s", (char *)i);
    v13 = find_pos(str, html, pos3);
    pos2 = v13;
    if (v13 == -1) {
        // 0x804e70d
        print_warning("extension '%s' not listed in index.html.\n");
        // branch -> 0x804e7e0
    } else {
        // 0x804e728
        v16 = start;
        v17 = v16;
        if (v13 < v16) {
            // 0x804e736
            delete_str(v13, html);
            v17 = start;
            // branch -> 0x804e74e
        }
        // 0x804e74e
        start = v17 - 1;
        v14 = find_pos("<ul>", html, pos3);
        pos2 = v14;
        if (v14 != -1) {
            // 0x804e784
            v15 = start;
            if (v15 > v14) {
                // 0x804e792
                if (v15 - v14 <= 1) {
                    // 0x804e7d7
                    found = 0;
                    delete_str(v14 - 1, html);
                    v11 = found + 1;
                    found = v11;
                    if (v11 < 4) {
                        delete_str(pos2 - 1, html);
                        v10 = found + 1;
                        found = v10;
                        while (v10 < 4) {
                            // 0x804e7b5
                            delete_str(pos2 - 1, html);
                            v10 = found + 1;
                            found = v10;
                            // continue -> 0x804e7b5
                        }
                        // 0x804e7e0
                        if (*(int32_t *)20 != v7) {
                            // 0x804e7ec
                            __stack_chk_fail();
                            // branch -> 0x804e7f1
                        }
                        // 0x804e7f1
                        return;
                    }
                }
            }
        }
    }
    // 0x804e7e0
    if (*(int32_t *)20 != v7) {
        // 0x804e7ec
        __stack_chk_fail();
        // branch -> 0x804e7f1
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804e7f3 - 0x804ec16
// Line range:    169 - 268
void register_html(char * pkg_short_name, char * gisbase, int32_t major, int32_t minor, int32_t revision) {
    char str4[2048];
    char v1[2048];
    // 0x804e7f3
    struct _IO_FILE_5 * v2;
    struct _IO_FILE_5 * f_in = v2; // bp-4132
    int32_t v3;
    int32_t i = v3; // bp-4128
    int32_t v4;
    int32_t n_lines = v4; // bp-4124
    char ** v5;
    char ** line = v5; // bp-4120
    int32_t v6 = *(int32_t *)20; // 0x804e810
    int32_t str3;
    sprintf((char *)&str3, "%s/docs/html/index.html", gisbase);
    struct _IO_FILE * file = fopen((char *)&str3, "r"); // 0x804e84d
    i = (int32_t)file;
    int32_t v7; // 0x804ea62
    int32_t v8; // 0x804ea62107
    int32_t v9; // 0x804eb66
    int32_t v10; // 0x804ebd1
    int32_t v11; // 0x804ea91_11
    struct _IO_FILE * file2; // 0x804e8ea
    char * str2; // 0x804e9fe
    char * str; // 0x804e9fe51
    int32_t len; // 0x804eaa0
    char mem;
    int32_t err_num2; // 0x804e903
    int32_t str5; // 0x804eac7
    int32_t format; // 0x804eb52
    int32_t v12; // 0x804ebc7
    char v13; // 0x804eb15
    char v14; // 0x804eac1
    char v15; // 0x804eb76
    char v16; // 0x804eb7637
    char v17; // 0x804ebc1
    char ** v18; // 0x804ea07
    char ** v19; // 0x804ea0754
    if (file == NULL) {
        // 0x804e861
        if (*__errno_location() != 2) {
            // 0x804e871
            fclose((struct _IO_FILE *)i);
            int32_t err_num = *__errno_location(); // 0x804e884
            strerror(err_num);
            print_error(-24, "checking for file '%s': %s\n");
            // branch -> 0x804e8b0
            // 0x804e8b0
            memcpy(TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMP_HTML);
            file2 = fopen(TMP_HTML, "w+");
            f_in = (struct _IO_FILE_5 *)file2;
            if (file2 == NULL) {
                // 0x804e8fe
                err_num2 = *__errno_location();
                strerror(err_num2);
                print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804e92d
            }
            // 0x804e92d
            atexit((void (**)())exit_db);
            if (VERBOSE == 0) {
                // 0x804e977
                sprintf(str4, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", TMP_HTML, gisbase, TMP_NULL, gisbase, TMP_NULL);
                // branch -> 0x804e9ba
            } else {
                // 0x804e942
                sprintf(str4, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", TMP_HTML, gisbase, gisbase);
                // branch -> 0x804e9ba
            }
            // 0x804e9ba
            strcpy(HTML_CMD, str4);
            line = NULL;
            str = fgets(str4, 2048, (struct _IO_FILE *)i);
            v19 = line;
            if (str != NULL) {
                line = (char **)((int32_t)v19 + 1);
                str2 = fgets(str4, 2048, (struct _IO_FILE *)i);
                v18 = line;
                while (str2 != NULL) {
                    // 0x804e9dc
                    line = (char **)((int32_t)v18 + 1);
                    str2 = fgets(str4, 2048, (struct _IO_FILE *)i);
                    v18 = line;
                    // continue -> 0x804e9dc
                }
                // 0x804ea07
                if (v18 != NULL) {
                    // 0x804ea14
                    rewind((struct _IO_FILE *)i);
                    mem = (int32_t)calloc((int32_t)line + 10, 4);
                    v1[0] = mem;
                    n_lines = 0;
                    if ((int32_t)line > -10) {
                        // 0x804ea4d
                        *(int32_t *)(int32_t)mem = 0;
                        v8 = n_lines + 1;
                        n_lines = v8;
                        if ((int32_t)line + 10 > v8) {
                            *(int32_t *)(int32_t)((char)(4 * v8) + v1[0]) = 0;
                            v7 = n_lines + 1;
                            n_lines = v7;
                            while ((int32_t)line + 10 > v7) {
                                // 0x804ea4d
                                *(int32_t *)(int32_t)((char)(4 * v7) + v1[0]) = 0;
                                v7 = n_lines + 1;
                                n_lines = v7;
                                // continue -> 0x804ea4d
                            }
                            // 0x804eadc
                            n_lines = 0;
                            if (fgets(str4, 2048, (struct _IO_FILE *)i) == NULL) {
                                // 0x804eb00
                                v13 = v1[0];
                                new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                                n_lines = 0;
                                v16 = v1[0];
                                if (*(int32_t *)(int32_t)v16 == 0) {
                                    // 0x804eb82
                                    fflush((struct _IO_FILE *)f_in);
                                    fclose((struct _IO_FILE *)i);
                                    fclose((struct _IO_FILE *)f_in);
                                    n_lines = 0;
                                    if ((int32_t)line <= -10) {
                                        // 0x804ebe9
                                        free((char *)(int32_t)v1[0]);
                                        // branch -> 0x804ebfd
                                        // 0x804ebfd
                                        if (*(int32_t *)20 != v6) {
                                            // 0x804ec09
                                            __stack_chk_fail();
                                            // branch -> 0x804ec0e
                                        }
                                        // 0x804ec0e
                                        return;
                                    }
                                    v17 = v1[0];
                                    free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    while ((int32_t)line + 10 > v10) {
                                        // 0x804ebb8
                                        v17 = v1[0];
                                        v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                        free((char *)v12);
                                        v10 = n_lines + 1;
                                        n_lines = v10;
                                        // continue -> 0x804ebb8
                                    }
                                    // 0x804ebe9
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804ebfd
                                    // 0x804ebfd
                                    if (*(int32_t *)20 != v6) {
                                        // 0x804ec09
                                        __stack_chk_fail();
                                        // branch -> 0x804ec0e
                                    }
                                    // 0x804ec0e
                                    return;
                                }
                                format = *(int32_t *)(int32_t)((char)0 + v16);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v9 = n_lines + 1;
                                n_lines = v9;
                                v15 = v1[0];
                                while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                                    // 0x804eb43
                                    format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                    v9 = n_lines + 1;
                                    n_lines = v9;
                                    v15 = v1[0];
                                    // continue -> 0x804eb43
                                }
                                // 0x804eb82
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if ((int32_t)line <= -10) {
                                    // 0x804ebe9
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804ebfd
                                    // 0x804ebfd
                                    if (*(int32_t *)20 != v6) {
                                        // 0x804ec09
                                        __stack_chk_fail();
                                        // branch -> 0x804ec0e
                                    }
                                    // 0x804ec0e
                                    return;
                                }
                                v17 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                                v10 = n_lines + 1;
                                n_lines = v10;
                                while ((int32_t)line + 10 > v10) {
                                    // 0x804ebb8
                                    v17 = v1[0];
                                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                    free((char *)v12);
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    // continue -> 0x804ebb8
                                }
                                // 0x804ebe9
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804ebfd
                                // 0x804ebfd
                                if (*(int32_t *)20 != v6) {
                                    // 0x804ec09
                                    __stack_chk_fail();
                                    // branch -> 0x804ec0e
                                }
                                // 0x804ec0e
                                return;
                            }
                            v11 = (char)(4 * n_lines) + v1[0];
                            g3 = v11;
                            len = strlen(str4);
                            *(int32_t *)v11 = (int32_t)malloc(len + 1);
                            v14 = v1[0];
                            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                            strcpy((char *)str5, str4);
                            n_lines++;
                            while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                                // 0x804ea86
                                v11 = (char)(4 * n_lines) + v1[0];
                                g3 = v11;
                                len = strlen(str4);
                                *(int32_t *)v11 = (int32_t)malloc(len + 1);
                                v14 = v1[0];
                                str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                                strcpy((char *)str5, str4);
                                n_lines++;
                                // continue -> 0x804ea86
                            }
                            // 0x804eb00
                            v13 = v1[0];
                            new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                            n_lines = 0;
                            v16 = v1[0];
                            if (*(int32_t *)(int32_t)v16 == 0) {
                                // 0x804eb82
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if ((int32_t)line <= -10) {
                                    // 0x804ebe9
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804ebfd
                                    // 0x804ebfd
                                    if (*(int32_t *)20 != v6) {
                                        // 0x804ec09
                                        __stack_chk_fail();
                                        // branch -> 0x804ec0e
                                    }
                                    // 0x804ec0e
                                    return;
                                }
                                v17 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                                v10 = n_lines + 1;
                                n_lines = v10;
                                while ((int32_t)line + 10 > v10) {
                                    // 0x804ebb8
                                    v17 = v1[0];
                                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                    free((char *)v12);
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    // continue -> 0x804ebb8
                                }
                                // 0x804ebe9
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804ebfd
                                // 0x804ebfd
                                if (*(int32_t *)20 != v6) {
                                    // 0x804ec09
                                    __stack_chk_fail();
                                    // branch -> 0x804ec0e
                                }
                                // 0x804ec0e
                                return;
                            }
                            format = *(int32_t *)(int32_t)((char)0 + v16);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v15 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                                // 0x804eb43
                                format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v9 = n_lines + 1;
                                n_lines = v9;
                                v15 = v1[0];
                                // continue -> 0x804eb43
                            }
                            // 0x804eb82
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line <= -10) {
                                // 0x804ebe9
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804ebfd
                                // 0x804ebfd
                                if (*(int32_t *)20 != v6) {
                                    // 0x804ec09
                                    __stack_chk_fail();
                                    // branch -> 0x804ec0e
                                }
                                // 0x804ec0e
                                return;
                            }
                            v17 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 10 > v10) {
                                // 0x804ebb8
                                v17 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804ebb8
                            }
                            // 0x804ebe9
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804ebfd
                            // 0x804ebfd
                            if (*(int32_t *)20 != v6) {
                                // 0x804ec09
                                __stack_chk_fail();
                                // branch -> 0x804ec0e
                            }
                            // 0x804ec0e
                            return;
                        }
                    }
                    // 0x804eadc
                    n_lines = 0;
                    if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v14 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                            // 0x804ea86
                            v11 = (char)(4 * n_lines) + v1[0];
                            g3 = v11;
                            len = strlen(str4);
                            *(int32_t *)v11 = (int32_t)malloc(len + 1);
                            v14 = v1[0];
                            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                            strcpy((char *)str5, str4);
                            n_lines++;
                            // continue -> 0x804ea86
                        }
                        // 0x804eb00
                        v13 = v1[0];
                        new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                        n_lines = 0;
                        v16 = v1[0];
                        if (*(int32_t *)(int32_t)v16 == 0) {
                            // 0x804eb82
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line <= -10) {
                                // 0x804ebe9
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804ebfd
                                // 0x804ebfd
                                if (*(int32_t *)20 != v6) {
                                    // 0x804ec09
                                    __stack_chk_fail();
                                    // branch -> 0x804ec0e
                                }
                                // 0x804ec0e
                                return;
                            }
                            v17 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 10 > v10) {
                                // 0x804ebb8
                                v17 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804ebb8
                            }
                            // 0x804ebe9
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804ebfd
                            // 0x804ebfd
                            if (*(int32_t *)20 != v6) {
                                // 0x804ec09
                                __stack_chk_fail();
                                // branch -> 0x804ec0e
                            }
                            // 0x804ec0e
                            return;
                        }
                        format = *(int32_t *)(int32_t)((char)0 + v16);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v15 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                            // 0x804eb43
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v15 = v1[0];
                            // continue -> 0x804eb43
                        }
                        // 0x804eb82
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line <= -10) {
                            // 0x804ebe9
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804ebfd
                            // 0x804ebfd
                            if (*(int32_t *)20 != v6) {
                                // 0x804ec09
                                __stack_chk_fail();
                                // branch -> 0x804ec0e
                            }
                            // 0x804ec0e
                            return;
                        }
                        v17 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 10 > v10) {
                            // 0x804ebb8
                            v17 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804ebb8
                        }
                        // 0x804ebe9
                        free((char *)(int32_t)v1[0]);
                        // branch -> 0x804ebfd
                        // 0x804ebfd
                        if (*(int32_t *)20 != v6) {
                            // 0x804ec09
                            __stack_chk_fail();
                            // branch -> 0x804ec0e
                        }
                        // 0x804ec0e
                        return;
                    }
                    // 0x804eb00
                    v13 = v1[0];
                    new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                    n_lines = 0;
                    v16 = v1[0];
                    if (*(int32_t *)(int32_t)v16 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v16);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v15 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                            // 0x804eb43
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v15 = v1[0];
                            // continue -> 0x804eb43
                        }
                        // 0x804eb82
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line <= -10) {
                            // 0x804ebe9
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804ebfd
                            // 0x804ebfd
                            if (*(int32_t *)20 != v6) {
                                // 0x804ec09
                                __stack_chk_fail();
                                // branch -> 0x804ec0e
                            }
                            // 0x804ec0e
                            return;
                        }
                        v17 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 10 > v10) {
                            // 0x804ebb8
                            v17 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804ebb8
                        }
                        // 0x804ebe9
                        free((char *)(int32_t)v1[0]);
                        // branch -> 0x804ebfd
                        // 0x804ebfd
                        if (*(int32_t *)20 != v6) {
                            // 0x804ec09
                            __stack_chk_fail();
                            // branch -> 0x804ec0e
                        }
                        // 0x804ec0e
                        return;
                    }
                    // 0x804eb82
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -10) {
                        v17 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 10 > v10) {
                            // 0x804ebb8
                            v17 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804ebb8
                        }
                        // 0x804ebe9
                        free((char *)(int32_t)v1[0]);
                        // branch -> 0x804ebfd
                        // 0x804ebfd
                        if (*(int32_t *)20 != v6) {
                            // 0x804ec09
                            __stack_chk_fail();
                            // branch -> 0x804ec0e
                        }
                        // 0x804ec0e
                        return;
                    }
                    // 0x804ebe9
                    free((char *)(int32_t)v1[0]);
                    // branch -> 0x804ebfd
                }
                // 0x804ebfd
                if (*(int32_t *)20 != v6) {
                    // 0x804ec09
                    __stack_chk_fail();
                    // branch -> 0x804ec0e
                }
                // 0x804ec0e
                return;
            }
            // 0x804ea07
            if (v19 != NULL) {
                // 0x804ea14
                rewind((struct _IO_FILE *)i);
                mem = (int32_t)calloc((int32_t)line + 10, 4);
                v1[0] = mem;
                n_lines = 0;
                if ((int32_t)line > -10) {
                    // 0x804ea4d
                    *(int32_t *)(int32_t)mem = 0;
                    v8 = n_lines + 1;
                    n_lines = v8;
                    if ((int32_t)line + 10 > v8) {
                        *(int32_t *)(int32_t)((char)(4 * v8) + v1[0]) = 0;
                        v7 = n_lines + 1;
                        n_lines = v7;
                        while ((int32_t)line + 10 > v7) {
                            // 0x804ea4d
                            *(int32_t *)(int32_t)((char)(4 * v7) + v1[0]) = 0;
                            v7 = n_lines + 1;
                            n_lines = v7;
                            // continue -> 0x804ea4d
                        }
                        // 0x804eadc
                        n_lines = 0;
                        if (fgets(str4, 2048, (struct _IO_FILE *)i) == NULL) {
                            // 0x804eb00
                            v13 = v1[0];
                            new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                            n_lines = 0;
                            v16 = v1[0];
                            if (*(int32_t *)(int32_t)v16 == 0) {
                                // 0x804eb82
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if ((int32_t)line <= -10) {
                                    // 0x804ebe9
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804ebfd
                                    // 0x804ebfd
                                    if (*(int32_t *)20 != v6) {
                                        // 0x804ec09
                                        __stack_chk_fail();
                                        // branch -> 0x804ec0e
                                    }
                                    // 0x804ec0e
                                    return;
                                }
                                v17 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                                v10 = n_lines + 1;
                                n_lines = v10;
                                while ((int32_t)line + 10 > v10) {
                                    // 0x804ebb8
                                    v17 = v1[0];
                                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                    free((char *)v12);
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    // continue -> 0x804ebb8
                                }
                                // 0x804ebe9
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804ebfd
                                // 0x804ebfd
                                if (*(int32_t *)20 != v6) {
                                    // 0x804ec09
                                    __stack_chk_fail();
                                    // branch -> 0x804ec0e
                                }
                                // 0x804ec0e
                                return;
                            }
                            format = *(int32_t *)(int32_t)((char)0 + v16);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v15 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                                // 0x804eb43
                                format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v9 = n_lines + 1;
                                n_lines = v9;
                                v15 = v1[0];
                                // continue -> 0x804eb43
                            }
                            // 0x804eb82
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line <= -10) {
                                // 0x804ebe9
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804ebfd
                                // 0x804ebfd
                                if (*(int32_t *)20 != v6) {
                                    // 0x804ec09
                                    __stack_chk_fail();
                                    // branch -> 0x804ec0e
                                }
                                // 0x804ec0e
                                return;
                            }
                            v17 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 10 > v10) {
                                // 0x804ebb8
                                v17 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804ebb8
                            }
                            // 0x804ebe9
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804ebfd
                            // 0x804ebfd
                            if (*(int32_t *)20 != v6) {
                                // 0x804ec09
                                __stack_chk_fail();
                                // branch -> 0x804ec0e
                            }
                            // 0x804ec0e
                            return;
                        }
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v14 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                            // 0x804ea86
                            v11 = (char)(4 * n_lines) + v1[0];
                            g3 = v11;
                            len = strlen(str4);
                            *(int32_t *)v11 = (int32_t)malloc(len + 1);
                            v14 = v1[0];
                            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                            strcpy((char *)str5, str4);
                            n_lines++;
                            // continue -> 0x804ea86
                        }
                        // 0x804eb00
                        v13 = v1[0];
                        new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                        n_lines = 0;
                        v16 = v1[0];
                        if (*(int32_t *)(int32_t)v16 == 0) {
                            // 0x804eb82
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line <= -10) {
                                // 0x804ebe9
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804ebfd
                                // 0x804ebfd
                                if (*(int32_t *)20 != v6) {
                                    // 0x804ec09
                                    __stack_chk_fail();
                                    // branch -> 0x804ec0e
                                }
                                // 0x804ec0e
                                return;
                            }
                            v17 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 10 > v10) {
                                // 0x804ebb8
                                v17 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804ebb8
                            }
                            // 0x804ebe9
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804ebfd
                            // 0x804ebfd
                            if (*(int32_t *)20 != v6) {
                                // 0x804ec09
                                __stack_chk_fail();
                                // branch -> 0x804ec0e
                            }
                            // 0x804ec0e
                            return;
                        }
                        format = *(int32_t *)(int32_t)((char)0 + v16);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v15 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                            // 0x804eb43
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v15 = v1[0];
                            // continue -> 0x804eb43
                        }
                        // 0x804eb82
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line <= -10) {
                            // 0x804ebe9
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804ebfd
                            // 0x804ebfd
                            if (*(int32_t *)20 != v6) {
                                // 0x804ec09
                                __stack_chk_fail();
                                // branch -> 0x804ec0e
                            }
                            // 0x804ec0e
                            return;
                        }
                        v17 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 10 > v10) {
                            // 0x804ebb8
                            v17 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804ebb8
                        }
                        // 0x804ebe9
                        free((char *)(int32_t)v1[0]);
                        // branch -> 0x804ebfd
                        // 0x804ebfd
                        if (*(int32_t *)20 != v6) {
                            // 0x804ec09
                            __stack_chk_fail();
                            // branch -> 0x804ec0e
                        }
                        // 0x804ec0e
                        return;
                    }
                }
                // 0x804eadc
                n_lines = 0;
                if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                    v11 = (char)(4 * n_lines) + v1[0];
                    g3 = v11;
                    len = strlen(str4);
                    *(int32_t *)v11 = (int32_t)malloc(len + 1);
                    v14 = v1[0];
                    str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                    strcpy((char *)str5, str4);
                    n_lines++;
                    while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                        // 0x804ea86
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v14 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        // continue -> 0x804ea86
                    }
                    // 0x804eb00
                    v13 = v1[0];
                    new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                    n_lines = 0;
                    v16 = v1[0];
                    if (*(int32_t *)(int32_t)v16 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v16);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v15 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                            // 0x804eb43
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v15 = v1[0];
                            // continue -> 0x804eb43
                        }
                        // 0x804eb82
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line > -10) {
                            v17 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 10 > v10) {
                                // 0x804ebb8
                                v17 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804ebb8
                            }
                            // 0x804ebe9
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804ebfd
                            // 0x804ebfd
                            if (*(int32_t *)20 != v6) {
                                // 0x804ec09
                                __stack_chk_fail();
                                // branch -> 0x804ec0e
                            }
                            // 0x804ec0e
                            return;
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804eb82
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -10) {
                        v17 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 10 > v10) {
                            // 0x804ebb8
                            v17 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804ebb8
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804eb00
                v13 = v1[0];
                new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                n_lines = 0;
                v16 = v1[0];
                if (*(int32_t *)(int32_t)v16 != 0) {
                    format = *(int32_t *)(int32_t)((char)0 + v16);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v15 = v1[0];
                    while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                        // 0x804eb43
                        format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v15 = v1[0];
                        // continue -> 0x804eb43
                    }
                    // 0x804eb82
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -10) {
                        v17 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 10 > v10) {
                            // 0x804ebb8
                            v17 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804ebb8
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804eb82
                fflush((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)i);
                fclose((struct _IO_FILE *)f_in);
                n_lines = 0;
                if ((int32_t)line > -10) {
                    v17 = v1[0];
                    free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                    v10 = n_lines + 1;
                    n_lines = v10;
                    while ((int32_t)line + 10 > v10) {
                        // 0x804ebb8
                        v17 = v1[0];
                        v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                        free((char *)v12);
                        v10 = n_lines + 1;
                        n_lines = v10;
                        // continue -> 0x804ebb8
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804e8b0
    memcpy(TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(TMP_HTML);
    file2 = fopen(TMP_HTML, "w+");
    f_in = (struct _IO_FILE_5 *)file2;
    if (file2 == NULL) {
        // 0x804e8fe
        err_num2 = *__errno_location();
        strerror(err_num2);
        print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        // branch -> 0x804e92d
    }
    // 0x804e92d
    atexit((void (**)())exit_db);
    if (VERBOSE == 0) {
        // 0x804e977
        sprintf(str4, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", TMP_HTML, gisbase, TMP_NULL, gisbase, TMP_NULL);
        // branch -> 0x804e9ba
    } else {
        // 0x804e942
        sprintf(str4, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", TMP_HTML, gisbase, gisbase);
        // branch -> 0x804e9ba
    }
    // 0x804e9ba
    strcpy(HTML_CMD, str4);
    line = NULL;
    str = fgets(str4, 2048, (struct _IO_FILE *)i);
    v19 = line;
    char ** v20 = v19;
    if (str != NULL) {
        line = (char **)((int32_t)v19 + 1);
        str2 = fgets(str4, 2048, (struct _IO_FILE *)i);
        v18 = line;
        v20 = v18;
        while (str2 != NULL) {
            // 0x804e9dc
            line = (char **)((int32_t)v18 + 1);
            str2 = fgets(str4, 2048, (struct _IO_FILE *)i);
            v18 = line;
            v20 = v18;
            // continue -> 0x804e9dc
        }
        // 0x804ea07
        if (v20 != NULL) {
            // 0x804ea14
            rewind((struct _IO_FILE *)i);
            mem = (int32_t)calloc((int32_t)line + 10, 4);
            v1[0] = mem;
            n_lines = 0;
            if ((int32_t)line > -10) {
                // 0x804ea4d
                *(int32_t *)(int32_t)mem = 0;
                v8 = n_lines + 1;
                n_lines = v8;
                if ((int32_t)line + 10 > v8) {
                    *(int32_t *)(int32_t)((char)(4 * v8) + v1[0]) = 0;
                    v7 = n_lines + 1;
                    n_lines = v7;
                    while ((int32_t)line + 10 > v7) {
                        // 0x804ea4d
                        *(int32_t *)(int32_t)((char)(4 * v7) + v1[0]) = 0;
                        v7 = n_lines + 1;
                        n_lines = v7;
                        // continue -> 0x804ea4d
                    }
                    // 0x804eadc
                    n_lines = 0;
                    if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v14 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                            // 0x804ea86
                            v11 = (char)(4 * n_lines) + v1[0];
                            g3 = v11;
                            len = strlen(str4);
                            *(int32_t *)v11 = (int32_t)malloc(len + 1);
                            v14 = v1[0];
                            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                            strcpy((char *)str5, str4);
                            n_lines++;
                            // continue -> 0x804ea86
                        }
                        // 0x804eb00
                        v13 = v1[0];
                        new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                        n_lines = 0;
                        v16 = v1[0];
                        if (*(int32_t *)(int32_t)v16 != 0) {
                            format = *(int32_t *)(int32_t)((char)0 + v16);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v15 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                                // 0x804eb43
                                format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v9 = n_lines + 1;
                                n_lines = v9;
                                v15 = v1[0];
                                // continue -> 0x804eb43
                            }
                            // 0x804eb82
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line > -10) {
                                v17 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                                v10 = n_lines + 1;
                                n_lines = v10;
                                while ((int32_t)line + 10 > v10) {
                                    // 0x804ebb8
                                    v17 = v1[0];
                                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                    free((char *)v12);
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    // continue -> 0x804ebb8
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804eb82
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line > -10) {
                            v17 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 10 > v10) {
                                // 0x804ebb8
                                v17 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804ebb8
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804eb00
                    v13 = v1[0];
                    new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                    n_lines = 0;
                    v16 = v1[0];
                    if (*(int32_t *)(int32_t)v16 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v16);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v15 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                            // 0x804eb43
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v15 = v1[0];
                            // continue -> 0x804eb43
                        }
                        // 0x804eb82
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line > -10) {
                            v17 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 10 > v10) {
                                // 0x804ebb8
                                v17 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804ebb8
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804eb82
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -10) {
                        v17 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 10 > v10) {
                            // 0x804ebb8
                            v17 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804ebb8
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // 0x804eadc
            n_lines = 0;
            if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                v11 = (char)(4 * n_lines) + v1[0];
                g3 = v11;
                len = strlen(str4);
                *(int32_t *)v11 = (int32_t)malloc(len + 1);
                v14 = v1[0];
                str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                strcpy((char *)str5, str4);
                n_lines++;
                while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                    // 0x804ea86
                    v11 = (char)(4 * n_lines) + v1[0];
                    g3 = v11;
                    len = strlen(str4);
                    *(int32_t *)v11 = (int32_t)malloc(len + 1);
                    v14 = v1[0];
                    str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                    strcpy((char *)str5, str4);
                    n_lines++;
                    // continue -> 0x804ea86
                }
                // 0x804eb00
                v13 = v1[0];
                new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                n_lines = 0;
                v16 = v1[0];
                if (*(int32_t *)(int32_t)v16 != 0) {
                    format = *(int32_t *)(int32_t)((char)0 + v16);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v15 = v1[0];
                    while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                        // 0x804eb43
                        format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v15 = v1[0];
                        // continue -> 0x804eb43
                    }
                    // 0x804eb82
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -10) {
                        v17 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 10 > v10) {
                            // 0x804ebb8
                            v17 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804ebb8
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804eb82
                fflush((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)i);
                fclose((struct _IO_FILE *)f_in);
                n_lines = 0;
                if ((int32_t)line > -10) {
                    v17 = v1[0];
                    free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                    v10 = n_lines + 1;
                    n_lines = v10;
                    while ((int32_t)line + 10 > v10) {
                        // 0x804ebb8
                        v17 = v1[0];
                        v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                        free((char *)v12);
                        v10 = n_lines + 1;
                        n_lines = v10;
                        // continue -> 0x804ebb8
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804eb00
            v13 = v1[0];
            new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
            n_lines = 0;
            v16 = v1[0];
            if (*(int32_t *)(int32_t)v16 != 0) {
                format = *(int32_t *)(int32_t)((char)0 + v16);
                fprintf((struct _IO_FILE *)f_in, (char *)format);
                v9 = n_lines + 1;
                n_lines = v9;
                v15 = v1[0];
                while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                    // 0x804eb43
                    format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v15 = v1[0];
                    // continue -> 0x804eb43
                }
                // 0x804eb82
                fflush((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)i);
                fclose((struct _IO_FILE *)f_in);
                n_lines = 0;
                if ((int32_t)line > -10) {
                    v17 = v1[0];
                    free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                    v10 = n_lines + 1;
                    n_lines = v10;
                    while ((int32_t)line + 10 > v10) {
                        // 0x804ebb8
                        v17 = v1[0];
                        v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                        free((char *)v12);
                        v10 = n_lines + 1;
                        n_lines = v10;
                        // continue -> 0x804ebb8
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804eb82
            fflush((struct _IO_FILE *)f_in);
            fclose((struct _IO_FILE *)i);
            fclose((struct _IO_FILE *)f_in);
            n_lines = 0;
            if ((int32_t)line > -10) {
                v17 = v1[0];
                free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                v10 = n_lines + 1;
                n_lines = v10;
                while ((int32_t)line + 10 > v10) {
                    // 0x804ebb8
                    v17 = v1[0];
                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                    free((char *)v12);
                    v10 = n_lines + 1;
                    n_lines = v10;
                    // continue -> 0x804ebb8
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804ea07
    if (v20 != NULL) {
        // 0x804ea14
        rewind((struct _IO_FILE *)i);
        mem = (int32_t)calloc((int32_t)line + 10, 4);
        v1[0] = mem;
        n_lines = 0;
        if ((int32_t)line > -10) {
            // 0x804ea4d
            *(int32_t *)(int32_t)mem = 0;
            v8 = n_lines + 1;
            n_lines = v8;
            if ((int32_t)line + 10 > v8) {
                *(int32_t *)(int32_t)((char)(4 * v8) + v1[0]) = 0;
                v7 = n_lines + 1;
                n_lines = v7;
                while ((int32_t)line + 10 > v7) {
                    // 0x804ea4d
                    *(int32_t *)(int32_t)((char)(4 * v7) + v1[0]) = 0;
                    v7 = n_lines + 1;
                    n_lines = v7;
                    // continue -> 0x804ea4d
                }
                // 0x804eadc
                n_lines = 0;
                if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                    v11 = (char)(4 * n_lines) + v1[0];
                    g3 = v11;
                    len = strlen(str4);
                    *(int32_t *)v11 = (int32_t)malloc(len + 1);
                    v14 = v1[0];
                    str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                    strcpy((char *)str5, str4);
                    n_lines++;
                    while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                        // 0x804ea86
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v14 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        // continue -> 0x804ea86
                    }
                    // 0x804eb00
                    v13 = v1[0];
                    new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                    n_lines = 0;
                    v16 = v1[0];
                    if (*(int32_t *)(int32_t)v16 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v16);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v15 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                            // 0x804eb43
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v15 = v1[0];
                            // continue -> 0x804eb43
                        }
                        // 0x804eb82
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line > -10) {
                            v17 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v17));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 10 > v10) {
                                // 0x804ebb8
                                v17 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v17);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804ebb8
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804eb00
                v13 = v1[0];
                new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
                n_lines = 0;
                v16 = v1[0];
                if (*(int32_t *)(int32_t)v16 != 0) {
                    format = *(int32_t *)(int32_t)((char)0 + v16);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v15 = v1[0];
                    while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                        // 0x804eb43
                        format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v15 = v1[0];
                        // continue -> 0x804eb43
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        }
        // 0x804eadc
        n_lines = 0;
        if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
            v11 = (char)(4 * n_lines) + v1[0];
            g3 = v11;
            len = strlen(str4);
            *(int32_t *)v11 = (int32_t)malloc(len + 1);
            v14 = v1[0];
            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
            strcpy((char *)str5, str4);
            n_lines++;
            while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                // 0x804ea86
                v11 = (char)(4 * n_lines) + v1[0];
                g3 = v11;
                len = strlen(str4);
                *(int32_t *)v11 = (int32_t)malloc(len + 1);
                v14 = v1[0];
                str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v14);
                strcpy((char *)str5, str4);
                n_lines++;
                // continue -> 0x804ea86
            }
            // 0x804eb00
            v13 = v1[0];
            new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
            n_lines = 0;
            v16 = v1[0];
            if (*(int32_t *)(int32_t)v16 != 0) {
                format = *(int32_t *)(int32_t)((char)0 + v16);
                fprintf((struct _IO_FILE *)f_in, (char *)format);
                v9 = n_lines + 1;
                n_lines = v9;
                v15 = v1[0];
                while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                    // 0x804eb43
                    format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v15 = v1[0];
                    // continue -> 0x804eb43
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x804eb00
        v13 = v1[0];
        new_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v13, major, minor, revision);
        n_lines = 0;
        v16 = v1[0];
        if (*(int32_t *)(int32_t)v16 != 0) {
            format = *(int32_t *)(int32_t)((char)0 + v16);
            fprintf((struct _IO_FILE *)f_in, (char *)format);
            v9 = n_lines + 1;
            n_lines = v9;
            v15 = v1[0];
            while (*(int32_t *)(int32_t)((char)(4 * v9) + v15) != 0) {
                // 0x804eb43
                format = *(int32_t *)(int32_t)((char)(4 * v9) + v15);
                fprintf((struct _IO_FILE *)f_in, (char *)format);
                v9 = n_lines + 1;
                n_lines = v9;
                v15 = v1[0];
                // continue -> 0x804eb43
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804ec17 - 0x804f025
// Line range:    271 - 368
void deregister_html(char * pkg_short_name, char * gisbase) {
    char str4[2048];
    char v1[2048];
    // 0x804ec17
    struct _IO_FILE_5 * v2;
    struct _IO_FILE_5 * f_in = v2; // bp-4132
    int32_t v3;
    int32_t i = v3; // bp-4128
    int32_t v4;
    int32_t n_lines = v4; // bp-4124
    char ** v5;
    char ** line = v5; // bp-4120
    int32_t v6 = *(int32_t *)20; // 0x804ec34
    int32_t str3;
    sprintf((char *)&str3, "%s/docs/html/index.html", gisbase);
    struct _IO_FILE * file = fopen((char *)&str3, "r"); // 0x804ec71
    i = (int32_t)file;
    int32_t v7; // 0x804ee86
    int32_t v8; // 0x804ee86107
    int32_t v9; // 0x804ef75
    int32_t v10; // 0x804efe0
    int32_t v11; // 0x804eeb5_11
    struct _IO_FILE * file2; // 0x804ed0e
    char * str2; // 0x804ee22
    char * str; // 0x804ee2251
    int32_t len; // 0x804eec4
    char mem;
    int32_t err_num2; // 0x804ed27
    int32_t str5; // 0x804eeeb
    int32_t format; // 0x804ef61
    int32_t v12; // 0x804efd6
    char v13; // 0x804eee5
    char v14; // 0x804ef85
    char v15; // 0x804ef8537
    char v16; // 0x804efd0
    char ** v17; // 0x804ee2b
    char ** v18; // 0x804ee2b54
    if (file == NULL) {
        // 0x804ec85
        if (*__errno_location() != 2) {
            // 0x804ec95
            fclose((struct _IO_FILE *)i);
            int32_t err_num = *__errno_location(); // 0x804eca8
            strerror(err_num);
            print_error(-24, "checking for file '%s': %s\n");
            // branch -> 0x804ecd4
            // 0x804ecd4
            memcpy(TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMP_HTML);
            file2 = fopen(TMP_HTML, "w+");
            f_in = (struct _IO_FILE_5 *)file2;
            if (file2 == NULL) {
                // 0x804ed22
                err_num2 = *__errno_location();
                strerror(err_num2);
                print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804ed51
            }
            // 0x804ed51
            atexit((void (**)())exit_db);
            if (VERBOSE == 0) {
                // 0x804ed9b
                sprintf(str4, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", TMP_HTML, gisbase, TMP_NULL, gisbase, TMP_NULL);
                // branch -> 0x804edde
            } else {
                // 0x804ed66
                sprintf(str4, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", TMP_HTML, gisbase, gisbase);
                // branch -> 0x804edde
            }
            // 0x804edde
            strcpy(HTML_CMD, str4);
            line = NULL;
            str = fgets(str4, 2048, (struct _IO_FILE *)i);
            v18 = line;
            if (str != NULL) {
                line = (char **)((int32_t)v18 + 1);
                str2 = fgets(str4, 2048, (struct _IO_FILE *)i);
                v17 = line;
                while (str2 != NULL) {
                    // 0x804ee00
                    line = (char **)((int32_t)v17 + 1);
                    str2 = fgets(str4, 2048, (struct _IO_FILE *)i);
                    v17 = line;
                    // continue -> 0x804ee00
                }
                // 0x804ee2b
                if (v17 != NULL) {
                    // 0x804ee38
                    rewind((struct _IO_FILE *)i);
                    mem = (int32_t)calloc((int32_t)line + 1, 4);
                    v1[0] = mem;
                    n_lines = 0;
                    if ((int32_t)line > -1) {
                        // 0x804ee71
                        *(int32_t *)(int32_t)mem = 0;
                        v8 = n_lines + 1;
                        n_lines = v8;
                        if ((int32_t)line + 1 > v8) {
                            *(int32_t *)(int32_t)((char)(4 * v8) + v1[0]) = 0;
                            v7 = n_lines + 1;
                            n_lines = v7;
                            while ((int32_t)line + 1 > v7) {
                                // 0x804ee71
                                *(int32_t *)(int32_t)((char)(4 * v7) + v1[0]) = 0;
                                v7 = n_lines + 1;
                                n_lines = v7;
                                // continue -> 0x804ee71
                            }
                            // 0x804ef00
                            n_lines = 0;
                            if (fgets(str4, 2048, (struct _IO_FILE *)i) == NULL) {
                                // 0x804ef24
                                delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                                n_lines = 0;
                                v15 = v1[0];
                                if (*(int32_t *)(int32_t)v15 == 0) {
                                    // 0x804ef91
                                    fflush((struct _IO_FILE *)f_in);
                                    fclose((struct _IO_FILE *)i);
                                    fclose((struct _IO_FILE *)f_in);
                                    n_lines = 0;
                                    if ((int32_t)line <= -1) {
                                        // 0x804eff8
                                        free((char *)(int32_t)v1[0]);
                                        // branch -> 0x804f00c
                                        // 0x804f00c
                                        if (*(int32_t *)20 != v6) {
                                            // 0x804f018
                                            __stack_chk_fail();
                                            // branch -> 0x804f01d
                                        }
                                        // 0x804f01d
                                        return;
                                    }
                                    v16 = v1[0];
                                    free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    while ((int32_t)line + 1 > v10) {
                                        // 0x804efc7
                                        v16 = v1[0];
                                        v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                        free((char *)v12);
                                        v10 = n_lines + 1;
                                        n_lines = v10;
                                        // continue -> 0x804efc7
                                    }
                                    // 0x804eff8
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804f00c
                                    // 0x804f00c
                                    if (*(int32_t *)20 != v6) {
                                        // 0x804f018
                                        __stack_chk_fail();
                                        // branch -> 0x804f01d
                                    }
                                    // 0x804f01d
                                    return;
                                }
                                format = *(int32_t *)(int32_t)((char)0 + v15);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v9 = n_lines + 1;
                                n_lines = v9;
                                v14 = v1[0];
                                while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                                    // 0x804ef52
                                    format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                    v9 = n_lines + 1;
                                    n_lines = v9;
                                    v14 = v1[0];
                                    // continue -> 0x804ef52
                                }
                                // 0x804ef91
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if ((int32_t)line <= -1) {
                                    // 0x804eff8
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804f00c
                                    // 0x804f00c
                                    if (*(int32_t *)20 != v6) {
                                        // 0x804f018
                                        __stack_chk_fail();
                                        // branch -> 0x804f01d
                                    }
                                    // 0x804f01d
                                    return;
                                }
                                v16 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                                v10 = n_lines + 1;
                                n_lines = v10;
                                while ((int32_t)line + 1 > v10) {
                                    // 0x804efc7
                                    v16 = v1[0];
                                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                    free((char *)v12);
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    // continue -> 0x804efc7
                                }
                                // 0x804eff8
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f00c
                                // 0x804f00c
                                if (*(int32_t *)20 != v6) {
                                    // 0x804f018
                                    __stack_chk_fail();
                                    // branch -> 0x804f01d
                                }
                                // 0x804f01d
                                return;
                            }
                            v11 = (char)(4 * n_lines) + v1[0];
                            g3 = v11;
                            len = strlen(str4);
                            *(int32_t *)v11 = (int32_t)malloc(len + 1);
                            v13 = v1[0];
                            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                            strcpy((char *)str5, str4);
                            n_lines++;
                            while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                                // 0x804eeaa
                                v11 = (char)(4 * n_lines) + v1[0];
                                g3 = v11;
                                len = strlen(str4);
                                *(int32_t *)v11 = (int32_t)malloc(len + 1);
                                v13 = v1[0];
                                str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                                strcpy((char *)str5, str4);
                                n_lines++;
                                // continue -> 0x804eeaa
                            }
                            // 0x804ef24
                            delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                            n_lines = 0;
                            v15 = v1[0];
                            if (*(int32_t *)(int32_t)v15 == 0) {
                                // 0x804ef91
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if ((int32_t)line <= -1) {
                                    // 0x804eff8
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804f00c
                                    // 0x804f00c
                                    if (*(int32_t *)20 != v6) {
                                        // 0x804f018
                                        __stack_chk_fail();
                                        // branch -> 0x804f01d
                                    }
                                    // 0x804f01d
                                    return;
                                }
                                v16 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                                v10 = n_lines + 1;
                                n_lines = v10;
                                while ((int32_t)line + 1 > v10) {
                                    // 0x804efc7
                                    v16 = v1[0];
                                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                    free((char *)v12);
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    // continue -> 0x804efc7
                                }
                                // 0x804eff8
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f00c
                                // 0x804f00c
                                if (*(int32_t *)20 != v6) {
                                    // 0x804f018
                                    __stack_chk_fail();
                                    // branch -> 0x804f01d
                                }
                                // 0x804f01d
                                return;
                            }
                            format = *(int32_t *)(int32_t)((char)0 + v15);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v14 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                                // 0x804ef52
                                format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v9 = n_lines + 1;
                                n_lines = v9;
                                v14 = v1[0];
                                // continue -> 0x804ef52
                            }
                            // 0x804ef91
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line <= -1) {
                                // 0x804eff8
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f00c
                                // 0x804f00c
                                if (*(int32_t *)20 != v6) {
                                    // 0x804f018
                                    __stack_chk_fail();
                                    // branch -> 0x804f01d
                                }
                                // 0x804f01d
                                return;
                            }
                            v16 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 1 > v10) {
                                // 0x804efc7
                                v16 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804efc7
                            }
                            // 0x804eff8
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f00c
                            // 0x804f00c
                            if (*(int32_t *)20 != v6) {
                                // 0x804f018
                                __stack_chk_fail();
                                // branch -> 0x804f01d
                            }
                            // 0x804f01d
                            return;
                        }
                    }
                    // 0x804ef00
                    n_lines = 0;
                    if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v13 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                            // 0x804eeaa
                            v11 = (char)(4 * n_lines) + v1[0];
                            g3 = v11;
                            len = strlen(str4);
                            *(int32_t *)v11 = (int32_t)malloc(len + 1);
                            v13 = v1[0];
                            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                            strcpy((char *)str5, str4);
                            n_lines++;
                            // continue -> 0x804eeaa
                        }
                        // 0x804ef24
                        delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                        n_lines = 0;
                        v15 = v1[0];
                        if (*(int32_t *)(int32_t)v15 == 0) {
                            // 0x804ef91
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line <= -1) {
                                // 0x804eff8
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f00c
                                // 0x804f00c
                                if (*(int32_t *)20 != v6) {
                                    // 0x804f018
                                    __stack_chk_fail();
                                    // branch -> 0x804f01d
                                }
                                // 0x804f01d
                                return;
                            }
                            v16 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 1 > v10) {
                                // 0x804efc7
                                v16 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804efc7
                            }
                            // 0x804eff8
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f00c
                            // 0x804f00c
                            if (*(int32_t *)20 != v6) {
                                // 0x804f018
                                __stack_chk_fail();
                                // branch -> 0x804f01d
                            }
                            // 0x804f01d
                            return;
                        }
                        format = *(int32_t *)(int32_t)((char)0 + v15);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v14 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                            // 0x804ef52
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v14 = v1[0];
                            // continue -> 0x804ef52
                        }
                        // 0x804ef91
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line <= -1) {
                            // 0x804eff8
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f00c
                            // 0x804f00c
                            if (*(int32_t *)20 != v6) {
                                // 0x804f018
                                __stack_chk_fail();
                                // branch -> 0x804f01d
                            }
                            // 0x804f01d
                            return;
                        }
                        v16 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 1 > v10) {
                            // 0x804efc7
                            v16 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804efc7
                        }
                        // 0x804eff8
                        free((char *)(int32_t)v1[0]);
                        // branch -> 0x804f00c
                        // 0x804f00c
                        if (*(int32_t *)20 != v6) {
                            // 0x804f018
                            __stack_chk_fail();
                            // branch -> 0x804f01d
                        }
                        // 0x804f01d
                        return;
                    }
                    // 0x804ef24
                    delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                    n_lines = 0;
                    v15 = v1[0];
                    if (*(int32_t *)(int32_t)v15 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v15);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v14 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                            // 0x804ef52
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v14 = v1[0];
                            // continue -> 0x804ef52
                        }
                        // 0x804ef91
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line <= -1) {
                            // 0x804eff8
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f00c
                            // 0x804f00c
                            if (*(int32_t *)20 != v6) {
                                // 0x804f018
                                __stack_chk_fail();
                                // branch -> 0x804f01d
                            }
                            // 0x804f01d
                            return;
                        }
                        v16 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 1 > v10) {
                            // 0x804efc7
                            v16 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804efc7
                        }
                        // 0x804eff8
                        free((char *)(int32_t)v1[0]);
                        // branch -> 0x804f00c
                        // 0x804f00c
                        if (*(int32_t *)20 != v6) {
                            // 0x804f018
                            __stack_chk_fail();
                            // branch -> 0x804f01d
                        }
                        // 0x804f01d
                        return;
                    }
                    // 0x804ef91
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -1) {
                        v16 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 1 > v10) {
                            // 0x804efc7
                            v16 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804efc7
                        }
                        // 0x804eff8
                        free((char *)(int32_t)v1[0]);
                        // branch -> 0x804f00c
                        // 0x804f00c
                        if (*(int32_t *)20 != v6) {
                            // 0x804f018
                            __stack_chk_fail();
                            // branch -> 0x804f01d
                        }
                        // 0x804f01d
                        return;
                    }
                    // 0x804eff8
                    free((char *)(int32_t)v1[0]);
                    // branch -> 0x804f00c
                }
                // 0x804f00c
                if (*(int32_t *)20 != v6) {
                    // 0x804f018
                    __stack_chk_fail();
                    // branch -> 0x804f01d
                }
                // 0x804f01d
                return;
            }
            // 0x804ee2b
            if (v18 != NULL) {
                // 0x804ee38
                rewind((struct _IO_FILE *)i);
                mem = (int32_t)calloc((int32_t)line + 1, 4);
                v1[0] = mem;
                n_lines = 0;
                if ((int32_t)line > -1) {
                    // 0x804ee71
                    *(int32_t *)(int32_t)mem = 0;
                    v8 = n_lines + 1;
                    n_lines = v8;
                    if ((int32_t)line + 1 > v8) {
                        *(int32_t *)(int32_t)((char)(4 * v8) + v1[0]) = 0;
                        v7 = n_lines + 1;
                        n_lines = v7;
                        while ((int32_t)line + 1 > v7) {
                            // 0x804ee71
                            *(int32_t *)(int32_t)((char)(4 * v7) + v1[0]) = 0;
                            v7 = n_lines + 1;
                            n_lines = v7;
                            // continue -> 0x804ee71
                        }
                        // 0x804ef00
                        n_lines = 0;
                        if (fgets(str4, 2048, (struct _IO_FILE *)i) == NULL) {
                            // 0x804ef24
                            delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                            n_lines = 0;
                            v15 = v1[0];
                            if (*(int32_t *)(int32_t)v15 == 0) {
                                // 0x804ef91
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if ((int32_t)line <= -1) {
                                    // 0x804eff8
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804f00c
                                    // 0x804f00c
                                    if (*(int32_t *)20 != v6) {
                                        // 0x804f018
                                        __stack_chk_fail();
                                        // branch -> 0x804f01d
                                    }
                                    // 0x804f01d
                                    return;
                                }
                                v16 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                                v10 = n_lines + 1;
                                n_lines = v10;
                                while ((int32_t)line + 1 > v10) {
                                    // 0x804efc7
                                    v16 = v1[0];
                                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                    free((char *)v12);
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    // continue -> 0x804efc7
                                }
                                // 0x804eff8
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f00c
                                // 0x804f00c
                                if (*(int32_t *)20 != v6) {
                                    // 0x804f018
                                    __stack_chk_fail();
                                    // branch -> 0x804f01d
                                }
                                // 0x804f01d
                                return;
                            }
                            format = *(int32_t *)(int32_t)((char)0 + v15);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v14 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                                // 0x804ef52
                                format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v9 = n_lines + 1;
                                n_lines = v9;
                                v14 = v1[0];
                                // continue -> 0x804ef52
                            }
                            // 0x804ef91
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line <= -1) {
                                // 0x804eff8
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f00c
                                // 0x804f00c
                                if (*(int32_t *)20 != v6) {
                                    // 0x804f018
                                    __stack_chk_fail();
                                    // branch -> 0x804f01d
                                }
                                // 0x804f01d
                                return;
                            }
                            v16 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 1 > v10) {
                                // 0x804efc7
                                v16 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804efc7
                            }
                            // 0x804eff8
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f00c
                            // 0x804f00c
                            if (*(int32_t *)20 != v6) {
                                // 0x804f018
                                __stack_chk_fail();
                                // branch -> 0x804f01d
                            }
                            // 0x804f01d
                            return;
                        }
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v13 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                            // 0x804eeaa
                            v11 = (char)(4 * n_lines) + v1[0];
                            g3 = v11;
                            len = strlen(str4);
                            *(int32_t *)v11 = (int32_t)malloc(len + 1);
                            v13 = v1[0];
                            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                            strcpy((char *)str5, str4);
                            n_lines++;
                            // continue -> 0x804eeaa
                        }
                        // 0x804ef24
                        delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                        n_lines = 0;
                        v15 = v1[0];
                        if (*(int32_t *)(int32_t)v15 == 0) {
                            // 0x804ef91
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line <= -1) {
                                // 0x804eff8
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f00c
                                // 0x804f00c
                                if (*(int32_t *)20 != v6) {
                                    // 0x804f018
                                    __stack_chk_fail();
                                    // branch -> 0x804f01d
                                }
                                // 0x804f01d
                                return;
                            }
                            v16 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 1 > v10) {
                                // 0x804efc7
                                v16 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804efc7
                            }
                            // 0x804eff8
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f00c
                            // 0x804f00c
                            if (*(int32_t *)20 != v6) {
                                // 0x804f018
                                __stack_chk_fail();
                                // branch -> 0x804f01d
                            }
                            // 0x804f01d
                            return;
                        }
                        format = *(int32_t *)(int32_t)((char)0 + v15);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v14 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                            // 0x804ef52
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v14 = v1[0];
                            // continue -> 0x804ef52
                        }
                        // 0x804ef91
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line <= -1) {
                            // 0x804eff8
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f00c
                            // 0x804f00c
                            if (*(int32_t *)20 != v6) {
                                // 0x804f018
                                __stack_chk_fail();
                                // branch -> 0x804f01d
                            }
                            // 0x804f01d
                            return;
                        }
                        v16 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 1 > v10) {
                            // 0x804efc7
                            v16 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804efc7
                        }
                        // 0x804eff8
                        free((char *)(int32_t)v1[0]);
                        // branch -> 0x804f00c
                        // 0x804f00c
                        if (*(int32_t *)20 != v6) {
                            // 0x804f018
                            __stack_chk_fail();
                            // branch -> 0x804f01d
                        }
                        // 0x804f01d
                        return;
                    }
                }
                // 0x804ef00
                n_lines = 0;
                if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                    v11 = (char)(4 * n_lines) + v1[0];
                    g3 = v11;
                    len = strlen(str4);
                    *(int32_t *)v11 = (int32_t)malloc(len + 1);
                    v13 = v1[0];
                    str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                    strcpy((char *)str5, str4);
                    n_lines++;
                    while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                        // 0x804eeaa
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v13 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        // continue -> 0x804eeaa
                    }
                    // 0x804ef24
                    delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                    n_lines = 0;
                    v15 = v1[0];
                    if (*(int32_t *)(int32_t)v15 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v15);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v14 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                            // 0x804ef52
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v14 = v1[0];
                            // continue -> 0x804ef52
                        }
                        // 0x804ef91
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line > -1) {
                            v16 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 1 > v10) {
                                // 0x804efc7
                                v16 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804efc7
                            }
                            // 0x804eff8
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f00c
                            // 0x804f00c
                            if (*(int32_t *)20 != v6) {
                                // 0x804f018
                                __stack_chk_fail();
                                // branch -> 0x804f01d
                            }
                            // 0x804f01d
                            return;
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804ef91
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -1) {
                        v16 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 1 > v10) {
                            // 0x804efc7
                            v16 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804efc7
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804ef24
                delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                n_lines = 0;
                v15 = v1[0];
                if (*(int32_t *)(int32_t)v15 != 0) {
                    format = *(int32_t *)(int32_t)((char)0 + v15);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v14 = v1[0];
                    while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                        // 0x804ef52
                        format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v14 = v1[0];
                        // continue -> 0x804ef52
                    }
                    // 0x804ef91
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -1) {
                        v16 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 1 > v10) {
                            // 0x804efc7
                            v16 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804efc7
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804ef91
                fflush((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)i);
                fclose((struct _IO_FILE *)f_in);
                n_lines = 0;
                if ((int32_t)line > -1) {
                    v16 = v1[0];
                    free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                    v10 = n_lines + 1;
                    n_lines = v10;
                    while ((int32_t)line + 1 > v10) {
                        // 0x804efc7
                        v16 = v1[0];
                        v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                        free((char *)v12);
                        v10 = n_lines + 1;
                        n_lines = v10;
                        // continue -> 0x804efc7
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804ecd4
    memcpy(TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(TMP_HTML);
    file2 = fopen(TMP_HTML, "w+");
    f_in = (struct _IO_FILE_5 *)file2;
    if (file2 == NULL) {
        // 0x804ed22
        err_num2 = *__errno_location();
        strerror(err_num2);
        print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        // branch -> 0x804ed51
    }
    // 0x804ed51
    atexit((void (**)())exit_db);
    if (VERBOSE == 0) {
        // 0x804ed9b
        sprintf(str4, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", TMP_HTML, gisbase, TMP_NULL, gisbase, TMP_NULL);
        // branch -> 0x804edde
    } else {
        // 0x804ed66
        sprintf(str4, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", TMP_HTML, gisbase, gisbase);
        // branch -> 0x804edde
    }
    // 0x804edde
    strcpy(HTML_CMD, str4);
    line = NULL;
    str = fgets(str4, 2048, (struct _IO_FILE *)i);
    v18 = line;
    char ** v19 = v18;
    if (str != NULL) {
        line = (char **)((int32_t)v18 + 1);
        str2 = fgets(str4, 2048, (struct _IO_FILE *)i);
        v17 = line;
        v19 = v17;
        while (str2 != NULL) {
            // 0x804ee00
            line = (char **)((int32_t)v17 + 1);
            str2 = fgets(str4, 2048, (struct _IO_FILE *)i);
            v17 = line;
            v19 = v17;
            // continue -> 0x804ee00
        }
        // 0x804ee2b
        if (v19 != NULL) {
            // 0x804ee38
            rewind((struct _IO_FILE *)i);
            mem = (int32_t)calloc((int32_t)line + 1, 4);
            v1[0] = mem;
            n_lines = 0;
            if ((int32_t)line > -1) {
                // 0x804ee71
                *(int32_t *)(int32_t)mem = 0;
                v8 = n_lines + 1;
                n_lines = v8;
                if ((int32_t)line + 1 > v8) {
                    *(int32_t *)(int32_t)((char)(4 * v8) + v1[0]) = 0;
                    v7 = n_lines + 1;
                    n_lines = v7;
                    while ((int32_t)line + 1 > v7) {
                        // 0x804ee71
                        *(int32_t *)(int32_t)((char)(4 * v7) + v1[0]) = 0;
                        v7 = n_lines + 1;
                        n_lines = v7;
                        // continue -> 0x804ee71
                    }
                    // 0x804ef00
                    n_lines = 0;
                    if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v13 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                            // 0x804eeaa
                            v11 = (char)(4 * n_lines) + v1[0];
                            g3 = v11;
                            len = strlen(str4);
                            *(int32_t *)v11 = (int32_t)malloc(len + 1);
                            v13 = v1[0];
                            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                            strcpy((char *)str5, str4);
                            n_lines++;
                            // continue -> 0x804eeaa
                        }
                        // 0x804ef24
                        delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                        n_lines = 0;
                        v15 = v1[0];
                        if (*(int32_t *)(int32_t)v15 != 0) {
                            format = *(int32_t *)(int32_t)((char)0 + v15);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v14 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                                // 0x804ef52
                                format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v9 = n_lines + 1;
                                n_lines = v9;
                                v14 = v1[0];
                                // continue -> 0x804ef52
                            }
                            // 0x804ef91
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if ((int32_t)line > -1) {
                                v16 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                                v10 = n_lines + 1;
                                n_lines = v10;
                                while ((int32_t)line + 1 > v10) {
                                    // 0x804efc7
                                    v16 = v1[0];
                                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                    free((char *)v12);
                                    v10 = n_lines + 1;
                                    n_lines = v10;
                                    // continue -> 0x804efc7
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804ef91
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line > -1) {
                            v16 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 1 > v10) {
                                // 0x804efc7
                                v16 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804efc7
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804ef24
                    delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                    n_lines = 0;
                    v15 = v1[0];
                    if (*(int32_t *)(int32_t)v15 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v15);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v14 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                            // 0x804ef52
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v14 = v1[0];
                            // continue -> 0x804ef52
                        }
                        // 0x804ef91
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line > -1) {
                            v16 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 1 > v10) {
                                // 0x804efc7
                                v16 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804efc7
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804ef91
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -1) {
                        v16 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 1 > v10) {
                            // 0x804efc7
                            v16 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804efc7
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // 0x804ef00
            n_lines = 0;
            if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                v11 = (char)(4 * n_lines) + v1[0];
                g3 = v11;
                len = strlen(str4);
                *(int32_t *)v11 = (int32_t)malloc(len + 1);
                v13 = v1[0];
                str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                strcpy((char *)str5, str4);
                n_lines++;
                while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                    // 0x804eeaa
                    v11 = (char)(4 * n_lines) + v1[0];
                    g3 = v11;
                    len = strlen(str4);
                    *(int32_t *)v11 = (int32_t)malloc(len + 1);
                    v13 = v1[0];
                    str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                    strcpy((char *)str5, str4);
                    n_lines++;
                    // continue -> 0x804eeaa
                }
                // 0x804ef24
                delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                n_lines = 0;
                v15 = v1[0];
                if (*(int32_t *)(int32_t)v15 != 0) {
                    format = *(int32_t *)(int32_t)((char)0 + v15);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v14 = v1[0];
                    while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                        // 0x804ef52
                        format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v14 = v1[0];
                        // continue -> 0x804ef52
                    }
                    // 0x804ef91
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if ((int32_t)line > -1) {
                        v16 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                        v10 = n_lines + 1;
                        n_lines = v10;
                        while ((int32_t)line + 1 > v10) {
                            // 0x804efc7
                            v16 = v1[0];
                            v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                            free((char *)v12);
                            v10 = n_lines + 1;
                            n_lines = v10;
                            // continue -> 0x804efc7
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804ef91
                fflush((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)i);
                fclose((struct _IO_FILE *)f_in);
                n_lines = 0;
                if ((int32_t)line > -1) {
                    v16 = v1[0];
                    free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                    v10 = n_lines + 1;
                    n_lines = v10;
                    while ((int32_t)line + 1 > v10) {
                        // 0x804efc7
                        v16 = v1[0];
                        v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                        free((char *)v12);
                        v10 = n_lines + 1;
                        n_lines = v10;
                        // continue -> 0x804efc7
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804ef24
            delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
            n_lines = 0;
            v15 = v1[0];
            if (*(int32_t *)(int32_t)v15 != 0) {
                format = *(int32_t *)(int32_t)((char)0 + v15);
                fprintf((struct _IO_FILE *)f_in, (char *)format);
                v9 = n_lines + 1;
                n_lines = v9;
                v14 = v1[0];
                while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                    // 0x804ef52
                    format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v14 = v1[0];
                    // continue -> 0x804ef52
                }
                // 0x804ef91
                fflush((struct _IO_FILE *)f_in);
                fclose((struct _IO_FILE *)i);
                fclose((struct _IO_FILE *)f_in);
                n_lines = 0;
                if ((int32_t)line > -1) {
                    v16 = v1[0];
                    free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                    v10 = n_lines + 1;
                    n_lines = v10;
                    while ((int32_t)line + 1 > v10) {
                        // 0x804efc7
                        v16 = v1[0];
                        v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                        free((char *)v12);
                        v10 = n_lines + 1;
                        n_lines = v10;
                        // continue -> 0x804efc7
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804ef91
            fflush((struct _IO_FILE *)f_in);
            fclose((struct _IO_FILE *)i);
            fclose((struct _IO_FILE *)f_in);
            n_lines = 0;
            if ((int32_t)line > -1) {
                v16 = v1[0];
                free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                v10 = n_lines + 1;
                n_lines = v10;
                while ((int32_t)line + 1 > v10) {
                    // 0x804efc7
                    v16 = v1[0];
                    v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                    free((char *)v12);
                    v10 = n_lines + 1;
                    n_lines = v10;
                    // continue -> 0x804efc7
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804ee2b
    if (v19 != NULL) {
        // 0x804ee38
        rewind((struct _IO_FILE *)i);
        mem = (int32_t)calloc((int32_t)line + 1, 4);
        v1[0] = mem;
        n_lines = 0;
        if ((int32_t)line > -1) {
            // 0x804ee71
            *(int32_t *)(int32_t)mem = 0;
            v8 = n_lines + 1;
            n_lines = v8;
            if ((int32_t)line + 1 > v8) {
                *(int32_t *)(int32_t)((char)(4 * v8) + v1[0]) = 0;
                v7 = n_lines + 1;
                n_lines = v7;
                while ((int32_t)line + 1 > v7) {
                    // 0x804ee71
                    *(int32_t *)(int32_t)((char)(4 * v7) + v1[0]) = 0;
                    v7 = n_lines + 1;
                    n_lines = v7;
                    // continue -> 0x804ee71
                }
                // 0x804ef00
                n_lines = 0;
                if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                    v11 = (char)(4 * n_lines) + v1[0];
                    g3 = v11;
                    len = strlen(str4);
                    *(int32_t *)v11 = (int32_t)malloc(len + 1);
                    v13 = v1[0];
                    str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                    strcpy((char *)str5, str4);
                    n_lines++;
                    while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                        // 0x804eeaa
                        v11 = (char)(4 * n_lines) + v1[0];
                        g3 = v11;
                        len = strlen(str4);
                        *(int32_t *)v11 = (int32_t)malloc(len + 1);
                        v13 = v1[0];
                        str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                        strcpy((char *)str5, str4);
                        n_lines++;
                        // continue -> 0x804eeaa
                    }
                    // 0x804ef24
                    delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                    n_lines = 0;
                    v15 = v1[0];
                    if (*(int32_t *)(int32_t)v15 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v15);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v14 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                            // 0x804ef52
                            format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v9 = n_lines + 1;
                            n_lines = v9;
                            v14 = v1[0];
                            // continue -> 0x804ef52
                        }
                        // 0x804ef91
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if ((int32_t)line > -1) {
                            v16 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v16));
                            v10 = n_lines + 1;
                            n_lines = v10;
                            while ((int32_t)line + 1 > v10) {
                                // 0x804efc7
                                v16 = v1[0];
                                v12 = *(int32_t *)(int32_t)((char)(4 * v10) + v16);
                                free((char *)v12);
                                v10 = n_lines + 1;
                                n_lines = v10;
                                // continue -> 0x804efc7
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804ef24
                delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
                n_lines = 0;
                v15 = v1[0];
                if (*(int32_t *)(int32_t)v15 != 0) {
                    format = *(int32_t *)(int32_t)((char)0 + v15);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v14 = v1[0];
                    while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                        // 0x804ef52
                        format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v9 = n_lines + 1;
                        n_lines = v9;
                        v14 = v1[0];
                        // continue -> 0x804ef52
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        }
        // 0x804ef00
        n_lines = 0;
        if (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
            v11 = (char)(4 * n_lines) + v1[0];
            g3 = v11;
            len = strlen(str4);
            *(int32_t *)v11 = (int32_t)malloc(len + 1);
            v13 = v1[0];
            str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
            strcpy((char *)str5, str4);
            n_lines++;
            while (fgets(str4, 2048, (struct _IO_FILE *)i) != NULL) {
                // 0x804eeaa
                v11 = (char)(4 * n_lines) + v1[0];
                g3 = v11;
                len = strlen(str4);
                *(int32_t *)v11 = (int32_t)malloc(len + 1);
                v13 = v1[0];
                str5 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v13);
                strcpy((char *)str5, str4);
                n_lines++;
                // continue -> 0x804eeaa
            }
            // 0x804ef24
            delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
            n_lines = 0;
            v15 = v1[0];
            if (*(int32_t *)(int32_t)v15 != 0) {
                format = *(int32_t *)(int32_t)((char)0 + v15);
                fprintf((struct _IO_FILE *)f_in, (char *)format);
                v9 = n_lines + 1;
                n_lines = v9;
                v14 = v1[0];
                while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                    // 0x804ef52
                    format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v9 = n_lines + 1;
                    n_lines = v9;
                    v14 = v1[0];
                    // continue -> 0x804ef52
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x804ef24
        delete_ext_html(pkg_short_name, gisbase, (char **)(int32_t)v1[0]);
        n_lines = 0;
        v15 = v1[0];
        if (*(int32_t *)(int32_t)v15 != 0) {
            format = *(int32_t *)(int32_t)((char)0 + v15);
            fprintf((struct _IO_FILE *)f_in, (char *)format);
            v9 = n_lines + 1;
            n_lines = v9;
            v14 = v1[0];
            while (*(int32_t *)(int32_t)((char)(4 * v9) + v14) != 0) {
                // 0x804ef52
                format = *(int32_t *)(int32_t)((char)(4 * v9) + v14);
                fprintf((struct _IO_FILE *)f_in, (char *)format);
                v9 = n_lines + 1;
                n_lines = v9;
                v14 = v1[0];
                // continue -> 0x804ef52
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804f026 - 0x804f7e7
// Line range:    374 - 549
int32_t restore_html(char * gisbase) {
    char str7[2048];
    char v1[2048];
    // 0x804f026
    int32_t v2;
    int32_t revision = v2; // bp-10320
    int32_t v3;
    int32_t minor = v3; // bp-10316
    int32_t v4;
    int32_t major = v4; // bp-10312
    int32_t v5;
    int32_t n_subdirs = v5; // bp-10308
    int32_t v6;
    int32_t num_restored = v6; // bp-10304
    struct dirent_2 * v7;
    struct dirent_2 * ep = v7; // bp-10300
    struct __dirstream_3 * v8;
    struct __dirstream_3 * subdirp = v8; // bp-10296
    struct _IO_FILE_5 * v9;
    struct _IO_FILE_5 * f_ext = v9; // bp-10288
    struct _IO_FILE_5 * v10;
    struct _IO_FILE_5 * f_out = v10; // bp-10284
    struct _IO_FILE_5 * v11;
    struct _IO_FILE_5 * f_in = v11; // bp-10280
    int32_t v12;
    int32_t i = v12; // bp-10276
    int32_t v13;
    int32_t n_lines = v13; // bp-10272
    int32_t v14;
    int32_t n_entries = v14; // bp-10268
    revision = (int32_t)gisbase;
    int32_t v15 = *(int32_t *)20; // 0x804f03a
    int32_t str4;
    sprintf((char *)&str4, "%s/docs/html/index.html", gisbase);
    struct _IO_FILE * file = fopen((char *)&str4, "r"); // 0x804f077
    i = (int32_t)file;
    int32_t v16; // 0x804f3d4
    int32_t v17; // 0x804f3d4193
    int32_t v18; // 0x804f72b
    int32_t v19; // 0x804f796
    struct _IO_FILE * file2; // 0x804f11a
    struct __dirstream * dirp; // 0x804f22a
    struct dirent * v20; // 0x804f30d89
    char * str; // 0x804f361
    int32_t len; // 0x804f41b
    char * mem2; // 0x804f426
    char * str3; // 0x804f472
    char * str2; // 0x804f47274
    struct __dirstream * dirp3; // 0x804f499
    struct dirent * v21; // 0x804f6d669
    struct dirent * v22; // 0x804f6d672
    char v23;
    char v24;
    int32_t str5;
    int32_t str6;
    char * v25;
    char mem;
    int32_t err_num2; // 0x804f133
    int32_t str8; // 0x804f442
    int32_t format; // 0x804f717
    int32_t v26; // 0x804f78c
    char v27;
    char v28; // 0x804f40c
    char v29; // 0x804f43c
    char v30; // 0x804f73b
    char v31; // 0x804f73b62
    char v32; // 0x804f786
    int32_t v33; // 0x804f36a
    char v34;
    if (file == NULL) {
        // 0x804f08b
        if (*__errno_location() == 2) {
            // 0x804f097
            // branch -> 0x804f7cb
        } else {
            // 0x804f0a1
            fclose((struct _IO_FILE *)i);
            int32_t err_num = *__errno_location(); // 0x804f0b4
            strerror(err_num);
            print_error(-24, "checking for file '%s': %s\n");
            // branch -> 0x804f0e0
            // 0x804f0e0
            memcpy(TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMP_HTML);
            file2 = fopen(TMP_HTML, "w+");
            f_in = (struct _IO_FILE_5 *)file2;
            if (file2 == NULL) {
                // 0x804f12e
                err_num2 = *__errno_location();
                strerror(err_num2);
                print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
                // branch -> 0x804f15d
            }
            // 0x804f15d
            v25 = (char *)revision;
            if (VERBOSE == 0) {
                // 0x804f19b
                sprintf((char *)&str5, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", TMP_HTML, v25, TMP_NULL, v25, TMP_NULL);
                // branch -> 0x804f1de
            } else {
                // 0x804f166
                sprintf((char *)&str5, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", TMP_HTML, v25, v25);
                // branch -> 0x804f1de
            }
            // 0x804f1de
            strcpy(HTML_CMD, (char *)&str5);
            atexit((void (**)())exit_db);
            sprintf((char *)&str6, "%s/docs/extensions", (char *)revision);
            dirp = opendir((char *)&str6);
            f_ext = (struct _IO_FILE_5 *)dirp;
            if (dirp == NULL) {
                // 0x804f23e
                // branch -> 0x804f7cb
            } else {
                // 0x804f248
                num_restored = 0;
                v20 = readdir(dirp);
                subdirp = (struct __dirstream_3 *)v20;
                if (v20 != NULL) {
                    struct dirent * v35 = v20; // 0x804f30d92
                    // branch -> 0x804f261
                    while (true) {
                        // 0x804f261
                        sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v35 + 11));
                        if (strcmp((char *)((int32_t)subdirp + 11), ".") != 0) {
                          lab_0x804f2ac:
                            // 0x804f2ac
                            if (strcmp((char *)((int32_t)subdirp + 11), "..") != 0) {
                                struct __dirstream * dirp2 = opendir(str7); // 0x804f2d2
                                if (dirp2 != NULL) {
                                    // 0x804f2e6
                                    num_restored++;
                                    closedir(dirp2);
                                    // branch -> 0x804f304
                                }
                            }
                        }
                      lab_0x804f304:;
                        struct dirent * v36 = readdir((struct __dirstream *)f_ext); // 0x804f30d
                        subdirp = (struct __dirstream_3 *)v36;
                        if (v36 == NULL) {
                            // break -> 0x804f325
                            break;
                        }
                        v35 = v36;
                        // continue -> 0x804f261
                    }
                    // 0x804f325
                    closedir((struct __dirstream *)f_ext);
                    n_entries = 0;
                    str = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                    v33 = n_entries;
                    // branch -> 0x804f346
                    while (str != NULL) {
                        // 0x804f346
                        n_entries = v33 + 1;
                        str = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                        v33 = n_entries;
                        // continue -> 0x804f346
                    }
                    // 0x804f36a
                    int32_t v37; // eax
                    int32_t v38; // bp+299
                    if (v33 == 0) {
                        // 0x804f373
                        v37 = 0;
                        v38 = 0;
                        // branch -> 0x804f7cb
                    } else {
                        // 0x804f37d
                        rewind((struct _IO_FILE *)i);
                        mem = (int32_t)calloc(num_restored + 10 + n_entries, 4);
                        v1[0] = mem;
                        n_lines = 0;
                        if (num_restored + 10 + n_entries > 0) {
                            // 0x804f3bf
                            *(int32_t *)(int32_t)mem = 0;
                            v17 = n_lines + 1;
                            n_lines = v17;
                            if (num_restored + 10 + n_entries > v17) {
                                v27 = v1[0];
                                *(int32_t *)(int32_t)((char)(4 * v17) + v27) = 0;
                                v16 = n_lines + 1;
                                n_lines = v16;
                                while (num_restored + 10 + n_entries > v16) {
                                    // 0x804f3bf
                                    *(int32_t *)(int32_t)((char)(4 * v16) + v1[0]) = 0;
                                    v16 = n_lines + 1;
                                    n_lines = v16;
                                    // continue -> 0x804f3bf
                                }
                                // 0x804f457
                                n_lines = 0;
                                str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                                v24 = 4 * n_lines;
                                if (str2 == NULL) {
                                    // 0x804f47b
                                    *(int32_t *)(int32_t)(v1[0] + v24) = 0;
                                    dirp3 = opendir((char *)&str6);
                                    f_ext = (struct _IO_FILE_5 *)dirp3;
                                    ep = NULL;
                                    v21 = readdir(dirp3);
                                    subdirp = (struct __dirstream_3 *)v21;
                                    if (v21 != NULL) {
                                        // 0x804f4b3
                                        // branch -> 0x804f4b3
                                        while (true) {
                                            // 0x804f4b3
                                            sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                                            if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                                                goto lab_0x804f6cd_12;
                                            }
                                            goto lab_0x804f502_11;
                                        }
                                    }
                                    // 0x804f6ee
                                    closedir((struct __dirstream *)f_ext);
                                    n_lines = 0;
                                    v31 = v1[0];
                                    if (*(int32_t *)(int32_t)v31 == 0) {
                                        // 0x804f747
                                        fflush((struct _IO_FILE *)f_in);
                                        fclose((struct _IO_FILE *)i);
                                        fclose((struct _IO_FILE *)f_in);
                                        n_lines = 0;
                                        if (num_restored + 10 + n_entries <= 0) {
                                            // 0x804f7b7
                                            free((char *)(int32_t)v1[0]);
                                            // branch -> 0x804f7cb
                                            // 0x804f7cb
                                            if (*(int32_t *)20 != v15) {
                                                // 0x804f7d7
                                                __stack_chk_fail();
                                                // branch -> 0x804f7dc
                                            }
                                            // 0x804f7dc
                                            return (int32_t)ep;
                                        }
                                        v32 = v1[0];
                                        free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        while (num_restored + 10 + n_entries > v19) {
                                            // 0x804f77d
                                            v32 = v1[0];
                                            v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                            free((char *)v26);
                                            v19 = n_lines + 1;
                                            n_lines = v19;
                                            // continue -> 0x804f77d
                                        }
                                        // 0x804f7b7
                                        free((char *)(int32_t)v1[0]);
                                        // branch -> 0x804f7cb
                                        // 0x804f7cb
                                        if (*(int32_t *)20 != v15) {
                                            // 0x804f7d7
                                            __stack_chk_fail();
                                            // branch -> 0x804f7dc
                                        }
                                        // 0x804f7dc
                                        return (int32_t)ep;
                                    }
                                    format = *(int32_t *)(int32_t)((char)0 + v31);
                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                    v18 = n_lines + 1;
                                    n_lines = v18;
                                    v30 = v1[0];
                                    while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                        // 0x804f708
                                        format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                        v18 = n_lines + 1;
                                        n_lines = v18;
                                        v30 = v1[0];
                                        // continue -> 0x804f708
                                    }
                                    // 0x804f747
                                    fflush((struct _IO_FILE *)f_in);
                                    fclose((struct _IO_FILE *)i);
                                    fclose((struct _IO_FILE *)f_in);
                                    n_lines = 0;
                                    if (num_restored + 10 + n_entries <= 0) {
                                        // 0x804f7b7
                                        free((char *)(int32_t)v1[0]);
                                        // branch -> 0x804f7cb
                                        // 0x804f7cb
                                        if (*(int32_t *)20 != v15) {
                                            // 0x804f7d7
                                            __stack_chk_fail();
                                            // branch -> 0x804f7dc
                                        }
                                        // 0x804f7dc
                                        return (int32_t)ep;
                                    }
                                    v32 = v1[0];
                                    free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    while (num_restored + 10 + n_entries > v19) {
                                        // 0x804f77d
                                        v32 = v1[0];
                                        v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                        free((char *)v26);
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        // continue -> 0x804f77d
                                    }
                                    // 0x804f7b7
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804f7cb
                                    // 0x804f7cb
                                    if (*(int32_t *)20 != v15) {
                                        // 0x804f7d7
                                        __stack_chk_fail();
                                        // branch -> 0x804f7dc
                                    }
                                    // 0x804f7dc
                                    return (int32_t)ep;
                                }
                                v28 = v1[0];
                                len = strlen((char *)&str5);
                                mem2 = malloc(len + 1);
                                *(int32_t *)(int32_t)(v28 + v24) = (int32_t)mem2;
                                v29 = v1[0];
                                str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                                strcpy((char *)str8, (char *)&str5);
                                n_lines++;
                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                                v23 = 4 * n_lines;
                                while (str3 != NULL) {
                                    // 0x804f401
                                    len = strlen((char *)&str5);
                                    mem2 = malloc(len + 1);
                                    *(int32_t *)(int32_t)(v1[0] + v23) = (int32_t)mem2;
                                    v29 = v1[0];
                                    str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                                    strcpy((char *)str8, (char *)&str5);
                                    n_lines++;
                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                                    v23 = 4 * n_lines;
                                    // continue -> 0x804f401
                                }
                                // 0x804f47b
                                *(int32_t *)(int32_t)(v1[0] + v23) = 0;
                                dirp3 = opendir((char *)&str6);
                                f_ext = (struct _IO_FILE_5 *)dirp3;
                                ep = NULL;
                                v21 = readdir(dirp3);
                                subdirp = (struct __dirstream_3 *)v21;
                                if (v21 == NULL) {
                                    // 0x804f6ee
                                    closedir((struct __dirstream *)f_ext);
                                    n_lines = 0;
                                    v31 = v1[0];
                                    if (*(int32_t *)(int32_t)v31 == 0) {
                                        // 0x804f747
                                        fflush((struct _IO_FILE *)f_in);
                                        fclose((struct _IO_FILE *)i);
                                        fclose((struct _IO_FILE *)f_in);
                                        n_lines = 0;
                                        if (num_restored + 10 + n_entries <= 0) {
                                            // 0x804f7b7
                                            free((char *)(int32_t)v1[0]);
                                            // branch -> 0x804f7cb
                                            // 0x804f7cb
                                            if (*(int32_t *)20 != v15) {
                                                // 0x804f7d7
                                                __stack_chk_fail();
                                                // branch -> 0x804f7dc
                                            }
                                            // 0x804f7dc
                                            return (int32_t)ep;
                                        }
                                        v32 = v1[0];
                                        free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        while (num_restored + 10 + n_entries > v19) {
                                            // 0x804f77d
                                            v32 = v1[0];
                                            v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                            free((char *)v26);
                                            v19 = n_lines + 1;
                                            n_lines = v19;
                                            // continue -> 0x804f77d
                                        }
                                        // 0x804f7b7
                                        free((char *)(int32_t)v1[0]);
                                        // branch -> 0x804f7cb
                                        // 0x804f7cb
                                        if (*(int32_t *)20 != v15) {
                                            // 0x804f7d7
                                            __stack_chk_fail();
                                            // branch -> 0x804f7dc
                                        }
                                        // 0x804f7dc
                                        return (int32_t)ep;
                                    }
                                    format = *(int32_t *)(int32_t)((char)0 + v31);
                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                    v18 = n_lines + 1;
                                    n_lines = v18;
                                    v30 = v1[0];
                                    while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                        // 0x804f708
                                        format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                        v18 = n_lines + 1;
                                        n_lines = v18;
                                        v30 = v1[0];
                                        // continue -> 0x804f708
                                    }
                                    // 0x804f747
                                    fflush((struct _IO_FILE *)f_in);
                                    fclose((struct _IO_FILE *)i);
                                    fclose((struct _IO_FILE *)f_in);
                                    n_lines = 0;
                                    if (num_restored + 10 + n_entries <= 0) {
                                        // 0x804f7b7
                                        free((char *)(int32_t)v1[0]);
                                        // branch -> 0x804f7cb
                                        // 0x804f7cb
                                        if (*(int32_t *)20 != v15) {
                                            // 0x804f7d7
                                            __stack_chk_fail();
                                            // branch -> 0x804f7dc
                                        }
                                        // 0x804f7dc
                                        return (int32_t)ep;
                                    }
                                    v32 = v1[0];
                                    free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    while (num_restored + 10 + n_entries > v19) {
                                        // 0x804f77d
                                        v32 = v1[0];
                                        v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                        free((char *)v26);
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        // continue -> 0x804f77d
                                    }
                                    // 0x804f7b7
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804f7cb
                                    // 0x804f7cb
                                    if (*(int32_t *)20 != v15) {
                                        // 0x804f7d7
                                        __stack_chk_fail();
                                        // branch -> 0x804f7dc
                                    }
                                    // 0x804f7dc
                                    return (int32_t)ep;
                                }
                                // 0x804f4b3
                                v22 = v21;
                                // branch -> 0x804f4b3
                                while (true) {
                                    // 0x804f4b3
                                    sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v22 + 11));
                                    struct dirent * v39; // 0x804f6d6
                                    if (strcmp((char *)((int32_t)subdirp + 11), ".") != 0) {
                                      lab_0x804f502_11:
                                        // 0x804f502
                                        if (strcmp((char *)((int32_t)subdirp + 11), "..") != 0) {
                                            struct __dirstream * dirp4 = opendir(str7); // 0x804f52c
                                            if (dirp4 != NULL) {
                                                // 0x804f544
                                                closedir(dirp4);
                                                int32_t str9;
                                                sprintf((char *)&str9, "%s/index.html", str7);
                                                struct _IO_FILE * file3 = fopen((char *)&str9, "r"); // 0x804f585
                                                f_out = (struct _IO_FILE_5 *)file3;
                                                if (file3 != NULL) {
                                                    // 0x804f59d
                                                    n_subdirs = 0;
                                                    major = 0;
                                                    minor = 0;
                                                    n_lines = 0;
                                                    if (fgets((char *)&str5, 2048, file3) != NULL) {
                                                        while (true) {
                                                            // 0x804f5c7
                                                            if (strstr((char *)&str5, "<title>") == NULL) {
                                                                // 0x804f5c7
                                                                if (fgets((char *)&str5, 2048, (struct _IO_FILE *)f_out) == NULL) {
                                                                    // break -> 0x804f611
                                                                    break;
                                                                }
                                                                // continue -> 0x804f5c7
                                                                continue;
                                                            } else {
                                                                // 0x804f611
                                                                n_lines = 1;
                                                                // branch -> 0x804f61e
                                                              lab_0x804f61e:;
                                                                char * found_char_pos = strchr((char *)&str5, 40); // 0x804f634
                                                                sscanf((char *)((int32_t)found_char_pos + 1), "%i.%i.%i", &n_subdirs, &major, &minor);
                                                                int32_t v40 = (int32_t)subdirp + 11; // 0x804f67e
                                                                g3 = v40;
                                                                char v41 = v1[0]; // 0x804f68d
                                                                new_ext_html((char *)v40, (char *)revision, (char **)(int32_t)v41, n_subdirs, major, minor);
                                                                ep = (struct dirent_2 *)((int32_t)ep + 1);
                                                                fclose((struct _IO_FILE *)f_out);
                                                                // branch -> 0x804f6cd
                                                            }
                                                          lab_0x804f6cd:
                                                            // 0x804f6cd
                                                            v39 = readdir((struct __dirstream *)f_ext);
                                                            subdirp = (struct __dirstream_3 *)v39;
                                                            if (v39 == NULL) {
                                                                // break (via goto) -> 0x804f6ee
                                                                goto lab_0x804f6ee;
                                                            }
                                                            v22 = v39;
                                                            // continue (via goto) -> 0x804f4b3
                                                            goto lab_0x804f4b3;
                                                        }
                                                        // 0x804f6ee
                                                        closedir((struct __dirstream *)f_ext);
                                                        n_lines = 0;
                                                        v31 = v1[0];
                                                        if (*(int32_t *)(int32_t)v31 == 0) {
                                                            // 0x804f747
                                                            fflush((struct _IO_FILE *)f_in);
                                                            fclose((struct _IO_FILE *)i);
                                                            fclose((struct _IO_FILE *)f_in);
                                                            n_lines = 0;
                                                            if (num_restored + 10 + n_entries <= 0) {
                                                                // 0x804f7b7
                                                                free((char *)(int32_t)v1[0]);
                                                                // branch -> 0x804f7cb
                                                                // 0x804f7cb
                                                                if (*(int32_t *)20 != v15) {
                                                                    // 0x804f7d7
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x804f7dc
                                                                }
                                                                // 0x804f7dc
                                                                return (int32_t)ep;
                                                            }
                                                            v32 = v1[0];
                                                            free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            while (num_restored + 10 + n_entries > v19) {
                                                                // 0x804f77d
                                                                v32 = v1[0];
                                                                v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                                                free((char *)v26);
                                                                v19 = n_lines + 1;
                                                                n_lines = v19;
                                                                // continue -> 0x804f77d
                                                            }
                                                            // 0x804f7b7
                                                            free((char *)(int32_t)v1[0]);
                                                            // branch -> 0x804f7cb
                                                            // 0x804f7cb
                                                            if (*(int32_t *)20 != v15) {
                                                                // 0x804f7d7
                                                                __stack_chk_fail();
                                                                // branch -> 0x804f7dc
                                                            }
                                                            // 0x804f7dc
                                                            return (int32_t)ep;
                                                        }
                                                        format = *(int32_t *)(int32_t)((char)0 + v31);
                                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                        v18 = n_lines + 1;
                                                        n_lines = v18;
                                                        v30 = v1[0];
                                                        while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                                            // 0x804f708
                                                            format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                                                            v18 = n_lines + 1;
                                                            n_lines = v18;
                                                            v30 = v1[0];
                                                            // continue -> 0x804f708
                                                        }
                                                        // 0x804f747
                                                        fflush((struct _IO_FILE *)f_in);
                                                        fclose((struct _IO_FILE *)i);
                                                        fclose((struct _IO_FILE *)f_in);
                                                        n_lines = 0;
                                                        if (num_restored + 10 + n_entries <= 0) {
                                                            // 0x804f7b7
                                                            free((char *)(int32_t)v1[0]);
                                                            // branch -> 0x804f7cb
                                                            // 0x804f7cb
                                                            if (*(int32_t *)20 != v15) {
                                                                // 0x804f7d7
                                                                __stack_chk_fail();
                                                                // branch -> 0x804f7dc
                                                            }
                                                            // 0x804f7dc
                                                            return (int32_t)ep;
                                                        }
                                                        v32 = v1[0];
                                                        free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                                        v19 = n_lines + 1;
                                                        n_lines = v19;
                                                        while (num_restored + 10 + n_entries > v19) {
                                                            // 0x804f77d
                                                            v32 = v1[0];
                                                            v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                                            free((char *)v26);
                                                            v19 = n_lines + 1;
                                                            n_lines = v19;
                                                            // continue -> 0x804f77d
                                                        }
                                                        // 0x804f7b7
                                                        free((char *)(int32_t)v1[0]);
                                                        // branch -> 0x804f7cb
                                                        // 0x804f7cb
                                                        if (*(int32_t *)20 != v15) {
                                                            // 0x804f7d7
                                                            __stack_chk_fail();
                                                            // branch -> 0x804f7dc
                                                        }
                                                        // 0x804f7dc
                                                        return (int32_t)ep;
                                                    }
                                                    // 0x804f611
                                                    if (n_lines == 0) {
                                                        goto lab_0x804f6cd;
                                                    }
                                                    goto lab_0x804f61e;
                                                }
                                            }
                                        }
                                    }
                                  lab_0x804f6cd_12:
                                    // 0x804f6cd
                                    v39 = readdir((struct __dirstream *)f_ext);
                                    subdirp = (struct __dirstream_3 *)v39;
                                    if (v39 == NULL) {
                                        // break -> 0x804f6ee
                                        break;
                                    }
                                    v22 = v39;
                                    // continue -> 0x804f4b3
                                }
                                // 0x804f6ee
                                closedir((struct __dirstream *)f_ext);
                                n_lines = 0;
                                v31 = v1[0];
                                if (*(int32_t *)(int32_t)v31 == 0) {
                                    // 0x804f747
                                    fflush((struct _IO_FILE *)f_in);
                                    fclose((struct _IO_FILE *)i);
                                    fclose((struct _IO_FILE *)f_in);
                                    n_lines = 0;
                                    if (num_restored + 10 + n_entries <= 0) {
                                        // 0x804f7b7
                                        free((char *)(int32_t)v1[0]);
                                        // branch -> 0x804f7cb
                                        // 0x804f7cb
                                        if (*(int32_t *)20 != v15) {
                                            // 0x804f7d7
                                            __stack_chk_fail();
                                            // branch -> 0x804f7dc
                                        }
                                        // 0x804f7dc
                                        return (int32_t)ep;
                                    }
                                    v32 = v1[0];
                                    free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    while (num_restored + 10 + n_entries > v19) {
                                        // 0x804f77d
                                        v32 = v1[0];
                                        v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                        free((char *)v26);
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        // continue -> 0x804f77d
                                    }
                                    // 0x804f7b7
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804f7cb
                                    // 0x804f7cb
                                    if (*(int32_t *)20 != v15) {
                                        // 0x804f7d7
                                        __stack_chk_fail();
                                        // branch -> 0x804f7dc
                                    }
                                    // 0x804f7dc
                                    return (int32_t)ep;
                                }
                                format = *(int32_t *)(int32_t)((char)0 + v31);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v30 = v1[0];
                                while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                    // 0x804f708
                                    format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                    v18 = n_lines + 1;
                                    n_lines = v18;
                                    v30 = v1[0];
                                    // continue -> 0x804f708
                                }
                                // 0x804f747
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if (num_restored + 10 + n_entries <= 0) {
                                    // 0x804f7b7
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804f7cb
                                    // 0x804f7cb
                                    if (*(int32_t *)20 != v15) {
                                        // 0x804f7d7
                                        __stack_chk_fail();
                                        // branch -> 0x804f7dc
                                    }
                                    // 0x804f7dc
                                    return (int32_t)ep;
                                }
                                v32 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (num_restored + 10 + n_entries > v19) {
                                    // 0x804f77d
                                    v32 = v1[0];
                                    v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                    free((char *)v26);
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804f77d
                                }
                                // 0x804f7b7
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f7cb
                                // 0x804f7cb
                                if (*(int32_t *)20 != v15) {
                                    // 0x804f7d7
                                    __stack_chk_fail();
                                    // branch -> 0x804f7dc
                                }
                                // 0x804f7dc
                                return (int32_t)ep;
                            }
                        }
                        // 0x804f457
                        n_lines = 0;
                        str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                        v24 = 4 * n_lines;
                        if (str2 != NULL) {
                            v28 = v1[0];
                            len = strlen((char *)&str5);
                            mem2 = malloc(len + 1);
                            *(int32_t *)(int32_t)(v28 + v24) = (int32_t)mem2;
                            v29 = v1[0];
                            str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                            strcpy((char *)str8, (char *)&str5);
                            n_lines++;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                            v23 = 4 * n_lines;
                            while (str3 != NULL) {
                                // 0x804f401
                                len = strlen((char *)&str5);
                                mem2 = malloc(len + 1);
                                *(int32_t *)(int32_t)(v1[0] + v23) = (int32_t)mem2;
                                v29 = v1[0];
                                str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                                strcpy((char *)str8, (char *)&str5);
                                n_lines++;
                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                                v23 = 4 * n_lines;
                                // continue -> 0x804f401
                            }
                            // 0x804f47b
                            *(int32_t *)(int32_t)(v1[0] + v23) = 0;
                            dirp3 = opendir((char *)&str6);
                            f_ext = (struct _IO_FILE_5 *)dirp3;
                            ep = NULL;
                            v21 = readdir(dirp3);
                            subdirp = (struct __dirstream_3 *)v21;
                            if (v21 != NULL) {
                                // 0x804f4b3
                                // branch -> 0x804f4b3
                                while (true) {
                                    // 0x804f4b3
                                    sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                                    if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                                        goto lab_0x804f6cd_12;
                                    }
                                    goto lab_0x804f502_11;
                                }
                            }
                            // 0x804f6ee
                            closedir((struct __dirstream *)f_ext);
                            n_lines = 0;
                            v31 = v1[0];
                            if (*(int32_t *)(int32_t)v31 == 0) {
                                // 0x804f747
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if (num_restored + 10 + n_entries <= 0) {
                                    // 0x804f7b7
                                    free((char *)(int32_t)v1[0]);
                                    // branch -> 0x804f7cb
                                    // 0x804f7cb
                                    if (*(int32_t *)20 != v15) {
                                        // 0x804f7d7
                                        __stack_chk_fail();
                                        // branch -> 0x804f7dc
                                    }
                                    // 0x804f7dc
                                    return (int32_t)ep;
                                }
                                v32 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (num_restored + 10 + n_entries > v19) {
                                    // 0x804f77d
                                    v32 = v1[0];
                                    v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                    free((char *)v26);
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804f77d
                                }
                                // 0x804f7b7
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f7cb
                                // 0x804f7cb
                                if (*(int32_t *)20 != v15) {
                                    // 0x804f7d7
                                    __stack_chk_fail();
                                    // branch -> 0x804f7dc
                                }
                                // 0x804f7dc
                                return (int32_t)ep;
                            }
                            format = *(int32_t *)(int32_t)((char)0 + v31);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v30 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                // 0x804f708
                                format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v30 = v1[0];
                                // continue -> 0x804f708
                            }
                            // 0x804f747
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (num_restored + 10 + n_entries <= 0) {
                                // 0x804f7b7
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f7cb
                                // 0x804f7cb
                                if (*(int32_t *)20 != v15) {
                                    // 0x804f7d7
                                    __stack_chk_fail();
                                    // branch -> 0x804f7dc
                                }
                                // 0x804f7dc
                                return (int32_t)ep;
                            }
                            v32 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (num_restored + 10 + n_entries > v19) {
                                // 0x804f77d
                                v32 = v1[0];
                                v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                free((char *)v26);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804f77d
                            }
                            // 0x804f7b7
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f7cb
                            // 0x804f7cb
                            if (*(int32_t *)20 != v15) {
                                // 0x804f7d7
                                __stack_chk_fail();
                                // branch -> 0x804f7dc
                            }
                            // 0x804f7dc
                            return (int32_t)ep;
                        }
                        // 0x804f47b
                        *(int32_t *)(int32_t)(v1[0] + v24) = 0;
                        dirp3 = opendir((char *)&str6);
                        f_ext = (struct _IO_FILE_5 *)dirp3;
                        ep = NULL;
                        v21 = readdir(dirp3);
                        subdirp = (struct __dirstream_3 *)v21;
                        if (v21 != NULL) {
                            // 0x804f4b3
                            // branch -> 0x804f4b3
                            while (true) {
                                // 0x804f4b3
                                sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                                if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                                    goto lab_0x804f6cd_12;
                                }
                                goto lab_0x804f502_11;
                            }
                        }
                        // 0x804f6ee
                        closedir((struct __dirstream *)f_ext);
                        n_lines = 0;
                        v31 = v1[0];
                        if (*(int32_t *)(int32_t)v31 != 0) {
                            format = *(int32_t *)(int32_t)((char)0 + v31);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v30 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                // 0x804f708
                                format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v30 = v1[0];
                                // continue -> 0x804f708
                            }
                            // 0x804f747
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (num_restored + 10 + n_entries <= 0) {
                                // 0x804f7b7
                                free((char *)(int32_t)v1[0]);
                                // branch -> 0x804f7cb
                                // 0x804f7cb
                                if (*(int32_t *)20 != v15) {
                                    // 0x804f7d7
                                    __stack_chk_fail();
                                    // branch -> 0x804f7dc
                                }
                                // 0x804f7dc
                                return (int32_t)ep;
                            }
                            v32 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (num_restored + 10 + n_entries > v19) {
                                // 0x804f77d
                                v32 = v1[0];
                                v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                free((char *)v26);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804f77d
                            }
                            // 0x804f7b7
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f7cb
                            // 0x804f7cb
                            if (*(int32_t *)20 != v15) {
                                // 0x804f7d7
                                __stack_chk_fail();
                                // branch -> 0x804f7dc
                            }
                            // 0x804f7dc
                            return (int32_t)ep;
                        }
                        // 0x804f747
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (num_restored + 10 + n_entries > 0) {
                            v32 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (num_restored + 10 + n_entries > v19) {
                                // 0x804f77d
                                v32 = v1[0];
                                v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                free((char *)v26);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804f77d
                            }
                            // 0x804f7b7
                            free((char *)(int32_t)v1[0]);
                            // branch -> 0x804f7cb
                            // 0x804f7cb
                            if (*(int32_t *)20 != v15) {
                                // 0x804f7d7
                                __stack_chk_fail();
                                // branch -> 0x804f7dc
                            }
                            // 0x804f7dc
                            return (int32_t)ep;
                        }
                        // 0x804f7b7
                        free((char *)(int32_t)v1[0]);
                        int32_t v42 = (int32_t)ep; // 0x804f7c5_0
                        v37 = v42;
                        v38 = v42;
                        // branch -> 0x804f7cb
                    }
                    // 0x804f7cb
                    int32_t result; // 0x804f7e4_2
                    if (*(int32_t *)20 != v15) {
                        // 0x804f7d7
                        __stack_chk_fail();
                        result = v37;
                        // branch -> 0x804f7dc
                    } else {
                        result = v38;
                    }
                    // 0x804f7dc
                    return result;
                }
                // 0x804f325
                closedir((struct __dirstream *)f_ext);
                n_entries = 0;
                str = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                v33 = n_entries;
                // branch -> 0x804f346
                while (str != NULL) {
                    // 0x804f346
                    n_entries = v33 + 1;
                    str = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                    v33 = n_entries;
                    // continue -> 0x804f346
                }
                // 0x804f36a
                if (v33 == 0) {
                    // 0x804f373
                    // branch -> 0x804f7cb
                } else {
                    // 0x804f37d
                    rewind((struct _IO_FILE *)i);
                    mem = (int32_t)calloc(num_restored + 10 + n_entries, 4);
                    v1[0] = mem;
                    n_lines = 0;
                    if (num_restored + 10 + n_entries > 0) {
                        // 0x804f3bf
                        *(int32_t *)(int32_t)mem = 0;
                        v17 = n_lines + 1;
                        n_lines = v17;
                        if (num_restored + 10 + n_entries > v17) {
                            v27 = v1[0];
                            *(int32_t *)(int32_t)((char)(4 * v17) + v27) = 0;
                            v16 = n_lines + 1;
                            n_lines = v16;
                            while (num_restored + 10 + n_entries > v16) {
                                // 0x804f3bf
                                *(int32_t *)(int32_t)((char)(4 * v16) + v1[0]) = 0;
                                v16 = n_lines + 1;
                                n_lines = v16;
                                // continue -> 0x804f3bf
                            }
                            // 0x804f457
                            n_lines = 0;
                            str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                            v24 = 4 * n_lines;
                            v34 = v24;
                            if (str2 != NULL) {
                                v28 = v1[0];
                                len = strlen((char *)&str5);
                                mem2 = malloc(len + 1);
                                *(int32_t *)(int32_t)(v28 + v24) = (int32_t)mem2;
                                v29 = v1[0];
                                str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                                strcpy((char *)str8, (char *)&str5);
                                n_lines++;
                                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                                v23 = 4 * n_lines;
                                v34 = v23;
                                while (str3 != NULL) {
                                    // 0x804f401
                                    len = strlen((char *)&str5);
                                    mem2 = malloc(len + 1);
                                    *(int32_t *)(int32_t)(v1[0] + v23) = (int32_t)mem2;
                                    v29 = v1[0];
                                    str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                                    strcpy((char *)str8, (char *)&str5);
                                    n_lines++;
                                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                                    v23 = 4 * n_lines;
                                    v34 = v23;
                                    // continue -> 0x804f401
                                }
                                // 0x804f47b
                                *(int32_t *)(int32_t)(v1[0] + v34) = 0;
                                dirp3 = opendir((char *)&str6);
                                f_ext = (struct _IO_FILE_5 *)dirp3;
                                ep = NULL;
                                v21 = readdir(dirp3);
                                subdirp = (struct __dirstream_3 *)v21;
                                if (v21 != NULL) {
                                    // 0x804f4b3
                                    // branch -> 0x804f4b3
                                    while (true) {
                                        // 0x804f4b3
                                        sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                                        if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                                            goto lab_0x804f6cd_12;
                                        }
                                        goto lab_0x804f502_11;
                                    }
                                }
                                // 0x804f6ee
                                closedir((struct __dirstream *)f_ext);
                                n_lines = 0;
                                v31 = v1[0];
                                if (*(int32_t *)(int32_t)v31 != 0) {
                                    format = *(int32_t *)(int32_t)((char)0 + v31);
                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                    v18 = n_lines + 1;
                                    n_lines = v18;
                                    v30 = v1[0];
                                    while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                        // 0x804f708
                                        format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                                        v18 = n_lines + 1;
                                        n_lines = v18;
                                        v30 = v1[0];
                                        // continue -> 0x804f708
                                    }
                                    // 0x804f747
                                    fflush((struct _IO_FILE *)f_in);
                                    fclose((struct _IO_FILE *)i);
                                    fclose((struct _IO_FILE *)f_in);
                                    n_lines = 0;
                                    if (num_restored + 10 + n_entries > 0) {
                                        v32 = v1[0];
                                        free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        while (num_restored + 10 + n_entries > v19) {
                                            // 0x804f77d
                                            v32 = v1[0];
                                            v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                            free((char *)v26);
                                            v19 = n_lines + 1;
                                            n_lines = v19;
                                            // continue -> 0x804f77d
                                        }
                                        // 0x804f7b7
                                        free((char *)(int32_t)v1[0]);
                                        // branch -> 0x804f7cb
                                        // 0x804f7cb
                                        if (*(int32_t *)20 != v15) {
                                            // 0x804f7d7
                                            __stack_chk_fail();
                                            // branch -> 0x804f7dc
                                        }
                                        // 0x804f7dc
                                        return (int32_t)ep;
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x804f747
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if (num_restored + 10 + n_entries > 0) {
                                    v32 = v1[0];
                                    free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    while (num_restored + 10 + n_entries > v19) {
                                        // 0x804f77d
                                        v32 = v1[0];
                                        v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                        free((char *)v26);
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        // continue -> 0x804f77d
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804f47b
                            *(int32_t *)(int32_t)(v1[0] + v34) = 0;
                            dirp3 = opendir((char *)&str6);
                            f_ext = (struct _IO_FILE_5 *)dirp3;
                            ep = NULL;
                            v21 = readdir(dirp3);
                            subdirp = (struct __dirstream_3 *)v21;
                            if (v21 != NULL) {
                                // 0x804f4b3
                                // branch -> 0x804f4b3
                                while (true) {
                                    // 0x804f4b3
                                    sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                                    if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                                        goto lab_0x804f6cd_12;
                                    }
                                    goto lab_0x804f502_11;
                                }
                            }
                            // 0x804f6ee
                            closedir((struct __dirstream *)f_ext);
                            n_lines = 0;
                            v31 = v1[0];
                            if (*(int32_t *)(int32_t)v31 != 0) {
                                format = *(int32_t *)(int32_t)((char)0 + v31);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v30 = v1[0];
                                while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                    // 0x804f708
                                    format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                                    v18 = n_lines + 1;
                                    n_lines = v18;
                                    v30 = v1[0];
                                    // continue -> 0x804f708
                                }
                                // 0x804f747
                                fflush((struct _IO_FILE *)f_in);
                                fclose((struct _IO_FILE *)i);
                                fclose((struct _IO_FILE *)f_in);
                                n_lines = 0;
                                if (num_restored + 10 + n_entries > 0) {
                                    v32 = v1[0];
                                    free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    while (num_restored + 10 + n_entries > v19) {
                                        // 0x804f77d
                                        v32 = v1[0];
                                        v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                        free((char *)v26);
                                        v19 = n_lines + 1;
                                        n_lines = v19;
                                        // continue -> 0x804f77d
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804f747
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (num_restored + 10 + n_entries > 0) {
                                v32 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (num_restored + 10 + n_entries > v19) {
                                    // 0x804f77d
                                    v32 = v1[0];
                                    v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                    free((char *)v26);
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804f77d
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x804f457
                    n_lines = 0;
                    str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                    v24 = 4 * n_lines;
                    v34 = v24;
                    if (str2 != NULL) {
                        v28 = v1[0];
                        len = strlen((char *)&str5);
                        mem2 = malloc(len + 1);
                        *(int32_t *)(int32_t)(v28 + v24) = (int32_t)mem2;
                        v29 = v1[0];
                        str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                        strcpy((char *)str8, (char *)&str5);
                        n_lines++;
                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                        v23 = 4 * n_lines;
                        v34 = v23;
                        while (str3 != NULL) {
                            // 0x804f401
                            len = strlen((char *)&str5);
                            mem2 = malloc(len + 1);
                            *(int32_t *)(int32_t)(v1[0] + v23) = (int32_t)mem2;
                            v29 = v1[0];
                            str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                            strcpy((char *)str8, (char *)&str5);
                            n_lines++;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                            v23 = 4 * n_lines;
                            v34 = v23;
                            // continue -> 0x804f401
                        }
                        // 0x804f47b
                        *(int32_t *)(int32_t)(v1[0] + v34) = 0;
                        dirp3 = opendir((char *)&str6);
                        f_ext = (struct _IO_FILE_5 *)dirp3;
                        ep = NULL;
                        v21 = readdir(dirp3);
                        subdirp = (struct __dirstream_3 *)v21;
                        if (v21 != NULL) {
                            // 0x804f4b3
                            // branch -> 0x804f4b3
                            while (true) {
                                // 0x804f4b3
                                sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                                if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                                    goto lab_0x804f6cd_12;
                                }
                                goto lab_0x804f502_11;
                            }
                        }
                        // 0x804f6ee
                        closedir((struct __dirstream *)f_ext);
                        n_lines = 0;
                        v31 = v1[0];
                        if (*(int32_t *)(int32_t)v31 != 0) {
                            format = *(int32_t *)(int32_t)((char)0 + v31);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v30 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                // 0x804f708
                                format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v30 = v1[0];
                                // continue -> 0x804f708
                            }
                            // 0x804f747
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (num_restored + 10 + n_entries > 0) {
                                v32 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (num_restored + 10 + n_entries > v19) {
                                    // 0x804f77d
                                    v32 = v1[0];
                                    v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                    free((char *)v26);
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804f77d
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804f747
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (num_restored + 10 + n_entries > 0) {
                            v32 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (num_restored + 10 + n_entries > v19) {
                                // 0x804f77d
                                v32 = v1[0];
                                v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                free((char *)v26);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804f77d
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804f47b
                    *(int32_t *)(int32_t)(v1[0] + v34) = 0;
                    dirp3 = opendir((char *)&str6);
                    f_ext = (struct _IO_FILE_5 *)dirp3;
                    ep = NULL;
                    v21 = readdir(dirp3);
                    subdirp = (struct __dirstream_3 *)v21;
                    if (v21 != NULL) {
                        // 0x804f4b3
                        // branch -> 0x804f4b3
                        while (true) {
                            // 0x804f4b3
                            sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                            if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                                goto lab_0x804f6cd_12;
                            }
                            goto lab_0x804f502_11;
                        }
                    }
                    // 0x804f6ee
                    closedir((struct __dirstream *)f_ext);
                    n_lines = 0;
                    v31 = v1[0];
                    if (*(int32_t *)(int32_t)v31 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v31);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v18 = n_lines + 1;
                        n_lines = v18;
                        v30 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                            // 0x804f708
                            format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v30 = v1[0];
                            // continue -> 0x804f708
                        }
                        // 0x804f747
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (num_restored + 10 + n_entries > 0) {
                            v32 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (num_restored + 10 + n_entries > v19) {
                                // 0x804f77d
                                v32 = v1[0];
                                v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                free((char *)v26);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804f77d
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804f747
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if (num_restored + 10 + n_entries > 0) {
                        v32 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                        v19 = n_lines + 1;
                        n_lines = v19;
                        while (num_restored + 10 + n_entries > v19) {
                            // 0x804f77d
                            v32 = v1[0];
                            v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                            free((char *)v26);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            // continue -> 0x804f77d
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804f0e0
    memcpy(TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(TMP_HTML);
    file2 = fopen(TMP_HTML, "w+");
    f_in = (struct _IO_FILE_5 *)file2;
    if (file2 == NULL) {
        // 0x804f12e
        err_num2 = *__errno_location();
        strerror(err_num2);
        print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        // branch -> 0x804f15d
    }
    // 0x804f15d
    v25 = (char *)revision;
    if (VERBOSE == 0) {
        // 0x804f19b
        sprintf((char *)&str5, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", TMP_HTML, v25, TMP_NULL, v25, TMP_NULL);
        // branch -> 0x804f1de
    } else {
        // 0x804f166
        sprintf((char *)&str5, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", TMP_HTML, v25, v25);
        // branch -> 0x804f1de
    }
    // 0x804f1de
    strcpy(HTML_CMD, (char *)&str5);
    atexit((void (**)())exit_db);
    sprintf((char *)&str6, "%s/docs/extensions", (char *)revision);
    dirp = opendir((char *)&str6);
    f_ext = (struct _IO_FILE_5 *)dirp;
    if (dirp == NULL) {
        // 0x804f23e
        // branch -> 0x804f7cb
    } else {
        // 0x804f248
        num_restored = 0;
        v20 = readdir(dirp);
        subdirp = (struct __dirstream_3 *)v20;
        if (v20 != NULL) {
            // 0x804f261
            // branch -> 0x804f261
            while (true) {
                // 0x804f261
                sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v20 + 11));
                if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                    goto lab_0x804f304;
                }
                goto lab_0x804f2ac;
            }
        }
        // 0x804f325
        closedir((struct __dirstream *)f_ext);
        n_entries = 0;
        str = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
        v33 = n_entries;
        // branch -> 0x804f346
        while (str != NULL) {
            // 0x804f346
            n_entries = v33 + 1;
            str = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
            v33 = n_entries;
            // continue -> 0x804f346
        }
        // 0x804f36a
        if (v33 == 0) {
            // 0x804f373
            // branch -> 0x804f7cb
        } else {
            // 0x804f37d
            rewind((struct _IO_FILE *)i);
            mem = (int32_t)calloc(num_restored + 10 + n_entries, 4);
            v1[0] = mem;
            n_lines = 0;
            if (num_restored + 10 + n_entries > 0) {
                // 0x804f3bf
                *(int32_t *)(int32_t)mem = 0;
                v17 = n_lines + 1;
                n_lines = v17;
                if (num_restored + 10 + n_entries > v17) {
                    v27 = v1[0];
                    *(int32_t *)(int32_t)((char)(4 * v17) + v27) = 0;
                    v16 = n_lines + 1;
                    n_lines = v16;
                    while (num_restored + 10 + n_entries > v16) {
                        // 0x804f3bf
                        *(int32_t *)(int32_t)((char)(4 * v16) + v1[0]) = 0;
                        v16 = n_lines + 1;
                        n_lines = v16;
                        // continue -> 0x804f3bf
                    }
                    // 0x804f457
                    n_lines = 0;
                    str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                    v24 = 4 * n_lines;
                    v34 = v24;
                    if (str2 != NULL) {
                        v28 = v1[0];
                        len = strlen((char *)&str5);
                        mem2 = malloc(len + 1);
                        *(int32_t *)(int32_t)(v28 + v24) = (int32_t)mem2;
                        v29 = v1[0];
                        str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                        strcpy((char *)str8, (char *)&str5);
                        n_lines++;
                        str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                        v23 = 4 * n_lines;
                        v34 = v23;
                        while (str3 != NULL) {
                            // 0x804f401
                            len = strlen((char *)&str5);
                            mem2 = malloc(len + 1);
                            *(int32_t *)(int32_t)(v1[0] + v23) = (int32_t)mem2;
                            v29 = v1[0];
                            str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                            strcpy((char *)str8, (char *)&str5);
                            n_lines++;
                            str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                            v23 = 4 * n_lines;
                            v34 = v23;
                            // continue -> 0x804f401
                        }
                        // 0x804f47b
                        *(int32_t *)(int32_t)(v1[0] + v34) = 0;
                        dirp3 = opendir((char *)&str6);
                        f_ext = (struct _IO_FILE_5 *)dirp3;
                        ep = NULL;
                        v21 = readdir(dirp3);
                        subdirp = (struct __dirstream_3 *)v21;
                        if (v21 != NULL) {
                            // 0x804f4b3
                            // branch -> 0x804f4b3
                            while (true) {
                                // 0x804f4b3
                                sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                                if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                                    goto lab_0x804f6cd_12;
                                }
                                goto lab_0x804f502_11;
                            }
                        }
                        // 0x804f6ee
                        closedir((struct __dirstream *)f_ext);
                        n_lines = 0;
                        v31 = v1[0];
                        if (*(int32_t *)(int32_t)v31 != 0) {
                            format = *(int32_t *)(int32_t)((char)0 + v31);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v30 = v1[0];
                            while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                                // 0x804f708
                                format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                                fprintf((struct _IO_FILE *)f_in, (char *)format);
                                v18 = n_lines + 1;
                                n_lines = v18;
                                v30 = v1[0];
                                // continue -> 0x804f708
                            }
                            // 0x804f747
                            fflush((struct _IO_FILE *)f_in);
                            fclose((struct _IO_FILE *)i);
                            fclose((struct _IO_FILE *)f_in);
                            n_lines = 0;
                            if (num_restored + 10 + n_entries > 0) {
                                v32 = v1[0];
                                free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                                v19 = n_lines + 1;
                                n_lines = v19;
                                while (num_restored + 10 + n_entries > v19) {
                                    // 0x804f77d
                                    v32 = v1[0];
                                    v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                    free((char *)v26);
                                    v19 = n_lines + 1;
                                    n_lines = v19;
                                    // continue -> 0x804f77d
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804f747
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (num_restored + 10 + n_entries > 0) {
                            v32 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (num_restored + 10 + n_entries > v19) {
                                // 0x804f77d
                                v32 = v1[0];
                                v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                free((char *)v26);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804f77d
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804f47b
                    *(int32_t *)(int32_t)(v1[0] + v34) = 0;
                    dirp3 = opendir((char *)&str6);
                    f_ext = (struct _IO_FILE_5 *)dirp3;
                    ep = NULL;
                    v21 = readdir(dirp3);
                    subdirp = (struct __dirstream_3 *)v21;
                    if (v21 != NULL) {
                        // 0x804f4b3
                        // branch -> 0x804f4b3
                        while (true) {
                            // 0x804f4b3
                            sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                            if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                                goto lab_0x804f6cd_12;
                            }
                            goto lab_0x804f502_11;
                        }
                    }
                    // 0x804f6ee
                    closedir((struct __dirstream *)f_ext);
                    n_lines = 0;
                    v31 = v1[0];
                    if (*(int32_t *)(int32_t)v31 != 0) {
                        format = *(int32_t *)(int32_t)((char)0 + v31);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v18 = n_lines + 1;
                        n_lines = v18;
                        v30 = v1[0];
                        while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                            // 0x804f708
                            format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                            fprintf((struct _IO_FILE *)f_in, (char *)format);
                            v18 = n_lines + 1;
                            n_lines = v18;
                            v30 = v1[0];
                            // continue -> 0x804f708
                        }
                        // 0x804f747
                        fflush((struct _IO_FILE *)f_in);
                        fclose((struct _IO_FILE *)i);
                        fclose((struct _IO_FILE *)f_in);
                        n_lines = 0;
                        if (num_restored + 10 + n_entries > 0) {
                            v32 = v1[0];
                            free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                            v19 = n_lines + 1;
                            n_lines = v19;
                            while (num_restored + 10 + n_entries > v19) {
                                // 0x804f77d
                                v32 = v1[0];
                                v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                                free((char *)v26);
                                v19 = n_lines + 1;
                                n_lines = v19;
                                // continue -> 0x804f77d
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x804f747
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if (num_restored + 10 + n_entries > 0) {
                        v32 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                        v19 = n_lines + 1;
                        n_lines = v19;
                        while (num_restored + 10 + n_entries > v19) {
                            // 0x804f77d
                            v32 = v1[0];
                            v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                            free((char *)v26);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            // continue -> 0x804f77d
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // 0x804f457
            n_lines = 0;
            str2 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
            v24 = 4 * n_lines;
            v34 = v24;
            if (str2 != NULL) {
                v28 = v1[0];
                len = strlen((char *)&str5);
                mem2 = malloc(len + 1);
                *(int32_t *)(int32_t)(v28 + v24) = (int32_t)mem2;
                v29 = v1[0];
                str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                strcpy((char *)str8, (char *)&str5);
                n_lines++;
                str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                v23 = 4 * n_lines;
                v34 = v23;
                while (str3 != NULL) {
                    // 0x804f401
                    len = strlen((char *)&str5);
                    mem2 = malloc(len + 1);
                    *(int32_t *)(int32_t)(v1[0] + v23) = (int32_t)mem2;
                    v29 = v1[0];
                    str8 = *(int32_t *)(int32_t)((char)(4 * n_lines) + v29);
                    strcpy((char *)str8, (char *)&str5);
                    n_lines++;
                    str3 = fgets((char *)&str5, 2048, (struct _IO_FILE *)i);
                    v23 = 4 * n_lines;
                    v34 = v23;
                    // continue -> 0x804f401
                }
                // 0x804f47b
                *(int32_t *)(int32_t)(v1[0] + v34) = 0;
                dirp3 = opendir((char *)&str6);
                f_ext = (struct _IO_FILE_5 *)dirp3;
                ep = NULL;
                v21 = readdir(dirp3);
                subdirp = (struct __dirstream_3 *)v21;
                if (v21 != NULL) {
                    // 0x804f4b3
                    // branch -> 0x804f4b3
                    while (true) {
                        // 0x804f4b3
                        sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v21 + 11));
                        if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                            goto lab_0x804f6cd_12;
                        }
                        goto lab_0x804f502_11;
                    }
                }
                // 0x804f6ee
                closedir((struct __dirstream *)f_ext);
                n_lines = 0;
                v31 = v1[0];
                if (*(int32_t *)(int32_t)v31 != 0) {
                    format = *(int32_t *)(int32_t)((char)0 + v31);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v18 = n_lines + 1;
                    n_lines = v18;
                    v30 = v1[0];
                    while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                        // 0x804f708
                        format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                        fprintf((struct _IO_FILE *)f_in, (char *)format);
                        v18 = n_lines + 1;
                        n_lines = v18;
                        v30 = v1[0];
                        // continue -> 0x804f708
                    }
                    // 0x804f747
                    fflush((struct _IO_FILE *)f_in);
                    fclose((struct _IO_FILE *)i);
                    fclose((struct _IO_FILE *)f_in);
                    n_lines = 0;
                    if (num_restored + 10 + n_entries > 0) {
                        v32 = v1[0];
                        free((char *)*(int32_t *)(int32_t)((char)0 + v32));
                        v19 = n_lines + 1;
                        n_lines = v19;
                        while (num_restored + 10 + n_entries > v19) {
                            // 0x804f77d
                            v32 = v1[0];
                            v26 = *(int32_t *)(int32_t)((char)(4 * v19) + v32);
                            free((char *)v26);
                            v19 = n_lines + 1;
                            n_lines = v19;
                            // continue -> 0x804f77d
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x804f47b
            *(int32_t *)(int32_t)(v1[0] + v34) = 0;
            dirp3 = opendir((char *)&str6);
            f_ext = (struct _IO_FILE_5 *)dirp3;
            ep = NULL;
            v21 = readdir(dirp3);
            subdirp = (struct __dirstream_3 *)v21;
            if (v21 != NULL) {
                // 0x804f4b3
                v22 = v21;
                // branch -> 0x804f4b3
              lab_0x804f4b3:
                while (true) {
                    // 0x804f4b3
                    sprintf(str7, "%s/%s", &str6, (char *)((int32_t)v22 + 11));
                    if (strcmp((char *)((int32_t)subdirp + 11), ".") == 0) {
                        goto lab_0x804f6cd_12;
                    }
                    goto lab_0x804f502_11;
                }
            }
          lab_0x804f6ee:
            // 0x804f6ee
            closedir((struct __dirstream *)f_ext);
            n_lines = 0;
            v31 = v1[0];
            if (*(int32_t *)(int32_t)v31 != 0) {
                format = *(int32_t *)(int32_t)((char)0 + v31);
                fprintf((struct _IO_FILE *)f_in, (char *)format);
                v18 = n_lines + 1;
                n_lines = v18;
                v30 = v1[0];
                while (*(int32_t *)(int32_t)((char)(4 * v18) + v30) != 0) {
                    // 0x804f708
                    format = *(int32_t *)(int32_t)((char)(4 * v18) + v30);
                    fprintf((struct _IO_FILE *)f_in, (char *)format);
                    v18 = n_lines + 1;
                    n_lines = v18;
                    v30 = v1[0];
                    // continue -> 0x804f708
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x804f7e8 - 0x804faaa
// Line range:    29 - 81
void check_extension(char * package, char * name, int32_t * major, int32_t * minor, int32_t * revision) {
    char v1[2048];
    char str[2048];
    char v2[2048];
    // 0x804f7e8
    int32_t v3;
    int32_t error = v3; // bp-2072
    int32_t v4 = *(int32_t *)20; // 0x804f821
    v2[4] = 0;
    memset(v1, 0, 511);
    fwrite("Checking extension ...", 1, 22, (struct _IO_FILE *)g15);
    strcpy(str, package);
    char v5 = chdir(str);
    v2[0] = v5;
    if (v5 <= 0) {
        int32_t err_num = *__errno_location(); // 0x804f8ad
        strerror(err_num);
        print_error(-2, "extension '%s' not accessible: %s\n");
        // branch -> 0x804f8d9
    }
    struct _IO_FILE * file = fopen("id", "r"); // 0x804f8ea
    error = (int32_t)file;
    struct _IO_FILE * file2; // 0x804f9a6
    char items_assigned;
    if (file != NULL) {
        // 0x804f914
        fscanf(file, "%[<GRASS extension package>] ", &str);
        if (strcmp("<GRASS extension package>", str) != 0) {
            // 0x804f94f
            fclose((struct _IO_FILE *)error);
            print_error(-6, "unknown file identifier.\n");
            // branch -> 0x804f971
        }
        // 0x804f971
        fclose((struct _IO_FILE *)error);
        get_package_name(".", name);
        file2 = fopen("version", "r");
        error = (int32_t)file2;
        if (file2 == NULL) {
            // 0x804f9ba
            print_error(-6, "'version' file not readable.\n");
            // branch -> 0x804fa71
        } else {
            // 0x804f9d3
            nc_fgets_nb(str, 2048, (struct _IO_FILE_2 *)file2);
            *minor = 0;
            *revision = 0;
            items_assigned = sscanf(str, "%i.%i.%i", major, minor, revision);
            v2[0] = items_assigned;
            if (items_assigned <= 0) {
                // 0x804fa4f
                fclose((struct _IO_FILE *)error);
                print_error(-6, "invalid or missing version information.\n");
                // branch -> 0x804fa71
            }
        }
        // 0x804fa71
        print_done();
        chdir("..");
        fclose((struct _IO_FILE *)error);
        if (*(int32_t *)20 != v4) {
            // 0x804fa9c
            __stack_chk_fail();
            // branch -> 0x804faa1
        }
        // 0x804faa1
        return;
    }
    // 0x804f8fe
    print_error(-6, "'id' file not readable.\n");
    // branch -> 0x804f971
    // 0x804f971
    fclose((struct _IO_FILE *)error);
    get_package_name(".", name);
    file2 = fopen("version", "r");
    error = (int32_t)file2;
    if (file2 == NULL) {
        // 0x804f9ba
        print_error(-6, "'version' file not readable.\n");
        // branch -> 0x804fa71
        // 0x804fa71
        print_done();
        chdir("..");
        fclose((struct _IO_FILE *)error);
        if (*(int32_t *)20 != v4) {
            // 0x804fa9c
            __stack_chk_fail();
            // branch -> 0x804faa1
        }
        // 0x804faa1
        return;
    }
    // 0x804f9d3
    nc_fgets_nb(str, 2048, (struct _IO_FILE_2 *)file2);
    *minor = 0;
    *revision = 0;
    items_assigned = sscanf(str, "%i.%i.%i", major, minor, revision);
    v2[0] = items_assigned;
    if (items_assigned <= 0) {
        // 0x804fa4f
        fclose((struct _IO_FILE *)error);
        print_error(-6, "invalid or missing version information.\n");
        // branch -> 0x804fa71
    }
    // 0x804fa71
    print_done();
    chdir("..");
    fclose((struct _IO_FILE *)error);
    if (*(int32_t *)20 != v4) {
        // 0x804fa9c
        __stack_chk_fail();
        // branch -> 0x804faa1
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x804faab - 0x804ff42
// Line range:    88 - 198
void unpack_extension(char * package) {
    char str[2048];
    char v1[2048];
    // 0x804faab
    int32_t v2;
    int32_t ftype = v2; // bp-2080
    int32_t v3;
    int32_t fd = v3; // bp-2076
    int32_t v4;
    int32_t error = v4; // bp-2072
    ftype = (int32_t)package;
    int32_t v5 = *(int32_t *)20; // 0x804fabe
    fwrite("Uncompressing files...", 1, 22, (struct _IO_FILE *)g15);
    memcpy(TMPDIR, "/tmp/grass.extension.XXXXXX", 28);
    mkstemp(TMPDIR);
    int32_t fd2 = open(TMPDIR, O_CREAT);
    error = fd2;
    if (fd2 == -1) {
        int32_t err_num = *__errno_location(); // 0x804fb49
        strerror(err_num);
        print_error(-7, "could not create temp directory name: %s");
        exit(-7);
        // UNREACHABLE
    }
    if (VERBOSE != 0) {
        // 0x804fb80
        fprintf((struct _IO_FILE *)g15, "\nUncompressing to: %s.\n", TMPDIR);
        fd2 = error;
        // branch -> 0x804fb9e
    }
    // 0x804fb9e
    close(fd2);
    remove(TMPDIR);
    mkdir_s(TMPDIR, "0700");
    atexit((void (**)())exit_tmp);
    sprintf(str, "cp %s %s", (char *)ftype, TMPDIR);
    char system_rc = system(str);
    v1[0] = system_rc;
    if (system_rc <= 0) {
        // 0x804fc1e
        print_error(-7, "could not copy extension files to temp dir.\n");
        exit(-7);
        // UNREACHABLE
    }
    int32_t v6 = check_filetype((char *)ftype); // 0x804fc47
    fd = v6;
    int32_t v7 = v6; // 0x804fcf7
    char * v8;
    char * v9;
    char system_rc2;
    int32_t v10; // 0x804fd7d
    int32_t v11; // 0x804feaa
    int32_t v12; // 0x804fed1
    int32_t v13; // 0x804fef8
    switch (v6) {
        case 0: {
            // 0x804fc71
            print_warning("file name not '.tar.gz', '.tgz', '.tar.bz2', '.tbz' or '.zip'. Assuming '.tgz'.\n");
            fd = 1;
            // branch -> 0x804fc7a
        }
        case 1: {
            // 0x804fc7a
            basename();
            char * v14 = (char *)g1;
            if (VERBOSE == 0) {
                // 0x804fcbe
                sprintf(str, "tar -xzf %s/%s -C %s", TMPDIR, v14, TMPDIR);
                // branch -> 0x804fcf7
            } else {
                // 0x804fc83
                sprintf(str, "tar -xzvf %s/%s -C %s", TMPDIR, v14, TMPDIR);
                // branch -> 0x804fcf7
            }
            // 0x804fcf7
            v7 = fd;
            // branch -> 0x804fcf7
            // 0x804fcf7
            v10 = v7;
            if (v7 == 2) {
                // 0x804fd00
                basename();
                sprintf(str, "tar -xjvf %s/%s -C %s", TMPDIR, (char *)g1, TMPDIR);
                v10 = fd;
                // branch -> 0x804fd7d
            }
            // 0x804fd7d
            if (v10 != 3) {
                // 0x804fe03
                if (fd != 4) {
                    // 0x804fe89
                    system_rc2 = system(str);
                    v1[0] = system_rc2;
                    if (system_rc2 > 0) {
                        // 0x804ff2b
                        print_done();
                        if (*(int32_t *)20 != v5) {
                            // 0x804ff3c
                            __stack_chk_fail();
                            // branch -> 0x804ff41
                        }
                        // 0x804ff41
                        return;
                    }
                    // 0x804feaa
                    v11 = fd;
                    v12 = v11;
                    if (v11 == 1) {
                        // 0x804feb3
                        print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
                        v12 = fd;
                        // branch -> 0x804fed1
                    }
                    // 0x804fed1
                    v13 = v12;
                    if (v12 == 2) {
                        // 0x804feda
                        print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
                        v13 = fd;
                        // branch -> 0x804fef8
                    }
                    // 0x804fef8
                    if (v13 == 3) {
                        // 0x804ff01
                        print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
                        // branch -> 0x804ff1f
                    }
                    // 0x804ff1f
                    exit(-7);
                    // UNREACHABLE
                }
                // 0x804fe0c
                basename();
                v9 = (char *)g1;
                if (VERBOSE == 0) {
                    // 0x804fe50
                    sprintf(str, "tar -xf %s/%s -C %s", TMPDIR, v9, TMPDIR);
                    // branch -> 0x804fe89
                } else {
                    // 0x804fe15
                    sprintf(str, "tar -xvf %s/%s -C %s", TMPDIR, v9, TMPDIR);
                    // branch -> 0x804fe89
                }
                // 0x804fe89
                system_rc2 = system(str);
                v1[0] = system_rc2;
                if (system_rc2 > 0) {
                    // 0x804ff2b
                    print_done();
                    if (*(int32_t *)20 != v5) {
                        // 0x804ff3c
                        __stack_chk_fail();
                        // branch -> 0x804ff41
                    }
                    // 0x804ff41
                    return;
                }
                // 0x804feaa
                v11 = fd;
                v12 = v11;
                if (v11 == 1) {
                    // 0x804feb3
                    print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
                    v12 = fd;
                    // branch -> 0x804fed1
                }
                // 0x804fed1
                v13 = v12;
                if (v12 == 2) {
                    // 0x804feda
                    print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
                    v13 = fd;
                    // branch -> 0x804fef8
                }
                // 0x804fef8
                if (v13 == 3) {
                    // 0x804ff01
                    print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
                    // branch -> 0x804ff1f
                }
                // 0x804ff1f
                exit(-7);
                // UNREACHABLE
            }
            // 0x804fd86
            basename();
            v8 = (char *)g1;
            if (VERBOSE == 0) {
                // 0x804fdca
                sprintf(str, "unzip -qq %s/%s -d %s", TMPDIR, v8, TMPDIR);
                // branch -> 0x804fe03
            } else {
                // 0x804fd8f
                sprintf(str, "unzip %s/%s -d %s", TMPDIR, v8, TMPDIR);
                // branch -> 0x804fe03
            }
            // 0x804fe03
            if (fd != 4) {
                // 0x804fe89
                system_rc2 = system(str);
                v1[0] = system_rc2;
                if (system_rc2 > 0) {
                    // 0x804ff2b
                    print_done();
                    if (*(int32_t *)20 != v5) {
                        // 0x804ff3c
                        __stack_chk_fail();
                        // branch -> 0x804ff41
                    }
                    // 0x804ff41
                    return;
                }
                // 0x804feaa
                v11 = fd;
                v12 = v11;
                if (v11 == 1) {
                    // 0x804feb3
                    print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
                    v12 = fd;
                    // branch -> 0x804fed1
                }
                // 0x804fed1
                v13 = v12;
                if (v12 == 2) {
                    // 0x804feda
                    print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
                    v13 = fd;
                    // branch -> 0x804fef8
                }
                // 0x804fef8
                if (v13 == 3) {
                    // 0x804ff01
                    print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
                    // branch -> 0x804ff1f
                }
                // 0x804ff1f
                exit(-7);
                // UNREACHABLE
            }
            // 0x804fe0c
            basename();
            v9 = (char *)g1;
            if (VERBOSE == 0) {
                // 0x804fe50
                sprintf(str, "tar -xf %s/%s -C %s", TMPDIR, v9, TMPDIR);
                // branch -> 0x804fe89
            } else {
                // 0x804fe15
                sprintf(str, "tar -xvf %s/%s -C %s", TMPDIR, v9, TMPDIR);
                // branch -> 0x804fe89
            }
            // 0x804fe89
            system_rc2 = system(str);
            v1[0] = system_rc2;
            if (system_rc2 > 0) {
                // 0x804ff2b
                print_done();
                if (*(int32_t *)20 != v5) {
                    // 0x804ff3c
                    __stack_chk_fail();
                    // branch -> 0x804ff41
                }
                // 0x804ff41
                return;
            }
            // 0x804feaa
            v11 = fd;
            v12 = v11;
            if (v11 == 1) {
                // 0x804feb3
                print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
                v12 = fd;
                // branch -> 0x804fed1
            }
            // 0x804fed1
            v13 = v12;
            if (v12 == 2) {
                // 0x804feda
                print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
                v13 = fd;
                // branch -> 0x804fef8
            }
            // 0x804fef8
            if (v13 == 3) {
                // 0x804ff01
                print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
                // branch -> 0x804ff1f
            }
            // 0x804ff1f
            exit(-7);
            // UNREACHABLE
        }
    }
    // 0x804fcf7
    v10 = v7;
    if (v7 == 2) {
        // 0x804fd00
        basename();
        sprintf(str, "tar -xjvf %s/%s -C %s", TMPDIR, (char *)g1, TMPDIR);
        v10 = fd;
        // branch -> 0x804fd7d
    }
    // 0x804fd7d
    if (v10 != 3) {
        // 0x804fe03
        if (fd != 4) {
            // 0x804fe89
            system_rc2 = system(str);
            v1[0] = system_rc2;
            if (system_rc2 > 0) {
                // 0x804ff2b
                print_done();
                if (*(int32_t *)20 != v5) {
                    // 0x804ff3c
                    __stack_chk_fail();
                    // branch -> 0x804ff41
                }
                // 0x804ff41
                return;
            }
            // 0x804feaa
            v11 = fd;
            v12 = v11;
            if (v11 == 1) {
                // 0x804feb3
                print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
                v12 = fd;
                // branch -> 0x804fed1
            }
            // 0x804fed1
            v13 = v12;
            if (v12 == 2) {
                // 0x804feda
                print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
                v13 = fd;
                // branch -> 0x804fef8
            }
            // 0x804fef8
            if (v13 == 3) {
                // 0x804ff01
                print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
                // branch -> 0x804ff1f
            }
            // 0x804ff1f
            exit(-7);
            // UNREACHABLE
        }
        // 0x804fe0c
        basename();
        v9 = (char *)g1;
        if (VERBOSE == 0) {
            // 0x804fe50
            sprintf(str, "tar -xf %s/%s -C %s", TMPDIR, v9, TMPDIR);
            // branch -> 0x804fe89
        } else {
            // 0x804fe15
            sprintf(str, "tar -xvf %s/%s -C %s", TMPDIR, v9, TMPDIR);
            // branch -> 0x804fe89
        }
        // 0x804fe89
        system_rc2 = system(str);
        v1[0] = system_rc2;
        if (system_rc2 > 0) {
            // 0x804ff2b
            print_done();
            if (*(int32_t *)20 != v5) {
                // 0x804ff3c
                __stack_chk_fail();
                // branch -> 0x804ff41
            }
            // 0x804ff41
            return;
        }
        // 0x804feaa
        v11 = fd;
        v12 = v11;
        if (v11 == 1) {
            // 0x804feb3
            print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
            v12 = fd;
            // branch -> 0x804fed1
        }
        // 0x804fed1
        v13 = v12;
        if (v12 == 2) {
            // 0x804feda
            print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
            v13 = fd;
            // branch -> 0x804fef8
        }
        // 0x804fef8
        if (v13 == 3) {
            // 0x804ff01
            print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
            // branch -> 0x804ff1f
        }
        // 0x804ff1f
        exit(-7);
        // UNREACHABLE
    }
    // 0x804fd86
    basename();
    v8 = (char *)g1;
    if (VERBOSE == 0) {
        // 0x804fdca
        sprintf(str, "unzip -qq %s/%s -d %s", TMPDIR, v8, TMPDIR);
        // branch -> 0x804fe03
    } else {
        // 0x804fd8f
        sprintf(str, "unzip %s/%s -d %s", TMPDIR, v8, TMPDIR);
        // branch -> 0x804fe03
    }
    // 0x804fe03
    if (fd != 4) {
        // 0x804fe89
        system_rc2 = system(str);
        v1[0] = system_rc2;
        if (system_rc2 > 0) {
            // 0x804ff2b
            print_done();
            if (*(int32_t *)20 != v5) {
                // 0x804ff3c
                __stack_chk_fail();
                // branch -> 0x804ff41
            }
            // 0x804ff41
            return;
        }
        // 0x804feaa
        v11 = fd;
        v12 = v11;
        if (v11 == 1) {
            // 0x804feb3
            print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
            v12 = fd;
            // branch -> 0x804fed1
        }
        // 0x804fed1
        v13 = v12;
        if (v12 == 2) {
            // 0x804feda
            print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
            v13 = fd;
            // branch -> 0x804fef8
        }
        // 0x804fef8
        if (v13 == 3) {
            // 0x804ff01
            print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
            // branch -> 0x804ff1f
        }
        // 0x804ff1f
        exit(-7);
        // UNREACHABLE
    }
    // 0x804fe0c
    basename();
    v9 = (char *)g1;
    if (VERBOSE == 0) {
        // 0x804fe50
        sprintf(str, "tar -xf %s/%s -C %s", TMPDIR, v9, TMPDIR);
        // branch -> 0x804fe89
    } else {
        // 0x804fe15
        sprintf(str, "tar -xvf %s/%s -C %s", TMPDIR, v9, TMPDIR);
        // branch -> 0x804fe89
    }
    // 0x804fe89
    system_rc2 = system(str);
    v1[0] = system_rc2;
    if (system_rc2 > 0) {
        // 0x804ff2b
        print_done();
        if (*(int32_t *)20 != v5) {
            // 0x804ff3c
            __stack_chk_fail();
            // branch -> 0x804ff41
        }
        // 0x804ff41
        return;
    }
    // 0x804feaa
    v11 = fd;
    v12 = v11;
    if (v11 == 1) {
        // 0x804feb3
        print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
        v12 = fd;
        // branch -> 0x804fed1
    }
    // 0x804fed1
    v13 = v12;
    if (v12 == 2) {
        // 0x804feda
        print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
        v13 = fd;
        // branch -> 0x804fef8
    }
    // 0x804fef8
    if (v13 == 3) {
        // 0x804ff01
        print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
        // branch -> 0x804ff1f
    }
    // 0x804ff1f
    exit(-7);
    // UNREACHABLE
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x804ff43 - 0x805014d
// Line range:    201 - 235
void query_extension(char * package, char * name, int32_t major, int32_t minor, int32_t revision, char * short_name, char * invocation, char * org_name) {
    char str[2048];
    char v1[2048];
    // 0x804ff43
    basename();
    strcpy(str, (char *)g1);
    char v2 = chdir(str);
    v1[0] = v2;
    if (v2 <= 0) {
        int32_t err_num = *__errno_location(); // 0x804ffc6
        strerror(err_num);
        print_error(-2, "extension '%s' not accessible: %s\n");
        // branch -> 0x804fff2
    }
    // 0x804fff2
    fprintf((struct _IO_FILE *)g15, "\nExtension '%s', version %i.%i.%i\n\n", name, major, minor, revision);
    dump_ascii("description", "Description");
    dump_ascii("commands", "Commands provided");
    dump_ascii("libs", "Libraries provided");
    dump_ascii("headers", "Header files provided");
    dump_ascii("depends", "Dependencies");
    dump_ascii("bugs", "Bugs");
    sprintf(str, "../%s", package);
    list_binaries(str);
    dump_ascii("authors", "Author(s)");
    fprintf((struct _IO_FILE *)g15, "Type '%s -d %s' to see more detailed information.\n", invocation, org_name);
    fprintf((struct _IO_FILE *)g15, "Type '%s -l %s' to see copyright information.\n", invocation, org_name);
    system("sh post");
    exit(0);
    // UNREACHABLE
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x805014e - 0x805021f
// Line range:    242 - 258
void print_cfg(void) {
    char v1[2048];
    char str[2048];
    int32_t v2 = *(int32_t *)20; // 0x8050158
    char file = (int32_t)fopen("config.msg", "r");
    v1[0] = file;
    if (file != 0) {
        // 0x8050187
        fwrite("\nResult of configuration: \n", 1, 27, (struct _IO_FILE *)g15);
        if (fgets(str, 2048, (struct _IO_FILE *)(int32_t)v1[0]) != NULL) {
            fputs(str, (struct _IO_FILE *)g15);
            while (fgets(str, 2048, (struct _IO_FILE *)(int32_t)v1[0]) != NULL) {
                // 0x80501b1
                fputs(str, (struct _IO_FILE *)g15);
                // continue -> 0x80501b1
            }
            // 0x80501ec
            fputc(10, (struct _IO_FILE *)g15);
            // branch -> 0x8050201
            // 0x8050201
            remove("config.msg");
            if (*(int32_t *)20 != v2) {
                // 0x8050219
                __stack_chk_fail();
                // branch -> 0x805021e
            }
            // 0x805021e
            return;
        }
        // 0x80501ec
        fputc(10, (struct _IO_FILE *)g15);
        // branch -> 0x8050201
    }
    // 0x8050201
    remove("config.msg");
    if (*(int32_t *)20 != v2) {
        // 0x8050219
        __stack_chk_fail();
        // branch -> 0x805021e
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8050220 - 0x8050c66
// Line range:    263 - 469
void source_install(char * package, char * gisbase, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version) {
    struct stat_1 v1;
    char str4[2048];
    struct stat_1 buf;
    char v2[2048];
    int32_t v3;
    int32_t major = v3; // bp-10288
    char * v4;
    char * grass_revision = v4; // bp-10284
    char * v5;
    char * grass_minor = v5; // bp-10280
    char * v6;
    char * grass_major = v6; // bp-10276
    char * v7;
    char * verstr = v7; // bp-10272
    struct _IO_FILE_6 * v8;
    struct _IO_FILE_6 * f = v8; // bp-10268
    int32_t v9;
    int32_t error = v9; // bp-10264
    v1.e0 = (int32_t)package;
    int32_t v10 = *(int32_t *)20; // 0x805024e
    char v11 = stat(gisbase, (struct stat *)&buf);
    v2[0] = v11;
    if (v11 <= 0) {
        int32_t err_num = *__errno_location(); // 0x8050284
        strerror(err_num);
        print_error(-5, "installation directory invalid: %s\n");
        // branch -> 0x80502a6
    }
    // 0x80502a6
    sprintf(GINSTALL_DST, "GINSTALL_DST=%s", gisbase);
    putenv(GINSTALL_DST);
    int32_t str;
    sprintf((char *)&str, "%s/include", gisbase);
    sprintf(GINSTALL_INC, "GINSTALL_INC=%s", &str);
    putenv(GINSTALL_INC);
    sprintf((char *)&str, "%s/lib", gisbase);
    sprintf(GINSTALL_LIB, "GINSTALL_LIB=%s", &str);
    putenv(GINSTALL_LIB);
    sprintf(GEM_GRASS_DIR, "GEM_GRASS_DIR=%s", gisbase);
    putenv(GEM_GRASS_DIR);
    char * str2 = strdup(grass_version); // 0x805039d
    f = (struct _IO_FILE_6 *)str2;
    verstr = strtok(str2, ".");
    grass_major = strtok(NULL, ".");
    grass_minor = strtok(NULL, ".");
    grass_revision = (char *)strtol(verstr, NULL, 10);
    major = strtol(grass_major, NULL, 10);
    strtol(grass_minor, NULL, 10);
    strtol(grass_minor, NULL, 10);
    free((char *)f);
    atexit((void (**)())exit_tmp);
    basename();
    int32_t str3;
    sprintf((char *)&str3, "%s/src", (char *)g1);
    char v12 = chdir((char *)&str3);
    v2[0] = v12;
    if (v12 <= 0) {
        int32_t err_num2 = *__errno_location(); // 0x80504cc
        strerror(err_num2);
        print_error(-2, "extension files in '%s' not accessible: %s\n");
        // branch -> 0x80504f8
    }
    // 0x80504f8
    if (SKIP_CFG == 0) {
        // 0x8050505
        int32_t system_rc;
        if (VERBOSE == 0) {
            // 0x8050573
            fwrite("Configuring...", 1, 14, (struct _IO_FILE *)g15);
            sprintf(str4, "sh %s %s --quiet &> %s", CONFIG_CMD, (void (**)())&CONFIG_OPTS, TMP_NULL);
            system_rc = system(str4);
            // branch -> 0x80505de
        } else {
            // 0x805050e
            fwrite("Running configure script:\n", 1, 26, (struct _IO_FILE *)g15);
            sprintf(str4, "sh %s %s", CONFIG_CMD, (void (**)())&CONFIG_OPTS);
            system_rc = system(str4);
            // branch -> 0x80505de
        }
        char v13 = system_rc;
        v2[0] = v13;
        char v14 = v13; // 0x80505fb
        if (v13 == -1) {
            // 0x80505e7
            print_error(-27, "could not run configure script.\n");
            v14 = v2[0];
            // branch -> 0x80505fb
        }
        // 0x80505fb
        if (v14 >= 1) {
            // 0x8050604
            print_error(-3, "system configuration failed.\n");
            // branch -> 0x8050618
        }
        // 0x8050618
        print_done();
        print_cfg();
        // branch -> 0x8050622
    }
    // 0x8050622
    sprintf(GEM_EXT_NAME, "GEM_EXT_NAME=%s", pkg_short_name);
    putenv(GEM_EXT_NAME);
    sprintf((char *)&str, "%i.%i.%i", pkg_major, pkg_minor, pkg_revision);
    sprintf(GEM_EXT_VERSION, "GEM_EXT_VERSION=%s", &str);
    putenv(GEM_EXT_VERSION);
    dump_html("../description", TMP_DESCR);
    dump_html("../info", TMP_INFO);
    dump_html("../depends", TMP_DEPS);
    dump_html("../bugs", TMP_BUGS);
    dump_html("../authors", TMP_AUTHORS);
    sprintf(GEM_EXT_DESCR, "GEM_EXT_DESCR=%s", TMP_DESCR);
    putenv(GEM_EXT_DESCR);
    sprintf(GEM_EXT_INFO, "GEM_EXT_INFO=%s", TMP_INFO);
    putenv(GEM_EXT_INFO);
    sprintf(GEM_EXT_DEPS, "GEM_EXT_DEPS=%s", TMP_DEPS);
    putenv(GEM_EXT_DEPS);
    sprintf(GEM_EXT_BUGS, "GEM_EXT_BUGS=%s", TMP_BUGS);
    putenv(GEM_EXT_BUGS);
    sprintf(GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s", TMP_AUTHORS);
    putenv(GEM_EXT_AUTHORS);
    atexit((void (**)())exit_tmp);
    check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
    int32_t system_rc2;
    if (VERBOSE == 0) {
        // 0x805085f
        fwrite("Compiling...", 1, 12, (struct _IO_FILE *)g15);
        sprintf(str4, "%s -f Makefile &> %s", MAKE_CMD, (void (**)())&TMP_NULL);
        system_rc2 = system(str4);
        // branch -> 0x80508c2
    } else {
        // 0x805080c
        fprintf((struct _IO_FILE *)g15, "Running '%s':\n", MAKE_CMD);
        sprintf(str4, "%s -f Makefile", MAKE_CMD);
        system_rc2 = system(str4);
        // branch -> 0x80508c2
    }
    char v15 = system_rc2;
    v2[0] = v15;
    struct _IO_FILE * file; // 0x805094b
    int32_t str5;
    int32_t str6;
    int32_t err_num3; // 0x8050964
    if (v15 != -1) {
        // 0x80508f0
        if (v15 >= 1) {
            // 0x80508f9
            print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
            // branch -> 0x805090d
        }
        // 0x805090d
        print_done();
        fwrite("Installing...", 1, 13, (struct _IO_FILE *)g15);
        file = fopen("../uninstall", "r");
        error = (int32_t)file;
        if (file == NULL) {
            // 0x805095f
            err_num3 = *__errno_location();
            strerror(err_num3);
            print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
            // branch -> 0x8050a26
        } else {
            // 0x8050983
            if (VERBOSE == 0) {
                // 0x80509cf
                sprintf((char *)&str, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", gisbase, pkg_short_name, TMP_NULL);
                strcpy(UNINSTALL_CMD, (char *)&str);
                // branch -> 0x8050a18
            } else {
                // 0x805098c
                sprintf((char *)&str, "cp -vf ../uninstall %s/etc/uninstall.%s ;", gisbase, pkg_short_name);
                strcpy(UNINSTALL_CMD, (char *)&str);
                // branch -> 0x8050a18
            }
            // 0x8050a18
            fclose((struct _IO_FILE *)error);
            // branch -> 0x8050a26
        }
        // 0x8050a26
        register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
        check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
        if (grass_revision == (char *)6 && major <= 0) {
            // 0x8050a8f
            register_entries_gisman(pkg_short_name, gisbase);
            // branch -> 0x8050aa7
        }
        // 0x8050aa7
        register_entries_gisman2(pkg_short_name, gisbase);
        register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
        if (VERBOSE == 0) {
            // 0x8050b50
            sprintf((char *)&str5, "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", MAKE_CMD, (void (**)())&TMP_NULL, TMPDB, gisbase, TMP_NULL, gisbase, TMP_NULL);
            // branch -> 0x8050ba3
        } else {
            // 0x8050af5
            fprintf((struct _IO_FILE *)g15, "Running '%s install':\n", MAKE_CMD);
            sprintf((char *)&str5, "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", MAKE_CMD, (void (**)())&TMPDB, gisbase, gisbase);
            // branch -> 0x8050ba3
        }
        // 0x8050ba3
        if (VERBOSE == 0) {
            // 0x8050bcd
            sprintf((char *)&str6, "sh ../post &> %s", TMP_NULL);
            // branch -> 0x8050bec
        } else {
            // 0x8050bac
            memcpy((char *)&str6, "sh ../post", 11);
            // branch -> 0x8050bec
        }
        // 0x8050bec
        sprintf((char *)&str, "%s %s %s %s %s %s", &str5, (void (**)())&UNINSTALL_CMD, GISMAN_CMD, GISMAN2_CMD, HTML_CMD, &str6);
        su(gisbase, (char *)&str);
        print_done();
        if (*(int32_t *)20 != v10) {
            // 0x8050c60
            __stack_chk_fail();
            // branch -> 0x8050c65
        }
        // 0x8050c65
        return;
    }
    // 0x80508cb
    if (VERBOSE == 0) {
        // 0x80508d4
        print_error(-9, "could not run '%s' do you have make tools installed?\n");
        // branch -> 0x80508f0
        // 0x80508f0
        if (v2[0] >= 1) {
            // 0x80508f9
            print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
            // branch -> 0x805090d
        }
        // 0x805090d
        print_done();
        fwrite("Installing...", 1, 13, (struct _IO_FILE *)g15);
        file = fopen("../uninstall", "r");
        error = (int32_t)file;
        if (file == NULL) {
            // 0x805095f
            err_num3 = *__errno_location();
            strerror(err_num3);
            print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
            // branch -> 0x8050a26
        } else {
            // 0x8050983
            if (VERBOSE == 0) {
                // 0x80509cf
                sprintf((char *)&str, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", gisbase, pkg_short_name, TMP_NULL);
                strcpy(UNINSTALL_CMD, (char *)&str);
                // branch -> 0x8050a18
            } else {
                // 0x805098c
                sprintf((char *)&str, "cp -vf ../uninstall %s/etc/uninstall.%s ;", gisbase, pkg_short_name);
                strcpy(UNINSTALL_CMD, (char *)&str);
                // branch -> 0x8050a18
            }
            // 0x8050a18
            fclose((struct _IO_FILE *)error);
            // branch -> 0x8050a26
        }
        // 0x8050a26
        register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
        check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
        if (grass_revision == (char *)6 && major <= 0) {
            // 0x8050a8f
            register_entries_gisman(pkg_short_name, gisbase);
            // branch -> 0x8050aa7
        }
        // 0x8050aa7
        register_entries_gisman2(pkg_short_name, gisbase);
        register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
        if (VERBOSE == 0) {
            // 0x8050b50
            sprintf((char *)&str5, "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", MAKE_CMD, (void (**)())&TMP_NULL, TMPDB, gisbase, TMP_NULL, gisbase, TMP_NULL);
            // branch -> 0x8050ba3
        } else {
            // 0x8050af5
            fprintf((struct _IO_FILE *)g15, "Running '%s install':\n", MAKE_CMD);
            sprintf((char *)&str5, "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", MAKE_CMD, (void (**)())&TMPDB, gisbase, gisbase);
            // branch -> 0x8050ba3
        }
        // 0x8050ba3
        if (VERBOSE == 0) {
            // 0x8050bcd
            sprintf((char *)&str6, "sh ../post &> %s", TMP_NULL);
            // branch -> 0x8050bec
        } else {
            // 0x8050bac
            memcpy((char *)&str6, "sh ../post", 11);
            // branch -> 0x8050bec
        }
        // 0x8050bec
        sprintf((char *)&str, "%s %s %s %s %s %s", &str5, (void (**)())&UNINSTALL_CMD, GISMAN_CMD, GISMAN2_CMD, HTML_CMD, &str6);
        su(gisbase, (char *)&str);
        print_done();
        if (*(int32_t *)20 != v10) {
            // 0x8050c60
            __stack_chk_fail();
            // branch -> 0x8050c65
        }
        // 0x8050c65
        return;
    }
    // 0x805090d
    print_done();
    fwrite("Installing...", 1, 13, (struct _IO_FILE *)g15);
    file = fopen("../uninstall", "r");
    error = (int32_t)file;
    if (file == NULL) {
        // 0x805095f
        err_num3 = *__errno_location();
        strerror(err_num3);
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
        // branch -> 0x8050a26
    } else {
        // 0x8050983
        if (VERBOSE == 0) {
            // 0x80509cf
            sprintf((char *)&str, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", gisbase, pkg_short_name, TMP_NULL);
            strcpy(UNINSTALL_CMD, (char *)&str);
            // branch -> 0x8050a18
        } else {
            // 0x805098c
            sprintf((char *)&str, "cp -vf ../uninstall %s/etc/uninstall.%s ;", gisbase, pkg_short_name);
            strcpy(UNINSTALL_CMD, (char *)&str);
            // branch -> 0x8050a18
        }
        // 0x8050a18
        fclose((struct _IO_FILE *)error);
        // branch -> 0x8050a26
    }
    // 0x8050a26
    register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
    check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
    if (grass_revision == (char *)6 && major <= 0) {
        // 0x8050a8f
        register_entries_gisman(pkg_short_name, gisbase);
        // branch -> 0x8050aa7
    }
    // 0x8050aa7
    register_entries_gisman2(pkg_short_name, gisbase);
    register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
    if (VERBOSE == 0) {
        // 0x8050b50
        sprintf((char *)&str5, "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", MAKE_CMD, (void (**)())&TMP_NULL, TMPDB, gisbase, TMP_NULL, gisbase, TMP_NULL);
        // branch -> 0x8050ba3
    } else {
        // 0x8050af5
        fprintf((struct _IO_FILE *)g15, "Running '%s install':\n", MAKE_CMD);
        sprintf((char *)&str5, "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", MAKE_CMD, (void (**)())&TMPDB, gisbase, gisbase);
        // branch -> 0x8050ba3
    }
    // 0x8050ba3
    if (VERBOSE == 0) {
        // 0x8050bcd
        sprintf((char *)&str6, "sh ../post &> %s", TMP_NULL);
        // branch -> 0x8050bec
    } else {
        // 0x8050bac
        memcpy((char *)&str6, "sh ../post", 11);
        // branch -> 0x8050bec
    }
    // 0x8050bec
    sprintf((char *)&str, "%s %s %s %s %s %s", &str5, (void (**)())&UNINSTALL_CMD, GISMAN_CMD, GISMAN2_CMD, HTML_CMD, &str6);
    su(gisbase, (char *)&str);
    print_done();
    if (*(int32_t *)20 != v10) {
        // 0x8050c60
        __stack_chk_fail();
        // branch -> 0x8050c65
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8050c67 - 0x8051489
// Line range:    475 - 633
void bin_install(char * package, char * gisbase, char * bins, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version) {
    struct stat_1 v1;
    char v2[2048];
    char str5[2048];
    struct stat_1 buf;
    int32_t v3;
    int32_t major = v3; // bp-8240
    char * v4;
    char * grass_revision = v4; // bp-8236
    char * v5;
    char * grass_minor = v5; // bp-8232
    char * v6;
    char * grass_major = v6; // bp-8228
    char * v7;
    char * verstr = v7; // bp-8224
    struct _IO_FILE_6 * v8;
    struct _IO_FILE_6 * f = v8; // bp-8220
    int32_t v9;
    int32_t error = v9; // bp-8216
    v1.e0 = (int32_t)package;
    char v10 = stat(gisbase, (struct stat *)&buf);
    v2[0] = v10;
    if (v10 <= 0) {
        int32_t err_num = *__errno_location(); // 0x8050cd4
        strerror(err_num);
        print_error(-5, "installation directory invalid: %s\n");
        // branch -> 0x8050cf6
    }
    // 0x8050cf6
    sprintf(GINSTALL_DST, "GINSTALL_DST=%s", gisbase);
    putenv(GINSTALL_DST);
    int32_t str;
    sprintf((char *)&str, "%s/include", gisbase);
    sprintf(GINSTALL_INC, "GINSTALL_INC=%s", &str);
    putenv(GINSTALL_INC);
    sprintf((char *)&str, "%s/lib", gisbase);
    sprintf(GINSTALL_LIB, "GINSTALL_LIB=%s", &str);
    putenv(GINSTALL_LIB);
    sprintf(GEM_GRASS_DIR, "GEM_GRASS_DIR=%s", gisbase);
    putenv(GEM_GRASS_DIR);
    char * str2 = strdup(grass_version); // 0x8050ded
    f = (struct _IO_FILE_6 *)str2;
    verstr = strtok(str2, ".");
    grass_major = strtok(NULL, ".");
    grass_minor = strtok(NULL, ".");
    grass_revision = (char *)strtol(verstr, NULL, 10);
    major = strtol(grass_major, NULL, 10);
    strtol(grass_minor, NULL, 10);
    strtol(grass_minor, NULL, 10);
    free((char *)f);
    atexit((void (**)())exit_tmp);
    basename();
    int32_t str3;
    sprintf((char *)&str3, "%s/%s", (char *)g1, bins);
    char v11 = chdir((char *)&str3);
    v2[0] = v11;
    if (v11 <= 0) {
        int32_t err_num2 = *__errno_location(); // 0x8050f26
        strerror(err_num2);
        print_error(-2, "extension file binaries in '%s' not accessible: %s\n");
        // branch -> 0x8050f52
    }
    // 0x8050f52
    sprintf(GEM_EXT_NAME, "GEM_EXT_NAME=%s", pkg_short_name);
    putenv(GEM_EXT_NAME);
    sprintf((char *)&str, "%i.%i.%i", pkg_major, pkg_minor, pkg_revision);
    sprintf(GEM_EXT_VERSION, "GEM_EXT_VERSION=%s", &str);
    putenv(GEM_EXT_VERSION);
    dump_html("../description", TMP_DESCR);
    dump_html("../info", TMP_INFO);
    dump_html("../depends", TMP_DEPS);
    dump_html("../bugs", TMP_BUGS);
    dump_html("../authors", TMP_AUTHORS);
    sprintf(GEM_EXT_DESCR, "GEM_EXT_DESCR=%s", TMP_DESCR);
    putenv(GEM_EXT_DESCR);
    sprintf(GEM_EXT_INFO, "GEM_EXT_INFO=%s", TMP_INFO);
    putenv(GEM_EXT_INFO);
    sprintf(GEM_EXT_DEPS, "GEM_EXT_DEPS=%s", TMP_DEPS);
    putenv(GEM_EXT_DEPS);
    sprintf(GEM_EXT_BUGS, "GEM_EXT_BUGS=%s", TMP_BUGS);
    putenv(GEM_EXT_BUGS);
    sprintf(GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s", TMP_AUTHORS);
    putenv(GEM_EXT_AUTHORS);
    atexit((void (**)())exit_tmp);
    check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
    fwrite("Installing...", 1, 13, (struct _IO_FILE *)g15);
    struct _IO_FILE * file = fopen("../uninstall", "r"); // 0x805116c
    error = (int32_t)file;
    if (file == NULL) {
        int32_t err_num3 = *__errno_location(); // 0x8051185
        strerror(err_num3);
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
        // branch -> 0x8051247
    } else {
        // 0x80511a4
        if (VERBOSE == 0) {
            // 0x80511f0
            sprintf((char *)&str, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", gisbase, pkg_short_name, TMP_NULL);
            strcpy(UNINSTALL_CMD, (char *)&str);
            // branch -> 0x8051239
        } else {
            // 0x80511ad
            sprintf((char *)&str, "cp -vf ../uninstall %s/etc/uninstall.%s ;", gisbase, pkg_short_name);
            strcpy(UNINSTALL_CMD, (char *)&str);
            // branch -> 0x8051239
        }
        // 0x8051239
        fclose((struct _IO_FILE *)error);
        // branch -> 0x8051247
    }
    // 0x8051247
    register_extension(gisbase, bins, pkg_short_name, pkg_major, pkg_minor, pkg_revision);
    check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
    if (grass_revision == (char *)6 && major <= 0) {
        // 0x80512b2
        register_entries_gisman(pkg_short_name, gisbase);
        // branch -> 0x80512ca
    }
    // 0x80512ca
    register_entries_gisman2(pkg_short_name, gisbase);
    register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
    int32_t str4;
    if (VERBOSE == 0) {
        // 0x8051373
        sprintf((char *)&str4, "bin/%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", MAKE_CMD, (void (**)())&TMP_NULL, TMPDB, gisbase, TMP_NULL, gisbase, TMP_NULL);
        // branch -> 0x80513c6
    } else {
        // 0x8051318
        fprintf((struct _IO_FILE *)g15, "Running '%s install':\n", MAKE_CMD);
        sprintf((char *)&str4, "bin/%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", MAKE_CMD, (void (**)())&TMPDB, gisbase, gisbase);
        // branch -> 0x80513c6
    }
    // 0x80513c6
    if (VERBOSE == 0) {
        // 0x80513f0
        sprintf(str5, "sh ../post &> %s", TMP_NULL);
        // branch -> 0x805140f
    } else {
        // 0x80513cf
        memcpy(str5, "sh ../post", 11);
        // branch -> 0x805140f
    }
    // 0x805140f
    sprintf((char *)&str, "%s %s %s %s %s %s", &str4, (void (**)())&UNINSTALL_CMD, GISMAN_CMD, GISMAN2_CMD, HTML_CMD, str5);
    su(gisbase, (char *)&str);
    print_done();
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8051483
        __stack_chk_fail();
        // branch -> 0x8051488
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x805148a - 0x8051cf3
// Line range:    636 - 805
void test_install(char * package, char * gisbase, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version) {
    struct stat_1 v1;
    char str4[2048];
    struct stat_1 buf;
    char v2[2048];
    int32_t v3;
    int32_t major = v3; // bp-6192
    char * v4;
    char * grass_revision = v4; // bp-6188
    char * v5;
    char * grass_minor = v5; // bp-6184
    char * v6;
    char * grass_major = v6; // bp-6180
    char * v7;
    char * verstr = v7; // bp-6176
    struct _IO_FILE_6 * v8;
    struct _IO_FILE_6 * f = v8; // bp-6172
    v1.e0 = (int32_t)package;
    int32_t v9 = *(int32_t *)20; // 0x80514b8
    char v10 = stat(gisbase, (struct stat *)&buf);
    v2[0] = v10;
    if (v10 <= 0) {
        int32_t err_num = *__errno_location(); // 0x80514ee
        strerror(err_num);
        print_error(-5, "installation directory invalid: %s\n");
        // branch -> 0x8051510
    }
    // 0x8051510
    sprintf(GINSTALL_DST, "GINSTALL_DST=%s", gisbase);
    putenv(GINSTALL_DST);
    int32_t str;
    sprintf((char *)&str, "%s/include", gisbase);
    sprintf(GINSTALL_INC, "GINSTALL_INC=%s", &str);
    putenv(GINSTALL_INC);
    sprintf((char *)&str, "%s/lib", gisbase);
    sprintf(GINSTALL_LIB, "GINSTALL_LIB=%s", &str);
    putenv(GINSTALL_LIB);
    sprintf(GEM_GRASS_DIR, "GEM_GRASS_DIR=%s", gisbase);
    putenv(GEM_GRASS_DIR);
    char * str2 = strdup(grass_version); // 0x8051607
    f = (struct _IO_FILE_6 *)str2;
    verstr = strtok(str2, ".");
    grass_major = strtok(NULL, ".");
    grass_minor = strtok(NULL, ".");
    grass_revision = (char *)strtol(verstr, NULL, 10);
    major = strtol(grass_major, NULL, 10);
    strtol(grass_minor, NULL, 10);
    strtol(grass_minor, NULL, 10);
    free((char *)f);
    atexit((void (**)())exit_tmp);
    basename();
    int32_t str3;
    sprintf((char *)&str3, "%s/src", (char *)g1);
    char v11 = chdir((char *)&str3);
    v2[0] = v11;
    if (v11 <= 0) {
        int32_t err_num2 = *__errno_location(); // 0x8051736
        strerror(err_num2);
        print_error(-2, "extension files in '%s' not accessible: %s\n");
        // branch -> 0x8051762
    }
    // 0x8051762
    if (SKIP_CFG == 0) {
        // 0x805176f
        int32_t system_rc;
        if (VERBOSE == 0) {
            // 0x80517dd
            fwrite("Configuring...", 1, 14, (struct _IO_FILE *)g15);
            sprintf(str4, "sh %s %s --quiet &> %s", CONFIG_CMD, (void (**)())&CONFIG_OPTS, TMP_NULL);
            system_rc = system(str4);
            // branch -> 0x8051848
        } else {
            // 0x8051778
            fwrite("Running configure script:\n", 1, 26, (struct _IO_FILE *)g15);
            sprintf(str4, "sh %s %s", CONFIG_CMD, (void (**)())&CONFIG_OPTS);
            system_rc = system(str4);
            // branch -> 0x8051848
        }
        char v12 = system_rc;
        v2[0] = v12;
        char v13 = v12; // 0x8051865
        if (v12 == -1) {
            // 0x8051851
            print_error(-27, "could not run configure script.\n");
            v13 = v2[0];
            // branch -> 0x8051865
        }
        // 0x8051865
        if (v13 >= 1) {
            // 0x805186e
            print_error(-3, "system configuration failed.\n");
            // branch -> 0x8051882
        }
        // 0x8051882
        print_done();
        print_cfg();
        // branch -> 0x805188c
    }
    // 0x805188c
    sprintf(GEM_EXT_NAME, "GEM_EXT_NAME=%s", pkg_short_name);
    putenv(GEM_EXT_NAME);
    sprintf((char *)&str, "%i.%i.%i", pkg_major, pkg_minor, pkg_revision);
    sprintf(GEM_EXT_VERSION, "GEM_EXT_VERSION=%s", &str);
    putenv(GEM_EXT_VERSION);
    dump_plain("../description", TMP_DESCR);
    dump_plain("../info", TMP_INFO);
    dump_plain("../depends", TMP_DEPS);
    dump_plain("../bugs", TMP_BUGS);
    dump_plain("../authors", TMP_AUTHORS);
    sprintf(GEM_EXT_DESCR, "GEM_EXT_DESCR=%s", TMP_DESCR);
    putenv(GEM_EXT_DESCR);
    sprintf(GEM_EXT_INFO, "GEM_EXT_INFO=%s", TMP_INFO);
    putenv(GEM_EXT_INFO);
    sprintf(GEM_EXT_DEPS, "GEM_EXT_DEPS=%s", TMP_DEPS);
    putenv(GEM_EXT_DEPS);
    sprintf(GEM_EXT_BUGS, "GEM_EXT_BUGS=%s", TMP_BUGS);
    putenv(GEM_EXT_BUGS);
    sprintf(GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s", TMP_AUTHORS);
    putenv(GEM_EXT_AUTHORS);
    atexit((void (**)())exit_tmp);
    check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
    int32_t system_rc2;
    if (VERBOSE == 0) {
        // 0x8051ac9
        fwrite("Compiling...", 1, 12, (struct _IO_FILE *)g15);
        sprintf(str4, "%s -f Makefile &> %s", MAKE_CMD, (void (**)())&TMP_NULL);
        system_rc2 = system(str4);
        // branch -> 0x8051b2c
    } else {
        // 0x8051a76
        fprintf((struct _IO_FILE *)g15, "Running '%s':\n", MAKE_CMD);
        sprintf(str4, "%s -f Makefile", MAKE_CMD);
        system_rc2 = system(str4);
        // branch -> 0x8051b2c
    }
    char v14 = system_rc2;
    v2[0] = v14;
    struct _IO_FILE * file; // 0x8051bb5
    int32_t err_num3; // 0x8051bce
    if (v14 != -1) {
        // 0x8051b5a
        if (v14 >= 1) {
            // 0x8051b63
            print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
            // branch -> 0x8051b77
        }
        // 0x8051b77
        print_done();
        fwrite("Installing...", 1, 13, (struct _IO_FILE *)g15);
        file = fopen("../uninstall", "r");
        if (file == NULL) {
            // 0x8051bc9
            err_num3 = *__errno_location();
            strerror(err_num3);
            print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
            // branch -> 0x8051bf8
        } else {
            // 0x8051bea
            fclose(file);
            // branch -> 0x8051bf8
        }
        // 0x8051bf8
        register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
        check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
        if (grass_revision == (char *)6 && major <= 0) {
            // 0x8051c61
            register_entries_gisman(pkg_short_name, gisbase);
            // branch -> 0x8051c79
        }
        // 0x8051c79
        register_entries_gisman2(pkg_short_name, gisbase);
        register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
        fprintf((struct _IO_FILE *)g15, "(skipping '%s install')...", MAKE_CMD);
        print_done();
        if (*(int32_t *)20 != v9) {
            // 0x8051ced
            __stack_chk_fail();
            // branch -> 0x8051cf2
        }
        // 0x8051cf2
        return;
    }
    // 0x8051b35
    if (VERBOSE == 0) {
        // 0x8051b3e
        print_error(-9, "could not run '%s' do you have make tools installed?\n");
        // branch -> 0x8051b5a
        // 0x8051b5a
        if (v2[0] >= 1) {
            // 0x8051b63
            print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
            // branch -> 0x8051b77
        }
        // 0x8051b77
        print_done();
        fwrite("Installing...", 1, 13, (struct _IO_FILE *)g15);
        file = fopen("../uninstall", "r");
        if (file == NULL) {
            // 0x8051bc9
            err_num3 = *__errno_location();
            strerror(err_num3);
            print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
            // branch -> 0x8051bf8
        } else {
            // 0x8051bea
            fclose(file);
            // branch -> 0x8051bf8
        }
        // 0x8051bf8
        register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
        check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
        if (grass_revision == (char *)6 && major <= 0) {
            // 0x8051c61
            register_entries_gisman(pkg_short_name, gisbase);
            // branch -> 0x8051c79
        }
        // 0x8051c79
        register_entries_gisman2(pkg_short_name, gisbase);
        register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
        fprintf((struct _IO_FILE *)g15, "(skipping '%s install')...", MAKE_CMD);
        print_done();
        if (*(int32_t *)20 != v9) {
            // 0x8051ced
            __stack_chk_fail();
            // branch -> 0x8051cf2
        }
        // 0x8051cf2
        return;
    }
    // 0x8051b77
    print_done();
    fwrite("Installing...", 1, 13, (struct _IO_FILE *)g15);
    file = fopen("../uninstall", "r");
    if (file == NULL) {
        // 0x8051bc9
        err_num3 = *__errno_location();
        strerror(err_num3);
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
        // branch -> 0x8051bf8
    } else {
        // 0x8051bea
        fclose(file);
        // branch -> 0x8051bf8
    }
    // 0x8051bf8
    register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
    check_dependencies((char *)(int32_t)v1.e0, gisbase, grass_version);
    if (grass_revision == (char *)6 && major <= 0) {
        // 0x8051c61
        register_entries_gisman(pkg_short_name, gisbase);
        // branch -> 0x8051c79
    }
    // 0x8051c79
    register_entries_gisman2(pkg_short_name, gisbase);
    register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
    fprintf((struct _IO_FILE *)g15, "(skipping '%s install')...", MAKE_CMD);
    print_done();
    if (*(int32_t *)20 != v9) {
        // 0x8051ced
        __stack_chk_fail();
        // branch -> 0x8051cf2
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8051cf4 - 0x80521a3
// Line range:    812 - 904
void uninstall(char * package, char * pkg_short_name, char * gisbase, char * grass_version) {
    struct stat_1 v1;
    char v2[2048];
    char str2[2048];
    struct stat_1 buf;
    int32_t v3;
    int32_t major = v3; // bp-4144
    char * v4;
    char * grass_revision = v4; // bp-4140
    char * v5;
    char * grass_minor = v5; // bp-4136
    char * v6;
    char * grass_major = v6; // bp-4132
    char * v7;
    char * verstr = v7; // bp-4128
    int32_t v8;
    int32_t no_script = v8; // bp-4124
    int32_t v9;
    int32_t error = v9; // bp-4120
    v1.e0 = (int32_t)package;
    int32_t v10 = *(int32_t *)20; // 0x8051d22
    fwrite("Un-installing...", 1, 16, (struct _IO_FILE *)g15);
    sprintf(UNINSTALL_BASE, "UNINSTALL_BASE=%s", gisbase);
    putenv(UNINSTALL_BASE);
    char * str = strdup(grass_version); // 0x8051d88
    no_script = (int32_t)str;
    verstr = strtok(str, ".");
    grass_major = strtok(NULL, ".");
    grass_minor = strtok(NULL, ".");
    grass_revision = (char *)strtol(verstr, NULL, 10);
    major = strtol(grass_major, NULL, 10);
    strtol(grass_minor, NULL, 10);
    strtol(grass_minor, NULL, 10);
    free((char *)no_script);
    atexit((void (**)())exit_tmp);
    deregister_extension((char *)(int32_t)v1.e0, pkg_short_name, gisbase);
    if (grass_revision != (char *)6 || major > 0) {
        // 0x8051cf4
        // branch -> 0x8051f2a
    } else {
        char v11 = deregister_entries_gisman(pkg_short_name, gisbase);
        v2[0] = v11;
        char v12 = v11; // 0x8051ef8
        if (v11 == -1) {
            // 0x8051ecf
            print_warning("GIS Manager menu entries could not be removed.\n");
            memcpy(GISMAN_CMD, (char *)&g9, 1);
            v12 = v2[0];
            // branch -> 0x8051ef8
        }
        // 0x8051ef8
        if (v12 == 0) {
            // 0x8051f01
            print_warning("no entries found to remove from GIS Manager.\n");
            memcpy(GISMAN_CMD, (char *)&g9, 1);
            // branch -> 0x8051f2a
        }
    }
    // 0x8051f2a
    deregister_entries_gisman2(pkg_short_name, gisbase);
    deregister_html(pkg_short_name, gisbase);
    sprintf(str2, "%s/etc/uninstall.%s", gisbase, pkg_short_name);
    error = 0;
    char v13 = stat(str2, (struct stat *)&buf);
    v2[0] = v13;
    char * str4;
    int32_t str3;
    if (v13 > 0) {
        // 0x8051fcc
        if (error == 0) {
            // 0x8051ff9
            if (VERBOSE == 0) {
                // 0x8052090
                sprintf((char *)&str3, "sh %s &> %s ; rm -vf %s &> %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s &> %s ; rm -vf %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db &> %s ; chmod -v a+r %s/etc/extensions.db &> %s ;", str2, (void (**)())&TMP_NULL, str2, TMP_NULL, gisbase, pkg_short_name, TMP_NULL, gisbase, pkg_short_name, TMP_NULL, TMPDB, gisbase, TMP_NULL, gisbase, TMP_NULL);
                strcpy(UNINSTALL_CMD, (char *)&str3);
                str4 = (char *)&str3;
                // branch -> 0x8052145
            } else {
                // 0x8052006
                sprintf((char *)&str3, "sh %s ; rm -vf %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s ; rm -vf %s/etc/dm/gem-entries/%s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", str2, &str2, gisbase, pkg_short_name, gisbase, pkg_short_name, TMPDB, gisbase, gisbase);
                strcpy(UNINSTALL_CMD, (char *)&str3);
                str4 = (char *)&str3;
                // branch -> 0x8052145
            }
            // 0x8052145
            sprintf(str4, "%s %s %s", UNINSTALL_CMD, (void (**)())&GISMAN_CMD, HTML_CMD);
            su(gisbase, str4);
            print_done();
            if (*(int32_t *)20 != v10) {
                // 0x805219d
                __stack_chk_fail();
                // branch -> 0x80521a2
            }
            // 0x80521a2
            return;
        }
    } else {
        // 0x8051fcc
        print_warning("no uninstall script available for this extension.\n \t\t\tUnneeded files may have been left on your system.\n");
        error = 1;
        // branch -> 0x8051fd5
    }
    int32_t err_num = *__errno_location(); // 0x8051fda
    strerror(err_num);
    print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
    str4 = (char *)&str3;
    // branch -> 0x8052145
    // 0x8052145
    sprintf(str4, "%s %s %s", UNINSTALL_CMD, (void (**)())&GISMAN_CMD, HTML_CMD);
    su(gisbase, str4);
    print_done();
    if (*(int32_t *)20 != v10) {
        // 0x805219d
        __stack_chk_fail();
        // branch -> 0x80521a2
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x80521a4 - 0x8052333
// Line range:    907 - 946
int32_t source_clean(char * package) {
    char str2[2048];
    char v1[2048];
    basename();
    int32_t str;
    sprintf((char *)&str, "%s/src", (char *)g1);
    char v2 = chdir((char *)&str);
    v1[0] = v2;
    if (v2 <= 0) {
        // 0x8052207
        print_error(-2, "extension '%s' not accessible: ");
        // branch -> 0x8052225
    }
    // 0x8052225
    int32_t system_rc;
    if (VERBOSE == 0) {
        // 0x8052281
        fwrite("Cleaning up...", 1, 14, (struct _IO_FILE *)g15);
        sprintf(str2, "%s -f Makefile -s clean &> %s", MAKE_CMD, (void (**)())&TMP_NULL);
        system_rc = system(str2);
        // branch -> 0x80522e4
    } else {
        // 0x805222e
        fprintf((struct _IO_FILE *)g15, "Running '%s clean':\n", MAKE_CMD);
        sprintf(str2, "%s -f Makefile clean", MAKE_CMD);
        system_rc = system(str2);
        // branch -> 0x80522e4
    }
    char v3 = system_rc;
    v1[0] = v3;
    if (v3 == -1) {
        // 0x80522ed
        print_error(-9, "could not run '%s clean' do you have make tools installed?\n");
        // branch -> 0x8052310
    } else {
        // 0x805230b
        print_done();
        // branch -> 0x8052310
    }
    // 0x8052310
    system("sh ../post");
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x805232d
        __stack_chk_fail();
        // branch -> 0x8052332
    }
    // 0x8052332
    return 0;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8052334 - 0x80525fb
// Line range:    952 - 1016
void restore(char * gisbase, char * grass_version) {
    char str2[2048];
    char v1[2048];
    // 0x8052334
    int32_t v2;
    int32_t major = v2; // bp-2092
    char * v3;
    char * grass_revision = v3; // bp-2088
    char * v4;
    char * grass_minor = v4; // bp-2084
    char * v5;
    char * grass_major = v5; // bp-2080
    char * v6;
    char * verstr = v6; // bp-2076
    int32_t v7;
    int32_t num_restored = v7; // bp-2072
    int32_t v8 = *(int32_t *)20; // 0x8052350
    char * str = strdup(grass_version); // 0x8052363
    num_restored = (int32_t)str;
    verstr = strtok(str, ".");
    grass_major = strtok(NULL, ".");
    grass_minor = strtok(NULL, ".");
    grass_revision = (char *)strtol(verstr, NULL, 10);
    major = strtol(grass_major, NULL, 10);
    strtol(grass_minor, NULL, 10);
    strtol(grass_minor, NULL, 10);
    free((char *)num_restored);
    fwrite("Restoring...", 1, 12, (struct _IO_FILE *)g15);
    char * v9;
    char v10;
    char v11; // 0x80524ef
    char v12; // 0x80525c5
    if (grass_revision != (char *)6 || major > 0) {
        // 0x8052334
        v9 = &v1[0];
        // branch -> 0x80524b2
        // 0x80524b2
        v10 = restore_html(gisbase);
        *v9 = v10;
        v11 = v10;
        if (VERBOSE != 0) {
            // 0x80524cf
            fprintf((struct _IO_FILE *)g15, "\nRestored links in index.hml: %i\n", (int32_t)v10);
            v11 = *v9;
            // branch -> 0x80524ef
        }
        // 0x80524ef
        v12 = v11;
        if (v11 >= 1) {
            // 0x80524fc
            if (VERBOSE == 0) {
                // 0x8052556
                sprintf(str2, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl &> %s ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", TMP_GISMAN, gisbase, gisbase, TMP_NULL, TMP_HTML, gisbase, gisbase);
                // branch -> 0x80525ad
            } else {
                // 0x8052505
                sprintf(str2, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", TMP_GISMAN, gisbase, gisbase, TMP_HTML, gisbase, gisbase);
                // branch -> 0x80525ad
            }
            // 0x80525ad
            su(gisbase, str2);
            v12 = *v9;
            // branch -> 0x80525c5
        }
        // 0x80525c5
        if (v12 == 0) {
            // 0x80525ce
            print_error(-26, "could not find anything to restore.\n");
            // branch -> 0x80525e9
        } else {
            // 0x80525e4
            print_done();
            // branch -> 0x80525e9
        }
        // 0x80525e9
        if (*(int32_t *)20 != v8) {
            // 0x80525f5
            __stack_chk_fail();
            // branch -> 0x80525fa
        }
        // 0x80525fa
        return;
    }
    char v13 = restore_entries_gisman(gisbase);
    v1[0] = v13;
    if (VERBOSE != 0) {
        // 0x8052492
        fprintf((struct _IO_FILE *)g15, "\nRestored entries for GIS Manager: %i\n", (int32_t)v13);
        v9 = &v1[0];
        // branch -> 0x80524b2
    } else {
        v9 = &v1[0];
    }
    // 0x80524b2
    v10 = restore_html(gisbase);
    *v9 = v10;
    v11 = v10;
    if (VERBOSE != 0) {
        // 0x80524cf
        fprintf((struct _IO_FILE *)g15, "\nRestored links in index.hml: %i\n", (int32_t)v10);
        v11 = *v9;
        // branch -> 0x80524ef
    }
    // 0x80524ef
    v12 = v11;
    if (v11 >= 1) {
        // 0x80524fc
        if (VERBOSE == 0) {
            // 0x8052556
            sprintf(str2, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl &> %s ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", TMP_GISMAN, gisbase, gisbase, TMP_NULL, TMP_HTML, gisbase, gisbase);
            // branch -> 0x80525ad
        } else {
            // 0x8052505
            sprintf(str2, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", TMP_GISMAN, gisbase, gisbase, TMP_HTML, gisbase, gisbase);
            // branch -> 0x80525ad
        }
        // 0x80525ad
        su(gisbase, str2);
        v12 = *v9;
        // branch -> 0x80525c5
    }
    // 0x80525c5
    if (v12 == 0) {
        // 0x80525ce
        print_error(-26, "could not find anything to restore.\n");
        // branch -> 0x80525e9
    } else {
        // 0x80525e4
        print_done();
        // branch -> 0x80525e9
    }
    // 0x80525e9
    if (*(int32_t *)20 != v8) {
        // 0x80525f5
        __stack_chk_fail();
        // branch -> 0x80525fa
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x80525fc - 0x8052747
// Line range:    1022 - 1050
void list_extensions(char * gisbase) {
    char v1[2048];
    char str[2048];
    // 0x80525fc
    fprintf((struct _IO_FILE *)g15, "\nExtensions in '%s' (name, version, type, depends):\n", gisbase);
    sprintf(str, "%s/etc/extensions.db", gisbase);
    char file = (int32_t)fopen(str, "r");
    v1[0] = file;
    char file2 = file; // 0x8052711
    if (file == 0) {
        // 0x8052684
        if (*__errno_location() == 2) {
            // 0x8052690
            fwrite("NONE.\n", 1, 6, g14);
            fclose((struct _IO_FILE *)(int32_t)v1[0]);
            exit(0);
            // UNREACHABLE
        }
        // 0x80526d2
        fclose((struct _IO_FILE *)(int32_t)v1[0]);
        int32_t err_num = *__errno_location(); // 0x80526e5
        strerror(err_num);
        print_error(-29, "checking for file '%s': %s\n");
        file2 = v1[0];
        // branch -> 0x8052711
    }
    // 0x8052711
    fclose((struct _IO_FILE *)(int32_t)file2);
    dump_ascii(str, (char *)&g9);
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8052741
        __stack_chk_fail();
        // branch -> 0x8052746
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8052748 - 0x8052a4f
// Line range:    1057 - 1122
void run_post(char * package, int32_t action, char * bins, char * gisbase) {
    switch (action) {
        case 3: {
            // 0x805278f
            memcpy(GEM_ACTION, "GEM_ACTION=INSTALL", 19);
            // branch -> 0x805284a
            break;
        }
        case 4: {
            // 0x80527b1
            memcpy(GEM_ACTION, "GEM_ACTION=INSTALL", 19);
            // branch -> 0x805284a
            break;
        }
        case 5: {
            // 0x80527d0
            memcpy(GEM_ACTION, "GEM_ACTION=QUERY", 17);
            // branch -> 0x805284a
            break;
        }
        case 6: {
            // 0x80527ef
            memcpy(GEM_ACTION, "GEM_ACTION=CLEAN", 17);
            // branch -> 0x805284a
            break;
        }
        case 7: {
            // 0x805280e
            memcpy(GEM_ACTION, "GEM_ACTION=LICENSE", 19);
            // branch -> 0x805284a
            break;
        }
        case 9: {
            // 0x805282d
            memcpy(GEM_ACTION, "GEM_ACTION=DETAILS", 19);
            // branch -> 0x805284a
            break;
        }
    }
    // 0x805284a
    putenv(GEM_ACTION);
    if (gisbase == NULL) {
        // 0x8052880
        memcpy(INSTALL_BASE, "INSTALL_BASE=UNDEFINED", 23);
        // branch -> 0x805289d
    } else {
        // 0x805285f
        sprintf(INSTALL_BASE, "INSTALL_BASE=%s", gisbase);
        // branch -> 0x805289d
    }
    // 0x805289d
    putenv(INSTALL_BASE);
    int32_t buf;
    getcwd((char *)&buf, 2048);
    basename();
    int32_t str;
    sprintf((char *)&str, "%s/%s/src", &buf, (char *)g1);
    sprintf(EXT_BASE, "EXT_BASE=%s", &str);
    putenv(EXT_BASE);
    if (bins == NULL) {
        // 0x8052926
        memcpy(INSTALL_TYPE, "INSTALL_TYPE=src", 17);
        // branch -> 0x8052964
    } else {
        // 0x8052945
        sprintf(INSTALL_TYPE, "INSTALL_TYPE=%s", bins);
        // branch -> 0x8052964
    }
    // 0x8052964
    putenv(INSTALL_TYPE);
    sprintf((char *)&buf, "%i", FORCE);
    sprintf(GEM_FORCE, "GEM_FORCE=%s", &buf);
    putenv(GEM_FORCE);
    sprintf((char *)&buf, "%i", VERBOSE);
    sprintf(GEM_VERBOSE, "GEM_VERBOSE=%s", &buf);
    putenv(GEM_VERBOSE);
    memcpy(GEM_GUI, "GEM_GUI=0", 10);
    putenv(GEM_GUI);
    atexit((void (**)())exit_tmp);
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8052a49
        __stack_chk_fail();
        // branch -> 0x8052a4e
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x8052a50 - 0x8053001
// Line range:    148 - 209
void show_help(void) {
    // 0x8052a50
    fwrite("Usage: gem64 [OPTION] [ACTION] [FILE|DIR]\n", 1, 42, (struct _IO_FILE *)g15);
    fwrite("Install a GRASS extension from FILE or DIR.\n", 1, 44, (struct _IO_FILE *)g15);
    fwrite("Manage (installed) GRASS extension(s).\n", 1, 39, (struct _IO_FILE *)g15);
    fwrite("\nPossible ACTIONs are:\n", 1, 23, (struct _IO_FILE *)g15);
    fwrite("  -i, --install=EXT\tinstall a GRASS extension\n", 1, 46, (struct _IO_FILE *)g15);
    fwrite("  -u, --uninstall=EXT\tremove an extension from GRASS\n", 1, 53, (struct _IO_FILE *)g15);
    fwrite("  -q, --query=EXT\tdisplay information about extension/list installed\n", 1, 69, (struct _IO_FILE *)g15);
    fwrite("  -d, --details=EXT\tdisplay additional details about an extension\n", 1, 66, (struct _IO_FILE *)g15);
    fwrite("  -c, --clean=EXT\tclean extension's source code directories\n", 1, 60, (struct _IO_FILE *)g15);
    fwrite("  -t, --test=EXT\tconfigure and compile extension, but don't install\n", 1, 68, (struct _IO_FILE *)g15);
    fwrite("  -l, --license=EXT\tshow copyright information for an extension\n", 1, 64, (struct _IO_FILE *)g15);
    fwrite("  -r, --restore\t\trecreate HTML links and GIS Manager entries\n", 1, 61, (struct _IO_FILE *)g15);
    fwrite("  -h, --help\t\tdisplay this help and exit\n", 1, 41, (struct _IO_FILE *)g15);
    fwrite("  -V, --version\t\toutput version information and exit\n\n", 1, 54, (struct _IO_FILE *)g15);
    fwrite("\nPossible OPTIONs are:\n", 1, 23, (struct _IO_FILE *)g15);
    fwrite("  -g, --grass=PATH\tpath to GRASS installation dir\n", 1, 50, (struct _IO_FILE *)g15);
    fwrite("  -b, --binary=NAME\tno compilation: use binary files for system NAME\n", 1, 69, (struct _IO_FILE *)g15);
    fwrite("  -f, --force\t\tforce action, regardless of dependencies\n", 1, 56, (struct _IO_FILE *)g15);
    fwrite("  -v, --verbose\t\tdisplay detailed status information\n", 1, 53, (struct _IO_FILE *)g15);
    fwrite("  -s, --skip-config\tskip configure script\n", 1, 42, (struct _IO_FILE *)g15);
    fwrite("  -x, --config-opts=OPTS\tpass OPTS to configure script\n", 1, 55, (struct _IO_FILE *)g15);
    fwrite("  -o, --options=OPTS\toptions to pass to the C compiler/linker\n", 1, 62, (struct _IO_FILE *)g15);
    fwrite("  -C, --config-cmd=CMD\tDefine custom 'configure' command (default=configure)\n", 1, 77, (struct _IO_FILE *)g15);
    fwrite("  -m, --make-cmd=CMD\tDefine custom 'make' command (default=make)\n", 1, 65, (struct _IO_FILE *)g15);
    fwrite("\nWhen run from within a GRASS session, locations of libs, header files\n", 1, 71, (struct _IO_FILE *)g15);
    fwrite("and installation target dir will be assumed to match those of the active\n", 1, 73, (struct _IO_FILE *)g15);
    fwrite("GRASS version. ", 1, 15, (struct _IO_FILE *)g15);
    fwrite("Option -g can be used to override these or install extensions\nfrom outside", 1, 74, (struct _IO_FILE *)g15);
    fwrite("of a GRASS session.\n", 1, 20, (struct _IO_FILE *)g15);
    fwrite("Per default, extensions will be compiled from source and then installed.\n", 1, 73, (struct _IO_FILE *)g15);
    fwrite("If the exension package contains binaries for the user's platform, they can\n", 1, 76, (struct _IO_FILE *)g15);
    fwrite("be installed instead using the -b option. ", 1, 42, (struct _IO_FILE *)g15);
    fwrite("For installation from source code, a C compiler and make tools are needed.\n", 1, 75, (struct _IO_FILE *)g15);
    fwrite("\nExample:\n", 1, 10, (struct _IO_FILE *)g15);
    fwrite("\tgem64 -b macosx --grass=/usr/local/grass-6.4.0 -i myExtension\n", 1, 63, (struct _IO_FILE *)g15);
    fwrite("Installs the MacOS X binaries for 'myExtension' in /usr/local/grass-6.4.0.\n", 1, 75, (struct _IO_FILE *)g15);
    exit(0);
    // UNREACHABLE
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x8053002 - 0x80530b8
// Line range:    213 - 232
void show_details(char * package) {
    char str[2048];
    char v1[2048];
    // 0x8053002
    basename();
    strcpy(str, (char *)g1);
    char v2 = chdir(str);
    v1[0] = v2;
    if (v2 <= 0) {
        int32_t err_num = *__errno_location(); // 0x8053061
        strerror(err_num);
        print_error(-2, "extension '%s' not accessible: (%s)\n");
        // branch -> 0x805308d
    }
    // 0x805308d
    dump_ascii("info", "Detailed information");
    system("sh post");
    exit(0);
    // UNREACHABLE
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x80530b9 - 0x805316f
// Line range:    236 - 254
void show_license(char * package) {
    char str[2048];
    char v1[2048];
    // 0x80530b9
    basename();
    strcpy(str, (char *)g1);
    char v2 = chdir(str);
    v1[0] = v2;
    if (v2 <= 0) {
        int32_t err_num = *__errno_location(); // 0x8053118
        strerror(err_num);
        print_error(-2, "extension '%s' not accessible: (%s)\n");
        // branch -> 0x8053144
    }
    // 0x8053144
    dump_ascii("license", "Detailed information");
    system("sh post");
    exit(0);
    // UNREACHABLE
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x8053170 - 0x8053241
// Line range:    258 - 267
void show_version(void) {
    // 0x8053170
    fprintf((struct _IO_FILE *)g15, "gem64 (GRASS extensions manager) %.2f\n", 1.03);
    fwrite("Written by Benjamin Ducke\n", 1, 26, (struct _IO_FILE *)g15);
    fwrite("\nCopyright (C) 2005 Benjamin Ducke\n", 1, 35, (struct _IO_FILE *)g15);
    fwrite("This is free software; see the source for copying conditions.  There is NO\n", 1, 75, (struct _IO_FILE *)g15);
    fwrite("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 1, 76, (struct _IO_FILE *)g15);
    exit(0);
    // UNREACHABLE
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x805331e - 0x80546df
// Line range:    302 - 857
int main(int argc, char ** argv) {
    struct stat_2 buf2;
    struct stat_2 buf;
    char str7[2048];
    char str[2048];
    char str9[2048];
    char str2[2048];
    char v1[2048];
    char str3[2048];
    char str4[2048];
    int32_t v2;
    int32_t option_index = v2; // bp-14476
    int32_t v3;
    int32_t dir_found = v3; // bp-14472
    struct dirent_3 * v4;
    struct dirent_3 * dir_entry = v4; // bp-14468
    struct __dirstream_4 * v5;
    struct __dirstream_4 * dir = v5; // bp-14464
    int32_t v6;
    int32_t error = v6; // bp-14456
    int32_t v7;
    int32_t valid = v7; // bp-14452
    int32_t v8;
    int32_t action = v8; // bp-14448
    int32_t v9;
    int32_t option = v9; // bp-14444
    int32_t v10;
    int32_t revision = v10; // bp-14440
    int32_t v11;
    int32_t minor = v11; // bp-14436
    int32_t v12;
    int32_t major = v12; // bp-14432
    struct _IO_FILE_7 * v13;
    struct _IO_FILE_7 * f = v13; // bp-14424
    int32_t v14;
    int32_t pkg_revision = v14; // bp-14420
    int32_t v15;
    int32_t pkg_minor = v15; // bp-14416
    int32_t v16;
    int32_t pkg_major = v16; // bp-14412
    char * v17;
    char * bins = v17; // bp-14408
    char * v18;
    char * url = v18; // bp-14400
    char * v19;
    char * tmp = v19; // bp-14396
    char * v20;
    char * grass_revision = v20; // bp-14392
    char * v21;
    char * grass_minor = v21; // bp-14388
    char * v22;
    char * grass_major = v22; // bp-14384
    char * v23;
    char * grass_version = v23; // bp-14380
    char * v24;
    char * gisbase = v24; // bp-14376
    option_index = 0;
    VERBOSE = 0;
    TMPCLEAN = 0;
    TMPDBCLEAN = 0;
    FORCE = 0;
    UPGRADE = 0;
    ERROR = 0;
    WARNINGS = 0;
    SKIP_CFG = 0;
    memcpy(GISMAN_CMD, (char *)&g10, 1);
    memcpy(GISMAN2_CMD, (char *)&g10, 1);
    memcpy(QGIS_CMD, (char *)&g10, 1);
    memcpy(UNINSTALL_CMD, (char *)&g10, 1);
    memcpy(HTML_CMD, (char *)&g10, 1);
    memcpy(TMPDIR, (char *)&g10, 1);
    memcpy(TMPDB, (char *)&g10, 1);
    memcpy(TMP_GISMAN, (char *)&g10, 1);
    memcpy(TMP_DESCR, (char *)&g10, 1);
    memcpy(TMP_INFO, (char *)&g10, 1);
    memcpy(TMP_DEPS, (char *)&g10, 1);
    memcpy(TMP_BUGS, (char *)&g10, 1);
    memcpy(TMP_AUTHORS, (char *)&g10, 1);
    memcpy(TMP_HTML, (char *)&g10, 1);
    memcpy(TMP_NULL, (char *)&g10, 1);
    memcpy(CONFIG_OPTS, (char *)&g10, 1);
    memcpy(CONFIG_CMD, "configure", 10);
    memcpy(MAKE_CMD, "make", 5);
    getcwd(CWD, 2048);
    fwrite((char *)&g11, 1, 4, (struct _IO_FILE *)g15);
    tmp = malloc(2048);
    strcpy(str, (char *)*(int32_t *)argv);
    setvbuf((struct _IO_FILE *)g15, NULL, 2, 0);
    if (argc == 1) {
        // 0x8053644
        show_help();
        exit(0);
        // UNREACHABLE
    }
    // 0x8053655
    atexit((void (**)())exit_msg);
    valid = 0;
    bins = NULL;
    gisbase = NULL;
    g16 = 0;
    int32_t v25 = getopt_long(argc, argv, ":i:u:q:d:c:C:t:l:m:o:x:rhVg:b:fvs", (struct option *)&g12, &option_index); // 0x80536b5
    // branch -> 0x8053a9b
    while (true) {
        // 0x8053a9b
        option = v25;
        int32_t v26 = v25; // 0x80536e4
        char * env_val5; // 0x8053bfc
        char * env_val4; // 0x8053c95
        char * mem; // 0x8053d54
        char * found_char_pos; // 0x8053d8c
        int32_t v27; // 0x8053e16
        struct __dirstream * dirp; // 0x8053efd
        struct dirent * v28; // 0x8053f13
        char * env_val; // 0x8054088
        char * env_val2; // 0x8054225
        char * env_val3; // 0x8054280
        struct _IO_FILE * file; // 0x80542d0
        char * mem2; // 0x8054303
        char * str6; // 0x805437e
        char * mem3; // 0x805445a
        int32_t err_num; // 0x8053baf
        int32_t err_num2; // 0x8053e31
        char * v29; // 0x8054094
        char * v30; // 0x8054529
        char * v31; // 0x80545d6
        char * v32; // 0x805465f
        int32_t v33; // 0x8053aa9
        int32_t v34; // 0x8053ac7
        int32_t v35; // 0x8053b11
        int32_t v36; // 0x8053bdd
        char * v37; // 0x8054077
        char * str5;
        switch (v25) {
            case -1: {
                // 0x8053aa9
                v33 = valid;
                // branch -> 0x8053aa9
                break;
            }
            case 63: {
                // 0x80536d0
                print_error(-1, "unknown option or action specified.\n");
                // branch -> 0x80536e4
                v26 = option;
            }
            default: {
                int32_t v38 = v26; // 0x8053838
                int32_t str8; // 0x80538e5
                int32_t v39; // 0x805391e
                int32_t v40; // 0x805395f
                if (v26 == 58) {
                    // 0x80536f2
                    int32_t v41; // 0x805374c
                    if (g13 != 105) {
                        // 0x80536fc
                        if (g13 != 117) {
                            // 0x8053706
                            if (g13 != 100) {
                                // 0x8053710
                                if (g13 != 99) {
                                    // 0x805371a
                                    if (g13 != 116) {
                                        // 0x8053724
                                        if (g13 != 108) {
                                            // 0x805372e
                                            if (g13 != 114) {
                                                v41 = g13;
                                              lab_0x805374c:;
                                                int32_t v42 = v41; // 0x805376a
                                                if (v41 == 103) {
                                                    // 0x8053756
                                                    print_error(-1, "missing path to GRASS 6.\n");
                                                    v42 = g13;
                                                    // branch -> 0x805376a
                                                }
                                                // 0x805376a
                                                int32_t v43; // 0x80537a6
                                                if (v42 == 98) {
                                                    // 0x8053788
                                                    print_error(-1, "missing name of binary architecture.\n");
                                                    if (g13 == 98) {
                                                        // 0x8053792
                                                        print_error(-1, "missing configure options.\n");
                                                        v43 = g13;
                                                        // branch -> 0x80537a6
                                                    } else {
                                                        v43 = g13;
                                                    }
                                                } else {
                                                    // 0x8053788
                                                    v43 = v42;
                                                    // branch -> 0x80537a6
                                                }
                                                // 0x80537a6
                                                if (v43 == 113) {
                                                    // 0x80537b0
                                                    action = 12;
                                                    int32_t v44 = valid + 1; // 0x80537bb
                                                    valid = v44;
                                                    v33 = v44;
                                                    // branch -> 0x8053aa9
                                                    // 0x8053aa9
                                                    v34 = v33;
                                                    if (v33 <= 0) {
                                                        // 0x8053ab3
                                                        print_error(-1, "please specify a valid action.\n");
                                                        v34 = valid;
                                                        // branch -> 0x8053ac7
                                                    }
                                                    // 0x8053ac7
                                                    if (v34 >= 2) {
                                                        // 0x8053ad1
                                                        print_error(-1, "please specify only one action.\n");
                                                        // branch -> 0x8053ae5
                                                    }
                                                    // 0x8053ae5
                                                    sprintf(GEM_C_OPTS, "GEM_C_OPTS=%s", str7);
                                                    putenv(GEM_C_OPTS);
                                                    v35 = action;
                                                    switch (v35) {
                                                        default: {
                                                            // 0x8053b47
                                                            v36 = v35;
                                                            if (VERBOSE == 0) {
                                                                // 0x8053b54
                                                                memcpy(TMP_NULL, "/tmp/grass.extension.log.XXXXXX", 32);
                                                                mkstemp(TMP_NULL);
                                                                if (open(TMP_NULL, O_CREAT) == -1) {
                                                                    // 0x8053baa
                                                                    err_num = *__errno_location();
                                                                    strerror(err_num);
                                                                    print_error(-30, "could not create temp file: %s");
                                                                    exit(-30);
                                                                    // UNREACHABLE
                                                                }
                                                                // 0x8053b54
                                                                v36 = action;
                                                                // branch -> 0x8053bdd
                                                            }
                                                            // 0x8053bdd
                                                            switch (v36) {
                                                                default: {
                                                                    // 0x8053d04
                                                                    if (strstr(str2, "http://") == NULL) {
                                                                        // 0x8053d1f
                                                                        if (strstr(str2, "ftp://") != NULL) {
                                                                            // 0x8053d3e
                                                                            wget_extension(str2);
                                                                            mem = malloc(2048);
                                                                            url = mem;
                                                                            strcpy(mem, str2);
                                                                            found_char_pos = strrchr(url, 47);
                                                                            strcpy(str2, (char *)((int32_t)found_char_pos + 1));
                                                                            free(url);
                                                                            // branch -> 0x8053dc9
                                                                        }
                                                                    } else {
                                                                        // 0x8053d3e
                                                                        wget_extension(str2);
                                                                        mem = malloc(2048);
                                                                        url = mem;
                                                                        strcpy(mem, str2);
                                                                        found_char_pos = strrchr(url, 47);
                                                                        strcpy(str2, (char *)((int32_t)found_char_pos + 1));
                                                                        free(url);
                                                                        // branch -> 0x8053dc9
                                                                    }
                                                                    // 0x8053dc9
                                                                    if (VERBOSE != 0) {
                                                                        // 0x8053dd2
                                                                        fprintf((struct _IO_FILE *)g15, "Extension location is '%s'.\n", str2);
                                                                        // branch -> 0x8053df3
                                                                    }
                                                                    // 0x8053df3
                                                                    if (action != 10) {
                                                                        // 0x8053e01
                                                                        v27 = stat(str2, (struct stat *)&buf);
                                                                        error = v27;
                                                                        if (v27 <= 0) {
                                                                            // 0x8053e2c
                                                                            err_num2 = *__errno_location();
                                                                            strerror(err_num2);
                                                                            print_error(-2, "extension FILE or DIR '%s' invalid: %s\n");
                                                                            // branch -> 0x8053e5e
                                                                        }
                                                                        // 0x8053e5e
                                                                        if ((buf.e3 & 0xf000) == 0x4000) {
                                                                            // 0x8053e71
                                                                            if (VERBOSE != 0) {
                                                                                // 0x8053e89
                                                                                fwrite("Extension files stored in a directory.\n", 1, 39, (struct _IO_FILE *)g15);
                                                                                // branch -> 0x805402d
                                                                            }
                                                                        } else {
                                                                            // 0x8053eb6
                                                                            if (VERBOSE != 0) {
                                                                                // 0x8053ebf
                                                                                fwrite("Extension files stored in a package file.\n", 1, 42, (struct _IO_FILE *)g15);
                                                                                // branch -> 0x8053ee7
                                                                            }
                                                                            // 0x8053ee7
                                                                            unpack_extension(str2);
                                                                            dirp = opendir(TMPDIR);
                                                                            dir = (struct __dirstream_4 *)dirp;
                                                                            v28 = readdir(dirp);
                                                                            dir_entry = (struct dirent_3 *)v28;
                                                                            dir_found = 0;
                                                                            if (v28 != NULL) {
                                                                                struct dirent_3 * v45 = (struct dirent_3 *)v28; // 0x8053fe7112
                                                                                // branch -> 0x8053f2f
                                                                                while (true) {
                                                                                    // 0x8053f2f
                                                                                    if (strcmp((char *)((int32_t)v45 + 11), ".") != 0) {
                                                                                      lab_0x8053f51:
                                                                                        // 0x8053f51
                                                                                        if (strcmp((char *)((int32_t)dir_entry + 11), "..") != 0) {
                                                                                            // 0x8053f6f
                                                                                            sprintf(tmp, "%s/%s", TMPDIR, (void (**)())((int32_t)dir_entry + 11));
                                                                                            stat(tmp, (struct stat *)&buf2);
                                                                                            if ((buf2.e3 & 0xf000) == 0x4000) {
                                                                                                // 0x8053fc4
                                                                                                dir_found = 1;
                                                                                                // branch -> 0x8053ff5
                                                                                                // 0x8053ff5
                                                                                                strcpy(str2, tmp);
                                                                                                if (dir_found == 0) {
                                                                                                    // 0x8054019
                                                                                                    print_error(-7, "no top-level directory found in extension package.\n");
                                                                                                    // branch -> 0x805402d
                                                                                                }
                                                                                                // 0x805402d
                                                                                                if (action == 10) {
                                                                                                    // 0x8054037
                                                                                                    strcpy(str3, str2);
                                                                                                    // branch -> 0x805406d
                                                                                                } else {
                                                                                                    // 0x8054053
                                                                                                    get_package_name(str2, str3);
                                                                                                    // branch -> 0x805406d
                                                                                                }
                                                                                                // 0x805406d
                                                                                                if (valid >= 1) {
                                                                                                    // 0x8054077
                                                                                                    v37 = gisbase;
                                                                                                    v29 = v37;
                                                                                                    if (v37 == NULL) {
                                                                                                        // 0x8054081
                                                                                                        env_val = getenv("GISBASE");
                                                                                                        gisbase = env_val;
                                                                                                        v29 = env_val;
                                                                                                        // branch -> 0x8054094
                                                                                                    }
                                                                                                    // 0x8054094
                                                                                                    run_post(str2, action, bins, v29);
                                                                                                    // branch -> 0x80540c4
                                                                                                }
                                                                                                // 0x80540c4
                                                                                                if (VERBOSE != 0) {
                                                                                                    // 0x80540cd
                                                                                                    fprintf((struct _IO_FILE *)g15, "Extension will be installed from '%s'\n", str2);
                                                                                                    // branch -> 0x80540ee
                                                                                                }
                                                                                                // 0x80540ee
                                                                                                if (action == 10) {
                                                                                                    // 0x8054214
                                                                                                    if (gisbase == NULL) {
                                                                                                        // 0x805421e
                                                                                                        env_val2 = getenv("GISBASE");
                                                                                                        gisbase = env_val2;
                                                                                                        if (env_val2 == NULL) {
                                                                                                            // 0x805423b
                                                                                                            print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                                                            // branch -> 0x805424f
                                                                                                        }
                                                                                                    }
                                                                                                    // 0x805424f
                                                                                                    if (VERBOSE != 0) {
                                                                                                        // 0x8054258
                                                                                                        fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                                                        // branch -> 0x8054279
                                                                                                    }
                                                                                                    // 0x8054279
                                                                                                    env_val3 = getenv("GRASS_VERSION");
                                                                                                    grass_version = env_val3;
                                                                                                    if (env_val3 == NULL) {
                                                                                                        // 0x805429a
                                                                                                        sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                                                                                        file = fopen(str4, "r");
                                                                                                        f = (struct _IO_FILE_7 *)file;
                                                                                                        if (file == NULL) {
                                                                                                            // 0x80542e6
                                                                                                            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                                            // branch -> 0x8054366
                                                                                                        } else {
                                                                                                            // 0x80542fc
                                                                                                            mem2 = malloc(16);
                                                                                                            grass_version = mem2;
                                                                                                            error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                                                                                            fclose((struct _IO_FILE *)f);
                                                                                                            if (error <= 0) {
                                                                                                                // 0x8054352
                                                                                                                print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                                                // branch -> 0x8054366
                                                                                                            }
                                                                                                        }
                                                                                                        // 0x8054366
                                                                                                        str5 = grass_version;
                                                                                                        if (str5 != NULL) {
                                                                                                            // 0x8054374
                                                                                                            str6 = strdup(str5);
                                                                                                            tmp = str6;
                                                                                                            grass_major = strtok(str6, ".");
                                                                                                            grass_minor = strtok(NULL, ".");
                                                                                                            grass_revision = strtok(NULL, ".");
                                                                                                            major = strtol(grass_major, NULL, 10);
                                                                                                            minor = strtol(grass_minor, NULL, 10);
                                                                                                            revision = strtol(grass_revision, NULL, 10);
                                                                                                            mem3 = malloc(2048);
                                                                                                            grass_version = mem3;
                                                                                                            sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                                            if (VERBOSE != 0) {
                                                                                                                // 0x80544a8
                                                                                                                fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                                                // branch -> 0x80544c9
                                                                                                            }
                                                                                                            // 0x80544c9
                                                                                                            if (major <= 5) {
                                                                                                                // 0x80544d3
                                                                                                                print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                                                // branch -> 0x80544e7
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        // 0x8054374
                                                                                                        str6 = strdup(env_val3);
                                                                                                        tmp = str6;
                                                                                                        grass_major = strtok(str6, ".");
                                                                                                        grass_minor = strtok(NULL, ".");
                                                                                                        grass_revision = strtok(NULL, ".");
                                                                                                        major = strtol(grass_major, NULL, 10);
                                                                                                        minor = strtol(grass_minor, NULL, 10);
                                                                                                        revision = strtol(grass_revision, NULL, 10);
                                                                                                        mem3 = malloc(2048);
                                                                                                        grass_version = mem3;
                                                                                                        sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                                        if (VERBOSE != 0) {
                                                                                                            // 0x80544a8
                                                                                                            fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                                            // branch -> 0x80544c9
                                                                                                        }
                                                                                                        // 0x80544c9
                                                                                                        if (major <= 5) {
                                                                                                            // 0x80544d3
                                                                                                            print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                                            // branch -> 0x80544e7
                                                                                                        }
                                                                                                    }
                                                                                                    // 0x80544e7
                                                                                                    sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                                                                                    switch (action) {
                                                                                                        case 3: {
                                                                                                            // 0x8054514
                                                                                                            v30 = grass_version;
                                                                                                            g3 = (int32_t)v30;
                                                                                                            source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                                                                                            exit(0);
                                                                                                            // UNREACHABLE
                                                                                                        }
                                                                                                        case 10: {
                                                                                                            // 0x805457b
                                                                                                            uninstall(str2, str3, gisbase, grass_version);
                                                                                                            exit(0);
                                                                                                            // UNREACHABLE
                                                                                                        }
                                                                                                        case 8: {
                                                                                                            // 0x80545c1
                                                                                                            v31 = grass_version;
                                                                                                            g3 = (int32_t)v31;
                                                                                                            test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                                                                                            exit(0);
                                                                                                            // UNREACHABLE
                                                                                                        }
                                                                                                        case 4: {
                                                                                                            // 0x805462c
                                                                                                            if (binaries_exist(str2, bins) == 0) {
                                                                                                                // 0x80546b2
                                                                                                                print_error(-12, "no binaries for system '%s'\n");
                                                                                                                // branch -> 0x80546d1
                                                                                                                // 0x80546d1
                                                                                                                exit(0);
                                                                                                                // UNREACHABLE
                                                                                                            }
                                                                                                            // 0x805464a
                                                                                                            v32 = grass_version;
                                                                                                            g3 = (int32_t)v32;
                                                                                                            bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                                                                                            exit(0);
                                                                                                            // UNREACHABLE
                                                                                                            break;
                                                                                                        }
                                                                                                    }
                                                                                                    // 0x80546d1
                                                                                                    exit(0);
                                                                                                    // UNREACHABLE
                                                                                                }
                                                                                                // 0x8054133
                                                                                                check_extension(str2, v1, &pkg_major, &pkg_minor, &pkg_revision);
                                                                                                switch (action) {
                                                                                                    case 5: {
                                                                                                        // 0x805413d
                                                                                                        query_extension(str2, v1, pkg_major, pkg_minor, pkg_revision, str3, str, str9);
                                                                                                        exit(0);
                                                                                                        // UNREACHABLE
                                                                                                    }
                                                                                                    case 9: {
                                                                                                        // 0x80541af
                                                                                                        show_details(str2);
                                                                                                        exit(0);
                                                                                                        // UNREACHABLE
                                                                                                    }
                                                                                                    case 7: {
                                                                                                        // 0x80541d4
                                                                                                        show_license(str2);
                                                                                                        exit(0);
                                                                                                        // UNREACHABLE
                                                                                                    }
                                                                                                    case 6: {
                                                                                                        // 0x80541f9
                                                                                                        source_clean(str2);
                                                                                                        exit(0);
                                                                                                        // UNREACHABLE
                                                                                                    }
                                                                                                }
                                                                                                // 0x8054214
                                                                                                if (gisbase == NULL) {
                                                                                                    // 0x805421e
                                                                                                    env_val2 = getenv("GISBASE");
                                                                                                    gisbase = env_val2;
                                                                                                    if (env_val2 == NULL) {
                                                                                                        // 0x805423b
                                                                                                        print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                                                        // branch -> 0x805424f
                                                                                                    }
                                                                                                }
                                                                                                // 0x805424f
                                                                                                if (VERBOSE != 0) {
                                                                                                    // 0x8054258
                                                                                                    fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                                                    // branch -> 0x8054279
                                                                                                }
                                                                                                // 0x8054279
                                                                                                env_val3 = getenv("GRASS_VERSION");
                                                                                                grass_version = env_val3;
                                                                                                if (env_val3 == NULL) {
                                                                                                    // 0x805429a
                                                                                                    sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                                                                                    file = fopen(str4, "r");
                                                                                                    f = (struct _IO_FILE_7 *)file;
                                                                                                    if (file == NULL) {
                                                                                                        // 0x80542e6
                                                                                                        print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                                        // branch -> 0x8054366
                                                                                                    } else {
                                                                                                        // 0x80542fc
                                                                                                        mem2 = malloc(16);
                                                                                                        grass_version = mem2;
                                                                                                        error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                                                                                        fclose((struct _IO_FILE *)f);
                                                                                                        if (error <= 0) {
                                                                                                            // 0x8054352
                                                                                                            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                                            // branch -> 0x8054366
                                                                                                        }
                                                                                                    }
                                                                                                    // 0x8054366
                                                                                                    str5 = grass_version;
                                                                                                    if (str5 != NULL) {
                                                                                                        // 0x8054374
                                                                                                        str6 = strdup(str5);
                                                                                                        tmp = str6;
                                                                                                        grass_major = strtok(str6, ".");
                                                                                                        grass_minor = strtok(NULL, ".");
                                                                                                        grass_revision = strtok(NULL, ".");
                                                                                                        major = strtol(grass_major, NULL, 10);
                                                                                                        minor = strtol(grass_minor, NULL, 10);
                                                                                                        revision = strtol(grass_revision, NULL, 10);
                                                                                                        mem3 = malloc(2048);
                                                                                                        grass_version = mem3;
                                                                                                        sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                                        if (VERBOSE != 0) {
                                                                                                            // 0x80544a8
                                                                                                            fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                                            // branch -> 0x80544c9
                                                                                                        }
                                                                                                        // 0x80544c9
                                                                                                        if (major <= 5) {
                                                                                                            // 0x80544d3
                                                                                                            print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                                            // branch -> 0x80544e7
                                                                                                        }
                                                                                                    }
                                                                                                } else {
                                                                                                    // 0x8054374
                                                                                                    str6 = strdup(env_val3);
                                                                                                    tmp = str6;
                                                                                                    grass_major = strtok(str6, ".");
                                                                                                    grass_minor = strtok(NULL, ".");
                                                                                                    grass_revision = strtok(NULL, ".");
                                                                                                    major = strtol(grass_major, NULL, 10);
                                                                                                    minor = strtol(grass_minor, NULL, 10);
                                                                                                    revision = strtol(grass_revision, NULL, 10);
                                                                                                    mem3 = malloc(2048);
                                                                                                    grass_version = mem3;
                                                                                                    sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                                    if (VERBOSE != 0) {
                                                                                                        // 0x80544a8
                                                                                                        fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                                        // branch -> 0x80544c9
                                                                                                    }
                                                                                                    // 0x80544c9
                                                                                                    if (major <= 5) {
                                                                                                        // 0x80544d3
                                                                                                        print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                                        // branch -> 0x80544e7
                                                                                                    }
                                                                                                }
                                                                                                // 0x80544e7
                                                                                                sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                                                                                switch (action) {
                                                                                                    case 3: {
                                                                                                        // 0x8054514
                                                                                                        v30 = grass_version;
                                                                                                        g3 = (int32_t)v30;
                                                                                                        source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                                                                                        exit(0);
                                                                                                        // UNREACHABLE
                                                                                                    }
                                                                                                    case 10: {
                                                                                                        // 0x805457b
                                                                                                        uninstall(str2, str3, gisbase, grass_version);
                                                                                                        exit(0);
                                                                                                        // UNREACHABLE
                                                                                                    }
                                                                                                    case 8: {
                                                                                                        // 0x80545c1
                                                                                                        v31 = grass_version;
                                                                                                        g3 = (int32_t)v31;
                                                                                                        test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                                                                                        exit(0);
                                                                                                        // UNREACHABLE
                                                                                                    }
                                                                                                    case 4: {
                                                                                                        // 0x805462c
                                                                                                        if (binaries_exist(str2, bins) == 0) {
                                                                                                            // 0x80546b2
                                                                                                            print_error(-12, "no binaries for system '%s'\n");
                                                                                                            // branch -> 0x80546d1
                                                                                                            // 0x80546d1
                                                                                                            exit(0);
                                                                                                            // UNREACHABLE
                                                                                                        }
                                                                                                        // 0x805464a
                                                                                                        v32 = grass_version;
                                                                                                        g3 = (int32_t)v32;
                                                                                                        bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                                                                                        exit(0);
                                                                                                        // UNREACHABLE
                                                                                                        break;
                                                                                                    }
                                                                                                }
                                                                                                // 0x80546d1
                                                                                                exit(0);
                                                                                                // UNREACHABLE
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                  lab_0x8053fd1:;
                                                                                    struct dirent * v46 = readdir((struct __dirstream *)dir); // 0x8053fdb
                                                                                    dir_entry = (struct dirent_3 *)v46;
                                                                                    if (v46 == NULL) {
                                                                                        // break -> 0x8053ff5
                                                                                        break;
                                                                                    }
                                                                                    v45 = (struct dirent_3 *)v46;
                                                                                    // continue -> 0x8053f2f
                                                                                }
                                                                                // 0x8053ff5
                                                                                strcpy(str2, tmp);
                                                                                if (dir_found == 0) {
                                                                                    // 0x8054019
                                                                                    print_error(-7, "no top-level directory found in extension package.\n");
                                                                                    // branch -> 0x805402d
                                                                                }
                                                                                // 0x805402d
                                                                                if (action == 10) {
                                                                                    // 0x8054037
                                                                                    strcpy(str3, str2);
                                                                                    // branch -> 0x805406d
                                                                                } else {
                                                                                    // 0x8054053
                                                                                    get_package_name(str2, str3);
                                                                                    // branch -> 0x805406d
                                                                                }
                                                                                // 0x805406d
                                                                                if (valid >= 1) {
                                                                                    // 0x8054077
                                                                                    v37 = gisbase;
                                                                                    v29 = v37;
                                                                                    if (v37 == NULL) {
                                                                                        // 0x8054081
                                                                                        env_val = getenv("GISBASE");
                                                                                        gisbase = env_val;
                                                                                        v29 = env_val;
                                                                                        // branch -> 0x8054094
                                                                                    }
                                                                                    // 0x8054094
                                                                                    run_post(str2, action, bins, v29);
                                                                                    // branch -> 0x80540c4
                                                                                }
                                                                                // 0x80540c4
                                                                                if (VERBOSE != 0) {
                                                                                    // 0x80540cd
                                                                                    fprintf((struct _IO_FILE *)g15, "Extension will be installed from '%s'\n", str2);
                                                                                    // branch -> 0x80540ee
                                                                                }
                                                                                // 0x80540ee
                                                                                if (action == 10) {
                                                                                    // 0x8054214
                                                                                    if (gisbase == NULL) {
                                                                                        // 0x805421e
                                                                                        env_val2 = getenv("GISBASE");
                                                                                        gisbase = env_val2;
                                                                                        if (env_val2 == NULL) {
                                                                                            // 0x805423b
                                                                                            print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                                            // branch -> 0x805424f
                                                                                        }
                                                                                    }
                                                                                    // 0x805424f
                                                                                    if (VERBOSE != 0) {
                                                                                        // 0x8054258
                                                                                        fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                                        // branch -> 0x8054279
                                                                                    }
                                                                                    // 0x8054279
                                                                                    env_val3 = getenv("GRASS_VERSION");
                                                                                    grass_version = env_val3;
                                                                                    if (env_val3 == NULL) {
                                                                                        // 0x805429a
                                                                                        sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                                                                        file = fopen(str4, "r");
                                                                                        f = (struct _IO_FILE_7 *)file;
                                                                                        if (file == NULL) {
                                                                                            // 0x80542e6
                                                                                            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                            // branch -> 0x8054366
                                                                                        } else {
                                                                                            // 0x80542fc
                                                                                            mem2 = malloc(16);
                                                                                            grass_version = mem2;
                                                                                            error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                                                                            fclose((struct _IO_FILE *)f);
                                                                                            if (error <= 0) {
                                                                                                // 0x8054352
                                                                                                print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                                // branch -> 0x8054366
                                                                                            }
                                                                                        }
                                                                                        // 0x8054366
                                                                                        str5 = grass_version;
                                                                                        if (str5 != NULL) {
                                                                                            // 0x8054374
                                                                                            str6 = strdup(str5);
                                                                                            tmp = str6;
                                                                                            grass_major = strtok(str6, ".");
                                                                                            grass_minor = strtok(NULL, ".");
                                                                                            grass_revision = strtok(NULL, ".");
                                                                                            major = strtol(grass_major, NULL, 10);
                                                                                            minor = strtol(grass_minor, NULL, 10);
                                                                                            revision = strtol(grass_revision, NULL, 10);
                                                                                            mem3 = malloc(2048);
                                                                                            grass_version = mem3;
                                                                                            sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                            if (VERBOSE != 0) {
                                                                                                // 0x80544a8
                                                                                                fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                                // branch -> 0x80544c9
                                                                                            }
                                                                                            // 0x80544c9
                                                                                            if (major <= 5) {
                                                                                                // 0x80544d3
                                                                                                print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                                // branch -> 0x80544e7
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // 0x8054374
                                                                                        str6 = strdup(env_val3);
                                                                                        tmp = str6;
                                                                                        grass_major = strtok(str6, ".");
                                                                                        grass_minor = strtok(NULL, ".");
                                                                                        grass_revision = strtok(NULL, ".");
                                                                                        major = strtol(grass_major, NULL, 10);
                                                                                        minor = strtol(grass_minor, NULL, 10);
                                                                                        revision = strtol(grass_revision, NULL, 10);
                                                                                        mem3 = malloc(2048);
                                                                                        grass_version = mem3;
                                                                                        sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                        if (VERBOSE != 0) {
                                                                                            // 0x80544a8
                                                                                            fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                            // branch -> 0x80544c9
                                                                                        }
                                                                                        // 0x80544c9
                                                                                        if (major <= 5) {
                                                                                            // 0x80544d3
                                                                                            print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                            // branch -> 0x80544e7
                                                                                        }
                                                                                    }
                                                                                    // 0x80544e7
                                                                                    sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                                                                    switch (action) {
                                                                                        case 3: {
                                                                                            // 0x8054514
                                                                                            v30 = grass_version;
                                                                                            g3 = (int32_t)v30;
                                                                                            source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                                                                            exit(0);
                                                                                            // UNREACHABLE
                                                                                        }
                                                                                        case 10: {
                                                                                            // 0x805457b
                                                                                            uninstall(str2, str3, gisbase, grass_version);
                                                                                            exit(0);
                                                                                            // UNREACHABLE
                                                                                        }
                                                                                        case 8: {
                                                                                            // 0x80545c1
                                                                                            v31 = grass_version;
                                                                                            g3 = (int32_t)v31;
                                                                                            test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                                                                            exit(0);
                                                                                            // UNREACHABLE
                                                                                        }
                                                                                        case 4: {
                                                                                            // 0x805462c
                                                                                            if (binaries_exist(str2, bins) == 0) {
                                                                                                // 0x80546b2
                                                                                                print_error(-12, "no binaries for system '%s'\n");
                                                                                                // branch -> 0x80546d1
                                                                                                // 0x80546d1
                                                                                                exit(0);
                                                                                                // UNREACHABLE
                                                                                            }
                                                                                            // 0x805464a
                                                                                            v32 = grass_version;
                                                                                            g3 = (int32_t)v32;
                                                                                            bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                                                                            exit(0);
                                                                                            // UNREACHABLE
                                                                                            break;
                                                                                        }
                                                                                    }
                                                                                    // 0x80546d1
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                }
                                                                                // 0x8054133
                                                                                check_extension(str2, v1, &pkg_major, &pkg_minor, &pkg_revision);
                                                                                switch (action) {
                                                                                    case 5: {
                                                                                        // 0x805413d
                                                                                        query_extension(str2, v1, pkg_major, pkg_minor, pkg_revision, str3, str, str9);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    case 9: {
                                                                                        // 0x80541af
                                                                                        show_details(str2);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    case 7: {
                                                                                        // 0x80541d4
                                                                                        show_license(str2);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    case 6: {
                                                                                        // 0x80541f9
                                                                                        source_clean(str2);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                }
                                                                                // 0x8054214
                                                                                if (gisbase == NULL) {
                                                                                    // 0x805421e
                                                                                    env_val2 = getenv("GISBASE");
                                                                                    gisbase = env_val2;
                                                                                    if (env_val2 == NULL) {
                                                                                        // 0x805423b
                                                                                        print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                                        // branch -> 0x805424f
                                                                                    }
                                                                                }
                                                                                // 0x805424f
                                                                                if (VERBOSE != 0) {
                                                                                    // 0x8054258
                                                                                    fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                                    // branch -> 0x8054279
                                                                                }
                                                                                // 0x8054279
                                                                                env_val3 = getenv("GRASS_VERSION");
                                                                                grass_version = env_val3;
                                                                                if (env_val3 == NULL) {
                                                                                    // 0x805429a
                                                                                    sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                                                                    file = fopen(str4, "r");
                                                                                    f = (struct _IO_FILE_7 *)file;
                                                                                    if (file == NULL) {
                                                                                        // 0x80542e6
                                                                                        print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                        // branch -> 0x8054366
                                                                                    } else {
                                                                                        // 0x80542fc
                                                                                        mem2 = malloc(16);
                                                                                        grass_version = mem2;
                                                                                        error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                                                                        fclose((struct _IO_FILE *)f);
                                                                                        if (error <= 0) {
                                                                                            // 0x8054352
                                                                                            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                            // branch -> 0x8054366
                                                                                        }
                                                                                    }
                                                                                    // 0x8054366
                                                                                    str5 = grass_version;
                                                                                    if (str5 != NULL) {
                                                                                        // 0x8054374
                                                                                        str6 = strdup(str5);
                                                                                        tmp = str6;
                                                                                        grass_major = strtok(str6, ".");
                                                                                        grass_minor = strtok(NULL, ".");
                                                                                        grass_revision = strtok(NULL, ".");
                                                                                        major = strtol(grass_major, NULL, 10);
                                                                                        minor = strtol(grass_minor, NULL, 10);
                                                                                        revision = strtol(grass_revision, NULL, 10);
                                                                                        mem3 = malloc(2048);
                                                                                        grass_version = mem3;
                                                                                        sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                        if (VERBOSE != 0) {
                                                                                            // 0x80544a8
                                                                                            fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                            // branch -> 0x80544c9
                                                                                        }
                                                                                        // 0x80544c9
                                                                                        if (major <= 5) {
                                                                                            // 0x80544d3
                                                                                            print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                            // branch -> 0x80544e7
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // 0x8054374
                                                                                    str6 = strdup(env_val3);
                                                                                    tmp = str6;
                                                                                    grass_major = strtok(str6, ".");
                                                                                    grass_minor = strtok(NULL, ".");
                                                                                    grass_revision = strtok(NULL, ".");
                                                                                    major = strtol(grass_major, NULL, 10);
                                                                                    minor = strtol(grass_minor, NULL, 10);
                                                                                    revision = strtol(grass_revision, NULL, 10);
                                                                                    mem3 = malloc(2048);
                                                                                    grass_version = mem3;
                                                                                    sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                    if (VERBOSE != 0) {
                                                                                        // 0x80544a8
                                                                                        fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                        // branch -> 0x80544c9
                                                                                    }
                                                                                    // 0x80544c9
                                                                                    if (major <= 5) {
                                                                                        // 0x80544d3
                                                                                        print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                        // branch -> 0x80544e7
                                                                                    }
                                                                                }
                                                                                // 0x80544e7
                                                                                sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                                                                switch (action) {
                                                                                    case 3: {
                                                                                        // 0x8054514
                                                                                        v30 = grass_version;
                                                                                        g3 = (int32_t)v30;
                                                                                        source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    case 10: {
                                                                                        // 0x805457b
                                                                                        uninstall(str2, str3, gisbase, grass_version);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    case 8: {
                                                                                        // 0x80545c1
                                                                                        v31 = grass_version;
                                                                                        g3 = (int32_t)v31;
                                                                                        test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    case 4: {
                                                                                        // 0x805462c
                                                                                        if (binaries_exist(str2, bins) == 0) {
                                                                                            // 0x80546b2
                                                                                            print_error(-12, "no binaries for system '%s'\n");
                                                                                            // branch -> 0x80546d1
                                                                                            // 0x80546d1
                                                                                            exit(0);
                                                                                            // UNREACHABLE
                                                                                        }
                                                                                        // 0x805464a
                                                                                        v32 = grass_version;
                                                                                        g3 = (int32_t)v32;
                                                                                        bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                        break;
                                                                                    }
                                                                                }
                                                                                // 0x80546d1
                                                                                exit(0);
                                                                                // UNREACHABLE
                                                                            }
                                                                            // 0x8053ff5
                                                                            strcpy(str2, tmp);
                                                                            if (dir_found == 0) {
                                                                                // 0x8054019
                                                                                print_error(-7, "no top-level directory found in extension package.\n");
                                                                                // branch -> 0x805402d
                                                                            }
                                                                        }
                                                                        // 0x805402d
                                                                        if (action != 10) {
                                                                            // 0x8054053
                                                                            get_package_name(str2, str3);
                                                                            // branch -> 0x805406d
                                                                            // 0x805406d
                                                                            if (valid >= 1) {
                                                                                // 0x8054077
                                                                                v37 = gisbase;
                                                                                v29 = v37;
                                                                                if (v37 == NULL) {
                                                                                    // 0x8054081
                                                                                    env_val = getenv("GISBASE");
                                                                                    gisbase = env_val;
                                                                                    v29 = env_val;
                                                                                    // branch -> 0x8054094
                                                                                }
                                                                                // 0x8054094
                                                                                run_post(str2, action, bins, v29);
                                                                                // branch -> 0x80540c4
                                                                            }
                                                                            // 0x80540c4
                                                                            if (VERBOSE != 0) {
                                                                                // 0x80540cd
                                                                                fprintf((struct _IO_FILE *)g15, "Extension will be installed from '%s'\n", str2);
                                                                                // branch -> 0x80540ee
                                                                            }
                                                                            // 0x80540ee
                                                                            if (action == 10) {
                                                                                // 0x8054214
                                                                                if (gisbase == NULL) {
                                                                                    // 0x805421e
                                                                                    env_val2 = getenv("GISBASE");
                                                                                    gisbase = env_val2;
                                                                                    if (env_val2 == NULL) {
                                                                                        // 0x805423b
                                                                                        print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                                        // branch -> 0x805424f
                                                                                    }
                                                                                }
                                                                                // 0x805424f
                                                                                if (VERBOSE != 0) {
                                                                                    // 0x8054258
                                                                                    fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                                    // branch -> 0x8054279
                                                                                }
                                                                                // 0x8054279
                                                                                env_val3 = getenv("GRASS_VERSION");
                                                                                grass_version = env_val3;
                                                                                if (env_val3 == NULL) {
                                                                                    // 0x805429a
                                                                                    sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                                                                    file = fopen(str4, "r");
                                                                                    f = (struct _IO_FILE_7 *)file;
                                                                                    if (file == NULL) {
                                                                                        // 0x80542e6
                                                                                        print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                        // branch -> 0x8054366
                                                                                    } else {
                                                                                        // 0x80542fc
                                                                                        mem2 = malloc(16);
                                                                                        grass_version = mem2;
                                                                                        error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                                                                        fclose((struct _IO_FILE *)f);
                                                                                        if (error <= 0) {
                                                                                            // 0x8054352
                                                                                            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                            // branch -> 0x8054366
                                                                                        }
                                                                                    }
                                                                                    // 0x8054366
                                                                                    str5 = grass_version;
                                                                                    if (str5 != NULL) {
                                                                                        // 0x8054374
                                                                                        str6 = strdup(str5);
                                                                                        tmp = str6;
                                                                                        grass_major = strtok(str6, ".");
                                                                                        grass_minor = strtok(NULL, ".");
                                                                                        grass_revision = strtok(NULL, ".");
                                                                                        major = strtol(grass_major, NULL, 10);
                                                                                        minor = strtol(grass_minor, NULL, 10);
                                                                                        revision = strtol(grass_revision, NULL, 10);
                                                                                        mem3 = malloc(2048);
                                                                                        grass_version = mem3;
                                                                                        sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                        if (VERBOSE != 0) {
                                                                                            // 0x80544a8
                                                                                            fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                            // branch -> 0x80544c9
                                                                                        }
                                                                                        // 0x80544c9
                                                                                        if (major <= 5) {
                                                                                            // 0x80544d3
                                                                                            print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                            // branch -> 0x80544e7
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // 0x8054374
                                                                                    str6 = strdup(env_val3);
                                                                                    tmp = str6;
                                                                                    grass_major = strtok(str6, ".");
                                                                                    grass_minor = strtok(NULL, ".");
                                                                                    grass_revision = strtok(NULL, ".");
                                                                                    major = strtol(grass_major, NULL, 10);
                                                                                    minor = strtol(grass_minor, NULL, 10);
                                                                                    revision = strtol(grass_revision, NULL, 10);
                                                                                    mem3 = malloc(2048);
                                                                                    grass_version = mem3;
                                                                                    sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                    if (VERBOSE != 0) {
                                                                                        // 0x80544a8
                                                                                        fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                        // branch -> 0x80544c9
                                                                                    }
                                                                                    // 0x80544c9
                                                                                    if (major <= 5) {
                                                                                        // 0x80544d3
                                                                                        print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                        // branch -> 0x80544e7
                                                                                    }
                                                                                }
                                                                                // 0x80544e7
                                                                                sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                                                                switch (action) {
                                                                                    case 3: {
                                                                                        // 0x8054514
                                                                                        v30 = grass_version;
                                                                                        g3 = (int32_t)v30;
                                                                                        source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    case 10: {
                                                                                        // 0x805457b
                                                                                        uninstall(str2, str3, gisbase, grass_version);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    case 8: {
                                                                                        // 0x80545c1
                                                                                        v31 = grass_version;
                                                                                        g3 = (int32_t)v31;
                                                                                        test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    case 4: {
                                                                                        // 0x805462c
                                                                                        if (binaries_exist(str2, bins) == 0) {
                                                                                            // 0x80546b2
                                                                                            print_error(-12, "no binaries for system '%s'\n");
                                                                                            // branch -> 0x80546d1
                                                                                            // 0x80546d1
                                                                                            exit(0);
                                                                                            // UNREACHABLE
                                                                                        }
                                                                                        // 0x805464a
                                                                                        v32 = grass_version;
                                                                                        g3 = (int32_t)v32;
                                                                                        bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                        break;
                                                                                    }
                                                                                }
                                                                                // 0x80546d1
                                                                                exit(0);
                                                                                // UNREACHABLE
                                                                            }
                                                                            // 0x8054133
                                                                            check_extension(str2, v1, &pkg_major, &pkg_minor, &pkg_revision);
                                                                            switch (action) {
                                                                                case 5: {
                                                                                    // 0x805413d
                                                                                    query_extension(str2, v1, pkg_major, pkg_minor, pkg_revision, str3, str, str9);
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                }
                                                                                case 9: {
                                                                                    // 0x80541af
                                                                                    show_details(str2);
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                }
                                                                                case 7: {
                                                                                    // 0x80541d4
                                                                                    show_license(str2);
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                }
                                                                                case 6: {
                                                                                    // 0x80541f9
                                                                                    source_clean(str2);
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                }
                                                                            }
                                                                            // 0x8054214
                                                                            if (gisbase == NULL) {
                                                                                // 0x805421e
                                                                                env_val2 = getenv("GISBASE");
                                                                                gisbase = env_val2;
                                                                                if (env_val2 == NULL) {
                                                                                    // 0x805423b
                                                                                    print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                                    // branch -> 0x805424f
                                                                                }
                                                                            }
                                                                            // 0x805424f
                                                                            if (VERBOSE != 0) {
                                                                                // 0x8054258
                                                                                fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                                // branch -> 0x8054279
                                                                            }
                                                                            // 0x8054279
                                                                            env_val3 = getenv("GRASS_VERSION");
                                                                            grass_version = env_val3;
                                                                            if (env_val3 == NULL) {
                                                                                // 0x805429a
                                                                                sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                                                                file = fopen(str4, "r");
                                                                                f = (struct _IO_FILE_7 *)file;
                                                                                if (file == NULL) {
                                                                                    // 0x80542e6
                                                                                    print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                    // branch -> 0x8054366
                                                                                } else {
                                                                                    // 0x80542fc
                                                                                    mem2 = malloc(16);
                                                                                    grass_version = mem2;
                                                                                    error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                                                                    fclose((struct _IO_FILE *)f);
                                                                                    if (error <= 0) {
                                                                                        // 0x8054352
                                                                                        print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                        // branch -> 0x8054366
                                                                                    }
                                                                                }
                                                                                // 0x8054366
                                                                                str5 = grass_version;
                                                                                if (str5 != NULL) {
                                                                                    // 0x8054374
                                                                                    str6 = strdup(str5);
                                                                                    tmp = str6;
                                                                                    grass_major = strtok(str6, ".");
                                                                                    grass_minor = strtok(NULL, ".");
                                                                                    grass_revision = strtok(NULL, ".");
                                                                                    major = strtol(grass_major, NULL, 10);
                                                                                    minor = strtol(grass_minor, NULL, 10);
                                                                                    revision = strtol(grass_revision, NULL, 10);
                                                                                    mem3 = malloc(2048);
                                                                                    grass_version = mem3;
                                                                                    sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                    if (VERBOSE != 0) {
                                                                                        // 0x80544a8
                                                                                        fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                        // branch -> 0x80544c9
                                                                                    }
                                                                                    // 0x80544c9
                                                                                    if (major <= 5) {
                                                                                        // 0x80544d3
                                                                                        print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                        // branch -> 0x80544e7
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                // 0x8054374
                                                                                str6 = strdup(env_val3);
                                                                                tmp = str6;
                                                                                grass_major = strtok(str6, ".");
                                                                                grass_minor = strtok(NULL, ".");
                                                                                grass_revision = strtok(NULL, ".");
                                                                                major = strtol(grass_major, NULL, 10);
                                                                                minor = strtol(grass_minor, NULL, 10);
                                                                                revision = strtol(grass_revision, NULL, 10);
                                                                                mem3 = malloc(2048);
                                                                                grass_version = mem3;
                                                                                sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                if (VERBOSE != 0) {
                                                                                    // 0x80544a8
                                                                                    fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                    // branch -> 0x80544c9
                                                                                }
                                                                                // 0x80544c9
                                                                                if (major <= 5) {
                                                                                    // 0x80544d3
                                                                                    print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                    // branch -> 0x80544e7
                                                                                }
                                                                            }
                                                                            // 0x80544e7
                                                                            sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                                                            switch (action) {
                                                                                case 3: {
                                                                                    // 0x8054514
                                                                                    v30 = grass_version;
                                                                                    g3 = (int32_t)v30;
                                                                                    source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                }
                                                                                case 10: {
                                                                                    // 0x805457b
                                                                                    uninstall(str2, str3, gisbase, grass_version);
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                }
                                                                                case 8: {
                                                                                    // 0x80545c1
                                                                                    v31 = grass_version;
                                                                                    g3 = (int32_t)v31;
                                                                                    test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                }
                                                                                case 4: {
                                                                                    // 0x805462c
                                                                                    if (binaries_exist(str2, bins) == 0) {
                                                                                        // 0x80546b2
                                                                                        print_error(-12, "no binaries for system '%s'\n");
                                                                                        // branch -> 0x80546d1
                                                                                        // 0x80546d1
                                                                                        exit(0);
                                                                                        // UNREACHABLE
                                                                                    }
                                                                                    // 0x805464a
                                                                                    v32 = grass_version;
                                                                                    g3 = (int32_t)v32;
                                                                                    bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                    break;
                                                                                }
                                                                            }
                                                                            // 0x80546d1
                                                                            exit(0);
                                                                            // UNREACHABLE
                                                                        }
                                                                    }
                                                                    // 0x8054037
                                                                    strcpy(str3, str2);
                                                                    // branch -> 0x805406d
                                                                    // 0x805406d
                                                                    if (valid >= 1) {
                                                                        // 0x8054077
                                                                        v37 = gisbase;
                                                                        v29 = v37;
                                                                        if (v37 == NULL) {
                                                                            // 0x8054081
                                                                            env_val = getenv("GISBASE");
                                                                            gisbase = env_val;
                                                                            v29 = env_val;
                                                                            // branch -> 0x8054094
                                                                        }
                                                                        // 0x8054094
                                                                        run_post(str2, action, bins, v29);
                                                                        // branch -> 0x80540c4
                                                                    }
                                                                    // 0x80540c4
                                                                    if (VERBOSE != 0) {
                                                                        // 0x80540cd
                                                                        fprintf((struct _IO_FILE *)g15, "Extension will be installed from '%s'\n", str2);
                                                                        // branch -> 0x80540ee
                                                                    }
                                                                    // 0x80540ee
                                                                    if (action == 10) {
                                                                        // 0x8054214
                                                                        if (gisbase == NULL) {
                                                                            // 0x805421e
                                                                            env_val2 = getenv("GISBASE");
                                                                            gisbase = env_val2;
                                                                            if (env_val2 == NULL) {
                                                                                // 0x805423b
                                                                                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                                // branch -> 0x805424f
                                                                            }
                                                                        }
                                                                        // 0x805424f
                                                                        if (VERBOSE != 0) {
                                                                            // 0x8054258
                                                                            fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                            // branch -> 0x8054279
                                                                        }
                                                                        // 0x8054279
                                                                        env_val3 = getenv("GRASS_VERSION");
                                                                        grass_version = env_val3;
                                                                        if (env_val3 == NULL) {
                                                                            // 0x805429a
                                                                            sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                                                            file = fopen(str4, "r");
                                                                            f = (struct _IO_FILE_7 *)file;
                                                                            if (file == NULL) {
                                                                                // 0x80542e6
                                                                                print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                // branch -> 0x8054366
                                                                            } else {
                                                                                // 0x80542fc
                                                                                mem2 = malloc(16);
                                                                                grass_version = mem2;
                                                                                error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                                                                fclose((struct _IO_FILE *)f);
                                                                                if (error <= 0) {
                                                                                    // 0x8054352
                                                                                    print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                    // branch -> 0x8054366
                                                                                }
                                                                            }
                                                                            // 0x8054366
                                                                            str5 = grass_version;
                                                                            if (str5 != NULL) {
                                                                                // 0x8054374
                                                                                str6 = strdup(str5);
                                                                                tmp = str6;
                                                                                grass_major = strtok(str6, ".");
                                                                                grass_minor = strtok(NULL, ".");
                                                                                grass_revision = strtok(NULL, ".");
                                                                                major = strtol(grass_major, NULL, 10);
                                                                                minor = strtol(grass_minor, NULL, 10);
                                                                                revision = strtol(grass_revision, NULL, 10);
                                                                                mem3 = malloc(2048);
                                                                                grass_version = mem3;
                                                                                sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                                if (VERBOSE != 0) {
                                                                                    // 0x80544a8
                                                                                    fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                    // branch -> 0x80544c9
                                                                                }
                                                                                // 0x80544c9
                                                                                if (major <= 5) {
                                                                                    // 0x80544d3
                                                                                    print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                    // branch -> 0x80544e7
                                                                                }
                                                                            }
                                                                        } else {
                                                                            // 0x8054374
                                                                            str6 = strdup(env_val3);
                                                                            tmp = str6;
                                                                            grass_major = strtok(str6, ".");
                                                                            grass_minor = strtok(NULL, ".");
                                                                            grass_revision = strtok(NULL, ".");
                                                                            major = strtol(grass_major, NULL, 10);
                                                                            minor = strtol(grass_minor, NULL, 10);
                                                                            revision = strtol(grass_revision, NULL, 10);
                                                                            mem3 = malloc(2048);
                                                                            grass_version = mem3;
                                                                            sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                            if (VERBOSE != 0) {
                                                                                // 0x80544a8
                                                                                fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                // branch -> 0x80544c9
                                                                            }
                                                                            // 0x80544c9
                                                                            if (major <= 5) {
                                                                                // 0x80544d3
                                                                                print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                // branch -> 0x80544e7
                                                                            }
                                                                        }
                                                                        // 0x80544e7
                                                                        sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                                                        switch (action) {
                                                                            case 3: {
                                                                                // 0x8054514
                                                                                v30 = grass_version;
                                                                                g3 = (int32_t)v30;
                                                                                source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                                                                exit(0);
                                                                                // UNREACHABLE
                                                                            }
                                                                            case 10: {
                                                                                // 0x805457b
                                                                                uninstall(str2, str3, gisbase, grass_version);
                                                                                exit(0);
                                                                                // UNREACHABLE
                                                                            }
                                                                            case 8: {
                                                                                // 0x80545c1
                                                                                v31 = grass_version;
                                                                                g3 = (int32_t)v31;
                                                                                test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                                                                exit(0);
                                                                                // UNREACHABLE
                                                                            }
                                                                            case 4: {
                                                                                // 0x805462c
                                                                                if (binaries_exist(str2, bins) == 0) {
                                                                                    // 0x80546b2
                                                                                    print_error(-12, "no binaries for system '%s'\n");
                                                                                    // branch -> 0x80546d1
                                                                                    // 0x80546d1
                                                                                    exit(0);
                                                                                    // UNREACHABLE
                                                                                }
                                                                                // 0x805464a
                                                                                v32 = grass_version;
                                                                                g3 = (int32_t)v32;
                                                                                bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                                                                exit(0);
                                                                                // UNREACHABLE
                                                                                break;
                                                                            }
                                                                        }
                                                                        // 0x80546d1
                                                                        exit(0);
                                                                        // UNREACHABLE
                                                                    }
                                                                    // 0x8054133
                                                                    check_extension(str2, v1, &pkg_major, &pkg_minor, &pkg_revision);
                                                                    switch (action) {
                                                                        case 5: {
                                                                            // 0x805413d
                                                                            query_extension(str2, v1, pkg_major, pkg_minor, pkg_revision, str3, str, str9);
                                                                            exit(0);
                                                                            // UNREACHABLE
                                                                        }
                                                                        case 9: {
                                                                            // 0x80541af
                                                                            show_details(str2);
                                                                            exit(0);
                                                                            // UNREACHABLE
                                                                        }
                                                                        case 7: {
                                                                            // 0x80541d4
                                                                            show_license(str2);
                                                                            exit(0);
                                                                            // UNREACHABLE
                                                                        }
                                                                        case 6: {
                                                                            // 0x80541f9
                                                                            source_clean(str2);
                                                                            exit(0);
                                                                            // UNREACHABLE
                                                                        }
                                                                    }
                                                                    // 0x8054214
                                                                    if (gisbase == NULL) {
                                                                        // 0x805421e
                                                                        env_val2 = getenv("GISBASE");
                                                                        gisbase = env_val2;
                                                                        if (env_val2 == NULL) {
                                                                            // 0x805423b
                                                                            print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                            // branch -> 0x805424f
                                                                        }
                                                                    }
                                                                    // 0x805424f
                                                                    if (VERBOSE != 0) {
                                                                        // 0x8054258
                                                                        fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                        // branch -> 0x8054279
                                                                    }
                                                                    // 0x8054279
                                                                    env_val3 = getenv("GRASS_VERSION");
                                                                    grass_version = env_val3;
                                                                    if (env_val3 == NULL) {
                                                                        // 0x805429a
                                                                        sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                                                        file = fopen(str4, "r");
                                                                        f = (struct _IO_FILE_7 *)file;
                                                                        if (file == NULL) {
                                                                            // 0x80542e6
                                                                            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                            // branch -> 0x8054366
                                                                        } else {
                                                                            // 0x80542fc
                                                                            mem2 = malloc(16);
                                                                            grass_version = mem2;
                                                                            error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                                                            fclose((struct _IO_FILE *)f);
                                                                            if (error <= 0) {
                                                                                // 0x8054352
                                                                                print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                                                // branch -> 0x8054366
                                                                            }
                                                                        }
                                                                        // 0x8054366
                                                                        str5 = grass_version;
                                                                        if (str5 != NULL) {
                                                                            // 0x8054374
                                                                            str6 = strdup(str5);
                                                                            tmp = str6;
                                                                            grass_major = strtok(str6, ".");
                                                                            grass_minor = strtok(NULL, ".");
                                                                            grass_revision = strtok(NULL, ".");
                                                                            major = strtol(grass_major, NULL, 10);
                                                                            minor = strtol(grass_minor, NULL, 10);
                                                                            revision = strtol(grass_revision, NULL, 10);
                                                                            mem3 = malloc(2048);
                                                                            grass_version = mem3;
                                                                            sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                            if (VERBOSE != 0) {
                                                                                // 0x80544a8
                                                                                fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                                // branch -> 0x80544c9
                                                                            }
                                                                            // 0x80544c9
                                                                            if (major <= 5) {
                                                                                // 0x80544d3
                                                                                print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                                // branch -> 0x80544e7
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // 0x8054374
                                                                        str6 = strdup(env_val3);
                                                                        tmp = str6;
                                                                        grass_major = strtok(str6, ".");
                                                                        grass_minor = strtok(NULL, ".");
                                                                        grass_revision = strtok(NULL, ".");
                                                                        major = strtol(grass_major, NULL, 10);
                                                                        minor = strtol(grass_minor, NULL, 10);
                                                                        revision = strtol(grass_revision, NULL, 10);
                                                                        mem3 = malloc(2048);
                                                                        grass_version = mem3;
                                                                        sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                                                        if (VERBOSE != 0) {
                                                                            // 0x80544a8
                                                                            fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                                            // branch -> 0x80544c9
                                                                        }
                                                                        // 0x80544c9
                                                                        if (major <= 5) {
                                                                            // 0x80544d3
                                                                            print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                                            // branch -> 0x80544e7
                                                                        }
                                                                    }
                                                                    // 0x80544e7
                                                                    sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                                                    switch (action) {
                                                                        case 3: {
                                                                            // 0x8054514
                                                                            v30 = grass_version;
                                                                            g3 = (int32_t)v30;
                                                                            source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                                                            exit(0);
                                                                            // UNREACHABLE
                                                                        }
                                                                        case 10: {
                                                                            // 0x805457b
                                                                            uninstall(str2, str3, gisbase, grass_version);
                                                                            exit(0);
                                                                            // UNREACHABLE
                                                                        }
                                                                        case 8: {
                                                                            // 0x80545c1
                                                                            v31 = grass_version;
                                                                            g3 = (int32_t)v31;
                                                                            test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                                                            exit(0);
                                                                            // UNREACHABLE
                                                                        }
                                                                        case 4: {
                                                                            // 0x805462c
                                                                            if (binaries_exist(str2, bins) == 0) {
                                                                                // 0x80546b2
                                                                                print_error(-12, "no binaries for system '%s'\n");
                                                                                // branch -> 0x80546d1
                                                                                // 0x80546d1
                                                                                exit(0);
                                                                                // UNREACHABLE
                                                                            }
                                                                            // 0x805464a
                                                                            v32 = grass_version;
                                                                            g3 = (int32_t)v32;
                                                                            bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                                                            exit(0);
                                                                            // UNREACHABLE
                                                                            break;
                                                                        }
                                                                    }
                                                                    // 0x80546d1
                                                                    exit(0);
                                                                    // UNREACHABLE
                                                                    break;
                                                                }
                                                                case 11: {
                                                                    // 0x8053beb
                                                                    if (gisbase != NULL) {
                                                                        // 0x8053c26
                                                                        if (VERBOSE != 0) {
                                                                            // 0x8053c2f
                                                                            fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                            // branch -> 0x8053c50
                                                                        }
                                                                        // 0x8053c50
                                                                        restore(gisbase, grass_version);
                                                                        exit(0);
                                                                        // UNREACHABLE
                                                                    }
                                                                    break;
                                                                }
                                                                case 12: {
                                                                    // 0x8053c84
                                                                    if (gisbase == NULL) {
                                                                        // 0x8053c8e
                                                                        env_val4 = getenv("GISBASE");
                                                                        gisbase = env_val4;
                                                                        if (env_val4 == NULL) {
                                                                            // 0x8053cab
                                                                            print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                            // branch -> 0x8053cbf
                                                                        }
                                                                    }
                                                                    // 0x8053cbf
                                                                    if (VERBOSE != 0) {
                                                                        // 0x8053cc8
                                                                        fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                        // branch -> 0x8053ce9
                                                                    }
                                                                    // 0x8053ce9
                                                                    list_extensions(gisbase);
                                                                    exit(0);
                                                                    // UNREACHABLE
                                                                    break;
                                                                }
                                                            }
                                                            // 0x8053bf5
                                                            env_val5 = getenv("GISBASE");
                                                            gisbase = env_val5;
                                                            if (env_val5 == NULL) {
                                                                // 0x8053c12
                                                                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                                                // branch -> 0x8053c26
                                                            }
                                                            // 0x8053c26
                                                            if (VERBOSE != 0) {
                                                                // 0x8053c2f
                                                                fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                                                // branch -> 0x8053c50
                                                            }
                                                            // 0x8053c50
                                                            restore(gisbase, grass_version);
                                                            exit(0);
                                                            // UNREACHABLE
                                                            break;
                                                        }
                                                        case 1: {
                                                            // 0x8053b1b
                                                            show_help();
                                                            exit(0);
                                                            // UNREACHABLE
                                                        }
                                                        case 2: {
                                                            // 0x8053b36
                                                            show_version();
                                                            exit(0);
                                                            // UNREACHABLE
                                                        }
                                                    }
                                                } else {
                                                    // 0x80537a6
                                                    v38 = option;
                                                    // branch -> 0x80537c8
                                                    // 0x80537c8
                                                    v39 = v38;
                                                    switch (v38) {
                                                        case 117: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action != 4) {
                                                                      lab_0x8053862_19:
                                                                        // 0x8053862
                                                                        action = 3;
                                                                        // branch -> 0x80538e5
                                                                    }
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_10:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 != 0) {
                                                              lab_0x80538ee_19:
                                                                // 0x80538ee
                                                                strcpy(str2, (char *)str8);
                                                                strcpy(str9, (char *)g17);
                                                                v39 = option;
                                                                // branch -> 0x805391e
                                                            } else {
                                                                v39 = v38;
                                                            }
                                                            break;
                                                        }
                                                        case 116: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_10;
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_10;
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_10;
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_10;
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action == 4) {
                                                                        goto lab_0x80538e5_10;
                                                                    }
                                                                    goto lab_0x8053862_19;
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_10;
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_10;
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_10;
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_10;
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_10;
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_20:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 != 0) {
                                                                goto lab_0x80538ee_19;
                                                            }
                                                            v39 = v38;
                                                          lab_0x805391e_8:
                                                            // 0x805391e
                                                            v40 = v39;
                                                            if (v39 == 103) {
                                                              lab_0x8053928_2:;
                                                                char * mem4 = malloc(strlen((char *)g17) + 1); // 0x805393b
                                                                gisbase = mem4;
                                                                strcpy(mem4, (char *)g17);
                                                                v40 = option;
                                                                // branch -> 0x805395f
                                                            }
                                                          lab_0x805395f_2:;
                                                            int32_t v47 = v40; // 0x80539ab
                                                            if (v40 == 98) {
                                                                char * mem5 = malloc(strlen((char *)g17) + 1); // 0x805397c
                                                                bins = mem5;
                                                                strcpy(mem5, (char *)g17);
                                                                action = 4;
                                                                v47 = option;
                                                                // branch -> 0x80539ab
                                                            }
                                                            int32_t v48 = v47; // 0x8053a06
                                                            if (v47 == 120) {
                                                                // 0x80539b5
                                                                strcpy(CONFIG_OPTS, (char *)g17);
                                                                v48 = option;
                                                                // branch -> 0x80539ca
                                                            }
                                                            int32_t v49 = v48; // 0x8053a28
                                                            switch (v48) {
                                                                case 102: {
                                                                    // 0x80539de
                                                                    FORCE = 1;
                                                                    // branch -> 0x8053a66
                                                                    break;
                                                                }
                                                                case 118: {
                                                                    // 0x80539e8
                                                                    VERBOSE = 1;
                                                                    // branch -> 0x8053a66
                                                                    break;
                                                                }
                                                                case 115: {
                                                                    // 0x8053a47
                                                                    SKIP_CFG = 1;
                                                                    // branch -> 0x8053a66
                                                                    break;
                                                                }
                                                                case 111: {
                                                                    // 0x8053a10
                                                                    strcat(str7, (char *)g17);
                                                                    // branch -> 0x8053a28
                                                                    v49 = option;
                                                                }
                                                                default: {
                                                                    int32_t v50 = v49; // 0x8053a47
                                                                    if (v49 == 67) {
                                                                        // 0x8053a32
                                                                        strcpy(CONFIG_CMD, (char *)g17);
                                                                        v50 = option;
                                                                        // branch -> 0x8053a47
                                                                    }
                                                                    // 0x8053a47
                                                                    if (v50 == 109) {
                                                                        // 0x8053a51
                                                                        strcpy(MAKE_CMD, (char *)g17);
                                                                        // branch -> 0x8053a66
                                                                    }
                                                                    break;
                                                                }
                                                            }
                                                            int32_t v51 = getopt_long(argc, argv, ":i:u:q:d:c:t:l:o:x:rhVg:b:fvs", (struct option *)&g12, &option_index); // 0x8053a8f
                                                            v25 = v51;
                                                            // branch -> 0x8053a9b
                                                            continue;
                                                        }
                                                        case 114: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_20;
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_20;
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_20;
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_20;
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action == 4) {
                                                                        goto lab_0x80538e5_20;
                                                                    }
                                                                    goto lab_0x8053862_19;
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_20;
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_20;
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_20;
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_20;
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_20;
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_30:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 == 0) {
                                                                v39 = v38;
                                                                goto lab_0x805391e_8;
                                                            }
                                                            goto lab_0x80538ee_19;
                                                            break;
                                                        }
                                                        case 113: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_30;
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_30;
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_30;
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_30;
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action == 4) {
                                                                        goto lab_0x80538e5_30;
                                                                    }
                                                                    goto lab_0x8053862_19;
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_30;
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_30;
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_30;
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_30;
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_30;
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_40:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 == 0) {
                                                                v39 = v38;
                                                                goto lab_0x805391e_8;
                                                            }
                                                            goto lab_0x80538ee_19;
                                                            break;
                                                        }
                                                        case 108: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_40;
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_40;
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_40;
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_40;
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action == 4) {
                                                                        goto lab_0x80538e5_40;
                                                                    }
                                                                    goto lab_0x8053862_19;
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_40;
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_40;
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_40;
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_40;
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_40;
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_50:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 == 0) {
                                                                v39 = v38;
                                                                goto lab_0x805391e_8;
                                                            }
                                                            goto lab_0x80538ee_19;
                                                            break;
                                                        }
                                                        case 105: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_50;
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_50;
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_50;
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_50;
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action == 4) {
                                                                        goto lab_0x80538e5_50;
                                                                    }
                                                                    goto lab_0x8053862_19;
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_50;
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_50;
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_50;
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_50;
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_50;
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_60:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 == 0) {
                                                                v39 = v38;
                                                                goto lab_0x805391e_8;
                                                            }
                                                            goto lab_0x80538ee_19;
                                                            break;
                                                        }
                                                        case 104: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_60;
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_60;
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_60;
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_60;
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action == 4) {
                                                                        goto lab_0x80538e5_60;
                                                                    }
                                                                    goto lab_0x8053862_19;
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_60;
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_60;
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_60;
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_60;
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_60;
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_70:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 == 0) {
                                                                v39 = v38;
                                                                goto lab_0x805391e_8;
                                                            }
                                                            goto lab_0x80538ee_19;
                                                            break;
                                                        }
                                                        case 100: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_70;
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_70;
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_70;
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_70;
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action == 4) {
                                                                        goto lab_0x80538e5_70;
                                                                    }
                                                                    goto lab_0x8053862_19;
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_70;
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_70;
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_70;
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_70;
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_70;
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_80:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 == 0) {
                                                                v39 = v38;
                                                                goto lab_0x805391e_8;
                                                            }
                                                            goto lab_0x80538ee_19;
                                                            break;
                                                        }
                                                        case 99: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_80;
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_80;
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_80;
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_80;
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action == 4) {
                                                                        goto lab_0x80538e5_80;
                                                                    }
                                                                    goto lab_0x8053862_19;
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_80;
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_80;
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_80;
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_80;
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_80;
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_90:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 == 0) {
                                                                v39 = v38;
                                                                goto lab_0x805391e_8;
                                                            }
                                                            goto lab_0x80538ee_19;
                                                            break;
                                                        }
                                                        case 86: {
                                                            // 0x8053830
                                                            valid++;
                                                            switch (v38) {
                                                                case 86: {
                                                                    // 0x80538d7
                                                                    action = 2;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_90;
                                                                    break;
                                                                }
                                                                case 99: {
                                                                    // 0x8053896
                                                                    action = 6;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_90;
                                                                    break;
                                                                }
                                                                case 100: {
                                                                    // 0x8053889
                                                                    action = 9;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_90;
                                                                    break;
                                                                }
                                                                case 104: {
                                                                    // 0x80538ca
                                                                    action = 1;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_90;
                                                                    break;
                                                                }
                                                                case 105: {
                                                                    // 0x8053854
                                                                    if (action == 4) {
                                                                        goto lab_0x80538e5_90;
                                                                    }
                                                                    goto lab_0x8053862_19;
                                                                    break;
                                                                }
                                                                case 108: {
                                                                    // 0x80538b0
                                                                    action = 7;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_90;
                                                                    break;
                                                                }
                                                                case 113: {
                                                                    // 0x805387c
                                                                    action = 5;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_90;
                                                                    break;
                                                                }
                                                                case 114: {
                                                                    // 0x80538bd
                                                                    action = 11;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_90;
                                                                    break;
                                                                }
                                                                case 116: {
                                                                    // 0x80538a3
                                                                    action = 8;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_90;
                                                                    break;
                                                                }
                                                                case 117: {
                                                                    // 0x805386f
                                                                    action = 10;
                                                                    // branch -> 0x80538e5
                                                                    goto lab_0x80538e5_90;
                                                                    break;
                                                                }
                                                            }
                                                          lab_0x80538e5_100:
                                                            // 0x80538e5
                                                            str8 = g17;
                                                            if (str8 == 0) {
                                                                v39 = v38;
                                                                goto lab_0x805391e_8;
                                                            }
                                                            goto lab_0x80538ee_19;
                                                            break;
                                                        }
                                                    }
                                                  lab_0x805391e_18:
                                                    // 0x805391e
                                                    if (v39 == 103) {
                                                        goto lab_0x8053928_2;
                                                    }
                                                    v40 = v39;
                                                    goto lab_0x805395f_2;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // 0x8053738
                    print_error(-1, "missing file or directory name.\n");
                    v41 = g13;
                    // branch -> 0x805374c
                    goto lab_0x805374c;
                }
                // 0x80537c8
                v39 = v38;
                switch (v38) {
                    case 117: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_100;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_100;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_100;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_100;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_100;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_100;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_100;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_100;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_100;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_100;
                            }
                        }
                      lab_0x80538e5_110:
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                        break;
                    }
                    case 116: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_110;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_110;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_110;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_110;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_110;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_110;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_110;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_110;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_110;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_110;
                            }
                        }
                      lab_0x80538e5_120:
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                        break;
                    }
                    case 114: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_120;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_120;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_120;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_120;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_120;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_120;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_120;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_120;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_120;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_120;
                            }
                        }
                      lab_0x80538e5_130:
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                        break;
                    }
                    case 113: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_130;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_130;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_130;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_130;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_130;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_130;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_130;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_130;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_130;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_130;
                            }
                        }
                      lab_0x80538e5_140:
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                        break;
                    }
                    case 108: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_140;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_140;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_140;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_140;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_140;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_140;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_140;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_140;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_140;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_140;
                            }
                        }
                      lab_0x80538e5_150:
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                        break;
                    }
                    case 105: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_150;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_150;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_150;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_150;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_150;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_150;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_150;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_150;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_150;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_150;
                            }
                        }
                      lab_0x80538e5_160:
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                        break;
                    }
                    case 104: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_160;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_160;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_160;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_160;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_160;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_160;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_160;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_160;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_160;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_160;
                            }
                        }
                      lab_0x80538e5_170:
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                        break;
                    }
                    case 100: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_170;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_170;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_170;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_170;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_170;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_170;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_170;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_170;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_170;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_170;
                            }
                        }
                      lab_0x80538e5_180:
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                        break;
                    }
                    case 99: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_180;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_180;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_180;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_180;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_180;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_180;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_180;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_180;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_180;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_180;
                            }
                        }
                      lab_0x80538e5_190:
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                        break;
                    }
                    case 86: {
                        // 0x8053830
                        valid++;
                        switch (v38) {
                            case 86: {
                                // 0x80538d7
                                action = 2;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_190;
                            }
                            case 99: {
                                // 0x8053896
                                action = 6;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_190;
                            }
                            case 100: {
                                // 0x8053889
                                action = 9;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_190;
                            }
                            case 104: {
                                // 0x80538ca
                                action = 1;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_190;
                            }
                            case 105: {
                                // 0x8053854
                                if (action == 4) {
                                    goto lab_0x80538e5_190;
                                }
                                goto lab_0x8053862_19;
                            }
                            case 108: {
                                // 0x80538b0
                                action = 7;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_190;
                            }
                            case 113: {
                                // 0x805387c
                                action = 5;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_190;
                            }
                            case 114: {
                                // 0x80538bd
                                action = 11;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_190;
                            }
                            case 116: {
                                // 0x80538a3
                                action = 8;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_190;
                            }
                            case 117: {
                                // 0x805386f
                                action = 10;
                                // branch -> 0x80538e5
                                goto lab_0x80538e5_190;
                            }
                        }
                        // 0x80538e5
                        str8 = g17;
                        if (str8 == 0) {
                            v39 = v38;
                            goto lab_0x805391e_18;
                        }
                        goto lab_0x80538ee_19;
                    }
                }
                // 0x805391e
                if (v39 == 103) {
                    goto lab_0x8053928_2;
                }
                v40 = v39;
                goto lab_0x805395f_2;
            }
        }
        // 0x8053aa9
        v34 = v33;
        if (v33 <= 0) {
            // 0x8053ab3
            print_error(-1, "please specify a valid action.\n");
            v34 = valid;
            // branch -> 0x8053ac7
        }
        // 0x8053ac7
        if (v34 >= 2) {
            // 0x8053ad1
            print_error(-1, "please specify only one action.\n");
            // branch -> 0x8053ae5
        }
        // 0x8053ae5
        sprintf(GEM_C_OPTS, "GEM_C_OPTS=%s", str7);
        putenv(GEM_C_OPTS);
        v35 = action;
        switch (v35) {
            default: {
                // 0x8053b47
                v36 = v35;
                if (VERBOSE == 0) {
                    // 0x8053b54
                    memcpy(TMP_NULL, "/tmp/grass.extension.log.XXXXXX", 32);
                    mkstemp(TMP_NULL);
                    if (open(TMP_NULL, O_CREAT) == -1) {
                        // 0x8053baa
                        err_num = *__errno_location();
                        strerror(err_num);
                        print_error(-30, "could not create temp file: %s");
                        exit(-30);
                        // UNREACHABLE
                    }
                    // 0x8053b54
                    v36 = action;
                    // branch -> 0x8053bdd
                }
                // 0x8053bdd
                switch (v36) {
                    default: {
                        // 0x8053d04
                        if (strstr(str2, "http://") == NULL) {
                            // 0x8053d1f
                            if (strstr(str2, "ftp://") != NULL) {
                                // 0x8053d3e
                                wget_extension(str2);
                                mem = malloc(2048);
                                url = mem;
                                strcpy(mem, str2);
                                found_char_pos = strrchr(url, 47);
                                strcpy(str2, (char *)((int32_t)found_char_pos + 1));
                                free(url);
                                // branch -> 0x8053dc9
                            }
                        } else {
                            // 0x8053d3e
                            wget_extension(str2);
                            mem = malloc(2048);
                            url = mem;
                            strcpy(mem, str2);
                            found_char_pos = strrchr(url, 47);
                            strcpy(str2, (char *)((int32_t)found_char_pos + 1));
                            free(url);
                            // branch -> 0x8053dc9
                        }
                        // 0x8053dc9
                        if (VERBOSE != 0) {
                            // 0x8053dd2
                            fprintf((struct _IO_FILE *)g15, "Extension location is '%s'.\n", str2);
                            // branch -> 0x8053df3
                        }
                        // 0x8053df3
                        if (action != 10) {
                            // 0x8053e01
                            v27 = stat(str2, (struct stat *)&buf);
                            error = v27;
                            if (v27 <= 0) {
                                // 0x8053e2c
                                err_num2 = *__errno_location();
                                strerror(err_num2);
                                print_error(-2, "extension FILE or DIR '%s' invalid: %s\n");
                                // branch -> 0x8053e5e
                            }
                            // 0x8053e5e
                            if ((buf.e3 & 0xf000) == 0x4000) {
                                // 0x8053e71
                                if (VERBOSE != 0) {
                                    // 0x8053e89
                                    fwrite("Extension files stored in a directory.\n", 1, 39, (struct _IO_FILE *)g15);
                                    // branch -> 0x805402d
                                }
                            } else {
                                // 0x8053eb6
                                if (VERBOSE != 0) {
                                    // 0x8053ebf
                                    fwrite("Extension files stored in a package file.\n", 1, 42, (struct _IO_FILE *)g15);
                                    // branch -> 0x8053ee7
                                }
                                // 0x8053ee7
                                unpack_extension(str2);
                                dirp = opendir(TMPDIR);
                                dir = (struct __dirstream_4 *)dirp;
                                v28 = readdir(dirp);
                                dir_entry = (struct dirent_3 *)v28;
                                dir_found = 0;
                                if (v28 != NULL) {
                                    // 0x8053f2f
                                    // branch -> 0x8053f2f
                                    while (true) {
                                        // 0x8053f2f
                                        if (strcmp((char *)((int32_t)(struct dirent_3 *)v28 + 11), ".") == 0) {
                                            goto lab_0x8053fd1;
                                        }
                                        goto lab_0x8053f51;
                                    }
                                }
                                // 0x8053ff5
                                strcpy(str2, tmp);
                                if (dir_found == 0) {
                                    // 0x8054019
                                    print_error(-7, "no top-level directory found in extension package.\n");
                                    // branch -> 0x805402d
                                }
                            }
                            // 0x805402d
                            if (action != 10) {
                                // 0x8054053
                                get_package_name(str2, str3);
                                // branch -> 0x805406d
                                // 0x805406d
                                if (valid >= 1) {
                                    // 0x8054077
                                    v37 = gisbase;
                                    v29 = v37;
                                    if (v37 == NULL) {
                                        // 0x8054081
                                        env_val = getenv("GISBASE");
                                        gisbase = env_val;
                                        v29 = env_val;
                                        // branch -> 0x8054094
                                    }
                                    // 0x8054094
                                    run_post(str2, action, bins, v29);
                                    // branch -> 0x80540c4
                                }
                                // 0x80540c4
                                if (VERBOSE != 0) {
                                    // 0x80540cd
                                    fprintf((struct _IO_FILE *)g15, "Extension will be installed from '%s'\n", str2);
                                    // branch -> 0x80540ee
                                }
                                // 0x80540ee
                                if (action == 10) {
                                    // 0x8054214
                                    if (gisbase == NULL) {
                                        // 0x805421e
                                        env_val2 = getenv("GISBASE");
                                        gisbase = env_val2;
                                        if (env_val2 == NULL) {
                                            // 0x805423b
                                            print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                            // branch -> 0x805424f
                                        }
                                    }
                                    // 0x805424f
                                    if (VERBOSE != 0) {
                                        // 0x8054258
                                        fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                        // branch -> 0x8054279
                                    }
                                    // 0x8054279
                                    env_val3 = getenv("GRASS_VERSION");
                                    grass_version = env_val3;
                                    if (env_val3 == NULL) {
                                        // 0x805429a
                                        sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                        file = fopen(str4, "r");
                                        f = (struct _IO_FILE_7 *)file;
                                        if (file == NULL) {
                                            // 0x80542e6
                                            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                            // branch -> 0x8054366
                                        } else {
                                            // 0x80542fc
                                            mem2 = malloc(16);
                                            grass_version = mem2;
                                            error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                            fclose((struct _IO_FILE *)f);
                                            if (error <= 0) {
                                                // 0x8054352
                                                print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                                // branch -> 0x8054366
                                            }
                                        }
                                        // 0x8054366
                                        str5 = grass_version;
                                        if (str5 != NULL) {
                                            // 0x8054374
                                            str6 = strdup(str5);
                                            tmp = str6;
                                            grass_major = strtok(str6, ".");
                                            grass_minor = strtok(NULL, ".");
                                            grass_revision = strtok(NULL, ".");
                                            major = strtol(grass_major, NULL, 10);
                                            minor = strtol(grass_minor, NULL, 10);
                                            revision = strtol(grass_revision, NULL, 10);
                                            mem3 = malloc(2048);
                                            grass_version = mem3;
                                            sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                            if (VERBOSE != 0) {
                                                // 0x80544a8
                                                fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                                // branch -> 0x80544c9
                                            }
                                            // 0x80544c9
                                            if (major <= 5) {
                                                // 0x80544d3
                                                print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                                // branch -> 0x80544e7
                                            }
                                        }
                                    } else {
                                        // 0x8054374
                                        str6 = strdup(env_val3);
                                        tmp = str6;
                                        grass_major = strtok(str6, ".");
                                        grass_minor = strtok(NULL, ".");
                                        grass_revision = strtok(NULL, ".");
                                        major = strtol(grass_major, NULL, 10);
                                        minor = strtol(grass_minor, NULL, 10);
                                        revision = strtol(grass_revision, NULL, 10);
                                        mem3 = malloc(2048);
                                        grass_version = mem3;
                                        sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                        if (VERBOSE != 0) {
                                            // 0x80544a8
                                            fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                            // branch -> 0x80544c9
                                        }
                                        // 0x80544c9
                                        if (major <= 5) {
                                            // 0x80544d3
                                            print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                            // branch -> 0x80544e7
                                        }
                                    }
                                    // 0x80544e7
                                    sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                    switch (action) {
                                        case 3: {
                                            // 0x8054514
                                            v30 = grass_version;
                                            g3 = (int32_t)v30;
                                            source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                            exit(0);
                                            // UNREACHABLE
                                        }
                                        case 10: {
                                            // 0x805457b
                                            uninstall(str2, str3, gisbase, grass_version);
                                            exit(0);
                                            // UNREACHABLE
                                        }
                                        case 8: {
                                            // 0x80545c1
                                            v31 = grass_version;
                                            g3 = (int32_t)v31;
                                            test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                            exit(0);
                                            // UNREACHABLE
                                        }
                                        case 4: {
                                            // 0x805462c
                                            if (binaries_exist(str2, bins) == 0) {
                                                // 0x80546b2
                                                print_error(-12, "no binaries for system '%s'\n");
                                                // branch -> 0x80546d1
                                                // 0x80546d1
                                                exit(0);
                                                // UNREACHABLE
                                            }
                                            // 0x805464a
                                            v32 = grass_version;
                                            g3 = (int32_t)v32;
                                            bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                            exit(0);
                                            // UNREACHABLE
                                        }
                                    }
                                    // 0x80546d1
                                    exit(0);
                                    // UNREACHABLE
                                }
                                // 0x8054133
                                check_extension(str2, v1, &pkg_major, &pkg_minor, &pkg_revision);
                                switch (action) {
                                    case 5: {
                                        // 0x805413d
                                        query_extension(str2, v1, pkg_major, pkg_minor, pkg_revision, str3, str, str9);
                                        exit(0);
                                        // UNREACHABLE
                                    }
                                    case 9: {
                                        // 0x80541af
                                        show_details(str2);
                                        exit(0);
                                        // UNREACHABLE
                                    }
                                    case 7: {
                                        // 0x80541d4
                                        show_license(str2);
                                        exit(0);
                                        // UNREACHABLE
                                    }
                                    case 6: {
                                        // 0x80541f9
                                        source_clean(str2);
                                        exit(0);
                                        // UNREACHABLE
                                    }
                                }
                                // 0x8054214
                                if (gisbase == NULL) {
                                    // 0x805421e
                                    env_val2 = getenv("GISBASE");
                                    gisbase = env_val2;
                                    if (env_val2 == NULL) {
                                        // 0x805423b
                                        print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                        // branch -> 0x805424f
                                    }
                                }
                                // 0x805424f
                                if (VERBOSE != 0) {
                                    // 0x8054258
                                    fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                    // branch -> 0x8054279
                                }
                                // 0x8054279
                                env_val3 = getenv("GRASS_VERSION");
                                grass_version = env_val3;
                                if (env_val3 == NULL) {
                                    // 0x805429a
                                    sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                    file = fopen(str4, "r");
                                    f = (struct _IO_FILE_7 *)file;
                                    if (file == NULL) {
                                        // 0x80542e6
                                        print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                        // branch -> 0x8054366
                                    } else {
                                        // 0x80542fc
                                        mem2 = malloc(16);
                                        grass_version = mem2;
                                        error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                        fclose((struct _IO_FILE *)f);
                                        if (error <= 0) {
                                            // 0x8054352
                                            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                            // branch -> 0x8054366
                                        }
                                    }
                                    // 0x8054366
                                    str5 = grass_version;
                                    if (str5 != NULL) {
                                        // 0x8054374
                                        str6 = strdup(str5);
                                        tmp = str6;
                                        grass_major = strtok(str6, ".");
                                        grass_minor = strtok(NULL, ".");
                                        grass_revision = strtok(NULL, ".");
                                        major = strtol(grass_major, NULL, 10);
                                        minor = strtol(grass_minor, NULL, 10);
                                        revision = strtol(grass_revision, NULL, 10);
                                        mem3 = malloc(2048);
                                        grass_version = mem3;
                                        sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                        if (VERBOSE != 0) {
                                            // 0x80544a8
                                            fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                            // branch -> 0x80544c9
                                        }
                                        // 0x80544c9
                                        if (major <= 5) {
                                            // 0x80544d3
                                            print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                            // branch -> 0x80544e7
                                        }
                                    }
                                } else {
                                    // 0x8054374
                                    str6 = strdup(env_val3);
                                    tmp = str6;
                                    grass_major = strtok(str6, ".");
                                    grass_minor = strtok(NULL, ".");
                                    grass_revision = strtok(NULL, ".");
                                    major = strtol(grass_major, NULL, 10);
                                    minor = strtol(grass_minor, NULL, 10);
                                    revision = strtol(grass_revision, NULL, 10);
                                    mem3 = malloc(2048);
                                    grass_version = mem3;
                                    sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                    if (VERBOSE != 0) {
                                        // 0x80544a8
                                        fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                        // branch -> 0x80544c9
                                    }
                                    // 0x80544c9
                                    if (major <= 5) {
                                        // 0x80544d3
                                        print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                        // branch -> 0x80544e7
                                    }
                                }
                                // 0x80544e7
                                sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                                switch (action) {
                                    case 3: {
                                        // 0x8054514
                                        v30 = grass_version;
                                        g3 = (int32_t)v30;
                                        source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                        exit(0);
                                        // UNREACHABLE
                                    }
                                    case 10: {
                                        // 0x805457b
                                        uninstall(str2, str3, gisbase, grass_version);
                                        exit(0);
                                        // UNREACHABLE
                                    }
                                    case 8: {
                                        // 0x80545c1
                                        v31 = grass_version;
                                        g3 = (int32_t)v31;
                                        test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                        exit(0);
                                        // UNREACHABLE
                                    }
                                    case 4: {
                                        // 0x805462c
                                        if (binaries_exist(str2, bins) == 0) {
                                            // 0x80546b2
                                            print_error(-12, "no binaries for system '%s'\n");
                                            // branch -> 0x80546d1
                                            // 0x80546d1
                                            exit(0);
                                            // UNREACHABLE
                                        }
                                        // 0x805464a
                                        v32 = grass_version;
                                        g3 = (int32_t)v32;
                                        bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                        exit(0);
                                        // UNREACHABLE
                                    }
                                }
                                // 0x80546d1
                                exit(0);
                                // UNREACHABLE
                            }
                        }
                        // 0x8054037
                        strcpy(str3, str2);
                        // branch -> 0x805406d
                        // 0x805406d
                        if (valid >= 1) {
                            // 0x8054077
                            v37 = gisbase;
                            v29 = v37;
                            if (v37 == NULL) {
                                // 0x8054081
                                env_val = getenv("GISBASE");
                                gisbase = env_val;
                                v29 = env_val;
                                // branch -> 0x8054094
                            }
                            // 0x8054094
                            run_post(str2, action, bins, v29);
                            // branch -> 0x80540c4
                        }
                        // 0x80540c4
                        if (VERBOSE != 0) {
                            // 0x80540cd
                            fprintf((struct _IO_FILE *)g15, "Extension will be installed from '%s'\n", str2);
                            // branch -> 0x80540ee
                        }
                        // 0x80540ee
                        if (action == 10) {
                            // 0x8054214
                            if (gisbase == NULL) {
                                // 0x805421e
                                env_val2 = getenv("GISBASE");
                                gisbase = env_val2;
                                if (env_val2 == NULL) {
                                    // 0x805423b
                                    print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                    // branch -> 0x805424f
                                }
                            }
                            // 0x805424f
                            if (VERBOSE != 0) {
                                // 0x8054258
                                fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                // branch -> 0x8054279
                            }
                            // 0x8054279
                            env_val3 = getenv("GRASS_VERSION");
                            grass_version = env_val3;
                            if (env_val3 == NULL) {
                                // 0x805429a
                                sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                                file = fopen(str4, "r");
                                f = (struct _IO_FILE_7 *)file;
                                if (file == NULL) {
                                    // 0x80542e6
                                    print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                    // branch -> 0x8054366
                                } else {
                                    // 0x80542fc
                                    mem2 = malloc(16);
                                    grass_version = mem2;
                                    error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                    fclose((struct _IO_FILE *)f);
                                    if (error <= 0) {
                                        // 0x8054352
                                        print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                        // branch -> 0x8054366
                                    }
                                }
                                // 0x8054366
                                str5 = grass_version;
                                if (str5 != NULL) {
                                    // 0x8054374
                                    str6 = strdup(str5);
                                    tmp = str6;
                                    grass_major = strtok(str6, ".");
                                    grass_minor = strtok(NULL, ".");
                                    grass_revision = strtok(NULL, ".");
                                    major = strtol(grass_major, NULL, 10);
                                    minor = strtol(grass_minor, NULL, 10);
                                    revision = strtol(grass_revision, NULL, 10);
                                    mem3 = malloc(2048);
                                    grass_version = mem3;
                                    sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                    if (VERBOSE != 0) {
                                        // 0x80544a8
                                        fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                        // branch -> 0x80544c9
                                    }
                                    // 0x80544c9
                                    if (major <= 5) {
                                        // 0x80544d3
                                        print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                        // branch -> 0x80544e7
                                    }
                                }
                            } else {
                                // 0x8054374
                                str6 = strdup(env_val3);
                                tmp = str6;
                                grass_major = strtok(str6, ".");
                                grass_minor = strtok(NULL, ".");
                                grass_revision = strtok(NULL, ".");
                                major = strtol(grass_major, NULL, 10);
                                minor = strtol(grass_minor, NULL, 10);
                                revision = strtol(grass_revision, NULL, 10);
                                mem3 = malloc(2048);
                                grass_version = mem3;
                                sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                if (VERBOSE != 0) {
                                    // 0x80544a8
                                    fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                    // branch -> 0x80544c9
                                }
                                // 0x80544c9
                                if (major <= 5) {
                                    // 0x80544d3
                                    print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                    // branch -> 0x80544e7
                                }
                            }
                            // 0x80544e7
                            sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                            switch (action) {
                                case 3: {
                                    // 0x8054514
                                    v30 = grass_version;
                                    g3 = (int32_t)v30;
                                    source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                    exit(0);
                                    // UNREACHABLE
                                }
                                case 10: {
                                    // 0x805457b
                                    uninstall(str2, str3, gisbase, grass_version);
                                    exit(0);
                                    // UNREACHABLE
                                }
                                case 8: {
                                    // 0x80545c1
                                    v31 = grass_version;
                                    g3 = (int32_t)v31;
                                    test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                    exit(0);
                                    // UNREACHABLE
                                }
                                case 4: {
                                    // 0x805462c
                                    if (binaries_exist(str2, bins) == 0) {
                                        // 0x80546b2
                                        print_error(-12, "no binaries for system '%s'\n");
                                        // branch -> 0x80546d1
                                        // 0x80546d1
                                        exit(0);
                                        // UNREACHABLE
                                    }
                                    // 0x805464a
                                    v32 = grass_version;
                                    g3 = (int32_t)v32;
                                    bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                    exit(0);
                                    // UNREACHABLE
                                }
                            }
                            // 0x80546d1
                            exit(0);
                            // UNREACHABLE
                        }
                        // 0x8054133
                        check_extension(str2, v1, &pkg_major, &pkg_minor, &pkg_revision);
                        switch (action) {
                            case 5: {
                                // 0x805413d
                                query_extension(str2, v1, pkg_major, pkg_minor, pkg_revision, str3, str, str9);
                                exit(0);
                                // UNREACHABLE
                            }
                            case 9: {
                                // 0x80541af
                                show_details(str2);
                                exit(0);
                                // UNREACHABLE
                            }
                            case 7: {
                                // 0x80541d4
                                show_license(str2);
                                exit(0);
                                // UNREACHABLE
                            }
                            case 6: {
                                // 0x80541f9
                                source_clean(str2);
                                exit(0);
                                // UNREACHABLE
                            }
                        }
                        // 0x8054214
                        if (gisbase == NULL) {
                            // 0x805421e
                            env_val2 = getenv("GISBASE");
                            gisbase = env_val2;
                            if (env_val2 == NULL) {
                                // 0x805423b
                                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                // branch -> 0x805424f
                            }
                        }
                        // 0x805424f
                        if (VERBOSE != 0) {
                            // 0x8054258
                            fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                            // branch -> 0x8054279
                        }
                        // 0x8054279
                        env_val3 = getenv("GRASS_VERSION");
                        grass_version = env_val3;
                        if (env_val3 == NULL) {
                            // 0x805429a
                            sprintf(str4, "%s/etc/VERSIONNUMBER", gisbase);
                            file = fopen(str4, "r");
                            f = (struct _IO_FILE_7 *)file;
                            if (file == NULL) {
                                // 0x80542e6
                                print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                // branch -> 0x8054366
                            } else {
                                // 0x80542fc
                                mem2 = malloc(16);
                                grass_version = mem2;
                                error = fscanf((struct _IO_FILE *)f, "%s", mem2);
                                fclose((struct _IO_FILE *)f);
                                if (error <= 0) {
                                    // 0x8054352
                                    print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                                    // branch -> 0x8054366
                                }
                            }
                            // 0x8054366
                            str5 = grass_version;
                            if (str5 != NULL) {
                                // 0x8054374
                                str6 = strdup(str5);
                                tmp = str6;
                                grass_major = strtok(str6, ".");
                                grass_minor = strtok(NULL, ".");
                                grass_revision = strtok(NULL, ".");
                                major = strtol(grass_major, NULL, 10);
                                minor = strtol(grass_minor, NULL, 10);
                                revision = strtol(grass_revision, NULL, 10);
                                mem3 = malloc(2048);
                                grass_version = mem3;
                                sprintf(mem3, "%i.%i.%i", major, minor, revision);
                                if (VERBOSE != 0) {
                                    // 0x80544a8
                                    fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                    // branch -> 0x80544c9
                                }
                                // 0x80544c9
                                if (major <= 5) {
                                    // 0x80544d3
                                    print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                    // branch -> 0x80544e7
                                }
                            }
                        } else {
                            // 0x8054374
                            str6 = strdup(env_val3);
                            tmp = str6;
                            grass_major = strtok(str6, ".");
                            grass_minor = strtok(NULL, ".");
                            grass_revision = strtok(NULL, ".");
                            major = strtol(grass_major, NULL, 10);
                            minor = strtol(grass_minor, NULL, 10);
                            revision = strtol(grass_revision, NULL, 10);
                            mem3 = malloc(2048);
                            grass_version = mem3;
                            sprintf(mem3, "%i.%i.%i", major, minor, revision);
                            if (VERBOSE != 0) {
                                // 0x80544a8
                                fprintf((struct _IO_FILE *)g15, "GRASS version is %s.\n", grass_version);
                                // branch -> 0x80544c9
                            }
                            // 0x80544c9
                            if (major <= 5) {
                                // 0x80544d3
                                print_error(-11, "extensions only work with GRASS version 6 and above.\n");
                                // branch -> 0x80544e7
                            }
                        }
                        // 0x80544e7
                        sprintf(str7, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
                        switch (action) {
                            case 3: {
                                // 0x8054514
                                v30 = grass_version;
                                g3 = (int32_t)v30;
                                source_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v30);
                                exit(0);
                                // UNREACHABLE
                            }
                            case 10: {
                                // 0x805457b
                                uninstall(str2, str3, gisbase, grass_version);
                                exit(0);
                                // UNREACHABLE
                            }
                            case 8: {
                                // 0x80545c1
                                v31 = grass_version;
                                g3 = (int32_t)v31;
                                test_install(str2, gisbase, str3, pkg_major, pkg_minor, pkg_revision, v31);
                                exit(0);
                                // UNREACHABLE
                            }
                            case 4: {
                                // 0x805462c
                                if (binaries_exist(str2, bins) == 0) {
                                    // 0x80546b2
                                    print_error(-12, "no binaries for system '%s'\n");
                                    // branch -> 0x80546d1
                                    // 0x80546d1
                                    exit(0);
                                    // UNREACHABLE
                                }
                                // 0x805464a
                                v32 = grass_version;
                                g3 = (int32_t)v32;
                                bin_install(str2, gisbase, bins, str3, pkg_major, pkg_minor, pkg_revision, v32);
                                exit(0);
                                // UNREACHABLE
                            }
                        }
                        // 0x80546d1
                        exit(0);
                        // UNREACHABLE
                    }
                    case 11: {
                        // 0x8053beb
                        if (gisbase != NULL) {
                            // 0x8053c26
                            if (VERBOSE != 0) {
                                // 0x8053c2f
                                fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                                // branch -> 0x8053c50
                            }
                            // 0x8053c50
                            restore(gisbase, grass_version);
                            exit(0);
                            // UNREACHABLE
                        }
                        break;
                    }
                    case 12: {
                        // 0x8053c84
                        if (gisbase == NULL) {
                            // 0x8053c8e
                            env_val4 = getenv("GISBASE");
                            gisbase = env_val4;
                            if (env_val4 == NULL) {
                                // 0x8053cab
                                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                                // branch -> 0x8053cbf
                            }
                        }
                        // 0x8053cbf
                        if (VERBOSE != 0) {
                            // 0x8053cc8
                            fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                            // branch -> 0x8053ce9
                        }
                        // 0x8053ce9
                        list_extensions(gisbase);
                        exit(0);
                        // UNREACHABLE
                    }
                }
                // 0x8053bf5
                env_val5 = getenv("GISBASE");
                gisbase = env_val5;
                if (env_val5 == NULL) {
                    // 0x8053c12
                    print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                    // branch -> 0x8053c26
                }
                // 0x8053c26
                if (VERBOSE != 0) {
                    // 0x8053c2f
                    fprintf((struct _IO_FILE *)g15, "Path to GRASS is %s.\n", gisbase);
                    // branch -> 0x8053c50
                }
                // 0x8053c50
                restore(gisbase, grass_version);
                exit(0);
                // UNREACHABLE
            }
            case 1: {
                // 0x8053b1b
                show_help();
                exit(0);
                // UNREACHABLE
            }
            case 2: {
                // 0x8053b36
                show_version();
                exit(0);
                // UNREACHABLE
            }
        }
    }
}

// --------------- Statically Linked Functions ----------------

// int atexit(void(* func)(void));
// int stat(const char * restrict file, struct stat * restrict buf);

// --------------- Dynamically Linked Functions ---------------

// int * __errno_location(void);
// void __stack_chk_fail(void);
// void * calloc(size_t nmemb, size_t size);
// int chdir(const char * path);
// int close(int fd);
// int closedir(DIR * dirp);
// void exit(int status);
// int fclose(FILE * stream);
// int fflush(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputc(int c, FILE * stream);
// int fputs(const char * restrict s, FILE * restrict stream);
// void free(void * ptr);
// int fscanf(FILE * restrict stream, const char * restrict format, ...);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// char * getcwd(char * buf, size_t size);
// char * getenv(const char * name);
// int getopt_long(int argc, char * const * argv, const char * shortopts, const struct option * longopts, int * longind);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int mkstemp(char * template);
// int open(const char * file, int oflag, ...);
// DIR * opendir(const char * name);
// int putenv(char * string);
// int rand(void);
// struct dirent * readdir(DIR * dirp);
// int remove(const char * filename);
// void rewind(FILE * stream);
// int setvbuf(FILE * restrict stream, char * restrict buf, int modes, size_t n);
// int sprintf(char * restrict s, const char * restrict format, ...);
// void srand(unsigned int seed);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// char * strcat(char * restrict dest, const char * restrict src);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strdup(const char * s);
// char * strerror(int errnum);
// size_t strlen(const char * s);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// char * strstr(char * haystack, const char * needle);
// char * strtok(char * restrict s, const char * restrict delim);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// int system(const char * command);
// int vsprintf(char * restrict s, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.5)
// Detected language: C
// Detected functions: 61
// Decompiler release: VERSION
// Decompilation date: DATE
