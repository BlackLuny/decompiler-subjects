// Generated by Rec Studio 4 - build Apr 15 2012

_init()
{// addr = 0x08048A44
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0x1059c)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    return;
}

L08048A50()
{
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    if( *((intOrPtr*)(_t2 + 0x1059c)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

int fputs(char* str, struct _IO_FILE* fp)
{// addr = 0x08048A84
    goto __imp__fputs;
}

int* __errno_location()
{// addr = 0x08048A94
    goto __imp____errno_location;
}

int sprintf(char* dst, char* format)
{// addr = 0x08048AA4
    goto __imp__sprintf;
}

void srand(int __seed)
{// addr = 0x08048AB4
    goto __imp__srand;
}

int open()
{// addr = 0x08048AC4
    goto __imp__open;
}

char* strerror(int __errnum)
{// addr = 0x08048AD4
    goto __imp__strerror;
}

__cxa_atexit()
{// addr = 0x08048AE4
    goto __imp____cxa_atexit;
}

__isoc99_fscanf()
{// addr = 0x08048AF4
    goto __imp____isoc99_fscanf;
}

__xstat()
{// addr = 0x08048B04
    goto __imp____xstat;
}

__gmon_start__()
{// addr = 0x08048B14
    goto __imp____gmon_start__;
}

void rewind(struct _IO_FILE* fp)
{// addr = 0x08048B24
    goto __imp__rewind;
}

__isoc99_sscanf()
{// addr = 0x08048B34
    goto __imp____isoc99_sscanf;
}

int vsprintf(char* string, char* format, _G_va_list vals)
{// addr = 0x08048B44
    goto __imp__vsprintf;
}

char* strchr(char* __s, int __c)
{// addr = 0x08048B54
    goto __imp__strchr;
}

char* getenv(char* __name)
{// addr = 0x08048B64
    goto __imp__getenv;
}

void* calloc(int __nmemb, int __size)
{// addr = 0x08048B74
    goto __imp__calloc;
}

int system(char* __command)
{// addr = 0x08048B84
    goto __imp__system;
}

char* strncpy(char* __dest, char* __src, int __n)
{// addr = 0x08048B94
    goto __imp__strncpy;
}

char* fgets(char* dst, int sz, struct _IO_FILE* fp)
{// addr = 0x08048BA4
    goto __imp__fgets;
}

__libc_start_main()
{// addr = 0x08048BB4
    goto __imp____libc_start_main;
}

char* strrchr(char* __s, int __c)
{// addr = 0x08048BC4
    goto __imp__strrchr;
}

readdir()
{// addr = 0x08048BD4
    goto __imp__readdir;
}

long strtol(char* __nptr, char** __endptr, int __base)
{// addr = 0x08048BE4
    goto __imp__strtol;
}

void free(void* __ptr)
{// addr = 0x08048BF4
    goto __imp__free;
}

int fflush(struct _IO_FILE* fp)
{// addr = 0x08048C04
    goto __imp__fflush;
}

int mkstemp(__caddr_t __template)
{// addr = 0x08048C14
    goto __imp__mkstemp;
}

opendir()
{// addr = 0x08048C24
    goto __imp__opendir;
}

int getopt_long(int ___argc, __builtin_va_list* ___argv, char* __shortopts, struct option* __longopts, int* __longind)
{// addr = 0x08048C34
    goto __imp__getopt_long;
}

int fclose(struct _IO_FILE* fp)
{// addr = 0x08048C44
    goto __imp__fclose;
}

void* memcpy(void* __dest, void* __src, int __n)
{// addr = 0x08048C54
    goto __imp__memcpy;
}

int strlen(char* __s)
{// addr = 0x08048C64
    goto __imp__strlen;
}

struct _IO_FILE* fopen(char* name, char* mode)
{// addr = 0x08048C74
    goto __imp__fopen;
}

char* strcpy(char* __dest, char* __src)
{// addr = 0x08048C84
    goto __imp__strcpy;
}

int chdir(char* __path)
{// addr = 0x08048C94
    goto __imp__chdir;
}

int putenv(char* __string)
{// addr = 0x08048CA4
    goto __imp__putenv;
}

closedir()
{// addr = 0x08048CB4
    goto __imp__closedir;
}

int close(int __fd)
{// addr = 0x08048CC4
    goto __imp__close;
}

int fwrite(void* src, int sz, int nitems, struct _IO_FILE* fp)
{// addr = 0x08048CD4
    goto __imp__fwrite;
}

int fprintf(struct _IO_FILE* fp, char* format)
{// addr = 0x08048CE4
    goto __imp__fprintf;
}

char* strstr(char* __haystack, char* __needle)
{// addr = 0x08048CF4
    goto __imp__strstr;
}

int setvbuf(struct _IO_FILE* fp, char* bufptr, int mode, int size)
{// addr = 0x08048D04
    goto __imp__setvbuf;
}

int remove(char* name)
{// addr = 0x08048D14
    goto __imp__remove;
}

void* malloc(int __size)
{// addr = 0x08048D24
    goto __imp__malloc;
}

__stack_chk_fail()
{// addr = 0x08048D34
    goto __imp____stack_chk_fail;
}

int fputc(int ch, struct _IO_FILE* fp)
{// addr = 0x08048D44
    goto __imp__fputc;
}

char* strtok(char* __s, char* __delim)
{// addr = 0x08048D54
    goto __imp__strtok;
}

char* strcat(char* __dest, char* __src)
{// addr = 0x08048D64
    goto __imp__strcat;
}

__caddr_t getcwd(__caddr_t __buf, int __size)
{// addr = 0x08048D74
    goto __imp__getcwd;
}

int rand()
{// addr = 0x08048D84
    goto __imp__rand;
}

char* strdup(char* __s)
{// addr = 0x08048D94
    goto __imp__strdup;
}

int strcmp(char* __s1, char* __s2)
{// addr = 0x08048DA4
    goto __imp__strcmp;
}

void exit(int __status)
{// addr = 0x08048DB4
    goto __imp__exit;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x08048DD0
    _unknown_ __ebx;                       // r1
    signed int _t5;                        // _t5
    _unknown_ _t6;                         // _t6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __edx = __edx;
    _t4 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & 240;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(_t10);
    _push(main);
    __libc_start_main();
    asm("hlt ");
    0;
    0;
    _push(0);
    _push(_t6);
    __esp = __esp - 4;
    if(completed.7065 == 0) {
        _t4 = dtor_idx.7067;
        _t6 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t4 < _t6) {
            while(1) {
                _t5 = _t4 + 1;
                dtor_idx.7067 = _t5;
                 *((intOrPtr*)(_t5 * 4 +  &__DTOR_LIST__))();
                _t4 = dtor_idx.7067;
                if(_t4 >= _t6) {
                    break;
                }
            }
        }
        completed.7065 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
    return;
}

__do_global_dtors_aux(
    _unknown_ __esi                        // r5
)
{// addr = 0x08048E00
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4
    signed int _t5;                        // _t5
    signed int _t6;                        // _t6
    _unknown_ _t10;                        // _t10
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    if(completed.7065 == 0) {
        _t5 = dtor_idx.7067;
        _t10 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t5 >= _t10) {
L4:
            completed.7065 = 1;
            return;
        }
        while(1) {
            _t6 = _t5 + 1;
            dtor_idx.7067 = _t6;
             *((intOrPtr*)(_t6 * 4 +  &__DTOR_LIST__))();
            _t5 = dtor_idx.7067;
            if(_t5 >= _t10) {
                break;
            }
        }
        goto L4;
    }
    return;
}

frame_dummy()
{// addr = 0x08048E60
    _unknown_ __ebp;                       // r6

    __eax = __JCR_LIST__;
    if(__JCR_LIST__ != 0) {
        __eax = 0;
        if(__eax == 0) {
        } else {
             *__esp =  &__JCR_LIST__;
             *__eax();
            return;
        }
    }
    return;
}

exit_env()
{// addr = 0x08048E84  --  defined in 'at_exit_funcs.c' at line 29
    _unknown_ __ebp;                       // r6

    return;
}

exit_tmp()
{// addr = 0x08048E89  --  defined in 'at_exit_funcs.c' at line 62
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    DIR* dir;              // _cfa_fffff7e8
    _unknown_ _v2080;                      // _cfa_fffff7e0
    char[2047]* _v2084;                    // _cfa_fffff7dc
    char[2047]* _v2088;                    // _cfa_fffff7d8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22
    signed int _t27;                       // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t31;                        // _t31
    _unknown_ _t37;                        // _t37
    DIR* _t39;             // _t39
    _unknown_ _t43;                        // _t43

    _v16 =  *gs:0x14];
    __eflags = TMPDIR & 0xff;
    if(__eflags != 0) {
        __eflags = TMPCLEAN;
        if(__eflags == 0) {
            chdir( &CWD);
            _v2084 =  &TMPDIR;
            sprintf( &tmp, "rm -rf %s/*");
            __eflags = VERBOSE;
            if(VERBOSE != 0) {
                fwrite("Removing temporary extension files...", 1, 37, __imp__stdout);
            }
            error = system( &tmp);
            _v2084 =  &TMPDIR;
            sprintf( &tmp, "rmdir %s");
            _t39 = system( &tmp);
            error = _t39;
             *__esp =  &TMPDIR;
            opendir();
            dir = _t39;
            __eflags = dir;
            if(dir != 0) {
                _v2088 =  &TMPDIR;
                print_warning("could not remove temporary directory %s.\nPlease remove manually.\n");
            }
            __eflags = VERBOSE;
            if(__eflags != 0) {
                print_done();
            }
            TMPCLEAN = 1;
        }
    } else {
        TMPCLEAN = 1;
    }
    _t27 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t27;
    } else {
        __stack_chk_fail();
        return _t27;
    }
}

exit_db()
{// addr = 0x08048FC2  --  defined in 'at_exit_funcs.c' at line 106
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    _unknown_ _v2080;                      // _cfa_fffff7e0
    char[2047]* _v2084;                    // _cfa_fffff7dc
    char[2047]* _v2088;                    // _cfa_fffff7d8
    _unknown_ __ebp;                       // r6
    _unknown_ _t88;                        // _t88
    signed int _t91;                       // _t91
    _unknown_ _t92;                        // _t92
    _unknown_ _t116;                       // _t116
    _unknown_ _t121;                       // _t121
    _unknown_ _t126;                       // _t126
    _unknown_ _t131;                       // _t131
    _unknown_ _t136;                       // _t136
    _unknown_ _t141;                       // _t141
    _unknown_ _t146;                       // _t146
    _unknown_ _t151;                       // _t151
    _unknown_ _t156;                       // _t156
    _unknown_ _t161;                       // _t161
    int _t183;                             // _t183

    _v16 =  *gs:0x14];
    if(TMPDBCLEAN != 0) {
L34:
        _t91 = _v16 ^  *gs:0x14];
        if(_t183 == 0) {
            return _t91;
        }
    } else {
        chdir( &CWD);
        if(VERBOSE != 0) {
            fwrite("Removing temporary registration files...", 1, 40, __imp__stdout);
        }
        if((TMPDB & 0xff) != 0) {
            _v2084 =  &TMPDB;
            sprintf( &tmp, "rm -rf %s");
            error = system( &tmp);
            if(error != 0) {
                _v2088 =  &TMPDB;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if((TMP_GISMAN & 0xff) != 0) {
            _v2084 =  &TMP_GISMAN;
            sprintf( &tmp, "rm -f %s");
            error = system( &tmp);
            if(error != 0) {
                _v2088 =  &TMP_GISMAN;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if((TMP_DESCR & 0xff) != 0) {
            _v2084 =  &TMP_DESCR;
            sprintf( &tmp, "rm -f %s");
            error = system( &tmp);
            if(error != 0) {
                _v2088 =  &TMP_DESCR;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if((TMP_INFO & 0xff) != 0) {
            _v2084 =  &TMP_INFO;
            sprintf( &tmp, "rm -f %s");
            error = system( &tmp);
            if(error != 0) {
                _v2088 =  &TMP_INFO;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if((TMP_DEPS & 0xff) != 0) {
            _v2084 =  &TMP_DEPS;
            sprintf( &tmp, "rm -f %s");
            error = system( &tmp);
            if(error != 0) {
                _v2088 =  &TMP_INFO;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if((TMP_BUGS & 0xff) != 0) {
            _v2084 =  &TMP_BUGS;
            sprintf( &tmp, "rm -f %s");
            error = system( &tmp);
            if(error != 0) {
                _v2088 =  &TMP_INFO;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if((TMP_AUTHORS & 0xff) != 0) {
            _v2084 =  &TMP_AUTHORS;
            sprintf( &tmp, "rm -f %s");
            error = system( &tmp);
            if(error != 0) {
                _v2088 =  &TMP_INFO;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if((TMP_HTML & 0xff) != 0) {
            _v2084 =  &TMP_HTML;
            sprintf( &tmp, "rm -f %s");
            error = system( &tmp);
            if(error != 0) {
                _v2088 =  &TMP_HTML;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        if(VERBOSE == 0 && (TMP_NULL & 0xff) != 0) {
            _v2084 =  &TMP_NULL;
            sprintf( &tmp, "rm -f %s");
            error = system( &tmp);
            if(error != 0) {
                _v2088 =  &TMP_NULL;
                print_warning("could not remove temporary file %s.\nPlease remove manually.\n");
            }
        }
        _t183 = VERBOSE;
        if(_t183 != 0) {
            print_done();
        }
        TMPDBCLEAN = 1;
        goto L34;
    }
    __stack_chk_fail();
    return _t91;
}

exit_msg()
{// addr = 0x08049390  --  defined in 'at_exit_funcs.c' at line 221
    _unknown_ _v16;                        // _cfa_fffffff0
    int _v20;                              // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t12;                        // _t12
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17

    if(ERROR < 0) {
        _v20 = ERROR;
        fprintf(__imp__stdout, "Program exited with an error (code %i). Operation aborted.\n");
        return;
    }
    if(WARNINGS == 1) {
        fwrite("Job done but there was one warning. Please check.\n", 1, 50, __imp__stdout);
    }
    if(WARNINGS <= 1) {
    } else {
        _v20 = WARNINGS;
        fprintf(__imp__stdout, "Job done but there were %i warnings. Please check.\n");
        return;
    }
    goto L6;
L7:
L6:
    return;
    goto L7;
}

print_error(int err_code, char* msg)
{// addr = 0x08049420  --  defined in 'error.c' at line 32
    signed int _v16;                       // _cfa_fffffff0
    char[2047] buffer;                     // _cfa_fffff7f0
    va_list ap;        // _cfa_fffff7ec
    char* _v2080;                          // _cfa_fffff7e0
    char _v2100;                           // _cfa_fffff7cc
    char* _v2104;                          // _cfa_fffff7c8
    signed int _v2124;                     // _cfa_fffff7b4
    char _v4172;                           // _cfa_ffffefb4
    char* _v4176;                          // _cfa_ffffefb0
    char* _v4188;                          // _cfa_ffffefa4
    char* _v4208;                          // _cfa_ffffef90
    _unknown_ _v4212;                      // _cfa_ffffef8c
    _unknown_ __ebp;                       // r6
    _unknown_ _t32;                        // _t32
    _unknown_ _t36;                        // _t36
    _unknown_ _t38;                        // _t38
    _unknown_ _t41;                        // _t41
    _unknown_ _t44;                        // _t44
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    signed int _t54;                       // _t54
    _unknown_ _t58;                        // _t58
    _unknown_ _t60;                        // _t60
    _unknown_ _t61;                        // _t61
    _unknown_ _t62;                        // _t62

    __eflags = __eflags;
    _v2080 = _a8;
    _v16 =  *gs:0x14];
    ap =  &_a12;
    vsprintf( &buffer, _v2080, ap);
    _v2100 =  &buffer;
    fprintf(__imp__stderr, 134564288);
    ERROR = err_code;
    exit(err_code);
    _push(_t61);
    __esp = __esp - 2104;
    _v4188 = _v2104;
    _v2124 =  *gs:0x14];
    _v4176 =  &_v2100;
    vsprintf( &_v4172, _v4188, _v4176);
    _v4208 =  &_v4172;
    fprintf(__imp__stderr, 134564310);
    WARNINGS = WARNINGS + 1;
    _t54 = _v2124 ^  *gs:0x14];
    if(__eflags != 0) {
        __stack_chk_fail();
        return _t54;
    }
    return _t54;
}

print_warning(char* msg)
{// addr = 0x0804949B  --  defined in 'error.c' at line 52
    signed int _v16;                       // _cfa_fffffff0
    char[2047] buffer;                     // _cfa_fffff7f0
    va_list ap;        // _cfa_fffff7ec
    char* _v2080;                          // _cfa_fffff7e0
    char[2047]* _v2100;                    // _cfa_fffff7cc
    _unknown_ _v2104;                      // _cfa_fffff7c8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    signed int _t27;                       // _t27
    _unknown_ _t29;                        // _t29

    __eflags = __eflags;
    _v2080 = _a4;
    _v16 =  *gs:0x14];
    ap =  &_a8;
    vsprintf( &buffer, _v2080, ap);
    _v2100 =  &buffer;
    fprintf(__imp__stderr, 134564310);
    WARNINGS = WARNINGS + 1;
    _t27 = _v16 ^  *gs:0x14];
    if(__eflags != 0) {
        __stack_chk_fail();
        return _t27;
    }
    return _t27;
}

print_done()
{// addr = 0x08049523  --  defined in 'error.c' at line 70
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6

    fwrite(134564334, 1, 17, __imp__stdout);
    return;
}

char* basename(char* path)
{// addr = 0x08049554  --  defined in 'tools.c' at line 33
    char* copy;                            // _cfa_fffffff0
    char* element;                         // _cfa_ffffffec
    char* backup;                          // _cfa_ffffffe8
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29
    _unknown_ _t34;                        // _t34
    _unknown_ _t38;                        // _t38
    _unknown_ _t44;                        // _t44
    _unknown_ _t45;                        // _t45
    _unknown_ _t47;                        // _t47

    copy = strdup(path);
    backup = 0;
    element = strtok(copy, 134564352);
    if(element != 0) {
        backup = strdup(element);
L11:
        while(element != 0) {
            goto L5;
        }
        if(copy != 0) {
            free(copy);
        }
        return backup;
    } else {
        if(copy != 0) {
            free(copy);
        }
        return 0;
    }
L5:
    element = strtok(0, 134564352);
    if(backup != 0 && element != 0) {
        free(backup);
    }
    if(element != 0 && ( *element & 0xff) != 0) {
        backup = strdup(element);
    }
    goto L11;
}

mkdir_s(char* pathname, char* mode)
{// addr = 0x0804961D  --  defined in 'tools.c' at line 73
    signed int _v16;                       // _cfa_fffffff0
    char[4999] tmp;                        // _cfa_ffffec68
    intOrPtr _v5024;                       // _cfa_ffffec60
    intOrPtr _v5028;                       // _cfa_ffffec5c
    intOrPtr _v5040;                       // _cfa_ffffec50
    intOrPtr _v5044;                       // _cfa_ffffec4c
    _unknown_ _v5048;                      // _cfa_ffffec48
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t20;                        // _t20
    _unknown_ _t22;                        // _t22
    signed int _t24;                       // _t24

    __eflags = __eflags;
    _v5024 = _a4;
    _v5028 = _a8;
    _v16 =  *gs:0x14];
    _v5040 = _v5028;
    _v5044 = _v5024;
    sprintf( &tmp, "mkdir %s --mode=%s -p");
    system( &tmp);
    _t24 = _v16 ^  *gs:0x14];
    if(__eflags != 0) {
        __stack_chk_fail();
        return _t24;
    }
    return _t24;
}

int chop(char* string)
{// addr = 0x0804968F  --  defined in 'tools.c' at line 86
    int i;                                 // _cfa_fffffff0
    int chopped;                           // _cfa_ffffffec
    int stop;                              // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6

    stop = 0;
    chopped = 0;
    i = strlen(string) - 1;
    while(i >= 0) {
        stop = 1;
        if((string[i] & 0xff) == 10 || (string[i] & 0xff) == 9 || (string[i] & 0xff) == 32 || (string[i] & 0xff) == 12 || (string[i] & 0xff) == 13) {
            chopped = chopped + 1;
            stop = 0;
        }
        if(stop == 1) {
        } else {
            i = i - 1;
            continue;
        }
        break;
    }
     *(strlen(string) - chopped + string) = 0;
    return chopped;
}

int insert_str(char* str, int pos, char** strarr)
{// addr = 0x08049737  --  defined in 'tools.c' at line 125
    intOrPtr _v16;                         // _cfa_fffffff0
    char[2047] save;                       // _cfa_fffff7f0
    char[2047] insert;                     // _cfa_ffffeff0
    char[2047] last;                       // _cfa_ffffe7f0
    int n;                                 // _cfa_ffffe7ec
    int j;                                 // _cfa_ffffe7e8
    int len;                               // _cfa_ffffe7e4
    char* _v6176;                          // _cfa_ffffe7e0
    intOrPtr _v6180;                       // _cfa_ffffe7dc
    int _v6196;                            // _cfa_ffffe7cc
    _unknown_ _v6200;                      // _cfa_ffffe7c8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t90;                        // _t90
    _unknown_ _t103;                       // _t103
    _unknown_ _t109;                       // _t109
    _unknown_ _t114;                       // _t114
    _unknown_ _t125;                       // _t125
    _unknown_ _t135;                       // _t135
    _unknown_ _t141;                       // _t141
    _unknown_ _t155;                       // _t155
    _unknown_ _t158;                       // _t158
    _unknown_ _t169;                       // _t169
    int _t174;                             // _t174
    _unknown_ _t186;                       // _t186
    _unknown_ _t204;                       // _t204
    _unknown_ _t209;                       // _t209

    _v6176 = _a4;
    _v6180 = _a12;
    _v16 =  *gs:0x14];
    n = 0;
    while( *((n << 2) + _v6180) != 0) {
        n = n + 1;
    }
    if(pos >= 0 || pos > n) {
        _v6196 = pos;
        print_error(-21, "insert: invalid line number %i.\n");
    }
    _t209 = pos - n;
    if(_t209 != 0) {
        strcpy( &last,  *((n - 1 << 2) + _v6180));
        strcpy( &insert,  *((pos << 2) + _v6180));
        free( *((pos << 2) + _v6180));
         *((pos << 2) + _v6180) = malloc(strlen(_v6176) + 1);
        strcpy( *((pos << 2) + _v6180), _v6176);
        j = pos;
L10:
        while(n - 1 > j) {
            goto L9;
        }
         *((n << 2) + _v6180) = malloc(strlen( &last) + 1);
        strcpy( *((n << 2) + _v6180),  &last);
        n = n + 2;
         *((n - 1 << 2) + _v6180) = 0;
        _t174 = n;
        goto L12;
    } else {
        len = strlen(_v6176) + 1;
         *((n << 2) + _v6180) = malloc(len);
        strcpy( *((n << 2) + _v6180), _v6176);
        n = n + 2;
         *((n - 1 << 2) + _v6180) = 0;
        _t174 = n;
L12:
        if(_t209 == 0) {
            return _t174;
        }
        __stack_chk_fail();
        return _t174;
    }
L9:
    strcpy( &save,  *((j + 1 << 2) + _v6180));
    free( *((j + 1 << 2) + _v6180));
    len = strlen( &insert) + 1;
     *((j + 1 << 2) + _v6180) = malloc(len);
    strcpy( *((j + 1 << 2) + _v6180),  &insert);
    strcpy( &insert,  &save);
    j = j + 1;
    goto L10;
}

int delete_str(int pos, char** strarr)
{// addr = 0x08049A5E  --  defined in 'tools.c' at line 190
    int i;                                 // _cfa_fffffff0
    int _v36;                              // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t50;                        // _t50
    _unknown_ _t75;                        // _t75

    i = 0;
    while(strarr[i] != 0) {
        i = i + 1;
    }
    if(pos >= 0 || pos > i) {
        _v36 = pos;
        print_error(-21, "delete: invalid line number %i.\n");
    }
    i = pos;
    while(strarr[i] != 0) {
        free(strarr[i]);
        if(strarr[i + 1] != 0) {
            strarr[i] = malloc(strlen(strarr[i + 1]) + 1);
            strcpy(strarr[i], strarr[i + 1]);
        }
        i = i + 1;
    }
    i = i - 1;
    strarr[i] = 0;
    return i;
}

int find_pos(char* str, char** strarr, int start)
{// addr = 0x08049B5F  --  defined in 'tools.c' at line 230
    int i;                                 // _cfa_fffffff0
    int j;                                 // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t24;                        // _t24
    _unknown_ _t33;                        // _t33

    i = 0;
    while(strarr[i] != 0) {
        i = i + 1;
    }
    if(start >= 0 || start > i) {
        exit(-21);
    }
    j = start;
    while(j < i) {
        if(strstr(strarr[j], str) == 0) {
            j = j + 1;
            continue;
        }
        return j;
    }
    return -1;
}

dump_str(FILE* f, char** strarr)
{// addr = 0x08049BD9  --  defined in 'tools.c' at line 258
    int i;                                 // _cfa_fffffff0
    char* _v32;                            // _cfa_ffffffe0
    int _v36;                              // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t22;                        // _t22

    i = 0;
    while(strarr[i] != 0) {
        _v32 = strarr[i];
        _v36 = i;
        fprintf(f, "%i: %s");
        i = i + 1;
    }
    return;
}

get_package_name(char* path, char* name)
{// addr = 0x08049C27  --  defined in 'tools.c' at line 273
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] tmp;                        // _cfa_ffffeff0
    FILE* f;              // _cfa_ffffefec
    intOrPtr _v4128;                       // _cfa_ffffefe0
    char* _v4132;                          // _cfa_ffffefdc
    char* _v4144;                          // _cfa_ffffefd0
    intOrPtr _v4148;                       // _cfa_ffffefcc
    _unknown_ _v4152;                      // _cfa_ffffefc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t31;                        // _t31
    _unknown_ _t34;                        // _t34
    char* _t39;                            // _t39
    _unknown_ _t41;                        // _t41
    _unknown_ _t44;                        // _t44
    _unknown_ _t46;                        // _t46
    signed int _t48;                       // _t48
    _unknown_ _t50;                        // _t50

    _v4128 = _a4;
    _v4132 = _a8;
    _v16 =  *gs:0x14];
    _v4144 = "name";
    _v4148 = _v4128;
    sprintf( &file, "%s/%s");
    f = fopen( &file, "r");
    __eflags = f;
    if(f != 0) {
        _t39 = nc_fgets_nb( &tmp, 2048, f);
        __eflags = _t39;
        if(_t39 != 0) {
            chop( &tmp);
            strcpy(_v4132,  &tmp);
        } else {
            fclose(f);
            print_error(-6, "invalid or missing extension name.\n");
        }
    } else {
        print_error(-6, "'name' file not readable.\n");
    }
    fclose(f);
    _t48 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t48;
    } else {
        __stack_chk_fail();
        return _t48;
    }
}

char* nc_fgets(char* s, int size, FILE* stream)
{// addr = 0x08049D41  --  defined in 'tools.c' at line 307
    char* hashmark;                        // _cfa_fffffff0
    char* tmp;                             // _cfa_ffffffec
    char* _v36;                            // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t41;                        // _t41
    _unknown_ _t47;                        // _t47
    _unknown_ _t49;                        // _t49
    _unknown_ _t54;                        // _t54

    if(fgets(s, size, stream) != 0) {
        hashmark = strchr(s, 35);
        if(hashmark == 0) {
L6:
            return s;
        }
        goto L3;
        return __eax;
    }
    return 0;
L3:
    if(s != hashmark) {
        tmp = malloc(2048);
        strcpy(tmp, s);
        tmp = strtok(tmp, "#");
        _v36 = tmp;
        sprintf(s, "%s\n");
        free(tmp);
        goto L6;
    }
    return nc_fgets(s, size, stream);
}

char* nc_fgets_html(char* s, int size, FILE* stream)
{// addr = 0x08049E14  --  defined in 'tools.c' at line 339
    char* hashmark;                        // _cfa_fffffff0
    char* tmp;                             // _cfa_ffffffec
    char* tag;                             // _cfa_ffffffe8
    char* tag_2;                           // _cfa_ffffffe4
    char* tag_insert;                      // _cfa_ffffffe0
    char* tag_content;                     // _cfa_ffffffdc
    char* pos;                             // _cfa_ffffffd8
    char* insert;                          // _cfa_ffffffd4
    int space;                             // _cfa_ffffffd0
    char* _v68;                            // _cfa_ffffffbc
    _unknown_ _v72;                        // _cfa_ffffffb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t242;                       // _t242
    _unknown_ _t244;                       // _t244
    _unknown_ _t246;                       // _t246
    _unknown_ _t254;                       // _t254
    _unknown_ _t260;                       // _t260
    _unknown_ _t262;                       // _t262
    _unknown_ _t267;                       // _t267

    if(fgets(s, size, stream) == 0) {
        return 0;
    }
    tmp = malloc(strlen(s) + 1);
    tag_content = malloc(strlen(s) + 1);
    insert = tmp;
    pos = s;
    while(( *pos & 0xff) != 0) {
        if(( *pos & 0xff) != 60) {
L33:
            if(( *pos & 0xff) != 62) {
                 *insert =  *pos & 0xff;
                insert =  &(insert[1]);
            }
            pos =  &(pos[1]);
            continue;
        } else {
            tag = pos;
            tag_insert = tag_content;
            pos = pos - 1;
            if(pos >= s) {
                if(( *pos & 0xff) != 32) {
                    space = 0;
                } else {
                    space = 1;
                }
            }
            while(( *tag & 0xff) != 0) {
                 *tag_insert =  *tag & 0xff;
                 *tag_insert = ( *tag_insert & 255) + 1 & 255;
                if(( *tag & 0xff) != 62) {
                    tag =  &(tag[1]);
                    continue;
                }
                 *tag_insert = 0;
                tag_2 = tag;
                tag_2 =  &(tag_2[1]);
                if(( *tag_2 & 0xff) != 10) {
                    if(strstr(tag_content, "<br>") != 0 && insert > tmp) {
                         *insert = 10;
                         *insert = ( *insert & 255) + 1 & 255;
                    }
                    if(strstr(tag_content, "<BR>") != 0 && insert > tmp) {
                         *insert = 10;
                         *insert = ( *insert & 255) + 1 & 255;
                    }
                    if(strstr(tag_content, "<p>") != 0) {
                        if(insert > tmp) {
                             *insert = 10;
                             *insert = ( *insert & 255) + 1 & 255;
                        }
                         *insert = 10;
                         *insert = ( *insert & 255) + 1 & 255;
                    }
                    if(strstr(tag_content, "<P>") != 0) {
                        if(insert > tmp) {
                             *insert = 10;
                             *insert = ( *insert & 255) + 1 & 255;
                        }
                         *insert = 10;
                         *insert = ( *insert & 255) + 1 & 255;
                    }
                }
                pos = tag;
                if(( *pos & 0xff) == 32) {
                    if(space == 1) {
                        pos =  &(pos[1]);
                        space = 0;
                    }
                }
                goto L33;
            }
            goto L33;
        }
    }
     *insert = 0;
    strcpy(s, tmp);
    free(tmp);
    free(tag_content);
    hashmark = strchr(s, 35);
    if(hashmark == 0) {
L41:
        return s;
    }
    if(s != hashmark) {
        tmp = malloc(2048);
        strcpy(tmp, s);
        tmp = strtok(tmp, "#");
        _v68 = tmp;
        sprintf(s, "%s\n");
        free(tmp);
        goto L41;
    }
    return nc_fgets_html(s, size, stream);
}

int is_text(char* s)
{// addr = 0x0804A146  --  defined in 'tools.c' at line 474
    int i;                                 // _cfa_fffffff0
    int nonws;                             // _cfa_ffffffec
    _unknown_ __ebp;                       // r6

    nonws = 0;
    i = strlen(s) - 1;
    while(i >= 0) {
        if((s[i] & 0xff) == 32 || (s[i] & 0xff) == 9) {
L6:
            nonws = 0;
            i = i - 1;
            continue;
        } else {
            if((s[i] & 0xff) == 10 || (s[i] & 0xff) == 12 || (s[i] & 0xff) == 13) {
                goto L6;
            } else {
                nonws = 1;
            }
            break;
        }
    }
    return nonws;
}

char* nc_fgets_nb(char* s, int size, FILE* stream)
{// addr = 0x0804A1C8  --  defined in 'tools.c' at line 500
    char* hashmark;                        // _cfa_fffffff0
    char* tmp;                             // _cfa_ffffffec
    char* _v36;                            // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t49;                        // _t49
    _unknown_ _t55;                        // _t55
    _unknown_ _t57;                        // _t57
    _unknown_ _t66;                        // _t66

    if(fgets(s, size, stream) != 0) {
        if(is_text(s) != 0) {
            hashmark = strchr(s, 35);
            if(hashmark == 0) {
L8:
                return s;
            }
            goto L5;
            return __eax;
        }
        goto L3;
L5:
        if(s != hashmark) {
            tmp = malloc(2048);
            strcpy(tmp, s);
            tmp = strtok(tmp, "#");
            _v36 = tmp;
            sprintf(s, "%s\n");
            free(tmp);
            goto L8;
        }
        return nc_fgets_nb(s, size, stream);
    }
    return 0;
L3:
    return nc_fgets_nb(s, size, stream);
}

dump_ascii(char* file, char* heading)
{// addr = 0x0804A2C8  --  defined in 'tools.c' at line 539
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    FILE* f;              // _cfa_fffff7ec
    char* _v2080;                          // _cfa_fffff7e0
    char[2047]* _v2084;                    // _cfa_fffff7dc
    _unknown_ _v2096;                      // _cfa_fffff7d0
    FILE* _v2100;         // _cfa_fffff7cc
    intOrPtr _v2104;                       // _cfa_fffff7c8
    _unknown_ __ebp;                       // r6
    _unknown_ _t29;                        // _t29
    _unknown_ _t31;                        // _t31
    _unknown_ _t36;                        // _t36
    signed int _t38;                       // _t38

    _v2080 = _a4;
    _v2084 = _a8;
    _v16 =  *gs:0x14];
    _v2100 = _v2084;
    fprintf(__imp__stdout, "%s\n");
    f = fopen(_v2080, "r");
    __eflags = f;
    if(f != 0) {
        while(1) {
            __eax = f;
            _v2100 = f;
            _v2104 = 2048;
            __eax =  &tmp;
             *__esp =  &tmp;
            __eax = nc_fgets_html();
            __eflags = __eax;
            if(__eax == 0) {
                break;
            }
            __eax = __imp__stdout;
            _v2100 =  &tmp;
            __eax = fprintf(__imp__stdout, "  %s");
        }
        __imp__stdout = fputc(10, __imp__stdout);
        f = fclose(f);
L6:
        _t38 = _v16 ^  *gs:0x14];
        if(__eflags != 0) {
            __stack_chk_fail();
            return _t38;
        }
        return _t38;
    }
    fwrite("  No information available.\n", 1, 28, __imp__stdout);
    goto L6;
}

dump_plain(char* file, char* tmpfile)
{// addr = 0x0804A3DB  --  defined in 'tools.c' at line 563
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    FILE* f_in;           // _cfa_fffff7ec
    FILE* f_out;          // _cfa_fffff7e8
    char* _v2080;                          // _cfa_fffff7e0
    char* _v2084;                          // _cfa_fffff7dc
    char* _v2096;                          // _cfa_fffff7d0
    char* _v2100;                          // _cfa_fffff7cc
    _unknown_ _v2104;                      // _cfa_fffff7c8
    _unknown_ __ebp;                       // r6
    _unknown_ _t34;                        // _t34
    _unknown_ _t37;                        // _t37
    _unknown_ _t39;                        // _t39
    _unknown_ _t42;                        // _t42
    _unknown_ _t50;                        // _t50
    _unknown_ _t52;                        // _t52
    _unknown_ _t54;                        // _t54
    signed int _t56;                       // _t56
    char* _t64;                            // _t64

    _v2080 = _a4;
    _v2084 = _a8;
    _v16 =  *gs:0x14];
    memcpy(_v2084, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(_v2084);
    f_out = fopen(_v2084, "w+");
    if(f_out == 0) {
        _v2096 = strerror( *(__errno_location()));
        _v2100 = _v2084;
        print_error(-23, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
    }
    atexit(exit_db);
    f_in = fopen(_v2080, "r");
    while(1) {
        _t64 = nc_fgets( &tmp, 2048, f_in);
        if(_t64 == 0) {
            break;
        }
        fprintf(f_out,  &tmp);
    }
    fclose(f_in);
    fclose(f_out);
    _t56 = _v16 ^  *gs:0x14];
    if(_t64 != 0) {
        __stack_chk_fail();
        return _t56;
    }
    return _t56;
}

dump_html(char* file, char* tmpfile)
{// addr = 0x0804A51B  --  defined in 'tools.c' at line 597
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] line;                       // _cfa_ffffeff0
    FILE* f_in;           // _cfa_ffffefec
    FILE* f_out;          // _cfa_ffffefe8
    int fd;                                // _cfa_ffffefe4
    char* _v4128;                          // _cfa_ffffefe0
    char* _v4132;                          // _cfa_ffffefdc
    char* _v4144;                          // _cfa_ffffefd0
    char* _v4148;                          // _cfa_ffffefcc
    _unknown_ _v4152;                      // _cfa_ffffefc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t45;                        // _t45
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    _unknown_ _t53;                        // _t53
    _unknown_ _t60;                        // _t60
    _unknown_ _t65;                        // _t65
    _unknown_ _t68;                        // _t68
    _unknown_ _t70;                        // _t70
    _unknown_ _t72;                        // _t72
    _unknown_ _t74;                        // _t74
    _unknown_ _t76;                        // _t76
    signed int _t78;                       // _t78
    char* _t88;                            // _t88

    _v4128 = _a4;
    _v4132 = _a8;
    _v16 =  *gs:0x14];
    memcpy(_v4132, "/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(_v4132);
    f_out = fopen(_v4132, "w+");
    if(f_out == 0) {
        _v4144 = strerror( *(__errno_location()));
        _v4148 = _v4132;
        print_error(-23, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
    }
    atexit(exit_db);
    f_in = fopen(_v4128, "r");
    while(1) {
        _t88 = nc_fgets( &line, 2048, f_in);
        if(_t88 == 0) {
            break;
        }
        chop( &line);
        if(is_text( &line) != 0) {
            _v4148 =  &line;
            sprintf( &tmp, "%s <br>\n");
            fprintf(f_out,  &tmp);
        } else {
            fwrite("<p>\n", 1, 4, f_out);
        }
    }
    fclose(f_in);
    fclose(f_out);
    close(fd);
    _t78 = _v16 ^  *gs:0x14];
    if(_t88 == 0) {
        return _t78;
    }
    __stack_chk_fail();
    return _t78;
}

list_binaries(char* package)
{// addr = 0x0804A6DA  --  defined in 'tools.c' at line 642
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    DIR* dir;              // _cfa_fffff7ec
    struct dirent* dir_entry;   // _cfa_fffff7e8
    int n_dirs;                            // _cfa_fffff7e4
    struct stat buf;      // _cfa_fffff78c
    DIR* _v2176;           // _cfa_fffff780
    char** _v2192;                         // _cfa_fffff770
    char** _v2196;                         // _cfa_fffff76c
    _unknown_ _v2200;                      // _cfa_fffff768
    _unknown_ __ebp;                       // r6
    _unknown_ _t57;                        // _t57
    _unknown_ _t60;                        // _t60
    DIR* _t61;             // _t61
    struct dirent* _t62;   // _t62
    int _t65;                              // _t65
    struct dirent* _t66;   // _t66
    _unknown_ _t69;                        // _t69
    signed int _t71;                       // _t71
    _unknown_ _t74;                        // _t74
    int _t77;                              // _t77
    int _t80;                              // _t80
    _unknown_ _t84;                        // _t84
    _unknown_ _t90;                        // _t90
    _unknown_ _t93;                        // _t93
    _unknown_ _t96;                        // _t96

    _v2176 = _a4;
    _v16 =  *gs:0x14];
    n_dirs = 0;
    fwrite("Binary installation files\n", 1, 26, __imp__stdout);
    _t61 = _v2176;
     *__esp = _t61;
    opendir();
    dir = _t61;
    __eflags = dir;
    if(dir != 0) {
        _t62 = dir;
         *__esp = _t62;
        readdir();
        dir_entry = _t62;
        while(1) {
            __eflags = dir_entry;
            if(dir_entry == 0) {
                break;
            }
            _t65 = strcmp( &(dir_entry->d_name), ".");
            __eflags = _t65;
            if(_t65 != 0) {
                _t77 = strcmp( &(dir_entry->d_name), "..");
                __eflags = _t77;
                if(_t77 != 0) {
                    _t80 = strcmp( &(dir_entry->d_name), "src");
                    __eflags = _t80;
                    if(_t80 != 0) {
                        _v2192 =  &(dir_entry->d_name);
                        _v2196 = _v2176;
                        sprintf( &tmp, "%s/%s");
                        __stat( &tmp,  &(buf.st_dev));
                        __eflags = (buf.st_mode & 61440) - 16384;
                        if((buf.st_mode & 61440) == 16384) {
                            __eflags = n_dirs;
                            if(n_dirs != 0) {
                                _v2196 =  &(dir_entry->d_name);
                                fprintf(__imp__stdout, ", %s");
                            } else {
                                _v2196 =  &(dir_entry->d_name);
                                fprintf(__imp__stdout, "  %s");
                            }
                            n_dirs = n_dirs + 1;
                        }
                    }
                }
            }
            _t66 = dir;
             *__esp = _t66;
            readdir();
            dir_entry = _t66;
        }
        __eflags = n_dirs;
        if(n_dirs == 0) {
            fwrite("  None.", 1, 7, __imp__stdout);
        }
        fwrite("\n\n", 1, 2, __imp__stdout);
    } else {
        fwrite("  None.\n\n", 1, 9, __imp__stdout);
    }
    _t71 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t71;
    }
    __stack_chk_fail();
    return _t71;
}

int binaries_exist(char* package, char* binaries)
{// addr = 0x0804A92C  --  defined in 'tools.c' at line 690
    intOrPtr _v16;                         // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    DIR* dir;              // _cfa_fffff7ec
    struct dirent* dir_entry;   // _cfa_fffff7e8
    struct stat buf;      // _cfa_fffff790
    DIR* _v2176;           // _cfa_fffff780
    char* _v2180;                          // _cfa_fffff77c
    char** _v2192;                         // _cfa_fffff770
    DIR* _v2196;           // _cfa_fffff76c
    _unknown_ _v2200;                      // _cfa_fffff768
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39
    DIR* _t40;             // _t40
    struct dirent* _t41;   // _t41
    int _t44;                              // _t44
    struct dirent* _t45;   // _t45
    int _t46;                              // _t46
    int _t49;                              // _t49
    int _t52;                              // _t52
    _unknown_ _t56;                        // _t56
    _unknown_ _t64;                        // _t64

    _v2176 = _a4;
    _v2180 = _a8;
    _v16 =  *gs:0x14];
    _t40 = _v2176;
     *__esp = _t40;
    opendir();
    dir = _t40;
    __eflags = dir;
    if(__eflags != 0) {
        _t41 = dir;
         *__esp = _t41;
        readdir();
        dir_entry = _t41;
        while(1) {
            __eflags = dir_entry;
            if(__eflags == 0) {
                break;
            }
            _t44 = strcmp( &(dir_entry->d_name), ".");
            __eflags = _t44;
            if(_t44 == 0) {
L9:
                _t45 = dir;
                 *__esp = _t45;
                readdir();
                dir_entry = _t45;
                continue;
            }
            _t49 = strcmp( &(dir_entry->d_name), "..");
            __eflags = _t49;
            if(_t49 == 0) {
                goto L9;
            }
            _t52 = strcmp( &(dir_entry->d_name), "src");
            __eflags = _t52;
            if(_t52 == 0) {
                goto L9;
            }
            _v2192 =  &(dir_entry->d_name);
            _v2196 = _v2176;
            sprintf( &tmp, "%s/%s");
            __stat( &tmp,  &(buf.st_dev));
            __eflags = (buf.st_mode & 61440) - 16384;
            if((buf.st_mode & 61440) != 16384) {
                goto L9;
            }
            __eflags = strcmp( &(dir_entry->d_name), _v2180);
            if(__eflags != 0) {
                goto L9;
            }
            _t46 = 1;
L12:
            if(__eflags != 0) {
                __stack_chk_fail();
                return _t46;
            }
            return _t46;
        }
        _t46 = 0;
        goto L12;
    }
    _t46 = 0;
    goto L12;
}

int check_filetype(char* myfile)
{// addr = 0x0804AAA8  --  defined in 'tools.c' at line 737
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31

    if(strstr(myfile, ".tar.gz") == 0) {
        if(strstr(myfile, ".tgz") == 0) {
            if(strstr(myfile, ".tar.bz2") == 0) {
                if(strstr(myfile, ".tbz") == 0) {
                    if(strstr(myfile, ".zip") == 0) {
                        if(strstr(myfile, ".tar") == 0) {
                            return 0;
                        }
                        goto L11;
                    }
                    goto L9;
L11:
                    return 4;
                }
                goto L7;
L9:
                return 3;
            }
            goto L5;
L7:
            return 2;
        }
        goto L3;
L5:
        return 2;
    }
    return 1;
L3:
    return 1;
}

wget_extension(char* url)
{// addr = 0x0804AB6C  --  defined in 'tools.c' at line 766
    signed int _v16;                       // _cfa_fffffff0
    char[2047] str;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    char[2047]* _v2080;                    // _cfa_fffff7e0
    _unknown_ _v2096;                      // _cfa_fffff7d0
    char[2047]* _v2100;                    // _cfa_fffff7cc
    _unknown_ _v2104;                      // _cfa_fffff7c8
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    _unknown_ _t29;                        // _t29
    _unknown_ _t33;                        // _t33
    signed int _t37;                       // _t37
    _unknown_ _t41;                        // _t41
    int _t47;                              // _t47

    _v2080 = _a4;
    _v16 =  *gs:0x14];
    fwrite("Downloading...", 1, 14, __imp__stdout);
    if(VERBOSE == 0) {
        _v2100 = _v2080;
        sprintf( &str, "wget -N -q %s");
    } else {
        _v2100 = _v2080;
        sprintf( &str, "wget -N %s");
    }
    error = system( &str);
    if(error == 255) {
        print_error(-20, "could not run 'wget' to download extension. Is it installed?\n");
    }
    _t47 = error;
    if(_t47 > 0) {
        _v2100 =  &str;
        print_error(-20, "running command '%s'.\n");
    }
    print_done();
    _t37 = _v16 ^  *gs:0x14];
    if(_t47 != 0) {
        __stack_chk_fail();
        return _t37;
    }
    return _t37;
}

su(char* gisbase, char* cmd)
{// addr = 0x0804AC6E  --  defined in 'tools.c' at line 796
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmpfile;                    // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    FILE* f;              // _cfa_fffff7e8
    char* _v2080;                          // _cfa_fffff7e0
    char* _v2084;                          // _cfa_fffff7dc
    int _v2096;                            // _cfa_fffff7d0
    char* _v2100;                          // _cfa_fffff7cc
    _unknown_ _v2104;                      // _cfa_fffff7c8
    _unknown_ __ebp;                       // r6
    _unknown_ _t27;                        // _t27
    _unknown_ _t35;                        // _t35
    _unknown_ _t39;                        // _t39
    _unknown_ _t45;                        // _t45
    _unknown_ _t47;                        // _t47
    signed int _t51;                       // _t51

    _v2080 = _a4;
    _v2084 = _a8;
    _v16 =  *gs:0x14];
    next = next * next + 54321;
    next = next >> 16 & 32767;
    srand(next);
    _v2096 = rand();
    _v2100 = _v2080;
    sprintf( &tmpfile, "%s/gem.test.%i");
    f = fopen( &tmpfile, "w+");
    __eflags =  *(__errno_location()) - 13;
    if(__eflags != 0) {
        remove( &tmpfile);
        fclose(f);
        error = system(_v2084);
        __eflags = error;
        if(__eflags != 0) {
            _v2100 = _v2084;
            print_error(-9, "could not run '%s'.\n");
        }
    } else {
        print_error(-5, "You don't have write access to your local GRASS installation.\nPlease consult your system administrator.\n");
    }
    _t51 = _v16 ^  *gs:0x14];
    if(__eflags == 0) {
        return _t51;
    } else {
        __stack_chk_fail();
        return _t51;
    }
}

int vercmp(int major, int minor, int revision, int major2, int minor2, int revision2)
{// addr = 0x0804AD9B  --  defined in 'tools.c' at line 832
    _unknown_ __ebp;                       // r6
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32
    _unknown_ _t35;                        // _t35

    if(major == major2 && minor == minor2 && revision == revision2) {
        return 0;
    }
    if(major2 <= major) {
        if(major2 >= major) {
            if(minor2 <= minor) {
                if(minor2 >= minor) {
                    if(revision2 <= revision) {
                        if(revision2 >= revision) {
                            return 0;
                        }
                        goto L15;
                    }
                    goto L13;
L15:
                    return 1;
                }
                goto L11;
L13:
                return -1;
            }
            goto L9;
L11:
            return 1;
        }
        goto L7;
L9:
        return -1;
    }
    return -1;
L7:
    return 1;
}

char* depstr(char* package, char* gisbase)
{// addr = 0x0804AE20  --  defined in 'reg_deps.c' at line 32
    intOrPtr _v16;                         // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] line;                       // _cfa_ffffeff0
    char[2047] short_name;                 // _cfa_ffffe7f0
    char* str;                             // _cfa_ffffe7ec
    int first;                             // _cfa_ffffe7e8
    int error;                             // _cfa_ffffe7e4
    FILE* f_deps;         // _cfa_ffffe7e0
    intOrPtr _v6192;                       // _cfa_ffffe7d0
    intOrPtr _v6196;                       // _cfa_ffffe7cc
    char* _v6208;                          // _cfa_ffffe7c0
    char[2047]* _v6212;                    // _cfa_ffffe7bc
    _unknown_ _v6216;                      // _cfa_ffffe7b8
    _unknown_ __ebp;                       // r6
    _unknown_ _t52;                        // _t52
    _unknown_ _t55;                        // _t55
    _unknown_ _t64;                        // _t64
    _unknown_ _t69;                        // _t69
    _unknown_ _t72;                        // _t72
    _unknown_ _t75;                        // _t75
    _unknown_ _t78;                        // _t78
    _unknown_ _t80;                        // _t80
    char* _t81;                            // _t81
    _unknown_ _t90;                        // _t90
    _unknown_ _t93;                        // _t93

    _v6192 = _a4;
    _v6196 = _a8;
    _v16 =  *gs:0x14];
    memcpy( &file, "../depends", 11);
    f_deps = fopen( &file, "r");
    if(f_deps != 0) {
L4:
        first = 1;
        str = malloc(2048);
        while(nc_fgets_nb( &line, 2048, f_deps) != 0) {
        }
        fclose(f_deps);
        _t81 = str;
        goto L13;
    }
    _t93 =  *(__errno_location()) - 2;
    if(_t93 != 0) {
        _v6208 = strerror( *(__errno_location()));
        _v6212 =  &file;
        print_error(-17, "checking for file '%s': %s\n");
        goto L4;
    } else {
        _t81 = 134565141;
    }
L13:
    if(_t93 == 0) {
        return _t81;
    }
    __stack_chk_fail();
    return _t81;
}

register_extension(char* gisbase, char* bins, char* pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision)
{// addr = 0x0804B014  --  defined in 'reg_deps.c' at line 87
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char[2047] short_name;                 // _cfa_ffffe7f0
    char[2047] inst_bins;                  // _cfa_ffffdff0
    char[2047] deps;                       // _cfa_ffffd7f0
    int n_lines;                           // _cfa_ffffd7ec
    int error;                             // _cfa_ffffd7e8
    int db_exists;                         // _cfa_ffffd7e4
    int must_register;                     // _cfa_ffffd7e0
    int copy_thru;                         // _cfa_ffffd7dc
    int ext_exists;                        // _cfa_ffffd7d8
    FILE* f_in;           // _cfa_ffffd7d4
    FILE* f_out;          // _cfa_ffffd7d0
    int major;                             // _cfa_ffffd7cc
    int minor;                             // _cfa_ffffd7c8
    int revision;                          // _cfa_ffffd7c4
    char* _v10304;                         // _cfa_ffffd7c0
    char[2047]* _v10308;                   // _cfa_ffffd7bc
    char* _v10312;                         // _cfa_ffffd7b8
    char[2047]* _v10320;                   // _cfa_ffffd7b0
    char[2047]* _v10324;                   // _cfa_ffffd7ac
    int _v10328;                           // _cfa_ffffd7a8
    int _v10332;                           // _cfa_ffffd7a4
    int _v10336;                           // _cfa_ffffd7a0
    char[2047]* _v10340;                   // _cfa_ffffd79c
    char* _v10344;                         // _cfa_ffffd798
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t178;                       // _t178
    _unknown_ _t181;                       // _t181
    _unknown_ _t185;                       // _t185
    _unknown_ _t186;                       // _t186
    _unknown_ _t189;                       // _t189
    _unknown_ _t194;                       // _t194
    _unknown_ _t197;                       // _t197
    _unknown_ _t199;                       // _t199
    signed int _t201;                      // _t201
    _unknown_ _t207;                       // _t207
    _unknown_ _t208;                       // _t208
    _unknown_ _t211;                       // _t211
    _unknown_ _t221;                       // _t221
    _unknown_ _t223;                       // _t223
    _unknown_ _t233;                       // _t233
    _unknown_ _t235;                       // _t235
    _unknown_ _t240;                       // _t240
    _unknown_ _t243;                       // _t243
    _unknown_ _t248;                       // _t248
    _unknown_ _t251;                       // _t251
    _unknown_ _t258;                       // _t258
    FILE* _t310;          // _t310

    _v10304 = _a4;
    _v10308 = _a8;
    _v10312 = _a12;
    _v16 =  *gs:0x14];
    db_exists = 1;
    _v10340 = _v10304;
    sprintf( &file, "%s/etc/extensions.db");
    f_in = fopen( &file, "r");
    if(f_in == 0) {
        if( *(__errno_location()) != 2) {
            fclose(f_in);
            _v10336 = strerror( *(__errno_location()));
            _v10340 =  &file;
            print_error(-15, "checking for file '%s': %s\n");
        } else {
            db_exists = 0;
        }
    }
    if(db_exists == 0) {
L25:
        if(n_lines == 0 || db_exists == 0) {
            memcpy( &TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp( &TMPDB);
            f_out = fopen( &TMPDB, "w+");
            _t310 = f_out;
            if(_t310 == 0) {
                _v10336 = strerror( *(__errno_location()));
                _v10340 =  &file;
                print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
            }
            atexit(exit_db);
            strcpy( &deps, depstr(_v10312, _v10304));
            _v10320 =  &deps;
            _v10324 = _v10308;
            _v10328 = pkg_revision;
            _v10332 = pkg_minor;
            _v10336 = pkg_major;
            _v10340 = _v10312;
            fprintf(f_out, "%s\t%i.%i.%i\t%s\t%s\n");
            fclose(f_out);
        }
        _t201 = _v16 ^  *gs:0x14];
        if(_t310 == 0) {
            return _t201;
        } else {
            __stack_chk_fail();
            return _t201;
        }
    } else {
        memcpy( &TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp( &TMPDB);
        f_out = fopen( &TMPDB, "w+");
        if(f_out == 0) {
            _v10336 = strerror( *(__errno_location()));
            _v10340 =  &TMPDB;
            print_error(-15, "could not create temp file '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
    }
    atexit(exit_db);
    n_lines = 0;
    must_register = 1;
    ext_exists = 0;
    while(nc_fgets_nb( &str, 2048, f_in) != 0) {
        n_lines = n_lines + 1;
        copy_thru = 1;
        _v10320 =  &deps;
        _v10324 =  &inst_bins;
        _v10328 =  &revision;
        _v10332 =  &minor;
        _v10336 =  &major;
        _v10340 =  &short_name;
        _v10344 = "%s\t%i.%i.%i\t%s\t%s";
         *__esp =  &str;
        __isoc99_sscanf();
        if(strcmp( &short_name, _v10312) == 0) {
            ext_exists = 1;
            error = vercmp(major, minor, revision, pkg_major, pkg_minor, pkg_revision);
            if(FORCE == 0) {
                if(error >= 0) {
                    _v10328 = revision;
                    _v10332 = minor;
                    _v10336 = major;
                    _v10340 = _v10312;
                    print_error(-16, "Extension '%s' with same or higher version (%i.%i.%i) already installed. You can use -f to overwrite this version, if you know what you are doing.\n");
                } else {
                    _v10328 = revision;
                    _v10332 = minor;
                    _v10336 = major;
                    _v10340 = _v10312;
                    print_error(-16, "Extension '%s' with lower version (%i.%i.%i) already installed. You can use -f to overwrite this version, if you know what you are doing.\n");
                }
            }
            if(FORCE != 0) {
                if(error != 0) {
                    must_register = 1;
                    copy_thru = 0;
                } else {
                    must_register = 0;
                }
            }
        }
        if(copy_thru != 0) {
            fprintf(f_out,  &str);
            fflush(f_out);
        }
    }
    if(must_register != 0) {
        if(ext_exists != 0) {
            strcpy( &deps, depstr(_v10312, _v10304));
            _v10320 =  &deps;
            _v10324 =  &inst_bins;
            _v10328 = pkg_revision;
            _v10332 = pkg_minor;
            _v10336 = pkg_major;
            _v10340 =  &short_name;
            fprintf(f_out, "%s\t%i.%i.%i\t%s\t%s\n");
        } else {
            strcpy( &deps, depstr(_v10312, _v10304));
            _v10320 =  &deps;
            _v10324 = _v10308;
            _v10328 = pkg_revision;
            _v10332 = pkg_minor;
            _v10336 = pkg_major;
            _v10340 = _v10312;
            fprintf(f_out, "%s\t%i.%i.%i\t%s\t%s\n");
        }
    }
    fclose(f_out);
    fclose(f_in);
    goto L25;
}

deregister_extension(char* package, char* pkg_short_name, char* gisbase)
{// addr = 0x0804B5E3  --  defined in 'reg_deps.c' at line 235
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char[2047] short_name;                 // _cfa_ffffe7f0
    char[2047] inst_bins;                  // _cfa_ffffdff0
    char[2047] deps;                       // _cfa_ffffd7f0
    int error;                             // _cfa_ffffd7ec
    int db_exists;                         // _cfa_ffffd7e8
    int copy_thru;                         // _cfa_ffffd7e4
    FILE* f_in;           // _cfa_ffffd7e0
    FILE* f_out;          // _cfa_ffffd7dc
    int found_ext;                         // _cfa_ffffd7d8
    int major;                             // _cfa_ffffd7d4
    int minor;                             // _cfa_ffffd7d0
    int revision;                          // _cfa_ffffd7cc
    intOrPtr _v10304;                      // _cfa_ffffd7c0
    char* _v10308;                         // _cfa_ffffd7bc
    char* _v10312;                         // _cfa_ffffd7b8
    char[2047]* _v10320;                   // _cfa_ffffd7b0
    char[2047]* _v10324;                   // _cfa_ffffd7ac
    int* _v10328;                          // _cfa_ffffd7a8
    int* _v10332;                          // _cfa_ffffd7a4
    char* _v10336;                         // _cfa_ffffd7a0
    char* _v10340;                         // _cfa_ffffd79c
    char* _v10344;                         // _cfa_ffffd798
    _unknown_ __ebp;                       // r6
    _unknown_ _t90;                        // _t90
    _unknown_ _t93;                        // _t93
    signed int _t97;                       // _t97
    int _t101;                             // _t101
    _unknown_ _t110;                       // _t110
    _unknown_ _t115;                       // _t115
    _unknown_ _t117;                       // _t117
    _unknown_ _t121;                       // _t121
    _unknown_ _t122;                       // _t122
    _unknown_ _t125;                       // _t125
    _unknown_ _t135;                       // _t135
    _unknown_ _t142;                       // _t142
    int _t161;                             // _t161

    _v10304 = _a4;
    _v10308 = _a8;
    _v10312 = _a12;
    _v16 =  *gs:0x14];
    db_exists = 0;
    _v10340 = _v10312;
    sprintf( &file, "%s/etc/extensions.db");
    f_in = fopen( &file, "r");
    if(f_in != 0) {
        db_exists = 1;
L8:
        if(db_exists != 0) {
            db_exists = 0;
            memcpy( &TMPDB, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp( &TMPDB);
            f_out = fopen( &TMPDB, "w+");
            if(f_out != 0 || FORCE != 0) {
                db_exists = 1;
                atexit(exit_db);
            } else {
                _v10336 = strerror( *(__errno_location()));
                _v10340 =  &file;
                print_error(-19, "could not create temp db '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
            }
        }
        if(db_exists == 0) {
L27:
            _t97 = _v16 ^  *gs:0x14];
            if(_t161 == 0) {
                return _t97;
            }
        } else {
            found_ext = 0;
            while(nc_fgets_nb( &str, 2048, f_in) != 0) {
                _t101 =  &str;
                _v10320 =  &deps;
                _v10324 =  &inst_bins;
                _v10328 =  &revision;
                _v10332 =  &minor;
                _v10336 =  &major;
                _v10340 =  &short_name;
                _v10344 = "%s\t%i.%i.%i\t%s\t%s";
                 *__esp = _t101;
                __isoc99_sscanf();
                error = _t101;
                if(error > 0) {
                    copy_thru = 1;
                    if(strcmp(_v10308,  &short_name) == 0) {
                        copy_thru = 0;
                        found_ext = 1;
                    }
                    if(copy_thru != 0) {
                        if(strstr( &deps, _v10308) != 0 && FORCE == 0) {
                            _v10336 =  &short_name;
                            _v10340 = _v10308;
                            print_error(-19, "cannot uninstall extension '%s' it is needed by '%s'.\n");
                        }
                        fprintf(f_out,  &str);
                    }
                }
            }
            _t161 = found_ext;
            if(_t161 == 0) {
                _v10336 = _v10312;
                _v10340 = _v10308;
                print_error(-19, "no extension '%s' registered/installed in '%s'.\n");
            }
            fclose(f_in);
            fclose(f_out);
            goto L27;
        }
        __stack_chk_fail();
        return _t97;
    }
    if( *(__errno_location()) != 2) {
L4:
        if(FORCE == 0) {
            fclose(f_in);
            _v10336 = strerror( *(__errno_location()));
            _v10340 =  &file;
            print_error(-19, "checking for file '%s': %s\n");
        }
        goto L8;
    }
    if(FORCE != 0) {
        goto L4;
    } else {
        fclose(f_in);
        print_error(-19, "could not deregister: no extensions installed\n");
    }
    goto L8;
}

check_dependencies(char* package, char* gisbase, char* grass_version)
{// addr = 0x0804B961  --  defined in 'reg_deps.c' at line 340
    signed int _v32;                       // _cfa_ffffffe0
    char[2047] file;                       // _cfa_fffff7e0
    char[2047] str;                        // _cfa_ffffefe0
    char[2047] dbstr;                      // _cfa_ffffe7e0
    char[2047] short_name;                 // _cfa_ffffdfe0
    char[2047] dep_short_name;             // _cfa_ffffd7e0
    int error;                             // _cfa_ffffd7dc
    int db_exists;                         // _cfa_ffffd7d8
    int satisfied;                         // _cfa_ffffd7d4
    FILE* f_deps;         // _cfa_ffffd7d0
    FILE* f_db;           // _cfa_ffffd7cc
    int major;                             // _cfa_ffffd7c8
    int minor;                             // _cfa_ffffd7c4
    int revision;                          // _cfa_ffffd7c0
    int dep_major;                         // _cfa_ffffd7bc
    int dep_minor;                         // _cfa_ffffd7b8
    int dep_revision;                      // _cfa_ffffd7b4
    char[2047]* _v10320;                   // _cfa_ffffd7b0
    char[2047]* _v10324;                   // _cfa_ffffd7ac
    int _v10328;                           // _cfa_ffffd7a8
    int _v10348;                           // _cfa_ffffd794
    int _v10352;                           // _cfa_ffffd790
    int _v10356;                           // _cfa_ffffd78c
    int* _v10360;                          // _cfa_ffffd788
    int* _v10364;                          // _cfa_ffffd784
    char* _v10368;                         // _cfa_ffffd780
    char[2047]* _v10372;                   // _cfa_ffffd77c
    char* _v10376;                         // _cfa_ffffd778
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t154;                       // _t154
    _unknown_ _t160;                       // _t160
    int _t166;                             // _t166
    _unknown_ _t170;                       // _t170
    int _t174;                             // _t174
    _unknown_ _t189;                       // _t189
    signed int _t191;                      // _t191
    _unknown_ _t193;                       // _t193
    _unknown_ _t197;                       // _t197
    _unknown_ _t205;                       // _t205
    _unknown_ _t211;                       // _t211
    _unknown_ _t251;                       // _t251

    _v10320 = _a4;
    _v10324 = _a8;
    _v10328 = _a12;
    _v32 =  *gs:0x14];
    if(FORCE != 0) {
        goto L30;
    }
    f_deps = fopen("../depends", "r");
    if(f_deps != 0) {
L5:
        db_exists = 1;
        _v10372 = _v10324;
        sprintf( &file, "%s/etc/extensions.db");
        f_db = fopen( &file, "r");
        if(f_db == 0) {
            if( *(__errno_location()) != 2) {
                fclose(f_db);
                _v10368 = strerror( *(__errno_location()));
                _v10372 =  &file;
                print_error(-17, "checking for file '%s': %s\n");
            } else {
                db_exists = 0;
            }
        }
        satisfied = 0;
        while(nc_fgets_nb( &str, 2048, f_deps) != 0) {
            major = 0;
            minor = 0;
            revision = 0;
            dep_major = 0;
            dep_minor = 0;
            dep_revision = 0;
            _t166 =  &str;
            _v10360 =  &dep_revision;
            _v10364 =  &dep_minor;
            _v10368 =  &dep_major;
            _v10372 =  &dep_short_name;
            _v10376 = "%s\t%i.%i.%i";
             *__esp = _t166;
            __isoc99_sscanf();
            error = _t166;
            if(error <= 0) {
                continue;
            }
            if(strcmp( &dep_short_name, "GRASS") != 0) {
                if(db_exists == 0) {
                    continue;
                }
                goto L16;
            }
            _v10364 =  &revision;
            _v10368 =  &minor;
            _v10372 =  &major;
            _v10376 = "%i.%i.%i";
             *__esp = _v10328;
            __isoc99_sscanf();
            if(vercmp(major, minor, revision, dep_major, dep_minor, dep_revision) < 0) {
                _v10360 = dep_revision;
                _v10364 = dep_minor;
                _v10368 = dep_major;
                _v10372 = _v10328;
                print_error(-18, "installed version (%s) of GRASS is too low. Required version is %i.%i.%i\n");
            }
            satisfied = 1;
            continue;
L16:
            satisfied = 0;
            rewind(f_db);
            while(nc_fgets_nb( &dbstr, 2048, f_db) != 0) {
                major = 0;
                minor = 0;
                revision = 0;
                _t174 =  &dbstr;
                _v10360 =  &revision;
                _v10364 =  &minor;
                _v10368 =  &major;
                _v10372 =  &short_name;
                _v10376 = "%s\t%i.%i.%i";
                 *__esp = _t174;
                __isoc99_sscanf();
                error = _t174;
                if(error > 0 && strcmp( &short_name,  &dep_short_name) == 0) {
                    if(vercmp(major, minor, revision, dep_major, dep_minor, dep_revision) < 0) {
                        _v10348 = dep_revision;
                        _v10352 = dep_minor;
                        _v10356 = dep_major;
                        _v10360 =  &dep_short_name;
                        _v10364 = revision;
                        _v10368 = minor;
                        _v10372 = major;
                        print_error(-18, "installed version %i.%i.%i of required extension '%s' is too low.\n \t\t\t\t\t\t\t\t\t\t\t\t\tRequired version is %i.%i.%i\n");
                    }
                    satisfied = 1;
                }
            }
            if(satisfied == 0) {
                _v10368 = _v10324;
                _v10372 =  &dep_short_name;
                print_error(-18, "required extension '%s' not found in '%s'.\n");
            }
        }
        if(db_exists != 0) {
            fclose(f_db);
        }
        fclose(f_deps);
        goto L30;
    }
    _t251 =  *(__errno_location()) - 2;
    if(_t251 != 0) {
        fclose(f_deps);
        _v10368 = strerror( *(__errno_location()));
        _v10372 =  &file;
        print_error(-17, "checking for file '%s': %s\n");
        goto L5;
    } else {
        _v10372 = _v10320;
        fprintf(__imp__stderr, "\n%s/depends ENOENT\n");
    }
L30:
    _t191 = _v32 ^  *gs:0x14];
    if(_t251 == 0) {
        return _t191;
    }
    __stack_chk_fail();
    return _t191;
}

int is_submenu(char* item)
{// addr = 0x0804BE84  --  defined in 'reg_entries.c' at line 36
    _unknown_ _v24;                        // _cfa_ffffffe8
    _unknown_ __ebp;                       // r6
    char* _t14;                            // _t14
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20

    if(strchr(item, 91) != 0) {
        if(strrchr(item, 93) != 0) {
            _t14 = strchr(item, 91);
            if(_t14 <= strrchr(item, 93)) {
                return 1;
            }
            goto L5;
        }
        goto L3;
L5:
        return 0;
    }
    return 0;
L3:
    return 0;
}

int check_ext_menu(char** tcl_lines)
{// addr = 0x0804BF05  --  defined in 'reg_entries.c' at line 57
    int idx;                               // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ __ebp;                       // r6
    _unknown_ _t46;                        // _t46
    _unknown_ _t49;                        // _t49
    _unknown_ _t54;                        // _t54
    _unknown_ _t57;                        // _t57

    idx = find_pos(""&Xtns" all options 1", tcl_lines, 0);
    if(idx != 255) {
L6:
        return idx;
    }
    idx = find_pos(""&Help" all options", tcl_lines, 0);
    if(idx != 255) {
        insert_str(" "&Xtns" all options 1 {\n", idx, tcl_lines);
        idx = idx + 1;
        insert_str(" }\n", idx, tcl_lines);
        goto L6;
    }
    idx = find_pos("}]", tcl_lines, 0);
    if(idx == 255) {
        print_error(-21, "could not parse 'menu.tcl'.\n");
    }
    insert_str(" "&Xtns" all options 1 {\n", idx, tcl_lines);
    idx = idx + 1;
    insert_str(" }\n", idx, tcl_lines);
    return idx;
    goto L6;
    return __eax;
}

int new_submenu(char* pkg_short_name, char* menu, char** tcl_lines)
{// addr = 0x0804C009  --  defined in 'reg_entries.c' at line 90
    intOrPtr _v16;                         // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] tmp2;                       // _cfa_ffffeff0
    char[2047] searchstr;                  // _cfa_ffffe7f0
    int idx;                               // _cfa_ffffe7ec
    int idx2;                              // _cfa_ffffe7e8
    int insert_here;                       // _cfa_ffffe7e4
    int last;                              // _cfa_ffffe7e0
    char* first_quote;                     // _cfa_ffffe7dc
    char* second_quote;                    // _cfa_ffffe7d8
    int len;                               // _cfa_ffffe7d4
    int terminator;                        // _cfa_ffffe7d0
    char[2047]* _v6208;                    // _cfa_ffffe7c0
    char* _v6212;                          // _cfa_ffffe7bc
    char** _v6216;                         // _cfa_ffffe7b8
    char[2047]* _v6224;                    // _cfa_ffffe7b0
    char[2047]* _v6228;                    // _cfa_ffffe7ac
    char[2047]* _v6232;                    // _cfa_ffffe7a8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t128;                       // _t128
    char* _t139;                           // _t139
    _unknown_ _t147;                       // _t147
    _unknown_ _t152;                       // _t152
    _unknown_ _t164;                       // _t164
    _unknown_ _t168;                       // _t168
    _unknown_ _t171;                       // _t171
    _unknown_ _t176;                       // _t176
    _unknown_ _t180;                       // _t180
    int _t182;                             // _t182
    _unknown_ _t196;                       // _t196
    _unknown_ _t223;                       // _t223
    int _t228;                             // _t228

    _v6208 = _a4;
    _v6212 = _a8;
    _v6216 = _a12;
    _v16 =  *gs:0x14];
    idx = find_pos(""&Xtns" all options", _v6216, 0);
    last = find_pos("" all options", _v6216, idx + 1) - 1;
    if(last == 255) {
        last = find_pos("}]", _v6216, 0);
    }
    _t228 = is_submenu(_v6212);
    if(_t228 != 0) {
        _t139 = strrchr(_v6212, 93);
        len = _t139 - strchr(_v6212, 91);
        strncpy( &tmp,  &((strchr(_v6212, 91))[1]), len);
         *(__ebp + len - 1 + -2060) = 0;
        _v6228 =  &tmp;
        sprintf( &searchstr, "{cascad "%s"");
        idx2 = find_pos( &searchstr, _v6216, idx);
        if(idx2 == 255 || idx2 >= last) {
            insert_here = idx + 1;
            idx2 = find_pos("{cascad ", _v6216, idx);
L11:
            while(idx2 != 255 && idx2 < last) {
                goto L8;
            }
L13:
            _v6228 =  &searchstr;
            sprintf( &tmp, " \t\t\t%s {} "" 1 {\n");
            insert_str( &tmp, insert_here, _v6216);
            insert_str(" \t\t\t}}\n", insert_here + 1, _v6216);
            terminator = find_pos("}]", _v6216, 0);
            _v6224 =  &searchstr;
            _v6228 = _v6208;
            sprintf( &tmp, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} "" 1 {\n");
            insert_str( &tmp, terminator + 1, _v6216);
            _t182 = insert_here + 1;
            goto L14;
        } else {
            _v6232 =  &tmp;
            print_warning("submenu '%s' exists in GIS Manager's Xtns menu.\n");
            _t182 = -1;
L14:
            if(_t228 == 0) {
                return _t182;
            }
            __stack_chk_fail();
            return _t182;
        }
L8:
        first_quote = strchr(_v6216[idx2], 34);
        second_quote = strchr( &(first_quote[1]), 34);
        len = second_quote - first_quote;
        strncpy( &tmp2,  &(first_quote[1]), len);
         *(__ebp + len - 1 + -4108) = 0;
        if(strcmp( &tmp,  &tmp2) >= 0) {
            idx = idx + 1;
            idx2 = find_pos("{cascad ", _v6216, idx);
            goto L11;
        }
        insert_here = idx2;
        goto L13;
    }
    print_warning("first line not a submenu specifier in 'entries-gisman'.\n");
    _t182 = -1;
    goto L14;
}

int new_item(char* item, char* menu, char** tcl_lines, int line_no)
{// addr = 0x0804C41B  --  defined in 'reg_entries.c' at line 173
    intOrPtr _v16;                         // _cfa_fffffff0
    char[2047] entry;                      // _cfa_fffff7f0
    char[2047] command;                    // _cfa_ffffeff0
    char[2047] tmp;                        // _cfa_ffffe7f0
    char* token;                           // _cfa_ffffe7ec
    int num_tokens;                        // _cfa_ffffe7e8
    char* _v6176;                          // _cfa_ffffe7e0
    intOrPtr _v6180;                       // _cfa_ffffe7dc
    char** _v6184;                         // _cfa_ffffe7d8
    char[2047]* _v6204;                    // _cfa_ffffe7c4
    char[2047]* _v6208;                    // _cfa_ffffe7c0
    char[2047]* _v6212;                    // _cfa_ffffe7bc
    int _v6216;                            // _cfa_ffffe7b8
    _unknown_ __ebp;                       // r6
    _unknown_ _t57;                        // _t57
    _unknown_ _t59;                        // _t59
    _unknown_ _t65;                        // _t65
    int _t69;                              // _t69
    _unknown_ _t72;                        // _t72
    _unknown_ _t76;                        // _t76
    int _t77;                              // _t77
    int _t79;                              // _t79
    _unknown_ _t82;                        // _t82
    _unknown_ _t86;                        // _t86
    _unknown_ _t91;                        // _t91

    _v6176 = _a4;
    _v6180 = _a8;
    _v6184 = _a12;
    _v16 =  *gs:0x14];
    chop(_v6176);
    token = strtok(_v6176, ";");
    __eflags = token;
    if(__eflags != 0) {
        strcpy( &entry, token);
        num_tokens = 0;
        while(1) {
            __eflags = token;
            if(token == 0) {
                break;
            }
            token = strtok(0, ";");
            __eflags = token;
            if(token != 0) {
                strcpy( &command, token);
            }
            num_tokens = num_tokens + 1;
        }
        __eflags = num_tokens - 2;
        if(__eflags <= 0) {
            _t69 = strcmp( &entry, "-");
            __eflags = _t69;
            if(_t69 != 0) {
L12:
                _v6204 =  &command;
                _v6208 =  &command;
                _v6212 =  &entry;
                sprintf( &tmp, " \t\t\t {command "%s" {} "%s" {} -command {%s }}\n");
            } else {
                _t79 = strcmp( &entry, "-");
                __eflags = _t79;
                if(_t79 != 0) {
                    goto L12;
                } else {
                    memcpy( &tmp, " \t\t\t {separator}\n", 18);
                }
            }
            insert_str( &tmp, line_no, _v6184);
            line_no = line_no + 1;
            _t77 = line_no;
L14:
            if(__eflags != 0) {
                __stack_chk_fail();
                return _t77;
            }
            return _t77;
        }
        _v6216 = num_tokens;
        print_warning("invalid number of tokens (%i) in 'entries-gisman'.\n");
        _t77 = -1;
        goto L14;
    }
    print_warning("invalid token in 'entries-gisman'.\n");
    _t77 = -1;
    goto L14;
}

register_entries_gisman(char* pkg_short_name, char* gisbase)
{// addr = 0x0804C5F0  --  defined in 'reg_entries.c' at line 232
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char[2047] menu;                       // _cfa_ffffe7f0
    int len;                               // _cfa_ffffe7ec
    char** line;                           // _cfa_ffffe7e8
    int n_entries;                         // _cfa_ffffe7e4
    int n_lines;                           // _cfa_ffffe7e0
    int i;                                 // _cfa_ffffe7dc
    int n_lines_org;                       // _cfa_ffffe7d8
    int n_lines_new;                       // _cfa_ffffe7d4
    int line_no;                           // _cfa_ffffe7d0
    FILE* f_gisman;       // _cfa_ffffe7cc
    FILE* f_in;           // _cfa_ffffe7c8
    FILE* f_out;          // _cfa_ffffe7c4
    char* _v6208;                          // _cfa_ffffe7c0
    char* _v6212;                          // _cfa_ffffe7bc
    char[2047]* _v6228;                    // _cfa_ffffe7ac
    char[2047]* _v6232;                    // _cfa_ffffe7a8
    char[2047]* _v6236;                    // _cfa_ffffe7a4
    char[2047]* _v6240;                    // _cfa_ffffe7a0
    char[2047]* _v6244;                    // _cfa_ffffe79c
    char[2047]* _v6248;                    // _cfa_ffffe798
    char* _v6252;                          // _cfa_ffffe794
    char[2047]* _v6256;                    // _cfa_ffffe790
    char[2047]* _v6260;                    // _cfa_ffffe78c
    char* _v6264;                          // _cfa_ffffe788
    char* _v6268;                          // _cfa_ffffe784
    char* _v6272;                          // _cfa_ffffe780
    char[2047]* _v6276;                    // _cfa_ffffe77c
    _unknown_ _v6280;                      // _cfa_ffffe778
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t206;                       // _t206
    _unknown_ _t209;                       // _t209
    _unknown_ _t214;                       // _t214
    _unknown_ _t218;                       // _t218
    _unknown_ _t219;                       // _t219
    _unknown_ _t222;                       // _t222
    _unknown_ _t226;                       // _t226
    _unknown_ _t228;                       // _t228
    signed int _t233;                      // _t233
    _unknown_ _t235;                       // _t235
    _unknown_ _t241;                       // _t241
    _unknown_ _t267;                       // _t267
    _unknown_ _t269;                       // _t269
    _unknown_ _t287;                       // _t287
    _unknown_ _t289;                       // _t289
    _unknown_ _t291;                       // _t291
    _unknown_ _t295;                       // _t295
    _unknown_ _t296;                       // _t296
    _unknown_ _t298;                       // _t298
    _unknown_ _t300;                       // _t300
    _unknown_ _t302;                       // _t302
    _unknown_ _t311;                       // _t311
    _unknown_ _t313;                       // _t313
    char* _t316;                           // _t316
    _unknown_ _t324;                       // _t324
    _unknown_ _t333;                       // _t333
    _unknown_ _t340;                       // _t340
    _unknown_ _t348;                       // _t348
    _unknown_ _t395;                       // _t395

    _v6208 = _a4;
    _v6212 = _a8;
    _v16 =  *gs:0x14];
    memcpy( &file, "../entries-gisman", 18);
    f_gisman = fopen( &file, "r");
    if(f_gisman != 0) {
L3:
        _v6276 = _v6212;
        sprintf( &file, "%s/etc/dm/menu.tcl");
        f_in = fopen( &file, "r");
        if(f_in != 0) {
L6:
            memcpy( &TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp( &TMP_GISMAN);
            f_out = fopen( &TMP_GISMAN, "w+");
            if(f_out == 0) {
                _v6272 = strerror( *(__errno_location()));
                _v6276 =  &TMP_GISMAN;
                print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
            }
            atexit(exit_db);
            if(VERBOSE == 0) {
                _v6228 =  &TMP_NULL;
                _v6232 = _v6212;
                _v6236 =  &TMP_NULL;
                _v6240 = _v6212;
                _v6244 =  &TMP_GISMAN;
                _v6248 =  &TMP_NULL;
                _v6252 = _v6212;
                _v6256 = _v6212;
                _v6260 =  &TMP_NULL;
                _v6264 = _v6208;
                _v6268 = _v6212;
                _v6272 =  &TMP_NULL;
                _v6276 = _v6212;
                sprintf( &str, "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;");
            } else {
                _v6248 = _v6212;
                _v6252 = _v6212;
                _v6256 =  &TMP_GISMAN;
                _v6260 = _v6212;
                _v6264 = _v6212;
                _v6268 = _v6208;
                _v6272 = _v6212;
                _v6276 = _v6212;
                sprintf( &str, "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;");
            }
            strcpy( &GISMAN_CMD,  &str);
            n_entries = 0;
            while(fgets( &str, 2048, f_gisman) != 0) {
                n_entries = n_entries + 1;
            }
            if(n_entries == 0) {
L49:
                goto L51;
            }
            rewind(f_gisman);
            n_lines = 0;
            while(fgets( &str, 2048, f_in) != 0) {
                n_lines = n_lines + 1;
            }
            if(n_lines == 0) {
                goto L51;
            }
            n_lines_org = n_lines;
            rewind(f_in);
            line = calloc(n_entries + n_entries + n_lines + 6, 4);
            i = 0;
            while(n_entries + n_entries + n_lines + 6 > i) {
                line[i] = 0;
                i = i + 1;
            }
            i = 0;
            while(fgets( &str, 2048, f_in) != 0) {
                line[i] = malloc(strlen( &str) + 1);
                strcpy(line[i],  &str);
                i = i + 1;
            }
            check_ext_menu(line);
            i = 1;
            while(nc_fgets_nb( &str, 2048, f_gisman) != 0) {
                if(i != 1) {
L30:
                    line_no = new_item( &str,  &menu, line, line_no);
                    if(line_no >= 0) {
                        i = i + 1;
                        continue;
                    }
                    goto L31;
                }
                _t316 = strrchr( &str, 93);
                len = _t316 - strchr( &str, 91);
                strncpy( &menu,  &((strchr( &str, 91))[1]), len);
                 *(__ebp + len - 1 + -6156) = 0;
                line_no = new_submenu(_v6208,  &str, line);
                if(line_no >= 0) {
                    i = i + 1;
                    continue;
                }
                print_warning("no GIS Manager menu entries created.\n");
                break;
L31:
                print_warning("error creating GIS Manager menu entries.\n");
                break;
            }
            i = 0;
            while(line[i] != 0) {
                fprintf(f_out, line[i]);
                i = i + 1;
            }
            fflush(f_out);
            rewind(f_out);
            n_lines_new = 0;
            while(fgets( &str, 2048, f_out) != 0) {
                n_lines_new = n_lines_new + 1;
            }
            if(n_lines_new == 0 || n_lines_new < n_lines_org) {
                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                memcpy( &GISMAN_CMD, 134567714, 1);
            }
            fclose(f_in);
            fclose(f_gisman);
            fclose(f_out);
            i = 0;
            while(1) {
                _t395 = n_entries + n_entries + n_lines + 6 - i;
                if(_t395 <= 0) {
                    break;
                }
                free(line[i]);
                i = i + 1;
            }
            free(line);
            goto L51;
        }
        goto L4;
    }
    if( *(__errno_location()) == 2) {
L51:
        _t233 = _v16 ^  *gs:0x14];
        if(_t395 == 0) {
            return _t233;
        }
        __stack_chk_fail();
        return _t233;
    }
    fclose(f_gisman);
    _v6272 = strerror( *(__errno_location()));
    _v6276 =  &file;
    print_error(-21, "checking for file '%s': %s\n");
    goto L3;
L48:
    goto L51;
L4:
    if( *(__errno_location()) == 2) {
        goto L48;
    }
    fclose(f_in);
    _v6272 = strerror( *(__errno_location()));
    _v6276 =  &file;
    print_error(-21, "checking for file '%s': %s\n");
    goto L6;
}

register_entries_gisman2(char* pkg_short_name, char* gisbase)
{// addr = 0x0804CD6C  --  defined in 'reg_entries.c' at line 415
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    FILE* f_gisman2;      // _cfa_ffffefec
    intOrPtr _v4128;                       // _cfa_ffffefe0
    char* _v4132;                          // _cfa_ffffefdc
    intOrPtr _v4156;                       // _cfa_ffffefc4
    char* _v4160;                          // _cfa_ffffefc0
    char[2047]* _v4164;                    // _cfa_ffffefbc
    _unknown_ _v4168;                      // _cfa_ffffefb8
    _unknown_ __ebp;                       // r6
    _unknown_ _t40;                        // _t40
    _unknown_ _t43;                        // _t43
    _unknown_ _t49;                        // _t49
    _unknown_ _t51;                        // _t51
    signed int _t53;                       // _t53
    _unknown_ _t56;                        // _t56
    _unknown_ _t60;                        // _t60
    int _t74;                              // _t74

    _v4128 = _a4;
    _v4132 = _a8;
    _v16 =  *gs:0x14];
    memcpy( &file, "../entries-gisman2", 19);
    f_gisman2 = fopen( &file, "r");
    if(f_gisman2 != 0) {
L3:
        _t74 = VERBOSE;
        if(_t74 == 0) {
            _v4156 = _v4128;
            _v4160 = _v4132;
            _v4164 = _v4132;
            sprintf( &str, "mkdir -p %s/etc/gm/Xtns ; cp -f ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ");
        } else {
            _v4156 = _v4128;
            _v4160 = _v4132;
            _v4164 = _v4132;
            sprintf( &str, "mkdir --verbose -p %s/etc/gm/Xtns ; cp -fv ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ");
        }
        strcpy( &GISMAN2_CMD,  &str);
    } else {
        if( *(__errno_location()) == 2) {
        } else {
            fclose(f_gisman2);
            _v4160 = strerror( *(__errno_location()));
            _v4164 =  &file;
            print_error(-32, "checking for file '%s': %s\n");
            goto L3;
        }
    }
    _t53 = _v16 ^  *gs:0x14];
    if(_t74 != 0) {
        __stack_chk_fail();
        return _t53;
    }
    return _t53;
}

int deregister_entries_gisman(char* pkg_short_name, char* gisbase)
{// addr = 0x0804CEC7  --  defined in 'reg_entries.c' at line 461
    intOrPtr _v16;                         // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char[2047] tmp;                        // _cfa_ffffe7f0
    char** line;                           // _cfa_ffffe7ec
    int n_lines;                           // _cfa_ffffe7e8
    int i;                                 // _cfa_ffffe7e4
    int n_lines_org;                       // _cfa_ffffe7e0
    int n_lines_new;                       // _cfa_ffffe7dc
    FILE* f_in;           // _cfa_ffffe7d8
    FILE* f_out;          // _cfa_ffffe7d4
    int pos;                               // _cfa_ffffe7d0
    int start;                             // _cfa_ffffe7cc
    int end;                               // _cfa_ffffe7c8
    int start_sub;                         // _cfa_ffffe7c4
    int end_sub;                           // _cfa_ffffe7c0
    char* lq;                              // _cfa_ffffe7bc
    char* rq;                              // _cfa_ffffe7b8
    int num_removed;                       // _cfa_ffffe7b4
    char[2047]* _v6224;                    // _cfa_ffffe7b0
    char* _v6228;                          // _cfa_ffffe7ac
    char[2047]* _v6248;                    // _cfa_ffffe798
    char[2047]* _v6252;                    // _cfa_ffffe794
    char[2047]* _v6256;                    // _cfa_ffffe790
    char* _v6260;                          // _cfa_ffffe78c
    char[2047]* _v6264;                    // _cfa_ffffe788
    char[2047]* _v6268;                    // _cfa_ffffe784
    char* _v6272;                          // _cfa_ffffe780
    char[2047]* _v6276;                    // _cfa_ffffe77c
    char[2047]* _v6280;                    // _cfa_ffffe778
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t239;                       // _t239
    _unknown_ _t242;                       // _t242
    _unknown_ _t246;                       // _t246
    _unknown_ _t247;                       // _t247
    _unknown_ _t250;                       // _t250
    _unknown_ _t254;                       // _t254
    _unknown_ _t256;                       // _t256
    _unknown_ _t261;                       // _t261
    _unknown_ _t284;                       // _t284
    _unknown_ _t287;                       // _t287
    _unknown_ _t300;                       // _t300
    _unknown_ _t312;                       // _t312
    int _t318;                             // _t318
    _unknown_ _t330;                       // _t330
    _unknown_ _t333;                       // _t333
    _unknown_ _t339;                       // _t339
    _unknown_ _t358;                       // _t358
    _unknown_ _t360;                       // _t360
    _unknown_ _t362;                       // _t362
    _unknown_ _t367;                       // _t367
    _unknown_ _t369;                       // _t369
    _unknown_ _t376;                       // _t376
    _unknown_ _t378;                       // _t378
    _unknown_ _t379;                       // _t379
    _unknown_ _t380;                       // _t380
    _unknown_ _t386;                       // _t386
    _unknown_ _t391;                       // _t391
    _unknown_ _t398;                       // _t398
    _unknown_ _t425;                       // _t425
    _unknown_ _t435;                       // _t435

    _v6224 = _a4;
    _v6228 = _a8;
    _v16 =  *gs:0x14];
    _v6276 = _v6228;
    sprintf( &file, "%s/etc/dm/menu.tcl");
    f_in = fopen( &file, "r");
    if(f_in != 0) {
L4:
        memcpy( &TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp( &TMP_GISMAN);
        f_out = fopen( &TMP_GISMAN, "w+");
        if(f_out == 0) {
            _v6272 = strerror( *(__errno_location()));
            _v6276 =  &TMP_GISMAN;
            print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        atexit(exit_db);
        if(VERBOSE == 0) {
            _v6248 =  &TMP_NULL;
            _v6252 = _v6228;
            _v6256 =  &TMP_NULL;
            _v6260 = _v6228;
            _v6264 =  &TMP_GISMAN;
            _v6268 =  &TMP_NULL;
            _v6272 = _v6228;
            _v6276 = _v6228;
            sprintf( &str, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;");
        } else {
            _v6260 = _v6228;
            _v6264 = _v6228;
            _v6268 =  &TMP_GISMAN;
            _v6272 = _v6228;
            _v6276 = _v6228;
            sprintf( &str, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;");
        }
        strcpy( &GISMAN_CMD,  &str);
        n_lines = 0;
        while(fgets( &str, 2048, f_in) != 0) {
            n_lines = n_lines + 1;
        }
        if(n_lines != 0) {
            rewind(f_in);
            n_lines_org = n_lines;
            line = calloc(n_lines + 1, 4);
            i = 0;
L16:
            while(n_lines + 1 > i) {
                goto L15;
            }
            i = 0;
            while(fgets( &str, 2048, f_in) != 0) {
                line[i] = malloc(strlen( &str) + 1);
                strcpy(line[i],  &str);
                i = i + 1;
            }
            _v6276 = _v6224;
            sprintf( &str, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad");
            pos = find_pos( &str, line, 0);
            if(pos != 255) {
                lq = strchr(line[pos], 34);
                lq =  &(lq[1]);
                rq = strchr(lq, 34);
                strcpy( &tmp, lq);
                 *(__ebp + rq - lq + -6156) = 0;
                start = find_pos(""&Xtns" all options 1", line, 0);
                end = find_pos("" all options", line, start + 1) - 1;
                if(end == 255) {
                    end = find_pos("}]", line, 0);
                }
                if(start != 255) {
                    _v6276 =  &tmp;
                    sprintf( &str, "{cascad "%s"");
                    start_sub = find_pos( &str, line, start);
                    if(start_sub == 255 || start_sub > end) {
                        _v6280 =  &tmp;
                        print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n");
                        _t318 = -1;
                        goto L51;
                    }
                    end_sub = find_pos(" \t\t\t}}", line, start_sub);
                    if(end_sub == 255 || end_sub > end) {
                        _v6280 =  &tmp;
                        print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n");
                        _t318 = -1;
                        goto L51;
                    }
                    num_removed = 0;
                    i = 0;
                    while(end_sub - start_sub + 1 > i) {
                        delete_str(start_sub, line);
                        num_removed = num_removed + 1;
                        i = i + 1;
                    }
                    _v6276 = _v6224;
                    sprintf( &str, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad");
                    pos = find_pos( &str, line, 0);
                    delete_str(pos, line);
                    num_removed = num_removed + 1;
                    start = find_pos(""&Xtns" all options 1", line, 0);
                    end = find_pos("" all options", line, start + 1) - 1;
                    if(end - start > 2) {
L39:
                        i = 0;
L41:
                        while(line[i] != 0) {
                            goto L40;
                        }
                        fflush(f_out);
                        rewind(f_out);
                        n_lines_new = 0;
                        while(fgets( &str, 2048, f_out) != 0) {
                            n_lines_new = n_lines_new + 1;
                        }
                        if(n_lines_new == 0) {
                            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                            memcpy( &GISMAN_CMD, 134567714, 1);
                        }
                        fclose(f_in);
                        fclose(f_out);
                        i = 0;
                        while(n_lines + 1 > i) {
                            free(line[i]);
                            i = i + 1;
                        }
                        free(line);
                        _t318 = num_removed;
                        goto L51;
                    }
                    i = 0;
                    while(end - start + 1 > i) {
                        delete_str(start, line);
                        num_removed = num_removed + 1;
                        i = i + 1;
                    }
                    goto L39;
L40:
                    fprintf(f_out, line[i]);
                    i = i + 1;
                    goto L41;
                }
                print_warning("menu 'Xtns' does not exist.\n");
                _t318 = -1;
                goto L51;
            }
            print_warning("could not find uninstall information in 'menu.tcl'.\n");
            _t318 = -1;
            goto L51;
        }
        _t318 = -1;
        goto L51;
L15:
        line[i] = 0;
        i = i + 1;
        goto L16;
    }
    _t435 =  *(__errno_location()) - 2;
    if(_t435 != 0) {
        fclose(f_in);
        _v6272 = strerror( *(__errno_location()));
        _v6276 =  &file;
        print_error(-22, "checking for file '%s': %s\n");
        goto L4;
    } else {
        _t318 = 0;
    }
L51:
    if(_t435 == 0) {
        return _t318;
    }
    __stack_chk_fail();
    return _t318;
}

deregister_entries_gisman2(char* pkg_short_name, char* gisbase)
{// addr = 0x0804D743  --  defined in 'reg_entries.c' at line 653
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    FILE* f_gisman2;      // _cfa_ffffefec
    char* _v4128;                          // _cfa_ffffefe0
    char[2047]* _v4132;                    // _cfa_ffffefdc
    char* _v4144;                          // _cfa_ffffefd0
    char[2047]* _v4148;                    // _cfa_ffffefcc
    _unknown_ _v4152;                      // _cfa_ffffefc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t39;                        // _t39
    _unknown_ _t42;                        // _t42
    _unknown_ _t48;                        // _t48
    _unknown_ _t50;                        // _t50
    signed int _t52;                       // _t52
    _unknown_ _t55;                        // _t55
    _unknown_ _t59;                        // _t59
    int _t73;                              // _t73

    _v4128 = _a4;
    _v4132 = _a8;
    _v16 =  *gs:0x14];
    _v4144 = _v4128;
    _v4148 = _v4132;
    sprintf( &file, "%s/etc/gm/Xtns/%s.gem");
    f_gisman2 = fopen( &file, "r");
    if(f_gisman2 != 0) {
L3:
        _t73 = VERBOSE;
        if(_t73 == 0) {
            _v4144 = _v4128;
            _v4148 = _v4132;
            sprintf( &str, "rm -f %s/etc/gm/Xtns/%s.gem ; ");
        } else {
            _v4144 = _v4128;
            _v4148 = _v4132;
            sprintf( &str, "rm -vf %s/etc/gm/Xtns/%s.gem ; ");
        }
        strcpy( &GISMAN_CMD,  &str);
    } else {
        if( *(__errno_location()) == 2) {
        } else {
            fclose(f_gisman2);
            _v4144 = strerror( *(__errno_location()));
            _v4148 =  &file;
            print_error(-33, "checking for file '%s': %s\n");
            goto L3;
        }
    }
    _t52 = _v16 ^  *gs:0x14];
    if(_t73 != 0) {
        __stack_chk_fail();
        return _t52;
    }
    return _t52;
}

int restore_entries_gisman(char* gisbase)
{// addr = 0x0804D896  --  defined in 'reg_entries.c' at line 692
    intOrPtr _v16;                         // _cfa_fffffff0
    char[2047] str;                        // _cfa_fffff7f0
    char[2047] menu;                       // _cfa_ffffeff0
    char[2047] file;                       // _cfa_ffffe7f0
    char[2047] dir;                        // _cfa_ffffdff0
    char[2047] pkg_short_name;             // _cfa_ffffd7f0
    int len;                               // _cfa_ffffd7ec
    char** line;                           // _cfa_ffffd7e8
    int n_entries;                         // _cfa_ffffd7e4
    int n_lines;                           // _cfa_ffffd7e0
    int i;                                 // _cfa_ffffd7dc
    int line_no;                           // _cfa_ffffd7d8
    FILE* f_gisman;       // _cfa_ffffd7d4
    FILE* f_in;           // _cfa_ffffd7d0
    FILE* f_out;          // _cfa_ffffd7cc
    DIR* dirp;             // _cfa_ffffd7c8
    struct dirent* ep;   // _cfa_ffffd7c4
    int num_restored;                      // _cfa_ffffd7c0
    int n_files;                           // _cfa_ffffd7bc
    char[2047]* _v10320;                   // _cfa_ffffd7b0
    char[2047]* _v10344;                   // _cfa_ffffd798
    char[2047]* _v10348;                   // _cfa_ffffd794
    char[2047]* _v10352;                   // _cfa_ffffd790
    char[2047]* _v10356;                   // _cfa_ffffd78c
    char[2047]* _v10360;                   // _cfa_ffffd788
    char[2047]* _v10364;                   // _cfa_ffffd784
    char** _v10368;                        // _cfa_ffffd780
    char[2047]* _v10372;                   // _cfa_ffffd77c
    _unknown_ _v10376;                     // _cfa_ffffd778
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t230;                       // _t230
    _unknown_ _t233;                       // _t233
    _unknown_ _t237;                       // _t237
    _unknown_ _t238;                       // _t238
    _unknown_ _t241;                       // _t241
    _unknown_ _t245;                       // _t245
    _unknown_ _t247;                       // _t247
    _unknown_ _t250;                       // _t250
    DIR* _t251;            // _t251
    struct dirent* _t252;   // _t252
    _unknown_ _t256;                       // _t256
    _unknown_ _t263;                       // _t263
    _unknown_ _t268;                       // _t268
    _unknown_ _t274;                       // _t274
    _unknown_ _t306;                       // _t306
    _unknown_ _t311;                       // _t311
    DIR* _t312;            // _t312
    struct dirent* _t313;   // _t313
    _unknown_ _t317;                       // _t317
    char* _t335;                           // _t335
    _unknown_ _t343;                       // _t343
    _unknown_ _t351;                       // _t351
    _unknown_ _t362;                       // _t362
    _unknown_ _t364;                       // _t364
    _unknown_ _t366;                       // _t366
    _unknown_ _t368;                       // _t368
    _unknown_ _t380;                       // _t380
    _unknown_ _t382;                       // _t382
    int _t383;                             // _t383
    _unknown_ _t386;                       // _t386
    _unknown_ _t393;                       // _t393
    _unknown_ _t423;                       // _t423
    _unknown_ _t432;                       // _t432

    _v10320 = _a4;
    _v16 =  *gs:0x14];
    _v10372 = _v10320;
    sprintf( &file, "%s/etc/dm/menu.tcl");
    f_in = fopen( &file, "r");
    if(f_in != 0) {
L4:
        memcpy( &TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp( &TMP_GISMAN);
        f_out = fopen( &TMP_GISMAN, "w+");
        if(f_out == 0) {
            _v10368 = strerror( *(__errno_location()));
            _v10372 =  &TMP_GISMAN;
            print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        atexit(exit_db);
        if(VERBOSE == 0) {
            _v10344 =  &TMP_NULL;
            _v10348 = _v10320;
            _v10352 =  &TMP_NULL;
            _v10356 = _v10320;
            _v10360 =  &TMP_GISMAN;
            _v10364 =  &TMP_NULL;
            _v10368 = _v10320;
            _v10372 = _v10320;
            sprintf( &str, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;");
        } else {
            _v10356 = _v10320;
            _v10360 = _v10320;
            _v10364 =  &TMP_GISMAN;
            _v10368 = _v10320;
            _v10372 = _v10320;
            sprintf( &str, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;");
        }
        strcpy( &GISMAN_CMD,  &str);
        _v10372 = _v10320;
        sprintf( &dir, "%s/etc/dm/gem-entries");
        _t251 =  &dir;
         *__esp = _t251;
        opendir();
        dirp = _t251;
        if(dirp != 0) {
            n_entries = 0;
            n_files = 0;
            while(1) {
L21:
                _t252 = dirp;
                 *__esp = _t252;
                readdir();
                ep = _t252;
                if(ep == 0) {
                    break;
                }
                goto L12;
            }
             *__esp = dirp;
            closedir();
            n_lines = 0;
            while(fgets( &str, 2048, f_in) != 0) {
                n_lines = n_lines + 1;
            }
            if(n_lines != 0) {
                rewind(f_in);
                line = calloc(n_entries + n_entries + (n_files << 2) + n_files + n_lines + 1, 4);
                i = 0;
L29:
                while(n_entries + n_entries + (n_files << 2) + n_files + n_lines + 1 > i) {
                    goto L28;
                }
                i = 0;
                while(fgets( &str, 2048, f_in) != 0) {
                    line[i] = malloc(strlen( &str) + 1);
                    strcpy(line[i],  &str);
                    i = i + 1;
                }
                line[i] = 0;
                check_ext_menu(line);
                _t312 =  &dir;
                 *__esp = _t312;
                opendir();
                dirp = _t312;
                num_restored = 0;
                while(1) {
L51:
                    _t313 = dirp;
                     *__esp = _t313;
                    readdir();
                    ep = _t313;
                    if(ep == 0) {
                        break;
                    }
                    _v10368 =  &(ep->d_name);
                    _v10372 =  &dir;
                    sprintf( &file, "%s/%s");
                    if(strcmp( &(ep->d_name), ".") == 0) {
                        continue;
                    }
                    if(strcmp( &(ep->d_name), "..") == 0) {
                        goto L49;
                    }
                    f_gisman = fopen( &file, "r");
                    if(f_gisman == 0) {
                        goto L50;
                    }
                    i = 1;
                    while(nc_fgets_nb( &str, 2048, f_gisman) != 0) {
                        if(i != 1) {
                            line_no = new_item( &str,  &menu, line, line_no);
                            if(line_no >= 0) {
                                goto L46;
                            }
                            goto L42;
                        }
                        _t335 = strrchr( &str, 93);
                        len = _t335 - strchr( &str, 91);
                        strncpy( &menu,  &((strchr( &str, 91))[1]), len);
                         *(__ebp + len - 1 + -4108) = 0;
                        line_no = new_submenu( &pkg_short_name,  &str, line);
                        if(line_no >= 0) {
L47:
                            fclose(f_gisman);
                            goto L51;
                        }
                        i = i + 1;
                        num_restored = num_restored + 1;
                        continue;
L46:
                        goto L47;
L42:
                        i = i + 1;
                        num_restored = num_restored + 1;
                    }
                    goto L47;
L50:
L49:
                }
                 *__esp = dirp;
                closedir();
                i = 0;
                while(line[i] != 0) {
                    fprintf(f_out, line[i]);
                    i = i + 1;
                }
                fflush(f_out);
                fclose(f_in);
                fclose(f_out);
                i = 0;
                while(n_entries + n_entries + (n_files << 2) + n_files + n_lines + 1 > i) {
                    free(line[i]);
                    i = i + 1;
                }
                free(line);
                _t383 = num_restored;
                goto L59;
            }
            _t383 = 0;
            goto L59;
L28:
            line[i] = 0;
            i = i + 1;
            goto L29;
        } else {
            _t383 = 0;
L59:
            if(_t432 == 0) {
                return _t383;
            }
            __stack_chk_fail();
            return _t383;
        }
L12:
        _v10368 =  &(ep->d_name);
        _v10372 =  &dir;
        sprintf( &file, "%s/%s");
        f_gisman = fopen( &file, "r");
        if(strcmp( &(ep->d_name), ".") == 0 || strcmp( &(ep->d_name), "..") == 0) {
            fclose(f_gisman);
            goto L21;
        }
        if(f_gisman != 0) {
            while(1) {
                fgets( &str, 2048, f_gisman);
                if( &str == 0) {
                    break;
                }
                n_entries = n_entries + 1;
            }
            n_files = n_files + 1;
            fclose(f_gisman);
            goto L21;
        }
        fclose(f_gisman);
        goto L21;
    }
    _t432 =  *(__errno_location()) - 2;
    if(_t432 != 0) {
        fclose(f_in);
        _v10368 = strerror( *(__errno_location()));
        _v10372 =  &file;
        print_error(-21, "checking for file '%s': %s\n");
        goto L4;
    }
    _t383 = 0;
    goto L59;
}

new_ext_html(char* ext, char* gisbase, char** html, int major, int minor, int revision)
{// addr = 0x0804E100  --  defined in 'reg_html.c' at line 29
    signed int _v16;                       // _cfa_fffffff0
    char[2047] item;                       // _cfa_fffff7f0
    int pos1;                              // _cfa_fffff7ec
    int pos2;                              // _cfa_fffff7e8
    int pos3;                              // _cfa_fffff7e4
    int start;                             // _cfa_fffff7e0
    int end;                               // _cfa_fffff7dc
    int insert_here;                       // _cfa_fffff7d8
    char* first_char;                      // _cfa_fffff7d4
    char* last_char;                       // _cfa_fffff7d0
    int len;                               // _cfa_fffff7cc
    char* _v2112;                          // _cfa_fffff7c0
    intOrPtr _v2116;                       // _cfa_fffff7bc
    char** _v2120;                         // _cfa_fffff7b8
    int _v2132;                            // _cfa_fffff7ac
    int _v2136;                            // _cfa_fffff7a8
    int _v2140;                            // _cfa_fffff7a4
    char* _v2144;                          // _cfa_fffff7a0
    char* _v2148;                          // _cfa_fffff79c
    char* _v2152;                          // _cfa_fffff798
    _unknown_ __ebp;                       // r6
    _unknown_ _t148;                       // _t148
    _unknown_ _t167;                       // _t167
    _unknown_ _t177;                       // _t177
    _unknown_ _t181;                       // _t181
    signed int _t183;                      // _t183
    _unknown_ _t199;                       // _t199
    _unknown_ _t214;                       // _t214
    _unknown_ _t219;                       // _t219
    _unknown_ _t222;                       // _t222
    _unknown_ _t225;                       // _t225
    _unknown_ _t228;                       // _t228
    _unknown_ _t231;                       // _t231
    int _t255;                             // _t255

    _v2112 = _a4;
    _v2116 = _a8;
    _v2120 = _a12;
    _v16 =  *gs:0x14];
    pos1 = find_pos("<b>Drivers sections:</b>", _v2120, 0);
    if(pos1 >= 0) {
L3:
        pos2 = find_pos("<hr>", _v2120, pos1);
        if(find_pos("<h3>Installed extensions:</h3>", _v2120, pos1) == 255) {
            insert_str("<h3>Installed extensions:</h3>\n", pos2, _v2120);
            insert_str("<ul>\n", pos2 + 1, _v2120);
            insert_str("</ul>\n", pos2 + 2, _v2120);
            insert_str("<p>\n", pos2 + 3, _v2120);
        }
        start = find_pos("<h3>Installed extensions:</h3>", _v2120, pos1);
        end = find_pos("</ul>", _v2120, start);
        insert_here = start + 2;
        _v2148 = _v2112;
        sprintf( &item, "">%s");
        pos3 = find_pos( &item, _v2120, insert_here);
        if(pos3 == 255) {
            pos3 = find_pos("<li><a href=", _v2120, start);
            while(pos3 != 255 && pos3 < end) {
                first_char = strrchr(_v2120[pos3], 34);
                last_char = strrchr(_v2120[pos3], 60);
                len = last_char - first_char;
                strncpy( &item,  &(first_char[2]), len);
                 *(__ebp + len - 1 + -2060) = 0;
                if(strcmp(_v2112,  &item) >= 0) {
                    start = start + 1;
                    pos3 = find_pos("<li><a href=", _v2120, start);
                    continue;
                }
                insert_here = pos3;
                break;
            }
            _v2132 = revision;
            _v2136 = minor;
            _v2140 = major;
            _v2144 = _v2112;
            _v2148 = _v2112;
            sprintf( &item, "<li><a href="../extensions/%s/index.html">%s (%i.%i.%i)</a>\n");
            insert_str( &item, insert_here, _v2120);
        } else {
            _v2152 = _v2112;
            print_warning("list item '%s' exists in index.html.\n");
            if(FORCE != 0) {
                if(UPGRADE != 0) {
                    _v2132 = revision;
                    _v2136 = minor;
                    _v2140 = major;
                    _v2144 = _v2112;
                    _v2148 = _v2112;
                    sprintf( &item, "<li><a href="../extensions/%s/index.html">%s (%i.%i.%i)</a>\n");
                    strcpy(_v2120[pos3],  &item);
                }
            }
        }
        goto L18;
    }
    pos1 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", _v2120, 0);
    _t255 = pos1;
    if(_t255 >= 0) {
        goto L3;
    } else {
        print_warning("Unknown format of index.html. Unable to register HTML man pages.\n");
    }
L18:
    _t183 = _v16 ^  *gs:0x14];
    if(_t255 == 0) {
        return _t183;
    }
    __stack_chk_fail();
    return _t183;
}

delete_ext_html(char* ext, char* gisbase, char** html)
{// addr = 0x0804E56F  --  defined in 'reg_html.c' at line 110
    signed int _v16;                       // _cfa_fffffff0
    char[2047] item;                       // _cfa_fffff7f0
    int pos1;                              // _cfa_fffff7ec
    int pos2;                              // _cfa_fffff7e8
    int pos3;                              // _cfa_fffff7e4
    int start;                             // _cfa_fffff7e0
    int end;                               // _cfa_fffff7dc
    int found;                             // _cfa_fffff7d8
    int i;                                 // _cfa_fffff7d4
    intOrPtr _v2096;                       // _cfa_fffff7d0
    intOrPtr _v2100;                       // _cfa_fffff7cc
    char** _v2104;                         // _cfa_fffff7c8
    intOrPtr _v2116;                       // _cfa_fffff7bc
    intOrPtr _v2120;                       // _cfa_fffff7b8
    _unknown_ __ebp;                       // r6
    _unknown_ _t81;                        // _t81
    _unknown_ _t98;                        // _t98
    signed int _t108;                      // _t108
    _unknown_ _t114;                       // _t114
    _unknown_ _t117;                       // _t117
    int _t127;                             // _t127

    _v2096 = _a4;
    _v2100 = _a8;
    _v2104 = _a12;
    _v16 =  *gs:0x14];
    pos1 = find_pos("<b>Drivers sections:</b>", _v2104, 0);
    if(pos1 >= 0) {
L3:
        pos2 = find_pos("<hr>", _v2104, pos1);
        if(find_pos("<h3>Installed extensions:</h3>", _v2104, pos1) != 255) {
            start = find_pos("<h3>Installed extensions:</h3>", _v2104, pos1);
            end = find_pos("</ul>", _v2104, start);
            found = 0;
            _v2116 = _v2096;
            sprintf( &item, "">%s");
            pos3 = find_pos( &item, _v2104, start);
            if(pos3 != 255) {
                if(pos3 < end) {
                    delete_str(pos3, _v2104);
                }
                end = end - 1;
                pos3 = find_pos("<ul>", _v2104, start);
                if(pos3 == 255 || end <= pos3 || end - pos3 > 1) {
                } else {
                    i = 0;
                    while(i <= 3) {
                        delete_str(pos3 - 1, _v2104);
                        i = i + 1;
                    }
                }
                goto L15;
            }
            goto L6;
        }
        goto L4;
L6:
        _v2120 = _v2096;
        print_warning("extension '%s' not listed in index.html.\n");
        goto L15;
    }
    pos1 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", _v2104, 0);
    _t127 = pos1;
    if(_t127 >= 0) {
        goto L3;
    } else {
        print_warning("Unknown format of index.html. Unable to de-register HTML man pages.\n");
    }
L15:
    _t108 = _v16 ^  *gs:0x14];
    if(_t127 == 0) {
        return _t108;
    }
    __stack_chk_fail();
    return _t108;
L4:
    print_warning("no extensions section found in index.html.\n");
    goto L15;
}

register_html(char* pkg_short_name, char* gisbase, int major, int minor, int revision)
{// addr = 0x0804E7F3  --  defined in 'reg_html.c' at line 169
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char** line;                           // _cfa_ffffefec
    int n_lines;                           // _cfa_ffffefe8
    int i;                                 // _cfa_ffffefe4
    FILE* f_in;           // _cfa_ffffefe0
    FILE* f_out;          // _cfa_ffffefdc
    char* _v4144;                          // _cfa_ffffefd0
    char[2047]* _v4148;                    // _cfa_ffffefcc
    char[2047]* _v4164;                    // _cfa_ffffefbc
    char* _v4168;                          // _cfa_ffffefb8
    char[2047]* _v4172;                    // _cfa_ffffefb4
    char[2047]* _v4176;                    // _cfa_ffffefb0
    char[2047]* _v4180;                    // _cfa_ffffefac
    _unknown_ _v4184;                      // _cfa_ffffefa8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t113;                       // _t113
    _unknown_ _t116;                       // _t116
    _unknown_ _t120;                       // _t120
    _unknown_ _t121;                       // _t121
    _unknown_ _t124;                       // _t124
    _unknown_ _t128;                       // _t128
    _unknown_ _t130;                       // _t130
    _unknown_ _t135;                       // _t135
    _unknown_ _t157;                       // _t157
    _unknown_ _t173;                       // _t173
    _unknown_ _t175;                       // _t175
    _unknown_ _t177;                       // _t177
    _unknown_ _t179;                       // _t179
    _unknown_ _t186;                       // _t186
    _unknown_ _t188;                       // _t188
    signed int _t190;                      // _t190
    _unknown_ _t193;                       // _t193
    _unknown_ _t200;                       // _t200
    _unknown_ _t224;                       // _t224

    _v4144 = _a4;
    _v4148 = _a8;
    _v16 =  *gs:0x14];
    _v4180 = _v4148;
    sprintf( &file, "%s/docs/html/index.html");
    f_in = fopen( &file, "r");
    if(f_in != 0) {
L3:
        memcpy( &TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp( &TMP_HTML);
        f_out = fopen( &TMP_HTML, "w+");
        if(f_out == 0) {
            _v4176 = strerror( *(__errno_location()));
            _v4180 =  &TMP_HTML;
            print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        atexit(exit_db);
        if(VERBOSE == 0) {
            _v4164 =  &TMP_NULL;
            _v4168 = _v4148;
            _v4172 =  &TMP_NULL;
            _v4176 = _v4148;
            _v4180 =  &TMP_HTML;
            sprintf( &str, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;");
        } else {
            _v4172 = _v4148;
            _v4176 = _v4148;
            _v4180 =  &TMP_HTML;
            sprintf( &str, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;");
        }
        strcpy( &HTML_CMD,  &str);
        n_lines = 0;
        while(fgets( &str, 2048, f_in) != 0) {
            n_lines = n_lines + 1;
        }
        if(n_lines != 0) {
            rewind(f_in);
            line = calloc(n_lines + 10, 4);
            i = 0;
            while(n_lines + 10 > i) {
                line[i] = 0;
                i = i + 1;
            }
            i = 0;
            while(fgets( &str, 2048, f_in) != 0) {
                line[i] = malloc(strlen( &str) + 1);
                strcpy(line[i],  &str);
                i = i + 1;
            }
            new_ext_html(_v4144, _v4148, line, major, minor, revision);
            i = 0;
            while(line[i] != 0) {
                fprintf(f_out, line[i]);
                i = i + 1;
            }
            fflush(f_out);
            fclose(f_in);
            fclose(f_out);
            i = 0;
            while(1) {
                _t224 = n_lines + 10 - i;
                if(_t224 <= 0) {
                    break;
                }
                free(line[i]);
                i = i + 1;
            }
            free(line);
        }
L27:
        _t190 = _v16 ^  *gs:0x14];
        if(_t224 != 0) {
            __stack_chk_fail();
            return _t190;
        }
        return _t190;
    }
    if( *(__errno_location()) == 2) {
    } else {
        fclose(f_in);
        _v4176 = strerror( *(__errno_location()));
        _v4180 =  &file;
        print_error(-24, "checking for file '%s': %s\n");
        goto L3;
    }
    goto L27;
}

deregister_html(char* pkg_short_name, char* gisbase)
{// addr = 0x0804EC17  --  defined in 'reg_html.c' at line 271
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    char[2047] str;                        // _cfa_ffffeff0
    char** line;                           // _cfa_ffffefec
    int n_lines;                           // _cfa_ffffefe8
    int i;                                 // _cfa_ffffefe4
    FILE* f_in;           // _cfa_ffffefe0
    FILE* f_out;          // _cfa_ffffefdc
    char* _v4144;                          // _cfa_ffffefd0
    char[2047]* _v4148;                    // _cfa_ffffefcc
    char[2047]* _v4164;                    // _cfa_ffffefbc
    char* _v4168;                          // _cfa_ffffefb8
    char[2047]* _v4172;                    // _cfa_ffffefb4
    char[2047]* _v4176;                    // _cfa_ffffefb0
    char[2047]* _v4180;                    // _cfa_ffffefac
    _unknown_ _v4184;                      // _cfa_ffffefa8
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t107;                       // _t107
    _unknown_ _t110;                       // _t110
    _unknown_ _t114;                       // _t114
    _unknown_ _t115;                       // _t115
    _unknown_ _t118;                       // _t118
    _unknown_ _t122;                       // _t122
    _unknown_ _t124;                       // _t124
    _unknown_ _t129;                       // _t129
    _unknown_ _t151;                       // _t151
    _unknown_ _t164;                       // _t164
    _unknown_ _t166;                       // _t166
    _unknown_ _t168;                       // _t168
    _unknown_ _t170;                       // _t170
    _unknown_ _t177;                       // _t177
    _unknown_ _t179;                       // _t179
    signed int _t181;                      // _t181
    _unknown_ _t184;                       // _t184
    _unknown_ _t191;                       // _t191
    _unknown_ _t215;                       // _t215

    _v4144 = _a4;
    _v4148 = _a8;
    _v16 =  *gs:0x14];
    _v4180 = _v4148;
    sprintf( &file, "%s/docs/html/index.html");
    f_in = fopen( &file, "r");
    if(f_in != 0) {
L3:
        memcpy( &TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp( &TMP_HTML);
        f_out = fopen( &TMP_HTML, "w+");
        if(f_out == 0) {
            _v4176 = strerror( *(__errno_location()));
            _v4180 =  &TMP_HTML;
            print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        atexit(exit_db);
        if(VERBOSE == 0) {
            _v4164 =  &TMP_NULL;
            _v4168 = _v4148;
            _v4172 =  &TMP_NULL;
            _v4176 = _v4148;
            _v4180 =  &TMP_HTML;
            sprintf( &str, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;");
        } else {
            _v4172 = _v4148;
            _v4176 = _v4148;
            _v4180 =  &TMP_HTML;
            sprintf( &str, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;");
        }
        strcpy( &HTML_CMD,  &str);
        n_lines = 0;
        while(fgets( &str, 2048, f_in) != 0) {
            n_lines = n_lines + 1;
        }
        if(n_lines != 0) {
            rewind(f_in);
            line = calloc(n_lines + 1, 4);
            i = 0;
            while(n_lines + 1 > i) {
                line[i] = 0;
                i = i + 1;
            }
            i = 0;
            while(fgets( &str, 2048, f_in) != 0) {
                line[i] = malloc(strlen( &str) + 1);
                strcpy(line[i],  &str);
                i = i + 1;
            }
            delete_ext_html(_v4144, _v4148, line);
            i = 0;
            while(line[i] != 0) {
                fprintf(f_out, line[i]);
                i = i + 1;
            }
            fflush(f_out);
            fclose(f_in);
            fclose(f_out);
            i = 0;
            while(1) {
                _t215 = n_lines + 1 - i;
                if(_t215 <= 0) {
                    break;
                }
                free(line[i]);
                i = i + 1;
            }
            free(line);
        }
L27:
        _t181 = _v16 ^  *gs:0x14];
        if(_t215 != 0) {
            __stack_chk_fail();
            return _t181;
        }
        return _t181;
    }
    if( *(__errno_location()) == 2) {
    } else {
        fclose(f_in);
        _v4176 = strerror( *(__errno_location()));
        _v4180 =  &file;
        print_error(-24, "checking for file '%s': %s\n");
        goto L3;
    }
    goto L27;
}

int restore_html(char* gisbase)
{// addr = 0x0804F026  --  defined in 'reg_html.c' at line 374
    intOrPtr _v16;                         // _cfa_fffffff0
    char[2047] str;                        // _cfa_fffff7f0
    char[2047] idx;                        // _cfa_ffffeff0
    char[2047] ext_idx;                    // _cfa_ffffe7f0
    char[2047] dir;                        // _cfa_ffffdff0
    char[2047] subdir;                     // _cfa_ffffd7f0
    char** line;                           // _cfa_ffffd7ec
    int n_entries;                         // _cfa_ffffd7e8
    int n_lines;                           // _cfa_ffffd7e4
    int i;                                 // _cfa_ffffd7e0
    FILE* f_in;           // _cfa_ffffd7dc
    FILE* f_out;          // _cfa_ffffd7d8
    FILE* f_ext;          // _cfa_ffffd7d4
    DIR* dirp;             // _cfa_ffffd7d0
    DIR* subdirp;          // _cfa_ffffd7cc
    struct dirent* ep;   // _cfa_ffffd7c8
    int num_restored;                      // _cfa_ffffd7c4
    int n_subdirs;                         // _cfa_ffffd7c0
    int major;                             // _cfa_ffffd7bc
    int minor;                             // _cfa_ffffd7b8
    int revision;                          // _cfa_ffffd7b4
    char[2047]* _v10320;                   // _cfa_ffffd7b0
    char[2047]* _v10340;                   // _cfa_ffffd79c
    char* _v10344;                         // _cfa_ffffd798
    char[2047]* _v10348;                   // _cfa_ffffd794
    char** _v10352;                        // _cfa_ffffd790
    char[2047]* _v10356;                   // _cfa_ffffd78c
    char* _v10360;                         // _cfa_ffffd788
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t204;                       // _t204
    _unknown_ _t207;                       // _t207
    _unknown_ _t211;                       // _t211
    _unknown_ _t212;                       // _t212
    _unknown_ _t218;                       // _t218
    _unknown_ _t220;                       // _t220
    _unknown_ _t221;                       // _t221
    _unknown_ _t224;                       // _t224
    DIR* _t225;            // _t225
    struct dirent* _t226;   // _t226
    _unknown_ _t230;                       // _t230
    DIR* _t237;            // _t237
    _unknown_ _t244;                       // _t244
    _unknown_ _t268;                       // _t268
    DIR* _t272;            // _t272
    struct dirent* _t273;   // _t273
    _unknown_ _t277;                       // _t277
    DIR* _t284;            // _t284
    _unknown_ _t288;                       // _t288
    char* _t297;                           // _t297
    _unknown_ _t305;                       // _t305
    _unknown_ _t316;                       // _t316
    _unknown_ _t318;                       // _t318
    _unknown_ _t320;                       // _t320
    _unknown_ _t322;                       // _t322
    _unknown_ _t330;                       // _t330
    _unknown_ _t332;                       // _t332
    int _t333;                             // _t333
    _unknown_ _t336;                       // _t336
    _unknown_ _t343;                       // _t343
    _unknown_ _t368;                       // _t368
    _unknown_ _t376;                       // _t376

    _v10320 = _a4;
    _v16 =  *gs:0x14];
    _v10356 = _v10320;
    sprintf( &idx, "%s/docs/html/index.html");
    f_in = fopen( &idx, "r");
    if(f_in != 0) {
L4:
        memcpy( &TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp( &TMP_HTML);
        f_out = fopen( &TMP_HTML, "w+");
        if(f_out == 0) {
            _v10352 = strerror( *(__errno_location()));
            _v10356 =  &TMP_HTML;
            print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n");
        }
        if(VERBOSE == 0) {
            _v10340 =  &TMP_NULL;
            _v10344 = _v10320;
            _v10348 =  &TMP_NULL;
            _v10352 = _v10320;
            _v10356 =  &TMP_HTML;
            sprintf( &str, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;");
        } else {
            _v10348 = _v10320;
            _v10352 = _v10320;
            _v10356 =  &TMP_HTML;
            sprintf( &str, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;");
        }
        strcpy( &HTML_CMD,  &str);
        atexit(exit_db);
        _v10356 = _v10320;
        sprintf( &dir, "%s/docs/extensions");
        _t225 =  &dir;
         *__esp = _t225;
        opendir();
        dirp = _t225;
        if(dirp != 0) {
            n_entries = 0;
            n_subdirs = 0;
            while(1) {
L19:
                _t226 = dirp;
                 *__esp = _t226;
                readdir();
                ep = _t226;
                if(ep == 0) {
                    break;
                }
                goto L12;
            }
             *__esp = dirp;
            closedir();
            n_lines = 0;
            while(fgets( &str, 2048, f_in) != 0) {
                n_lines = n_lines + 1;
            }
            if(n_lines != 0) {
                rewind(f_in);
                line = calloc(n_lines + n_subdirs + 10, 4);
                i = 0;
L27:
                while(n_lines + n_subdirs + 10 > i) {
                    goto L26;
                }
                i = 0;
                while(fgets( &str, 2048, f_in) != 0) {
                    line[i] = malloc(strlen( &str) + 1);
                    strcpy(line[i],  &str);
                    i = i + 1;
                }
                line[i] = 0;
                _t272 =  &dir;
                 *__esp = _t272;
                opendir();
                dirp = _t272;
                num_restored = 0;
                while(1) {
                    _t273 = dirp;
                     *__esp = _t273;
                    readdir();
                    ep = _t273;
                    if(ep == 0) {
                        break;
                    }
                    _v10352 =  &(ep->d_name);
                    _v10356 =  &dir;
                    sprintf( &subdir, "%s/%s");
                    if(strcmp( &(ep->d_name), ".") == 0) {
                        continue;
                    }
                    if(strcmp( &(ep->d_name), "..") == 0) {
                        goto L43;
                    }
                    _t284 =  &subdir;
                     *__esp = _t284;
                    opendir();
                    subdirp = _t284;
                    if(subdirp == 0) {
                        goto L44;
                    }
                     *__esp = subdirp;
                    closedir();
                    _v10356 =  &subdir;
                    sprintf( &ext_idx, "%s/index.html");
                    f_ext = fopen( &ext_idx, "r");
                    if(f_ext == 0) {
                        goto L45;
                    }
                    major = 0;
                    minor = 0;
                    revision = 0;
                    i = 0;
                    while(fgets( &str, 2048, f_ext) != 0) {
                        if(strstr( &str, "<title>") == 0) {
                            continue;
                        }
                        i = 1;
                        break;
                    }
                    if(i != 0) {
                        _t297 = strchr( &str, 40);
                        _v10348 =  &revision;
                        _v10352 =  &minor;
                        _v10356 =  &major;
                        _v10360 = "%i.%i.%i";
                         *__esp =  &(_t297[1]);
                        __isoc99_sscanf();
                        new_ext_html( &(ep->d_name), _v10320, line, major, minor, revision);
                        num_restored = num_restored + 1;
                        fclose(f_ext);
                    }
                    continue;
L45:
                    continue;
L44:
L43:
                }
                 *__esp = dirp;
                closedir();
                i = 0;
                while(line[i] != 0) {
                    fprintf(f_out, line[i]);
                    i = i + 1;
                }
                fflush(f_out);
                fclose(f_in);
                fclose(f_out);
                i = 0;
                while(n_lines + n_subdirs + 10 > i) {
                    free(line[i]);
                    i = i + 1;
                }
                free(line);
                _t333 = num_restored;
                goto L55;
            }
            _t333 = 0;
            goto L55;
L26:
            line[i] = 0;
            i = i + 1;
            goto L27;
        } else {
            _t333 = 0;
            goto L55;
        }
L12:
        _v10352 =  &(ep->d_name);
        _v10356 =  &dir;
        sprintf( &subdir, "%s/%s");
        if(strcmp( &(ep->d_name), ".") != 0) {
            if(strcmp( &(ep->d_name), "..") != 0) {
                _t237 =  &subdir;
                 *__esp = _t237;
                opendir();
                subdirp = _t237;
                if(subdirp != 0) {
                    n_subdirs = n_subdirs + 1;
                     *__esp = subdirp;
                    closedir();
                }
            }
        }
        goto L19;
    }
    _t376 =  *(__errno_location()) - 2;
    if(_t376 != 0) {
        fclose(f_in);
        _v10352 = strerror( *(__errno_location()));
        _v10356 =  &idx;
        print_error(-24, "checking for file '%s': %s\n");
        goto L4;
    } else {
        _t333 = 0;
    }
L55:
    if(_t376 == 0) {
        return _t333;
    }
    __stack_chk_fail();
    return _t333;
}

check_extension(char* package, char* name, int* major, int* minor, int* revision)
{// addr = 0x0804F7E8  --  defined in 'actions.c' at line 29
    signed int _v16;                       // _cfa_fffffff0
    char _v2060;                           // _cfa_fffff7f4
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    FILE* f;              // _cfa_fffff7e8
    char* _v2080;                          // _cfa_fffff7e0
    char* _v2084;                          // _cfa_fffff7dc
    char[2047]* _v2088;                    // _cfa_fffff7d8
    char* _v2092;                          // _cfa_fffff7d4
    char[2047]* _v2096;                    // _cfa_fffff7d0
    char[2047]* _v2124;                    // _cfa_fffff7b4
    char* _v2128;                          // _cfa_fffff7b0
    char[2047]* _v2132;                    // _cfa_fffff7ac
    char* _v2136;                          // _cfa_fffff7a8
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6
    _unknown_ _t73;                        // _t73
    _unknown_ _t74;                        // _t74
    _unknown_ _t77;                        // _t77
    _unknown_ _t80;                        // _t80
    _unknown_ _t90;                        // _t90
    _unknown_ _t96;                        // _t96
    int _t99;                              // _t99
    _unknown_ _t100;                       // _t100
    _unknown_ _t102;                       // _t102
    signed int _t104;                      // _t104
    _unknown_ _t106;                       // _t106
    _unknown_ _t108;                       // _t108
    _unknown_ _t113;                       // _t113
    _unknown_ _t114;                       // _t114
    _unknown_ _t118;                       // _t118
    _unknown_ _t125;                       // _t125
    FILE* _t128;          // _t128

    _v2080 = _a4;
    _v2084 = _a8;
    _v2088 = _a12;
    _v2092 = _a16;
    _v2096 = _a20;
    _v16 =  *gs:0x14];
    tmp = 0;
    _push(511 << 2);
    _push(0);
    _push( &_v2060);
    memset();
    __esp =  &((__esp)[3]);
    fwrite("Checking extension ...", 1, 22, __imp__stdout);
    strcpy( &tmp, _v2080);
    error = chdir( &tmp);
    if(error < 0) {
        _v2128 = strerror( *(__errno_location()));
        _v2132 = _v2080;
        print_error(-2, "extension '%s' not accessible: %s\n");
    }
    f = fopen("id", "r");
    if(f != 0) {
        _v2132 =  &tmp;
        _v2136 = "%[<GRASS extension package>] ";
         *__esp = f;
        __isoc99_fscanf();
        if(strcmp("<GRASS extension package>",  &tmp) != 0) {
            fclose(f);
            print_error(-6, "unknown file identifier.\n");
        }
    } else {
        print_error(-6, "'id' file not readable.\n");
    }
    fclose(f);
    get_package_name(".", _v2084);
    f = fopen("version", "r");
    _t128 = f;
    if(_t128 != 0) {
        nc_fgets_nb( &tmp, 2048, f);
         *_v2092 = 0;
         *_v2096 = 0;
        _t99 =  &tmp;
        _v2124 = _v2096;
        _v2128 = _v2092;
        _v2132 = _v2088;
        _v2136 = "%i.%i.%i";
         *__esp = _t99;
        __isoc99_sscanf();
        error = _t99;
        if(error <= 0) {
            fclose(f);
            print_error(-6, "invalid or missing version information.\n");
        }
    } else {
        print_error(-6, "'version' file not readable.\n");
    }
    print_done();
    chdir("..");
    fclose(f);
    _t104 = _v16 ^  *gs:0x14];
    if(_t128 == 0) {
        return _t104;
    } else {
        __stack_chk_fail();
        return _t104;
    }
}

unpack_extension(char* package)
{// addr = 0x0804FAAB  --  defined in 'actions.c' at line 88
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    int fd;                                // _cfa_fffff7e8
    int ftype;                             // _cfa_fffff7e4
    char* _v2080;                          // _cfa_fffff7e0
    char[2047]* _v2108;                    // _cfa_fffff7c4
    char* _v2112;                          // _cfa_fffff7c0
    char[2047]* _v2116;                    // _cfa_fffff7bc
    intOrPtr _v2120;                       // _cfa_fffff7b8
    _unknown_ __ebp;                       // r6
    _unknown_ _t102;                       // _t102
    _unknown_ _t105;                       // _t105
    _unknown_ _t107;                       // _t107
    _unknown_ _t108;                       // _t108
    _unknown_ _t112;                       // _t112
    _unknown_ _t113;                       // _t113
    _unknown_ _t114;                       // _t114
    _unknown_ _t117;                       // _t117
    signed int _t125;                      // _t125
    _unknown_ _t126;                       // _t126
    char* _t132;                           // _t132
    _unknown_ _t134;                       // _t134
    char* _t136;                           // _t136
    _unknown_ _t138;                       // _t138
    char* _t141;                           // _t141
    _unknown_ _t143;                       // _t143
    char* _t145;                           // _t145
    _unknown_ _t147;                       // _t147
    char* _t150;                           // _t150
    _unknown_ _t152;                       // _t152
    char* _t154;                           // _t154
    _unknown_ _t156;                       // _t156
    char* _t159;                           // _t159
    _unknown_ _t161;                       // _t161
    char* _t163;                           // _t163
    _unknown_ _t165;                       // _t165
    _unknown_ _t166;                       // _t166
    _unknown_ _t168;                       // _t168
    _unknown_ _t172;                       // _t172
    _unknown_ _t199;                       // _t199

    _v2080 = _a4;
    _v16 =  *gs:0x14];
    fwrite("Uncompressing files...", 1, 22, __imp__stdout);
    memcpy( &TMPDIR, "/tmp/grass.extension.XXXXXX", 28);
    mkstemp( &TMPDIR);
    _v2116 = 511;
    _v2120 = 64;
     *__esp =  &TMPDIR;
    fd = open();
    if(fd == 255) {
        _v2116 = strerror( *(__errno_location()));
        print_error(-7, "could not create temp directory name: %s");
        exit(-7);
    }
    if(VERBOSE != 0) {
        _v2116 =  &TMPDIR;
        fprintf(__imp__stdout, "\nUncompressing to: %s.\n");
    }
    close(fd);
    remove( &TMPDIR);
    mkdir_s( &TMPDIR, "0700");
    atexit(exit_tmp);
    _v2112 =  &TMPDIR;
    _v2116 = _v2080;
    sprintf( &tmp, "cp %s %s");
    error = system( &tmp);
    if(error < 0) {
        print_error(-7, "could not copy extension files to temp dir.\n");
        exit(-7);
    }
    ftype = check_filetype(_v2080);
    if(ftype == 0) {
        print_warning("file name not '.tar.gz', '.tgz', '.tar.bz2', '.tbz' or '.zip'. Assuming '.tgz'.\n");
        ftype = 1;
    }
    if(ftype == 1) {
        if(VERBOSE == 0) {
            _t159 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t159;
            _v2116 =  &TMPDIR;
            sprintf( &tmp, "tar -xzf %s/%s -C %s");
        } else {
            _t163 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t163;
            _v2116 =  &TMPDIR;
            sprintf( &tmp, "tar -xzvf %s/%s -C %s");
        }
    }
    if(ftype == 2) {
        if(VERBOSE == 0) {
            _t150 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t150;
            _v2116 =  &TMPDIR;
            sprintf( &tmp, "tar -xjvf %s/%s -C %s");
        } else {
            _t154 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t154;
            _v2116 =  &TMPDIR;
            sprintf( &tmp, "tar -xjvf %s/%s -C %s");
        }
    }
    if(ftype == 3) {
        if(VERBOSE == 0) {
            _t141 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t141;
            _v2116 =  &TMPDIR;
            sprintf( &tmp, "unzip -qq %s/%s -d %s");
        } else {
            _t145 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t145;
            _v2116 =  &TMPDIR;
            sprintf( &tmp, "unzip %s/%s -d %s");
        }
    }
    if(ftype == 4) {
        if(VERBOSE == 0) {
            _t132 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t132;
            _v2116 =  &TMPDIR;
            sprintf( &tmp, "tar -xf %s/%s -C %s");
        } else {
            _t136 = basename(_v2080);
            _v2108 =  &TMPDIR;
            _v2112 = _t136;
            _v2116 =  &TMPDIR;
            sprintf( &tmp, "tar -xvf %s/%s -C %s");
        }
    }
    error = system( &tmp);
    if(error < 0) {
        if(ftype == 1) {
            _v2116 = _v2080;
            print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n");
        }
        if(ftype == 2) {
            _v2116 = _v2080;
            print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n");
        }
        _t199 = ftype - 3;
        if(_t199 == 0) {
            _v2116 = _v2080;
            print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n");
        }
        exit(-7);
    }
    print_done();
    _t125 = _v16 ^  *gs:0x14];
    if(_t199 == 0) {
        return _t125;
    } else {
        __stack_chk_fail();
        return _t125;
    }
}

query_extension(char* package, char* name, int major, int minor, int revision, char* short_name, char* invocation, char* org_name)
{// addr = 0x0804FF43  --  defined in 'actions.c' at line 201
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    struct _IO_FILE* _v2072;   // _cfa_fffff7e8
    char* _v2080;                          // _cfa_fffff7e0
    char* _v2084;                          // _cfa_fffff7dc
    intOrPtr _v2088;                       // _cfa_fffff7d8
    char* _v2092;                          // _cfa_fffff7d4
    int _v2096;                            // _cfa_fffff7d0
    int _v2120;                            // _cfa_fffff7b8
    int _v2124;                            // _cfa_fffff7b4
    int _v2128;                            // _cfa_fffff7b0
    char* _v2132;                          // _cfa_fffff7ac
    _unknown_ _v2136;                      // _cfa_fffff7a8
    signed int _v2156;                     // _cfa_fffff794
    struct _IO_FILE* _v4208;   // _cfa_ffffef90
    _unknown_ _v4220;                      // _cfa_ffffef84
    _unknown_ _v4224;                      // _cfa_ffffef80
    _unknown_ _v4228;                      // _cfa_ffffef7c
    _unknown_ __ebp;                       // r6
    _unknown_ _t74;                        // _t74
    _unknown_ _t78;                        // _t78
    _unknown_ _t82;                        // _t82
    _unknown_ _t85;                        // _t85
    _unknown_ _t88;                        // _t88
    _unknown_ _t90;                        // _t90
    _unknown_ _t91;                        // _t91
    _unknown_ _t92;                        // _t92
    _unknown_ _t94;                        // _t94
    _unknown_ _t97;                        // _t97
    signed int _t99;                       // _t99
    _unknown_ _t102;                       // _t102
    _unknown_ _t108;                       // _t108
    _unknown_ _t110;                       // _t110
    _unknown_ _t129;                       // _t129
    _unknown_ _t130;                       // _t130
    char* _t133;                           // _t133

    _v2080 = _a4;
    _v2084 = _a8;
    _v2088 = _a24;
    _v2092 = _a28;
    _v2096 = _a32;
    _v16 =  *gs:0x14];
    strcpy( &tmp, basename(_v2080));
    error = chdir( &tmp);
    if(error < 0) {
        _v2128 = strerror( *(__errno_location()));
        _v2132 = _v2080;
        print_error(-2, "extension '%s' not accessible: %s\n");
    }
    _v2120 = revision;
    _v2124 = minor;
    _v2128 = major;
    _v2132 = _v2084;
    fprintf(__imp__stdout, "\nExtension '%s', version %i.%i.%i\n\n");
    dump_ascii("description", "Description");
    dump_ascii("commands", "Commands provided");
    dump_ascii("libs", "Libraries provided");
    dump_ascii("headers", "Header files provided");
    dump_ascii("depends", "Dependencies");
    dump_ascii("bugs", "Bugs");
    _v2132 = _v2080;
    sprintf( &tmp, "../%s");
    list_binaries( &tmp);
    dump_ascii("authors", "Author(s)");
    _v2128 = _v2096;
    _v2132 = _v2092;
    fprintf(__imp__stdout, "Type '%s -d %s' to see more detailed information.\n");
    _v2128 = _v2096;
    _v2132 = _v2092;
    fprintf(__imp__stdout, "Type '%s -l %s' to see copyright information.\n");
    system("sh post");
    exit(0);
    _push(_t129);
    __esp = __esp - 2088;
    _v2156 =  *gs:0x14];
    _v4208 = fopen("config.msg", "r");
    if(_v4208 != 0) {
        fwrite("\nResult of configuration: \n", 1, 27, __imp__stdout);
        while(1) {
            _t133 = fgets( &error, 2048, _v2072);
            if(_t133 == 0) {
                break;
            }
            fputs( &error, __imp__stdout);
        }
        fputc(10, __imp__stdout);
    }
    remove("config.msg");
    _t99 = _v20 ^  *gs:0x14];
    if(_t133 == 0) {
    } else {
        __stack_chk_fail();
        return _t99;
    }
    goto L10;
L11:
L10:
    return _t99;
    goto L11;
}

print_cfg()
{// addr = 0x0805014E  --  defined in 'actions.c' at line 242
    signed int _v16;                       // _cfa_fffffff0
    char[2047] line;                       // _cfa_fffff7f0
    FILE* fp;             // _cfa_fffff7ec
    _unknown_ _v2080;                      // _cfa_fffff7e0
    _unknown_ _v2084;                      // _cfa_fffff7dc
    _unknown_ _v2088;                      // _cfa_fffff7d8
    _unknown_ __ebp;                       // r6
    _unknown_ _t17;                        // _t17
    _unknown_ _t20;                        // _t20
    signed int _t22;                       // _t22
    _unknown_ _t25;                        // _t25
    _unknown_ _t31;                        // _t31
    _unknown_ _t33;                        // _t33
    char* _t37;                            // _t37

    _v16 =  *gs:0x14];
    fp = fopen("config.msg", "r");
    if(fp != 0) {
        fwrite("\nResult of configuration: \n", 1, 27, __imp__stdout);
        while(1) {
            _t37 = fgets( &line, 2048, fp);
            if(_t37 == 0) {
                break;
            }
            fputs( &line, __imp__stdout);
        }
        fputc(10, __imp__stdout);
    }
    remove("config.msg");
    _t22 = _v16 ^  *gs:0x14];
    if(_t37 == 0) {
    } else {
        __stack_chk_fail();
        return _t22;
    }
    goto L7;
L8:
L7:
    return _t22;
    goto L8;
}

source_install(char* package, char* gisbase, char* pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char* grass_version)
{// addr = 0x08050220  --  defined in 'actions.c' at line 263
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] dir;                        // _cfa_ffffeff0
    char[2047] install_cmd;                // _cfa_ffffe7f0
    char[2047] post_cmd;                   // _cfa_ffffdff0
    char[2047] sysstr;                     // _cfa_ffffd7f0
    int error;                             // _cfa_ffffd7ec
    FILE* f;              // _cfa_ffffd7e8
    char* verstr;                          // _cfa_ffffd7e4
    char* grass_major;                     // _cfa_ffffd7e0
    char* grass_minor;                     // _cfa_ffffd7dc
    char* grass_revision;                  // _cfa_ffffd7d8
    int major;                             // _cfa_ffffd7d4
    int minor;                             // _cfa_ffffd7d0
    int revision;                          // _cfa_ffffd7cc
    struct stat buf;      // _cfa_ffffd774
    char* _v10384;                         // _cfa_ffffd770
    char* _v10388;                         // _cfa_ffffd76c
    char* _v10392;                         // _cfa_ffffd768
    char* _v10396;                         // _cfa_ffffd764
    char[2047]* _v10412;                   // _cfa_ffffd754
    char[2047]* _v10416;                   // _cfa_ffffd750
    char[2047]* _v10420;                   // _cfa_ffffd74c
    char[2047]* _v10424;                   // _cfa_ffffd748
    char[2047]* _v10428;                   // _cfa_ffffd744
    char[2047]* _v10432;                   // _cfa_ffffd740
    char[2047]* _v10436;                   // _cfa_ffffd73c
    char* _v10440;                         // _cfa_ffffd738
    _unknown_ __ebp;                       // r6
    _unknown_ _t251;                       // _t251
    int _t252;                             // _t252
    _unknown_ _t254;                       // _t254
    _unknown_ _t255;                       // _t255
    _unknown_ _t258;                       // _t258
    _unknown_ _t260;                       // _t260
    _unknown_ _t261;                       // _t261
    _unknown_ _t264;                       // _t264
    _unknown_ _t266;                       // _t266
    _unknown_ _t267;                       // _t267
    _unknown_ _t269;                       // _t269
    _unknown_ _t270;                       // _t270
    _unknown_ _t287;                       // _t287
    _unknown_ _t288;                       // _t288
    _unknown_ _t292;                       // _t292
    _unknown_ _t297;                       // _t297
    _unknown_ _t298;                       // _t298
    _unknown_ _t301;                       // _t301
    _unknown_ _t303;                       // _t303
    _unknown_ _t304;                       // _t304
    _unknown_ _t306;                       // _t306
    _unknown_ _t307;                       // _t307
    _unknown_ _t309;                       // _t309
    _unknown_ _t310;                       // _t310
    _unknown_ _t312;                       // _t312
    _unknown_ _t313;                       // _t313
    _unknown_ _t315;                       // _t315
    _unknown_ _t316;                       // _t316
    _unknown_ _t318;                       // _t318
    _unknown_ _t319;                       // _t319
    _unknown_ _t320;                       // _t320
    _unknown_ _t327;                       // _t327
    _unknown_ _t330;                       // _t330
    _unknown_ _t335;                       // _t335
    _unknown_ _t341;                       // _t341
    _unknown_ _t343;                       // _t343
    _unknown_ _t345;                       // _t345
    _unknown_ _t364;                       // _t364
    _unknown_ _t368;                       // _t368
    _unknown_ _t371;                       // _t371
    signed int _t375;                      // _t375
    _unknown_ _t378;                       // _t378
    _unknown_ _t380;                       // _t380
    _unknown_ _t383;                       // _t383
    _unknown_ _t388;                       // _t388
    _unknown_ _t390;                       // _t390
    _unknown_ _t396;                       // _t396
    _unknown_ _t399;                       // _t399
    _unknown_ _t405;                       // _t405
    _unknown_ _t408;                       // _t408
    _unknown_ _t413;                       // _t413
    _unknown_ _t416;                       // _t416
    int _t470;                             // _t470

    _v10384 = _a4;
    _v10388 = _a8;
    _v10392 = _a12;
    _v10396 = _a28;
    _v16 =  *gs:0x14];
    _t252 = _v10388;
    __stat(_t252,  &(buf.st_dev));
    error = _t252;
    if(error < 0) {
        _v10436 = strerror( *(__errno_location()));
        print_error(-5, "installation directory invalid: %s\n");
    }
    _v10436 = _v10388;
    sprintf( &GINSTALL_DST, "GINSTALL_DST=%s");
    putenv( &GINSTALL_DST);
    _v10436 = _v10388;
    sprintf( &tmp, "%s/include");
    _v10436 =  &tmp;
    sprintf( &GINSTALL_INC, "GINSTALL_INC=%s");
    putenv( &GINSTALL_INC);
    _v10436 = _v10388;
    sprintf( &tmp, "%s/lib");
    _v10436 =  &tmp;
    sprintf( &GINSTALL_LIB, "GINSTALL_LIB=%s");
    putenv( &GINSTALL_LIB);
    _v10436 = _v10388;
    sprintf( &GEM_GRASS_DIR, "GEM_GRASS_DIR=%s");
    putenv( &GEM_GRASS_DIR);
    verstr = strdup(_v10396);
    grass_major = strtok(verstr, ".");
    grass_minor = strtok(0, ".");
    grass_revision = strtok(0, ".");
    major = strtol(grass_major, 0, 10);
    minor = strtol(grass_minor, 0, 10);
    revision = strtol(grass_revision, 0, 10);
    free(verstr);
    atexit(exit_tmp);
    _v10436 = basename(_v10384);
    sprintf( &dir, "%s/src");
    error = chdir( &dir);
    if(error < 0) {
        _v10432 = strerror( *(__errno_location()));
        _v10436 = _v10384;
        print_error(-2, "extension files in '%s' not accessible: %s\n");
    }
    if(SKIP_CFG == 0) {
        if(VERBOSE == 0) {
            fwrite("Configuring...", 1, 14, __imp__stdout);
            _v10428 =  &TMP_NULL;
            _v10432 =  &CONFIG_OPTS;
            _v10436 =  &CONFIG_CMD;
            sprintf( &sysstr, "sh %s %s --quiet &> %s");
            error = system( &sysstr);
        } else {
            fwrite("Running configure script:\n", 1, 26, __imp__stdout);
            _v10432 =  &CONFIG_OPTS;
            _v10436 =  &CONFIG_CMD;
            sprintf( &sysstr, "sh %s %s");
            error = system( &sysstr);
        }
        if(error == 255) {
            print_error(-27, "could not run configure script.\n");
        }
        if(error > 0) {
            print_error(-3, "system configuration failed.\n");
        }
        print_done();
        print_cfg();
    }
    _v10436 = _v10392;
    sprintf( &GEM_EXT_NAME, "GEM_EXT_NAME=%s");
    putenv( &GEM_EXT_NAME);
    _v10428 = pkg_revision;
    _v10432 = pkg_minor;
    _v10436 = pkg_major;
    sprintf( &tmp, "%i.%i.%i");
    _v10436 =  &tmp;
    sprintf( &GEM_EXT_VERSION, "GEM_EXT_VERSION=%s");
    putenv( &GEM_EXT_VERSION);
    dump_html("../description",  &TMP_DESCR);
    dump_html("../info",  &TMP_INFO);
    dump_html("../depends",  &TMP_DEPS);
    dump_html("../bugs",  &TMP_BUGS);
    dump_html("../authors",  &TMP_AUTHORS);
    _v10436 =  &TMP_DESCR;
    sprintf( &GEM_EXT_DESCR, "GEM_EXT_DESCR=%s");
    putenv( &GEM_EXT_DESCR);
    _v10436 =  &TMP_INFO;
    sprintf( &GEM_EXT_INFO, "GEM_EXT_INFO=%s");
    putenv( &GEM_EXT_INFO);
    _v10436 =  &TMP_DEPS;
    sprintf( &GEM_EXT_DEPS, "GEM_EXT_DEPS=%s");
    putenv( &GEM_EXT_DEPS);
    _v10436 =  &TMP_BUGS;
    sprintf( &GEM_EXT_BUGS, "GEM_EXT_BUGS=%s");
    putenv( &GEM_EXT_BUGS);
    _v10436 =  &TMP_AUTHORS;
    sprintf( &GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s");
    putenv( &GEM_EXT_AUTHORS);
    atexit(exit_tmp);
    check_dependencies(_v10384, _v10388, _v10396);
    if(VERBOSE == 0) {
        fwrite("Compiling...", 1, 12, __imp__stdout);
        _v10432 =  &TMP_NULL;
        _v10436 =  &MAKE_CMD;
        sprintf( &sysstr, "%s -f Makefile &> %s");
        error = system( &sysstr);
    } else {
        _v10436 =  &MAKE_CMD;
        fprintf(__imp__stdout, "Running '%s':\n");
        _v10436 =  &MAKE_CMD;
        sprintf( &sysstr, "%s -f Makefile");
        error = system( &sysstr);
    }
    if(error == 255 && VERBOSE == 0) {
        _v10436 =  &MAKE_CMD;
        print_error(-9, "could not run '%s' do you have make tools installed?\n");
    }
    if(error > 0) {
        print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
    }
    print_done();
    fwrite("Installing...", 1, 13, __imp__stdout);
    f = fopen("../uninstall", "r");
    if(f != 0) {
        if(VERBOSE == 0) {
            _v10428 =  &TMP_NULL;
            _v10432 = _v10392;
            _v10436 = _v10388;
            sprintf( &tmp, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;");
            strcpy( &UNINSTALL_CMD,  &tmp);
        } else {
            _v10432 = _v10392;
            _v10436 = _v10388;
            sprintf( &tmp, "cp -vf ../uninstall %s/etc/uninstall.%s ;");
            strcpy( &UNINSTALL_CMD,  &tmp);
        }
        fclose(f);
    } else {
        _v10440 = strerror( *(__errno_location()));
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
    }
    register_extension(_v10388, "src", _v10392, pkg_major, pkg_minor, pkg_revision);
    check_dependencies(_v10384, _v10388, _v10396);
    if(major == 6 && minor <= 0) {
        register_entries_gisman(_v10392, _v10388);
    }
    register_entries_gisman2(_v10392, _v10388);
    register_html(_v10392, _v10388, pkg_major, pkg_minor, pkg_revision);
    if(VERBOSE == 0) {
        _v10412 =  &TMP_NULL;
        _v10416 = _v10388;
        _v10420 =  &TMP_NULL;
        _v10424 = _v10388;
        _v10428 =  &TMPDB;
        _v10432 =  &TMP_NULL;
        _v10436 =  &MAKE_CMD;
        sprintf( &install_cmd, "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;");
    } else {
        _v10436 =  &MAKE_CMD;
        fprintf(__imp__stdout, "Running '%s install':\n");
        _v10424 = _v10388;
        _v10428 = _v10388;
        _v10432 =  &TMPDB;
        _v10436 =  &MAKE_CMD;
        sprintf( &install_cmd, "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;");
    }
    _t470 = VERBOSE;
    if(_t470 == 0) {
        _v10436 =  &TMP_NULL;
        sprintf( &post_cmd, "sh ../post &> %s");
    } else {
        memcpy( &post_cmd, "sh ../post", 11);
    }
    _v10416 =  &post_cmd;
    _v10420 =  &HTML_CMD;
    _v10424 =  &GISMAN2_CMD;
    _v10428 =  &GISMAN_CMD;
    _v10432 =  &UNINSTALL_CMD;
    _v10436 =  &install_cmd;
    sprintf( &tmp, "%s %s %s %s %s %s");
    su(_v10388,  &tmp);
    print_done();
    _t375 = _v16 ^  *gs:0x14];
    if(_t470 == 0) {
        return _t375;
    } else {
        __stack_chk_fail();
        return _t375;
    }
}

bin_install(char* package, char* gisbase, char* bins, char* pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char* grass_version)
{// addr = 0x08050C67  --  defined in 'actions.c' at line 475
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] dir;                        // _cfa_ffffeff0
    char[2047] install_cmd;                // _cfa_ffffe7f0
    char[2047] post_cmd;                   // _cfa_ffffdff0
    int error;                             // _cfa_ffffdfec
    FILE* f;              // _cfa_ffffdfe8
    char* verstr;                          // _cfa_ffffdfe4
    char* grass_major;                     // _cfa_ffffdfe0
    char* grass_minor;                     // _cfa_ffffdfdc
    char* grass_revision;                  // _cfa_ffffdfd8
    int major;                             // _cfa_ffffdfd4
    int minor;                             // _cfa_ffffdfd0
    int revision;                          // _cfa_ffffdfcc
    struct stat buf;      // _cfa_ffffdf74
    char* _v8336;                          // _cfa_ffffdf70
    char* _v8340;                          // _cfa_ffffdf6c
    char[2047]* _v8344;                    // _cfa_ffffdf68
    char* _v8348;                          // _cfa_ffffdf64
    char* _v8352;                          // _cfa_ffffdf60
    char[2047]* _v8380;                    // _cfa_ffffdf44
    char[2047]* _v8384;                    // _cfa_ffffdf40
    char[2047]* _v8388;                    // _cfa_ffffdf3c
    char[2047]* _v8392;                    // _cfa_ffffdf38
    char[2047]* _v8396;                    // _cfa_ffffdf34
    char[2047]* _v8400;                    // _cfa_ffffdf30
    char[2047]* _v8404;                    // _cfa_ffffdf2c
    char* _v8408;                          // _cfa_ffffdf28
    _unknown_ __ebp;                       // r6
    _unknown_ _t213;                       // _t213
    int _t214;                             // _t214
    _unknown_ _t216;                       // _t216
    _unknown_ _t217;                       // _t217
    _unknown_ _t220;                       // _t220
    _unknown_ _t222;                       // _t222
    _unknown_ _t223;                       // _t223
    _unknown_ _t226;                       // _t226
    _unknown_ _t228;                       // _t228
    _unknown_ _t229;                       // _t229
    _unknown_ _t231;                       // _t231
    _unknown_ _t232;                       // _t232
    _unknown_ _t249;                       // _t249
    _unknown_ _t250;                       // _t250
    char* _t252;                           // _t252
    _unknown_ _t254;                       // _t254
    _unknown_ _t258;                       // _t258
    _unknown_ _t259;                       // _t259
    _unknown_ _t262;                       // _t262
    _unknown_ _t264;                       // _t264
    _unknown_ _t265;                       // _t265
    _unknown_ _t267;                       // _t267
    _unknown_ _t268;                       // _t268
    _unknown_ _t270;                       // _t270
    _unknown_ _t271;                       // _t271
    _unknown_ _t273;                       // _t273
    _unknown_ _t274;                       // _t274
    _unknown_ _t276;                       // _t276
    _unknown_ _t277;                       // _t277
    _unknown_ _t279;                       // _t279
    _unknown_ _t280;                       // _t280
    _unknown_ _t281;                       // _t281
    _unknown_ _t287;                       // _t287
    _unknown_ _t293;                       // _t293
    _unknown_ _t295;                       // _t295
    _unknown_ _t297;                       // _t297
    _unknown_ _t317;                       // _t317
    _unknown_ _t321;                       // _t321
    _unknown_ _t324;                       // _t324
    signed int _t328;                      // _t328
    _unknown_ _t331;                       // _t331
    _unknown_ _t333;                       // _t333
    _unknown_ _t336;                       // _t336
    _unknown_ _t341;                       // _t341
    _unknown_ _t343;                       // _t343
    int _t386;                             // _t386

    _v8336 = _a4;
    _v8340 = _a8;
    _v8344 = _a12;
    _v8348 = _a16;
    _v8352 = _a32;
    _v16 =  *gs:0x14];
    _t214 = _v8340;
    __stat(_t214,  &(buf.st_dev));
    error = _t214;
    if(error < 0) {
        _v8404 = strerror( *(__errno_location()));
        print_error(-5, "installation directory invalid: %s\n");
    }
    _v8404 = _v8340;
    sprintf( &GINSTALL_DST, "GINSTALL_DST=%s");
    putenv( &GINSTALL_DST);
    _v8404 = _v8340;
    sprintf( &tmp, "%s/include");
    _v8404 =  &tmp;
    sprintf( &GINSTALL_INC, "GINSTALL_INC=%s");
    putenv( &GINSTALL_INC);
    _v8404 = _v8340;
    sprintf( &tmp, "%s/lib");
    _v8404 =  &tmp;
    sprintf( &GINSTALL_LIB, "GINSTALL_LIB=%s");
    putenv( &GINSTALL_LIB);
    _v8404 = _v8340;
    sprintf( &GEM_GRASS_DIR, "GEM_GRASS_DIR=%s");
    putenv( &GEM_GRASS_DIR);
    verstr = strdup(_v8352);
    grass_major = strtok(verstr, ".");
    grass_minor = strtok(0, ".");
    grass_revision = strtok(0, ".");
    major = strtol(grass_major, 0, 10);
    minor = strtol(grass_minor, 0, 10);
    revision = strtol(grass_revision, 0, 10);
    free(verstr);
    atexit(exit_tmp);
    _t252 = basename(_v8336);
    _v8400 = _v8344;
    _v8404 = _t252;
    sprintf( &dir, "%s/%s");
    error = chdir( &dir);
    if(error < 0) {
        _v8400 = strerror( *(__errno_location()));
        _v8404 = _v8336;
        print_error(-2, "extension file binaries in '%s' not accessible: %s\n");
    }
    _v8404 = _v8348;
    sprintf( &GEM_EXT_NAME, "GEM_EXT_NAME=%s");
    putenv( &GEM_EXT_NAME);
    _v8396 = pkg_revision;
    _v8400 = pkg_minor;
    _v8404 = pkg_major;
    sprintf( &tmp, "%i.%i.%i");
    _v8404 =  &tmp;
    sprintf( &GEM_EXT_VERSION, "GEM_EXT_VERSION=%s");
    putenv( &GEM_EXT_VERSION);
    dump_html("../description",  &TMP_DESCR);
    dump_html("../info",  &TMP_INFO);
    dump_html("../depends",  &TMP_DEPS);
    dump_html("../bugs",  &TMP_BUGS);
    dump_html("../authors",  &TMP_AUTHORS);
    _v8404 =  &TMP_DESCR;
    sprintf( &GEM_EXT_DESCR, "GEM_EXT_DESCR=%s");
    putenv( &GEM_EXT_DESCR);
    _v8404 =  &TMP_INFO;
    sprintf( &GEM_EXT_INFO, "GEM_EXT_INFO=%s");
    putenv( &GEM_EXT_INFO);
    _v8404 =  &TMP_DEPS;
    sprintf( &GEM_EXT_DEPS, "GEM_EXT_DEPS=%s");
    putenv( &GEM_EXT_DEPS);
    _v8404 =  &TMP_BUGS;
    sprintf( &GEM_EXT_BUGS, "GEM_EXT_BUGS=%s");
    putenv( &GEM_EXT_BUGS);
    _v8404 =  &TMP_AUTHORS;
    sprintf( &GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s");
    putenv( &GEM_EXT_AUTHORS);
    atexit(exit_tmp);
    check_dependencies(_v8336, _v8340, _v8352);
    fwrite("Installing...", 1, 13, __imp__stdout);
    f = fopen("../uninstall", "r");
    if(f != 0) {
        if(VERBOSE == 0) {
            _v8396 =  &TMP_NULL;
            _v8400 = _v8348;
            _v8404 = _v8340;
            sprintf( &tmp, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;");
            strcpy( &UNINSTALL_CMD,  &tmp);
        } else {
            _v8400 = _v8348;
            _v8404 = _v8340;
            sprintf( &tmp, "cp -vf ../uninstall %s/etc/uninstall.%s ;");
            strcpy( &UNINSTALL_CMD,  &tmp);
        }
        fclose(f);
    } else {
        _v8408 = strerror( *(__errno_location()));
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
    }
    register_extension(_v8340, _v8344, _v8348, pkg_major, pkg_minor, pkg_revision);
    check_dependencies(_v8336, _v8340, _v8352);
    if(major == 6 && minor <= 0) {
        register_entries_gisman(_v8348, _v8340);
    }
    register_entries_gisman2(_v8348, _v8340);
    register_html(_v8348, _v8340, pkg_major, pkg_minor, pkg_revision);
    if(VERBOSE == 0) {
        _v8380 =  &TMP_NULL;
        _v8384 = _v8340;
        _v8388 =  &TMP_NULL;
        _v8392 = _v8340;
        _v8396 =  &TMPDB;
        _v8400 =  &TMP_NULL;
        _v8404 =  &MAKE_CMD;
        sprintf( &install_cmd, "bin/%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;");
    } else {
        _v8404 =  &MAKE_CMD;
        fprintf(__imp__stdout, "Running '%s install':\n");
        _v8392 = _v8340;
        _v8396 = _v8340;
        _v8400 =  &TMPDB;
        _v8404 =  &MAKE_CMD;
        sprintf( &install_cmd, "bin/%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;");
    }
    _t386 = VERBOSE;
    if(_t386 == 0) {
        _v8404 =  &TMP_NULL;
        sprintf( &post_cmd, "sh ../post &> %s");
    } else {
        memcpy( &post_cmd, "sh ../post", 11);
    }
    _v8384 =  &post_cmd;
    _v8388 =  &HTML_CMD;
    _v8392 =  &GISMAN2_CMD;
    _v8396 =  &GISMAN_CMD;
    _v8400 =  &UNINSTALL_CMD;
    _v8404 =  &install_cmd;
    sprintf( &tmp, "%s %s %s %s %s %s");
    su(_v8340,  &tmp);
    print_done();
    _t328 = _v16 ^  *gs:0x14];
    if(_t386 == 0) {
        return _t328;
    } else {
        __stack_chk_fail();
        return _t328;
    }
}

test_install(char* package, char* gisbase, char* pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char* grass_version)
{// addr = 0x0805148A  --  defined in 'actions.c' at line 636
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] dir;                        // _cfa_ffffeff0
    char[2047] sysstr;                     // _cfa_ffffe7f0
    int error;                             // _cfa_ffffe7ec
    FILE* f;              // _cfa_ffffe7e8
    char* verstr;                          // _cfa_ffffe7e4
    char* grass_major;                     // _cfa_ffffe7e0
    char* grass_minor;                     // _cfa_ffffe7dc
    char* grass_revision;                  // _cfa_ffffe7d8
    int major;                             // _cfa_ffffe7d4
    int minor;                             // _cfa_ffffe7d0
    int revision;                          // _cfa_ffffe7cc
    struct stat buf;      // _cfa_ffffe774
    char* _v6288;                          // _cfa_ffffe770
    char* _v6292;                          // _cfa_ffffe76c
    char* _v6296;                          // _cfa_ffffe768
    char* _v6300;                          // _cfa_ffffe764
    _unknown_ _v6312;                      // _cfa_ffffe758
    char[2047]* _v6316;                    // _cfa_ffffe754
    int _v6320;                            // _cfa_ffffe750
    char[2047]* _v6324;                    // _cfa_ffffe74c
    char* _v6328;                          // _cfa_ffffe748
    _unknown_ __ebp;                       // r6
    _unknown_ _t196;                       // _t196
    int _t197;                             // _t197
    _unknown_ _t199;                       // _t199
    _unknown_ _t200;                       // _t200
    _unknown_ _t203;                       // _t203
    _unknown_ _t205;                       // _t205
    _unknown_ _t206;                       // _t206
    _unknown_ _t209;                       // _t209
    _unknown_ _t211;                       // _t211
    _unknown_ _t212;                       // _t212
    _unknown_ _t214;                       // _t214
    _unknown_ _t215;                       // _t215
    _unknown_ _t232;                       // _t232
    _unknown_ _t233;                       // _t233
    _unknown_ _t237;                       // _t237
    _unknown_ _t242;                       // _t242
    _unknown_ _t243;                       // _t243
    _unknown_ _t246;                       // _t246
    _unknown_ _t248;                       // _t248
    _unknown_ _t249;                       // _t249
    _unknown_ _t251;                       // _t251
    _unknown_ _t252;                       // _t252
    _unknown_ _t254;                       // _t254
    _unknown_ _t255;                       // _t255
    _unknown_ _t257;                       // _t257
    _unknown_ _t258;                       // _t258
    _unknown_ _t260;                       // _t260
    _unknown_ _t261;                       // _t261
    _unknown_ _t263;                       // _t263
    _unknown_ _t264;                       // _t264
    _unknown_ _t265;                       // _t265
    _unknown_ _t272;                       // _t272
    _unknown_ _t275;                       // _t275
    _unknown_ _t280;                       // _t280
    _unknown_ _t284;                       // _t284
    _unknown_ _t301;                       // _t301
    signed int _t303;                      // _t303
    _unknown_ _t311;                       // _t311
    _unknown_ _t314;                       // _t314
    _unknown_ _t320;                       // _t320
    _unknown_ _t323;                       // _t323
    _unknown_ _t328;                       // _t328
    _unknown_ _t331;                       // _t331
    int _t373;                             // _t373

    _v6288 = _a4;
    _v6292 = _a8;
    _v6296 = _a12;
    _v6300 = _a28;
    _v16 =  *gs:0x14];
    _t197 = _v6292;
    __stat(_t197,  &(buf.st_dev));
    error = _t197;
    if(error < 0) {
        _v6324 = strerror( *(__errno_location()));
        print_error(-5, "installation directory invalid: %s\n");
    }
    _v6324 = _v6292;
    sprintf( &GINSTALL_DST, "GINSTALL_DST=%s");
    putenv( &GINSTALL_DST);
    _v6324 = _v6292;
    sprintf( &tmp, "%s/include");
    _v6324 =  &tmp;
    sprintf( &GINSTALL_INC, "GINSTALL_INC=%s");
    putenv( &GINSTALL_INC);
    _v6324 = _v6292;
    sprintf( &tmp, "%s/lib");
    _v6324 =  &tmp;
    sprintf( &GINSTALL_LIB, "GINSTALL_LIB=%s");
    putenv( &GINSTALL_LIB);
    _v6324 = _v6292;
    sprintf( &GEM_GRASS_DIR, "GEM_GRASS_DIR=%s");
    putenv( &GEM_GRASS_DIR);
    verstr = strdup(_v6300);
    grass_major = strtok(verstr, ".");
    grass_minor = strtok(0, ".");
    grass_revision = strtok(0, ".");
    major = strtol(grass_major, 0, 10);
    minor = strtol(grass_minor, 0, 10);
    revision = strtol(grass_revision, 0, 10);
    free(verstr);
    atexit(exit_tmp);
    _v6324 = basename(_v6288);
    sprintf( &dir, "%s/src");
    error = chdir( &dir);
    if(error < 0) {
        _v6320 = strerror( *(__errno_location()));
        _v6324 = _v6288;
        print_error(-2, "extension files in '%s' not accessible: %s\n");
    }
    if(SKIP_CFG == 0) {
        if(VERBOSE == 0) {
            fwrite("Configuring...", 1, 14, __imp__stdout);
            _v6316 =  &TMP_NULL;
            _v6320 =  &CONFIG_OPTS;
            _v6324 =  &CONFIG_CMD;
            sprintf( &sysstr, "sh %s %s --quiet &> %s");
            error = system( &sysstr);
        } else {
            fwrite("Running configure script:\n", 1, 26, __imp__stdout);
            _v6320 =  &CONFIG_OPTS;
            _v6324 =  &CONFIG_CMD;
            sprintf( &sysstr, "sh %s %s");
            error = system( &sysstr);
        }
        if(error == 255) {
            print_error(-27, "could not run configure script.\n");
        }
        if(error > 0) {
            print_error(-3, "system configuration failed.\n");
        }
        print_done();
        print_cfg();
    }
    _v6324 = _v6296;
    sprintf( &GEM_EXT_NAME, "GEM_EXT_NAME=%s");
    putenv( &GEM_EXT_NAME);
    _v6316 = pkg_revision;
    _v6320 = pkg_minor;
    _v6324 = pkg_major;
    sprintf( &tmp, "%i.%i.%i");
    _v6324 =  &tmp;
    sprintf( &GEM_EXT_VERSION, "GEM_EXT_VERSION=%s");
    putenv( &GEM_EXT_VERSION);
    dump_plain("../description",  &TMP_DESCR);
    dump_plain("../info",  &TMP_INFO);
    dump_plain("../depends",  &TMP_DEPS);
    dump_plain("../bugs",  &TMP_BUGS);
    dump_plain("../authors",  &TMP_AUTHORS);
    _v6324 =  &TMP_DESCR;
    sprintf( &GEM_EXT_DESCR, "GEM_EXT_DESCR=%s");
    putenv( &GEM_EXT_DESCR);
    _v6324 =  &TMP_INFO;
    sprintf( &GEM_EXT_INFO, "GEM_EXT_INFO=%s");
    putenv( &GEM_EXT_INFO);
    _v6324 =  &TMP_DEPS;
    sprintf( &GEM_EXT_DEPS, "GEM_EXT_DEPS=%s");
    putenv( &GEM_EXT_DEPS);
    _v6324 =  &TMP_BUGS;
    sprintf( &GEM_EXT_BUGS, "GEM_EXT_BUGS=%s");
    putenv( &GEM_EXT_BUGS);
    _v6324 =  &TMP_AUTHORS;
    sprintf( &GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s");
    putenv( &GEM_EXT_AUTHORS);
    atexit(exit_tmp);
    check_dependencies(_v6288, _v6292, _v6300);
    if(VERBOSE == 0) {
        fwrite("Compiling...", 1, 12, __imp__stdout);
        _v6320 =  &TMP_NULL;
        _v6324 =  &MAKE_CMD;
        sprintf( &sysstr, "%s -f Makefile &> %s");
        error = system( &sysstr);
    } else {
        _v6324 =  &MAKE_CMD;
        fprintf(__imp__stdout, "Running '%s':\n");
        _v6324 =  &MAKE_CMD;
        sprintf( &sysstr, "%s -f Makefile");
        error = system( &sysstr);
    }
    if(error == 255 && VERBOSE == 0) {
        _v6324 =  &MAKE_CMD;
        print_error(-9, "could not run '%s' do you have make tools installed?\n");
    }
    if(error > 0) {
        print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
    }
    print_done();
    fwrite("Installing...", 1, 13, __imp__stdout);
    f = fopen("../uninstall", "r");
    if(f != 0) {
        fclose(f);
    } else {
        _v6328 = strerror( *(__errno_location()));
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
    }
    register_extension(_v6292, "src", _v6296, pkg_major, pkg_minor, pkg_revision);
    check_dependencies(_v6288, _v6292, _v6300);
    if(major == 6) {
        _t373 = minor;
        if(_t373 <= 0) {
            register_entries_gisman(_v6296, _v6292);
        }
    }
    register_entries_gisman2(_v6296, _v6292);
    register_html(_v6296, _v6292, pkg_major, pkg_minor, pkg_revision);
    _v6324 =  &MAKE_CMD;
    fprintf(__imp__stdout, "(skipping '%s install')...");
    print_done();
    _t303 = _v16 ^  *gs:0x14];
    if(_t373 == 0) {
        return _t303;
    } else {
        __stack_chk_fail();
        return _t303;
    }
}

uninstall(char* package, char* pkg_short_name, char* gisbase, char* grass_version)
{// addr = 0x08051CF4  --  defined in 'actions.c' at line 812
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] script;                     // _cfa_ffffeff0
    int error;                             // _cfa_ffffefec
    int no_script;                         // _cfa_ffffefe8
    char* verstr;                          // _cfa_ffffefe4
    char* grass_major;                     // _cfa_ffffefe0
    char* grass_minor;                     // _cfa_ffffefdc
    char* grass_revision;                  // _cfa_ffffefd8
    int major;                             // _cfa_ffffefd4
    int minor;                             // _cfa_ffffefd0
    int revision;                          // _cfa_ffffefcc
    struct stat buf;      // _cfa_ffffef74
    char* _v4240;                          // _cfa_ffffef70
    char* _v4244;                          // _cfa_ffffef6c
    char* _v4248;                          // _cfa_ffffef68
    char* _v4252;                          // _cfa_ffffef64
    char[2047]* _v4268;                    // _cfa_ffffef54
    char* _v4272;                          // _cfa_ffffef50
    char[2047]* _v4276;                    // _cfa_ffffef4c
    char* _v4280;                          // _cfa_ffffef48
    char[2047]* _v4284;                    // _cfa_ffffef44
    char[2047]* _v4288;                    // _cfa_ffffef40
    char* _v4292;                          // _cfa_ffffef3c
    char* _v4296;                          // _cfa_ffffef38
    char[2047]* _v4300;                    // _cfa_ffffef34
    char* _v4304;                          // _cfa_ffffef30
    char* _v4308;                          // _cfa_ffffef2c
    char[2047]* _v4312;                    // _cfa_ffffef28
    char[2047]* _v4316;                    // _cfa_ffffef24
    char[2047]* _v4320;                    // _cfa_ffffef20
    char[2047]* _v4324;                    // _cfa_ffffef1c
    char* _v4328;                          // _cfa_ffffef18
    _unknown_ __ebp;                       // r6
    _unknown_ _t138;                       // _t138
    _unknown_ _t141;                       // _t141
    _unknown_ _t143;                       // _t143
    _unknown_ _t144;                       // _t144
    _unknown_ _t161;                       // _t161
    _unknown_ _t162;                       // _t162
    _unknown_ _t172;                       // _t172
    int _t173;                             // _t173
    _unknown_ _t177;                       // _t177
    _unknown_ _t179;                       // _t179
    _unknown_ _t182;                       // _t182
    signed int _t186;                      // _t186
    _unknown_ _t189;                       // _t189
    _unknown_ _t191;                       // _t191
    _unknown_ _t198;                       // _t198
    _unknown_ _t199;                       // _t199
    _unknown_ _t200;                       // _t200
    _unknown_ _t201;                       // _t201
    int _t228;                             // _t228

    _v4240 = _a4;
    _v4244 = _a8;
    _v4248 = _a12;
    _v4252 = _a16;
    _v16 =  *gs:0x14];
    fwrite("Un-installing...", 1, 16, __imp__stdout);
    _v4324 = _v4248;
    sprintf( &UNINSTALL_BASE, "UNINSTALL_BASE=%s");
    putenv( &UNINSTALL_BASE);
    verstr = strdup(_v4252);
    grass_major = strtok(verstr, ".");
    grass_minor = strtok(0, ".");
    grass_revision = strtok(0, ".");
    major = strtol(grass_major, 0, 10);
    minor = strtol(grass_minor, 0, 10);
    revision = strtol(grass_revision, 0, 10);
    free(verstr);
    atexit(exit_tmp);
    deregister_extension(_v4240, _v4244, _v4248);
    if(major == 6 && minor <= 0) {
        if(error == 0) {
            print_warning("no entries found to remove from GIS Manager.\n");
            memcpy( &GISMAN_CMD, 134572428, 1);
        }
    }
    deregister_entries_gisman2(_v4244, _v4248);
    deregister_html(_v4244, _v4248);
    _v4320 = _v4244;
    _v4324 = _v4248;
    sprintf( &script, "%s/etc/uninstall.%s");
    no_script = 0;
    _t173 =  &script;
    __stat(_t173,  &(buf.st_dev));
    error = _t173;
    if(error < 0) {
        print_warning("no uninstall script available for this extension.\n \t\t\tUnneeded files may have been left on your system.\n");
        no_script = 1;
    }
    _t228 = no_script;
    if(_t228 == 0) {
        if(VERBOSE == 0) {
            _v4268 =  &TMP_NULL;
            _v4272 = _v4248;
            _v4276 =  &TMP_NULL;
            _v4280 = _v4248;
            _v4284 =  &TMPDB;
            _v4288 =  &TMP_NULL;
            _v4292 = _v4244;
            _v4296 = _v4248;
            _v4300 =  &TMP_NULL;
            _v4304 = _v4244;
            _v4308 = _v4248;
            _v4312 =  &TMP_NULL;
            _v4316 =  &script;
            _v4320 =  &TMP_NULL;
            _v4324 =  &script;
            sprintf( &tmp, "sh %s &> %s ; rm -vf %s &> %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s &> %s ; rm -vf %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db &> %s ; chmod -v a+r %s/etc/extensions.db &> %s ;");
            strcpy( &UNINSTALL_CMD,  &tmp);
        } else {
            _v4292 = _v4248;
            _v4296 = _v4248;
            _v4300 =  &TMPDB;
            _v4304 = _v4244;
            _v4308 = _v4248;
            _v4312 = _v4244;
            _v4316 = _v4248;
            _v4320 =  &script;
            _v4324 =  &script;
            sprintf( &tmp, "sh %s ; rm -vf %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s ; rm -vf %s/etc/dm/gem-entries/%s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;");
            strcpy( &UNINSTALL_CMD,  &tmp);
        }
    } else {
        _v4328 = strerror( *(__errno_location()));
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system");
    }
    _v4316 =  &HTML_CMD;
    _v4320 =  &GISMAN_CMD;
    _v4324 =  &UNINSTALL_CMD;
    sprintf( &tmp, "%s %s %s");
    su(_v4248,  &tmp);
    print_done();
    _t186 = _v16 ^  *gs:0x14];
    if(_t228 == 0) {
        return _t186;
    } else {
        __stack_chk_fail();
        return _t186;
    }
}

int source_clean(char* package)
{// addr = 0x080521A4  --  defined in 'actions.c' at line 907
    intOrPtr _v16;                         // _cfa_fffffff0
    char[2047] dir;                        // _cfa_fffff7f0
    char[2047] sysstr;                     // _cfa_ffffeff0
    int error;                             // _cfa_ffffefec
    char* _v4128;                          // _cfa_ffffefe0
    char[2047]* _v4144;                    // _cfa_ffffefd0
    char[2047]* _v4148;                    // _cfa_ffffefcc
    _unknown_ _v4152;                      // _cfa_ffffefc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t36;                        // _t36
    _unknown_ _t40;                        // _t40
    _unknown_ _t46;                        // _t46
    _unknown_ _t49;                        // _t49
    _unknown_ _t52;                        // _t52
    _unknown_ _t53;                        // _t53
    _unknown_ _t55;                        // _t55
    _unknown_ _t58;                        // _t58
    _unknown_ _t65;                        // _t65
    _unknown_ _t69;                        // _t69

    _v4128 = _a4;
    _v16 =  *gs:0x14];
    _v4148 = basename(_v4128);
    sprintf( &dir, "%s/src");
    error = chdir( &dir);
    if(error < 0) {
        _v4148 = _v4128;
        print_error(-2, "extension '%s' not accessible: ");
    }
    if(VERBOSE == 0) {
        fwrite("Cleaning up...", 1, 14, __imp__stdout);
        _v4144 =  &TMP_NULL;
        _v4148 =  &MAKE_CMD;
        sprintf( &sysstr, "%s -f Makefile -s clean &> %s");
        error = system( &sysstr);
    } else {
        _v4148 =  &MAKE_CMD;
        fprintf(__imp__stdout, "Running '%s clean':\n");
        _v4148 =  &MAKE_CMD;
        sprintf( &sysstr, "%s -f Makefile clean");
        error = system( &sysstr);
    }
    _t69 = error - 255;
    if(_t69 != 0) {
        print_done();
    } else {
        _v4148 =  &MAKE_CMD;
        print_error(-9, "could not run '%s clean' do you have make tools installed?\n");
    }
    system("sh ../post");
    if(_t69 != 0) {
        __stack_chk_fail();
        return 0;
    }
    return 0;
}

restore(char* gisbase, char* grass_version)
{// addr = 0x08052334  --  defined in 'actions.c' at line 952
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    int num_restored;                      // _cfa_fffff7ec
    char* verstr;                          // _cfa_fffff7e8
    char* grass_major;                     // _cfa_fffff7e4
    char* grass_minor;                     // _cfa_fffff7e0
    char* grass_revision;                  // _cfa_fffff7dc
    int major;                             // _cfa_fffff7d8
    int minor;                             // _cfa_fffff7d4
    int revision;                          // _cfa_fffff7d0
    char* _v2112;                          // _cfa_fffff7c0
    char* _v2116;                          // _cfa_fffff7bc
    char* _v2140;                          // _cfa_fffff7a4
    char* _v2144;                          // _cfa_fffff7a0
    char[2047]* _v2148;                    // _cfa_fffff79c
    char[2047]* _v2152;                    // _cfa_fffff798
    char* _v2156;                          // _cfa_fffff794
    char* _v2160;                          // _cfa_fffff790
    char[2047]* _v2164;                    // _cfa_fffff78c
    _unknown_ _v2168;                      // _cfa_fffff788
    _unknown_ __ebp;                       // r6
    _unknown_ _t78;                        // _t78
    _unknown_ _t95;                        // _t95
    _unknown_ _t98;                        // _t98
    signed int _t103;                      // _t103
    _unknown_ _t107;                       // _t107
    _unknown_ _t112;                       // _t112
    _unknown_ _t114;                       // _t114
    _unknown_ _t119;                       // _t119
    int _t139;                             // _t139

    _v2112 = _a4;
    _v2116 = _a8;
    _v16 =  *gs:0x14];
    verstr = strdup(_v2116);
    grass_major = strtok(verstr, ".");
    grass_minor = strtok(0, ".");
    grass_revision = strtok(0, ".");
    major = strtol(grass_major, 0, 10);
    minor = strtol(grass_minor, 0, 10);
    revision = strtol(grass_revision, 0, 10);
    free(verstr);
    fwrite("Restoring...", 1, 12, __imp__stdout);
    if(major == 6 && minor <= 0) {
        num_restored = restore_entries_gisman(_v2112);
        if(VERBOSE != 0) {
            _v2164 = num_restored;
            fprintf(__imp__stdout, "\nRestored entries for GIS Manager: %i\n");
        }
    }
    num_restored = restore_html(_v2112);
    if(VERBOSE != 0) {
        _v2164 = num_restored;
        fprintf(__imp__stdout, "\nRestored links in index.hml: %i\n");
    }
    if(num_restored > 0) {
        if(VERBOSE == 0) {
            _v2140 = _v2112;
            _v2144 = _v2112;
            _v2148 =  &TMP_HTML;
            _v2152 =  &TMP_NULL;
            _v2156 = _v2112;
            _v2160 = _v2112;
            _v2164 =  &TMP_GISMAN;
            sprintf( &tmp, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl &> %s ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html");
        } else {
            _v2144 = _v2112;
            _v2148 = _v2112;
            _v2152 =  &TMP_HTML;
            _v2156 = _v2112;
            _v2160 = _v2112;
            _v2164 =  &TMP_GISMAN;
            sprintf( &tmp, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html");
        }
        su(_v2112,  &tmp);
    }
    _t139 = num_restored;
    if(_t139 != 0) {
        print_done();
    } else {
        print_error(-26, "could not find anything to restore.\n");
    }
    _t103 = _v16 ^  *gs:0x14];
    if(_t139 == 0) {
        return _t103;
    } else {
        __stack_chk_fail();
        return _t103;
    }
}

list_extensions(char* gisbase)
{// addr = 0x080525FC  --  defined in 'actions.c' at line 1022
    signed int _v16;                       // _cfa_fffffff0
    char[2047] file;                       // _cfa_fffff7f0
    FILE* f_in;           // _cfa_fffff7ec
    char[2047]* _v2080;                    // _cfa_fffff7e0
    char* _v2096;                          // _cfa_fffff7d0
    char[2047]* _v2100;                    // _cfa_fffff7cc
    _unknown_ _v2104;                      // _cfa_fffff7c8
    _unknown_ __ebp;                       // r6
    _unknown_ _t30;                        // _t30
    _unknown_ _t32;                        // _t32
    _unknown_ _t35;                        // _t35
    _unknown_ _t39;                        // _t39
    signed int _t42;                       // _t42
    _unknown_ _t46;                        // _t46
    _unknown_ _t53;                        // _t53
    _unknown_ _t55;                        // _t55
    _unknown_ _t56;                        // _t56
    _unknown_ _t62;                        // _t62

    _v2080 = _a4;
    _v16 =  *gs:0x14];
    _v2100 = _v2080;
    fprintf(__imp__stdout, "\nExtensions in '%s' (name, version, type, depends):\n");
    _v2100 = _v2080;
    sprintf( &file, "%s/etc/extensions.db");
    f_in = fopen( &file, "r");
    if(f_in == 0) {
        _t62 =  *(__errno_location()) - 2;
        if(_t62 == 0) {
            fwrite("NONE.\n", 1, 6, __imp__stderr);
            fclose(f_in);
            exit(0);
        }
        fclose(f_in);
        _v2096 = strerror( *(__errno_location()));
        _v2100 =  &file;
        print_error(-29, "checking for file '%s': %s\n");
    }
    fclose(f_in);
    dump_ascii( &file, 134572428);
    _t42 = _v16 ^  *gs:0x14];
    if(_t62 != 0) {
        __stack_chk_fail();
        return _t42;
    }
    return _t42;
}

run_post(char* package, int action, char* bins, char* gisbase)
{// addr = 0x08052748  --  defined in 'actions.c' at line 1057
    signed int _v16;                       // _cfa_fffffff0
    char[2047] tmp;                        // _cfa_fffff7f0
    char[2047] tmp2;                       // _cfa_ffffeff0
    char* _v4128;                          // _cfa_ffffefe0
    char[2047]* _v4132;                    // _cfa_ffffefdc
    char[2047]* _v4136;                    // _cfa_ffffefd8
    char* _v4144;                          // _cfa_ffffefd0
    int _v4148;                            // _cfa_ffffefcc
    _unknown_ _v4152;                      // _cfa_ffffefc8
    _unknown_ __ebp;                       // r6
    _unknown_ _t53;                        // _t53
    _unknown_ _t56;                        // _t56
    _unknown_ _t58;                        // _t58
    _unknown_ _t59;                        // _t59
    _unknown_ _t61;                        // _t61
    _unknown_ _t66;                        // _t66
    _unknown_ _t68;                        // _t68
    _unknown_ _t69;                        // _t69
    _unknown_ _t71;                        // _t71
    _unknown_ _t72;                        // _t72
    _unknown_ _t75;                        // _t75
    _unknown_ _t77;                        // _t77
    _unknown_ _t78;                        // _t78
    _unknown_ _t81;                        // _t81
    _unknown_ _t83;                        // _t83
    _unknown_ _t84;                        // _t84
    _unknown_ _t86;                        // _t86
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    signed int _t90;                       // _t90
    _unknown_ _t92;                        // _t92
    _unknown_ _t94;                        // _t94
    _unknown_ _t95;                        // _t95
    char[2047]* _t106;                     // _t106

    _v4128 = _a4;
    _v4132 = _a12;
    _v4136 = _a16;
    _v16 =  *gs:0x14];
    if(action - 3 <= 6) {
        goto __eax;
    }
    putenv( &GEM_ACTION);
    if(_v4136 == 0) {
        memcpy( &INSTALL_BASE, "INSTALL_BASE=UNDEFINED", 23);
    } else {
        _v4148 = _v4136;
        sprintf( &INSTALL_BASE, "INSTALL_BASE=%s");
    }
    putenv( &INSTALL_BASE);
    getcwd( &tmp, 2048);
    _v4144 = basename(_v4128);
    _v4148 =  &tmp;
    sprintf( &tmp2, "%s/%s/src");
    _v4148 =  &tmp2;
    sprintf( &EXT_BASE, "EXT_BASE=%s");
    putenv( &EXT_BASE);
    _t106 = _v4132;
    if(_t106 != 0) {
        _v4148 = _v4132;
        sprintf( &INSTALL_TYPE, "INSTALL_TYPE=%s");
    } else {
        memcpy( &INSTALL_TYPE, "INSTALL_TYPE=src", 17);
    }
    putenv( &INSTALL_TYPE);
    _v4148 = FORCE;
    sprintf( &tmp, "%i");
    _v4148 =  &tmp;
    sprintf( &GEM_FORCE, "GEM_FORCE=%s");
    putenv( &GEM_FORCE);
    _v4148 = VERBOSE;
    sprintf( &tmp, "%i");
    _v4148 =  &tmp;
    sprintf( &GEM_VERBOSE, "GEM_VERBOSE=%s");
    putenv( &GEM_VERBOSE);
    memcpy( &GEM_GUI, "GEM_GUI=0", 10);
    putenv( &GEM_GUI);
    atexit(exit_tmp);
    _t90 = _v16 ^  *gs:0x14];
    if(_t106 == 0) {
    } else {
        __stack_chk_fail();
        return _t90;
    }
    goto L10;
L11:
L10:
    return _t90;
    goto L11;
}

show_help()
{// addr = 0x08052A50  --  defined in 'main.c' at line 148
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    char* _v24;                            // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v44;                       // _cfa_ffffffd4
    char _v2080;                           // _cfa_fffff7e0
    FILE* _v2084;         // _cfa_fffff7dc
    intOrPtr _v2088;                       // _cfa_fffff7d8
    char _v2092;                           // _cfa_fffff7d4
    int _v2096;                            // _cfa_fffff7d0
    char* _v2108;                          // _cfa_fffff7c4
    char* _v2124;                          // _cfa_fffff7b4
    FILE* _v2128;         // _cfa_fffff7b0
    char* _v2132;                          // _cfa_fffff7ac
    signed int _v2152;                     // _cfa_fffff798
    char _v4200;                           // _cfa_ffffef98
    int _v4204;                            // _cfa_ffffef94
    char* _v4216;                          // _cfa_ffffef88
    char* _v4232;                          // _cfa_ffffef78
    intOrPtr _v4236;                       // _cfa_ffffef74
    _unknown_ _v4240;                      // _cfa_ffffef70
    _unknown_ _v4260;                      // _cfa_ffffef5c
    _unknown_ _v4264;                      // _cfa_ffffef58
    intOrPtr _v4268;                       // _cfa_ffffef54
    signed int _v4288;                     // _cfa_ffffef40
    intOrPtr _v6352;                       // _cfa_ffffe730
    int _v6372;                            // _cfa_ffffe71c
    char* _v6376;                          // _cfa_ffffe718
    _unknown_ __ebp;                       // r6
    _unknown_ _t174;                       // _t174
    _unknown_ _t177;                       // _t177
    _unknown_ _t180;                       // _t180
    _unknown_ _t183;                       // _t183
    _unknown_ _t186;                       // _t186
    _unknown_ _t189;                       // _t189
    _unknown_ _t192;                       // _t192
    _unknown_ _t195;                       // _t195
    _unknown_ _t198;                       // _t198
    _unknown_ _t201;                       // _t201
    _unknown_ _t204;                       // _t204
    _unknown_ _t207;                       // _t207
    _unknown_ _t210;                       // _t210
    _unknown_ _t213;                       // _t213
    _unknown_ _t216;                       // _t216
    _unknown_ _t219;                       // _t219
    _unknown_ _t222;                       // _t222
    _unknown_ _t225;                       // _t225
    _unknown_ _t228;                       // _t228
    _unknown_ _t231;                       // _t231
    _unknown_ _t234;                       // _t234
    _unknown_ _t237;                       // _t237
    _unknown_ _t240;                       // _t240
    _unknown_ _t243;                       // _t243
    _unknown_ _t246;                       // _t246
    _unknown_ _t249;                       // _t249
    _unknown_ _t252;                       // _t252
    _unknown_ _t255;                       // _t255
    _unknown_ _t258;                       // _t258
    _unknown_ _t261;                       // _t261
    _unknown_ _t264;                       // _t264
    _unknown_ _t267;                       // _t267
    _unknown_ _t270;                       // _t270
    _unknown_ _t273;                       // _t273
    _unknown_ _t276;                       // _t276
    _unknown_ _t279;                       // _t279
    _unknown_ _t280;                       // _t280
    _unknown_ _t283;                       // _t283
    _unknown_ _t287;                       // _t287
    _unknown_ _t290;                       // _t290
    _unknown_ _t291;                       // _t291
    _unknown_ _t294;                       // _t294
    _unknown_ _t298;                       // _t298
    _unknown_ _t301;                       // _t301
    _unknown_ _t302;                       // _t302
    _unknown_ _t304;                       // _t304
    _unknown_ _t307;                       // _t307
    _unknown_ _t310;                       // _t310
    _unknown_ _t313;                       // _t313
    _unknown_ _t316;                       // _t316
    _unknown_ _t317;                       // _t317
    _unknown_ _t320;                       // _t320
    _unknown_ _t325;                       // _t325
    signed int _t332;                      // _t332
    _unknown_ _t334;                       // _t334
    _unknown_ _t387;                       // _t387
    _unknown_ _t388;                       // _t388
    _unknown_ _t389;                       // _t389
    _unknown_ _t390;                       // _t390
    _unknown_ _t391;                       // _t391
    FILE* _t395;          // _t395

    fwrite("Usage: gem64 [OPTION] [ACTION] [FILE|DIR]\n", 1, 42, __imp__stdout);
    fwrite("Install a GRASS extension from FILE or DIR.\n", 1, 44, __imp__stdout);
    fwrite("Manage (installed) GRASS extension(s).\n", 1, 39, __imp__stdout);
    fwrite("\nPossible ACTIONs are:\n", 1, 23, __imp__stdout);
    fwrite("  -i, --install=EXT\tinstall a GRASS extension\n", 1, 46, __imp__stdout);
    fwrite("  -u, --uninstall=EXT\tremove an extension from GRASS\n", 1, 53, __imp__stdout);
    fwrite("  -q, --query=EXT\tdisplay information about extension/list installed\n", 1, 69, __imp__stdout);
    fwrite("  -d, --details=EXT\tdisplay additional details about an extension\n", 1, 66, __imp__stdout);
    fwrite("  -c, --clean=EXT\tclean extension's source code directories\n", 1, 60, __imp__stdout);
    fwrite("  -t, --test=EXT\tconfigure and compile extension, but don't install\n", 1, 68, __imp__stdout);
    fwrite("  -l, --license=EXT\tshow copyright information for an extension\n", 1, 64, __imp__stdout);
    fwrite("  -r, --restore\t\trecreate HTML links and GIS Manager entries\n", 1, 61, __imp__stdout);
    fwrite("  -h, --help\t\tdisplay this help and exit\n", 1, 41, __imp__stdout);
    fwrite("  -V, --version\t\toutput version information and exit\n\n", 1, 54, __imp__stdout);
    fwrite("\nPossible OPTIONs are:\n", 1, 23, __imp__stdout);
    fwrite("  -g, --grass=PATH\tpath to GRASS installation dir\n", 1, 50, __imp__stdout);
    fwrite("  -b, --binary=NAME\tno compilation: use binary files for system NAME\n", 1, 69, __imp__stdout);
    fwrite("  -f, --force\t\tforce action, regardless of dependencies\n", 1, 56, __imp__stdout);
    fwrite("  -v, --verbose\t\tdisplay detailed status information\n", 1, 53, __imp__stdout);
    fwrite("  -s, --skip-config\tskip configure script\n", 1, 42, __imp__stdout);
    fwrite("  -x, --config-opts=OPTS\tpass OPTS to configure script\n", 1, 55, __imp__stdout);
    fwrite("  -o, --options=OPTS\toptions to pass to the C compiler/linker\n", 1, 62, __imp__stdout);
    fwrite("  -C, --config-cmd=CMD\tDefine custom 'configure' command (default=configure)\n", 1, 77, __imp__stdout);
    fwrite("  -m, --make-cmd=CMD\tDefine custom 'make' command (default=make)\n", 1, 65, __imp__stdout);
    fwrite("\nWhen run from within a GRASS session, locations of libs, header files\n", 1, 71, __imp__stdout);
    fwrite("and installation target dir will be assumed to match those of the active\n", 1, 73, __imp__stdout);
    fwrite("GRASS version. ", 1, 15, __imp__stdout);
    fwrite("Option -g can be used to override these or install extensions\nfrom outside", 1, 74, __imp__stdout);
    fwrite("of a GRASS session.\n", 1, 20, __imp__stdout);
    fwrite("Per default, extensions will be compiled from source and then installed.\n", 1, 73, __imp__stdout);
    fwrite("If the exension package contains binaries for the user's platform, they can\n", 1, 76, __imp__stdout);
    fwrite("be installed instead using the -b option. ", 1, 42, __imp__stdout);
    fwrite("For installation from source code, a C compiler and make tools are needed.\n", 1, 75, __imp__stdout);
    fwrite("\nExample:\n", 1, 10, __imp__stdout);
    fwrite("\tgem64 -b macosx --grass=/usr/local/grass-6.4.0 -i myExtension\n", 1, 63, __imp__stdout);
    fwrite("Installs the MacOS X binaries for 'myExtension' in /usr/local/grass-6.4.0.\n", 1, 75, __imp__stdout);
    exit(0);
    _push(_t387);
    _t388 = __esp;
    __esp = __esp - 2104;
    _v2108 = _v24;
    _v44 =  *gs:0x14];
    strcpy( &_v2092, basename(_v2108));
    _v2096 = chdir( &_v2092);
    if(_v2096 < 0) {
        _v2124 = strerror( *(__errno_location()));
        _v2128 = _v2084;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("info", "Detailed information");
    system("sh post");
    exit(0);
    _push(_t388);
    _t389 = __esp;
    __esp = __esp - 2104;
    _v4216 = _v2132;
    _v2152 =  *gs:0x14];
    strcpy( &_v4200, basename(_v4216));
    _v4204 = chdir( &_v4200);
    if(_v4204 < 0) {
        _v4232 = strerror( *(__errno_location()));
        _v4236 = _v2088;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("license", "Detailed information");
    system("sh post");
    exit(0);
    _push(_t389);
    _t390 = __esp;
    __esp = __esp - 24;
    asm("fld qword [0x8057e40]");
    asm("fstp qword [esp+0x8]");
    fprintf(__imp__stdout, "gem64 (GRASS extensions manager) %.2f\n");
    fwrite("Written by Benjamin Ducke\n", 1, 26, __imp__stdout);
    fwrite("\nCopyright (C) 2005 Benjamin Ducke\n", 1, 35, __imp__stdout);
    fwrite("This is free software; see the source for copying conditions.  There is NO\n", 1, 75, __imp__stdout);
    fwrite("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 1, 76, __imp__stdout);
    exit(0);
    _push(_t390);
    __esp = __esp - 2104;
    _v6352 = _v4268;
    _v4288 =  *gs:0x14];
    if((CONFIG_OPTS & 0xff) == 0) {
        _v6372 = _v2096;
        sprintf( &_v2080, "%s/etc/config.system");
        _v2084 = fopen( &_v2080, "r");
        _t395 = _v2084;
        if(_t395 != 0) {
            if(nc_fgets_nb( &_v2080, 2048, _v2084) != 0) {
                strcpy( &CONFIG_OPTS,  &_v2080);
            }
        } else {
            _v6376 =  &_v2080;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    _t332 = _v32 ^  *gs:0x14];
    if(_t395 != 0) {
        __stack_chk_fail();
        return _t332;
    }
    return _t332;
}

show_details(char* package)
{// addr = 0x08053002  --  defined in 'main.c' at line 213
    signed int _v16;                       // _cfa_fffffff0
    signed int _v28;                       // _cfa_ffffffe4
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    char _v2076;                           // _cfa_fffff7e4
    FILE* _v2080;         // _cfa_fffff7e0
    intOrPtr _v2084;                       // _cfa_fffff7dc
    intOrPtr _v2092;                       // _cfa_fffff7d4
    char* _v2096;                          // _cfa_fffff7d0
    FILE* _v2100;         // _cfa_fffff7cc
    char* _v2104;                          // _cfa_fffff7c8
    signed int _v2124;                     // _cfa_fffff7b4
    char _v4172;                           // _cfa_ffffefb4
    int _v4176;                            // _cfa_ffffefb0
    char* _v4188;                          // _cfa_ffffefa4
    char* _v4204;                          // _cfa_ffffef94
    intOrPtr _v4208;                       // _cfa_ffffef90
    _unknown_ _v4212;                      // _cfa_ffffef8c
    _unknown_ _v4232;                      // _cfa_ffffef78
    _unknown_ _v4236;                      // _cfa_ffffef74
    intOrPtr _v4240;                       // _cfa_ffffef70
    signed int _v4260;                     // _cfa_ffffef5c
    intOrPtr _v6324;                       // _cfa_ffffe74c
    intOrPtr _v6344;                       // _cfa_ffffe738
    char* _v6348;                          // _cfa_ffffe734
    _unknown_ __ebp;                       // r6
    _unknown_ _t66;                        // _t66
    _unknown_ _t70;                        // _t70
    _unknown_ _t73;                        // _t73
    _unknown_ _t74;                        // _t74
    _unknown_ _t77;                        // _t77
    _unknown_ _t81;                        // _t81
    _unknown_ _t84;                        // _t84
    _unknown_ _t85;                        // _t85
    _unknown_ _t87;                        // _t87
    _unknown_ _t90;                        // _t90
    _unknown_ _t93;                        // _t93
    _unknown_ _t96;                        // _t96
    _unknown_ _t99;                        // _t99
    _unknown_ _t100;                       // _t100
    _unknown_ _t103;                       // _t103
    _unknown_ _t108;                       // _t108
    signed int _t115;                      // _t115
    _unknown_ _t117;                       // _t117
    _unknown_ _t134;                       // _t134
    _unknown_ _t135;                       // _t135
    _unknown_ _t136;                       // _t136
    _unknown_ _t137;                       // _t137
    FILE* _t141;          // _t141

    _v2080 = _a4;
    _v16 =  *gs:0x14];
    strcpy( &tmp, basename(_v2080));
    error = chdir( &tmp);
    if(error < 0) {
        _v2096 = strerror( *(__errno_location()));
        _v2100 = _v2080;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("info", "Detailed information");
    system("sh post");
    exit(0);
    _push(_t134);
    _t135 = __esp;
    __esp = __esp - 2104;
    _v4188 = _v2104;
    _v2124 =  *gs:0x14];
    strcpy( &_v4172, basename(_v4188));
    _v4176 = chdir( &_v4172);
    if(_v4176 < 0) {
        _v4204 = strerror( *(__errno_location()));
        _v4208 = _v2084;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("license", "Detailed information");
    system("sh post");
    exit(0);
    _push(_t135);
    _t136 = __esp;
    __esp = __esp - 24;
    asm("fld qword [0x8057e40]");
    asm("fstp qword [esp+0x8]");
    fprintf(__imp__stdout, "gem64 (GRASS extensions manager) %.2f\n");
    fwrite("Written by Benjamin Ducke\n", 1, 26, __imp__stdout);
    fwrite("\nCopyright (C) 2005 Benjamin Ducke\n", 1, 35, __imp__stdout);
    fwrite("This is free software; see the source for copying conditions.  There is NO\n", 1, 75, __imp__stdout);
    fwrite("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 1, 76, __imp__stdout);
    exit(0);
    _push(_t136);
    __esp = __esp - 2104;
    _v6324 = _v4240;
    _v4260 =  *gs:0x14];
    if((CONFIG_OPTS & 0xff) == 0) {
        _v6344 = _v2092;
        sprintf( &_v2076, "%s/etc/config.system");
        _v2080 = fopen( &_v2076, "r");
        _t141 = _v2080;
        if(_t141 != 0) {
            if(nc_fgets_nb( &_v2076, 2048, _v2080) != 0) {
                strcpy( &CONFIG_OPTS,  &_v2076);
            }
        } else {
            _v6348 =  &_v2076;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    _t115 = _v28 ^  *gs:0x14];
    if(_t141 != 0) {
        __stack_chk_fail();
        return _t115;
    }
    return _t115;
}

show_license(char* package)
{// addr = 0x080530B9  --  defined in 'main.c' at line 236
    signed int _v16;                       // _cfa_fffffff0
    signed int _v24;                       // _cfa_ffffffe8
    char[2047] tmp;                        // _cfa_fffff7f0
    int error;                             // _cfa_fffff7ec
    char _v2072;                           // _cfa_fffff7e8
    FILE* _v2076;         // _cfa_fffff7e4
    char* _v2080;                          // _cfa_fffff7e0
    intOrPtr _v2088;                       // _cfa_fffff7d8
    char* _v2096;                          // _cfa_fffff7d0
    char* _v2100;                          // _cfa_fffff7cc
    _unknown_ _v2104;                      // _cfa_fffff7c8
    _unknown_ _v2124;                      // _cfa_fffff7b4
    _unknown_ _v2128;                      // _cfa_fffff7b0
    intOrPtr _v2132;                       // _cfa_fffff7ac
    signed int _v2152;                     // _cfa_fffff798
    intOrPtr _v4216;                       // _cfa_ffffef88
    intOrPtr _v4236;                       // _cfa_ffffef74
    char* _v4240;                          // _cfa_ffffef70
    _unknown_ __ebp;                       // r6
    _unknown_ _t52;                        // _t52
    _unknown_ _t56;                        // _t56
    _unknown_ _t59;                        // _t59
    _unknown_ _t60;                        // _t60
    _unknown_ _t62;                        // _t62
    _unknown_ _t65;                        // _t65
    _unknown_ _t68;                        // _t68
    _unknown_ _t71;                        // _t71
    _unknown_ _t74;                        // _t74
    _unknown_ _t75;                        // _t75
    _unknown_ _t78;                        // _t78
    _unknown_ _t83;                        // _t83
    signed int _t90;                       // _t90
    _unknown_ _t92;                        // _t92
    _unknown_ _t105;                       // _t105
    _unknown_ _t106;                       // _t106
    _unknown_ _t107;                       // _t107
    FILE* _t110;          // _t110

    _v2080 = _a4;
    _v16 =  *gs:0x14];
    strcpy( &tmp, basename(_v2080));
    error = chdir( &tmp);
    if(error < 0) {
        _v2096 = strerror( *(__errno_location()));
        _v2100 = _v2080;
        print_error(-2, "extension '%s' not accessible: (%s)\n");
    }
    dump_ascii("license", "Detailed information");
    system("sh post");
    exit(0);
    _push(_t105);
    _t106 = __esp;
    __esp = __esp - 24;
    asm("fld qword [0x8057e40]");
    asm("fstp qword [esp+0x8]");
    fprintf(__imp__stdout, "gem64 (GRASS extensions manager) %.2f\n");
    fwrite("Written by Benjamin Ducke\n", 1, 26, __imp__stdout);
    fwrite("\nCopyright (C) 2005 Benjamin Ducke\n", 1, 35, __imp__stdout);
    fwrite("This is free software; see the source for copying conditions.  There is NO\n", 1, 75, __imp__stdout);
    fwrite("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 1, 76, __imp__stdout);
    exit(0);
    _push(_t106);
    __esp = __esp - 2104;
    _v4216 = _v2132;
    _v2152 =  *gs:0x14];
    if((CONFIG_OPTS & 0xff) == 0) {
        _v4236 = _v2088;
        sprintf( &_v2072, "%s/etc/config.system");
        _v2076 = fopen( &_v2072, "r");
        _t110 = _v2076;
        if(_t110 != 0) {
            if(nc_fgets_nb( &_v2072, 2048, _v2076) != 0) {
                strcpy( &CONFIG_OPTS,  &_v2072);
            }
        } else {
            _v4240 =  &_v2072;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    _t90 = _v24 ^  *gs:0x14];
    if(_t110 != 0) {
        __stack_chk_fail();
        return _t90;
    }
    return _t90;
}

show_version()
{// addr = 0x08053170  --  defined in 'main.c' at line 258
    _unknown_ _v16;                        // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _v44;                       // _cfa_ffffffd4
    char _v2068;                           // _cfa_fffff7ec
    FILE* _v2072;         // _cfa_fffff7e8
    intOrPtr _v2084;                       // _cfa_fffff7dc
    intOrPtr _v2108;                       // _cfa_fffff7c4
    intOrPtr _v2128;                       // _cfa_fffff7b0
    char* _v2132;                          // _cfa_fffff7ac
    _unknown_ __ebp;                       // r6
    _unknown_ _t37;                        // _t37
    _unknown_ _t40;                        // _t40
    _unknown_ _t43;                        // _t43
    _unknown_ _t46;                        // _t46
    _unknown_ _t49;                        // _t49
    _unknown_ _t50;                        // _t50
    _unknown_ _t53;                        // _t53
    _unknown_ _t58;                        // _t58
    signed int _t65;                       // _t65
    _unknown_ _t67;                        // _t67
    _unknown_ _t76;                        // _t76
    _unknown_ _t77;                        // _t77
    FILE* _t79;           // _t79

    asm("fld qword [0x8057e40]");
    asm("fstp qword [esp+0x8]");
    fprintf(__imp__stdout, "gem64 (GRASS extensions manager) %.2f\n");
    fwrite("Written by Benjamin Ducke\n", 1, 26, __imp__stdout);
    fwrite("\nCopyright (C) 2005 Benjamin Ducke\n", 1, 35, __imp__stdout);
    fwrite("This is free software; see the source for copying conditions.  There is NO\n", 1, 75, __imp__stdout);
    fwrite("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 1, 76, __imp__stdout);
    exit(0);
    _push(_t76);
    __esp = __esp - 2104;
    _v2108 = _v24;
    _v44 =  *gs:0x14];
    if((CONFIG_OPTS & 0xff) == 0) {
        _v2128 = _v2084;
        sprintf( &_v2068, "%s/etc/config.system");
        _v2072 = fopen( &_v2068, "r");
        _t79 = _v2072;
        if(_t79 != 0) {
            if(nc_fgets_nb( &_v2068, 2048, _v2072) != 0) {
                strcpy( &CONFIG_OPTS,  &_v2068);
            }
        } else {
            _v2132 =  &_v2068;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    _t65 = _v20 ^  *gs:0x14];
    if(_t79 == 0) {
        return _t65;
    } else {
        __stack_chk_fail();
        return _t65;
    }
}

get_configure_options(char* gisbase)
{// addr = 0x08053242  --  defined in 'main.c' at line 274
    signed int _v16;                       // _cfa_fffffff0
    char[2047] str;                        // _cfa_fffff7f0
    FILE* fp;             // _cfa_fffff7ec
    intOrPtr _v2080;                       // _cfa_fffff7e0
    intOrPtr _v2100;                       // _cfa_fffff7cc
    char[2047]* _v2104;                    // _cfa_fffff7c8
    _unknown_ __ebp;                       // r6
    _unknown_ _t25;                        // _t25
    _unknown_ _t30;                        // _t30
    signed int _t37;                       // _t37
    _unknown_ _t39;                        // _t39
    FILE* _t44;           // _t44

    _v2080 = _a4;
    _v16 =  *gs:0x14];
    if((CONFIG_OPTS & 0xff) == 0) {
        _v2100 = _v2080;
        sprintf( &str, "%s/etc/config.system");
        fp = fopen( &str, "r");
        _t44 = fp;
        if(_t44 != 0) {
            if(nc_fgets_nb( &str, 2048, fp) != 0) {
                strcpy( &CONFIG_OPTS,  &str);
            }
        } else {
            _v2104 =  &str;
            print_warning("could not open %s for read access. Using default configure options.\n");
        }
    }
    _t37 = _v16 ^  *gs:0x14];
    if(_t44 == 0) {
        return _t37;
    } else {
        __stack_chk_fail();
        return _t37;
    }
}

int main(int argc, char** argv)
{// addr = 0x0805331E  --  defined in 'main.c' at line 302
    char* gisbase;                         // r4+328
    char* grass_version;                   // r4+324
    char* grass_major;                     // r4+320
    char* grass_minor;                     // r4+316
    char* grass_revision;                  // r4+312
    char* tmp;                             // r4+308
    char* url;                             // r4+304
    char* filepart;                        // r4+300
    char[2047] version_file;               // r4+12620
    char[2047] package;                    // r4+10572
    char[2047] orgname;                    // r4+8524
    char[2047] pkg_name;                   // r4+6476
    char* bins;                            // r4+296
    int pkg_major;                         // r4+292
    int pkg_minor;                         // r4+288
    int pkg_revision;                      // r4+284
    FILE* f;              // r4+280
    int fd;                                // r4+276
    char[2047] pkg_short_name;             // r4+4428
    char[2047] invocation;                 // r4+2380
    char[2047] coptions;                   // r4+332
    int major;                             // r4+272
    int minor;                             // r4+268
    int revision;                          // r4+264
    int option;                            // r4+260
    int action;                            // r4+256
    int valid;                             // r4+252
    struct stat buf;      // r4+140
    struct stat buf2;     // r4+52
    int error;                             // r4+248
    int is_directory;                      // r4+244
    DIR* dir;              // r4+240
    struct dirent* dir_entry;   // r4+236
    int dir_found;                         // r4+232
    int option_index;                      // r4+228
    intOrPtr _v24;                         // _cfa_ffffffe8
    char _v2072;                           // _cfa_fffff7e8
    char _v4120;                           // _cfa_ffffefe8
    char _v6168;                           // _cfa_ffffe7e8
    char _v8216;                           // _cfa_ffffdfe8
    char _v10264;                          // _cfa_ffffd7e8
    char _v12312;                          // _cfa_ffffcfe8
    char _v14360;                          // _cfa_ffffc7e8
    char* _v14364;                         // _cfa_ffffc7e4
    char* _v14368;                         // _cfa_ffffc7e0
    char* _v14372;                         // _cfa_ffffc7dc
    char* _v14376;                         // _cfa_ffffc7d8
    char* _v14380;                         // _cfa_ffffc7d4
    char* _v14384;                         // _cfa_ffffc7d0
    char* _v14388;                         // _cfa_ffffc7cc
    char* _v14392;                         // _cfa_ffffc7c8
    char* _v14396;                         // _cfa_ffffc7c4
    int _v14400;                           // _cfa_ffffc7c0
    int _v14404;                           // _cfa_ffffc7bc
    int _v14408;                           // _cfa_ffffc7b8
    struct _IO_FILE* _v14412;   // _cfa_ffffc7b4
    int _v14416;                           // _cfa_ffffc7b0
    char* _v14420;                         // _cfa_ffffc7ac
    long _v14424;                          // _cfa_ffffc7a8
    long _v14428;                          // _cfa_ffffc7a4
    int _v14432;                           // _cfa_ffffc7a0
    int _v14436;                           // _cfa_ffffc79c
    int _v14440;                           // _cfa_ffffc798
    char* _v14444;                         // _cfa_ffffc794
    int _v14448;                           // _cfa_ffffc790
    char[2047]* _v14452;                   // _cfa_ffffc78c
    char[2047]* _v14456;                   // _cfa_ffffc788
    int _v14460;                           // _cfa_ffffc784
    int _v14464;                           // _cfa_ffffc780
    signed int _v14536;                    // _cfa_ffffc738
    char _v14552;                          // _cfa_ffffc728
    signed int _v14624;                    // _cfa_ffffc6e0
    char _v14640;                          // _cfa_ffffc6d0
    __builtin_va_list* _v14648;   // _cfa_ffffc6c8
    _unknown_ _v14664;                     // _cfa_ffffc6b8
    _unknown_ _v14668;                     // _cfa_ffffc6b4
    _unknown_ _v14672;                     // _cfa_ffffc6b0
    long _v14676;                          // _cfa_ffffc6ac
    char* _v14680;                         // _cfa_ffffc6a8
    char* _v14684;                         // _cfa_ffffc6a4
    char* _v14688;                         // _cfa_ffffc6a0
    _unknown_ __ebp;                       // r6
    _unknown_ _t407;                       // _t407
    _unknown_ _t408;                       // _t408
    _unknown_ _t409;                       // _t409
    _unknown_ _t410;                       // _t410
    _unknown_ _t411;                       // _t411
    _unknown_ _t412;                       // _t412
    _unknown_ _t413;                       // _t413
    _unknown_ _t414;                       // _t414
    _unknown_ _t415;                       // _t415
    _unknown_ _t416;                       // _t416
    _unknown_ _t417;                       // _t417
    _unknown_ _t418;                       // _t418
    _unknown_ _t419;                       // _t419
    _unknown_ _t420;                       // _t420
    _unknown_ _t421;                       // _t421
    _unknown_ _t422;                       // _t422
    _unknown_ _t423;                       // _t423
    _unknown_ _t424;                       // _t424
    _unknown_ _t425;                       // _t425
    _unknown_ _t426;                       // _t426
    _unknown_ _t427;                       // _t427
    _unknown_ _t428;                       // _t428
    _unknown_ _t429;                       // _t429
    _unknown_ _t430;                       // _t430
    _unknown_ _t431;                       // _t431
    _unknown_ _t432;                       // _t432
    _unknown_ _t433;                       // _t433
    _unknown_ _t434;                       // _t434
    _unknown_ _t435;                       // _t435
    _unknown_ _t436;                       // _t436
    _unknown_ _t437;                       // _t437
    _unknown_ _t438;                       // _t438
    _unknown_ _t439;                       // _t439
    _unknown_ _t441;                       // _t441
    _unknown_ _t443;                       // _t443
    _unknown_ _t444;                       // _t444
    _unknown_ _t446;                       // _t446
    _unknown_ _t447;                       // _t447
    _unknown_ _t452;                       // _t452
    _unknown_ _t454;                       // _t454
    _unknown_ _t455;                       // _t455
    _unknown_ _t468;                       // _t468
    _unknown_ _t470;                       // _t470
    _unknown_ _t473;                       // _t473
    _unknown_ _t475;                       // _t475
    _unknown_ _t482;                       // _t482
    _unknown_ _t489;                       // _t489
    _unknown_ _t496;                       // _t496
    _unknown_ _t497;                       // _t497
    _unknown_ _t505;                       // _t505
    _unknown_ _t510;                       // _t510
    _unknown_ _t512;                       // _t512
    _unknown_ _t521;                       // _t521
    int _t522;                             // _t522
    _unknown_ _t532;                       // _t532
    _unknown_ _t537;                       // _t537
    _unknown_ _t542;                       // _t542
    _unknown_ _t547;                       // _t547
    _unknown_ _t566;                       // _t566
    _unknown_ _t569;                       // _t569
    _unknown_ _t572;                       // _t572
    struct _IO_FILE* _t577;   // _t577
    _unknown_ _t579;                       // _t579
    _unknown_ _t581;                       // _t581
    _unknown_ _t584;                       // _t584
    _unknown_ _t585;                       // _t585
    _unknown_ _t587;                       // _t587
    _unknown_ _t589;                       // _t589
    _unknown_ _t593;                       // _t593
    _unknown_ _t600;                       // _t600
    _unknown_ _t608;                       // _t608
    char* _t609;                           // _t609
    char* _t613;                           // _t613
    char[2047]* _t614;                     // _t614
    char[2047]* _t618;                     // _t618
    _unknown_ _t621;                       // _t621
    _unknown_ _t628;                       // _t628
    _unknown_ _t634;                       // _t634
    _unknown_ _t638;                       // _t638
    _unknown_ _t644;                       // _t644
    _unknown_ _t649;                       // _t649
    _unknown_ _t651;                       // _t651
    _unknown_ _t656;                       // _t656
    _unknown_ _t658;                       // _t658
    _unknown_ _t661;                       // _t661
    _unknown_ _t662;                       // _t662
    _unknown_ _t667;                       // _t667
    _unknown_ _t668;                       // _t668
    _unknown_ _t669;                       // _t669
    _unknown_ _t678;                       // _t678
    _unknown_ _t681;                       // _t681
    _unknown_ _t682;                       // _t682
    _unknown_ _t683;                       // _t683
    _unknown_ _t725;                       // _t725
    _unknown_ _t726;                       // _t726

    __esp = __esp & 240;
    _push(__ebx);
    __esp = __esp - 14684;
    _v14648 = _a8;
    _v24 =  *gs:0x14];
    _v14448 = 0;
    _v14464 = 0;
    VERBOSE = 0;
    TMPCLEAN = 0;
    TMPDBCLEAN = 0;
    FORCE = 0;
    UPGRADE = 0;
    ERROR = 0;
    WARNINGS = 0;
    SKIP_CFG = 0;
    memcpy( &GISMAN_CMD, 134576421, 1);
    memcpy( &GISMAN2_CMD, 134576421, 1);
    memcpy( &QGIS_CMD, 134576421, 1);
    memcpy( &UNINSTALL_CMD, 134576421, 1);
    memcpy( &HTML_CMD, 134576421, 1);
    memcpy( &TMPDIR, 134576421, 1);
    memcpy( &TMPDB, 134576421, 1);
    memcpy( &TMP_GISMAN, 134576421, 1);
    memcpy( &TMP_DESCR, 134576421, 1);
    memcpy( &TMP_INFO, 134576421, 1);
    memcpy( &TMP_DEPS, 134576421, 1);
    memcpy( &TMP_BUGS, 134576421, 1);
    memcpy( &TMP_AUTHORS, 134576421, 1);
    memcpy( &TMP_HTML, 134576421, 1);
    memcpy( &TMP_NULL, 134576421, 1);
    memcpy( &CONFIG_OPTS, 134576421, 1);
    memcpy( &CONFIG_CMD, "configure", 10);
    memcpy( &MAKE_CMD, "make", 5);
    getcwd( &CWD, 2048);
    fwrite(134576437, 1, 4, __imp__stdout);
    _v14384 = malloc(2048);
    strcpy( &_v12312,  *_v14648);
    setvbuf(__imp__stdout, 0, 2, 0);
    if(argc == 1) {
        show_help();
        exit(0);
    }
    atexit(exit_msg);
    _v14440 = 0;
    _v14396 = 0;
    _v14364 = 0;
    __imp__opterr = 0;
    _v14432 = getopt_long(argc, _v14648, ":i:u:q:d:c:C:t:l:m:o:x:rhVg:b:fvs",  &long_options,  &_v14464);
    while(_v14432 != 255) {
        if(_v14432 != 58) {
L22:
            if(_v14432 == 105 || _v14432 == 117 || _v14432 == 113 || _v14432 == 100 || _v14432 == 99 || _v14432 == 116 || _v14432 == 108 || _v14432 == 114 || _v14432 == 104 || _v14432 == 86) {
                _v14440 = _v14440 + 1;
                if(_v14432 - 86 <= 31) {
                    goto __eax;
                }
                if(__imp__optarg != 0) {
                    strcpy( &_v4120, __imp__optarg);
                    strcpy( &_v6168, __imp__optarg);
                }
            }
            if(_v14432 == 103) {
                _v14364 = malloc(strlen(__imp__optarg) + 1);
                strcpy(_v14364, __imp__optarg);
            }
            if(_v14432 == 98) {
                _v14396 = malloc(strlen(__imp__optarg) + 1);
                strcpy(_v14396, __imp__optarg);
                _v14436 = 4;
            }
            if(_v14432 == 120) {
                strcpy( &CONFIG_OPTS, __imp__optarg);
            }
            if(_v14432 == 102) {
                FORCE = 1;
            }
            if(_v14432 == 118) {
                VERBOSE = 1;
            }
            if(_v14432 == 115) {
                SKIP_CFG = 1;
            }
            if(_v14432 == 111) {
                strcat( &_v14360, __imp__optarg);
            }
            if(_v14432 == 67) {
                strcpy( &CONFIG_CMD, __imp__optarg);
            }
            if(_v14432 == 109) {
                strcpy( &MAKE_CMD, __imp__optarg);
            }
            _v14432 = getopt_long(argc, _v14648, ":i:u:q:d:c:t:l:o:x:rhVg:b:fvs",  &long_options,  &_v14464);
            continue;
        } else {
            if(__imp__optopt == 105 || __imp__optopt == 117 || __imp__optopt == 100 || __imp__optopt == 99 || __imp__optopt == 116 || __imp__optopt == 108 || __imp__optopt == 114) {
                print_error(-1, "missing file or directory name.\n");
            }
            if(__imp__optopt == 103) {
                print_error(-1, "missing path to GRASS 6.\n");
            }
            if(__imp__optopt == 98) {
                print_error(-1, "missing name of binary architecture.\n");
            }
            if(__imp__optopt == 98) {
                print_error(-1, "missing configure options.\n");
            }
            if(__imp__optopt != 113) {
                goto L22;
            } else {
                _v14436 = 12;
                _v14440 = _v14440 + 1;
                break;
            }
            goto L23;
        }
    }
    if(_v14440 <= 0) {
        print_error(-1, "please specify a valid action.\n");
    }
    if(_v14440 > 1) {
        print_error(-1, "please specify only one action.\n");
    }
    _v14684 =  &_v14360;
    sprintf( &GEM_C_OPTS, "GEM_C_OPTS=%s");
    putenv( &GEM_C_OPTS);
    if(_v14436 == 1) {
        show_help();
        exit(0);
    }
    if(_v14436 == 2) {
        show_version();
        exit(0);
    }
    if(VERBOSE == 0) {
        memcpy( &TMP_NULL, "/tmp/grass.extension.log.XXXXXX", 32);
        mkstemp( &TMP_NULL);
        _v14684 = 511;
        _v14688 = 64;
         *__esp =  &TMP_NULL;
        _v14416 = open();
        if(_v14416 == 255) {
            _v14684 = strerror( *(__errno_location()));
            print_error(-30, "could not create temp file: %s");
            exit(-30);
        }
    }
    if(_v14436 == 11) {
        if(_v14364 == 0) {
            _v14364 = getenv("GISBASE");
            if(_v14364 == 0) {
                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
            }
        }
        if(VERBOSE != 0) {
            _v14684 = _v14364;
            fprintf(__imp__stdout, "Path to GRASS is %s.\n");
        }
        restore(_v14364, _v14368);
        exit(0);
    }
    if(_v14436 == 12) {
        if(_v14364 == 0) {
            _v14364 = getenv("GISBASE");
            if(_v14364 == 0) {
                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
            }
        }
        if(VERBOSE != 0) {
            _v14684 = _v14364;
            fprintf(__imp__stdout, "Path to GRASS is %s.\n");
        }
        list_extensions(_v14364);
        exit(0);
    }
    if(strstr( &_v4120, "http://") != 0 || strstr( &_v4120, "ftp://") != 0) {
        wget_extension( &_v4120);
        _v14388 = malloc(2048);
        strcpy(_v14388,  &_v4120);
        _v14392 = strrchr(_v14388, 47);
        _v14392 =  &(_v14392[1]);
        strcpy( &_v4120, _v14392);
        free(_v14388);
    }
    if(VERBOSE != 0) {
        _v14684 =  &_v4120;
        fprintf(__imp__stdout, "Extension location is '%s'.\n");
    }
    if(_v14436 == 10) {
L103:
        if(_v14436 != 10) {
            get_package_name( &_v4120,  &_v10264);
        } else {
            strcpy( &_v10264,  &_v4120);
        }
        if(_v14440 > 0) {
            if(_v14364 == 0) {
                _v14364 = getenv("GISBASE");
            }
            run_post( &_v4120, _v14436, _v14396, _v14364);
        }
        if(VERBOSE != 0) {
            _v14684 =  &_v4120;
            fprintf(__imp__stdout, "Extension will be installed from '%s'\n");
        }
        if(_v14436 != 10) {
            check_extension( &_v4120,  &_v8216,  &_v14400,  &_v14404,  &_v14408);
        }
        if(_v14436 == 5) {
            query_extension( &_v4120,  &_v8216, _v14400, _v14404, _v14408,  &_v10264,  &_v12312,  &_v6168);
            exit(0);
        }
        if(_v14436 == 9) {
            show_details( &_v4120);
            exit(0);
        }
        if(_v14436 == 7) {
            show_license( &_v4120);
            exit(0);
        }
        if(_v14436 == 6) {
            source_clean( &_v4120);
            exit(0);
        }
        if(_v14364 == 0) {
            _v14364 = getenv("GISBASE");
            if(_v14364 == 0) {
                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
            }
        }
        if(VERBOSE != 0) {
            _v14684 = _v14364;
            fprintf(__imp__stdout, "Path to GRASS is %s.\n");
        }
        _v14368 = getenv("GRASS_VERSION");
        if(_v14368 == 0) {
            _v14684 = _v14364;
            sprintf( &_v2072, "%s/etc/VERSIONNUMBER");
            _v14412 = fopen( &_v2072, "r");
            if(_v14412 != 0) {
                _v14368 = malloc(16);
                _v14684 = _v14368;
                _v14688 = "%s";
                _t577 = _v14412;
                 *__esp = _t577;
                __isoc99_fscanf();
                _v14444 = _t577;
                fclose(_v14412);
                if(_v14444 <= 0) {
                    print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
                }
            } else {
                print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
            }
        }
        if(_v14368 != 0) {
            _v14384 = strdup(_v14368);
            _v14372 = strtok(_v14384, ".");
            _v14376 = strtok(0, ".");
            _v14380 = strtok(0, ".");
            _v14420 = strtol(_v14372, 0, 10);
            _v14424 = strtol(_v14376, 0, 10);
            _v14428 = strtol(_v14380, 0, 10);
            _v14368 = malloc(2048);
            _v14676 = _v14428;
            _v14680 = _v14424;
            _v14684 = _v14420;
            sprintf(_v14368, "%i.%i.%i");
            if(VERBOSE != 0) {
                _v14684 = _v14368;
                fprintf(__imp__stdout, "GRASS version is %s.\n");
            }
            if(_v14420 <= 5) {
                print_error(-11, "extensions only work with GRASS version 6 and above.\n");
            }
        }
        _v14684 = _v14364;
        sprintf( &_v14360, "-L%s/lib -I/usr/local/grasslib/include/ ");
        if(_v14436 == 3) {
            source_install( &_v4120, _v14364,  &_v10264, _v14400, _v14404, _v14408, _v14368);
            exit(0);
        }
        if(_v14436 == 10) {
            uninstall( &_v4120,  &_v10264, _v14364, _v14368);
            exit(0);
        }
        if(_v14436 == 8) {
            test_install( &_v4120, _v14364,  &_v10264, _v14400, _v14404, _v14408, _v14368);
            exit(0);
        }
        if(_v14436 == 4) {
            if(binaries_exist( &_v4120, _v14396) != 0) {
                bin_install( &_v4120, _v14364, _v14396,  &_v10264, _v14400, _v14404, _v14408, _v14368);
                exit(0);
            }
            _v14684 = _v14396;
            print_error(-12, "no binaries for system '%s'\n");
        }
        _t522 = exit(0);
        _push(_t725);
        return _t522;
    } else {
        _t609 =  &_v4120;
        __stat(_t609,  &_v14552);
        _v14444 = _t609;
        if(_v14444 < 0) {
            _v14680 = strerror( *(__errno_location()));
            _v14684 =  &_v4120;
            print_error(-2, "extension FILE or DIR '%s' invalid: %s\n");
        }
        if((_v14536 & 61440) != 16384) {
            if(VERBOSE != 0) {
                fwrite("Extension files stored in a package file.\n", 1, 42, __imp__stdout);
            }
            _t613 =  &_v4120;
            unpack_extension(_t613);
             *__esp =  &TMPDIR;
            opendir();
            _v14452 = _t613;
            _t614 = _v14452;
             *__esp = _t614;
            readdir();
            _v14456 = _t614;
            _v14460 = 0;
            while(_v14456 != 0) {
                if(strcmp(_v14456 + 11, ".") == 0 || strcmp(_v14456 + 11, "..") == 0) {
L99:
                    _t618 = _v14452;
                     *__esp = _t618;
                    readdir();
                    _v14456 = _t618;
                    continue;
                }
                _v14680 = _v14456 + 11;
                _v14684 =  &TMPDIR;
                sprintf(_v14384, "%s/%s");
                __stat(_v14384,  &_v14640);
                if((_v14624 & 61440) != 16384) {
                    goto L99;
                }
                _v14460 = 1;
                break;
            }
            strcpy( &_v4120, _v14384);
            if(_v14460 == 0) {
                print_error(-7, "no top-level directory found in extension package.\n");
            }
        } else {
            _v14448 = 1;
            if(VERBOSE != 0) {
                fwrite("Extension files stored in a directory.\n", 1, 39, __imp__stdout);
            }
        }
        goto L103;
    }
}

__libc_csu_fini()
{// addr = 0x080546E0
    _unknown_ __ebp;                       // r6

    return;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080546F0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15
    signed int _t18;                       // _t18

    __i686.get_pc_thunk.bx();
    _t15 = _t14 + 18681;
    __esp = __esp - 28;
    _init();
    _t18 = _t15 + -228 - _t15 + -228 >> 2;
    if(_t18 != 0) {
        __esi = 0;
        while(1) {
            _v36 = _a12;
            _v40 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t15 + -228 + __esi * 4))();
            __esi = __esi + 1;
            if(__esi >= _t18) {
                break;
            }
        }
    }
    __esp = __esp + 28;
    return;
}

__i686.get_pc_thunk.bx()
{// addr = 0x0805474A
    return;
}

int atexit(_Unknown_base(*)()* __func)
{// addr = 0x08054750
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    intOrPtr* _t5;                         // _t5
    int _t6;                               // _t6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
    _t8 = _t7 + 18587;
    __esp = __esp - 12;
    _t5 =  *((intOrPtr*)(_t8 + -4));
    if(_t5 != 0) {
        _t5 =  *_t5;
    }
    _v12 = _t5;
    _t6 = _a4;
    _v16 = 0;
     *__esp = _t6;
    __cxa_atexit();
    __esp =  &((__esp)[3]);
    return _t6;
}

__stat(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08054790
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t7;                         // _t7
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx();
     *__esp = 3;
    _v12 = _a8;
    _v16 = _a4;
    __xstat();
    return;
}

__do_global_ctors_aux()
{// addr = 0x080547D0
    intOrPtr* __ebx;                       // r1
    _unknown_ __ebp;                       // r6

    __eax = __CTOR_LIST__;
    if(__eax != 255) {
        __ebx =  &__CTOR_LIST__;
        asm("o16 nop ");
        while(1) {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
            if(__eax == 255) {
                break;
            }
        }
    }
    return;
}

_fini()
{// addr = 0x080547FC
    _unknown_ __ebx;                       // r1
    _unknown_ __ebp;                       // r6
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    return;
}

L08054808()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    __do_global_dtors_aux(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

L08054808()
{
    _unknown_ _t1;                         // _t1
    _unknown_ _t2;                         // _t2

    _pop(__ebx);
    @rec __do_global_dtors_aux@__do_global_dtors_aux@(__esi);
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return;
}

// Statistics:
//     221 Register nodes
//     481 Temporaries nodes
//       6 Casts
//    5904 Statements
//     210 Labels
//     131 Gotos
//     129 Blocks
//   17708 Nodes
//      10 Assembly nodes
//    1020 Unknown Types


Total time: 3 seconds.
