// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000(Stack uint32 dwArg04, Stack word32 dwArg08)
void fn00401000(uint32 dwArg04, word32 dwArg08)
{
	if (~0x5F80 != 0x00)
	{
		int32 dwLoc34_241 = 0x00;
		do
		{
			int32 v12_243 = dwLoc34_241 + 0x01;
			dwLoc34_241 = v12_243;
		} while (v12_243 <= 0x03);
		int32 dwLoc38_250 = 0x00;
		do
		{
			int32 v13_252 = dwLoc38_250 + 0x01;
			dwLoc38_250 = v13_252;
		} while (v13_252 <= 0x02);
	}
	if (0xF0 != 0x00)
	{
		Eq_25 ecx_115 = 0x00;
		int32 dwLoc48_119 = 0x00;
		do
		{
			if (true)
			{
				uint32 v16_142 = dwLoc28 - 0xDC05;
			}
			else
			{
				ui32 ecx_173 = ecx_115 * 0x02;
				uint32 edx_174 = 0x00;
				if ((ecx_173 & 28992) >= 0x00)
					edx_174 = ~0x0912;
				word32 eax_189 = edx_174 + 2323;
				uint32 v23_191 = dwLoc4C + eax_189;
				if (0xF0 == eax_189)
					edx_174 = edx_174 * 0x02;
			}
			int32 v21_118 = dwLoc48_119 + 0x01;
			dwLoc28 = 0x00;
			ecx_115 = fp - 0x50;
			dwLoc4C = 0x00;
			dwLoc48_119 = v21_118;
		} while (v21_118 <= 0x01);
	}
	return;
}

// 0040119C: void fn0040119C(Stack word32 dwArg08, Stack word32 dwArg0C)
void fn0040119C(word32 dwArg08, word32 dwArg0C)
{
	int32 dwLoc30_10 = 0x00;
	do
	{
		int32 v8_12 = dwLoc30_10 + 0x01;
		dwLoc30_10 = v8_12;
	} while (v8_12 <= 0x02);
	return;
}

// 0040122C: Register word32 fn0040122C(Register uint32 ecx, Stack word32 dwArg08, Register out ptr32 edxOut)
word32 fn0040122C(uint32 ecx, word32 dwArg08, ptr32 & edxOut)
{
	word32 eax_12 = 0xF7;
	word32 edx_19;
	*edxOut = ecx + 0x05B0;
	if (true)
		eax_12 = 0xF7 - ecx;
	return eax_12 + ecx + (ecx + 0x05B0);
}

// 00401268: Register word32 fn00401268(Stack word32 dwArg04)
word32 fn00401268(word32 dwArg04)
{
	int32 dwLoc34_10 = 0x00;
	do
	{
		int32 v8_12 = dwLoc34_10 + 0x01;
		dwLoc34_10 = v8_12;
	} while (v8_12 <= 0x02);
	return fp - 0x18 - (fp + ~0x0F55) - (fp < ~0x0F55);
}

// 004012C0: void fn004012C0(Stack word32 dwArg04)
void fn004012C0(word32 dwArg04)
{
	int32 dwLoc40_10 = 0x00;
	do
	{
		int32 v8_12 = dwLoc40_10 + 0x01;
		dwLoc40_10 = v8_12;
	} while (v8_12 <= 0x03);
	int32 dwLoc44_19 = 0x00;
	do
	{
		int32 v10_21 = dwLoc44_19 + 0x01;
		dwLoc44_19 = v10_21;
	} while (v10_21 <= 0x04);
	return;
}

// 0040130C: Register uint32 fn0040130C(Register (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr Eq_138))))))))))))))))))))))))))))))))))))))))))))))))))) ebp, Stack word32 dwArg04, Register out ptr32 ebpOut)
uint32 fn0040130C( * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ebp, word32 dwArg04, ptr32 & ebpOut)
{
	fn0040197C(0x00421465);
	fn0040197C(0x00421491);
	fn0040197C(0x60FA);
	word32 ebp_5;
	*ebpOut = fp - 0x04;
	if (false)
	{
		int32 dwLoc28_178 = 0x00;
		do
		{
			fn004012C0(0xDA80);
			GetTickCount();
			fn004012C0(0xDA80);
			word32 ecx_200;
			word32 edx_201;
			fn00401AE0(4330845, 0xDA80, 2114, out ecx_200, out edx_201);
			int32 v23_204 = dwLoc28_178 + 0x01;
			dwLoc28_178 = v23_204;
		} while (v23_204 <= 0x01);
	}
	else
		fn00401268(333);
	word32 ecx_75;
	word32 edx_76;
	fn00401AE0(0x0947, 0x0947, 0x0F, out ecx_75, out edx_76);
	uint32 ecx_91;
	word32 edx_92;
	fn00401AE0(0x0947, 0x0947, 0x0F, out ecx_91, out edx_92);
	word32 edx_101;
	fn0040122C(ecx_91, 0x0F, out edx_101);
	int32 dwLoc3C_105 = 0x00;
	if (0x00 < dwArg04)
	{
		do
		{
			uint32 eax_151 = fn00401A48();
			if (eax_151 <= 0x05)
				return eax_151;
			else
				fn00401000(eax_151, 0x28052A40);
			int32 v41_162 = dwLoc3C_105 + 0x01;
			dwLoc14 = eax_151;
			dwLoc3C_105 = v41_162;
		} while (v41_162 < dwArg04);
	}
	return dwLoc14;
	word32 ebp_143;
	*ebpOut = Mem0[ebp + 0x00:word32];
	return *(ebp - 0x10);
}

// 00401750: Register uint32 fn00401750(Register uint32 ecx, Register word32 edx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg10, Register out ptr32 edxOut)
uint32 fn00401750(uint32 ecx, word32 edx, word32 dwArg04, word32 dwArg08, word32 dwArg10, ptr32 & edxOut)
{
	if (false && true)
	{
		int32 dwLoc4C_104 = fp - 0x20 ^ fp - 0x20;
		do
		{
			int32 v15_103 = dwLoc4C_104 + 0x01;
			edx = 0x0820;
			ecx = 4294949622;
			dwLoc4C_104 = v15_103;
		} while (v15_103 <= 0x01);
	}
	ui32 ecx_40 = ecx ^ dwArg04;
	ui32 edx_41 = edx - ecx_40;
	*edxOut = edx_41;
	return ecx_40 - 0x08 | edx_41;
}

// 00401818: void fn00401818(Register uint32 ecx, Register Eq_284 edx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn00401818(uint32 ecx, Eq_284 edx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	word32 dwLoc0C_113 = 0x8E;
	if (true)
	{
		fn0040119C(0x8E, 0x8E);
		fn0040119C(0x8E, 0x8E);
		fn004012C0(8664);
		fn0040119C(0x8E, 0x8E);
		fn004012C0(8664);
		fn0040197C(0x0946);
		goto l00401952;
	}
	ui32 eax_229 = 0x00;
	if (4294947945 != 0x00)
	{
l004018DE:
		word32 ecx_90;
		word32 edx_91;
		fn00401AE0(0x00, 0x43E3, 4331362, out ecx_90, out edx_91);
l00401952:
		word32 ecx_31;
		word32 edx_32;
		word32 eax_33 = fn00401AE0(dwLoc0C_113, dwLoc0C_113, dwLoc0C_113, out ecx_31, out edx_32);
		word32 esp_47;
		word32 ebp_48;
		byte SCZO_49;
		byte SO_50;
		word32 eax_51;
		byte SZO_52;
		byte C_53;
		byte Z_54;
		word32 edx_55;
		word32 ecx_56;
		byte CZ_57;
		dwArg08();
		return;
	}
	if (true)
	{
l00401893:
		int32 dwLoc1C_126 = 0x00;
		do
		{
			uint32 ecx_143 = ecx + edx_140;
			uint32 edx_140;
			ui64 ecx_eax_146 = SEQ(ecx_143, fn0040122C(ecx, 0x00, out edx_140) + ecx_143);
			ecx = SLICE(ecx_eax_146 + SEQ(edx_140, ecx_143), word32, 32);
			if (edx_140 >= ecx)
			{
				Eq_374 C_188 = false;
				if (true)
					C_188 = cond(ecx - dwLoc08);
				ecx = 0x00 - C_188;
			}
			int32 v44_165 = dwLoc1C_126 + 0x01;
			dwLoc0C_113 = dwLoc0C_113 - ecx;
			dwLoc1C_126 = v44_165;
		} while (v44_165 <= 0x05);
		word32 edx_175;
		fn0040122C(ecx, 0x00, out edx_175);
		goto l004018DE;
	}
	ecx = ~0x8D;
	dwLoc08 = ~0x8D;
	if (true)
	{
		if (false)
		{
l0040188E:
			uint32 eax_231 = eax_229 * 0x02;
			dwLoc0C_113 = 0x8E - eax_231 - (eax_231 < 0x00);
			goto l00401893;
		}
		eax_229 = ~0x8D;
		edx = edx ^ ~0x8D ^ ~0x8D;
	}
	dwLoc08 = (word32) edx - 0x008E;
	goto l0040188E;
}

// 0040197C: void fn0040197C(Stack word32 dwArg0C)
void fn0040197C(word32 dwArg0C)
{
	int32 dwLoc40_20 = fp - 0x10 ^ fp - 0x10;
	do
	{
		int32 v10_22 = dwLoc40_20 + 0x01;
		dwLoc40_20 = v10_22;
	} while (v10_22 <= 0x04);
	return;
}

// 004019F0: void fn004019F0(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn004019F0(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	int32 dwLoc10_10 = 0x00;
	do
	{
		int32 v8_12 = dwLoc10_10 + 0x01;
		dwLoc10_10 = v8_12;
	} while (v8_12 <= 0x02);
	globals->dw4447E1 = dwArg04;
	globals->dw4447A5 = dwArg0C;
	int32 dwLoc20_25 = 0x00;
	do
	{
		int32 v11_32 = dwLoc20_25 + 0x01;
		dwLoc20_25 = v11_32;
	} while (v11_32 <= 0x05);
	globals->dw44477D = dwArg08;
	return;
}

// 00401A48: Register uint32 fn00401A48()
uint32 fn00401A48()
{
	int32 dwLoc18_10 = 0x00;
	do
	{
		int32 v8_12 = dwLoc18_10 + 0x01;
		dwLoc18_10 = v8_12;
	} while (v8_12 <= 0x01);
	uint32 edx_19 = globals->dw444739 << 11 ^ globals->dw444739;
	globals->dw444739 = globals->dw444741;
	int32 dwLoc28_26 = 0x00;
	do
	{
		int32 v12_34 = dwLoc28_26 + 0x01;
		dwLoc28_26 = v12_34;
	} while (v12_34 <= 0x01);
	globals->dw444741 = globals->dw44474D;
	globals->dw44474D = globals->dw444715;
	globals->dw444715 = globals->dw444715 >> 0x13 ^ globals->dw444715 ^ edx_19 ^ edx_19 >> 0x08;
	return globals->dw444715;
}

// 00401AE0: Register word32 fn00401AE0(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg10, Register out ptr32 ecxOut, Register out ptr32 edxOut)
word32 fn00401AE0(word32 dwArg04, word32 dwArg08, word32 dwArg10, ptr32 & ecxOut, ptr32 & edxOut)
{
	int32 dwLoc44_34 = 0x00;
	do
	{
		int32 v13_49 = dwLoc44_34 + 0x01;
		dwLoc44_34 = v13_49;
	} while (v13_49 <= 0x03);
	int32 dwLoc48_56 = 0x00;
	do
	{
		word32 eax_110 = 0x00;
		int32 dwLoc50_70 = 0x00;
		do
		{
			int32 v14_79 = dwLoc50_70 + 0x01;
			word32 edx_115 = 0x1BD9;
			dwLoc50_70 = v14_79;
		} while (v14_79 <= 0x05);
		int32 v15_83 = dwLoc48_56 + 0x01;
		dwLoc48_56 = v15_83;
	} while (v15_83 <= 0x03);
	if (0x00 != 0x00)
	{
		eax_110 = 0x0590;
		if (false)
		{
l00401BC1:
			word32 ecx_100;
			*ecxOut = 0x00;
			word32 edx_101;
			*edxOut = edx_115 ^ 0x00;
			return eax_110;
		}
	}
	edx_115 = 7753;
	goto l00401BC1;
}

// 00401C30: Register (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr Eq_138))))))))))))))))))))))))))))))))))))))))))))))))))) fn00401C30(Register (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr (ptr Eq_138))))))))))))))))))))))))))))))))))))))))))))))))))) ebp)
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * fn00401C30( * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ebp)
{
	int32 dwLoc38_10 = 0x00;
	do
	{
		int32 v8_12 = dwLoc38_10 + 0x01;
		dwLoc38_10 = v8_12;
	} while (v8_12 <= 0x02);
	int32 dwLoc3C_19 = 0x00;
	do
	{
		ui32 ecx_105 = 0x00;
		int32 dwLoc40_25 = 0x00;
		do
		{
			int32 v11_27 = dwLoc40_25 + 0x01;
			dwLoc40_25 = v11_27;
		} while (v11_27 <= 0x05);
		int32 v12_31 = dwLoc3C_19 + 0x01;
		dwLoc3C_19 = v12_31;
	} while (v12_31 <= 0x02);
	if (true)
	{
		ui32 eax_103 = 0x00;
		int32 dwLoc58_101 = 0x00;
		do
		{
			if (false)
			{
				uint32 edx_124 = 0x00 - eax_103;
				ui32 eax_125 = eax_103 - ecx_105;
				if (dwLoc30 >= edx_124)
					eax_125 = dwLoc14 ^ 0x00;
				uint32 eax_134 = eax_125 * 0x02;
				uint32 edx_135 = edx_124 - eax_134;
				word32 v19_136 = 0x00 - ecx_105 - edx_135;
				eax_103 = eax_134 ^ 0x45;
				if (edx_135 == (eax_134 ^ 0x45))
				{
					ui32 eax_152 = (eax_134 ^ 0x45) - 0xD488;
					if ((dwLoc14 & 99) >= 0x00)
					{
						ecx_105 = ecx_105 + v19_136;
						eax_152 = eax_152 ^ edx_135;
					}
					eax_103 = eax_152 * 0x02;
				}
			}
			else
			{
				eax_103 = eax_103 - 0xAFEF;
				Eq_594 C_178 = false;
				if (eax_103 == 0x00)
					C_178 = cond(ecx_105 * 0x02);
				ecx_105 = 0x00 - C_178;
			}
			int32 v20_119 = dwLoc58_101 + 0x01;
			dwLoc58_101 = v20_119;
		} while (v20_119 <= 0x01);
	}
	return ebp;
	*(ebp - 44) = 0xE6;
	*(ebp - 0x0C) = 0x00;
	*(ebp - 0x30) = 11210;
	*(ebp - 0x04) = *(ebp - 0x0C) - *(ebp - 0x30);
	return *ebp;
}

// 00402054: Register Eq_170 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	***************************************************************************************************** ebp_181 = fp - 0x04;
	if (false)
	{
l004021A6:
		Eq_651 dwLoc54_45 = 0xCB;
		if (true)
		{
			eax.u0 = 0xA0F9;
			goto l004022B1;
		}
		if (true)
		{
l00402268:
			if (dwLoc54_45 != 0x0D)
			{
				int32 dwLoc70_717 = 0x00;
				do
				{
					edx = edx * 0x02;
					if ((dwLoc54_45 & edx) != 0x00)
						edx = (edx & 60570) - 0xBB;
					int32 v41_745 = dwLoc70_717 + 0x01;
					dwLoc70_717 = v41_745;
				} while (v41_745 <= 0x01);
			}
l004022B1:
			ui32 edx_121 = 0x00;
			word32 dwLoc84_128 = 0x00;
l004022B6:
			Eq_818 dwLoc88_525 = 0x9EEE;
			if (true)
			{
l0040236D:
				int32 v37_123 = dwLoc84_128 + 0x01;
				dwLoc84_128 = v37_123 + 0x01;
				if (v37_123 <= ~0x01)
					goto l004022B6;
				int32 dwLocB4_146 = 0x00;
				do
				{
					int32 v38_148 = dwLocB4_146 + 0x01;
					dwLocB4_146 = v38_148;
				} while (v38_148 <= 0x02);
				fn00401268(4331021);
				fn00401818(0x5D66, fp - 200, 11, 4200204, 0x00401550);
				do
				{
					*(ebp_181 - 0xD8) = 17195;
					if (*(ebp_181 - 0xD8) == 0xC4)
					{
						ebp_181 = fn00401C30(ebp_181);
						*(ebp_181 - 0xD0) = 0x4F4F;
						*(ebp_181 - 228) = ebp_181 - 0xD0;
						*(ebp_181 - 0xD0) = ((**(ebp_181 - 228) & *(ebp_181 - 0xD8)) - *(ebp_181 - 0xD8)) *s *(ebp_181 - 0xD0);
					}
					ebp_181 = fn00401C30(ebp_181);
					*(ebp_181 - 212) = *(ebp_181 - 212) + 0x01;
				} while (*(ebp_181 - 212) <= 0x05);
				*((word32) fp - 0x01FC) = (struct _OSVERSIONINFOA *) 8200030;
				ptr32 ebp_200;
				word32 eax_201 = fn0040130C(ebp_181, dwArg00, out ebp_200);
				*(ebp_200 - 0xCC) = eax_201;
				*(ebp_200 - 232) = 0xD5;
				*((word32) fp - 0x01FC) = *(ebp_200 - 232);
				word32 edx_208 = fn00401268(dwArg00);
				*(ebp_200 - 0xF0) = 0x00;
				uint32 ecx_211 = 0x00;
				do
				{
					*(ebp_200 - 0xEC) = 0xD0;
					*(ebp_200 - 244) = 0x82;
					*((word32) fp - 0x01FC) = &globals->t4215A1;
					*((word32) fp - 0x0200) = 4330774;
					*((word32) fp - 0x0204) = *(ebp_200 - 244);
					*((word32) fp - 0x0208) = *(ebp_200 - 0xEC);
					ecx_211 = fn00401750(ecx_211, edx_208, dwArg00, dwArg04, dwArg0C, out edx_208);
					*(ebp_200 - 0xF0) = *(ebp_200 - 0xF0) + 0x01;
				} while (*(ebp_200 - 0xF0) <= 0x05);
				word32 edx_262;
				*((word32) fp - 0x01FC) = ebp_200 - 488;
				GetVersionExA(*((word32) fp - 0x01FC));
				*((word32) fp - 0x01FC) = &globals->t4216B2;
				fn00401268(dwArg00);
				if (*(ebp_200 - 0xCC) != 0x00)
					edx_262 = 4204400;
				else
					edx_262 = 4201420;
				*(ebp_200 - 0x0100) = edx_262;
				*(ebp_200 - 0x0104) = 0xCF;
				*(ebp_200 - 0x0108) = 0x54;
				*(ebp_200 - 0x0110) = ebp_200 - 0x0104;
				*(ebp_200 - 0x0108) = (char *) **(ebp_200 - 0x0110) + (*(ebp_200 - 0x0108) | 188) + *(ebp_200 - 0x0108);
				word32 ecx_276 = *(ebp_200 - 0x0104) + *(ebp_200 - 0x0108);
				*(ebp_200 - 0x0108) = *(ebp_200 - 0x0108) + ecx_276;
				*(ebp_200 - 0x010C) = 66;
				word32 eax_281 = *(ebp_200 - 0x010C) - *(ebp_200 - 0x0108);
				*(ebp_200 - 0x0104) = *(ebp_200 - 0x0104) + eax_281;
				ptr32 esp_285;
				ptr32 ebp_286;
				byte SCZO_287;
				word32 ebx_288;
				word32 esi_289;
				word32 edi_290;
				byte Z_291;
				byte SZO_292;
				word32 eax_293;
				byte C_294;
				word32 edx_295;
				word32 ecx_296;
				byte SO_297;
				byte CZ_298;
				(*(ebp_200 - 0x0100))();
				*(ebp_286 - 0x0114) = eax_293;
				*(ebp_286 - 0x0118) = 0x00;
				*(ebp_286 - 288) = 171;
				*(esp_285 - 0x04) = *(ebp_286 - 288);
				*(esp_285 - 0x08) = *(ebp_286 - 288);
				*(esp_285 - 0x0C) = *(ebp_286 - 0x0118);
				*(esp_285 - 0x10) = *(ebp_286 - 0x0118);
				word32 ecx_317;
				word32 edx_318;
				fn00401AE0(dwArg00, dwArg04, dwArg0C, out ecx_317, out edx_318);
				*(ebp_286 - 0x011C) = 0x44;
				uint32 ecx_323 = *(ebp_286 - 0x011C);
				if (ecx_323 != *(ebp_286 - 0x0118))
				{
					*(esp_285 - 0x04) = *(ebp_286 - 288);
					*(esp_285 - 0x08) = *(ebp_286 - 0x011C);
					word32 edx_470;
					fn0040122C(ecx_323, dwArg04, out edx_470);
					*(ebp_286 - 0x011C) = *(ebp_286 - 0x011C) - ((*(ebp_286 - 0x0118) & 0x7713) + (*(ebp_286 - 0x011C) & 0x19));
					*(ebp_286 - 0x011C) = (*(ebp_286 - 0x011C) - *(ebp_286 - 0x0118)) *s *(ebp_286 - 0x011C);
				}
				else
				{
					*(esp_285 - 0x04) = *(ebp_286 - 288);
					*(esp_285 - 0x08) = *(ebp_286 - 0x011C);
					*(esp_285 - 0x0C) = 4331314;
					*(esp_285 - 0x10) = 4331142;
					word32 edx_495;
					fn00401750(ecx_323, edx_318, dwArg00, dwArg04, dwArg0C, out edx_495);
				}
				*(esp_285 - 0x04) = *(ebp_286 - 288);
				*(esp_285 - 0x08) = *(ebp_286 - 288);
				*(esp_285 - 0x0C) = *(ebp_286 - 0x0118);
				*(esp_285 - 0x10) = *(ebp_286 - 0x0118);
				word32 ecx_346;
				word32 edx_347;
				fn00401AE0(dwArg00, dwArg04, dwArg0C, out ecx_346, out edx_347);
				*(esp_285 - 0x04) = *(ebp_286 - 0x0118);
				fn00401268(dwArg00);
				*(esp_285 - 0x04) = *(ebp_286 - 0x9C);
				*(esp_285 - 0x08) = *(ebp_286 - 0x4C);
				*(esp_285 - 0x0C) = *(ebp_286 - 0x70);
				fn004019F0(dwArg00, dwArg04, dwArg08);
				*(ebp_286 - 300) = 0x00;
				do
				{
					*(ebp_286 - 0x0128) = 0x68;
					*(ebp_286 - 0x0134) = 0x00;
					*(ebp_286 - 0x0134) = *(ebp_286 - 0x0134) + *(ebp_286 - 0x0128) *s *(ebp_286 - 0x0134);
					GetLastError();
					*(ebp_286 - 300) = *(ebp_286 - 300) + 0x01;
				} while (*(ebp_286 - 300) <= 0x05);
				*(ebp_286 - 0x0138) = *(ebp_286 - 0xCC) + *(ebp_286 - 0x0114);
				*(esp_285 - 0x04) = 0x00;
				*(esp_285 - 0x08) = 0x00;
				*(esp_285 - 0x0C) = 0x00;
				CreateMutexA(*(esp_285 - 0x0C), *(esp_285 - 0x08), *(esp_285 - 0x04));
				*(ebp_286 - 0x0144) = 0x00;
				*(ebp_286 - 0x0140) = 0x3F6B;
				*(ebp_286 - 0x013C) = *(ebp_286 - 0x0144) - *(ebp_286 - 0x0140);
				*(esp_285 - 0x04) = *(ebp_286 - 0x0140);
				*(esp_285 - 0x08) = *(ebp_286 - 0x013C);
				*(esp_285 - 0x0C) = *(ebp_286 - 0x0140);
				*(esp_285 - 0x10) = *(ebp_286 - 0x0140);
				word32 ecx_412;
				word32 edx_413;
				word32 eax_414 = fn00401AE0(dwArg00, dwArg04, dwArg0C, out ecx_412, out edx_413);
				ptr32 esp_416;
				ptr32 ebp_417;
				byte SCZO_418;
				word32 ebx_419;
				word32 esi_420;
				word32 edi_421;
				byte Z_422;
				byte SZO_423;
				word32 eax_424;
				byte C_425;
				word32 edx_426;
				word32 ecx_427;
				byte SO_428;
				byte CZ_429;
				(*(ebp_286 - 0x0138))();
				*(ebp_417 - 0x0148) = eax_424;
				*(ebp_417 - 0x0154) = 0x062E;
				*(ebp_417 - 336) = 0x13;
				*(esp_416 - 0x04) = *(ebp_417 - 336);
				*(esp_416 - 0x08) = *(ebp_417 - 0x0154);
				*(esp_416 - 0x0C) = 4331428;
				fn0040119C(dwArg04, dwArg08);
				*(ebp_417 - 332) = 0x070E;
				*(esp_416 - 0x04) = *(ebp_417 - 336) + 0x01;
				int32 eax_454 = (int32) ((int64) *(ebp_417 - 332) / *(esp_416 - 0x04));
				*(ebp_417 - 332) = *(ebp_417 - 332) - eax_454;
				*(esp_416 - 0x04) = 0x00;
				int32 eax_460 = DPB(eax_454, AddAtomA(*(esp_416 - 0x04)), 0);
				*(esp_416 - 0x04) = 0x00;
				ExitProcess(*(esp_416 - 0x04));
			}
			ui32 ecx_515 = 0x00;
			int32 dwLoc90_524 = 0x00;
l004022D5:
			Eq_818 ecx_535 = ecx_515 * 0x02;
			uint64 ecx_ecx_539 = SEQ(ecx_535, ecx_535);
			word32 eax_541 = eax + ecx_535;
			if (dwLoc88_525 >= ecx_535)
			{
				ecx_535.u0 = (byte) (dwLoc88_525 < ecx_535) + ((word32) ecx_535 + dwLoc94);
				ecx_ecx_539 = SEQ(ecx_535, ecx_535);
				if (ecx_535 != dwLoc88_525)
					edx_121 = edx_121 - eax_541;
				eax_541 = eax_541 - 177;
				edx_121 = edx_121 ^ ecx_535;
			}
			ui64 ecx_eax_569 = SEQ(ecx_535, eax_541 - ecx_535) - ecx_ecx_539;
			Eq_818 ecx_571 = SLICE(ecx_eax_569, word32, 32);
			Eq_818 v35_572 = dwLoc88_525 - ecx_571;
			word32 eax_570 = (word32) ecx_eax_569;
			dwLoc88_525 = v35_572;
			if (ecx_571 >= v35_572)
				dwLoc94 = dwLoc94 + eax_570;
			ui32 ecx_578 = ecx_571 | 0x80;
			ui32 edx_583 = edx_121 - (ecx_571 | 0x80);
			eax = 0x012E - v35_572;
			if (((ecx_571 | 0x80) & edx_583) != 0x00)
			{
				edx_121 = edx_583;
				ecx_578 = (ecx_571 | 0x80) & 1881;
				if ((dwLoc78 & eax) < 0x00)
				{
l00402352:
					int32 v81_614 = dwLoc90_524 + 0x01;
					ecx_515 = ecx_578 + 0xFFD4 - eax;
					dwLoc90_524 = v81_614;
					if (v81_614 <= 0x04)
						goto l004022D5;
					goto l0040236D;
				}
				edx_583 = edx_583 & eax;
			}
			edx_121 = edx_583 + ecx_578;
			goto l00402352;
		}
		edx = 0x00;
		int32 dwLoc60_778 = 0x00;
l004021C9:
		eax = eax + dwLoc54_45;
		edx = (int32) ((byte) eax.u0 + (edx - 0x6A));
		if (dwLoc58 >= ecx)
		{
			Eq_667 v14_969 = dwLoc58 - 22;
			dwLoc58 = v14_969;
			eax = eax - ecx;
			if (false)
			{
l004021E7:
				uint32 ecx_807 = ecx * 0x02;
				int32 v20_818 = dwLoc60_778 + 0x01;
				ecx = (word32) (SEQ(dwLoc54_45, ecx_807) + SEQ(edx, ecx_807));
				dwLoc54_45 = v19;
				dwLoc60_778 = v20_818;
				if (v20_818 <= 0x01)
					goto l004021C9;
				if (true)
				{
					Eq_715 eax_828 = fp - 88;
					Eq_718 edx_839 = fp - 88 ^ 0x1398 | fp - 88;
					if (true)
						eax_828 = fp - 88 + edx_839;
					ui32 eax_847 = eax_828 * 0x02;
					ui32 edx_855 = 0x00 - (edx_839 < ~0x095D);
					Eq_733 C_861 = false;
					if ((v19 & edx_855) == 0x00)
						C_861 = cond(~0x0663);
					Eq_751 C_890;
					eax = (word32) C_861 + (eax_847 + ~0x095D);
					edx = edx_855 ^ 0x789B;
					if (true)
					{
						word32 ecx_918 = fp - ~0x0905 + v19;
						C_890 = cond(ecx_918 - eax);
						if (ecx_918 < eax)
						{
l00402261:
							dwLoc54_45 = v19 - 0xFE - C_890;
							goto l00402268;
						}
						edx = (word32) eax + (edx_855 ^ 0x789B);
					}
					eax = eax * 0x02;
					C_890 = cond(eax * 0x02);
					goto l00402261;
				}
				goto l00402268;
			}
			dwLoc58 = v14_969;
		}
		ecx.u0 = 0x00;
		goto l004021E7;
	}
	if (true)
	{
		eax.u0 = 37322;
		goto l004021A6;
	}
	int32 dwLoc14_1032 = 0xCD7D;
	if (true)
	{
		if ((word32) (SEQ(dwLoc2C, eax * 0x02) + SEQ(ecx, eax * 0x02)) >= 0xFA0B)
		{
			if (false)
			{
l004020D6:
				edx = 0x0A78;
				if (0x0A78 != 0x00)
					edx = 0x50;
				ecx.u0 = 3432;
l00402199:
				eax = (dwLoc14_1032 + 0xFA0B) *s 0xD0;
				goto l004021A6;
			}
		}
		goto l004020D6;
	}
	Eq_688 dwLoc24_1191 = dwLoc24 & 0x6A26;
	if (ecx != (dwLoc24 & 0x6A26))
	{
		if (128022 == (word32) eax + 64011)
		{
l00402143:
			edx = ((dwLoc14_1032 | 0xDA) + 996) * 0x02;
			if (true)
				dwLoc24_1191 = (dwLoc24 & 0x6A26) - 0x6CA6;
			Eq_798 eax_1222 = 0x00;
			if (true)
			{
				eax_1222 = 0x00 - (fp - 44);
				if (fp - 44 != dwLoc24_1191)
				{
l00402190:
					ecx = fp - 44 + eax_1222;
					goto l00402199;
				}
				edx = (word32) (fp - 44) + edx ^ dwLoc14_1032;
			}
			edx = edx + dwLoc14_1032;
			eax_1222 = eax_1222 | fp - 44;
			goto l00402190;
		}
	}
	dwLoc14_1032 = 0x0AD1;
	goto l00402143;
}

