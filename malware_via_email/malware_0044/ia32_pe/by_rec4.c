L00401078(intOrPtr _a4, intOrPtr _a8)
{
    signed int _v8;
    _unknown_ __ebp;
    _unknown_ _t57;
    _unknown_ _t59;
    _unknown_ _t71;
    signed int* _t73;
    _unknown_ _t82;
    _unknown_ _t84;

    _v8 = 0;
    while(_v8 < _a8) {
        if(_v8 > 1) {
             *(_a4 + _v8) = _v8 & 4294967295;
        }
        if(_v8 > 2) {
             *(_a4 + _v8) = _v8 & 4294967295;
        }
        if(_v8 > 2 && (_v8 - 2) % 3 == 0) {
             *((signed int*)(_a4 + _v8)) = _v8 + _a4 & 4294967295;
        }
        if((_v8 & 1) == 0) {
            _t73 = _a4 + _v8;
             *_t73 = _v8 + _a4 & 4294967295;
        }
        _v8 = _v8 + 1;
    }
}

L0040112A(_unknown_ __eax, signed int __ebx, _unknown_ __edx, signed int __edi, signed int __esi, _unknown_ __eflags)
{
    signed int __ebp;
    _unknown_ _t146;
    _unknown_ _t154;
    _unknown_ _t156;
    _unknown_ _t168;
    signed int* _t170;
    _unknown_ _t173;
    _unknown_ _t180;
    _unknown_ _t182;
    _unknown_ _t183;

    __esi = __esi;
    __edi = __edi;
    __ebx = __ebx;
    _push(__ebp);
    while(1) {
L14:
         *__esi = __ebp;
        _pop(__ecx);
        asm("cwde ");
        asm("rol dh, cl");
        asm("sbb [ebx+0x5f], bl");
        asm("sbb al, 0xd5");
        __edi = __edi + 1;
        asm("adc eax, 0xe804eb31");
        asm("invalid ");
        _pop(__ebp);
        asm("les ecx, [esi]");
        asm("out dx, eax");
        asm("invalid ");
        asm("sbb al, 0x79");
        if(__eflags == 0) {
            break;
        }
    }
    asm("invalid ");
    __ecx = __ecx + 1;
    asm("xchg esp, edx");
    asm("les esp, [edi]");
    asm("invalid ");
    __esi = __esi + 1;
    if(__eflags > 0) {
L18:
         *((intOrPtr*)(__esi + 316333659)) =  *((intOrPtr*)(__esi + 316333659)) + __esp;
         *((intOrPtr*)(__esi + -996112443))();
        while(1) {
L19:
            asm("xchg [eax+0x1cc7f5c4], esp");
            if(__eflags < 0) {
                break;
            }
        }
        asm("fmul qword [edx+0x5844c7c6]");
        _push(__ecx);
        _pop(es);
        __esi = __esi + 1;
        __ebx = __ebx + 1;
         *((intOrPtr*)(__ebx + 91)) =  *((intOrPtr*)(__ebx + 91)) + __ebx;
        asm("lds eax, [esi+0x59]");
         *((intOrPtr*)(__ecx - 58)) =  *((intOrPtr*)(__ecx - 58)) + __edx;
        asm("lodsd ");
        _pop(__edx);
        __ebp = __ebp |  *(__ebp - 57);
        asm("xchg edx, eax");
        asm("invalid ");
         *((intOrPtr*)(__ebx + 87)) =  *((intOrPtr*)(__ebx + 87)) + (__edx & 4294967295);
        asm("adc eax, 0xbe0066db");
        _pop(__ebp);
        asm("pushfd ");
        asm("les edi, [ebp+0x1]");
        asm("ficomp dword [ecx+esi]");
         *(__eax + 1) =  *(__eax + 1) ^ __esi;
        if(__eflags != 0) {
L28:
            _push(es);
            return;
        } else {
             *(__ebp + 98) =  ~( *(__ebp + 98));
            goto L23;
            do {
L23:
                _push(cs);
                __eax = __eax | __edi;
                 *(1304891005 + __eax * 4) =  *(1304891005 + __eax * 4) ^ __ebx;
                __ebx = __ebx - 1;
                _pop(__edx);
                asm("xchg [edx-0x3c], esi");
                __ebx = __ebx + 1;
                asm("invalid ");
                __esi = __esi + 1;
                asm("xchg ebx, eax");
                __eax = __eax ^ -418265274;
                _push(398740573);
                while(1) {
                    _pop(ss);
                     *((intOrPtr*)(__edi + 708307740)) =  *((intOrPtr*)(__edi + 708307740)) + __eax;
                     *__edi =  *__edi + __ebp;
                    __esp =  *((intOrPtr*)(__eax + 621679197));
                    asm("invalid ");
                    asm("sbb al, 0xbf");
                    if(__eflags < 0) {
                        break;
                    } else {
                        goto L32;
                    }
                    while(1) {
L32:
                        asm("sbb al, 0x7b");
                        if(__eflags < 0) {
                            goto L41;
                        } else {
                            goto L33;
                        }
                    }
                }
                asm("invalid ");
                asm("invalid ");
            } while(__eflags < 0);
            _push(__ebp);
            asm("rep xor al, [ds:ecx]");
            asm("aaa ");
            asm("xchg esi, eax");
            asm("sbb dword [ebp+0x12], 0xd8c7cd0f");
            -2079927249();
            goto L28;
        }
    }
    __eflags = (__eax & 4294967295) - (__ebx & 4294967295);
    asm("cmc ");
    asm("hlt ");
    asm("int3 ");
    _pop(__ebp);
    asm("les ecx, [cs:ebx+0x4f1c6301]");
    __eax = __eax ^ -1249705586;
    asm("hlt ");
    _push(cs);
    asm("cdq ");
    asm("invalid ");
    asm("sbb al, 0x13");
    if(__eflags >= 0) {
        while(1) {
             *_t170 =  *((intOrPtr*)(__ebp - 4)) +  *((intOrPtr*)(__ebp + 8)) & 4294967295;
            goto L12;
        }
    }
    asm("invalid ");
    asm("xchg [esp+eax*8+0x4619c7d1], eax");
    __ecx = __ecx;
    asm("aam 0xc7");
    asm("scasd ");
    asm("hlt ");
    asm("out 0x5d, al");
    asm("faddp st4, st0");
    asm("movsd ");
    goto L18;
}

LPSTR lstrcpyA(LPSTR a, LPCSTR b)
{// addr = 0x00401860
    goto __imp__lstrcpyA;
}

@type-tree LPSTR@LPSTR@ lstrcpyA(@type-tree LPSTR@LPSTR@ a, @type-tree LPCSTR@LPCSTR@ b)
{// addr = 0x00401860
    goto __imp__lstrcpyA;
}

// Statistics:
//      87 Register nodes
//       3 Temporaries nodes
//      15 Casts
//      59 Statements
//      12 Labels
//       7 Gotos
//       3 Blocks
//     417 Nodes
//      52 Assembly nodes
//      17 Unknown Types


