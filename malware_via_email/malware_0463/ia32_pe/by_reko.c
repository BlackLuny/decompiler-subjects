// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	struct Eq_3 * esp_18;
	byte SCZO_19;
	byte SZO_22;
	byte C_23;
	word32 eax_24;
	byte Z_25;
	word32 ebp_26;
	word32 edi_27;
	byte cl_28;
	byte dl_29;
	word32 ecx_30;
	byte CZ_31;
	word32 edx_32;
	byte S_33;
	Eq_17 ebx_20;
	Eq_17 esi_104;
	SHLWAPI.dll!StrStrIA();
	if (eax_24 == 0x00)
	{
		*(esp_18 - 0x04) = 0x00;
		*(esp_18 - 0x08) = 0x00;
		Eq_2 eax_57 = AddUsersToEncryptedFile(*(esp_18 - 0x08), *(esp_18 - 0x04));
		if (eax_57 != 0x00)
		{
			*(esp_18 - 0x04) = ~0x00;
			*(esp_18 - 0x08) = ~0x00;
			Eq_64 eax_66 = AreAllAccessesGranted(*(esp_18 - 0x08), *(esp_18 - 0x04));
			if (eax_66 == 0x00)
				ebx_20 = eax_66 + 0x19;
			*(esp_18 - 0x04) = ebp_26;
			*(esp_18 - 0x08) = edi_27;
			*(esp_18 - 0x0C) = (char *) &esp_18->ptr0008 + 0x04;
			*(esp_18 - 0x10) = 0x40;
			*(esp_18 - 0x14) = 0x3000;
			*(esp_18 - 0x18) = 0x00401000;
			VirtualProtect(*(esp_18 - 0x18), *(esp_18 - 0x14), *(esp_18 - 0x10), *(esp_18 - 0x0C));
			esp_18->ptr0008 = esp_18->ptr0008 - 0x01;
			struct Eq_150 * eax_156 = null;
			do
			{
				if (esi_104 == ebx_20)
					esi_104 = null;
				eax_156->b401678 = esi_104[0x00404000] ^ eax_156->b401678 ^ 0xAA;
				Eq_17 esi_107 = esi_104 + 0x01;
				if (esi_107 == ebx_20)
					esi_107 = null;
				eax_156->b401679 = esi_107[0x00404000] ^ eax_156->b401679 ^ 0xAA;
				Eq_17 esi_117 = esi_107 + 0x01;
				if (esi_117 == ebx_20)
					esi_117 = null;
				eax_156->b40167A = esi_117[0x00404000] ^ eax_156->b40167A ^ 0xAA;
				Eq_17 esi_127 = esi_117 + 0x01;
				if (esi_127 == ebx_20)
					esi_127 = null;
				eax_156->b40167B = esi_127[0x00404000] ^ eax_156->b40167B ^ 0xAA;
				Eq_17 esi_137 = esi_127 + 0x01;
				if (esi_137 == ebx_20)
					esi_137 = null;
				eax_156[700010] = (struct Eq_150) (esi_137[0x00404000] ^ eax_156[700010] ^ 0xAA);
				Eq_17 esi_147 = esi_137 + 0x01;
				if (esi_147 == ebx_20)
					esi_147 = null;
				eax_156 = eax_156 + 0x01;
				eax_156->b401677 = esi_147[0x00404000] ^ eax_156->b40167D ^ 0xAA;
				esi_104 = (Eq_17) (esi_147 + 0x01);
			} while (eax_156 < (struct Eq_150 *) 0x1440);
			esp_18->ptr0008 = (struct Eq_144 *) ((char *) &esp_18->ptr0008->dw0000 + 0x01);
			esp_18->dw0014 = 4199416;
			esp_18->ptr0010 = null;
			int32 edi_165 = 4199416;
			struct Eq_277 * ecx_166 = &globals->t402978;
			if (esp_18->ptr0008 > null)
			{
				do
				{
					Eq_312 eax_342 = ecx_166->t0004 - 0x08 >> 0x01;
					word16 * edx_345 = (char *) &ecx_166->t0004 + 0x04;
					if (eax_342 > 0x00)
					{
						Eq_312 ebx_366 = eax_342;
						do
						{
							ui32 eax_370 = (word32) *edx_345;
							if ((eax_370 & 0xF000) == 0x3000)
							{
								struct Eq_512 * eax_382 = (eax_370 & 0x0FFF) + ecx_166->dw0000;
								eax_382->dw4013F8 = eax_382->dw4013F8 + 0xF04013F8;
							}
							edx_345 = edx_345 + 0x01;
							ebx_366 = ebx_366 - 0x01;
						} while (ebx_366 != 0x00);
					}
					Eq_315 eax_351 = ecx_166->t0004;
					word32 edx_353 = Mem173[esp_18 + 0x10:word32] + eax_351;
					esp_18->ptr0010 = edx_353;
					word32 ecx_354 = ecx_166 + eax_351;
					int32 eax_358 = ecx_354->dw0004;
					struct Eq_144 * edx_360 = esp_18->ptr0010 + eax_358 / 0x0014;
					esp_18->ptr0010 = edx_360;
					ecx_166 = (struct Eq_277 *) (ecx_354 + eax_358 / 0x08);
				} while (edx_360 < esp_18->ptr0008);
			}
			esp_18->ptr0010 = &globals->t40216C;
			esp_18->ptr0010 = &globals->t40216C;
			esp_18->ptr0010 = &globals->t40216C;
			struct Eq_144 * ebx_192 = &globals->t40216C;
			edi_215 = edi_165;
			ebx_218 = ebx_192;
			if (globals->dw40217C != 0x00)
			{
				do
				{
					int32 edi_215;
					struct Eq_144 * ebx_218;
					*(esp_18 - 0x0C) = ebx_218->dw000C + edi_215;
					Eq_410 eax_225 = LoadLibraryA(*(esp_18 - 0x0C));
					esp_18->t0018 = eax_225;
					*(esp_18 - 0x0C) = ebx_218->dw000C + edi_215;
					Eq_410 eax_235 = LoadLibraryA(*(esp_18 - 0x0C));
					esp_18->t0018 = eax_235;
					*(esp_18 - 0x0C) = ebx_218->dw000C + edi_215;
					Eq_410 eax_245 = LoadLibraryA(*(esp_18 - 0x0C));
					esp_18->t0018 = eax_245;
					Eq_410 ecx_247 = eax_245;
					if (eax_245 != null)
					{
						ptr32 ebp_276 = ebx_218->dw0000;
						if (ebp_276 == 0x00)
							ebp_276 = ebx_218->dw0010;
						Eq_491 eax_282 = ebp_276 + edi_215;
						struct Eq_494 * ebp_283 = ebp_276 + edi_215;
						word32 * esi_284 = ebx_218->dw0010 + edi_215;
						if (eax_282 != 0x00)
						{
							while (true)
							{
								Eq_526 eax_302;
								if (eax_282 < 0x00)
								{
									*(esp_18 - 0x0C) = (word32) ebp_283->w0000;
									*(esp_18 - 0x10) = (HMODULE *) ecx_247;
									eax_302 = GetProcAddress(*(esp_18 - 0x10), *(esp_18 - 0x0C));
								}
								else
								{
									*(esp_18 - 0x0C) = (word32) eax_282 + 0x02 + edi_215;
									*(esp_18 - 0x10) = (HMODULE *) ecx_247;
									eax_302 = GetProcAddress(*(esp_18 - 0x10), *(esp_18 - 0x0C));
								}
								*esi_284 = (word32) eax_302;
								ebp_283 = ebp_283 + 0x01;
								eax_282.u1 = ebp_283->w0000;
								edi_215 = esp_18->dw0014;
								esi_284 = esi_284 + 0x01;
								if (eax_282 == 0x00)
									break;
								ecx_247 = esp_18->t0018;
							}
							ebx_218 = esp_18->ptr0010;
						}
					}
					ebx_218 = ebx_218 + 0x01;
					esp_18->ptr0010 = ebx_218;
				} while (ebx_218->dw0010 != 0x00);
			}
			ptr32 esp_195;
			byte SCZO_196;
			word32 ebx_197;
			word32 esi_198;
			byte SZO_199;
			byte C_200;
			word32 eax_201;
			byte Z_202;
			word32 ebp_203;
			word32 edi_204;
			byte cl_205;
			byte dl_206;
			word32 ecx_207;
			byte CZ_208;
			word32 edx_209;
			byte S_210;
			globals->t401E58();
			*(esp_195 - 0x04) = 0x00;
			ExitProcess(*(esp_195 - 0x04));
		}
		else
			return eax_57;
	}
	else
		return 0x00;
}

