/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_2509/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401030 - 0x0040108B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    *eax = *eax + al;
    *eax = *eax + al;
    eax = eax + 1;
    *eax = *eax + al;
    asm("adc [eax],al");
    *eax = *eax + al;
    al = al + *eax;
    *(eax + eax) = *(eax + eax) + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + eax;
    *edx = *edx + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    al = al + *eax;
    *eax = *eax + al;
    *eax = *eax + al;
    asm("adc [eax],al");
    *eax = *eax + dl;
    *eax = *eax + al;
    *eax = *eax + al;
    asm("adc [eax],al");
    *eax = *eax + dl;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    asm("adc [eax],al");
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *(ebx + 2621440) :: ecx;
    *eax = *eax + al;
    *eax = *eax + dh;
    *(eax + 193462283) = *(eax + 193462283) + cl;
}

/*	Procedure: 0x0040840C - 0x00408595
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040840C()
{



    asm("xchg eax,[%ss:ecx-0x23]");
    edx = edx - 1;
    eax = eax - 1;
    asm("loope 0x408413");
    asm("cwde");
    esi = edx;
    *(esi + -76375110) = al;
    asm("bound bp,[edx]");
    (restore)ss;
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    asm("lahf");
    (restore)es;
    cl = cl & *ecx;
    asm("Unknown opcode 0x82");
    esp = -1089687474;
    asm("xchg eax,esi");
    esp = 198367892;
    asm("xchg eax,ebx");
    *(esi + 1141925152) = *(esi + 1141925152) + ebp;
    bl = bl << cl;
    esi = -1418156640;
    (save)cs;
    (save)edi;
    asm("bound esi,[ecx+0x4c6c5824]");
    if(!(ebp = ebp + 1)) {
        asm("das");
        eax = 225799398;
        asm("adc eax,0x5cab7bf5");
        eax = eax + 311702649;
        asm("%s loadall286");
        if(ecx = ecx + ebp + *(edx + 992318265)) {
            goto L004084cb;
        }
        >= ? 0x40848a : ;
        eax = eax - 1;
        *ecx = *ecx - esp;
    }
    asm("in eax,0x93");
    asm("int 0x39");
    goto L0040848f;
    esp = 1335937478;
    *(ebx + -2128843416) = *(ebx + -2128843416) ^ eax;
    (restore)edi;
    edi = edi - 1;
    al = al | 173;
    -982247412 = *(ebx + -1397383611) * esi;
    (save)61;
L0040848f:
    asm("sti");
    asm("rep ret");
    asm("scasd");
    asm("salc");
    asm("arpl dx,si");
    *L2D6D7E7B = eax ^ -336803471;
    asm("adc esp,[ebp+eax*2+0x79]");
    asm("a16 jnl 0x4084a9");
    eax = eax ^ -1724607401;
    do {
        asm("pusha");
        asm("a16 mov ecx,0xfec1dda7");
        asm("into");
        asm("a16 xchg eax,esp");
        *edi & bl;
        asm("insb");
        asm("lodsd");
    } while(al - 167 < 83401401);
    al = *%fs:0x10e8cc8a];
L004084cb:
    eax = eax & 717205760;
    esi = -990073658;
    asm("aas");
    asm("cmc");
    *LA49224E2 = al;
    asm("rol byte [edx+0x30dfd4d0],0x96");
    *ebx & dh;
    (fsave) *%gs:0xf330f56c] - *(ebx - 44);
    (save)ebp;
    asm("adc ch,dh");
    asm("fldl2t");
    *edi = *esi;
    edi = edi + 4;
    -1860378906 = *(eax + edi * 8 + 1602721148) * (esi + 4);
    edi = edi - 1;
    eax = eax - -2022634280;
    goto L0040854f;
    asm("in al,0x5e");
    asm("cmc");
    ebp = ebp + 1;
    asm("popf");
    asm("int1");
    eax = *L20DA1D5E;
    asm("sbb al,0x28");
    asm("aaa");
    al = al - *(edi + 1622449117);
    goto L00408516;
L0040854f:
    while(1) {
        al = *L5D5BE522;
        asm("xchg dl,bh");
        bh = bh & *(edi + -933968572);
        (save)edx;
        if(al = al & 62) {
L00408516:
            asm("ror byte [edi-0x59],0xf9");
            asm("Unknown opcode 0xff");
            if(!(esi = esi & ebp + 1)) {
                (restore)ebp;
                (fsave)(frestore) * *(ecx - 79);
                (save)-95;
                if(edi = edi + 1) {
                    goto L00408573;
                }
                asm("int 0x65");
                asm("rol al,cl");
            }
            asm("out dx,eax");
            243945288 = *(esi + 1648255533) * ebx;
        } else {
            asm("adc [edx+0xeb7c3e8e],ebx");
            al = al & 211;
            (save)204567658;
            asm("iret");
            asm("loope 0x408532");
            ebx = ebx - 1;
L00408573:
            eax = eax + 1;
            asm("iret");
            edx = -930029622;
            asm("cld");
            asm("xchg eax,ecx");
            asm("clc");
            *%cs:esi] :: 66;
            dh :: *(ebx + edx * 4 + 1110989560);
            *edi = *esi;
            edi = edi + 4;
            esi = esi + 4;
            ch = 223;
            asm("%d popf");
        }
        ebp = ebp - 1;
        asm("out 0x31,al");
        ebx = ebx | edi;
        (restore)ebp;
        (restore)es;
        bh = 134;
        *L4D9F8756 = ~( *L4D9F8756);
        do {
        } while(esi = esi - 1);
    }
    asm("%s mov bl,0x9c");
    ebx = ebx - 1;
    asm("retf 0x6032");
}

/* DEST BLOCK NOT FOUND: 004086e2 -> ba6c8c3f */
/* DEST BLOCK NOT FOUND: 00408a8e -> 00401498 */
stack space not deallocated on return
/*	Procedure: 0x00408596 - 0x00408AFE
 *	Argument size: -31463
 *	Local size: 0
 *	Save regs size: 0
 */

L00408596()
{



    asm("xchg edi,[ebp+0x60]");
    *ebx = *ebx ^ esi;
    asm("outsd");
    *edx :: dl;
    asm("cmc");
    asm("adc eax,0x3d1db86f");
    al = al + *(edx + 265211970);
    asm("int3");
    *(esi - 54) = *(esi - 54) / *(esi - 54);
    edx = *(esi - 54) % *(esi - 54);
    if(!(edi = edi + 1)) {
        <= ? L0040861b : ;
        *(esi - 59) :: bh;
        esp = esp - ecx;
        asm("jpe 0x4085e9");
        ecx = ecx + 1;
        asm("int3");
        (save)esi;
        asm("xchg eax,esi");
        ecx = esi;
        asm("aas");
        asm("a16 out dx,eax");
        (restore)ecx;
        edi = edi + 1;
        edx = *%ds:0x63e35268] % *%ds:0x63e35268];
        if(!( *%ds:0x63e35268] = *%ds:0x63e35268] / *%ds:0x63e35268])) {
            (restore)esi;
            eax = L8fd98431();
            (save)ds;
            ah = 89;
            *edi = 89;
            edi = edi + 1;
            (save)ss;
            asm("salc");
            (restore)es;
            *edi = *esi;
            edi = edi + 1;
            esi = esi + 1;
            asm("retf 0xe5");
            (save)edx;
            ebp :: 0;
            edx = edx >> cl;
            eax = 28;
            ah = 154;
            asm("lds esi,[esi]");
            (save)edi;
            asm("%f jnc 0x408609");
            eax = -1003475391;
            esp = -158412051;
        }
    }
    asm("les ebp,[edi+0x9dd0617c]");
    asm("sbb al,0x1b");
    asm("Unknown opcode 0xd2");
    ebp = ebp ^ *(ecx + 2000726152);
    while(ecx <= *(ecx + 105)) {
    }
    *(edi + 1959271849) :: dl;
    asm("loope 0x408675");
    goto L0000a9c7;
    asm("adc edx,eax");
    asm("int3");
    al = (eax | 704409378) ^ 43;
    asm("mul byte [esi+0x56]");
    al = al + 145;
    asm("cmpsd");
    asm("in eax,dx");
    (save)cs;
    ax :: 57722;
    edx :: eax;
    asm("adc eax,0x2380e985");
    esi = esi + *(ebx + edx * 8 + 838633507);
    (fsave) *(edi + 116);
    asm("%s and ebx,ebx");
    ah = ah & cl;
    al = 69;
    ebp = ebp - 1;
    esp = esp - 1;
    asm("cdq");
    (save)eax;
    if(edi >= ecx) {
        eax = eax - 1;
        ebx = 603606235;
        edx = *(esi + -288780642);
    }
    (restore)ecx;
    asm("aam 0x43");
    *edx = *edx >> cl;
    asm("sbb esp,ebx");
    eax = *LCC82EB38;
    if(!(eax = eax + -686575723)) {
        asm("xchg eax,esp");
        al :: 85;
        *edi = *esi;
        edi = edi + 4;
        esi = esi + 4;
        eax = eax + -1070202139;
        asm("xchg eax,esi");
        (restore)esp;
        edi = *(ebx + -91495887);
        -63 = esi * edi;
        asm("Unknown opcode 0x82");
        eax = eax - 1;
        asm("sti");
        asm("sbb eax,0x22f69e5a");
L00408691:
        L000013f5();
        asm("scasd");
        asm("adc al,0x60");
        al = al - 82;
        asm("out dx,al");
        *(ebp - 73) :: esi;
        asm("jecxz 0x4086d5");
        asm("aam 0xd");
        asm("aaa");
        asm("pusha");
        asm("salc");
        asm("fnstsw [edx-0x47]");
        asm("Unknown opcode 0x8d");
        asm("cld");
        asm("scasd");
        al & 125;
        dl = 68;
        asm("adc eax,0xfa886286");
        asm("adc esp,[ecx]");
        asm("loope 0x4086a8");
        asm("cld");
        return(al & 17);
        asm("xchg eax,edx");
        if(bl = bl + *(edi + edi * 8 + 100)) {
            goto L00408746;
        }
        ebp = -1055283558;
        asm("jpe 0x4086f6");
    }
    ebx = -1969273694;
    esi = esi - 1;
    asm("rol dword [ebx-0x3f],0x70");
    (save)ebp;
    return;
    asm("xchg eax,ebx");
    goto Lba6c8c3f;
    if(ecx = ecx - *(edi + esi * 4)) {
        goto L00408691;
    }
    asm("in al,0x5");
    asm("cld");
    asm("Unknown opcode 0xf0");
    asm("Unknown opcode 0xc6");
    (restore)ecx;
    (restore)ds;
    asm("xchg eax,edx");
    asm("das");
    if(!(ebx = ebx - 1)) {
        ch = 193;
        asm("int 0x46");
        al = eax + 1 & 227;
        asm("aas");
        asm("ror byte [edi+0x257a5a0f],0x63");
L00408705:
        asm("Unknown opcode 0xc1");
        eax = eax ^ -2074917961;
        ebx = ebx + 1;
        asm("imul dword [ecx]");
        eax = eax - 1;
        asm("loop 0x408706");
        asm("salc");
        al & 157;
        esi = esi & *(ebx + edx * 8 + 44);
        *(ecx + -1783132794) = *(ecx + -1783132794) << 207;
        al = al + 58;
    }
    asm("sti");
    asm("cmovl esp,[edx-0x65]");
    *(edi + -288308578) = *(edi + -288308578) - bh;
    asm("popf");
    asm("aam 0xb9");
    (save)cs;
    ecx = ecx - 1;
    asm("int 0x2c");
    al = al & 148;
    asm("loope 0x408703");
    asm("sbb [edx],dl");
    asm("outsd");
    asm("lodsd");
    bl = 220;
    (restore)ebx;
    ch = ch | ah;
    asm("imul byte [edx+0xa2339ea8]");
L00408746:
    *(ecx - 85) & esp;
    asm("rol byte [edx-0x6e],1");
    asm("hlt");
    asm("daa");
    if(!(eax = eax - -400088895)) {
        asm("sbb eax,0x18d1208b");
L0040875a:
        goto ( *(ecx + -140445442));
        ch & dl;
        asm("xchg eax,[edx]");
        ebx = ebx - edi;
        *edi = al;
        (restore)ds;
        asm("hlt");
        asm("aam 0x1");
        asm("ficom word [edx]");
        asm("xchg eax,edx");
        if(esi = esi + 1) {
            goto L00408705;
        }
        eax = eax | 292629108;
        bh = bh / bh;
        edx = bh % bh;
        ah = 179;
        179 :: 1608931242;
        if(*(esi + 34) = *(esi + 34) | edi) {
            goto L00408802;
        }
        ebx = ebx - 1;
        asm("fcom dword [esi+0x61]");
        asm("in eax,0x4b");
        bh = bh & al;
        (save)eax;
        (save)edx;
        esi = esi - 1;
        (save)ebx;
        al = al - 213;
        asm("xchg eax,edx");
        *(esp + esi * 4 - 45) = *(esp + esi * 4 - 45) & ecx;
        asm("xchg edx,edx");
        (save)ebp;
        *(ebx - 124) :: dl;
        asm("adc al,0xeb");
        al = al & 167;
        *edi = *esi;
        edi = edi + 1;
        esi = esi + 1;
        asm("jecxz 0x40872f");
        asm("pmulhw mm1,[ecx+0x7d40b180]");
        asm("loopne 0x40877d");
        asm("int 0x93");
        al = al ^ ah;
        if(edx = edx + 1) {
            goto L0040875a;
        }
        asm("adc [ebp+ebp*2+0x14],ch");
        >= ? 0x40876e : ;
        asm("aam 0x4b");
        *edi = *esi;
        edi = edi + 4;
        esi = esi + 4;
        al = 82;
    }
    eax = -1011297372;
    esp = esp + 1;
    *(ebp + 1215697371) = *(ebp + 1215697371) - 1;
    bl = 134;
L004087cf:
    ebp = ebp - 1;
    asm("rcl ecx,1");
    ebx = ebx - 1;
L004087db:
    asm("adc edx,eax");
    asm("xchg eax,esp");
    if(!(eax + -1679780276 & 164)) {
        asm("Unknown opcode 0x8f");
        al & 147;
        (restore)esp;
        *edi = *edi ^ ebp;
        esi :: *L1ED9326E;
    }
    *(esi + 289151699) & edi;
L004087f5:
    ebp = ebp - *(edi - 53);
    asm("adc esi,ecx");
    *(eax + -42214589) = *(eax + -42214589) ^ dl;
L00408802:
    asm("daa");
    edi = edi - 1;
    *edi = eax;
    edi = edi + 4;
    asm("fcomp st3");
    ah = ah & al;
    asm("%s inc ebx");
    asm("sbb al,0xfc");
    ch = 23;
    asm("%s ret 0xc37c");
    edx = *(ecx + -1509633165);
    asm("sbb al,0x70");
    (restore)edx;
    asm("loop 0x40884f");
    if(edi = edi - 1) {
        goto L004087cf;
    }
    asm("out 0x5b,al");
    eax = eax & -2017126846;
    74 = eax * ecx;
L00408829:
    asm("sbb al,0x3");
    asm("loop 0x4087b0");
    st1 = (frestore);
    (save)edi;
    asm("cmpsd");
    asm("a16 adc eax,0x5bd9d1a4");
    asm("in eax,0xc1");
    -1426773103 = edi * ebx;
    bl = 193;
    (save)edx;
    if(*(eax - 1 + -1649484473) = *(eax - 1 + -1649484473) | ecx) {
        goto L004087db;
    }
    asm("cli");
    edx = -1859413882;
    asm("out dx,eax");
    asm("sbb al,[ecx+0x20]");
    (restore)ecx;
    ecx = -1394863678;
L0040885d:
    asm("sbb eax,[eax+0xa81eb130]");
    asm("adc ah,bh");
    st2 = (frestore);
    asm("sbb al,0x42");
    if(*(esi + 63) = *(esi + 63) - 1) {
        goto L004087f5;
    }
    edx = edx - 1;
    ebp = edi;
    (save)ds;
    (save)eax;
    asm("outsd");
    asm("lodsd");
    asm("in eax,0x21");
    if(al = al | *(edx + edx + -614158926)) {
        goto L00408829;
    }
    asm("xchg eax,ecx");
    goto L00005359;
    (restore)ebp;
    *L6FE172F6 = *L6FE172F6 - ecx;
    (restore)ds;
    eax = (eax | 1319219160) + (eax | 1319219160);
    asm("pushf");
    asm("int1");
    asm("Unknown opcode 0xc6");
    asm("in al,dx");
    asm("aam 0x89");
    asm("pushf");
    asm("out 0xec,eax");
    if(*eax = *eax & bl) {
        goto L00408829;
    }
    *(esi + ebp * 4 + -514645615) = bl;
    (restore)ebx;
    if(al = al + *(esi + 1351214269)) {
        goto L0040885d;
    }
    eax = L00005004();
    asm("adc al,0x2c");
    asm("outsb");
    asm("jpo 0x408848");
    bh = bh - ah;
    asm("insd");
    asm("sbb [ecx],al");
    asm("jpo 0x40892e");
    asm("Unknown opcode 0xff");
    asm("cli");
    ebx = -1519297158;
    (save)ecx;
    asm("sbb ecx,ecx");
    asm("out dx,eax");
    *(edx + 295953661) :: 67;
    asm("lahf");
    ebp = ebp + 1;
    asm("%s aad 0x33");
    asm("out dx,eax");
    eax = eax & 4186430;
    esi = 4194696;
    asm("lodsd");
    edi = eax;
    asm("xchg eax,ebp");
    asm("lodsd");
    asm("xchg eax,ecx");
    asm("rep movsd");
    asm("lodsd");
    ch = 28;
    asm("rep stosd");
    asm("lodsd");
    (save)eax;
    asm("xchg eax,edi");
    eax = *esi();
    if(!(edx = ebp + ecx * 4 + 92)) {
        if(!(al = al - 3)) {
            al = 0;
        }
        if(al >= 7) {
            al = al - 3;
        }
        (save)eax;
        ebx = ( *(edi - 1) & 255) << 3;
        ebx = ebp + 4108;
        al = 1;
        asm("jecxz 0x408950");
        ch = *(edi - *(ebp + 12));
        edx = 0;
        (save)0;
        edx = 1 & 255;
        *esi();
        (restore)edx;
        asm("lahf");
        asm("adc al,al");
        cl = cl >> 1;
        if(!(edx = ebx + al * 4)) {
            asm("sahf");
            asm("sbb dh,dl");
            == ? L00408930 : ;
            ah = 0;
            ecx = 0;
            ch = 1;
            *(esi + 8)();
        }
        ecx = 0;
        goto ( *(esi + 36));
    }
    ebx = *(ebp + 12);
    eax = *esi();
    if(!(edx = edx + 48)) {
        *esi();
        if(!(edx = edx + ecx)) {
            eax = *esi();
            if(edx = edx + ecx) {
                goto L0040899a;
            }
            al = 9;
            if(al >= 7) {
                al = 11;
            }
            (save)eax;
            eax = edi - *(ebp + 12);
            al = *eax;
            goto ( *(esi + 32));
        }
        eax = *esi();
        asm("xchg ebx,[ebp+0x10]");
        if(!(edx = edx + 96)) {
            eax = *esi();
            asm("xchg ebx,[ebp+0x14]");
            if(!(edx = edx + ecx)) {
                asm("xchg ebx,[ebp+0x18]");
            }
        }
L0040899a:
        al = 8;
        if(al >= 7) {
            al = 11;
        }
        (save)eax;
        (save)ebx;
        eax = *(esi + 12)();
        (restore)ebx;
        asm("xchg eax,ecx");
        goto ( *(esi + 60));
    }
    (restore)es;
    al = 7;
    if(!(edx = ebp + *(esi + 20))) {
        al = 10;
    }
    (save)eax;
    asm("xchg ebx,[ebp+0x10]");
    asm("xchg ebx,[ebp+0x14]");
    *(ebp + 24) = ebx;
    edx = ebp + *(esi + 24);
    eax = *(esi + 12)();
    ecx = 3;
    (save)eax;
    eax = eax - 1;
    if(eax >= 3) {
        eax = 3;
    }
    eax = eax << 6;
    cl = 64;
    ebx = ebp + eax * 4 + 892;
    ebx = eax;
    if(*(esi + 4)() >= 4) {
        ebx = 0;
        eax = eax >> 1;
        asm("adc ebx,ebx");
        eax = eax - 1;
        ebx = ebx + 1;
        asm("xchg eax,ecx");
        ebx = ebx + 1 << cl;
        cl :: 5;
        if(!(edx = ebp + ebx * 4 + 380)) {
            cl = cl - 4;
            eax = 0;
            *(ebp + 8) = *(ebp + 8) >> 1;
            edx = *( *ebp);
            asm("bswap edx");
            edx = edx - *(ebp + 4);
            eax = eax + eax;
            if(edx >= *(ebp + 8)) {
                edx = *(ebp + 8);
                eax = eax + 1;
                *(ebp + 4) = *(ebp + 4) + edx;
            }
            eax = *(esi + 16)();
            asm("loop 0x408a07");
            cl = 4;
            ebx = ebx + (eax << 4);
            edx = ebp + 28;
        }
        (save)ebx;
        (save)ecx;
        eax = 1 << cl;
        ebx = edx;
        asm("xchg eax,ecx");
        eax = *(esi + 4)();
        edx = 0;
        (restore)ecx;
        eax = eax >> 1;
        asm("adc edx,edx");
        asm("loop 0x408a40");
        (restore)ebx;
        ebx = ebx + edx;
    }
    ebx = ebx + 1;
    (restore)ecx;
    *(ebp + 12) = ebx;
    (save)esi;
    esi = edi - ebx;
    asm("rep movsb");
    al = *esi;
    esi = esi + 1;
    (restore)esi;
    cl = 128;
    *edi = al;
    if(edi + 1 < *(esi + 44)) {
        goto ( *(esi + 40));
    }
    (restore)eax;
    ecx = *(esi + 48);
    (restore)edi;
    asm("jecxz 0x408a84");
L00408a69:
    al = *edi;
    edi = edi + 1;
    al = al + 24;
    if(al >= 2 || *edi != 2) {
        goto L00408a69;
    }
    al = 0;
    asm("bswap eax");
    eax = eax + *(esi + 28) - edi;
    *edi = eax;
    edi = edi + 4;
    asm("loop 0x408a69");
    ebx = *(esi + 52);
    esi = *(esi + 56);
L00408a8a:
    esi = esi + 1;
    asm("lodsd");
    if(eax == 0) {
        goto L00401498;
    }
    (save)esi;
    asm("xchg eax,edi");
    eax = *(ebx - 4)();
    asm("xchg eax,ebp");
L00408a9a:
    al = *esi;
    esi = esi + 1;
    if(al != 0) {
        goto L00408a9a;
    }
    if(*esi == al) {
        goto L00408a8a;
    }
    eax = esi;
    >= ? 0x408aac : ;
    esi = esi + 1;
    eax = 0;
    eax = *esi;
    esi = esi + 4;
    eax = *ebx(ebp, eax);
    *edi = eax;
    edi = edi + 4;
    goto L00408a9a;
    (save)eax;
    (save)edx;
    eax = *(ebp + 8) >> 11;
    asm("mul dword [edx]");
    edx = *( *ebp);
    asm("bswap edx");
    (restore)edx;
    if(eax > edx - *(ebp + 4)) {
        *(ebp + 8) = eax;
        *edx = *edx + (8 - *edx >> 5);
    } else {
        *(ebp + 4) = *(ebp + 4) + eax;
        *(ebp + 8) = *(ebp + 8) - eax;
        *edx = *edx - ( *edx >> 5);
        asm("stc");
    }
    (restore)eax;
    asm("pushf");
    if(*(ebp + 11) == 0) {
        *ebp = *ebp + 1;
        *(ebp + 4) = *(ebp + 4) << 8;
        *(ebp + 8) = *(ebp + 8) << 8;
    }
    asm("popf");
}

/*	Procedure: 0x00408AFF - 0x00408B0F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00408AFF()
{



    eax = 1;
    do {
        edx = ebx + eax * 4;
        eax = *esi();
        asm("adc eax,eax");
    } while(eax < ecx);
    return(eax - ecx);
}

/*	Procedure: 0x00408B10 - 0x00408B30
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00408B10()
{



    cl = 8;
    eax = *esi();
    al = 1;
    if(!(edx = edx + 4)) {
        eax = *esi();
        al = 9;
        >= ? L00408b26 : ;
        ecx = ecx << 5;
        al = 17;
    }
    ebx = edx + eax * 4;
    eax = *(esi + 4)(eax);
    (restore)ebx;
    return(eax + ebx);
}

/*	Procedure: 0x00408B31 - 0x00408B38
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00408B31()
{



    (save)cs;
    *eax = *eax + al;
    *esi = *esi + bl;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* address  size  */
/* 0x00401030       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
