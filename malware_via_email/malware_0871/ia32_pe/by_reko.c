// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004010C4: Register DWORD Win32CrtStartup()
DWORD Win32CrtStartup()
{
	real64 rArg0_10;
	word32 edi_11 = fn004010D4(eax, cx, edx, ebx, ebp, edi, rArg0, rArg5, out rArg0_10);
	byte v5_15 = Mem0[eax + 0x00:byte] + al;
	Mem16[eax + 0x00:byte] = v5_15;
	byte al_19 = al - (v5_15 <u 0x00);
	Mem28[edx + 3244744192:byte] = Mem16[edx + 3244744192:byte] + (byte) ((~0x6F - (fp + 0x08)) - (al_19 <u 0x00));
	word32 eax_20 = DPB(eax, al_19, 0);
	fn004010D6(eax_20, edx, ebx, ebp, edi_11, dwArg00);
	return eax_20;
}

// 004010D4: Register word32 fn004010D4(Register word32 eax, Register word16 cx, Register word32 edx, Register word32 ebx, Register word32 ebp, Register word32 edi, FpuStack real64 rArg0, FpuStack real64 rArg5, FpuStack out ptr32 rArg0Out)
word32 fn004010D4(word32 eax, word16 cx, word32 edx, word32 ebx, word32 ebp, word32 edi, real64 rArg0, real64 rArg5, ptr32 & rArg0Out)
{
	__rol(cx, 0x04);
	return fn004010D6(eax, edx, ebx, ebp, edi, dwArg00);
}

// 004010D6: Register word32 fn004010D6(Register word32 eax, Register word32 edx, Register word32 ebx, Register word32 ebp, Register word32 edi, Stack word32 dwArg00)
word32 fn004010D6(word32 eax, word32 edx, word32 ebx, word32 ebp, word32 edi, word32 dwArg00)
{
fn004010D6_entry:
	def fp
	def edx
	def ebx
	def Mem0
	def edi
	def dwArg00
	def rArg0
	def eax
	def ebp
	def rArg5
	esp_1 = fp
	v3_5 = (edx[ebx * 0x02] & 0x04000000) != 0x00
	edx[ebx * 0x02] = __rol(edx[ebx * 0x02], 0x66)
	edi_8 = edi - ~0x3E
	edi_10 = dwArg00
	edi_11 = edi_10 - ~0x07
	di_12 = (word16) edi_11 (alias)
	ecx_13 = 0x00
	ecx_14 = ~0x6F
	cl_15 = (byte) ecx_14 (alias)
	cx_16 = (word16) ecx_14 (alias)
	SCZO_17 = cond(Mem6[edi_11 + 0x00:byte] - cl_15)
	Z_18 = SCZO_17 (alias)
	branch Mem6[edi_11 + 0x00:byte] == cl_15 l004010EA_thunk_fn0040110D
	goto l004010EC_in_fn004010D6
l004010D6:
l004010D6:
	edx = Mem0[esp + 0x00:word32]
	esp = esp + 0x04
	di = di - ~0x3E
	edi = Mem0[esp + 0x00:word32]
	edi = edi - ~0x07
	di = (word16) edi (alias)
	ecx = 0x00
	ecx = ~0x6F
	cl = (byte) ecx (alias)
	cx = (word16) ecx (alias)
	SCZO = cond(Mem0[edi + 0x00:byte] - cl)
	Z = SCZO (alias)
	branch Test(EQ,Z) l0040110D
	goto l004010EC
l004010E8_thunk_fn0040110D:
	rArg0 = fn0040110D(eax, cx, ebp, di, rArg0, rArg5)
	return edi
l004010EA_thunk_fn0040110D:
	rArg0_24 = fn0040110D(eax, cx_16, ebp, di_12, rArg0, rArg5)
	return edi_11
l004010EC:
	return edi
l004010EC_in_fn004010D6:
	return edi_11
l004010EC_in_fn004010D6:
	return edi_11
fn004010D6_exit:
	rArg0_19 = PHI(rArg0_24, rArg0, rArg0, rArg0, rArg0)
}

// 0040110D: FpuStack real64 fn0040110D(Register word32 eax, Register word16 cx, Register word32 ebp, Register word16 di, FpuStack real64 rArg0, FpuStack real64 rArg5)
real64 fn0040110D(word32 eax, word16 cx, word32 ebp, word16 di, real64 rArg0, real64 rArg5)
{
	fn00401123(eax, cx, ebp, di, dwLoc04, dwArg00);
}

// 00401123: void fn00401123(Register word32 eax, Register word16 cx, Register word32 ebp, Register word16 di, Stack word32 dwArg00, Stack word32 dwArg04)
void fn00401123(word32 eax, word16 cx, word32 ebp, word16 di, word32 dwArg00, word32 dwArg04)
{
fn00401123_entry:
	def fp
	def ecx
	def Mem0
	def ebp
	def dwArg04
	def fs
	eax_19 = DPB(1215832, (word16) (fp + 0x04), 0) (alias)
	edx_30 = Mem0[0x004010BF:word32]
	edi_23 = Mem0[eax_19 + 0x00:word32]
	ecx_28 = -DPB(ecx + 3631729173, (word16) (ecx + 3631729173) - 0x5D, 0)
	ax_33 = (word16) (eax_19 & edx_30) (alias)
	goto l00401157
l00401123:
l00401157:
	ax_36 = PHI(ax_33, ax_51)
	ecx_38 = PHI(ecx_28, ecx_47)
	edi_39 = PHI(edi_23, edi_41)
	edi_41 = edi_39 + 0x01
	esi_49 = ~Mem0[edi_41 + 0x00:word32] + edx_30
	ecx_47 = ~ecx_38
	ax_51 = __ror(ax_36 + 0x7F, 0x01)
	branch esi_49 != 0x01 l00401157
l00401173:
	__rol(ecx_47, 0x01)
	eax_67 = Mem0[edi_41 - 0x05 + 0x00:word32]
	__ror((edx_30 ^ ebp) + 4001110173, 0x02)
	ecx_76 = fp + 0x04
	eax_84 = dwArg04
	edi_88 = Mem0[4198441:word32]
l004011AE:
	eax_94 = PHI(eax_84, eax_101)
	ecx_95 = PHI(ecx_76, ecx_106)
	esi_98 = Mem0[eax_94 + 0x00:word32]
	__rol(ecx_95, 0x06)
	eax_101 = eax_94 - ~0x00
	ecx_106 = esi_98 ^ edi_88
	branch ecx_106 == 0x00 l004011CE
	goto l004011AE
l004011CE:
	edi_115 = edi_88 ^ eax_67
	cx_140 = (word16) ((eax_67 + 2856355484 ^ DPB(edi_115, (word16) edi_115 | ~0x35, 0)) + Mem0[fs:0x00:word32]) (alias)
	Mem141[fs:0x00:word32] = fp - 0x04
	__rol(cx_140, 0x07)
	return
fn00401123_exit:
}

