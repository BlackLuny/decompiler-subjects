// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00410328: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 esp_6;
	word32 edx_7;
	ptr32 ebp_8;
	word32 ecx_9;
	byte SCZO_10;
	byte SZO_11;
	byte C_12;
	byte Z_13;
	word32 eax_14;
	_p__iob();
	word32 ecx_20 = (word32) *(ebp_8 - 113) + dwLoc3C;
	struct Eq_25 * esp_25;
	word32 edx_26;
	struct Eq_27 * ebp_27;
	word32 ecx_28;
	byte SCZO_29;
	byte SZO_30;
	byte C_31;
	byte Z_32;
	word32 eax_33;
	tell();
	ui32 ecx_46 = (word32) *(ebp_27 - 0x46);
	*(esp_25 - 0x08) = 0x00;
	Eq_53 eax_56 = GetStdHandle(*(esp_25 - 0x08));
	word32 ecx_65 = (word32) *(ebp_27 - 118) + *(esp_25 - 0x80);
	ptr32 esp_70;
	word32 edx_71;
	struct Eq_96 * ebp_72;
	word32 ecx_73;
	byte SCZO_74;
	byte SZO_75;
	byte C_76;
	byte Z_77;
	word32 eax_78;
	_p__osver();
	*(esp_70 - 0x08) = (word32) ebp_72->b003A & 0x07;
	*(esp_70 - 0x0C) = 0x0F;
	uint32 eax_89 = _rotr(*(esp_70 - 0x0C), *(esp_70 - 0x08));
	ui32 edx_117 = (word32) *(ebp_72 - 22) ^ *(ebp_72 - 0x30);
	ui32 ecx_118 = (word32) ebp_72->b0004;
	*(esp_70 - 0x08) = 0x1F;
	word32 esp_123;
	word32 edx_124;
	word32 ebp_125;
	word32 ecx_126;
	byte SCZO_127;
	byte SZO_128;
	byte C_129;
	byte Z_130;
	word32 eax_131;
	ftol();
	ptr32 esp_140;
	word32 edx_141;
	ptr32 ebp_142;
	word32 ecx_143;
	byte SCZO_144;
	byte SZO_145;
	byte C_146;
	byte Z_147;
	word32 eax_148;
	_p__osver();
	word32 edx_165 = (word32) *(esp_140 - 0x5F);
	word32 esp_169;
	struct Eq_254 * ebp_171;
	word32 ecx_172;
	byte SCZO_173;
	byte SZO_174;
	byte C_175;
	byte Z_176;
	word32 eax_177;
	ui32 edx_170;
	tell();
	if (edx_170 != 0x024F)
		edx_170 = (word32) ebp_171->w0060 - ebp_171->dw0008 ^ *(ebp_171 - 0x6C);
	word32 edx_188 = edx_170 + 0x131E;
	struct Eq_323 * esp_193;
	word32 edx_194;
	struct Eq_325 * ebp_195;
	word32 ecx_196;
	byte SCZO_197;
	byte SZO_198;
	byte C_199;
	byte Z_200;
	word32 eax_201;
	_p__osver();
	*(esp_193 - 0x08) = 0x00;
	*(esp_193 - 0x0C) = 0x15;
	_rotr(*(esp_193 - 0x0C), *(esp_193 - 0x08));
	*(esp_193 - 0x08) = 0x00;
	GetDC(*(esp_193 - 0x08));
	GetCurrentProcess();
	ui32 edx_241 = (word32) *(ebp_195 - 22);
	if ((ebp_195->dw0010 ^ 0x3ADC) == *(ebp_195 - 0x48))
		edx_241 = (word32) ebp_195->b004C & *(esp_193 - 0x3C);
	Eq_2 eax_248 = GetLastError();
	<anonymous> * eax_258 = (eax_248 & 0x00) + 4243328;
	ui32 ecx_271 = (word32) ebp_195->w0008;
	Eq_376 edx_291 = ebp_195->t0004;
	if (edx_291 != (word32) (*(ebp_195 - 110)) + ebp_195->dw0010)
		edx_291 = edx_291 ^ *(ebp_195 - 0x68) ^ ebp_195->t0004;
	ui32 edx_317 = (word32) ebp_195->w000F;
	ui32 ecx_321 = (word32) *(ebp_195 - 0x28) ^ edx_317 + 4349;
	bool Z_324 = cond(ecx_321 - (edx_317 + 4349));
	if (ecx_321 != edx_317 + 4349)
	{
		word32 ecx_438 = ((word32) *(esp_193 - 0x08) ^ ebp_195->t0004) + *(ebp_195 - 88);
		Z_324 = cond(ecx_438);
	}
	word32 edx_331 = (word32) ebp_195->b007A;
	word32 ecx_332 = (word32) *(esp_193 - 0x36);
	if (!Z_324)
	{
		ecx_332 = (word32) ebp_195->w0034;
		edx_331 = (word32) ebp_195->w005D + ecx_332;
		if (*(ebp_195 - 0x0230) == edx_331)
		{
			ecx_332 = (word32) *(ebp_195 - 0x11);
			edx_331 = 0x2094;
			if (ecx_332 != 0x011C)
			{
				ecx_332 = *(ebp_195 - 0x44) + 0x0F87;
				edx_331 = *(ebp_195 - 0x14) + 0x2094;
			}
		}
	}
	ui32 ecx_337 = (ecx_332 ^ edx_331) - *(ebp_195 - 0x48);
	if (ecx_337 == (((word32) ebp_195->w0077 & 11134) & 1848))
		ecx_337 = (word32) *(ebp_195 - 111) + *(ebp_195 - 0x5C) & *(esp_193 - 88);
	word32 esp_361;
	word32 edx_362;
	word32 ebp_363;
	word32 ecx_364;
	byte SCZO_365;
	byte SZO_366;
	byte C_367;
	byte Z_368;
	word32 eax_369;
	eax_258();
	return eax_369;
}

