// subject.c
// Generated on 5/4/2015 1:17:57 AM by decompiling malware_via_email/malware_0604/ia32_pe/subject.exe
// using Decompiler version 0.4.2.0.

#include "subject.h"

void fn0040103C(word32 dwArg00)
{
fn0040103C_entry:
l0040103C:
fn0040103C_exit:
}

byte fn00401054(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 esi, word32 edi, ptr32 eaxOut, ptr32 edxOut, ptr32 ebxOut, ptr32 esiOut, ptr32 ediOut)
{
fn00401054_entry:
l00401054:
	word32 edi_5 = edi + esi
	word32 ecx_7 = (ecx | esi) - 0x00000001 - (edi_5 + 0x00000001)
	word32 ebx_9 = ebx ^ ecx_7
	word32 edi_10 = edi_5 + 0x00000001 | esi
	branch edi_10 <= 0x00000000 l0040111B
l00401066:
l0040106B:
l0040111B:
	word32 edx_16 = edx ^ eax
l0040111E_thunk_fn0040111F:
	word32 eax_20
	word32 edx_21
	word32 ebx_22
	word32 esi_23
	word32 edi_24
	return fn0040111F(eax, ecx_7, edx_16, ebx_9 - 0x00000001, esi + 0x00000001, edi_10, out eax_20, out edx_21, out ebx_22, out esi_23, out edi_24)
fn00401054_exit:
}

void fn00401078(word32 ecx, word32 edx, word32 ebx, word32 esi, word32 edi, word32 dwArg00)
{
fn00401078_entry:
l00401078:
l00401170:
fn00401078_exit:
}

real64 fn004010B7(word32 esi, word32 edi, word16 bx, byte cl, byte ch, byte dh, real64 rArg0)
{
	esp = fp;
	rArg0 = rArg0 * (real64) Mem0[esi + 0x0000000B:word32];
	fn00401266(edi, bx, cl, ch, dh);
	return;
}

byte fn004010F4(word32 eax, word32 edx, word32 ebx, word32 esi, word32 edi, ptr32 eaxOut, ptr32 edxOut, ptr32 ebxOut, ptr32 esiOut, ptr32 ediOut)
{
	*ebxOut = ebx;
	word32 esi_6 = esi | eax;
	*esiOut = esi_6;
	word32 edx_15 = edx - esi_6;
	*edxOut = edx_15;
	word32 edi_11 = ebx ^ edx;
	*ediOut = edi_11;
	word32 eax_12;
	*eaxOut = eax & 0xEEEEEEEE;
	word16 ax_13 = (word16) (eax & 0xEEEEEEEE);
	byte al_14 = (byte) (eax & 0xEEEEEEEE);
	word16 dx_16 = (word16) edx_15;
	byte SCZO_17 = cond(edx_15);
	if (edx_15 >= 0x00000000)
	{
		word32 edi_38;
		*ediOut = edi_11;
		word32 esi_41;
		*esiOut = esi_6;
		if (edx_15 < 0x00000000)
		{
			__outw(dx_16, ax_13);
			Mem43[eax & 0xEEEEEEEE:word32] = esi_6;
			Mem49[0x4BD03346:byte] = al_14 & 0x9D;
			word32 eax_45 = DPB(eax & 0xEEEEEEEE, al_14 & 0x9D, 0, 8);
			word32 eax_50;
			word32 edx_51;
			word32 ebx_52;
			word32 esi_53;
			word32 edi_54;
			return fn0040111F(eax_45, esi_6, edx_15, ebx, esi_6, edi_11, out eax_50, out edx_51, out ebx_52, out esi_53, out edi_54);
		}
		else
		{
			fn00401379(eax & 0xEEEEEEEE, esi_6, edx_15, ebx, esi_6, edi_11);
			return SCZO_17;
		}
	}
	else
	{
		fn00401379(eax & 0xEEEEEEEE, esi_6, edx_15, ebx, esi_6, edi_11);
		return SCZO_17;
	}
}

bool fn0040111F(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 esi, word32 edi, ptr32 eaxOut, ptr32 edxOut, ptr32 ebxOut, ptr32 esiOut, ptr32 ediOut)
{
fn0040111F_entry:
l0040111F:
	esp = fp
	eax = Mem0[eax + 0x00000008:word32]
	ecx = ecx - ebx
	SCZO = cond(ecx)
	ebx = ecx
	esi = esi - 0x00000001
	SZO = cond(esi)
l0040111F:
	eax = Mem0[eax + 0x00000008:word32]
	ecx = ecx - ebx
	SCZO = cond(ecx)
	ebx = ecx
	esi = esi - 0x00000001
	SZO = cond(esi)
l00401127_thunk_fn004012D6:
	C = fn004012D6(eax, ecx, edx, ebx, edi, psegArg00, dwArg02, out eax, out edx, out ebx, out esi, out edi)
	SCZO = C (alias)
	return C
fn0040111F_exit:
	use eax (=> eaxOut)
	use edx (=> edxOut)
	use ebx (=> ebxOut)
	use esi (=> esiOut)
	use edi (=> ediOut)
}

void fn00401186(word32 eax, word32 ecx, word32 ebx, word32 esi, word32 edi, word32 dwArg00, selector psegArg04)
{
	dwLoc14 = dwArg00;
	esp = fp + 0x00000004;
	ecx = ecx - edi;
	edi = edi + esi;
	esi = esi | eax;
	edx = ecx;
	esi = esi + edi;
	edx = edx - edi;
	ebx = ebx - edx;
	SCZO = cond(ebx);
	edi = edx;
	fn00401288(dwArg00);
	ebx = ebx + 0x00000001;
	eax = eax | Mem0[edx - 0x00000042:word32];
	al = (byte) eax;
	SZO = cond(eax);
	C = __daa(al, &al);
	es = psegArg04;
	esp = fp + 0x00000006;
	__fldcw(Mem0[edx + 0x00000000:word16]);
	C = fn004011A7(eax, edx, ebx, esi, edi, out eax, out edx, out ebx, out esi, out edi);
	return;
}

byte fn004011A7(word32 eax, word32 edx, word32 ebx, word32 esi, word32 edi, ptr32 eaxOut, ptr32 edxOut, ptr32 ebxOut, ptr32 esiOut, ptr32 ediOut)
{
	esp = fp;
	edx = edx + eax;
	ecx = edi;
	ebx = ebx - edx;
	ebx = ebx ^ esi;
	C = false;
	eax = Mem0[eax + 0x00000000:word32];
	edi = eax;
	edi = edi + 0x00000001;
	ecx = ecx + 0x00000001;
	SZO = cond(ecx);
	SCZO = SZO;
	CZ = SZO;
	if (Test(UGT,CZ))
		fn004011BB();
}

void fn004011BB()
{
fn004011BB_entry:
l004011BB:
fn004011BB_exit:
}

void fn004011BC(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 ebp, word32 esi, word32 edi)
{
	if (!CZ)
	{
		word32 eax_16 = DPB(eax, 0x35, 8, 8);
		fn004011D0(eax_16, ecx, ebx, ebp, esi + 0x00000004);
		return;
	}
	else
	{
		word32 eax_27;
		word32 edx_28;
		word32 ebx_29;
		word32 esi_30;
		word32 edi_31;
		fn00401054(eax, ecx, edx, ebx, esi, edi, out eax_27, out edx_28, out ebx_29, out esi_30, out edi_31);
		return;
	}
}

void fn004011D0(word32 eax, word32 ecx, word32 ebx, word32 ebp, word32 esi)
{
	word32 edi_14 = ecx - esi;
	word32 ecx_15 = ecx - 0x00000001 | esi;
	fn00401078(ecx_15, esi + 0x00000001, esi, esi, edi_14, dwLoc08);
	Mem24[esi + 0x00000052:byte] = Mem0[esi + 0x00000052:byte] + ah;
	fn004011BC(eax, ecx_15, esi + 0x00000001, esi, fp - 0x00000004, esi, edi_14);
	return;
}

void fn004011F0(word32 ecx, word32 edx, word32 ebx, word32 esi, byte al, word32 dwArg00)
{
fn004011F0_entry:
l004011F0:
fn004011F0_exit:
}

void fn00401233(word32 esi, word16 dx, byte al, byte cl, byte ch, byte bh)
{
fn00401233_entry:
l00401233:
l00401233:
fn00401233_exit:
}

void fn00401266(word32 edi, word16 bx, byte cl, byte ch, byte dh)
{
fn00401266_entry:
l00401266:
l00401266:
fn00401266_exit:
}

void fn00401288(word32 dwArg00)
{
fn00401288_entry:
l00401288:
fn00401288_exit:
}

byte fn004012D6(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 edi, selector psegArg00, word32 dwArg02, ptr32 eaxOut, ptr32 edxOut, ptr32 ebxOut, ptr32 esiOut, ptr32 ediOut)
{
	word32 edx_10 = edx + 0x00000001 - edi;
	*edxOut = edx_10;
	word32 edi_13 = edi | edx_10;
	word32 esi_9;
	*esiOut = edi - 0x00000001;
	word32 ecx_12 = edi | edi - 0x00000001;
	word16 di_14 = (word16) edi_13;
	if (!OVERFLOW(edi_13))
	{
		edi_13 = DPB(edi_13, di_14, 0, 16);
		*ediOut = edi_13;
		ebx = DPB(ebx, bl, 0, 8);
		*ebxOut = ebx;
		if (OVERFLOW(edi_13))
		{
			word32 eax_71 = DPB(eax, al - 0x22, 0, 8);
			*eaxOut = eax_71;
			byte SCZO_72 = cond(al - 0x22);
			if (al == 0x22)
			{
				word32 eax_81;
				word32 edx_82;
				word32 ebx_83;
				word32 esi_84;
				word32 edi_85;
				return fn004012FC(eax_71, ecx_12, edx_10, ebx, edi - 0x00000001, edi_13, out eax_81, out edx_82, out ebx_83, out esi_84, out edi_85);
			}
			else
			{
				fn0040135D(ecx_12, edx_10, ebx, edi - 0x00000001, edi_13, dwArg00);
				return SCZO_72;
			}
		}
		else
		{
l004010F1:
			word32 ebx_46 = ebx ^ edi_13;
			word32 eax_51;
			word32 edx_52;
			word32 ebx_53;
			word32 esi_54;
			word32 edi_55;
			return fn004010F4(eax, edx_10 + 0x00000001, ebx_46, edi - 0x00000001, edi_13, out eax_51, out edx_52, out ebx_53, out esi_54, out edi_55);
		}
	}
	else
		goto l004010F1;
}

byte fn004012FC(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 esi, word32 edi, ptr32 eaxOut, ptr32 edxOut, ptr32 ebxOut, ptr32 esiOut, ptr32 ediOut)
{
fn004012FC_entry:
	goto l004012FC
l0040108F:
	word32 ebx_24 = ebx - 0x00000001 | eax_19
	word32 ebx_28 = ebx_24 + 0x00000001 | edx_8
	word32 esi_27 = (edi_20 | edx_8) + (ebx_24 + 0x00000001)
	*esiOut = esi_27
	word32 ebx_29
	*ebxOut = ebx_28 - 0x00000001
	word16 bx_30 = (word16) (ebx_28 - 0x00000001)
	word32 edx_31
	*edxOut = edx_8 - 0x00000001
	byte dh_32 = SLICE(edx_8 - 0x00000001, byte, 8)
	word32 edi_33 = edi_20 ^ ecx_15 ^ edx_8 - 0x00000001
	*ediOut = edi_33
	branch edi_33 <= 0x00000000 l0040109E_thunk_fn004011A7
	goto l004010A4
l0040109E_thunk_fn004011A7:
	word32 eax_79
	word32 edx_80
	word32 ebx_81
	word32 esi_82
	word32 edi_83
	return fn004011A7(eax_19, edx_8 - 0x00000001, ebx_28 - 0x00000001, esi_27, edi_33, out eax_79, out edx_80, out ebx_81, out esi_82, out edi_83)
l004010A4:
	branch P l004010A6
l004010A6:
	branch P l004010A8
l004010A8:
	branch edi_33 > 0x00000000 l004010A8_thunk_fn004011A7
	goto l004010AE
l004010A8_thunk_fn004011A7:
	word32 eax_72
	word32 edx_73
	word32 ebx_74
	word32 esi_75
	word32 edi_76
	return fn004011A7(eax_19, edx_8 - 0x00000001, ebx_28 - 0x00000001, esi_27, edi_33, out eax_72, out edx_73, out ebx_74, out esi_75, out edi_76)
l004010AE:
	word32 eax_55 = __indw(0x4A)
	byte cl_57 = (byte) (ecx_15 - 0x00000001)
	byte ch_58 = SLICE(ecx_15 - 0x00000001, byte, 8)
	branch ecx_15 != 0x00000001 l004010B0_thunk_fn004010F4
	goto l004010B2
l004010B0_thunk_fn004010F4:
	word32 eax_65
	word32 edx_66
	word32 ebx_67
	word32 esi_68
	word32 edi_69
	return fn004010F4(eax_55, edx_8 - 0x00000001, ebx_28 - 0x00000001, esi_27, edi_33, out eax_65, out edx_66, out ebx_67, out esi_68, out edi_69)
l004010B2:
	word32 eax_59
	*eaxOut = eax_55 | 0x3349C380
l004010B2_thunk_fn004010B7:
	fn004010B7(esi_27, edi_33, bx_30, cl_57, ch_58, dh_32, rArg0)
	return false
l004012FC:
	word32 edx_8 = edx ^ eax
	word32 ecx_15 = ecx - edi
	word32 eax_19 = Mem0[eax + 0x00000090:word32]
	word32 edi_20 = edi + esi
	goto l0040108F
fn004012FC_exit:
}

void fn00401339(word32 eax, word32 edx, word32 ebx, word16 di, byte cl, byte ch)
{
fn00401339_entry:
l00401339:
	byte bh_11 = bh + al
	byte ch_16 = ~ch
	word32 esi_19 = eax ^ (DPB(edx, dh + dl, 8, 8) | DPB(ebx, bh_11, 8, 8))
	word16 dx_26 = (word16) edi
	branch bh_11 < 0x01 l0040134E_thunk_fn00401233
	goto l00401354
l0040134E_thunk_fn00401233:
	fn00401233(esi_19 + 0x00000001, dx_26, al, cl, ch_16, bh_11 + 0x01)
	return
l00401354:
fn00401339_exit:
}

void fn0040135D(word32 ecx, word32 edx, word32 ebx, word32 esi, word32 edi, word32 dwArg00)
{
	word32 eax_7 = Mem0[edi + 0x00000000:word32] *s 0x448FBBE0;
	byte al_8 = (byte) eax_7;
	word32 edi_19 = edi + 0x00000001 - edx;
	word32 eax_22;
	word32 edx_23;
	word32 ebx_24;
	word32 esi_25;
	word32 edi_26;
	fn004012FC(DPB(eax_7, al_8 & 0xE8, 0, 8), ecx - 0x00000001, edx, ebx - 0x00000001 - esi, esi, edi_19, out eax_22, out edx_23, out ebx_24, out esi_25, out edi_26);
	word32 edi_30 = (word32) (SEQ(al_8 & 0xE8, edi_19) + 0x0000005F00000001);
	word32 ebx_35 = DPB(ebx_24, 0x09, 8, 8);
	fn0040137C(eax_22 + 0x4A474974, edx_23, ebx_35, esi_25, edi_30 + 0x00000001);
	return;
}

void fn00401379(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 esi, word32 edi)
{
	fn0040137C(eax, edx - 0x00000001, ebx, esi, edi + 0x00000001);
	return;
}

void fn0040137C(word32 eax, word32 edx, word32 ebx, word32 esi, word32 edi)
{
fn0040137C_entry:
	def fp
	def esi
	def edx
	def eax
	def edi
	def ebx
	def dwLoc04
	def ah
	def bh
l0040137C:
	esp_1 = fp
	esi_3 = esi - 0x00000001
	edx_6 = edx ^ eax
	ecx_7 = esi_3
	edi_9 = edi ^ ecx_7
	edi_11 = edi_9 | ebx
	SZO_12 = cond(edi_11)
	C_13 = false
	fn0040103C(dwLoc04)
	SCZO_17 = cond(ah - bh)
	int3()
l0040137C:
	esi = esi - 0x00000001
	edx = edx ^ eax
	ecx = esi
	edi = edi ^ ecx
	edi = edi | ebx
	SZO = cond(edi)
	C = false
	fn0040103C(dwArg00)
	SCZO = cond(ah - bh)
	int3()
fn0040137C_exit:
}

void fn00401390(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 esi, word32 edi)
{
fn00401390_entry:
	goto l00401390
l004010B5:
	ecx = ecx - 0x00000001
	cl = (byte) ecx (alias)
	ch = SLICE(ecx, byte, 8) (alias)
	ebx = ebx ^ edx
	bx = (word16) ebx (alias)
	SZO = cond(ebx)
	C = false
l004010B6_thunk_fn004010B7:
	rArg0 = fn004010B7(esi, edi, bx, cl, ch, dh, rArg0)
	return
l004010C0_thunk_fn00401266:
	fn00401266(edi, bx, cl, ch, dh)
	return
l00401390:
	edi = edi | eax
	ecx = ecx + 0x00000001
	esi = esi ^ edx
	ebx = ebx - eax
	ebx = ebx - ecx
	ebx = ebx - 0x00000001
	bx = (word16) ebx (alias)
	ecx = ecx + edx
	cl = (byte) ecx (alias)
	ch = SLICE(ecx, byte, 8) (alias)
	SCZO = cond(ecx)
	C = SCZO (alias)
	branch Test(ULT,C) l004010B5
l004013A2:
fn00401390_exit:
}

