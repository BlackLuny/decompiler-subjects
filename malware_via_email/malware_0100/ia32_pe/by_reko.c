// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 eax_30 = AddAce(null, 0x00, 0x00, null, 0x00);
	Eq_17 esi_15 = 0x00;
	word32 ebx_295 = eax_30 + 0x23;
	if (AreAllAccessesGranted(~0x00, ~0x00) == 0x00)
		ebx_295 = eax_30 + 0x01;
	CloseHandle((void *) 0x59);
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x08);
	struct Eq_49 * eax_63 = null;
	do
	{
		if (esi_15 == ebx_295)
			esi_15.u0 = 0x00;
		eax_63[4198848] = (struct Eq_49) (eax_63[4198848] ^ *((word32) esi_15 + 0x00404000));
		eax_63 = eax_63 + 0x01;
		esi_15 = (word32) esi_15 + 0x01;
	} while (eax_63 < (struct Eq_49 *) 5152);
	struct Eq_71 * edi_107 = &globals->t4024A0;
	uint32 dwLoc04_100 = 0x00;
	do
	{
		Eq_75 eax_110 = edi_107->t0004;
		cui16 * esi_117 = (char *) &edi_107->t0004 + 0x04;
		if (eax_110 - 0x08 >> 0x01 > 0x00)
		{
			uint32 ebp_263 = eax_110 - 0x08 >> 0x01;
			do
			{
				if ((*esi_117 & 0xF000) == 0x3000)
				{
					struct Eq_179 * eax_285 = ((word32) *esi_117 & 0x0FFF) + edi_107->dw0000;
					eax_285->dw400F40 = eax_285->dw400F40 + 0xF0400F40;
				}
				esi_117 = esi_117 + 0x01;
				ebp_263 = ebp_263 - 0x01;
			} while (ebp_263 != 0x00);
		}
		Eq_75 eax_124 = edi_107->t0004;
		uint32 ecx_126 = (word32) eax_124.u0 + dwLoc04_100;
		word32 edi_127 = edi_107 + eax_124;
		int32 eax_131 = edi_127->dw0004;
		uint32 ecx_133 = ecx_126 + eax_131;
		edi_107 = (struct Eq_71 *) (edi_127 + eax_131 / 0x08);
		dwLoc04_100 = ecx_133;
	} while (ecx_133 < 228);
	struct Eq_121 * edi_144 = &globals->t401C9C;
	struct Eq_121 * dwLoc04_145 = &globals->t401C9C;
	if (Mem87[4201644:word32] != 0x00)
	{
		edi_177 = edi_144;
		do
		{
			struct Eq_121 * edi_177;
			Eq_161 eax_184 = LoadLibraryA(edi_177->dw000C + 0x00400F40);
			if (eax_184 != null)
			{
				word32 edi_211;
				word32 eax_206 = edi_177->dw0000;
				if (eax_206 != 0x00)
					edi_211 = eax_206;
				else
					edi_211 = edi_177->dw0010;
				word32 * edi_214 = edi_211 + 0x00400F40;
				word32 * esi_215 = dwLoc04_145->dw0010 + 0x00400F40;
				if (*edi_214 != 0x00)
				{
					do
					{
						Eq_164 dwLoc1C_244;
						int32 eax_239 = *edi_214;
						word16 ax_240 = (word16) eax_239;
						if (eax_239 < 0x00)
							dwLoc1C_244 = (word32) ax_240;
						else
							dwLoc1C_244 = eax_239 + 0x00400F42;
						*esi_215 = (word32) GetProcAddress(eax_184, dwLoc1C_244);
						edi_214 = edi_214 + 0x01;
						esi_215 = esi_215 + 0x01;
					} while (*edi_214 != 0x00);
				}
				edi_177 = dwLoc04_145;
			}
			edi_177 = edi_177 + 0x01;
			dwLoc04_145 = edi_177;
		} while (edi_177->dw0010 != 0x00);
	}
	ptr32 esp_153;
	byte SCZO_154;
	word32 ebx_155;
	word32 ebp_156;
	word32 esi_157;
	word32 edi_158;
	byte SZO_159;
	byte C_160;
	word32 ecx_161;
	word32 edx_162;
	word32 eax_163;
	byte Z_164;
	byte cl_165;
	word16 dx_166;
	byte S_167;
	word16 ax_168;
	globals->t401990();
	*(esp_153 - 0x04) = 0x00;
	ExitProcess(*(esp_153 - 0x04));
}

