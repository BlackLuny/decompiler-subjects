// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040100A: Register word32 fn0040100A(Register (ptr Eq_3) edi)
word32 fn0040100A(Eq_3 * edi)
{
	word32 ebp_4;
	real64 rArg0_5;
	fn0040100C(edi, rArg0, out ebp_4, out rArg0_5);
	return ebp_4;
}

// 0040100C: Register word32 fn0040100C(Register (ptr Eq_3) edi, FpuStack real64 rArg0, Register out ptr32 ebpOut, FpuStack out Eq_11 rArg0Out)
word32 fn0040100C(Eq_3 * edi, real64 rArg0, ptr32 & ebpOut, Eq_11 & rArg0Out)
{
	word32 eax_25;
	word32 ecx_26;
	word32 ebp_27;
	fn00401032(fp - 0x04, out eax_25, out ecx_26, out ebp_27);
	return eax_25;
}

// 00401028: FlagGroup bool fn00401028(Register (ptr Eq_22) ebp, Stack word32 dwArg00, Register out Eq_36 alOut, Register out ptr32 ecxOut, Register out ptr32 ebpOut)
bool fn00401028(Eq_22 * ebp, word32 dwArg00, Eq_36 & alOut, ptr32 & ecxOut, ptr32 & ebpOut)
{
	*alOut = al;
	*(ebp - 0x08) = *(ebp - 0x08) - *(ebp - 0x0C);
	word32 eax_11;
	word32 ecx_12;
	word32 ebp_13;
	return fn00401032(ebp, out eax_11, out ecx_12, out ebp_13);
}

// 00401032: FlagGroup bool fn00401032(Register (ptr Eq_22) ebp, Register out ptr32 eaxOut, Register out ptr32 ecxOut, Register out ptr32 ebpOut)
bool fn00401032(Eq_22 * ebp, ptr32 & eaxOut, ptr32 & ecxOut, ptr32 & ebpOut)
{
	*eaxOut = eax;
	uint32 ecx_4 = *(ebp - 0x08);
	*ecxOut = ecx_4;
	bool C_104 = cond(ecx_4 - ebp->dw0010);
	if (ecx_4 < ebp->dw0010)
	{
		ui32 edx_57 = ~*(ebp - 0x0C);
		*(ebp - 0x14) = ~(ebp->ptr000C + *(ebp - 0x08));
		ui32 edx_61 = ~(edx_57 | *(ebp - 0x14));
		ui32 ecx_65 = ebp->ptr0014 + *(ebp - 0x04);
		*(ebp - 0x14) = 0xFF;
		ui32 ebx_68 = ecx_65 & *(ebp - 0x14);
		*(ebp - 0x14) = ~0x00;
		ui32 ebx_70 = ebx_68 ^ *(ebp - 0x14);
		word32 * ebx_77 = (ebx_70 + 0x01 & 0x00 ^ ebp->dw0008) + *(ebp - 0x08);
		*(ebp - 0x10) = ebx_77;
		word32 ebx_81 = DPB(*ebx_77, (byte) ((edx_61 & 0xFF) + (ebx_70 + 0x01)), 0);
		word32 * edx_82 = *(ebp - 0x10);
		*(v3 - 0x04) = 0x00;
		*edx_82 = *(v3 - 0x04);
		*edx_82 = *edx_82 + -ebx_81;
		ui32 ecx_93 = *edx_82 ^ *(ebp - 0x14);
		*edx_82 = ecx_93 + 0x01;
		*(ebp - 0x04) = *(ebp - 0x04) + 0x01;
		word32 ecx_94;
		*ecxOut = ecx_93 + 0x01;
		if (*(ebp - 0x04) == 0x01)
			*(ebp - 0x04) = *(ebp - 0x04) & 0x00;
		C_104 = cond(*(ebp - 0x04) - 0x7500);
		if (*(ebp - 0x04) != 0x7500)
		{
			byte al_106;
			word32 ecx_107;
			word32 ebp_108;
			fn00401028(ebp, dwLoc04, out al_106, out ecx_107, out ebp_108);
			*ecx = (int32) rArg0;
			if (C)
			{
				word32 eax_114;
				return fn00401240(al_106, ebp_108, out eax_114);
			}
		}
	}
	word32 * ebp_42 = ebp->ptr0000;
	return C_104;
	word32 ebp_44;
	*ebpOut = *ebp_42;
	return C_104;
}

// 004010D0: Register Eq_15 Win32CrtStartup()
Eq_15 Win32CrtStartup()
{
	if ((0x00 - fn00401217(CreateToolbarEx(0x00, 0x00, 0x00, 0x00, null, 0x00, fp - 0x10, fp - 0x10, 0x00, 0x00, 0x00, 0x00, 0x00)) ^ ~0x057D) != 0x00)
	{
		word32 ebp_228;
		real64 rArg0_229;
		return fn0040100C((struct Eq_3 *) ~0x057D, rArg0, out ebp_228, out rArg0_229);
	}
	else
	{
		struct Eq_3 * edi_104 = -~0x00428FFF;
		real64 rArg0_133;
		ptr32 ebp_132;
		fn0040100C(edi_104, rArg0, out ebp_132, out rArg0_133);
		Mem141[ebp_132 - 0x24 + 0x00:word32] = Mem0[Mem0[ebp_132 - 0x10 + 0x00:word32] + 0x04:word32] + Mem0[Mem0[(ebp_132 - 0x10) + 0x00:word32] + 0x00:word32];
		*(fp - 0x0200) = 0x40;
		*(ebp_132 - 0x18) = *(ebp_132 - 0x18) & 0x00;
		*(fp - 0x0204) = 0x3000;
		*(fp - 0x0208) = *(ebp_132 - 0x24);
		*(fp - 0x020C) = 0x00;
		*(ebp_132 - 0x08) = (LPVOID *) VirtualAlloc(*(fp - 0x020C), *(fp - 0x0208), *(fp - 0x0204), *(fp - 0x0200));
		*(ebp_132 - 0x20) = 0x00400000;
		*(ebp_132 - 0x01AC) = *(ebp_132 - 0x01AC) & 0x00;
		ptr32 esp_156 = fp - 0x01FC;
		while (true)
		{
			Eq_15 eax_171 = *((char *) *(ebp_132 - 0x10) + 0x08);
			if (*(ebp_132 - 0x01AC) >= eax_171)
				break;
			word32 * esp_175 = esp_156 - 0x04;
			*esp_175 = *(ebp_132 - 0x28);
			struct Eq_3 * edi_177 = *(ebp_132 - 0x1C);
			*(esp_175 - 0x04) = edi_177->dw0004;
			*(esp_175 - 0x08) = (char *) **(ebp_132 - 0x1C) + *(ebp_132 - 0x20);
			*(esp_175 - 0x0C) = *(ebp_132 - 0x08) + *(ebp_132 - 0x18);
			ebp_132 = fn0040100A(edi_177);
			*(ebp_132 - 0x18) = (char *) *((char *) *(ebp_132 - 0x1C) + 0x04) + *(ebp_132 - 0x18);
			esp_156 = esp_175 - 0x10;
			*(ebp_132 - 0x01AC) = *(ebp_132 - 0x01AC) + 0x01;
			*(ebp_132 - 0x1C) = *(ebp_132 - 0x1C) + 0x08;
		}
		word32 * esp_206 = esp_156 - 0x04;
		*esp_206 = *(ebp_132 - 0x20);
		*(ebp_132 - 0x14) = *(ebp_132 - 0x08) + 0x1370;
		*(esp_206 - 0x04) = *(ebp_132 - 0x019C);
		*(esp_206 - 0x08) = *(ebp_132 - 0x14);
		*(esp_206 - 0x0C) = 0x0AC0;
		*(esp_206 - 0x10) = *(ebp_132 - 0x14);
		return eax_171;
	}
}

// 00401217: Register Eq_15 fn00401217(Register Eq_15 eax)
Eq_15 fn00401217(Eq_15 eax)
{
	if (eax == 0x00)
		eax = GetLastError();
	return eax;
}

// 00401240: FlagGroup bool fn00401240(Register byte al, Register word32 ebp, Register out ptr32 eaxOut)
bool fn00401240(byte al, word32 ebp, ptr32 & eaxOut)
{
	word32 eax_8;
	*eaxOut = DPB(eax, al + 0x52, 0);
	bool SCZO_9 = cond(al + 0x52);
	return SCZO_9;
}

