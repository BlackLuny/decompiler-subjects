// Generated by Rec Studio 4 - build Apr 15 2012

L0040100A(
    _unknown_ __eax,                       // r0
    _unknown_ __edx,                       // r3
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    signed int _v8;                        // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int* _v20;                      // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _t66;                        // _t66
    _unknown_ _t76;                        // _t76
    _unknown_ _t77;                        // _t77
    _unknown_ _t80;                        // _t80
    signed int _t86;                       // _t86
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    _unknown_ _t95;                        // _t95
    signed int* _t96;                      // _t96
    _unknown_ _t98;                        // _t98
    _unknown_ _t100;                       // _t100
    _unknown_ _t101;                       // _t101
    _unknown_ _t102;                       // _t102
    signed int _t104;                      // _t104
    _unknown_ _t107;                       // _t107
    _unknown_ _t108;                       // _t108

    _t102 = __esi;
    _t100 = __edi;
    _t88 = __edx;
    __eax = __eax;
    _push(_t107);
    _t108 = __esp;
    _push(_t100);
    _push(_t88);
    _v8 = _v8 & 0;
    _v12 = 0;
    _push(_t88);
    _push(_t102);
    _push(_t102);
    _v16 = -1;
    if(_v12 >= _a12) {
L6:
        __esp = _t108;
        _pop(__ebp);
        return;
    } else {
        asm("clc ");
        asm("sbb ecx, [ebx]");
        _v24 =  !( ~0x00000000);
        _v24 = 255;
        _v24 = -1;
        asm("clc ");
        asm("adc edx, ebx");
        _v20 = (( *(_a16 + _v8) & _v24 ^ _v24) + 1 & 0 ^ _a4) + _v12;
        _t96 = _v20;
        _push(0);
        _pop( *__edx);
        asm("clc ");
        asm("adc [edx], ebx");
        _t86 = ( *_t96 ^ _v24) + 1;
         *_t96 = _t86;
        _t104 = _v8 + 1;
        _v8 = _t104;
        if(_v8 == 1) {
            _v8 = _v8 & 0;
        }
        if(_v8 != 29952) {
            L00401028(__eax);
            asm("fist dword [ecx]");
            while(1) {
                asm("adc [edx-0x23], esi");
            }
        }
        goto L6;
    }
}

L0040100C(
    _unknown_ __eax,                       // r0
    _unknown_ __edx,                       // r3
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    signed int _v8;                        // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int* _v20;                      // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _t66;                        // _t66
    _unknown_ _t76;                        // _t76
    _unknown_ _t77;                        // _t77
    _unknown_ _t80;                        // _t80
    signed int _t86;                       // _t86
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    _unknown_ _t95;                        // _t95
    signed int* _t96;                      // _t96
    _unknown_ _t98;                        // _t98
    _unknown_ _t101;                       // _t101
    _unknown_ _t102;                       // _t102
    signed int _t104;                      // _t104
    _unknown_ _t107;                       // _t107
    _unknown_ _t108;                       // _t108

    _t102 = __esi;
    _t88 = __edx;
    __eax = __eax;
    _push(_t107);
    _t108 = __esp;
    _push(__edi);
    _push(_t88);
    _v8 = _v8 & 0;
    _v12 = 0;
    _push(_t88);
    _push(_t102);
    _push(_t102);
    _v16 = -1;
    if(_v12 >= _a12) {
L5:
        __esp = _t108;
        _pop(__ebp);
        return;
    } else {
        asm("clc ");
        asm("sbb ecx, [ebx]");
        _v24 =  !( ~0x00000000);
        _v24 = 255;
        _v24 = -1;
        asm("clc ");
        asm("adc edx, ebx");
        _v20 = (( *(_a16 + _v8) & _v24 ^ _v24) + 1 & 0 ^ _a4) + _v12;
        _t96 = _v20;
        _push(0);
        _pop( *__edx);
        asm("clc ");
        asm("adc [edx], ebx");
        _t86 = ( *_t96 ^ _v24) + 1;
         *_t96 = _t86;
        _t104 = _v8 + 1;
        _v8 = _t104;
        if(_v8 == 1) {
            _v8 = _v8 & 0;
        }
        if(_v8 != 29952) {
            L00401028(__eax);
            asm("fist dword [ecx]");
            while(1) {
                asm("adc [edx-0x23], esi");
            }
        }
        goto L5;
    }
}

L00401028(
    _unknown_ __eax                        // r0
)
{
    _unknown_ _t65;                        // _t65
    _unknown_ _t75;                        // _t75
    _unknown_ _t76;                        // _t76
    _unknown_ _t79;                        // _t79
    signed int _t85;                       // _t85
    _unknown_ _t86;                        // _t86
    _unknown_ _t93;                        // _t93
    signed int* _t94;                      // _t94
    _unknown_ _t96;                        // _t96
    _unknown_ _t100;                       // _t100
    _unknown_ _t101;                       // _t101
    signed int _t103;                      // _t103

    __eax = __eax;
    _pop(__esi);
     *((intOrPtr*)(__ebp - 8)) =  *((intOrPtr*)(__ebp - 8)) -  *((intOrPtr*)(__ebp - 12));
    if( *((intOrPtr*)(__ebp - 8)) >=  *((intOrPtr*)(__ebp + 16))) {
L5:
        _pop(__ebp);
        return;
    } else {
        asm("clc ");
        asm("sbb ecx, [ebx]");
         *(__ebp - 20) =  !( ~0x00000000);
         *(__ebp - 20) = 255;
         *(__ebp - 20) = -1;
        asm("clc ");
        asm("adc edx, ebx");
         *(__ebp - 16) = (( *( *((intOrPtr*)(__ebp + 20)) +  *(__ebp - 4)) &  *(__ebp - 20) ^  *(__ebp - 20)) + 1 & 0 ^  *(__ebp + 8)) +  *((intOrPtr*)(__ebp - 8));
        _t94 =  *(__ebp - 16);
        _push(0);
        _pop( *__edx);
        asm("clc ");
        asm("adc [edx], ebx");
        _t85 = ( *_t94 ^  *(__ebp - 20)) + 1;
         *_t94 = _t85;
        _t103 =  *(__ebp - 4) + 1;
         *(__ebp - 4) = _t103;
        if( *(__ebp - 4) == 1) {
             *(__ebp - 4) =  *(__ebp - 4) & 0;
        }
        if( *(__ebp - 4) != 29952) {
            L00401028(__eax);
            asm("fist dword [ecx]");
            while(1) {
                asm("adc [edx-0x23], esi");
            }
        }
        goto L5;
    }
}

L00401217(
    _unknown_ __eax                        // r0
)
{
    _unknown_ _t2;                         // _t2

    if(__eax == 0) {
        GetLastError();
        return;
    }
    return;
}

L00401217(
    _unknown_ __eax                        // r0
)
{
    _unknown_ _t2;                         // _t2

    if(__eax == 0) {
        @rec 0x00000000@GetLastError@();
        return;
    }
    return;
}

// Statistics:
//      50 Register nodes
//      41 Temporaries nodes
//       7 Casts
//      80 Statements
//       6 Labels
//       3 Gotos
//       4 Blocks
//     436 Nodes
//      24 Assembly nodes
//      47 Unknown Types


Total time: 0 seconds.
