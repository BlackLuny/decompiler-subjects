/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1554/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 00401472 -> 00401004 */
/* DEST BLOCK NOT FOUND: 00401490 -> 00401171 */
/* DEST BLOCK NOT FOUND: 004014bc -> 004010d7 */
/* DEST BLOCK NOT FOUND: 004014df -> 004013f7 */
/* DEST BLOCK NOT FOUND: 004014e5 -> 004013f7 */
/* DEST BLOCK NOT FOUND: 004014f0 -> 004013ab */
/* DEST BLOCK NOT FOUND: 00401515 -> 00401078 */
/* DEST BLOCK NOT FOUND: 00401543 -> 0040123d */
/* DEST BLOCK NOT FOUND: 00401549 -> 0040123d */
/* DEST BLOCK NOT FOUND: 0040154f -> 0040123d */
stack space not deallocated on return
/*	Procedure: 0x00401454 - 0x004015E3
 *	Argument size: 13636
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)ebp;
    ebp = esp;
    asm("adc ecx,0xd29b268f");
    esi = esi | edx;
    edx = edx | 1723390067;
    ecx = ecx - esi;
    esi = esi + 1;
    edx = ecx - 1;
    ecx = ecx - 1 | 661535391;
    goto L00401004;
    dl = dl + *eax;
    *(eax + 1) = *(eax + 1) + eax + 1;
    *edx = *edx + dh;
    asm("Unknown opcode 0xdc");
    bl = bl << cl;
    cl = cl + 113;
    al = ch;
    ch = ch + bh;
    asm("sbb ecx,0xc568e6b9");
    esi = esi ^ ecx;
    goto L00401171;
    *eax = *eax | 128;
    eax = eax + 1;
    asm("adc esi,0xa7db868c");
    asm("rol bl,0x1a");
    cl = (ecx | eax) << (ecx | eax);
    edi = 165706165;
    asm("sbb ebx,0xfffcb4ce");
    edi = edi + ebx;
    asm("int 0x2e");
    ch = ah - 56;
    bh = ~bh;
    goto L004010d7;
    *edx = *edx | al;
    asm("adc [eax],cl");
    dh = dh ^ 215;
    dh = dh + bl;
    bh = ~bh;
    eax = eax + 596384468;
    asm("sbb dl,0xd1");
    cl = cl + bl;
    asm("rol ch,cl");
    bl = 128;
    asm("rcr bl,cl");
    if(bh = bh + ch) {
        goto L004013f7;
    }
    >= ? 0x4013f7 : ;
    if(*edx = *edx + eax) {
        goto L004013ab;
    }
    ecx = ecx + 196315247;
    edx = edx + -1602580537;
    asm("adc edx,0x72c76d0f");
    asm("sbb ah,0x6e");
    bl = bh + 1 - 142;
    ecx = edi;
    bh = bh - 225;
    goto L00401078;
    *(eax + 1808695312) = *(eax + 1808695312) + 129;
    L02c00c1e();
    asm("sbb edi,0x50e6a77c");
    asm("rcr cl,cl");
    asm("adc esi,0xf8a310e0");
    dl = dl + 72 - 23;
    ah = ~ah;
    esi = esi - ebx;
    asm("adc ah,0x7b");
    if(bl = bl - 1) {
        goto L0040123d;
    }
    >= ? 0x40123d : ;
    goto ( *eax);
    eax = L00402513();
    asm("Unknown opcode 0x8e");
    if(!(al = al + *edx + 128)) {
        *(esi + 65) = *(esi + 65) + -19;
L00401561:
        (save)ds;
        asm("outsb");
        asm("int 0x6e");
        asm("outsb");
        asm("xchg edx,edi");
        asm("xchg cl,[esi]");
        asm("outsb");
        asm("xchg edx,edi");
        (restore)esi;
        ds = cs;
        if(ecx = ecx + 1) {
            goto L004015c5;
        }
        asm("outsb");
        asm("outsb");
        (save)esi;
        asm("outsb");
        gs = *(esi - 62);
        asm("outsb");
        asm("in eax,dx");
        bl = 238;
        asm("sbb eax,0x6e6e54ae");
        *(ebx - 104) = ss;
        asm("Unknown opcode 0x82");
        asm("outsb");
        asm("outsb");
        ah = 82;
        asm("out dx,eax");
        asm("into");
        ds = *L6E6E548E;
        < ? L00401583 : ;
        edi = edi ^ *(esp + ecx * 4);
        (save)edi;
        *(eax + 110) = *(eax + 110) + ebx;
        asm("outsb");
        return;
        asm("sbb eax,0x6e6e5482");
        (restore)ds;
        ah :: *(eax + 110);
        asm("outsb");
        (save)edx;
        gs = *(esi + 29);
        asm("%f push edx");
        asm("outsb");
        asm("outsb");
        asm("out 0x6e,eax");
    }
    asm("a16 outsb");
    asm("outsb");
    esi = esi ^ *(edx + 109);
    (restore)ax;
    *(ebx - 85) = ss;
    (restore)eax;
    asm("outsb");
    asm("outsb");
    (save)ebx;
    -17 = *%ds:ebx+ebx*2+0x6e6e587b] * ecx;
L004015c5:
    (restore)ds;
    asm("outsb");
    asm("insd");
    asm("insd");
    if(ebx = eax + 110) {
        goto L00401561;
    }
    (save)edi;
    esp = cs;
    asm("outsb");
    asm("outsb");
    asm("adc edi,+0x5e");
    *eax = *eax | -122;
    edi = edi ^ -114;
    asm("iret");
}

/*	Procedure: 0x004015E4 - 0x004015E5
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004015E4()
{



    (restore)esi;
    asm("iret");
}

/*	Procedure: 0x004015E6 - 0x00401612
 *	Argument size: -19307
 *	Local size: 0
 *	Save regs size: 0
 */

L004015E6()
{



    gs = *(edi + ebx);
    asm("a16 pusha");
    asm("outsb");
    asm("outsb");
    asm("outsb");
    ss = *(esi - 125);
    asm("rol dword [esi+0x6c2dd754],cl");
    edx = edx ^ *(esi + 241054572);
    asm("sbb eax,0x6e6e5a07");
    eax = *(ebx - 44)();
    asm("sahf");
    (fsave) *(eax + 1851849759);
    asm("outsb");
    asm("in eax,dx");
    asm("scasb");
}

stack space not deallocated on return
/*	Procedure: 0x00401613 - 0x004016DF
 *	Argument size: -1706
 *	Local size: 0
 *	Save regs size: 0
 */

L00401613()
{



    (save)edx;
    asm("sbb eax,0x6e6e5281");
    edi = edi ^ *edx;
    bl = 224;
    asm("sbb eax,0x6e6e526f");
    *(ebx + 61) = ss;
    asm("insb");
    asm("insb");
    asm("insb");
    (restore)ds;
    al = al | 108;
    asm("insb");
    asm("insb");
    (restore)esi;
    asm("scasb");
    ds = *(esi + 108);
    ss = *(edx - 116);
    esp = -612115066;
    asm("cmpsb");
    (save)esp;
    asm("rol byte [ebx+0xd2545d56],cl");
    (restore)ds;
    ebx = *(esi + ebp * 2 + 110);
    esp = esp + 1;
    eax = *L000000C8(edx);
    (save)esi;
    asm("out dx,eax");
    asm("jecxz 0x40165a");
    asm("o16 pop ds");
    eax :: 1382968924;
    (save)esi;
    asm("in eax,dx");
    (save)edx;
    return;
    asm("sti");
    *eax = *eax - 94;
    (save)esp;
    al = al & 229;
    asm("xchg esp,[ebx+0x6e6e6e6d]");
    *(esp + eax * 4 + -1806332893) = *(esp + eax * 4 + -1806332893) & 86;
    asm("outsb");
    asm("outsb");
    (save)esp;
    *(esi + 31) = *(esi + 31) - bl;
    (save)esi;
    asm("outsb");
    asm("outsb");
    (restore)ds;
    edx = ss;
    asm("outsb");
    asm("outsb");
    gs = *(esi + 1818128621);
L00401688:
    (restore)esi;
    *(esi + eax * 4) = *(esi + eax * 4) & 84;
    dh = dh - bh;
    asm("insb");
    asm("aaa");
    esi = esi + 1;
    asm("insb");
    asm("aaa");
    asm("adc eax,0x6eaa1df3");
    asm("outsb");
    asm("outsb");
    al :: 215;
    (restore)si;
    asm("outsb");
    asm("outsb");
    asm("outsb");
    *(ebp - 8) = ss;
    (restore)edx;
    asm("outsb");
    asm("outsb");
    asm("insb");
    asm("aaa");
    esi = esi - 1;
    asm("insb");
    asm("aaa");
    asm("%s pop ds");
    goto L00006d6c;
    asm("ror byte [esi+0x4683f76e],cl");
    asm("rep or dword [eax],-0x7a");
    (restore)ds;
    asm("popf");
    asm("outsb");
    asm("outsb");
    asm("outsb");
    asm("adc edi,-0x72");
    bh = 248;
    asm("insb");
    if(*eax = *eax - 94) {
        goto L00401688;
    }
    esp = esp + 1;
    108 = *(esi - 19) * ebx;
    (restore)esi;
    asm("scasb");
    asm("in eax,dx");
    asm("Unknown opcode 0x8e");
    asm("stc");
    asm("sti");
    asm("adc edi,-0x7a");
}

stack space not deallocated on return
/*	Procedure: 0x004016E0 - 0x004017D9
 *	Argument size: 24173
 *	Local size: 0
 *	Save regs size: 0
 */

L004016E0()
{



    asm("xlatb");
    <= ? L00401742 : ;
    asm("xlatb");
    asm("xchg bl,[edi-0x29]");
    asm("%d insd");
    gs = *(bp - 116);
    (save)ebp;
    *(eax + 110) = *(eax + 110) ^ ebx;
    asm("outsb");
    asm("Unknown opcode 0x8c");
    edx = -681603369;
    *edi = *edi ^ 94;
    asm("insb");
    if(!( *LD75F8F1B = *LD75F8F1B - 90)) {
        return;
        asm("Unknown opcode 0x8c");
        edx = 69177384;
        (restore)eax;
        asm("outsb");
        asm("outsb");
        (save)ebx;
        asm("xchg al,[bp+si+0x518c]");
        esi = -2089914798;
        asm("aam 0xb3");
        asm("repne rol byte [edx+0x3c6e6e6e],0x50");
        (save)esp;
        asm("Unknown opcode 0xfe");
        (save)esp;
        *(ecx - 125) = *(ecx - 125) + dl;
        *edi = *edi + ebx;
        edx = edx + 110;
        asm("outsb");
        (save)edx;
        asm("insb");
        (save)edx;
        asm("scasb");
        asm("in eax,dx");
        al = al & 224;
        asm("rol byte [esi+0x4683f76e],cl");
        asm("stc");
        asm("sti");
        *edi = *edi ^ 94;
        asm("xchg bl,[edi]");
        asm("clc");
        (restore)eax;
        asm("outsb");
        asm("outsb");
        asm("insb");
        asm("insb");
        asm("outsb");
        (restore)esi;
        asm("insd");
        asm("lock ficom word [eax+0x792f31c7]");
    }
    if(!( *(edx - 125) = *(edx - 125) - 8)) {
        asm("xlatb");
        asm("Unknown opcode 0x8e");
        bl = 242;
        al :: 55;
        asm("xchg al,[ecx+0x816c80d5]");
        asm("xchg eax,esi");
        *L6C80165D = al;
        (restore)ebp;
        (save)esi;
        *L8CE084DF = al;
        (save)edi;
        (save)cs;
        asm("insb");
        asm("insb");
        asm("insb");
        esp = esp + 1;
        asm("in al,0xae");
        asm("scasb");
        asm("in eax,dx");
        (save)esi;
        asm("insb");
        (save)esi;
        (save)esi;
        asm("sti");
        *eax = *eax - 94;
        esp = esp ^ -61;
        *(esi + -2015026092) & 1852747171;
        asm("outsb");
        *(ebx + eax * 4 + 595877384) = *(ebx + eax * 4 + 595877384) & -116;
        (save)ebp;
        asm("fcomp dword [eax+0x6e]");
        asm("outsb");
        (restore)ds;
        asm("int 0x54");
        asm("outsb");
        asm("outsb");
        (restore)esi;
        asm("insb");
        asm("insb");
        return;
        (save)edx;
        asm("sbb dl,[ebx-0x41]");
        asm("outsb");
        *(edi + 107) = ss;
        (restore)edx;
        asm("outsb");
        asm("outsb");
        bh = 81;
        asm("bound ecx,[esi]");
    }
    al = al + 227;
    asm("xlatb");
    (restore)esi;
    asm("aaa");
    *(ebx + 35618513) = al;
    (restore)eax;
    asm("outsb");
    asm("outsb");
    (restore)ds;
    asm("out 0x58,eax");
    asm("outsb");
    asm("outsb");
    *(edx + 31) = *(edx + 31) ^ -75;
    (restore)eax;
    asm("outsb");
    asm("outsb");
    asm("insb");
    asm("insb");
}

stack space not deallocated on return
/*	Procedure: 0x004017DA - 0x00401922
 *	Argument size: 24176
 *	Local size: 0
 *	Save regs size: 0
 */

L004017DA()
{



    *L83FEF783 = *L83FEF783 | ah;
    asm("xlatb");
    eax = eax + 1396081632;
    (fsave)(frestore) * *(esi + 1861053982);
    asm("outsb");
    (restore)edi;
    (save)es;
    asm("xchg eax,esi");
    asm("out dx,al");
    asm("xchg eax,[esi]");
    asm("xchg eax,esi");
    asm("out dx,al");
    asm("adc [edi-0xb],bl");
    asm("xchg eax,esi");
    asm("out dx,al");
    asm("xchg esi,ebp");
    asm("xchg eax,esi");
    asm("out dx,al");
    asm("int1");
    (restore)ds;
    *(esi + 110) = ds;
    asm("outsb");
    (save)edx;
    asm("outsb");
    (save)esi;
    asm("insd");
    ecx = ecx + 1;
    asm("insb");
    ebp = ds;
    eax = al - 46 - 1851318301;
    asm("outsb");
    (save)ds;
    asm("sbb dh,bl");
    (save)edx;
    asm("ror dword [esi],1");
    asm("sbb eax,0x6e6e6e43");
    asm("insb");
    eax = eax | -530655357;
    asm("rcr byte [esi+0x6e],cl");
    (restore)ds;
    al = *esi;
    if(!(esi = esi + 1)) {
        asm("outsb");
        (save)esi;
        return;
        asm("insb");
        asm("scasb");
        bl = 238;
        *eax = *eax | -122;
        *(edi + 94) = *(edi + 94) & 52;
        return;
        asm("rcr byte [esi+0x6e],cl");
        *(ebx + 536474438) & 1852725973;
L0040184b:
        asm("insd");
        asm("in eax,dx");
        (save)esi;
        asm("insb");
        (restore)esi;
        asm("insb");
        (save)esi;
        esp = esp + 1;
        al = 65;
        asm("outsb");
        asm("xchg edx,edi");
        asm("%s push cs");
        asm("insb");
        asm("aaa");
        asm("xchg cl,[esi]");
        ebp = ds;
        eax = al - 46 - 1851274525;
        asm("outsb");
        (save)ds;
        dl = dl - dh;
        al :: 74;
        (save)cs;
        asm("sbb eax,0x6e6e6e7a");
        asm("insb");
        eax = eax | 526268268;
        asm("xchg eax,esi");
        (restore)eax;
        asm("outsb");
        asm("outsb");
        (save)esi;
        asm("insd");
        ss = *(esi + 108);
        asm("insd");
        ah = ah - *eax;
        asm("rcr byte [esi+0x6e],cl");
        *(ebx + 1725322054) & 536607219;
        al = 84;
        asm("outsb");
        asm("outsb");
        asm("insb");
        asm("insb");
    }
    return;
    ds = esi;
    edi = edi - 1;
    (save)-229479316;
    asm("aaa");
    (restore)eax;
    asm("loopne 0x40189f");
    asm("sbb eax,0x6c6c6c4a");
    (restore)ds;
    asm("adc eax,0x526e6e52");
    if(*(edx - 39) >= -1277889934) {
        goto L0040184b;
    }
    >= ? 0x4018bc : ;
    esp = esp + 1;
    (save)edx;
    esp = esp + 1;
    bh = 221;
    asm("lock sbb eax,0x8c2df08c");
    asm("Unknown opcode 0x8c");
    esp = 136277854;
    ch = ch & *(esi + 110);
    esp = esp + 1;
    asm("xchg eax,esp");
    (save)edx;
    asm("in eax,dx");
    (save)edx;
    asm("insd");
    asm("insd");
    *L23965623 = *L23965623 + cl;
    (save)esi;
    asm("xchg eax,esi");
    eax = eax - esi;
    edx = edx & *(esi - 106);
    *(esp + esi * 8 + 41) = es;
    asm("lock pop ds");
    asm("aad 0x52");
    asm("outsb");
    asm("outsb");
    asm("insd");
    asm("in eax,dx");
    asm("insb");
    asm("in eax,dx");
    (save)edx;
    (save)edx;
    asm("insb");
    al & ah;
    asm("aaa");
    asm("fcomp qword [edi-0x29]");
    eax = eax - 1412290435;
    asm("in eax,dx");
    asm("in eax,0x83");
    asm("Unknown opcode 0xdd");
    edi = cs;
    *L4125376C = *L4125376C | ah;
    asm("outsb");
    asm("sbb eax,0x6e6e5654");
    (restore)edi;
    asm("xlatb");
    *(ecx - 19) = *(ecx - 19) + 1;
    (restore)ds;
    asm("cld");
    (save)esi;
    asm("outsb");
    asm("outsb");
    asm("in eax,dx");
}

stack space not deallocated on return
/*	Procedure: 0x00401923 - 0x00401BF9
 *	Argument size: 28754
 *	Local size: 0
 *	Save regs size: 0
 */

L00401923()
{



    (save)edx;
    asm("lahf");
    asm("outsb");
    asm("outsb");
    asm("outsb");
    asm("insd");
    eax = eax ^ 1852749684;
    asm("outsb");
    asm("insd");
    (save)cs;
    asm("insb");
    asm("aaa");
    asm("sbb ax,0x6e2e");
    asm("outsb");
    asm("outsb");
    (restore)ds;
    < ? L00401996 : ;
    asm("outsb");
    asm("outsb");
    (save)esp;
    asm("xlatb");
    (restore)esi;
    (restore)ds;
    edx = esp;
    asm("outsb");
    asm("outsb");
    asm("in eax,dx");
    (save)edx;
    asm("insb");
    (save)edx;
    asm("in eax,dx");
    asm("in eax,dx");
    *(ebx + 1835933254) & -678990226;
    asm("xchg cl,[esi]");
    asm("xchg edx,edi");
    (restore)esi;
    (save)cs;
    ecx = ecx + 1;
    asm("insb");
    ebp = ds;
    asm("outsb");
    asm("in eax,dx");
    gs = *(esi + 86);
    return;
    (restore)ds;
    if(!(eax = al - 46 - 1851002911)) {
        asm("insb");
        asm("insb");
        asm("adc [ebx+0xd75476d3],al");
        *(ebx + 139757060) & 45;
        asm("insb");
        ecx = ecx ^ *(esi + -1860366322);
        (restore)edx;
        asm("outsb");
        asm("outsb");
        (restore)ds;
        asm("%c o16 insb");
        asm("insb");
        asm("insd");
        asm("scasb");
        return;
        ss = edx;
        (save)esi;
        asm("outsb");
L0040199b:
        asm("outsd");
        asm("xchg ch,[si+0x6c]");
        asm("outsb");
        asm("outsb");
        *(ebx - 105) = ds;
        (save)108;
        asm("insb");
        asm("insb");
        asm("aaa");
        asm("xchg al,[ecx+0x6e]");
        (restore)ds;
        if(*(ebx + 920015686) & 241620871) {
            goto L00401a22;
        }
        asm("insb");
        asm("insb");
        return;
        asm("outsb");
        asm("insd");
        asm("insd");
        >= ? 0x4019f6 : ;
        asm("xchg eax,ebp");
        (save)esp;
        asm("aaa");
        (save)bx;
        edx = edx + 1;
        asm("Unknown opcode 0x82");
        al :: 33;
        *ecx = *ecx + 52;
        asm("xchg eax,ebp");
        esp = esp + 1;
        asm("Unknown opcode 0x82");
        *eax = *eax | -122;
        al = al ^ 149;
        (restore)ds;
        (restore)edi;
    }
    (save)edx;
    asm("outsb");
    asm("outsb");
    asm("adc edi,+0x66");
    al = *L491F3ED7;
    (save)edx;
    asm("outsb");
    asm("outsb");
    (save)edx;
    asm("insb");
    ds = *(esi - 82);
    (restore)esi;
    ebp = ebp - -98;
    (save)esp;
    asm("lock pop edi");
    asm("xlatb");
    eax = eax | 1092433772;
    asm("outsb");
    asm("sbb eax,0x6e6e54a2");
    (restore)edi;
    asm("xlatb");
L00401a06:
    asm("outsd");
    asm("aam 0xae");
    if(!( *(ebx + 609496360) & 229)) {
        asm("outsb");
        (restore)ds;
        (restore)esi;
        (restore)esi;
        asm("outsb");
        if(eax >= 1852599398) {
            goto L0040199b;
        }
        asm("fsubr qword [edx+ebp]");
        asm("loopne 0x4019ef");
        asm("xchg ch,[esi-0x9]");
        *(esi - 5) = *(esi - 5) + 31;
L00401a22:
        *(edx + 108) & ch;
        asm("insb");
        return;
        (save)ds;
        eax = eax + -1962605307;
        asm("xlatb");
        esi = esi - 1;
        (save)ds;
        asm("outsb");
        eax = eax + -678728082;
        asm("sbb eax,0x6e056e1e");
        asm("outsb");
        edx = edi;
        asm("adc eax,0x61b32c1e");
        asm("ror byte [ebx+0x491d46d7],cl");
        (save)108;
        asm("insb");
        (restore)ds;
        asm("insb");
        (save)edx;
        if(*(edx + 108) = *(edx + 108) & ch) {
            goto L00401a06;
        }
        asm("outsb");
        asm("Unknown opcode 0x8e");
        >= ? 0x401aca : ;
        asm("xchg edx,edi");
        asm("xchg cl,[esi]");
        asm("xchg edx,edi");
        (restore)esi;
        (save)cs;
        ecx = ecx + 1;
        asm("insb");
        ebp = ds;
        eax = al - 46 - 1851016989;
        asm("outsb");
        (save)ds;
        asm("out 0x86,al");
        (fsave)(frestore) / *ebx;
        (save)cs;
        asm("sbb eax,0x6c6c6a8c");
    }
    asm("insb");
    (restore)ds;
    asm("Unknown opcode 0xc6");
    if(!(eax = eax | -530131069)) {
        asm("outsb");
        asm("outsb");
        (save)esi;
        asm("scasb");
        asm("insb");
        asm("in eax,dx");
        ss = *(ebx - 44);
        <= ? L00401ae3 : ;
        asm("arpl [esi+0xa578c6e],ax");
        (save)edx;
L00401a97:
        asm("outsb");
        asm("outsb");
        al = al - 42 & 224;
        asm("rcl byte [esi+0x6e],cl");
        asm("outsb");
        esi = edx;
        (restore)esi;
        asm("outsb");
        asm("out dx,eax");
        asm("insd");
        edi = 509054062;
        if(*(ebx + 536474438) & 1819043582) {
            goto L00401b26;
        }
        asm("outsb");
        bh = 81;
        asm("bound ecx,[esi]");
        asm("aam 0x8c");
        (save)edi;
        (save)ebx;
        asm("%f insb");
        asm("insb");
        asm("sbb ebx,-0x6a");
        (save)esp;
        bh = bh >> cl;
        (restore)ds;
        asm("adc al,0x64");
        asm("insb");
        asm("insb");
        asm("insb");
        asm("Unknown opcode 0x8e");
        if(al = al + 227) {
            goto L00401a97;
        }
        asm("in eax,dx");
        asm("jecxz 0x401ae0");
        asm("xchg cl,[ebp+edx*2+0x6e6e525b]");
        (save)esp;
        *(esi + 31) = *(esi + 31) - bl;
        asm("aaa");
        (save)edx;
        asm("outsb");
        asm("outsb");
L00401ae7:
        *(esi + edx * 2) = *(esi + edx * 2) + 83;
        (restore)ds;
        (restore)esi;
        *(ebx + edx * 2) = *(ebx + edx * 2) ^ -38;
        (restore)esi;
        (restore)ds;
    }
    dl = dl & *(edx + 110);
    asm("outsb");
    asm("Unknown opcode 0x8c");
    esp = 1052544090;
    asm("sbb ch,[edi+0x1b]");
    asm("insb");
    *edx = ds;
    asm("lock sbb eax,0x52b51f86");
    asm("outsb");
    asm("outsb");
    gs = *(esi - 19);
    (save)cs;
    asm("sbb eax,0x6c6c6839");
    asm("insb");
    eax = eax | 1851183840;
    *(ebx + 1322668870) & -2023868564;
    asm("xlatb");
    asm("%d push cs");
L00401b26:
    ebp = ds;
    eax = al - 46 - 1852838943;
    asm("outsb");
    (save)edx;
    asm("insd");
    (save)edx;
    fs = *ebx;
    (save)esi;
    asm("xchg eax,esi");
    *(eax - esi + esi * 8 - 121) = es;
    asm("fbstp tword [eax+0x6f]");
    eax = eax + 1;
    *L578C6E21 = dh;
    (save)esp;
L00401b4a:
    asm("outsb");
    asm("outsb");
    asm("std");
    esi = esi & *(esi - 106);
    asm("std");
    esi = 1852730964;
    (restore)ds;
    asm("outsb");
    (save)esi;
    gs = *(esi - 62);
    es = edx;
    asm("out dx,eax");
    if(dl > *L6E6E6EC2) {
        goto L00401ae7;
    }
    (fsave)(frestore) / *(eax + esi * 2 + -1019444231);
    esi = esi - 1;
    al = al ^ 149;
    *(eax + 108) = *(eax + 108) >> 108;
    if(!(bl = bl - *edi)) {
        (save)edx;
        asm("outsb");
        asm("sbb eax,0x6c6c680b");
        *eax = *eax - -10;
        (save)esp;
        asm("xchg esp,[esi+edi*2]");
        asm("insb");
        edi = edi ^ *(ebp + 1814419339) ^ *(ebp + 1822831468) ^ *(ebp + 1851050271);
        asm("outsb");
        if(al = al & 229) {
            goto L00401b4a;
        }
        asm("outsb");
        asm("outsb");
        == ? L00401b80 : ;
        asm("sbb eax,0x6c6c666a");
        *(ecx + 88) = ss;
        (save)-1009488788;
        asm("%g xchg eax,esi");
        asm("sahf");
        (restore)edi;
        asm("%g xchg eax,esi");
        asm("cmpsb");
        al = al ^ ah;
        asm("rcr byte [esi+0x6e],cl");
        asm("adc edi,+0x5e");
        (save)esp;
        asm("in eax,dx");
        asm("in eax,0x83");
        *(esi - 125) = ~( *(esi - 125));
        asm("in eax,dx");
        eax :: 1048826452;
    }
    *(ebp - 82) = *(ebp - 82) | 84;
    *(al ^ *(ebx + 140476125)) = *(al ^ *(ebx + 140476125)) - -122;
    bl = 224;
    (restore)ds;
    *(edx + 108) = *(edx + 108) ^ esp;
    asm("insb");
    esp = esp + 1;
    bh = 108;
    asm("Unknown opcode 0x8e");
    asm("Unknown opcode 0x8e");
    gs = ebp;
    ah = ah - *eax;
    asm("rol byte [esi+0x4683f76e],cl");
    (save)ebx;
    asm("salc");
    asm("rep o16 pop ds");
    asm("sbb al,0x62");
    asm("insb");
    asm("insb");
}

stack space not deallocated on return
/*	Procedure: 0x00401BFA - 0x00401C2F
 *	Argument size: -15763
 *	Local size: 0
 *	Save regs size: 0
 */

L00401BFA()
{



    asm("in eax,dx");
    asm("outsb");
    asm("insb");
    asm("aaa");
    asm("Unknown opcode 0x8e");
    ebx = ecx;
    asm("cmpsb");
    esp = esp + 1;
    asm("Unknown opcode 0x82");
    *(ecx + 1468805859) :: -89;
    (save)edx;
    asm("outsb");
    asm("outsb");
    al = al - 68;
    *(eax - 114) = *(eax - 114) / *(eax - 114);
    edx = *(eax - 114) % *(eax - 114);
    asm("scasb");
    (restore)esi;
    asm("adc [ebx+0xb301548a],al");
    asm("out dx,al");
    (restore)ds;
    ebp = *(edx + 108);
    asm("insb");
    asm("lock out dx,al");
    (restore)esp;
    cl = 112;
    (restore)ds;
    (save)ebp;
    (save)108;
    asm("insb");
    (save)esi;
    (save)esi;
}

stack space not deallocated on return
/*	Procedure: 0x00401C30 - 0x00401DD0
 *	Argument size: 21356
 *	Local size: 0
 *	Save regs size: 0
 */

L00401C30()
{



    (restore)esi;
    ss = edx;
    asm("xchg ch,[esi-0x9]");
    *(esi + 108) = *(esi + 108) + 55;
    (restore)esi;
    ecx = ecx + 1;
    asm("insb");
    ebp = ds;
    al = al - 46;
L00401c41:
    eax = eax - 1852864797;
    asm("outsb");
    (save)ds;
    asm("adc eax,ebx");
    (save)ebp;
    asm("clc");
    (restore)ds;
    return(Lc2ac88bc());
    asm("out dx,al");
    asm("Unknown opcode 0x82");
    al = *L675386D7;
    asm("xchg ch,[esi-0x74]");
    (save)edi;
    asm("les esp,[edx+0x6c]");
    asm("insb");
    asm("adc edi,+0x3e");
    al = al - 42 & 224;
    (restore)ds;
    asm("Unknown opcode 0xdb");
    asm("bound ebp,[esp+ebp*2-0x13]");
    (save)edx;
    (save)edx;
    asm("in eax,dx");
    esi = edx;
    esp = esp + 1;
    (save)esp;
    *ebx = *ebx ^ -114;
    (save)esp;
    asm("aaa");
    (restore)esi;
    asm("a16 pop esi");
    (restore)ds;
    (restore)es;
    (save)edx;
    asm("outsb");
    asm("outsb");
    asm("enter 0x771f,0x66");
    asm("insb");
    asm("insb");
    asm("insd");
    asm("Unknown opcode 0x8e");
    if(*(ebx - 114) = *(ebx - 114) & 84) {
        goto L00401c41;
    }
    (save)esi;
    asm("sbb eax,0x6e6e70d5");
    (save)ds;
    dl = dl - dh;
    al :: 74;
    (save)cs;
    asm("sbb eax,0x6c6c6419");
    asm("insb");
    asm("%d push cs");
    asm("xchg edx,edi");
    asm("%s pop ds");
    ah = 112;
    asm("outsb");
    asm("outsb");
    if(!(eax = eax | -678989759)) {
        asm("insd");
        return;
        al = *esi;
        if(esi = esi + 1) {
            goto L00401d2b;
        }
        asm("outsb");
        (save)ds;
        asm("les ebx,[esi]");
        (save)esp;
        asm("%s push cs");
        asm("sbb eax,0x6c6c64f0");
        asm("insb");
        eax = eax | 1851708128;
        asm("insb");
        asm("aaa");
        ds = *edi;
        asm("arpl [eax+0x6c],bp");
        asm("insb");
        asm("insd");
        asm("in eax,dx");
        (restore)esi;
        if(*(ebx + 1725322054) & 241620871) {
            goto L00401d53;
        }
        asm("outsb");
        asm("adc ebx,-0x7a");
        (save)esp;
        asm("xlatb");
        (restore)esi;
        (save)cs;
        asm("sbb eax,0x6c6c6a9c");
        (restore)edi;
        asm("xlatb");
        (save)bx;
        asm("jecxz 0x401d67");
        *(ebp + 63) = ss;
        asm("insb");
        asm("insb");
        asm("insb");
        *(ebx + 1819036959) = *(ebx + 1819036959) ^ 108;
        (restore)esi;
        return;
        asm("out dx,al");
        asm("jecxz 0x401d01");
        *(edi - 128) = ss;
        >= ? 0x401d80 : ;
        asm("outsb");
        al = al & 224;
        asm("rcl byte [esi+0x6e],cl");
        *edi = ~( *edi);
        goto L00401d5b;
        asm("insb");
        asm("insb");
        (save)edx;
        asm("scasb");
        asm("in eax,dx");
        asm("outsb");
        edi = edi ^ -114;
        (restore)ds;
    }
    *(edx + 110) = *(edx + 110) & dl;
    asm("outsb");
    asm("Unknown opcode 0xc6");
L00401d2b:
    asm("adc [ecx+0x74506d01],al");
    (save)edx;
    edx = edx | esi;
    asm("out dx,al");
    asm("outsb");
    return;
    (save)ebx;
    asm("%d push esp");
    asm("aaa");
    (restore)esp;
    (save)esp;
    asm("jecxz 0x401d9b");
    asm("a16 pop esi");
    if(!( *ecx = *ecx + 1850869791)) {
        (save)ebx;
        asm("ficom dword [edx+0x53]");
        (restore)ds;
        (save)edx;
L00401d53:
        *(edi - 87) = ss;
        (save)609512556;
L00401d5b:
        (save)esi;
        (save)ebx;
        asm("arpl [esi+0x5e],dx");
        *(ebx + 111) = ds;
        (save)523005036;
        if(al & ah) {
            goto L00401dce;
        }
        asm("insb");
        asm("insb");
        >= ? 0x401d5b : ;
        (restore)esi;
        asm("insb");
        return;
        asm("aaa");
        asm("adc eax,0x6ed71df3");
        asm("outsb");
        asm("outsb");
        (restore)edi;
        asm("xlatb");
        asm("adc eax,0x6c3e376c");
        asm("aaa");
        asm("adc eax,0x40d01df3");
        asm("insb");
        asm("insb");
        al :: 215;
        (save)si;
        asm("outsb");
        asm("outsb");
        asm("outsb");
        *(ebp + 54) = ss;
        (save)edx;
        asm("outsb");
        asm("outsb");
        ds = cs;
        asm("adc eax,0x706e6e52");
        asm("in eax,dx");
        (restore)esi;
        asm("outsb");
        asm("insb");
        ebp = ds;
        eax = al - 46 - 1852755741;
        asm("outsb");
        (save)ds;
        al :: 242;
        ebp = ebp + 1;
        asm("aas");
        (save)cs;
        asm("sbb eax,0x6c6c62f4");
        asm("insb");
        eax = eax | -530131069;
        asm("rcr byte [esi+0x6e],cl");
        *(ebx + 1054233414) & 1082793971;
    }
    asm("insb");
    asm("insb");
    asm("outsb");
    asm("in eax,dx");
L00401dce:
}

stack space not deallocated on return
/*	Procedure: 0x00401DD1 - 0x00401F86
 *	Argument size: -1172
 *	Local size: 0
 *	Save regs size: 0
 */

L00401DD1()
{



    (save)ecx;
    goto L00401e3e;
    asm("insb");
    asm("insb");
    al = al - 42 & 224;
    asm("rcr byte [esi+0x6e],cl");
    *(ebx + -2095647930) & 1852755320;
    asm("outsb");
    ecx = ecx ^ -122;
    *ecx = *ecx & 68;
    asm("int 0x6c");
    asm("in eax,dx");
    (save)esi;
    asm("insb");
    asm("outsb");
    ds = *(esi + 108);
    asm("aaa");
    eax = eax & 489502572;
    *(edx + 108) = *(edx + 108) | ebp;
    asm("insb");
    asm("insb");
    asm("aaa");
    goto L00401e05;
L00401e3e:
    while(1) {
        asm("insb");
        asm("insb");
        asm("insd");
        if(!(eax = eax + 1)) {
            break;
        }
L00401e05:
        asm("aaa");
        asm("Unknown opcode 0xfe");
        asm("sbb eax,0x6e6e52aa");
        (restore)ds;
        asm("scasb");
        if(eax = eax & 1814902636) {
            goto L00401e81;
        }
        asm("outsb");
        asm("std");
        (restore)ds;
        < ? L00401e88 : ;
        asm("outsb");
        asm("outsb");
        (restore)esi;
        (restore)esi;
        asm("insb");
        ss = *(edx + 83);
        asm("aam 0x86");
        ecx = ecx ^ -122;
        *(edx + 31) = *(edx + 31) ^ 43;
        (save)108;
        asm("insb");
        *edx = *edx + -51;
        bl = 238;
        (restore)ds;
        eax :: *(eax + 108);
        asm("insb");
        asm("lock out dx,al");
        (restore)esp;
        (restore)ds;
        ecx = 113;
    }
    *(ebx + 97932102) & -1938931213;
    asm("iret");
    asm("sbb esi,+0x6f");
    asm("das");
    asm("insb");
    asm("outsb");
    asm("outsb");
    asm("outsb");
    if(!(ecx = ecx + 1)) {
        asm("adc esp,[esi+0x6c]");
        asm("insb");
        *L6C623B1F = eax;
        asm("insb");
        asm("scasb");
        asm("scasb");
        asm("insd");
        (save)edx;
        (save)cs;
        ebp = ds;
        asm("insb");
        (save)ds;
        if(eax = al - 46 - 1819034397) {
            goto L00401ec4;
        }
        al & dl;
        (save)cs;
    }
    asm("sbb eax,0x6c6c6288");
    asm("insb");
    eax = eax | 240048007;
L00401e81:
    asm("xchg edx,edi");
    asm("%s push cs");
    ecx = ecx + 1;
    asm("outsb");
    esp = esp + 1;
    *(esi - 82) :: ebx;
    (save)edx;
    return;
    *(edi - 122) = *(edi - 122) & 22;
    *(eax + 1852731085) = *(eax + 1852731085) - -125;
    al = al & 134;
    ebx = ebx ^ -122;
    *ebx = *ebx ^ -122;
    esp = esp + 1;
    (restore)eax;
    (restore)ds;
    asm("insb");
    asm("insb");
    asm("sbb ecx,-0x5a");
    asm("jecxz 0x401e8c");
    *(edi + 10) = ss;
    esi = 929852524;
    ebx = ecx;
    if(!(al = al & 104)) {
        asm("jecxz 0x401f27");
        asm("insb");
        asm("insb");
        asm("scasb");
        ss = *(esi + 112);
L00401ec4:
        asm("insb");
        (save)esi;
        (save)esi;
        asm("insb");
        esp = esp ^ *(esi + 497431404);
        asm("adc ch,[eax+0x6c]");
        asm("insb");
        asm("sbb eax,0x6c6c6235");
        asm("sbb eax,0x6c6c6ae3");
    }
    (restore)edi;
    asm("xlatb");
    eax = eax - -846691562;
    asm("outsb");
    asm("outsb");
    asm("outsb");
    (restore)edi;
    asm("out dx,eax");
    (restore)esi;
    asm("insb");
    asm("aaa");
    eax = eax & 489502572;
    *(esp + ebp * 2 + 108) = *(esp + ebp * 2 + 108) << 131;
    dh = 0;
    (restore)ds;
    if(!(eax = eax - 1)) {
        asm("outsb");
        gs = *(esi - 62);
        (restore)esi;
        ecx = ecx + 1;
        asm("outsb");
        ebp = ds;
        eax = al - 46 - 1818889501;
        asm("insb");
        (save)ds;
        edx = 246650476;
        asm("sbb eax,0x6c6c4031");
        asm("insb");
        eax = eax | 238475143;
        ebp = ds;
        eax = al - 46 - 1852867615;
        asm("outsb");
        (save)esi;
        asm("scasb");
        (save)edx;
        (save)edx;
        return;
        asm("xlatb");
        eax = eax - 251582292;
        asm("aam 0x1d");
        ebp = ebp & *(edx + 108);
        asm("insb");
        asm("adc edi,+0x2d");
        asm("sbb esi,+0x54");
        asm("in eax,dx");
        asm("in eax,0x1f");
        asm("cdq");
        asm("bound ebp,[esp+ebp*2-0x52]");
        (save)edx;
        asm("scasb");
        asm("xchg ebp,ebp");
        (save)edx;
        (save)cs;
        asm("insb");
        asm("aaa");
        asm("sbb ax,0x62d5");
        asm("insb");
        asm("insb");
        asm("les edx,[ebx-0x17]");
        asm("outsb");
        *(edi - 63) = ss;
        (save)-1642107796;
        asm("%f insb");
        asm("insb");
        gs = ebp;
        asm("in eax,dx");
        asm("outsb");
        asm("insd");
        gs = *edx;
    }
    asm("loopne 0x401f3f");
    asm("xchg ch,[esi-0x9]");
    *(esi + 46) = *(esi + 46) + -125;
    asm("aaa");
    asm("xchg al,[ebx+0xb2665e67]");
    asm("insd");
    bl = 35;
    (restore)ds;
    *edx = edi;
    asm("insb");
    asm("insb");
    asm("outsb");
}

stack space not deallocated on return
/*	Procedure: 0x00401F87 - 0x0040200F
 *	Argument size: 3924
 *	Local size: 0
 *	Save regs size: 0
 */

L00401F87()
{



    >= ? 0x401ff7 : ;
    asm("repne fdivp st7,st0");
    return;
    asm("lock rcl byte [edi+ebx*8-0x7c],cl");
    asm("loopne 0x401fb5");
    asm("loope 0x401fd2");
    asm("insb");
L00401f99:
    asm("insb");
    (save)edx;
    asm("in eax,dx");
    asm("insd");
    >= ? 0x401ff1 : ;
    asm("insb");
    return;
    *L6C40561D = al;
    asm("insb");
    (restore)ds;
    eax = -965972892;
    asm("Unknown opcode 0x0f");
    asm("sbb eax,0x6438558c");
    asm("insb");
    asm("insb");
    if(esi = esi + *edi) {
        goto L00401f99;
    }
    (restore)ds;
    *edx = bh;
    asm("insb");
    asm("insb");
    asm("Unknown opcode 0x8f");
    asm("Unknown opcode 0xdd");
    asm("lock sub eax,0x151fc65e");
    *(esp + ebp * 2 + 94) :: ch;
    asm("insb");
    es = *(ebx + -2080638650);
    *(esi + -2088355965) = *(esi + -2088355965) | cl;
    asm("a16 pop esi");
    al = al ^ 149;
    (restore)ds;
    ebx = -1905496990;
    (restore)esi;
    asm("in eax,dx");
    return;
    edi = edi;
    eax = eax + 1;
    asm("insb");
    asm("insb");
    asm("insb");
    asm("aaa");
    asm("sbb eax,0x1df6376c");
    asm("stc");
    eax = eax + 1;
    asm("insb");
    asm("insb");
    *eax = *eax | 45;
    edi = edi - -27;
    asm("adc ebp,+0x70");
    asm("sahf");
    (save)esp;
    asm("lock pop edi");
    asm("xlatb");
    eax = eax + 523053187;
    asm("into");
    asm("outsb");
    asm("outsb");
    asm("outsb");
}

stack space not deallocated on return
/*	Procedure: 0x00402010 - 0x00402032
 *	Argument size: 27885
 *	Local size: 0
 *	Save regs size: 0
 */

L00402010()
{



    (save)edx;
    asm("insd");
    (save)esi;
    ecx = ecx + 1;
    asm("insb");
    (save)cs;
    ebp = ds;
    eax = al - 46 - 1818814493;
    asm("insb");
    (save)ds;
    asm("les ebx,[esi]");
    (save)esp;
    asm("%s push cs");
    asm("sbb eax,0x6c6c3e2c");
    (save)cs;
    asm("aam 0xf7");
    esp = esp + 1;
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
}

/* DEST BLOCK NOT FOUND: 0040237e -> 2b03d4fd */
stack space not deallocated on return
/*	Procedure: 0x00402033 - 0x00402512
 *	Argument size: 9300
 *	Local size: 0
 *	Save regs size: 0
 */

L00402033()
{



    asm("sbb eax,0x6c6c6897");
    (save)ds;
    asm("lock leave");
    asm("Unknown opcode 0xfe");
    (save)eax;
    (save)cs;
L0040203e:
    asm("sbb eax,0x6c6c3edb");
    asm("insb");
    (restore)ds;
    (fsave) *(eax + 108);
    asm("insb");
    asm("scasb");
    if(eax = eax | -531703933) {
        goto L0040203e;
    }
    bl = 242;
    asm("sbb cl,[ecx+0x1d851a1d]");
    asm("Unknown opcode 0x0f");
    (fsave)(frestore) / *ecx;
    asm("o16 push ds");
    asm("outsb");
    asm("outsb");
    asm("outsb");
    asm("outsb");
    edx = edi;
    asm("o16 push ds");
    if(!(eax = eax + 1)) {
        asm("sti");
        asm("Unknown opcode 0xd9");
        edx = edi;
        asm("%d push ds");
        eax = eax + -1962605307;
        asm("xlatb");
        asm("%s pop ds");
        asm("into");
        eax = eax + 1;
        asm("insb");
        asm("insb");
        asm("scasb");
        (save)edx;
        asm("insd");
        (save)esi;
        (save)esi;
        asm("scasb");
        asm("insb");
        asm("aaa");
        *L6C6C6A19 = ~( *L6C6C6A19);
        esp = esp + 1;
        asm("xchg ch,[edi+esi+0x15]");
        (save)cs;
        asm("insb");
        asm("aaa");
        *L6C6C6C79 = ~( *L6C6C6C79);
        al :: 215;
        gs = *(esi + 110);
        asm("outsb");
        *(ebp - 39) = ss;
        (save)108;
        asm("insb");
        asm("insb");
        asm("aaa");
        eax = eax - 1818517277;
    }
    asm("insb");
    asm("insb");
    asm("aaa");
    asm("lock bound ebp,[esp+ebp*2+0x6d]");
    (save)edx;
    asm("outsb");
    asm("insb");
    (save)edx;
    if(!(eax = eax & 523057004)) {
        asm("aaa");
        eax = eax + -217237652;
        asm("sbb eax,0x6c6c3c3f");
        asm("rep sbb eax,0x6c6c64a6");
        asm("adc esp,+0x54");
        asm("in eax,dx");
        asm("in eax,0x6c");
        ebp = ebp - 1;
        ch = 243;
        asm("sbb eax,0x6c6c40d4");
        al = al & 31;
        asm("insb");
        asm("insb");
        gs = *(esi + 1819307118);
        return;
        asm("in eax,0x6c");
        esi = esi ^ ebp;
        asm("insb");
        asm("aaa");
        asm("imul byte [edi+esi+0x2d]");
        asm("sbb eax,0x6c6c6cb1");
        asm("Unknown opcode 0x8c");
        esp = -730899964;
        asm("%d outsb");
        asm("outsb");
        asm("outsb");
        (restore)ds;
        asm("sbb [esi],bh");
        asm("insb");
        asm("insb");
        return;
        if(bh < *edx) {
        }
        *edx = *edx + al;
        *edx = *edx | al;
L00402112:
        asm("cli");
        eax = ebx;
        asm("adc ebx,0x152ba1af");
        cl = ~(ch + 1);
        return;
        asm("sbb ecx,0x29d3f176");
        asm("rol bh,cl");
    }
    bh = bh << cl;
    asm("ror ah,0xd");
    asm("sbb ah,0x5b");
    dl = bh;
    if(!(ch = ch + dl)) {
        != ? 0x40213e : ;
        dl = dl + *eax;
        al = al + 16;
        dl = dl + dl;
    }
    asm("out dx,eax");
    cl = cl >> cl;
    asm("rol dh,cl");
    al = al | bl;
L00402146:
    bh = bh >> cl;
    dh = 9 - esi & 114;
    ebx = -41 - ch + edi;
    ch = ~ch;
    goto L004024b3;
    al = al + 64 + 2;
L0040216a:
    if(!( *(eax + -209654646) = *(eax + -209654646) & al)) {
        asm("repne rol dl,cl");
    }
    esi = ebx;
    edi = 2146665149;
    bl = ~bl;
    ch = ~ch;
    dh = 102;
    goto L00402447;
    *edx = *edx + al;
    *(ecx + 1714611174) = *(ecx + 1714611174) + 1;
L00402188:
    269020033 :: bh;
    asm("rcl bl,cl");
    asm("sbb bh,0xdd");
    edx = edx & 421294621;
    bh = bh + 1;
    asm("adc esi,0x40e5ab11");
    bl = bl << cl;
    asm("rcl bl,cl");
    edx = edx | -1916553997;
    ch = ch - 150;
    asm("rcl bh,cl");
    goto L004022f2;
    asm("adc [eax+0xd6800810],al");
    asm("sbb cl,[esi-0x80]");
    asm("salc");
    asm("Unknown opcode 0x8e");
    ch = !ch;
    asm("rol dl,cl");
    asm("sbb bl,0x39");
    edx = edx | -1018531740;
    bh = bh >> cl | ah;
    dl = dl - 249;
    asm("ror bh,cl");
    dl = dl | ch;
    goto L004024d5;
    asm("adc byte [eax],0x2");
    eax = eax + 1;
    *eax = *eax + edx;
    *(eax + 7835732) = *(eax + 7835732) + edi;
    (restore)eax;
    asm("ror ch,cl");
    edi = edi & 284885353;
    asm("ror bh,0x5");
    asm("rol bl,cl");
    bh = bh ^ ah;
    cl = !( !cl);
    bh = bh ^ dh;
    asm("rol bl,cl");
    if(!(eax = eax - -2281)) {
        >= ? L00402398 : ;
        al = al + *ecx;
        *(eax + 16) = *(eax + 16) | al;
        dh :: 194;
        asm("rcr bl,cl");
        edx = 254 & 255;
        esi = esi - -1904624352;
        ch = *eax;
        goto L00402146;
        *eax = *eax + al;
        *edi = al;
        edi = edi + 1;
        *ecx = *ecx + eax;
        al = al + 8;
L0040223d:
        edi = edi - -989470207;
        edx = edx ^ edi;
        esi = -1172784775 - edx;
        ecx = ecx ^ esi;
        edx = edx - esi;
        eax = eax + -2281;
        dl = dh << cl >> cl;
        esi = esi | -1439507500;
        asm("adc bl,0xed");
        ch = ch ^ 128;
        if(edi = edi - edx) {
            goto L0040216a;
        }
        >= ? 0x40216a : ;
        *(edx + 270533375) = *(edx + 270533375) + ebp;
L0040227a:
        eax = eax | -1027231381;
        asm("sbb dh,0x5f");
        edx = edx + 826945400;
        asm("sbb cl,0x3b");
        asm("rcl dh,cl");
        dh = dh << cl;
        bl = bl & 177;
        cl = ch | 13 | 251;
        goto L00402112;
        eax = eax + 1;
        *(edx + ebp * 4) = *(edx + ebp * 4) + eax;
        *(eax + edx) = *(eax + edx) & al;
L004022a5:
        dh = bl;
        ch = ch - 165;
        asm("ror ch,0x1d");
        cl = cl | dh;
        ecx = edx + 1;
        asm("rol cl,0x3");
        asm("ror ch,cl");
        edx = edi;
        asm("sbb ch,0x8f");
        cl = !ebx;
        if(!(ch = ch + bl)) {
            >= ? L00402315 : ;
            ch = ch + *(edx + 1258292352);
L004022cb:
            asm("ror dl,cl");
            edi = edi ^ 2146666761;
            asm("ror dh,cl");
            esi = esi - ecx;
            asm("ror bl,cl");
            bh = dh;
            cl = ~cl;
            if(dl = dl + bh) {
                goto L0040255f;
            }
            >= ? 0x40255f : ;
            *(esp + eax) = *(esp + eax) + eax;
            cl = cl + *eax;
            *(eax + -889292325) = *(eax + -889292325) + eax;
L004022f2:
            edx = edx + 1;
            bl = cl | ah;
            dh = !dh;
            dh = al;
            esi = esi ^ edi;
            if(dl = edx - 1 & 237) {
                goto L004023e5;
            }
            >= ? L004023e5 : ;
            al = al + 170;
            *edi = al;
            edi = edi + 1;
        }
        asm("sbb esi,0x19e10879");
        asm("sbb esi,0x17eb440e");
        esi = esi + -1718478535;
        asm("ror cl,0x1d");
        cl = cl - 1;
        asm("adc ecx,0xd64c7ff5");
        esi = esi - eax;
        cl = cl + ah;
        edx = edx - 1365156261;
        ch = ecx + eax + 1;
        if(!(esi = esi + 1)) {
            >= ? L00402378 : ;
            al = al + 1;
            *eax = *eax + ah;
            *(eax - 128) = *(eax - 128) + eax;
L0040234c:
            ch = ch >> cl;
            if(edx != -1365156261) {
                goto L0040256c;
            }
            ah = ah >> cl;
            dl = dl | bl;
            cl = cl + ah;
            edx = edx & 490618230;
            if(ah = ah + 184) {
                goto L00402495;
            }
            >= ? 0x402492 : ;
            *(edx + -2117104726) = *(edx + -2117104726) + ch;
        }
        asm("fst dword [ebp-0x5f]");
        goto L2b03d4fd;
        asm("int3");
        asm("rcl ch,cl");
        cl = !((ecx | eax) ^ al);
        if(esi = esi - edi) {
            goto L0040234c;
        }
        > ? L0040234c : ;
        *(eax + 1) = *(eax + 1) & al;
        *(edx + 735523586) = *(edx + 735523586) + ch;
    }
    asm("xlatb");
    asm("rol bh,0x19");
    edx = edx - esi;
    bl = bl + 183;
    cl = dl;
    asm("sbb esi,0xea71e085");
    bl = 87;
    goto L004024f6;
    *eax = *eax & dl;
    *eax = *eax | 4;
    asm("Unknown opcode 0xff");
    dh = dh - 1 | 196;
    asm("sbb cl,0xae");
    cl = cl >> cl;
    asm("adc cl,0x1d");
    dh = edx + 1 >> cl;
    ch = al | bh;
    asm("sbb ecx,0xf6dbe987");
    if(edi = edi - 1) {
        goto L004022a5;
    }
    >= ? 0x4022a5 : ;
    cl = cl + *eax;
    *(eax - 128) = *(eax - 128) | al;
L004023e5:
    bl = ch;
    esi = eax;
    dl = dl + al;
    esi = eax;
    asm("rol dh,0xa");
    dh = dh >> cl;
    asm("rol dl,cl");
    cl = cl - ch;
    dl = dl << cl;
    asm("rcl ch,cl");
    ch = ch >> cl;
    dh = dl;
    esi = esi + -2126165983;
    goto L00402532;
    *(edx + -2147482616) = *(edx + -2147482616) - 128;
L00402410:
    dl = dl ^ al;
    asm("rol ch,0x7");
    asm("sbb edx,0x7f8b2618");
    asm("sbb ebx,0x206d21b6");
    dh = dl + 1 - 1;
    asm("ror dh,0x5");
    ebx = ebx - 1 - 1 - esi;
    esi = esi + 473568580;
    asm("jpe 0x4021bf");
    asm("jpo 0x4021bf");
    eax = eax + 1;
    asm("Unknown opcode 0xff");
    goto ( *(edx + -2126495574));
L00402447:
    (fsave)(frestore) / *(esi - 125);
    asm("xchg eax,ecx");
    asm("out dx,al");
    esi = esi ^ ecx;
    asm("adc dl,0x18");
    dl = (dl ^ dh) - al;
    bl = ~bl;
    cl = cl - bh;
    goto L004022cb;
    *edx = *edx + eax;
    *(eax + -1057246464) = *(eax + -1057246464) + 1;
L00402465:
    asm("Unknown opcode 0xc7");
    eax = eax | *(eax + -148170518);
    asm("rol dh,cl");
    esi = esi + 1;
    bh = bh + 178;
    ch = ch ^ 200;
    esi = esi & -431008345;
    dl = 115;
    asm("sbb dl,0x5d");
    esi = esi + 1;
    goto L00402188;
    goto ( *(edx + -154391936));
L00402495:
    asm("Unknown opcode 0xd3");
    ch = ch ^ dh;
    dl = dl >> cl;
    ch = cl >> cl << cl >> cl;
    cl = dl;
    if(*edx = *edx + 32) {
        goto L0040227a;
    }
    >= ? L0040227a : ;
    *edx = *edx + eax;
    eax = eax + 1;
    *eax = *eax & cl;
    *eax = *eax | dl;
L004024b3:
    asm("rcl bl,cl");
    asm("ror dl,0xc");
    esi = edx;
    dl = ~dl;
    asm("rol bl,cl");
    ebx = ebx + ecx;
    asm("rol dh,cl");
    ebx = ebx - edi | ecx;
    dh = dh - cl;
    asm("ror bh,cl");
    goto L00402410;
    *(eax + 8) = *(eax + 8) & al;
    *(edx + 1138938370) = *(edx + 1138938370) + ch;
L004024d5:
    dh = edx + 1 + 1;
    ebx = ebx ^ esi;
    edx = edx | 670101627;
    ch = ch + 168;
    asm("sbb edx,0x89ece1bf");
    goto L00402465;
    eax = al + *(eax + ecx) + 1;
    *edx = *edx | dh;
L004024f6:
    *(eax + 2) = !( *(eax + 2));
    asm("lock add edx,0xce00bd27");
    esi = esi - 1;
    esi = -1717910326;
    dh = dh - bh;
    goto L0040223d;
    *eax = *eax & ah;
    *edi = al;
    edi = edi + 1;
    *eax = *eax + ecx;
}

/* DEST BLOCK NOT FOUND: 00402528 -> 004021ea */
/* DEST BLOCK NOT FOUND: 00402550 -> 004023b9 */
/* DEST BLOCK NOT FOUND: 00402556 -> 004023b9 */
/* DEST BLOCK NOT FOUND: 00402573 -> 0040221f */
/* DEST BLOCK NOT FOUND: 00402579 -> 0040221f */
/*	Procedure: 0x00402513 - 0x00402581
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402513()
{



    ch = ch ^ dl;
    eax = eax + -1061859113;
    asm("adc ch,0xd6");
    asm("ror ch,cl");
    bl = bl + dl;
    dh = dh << cl;
    bl = 143;
    goto L004021ea;
    *(edx + eax) = *(edx + eax) & al;
    *(eax - 120) = *(eax - 120) + al;
    asm("sbb dl,dl");
    asm("rcl edx,1");
    (fsave)(frestore) + *(eax + -1044380970);
    eax = eax | 517860993;
    ecx :: *edi;
    asm("adc edx,0x1ef26940");
    cl = cl | 125;
    asm("rcr dh,cl");
    if(eax = eax + 1) {
        goto L004023b9;
    }
    > ? L004023b9 : ;
    *ecx = *ecx | al;
    *edx();
    asm("std");
    ecx = ch + dh - 1;
    bl = bl - 197;
    asm("rol bh,cl");
    ch = cl ^ dh ^ dh;
    asm("ror cl,0xd");
    if(cl = cl - 205) {
        goto L0040221f;
    }
    >= ? 0x40221f : ;
    *(eax + 1) = *(eax + 1) | eax + 1;
}

/* address  size  */
/* 0x00401454       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
