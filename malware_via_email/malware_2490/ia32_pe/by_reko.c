// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040F9E4: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	Eq_3 edi_3 = edi;
	Eq_5 ebp_34 = dwArg04;
	Eq_7 eax_12 = IsWindow(dwArg04);
	ptr32 esp_17 = fp;
	if ((eax_12 | 0x01) == 0x01)
	{
		eax_12 = fn0040FA4C(GetProfileIntW(fp - 0x04, fp - 0x04, 0xF7), ecx, out ecx, out edx, out ebp_34, out esi, out edi_3);
		esp_17 = fp + 0x34;
	}
	word32 * esp_38 = esp_17 - 0x04;
	*esp_38 = ecx;
	*(esp_38 - 0x04) = (int32) eax_12;
	Eq_30 ebx_42 = *(esp_38 - 0x04);
	*(esp_38 - 0x04) = (union Eq_3 *) edi_3;
	word32 ecx_46 = ecx - 266694;
	if (edi_3 != esi)
	{
		word32 ecx_57;
		word32 edx_58;
		word32 ebp_59;
		word32 esi_60;
		word32 edi_61;
		return fn0040FA80(ecx_46 + 0x00042662, edx, ebx_42, ebp_34, esi, edi_3, out ecx_57, out edx_58, out ebp_59, out esi_60, out edi_61);
	}
	else
		return esp_38 - 0x04;
}

// 0040FA4C: Register Eq_2 fn0040FA4C(Register Eq_30 ebx, Stack word32 dwArg00, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_2 fn0040FA4C(UINT ebx, word32 dwArg00, ptr32 & ecxOut, ptr32 & edxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_3 eax_10 = VirtualAlloc(0x00, 83538, 0x3000, 0x40);
	uint32 edx_32 = DPB(28768668, bl + 0x9C, 0);
	word32 ecx_41;
	word32 edx_42;
	word32 ebp_43;
	word32 esi_44;
	word32 edi_45;
	return fn0040FA80(0x01F6, edx_32, ebx, null, dwArg00 + 0xC3, eax_10, out ecx_41, out edx_42, out ebp_43, out esi_44, out edi_45);
}

// 0040FA80: Register (ptr Eq_136) fn0040FA80(Register word32 ecx, Register uint32 edx, Register Eq_30 ebx, Register Eq_5 ebp, Register Eq_3 esi, Register Eq_3 edi, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_136 * fn0040FA80(word32 ecx, uint32 edx, UINT ebx, HWND ebp, Eq_3 esi, Eq_3 edi, ptr32 & ecxOut, ptr32 & edxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
fn0040FA80_entry:
l0040FA80:
	*(v3 - 0x04) = edx
	*(v3 - 0x08) = ecx
	*edi = (word32) *edi + (byte) ((word32) (*esi) + *(v3 - 0x04))
	uint32 edx_47 = *(v3 - 0x04)
	Eq_171 ecx_264 = *(v3 - 0x08)
	struct Eq_137 * esp_239 = v3
	esi = (word32) esi + 0x01
	edi = (word32) edi + 0x01
	ebp = (Eq_5) ((char *) &ebp->unused + 0x01)
	uint32 edx_247 = edx_47 >> 0x08
	byte dl_249 = (byte) (edx_47 >> 0x08)
	branch (struct HWND__ *) 0x04 != ebp l0040FAD4
l0040FACC:
	*(v3 - 0x04) = 28768668
	edx_247 = *(v3 - 0x04)
	dl_249 = (byte) edx_247
	esp_239 = v3
l0040FAD2:
	ebp = null
l0040FAD4:
	edx = DPB(edx_247, dl_249 + bl, 0)
	ecx = ecx_264 - 0x01
	branch ecx != 0x00 l0040FA80
l0040FADD:
	<anonymous> * edx_98 = esp_239->dw0000
	ptr32 esp_103
	byte SCZO_104
	word32 edx_105[]
	word32 esi_107
	struct Eq_218 * edi_108
	byte cl_109
	struct Eq_136 * eax_110
	byte Z_112
	byte SZO_113
	byte C_114
	byte dl_115
	byte bl_116
	byte CZ_117
	Eq_227 ebx_118
	word16 dx_119
	byte al_120
	byte O_121
	struct Eq_231 * cs_122
	word16 si_123
	Eq_233 ss_124
	byte ah_125
	byte D_126
	byte ch_127
	byte SO_128
	struct Eq_238 * ebp_111
	struct Eq_136 * ecx_106
	edx_98()
	branch ecx_106 != eax_110 l0040FB45
l0040FAE4:
	return eax_110
l0040FAE5:
	byte al_199 = (byte *) ~0x6638671C
	edi_108->dw0000 = __in(edx_105)
	ebp_111->b0039 = ebp_111->b0039 | ch_127
	Eq_324 esi_209 = esi_107 - esp_103
	edx_105[ebp_111] = (word32) esi_209 + 0x01
	ebp_111->b0020 = 0x53
	byte ch_219 = SLICE(ebx_118 - 0x01, byte, 8)
	*(esi_209 - 0x11) = *(esi_209 - 0x11) | ch_219
	*(esp_103 - 0x05) = (word32) esi_209 + 0x01
	struct Eq_356 * eax_200 = DPB(eax_110, al_199, 0)
	cu8 v36_230 = *(eax_200 - 0x05) + dl_115
	*(eax_200 - 0x05) = v36_230
	((Eq_440[]) 652629008)[ebp_111].b0000 = ((Eq_440[]) 652629008)[ebp_111].b0000 ^ ((byte) ecx_106 | ~0x13)
	*(esp_103 - 0x09) = edx_105
	ebp_111->b0003 = ebp_111->b0003 | ch_219
	uint64 edx_eax_246 = edi_108->dw0027 * edx_105
	ptr32 eax_248 = (word32) edx_eax_246
	*(eax_248 - 0x6B) = *(eax_248 - 0x6B) | ch_219
	bl = al_199
	esi = (byte) (v36_230 < 0x00) + ((word32) (ebx_118 - 0x01) + ((word32) esi_209 + 0x01))
	*esiOut = esi
	esp_239 = esp_103 - 0x09
	edx_247 = SLICE(edx_eax_246, word32, 32)
	*edxOut = edx_247
	dl_249 = SLICE(edx_eax_246, byte, 32)
	edi = edi_108 - 0x05
	*ediOut = edi
	word32 ebp_259
	*ebpOut = eax_248
	ecx_264 = ebx_118 - 0x02
	branch ebx_118 < 0x02 l0040FAD2
l0040FB28:
	word32 ecx_269
	*ecxOut = ebx_118 - 0x01
	return (char *) ebp_111 + 0x01
l0040FB45:
	eax_110[0x006D] = (struct Eq_136) __rol(eax_110[0x006D], cl_109)
	branch false l0040FAE5
l0040FB4D:
	__outb((word16) (edx_105 - 0x01), al_120)
	ptr32 esp_137 = esp_103 + 0x04
	word32 * edx_138 = edx_105 - 0x01
	byte al_143 = (byte) (eax_110 | 275581255)
	bool C_148 = false
l0040FB55:
	ecx_106->b0000 = __rcl(ecx_106->b0000, 0x01, C_148)
	word32 v24_165 = -*edx_138
	*edx_138 = v24_165
	ebp_111 = ebp_111 + ecx_106 + (v24_165 == 0x00)
	C_148 = cond(ebp_111)
	branch !OVERFLOW(ebp_111) l0040FB75
l0040FB5D:
	esp_137 = esp_137 + 0x04
	edx_138 = DPB(edx_138 - 0x01, 0x50, 0)
	ecx_106 = ecx_106 - 0x01
	branch ecx_106 != null l0040FB55
l0040FB65:
	*(esp_137 - 0x04) = (union Eq_233 *) ss_124
	__outb(0x62, al_143)
l0040FB75:
fn0040FA80_exit:
}

