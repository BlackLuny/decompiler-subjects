// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004011CE: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
l004011CE:
	esp = esp - 0x04;
	esp->dw0000 = ebp;
	uint64 ecx_edi_24 = SEQ(ecx, eax + edi) + ebx_eax;
	uint32 ebx_29 = ebx - SLICE(ecx_edi_24, word32, 32) - (ecx_edi_24 < 0x00);
	ebp = esp;
	uint32 ebx_40 = (word32) (SEQ(ebx_29 * 0x02, ebx_29 * 0x02) + SEQ(ebx_29, ebx_29)) | eax;
	uint32 ecx_49 = (eax | (word32) ecx_edi_24) + edx;
	uint32 ebx_65 = (0x00 - (ecx_49 < 0x00) & ebx_40) - eax;
	struct Eq_46 * ebx_71 = (word32) (SEQ(ebx_65, ebx_65) - &(eax->*eax));
	uint32 esi_74 = (edx - eax | ebx_71) - edx;
	uint32 edi_77 = eax + ebx_40;
	byte cl_63 = (byte) eax;
	word32 edi_84 = (word32) (SEQ(edi_77, edi_77) + SEQ(esi_74, eax));
	if (eax != (byte *) 388396232)
	{
		uint32 ecx_127 = eax - edx - (eax < (byte *) 388396232);
		uint32 ebx_128 = ebx_71 | ecx_127;
		ui64 eax_esi_135 = SEQ(eax + esi_74, (esi_74 | ebx_128) + ebx_128) + SEQ(ecx_127, ebx_128);
		edi = edi_84 - (word32) eax_esi_135;
		ebx = ebx_128 | edi;
		eax = SLICE(eax_esi_135, word32, 32) & edx;
		ecx = ebx;
		byte cl_150 = (byte) ebx;
		ebx_eax = SEQ(ebx, eax);
		al = (byte) eax;
		if (edx != 0x9545C21D)
		{
			word32 ebx_174 = 1825116880;
			do
				ebx_174 = ebx_174 + 1286682900;
			while (ebx_174 != 3891272532);
			__fclex();
			__wait();
		}
		else
		{
			Mem160[esp + eax:byte] = Mem19[esp + eax:byte] | al;
			*eax = *eax + cl_150;
			goto l004011CE;
		}
	}
	else
	{
		*eax = *eax & al;
		esp->a0001[eax].b0000 = esp->a0001[eax].b0000 + 0x23;
		ebx_71->dw8BFE03F1 = __ror(ebx_71->dw8BFE03F1, cl_63);
		ebx_71->b0000 = __rol(ebx_71->b0000, 0x01);
		ebx_71->b0000 = __rol(ebx_71->b0000, cl_63);
		__sti();
	}
}

