// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	struct Eq_3 * esp_23;
	byte SCZO_24;
	word32 esi_26;
	byte SZO_28;
	byte C_29;
	word32 edx_30;
	Eq_2 eax_31;
	byte Z_32;
	word32 ecx_33;
	byte dl_34;
	word32 ebp_35;
	byte CZ_36;
	byte S_37;
	Eq_16 ebx_25;
	Eq_16 edi_104;
	SHLWAPI.dll!StrStrIA();
	if (eax_31 != 0x00)
		return eax_31;
	else
	{
		*(esp_23 - 0x04) = (uint32) eax_31;
		*(esp_23 - 0x08) = (uint32) eax_31;
		Eq_2 eax_54 = AddUsersToEncryptedFile(*(esp_23 - 0x08), *(esp_23 - 0x04));
		if (eax_54 != 0x00)
		{
			*(esp_23 - 0x04) = ~0x00;
			*(esp_23 - 0x08) = ~0x00;
			Eq_60 eax_63 = AreAllAccessesGranted(*(esp_23 - 0x08), *(esp_23 - 0x04));
			if (eax_63 == 0x00)
				ebx_25 = eax_63 + 0x2E;
			*(esp_23 - 0x04) = (char *) &esp_23->ptr000C + 0x04;
			*(esp_23 - 0x08) = 0x40;
			*(esp_23 - 0x0C) = 0x3000;
			*(esp_23 - 0x10) = 0x00401000;
			VirtualProtect(*(esp_23 - 0x10), *(esp_23 - 0x0C), *(esp_23 - 0x08), *(esp_23 - 0x04));
			esp_23->ptr000C = esp_23->ptr000C - 0x01;
			struct Eq_136 * ecx_103 = null;
			do
			{
				if (edi_104 == ebx_25)
					edi_104 = null;
				ecx_103[4199896] = (struct Eq_136) (edi_104[0x00404000] ^ ecx_103[4199896] ^ 0xA0);
				ecx_103 = ecx_103 + 0x01;
				edi_104 = (Eq_16) (edi_104 + 0x01);
			} while (ecx_103 < (struct Eq_136 *) 0x1440);
			*(esp_23 - 0x04) = ebp_35;
			esp_23->ptr000C = (struct Eq_130 *) ((char *) &esp_23->ptr000C->dw0000 + 0x01);
			esp_23->dw001C = 0x00401358;
			esp_23->ptr0014 = null;
			struct Eq_181 * edx_111 = &globals->t4028D8;
			int32 edi_115 = 0x00401358;
			struct Eq_130 * ebp_116 = null;
			if (esp_23->ptr000C > null)
			{
				do
				{
					Eq_208 eax_256 = edx_111->t0004 - 0x08 >> 0x01;
					word16 * ecx_259 = (char *) &edx_111->t0004 + 0x04;
					if (eax_256 > 0x00)
					{
						Eq_208 ebx_272 = eax_256;
						do
						{
							ui32 eax_275 = (word32) *ecx_259;
							if ((eax_275 & 0xF000) == 0x3000)
							{
								struct Eq_243 * eax_287 = (eax_275 & 0x0FFF) + edx_111->dw0000;
								eax_287->dw401358 = eax_287->dw401358 + 0xF0401358;
							}
							ecx_259 = ecx_259 + 0x01;
							ebx_272 = ebx_272 - 0x01;
						} while (ebx_272 != 0x00);
						ebp_116 = esp_23->ptr0014;
					}
					ebp_116 = ebp_116 + Mem121[edx_111 + 0x04:word32];
					esp_23->ptr0014 = ebp_116;
					edx_111 = edx_111 + Mem266[edx_111 + 0x04:word32];
				} while (ebp_116 < esp_23->ptr000C);
			}
			esp_23->ptr0014 = &globals->t4020C4;
			esp_23->ptr0014 = &globals->t4020C4;
			if (globals->dw4020D4 != 0x00)
			{
				struct Eq_130 * ebx_158 = &globals->t4020C4;
				edi_162 = edi_115;
				do
				{
					int32 edi_162;
					*(esp_23 - 0x08) = ebx_158->dw000C + edi_162;
					Eq_345 eax_171 = LoadLibraryA(*(esp_23 - 0x08));
					esp_23->t0018 = eax_171;
					Eq_345 ecx_173 = eax_171;
					if (eax_171 != null)
					{
						ptr32 ebp_194 = ebx_158->dw0000;
						if (ebp_194 == 0x00)
							ebp_194 = ebx_158->dw0010;
						Eq_307 eax_200 = ebp_194 + edi_162;
						struct Eq_310 * ebp_201 = ebp_194 + edi_162;
						word32 * esi_202 = ebx_158->dw0010 + edi_162;
						if (eax_200 != 0x00)
						{
							while (true)
							{
								Eq_333 eax_218;
								if (eax_200 < 0x00)
								{
									*(esp_23 - 0x08) = (word32) ebp_201->w0000;
									*(esp_23 - 0x0C) = (HMODULE *) ecx_173;
									eax_218 = GetProcAddress(*(esp_23 - 0x0C), *(esp_23 - 0x08));
									edi_162 = esp_23->dw001C;
								}
								else
								{
									*(esp_23 - 0x08) = (word32) eax_200 + 0x02 + edi_162;
									*(esp_23 - 0x0C) = (HMODULE *) ecx_173;
									eax_218 = GetProcAddress(*(esp_23 - 0x0C), *(esp_23 - 0x08));
								}
								*esi_202 = (word32) eax_218;
								ebp_201 = ebp_201 + 0x01;
								eax_200.u1 = ebp_201->w0000;
								esi_202 = esi_202 + 0x01;
								if (eax_200 == 0x00)
									break;
								ecx_173 = esp_23->t0018;
							}
							ebx_158 = esp_23->ptr0014;
						}
					}
					ebx_158 = ebx_158 + 0x01;
					esp_23->ptr0014 = ebx_158;
				} while (ebx_158->dw0010 != 0x00);
			}
			ptr32 esp_140;
			byte SCZO_141;
			word32 ebx_142;
			word32 esi_143;
			word32 edi_144;
			byte SZO_145;
			byte C_146;
			word32 edx_147;
			word32 eax_148;
			byte Z_149;
			word32 ecx_150;
			byte dl_151;
			word32 ebp_152;
			byte CZ_153;
			byte S_154;
			globals->t401DB8();
			*(esp_140 - 0x04) = 0x00;
			ExitProcess(*(esp_140 - 0x04));
		}
		else
			return eax_54;
	}
}

