/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1527/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 004010e1 -> 00401005 */
/* DEST BLOCK NOT FOUND: 004010f5 -> 00401025 */
/* DEST BLOCK NOT FOUND: 004010fd -> 00401025 */
/* DEST BLOCK NOT FOUND: 0040111c -> 00401072 */
/* DEST BLOCK NOT FOUND: 00401167 -> 00401041 */
stack space not deallocated on return
/*	Procedure: 0x004010A4 - 0x004012ED
 *	Argument size: 17194
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)ebp;
    ebp = esp;
    ecx = ecx ^ ebx;
    edi = edi + 1;
    edx = eax;
    ebx = ebx | ecx;
    edx = edx - eax - edi;
    goto L00401170;
    *(eax + 8) = *(eax + 8) + 255;
    al = al + *edx;
    asm("adc [ebx],dh");
L004010be:
    *(edx + 3) & -653573677;
    ebx = ebx + 1;
    edx = edx ^ ecx;
    ebx = ebx + 1;
    goto L00401106;
    *eax = *eax + dl;
    *edx = *edx & al;
L004010cf:
    asm("repne xor bh,al");
    asm("smsw [esp]");
    al = al + 209;
    esi = esi + (dl | dh) + 77;
    goto L00401005;
    *eax = *eax + esp;
    al = al + 16;
    ebx = ebx + esi;
    cl = cl - bl;
    edi = edi + 1;
    bl = bl + dh;
    cl = 10;
    if(al & 8) {
        goto L00401025;
    }
    esp = ebp;
    (restore)ebp;
    return;
    goto L00401025;
    *eax = *eax + 1;
    eax = eax + 1;
L00401106:
    ecx = ecx - 1;
    ebx = ebx - esi;
    edx = (edx ^ ecx) - 1;
    cl = ~( !cl);
    edi = edi + edx;
    cl = cl - ah;
    asm("adc dl,0xa");
    asm("sbb ch,0x46");
    cl = bl;
    goto L00401072;
    asm("adc [eax],dl");
    *(eax + 50398336) = *(eax + 50398336) + al;
    asm("lock sbb dh,0x1a");
    cl = ecx + ebx - 1 - bh;
    asm("sbb dh,0xfb");
    (save)eax;
    asm("adc ah,0xff");
    al = ~(eax | ecx) + ~(eax | ecx);
    edi = edi + edx;
    esi = esi - 1;
    goto L004010cf;
    *ecx = *ecx + 2;
    eax = eax + 1;
    edi = edi + edi;
    dh = dh | bh;
    asm("rol dword [eax+0xd6039dd1],0x8a");
    asm("int 0xb");
    *edx = *edx / *edx;
    *( *edx % *edx) = *( *edx % *edx) >> cl;
    asm("int1");
    dl = dl | cl;
    ch = ch - 1;
    asm("adc dh,0x49");
    ch = ch - bl;
    asm("fnclex");
    bh = ~bh;
    goto L00401041;
    asm("adc [ecx],al");
    *(edx + -754201813) = *(edx + -754201813) + ebp;
L00401170:
    esi = esi + edx + ebx;
    ecx = ecx + 1;
    ecx = ecx | edx ^ esi ^ ebx;
    edi = edi | ebx;
    esi = esi | edx;
    goto L004010be;
    *eax = *eax + cl;
    *(edx + -402128385) = *(edx + -402128385) & ch;
    *(eax + eax) = ecx;
    asm("popa");
    if(!( *(ecx + 54) = *(ecx + 54) + ah)) {
        ah = *%gs:ebp+0x65];
        (save)ebx;
        asm("popf");
        *(esi + 118) :: 1406012674;
        asm("popf");
        asm("Unknown opcode 0x8e");
        (save)cs;
        asm("%g jl 0x40119d");
        *esi & ebp;
        asm("adc eax,0x7a6565e5");
        eax = eax - -30522610;
        asm("in eax,0x65");
        asm("%g popa");
        asm("%g popa");
        eax = eax + -304775815;
        asm("jecxz 0x40119d");
        dl = dl << 1;
        asm("%g inc ebx");
        asm("xchg eax,ebp");
        asm("lds esp,[ebp+0xbc5d6565]");
        asm("fsubr qword [edx]");
        asm("int 0xe5");
        asm("%g wait");
        asm("ror byte [esi+0xc2632edb],cl");
        asm("%g jns 0x401244");
        eax = eax & -756719007;
        esp :: edx;
        *ebx = *ebx << cl;
        asm("%c dec edi");
        asm("lds esp,[ebp+0x65]");
        *edx = *edx >> cl;
        asm("Unknown opcode 0x67");
        asm("Unknown opcode 0xc7");
        eax = eax | 221078254;
L004011f9:
        edx = edx + 1;
        asm("daa");
        asm("aad 0x18");
        asm("%g lahf");
        asm("iret");
        asm("xchg esi,[0x2eda7bc0]");
        asm("Unknown opcode 0x8d");
        asm("lds esp,[ebp+0x65]");
        asm("in eax,0x36");
        if(eax = eax + -1322963499) {
            goto L004011f9;
        }
        eax = eax & -2111826589;
    }
    asm("%g lahf");
    edi = -102503300;
    if(!(esp = esp - 1)) {
        asm("lds esp,[ebp+0x65]");
        asm("Unknown opcode 0x65");
        asm("Unknown opcode 0xc7");
        asm("retf");
        cl = 178;
    }
    (save)cs;
    (save)cs;
    ecx = 242 - *edx;
    asm("aas");
    *esi = *esi & ch;
    asm("int 0x5");
    asm("bound esp,[%gs:0x7ed67e61]");
    asm("lds ecx,[edi+0x621e0e7b]");
    asm("%g popa");
    ebp = ebp | *edx;
    asm("int 0x62");
    asm("%g wait");
    asm("ror byte [esi+0x92808dd5],cl");
    asm("popf");
    *esi = *esi - 172;
    asm("%g jns 0x4012be");
    asm("arpl [ebp+0x61],sp");
    *(ebp + 112) = *(ebp + 112) >> cl;
    asm("Unknown opcode 0xc5");
    asm("int 0xd2");
    if(!(dl = dl + dl)) {
        asm("Unknown opcode 0xc5");
        asm("iret");
        *(edx + 100) = *(edx + 100) >> cl;
        asm("adc bl,[edx+0x2bd2e80]");
        asm("%g popa");
        >= ? L004012db : ;
        eax = eax & -761592478;
        ss = ebp;
        ecx = edx + 1130708699;
        (restore)es;
        asm("ror byte [edx],cl");
        asm("adc eax,0x65656121");
        asm("%d add eax,0x2cd435ee");
        asm("in eax,0xf9");
        asm("in al,dx");
        asm("in eax,0xf9");
        asm("%c and eax,ebp");
        asm("%g jnl 0x401321");
        if(!(ebp = ebp | esp)) {
            asm("adc bl,[ebp+0x19cd28a]");
            asm("popa");
            asm("lahf");
            ah = *(ecx - 97);
            ebx :: 0;
            (save)cs;
            al :: 37;
            asm("Unknown opcode 0x65");
            asm("Unknown opcode 0x65");
            asm("Unknown opcode 0xdb");
            (save)cs;
            asm("lodsd");
            eax = eax & -304978587;
            asm("%c sub al,0x65");
            asm("bound edi,[%gs:ecx+0x65]");
            asm("in eax,0x25");
            asm("%s add eax,0x86030a2d");
        }
L004012ce:
        asm("aas");
        *(ebx + 1671238371) = *(ebx + 1671238371) & esi;
        asm("Unknown opcode 0xc7");
        asm("retf");
        asm("pusha");
        asm("lahf");
        asm("loop 0x40130f");
        asm("std");
        al = al + 97;
        bh = bh ^ cl;
        al = al & 114;
    }
    asm("int1");
    if(al = al + 97) {
        goto L004012ce;
    }
    return(al & 26);
}

/* DEST BLOCK NOT FOUND: 004014ee -> d2a57a18 */
stack space not deallocated on return
/*	Procedure: 0x004012EE - 0x0040189C
 *	Argument size: 31511
 *	Local size: 0
 *	Save regs size: 0
 */

L004012EE()
{



    asm("xchg eax,ebp");
    asm("int1");
    ah = ah + *(ebp + 101);
    asm("fsubr qword [esi]");
    asm("xchg eax,edx");
    asm("%g popa");
    asm("sbb bl,0xbb");
    (restore)esp;
    asm("rcr byte [ebp+0xf87dc562],cl");
    asm("rcr byte [ebx+0x615b2e62],cl");
    asm("popa");
    asm("popa");
    if(!(eax = eax & -1915395743)) {
        >= ? L00401376 : ;
        asm("%g popa");
        asm("rcr byte [ebp+0x9d0680],cl");
        asm("aad 0xd");
        al = al & *esi;
        asm("popf");
        asm("loop 0x4012f9");
        asm("loop 0x40138c");
        ebx = ebx + 1;
        asm("xchg eax,ebp");
        (save)cs;
        asm("rcr byte [ebp+0x2e22e00],cl");
        asm("bound eax,[%gs:0x9f617be5]");
        asm("arpl [edx+0x927be29d],dx");
        asm("popf");
        asm("bound edi,[ebx+0x3e]");
        asm("popa");
        if(ah = ah + *(ebp + 101)) {
            goto L004013ba;
        }
        (restore)ebp;
        >= ? 0x40134c : ;
        (save)cs;
        asm("loop 0x4013a1");
        *(ebx + 14) = (frestore) - *(ebp + -2004982427);
        asm("wait");
        edx = edx + 1;
        *%cs:ebp+0x75056565] = *%cs:ebp+0x75056565] << 97;
        eax = eax & -755466811;
        asm("jpe 0x4013e5");
        asm("adc bl,[edx+0x8c9f618c]");
        asm("%g push cs");
        asm("sahf");
        *edi = *esi;
        edi = edi + 4;
        esi = esi + 4;
        asm("adc bl,[%gs:ebp+0x425e2e0c]");
    }
    asm("%g popa");
    asm("%s in eax,0x79");
    asm("arpl [edx+0x75],sp");
    asm("loop 0x4013ef");
    asm("wait");
    asm("ror byte [esi+0x9fd25cbb],cl");
    asm("Unknown opcode 0x62");
    asm("rol byte [eax+0x2e],cl");
    asm("das");
    asm("lds esp,[ebp+0x65]");
    if(!(cl = cl - ch)) {
        >= ? 0x4013fe : ;
        asm("lds edi,[%ss:ebp-0x8]");
L004013a0:
        asm("popa");
        > ? L0040138b : ;
        asm("Unknown opcode 0xdb");
        (save)cs;
        asm("cmpsb");
        eax = eax + 1;
        asm("popa");
        asm("popa");
        asm("Unknown opcode 0xdc");
        asm("rcr byte [edx+0xc9bd28c],cl");
        asm("rcr byte [ebp+0x8fd22a8a],cl");
        asm("aad 0x4d");
        asm("arpl [esi],bp");
L004013ba:
        asm("%g in eax,0xe5");
        if(*(edx + 101) = *(edx + 101) | eax) {
            goto L0040143c;
        }
        (save)cs;
        esp :: *(ebp + -717003419);
        asm("lahf");
        edx = edx + 1;
        asm("%g xlatb");
        eax = eax & 241399581;
        eax :: 593847717;
        eax = eax | -1790746401;
        asm("Unknown opcode 0xc6");
        *edi = *esi;
        edi = edi + 4;
        esi = esi + 4;
        asm("%c jl 0x4013ab");
        asm("%g push cs");
        asm("arpl bp,ax");
        asm("Unknown opcode 0x65");
        asm("Unknown opcode 0x65");
        asm("Unknown opcode 0xc6");
        goto L00006365;
        asm("arpl [ebx+0x62],sp");
        asm("popa");
        eax = eax & 1702789349;
    }
    asm("%g push ebx");
    asm("popf");
    *(esi + 123) :: 227;
    *(bp + di - 99) = ss;
    cl = *(edx + -1885514870);
    if(*(esi - 118) = *(esi - 118) + bh) {
        goto L004013a0;
    }
    cl = *(edx + 261968778);
    <= ? L00401483 : ;
    ah = *(ebp + 101);
    (save)ebx;
    asm("popf");
    (save)cs;
    asm("%c pop edi");
    al = *L62796161;
    asm("arpl [%ss:ecx+0x75],sp");
    != ? 0x401449 : ;
    asm("%g inc ebx");
    asm("xchg eax,ebp");
    asm("aam 0x42");
    asm("xchg esi,[%gs:0xd8da7bc0]");
L0040143c:
    asm("in eax,dx");
    ebx = ebx + 1;
    asm("xchg eax,ebp");
    ah :: *(ebp + 1523737957);
    asm("stc");
    asm("Unknown opcode 0xc5");
    asm("int 0x1c");
    (save)1523743458;
    asm("in al,0xc5");
    asm("int 0xd2");
    asm("in eax,0x72");
    asm("xchg ah,[%cs:ebp+0x25626565]");
    asm("in eax,0x79");
    asm("popa");
    if(!(ebx = ebx + 1)) {
        asm("arpl [ebp-0x44],bx");
        cl = cl - ch;
        asm("loop 0x4014cf");
    }
    asm("wait");
    asm("ror byte [esi+0xe29fd271],cl");
L00401470:
    asm("rcl byte [eax+0x75378062],cl");
    asm("Unknown opcode 0xc7");
    asm("in al,dx");
    if(!(2122130789 = *%cs:0x65256565] * esp)) {
        >= ? 0x401489 : ;
        (save)cs;
        asm("cmpsb");
        if(*(ebp + 101) & esp) {
            goto L00401470;
        }
        asm("Unknown opcode 0xc6");
        asm("cmc");
        *edi = eax;
        edi = edi + 4;
        asm("jpo 0x4014a2");
        asm("%f movsd");
        asm("%g popa");
        ebp = ebp | *edx;
        asm("int 0xe5");
        asm("%g wait");
        asm("%c inc esp");
        *edi = *esi;
        edi = edi + 4;
        asm("%g in eax,0x5");
        asm("popa");
        if(!(esi = esi + 4)) {
            asm("rcr dl,cl");
            asm("in eax,0xd5");
            asm("Unknown opcode 0x2e");
        }
        asm("Unknown opcode 0x62");
        bh = bh >> cl;
        asm("aad 0x4d");
        asm("bound ebp,[esi]");
        (save)esp;
        asm("lds esp,[ebp+0x65]");
        ebx = ebx + 1;
        (save)6833061;
        cl = 21;
        asm("outsb");
        asm("popa");
        ebx = ebx + 1;
        cl = 45;
        (save)cs;
        asm("loop 0x40149e");
        ch = ch + al;
        asm("xchg eax,ebp");
        asm("adc ch,al");
        asm("Unknown opcode 0x65");
        asm("Unknown opcode 0x65");
        asm("Unknown opcode 0xc5");
        (fsave)(frestore) + st5;
        asm("bound ebp,[esi]");
        asm("sahf");
        asm("lds esp,[ebp+0x65]");
        if(ebx = ebx + 1) {
            goto L00401502;
        }
        >= ? L00401544 : ;
        >= ? 0x40155a : ;
        eax = eax & 734344732;
    }
    goto Ld2a57a18;
    asm("popf");
    asm("Unknown opcode 0x62");
    asm("rcr byte [edx+0x639bd2e2],cl");
    (restore)es;
    asm("bound ebp,[esi]");
    if(!(al = eax - -1038432819 - *(ebx - 107))) {
        asm("popa");
        asm("popa");
L00401502:
        >= ? 0x401566 : ;
        asm("arpl [%ss:esi],si");
        asm("rcl byte [eax+0x5d36ef62],cl");
        cl = cl - ch;
        asm("bound esp,[ebp-0x65]");
        asm("ror byte [esi+0xd25cbbdb],cl");
        asm("loop 0x40154a");
        (save)esp;
        edx = edx + 1;
        asm("bound esi,[%gs:ebp+0x79]");
        eax = eax & -1845150107;
        asm("popf");
        asm("popf");
        asm("Unknown opcode 0x8f");
        asm("jpo 0x4015ae");
        if(*(ebx - 110) = *(ebx - 110) + bh) {
            goto L0040158f;
        }
        >= ? 0x401535 : ;
        (save)cs;
        eax = eax ^ 778397157;
        esi = 1969579269;
        != ? 0x4015ba : ;
        != ? 0x401548 : ;
        asm("in eax,0xdb");
        (save)cs;
        >= ? L00401588 : ;
        asm("popa");
        asm("popa");
        asm("pusha");
        asm("popf");
        ch = ch & 101;
        goto ( *gs);
        (save)cs;
        *L2E616161 = al;
        asm("mul dword [0x9f616565]");
    }
    *(ebx + 97) :: -382825569;
    eax = eax & 912483685;
    asm("arpl si,bp");
    dl :: 0;
    asm("cmpsd");
    (fsave)(frestore) * st7;
    ebx = ebx + 1;
    asm("xchg eax,ebp");
    asm("%g pop ebp");
    esp = -489870628;
    asm("%g wait");
    asm("ror byte [esi+0x6525992e],cl");
    asm("arpl [%gs:ebp+0x7d],di");
    if(eax < *(edx + 101)) {
L0040158f:
        asm("rcr byte [edi+0x6290d2e2],cl");
        asm("out dx,eax");
        (save)93;
        esp = 1709362474;
        asm("wait");
        asm("ror byte [esi+0xd20dc75c],cl");
        eax = L00006161();
        eax = eax & 1634067813;
        asm("arpl [ebp+ebp-0x14],cx");
    }
    asm("in eax,0xf9");
    ebx = ebx + 1;
    asm("out dx,al");
    goto L00401609;
    asm("sbb al,[0x61807a2e]");
    asm("popa");
    asm("bound esi,[ebp+0x75]");
    if(!(eax = eax - 1291445740 - -1842483645)) {
        asm("popa");
        asm("fcomp dword [ebp+0xd2229f62]");
        eax :: -985649564;
        asm("%g out dx,al");
        asm("in eax,0xd2");
        asm("lds esp,[ebp+0x65]");
        if(eax = eax & edi | -298914856) {
            goto L00401653;
        }
        asm("bound ecx,[%ss:esi]");
        ch = ch - ah;
        asm("%g jpo 0x4015e6");
        asm("wait");
        asm("ror byte [esi+0x9ad25cbb],cl");
        asm("arpl si,bp");
        asm("xchg eax,edx");
        eax = eax + 603940150;
        asm("popa");
    }
L00401609:
    asm("lahf");
    asm("punpcklwd mm3,[edi+0x819f618f]");
    asm("Unknown opcode 0xdb");
    (save)cs;
    edx = 308635077;
    asm("popf");
    asm("%c inc ebp");
    asm("popa");
    asm("popa");
    asm("popa");
    if(!( *(ecx - 97) = *(ecx - 97) & -2120261376)) {
        eax = eax & 19756517;
        ebx = ebx + 1 + 1;
        (save)-1708255902;
        al :: 101;
        asm("%g ret 0x432a");
        asm("xchg eax,ebp");
        (save)eax;
        asm("loopne 0x40169e");
        asm("popa");
        asm("adc bl,[ebp+0x19dd201]");
        asm("les esp,[%cs:eax+0x7d756161]");
        eax = eax + 319710526;
        asm("lds esp,[ebp+0x65]");
L00401653:
        asm("adc bl,[ebp+0x19cd28b]");
        asm("Unknown opcode 0xc5");
        (fsave)(frestore) / st0;
        asm("adc eax,0x650579ed");
        asm("%g rcr ah,cl");
        asm("loop 0x40162b");
        asm("pushf");
        al = al | 97;
        asm("lahf");
        fs = *(ecx - 97);
        asm("sbb ebx,0x65858b0e");
L00401671:
        asm("%g pusha");
        asm("popf");
        asm("%g out dx,al");
        asm("adc bh,[ebp+0x7d]");
        if(*(edx + 101) = *(edx + 101) & 101) {
            goto L004016e2;
        }
        != ? 0x4016e4 : ;
        eax = eax + 1701123734;
        asm("%g jnz 0x40168a");
    }
    return;
    asm("xchg esp,[ebp+0x65]");
    asm("%g jnz 0x40170d");
    asm("popa");
    asm("lahf");
    *esi = *esi | 212;
    asm("lds esp,[ebp+0x65]");
    asm("%c insb");
    asm("lds ebx,[ebp+0x85ed2e62]");
    asm("%g jnz 0x4016ae");
    asm("bound edi,[ebp+0x5]");
    if(*(ebp + 101) & esp) {
        goto L00401671;
    }
    (restore)ds;
    return;
    (save)cs;
    ch = ch & al;
    asm("%g popa");
    edx = edx | *(edx + -1837428835);
    asm("popf");
    asm("Unknown opcode 0x8f");
    asm("jpo 0x401700");
    asm("%c outsb");
    asm("ror byte [esi+0x6575657e],cl");
    asm("%g xchg eax,edx");
    asm("popf");
    asm("loop 0x401755");
    asm("xchg eax,edx");
    asm("popf");
    asm("bound edi,[ebx+0x3e]");
    asm("popa");
    if(!(eax = eax + 1635083621 & 624354614)) {
L004016e2:
        (restore)ebp;
        >= ? 0x4016e6 : ;
        (save)cs;
        asm("loopne 0x40174f");
        asm("popa");
        if(!(esp = esp - *L9A2E6565)) {
            asm("%g and eax,0xa332859f");
            ebp = -940717277;
            bl = bl - *L6505DE2E;
            asm("%g in eax,0x36");
            asm("arpl [ebp+0x65],si");
            asm("loop 0x40178a");
            if(eax = eax + -1621001435) {
                goto L00401783;
            }
            (restore)ebp;
            >= ? 0x401715 : ;
            (save)cs;
            esp = ebp;
            (restore)ebp;
            eax = eax & -1132567195;
            esp = eax + 78;
            asm("jpo 0x40172e");
            asm("repne lds esp,[ebp+0x65]");
            asm("popa");
            asm("bound edi,[esi+0x72]");
            (restore)ebp;
            if(!(esp = esp | *(ecx - 97))) {
                (save)cs;
            }
            < ? L00401756 : ;
            asm("%c add al,0x25");
            asm("%g jnz 0x4017b3");
            asm("%g arpl bp,sp");
            edi = edx;
            eax = eax & 1696967438;
            asm("Unknown opcode 0x65");
            asm("Unknown opcode 0xdf");
            edi = edi - 1;
            asm("Unknown opcode 0xc7");
            cl = cl - *esi;
            ah = *LD5436565;
            asm("rep and byte [ecx+0x61],0xc7");
        }
    }
    asm("popa");
    if(!(eax = eax | 1635810862)) {
        asm("popa");
        asm("Unknown opcode 0xc6");
        asm("popf");
        ebp = ebp + eax;
    }
    asm("popf");
    asm("in eax,dx");
    (save)cs;
    asm("aam 0xc5");
    asm("rcr byte [%gs:ebp+0xc50ad201],cl");
    while(al = al | 123) {
    }
    *(ebp + 102) = *(ebp + 102) >> cl;
    asm("lds ebp,[0x610b9d12]");
    asm("lahf");
    (save)cs;
    asm("popa");
L00401783:
    asm("arpl [ebp+0x65],si");
    asm("popa");
    asm("rcr byte [%gs:edx+0x639bd2e2],cl");
    asm("%c wait");
    al = *L1BF66161;
    cl = cl ^ dl;
    if(!(al = al - *%cs:eax+0x61])) {
        return;
        asm("retf 0xacb");
        asm("sbb [%cs:eax+0x75616161],ah");
        if(eax = eax & 839764810) {
            goto L0040180f;
        }
        >= ? L0040182c : ;
        asm("%s aad 0x8d");
        asm("sbb bl,0xbb");
        (restore)esp;
        asm("rcr byte [edx+0x92f8dcc5],cl");
        asm("aam 0x75");
        asm("%g rol ah,cl");
        return;
        asm("cmc");
    }
    asm("popa");
    asm("popa");
    asm("lds ebx,[edx+0x6120ef2e]");
    asm("popa");
    asm("rcr ch,cl");
    asm("loop 0x401806");
    ebp = -446339835;
    asm("%g in eax,0x53");
    asm("popf");
    *(ecx - 33) = fs;
    if(eax < 0) {
        asm("Unknown opcode 0xdf");
        asm("in al,0x61");
        *(eax + 97) = (frestore);
        asm("Unknown opcode 0xdf");
        asm("in al,0x61");
        asm("Unknown opcode 0xdf");
        asm("in al,0xe");
        asm("sti");
        eax = eax & 1997432165;
        asm("in eax,0x65");
        asm("%g push cs");
        asm("loope 0x401804");
        asm("adc bl,[%gs:ebp+0x654c2e01]");
        asm("%g popa");
        asm("bound esi,[ebp+0x5]");
        asm("in eax,0x75");
L0040180f:
        asm("%g push cs");
        *(eax + -1654627999) = *(eax + -1654627999) & 1701143424;
        asm("%g inc ebx");
        asm("cmc");
        101 = *(ebp + 101) * esp;
        asm("popa");
        asm("lahf");
        *esi = *esi + ecx;
        asm("sbb [0x9f616565],esp");
        *(ecx - 97) = fs;
L00401830:
        (save)eax;
        asm("in eax,0x65");
        asm("rcr byte [%gs:ebx+ecx*4+0x92f8dcc5],cl");
        (fsave)(frestore) - *(ecx - 33);
        if(*esi = *esi + ecx) {
            goto L00401830;
        }
        asm("xchg eax,esp");
        != ? 0x40187b : ;
        asm("%g arpl bp,sp");
    }
    eax = eax + 625857860;
    asm("aad 0x2e");
    eax = eax & -1790760254;
    asm("adc [eax+0xdcc56161],eax");
    asm("in eax,0xd5");
    ch = ch << 1;
    asm("bound eax,[ebx+0x52]");
    asm("std");
    *(ecx + 97) = *(ecx + 97) & 46;
    (restore)ecx;
    eax = eax & 1630954853;
    asm("%g jnz 0x40187d");
    (save)esi;
    (save)cs;
    *LCF3F6565 = *LCF3F6565 | eax + 717448549;
    asm("in eax,dx");
    asm("Unknown opcode 0xc6");
    asm("lock stc");
    asm("o16 adc dh,al");
    asm("stc");
    asm("in al,0x11");
    cl = cl - ch;
    asm("bound esp,[ebp-0x2e]");
    L0000e3f5();
    eax = eax & -1697094299;
    asm("loop 0x4018dc");
    asm("cmc");
}

/*	Procedure: 0x0040189D - 0x00401953
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040189D()
{



    asm("lds ebx,[%gs:edx+0x52e08ee]");
    *(ecx + 97) = *(ecx + 97) & 121;
    asm("%s jnl 0x401929");
    if(!(eax = eax + 1698575997)) {
        (restore)ebp;
        >= ? 0x4018b7 : ;
        (save)cs;
        asm("%g add eax,0xb77e6565");
        asm("popa");
        asm("stc");
        asm("Unknown opcode 0xc7");
        asm("jpo 0x4018d0");
        asm("into");
        do {
            asm("xchg eax,edx");
            asm("popf");
            asm("Unknown opcode 0x8f");
            asm("jpo 0x40194b");
            if(eax = eax + 190932325) {
                goto L0040192c;
            }
            >= ? 0x4018d2 : ;
            (save)cs;
            ebp = 2036688133;
        } while(eax = *L7E656565 - 774835366);
        asm("Unknown opcode 0x65");
        asm("Unknown opcode 0x62");
        asm("in eax,0x25");
        asm("int1");
        do {
            asm("rol byte [edx+0x65656567],cl");
            asm("adc bl,[0x8c9f6162]");
            asm("popa");
            asm("lahf");
            *esi = *esi + ecx;
            *(eax + -1663934111) = eax;
            eax = ebp;
            (fsave)(frestore) / st0;
            asm("popa");
            asm("Unknown opcode 0xdf");
            asm("sti");
            asm("popa");
            asm("lahf");
            esp = *(ecx - 97);
            *esi = *esi + ecx;
            *%cs:ecx+0x61] = *%cs:ecx+0x61] & 67;
            (save)-317348390;
            *(ebp + 101) = *(ebp + 101) + ah;
            asm("%c clc");
        } while(eax = eax + 1698063717);
        asm("popf");
        asm("bound edi,[ebx+0xe]");
    }
    asm("fnstsw ax");
    asm("popa");
    asm("popa");
    asm("adc bl,[ebp+0x65d8d580]");
L0040192c:
    goto ( *ebp);
    asm("rol bh,cl");
    asm("out dx,al");
    asm("Unknown opcode 0xc5");
    asm("rcr bh,cl");
    asm("arpl bp,ax");
    asm("lahf");
    asm("Unknown opcode 0x62");
    asm("rcl al,cl");
    asm("arpl bp,ax");
    asm("bound ebp,[esi]");
    edi = edi + 1;
    asm("lds esp,[ebp+0x65]");
    asm("%c pop eax");
    al = *L7D256161;
    asm("popa");
    asm("%g jng 0x4019b3");
    asm("retf");
}

/*	Procedure: 0x00401954 - 0x00401D22
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401954()
{



    asm("Unknown opcode 0xfe");
    asm("adc [ebx+0xe],bh");
    asm("sti");
    eax = eax + 190932325;
    asm("rcr byte [ebp+0x62cd2a80],cl");
    asm("%g wait");
    asm("ror byte [esi+0xdb008dd5],cl");
    ebx = 1696986158;
    asm("arpl [%gs:0xa195437d],sp");
    asm("%g popa");
    asm("lahf");
    (save)cs;
    asm("popa");
    asm("lahf");
    ecx = *esi;
    ecx = -765106747;
    eax = L0000fdd2() + 774751590;
    ebx = ebx + 1;
    *(ecx + 97) = *(ecx + 97) & ah;
    asm("arpl [ebp+0x75],si");
    asm("%g popa");
    asm("Unknown opcode 0xdf");
    asm("stc");
    asm("popa");
    asm("fbld tword [edx+0x7b]");
    (save)cs;
    ecx = ecx - 1;
    *(ecx + 97) = *(ecx + 97) + ah;
    asm("sbb al,0xd5");
    asm("in eax,dx");
    asm("o16 sbb al,dl");
    asm("lodsd");
    asm("in eax,0x7d");
    if(!(ch = ch - dh)) {
        asm("Unknown opcode 0x36");
        asm("Unknown opcode 0x62");
        asm("fsubr qword [edx]");
        asm("int 0x62");
        asm("%g wait");
        asm("ror byte [esi+0x83d2f1db],cl");
        *%gs:bp+di] = *%gs:bp+di] >> cl;
        asm("loop 0x40199c");
        asm("int3");
        asm("aad 0xed");
        asm("loop 0x4019fd");
        asm("jecxz 0x4019d1");
        asm("popa");
        asm("popa");
        asm("bound esi,[ebp+0x63]");
        asm("%s jnl 0x401a56");
        ebx = ebx + 1;
        asm("xchg eax,ebp");
        eax = eax & *eax;
        asm("popa");
        asm("popa");
        asm("fsubr qword [edx]");
        asm("int 0xe5");
        asm("%g wait");
        asm("ror byte [esi+0x657e7d3e],cl");
        asm("%g a16 xchg eax,edx");
        asm("popf");
        asm("loop 0x401a6d");
        asm("%g xchg eax,edx");
        asm("popf");
        asm("bound edi,[ebx+0x2e]");
        (save)ebx;
        eax = eax & 2038261093 & 2033596029;
        (save)eax;
        eax = eax & -762110691;
        asm("lodsd");
        asm("xlatb");
        eax = eax + -966733125;
        asm("pxor mm1,[ecx+0xa0b92ebc]");
        asm("popa");
    }
    asm("popa");
    asm("popa");
    asm("popa");
    if(!(eax = eax & -2134167861)) {
        >= ? 0x401aa2 : ;
        asm("bound edi,[ebx+0xe]");
        asm("cmc");
        asm("%g popa");
        edx :: 0;
        asm("popf");
        asm("Unknown opcode 0x0f");
        cl = cl - ch;
        asm("in eax,0x65");
        asm("wait");
        asm("%s add eax,0x75256565");
        eax = eax & 2037998201;
        asm("popa");
        edx :: 0;
        asm("popf");
        asm("loop 0x401ab0");
        asm("wait");
        asm("ror byte [esi+0x3e629f61],cl");
        asm("popa");
        asm("%c mov al,0x61");
        asm("popa");
        asm("arpl [%ss:ecx+0x2e],sp");
        asm("cli");
        asm("popa");
        asm("popa");
        asm("popa");
        asm("sbb edx,edx");
        asm("fucom st3");
        asm("lds ebx,[ebp+0xe2dad28b]");
        asm("lds ebx,[edx+0x63df6101]");
        asm("jpo 0x401a8d");
        (save)cs;
        eax = eax ^ -765369888;
        asm("fucom st2");
        asm("lds ebx,[ebp+0x61042e01]");
        asm("popa");
        asm("popa");
        if(*edx = *edx - 205) {
            goto L00401ae9;
        }
        asm("bound eax,[0xc5790561]");
    }
    asm("int 0xee");
    ebp = ebp & esi;
    eax = eax & -719581753;
L00401a8f:
    ebp = ebp - 1;
    asm("in eax,0x1d");
    asm("fcomp dword [edx+0x66354380]");
    eax = eax + -1134729883;
    asm("arpl [%cs:ecx+0x61],sp");
L00401aa5:
    asm("popa");
    asm("%s add eax,0x2adcbc5d");
    asm("int 0x62");
    asm("%g wait");
    asm("ror byte [esi+0x61009d2e],cl");
    asm("popa");
    asm("in eax,0x63");
    asm("punpcklwd mm3,[edi+0x9d9262]");
    asm("jpo 0x401b46");
    if(!(eax = eax + -1915384110)) {
        >= ? 0x401acd : ;
        (save)cs;
        asm("into");
        asm("popa");
        asm("popa");
        if(eax = eax + 1) {
            goto L00401a8f;
        }
        esp = eax + 78;
        asm("jpo 0x401ae6");
        esp = *(ecx + 97);
        asm("popa");
        asm("popa");
        ebp = ebp | *esi;
        eax :: 912351680;
        asm("in eax,0x79");
        asm("%d jnl 0x401b4a");
L00401ae9:
        asm("lahf");
        *(ecx - 97) = fs;
        *esi = *esi + ecx;
        al :: 96;
        asm("popa");
        asm("popa");
        asm("popa");
        asm("lahf");
        *(ecx - 97) = fs;
        *(ecx - 97) = *(ecx - 97) + esp;
        asm("popa");
        asm("popa");
        asm("%c jno 0x401a84");
        asm("popa");
        asm("popa");
        if(al = (al | 14) + (al | 14)) {
            goto L00401b36;
        }
        eax :: *(eax + 1667588449);
        eax = eax & -152739274;
        (save)cs;
        asm("loope 0x401af6");
        asm("popa");
        asm("popa");
        asm("cwde");
        asm("%g nop");
        asm("%g inc ebx");
        asm("aad 0xe1");
        asm("popa");
        asm("popa");
        if(eax = eax + 1) {
            goto L00401aa5;
        }
        *(ebx - 43) & eax;
    }
    asm("in al,dx");
    eax = eax + 1;
    asm("popa");
    asm("popa");
    asm("aad 0x0");
    (save)ecx;
    eax = eax | *%cs:eax+0x61];
    asm("popa");
    asm("%s add eax,0xe249fe5");
L00401b36:
    al & 224;
    asm("popa");
    asm("popa");
    asm("%c dec ebp");
    eax = eax + 1;
    asm("popa");
    asm("popa");
    asm("imul byte [ebx]");
    (save)cs;
    ebx = ebx + 1;
    asm("cmc");
    (restore)es;
    al = *L2AC36161;
    asm("%c xlatb");
    eax = eax + 1;
    asm("popa");
    asm("popa");
    asm("adc edi,[edx+0x2d]");
    *(edx - 18) = *(edx - 18) + esp;
    *esi = *esi | dh;
    asm("in eax,0x63");
    asm("bound edi,[ecx+0x7e]");
    asm("%g jnl 0x401bc8");
    asm("%g adc bh,dl");
    asm("stc");
    eax = eax | 234486418;
    asm("sbb edx,[edx]");
    asm("sti");
    asm("stc");
    eax = eax | 234486674;
    asm("popa");
    asm("jpo 0x401bf8");
    if(edi >= *esi) {
        >= ? 0x401b7f : ;
        (save)cs;
        >= ? 0x401bc1 : ;
        asm("popa");
        asm("popa");
        <= ? L00401b5b : ;
        <= ? L00401b4c : ;
        asm("Unknown opcode 0x8f");
        asm("jpo 0x401bb8");
        asm("int1");
        *(ecx + 97) = *(ecx + 97) << 99;
        asm("popa");
        asm("popa");
        != ? 0x401bf4 : ;
        asm("Unknown opcode 0x62");
        asm("out dx,eax");
        ebp = eax;
        asm("lahf");
        asm("adc ch,0xce");
        asm("ror dl,cl");
        asm("out dx,eax");
        *esi = ebp;
        if(ah = ah & *(eax - 52)) {
            goto L00401c05;
        }
        asm("popa");
        asm("popa");
        asm("rcr byte [edx+0x2e89efe2],cl");
        asm("lock pusha");
        asm("popa");
        asm("popa");
        asm("adc [%cs:eax+0x61],esp");
        asm("popa");
        asm("arpl [ebp+0x36],di");
        >= ? 0x401ba0 : ;
        eax = eax & -493038875;
        asm("Unknown opcode 0xc7");
        ch = ch - *esi;
        97 = *(eax + 97) * eax;
        asm("sbb edx,edx");
        *L0DC7CAC5 = al;
        asm("%c cld");
        *(ecx + 97) = *(ecx + 97) + ah;
        eax = eax - 86458893;
        asm("sbb eax,0x61001b2e");
    }
    asm("popa");
    asm("in eax,0x63");
    eax = eax & -444767901;
    asm("ror byte [esi+0x928f8dd5],cl");
    asm("popf");
    *(ebx + 21) :: 144;
    asm("loop 0x401c53");
    asm("popa");
    asm("%g push eax");
    asm("loop 0x401c39");
    asm("%c cdq");
    asm("loopne 0x401c61");
    asm("popa");
    asm("%g xchg eax,edx");
    asm("popf");
L00401c05:
    asm("Unknown opcode 0x8f");
    asm("%c popa");
    *(ecx + 97) = *(ecx + 97) << 37;
    if(!(ah = ah & *(ecx - 97))) {
        (restore)esp;
        asm("rcr byte [ebp+0xe39dc6e2],cl");
        asm("adc bl,[ebp+0x9d12e2]");
        != ? 0x401bad : ;
        asm("arpl [ebp+0x43],sp");
        asm("cmc");
        asm("bound esp,[eax+0x61]");
        asm("popa");
        ebx = ebx + 1;
        bh = 157;
        asm("arpl [edx],dx");
        asm("popf");
        asm("adc dl,0x9f");
        asm("Unknown opcode 0x62");
        asm("rol byte [eax+0x43],cl");
        ebp = ebp + *esi;
        ebx = 155;
        asm("%g add eax,0x79622563");
        eax = eax & -591635103;
        cl = cl - ch;
        asm("arpl [ebp-0x65],sp");
        asm("ror byte [esi+0xe29ad2db],cl");
        asm("rcr byte [edx+0x614ff32e],cl");
        asm("popa");
        asm("rcr byte [ebp+0x61ab8763],cl");
        asm("popa");
        asm("popa");
        if(eax = eax & *(edi + 1632599598)) {
            goto L00401ccc;
        }
        asm("%g add eax,0x257d9236");
        asm("jpo 0x401cd0");
        asm("lahf");
        *esi = *esi | 105;
L00401c71:
    }
    al = *LD5D66161;
    eax = -443202715;
    *(ecx + 97) = *(ecx + 97) << 46;
    (restore)ecx;
    asm("scasd");
    asm("popa");
    asm("popa");
    if(eax = eax & 91583869) {
        goto L00401c71;
    }
    asm("%d popa");
    <= ? L00401d02 : ;
    (restore)ebp;
    >= ? 0x401c94 : ;
    (save)cs;
    asm("fldenv [eax+0xb17e6161]");
    asm("Unknown opcode 0xdb");
    eax = (eax & -2112980163) + 1;
    asm("popa");
    asm("popa");
    asm("popa");
    edx :: 0;
    asm("popf");
    asm("bound ebp,[edx]");
    asm("int 0x62");
    asm("%g wait");
    asm("%c test al,al");
    asm("popa");
    asm("popa");
    asm("arpl [esi],si");
    asm("arpl [ecx+0x63],di");
    asm("int1");
    asm("rol byte [edi+0xd2656565],cl");
    asm("fsubr st2");
    asm("rcr bl,cl");
    asm("loop 0x401c97");
    asm("Unknown opcode 0xdf");
    asm("loop 0x401cb6");
    *esi & ebp;
    *(ecx - 1 + 97) = *(ecx - 1 + 97) + ah;
L00401ccc:
    *(ebp + 1131075812) = *(ebp + 1131075812) >> cl;
    asm("xchg eax,ebp");
    asm("adc al,0x0");
    asm("popa");
    asm("popa");
    asm("popa");
    asm("lahf");
    asm("bound edx,[ebx-0x43]");
    asm("%f popa");
    asm("lahf");
    asm("arpl [ebx-0x43],dx");
    asm("in al,0x2e");
    ch = 0;
    asm("popa");
    asm("popa");
    eax = eax & 2100704893;
    asm("arpl [0x9cd25cbb],ax");
    asm("Unknown opcode 0x62");
    bl = bl >> cl;
    asm("Unknown opcode 0xc6");
    asm("wait");
    asm("loop 0x401cc1");
    (fsave)(frestore) / st0;
    asm("xchg eax,edx");
    asm("aam 0x9");
    asm("%g rol ah,cl");
    asm("%c push ecx");
    asm("loopne 0x401d6b");
    asm("popa");
    *%cs:0xd561614f] = eax & 1651865953;
    asm("loop 0x401d3b");
    ebx = ebx + 1;
    eax = eax ^ 1633763442;
    ch = ch >> cl;
    asm("Unknown opcode 0xc7");
    asm("retf");
}

/*	Procedure: 0x00401D23 - 0x00401D33
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D23()
{



    *edx = *edx - ah;
    asm("%g pusha");
    asm("das");
    asm("lds ecx,[eax*8+0xd2ccc52c]");
    asm("retf 0x9c2e");
}

/*	Procedure: 0x00401D34 - 0x00401F6C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D34()
{



    eax = eax + 1;
    asm("popa");
    asm("popa");
    eax = eax & 86320613 & -12539338;
    asm("adc [eax+0x2a],al");
L00401d43:
    *(esi + -497154328) = *(esi + -497154328) >> 2;
    asm("Unknown opcode 0xc7");
    dh = bh;
    eax = eax - ecx;
    dl = !dl;
    edi = ebx;
    bh = !bh;
    goto L00401f3e;
    eax = eax + 1;
    *eax = *eax + eax;
    *eax = *eax | 254;
L00401d60:
    asm("into");
    asm("adc bl,0x27");
    edi = edi + 1;
    edx = edx | ebx;
    asm("ror al,0xa");
    dh = dh - 1;
    edx = esi;
    goto L00401d91;
    *eax = *eax + edx;
    *edx = *edx + dh;
L00401d74:
    asm("lock sub dl,bl");
    ecx = ecx + -233;
    edi = edi - 1;
    bh = !bh;
    dh = dh + 1;
    edi = edi | ecx;
    esi = esi - ~dl;
    goto L00401d43;
    al = al + 32;
    *eax = *eax & dl;
    *(edx + -785654794) = *(edx + -785654794) & ch;
L00401d91:
    edx = edx + 1;
    bh = bh + 1 + 4;
    dh = dh + 8;
    al = al + 56;
    ebx = ebx - esi;
    dh = ~dh;
    ebx = ecx;
    goto L00401eb5;
    asm("adc bh,bh");
    *(eax + -746534672) = *(eax + -746534672) + 1;
L00401daf:
    asm("lahf");
    dh = edx + ebx - 1;
    ebx = ebx - 1;
    edx = edx - esi;
    edi = edi - 1;
    al = al - 138;
    bh = bh + dl + 1 - 1 ^ ah;
    goto L00401d60;
    *eax = *eax + al;
    bh = bh + bh;
    al = al + *eax;
    *(ecx + 1038371818) = *(ecx + 1038371818) + al;
L00401dd0:
    *(eax + -567066669) = eax;
    bh = 92 + esi - edi ^ cl;
    if(edx == 1992432565) {
        bh = bh - 1;
        ch = ch - al;
        ebx = ebx + 1;
        al = 243;
        goto L00401e90;
        *edi = al;
        edi = edi + 1;
        *eax = *eax & 128;
L00401dfe:
        asm("Unknown opcode 0xdf");
        asm("fdecstp");
        asm("ror byte [edx+0xfa0b42e0],cl");
        asm("sbb dh,0xdc");
        asm("adc dl,0x8d");
        dl = dl + 1;
        asm("adc dl,0x59");
        *ecx = ah;
        asm("sbb bh,0xe7");
        goto L00401e45;
        al = eax + 1 + 170 + 238;
        ch = !ch;
        asm("adc dl,0xfc");
        ecx = ecx + edx;
        edi = edi - 1;
        dh = dh + 1;
        asm("adc cl,0x7b");
        ecx = 7835732;
        (restore)ecx;
        edi = edi + esi;
        esi = esi + 1;
        bl = !L000000C4;
        ah = ah - 1;
        goto L00401f08;
        *eax = *eax | 170;
        *edx = *edx | al;
L00401e45:
        asm("std");
        dh = dh - 1;
        asm("sbb bl,0xbf");
        edx = edx + 1;
        bh = bl;
        ecx = ecx + 1;
        bh = bh + 150;
        goto L00401eee;
        asm("adc [ecx],al");
        *eax = *eax + dl;
        *edx = *edx + cl;
L00401e5d:
        esi = esi >> 1;
        return;
        asm("sbb dl,0x9c");
        edi = edi - ecx;
        dl = dl | dh;
        asm("adc bh,0x7b");
        edi = edi ^ ebx;
        goto L00401daf;
        *(eax - 86) = *(eax - 86) + al;
        *ecx = *ecx + al;
        *eax = *eax + ecx;
    }
L00401e79:
    edi = (edi ^ ecx) - eax;
    ebx = !bh - 1;
    edx = dh + 107 - 1;
    ebx = eax;
    al = *ecx;
    goto L00401e5d;
    asm("adc bh,bh");
    *edx = *edx + 1;
    *(eax + -1022638077) = *(eax + -1022638077) + al;
L00401e90:
    ch = !ch;
    bl = !bl;
    esi = esi - eax;
    asm("adc ch,0x92");
    ah = ah - 1;
    dl = dl | dh;
    esi = esi - ecx;
    dl = ~dl;
    return(ah + 28);
    goto L00401f60;
    *eax = *eax & dl;
    al = al + *(edx + ebp * 4);
    *edx = *edx + al;
L00401eb5:
    edi = edi ^ edx | ebx;
    dh = !dh;
    bh = bh | ch;
    bl = ah;
    asm("rol al,0x15");
    bl = bl - 1;
    edi = edi | esi;
    bh = bh - 1;
    edx = edx + 1;
    dh = dl;
    asm("sbb dh,0x3d");
    goto L00401dfe;
    asm("Unknown opcode 0xff");
    *(ecx + eax) = *(ecx + eax) + 1;
L00401ed7:
    dh = dh ^ dl;
    ah = bl;
    (save)ecx;
    bl = ~(ebx - esi) - 1 ^ cl;
    al = dl;
    goto L00401d74;
    *(eax + 2) = *(eax + 2) + 1;
    dh :: 0;
L00401eee:
    asm("ror dword [edx+0xf6cafefe],cl");
    (fsave)(frestore) * *(ebx + 11);
    asm("sti");
    edi = edi + 1;
    esi = esi - 1;
    edi = edi - ~((bh | ch) + cl);
    goto L00401f20;
    *edi = al;
    edi = edi + 1;
    asm("adc bh,bh");
L00401f08:
    bh = bh - 1;
    dl = dl | al;
    ebx = ebx - 1;
    ecx = ecx - -233;
    dh = dh | bh;
    al = al - 1;
    esi = esi ^ eax;
    eax = eax - ecx;
    goto L00401ed7;
    eax = *eax();
    *edi = al;
    edi = edi + 1;
L00401f20:
    dl = dl - 1;
    asm("adc bh,0x1");
    edx = esi;
    ebx = ebx - 1 - edi;
    edi = (edi ^ ecx) - edx;
    bh = ~(((bh | dl) ^ dl) + ecx);
    goto L00401dd0;
    *edx = *edx | al;
    dh = dh + *ebx;
L00401f3e:
    asm("rol dword [ecx+0x5e0d42f6],cl");
    asm("loop 0x401f8f");
    bl = (bl + 66 | edi) + 39;
    edi = edi + eax;
    asm("sbb dh,0x1");
    ebx = edi;
    goto L00401e79;
    *edi = al;
    edi = edi + 1;
    *eax = *eax + cl;
    eax = *eax();
L00401f60:
    asm("sbb bh,0xf1");
    ecx = ecx - eax;
    ah = ~ah;
    eax = ch ^ dl;
    bl = dh;
}

/* address  size  */
/* 0x004010a4       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
