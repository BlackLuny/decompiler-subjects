// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 eax_26 = AddAce(null, 0x00, 0x00, null, 0x00);
	Eq_17 ebx_15 = null;
	word32 edi_29 = eax_26 + 0x1E;
	if (AreAllAccessesGranted(~0x00, ~0x00) == 0x00)
		edi_29 = eax_26 + 0x1E ^ 0x0E;
	CloseHandle((void *) 0x59);
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x08);
	struct Eq_49 * eax_57 = null;
	do
	{
		if (ebx_15 == edi_29)
			ebx_15 = null;
		eax_57[4199048] = (struct Eq_49) (eax_57[4199048] ^ ebx_15[0x00404000]);
		eax_57 = eax_57 + 0x01;
		ebx_15 = (Eq_17) (ebx_15 + 0x01);
	} while (eax_57 < (struct Eq_49 *) 0x1440);
	struct Eq_72 * ecx_100 = &globals->t402588;
	uint32 esi_103 = 0x00;
	uint32 dwLoc04_119 = 0x00;
	do
	{
		Eq_80 eax_105 = ecx_100->t0004;
		word16 * edx_111 = (char *) &ecx_100->t0004 + 0x04;
		if (eax_105 - 0x08 >> 0x01 > 0x00)
		{
			uint32 edi_269 = eax_105 - 0x08 >> 0x01;
			do
			{
				ui32 eax_272 = (word32) *edx_111;
				if ((eax_272 & 0xF000) == 0x3000)
				{
					struct Eq_101 * eax_286 = (eax_272 & 0x0FFF) + ecx_100->dw0000;
					eax_286->dw401008 = eax_286->dw401008 + 0xF0401008;
				}
				edx_111 = edx_111 + 0x01;
				edi_269 = edi_269 - 0x01;
			} while (edi_269 != 0x00);
			esi_103 = dwLoc04_119;
		}
		esi_103 = (word32) ecx_100->t0004 + esi_103;
		dwLoc04_119 = esi_103;
		ecx_100 = ecx_100 + Mem81[ecx_100 + 0x04:word32];
	} while (esi_103 < 232);
	struct Eq_125 * esi_125 = &globals->t401D6C;
	struct Eq_125 * dwLoc04_126 = &globals->t401D6C;
	if (globals->dw401D7C != 0x00)
	{
		esi_177 = esi_125;
		do
		{
			struct Eq_125 * esi_177;
			Eq_192 eax_183 = LoadLibraryA(esi_177->dw000C + 0x00401008);
			if (eax_183 != null)
			{
				word32 edi_207 = esi_177->dw0000;
				if (edi_207 == 0x00)
					edi_207 = esi_177->dw0010;
				word32 * edi_212 = edi_207 + 0x00401008;
				word32 * esi_215 = esi_177->dw0010 + 0x00401008;
				if (*edi_212 != 0x00)
				{
					do
					{
						Eq_195 dwLoc1C_249;
						int32 eax_244 = *edi_212;
						word16 ax_245 = (word16) eax_244;
						if (eax_244 < 0x00)
							dwLoc1C_249 = (word32) ax_245;
						else
							dwLoc1C_249 = eax_244 + 0x0040100A;
						*esi_215 = (word32) GetProcAddress(eax_183, dwLoc1C_249);
						edi_212 = edi_212 + 0x01;
						esi_215 = esi_215 + 0x01;
					} while (*edi_212 != 0x00);
				}
				esi_177 = dwLoc04_126;
			}
			esi_177 = esi_177 + 0x01;
			dwLoc04_126 = esi_177;
		} while (esi_177->dw0010 != 0x00);
	}
	ptr32 esp_134;
	byte SCZO_135;
	word32 ebx_136;
	word32 ebp_137;
	word32 esi_138;
	word32 edi_139;
	byte SZO_140;
	byte C_141;
	word32 eax_142;
	word32 edx_143;
	byte Z_144;
	word32 ecx_145;
	byte cl_146;
	byte S_147;
	word16 ax_148;
	globals->t401A68();
	*(esp_134 - 0x04) = 0x00;
	ExitProcess(*(esp_134 - 0x04));
	ptr32 esp_152;
	byte SCZO_153;
	word32 ebx_154;
	word32 ebp_155;
	word32 esi_156;
	word32 edi_157;
	byte SZO_158;
	byte C_159;
	word32 eax_160;
	word32 edx_161;
	byte Z_162;
	word32 ecx_163;
	byte cl_164;
	byte S_165;
	word16 ax_166;
	globals->t401A68();
	*(esp_152 - 0x04) = 0x00;
	ExitProcess(*(esp_152 - 0x04));
}

