// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004011F8: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	byte al_14 = (byte) ebx;
	word32 edx_17 = __rol(edx, 0x02);
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	Eq_109 esp_52;
	byte SCZO_54;
	word32 ebx_55;
	word32 edi_56;
	word32 esi_57;
	word32 eax_58;
	word32 edx_59;
	byte C_60;
	byte al_61;
	word16 di_62;
	byte SZO_63;
	byte Z_64;
	int32 ebp_65;
	byte dl_66;
	word16 dx_67;
	word16 cx_68;
	word16 ax_69;
	word16 si_70;
	struct Eq_127 * fs_71;
	word32 ecx_53;
	globals->ptr401075();
	Eq_109 esi_72 = esp_52;
	do
	{
		word32 eax_80 = *esi_72;
		esi_72 = (word32) esi_72 + 0x01;
		ecx_53 = __ror(ecx_53, 0x0A);
	} while (eax_80 != 0x00);
	__ror(eax_80, 0x12);
	ui32 esi_108 = esi_72 - 0x6CC206AD | ~0x1B035D12;
	if (DPB(0x90, 0x90 - (~~0x07 + ebp_65), 0) == 0x00)
	{
		word16 ax_148 = (word16) esp_52;
		struct Eq_163 * edi_156 = DPB(1233235, ax_148, 0) + 0x00;
		__rol(ax_148, 0x04);
		ui32 ecx_160 = 0x004010E8;
		ui32 eax_163 = globals->dw40110D;
		do
		{
			edi_156 = edi_156 + 0x01;
			ecx_160 = edi_156 + ecx_160 ^ edi_156;
			word32 edx_176 = edi_156->dw0000 - eax_163;
		} while (edx_176 != 0x00);
		__ror(ecx_160, 0x02);
		ui32 eax_185 = ~(eax_163 | 0x93D50305);
		ui32 edx_191 = DPB(edx_176, edi_156->wFFFFFFFD, 0);
		ui32 eax_197 = &edi_156->wFFFFFFFD + DPB(eax_185, __rol((word16) eax_185, 0x0C), 0);
		*(esp_52 - 0x04) = (union Eq_109 *) esp_52;
		word32 * ecx_201 = *(esp_52 - 0x04);
		__rol(eax_197, 0x1E);
		*(esp_52 - 0x04) = *ecx_201;
		ui32 edi_216 = globals->dw40104D;
		Eq_2 edx_210 = *(esp_52 - 0x04);
		ui32 esi_218 = edi_216 & 0x0040104D;
		do
		{
			int32 eax_226 = *edx_210;
			esi_218 = esi_218 - eax_226;
			edx_210 = (word32) edx_210 + 0x01;
			word16 si_233 = (word16) esi_218;
			word16 ax_238 = (word16) (eax_226 >> 0x11);
		} while ((eax_226 ^ edi_216) == 0x00);
		int32 eax_248 = DPB(eax_226 >> 0x11, __ror(ax_238, 0x0C), 0);
		__ror(si_233, 0x0A);
		uint32 eax_258 = edx_191 << 0x10 >> 0x10;
		*(esp_52 - 0x04) = eax_258 + 4133933;
		*(esp_52 - 0x08) = fs_71->ptr0000;
		fs_71->ptr0000 = esp_52 - 0x08;
		*(esp_52 - 0x0C) = 0x00;
		__ror((word16) ((eax_258 + 4133933 ^ eax_248) << 11), 0x04);
		*(esp_52 - 0x10) = (union Eq_2 *) edx_210;
		return edx_210;
	}
	else
	{
		*(esp_52 - 0x04) = 0x56EF2652;
		*(esp_52 - 0x08) = esi_108;
		ImageList_GetDragImage(*(esp_52 - 0x08), *(esp_52 - 0x04));
		*(esp_52 - 0x04) = esi_108;
		return RegLoadKeyW(*(esp_52 - 0x04), *esp_52, *((word32) esp_52 + 0x04));
	}
}

