// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 1310D000: Register word32 fn1310D000(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10, Stack word32 dwArg14, Stack word32 dwArg18)
word32 fn1310D000(word32 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10, word32 dwArg14, word32 dwArg18)
{
	*dwArg10 = dwArg0C;
	word32 ebx_16 = dwArg14;
	uint32 eax_25 = (uint32) ((uint64) (uint32) dwArg14 /u 0x05);
	byte * dwArg08_113 = dwArg08 + dwArg14;
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		uint32 eax_69 = DPB(eax_25, AddAtomW((WCHAR *) 0xB8000000), 0);
		ebx_16 = (word32) *((word32) (int32) wLoc1C + dwArg18);
		eax_25 = (int32) *dwArg08_113 ^ ebx_16;
		*dwArg04 = (byte) eax_25;
		wLoc1C = (word16) ((word32) wLoc1C + 0x01);
		if ((int32) wLoc1C == 0x05)
			wLoc1C = 0x00;
		dwArg04 = dwArg04 + 0x01;
		dwArg08_113 = dwArg08_113 + 0x01;
	}
	return ebx_16;
}

// 1310D0A9: Register Eq_64 Win32CrtStartup()
Eq_64 Win32CrtStartup()
{
	InitCommonControls();
	GetLastError();
	Eq_71 eax_18 = DPB(ImageList_DragEnter((struct HWND__ *) 0x00BD0000, 0x0AA00000, 616), AddAtomW((WCHAR *) 0x00080000), 0);
	word32 ecx_36 = ImageList_Draw((struct _IMAGELIST *) 0x00234000, 0x00460000, (struct HDC__ *) 0x40000000, 0x00023C00, 0x000D6000, 0x0003F400) + edx;
	struct Eq_103 * v11_43 = (ecx_36 ^ 0x800401F0) + 0x930CE14A;
	word32 esi_47 = v11_43->dw0000;
	ptr32 esp_429 = fp - 0x02E0;
	if ((ecx_36 ^ 0x800401F0) != 0x800401F0)
		esp_429 = fp - 0x02E4;
	struct Eq_119 * esp_60 = esp_429 - 0x04;
	esp_60->t0000 = fp - 0x10;
	*(esp_60 - 0x04) = 0x04;
	*(esp_60 - 0x08) = fp - 0x023C;
	*(esp_60 - 0x0C) = fp - 0x023C;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	Eq_156 eax_82 = v11_43->t0004;
	esp_60->t0008 = fp - 0x0234;
	esp_60->t0004.u0 = 0x04;
	esp_60->t0000 = fp - 0x10;
	*(esp_60 - 0x04) = 0x04;
	*(esp_60 - 0x08) = fp - 0x025C;
	*(esp_60 - 0x0C) = fp - 600;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	ui32 esi_105 = v11_43->dw0008;
	esp_60->t0008 = fp - 0x0234;
	esp_60->t0004.u0 = 0x08;
	esp_60->t0000 = fp - 0x10;
	*(esp_60 - 0x04) = 0x04;
	*(esp_60 - 0x08) = fp - 0x1C;
	*(esp_60 - 0x0C) = fp - 0x14;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	word32 eax_137 = v11_43->dw000C;
	esp_60->t0008 = fp - 0x0234;
	esp_60->t0004.u0 = 0x0C;
	esp_60->t0000 = fp - 0x10;
	*(esp_60 - 0x04) = 0x04;
	*(esp_60 - 0x08) = fp - 0x28;
	*(esp_60 - 0x0C) = fp - 0x1C;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	Eq_276 dwLoc0248_171 = v11_43->t0010;
	esp_60->t0008 = fp - 0x0234;
	esp_60->t0004.u0 = 0x10;
	esp_60->t0000 = fp - 0x10;
	*(esp_60 - 0x04) = 0x04;
	*(esp_60 - 0x08) = fp - 600;
	*(esp_60 - 0x0C) = fp - 0x0248;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	esp_60->t0008.u0 = 0x40;
	esp_60->t0004.u0 = 0x3000;
	Eq_276 edx_200 = esi_105 * 0x08 + 0x0C;
	Mem216[esp_60 + 0x00:word32] = edx_200 + eax_82 + esi_47;
	*(esp_60 - 0x04) = (ecx_36 ^ 0x800401F0) - 0x800401F0;
	ui32 dwLoc024C_195 = 0x14;
	word32 * dwLoc24_198 = (char *) &v11_43->t0010 + 0x04;
	Eq_347 eax_221 = VirtualAlloc(*(esp_60 - 0x04), esp_60->t0000, esp_60->t0004, esp_60->t0008);
	byte * dwLoc0C_228 = (char *) edx_200 + (eax_137 + 0x13100000);
	Eq_276 dwLoc0264_232 = edx_200;
	ui32 dwLoc08_233 = 0x00;
	Eq_375 dwLoc18_234 = null;
	while (true)
	{
		ptr32 esp_252 = esp_429 + 0x08;
		if (0x01 == 0x00)
			break;
		if (dwLoc0264_232 == dwLoc0248_171)
		{
			ui32 edi_357 = dwLoc08_233 + 0x01;
			dwLoc08_233 = edi_357;
			if (edi_357 == esi_105)
				break;
			word32 edi_363 = *dwLoc24_198;
			*(esp_252 - 0x04) = fp - 0x0234;
			*(esp_252 - 0x08) = dwLoc024C_195;
			*(esp_252 - 0x0C) = fp - 0x10;
			*(esp_252 - 0x10) = 0x04;
			*(esp_252 - 0x14) = fp - 0x1C - dwLoc024C_195;
			*(esp_252 - 0x18) = fp - 0x1C;
			fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			LPVOID * eax_393 = dwLoc24_198 + 0x01;
			dwLoc0248_171 = (Eq_276) *eax_393;
			*(esp_252 - 0x04) = fp - 0x0234;
			ui32 eax_390 = dwLoc024C_195 + 0x04;
			*(esp_252 - 0x08) = eax_390;
			*(esp_252 - 0x0C) = fp - 0x10;
			*(esp_252 - 0x10) = 0x04;
			*(esp_252 - 0x14) = fp - 0x0248 - eax_390;
			*(esp_252 - 0x18) = fp - 0x0248;
			fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			dwLoc024C_195 = eax_390 + 0x04;
			dwLoc24_198 = (word32 *) ((char *) eax_393 + 0x04);
			dwLoc0264_232 = null;
			dwLoc0C_228 = edi_363 + 0x13100000;
		}
		Mem342[eax_221 + dwLoc18_234:byte] = Mem220[dwLoc0C_228 + 0x00:byte];
		dwLoc0C_228 = dwLoc0C_228 + 0x01;
		dwLoc18_234 = dwLoc18_234 + 0x01;
		dwLoc0264_232 = (Eq_276) ((char *) dwLoc0264_232 + 0x01);
	}
	*(esp_252 - 0x04) = fp - 0x0234;
	*(esp_252 - 0x08) = (LPVOID *) edx_200;
	*(esp_252 - 0x0C) = fp - 0x0238;
	*(esp_252 - 0x10) = (LPVOID *) eax_82;
	*(esp_252 - 0x14) = (LPVOID *) (eax_221 - edx_200);
	*(esp_252 - 0x18) = (LPVOID *) eax_221;
	word32 ebx_278 = fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(esp_252 - 0x04) = fp;
	*(esp_252 - 0x08) = fp - 0x0234;
	*(esp_252 - 0x0C) = (LPVOID *) eax_82;
	*(esp_252 - 0x10) = esi_47;
	*(esp_252 - 0x14) = (LPVOID *) eax_221;
	word32 edx_301 = eax_221 + eax_82;
	*(esp_252 - 0x18) = (LPVOID *) edx_301;
	ptr32 esp_305;
	word32 ebp_306;
	byte SCZO_307;
	word32 eax_308;
	word32 ecx_309;
	word32 edx_310;
	byte SZO_311;
	byte C_312;
	word32 esi_313;
	byte Z_314;
	word32 edi_315;
	word32 ebx_316;
	byte bl_317;
	(eax_221 + 0x0F50)();
	*(esp_305 - 0x04) = 0x00;
	ExitProcess(*(esp_305 - 0x04));
}

