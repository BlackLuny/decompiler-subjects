// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 edi_385 = AddAce(null, 0x00, 0x00, null, 0x00) + 0x25 + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00);
	Eq_3 ebp_16 = null;
	if (AreAnyAccessesGranted(~0x00, ~0x00) == 0x00)
		edi_385 = edi_385 - 0x22;
	struct Eq_246 * eax_394 = null;
	do
	{
		if (ebp_16 == edi_385)
			ebp_16 = null;
		eax_394[0x00401290] = (struct Eq_246) (eax_394[0x00401290] ^ ebp_16[0x00404000]);
		eax_394 = eax_394 + 0x01;
		ebp_16 = (Eq_3) (ebp_16 + 0x01);
	} while (eax_394 < (struct Eq_246 *) 5152);
	struct Eq_268 * edx_425 = &globals->t402570;
	uint32 dwLoc08_430 = 0x00;
	do
	{
		Eq_272 eax_437 = edx_425->t0004;
		cui16 * ecx_443 = (char *) &edx_425->t0004 + 0x04;
		if (eax_437 - 0x08 >> 0x01 > 0x00)
		{
			uint32 esi_621 = eax_437 - 0x08 >> 0x01;
			do
			{
				if ((*ecx_443 & 0xF000) == 0x3000)
				{
					struct Eq_431 * eax_642 = ((word32) *ecx_443 & 0x0FFF) + edx_425->dw0000;
					eax_642->dw401010 = eax_642->dw401010 + 0xF0401010;
				}
				ecx_443 = ecx_443 + 0x01;
				esi_621 = esi_621 - 0x01;
			} while (esi_621 != 0x00);
		}
		Eq_272 eax_450 = edx_425->t0004;
		uint32 ecx_452 = (word32) eax_450.u0 + dwLoc08_430;
		word32 edx_453 = edx_425 + eax_450;
		int32 eax_457 = edx_453->dw0004;
		uint32 ecx_459 = ecx_452 + eax_457;
		edx_425 = (struct Eq_268 *) (edx_453 + eax_457 / 0x08);
		dwLoc08_430 = ecx_459;
	} while (ecx_459 < 228);
	struct Eq_318 * ebx_469 = &globals->t401D6C;
	struct Eq_318 * dwLoc04_470 = &globals->t401D6C;
	ebx_503 = ebx_469;
	if (globals->dw401D7C != 0x00)
	{
		do
		{
			struct Eq_318 * ebx_503;
			Eq_357 eax_509 = LoadLibraryA(ebx_503->dw000C + 0x00401010);
			CloseHandle((void *) 0x62);
			Eq_357 eax_524 = LoadLibraryA(ebx_503->dw000C + 0x00401010);
			CloseHandle((void *) 0x62);
			if (eax_524 != null)
			{
				struct Eq_399 * edi_556 = ebx_503->dw0000;
				if (edi_556 == null)
					edi_556 = ebx_503->dw0010;
				Eq_405 eax_562 = edi_556->t401010;
				union Eq_409 * edi_564 = &edi_556->t401010;
				word32 * esi_565 = ebx_503->dw0010 + 0x00401010;
				bool S_568 = cond(eax_562);
				if (eax_562 != 0x00)
				{
					do
					{
						Eq_360 dwLoc1C_587;
						if (!S_568)
							dwLoc1C_587 = (word32) *edi_564;
						else
							dwLoc1C_587 = (Eq_360) ((word32) eax_562 + 0x00401012);
						*esi_565 = (word32) GetProcAddress(eax_524, dwLoc1C_587);
						edi_564 = (union Eq_409 *) ((char *) edi_564 + 0x04);
						eax_562 = *edi_564;
						esi_565 = esi_565 + 0x01;
						S_568 = cond(eax_562);
					} while (eax_562 != 0x00);
					ebx_503 = dwLoc04_470;
				}
			}
			ebx_503 = ebx_503 + 0x01;
			dwLoc04_470 = ebx_503;
		} while (ebx_503->dw0010 != 0x00);
	}
	ptr32 esp_480;
	byte SCZO_481;
	word32 ebx_482;
	word32 ebp_483;
	word32 esi_484;
	word32 edi_485;
	byte SZO_486;
	byte C_487;
	word32 eax_488;
	byte Z_489;
	word32 ecx_490;
	byte cl_491;
	word32 edx_492;
	word16 ax_493;
	byte S_494;
	globals->t401A60();
	*(esp_480 - 0x04) = 0x00;
	ExitProcess(*(esp_480 - 0x04));
}

