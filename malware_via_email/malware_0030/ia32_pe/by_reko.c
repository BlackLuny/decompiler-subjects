// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00401078(0x00401128, 0x062E);
}

// 00401078: void fn00401078(Stack word32 dwArg04, Stack word32 dwArg08)
void fn00401078(word32 dwArg04, word32 dwArg08)
{
	Eq_48 (* dwLoc08_24)[] = null;
	while (dwLoc08_24 < dwArg08)
	{
		if (dwLoc08_24 > (Eq_48 (*)[]) 0x01 && (dwLoc08_24 - 0x01 & 0x01) == 0x00)
		{
			word32 eax_109 = dwLoc08_24 + dwArg04;
			Mem116[dwArg04 + dwLoc08_24:byte] = (byte) (DPB(eax_109, *eax_109, 0) ^ 0x43);
		}
		if (dwLoc08_24 > (Eq_48 (*)[]) 0x01)
		{
			word32 eax_92 = dwLoc08_24 + dwArg04;
			Mem98[dwArg04 + dwLoc08_24:byte] = (byte) (DPB(eax_92, *eax_92, 0) + 121);
		}
		if (dwLoc08_24 > (Eq_48 (*)[]) 0x03)
		{
			Eq_48 (* edx_65)[] = dwLoc08_24 - (Eq_48 (*)[]) 0x03;
			if ((int32) (SEQ(edx_65 >> 0x1F, edx_65) % 0x03) == 0x00)
			{
				Eq_48 eax_81[] = dwLoc08_24 + dwArg04;
				Mem87[dwArg04 + dwLoc08_24:byte] = (byte) (DPB(eax_81, eax_81[0x00], 0) - (Eq_48 (*)[]) 0x04);
			}
		}
		Mem59[dwArg04 + dwLoc08_24:byte] = Mem0[dwLoc08_24 + dwArg04:byte] - (byte) dwLoc08_24;
		dwLoc08_24 = dwLoc08_24 + 0x01;
	}
	return;
}

// 00401128: void fn00401128(Register byte cl, Register byte bl, Register byte bh, Register (ptr word32) esi, Register (ptr word32) edi)
void fn00401128(byte cl, byte bl, byte bh, word32 * esi, word32 * edi)
{
	if (CZ)
	{
		*edi = *esi;
		__inb(166);
	}
}

