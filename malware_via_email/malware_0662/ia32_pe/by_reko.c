// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 ebx_15 = null;
	Eq_3 ebp_21 = (struct <anonymous> *) 0x28;
	Eq_2 eax_22 = AddUsersToEncryptedFile(&globals->t403020, null);
	if (eax_22 != 0x00)
	{
		Eq_17 eax_32 = AreAllAccessesGranted(~0x00, ~0x00);
		if (eax_32 == 0x00)
			ebp_21 = eax_32 + 0x26;
		VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x10);
		struct Eq_40 * eax_52 = null;
		do
		{
			if (ebx_15 == ebp_21)
				ebx_15 = null;
			eax_52[4199896] = (struct Eq_40) (ebx_15[0x00404000] ^ eax_52[4199896] ^ 0x54);
			eax_52 = eax_52 + 0x01;
			ebx_15 = (Eq_3) (ebx_15 + 0x01);
		} while (eax_52 < (struct Eq_40 *) 0x1440);
		struct Eq_64 * ecx_282 = &globals->t4028D8;
		uint32 dwLoc0C_281 = 0x00;
		if (true)
		{
			do
			{
				Eq_82 eax_290 = ecx_282->t0004 - 0x08 >> 0x01;
				word16 * edx_293 = (char *) &ecx_282->t0004 + 0x04;
				if (eax_290 > 0x00)
				{
					Eq_82 ebx_305 = eax_290;
					do
					{
						ui32 eax_308 = (word32) *edx_293;
						if ((eax_308 & 0xF000) == 0x3000)
						{
							struct Eq_226 * eax_319 = (eax_308 & 0x0FFF) + ecx_282->dw0000;
							eax_319->dw401358 = eax_319->dw401358 + 0xF0401358;
						}
						edx_293 = edx_293 + 0x01;
						ebx_305 = ebx_305 - 0x01;
					} while (ebx_305 != 0x00);
				}
				Eq_85 eax_297 = ecx_282->t0004;
				uint32 edx_299 = (word32) eax_297 + dwLoc0C_281;
				ecx_282 = ecx_282 + eax_297;
				dwLoc0C_281 = edx_299;
			} while (edx_299 < 228);
		}
		struct Eq_73 * ebx_104 = &globals->t4020C4;
		struct Eq_73 * dwLoc0C_105 = &globals->t4020C4;
		ebx_156 = ebx_104;
		if (Mem74[0x004020D4:word32] != 0x00)
		{
			do
			{
				struct Eq_73 * ebx_156;
				Eq_161 eax_173 = LoadLibraryA(ebx_156->dw000C + 0x00401358);
				if (eax_173 != null)
				{
					word32 ebp_202 = ebx_156->dw0000;
					if (ebp_202 == 0x00)
						ebp_202 = ebx_156->dw0010;
					word32 * ebp_207 = ebp_202 + 0x00401358;
					int32 eax_211 = *ebp_207;
					word32 * edi_212 = dwLoc0C_105->dw0010 + 0x00401358;
					if (eax_211 != 0x00)
					{
						do
						{
							Eq_241 eax_250;
							if (eax_211 < 0x00)
								eax_250 = GetProcAddress(eax_173, (word32) *ebp_207);
							else
								eax_250 = GetProcAddress(eax_173, eax_211 + 0x0040135A);
							*edi_212 = (word32) eax_250;
							ebp_207 = ebp_207 + 0x01;
							eax_211 = *ebp_207;
							edi_212 = edi_212 + 0x01;
						} while (eax_211 != 0x00);
					}
					ebx_156 = dwLoc0C_105;
				}
				ebx_156 = ebx_156 + 0x01;
				dwLoc0C_105 = ebx_156;
			} while (ebx_156->dw0010 != 0x00);
		}
		ptr32 esp_113;
		byte SCZO_114;
		word32 ebx_115;
		word32 ebp_116;
		word32 esi_117;
		word32 edi_118;
		byte SZO_119;
		byte C_120;
		word32 eax_121;
		byte Z_122;
		word32 edx_123;
		byte cl_124;
		word32 ecx_125;
		byte CZ_126;
		byte S_127;
		globals->t401DB8();
		*(esp_113 - 0x04) = 0x00;
		ExitProcess(*(esp_113 - 0x04));
		ptr32 esp_131;
		byte SCZO_132;
		word32 ebx_133;
		word32 ebp_134;
		word32 esi_135;
		word32 edi_136;
		byte SZO_137;
		byte C_138;
		word32 eax_139;
		byte Z_140;
		word32 edx_141;
		byte cl_142;
		word32 ecx_143;
		byte CZ_144;
		byte S_145;
		globals->t401DB8();
		*(esp_131 - 0x04) = 0x00;
		ExitProcess(*(esp_131 - 0x04));
	}
	else
		return eax_22;
}

