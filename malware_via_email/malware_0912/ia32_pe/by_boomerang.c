void _start(__size32 param1, __size32 param2);
__size32 proc2();

// address: 0x4010d0
void proc1(__size32 param1) {
    __size16 ax; 		// r0
    unsigned short cx; 		// r1
    int eax; 		// r24
    int eax_1; 		// r24{47}
    __size32 ebp; 		// r29
    __size32 ebx; 		// r27
    __size32 ebx_1; 		// r27{144}
    __size32 ecx; 		// r25
    __size32 edi; 		// r31
    __size32 edx; 		// r26
    __size32 esi; 		// r30
    __size32 *esp; 		// r28
    void *esp_1; 		// r28{171}
    unsigned int local0; 		// m[esp - 48]
    unsigned int local1; 		// m[esp - 44]
    __size32 local10; 		// m[esp - 12]
    int local11; 		// m[esp - 8]
    int local12; 		// m[esp - 6]
    int local13; 		// m[esp - 4]
    int local14; 		// m[esp + 24]
    int local15; 		// m[esp + 36]
    int local16; 		// m[esp - 30]{171}
    __size32 local2; 		// m[esp - 40]
    __size32 local3; 		// m[esp - 36]
    __size32 local4; 		// m[esp - 32]
    __size8 local5; 		// m[esp - 30]
    int local6; 		// m[esp - 28]
    int local7; 		// m[esp - 24]
    __size32 local8; 		// m[esp - 20]
    __size32 local9; 		// m[esp - 16]

    cx = *0;
    eax_1 = 0 >> 16 & 0xffff | (0);
    eax = proc2(); /* Warning: also results in ecx, ebx_1 */
    (**(ebx_1 + 24))(pc, pc, eax, eax, eax, local5 - 1, esp - 40, 0, edi, ebx, esi, eax_1 + 0x6030, 0, eax_1 + 0x6c7c, 0xb53898fa, 0, (unsigned short) eax, cx, eax, ecx, eax_1 + 0x6030, ebx_1, param1 + 1, 2, esp - 40, ADDFLAGS32(esp - 44, 20, esp - 24), ADDFLAGS32(esp - 44, 20, esp - 24), ADDFLAGS32(esp - 44, 20, esp - 24));
    (**(ebx + 28))(local0, local1, local2, local3, local4, local16, local6, local7, local8, local9, local10, local11, local12, local13, local14, local15, (unsigned short) eax, cx, eax, ecx, edx, ebx, ebp, esi, edi, <all>, flags, ZF, CF);
}

// address: 0x401004
void _start(__size32 param1, __size32 param2) {
    __size32 ebp; 		// r29
    __size32 edi; 		// r31
    __size32 edx; 		// r26
    __size32 esp; 		// r28

    edx = param1 + param2 + param2 + esp + 16;
    proc1(pc, 0, 16, 0x2230, esp - 24, 0xb753b36, 0, 0xd7236c22, 0xeb6d6e68, param2, ebp, edx + esp + 0xb753b48, 0, edx + esp + 16, ebp, param2, edi, LOGICALFLAGS32(0), LOGICALFLAGS32(0), LOGICALFLAGS32(0));
}

// address: 0x40169a
__size32 proc2() {
    unsigned int ax; 		// r0
    unsigned int eax; 		// r24
    void *ebx; 		// r27
    __size32 ecx; 		// r25
    union { unsigned short x1; unsigned int * x2; } local0; 		// m[esp - 10]

    for(;;) {
        ax = *local0;
        eax = (local0 >> 16 & 0xffff | (ax)) >> 16 & 0xffff | (ax - 0x5a4b);
        if (ax - 0x5a4b == 2) {
            break;
        }
    }
    ecx = *(eax + 60);
    ebx = *(ecx + eax + 128);
    ecx = *(eax + ebx);
    return eax + ecx + 4; /* WARNING: Also returning: ecx := ecx, ebx := eax + ecx + 4 */
}

