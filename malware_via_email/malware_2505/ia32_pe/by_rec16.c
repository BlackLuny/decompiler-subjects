/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_2505/ia32_pe/subject.exe'
 */

stack space not deallocated on return
/*	Procedure: 0x00408007 - 0x0040802E
 *	Argument size: 14356
 *	Local size: 0
 *	Save regs size: 0
 */

L00408007()
{



    ebx = ebx + 1;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *(eax + *eax + *(eax + *eax)) = *(eax + *eax + *(eax + *eax)) + al;
    (restore)eax;
    *eax = *eax + al;
    *eax = *eax + al;
    eax = eax + 1;
    *eax = *eax + al;
    asm("adc byte [eax],0x0");
    *eax = *eax + al;
    *eax = *eax - al;
    *eax = *eax + al;
}

stack space not deallocated on return
/*	Procedure: 0x0040802F - 0x00408105
 *	Argument size: 14356
 *	Local size: 0
 *	Save regs size: 0
 */

L0040802F()
{



    ebx = ebx + 1;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + eax;
    *eax = *eax + eax;
    if(!( *eax = *eax + al)) {
    }
    *eax = *eax + al;
    return;
    ebx = ebx + 1;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + eax;
    *eax = *eax + eax;
    *eax = *eax + al;
    *eax = al;
    *eax = *eax + al;
    return;
    ebx = ebx + 1;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + eax;
    *ebp = *ebp ^ esi;
    *(eax + 8388608) = *(eax + 8388608) + ah;
    *eax = *eax + al;
    dl = dl + al;
    asm("adc al,0x38");
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + eax;
    (restore)es;
    *eax = *eax + ebx + 1;
    *eax = *eax + al;
    dl = dl + al;
    asm("adc al,0x38");
    ebx = ebx + 1;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + eax;
    *eax = *eax + al;
    *eax = *eax + al;
    asm("enter 0x0,0x0");
    *eax = *eax + al;
    *eax = *eax + al;
    return;
    ebx = ebx + 1;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + eax;
    *eax = *eax + al;
    *eax = *eax + al;
    (fsave)(frestore) + *eax;
    *eax = *eax + al;
    al = *esi;
    esi = esi + 1;
    ah = ah + al;
    *eax = *eax + eax;
    *(eax + 4) = *(eax + 4) + dh;
    *eax = *eax + al;
    *(eax + 335544461) = *(eax + 335544461) + bl;
    *eax = *eax + al;
    *(eax + 4) = *(eax + 4) + dh;
    *eax = *eax + al;
    al = al + dh;
    al & 12;
    *eax = *eax + al;
    al = 4;
    *L00000004 = *L00000004 + 4;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax - al;
    *eax = *eax + al;
    *eax = *eax & al;
    *eax = *eax + al;
    eax = eax + 1;
    *eax = *eax + al;
    *ecx = *ecx + al;
    *eax = *eax + bl;
    *eax = *eax + al;
    *eax = *eax + al;
    *(eax + -2146664436) = *(eax + -2146664436) + al;
}

/*	Procedure: 0x00408C39 - 0x00408C42
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00408C39()
{



    ch = 255;
    asm("fist word [esi+eax*8+0x61637b96]");
    asm("arpl [esi+eax*8+0x61637b96],dx");
}

/*	Procedure: 0x00408C99 - 0x00408C9F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00408C99()
{



    ch = 206;
    asm("scasb");
    *(ebx + 97) & ah;
    asm("arpl [ebx+0x63616361],ax");
}

/*	Procedure: 0x00408CD8 - 0x00408CDA
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00408CD8()
{



    ch = 239;
    asm("iret");
}

/*	Procedure: 0x00408CDB - 0x00408DAE
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00408CDB()
{



    ch = 239;
    asm("Unknown opcode 0xc7");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("out dx,eax");
    asm("Unknown opcode 0xc7");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("out dx,eax");
    asm("Unknown opcode 0xc7");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("out dx,eax");
    asm("Unknown opcode 0xc7");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("out dx,eax");
    asm("Unknown opcode 0xc7");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("out dx,eax");
    asm("Unknown opcode 0xc7");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("out 0xbe,eax");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("out 0xbe,eax");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    asm("salc");
    dh = 165;
    asm("out dx,eax");
    asm("Unknown opcode 0xc7");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    ch = 150;
    *eax = es;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    asm("clc");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    asm("Unknown opcode 0x0f");
    asm("lock add [eax],al");
    do {
        asm("Unknown opcode 0x0f");
        asm("lock add [eax],al");
        asm("Unknown opcode 0x0f");
        asm("lock add [eax],al");
        asm("Unknown opcode 0x0f");
        asm("lock add [eax],al");
        asm("Unknown opcode 0x0f");
        asm("lock add [eax],al");
        do {
            asm("Unknown opcode 0x0f");
            asm("lock add [eax],al");
            (restore)ds;
            asm("lock add [eax],al");
            asm("aas");
            asm("lock add [eax],al");
        } while(*eax = *eax + al);
        *eax = *eax + al;
        (save)eax;
        *ecx = *ecx + al;
        *eax = *eax + 1;
        *ecx = *ecx + al;
        *ecx = *ecx + al;
        *eax = *eax + ah;
        *eax = *eax & al;
        *ecx = *ecx + al;
        *eax = *eax + bl;
    } while(*(eax + 822083596) = *(eax + 822083596) + ch);
    *(ecx + eax) = *(ecx + eax) + esi;
}

/* DEST BLOCK NOT FOUND: 0040a036 -> b10e1734 */
stack space not deallocated on return
/*	Procedure: 0x00409EC7 - 0x0040A057
 *	Argument size: 10209
 *	Local size: 0
 *	Save regs size: 0
 */

L00409EC7()
{



    ecx = ecx + -1967115356;
    (save)ebx;
    asm("into");
    *edx = *edx | dl;
    dl = dl - *(eax - 60);
    asm("lodsd");
    asm("fdivr dword [eax+ebp*4]");
    *(edi - 124) & edx;
    eax = L4edb8d33();
    asm("loope 0x409f4c");
    eax = eax + *(ebp + 70);
    asm("%c dec ecx");
    asm("adc [edx],bh");
    ecx :: eax;
    ebp = ebp + 1;
    asm("adc al,ah");
    eax :: 0;
    (save)esp;
    *edx & 1058079829;
    ebx = ebx + 1;
    asm("sahf");
    asm("loope 0x409e88");
    asm("popa");
    al = *L5D40713C;
    asm("xchg eax,edx");
    eax = al + 10 ^ *(al + 10 + 1396890656);
    asm("repne push esi");
    asm("xchg eax,esi");
    asm("adc al,0x52");
    if(!( *edx = *edx + esp)) {
        dl = 17;
        asm("xchg eax,ebp");
        asm("adc al,0x90");
        (restore)eax;
        esp = 429231966;
        asm("adc [edx+0x999c9f88],dh");
        asm("lodsd");
        *(esp + eax + 115) = *(esp + eax + 115) ^ esp;
        asm("sbb al,0x68");
        edi = edi - 1;
        *(esi + 1854121204) = *(esi + 1854121204) & ecx;
        edx = edx + 1;
    }
    asm("xchg eax,edi");
    (save)edx;
    *%ss:esi-0x5c] = *%ss:esi-0x5c] ^ dh;
    (save)eax;
    ebx = ebx + 1;
    ecx = ecx - 1;
    asm("adc eax,0xa736f63");
    asm("punpcklwd mm4,[edx+ebp*2-0x3d]");
    asm("o16 jo 0x409fbd");
    ebx = 1424524398;
L00409f4b:
    ecx = 1269840431;
    asm("int 0x50");
    bh :: *ebx;
    asm("adc al,0x45");
    esi = esi - 1;
    asm("Unknown opcode 0xd3");
    asm("rep jna 0x409f27");
    asm("insd");
    asm("les esp,[edx+0xe0e9b450]");
    asm("hlt");
    asm("%e jng 0x409f96");
    asm("daa");
    asm("insd");
    *(edi + 114) = *(edi + 114) ^ ebp;
    asm("daa");
    asm("a16 xor al,0x69");
    asm("jpo 0x409f19");
    if(dl >= *%ss:ebx]) {
        asm("jpe 0x409f9c");
        esi = esi ^ *edx;
        ecx = ecx - 1;
        asm("Unknown opcode 0xdb");
        if(cl >= 0) {
            goto L00409f4b;
        }
        (restore)edx;
        <= ? L00409f8e : ;
        asm("jpe 0x409fa6");
        esp = esp + 1;
        esi :: *ecx;
        asm("%s dec esi");
    }
    (fsave)(frestore) / *(ecx + edx * 4);
    asm("%e lahf");
    goto L00409fbb;
    asm("daa");
    asm("bound ecx,[bp+si+0x62]");
    al = al + 115;
    1746185156 = *(esi - 8) * ebp;
    115 = esi * ebx;
    asm("lahf");
    (restore)ss;
    dh = dh | *ecx;
    al = al + *(ebp + 86);
    asm("enter 0x544e,0x1d");
L00409fb0:
    (restore)edi;
    (save)ebx;
    ecx = ecx - 1;
    (restore)ebp;
    if(ebx = ebx - 1) {
        goto L00409fb0;
    }
    (save)edx;
    ebx = 0;
    *(esi + 68) = *(esi + 68) & ah;
L00409fbb:
    asm("xchg eax,esp");
    asm("cmovna esi,[ebp+0x6e]");
    asm("arpl [edi+0xd596f69],ax");
    edx = edx ^ ebp;
    if(!(esi = esi - 1 - 1)) {
        == ? L0040a026 : ;
        asm("outsb");
        eax = eax + 1;
        asm("wait");
        asm("jpe 0x40a009");
        al = 97;
        al = *esi;
        esi = esi + 1;
        *(eax + 1953639281) = *(eax + 1953639281) - bl;
        if(!( *(eax + 81) = *(eax + 81) & al)) {
            < ? L0040a05e : ;
            >= ? 0x40a019 : ;
            asm("outsb");
            == ? L00409ff6 : ;
            asm("Unknown opcode 0x66");
            asm("Unknown opcode 0x8f");
            *edi = *esi;
            edi = edi + 1;
            if(!(esi = esi + 1)) {
                eax = L0c59726c();
                asm("sbb [eax-0x66],ecx");
                asm("%f leave");
                < ? L0040a06d : ;
                asm("sti");
                asm("ficom dword [edx-0x6a]");
                return;
                asm("sbb al,0xd2");
                asm("adc al,[ecx]");
                *esi :: ah;
                (save)eax;
                *edi = *esi;
                edi = edi + 1;
                esi = esi + 1;
                esp = esp - 1;
                ch = *(ebx + -452688838);
                asm("a16 stc");
                asm("aam 0xa9");
                asm("%d jnz 0x40a044");
                -748765990 = edx * edx;
            }
            asm("daa");
            asm("jecxz 0x409fa5");
            asm("hlt");
            eax :: -1860425946;
            asm("Unknown opcode 0xc7");
            edi = edi - 1;
            L00002186();
            asm("sahf");
            eax & 1321674562;
            goto Lb10e1734;
            if(ecx = ecx + 1) {
                goto L0040a0ab;
            }
            != ? 0x40a012 : ;
            asm("xchg eax,edx");
            al = al ^ 101;
            edx = edx + 1;
            eax = eax ^ 1894451988;
        }
        (save)ebx;
        if(al = al | 210) {
            goto L08f6b0c8;
        }
    }
    asm("cli");
    < ? L0040a035 : ;
    < ? L0040a072 : ;
    ebp = ebp + edi;
    asm("Unknown opcode 0xf7");
    asm("int3");
    *eax = *eax + al;
}

/* address  size  */
/* 0x00400154       0 */ /* unknown */ void 	__entry_point__;
/* 0x0040a0b0       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x0040a0b4       0 */ /* unknown */ void 	__imp__GetProcAddress;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
