__size32 global15 = 0x337f0c79;// 4 bytes

// address: 0x401000
void _start() {
    int ax; 		// r0
    __size16 ax_1; 		// r0
    unsigned int ax_2; 		// r0{156}
    unsigned char cl; 		// r9
    unsigned char cl_1; 		// r9{107}
    __size32 eax; 		// r24
    __size32 eax_1; 		// r24{15}
    __size32 eax_2; 		// r24{63}
    unsigned int eax_3; 		// r24{318}
    unsigned int eax_4; 		// r24{139}
    __size32 ebp; 		// r29
    unsigned int ebp_1; 		// r29{349}
    union { unsigned int x7; unsigned short * x8; } ebp_2; 		// r29{396}
    __size32 ebx; 		// r27
    unsigned int ebx_1; 		// r27{63}
    union { union { unsigned int x7; void * x8; } * x15; unsigned int x16; } ebx_2; 		// r27{414}
    int ecx; 		// r25
    union { unsigned int x3; void * x4; } ecx_1; 		// r25{335}
    unsigned int ecx_2; 		// r25{366}
    __size32 edi; 		// r31
    int edx; 		// r26
    __size32 esi; 		// r30
    unsigned int esi_1; 		// r30{63}
    int esp; 		// r28
    union { unsigned int x7; void * x8; } *esp_1; 		// r28{63}
    LPCSTR local0; 		// m[esp - 48]
    char *local1; 		// m[esp - 44]
    int local10; 		// m[esp - 24]
    __size32 local11; 		// m[esp - 20]
    unsigned int local12; 		// m[esp_1 - 12]{74}
    void *local13; 		// m[esp_1 - 12]{84}
    unsigned int local14; 		// esi_1{328}
    unsigned int local2; 		// m[esp - 64]
    int local3; 		// m[esp - 60]
    int local4; 		// m[esp - 56]
    int local5; 		// m[esp - 52]
    __size32 local6; 		// m[esp - 40]
    __size32 local7; 		// m[esp - 36]
    __size32 local8; 		// m[esp - 32]
    int local9; 		// m[esp - 28]

    eax_1 = StrChrA();
    if (eax_1 == 0) {
        eax = LoadLibraryA("advapi32.dll");
        eax = GetProcAddress(eax, "AddAce"); /* Warning: also results in ecx, edx */
        (*eax)(pc, 0, 0, 0, 0, 0, edi, ebp, ebx, 0x404064, 0, esi, eax, ecx, edx, ebx, ebp, 0, edi, LOGICALFLAGS32(eax_1), LOGICALFLAGS32(eax_1), LOGICALFLAGS32(eax_1));
        ebp = eax_2 + 28;
        ebx = edi + ebx_1 * 2;
        *(__size32*)(esp_1 - 4) = -1;
        *(__size32*)(esp_1 - 8) = -1;
        eax = AreAllAccessesGranted();
        if (eax == 0) {
            ebp = eax_2 + 28 ^ 14;
        }
        local13 = esp_1 + 8;
        *(__size32*)(esp_1 - 16) = 64;
        *(__size32*)(esp_1 - 20) = 0x3000;
        *(__size32*)(esp_1 - 24) = 0x401000;
        ecx = VirtualProtect(); /* Warning: also results in edx */
        edi = esi_1 + edi * 4;
        eax = 0;
        do {
            eax_3 = eax;
            ebx = edx + ebx * 4;
            local14 = esi_1;
            if (esi_1 == ebp) {
                esi = 0;
                local14 = esi;
            }
            esi_1 = local14;
            edx = ecx + edx * 4;
            cl_1 = *(esi_1 + 0x405000);
            cl = (cl_1 ^ *(eax_3 + 0x4025e8));
            ecx = ((ecx >> 8 & 0xffffff | (cl_1)) >> 8 & 0xffffff | (cl)) >> 8 & 0xffffff | (cl ^ -20);
            *(char*)(eax_3 + 0x4025e8) = cl ^ -20;
            edi = edi * 9;
            eax = eax_3 + 1;
            esi_1++;
        } while (eax_3 + 1 < 0x1420);
        ebx = 0x4038c8;
        edi = 0x402368;
        ebp = 0;
        *(union { unsigned int x7; void * x8; }*)esp_1 = 0x402368;
        esi = 0xf0402368;
        *(__size32*)(esp_1 - 4) = 0;
        do {
            ecx_1 = ecx;
            eax_4 = *(ebx + 4);
            eax = (eax_4 - 8) / 2;
            ax = (unsigned short) (eax_4 - 8) / 2;
            ecx = ecx_1 * 2 + 0x402368;
            cl = (unsigned char) ecx_1 * 2 + 0x402368;
            edx = ebx + 8;
            if ((int)((eax_4 - 8) / 2) > 0) {
                ebp = (eax_4 - 8) / 2;
                do {
                    ebp_1 = ebp;
                    ax_2 = *edx;
                    ax = ax_2 & 0xfffff000;
                    eax = (eax >> 16 & 0xffff | (ax_2)) >> 16 & 0xffff | (ax_2 & 0xfffff000);
                    tmph = (ax_2 & 0xfffff000) - 0x3000;
                    if ((ax_2 & 0xfffff000) == 0x3000) {
                        ecx = *(unsigned short*)edx;
                        ecx = (ecx & 0xfff) + *ebx;
                        cl = (unsigned char) ecx;
                        *(__size32*)(ecx + 0x402368) = *(ecx + 0x402368) - 0xfbfdc98;
                        eax = ecx + 0x402368;
                        ax = (unsigned short) ecx + 0x402368;
                    }
                    edx += 2;
                    ebp = ebp_1 - 1;
                } while (ebp_1 != 1);
                ebp = *(esp_1 - 4);
            }
            ecx_2 = ecx;
            ebp += *(ebx + 4);
            *(unsigned int*)(esp_1 - 4) = ebp;
            ecx = ebx + ecx_2 * 4;
            cl = (unsigned char) ebx + ecx_2 * 4;
            ebx += *(ebx + 4);
        } while (ebp < 228);
        flags = SUBFLAGS32(*0x4030d4, 0, global15);
        ebx = 0x4030c4;
        *(__size32*)(esp_1 - 4) = 0x4030c4;
        if (*0x4030d4 != 0) {
            do {
                edx = *(ebx + 12);
                *(__size32*)(esp_1 - 28) = edx + edi;
                eax = LoadLibraryA(*(esp_1 - 28)); /* Warning: also results in edx */
                ecx = eax;
                cl = (unsigned char) eax;
                *(unsigned int*)(esp_1 + 4) = eax;
                if (eax != 0) {
                    ebp = *ebx;
                    if (ebp == 0) {
                        ebp = *(ebx + 16);
                    }
                    esi = *(ebx + 16);
                    eax = *(ebp + edi);
                    ax = (unsigned short) eax;
                    ebp += edi;
                    esi += edi;
                    if (eax != 0) {
L9:
                        ebp_2 = ebp;
                        if (eax >= 0) {
                            *(union { unsigned int x7; void * x8; }*)(esp_1 - 28) = eax + edi + 2;
                            *(union { void * x9; unsigned int x10; }*)(esp_1 - 32) = ecx;
                            eax = GetProcAddress(*(esp_1 - 32), *(esp_1 - 28)); /* Warning: also results in ecx, edx */
                            goto L5;
                        }
                        eax = *(unsigned short*)ebp_2;
                        *(unsigned int*)(esp_1 - 28) = eax;
                        *(union { void * x9; unsigned int x10; }*)(esp_1 - 32) = ecx;
                        eax = GetProcAddress(*(esp_1 - 32), *(esp_1 - 28)); /* Warning: also results in ecx, edx */
                        ebx = ecx + ebx * 2;
L5:
                        *(__size32*)esi = eax;
                        ebp = ebp_2 + 4;
                        eax = *(ebp_2 + 4);
                        ax = (unsigned short) eax;
                        edi = *esp_1;
                        esi += 4;
                        if (eax != 0) {
                            ecx = *(esp_1 + 4);
                            cl = (unsigned char) ecx;
                            goto L9;
                        }
                        ebx = *(esp_1 - 4);
                    }
                }
                ebx_2 = ebx;
                ebx = ebx_2 + 20;
                tmp1 = *(ebx_2 + 36);
                flags = SUBFLAGS32(*(ebx_2 + 36), 0, tmp1);
                *(union { union { unsigned int x7; void * x8; } * x15; unsigned int x16; }*)(esp_1 - 4) = ebx_2 + 20;
            } while (*(ebx_2 + 36) != 0);
        }
        (*0x402db8)(local2, local3, local4, local5, local0, local1, local6, local7, local8, local9, local10, local11, 0x2db8, cl, 0x402db8, ecx, edx, ebx, ebp, esi, edi, <all>, flags, ZF, CF);
        *(__size32*)(esp - 4) = 0;
        ExitProcess(*(esp - 4));
    }
    return;
}

