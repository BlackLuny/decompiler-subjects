// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_13;
	byte SCZO_14;
	word32 esi_15;
	byte SZO_16;
	byte C_17;
	word32 eax_18;
	byte Z_19;
	word32 ebx_20;
	word32 ebp_21;
	word32 edi_22;
	word32 edx_23;
	word32 ecx_24;
	byte cl_25;
	word16 ax_26;
	byte S_27;
	SHLWAPI.dll!StrChrA();
	if (eax_18 == 0x00)
	{
		*(esp_13 - 0x04) = ebx_20;
		*(esp_13 - 0x08) = ebp_21;
		*(esp_13 - 0x0C) = edi_22;
		*(esp_13 - 0x10) = 0x0040406C;
		*(esp_13 - 0x14) = 0x00404074;
		*(esp_13 - 0x14) = (HMODULE *) LoadLibraryA(*(esp_13 - 0x14));
		Eq_61 eax_51 = GetProcAddress(*(esp_13 - 0x14), *(esp_13 - 0x10));
		*(esp_13 - 0x10) = 0x00;
		*(esp_13 - 0x14) = 0x00;
		*(esp_13 - 0x18) = 0x00;
		*(esp_13 - 0x1C) = 0x00;
		*(esp_13 - 0x20) = 0x00;
		int32 eax_68 = eax_51();
		*(esp_13 - 0x24) = ~0x00;
		*(esp_13 - 0x28) = ~0x00;
		struct Eq_120 * ebp_321 = eax_68 + 0x1C;
		if (AreAllAccessesGranted(*(esp_13 - 0x28), *(esp_13 - 0x24)) == 0x00)
			ebp_321 = eax_68 + 0x1C ^ 0x0E;
		*(esp_13 - 0x24) = esp_13 - 0x10;
		*(esp_13 - 0x28) = 0x40;
		*(esp_13 - 44) = 0x3000;
		*(esp_13 - 0x30) = 0x00401000;
		VirtualProtect(*(esp_13 - 0x30), *(esp_13 - 44), *(esp_13 - 0x28), *(esp_13 - 0x24));
		struct Eq_191 * eax_103 = null;
		do
		{
			struct Eq_120 * esi_116;
			if (esi_116 == ebp_321)
				esi_116 = null;
			eax_103[4204008] = (struct Eq_191) (esi_116[0x00405000] ^ eax_103[4204008] ^ ~0x13);
			eax_103 = eax_103 + 0x01;
			esi_116 = esi_116 + 0x01;
		} while (eax_103 < (struct Eq_191 *) 5152);
		*(esp_13 - 0x08) = 0x00402368;
		*(esp_13 - 0x0C) = 0x00;
		struct Eq_229 * ebx_134 = &globals->t4038C8;
		int32 edi_136 = 0x00402368;
		uint32 ebp_137 = 0x00;
		do
		{
			Eq_237 eax_149 = ebx_134->t0004;
			cui16 * edx_157 = (char *) &ebx_134->t0004 + 0x04;
			if (eax_149 - 0x08 >> 0x01 > 0x00)
			{
				uint32 ebp_292 = eax_149 - 0x08 >> 0x01;
				do
				{
					if ((*edx_157 & 0xF000) == 0x3000)
					{
						struct Eq_263 * ecx_312 = ((word32) *edx_157 & 0x0FFF) + ebx_134->dw0000;
						ecx_312->dw402368 = ecx_312->dw402368 + 0xF0402368;
					}
					edx_157 = edx_157 + 0x01;
					ebp_292 = ebp_292 - 0x01;
				} while (ebp_292 != 0x00);
				ebp_137 = *(esp_13 - 0x0C);
			}
			ebp_137 = (word32) ebx_134->t0004 + ebp_137;
			*(esp_13 - 0x0C) = ebp_137;
			ebx_134 = ebx_134 + Mem165[ebx_134 + 0x04:word32];
		} while (ebp_137 < 228);
		*(esp_13 - 0x0C) = 0x004030C4;
		struct Eq_297 * ebx_173 = &globals->t4030C4;
		if (globals->dw4030D4 != 0x00)
		{
			edi_196 = edi_136;
			ebx_198 = ebx_173;
			do
			{
				int32 edi_196;
				struct Eq_297 * ebx_198;
				*(esp_13 - 0x24) = ebx_198->dw000C + edi_196;
				Eq_55 eax_206 = LoadLibraryA(*(esp_13 - 0x24));
				*(esp_13 - 0x04) = (HMODULE *) eax_206;
				Eq_55 ecx_208 = eax_206;
				if (eax_206 != null)
				{
					ptr32 ebp_231 = ebx_198->dw0000;
					if (ebp_231 == 0x00)
						ebp_231 = ebx_198->dw0010;
					Eq_353 eax_237 = ebp_231 + edi_196;
					struct Eq_356 * ebp_239 = ebp_231 + edi_196;
					word32 * esi_240 = ebx_198->dw0010 + edi_196;
					if (eax_237 != 0x00)
					{
						while (true)
						{
							Eq_61 eax_260;
							if (eax_237 < 0x00)
							{
								*(esp_13 - 0x24) = (word32) ebp_239->w0000;
								*(esp_13 - 0x28) = (HMODULE *) ecx_208;
								eax_260 = GetProcAddress(*(esp_13 - 0x28), *(esp_13 - 0x24));
							}
							else
							{
								*(esp_13 - 0x24) = (word32) eax_237 + 0x02 + edi_196;
								*(esp_13 - 0x28) = (HMODULE *) ecx_208;
								eax_260 = GetProcAddress(*(esp_13 - 0x28), *(esp_13 - 0x24));
							}
							*esi_240 = (word32) eax_260;
							ebp_239 = ebp_239 + 0x01;
							eax_237.u1 = ebp_239->w0000;
							edi_196 = *(esp_13 - 0x08);
							esi_240 = esi_240 + 0x01;
							if (eax_237 == 0x00)
								break;
							ecx_208 = (Eq_55) *(esp_13 - 0x04);
						}
						ebx_198 = (struct Eq_297 *) *(esp_13 - 0x0C);
					}
				}
				ebx_198 = ebx_198 + 0x01;
				*(esp_13 - 0x0C) = (struct Eq_297 **) ebx_198;
			} while (ebx_198->dw0010 != 0x00);
		}
		ptr32 esp_176;
		byte SCZO_177;
		word32 esi_178;
		byte SZO_179;
		byte C_180;
		word32 eax_181;
		byte Z_182;
		word32 ebx_183;
		word32 ebp_184;
		word32 edi_185;
		word32 edx_186;
		word32 ecx_187;
		byte cl_188;
		word16 ax_189;
		byte S_190;
		globals->t402DB8();
		*(esp_176 - 0x04) = 0x00;
		ExitProcess(*(esp_176 - 0x04));
	}
	else
		return 0x00;
}

