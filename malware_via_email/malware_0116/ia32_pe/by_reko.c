// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401020: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00403640(35116, dwLoc14);
	Eq_10 eax_17 = fn00403590();
	if (eax_17 == 0x00)
		return 0x00;
	Eq_17 eax_128 = globals->t40603C;
	struct Eq_20 * ecx_130 = globals->a401C00;
	ui32 * ebx_134 = (word32) fp - 14948;
	do
	{
		*ebx_134 = (globals->t40603C | 0xA605EF2A) ^ ecx_130->dw0000;
		ecx_130 = ecx_130 + 0x01;
		ebx_134 = ebx_134 - eax_128 * 0x05 + 0x04;
	} while (ecx_130 <= (struct Eq_20 *) ~0x00400490);
	struct Eq_46 * ecx_157 = null;
	int32 eax_162 = ((word32) eax_128 + 0x01) * 0x04;
	do
	{
		*ebx_134 = (word32) (eax_128 >= ~0x59FA10D4) - 1509560534 ^ ecx_157->dw404060;
		ebx_134 = ebx_134 + eax_162;
		ecx_157 = ecx_157 + (uint32) (0x04 /u ((word32) eax_128 + 0x01));
	} while (ecx_157 <= (struct Eq_46 *) 0x1A57);
	ui32 edx_1816 = (word32) fp - 2204 ^ (word32) fp - 2204;
	byte * dwLoc88D4_1015 = (word32) fp - 14948;
	struct Eq_81 * dwLoc890C_1828 = (word32) fp - 2204;
	byte dl_1817 = (byte) edx_1816;
	word16 dx_1818 = (word16) edx_1816;
	do
	{
		dwLoc890C_1828->w0000 = dx_1818;
		dwLoc890C_1828->w0000 = dx_1818;
		if ((dl_1817 & 0x01) == 0x00)
		{
			dwLoc890C_1828->b0004 = (byte) ((word32) *dwLoc88D4_1015 >> (byte) ((word32) bLoc8914));
			ui32 edx_1802 = edx_1816 + 0x01;
			struct Eq_137 * v21_1811 = dwLoc890C_1828 + 0x01;
			v21_1811->b0004 = (byte) ((word32) *dwLoc88D4_1015 >> (byte) ((word32) bLoc8914));
			edx_1816 = edx_1802 + 0x01;
			dl_1817 = (byte) (edx_1802 + 0x01);
			dx_1818 = (word16) (edx_1802 + 0x01);
			dwLoc890C_1828 = (struct Eq_81 *) (&v21_1811->b0004 + 0x02);
			if (edx_1802 + 0x01 == (eax_128 | 0x0108))
				break;
			continue;
		}
		dwLoc890C_1828->b0004 = (byte) ((word32) *dwLoc88D4_1015 & 0x0F);
		edx_1816 = edx_1816 + 0x01;
		dl_1817 = (byte) edx_1816;
		dx_1818 = (word16) edx_1816;
		dwLoc88D4_1015 = dwLoc88D4_1015 + 0x01;
		dwLoc890C_1828 = dwLoc890C_1828 + 0x01;
	} while (edx_1816 == (eax_128 | 0x0108));
	int32 eax_238 = 0x02;
	do
	{
		eax_238 - 0x1F + (fp - 0x04) = (byte *) 0x00;
		eax_238 = eax_238 + 0x01;
	} while (eax_238 != 0x11);
	int32 ecx_251 = ~0x0893;
	do
	{
		ci8 al_264 = (byte) (word32) *((word32) (fp - (uint32 *) 0x04) + (ecx_251 + 0x00));
		if (al_264 > 0x00)
		{
			Eq_183 edx_1796 = (uint32) ((uint64) (uint32) (int32) al_264 % (eax_128 - 0x01));
			Mem1799[fp - 0x22 + edx_1796:byte] = Mem243[fp - 0x22 + edx_1796:byte] + 0x01;
		}
		ecx_251 = ecx_251 + 0x06;
	} while (ecx_251 != 0x0EC4);
	uint32 ebx_276 = 0x00;
	int32 edx_279 = 0x01;
	do
	{
		ebx_276 = ebx_276 + (int32) (*((word32) (fp - (uint32 *) 0x04) + (edx_279 - 0x1F))) << (byte) ((0x00 - (eax_128 < 0x01)) + 0x02);
		*((word32) (fp - 100) + edx_279 * 0x04) = (word32) eax_128 + ebx_276;
		edx_279 = edx_279 + 0x01;
	} while (edx_279 != 0x10);
	word32 ecx_303 = fp + ~0x0897;
	do
	{
		int32 edx_308 = (int32) *ecx_303;
		word32 eax_309 = *((word32) (fp - 100) + edx_308 * 0x04);
		*(ecx_303 - 0x02) = (word16) eax_309;
		*((word32) (fp - 100) + edx_308 * 0x04) = eax_309 + 0x01;
		ecx_303 = ecx_303 + 0x06;
	} while (ecx_303 != fp - 616);
	uint32 ebx_350;
	uint32 eax_324 = (uint32) (0x0108 /u ((word32) eax_128 + 0x01));
	byte cl_326 = 0x00;
	uint32 edx_328 = 0x00;
	if (0x00 >= eax_324 - 0x01)
	{
		do
		{
			if (cl_326 == 0x00)
			{
				int32 edi_1024 = 0x80;
				uint32 edx_462 = SLICE(eax_128 * ~0x00FF00FE, word32, 32);
				Eq_326 dwLoc88CC_466 = -eax_128;
l0040169A:
				int32 ebx_1023 = edi_1024;
				ui32 esi_1700 = 0x00;
				int32 edi_497 = 0x00;
				int32 dwLoc88A4_499 = 0x00;
				struct Eq_438 * dwLoc88D0_1733 = (struct Eq_438 *) ~0x00;
l004016D2:
				ui32 edx_519 = eax_128 | 0x01;
				ui32 ecx_1787 = 0x00;
				do
				{
					ecx_1787 = ecx_1787 * 0x02;
					if (((word32) *dwLoc88D4_1015 & ebx_1023) != 0x00)
						ecx_1787 = ecx_1787 | 0x01;
					ebx_1023 = ebx_1023 >> 0x01;
					if (ebx_1023 == 0x00)
					{
						dwLoc88D4_1015 = dwLoc88D4_1015 + 0x01;
						ebx_1023 = 0x80;
					}
					edx_519 = edx_519 - 0x01;
				} while (edx_519 != 0x00);
				int32 v31_566 = dwLoc88A4_499 << 0x01 | ecx_1787;
				Eq_406 eax_569 = esi_1700 * 0x03 * 0x02;
				edi_497 = edi_497 + 0x01;
				dwLoc88A4_499 = v31_566;
				word32 edx_1773 = (int32) Mem318[fp + ~0x0897 + eax_569:byte];
				if (edi_497 > edx_1773)
				{
					word32 eax_1767 = fp + ~0x089B + eax_569 + 0x0A;
					do
					{
						edx_1773 = (int32) *eax_1767;
						esi_1700 = esi_1700 + 0x01;
						eax_1767 = eax_1767 + 0x06;
					} while (edi_497 > edx_1773);
				}
				if (edi_497 != edx_1773)
				{
					if (dwLoc88D0_1733 < null)
						goto l004016D2;
					word32 edx_608 = eax_128 + 0x01 << 0x08;
					if (dwLoc88D0_1733 >= edx_608)
					{
						if (dwLoc88D0_1733 == (edx_462 >> 0x08) + 0x0100)
						{
							if (dwLoc88CC_466 > 0x00)
							{
								word32 edi_1566 = eax_128 + 0x01 + (eax_128 + 0x01) * 0x02;
								struct Eq_973 * esi_1567 = (struct Eq_973 *) ~0x00;
								Eq_326 ebx_1572 = 0x00;
								Eq_17 edi_1573 = 0x00;
								ui32 v47_1578 = 0x40 - eax_128 * 0x41;
								do
								{
									Eq_986 eax_1598 = (word32) *((word32) (fp - (uint32 *) 0x04) + ((word32) ebx_1572 - 0x00008898));
									byte al_1600 = (byte) eax_1598;
									if (eax_128 != 0x00)
									{
										eax_1598 = (uint32) ((uint64) (uint32) (uint32) ((uint64) (uint32) eax_1598 /u eax_128) /u eax_128);
										al_1600 = (byte) eax_1598;
									}
									Eq_986 edx_1610 = eax_1598;
									if (esi_1567 <= (struct Eq_973 *) 0x43)
									{
										if (edi_1573 < (eax_128 | 0x10))
										{
											if (*((word32) edi_1573 + 0x00404000) != al_1600)
											{
												edi_1573 = eax_128;
												edx_1610 = eax_1598;
											}
											else
											{
												edi_1573 = (word32) edi_1573 + 0x01;
												edx_1610 = eax_1598;
											}
										}
										else
										{
											esi_1567 = esi_1567 + 0x01;
											if (esi_1567 <= (struct Eq_973 *) 0x2F)
											{
												int32 eax_1651 = (int32) esi_1567[0x00404010];
												edx_1610.u0 = ~0x00;
												if (eax_1651 != ~0x00)
													edx_1610 = (uint32) ((uint64) (uint32) eax_1651 % (eax_128 - (struct Eq_1623 *) 0x01));
											}
											else if (esi_1567 <= (struct Eq_973 *) 0x3F)
												edx_1610 = (int32) (esi_1567 - (edi_1566 << 0x04))->b404040;
											else
												edx_1610 = (int32) (esi_1567 - v47_1578)->b406000;
										}
									}
									Mem1627[ebx_1572 + ~0x8897 + (fp - 0x04):byte] = (byte) (edx_1610 *s (eax_128 + 0x01));
									ebx_1572 = (word32) ebx_1572 + 0x01;
								} while (ebx_1572 == dwLoc88CC_466);
							}
							*(fp - 0x10) = 4219229612;
							globals->dw406028 = 0x00;
							*(fp - 0x0C) = eax_17;
							int32 eax_1062 = fn00403390(dwArg00, dwArg04);
							*(fp - (uint32 *) 0x10) = 3424463584;
							*(fp - 0x0C) = eax_17;
							globals->dw406028 = eax_1062;
							int32 eax_1067 = fn00403390(dwArg00, dwArg04);
							Eq_17 edx_1068 = globals->t40603C;
							*(fp - 0x0C) = fp - 0x026C;
							*(fp - (uint32 *) 0x10) = 0x0104;
							globals->dw406014 = eax_1067;
							<anonymous> * eax_1073 = eax_1067 *s ((word32) edx_1068 + 0x01);
							struct Eq_800 * esp_1075;
							word32 ebp_1076;
							word32 eax_1077;
							word32 edi_1078;
							word32 esi_1079;
							word32 ebx_1080;
							byte SZO_1081;
							byte C_1082;
							byte Z_1083;
							word32 edx_1084;
							word32 ecx_1085;
							byte SCZO_1086;
							byte CZ_1087;
							byte al_1088;
							byte dl_1089;
							word16 dx_1090;
							byte cl_1091;
							word16 ax_1092;
							word16 cx_1093;
							byte S_1094;
							word16 di_1095;
							eax_1073();
							*(esp_1075 - 0x04) = esi_1079;
							*(esp_1075 - 0x08) = ~0x6B8AA076;
							int32 eax_1100 = fn00403390(dwArg00, dwArg04);
							Eq_17 edx_1101 = globals->t40603C;
							*(esp_1075 - 0x08) = (union Eq_838 *) (fp - (uint32 *) 0x026C);
							esp_1075->dw0000 = 0x00;
							*(esp_1075 - 0x04) = 0x00;
							globals->dw406010 = eax_1100;
							esp_1075->t0004 = fp - 0x0168;
							<anonymous> * eax_1107 = eax_1100 *s ((word32) edx_1101 + 0x01);
							struct Eq_864 * esp_1111;
							word32 ebp_1112;
							word32 eax_1113;
							word32 edi_1114;
							word32 esi_1115;
							word32 ebx_1116;
							byte SZO_1117;
							byte C_1118;
							byte Z_1119;
							word32 edx_1120;
							word32 ecx_1121;
							byte SCZO_1122;
							byte CZ_1123;
							byte al_1124;
							byte dl_1125;
							word16 dx_1126;
							byte cl_1127;
							word16 ax_1128;
							word16 cx_1129;
							byte S_1130;
							word16 di_1131;
							eax_1107();
							*(esp_1111 - 0x0C) = esi_1115;
							*(esp_1111 - 0x10) = 2165515512;
							int32 eax_1137 = fn00403390(dwArg00, dwArg04);
							Eq_17 edx_1138 = globals->t40603C;
							esp_1111->dw0008 = 0x00;
							esp_1111->dw0004 = 0x00;
							esp_1111->dw0000 = 0x02;
							*(esp_1111 - 0x04) = 0x00;
							globals->dw406004 = eax_1137;
							*(esp_1111 - 0x08) = 0x01;
							*(esp_1111 - 0x0C) = 0xC0000000;
							*(esp_1111 - 0x10) = (union Eq_935 *) (fp - 0x0168);
							<anonymous> * eax_1145 = eax_1137 *s ((word32) edx_1138 + 0x01);
							ptr32 esp_1150;
							word32 ebp_1151;
							word32 eax_1152;
							word32 edi_1153;
							word32 esi_1154;
							word32 ebx_1155;
							byte SZO_1156;
							byte C_1157;
							byte Z_1158;
							word32 edx_1159;
							word32 ecx_1160;
							byte SCZO_1161;
							byte CZ_1162;
							byte al_1163;
							byte dl_1164;
							word16 dx_1165;
							byte cl_1166;
							word16 ax_1167;
							word16 cx_1168;
							byte S_1169;
							word16 di_1170;
							eax_1145();
							if (eax_1152 != ~0x00)
							{
								*(esp_1150 - 0x1C) = 2390103535;
								*(esp_1150 - 0x18) = (union Eq_10 *) eax_17;
								int32 eax_1179 = fn00403390(dwArg00, dwArg04);
								Eq_17 edx_1180 = globals->t40603C;
								*(esp_1150 - 0x08) = 0x00;
								*(esp_1150 - 0x10) = 0x00;
								*(esp_1150 - 0x14) = 0x04;
								*(esp_1150 - 0x18) = 0x00;
								globals->dw40602C = eax_1179;
								*(esp_1150 - 0x1C) = eax_1152;
								word32 edx_1190 = dwLoc88CC_466 + 0x01;
								*(esp_1150 - 0x0C) = (union Eq_1063 *) edx_1190;
								<anonymous> * eax_1187 = eax_1179 *s ((word32) edx_1180 + 0x01);
								ptr32 esp_1193;
								word32 ebp_1194;
								word32 eax_1195;
								word32 edi_1196;
								word32 esi_1197;
								word32 ebx_1198;
								byte SZO_1199;
								byte C_1200;
								byte Z_1201;
								word32 edx_1202;
								word32 ecx_1203;
								byte SCZO_1204;
								byte CZ_1205;
								byte al_1206;
								byte dl_1207;
								word16 dx_1208;
								byte cl_1209;
								word16 ax_1210;
								word16 cx_1211;
								byte S_1212;
								word16 di_1213;
								eax_1187();
								*(esp_1193 - 0x14) = (union Eq_10 *) eax_17;
								*(esp_1193 - 0x18) = 0xFC1F1484;
								int32 eax_1220 = fn00403390(dwArg00, dwArg04);
								Eq_17 edx_1221 = globals->t40603C;
								*(esp_1193 - 0x08) = 0x00;
								*(esp_1193 - 0x0C) = 0x00;
								*(esp_1193 - 0x10) = 0x00;
								globals->dw406030 = eax_1220;
								*(esp_1193 - 0x14) = 0x02;
								*(esp_1193 - 0x18) = eax_1195;
								<anonymous> * eax_1228 = eax_1220 *s ((word32) edx_1221 + 0x01);
								word32 esp_1232;
								word32 ebp_1233;
								word32 eax_1234;
								word32 edi_1235;
								word32 esi_1236;
								word32 ebx_1237;
								byte SZO_1238;
								byte C_1239;
								byte Z_1240;
								word32 edx_1241;
								word32 ecx_1242;
								byte SCZO_1243;
								byte CZ_1244;
								byte al_1245;
								byte dl_1246;
								word16 dx_1247;
								byte cl_1248;
								word16 ax_1249;
								word16 cx_1250;
								byte S_1251;
								word16 di_1252;
								eax_1228();
								word32 esi_1254 = eax_1234;
								struct Eq_1169 * esp_1256 = esp_1232 - 0x14;
								if (dwLoc88CC_466 > 0x00)
								{
									Eq_326 ebx_1523 = 0x00;
									do
									{
										Eq_17 edx_1531 = globals->t40603C;
										esp_1256->t0004 = fp - 0x12;
										word32 eax_1536 = (word32) ebx_1523 + esi_1254;
										<anonymous> * edx_1538 = ((word32) edx_1531 + 0x01) *s globals->dw406028;
										esp_1256->dw0000 = eax_1536;
										word32 esp_1541;
										word32 ebp_1542;
										word32 eax_1543;
										word32 edi_1544;
										byte SZO_1547;
										byte C_1548;
										byte Z_1549;
										word32 edx_1550;
										word32 ecx_1551;
										byte SCZO_1552;
										byte CZ_1553;
										byte al_1554;
										byte dl_1555;
										word16 dx_1556;
										byte cl_1557;
										word16 ax_1558;
										word16 cx_1559;
										byte S_1560;
										word16 di_1561;
										edx_1538();
										esp_1256 = esp_1541 - 0x08;
									} while (ebx_1523 != dwLoc88CC_466);
								}
								esp_1256->dw0000 = ~0x3489B267;
								esp_1256->t0004 = eax_17;
								int32 eax_1265 = fn00403390(dwArg00, dwArg04);
								Eq_17 edx_1266 = globals->t40603C;
								esp_1256->dw0000 = esi_1254;
								globals->dw406034 = eax_1265;
								<anonymous> * eax_1270 = eax_1265 *s ((word32) edx_1266 + 0x01);
								union Eq_10 * esp_1272;
								word32 ebp_1273;
								word32 eax_1274;
								word32 edi_1275;
								word32 esi_1276;
								word32 ebx_1277;
								byte SZO_1278;
								byte C_1279;
								byte Z_1280;
								word32 edx_1281;
								word32 ecx_1282;
								byte SCZO_1283;
								byte CZ_1284;
								byte al_1285;
								byte dl_1286;
								word16 dx_1287;
								byte cl_1288;
								word16 ax_1289;
								word16 cx_1290;
								byte S_1291;
								word16 di_1292;
								eax_1270();
								*esp_1272 = (union Eq_10 *) eax_17;
								*(esp_1272 - 0x04) = 0x941A1EE1;
								int32 eax_1298 = fn00403390(dwArg00, dwArg04);
								Eq_17 edx_1299 = globals->t40603C;
								*(esp_1272 - 0x04) = eax_1195;
								globals->dw406008 = eax_1298;
								<anonymous> * eax_1305 = eax_1298 *s ((word32) edx_1299 + 0x01);
								ptr32 esp_1307;
								word32 ebp_1308;
								word32 eax_1309;
								word32 edi_1310;
								word32 esi_1311;
								word32 ebx_1312;
								byte SZO_1313;
								byte C_1314;
								byte Z_1315;
								word32 edx_1316;
								word32 ecx_1317;
								byte SCZO_1318;
								byte CZ_1319;
								byte al_1320;
								byte dl_1321;
								word16 dx_1322;
								byte cl_1323;
								word16 ax_1324;
								word16 cx_1325;
								byte S_1326;
								word16 di_1327;
								eax_1305();
								<anonymous> * eax_1330 = ((word32) globals->t40603C + 0x01) *s globals->dw406008;
								*(esp_1307 - 0x04) = edi_1310;
								union Eq_10 * esp_1334;
								word32 ebp_1335;
								word32 eax_1336;
								word32 edi_1337;
								word32 esi_1338;
								word32 ebx_1339;
								byte SZO_1340;
								byte C_1341;
								byte Z_1342;
								word32 edx_1343;
								word32 ecx_1344;
								byte SCZO_1345;
								byte CZ_1346;
								byte al_1347;
								byte dl_1348;
								word16 dx_1349;
								byte cl_1350;
								word16 ax_1351;
								word16 cx_1352;
								byte S_1353;
								word16 di_1354;
								eax_1330();
								*esp_1334 = (union Eq_10 *) eax_17;
								*(esp_1334 - 0x04) = 0xDE0B22C2;
								int32 eax_1360 = fn00403390(dwArg00, dwArg04);
								Eq_17 edx_1361 = globals->t40603C;
								globals->dw40601C = eax_1360;
								*(esp_1334 - 0x04) = (union Eq_1315 *) (fp - 0x0168);
								<anonymous> * eax_1364 = eax_1360 *s ((word32) edx_1361 + 0x01);
								struct Eq_1324 * esp_1368;
								word32 ebp_1369;
								word32 eax_1370;
								Eq_1327 edi_1371;
								word32 esi_1372;
								word32 ebx_1373;
								byte SZO_1374;
								byte C_1375;
								byte Z_1376;
								word32 edx_1377;
								word32 ecx_1378;
								byte SCZO_1379;
								byte CZ_1380;
								byte al_1381;
								byte dl_1382;
								word16 dx_1383;
								byte cl_1384;
								word16 ax_1385;
								word16 cx_1386;
								byte S_1387;
								word16 di_1388;
								eax_1364();
								esp_1368->t0000 = edi_1371;
								*(esp_1368 - 0x04) = 2843221742;
								int32 eax_1394 = fn00403390(dwArg00, dwArg04);
								Eq_17 edx_1395 = globals->t40603C;
								esp_1368->t0000 = fp - 0x026C;
								esp_1368->dw0004 = 0x0104;
								*(esp_1368 - 0x04) = 0x00;
								globals->dw406018 = eax_1394;
								<anonymous> * eax_1402 = eax_1394 *s ((word32) edx_1395 + 0x01);
								ptr32 esp_1404;
								word32 ebp_1405;
								word32 eax_1406;
								word32 edi_1407;
								word32 esi_1408;
								word32 ebx_1409;
								byte SZO_1410;
								byte C_1411;
								byte Z_1412;
								word32 edx_1413;
								word32 ecx_1414;
								byte SCZO_1415;
								byte CZ_1416;
								byte al_1417;
								byte dl_1418;
								word16 dx_1419;
								byte cl_1420;
								word16 ax_1421;
								word16 cx_1422;
								byte S_1423;
								word16 di_1424;
								eax_1402();
								*(esp_1404 - 0x08) = ebx_1409;
								*(esp_1404 - 0x0C) = 4229121209;
								int32 eax_1429 = fn00403390(dwArg00, dwArg04);
								Eq_17 edx_1430 = globals->t40603C;
								*(esp_1404 - 0x0C) = (union Eq_1419 *) (fp - 0x026C);
								globals->dw406038 = eax_1429;
								<anonymous> * eax_1434 = eax_1429 *s ((word32) edx_1430 + 0x01);
								word32 * esp_1436;
								word32 ebp_1437;
								word32 eax_1438;
								word32 edi_1439;
								word32 esi_1440;
								word32 ebx_1441;
								byte SZO_1442;
								byte C_1443;
								byte Z_1444;
								word32 edx_1445;
								word32 ecx_1446;
								byte SCZO_1447;
								byte CZ_1448;
								byte al_1449;
								byte dl_1450;
								word16 dx_1451;
								byte cl_1452;
								word16 ax_1453;
								word16 cx_1454;
								byte S_1455;
								word16 di_1456;
								eax_1434();
								*esp_1436 = edi_1439;
								*(esp_1436 - 0x04) = ~0x61F0C037;
								int32 eax_1461 = fn00403390(dwArg00, dwArg04);
								Eq_17 edx_1462 = globals->t40603C;
								*(esp_1436 - 0x04) = ebx_1441;
								globals->dw406020 = eax_1461;
								<anonymous> * eax_1466 = eax_1461 *s ((word32) edx_1462 + 0x01);
								word32 * esp_1468;
								word32 ebp_1469;
								word32 eax_1470;
								word32 edi_1471;
								word32 esi_1472;
								word32 ebx_1473;
								byte SZO_1474;
								byte C_1475;
								byte Z_1476;
								word32 edx_1477;
								word32 ecx_1478;
								byte SCZO_1479;
								byte CZ_1480;
								byte al_1481;
								byte dl_1482;
								word16 dx_1483;
								byte cl_1484;
								word16 ax_1485;
								word16 cx_1486;
								byte S_1487;
								word16 di_1488;
								eax_1466();
								*esp_1468 = edi_1471;
								*(esp_1468 - 0x04) = 2651074515;
								int32 eax_1493 = fn00403390(dwArg00, dwArg04);
								Eq_17 edx_1494 = globals->t40603C;
								*(esp_1468 - 0x04) = 0x00;
								globals->dw406024 = eax_1493;
								<anonymous> * eax_1498 = eax_1493 *s ((word32) edx_1494 + 0x01);
								word32 esp_1500;
								word32 ebp_1501;
								word32 eax_1502;
								word32 edi_1503;
								word32 esi_1504;
								word32 ebx_1505;
								byte SZO_1506;
								byte C_1507;
								byte Z_1508;
								word32 edx_1509;
								word32 ecx_1510;
								byte SCZO_1511;
								byte CZ_1512;
								byte al_1513;
								byte dl_1514;
								word16 dx_1515;
								byte cl_1516;
								word16 ax_1517;
								word16 cx_1518;
								byte S_1519;
								word16 di_1520;
								eax_1498();
							}
							return 0x00;
						}
						else
						{
							byte cl_1027;
							ui32 esi_1030;
							byte bLoc88ED_1029;
							Eq_548 dwLoc88C0_1013;
							word32 v34_638 = dwLoc88D0_1733 - (edx_608 + (eax_128 + 0x01));
							word32 eax_647 = (uint32) ((uint64) (uint32) (int32) (v34_638 * 0x03)->a405AC0[v34_638].w0000 /u (eax_128 + 0x01));
							word16 ax_654 = (word16) (word32) (v34_638 * 0x03)->a405AC2[v34_638].w0000;
							word16 di_656 = (word16) (word32) (v34_638 * 0x03)->a405AC4[v34_638].w0000;
							if (eax_647 != 0x00)
							{
								cl_1027 = (byte) (word32) *dwLoc88D4_1015;
								dwLoc88C0_1013 = eax_647;
								edi_1024 = ebx_1023 >> 0x01;
								bLoc88ED_1029 = cl_1027;
								esi_1030 = (word32) cl_1027;
							}
							else
							{
								int32 edx_928 = (int32) ax_654;
								cl_1027 = (byte) (word32) *dwLoc88D4_1015;
								ui32 dwLoc88BC_1044 = 0x00;
								int32 eax_1016 = edx_928 - (edx_928 | 0x01) *s eax_128;
								bLoc88ED_1029 = cl_1027;
								do
								{
									ui32 v39_960 = dwLoc88BC_1044 << 0x01;
									esi_1030 = (word32) cl_1027;
									dwLoc88BC_1044 = v39_960 << 0x01;
									if ((esi_1030 & ebx_1023) != 0x00)
										dwLoc88BC_1044 = v39_960 << 0x01 | 0x01 | 0x01;
									ebx_1023 = ebx_1023 >> 0x01;
									if (ebx_1023 == 0x00)
									{
										byte * v42_1014 = dwLoc88D4_1015 + 0x01;
										cl_1027 = (byte) (word32) *v42_1014;
										dwLoc88D4_1015 = v42_1014;
										eax_1016 = eax_1016 - 0x01;
										ebx_1023 = 0x80;
										edi_1024 = 0x40;
										bLoc88ED_1029 = cl_1027;
										esi_1030 = (word32) cl_1027;
										if (eax_1016 == 0x00)
											break;
										continue;
									}
									edi_1024 = ebx_1023 >> 0x01;
									eax_1016 = eax_1016 - 0x01;
								} while (eax_1016 == 0x00);
								Eq_710 eax_988 = (int32) di_656;
								uint32 edx_999 = (word32) eax_988 + (uint32) ((uint64) ((uint32) eax_128) /u (eax_988 | 0x01));
								dwLoc88C0_1013 = (uint32) ((uint64) (uint32) eax_128 /u (edx_999 | 0x01)) + edx_999 + dwLoc88BC_1044;
							}
							int32 dwLoc88B4_684;
							ui32 eax_691;
							if (edi_1024 != 0x00)
							{
								dwLoc88B4_684 = edi_1024 >> 0x01;
								eax_691 = esi_1030;
							}
							else
							{
								byte * v41_902 = dwLoc88D4_1015 + 0x01;
								cl_1027 = (byte) (word32) *v41_902;
								dwLoc88D4_1015 = v41_902;
								edi_1024 = 0x80;
								dwLoc88B4_684 = 0x40;
								eax_691 = (word32) cl_1027;
								bLoc88ED_1029 = cl_1027;
							}
							ui32 dwLoc88C4_701 = 0x07;
							if ((esi_1030 & ebx_1023) != 0x00)
							{
								if (dwLoc88B4_684 == 0x00)
								{
									byte * v37_886 = dwLoc88D4_1015 + 0x01;
									dwLoc88D4_1015 = v37_886;
									dwLoc88B4_684 = 0x80;
									bLoc88ED_1029 = (byte) (word32) *v37_886;
								}
								cl_1027 = (byte) (word32) bLoc88ED_1029;
								edi_1024 = dwLoc88B4_684;
								dwLoc88C4_701 = (word32) ((eax_691 & edi_1024) != 0x00) + (eax_128 | 0x08);
							}
							struct Eq_621 * eax_718 = dwLoc88C4_701 * 0x03;
							uint32 edx_715 = ~0x00;
							word32 ebx_720 = (int32) Mem318[eax_718 + 0x00405AC2 + eax_718:word16];
							if (ebx_720 != ~0x00)
								edx_715 = (uint32) ((uint64) (uint32) ebx_720 % (eax_128 - (struct Eq_672 *) 0x01));
							Eq_668 esi_729 = 0x00;
							while (true)
							{
								esi_729 = esi_729 * 0x02;
								if (((word32) cl_1027 & edi_1024) != 0x00)
									esi_729 = esi_729 | 0x01;
								edi_1024 = edi_1024 >> 0x01;
								if (edi_1024 == 0x00)
								{
									dwLoc88D4_1015 = dwLoc88D4_1015 + 0x01;
									edi_1024 = 0x80;
								}
								edx_715 = edx_715 - 0x01;
								if (edx_715 == 0x00)
									break;
								cl_1027 = (byte) (word32) *dwLoc88D4_1015;
							}
							struct Eq_1632 * eax_767 = dwLoc88C4_701 * 0x03;
							word32 edx_771 = (int32) Mem318[eax_767 + 0x00405AC4 + eax_767:word16];
							if (eax_128 != 0x00)
								edx_771 = edx_771 * 0x02;
							if (dwLoc88C0_1013 > 0x00)
							{
								word32 ebx_803 = fp + 4294932324 + dwLoc88CC_466;
								word32 dwLoc890C_809 = ebx_803 - ((esi_729 + eax_128) + edx_771);
								Eq_548 esi_810 = 0x00;
								do
								{
									*ebx_803 = (byte) (uint32) ((uint64) (uint32) (word32) *dwLoc890C_809 /u ((word32) globals->t40603C + 0x01));
									esi_810 = (word32) esi_810 + 0x01;
									dwLoc890C_809 = dwLoc890C_809 + 0x01;
									ebx_803 = ebx_803 + 0x01;
								} while (esi_810 != dwLoc88C0_1013);
							}
							dwLoc88CC_466 = dwLoc88CC_466 + dwLoc88C0_1013 - (dwLoc88C0_1013 | 0x01) *s Mem318[0x0040603C:word32];
							continue;
						}
					}
					else
					{
						Mem618[fp + 4294932324 + dwLoc88CC_466:byte] = (byte) (word32) bLoc88D0;
						word32 edx_619 = dwLoc88CC_466 + 0x01;
						Mem626[fp + 4294932324 + edx_619:byte] = (byte) (word32) bLoc88D0;
						edi_1024 = ebx_1023;
						dwLoc88CC_466 = edx_619 + 0x01;
						goto l0040169A;
					}
				}
				else
				{
					ui32 eax_1714 = esi_1700 * 0x03;
					word32 edx_1720 = fp + ~0x089B + eax_1714 * 0x02;
					if ((int32) *((word32) fp + (eax_1714 * 0x02 - 2202)) != v31_566)
					{
						do
						{
							word32 esi_1751 = esi_1700 + 0x01;
							esi_1700 = esi_1751 + 0x01;
							if ((int32) *((word32) edx_1846 + 0x0A) != edi_497)
								goto l0040177D;
							edx_1720 = (word32) edx_1846 + 0x06;
							Eq_446 edx_1846 = edx_1720;
						} while ((int32) *((word32) edx_1846 + 0x08) == v31_566);
					}
					int32 eax_1729 = (int32) *((word32) fp + ((esi_1700 * 0x03) * 0x02 - 2204));
					dwLoc88D0_1733 = (struct Eq_438 *) ~0x00;
					if (eax_1729 == ~0x00)
						continue;
					struct Eq_438 * edx_1739 = (uint32) ((uint64) (uint32) eax_1729 % (eax_128 - 0x01));
					dwLoc88D0_1733 = edx_1739;
					if (edx_1739 >= null)
						break;
					continue;
				}
			}
			cl_326 = 0x00;
			ebx_350 = 0x00;
l00401249:
			edx_328 = ebx_350;
		} while (edx_328 >= eax_324 - 0x01);
	}
	word32 edi_344 = fp - 0x10 + (edx_328 * 0x03) * 0x02;
	ebx_350 = edx_328 + 0x01;
	byte al_349 = (byte) (word32) *((word32) edi_344 - 0x0888);
	word32 eax_355 = fp - 0x10 + (ebx_350 * 0x03) * 0x02;
	if ((byte) (word32) al_349 > *(eax_355 - 0x0888))
	{
		word16 dx_367 = (word16) (word32) *((word32) edi_344 - 0x088A);
		Eq_336 cx_369 = (word16) (word32) *((word32) edi_344 - 0x088C);
		*((word32) edi_344 - 0x088C) = *((word32) eax_355 - 0x088C);
		*((word32) edi_344 - 0x0888) = (word16) (word32) *(eax_355 - 0x0888);
		*(eax_355 - 0x088A) = dx_367;
		*(eax_355 - 0x0888) = (byte) (word32) al_349;
		*((word32) eax_355 - 0x088C) = cx_369;
		cl_326 = 0x01;
		edx_328 = ebx_350;
		goto l0040124B;
	}
	goto l00401249;
}

// 00403390: Register uint32 fn00403390(Stack word32 dwArg04, Stack word32 dwArg08)
uint32 fn00403390(word32 dwArg04, word32 dwArg08)
{
fn00403390_entry:
	uint32 edx_132
	Eq_17 ebx_155 = globals->t40603C
	Eq_1704 edi_26 = dwArg08 | ebx_155
	struct Eq_1707 * edx_30 = (word32) edi_26 + 0x0078 + dwArg08->dw003C + (dwArg08 - (dwArg08 | 0x01) *s ebx_155)
	struct Eq_1720 * esp_15 = fp - 0xAC
	Eq_17 dwLoc84_161 = ebx_155
	word16 * eax_31 = edx_30->ptr0024
	ui32 ecx_34 = edx_30->dw0020
	branch (uint32) ((uint64) (uint32) edx_30->dw0018 /u ((word32) ebx_155 + 0x01)) == 0x00 l00403540
	goto l004033F0
l00403390:
l004033F0:
	uint32 dwLoc88_141 = 0x00
	struct Eq_1928 * ecx_143[] = dwArg08 + (ecx_34 - (ecx_34 | 0x01) *s ebx_155) / 0x0040
	word32 dwLoc8C_146 = edi_26 + eax_31
l00403422:
	word32 ecx_165 = dwArg08 + ecx_143[dwLoc88_141 * 0x04]
	Eq_1755 esi_166 = 0x00
	byte al_171 = (byte) (word32) ecx_165->a0000[0x00]
	branch al_171 == 0x00 l004034C1
l00403447:
	Eq_1755 edi_302 = 0x00
	goto l00403488
l00403450:
	esp_15->dw0004 = (uint32) ((uint64) (uint32) (fp - 0x12) /u eax_334)
	ptr32 eax_375 = (word32) edi_302.u0 + (fp - 114)
	esp_15->ptr0000 = eax_375
	word32 esp_378
	word32 ebp_379
	word32 edi_380
	word32 ebx_382
	byte SCZO_383
	word32 eax_384
	word32 ecx_385
	word32 edx_386
	byte SZO_387
	byte C_388
	byte Z_389
	byte al_390
	byte dl_391
	byte CZ_392
	ecx_337()
	ebx_155 = globals->t40603C
	esp_15 = esp_378 - 0x08
l00403475:
	esi_166 = (word32) esi_166.u0 + 0x01
	edi_302 = esi_166
	al_171 = (byte) (word32) Mem0[ecx_165 + esi_166:byte] (alias)
	branch al_171 == 0x00 l004034C1
l00403488:
	byte al_321 = (byte) (int32) al_171
	branch ebx_155 == 0x00 l00403493
	Eq_1768 eax_325 = (int32) al_321
	branch ebx_155 == 0x00 l00403493
l0040348F:
	eax_325 = (uint32) ((uint64) (uint32) (uint32) ((uint64) (uint32) eax_325 /u ebx_155) /u ebx_155)
l00403493:
	Eq_1772 eax_334 = (word32) ebx_155 + 0x01
	byte dl_332 = (byte) eax_325
	<anonymous> * ecx_337 = eax_334 *s globals->dw406028
	branch ecx_337 != null l00403450
l004034AE:
	int32 edx_359 = (int32) dl_332
	esi_166 - 110 + (fp - 0x04) = (byte *) (byte) (edx_359 - (edx_359 | 0x01) *s ebx_155)
	goto l00403475
l004034C1:
	Eq_1755 edx_188 = (word32) ebx_155 + 0x0030
	branch edx_188 <= esi_166 l004034DD
l004034C8:
	byte * eax_288 = (word32) esi_166.u0 + (fp - 114)
	Eq_1755 esi_292 = esi_166
l004034D0:
	*eax_288 = 0x00
	esi_292 = (word32) esi_292.u0 + 0x01
	eax_288 = eax_288 + 0x01
	branch edx_188 > esi_292 l004034D0
l004034DD:
	ui32 ecx_196 = 0x01
	ui32 eax_198 = dwLoc84_161 | dwArg04
l004034E8:
	ui32 edx_210 = (fp - 118)[ecx_196]
	branch ebx_155 == 0x00 l004034F2
l004034F0:
	edx_210 = edx_210 * 0x02
l004034F2:
	ecx_196 = ecx_196 + 0x01
	eax_198 = eax_198 ^ edx_210
	branch ecx_196 != 0x0D l004034E8
l004034FC:
	branch eax_198 == ~0x00 l00403510
l00403501:
	Eq_1896 ecx_244 = ebx_155 - 0x01
	branch (uint32) ((uint64) (uint32) eax_198 % ecx_244) == 2305906339 l0040354C
l00403510:
	uint32 v22_228 = dwLoc88_141 + 0x01
	dwLoc88_141 = v22_228
	branch (uint32) ((uint64) (uint32) edx_30->dw0018 /u ((word32) ebx_155 + 0x01)) <= v22_228 l00403540
l00403531:
	dwLoc8C_146 = dwLoc8C_146 + 0x02
	dwLoc84_161 = ebx_155
	goto l00403422
l00403540:
	edx_132 = 0x00
l00403542:
	return edx_132
l0040354C:
	edx_132 = ~0x00
	word32 eax_260 = ((ebx_155 + 0x01) *s (dwArg08 + Mem0[edx_30 + 0x1C:word32]))[(word32) Mem0[dwLoc8C_146 + 0x00:word16] * 0x04] + dwArg08
	branch eax_260 == ~0x00 l00403542
l00403577:
	return (uint32) ((uint64) (uint32) eax_260 % ecx_244)
fn00403390_exit:
}

// 00403590: Register uint32 fn00403590()
uint32 fn00403590()
{
	Eq_17 esi_21 = globals->t40603C;
	int32 ebx_22 = fs->ptr0018->ptr0030->dw000C;
	ui32 edi_30 = (word32) (uint32) ((uint64) (uint32) esi_21 /u (ebx_22 | 0x01)) + 0x001C + ebx_22;
	struct Eq_1967 * ecx_36 = edi_30 - (edi_30 | 0x01) *s esi_21;
	byte al_38 = (byte) (((word32) esi_21 + 0x01) *s 0x6B);
	byte al_47 = (byte) (((word32) esi_21 + 0x01) *s 114);
	byte dl_50 = (byte) (((esi_21 - 1148159575 >> 0x01) + 1148159575 >> 0x06) + 101);
	do
	{
		uint32 edx_101;
		struct Eq_2010 * eax_68 = (uint32) ((uint64) (uint32) ecx_36->dw0020 /u ((word32) esi_21 + 0x01));
		if (eax_68->b0000 == (byte) ((word32) al_38))
		{
			if (eax_68->b0002 == (byte) ((word32) dl_50))
			{
				if (eax_68->b0004 == (byte) ((word32) al_47))
				{
					word32 ebx_126 = ecx_36->dw0008;
					edx_101 = ~0x00;
					if (ebx_126 != ~0x00)
						edx_101 = (uint32) ((uint64) (uint32) ebx_126 % (esi_21 - 0x02));
					return edx_101;
				}
			}
		}
		ecx_36 = ecx_36->dw0000 | esi_21;
	} while (edi_30 == ecx_36->dw0000);
	edx_101 = 0x00;
	return edx_101;
}

// 00403640: void fn00403640(Register uint32 eax, Stack word32 dwArg00)
void fn00403640(uint32 eax, word32 dwArg00)
{
	struct Eq_2076 * ecx_10 = fp + 0x04;
	while (eax >= 0x1000)
	{
		ecx_10 = ecx_10 - 0x1000;
		ecx_10->dw0000 = ecx_10->dw0000;
		eax = eax - 0x1000;
	}
	word32 * ecx_22 = ecx_10 - eax;
	*ecx_22 = *ecx_22;
	word32 esp_32;
	word32 ecx_33;
	byte SCZO_34;
	word32 eax_35;
	byte C_36;
	byte SZO_37;
	dwArg00();
	return;
}

