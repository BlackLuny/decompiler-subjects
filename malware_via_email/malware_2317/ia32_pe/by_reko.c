// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004010DA: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 SCZO_6 = cond(fp - 0x20);
	if (false)
	{
		ebx = ebx - (edx + 0x0CC8);
		bl = (byte) ebx;
	}
	Eq_3 SCZDOP_140 = SCZO_6;
	Eq_3 SZO_138 = SCZO_6;
	Eq_3 edx_28 = eax;
	int32 ebx_31 = DPB(ebx, bl, 8);
	ptr32 esp_134 = fp - 0x24;
	while (true)
	{
		struct Eq_37 * esp_43 = esp_134 - 0x04;
		esp_43->t0000 = (struct <anonymous> *) 0x02;
		*(esp_43 - 0x04) = 0x00401000;
		EnumSystemLanguageGroupsA(*(esp_43 - 0x04), esp_43->t0000, esp_43->t0004);
		Eq_67 ecx_49 = (word32) edx_28 + ((word32) edx_28 + 0x1A54A4D1);
		esp_43->t0004 = SCZDOP_140;
		word16 ax_56 = esp_43->w0008;
		edx_28 = esp_43->t0004;
		esp_43->t0004.u0 = 432040460;
		byte ch_50 = SLICE(ecx_49, byte, 8);
		struct Eq_26 * eax_57 = DPB(&esp_43->w0008, ax_56, 0);
		byte al_59 = (byte) ax_56;
		ebx_31 = DPB(ebx_31, 0xA4, 8);
		if (!SZO_138)
			break;
		byte v29_135 = eax_57->b000C + ch_50;
		eax_57->b000C = v29_135;
		Eq_3 SCZO_137 = cond(v29_135);
		esp_134 = (char *) &esp_43->t0004 + 0x01;
		SZO_138 = SCZO_137;
		SCZDOP_140 = SCZO_137;
	}
	esp_43->t0000 = esi;
	__frstor(*edx_28);
	*(esp_43 - 0x04) = (union Eq_49 *) ss;
	word32 * ebx_80 = DPB(ebx_31, edi + ebx_31, 0);
	__outb(edx_28, al_59);
	word32 v24_87 = Mem78[edx_28 + 0x00:word32] + ecx_49;
	*edx_28 = v24_87;
	Eq_2 eax_71 = DPB(eax_57, cond(rArg0 - rArg0), 8);
	if (OVERFLOW(v24_87))
	{
		__lock();
		__hlt();
	}
	else if (v24_87 >= 0x00)
		return eax_71;
	else
	{
		*((word32) ecx_49 + (eax_71 * 0x04 + 0x004C)) = *((word32) ecx_49 + (eax_71 * 0x04 + 0x004C)) ^ ebx_80;
		*(esp_43 - 0x08) = esp_43 - 0x04;
		if (!OVERFLOW(edx_28 - 0x01))
		{
			*(esp_43 - 0x0C) = (DWORD *) eax_71;
			*(esp_43 - 0x10) = ebx_80;
			*(ecx_49 - 0x23) = ~0x58;
			(byte *) 0x66ABD0FD = (byte *) al_59;
			*ebx_80 = *ebx_80 + ~0x29;
		}
	}
}

