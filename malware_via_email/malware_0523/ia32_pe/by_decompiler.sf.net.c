// subject.c
// Generated on 5/4/2015 1:15:19 AM by decompiling malware_via_email/malware_0523/ia32_pe/subject.exe
// using Decompiler version 0.4.2.0.

#include "subject.h"

void fn00401071(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 ebp, word32 esi, word32 dwArg00)
{
fn00401071_entry:
l00401071:
l0040107C:
	word32 ebx_12 = ebx - edx
	word32 edi_15 = ecx ^ ebx_12
	branch ebx_12 == 0x00000001 l00401086_thunk_fn004011AA
	goto l0040108C
l00401086_thunk_fn004011AA:
	fn004011AA(eax, ecx, edx, ebx_12 + 0x00000001, ebp, esi, edi_15)
	return
l0040108C:
fn00401071_exit:
}

void fn004010D9(word32 dwArg00)
{
fn004010D9_entry:
l004010D9:
fn004010D9_exit:
}

void fn0040110D(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 esi, word32 edi)
{
fn0040110D_entry:
	goto l0040110D
l00401008:
l0040103D:
	goto l00401008
l0040110D:
	byte bl_6 = bl - ch
	word32 ebx_8 = DPB(ebx, bl_6, 0, 8)
	byte bh_20 = bh - ah
	word32 edx_15 = DPB(edx, -dh, 8, 8)
	byte bl_18 = bl_6 | cl
	word32 ebx_21 = DPB(ebx_8, bh_20, 8, 8)
	branch OVERFLOW(bh_20) l0040103D
	goto l00401120
l0040110D:
l00401120:
	word32 ebx_58 = DPB(ebx_21, bl_18, 0, 8)
	branch !OVERFLOW(bh_20) l0040103D
l00401128:
	word32 ecx_60 = DPB(ecx, ch | 0x7B, 8, 8)
	word32 ebx_62 = DPB(ebx_58, 0xC8, 8, 8)
l0040112D_thunk_fn0040112E:
	fn0040112E(eax, ecx_60, edx_15, ebx_62, ebx_8 + 0x00000001, dwArg33938E59)
	return
fn0040110D_exit:
}

void fn0040112E(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 edi, word32 dwArg33938E59)
{
fn0040112E_entry:
	goto l0040112E
l00401022:
	word32 edx_33 = edx_12 + 0x00000001 | esi_26 - 0x00000001
	word32 ebx_37 = ebx_23 + eax + edx_33
	byte bl_38 = (byte) ebx_37
	word32 edi_42 = ((eax | edx_33) ^ eax) + (edx_33 + 0x00000001)
l00401099:
	word32 esi_47 = esi_26 - 0x00000002 - ecx
	word32 edx_48 = edx_33 + 0x00000002 - edi_42 - esi_47
	fn00401183(eax, ecx, DPB(edx_48, cl, 8, 8), DPB(ebx_37, bl_38 | ch, 0, 8) - 0x00000001, fp - 0x00000004, esi_47 - ecx, edx_48, dwLoc08)
l004010B5:
	word32 ebx_23 = ebx_14 + 0x00000001 | edx_12
	word32 esi_26 = ecx + 0x00000001 | eax | edx_12
	branch false l00401022
l004010C6:
l004010CC:
	branch false l00401022
l004010D2:
l0040112E:
	word32 edx_12 = edx - eax - ebx
	word32 ebx_14 = ebx ^ edx_12
	goto l004010B5
fn0040112E_exit:
}

void fn00401183(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 ebp, word32 esi, word32 edi, word32 dwArg00)
{
	word32 ebx_15 = DPB(ebx, 0x88, 0, 8);
	byte dh_16 = -SLICE(edx, byte, 8);
	word32 edx_24 = DPB(edx, ch, 8, 8);
	if (!OVERFLOW(dh_16))
	{
		word32 eax_34 = DPB(eax, al, 0, 8);
		if (OVERFLOW(dh_16))
		{
			fn004011AA(esi + 0x00000001, 0xE1CB5A6D, edx_24, ebx_15, ebp, eax_34, edi);
			return;
		}
		else
		{
			fn0040110D(eax_34, ecx, edx_24, ebx_15, esi + 0x00000001, edi);
			return;
		}
	}
	else
	{
		fn0040110D(eax, ecx, edx_24, ebx_15, esi + 0x00000001, edi);
		return;
	}
}

void fn004011AA(word32 eax, word32 ecx, word32 edx, word32 ebx, word32 ebp, word32 esi, word32 edi)
{
	word32 ebx_4 = ebx - edx;
	word32 edi_5 = edi - 0x00000001 + ebx_4;
	word32 ebx_8 = ebx_4 | edi_5;
	word32 esi_10 = esi | ebx_8;
	fn004010D9(dwLoc04);
	Mem35[edi_5 | ebx_8:byte] = Mem0[esi_10 + 0x00000001 ^ eax:byte];
}

