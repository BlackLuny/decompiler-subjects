void proc1(__size32 param1);
__size32 proc2();

// address: 0x401004
void _start(__size32 param1, __size32 param2) {
    __size32 ebp; 		// r29
    __size32 edi; 		// r31
    __size32 edx; 		// r26
    __size32 esp; 		// r28

    edx = param1 + param2 + param2 + esp + 16;
    proc1(pc, 0, 16, 0x2230, esp - 24, 0xb7c0d899, 0, 0x41f09339, 0xf32ebacc, param2, ebp, (unsigned short) edx + esp - 0x483f2755, edx + esp - 0x483f2755, 0, edx + esp + 16, ebp, param2, edi, LOGICALFLAGS32(0), LOGICALFLAGS32(0), LOGICALFLAGS32(0));
}

// address: 0x4010d0
void proc1(__size32 param1) {
    __size8 al; 		// r8
    __size16 ax; 		// r0
    unsigned short cx; 		// r1
    int eax; 		// r24
    int eax_1; 		// r24{41}
    __size32 ebp; 		// r29
    __size32 ebx; 		// r27
    __size32 ebx_1; 		// r27{179}
    int ecx; 		// r25
    __size32 edi; 		// r31
    __size32 edx; 		// r26
    __size32 esi; 		// r30
    __size32 *esp; 		// r28
    void *esp_1; 		// r28{168}
    unsigned int local0; 		// m[esp - 48]
    __size32 local1; 		// m[esp - 44]
    __size32 local10; 		// m[esp - 12]
    int local11; 		// m[esp - 8]
    int local12; 		// m[esp - 6]
    int local13; 		// m[esp - 4]
    int local14; 		// m[esp + 24]
    int local15; 		// m[esp + 36]
    int local16; 		// m[esp - 30]{168}
    __size32 local2; 		// m[esp - 40]
    __size32 local3; 		// m[esp - 36]
    __size32 local4; 		// m[esp - 32]
    __size8 local5; 		// m[esp - 30]
    int local6; 		// m[esp - 28]
    int local7; 		// m[esp - 24]
    __size32 local8; 		// m[esp - 20]
    __size32 local9; 		// m[esp - 16]

    cx = *0;
    eax_1 = 0 >> 16 & 0xffff | (0);
    eax = proc2(); /* Warning: also results in al, ecx, ebx_1 */
    (**(ebx_1 + 24))(pc, eax, eax, eax, eax, local5 - 1, esp - 40, 0, edi, ebx, esi, eax_1 + 0x6030, 0, eax_1 + 0x6c7a, 0xe7f930c, 0, (unsigned short) eax, cx, al, eax, ecx, eax_1 + 0x6030, ebx_1, param1 + 1, 2, esp - 40, ADDFLAGS32(esp - 44, 20, esp - 24), ADDFLAGS32(esp - 44, 20, esp - 24), ADDFLAGS32(esp - 44, 20, esp - 24));
    (**(ebx + 28))(local0, local1, local2, local3, local4, local16, local6, local7, local8, local9, local10, local11, local12, local13, local14, local15, (unsigned short) eax, cx, al, eax, ecx, edx, ebx, ebp, esi, edi, <all>, flags, ZF, CF);
}

// address: 0x40169e
__size32 proc2() {
    unsigned char al; 		// r8
    unsigned short ax; 		// r0
    unsigned int eax; 		// r24
    void *ebx; 		// r27
    __size32 ecx; 		// r25
    unsigned short *local0; 		// m[esp - 10]

    for(;;) {
        ax = *local0;
        eax = local0 >> 16 & 0xffff | (ax);
        eax = eax >> 16 & 0xffff | ((unsigned short) eax - 0x5a4b);
        if ((unsigned short) eax == 2) {
            break;
        }
    }
    al =  ((unsigned short) eax > 2) ? 1 : 0;
    eax = eax >> 8 & 0xffffff | (al);
    ecx = *(eax + 60);
    ebx = *(ecx + eax + 128);
    ecx = *(eax + ebx);
    return eax + ecx + 4; /* WARNING: Also returning: al := al, ecx := ecx, ebx := eax + ecx + 4 */
}

