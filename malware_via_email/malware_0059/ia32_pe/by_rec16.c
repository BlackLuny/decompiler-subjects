/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0059/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 0040120c -> 004011c4 */
stack space not deallocated on return
/*	Procedure: 0x004011E9 - 0x00401221
 *	Argument size: 8980
 *	Local size: 0
 *	Save regs size: 0
 */

L004011E9()
{



    asm("aad 0x8b");
    asm("fsubr qword [edx-0x24]");
    *(ebx + 16) = eax;
    asm("aaa");
    *((al >> cl) + 212) = *((al >> cl) + 212) + (al >> cl) + 212;
    L004016D2();
    (restore)edi;
    asm("les ebp,[ecx]");
    (restore)ds;
    (save)354673054;
    *eax = *eax ^ dl;
    asm("pushf");
    dh = dh + bh;
    asm("jecxz 0x4011c4");
    *(ecx + edx * 2 - 74) = *(ecx + edx * 2 - 74) + dl;
    *(ebx + 49008723) = *(ebx + 49008723) + cl;
    (restore)eax;
    (restore)ds;
    eax = *edx(eax);
    asm("aaa");
    asm("stc");
}

/* DEST BLOCK NOT FOUND: 0040125c -> 00401290 */
/* DEST BLOCK NOT FOUND: 0040128f -> 00401296 */
/*	Procedure: 0x00401222 - 0x00401260
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401222()
{



    asm("adc eax,0x9c1070");
    asm("repne in al,dx");
    edx = edx & *L009C1024;
    asm("sbb esp,esp");
    edx = edx & *L009C1068;
    *(eax + 35) & eax;
    asm("adc eax,0x9c1008");
    asm("Unknown opcode 0xdf");
    ecx = ecx - 1;
    asm("outsb");
    *ebx = *ebx ^ 219;
    asm("aaa");
    al = al | 96;
    (save)edi;
    bl = bl & ch;
    asm("cmc");
    *(eax + 929111076) = esp;
    ebp = ebp | eax;
    asm("xchg eax,esi");
    (fsave) *eax;
    *ebx = *ebx + ch;
    asm("loopne 0x40127f");
    (restore)eax;
    goto L00401290;
    asm("xchg esi,edi");
}

/* DEST BLOCK NOT FOUND: 0040135b -> 004013ab */
stack space not deallocated on return
/*	Procedure: 0x00401261 - 0x00401360
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401261()
{



    edx = edx & *L009C1048;
    eax :: *ebx;
    ss = *(ecx + 80);
    *(edi + -1895240948) = *(edi + -1895240948) - 1;
L0040126d:
    (save)eax;
    (save)esp;
    eax = *(edi + -2064585972);
    (restore)ebx;
    return;
    asm("Unknown opcode 0xdb");
    edx = edx & *L009C106C;
    asm("mul edi");
    (save)cs;
    asm("retf");
    asm("Unknown opcode 0xde");
    asm("Unknown opcode 0xd2");
    if(!(edx = edx & *L009C102C)) {
        (save)esi;
L00401292:
        (save)ss;
        esi = esi + 1;
        asm("adc cl,[esi]");
    }
    return;
    asm("xchg eax,ebx");
    goto ( *ebx);
    asm("adc eax,0x9c103c");
    asm("lock mov [ebx],ah");
    asm("adc eax,0x9c1034");
    bl = 253;
    edx = edx & *L009C1050;
    esi = 1385258;
    asm("adc [eax+eax+0x15231573],bl");
    asm("sbb al,0x10");
    asm("pushf");
    dl = dl + al;
    *(esp + eax * 4) = *(esp + eax * 4) ^ 0;
L004012c1:
    ah = ah + bl;
    edi = *(esi + 16);
    asm("aaa");
    eax = eax - 1;
    *ebx & 82;
    goto L004012c1;
L004012d4:
    if(eax = *ebx + *(esi - 48)) {
        goto L0040126d;
    }
    esi = esi + *ebx;
    *(edx + 837484560) = *(edx + 837484560) & -117;
    eax = eax ^ *ebx;
    *edi = al;
    edi = edi + 1;
    al :: 139;
    ds = *eax;
    *eax = *eax + al;
    (save)edi;
    dh = 128;
    ah = ah + bl;
    bl = bl + ah;
    *(ecx - 10) = *(ecx - 10) ^ bl;
    goto L004012d4;
L004012f5:
    (save)edi;
    asm("adc ecx,[ebx+0x8dc6570f]");
    (save)esp;
    asm("int 0x2");
    ecx & -2147483428;
    asm("rol dword [edx+ecx*8-0x18],cl");
    *eax = es;
    if(*eax = *eax + al) {
        goto L00401292;
    }
    asm("aas");
    *edi = *edi + dh;
    (save)es;
    (save)esi;
    esp = esp + edi;
    asm("xchg eax,esi");
    goto L004012f5;
    eax & 444817114;
    asm("adc al,0xeb");
    bh = 31;
    asm("xchg eax,esi");
    *(ebp + 272897315) = *(ebp + 272897315) ^ ah;
    asm("pushf");
    *(edx + 54) = *(edx + 54) + bl;
    cl = *(ebx + -215208969);
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    (restore)esi;
    (restore)ds;
    (restore)ss;
    (save)538256171;
    asm("adc [eax+eax+0xc387ddcf],bl");
    *L004010d0();
    (restore)ds;
    (save)ebx;
    (save)eax;
    *( *(ebx - 48))();
    asm("aaa");
    asm("out dx,al");
    if(edx = (edx | eax) & *L009C105C) {
        goto L004013ab;
    }
    asm("Unknown opcode 0xd3");
    bh = 209;
    asm("pcmpgtd mm4,mm1");
}

/* DEST BLOCK NOT FOUND: 0040137c -> 0040135e */
/* DEST BLOCK NOT FOUND: 004013b7 -> 00401342 */
/* DEST BLOCK NOT FOUND: 004013d0 -> 00401342 */
/* DEST BLOCK NOT FOUND: 00401430 -> 004014b0 */
/* DEST BLOCK NOT FOUND: 00401498 -> 004014d6 */
stack space not deallocated on return
/*	Procedure: 0x00401361 - 0x00401489
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401361()
{



    asm("o16 loope 0x401383");
    asm("Unknown opcode 0x0f");
    asm("sahf");
    asm("retf 0x8b51");
    asm("Unknown opcode 0x8f");
    al = al | 80;
    asm("adc eax,0x9c1018");
L00401374:
    al = *L0842F7FF;
    if(*(esi + 594658052) = *(esi + 594658052) - 1) {
        goto L0040135e;
    }
    *(edx + 8) = *(edx + 8) + eax;
L00401381:
    asm("fcomip st0");
    ecx = ecx - eax;
L00401385:
    asm("aaa");
    al = al & ch;
    (restore)ecx;
    *(eax + 52) = *(eax + 52) + dl;
    ah = ah + 4;
    asm("jecxz 0x4013a9");
    goto L004013d5;
L00401396:
    eax = 0;
    ebx = 1541153053;
    (save)edi;
    asm("aam 0x89");
    (fsave)((frestore) + *eax) * *(ecx + 238487618);
    if(!(edx = edx + 1)) {
        (restore)edi;
        asm("les ebx,[eax]");
        goto L00401381;
        (save)ebx;
        esp = esp - -56;
        asm("cld");
        goto L00401396;
        ah = 59;
        asm("jpo 0x401342");
        asm("retf 0xeb58");
    }
    asm("retf 0xc387");
    (save)ecx;
    asm("int 0x23");
    asm("adc eax,0x9c104c");
    bh = 181;
    asm("scasd");
    (save)esi;
    asm("Unknown opcode 0xfe");
    goto ( *ebx);
    goto L004013fb;
    eax = L00401361();
L004013d5:
    asm("aaa");
    if(!(eax = 187 & 255)) {
        goto L00401385;
        > ? L00401413 : ;
        asm("aaa");
        asm("das");
L004013e3:
        if(!(ecx = ecx + 1)) {
            asm("out dx,eax");
            (restore)ebp;
            eax = L003f368d();
            goto L004013f5;
            (save)eax;
        }
        *edi = *esi;
        edi = edi + 1;
        esi = esi + 1;
        goto L00401374;
L004013f2:
        al = *esi;
        esi = esi + 1;
L004013f3:
        eax = eax >> 1;
L004013f5:
        al & 228;
        asm("adc ecx,ecx");
        asm("aaa");
L004013fb:
        if(edx = edx + 1) {
            goto L004013f2;
        }
L004013fc:
        (restore)edi;
        asm("rol dword [ecx],0xb0");
        asm("int3");
        bl = 2;
        eax = L00401261();
        asm("aaa");
L0040140b:
        if(eax = eax | -127990413) {
            goto L004013fc;
        }
        asm("adc [ecx-0x77],al");
L00401413:
        al = al + 248;
        goto L0040142c;
        asm("adc bl,[ebx+esi*2]");
        *ecx = *ecx ^ esi;
        asm("fsubr qword [ebx]");
        asm("retf");
        if(al = Lebea7e95() + *eax) {
            goto L004013f3;
        }
        goto L00401432;
L0040142c:
        (restore)eax;
        asm("Unknown opcode 0x8c");
        bl = 1;
        goto L004014b0;
L00401432:
        ecx = 0;
        eax = L0040168B();
    }
    asm("aaa");
    asm("int1");
    goto L004013f2;
    asm("aaa");
    eax = *LFF2116E8;
    asm("Unknown opcode 0xff");
    eax :: 32220;
    asm("scasd");
    asm("xchg eax,ebp");
    goto L0040140b;
    bl = 222;
    Lff64128d();
    goto L004013e3;
    (restore)ds;
    asm("loope 0x4013e9");
    if(ah != 217) {
        goto L00401413;
    }
    *(eax + 7003136) = *(eax + 7003136) + al;
    ecx = *(edi + -1895870452);
    bl = bl | al;
    ecx = ecx - 1;
    (restore)eax;
    asm("adc [eax-0x24],al");
    return;
    asm("sbb eax,0xd08bbc73");
L00401476:
    goto L00401476;
    ecx = *L7F2203FC;
    asm("Unknown opcode 0xdf");
    bl = bl | ch;
    asm("%e mov ebp,0x2f06b9c3");
}

/* DEST BLOCK NOT FOUND: 00401498 -> 004014d6 */
/*	Procedure: 0x0040148A - 0x004014A7
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040148A()
{



    return;
    ecx = -301715706;
    asm("Unknown opcode 0xc1");
    al = al + *%ss:ebx+0x420f844];
    goto L004014d6;
    edi = esi;
    ebx = 1541153053;
    asm("aaa");
    Lea9fd7da();
    *(ebx + 326488665) = *(ebx + 326488665) + ebp;
}

/* DEST BLOCK NOT FOUND: 004014c2 -> 004014a3 */
/* DEST BLOCK NOT FOUND: 0040156f -> 00401584 */
/*	Procedure: 0x004014A8 - 0x00401570
 *	Argument size: 24
 *	Local size: 0
 *	Save regs size: 0
 */

L004014A8(A4, A18)
/* unknown */ void  A4;
/* unknown */ void  A18;
{



    *edi = eax;
    (restore)ecx;
    asm("Unknown opcode 0xd2");
    if(edi = edi + 4) {
        goto L004014c0;
    }
    asm("aaa");
    (fsave)(frestore) * *(ebx + -910241017);
    ebx = ebx ^ *edi;
    al = eax ^ ecx ^ 145;
    if(!( *(eax + -611639260) = *(eax + -611639260) - edx)) {
        *edi = eax;
        edi = edi + 4;
        eax = 56367;
        edx = edx - 1;
        asm("Unknown opcode 0xf7");
        asm("enter 0xebeb,0xa9");
        ebx = ebx + eax;
        (save)edx;
        al = al ^ 188;
        eax = eax + *eax;
        (fsave)(frestore) - st3;
        asm("adc al,[ebx]");
        asm("sbb eax,0xc850b70f");
        goto L00401508;
        edx = edi;
        (save) *(ebx + 12);
        al :: 235;
        dl = dl ^ *(ecx + 1 + -14582296);
        eax = *(edx + 95)();
        asm("Unknown opcode 0xc6");
        *(edx + 55) = *(edx + 55) - cl;
        asm("salc");
        eax = *(eax - 116);
        (save)edx;
        edx = 56322;
        goto L0040153a;
L00401508:
        ebp = eax + 1796151298;
        (save)eax;
        (save)es;
        *edx = *edx ^ 40;
        edx = edx + 1;
        goto L00401529;
        *edi = al;
        edi = edi + 1;
        asm("xchg eax,esi");
        ecx = (ecx ^ *(ebp + 1460161419)) - 1;
        al :: 232;
        asm("sbb [eax+eax],eax");
        *(ebp + 1783165891) = *(ebp + 1783165891) + al;
L00401529:
        eax = eax + 1;
        (save)12288;
    }
    ebp = ecx;
    goto L00401551;
L00401534:
    ebx = 220;
    edi = eax;
L0040153a:
    ecx = ecx >> 2;
    goto L0040156d;
    esi = 0x401159;
    A18 = __imp__VirtualAlloc;
    goto L00401529;
L00401551:
    (save)edi;
    (save)0;
    eax = *ecx();
    A4 = eax;
    ecx = edi;
    goto L00401534;
    (save)-220;
    *esp = *esp + ebp;
    edx = 4194304;
    goto L00401583;
L0040156d:
    ecx = ecx + 1;
    asm("lodsd");
    goto L00401584;
}

/* DEST BLOCK NOT FOUND: 00401577 -> 00401540 */
/* DEST BLOCK NOT FOUND: 00401581 -> 0040155e */
/* DEST BLOCK NOT FOUND: 0040165c -> 004014a8 */
stack space not deallocated on return
/*	Procedure: 0x00401571 - 0x0040168A
 *	Argument size: 5867
 *	Local size: 0
 *	Save regs size: 0
 */

L00401571()
{



    asm("pusha");
    edi = 2228;
    goto L00401540;
L00401579:
    asm("popa");
    ebp = ebp + 344;
    goto L0040155e;
    return;
    eax = eax ^ ebx;
    *edi = eax;
    edi = edi + 4;
    asm("loop 0x40156e");
    ecx = __imp__VirtualFree;
    goto L00401579;
L00401591:
    al = al ^ 72;
    eax = eax + *eax;
L0040159b:
    eax = 383209842;
    (save)ebp;
    bl = ebx + 1 | ch;
    return(L0040198A());
L004015aa:
    *(ebx - 40) = eax;
    goto L0040159b;
    (save)ebx;
    ebx = edi;
    (al | 129) :: 603914240;
    goto L004015eb;
    edi = ebx;
    eax = 1895304564;
    goto L004015aa;
    asm("%f jc 0x4015de");
    *(eax + ebp * 8) = *(eax + ebp * 8) - esp;
    *(ebx - 48) = eax | *ebx;
    eax = 713448818;
    goto L00401591;
    (save)edi;
    *(eax + -411821983) = *(eax + -411821983) >> 1;
    eax = L00401812();
    asm("aaa");
    asm("aad 0x66");
L004015eb:
    ebp = ebp & 930372173;
L004015f2:
    ecx = ecx - 121856;
    goto L00401627;
    (save)87;
    eax = eax >> 213;
    bl = bl + ch;
    asm("jecxz 0x401592");
    ebx = ebx - 1;
    *(edi + 115) = *(edi + 115) | dl;
    al = al + 81;
    asm("aaa");
    (restore)ss;
L0040160f:
    eax = L0040f5bd();
    asm("Unknown opcode 0x8d");
    asm("enter 0x332,0xd1");
    al = al ^ 117;
    *eax = *eax + eax;
    (fsave)(al = al | 129) * *(ecx + -1014558653) + *(eax | *ebx) + *eax - st3;
    eax = eax + 1;
L00401620:
    asm("popa");
    asm("das");
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    (restore)ecx;
    goto L004015f2;
    eax = *(ecx - 56) & 65535;
L00401627:
    edi = *ebx;
    ebx = eax + -1786046463;
    (save)esp;
    asm("pusha");
    goto L00401651;
    edx = *(ecx - 38);
    asm("xchg eax,ecx");
    esi = edx;
    asm("sbb eax,0x3ec103e6");
    eax = eax + -933769237;
    eax = 0;
    asm("sbb eax,0x77f302e9");
    goto L00401620;
L00401650:
    L004014A8();
L00401651:
    esp = esp - 1;
    al = *(ebx + 4) ^ 255;
    asm("std");
    goto ( *ebx);
    goto L0040160f;
    al = al ^ 120;
    asm("cld");
    goto ( *ebx);
    goto L00401650;
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    return(eax | -283479072);
    asm("out dx,eax");
    return;
    asm("aaa");
    asm("daa");
    cl = 23;
    asm("aaa");
    asm("out dx,al");
    (save)esi;
    (save)edx;
    asm("Unknown opcode 0x8f");
    ebx = ecx;
    edx = -1055016996;
    asm("aaa");
    asm("adc esp,edx");
    asm("loopne 0x401611");
    (restore)edx;
}

/* DEST BLOCK NOT FOUND: 0040168c -> 00401656 */
/* DEST BLOCK NOT FOUND: 0040168e -> 00401677 */
/* DEST BLOCK NOT FOUND: 00401693 -> 00401666 */
stack space not deallocated on return
/*	Procedure: 0x0040168B - 0x004016A6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040168B()
{



    (restore)esi;
    goto L00401656;
    *(esp + esi * 2) & bl;
    asm("jecxz 0x401666");
    al :: 115;
    asm("fucomi st3");
    esi = esi | *ebx;
    asm("ror byte [ebx+0xeb0e8b14],0xd0");
    (restore)ds;
    return(*(esi + 2));
}

/* DEST BLOCK NOT FOUND: 004016ac -> 004016ea */
/*	Procedure: 0x004016A7 - 0x004016D1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004016A7()
{



L004016a7:
    if(ebx = ebx - 1) {
        goto L004016e0;
    }
    al = bl;
    goto L004016ea;
    al = cl;
    (restore)ecx;
    tword [ecx+0xdc08] = (frestore);
    if(!(esi = esi + 1)) {
        goto L004016A7;
        (save) *(edx - 34);
    }
    return;
    ecx = ecx + 1;
    L004011E9();
    asm("aaa");
    asm("out dx,al");
    edi = 51655850;
}

stack space not deallocated on return
/*	Procedure: 0x004016D2 - 0x004016FC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004016D2()
{



    asm("adc al,0x3");
    ah = ah + bl;
    (restore)ecx;
    return;
    return;
    bl :: ebx + 1230440523;
    ebx = ebx ^ *ecx;
    asm("Unknown opcode 0xc6");
    asm("Unknown opcode 0x8e");
    dh = 64;
    (save)60416;
    (save)eax;
    (save)edi;
    ebx = ebx - 1;
    al = al | 106;
    (fsave)(frestore) / st7;
    (save)ecx;
    asm("adc [edi],bl");
    *L0040cc28();
}

/* DEST BLOCK NOT FOUND: 00401719 -> 00401747 */
/* DEST BLOCK NOT FOUND: 00401733 -> 00401747 */
/*	Procedure: 0x004016FD - 0x00401722
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)ebp;
    ebp = esp;
    (save)0;
    (save)16384;
    (save)0;
    (save)4;
    (save)0;
    (save)-1;
    if(*__imp__CreateFileMappingA() == 0) {
        goto L00401747;
    }
    (save)eax;
    *__imp__GetCurrentProcessId();
    ecx = 0;
}

stack space not deallocated on return
/*	Procedure: 0x00401723 - 0x0040174C
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L00401723()
{



    esp = ebp;
    (restore)ebp;
    (restore)eax;
    (save)ecx;
    (save)ecx;
    (save)ecx;
    (save)6;
    (save)eax;
    eax = *__imp__MapViewOfFile();
    if(eax != 0) {
        eax = L0040174D(eax);
        esp = ebp;
        (restore)ebp;
        return;
        (restore)eax;
        L00401571();
        eax = 0;
    }
    esp = ebp;
    (restore)ebp;
}

/* DEST BLOCK NOT FOUND: 0040177c -> f4004b5f */
/*	Procedure: 0x0040174D - 0x00401811
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L0040174D(Ac)
/* unknown */ void  Ac;
{



    ebp = esp;
    esp = esp - 28;
    ecx = *(ebp + 8);
    *__imp__VirtualQuery(ecx, esp, 28, ebp);
    ecx = (Ac >> 12) - 1;
    esp = ebp;
    (restore)ebp;
    return;
    edx = -1043834982;
    goto Lf4004b5f;
    if(!( *(esp + (Ac >> 12)) = *(esp + (Ac >> 12)) + (Ac >> 12))) {
        goto L004017a9;
        al = al ^ 143;
        asm("std");
        goto ( *ebx);
L0040178a:
        (save)ecx;
        goto L0040179b;
        (save)edi;
        asm("lock pop ecx");
        (restore)eax;
        asm("aaa");
        asm("sbb al,0x8b");
L00401793:
        >= ? 0x40175e : ;
        (save)eax;
        (save)ecx;
        (save)edx;
        asm("aaa");
        (restore)ds;
L0040179b:
        ecx = eax;
        (restore)ecx;
        esp = ebp;
        (restore)ebp;
        != ? 0x4017a3 : ;
        asm("aaa");
        ecx = ecx ^ eax;
        goto L5f6b0387;
L004017a9:
        asm("Unknown opcode 0x82");
        eax = *(ecx + 16);
        asm("aaa");
        asm("salc");
        esi = esi + *(ebx - 40);
        edi = *(ecx + 12);
        *ebx = (frestore);
        (save)esi;
        goto L0040178a;
        ecx = *(ebx + 8);
        (save)edi;
        asm("Unknown opcode 0xc6");
        edx = 0;
        (save)edi;
        ecx = ecx - 1;
        asm("retf");
        (save)edi;
        (save)ecx;
        ebx = *(ebp + 587851784);
        asm("Unknown opcode 0xff");
        asm("Unknown opcode 0xff");
        goto L0040184d;
        asm("rep movsd");
        (restore)ecx;
        (restore)edi;
        *eax = *eax >> 59;
        (save)ss;
        if(al != 235) {
            goto L00401793;
        }
    }
    return;
    esi = esi - ecx;
    *L8EA8EB5A = *L8EA8EB5A * ebx;
    (save)14417920;
    goto L0040182f;
    asm("xchg al,bl");
    (restore)ecx;
    edx = edx ^ *edi;
    goto L00401827;
    eax = 1541153047;
    asm("Unknown opcode 0xdf");
    return;
    asm("aaa");
    (save)ds;
    ecx = 1539677132;
    (save)32547;
    asm("aaa");
    (save)es;
    eax = eax & ecx;
    *(ebx - 21) & ebx;
    (fsave)(frestore) / *(esi + ebx * 4 + 867939026);
}

/* DEST BLOCK NOT FOUND: 00401819 -> 004017dc */
/* DEST BLOCK NOT FOUND: 0040181b -> 004017ef */
/* DEST BLOCK NOT FOUND: 004018d0 -> 00401932 */
/*	Procedure: 0x00401812 - 0x004018D2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401812()
{



    asm("sahf");
    asm("Unknown opcode 0xd2");
    dl = 187;
    ecx = ecx ^ ebx;
    asm("Unknown opcode 0x0f");
    >= ? L004017dc : ;
    goto L004017ef;
    (restore)ds;
L0040181e:
    (save)ebx;
    (save)ecx;
    ebx = 1541153053;
    asm("aaa");
    (fsave)(frestore) + *ebx;
    asm("rcr dword [0x375910e8],0xdc");
    (restore)edx;
    if(*esi & ecx) {
        goto L0040181e;
    }
    goto L00401898;
    asm("psubusb mm5,[edi+0x65]");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    esp = esp & ebx;
    asm("xchg esi,[ebx]");
L0040183e:
    asm("retf");
    asm("imul dword [0x8e36eb5a]");
    (save)ecx;
    edx = 0;
    asm("%g retf");
    esp = esp & ebx;
    asm("xchg esi,[ebx]");
    asm("retf");
    asm("imul dword [0x21c7b8]");
    (restore)ebx;
    goto L0040187d;
L00401859:
    asm("Unknown opcode 0x8e");
    asm("mul ecx");
    goto L00401865;
    (restore)edx;
    *(edx - 40) = *(edx - 40) + eax;
    if(ecx = ecx - eax) {
        goto L0040183e;
    }
L00401865:
    eax = eax + ecx;
    edx = edx ^ *L2FC88B51;
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    ecx = 1541209572;
    edx = edx ^ *edi;
    eax = *(edx + 4);
    asm("aaa");
    asm("ficomp word [ecx-0x3d]");
L0040187d:
    asm("out dx,eax");
    return;
    eax = eax + edx;
    ebx & ebp;
    (fsave)(frestore) + *(edi + 45746856) + *eax;
    bl = bl + ch;
    asm("ror byte [edi],0x45");
    asm("rcl dword [edi+0x4e],1");
    al = al | 235;
    *(ebx + 16327750) = *(ebx + 16327750) - 1;
L00401898:
    if(*eax = *eax + al) {
        goto L00401859;
    }
    ah = eax + 1 + bl;
    *LA000DC00 = *LA000DC00 + bh;
    goto L004018b1;
    ecx = 14417952;
    eax & 536927232;
L004018b1:
    asm("Unknown opcode 0x0f");
    asm("cdq");
    ebx = ebx >> 1;
    eax = eax | 50873943;
    asm("xlatb");
    *(esi + 16) = eax :: 0 >= 0;
    goto L00401898;
    ecx = 14417924;
    eax & -2147427328;
    goto L00401932;
    eax = Lff6416d9();
}

/* DEST BLOCK NOT FOUND: 004018e4 -> 00401877 */
/*	Procedure: 0x004018D3 - 0x00401932
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004018D3()
{



    bh = bh + dh;
    edi :: 0;
    return;
    ebx = edx;
    asm("fist word [edx+0x3c]");
    goto L00401877;
    asm("xchg eax,edx");
    asm("lodsd");
    (save)esi;
    asm("aaa");
    (save)ebx;
L004018eb:
    if(!( *(ebp - 21) = *(ebp - 21) | 1625615155)) {
        asm("%d clc");
        (restore)edi;
        (restore)edi;
        asm("aaa");
        asm("out 0x8b,al");
        asm("lock push edi");
        asm("enter 0xc14e,0x35");
        asm("adc bl,ah");
        (restore)eax;
        (save)edi;
        edi = edi - 1;
        asm("sbb [ebx+0xf30320ab],cl");
        asm("aaa");
        (fsave) *ebx;
        return;
        *(edi - 21) & ebx;
        asm("sbb ebp,edi");
        asm("ror byte [ecx+0x611cf844],0xeb");
        *ebx = *ebx >> 243;
    }
    ebp = ebp - *(ebx + 875490080);
    (restore)ecx;
    asm("std");
    goto ( *ebx);
    (restore)ecx;
    (restore)esi;
    ebx :: *esi;
    goto L004018eb;
    esp = esp - *(edi + esi * 2);
    asm("jecxz 0x401930");
    eax = eax & 132898679;
}

/* DEST BLOCK NOT FOUND: 0040193c -> 004019a7 */
stack space not deallocated on return
/*	Procedure: 0x00401933 - 0x00401989
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401933()
{



    (save) *(edx - 92) + ebx;
    esi = esi & *(edx + 124);
    goto L004019a7;
    esi = ebx + eax;
    asm("in al,0x56");
    dh = dh + *(ebp + 1);
    (save)ecx;
    ecx = 0;
    asm("aaa");
    asm("rcl cl,cl");
    asm("out dx,al");
    asm("fbstp tword [edi+0x24]");
    asm("packssdw mm6,[ebx+esi-0x2]");
    asm("sbb eax,0xab0302e6");
    asm("sbb al,0x3");
    asm("rep jno 0x40194a");
    asm("cmpsd");
    (fsave)-642131489 + *( *LD9B9D9DF);
    *(ebx + -483529948) = *(ebx + -483529948) + cl;
    asm("enter 0xf303,0xe8");
    asm("in eax,0xfa");
    asm("Unknown opcode 0xff");
    (save) *edi;
    ebp = ebp >> 220;
    (restore)ebx;
    goto L00401985;
    (restore)ebx;
    return;
    ebp = ebp + *edi;
L00401985:
    asm("jecxz 0x40198d");
    L0040148A();
}

/* DEST BLOCK NOT FOUND: 00401997 -> 0040196c */
/* DEST BLOCK NOT FOUND: 00401a0b -> cc766c9b */
/*	Procedure: 0x0040198A - 0x00401A2F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040198A()
{



    asm("cli");
    asm("Unknown opcode 0xff");
    goto ( *(ebp + 84));
    eax = eax | *eax;
    asm("fdivr qword [esi+0xa4f8023f]");
    goto L0040196c;
    asm("bound edi,[ebx+0xe37823ee]");
    (restore)es;
    ebp = ebp + *edi;
    eax = Lff6413ae();
    esi = -1541200820;
    ecx = 365;
    asm("aaa");
    asm("rcr dword [edi],1");
    asm("Unknown opcode 0x82");
    *(ecx + 14417952) & bh;
    goto L004019cc;
    (save)edi;
    eax = eax + *ebx + 1;
    asm("loopne 0x40194e");
    eax = eax + 1;
L004019cc:
    (save)-36;
    asm("loop 0x4019cc");
    asm("sbb dword [eax],0xdc000080");
    goto ( *eax);
    *(eax + 1465983012) = ebx;
    Lc3c6eece();
    if(!(ecx = ecx + *(bh - bl + 216779875))) {
        asm("pushf");
    }
    asm("imul ecx");
    goto L00401a15;
    (save)edx;
    esi = esi - ecx;
    0 :: 0;
    asm("aaa");
    asm("lock push +0x16");
    al = al ^ 119;
    asm("clc");
    goto ( *ebx);
    asm("popa");
    return;
    asm("pusha");
    (save)edi;
    (save)ebx;
    *(ebx + 59461782) = *(ebx + 59461782) | cl;
    *(ax + 1) = *(ax + 1) + ax + 1;
    (fsave)(frestore) - st3;
    goto Lcc766c9b;
    asm("adc [ecx],esi");
    *ecx = *ecx | eax;
    *ecx = ah;
L00401a15:
    asm("pushf");
    *eax = *eax ^ dh;
    al = ah + *(esp + ecx + -1497095360) ^ 140 | bh;
    asm("popa");
    *L20000C48 = esp;
    *eax = *eax + ah;
    *eax = *eax + al;
}

/*	Procedure: 0x00401A30 - 0x00401A3E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401A30()
{



    asm("int3");
    bh = bh | bl;
    asm("adc ah,cl");
    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    *edx = *edx | al;
    *(al - 142) = *(al - 142) + al;
    asm("retf 0xd108");
}

/* DEST BLOCK NOT FOUND: 00401a47 -> 40344ed6 */
/*	Procedure: 0x00401A3F - 0x00401BBD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401A3F()
{



    *(ecx - 75) :: 194;
    *eax = *eax + al;
    goto L40344ed6;
    al = al + 201;
    *eax = *eax + eax;
    *ecx = *ecx + al;
    asm("aas");
    *ecx = es;
    asm("out dx,eax");
    (save)ebp;
    ecx = 1192342819;
    *(edx + eax + 8) = *(edx + eax + 8) - ebx;
    asm("adc [eax],ah");
    al = al + bl;
    esp = esp - *(edi + 268706744);
    asm("loope 0x401a6c");
    *eax = *eax + al;
    asm("pusha");
    ebp :: edi;
    (save)ebx;
    eax = -985615046;
    asm("sbb [ebx],cl");
    esi = esi & *(eax + eax);
    *eax = *eax + al;
    ah = ah + bh | *(edi + ebp);
    bl = bl - dl;
    ecx = ecx + edx;
    asm("sbb ebp,edi");
    ebp = ebp + 1;
    *eax = *eax + al;
    *eax = *eax + al;
    ebp = 420585519;
    *edx = *edx & dl;
    asm("adc [esp+ebx-0x10],ecx");
    ebp = ebp ^ *(edi + 40);
    *eax = *eax + dl;
    asm("xchg eax,esp");
    asm("wait");
    *(edi + 4) = *(edi + 4) | al;
    *edi = al;
    edi = edi + 1;
    asm("loopne 0x401a3e");
    *edi = al;
    edi = edi + 1;
    *eax = *eax ^ al;
    *eax = *eax + al;
    *edi = *edi + al;
    bh = bh | *esi;
    (save)esp;
    asm("aam 0x31");
    asm("rcr dh,0xc9");
    asm("loope 0x401abc");
    *eax = *eax + al;
    *(eax + 302742772) = *(eax + 302742772) + bl;
    al = al ^ 216;
    asm("jpo 0x401ac8");
    asm("loopne 0x401b1f");
    (save)ds;
    *eax = *eax + al;
    *edx = *edx | al;
    eax :: -1493132886;
    dl = dl | ah;
    eax = edx;
    *LC15303A1 = al;
    (save)esp;
    (fsave) *eax / *(eax + -1062626349);
    *edi = eax;
    edi = edi + 4;
    asm("adc [eax],al");
    *eax = *eax + al;
    *ecx = *ecx + ah;
    edx = edx & *esi;
    esi = esi - 1;
    asm("int 0x1");
    *eax = *eax + cl;
    al = (eax | -229076684) + 8;
    *esi = *esi & al;
    dh = dh + *(edi + edx * 2);
    bh = 144;
    *LCAC1A7B9 = al;
    asm("Unknown opcode 0xdb");
    *edx = *edx & al;
    (save)es;
    asm("rol byte [ebp+ebx*8+0x6008d29c],1");
    (save)edi;
    if(!( *(eax + 8) = *(eax + 8) | al)) {
        asm("cdq");
        *eax = *eax + dl;
        eax = eax + 1;
        asm("adc [ebx-0x4e],cl");
        asm("arpl [eax+edx],bp");
        esp = ebp;
        (restore)ebp;
        bh = bh & *ecx;
        *eax = *eax + al;
        asm("sbb byte [esi],0x6c");
        asm("rcl bl,1");
        al = al | 202;
        *eax :: bh;
        *(eax + 32) = *(eax + 32) - eax;
    }
    *ecx = *ecx + al;
    *L900A6898 = *L900A6898 - dl;
    asm("sbb ah,0x6b");
    (restore)esp;
    asm("adc [ecx],bh");
    asm("adc esp,[ebx+0xa8]");
    *eax = *eax + al;
    edx = edx | *(ebp + -646414312);
    *eax = *eax | al;
    al = al + 152;
    (restore)edi;
    (restore)es;
    ah = ah + bl;
    (save)46549779;
    asm("%s inc eax");
    *(esp + esi * 2 + 136405509) = *(esp + esi * 2 + 136405509) << 1;
    asm("sbb ah,ch");
    asm("sbb eax,ecx");
    asm("pusha");
    if(*(eax + 1) = *(eax + 1) + eax + 1) {
        goto L00401be4;
    }
    (restore)edi;
    *%ds:eax] = *%ds:eax] + al;
    *eax = *eax + al;
    eax :: 1247557409;
    *%fs:ebx] = *%fs:ebx] & bl;
    asm("insb");
    *eax = *eax + al;
    *eax = *eax + al;
    eax = eax - 1;
    cl :: 0;
    asm("out 0xc,eax");
    (save)ds;
    asm("rcl dword [edx-0x32],1");
    eax = *L9159C0DF;
    (save)edi;
    *eax = *eax + al;
    *eax = *eax + al;
    dl = dl + al;
    asm("insb");
    dh = dh & bh;
    asm("enter 0xa91f,0xd4");
    al = 114;
    asm("pusha");
    (save)ebx;
    *eax = *eax + al;
    *edi = *edi + dh;
    asm("adc edx,esi");
    *esi = *esi - 1078614882;
    (restore)eax;
    *eax = es;
    *eax = *eax + al;
    ch = ch + bl;
    ebp = ebp + ebx;
}

/* address  size  */
/* 0x0040037b       0 */ /* unknown */ void 	__imp__;
/* 0x00400407       0 */ /* unknown */ void 	__imp__;
/* 0x00401000       0 */ /* unknown */ void 	__imp__HeapDestroy;
/* 0x00401004       0 */ /* unknown */ void 	__imp__HeapLock;
/* 0x00401008       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x0040100c       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x00401010       0 */ /* unknown */ void 	__imp__MapViewOfFile;
/* 0x00401014       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x00401018       0 */ /* unknown */ void 	__imp__EnterCriticalSection;
/* 0x0040101c       0 */ /* unknown */ void 	__imp__GetNamedPipeHandleStateA;
/* 0x00401020       0 */ /* unknown */ void 	__imp__DeleteCriticalSection;
/* 0x00401024       0 */ /* unknown */ void 	__imp__CreateNamedPipeA;
/* 0x00401028       0 */ /* unknown */ void 	__imp__UnmapViewOfFile;
/* 0x0040102c       0 */ /* unknown */ void 	__imp__FileTimeToLocalFileTime;
/* 0x00401030       0 */ /* unknown */ void 	__imp__HeapFree;
/* 0x00401034       0 */ /* unknown */ void 	__imp__HeapSetInformation;
/* 0x00401038       0 */ /* unknown */ void 	__imp__GetCurrentProcessId;
/* 0x0040103c       0 */ /* unknown */ void 	__imp__GetFileTime;
/* 0x00401040       0 */ /* unknown */ void 	__imp__SetCurrentDirectoryA;
/* 0x00401044       0 */ /* unknown */ void 	__imp__SetFilePointerEx;
/* 0x00401048       0 */ /* unknown */ void 	__imp__SetFilePointer;
/* 0x0040104c       0 */ /* unknown */ void 	__imp__LeaveCriticalSection;
/* 0x00401050       0 */ /* unknown */ void 	__imp__HeapCreate;
/* 0x00401054       0 */ /* unknown */ void 	__imp__VirtualQuery;
/* 0x00401058       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x0040105c       0 */ /* unknown */ void 	__imp__InitializeCriticalSection;
/* 0x00401060       0 */ /* unknown */ void 	__imp__VirtualAlloc;
/* 0x00401064       0 */ /* unknown */ void 	__imp__CreateFileMappingA;
/* 0x00401068       0 */ /* unknown */ void 	__imp__ConnectNamedPipe;
/* 0x0040106c       0 */ /* unknown */ void 	__imp__CreateFileA;
/* 0x00401070       0 */ /* unknown */ void 	__imp__GetNamedPipeInfo;
/* 0x00401074       0 */ /* unknown */ void 	__imp__VirtualFree;
/* 0x004016fd       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
