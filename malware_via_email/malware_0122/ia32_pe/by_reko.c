// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00403640(35100, dwLoc14);
	word32 eax_17 = fn004035B0();
	if (eax_17 != 0x00)
	{
		*(fp - 0x08) = eax_17;
		*(fp - 0x0C) = ~0x034A2B0F;
		*(fp - 0x10) = 2976162152;
		<anonymous> * eax_123 = fn004034A0(dwArg00, dwArg04, dwArg08);
		*(fp - 0x0C) = fp - 616;
		*(fp - 0x10) = 0x0104;
		globals->ptr406014 = eax_123;
		struct Eq_59 * esp_128;
		word32 ebp_129;
		word32 eax_130;
		word32 edi_131;
		word32 esi_132;
		word32 ebx_133;
		byte SZO_134;
		byte C_135;
		byte Z_136;
		word32 edx_137;
		word32 ecx_138;
		byte SCZO_139;
		byte cl_140;
		byte CZ_141;
		byte dl_142;
		word16 dx_143;
		byte al_144;
		word16 bx_145;
		word16 ax_146;
		word16 cx_147;
		byte S_148;
		byte ah_149;
		byte bl_150;
		eax_123();
		esp_128->dw0000 = eax_17;
		*(esp_128 - 0x04) = 3096863366;
		*(esp_128 - 0x08) = 2976162152;
		<anonymous> * eax_157 = fn004034A0(dwArg00, dwArg04, dwArg08);
		*(esp_128 - 0x08) = fp - 616;
		esp_128->ptr0004 = fp - 0x0164;
		esp_128->dw0000 = 0x00;
		*(esp_128 - 0x04) = 0x00;
		globals->ptr406010 = eax_157;
		struct Eq_123 * esp_164;
		word32 ebp_165;
		word32 eax_166;
		word32 edi_167;
		word32 esi_168;
		word32 ebx_169;
		byte SZO_170;
		byte C_171;
		byte Z_172;
		word32 edx_173;
		word32 ecx_174;
		byte SCZO_175;
		byte cl_176;
		byte CZ_177;
		byte dl_178;
		word16 dx_179;
		byte al_180;
		word16 bx_181;
		word16 ax_182;
		word16 cx_183;
		byte S_184;
		byte ah_185;
		byte bl_186;
		eax_157();
		*(esp_164 - 0x08) = eax_17;
		*(esp_164 - 0x0C) = 266432455;
		*(esp_164 - 0x10) = 2976162152;
		<anonymous> * eax_193 = fn004034A0(dwArg00, dwArg04, dwArg08);
		*(esp_164 - 0x0C) = 0x5F21224B;
		*(esp_164 - 0x10) = 2976162152;
		*(esp_164 - 0x08) = eax_17;
		globals->ptr406028 = eax_193;
		<anonymous> * eax_199 = fn004034A0(dwArg00, dwArg04, dwArg08);
		esp_164->dw0008 = 0x00;
		esp_164->dw0004 = 0x00;
		esp_164->dw0000 = 0x02;
		*(esp_164 - 0x04) = 0x00;
		*(esp_164 - 0x08) = 0x01;
		globals->ptr406004 = eax_199;
		*(esp_164 - 0x0C) = 0xC0000000;
		*(esp_164 - 0x10) = fp - 0x0164;
		ptr32 esp_209;
		word32 ebp_210;
		word32 eax_211;
		word32 edi_212;
		word32 esi_213;
		word32 ebx_214;
		byte SZO_215;
		byte C_216;
		byte Z_217;
		word32 edx_218;
		word32 ecx_219;
		byte SCZO_220;
		byte cl_221;
		byte CZ_222;
		byte dl_223;
		word16 dx_224;
		byte al_225;
		word16 bx_226;
		word16 ax_227;
		word16 cx_228;
		byte S_229;
		byte ah_230;
		byte bl_231;
		eax_199();
		if (eax_211 != 0x01)
		{
			Eq_250 ecx_237 = globals->t40603C;
			struct Eq_253 * ebx_240 = null;
			ui32 * esi_1929 = (char *) fp - 15352;
			int32 eax_244 = ecx_237 * 0x04 + 0x04;
			ui32 edi_246 = ~0x27C4E228 << (byte) ecx_237;
			do
			{
				*esi_1929 = ebx_240->dw401BC0 ^ edi_246;
				ebx_240 = ebx_240 + eax_244 / 4201412;
				esi_1929 = esi_1929 + (uint32) (0x04 % (ecx_237 - 0x01));
			} while (ebx_240 <= (struct Eq_253 *) 5999);
			struct Eq_283 * edx_270 = null;
			int32 ecx_274 = ecx_237 - 0x01 & 0x04;
			while (true)
			{
				*esi_1929 = (0x00 - (globals->t40603C < 0x01) & 667214377) - 1334428754 ^ edx_270->dw404060;
				edx_270 = edx_270 + ecx_274 / 0x00404064;
				int32 eax_295 = (0x00 - (ecx_237 < 0x01) & ~0x03) + 0x08;
				if (edx_270 > (struct Eq_283 *) 7151)
					break;
				esi_1929 = esi_1929 + eax_295;
			}
			byte * dwLoc88C4_1004 = (char *) fp - 15352;
			ui32 esi_308 = 0x0108 << (byte) ((word32) bLoc88DC);
			if (esi_308 != 0x00)
			{
				struct Eq_332 * ebx_1848 = fp->aFFFFF768;
				ui32 edx_1851 = 0x00;
				byte dl_1853 = 0x00;
				word16 dx_1854 = 0x00;
				do
				{
					ebx_1848->w0000 = dx_1854;
					ebx_1848->w0000 = dx_1854;
					if ((dl_1853 & 0x01) == 0x00)
					{
						ebx_1848->b0004 = (byte) ((word32) *dwLoc88C4_1004 >> (byte) ((0x00 - (ecx_237 < 0x01) & ~0x03) + 0x08));
						ui32 edx_1883 = edx_1851 + 0x01;
						struct Eq_395 * ebx_1890 = ebx_1848 + 0x01;
						ebx_1890->b0004 = (byte) ((word32) *dwLoc88C4_1004 >> (byte) ((0x00 - (ecx_237 < 0x01) & ~0x03) + 0x08));
						edx_1851 = edx_1883 + 0x01;
						dl_1853 = (byte) (edx_1883 + 0x01);
						dx_1854 = (word16) (edx_1883 + 0x01);
						ebx_1848 = (struct Eq_332 *) (&ebx_1890->b0004 + 0x02);
						if (edx_1883 + 0x01 == esi_308)
							break;
						continue;
					}
					ebx_1848->b0004 = (byte) ((word32) *dwLoc88C4_1004 & 0x0F);
					edx_1851 = edx_1851 + 0x01;
					dl_1853 = (byte) edx_1851;
					dx_1854 = (word16) edx_1851;
					dwLoc88C4_1004 = dwLoc88C4_1004 + 0x01;
					ebx_1848 = ebx_1848 + 0x01;
				} while (edx_1851 == esi_308);
			}
			int32 eax_327 = 0x02;
			do
			{
				eax_327 - 0x01 + (fp - 0x20) = (byte *) 0x00;
				eax_327 = eax_327 + 0x01;
			} while (eax_327 != 0x11);
			int32 ebx_342 = ~0x088F;
			do
			{
				ci8 al_358 = (byte) (word32) (ebx_342 + 0x00 + (fp - 0x04));
				if (al_358 > 0x00)
				{
					int32 esi_1834 = (int32) al_358;
					int32 eax_1844 = (word32) (uint32) ((uint64) (uint32) ecx_237 /u (esi_1834 | 0x01)) + esi_1834;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x20)[eax_1844].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = (Eq_460) ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x20)[eax_1844].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000 + 0x01).a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000;
				}
				ebx_342 = ebx_342 + 0x06;
			} while (ebx_342 != 0x0EC0);
			int32 edx_377 = 0x01;
			ui32 dwLoc88F8_381 = 0x00;
			ui32 ebx_383 = DPB(ebx_342, 0x01, 0) << (byte) ((word32) bLoc88DC);
			do
			{
				ui32 v25_394 = dwLoc88F8_381 + (int32) ((edx_377 - 0x01) + (fp - 0x20)) << (byte) ebx_383;
				(fp - 0x60)[edx_377] = ecx_237 ^ v25_394;
				dwLoc88F8_381 = v25_394;
				edx_377 = edx_377 + 0x01;
			} while (edx_377 != 0x10);
			struct Eq_505 * ecx_405 = &fp->aFFFFF76C->b0000;
			do
			{
				int32 edx_410 = (int32) ecx_405->b0000;
				word32 eax_411 = (fp - 0x60)[edx_410];
				*(ecx_405 - 0x02) = (word16) eax_411;
				(fp - 0x60)[edx_410] = eax_411 + 0x01;
				ecx_405 = ecx_405 + 0x01;
			} while (ecx_405 != fp - 0x0264);
			uint32 ebx_447;
			byte cl_423 = 0x00;
			uint32 edx_425 = 0x00;
			uint32 eax_429 = (ecx_237 << 0x08) + 0x0107;
			if (0x00 >= eax_429)
			{
				do
				{
					if (cl_423 == 0x00)
					{
						int32 edi_1010 = 0x80;
						Eq_585 dwLoc88BC_567 = 0x00;
						Eq_587 ecx_570 = (word32) ecx_237 + 0x01 << 0x08;
						while (true)
						{
							while (true)
							{
								Eq_250 ebx_1729 = ecx_237;
								int32 esi_1049 = edi_1010;
								int32 edi_601 = 0x00;
								int32 dwLoc88A4_604 = 0x00;
								Eq_587 dwLoc88C0_1777 = ~0x00;
								do
								{
									ui32 edx_623 = (word32) ecx_237 + 0x01;
									ui32 ecx_1829 = 0x00;
									do
									{
										ecx_1829 = ecx_1829 * 0x02;
										if (((word32) *dwLoc88C4_1004 & esi_1049) != 0x00)
											ecx_1829 = ecx_1829 | 0x01;
										esi_1049 = esi_1049 >> 0x01;
										if (esi_1049 == 0x00)
										{
											dwLoc88C4_1004 = dwLoc88C4_1004 + 0x01;
											esi_1049 = 0x80;
										}
										edx_623 = edx_623 - 0x01;
									} while (edx_623 != 0x00);
									int32 v30_669 = dwLoc88A4_604 << 0x01 | ecx_1829;
									ui32 eax_668 = ebx_1729 * 0x03;
									edi_601 = edi_601 + 0x01;
									dwLoc88A4_604 = v30_669;
									int32 edx_1812 = (int32) fp->aFFFFF76C[eax_668].b0000;
									if (edi_601 > edx_1812)
									{
										struct Eq_685 * eax_1805 = fp->aFFFFF768 + eax_668 + 0x0A;
										do
										{
											edx_1812 = (int32) eax_1805->b0000;
											ebx_1729 = (word32) ebx_1729.u1 + 0x01;
											eax_1805 = eax_1805 + 0x01;
										} while (edi_601 > edx_1812);
									}
									if (edi_601 == edx_1812)
									{
										ui32 eax_1748 = ebx_1729 * 0x03;
										struct Eq_711 * edx_1754 = fp->aFFFFF768 + eax_1748;
										if ((int32) fp->aFFFFF76A[eax_1748] != v30_669)
										{
											do
											{
												word32 ebx_1787 = (word32) ebx_1729 + 0x01;
												ebx_1729 = ebx_1787 + 0x01;
												if ((int32) edx_1931->b000A != edi_601)
													goto l004016BD;
												edx_1754 = (struct Eq_711 *) ((char *) edx_1931 + 0x06);
												struct Eq_711 * edx_1931 = edx_1754;
											} while ((int32) edx_1931->w0008 == v30_669);
										}
										int32 eax_1767 = (int32) fp->aFFFFF768[ebx_1729 * 0x03];
										Eq_587 eax_1776 = (word32) (uint32) ((uint64) (uint32) ecx_237 /u (eax_1767 | 0x01)) + eax_1767;
										dwLoc88C0_1777 = eax_1776;
										if (eax_1776 >= 0x00)
											break;
										continue;
									}
								} while (dwLoc88C0_1777 < 0x00);
								if (dwLoc88C0_1777 >= (word32) ecx_237 + 0x0100)
									break;
								Mem726[fp + ~0x8897 + dwLoc88BC_567:byte] = (byte) (word32) bLoc88C0;
								int32 edx_727 = (word32) dwLoc88BC_567.u0 + 0x01;
								((char *) fp - 0x00008898)[edx_727] = (byte) (word32) bLoc88C0;
								((char *) fp - 0x00008898)[edx_727 + 0x01] = (byte) (word32) bLoc88C0;
								edi_1010 = esi_1049;
								dwLoc88BC_567 = edx_727 + 0x02;
							}
							if (dwLoc88C0_1777 == ecx_570)
								break;
							word32 eax_750 = 0x00 - (ecx_237 < 0x01);
							Eq_815 ecx_755 = dwLoc88C0_1777 - (DPB(eax_750, SLICE(eax_750, byte, 8) & ~0x01, 8) + 0x0202);
							int32 eax_761 = (int32) (ecx_755 * 0x03)->a405C62[ecx_755].w0000;
							uint32 dwLoc88B0_1043 = ~0x00;
							int32 ebx_767 = (int32) (ecx_755 * 0x03)->a405C60[ecx_755].w0000 & ecx_237 - 0x01;
							if (eax_761 != ~0x00)
								dwLoc88B0_1043 = (uint32) ((uint64) (uint32) eax_761 % (ecx_237 - 0x01));
							ui32 edx_1027;
							byte bl_1009;
							byte bLoc88DD_1017;
							int32 dwLoc88B4_1020;
							word16 cx_782 = (word16) (word32) (ecx_755 * 0x03)->a405C64[ecx_755].w0000;
							if (ebx_767 != 0x00)
							{
								bl_1009 = (byte) (word32) *dwLoc88C4_1004;
								dwLoc88B4_1020 = ebx_767;
								edi_1010 = esi_1049 >> 0x01;
								bLoc88DD_1017 = bl_1009;
								edx_1027 = (word32) bl_1009;
							}
							else
							{
								bl_1009 = (byte) (word32) *dwLoc88C4_1004;
								ui32 eax_1032 = 0x00;
								bLoc88DD_1017 = bl_1009;
								do
								{
									ui32 eax_1054 = eax_1032 * 0x02;
									edx_1027 = (word32) bl_1009;
									eax_1032 = eax_1054 * 0x02;
									if ((edx_1027 & esi_1049) != 0x00)
										eax_1032 = eax_1054 * 0x02 | 0x01 | 0x01;
									esi_1049 = esi_1049 >> 0x01;
									if (esi_1049 == 0x00)
									{
										byte * v45_1106 = dwLoc88C4_1004 + 0x01;
										uint32 v46_1114 = dwLoc88B0_1043 - 0x01;
										bl_1009 = (byte) (word32) *v45_1106;
										dwLoc88C4_1004 = v45_1106;
										esi_1049 = 0x80;
										edi_1010 = 0x40;
										dwLoc88B0_1043 = v46_1114;
										bLoc88DD_1017 = bl_1009;
										edx_1027 = (word32) bl_1009;
										if (v46_1114 == 0x00)
											break;
										continue;
									}
									uint32 v47_1125 = dwLoc88B0_1043 - 0x01;
									edi_1010 = esi_1049 >> 0x01;
									dwLoc88B0_1043 = v47_1125;
								} while (v47_1125 == 0x00);
								int32 ecx_1091 = (int32) cx_782 *s ((word32) ecx_237 + 0x01);
								if (ecx_237 != 0x00)
									ecx_1091 = ecx_1091 * 0x02;
								dwLoc88B4_1020 = ecx_1091 + eax_1032;
							}
							int32 dwLoc88F8_1002;
							ui32 eax_1012;
							if (edi_1010 != 0x00)
							{
								eax_1012 = edx_1027;
								dwLoc88F8_1002 = edi_1010 >> 0x01;
							}
							else
							{
								byte * v43_1003 = dwLoc88C4_1004 + 0x01;
								bl_1009 = (byte) (word32) *v43_1003;
								dwLoc88C4_1004 = v43_1003;
								edi_1010 = 0x80;
								dwLoc88F8_1002 = 0x40;
								eax_1012 = (word32) bl_1009;
								bLoc88DD_1017 = bl_1009;
							}
							ui32 dwLoc88B8_824 = 0x07;
							if ((edx_1027 & esi_1049) != 0x00)
							{
								if (dwLoc88F8_1002 == 0x00)
								{
									byte * v36_985 = dwLoc88C4_1004 + 0x01;
									dwLoc88C4_1004 = v36_985;
									dwLoc88F8_1002 = 0x80;
									bLoc88DD_1017 = (byte) (word32) *v36_985;
								}
								bl_1009 = (byte) (word32) bLoc88DD_1017;
								edi_1010 = dwLoc88F8_1002;
								dwLoc88B8_824 = (word32) ((eax_1012 & edi_1010) != 0x00) + (0x08 << (byte) ((word32) bLoc88DC));
							}
							struct Eq_895 * eax_837 = dwLoc88B8_824 * 0x03;
							word32 esi_839 = (int32) Mem420[eax_837 + 0x00405C62 + eax_837:word16];
							int32 edx_847 = (word32) (uint32) ((uint64) (uint32) ecx_237 /u (esi_839 | 0x01)) + esi_839;
							ui32 esi_851 = 0x00;
							while (true)
							{
								esi_851 = esi_851 * 0x02;
								if (((word32) bl_1009 & edi_1010) != 0x00)
									esi_851 = esi_851 | 0x01;
								edi_1010 = edi_1010 >> 0x01;
								if (edi_1010 == 0x00)
								{
									dwLoc88C4_1004 = dwLoc88C4_1004 + 0x01;
									edi_1010 = 0x80;
								}
								edx_847 = edx_847 - 0x01;
								if (edx_847 == 0x00)
									break;
								bl_1009 = (byte) (word32) *dwLoc88C4_1004;
							}
							struct Eq_1746 * eax_887 = dwLoc88B8_824 * 0x03;
							word16 ax_893 = (word16) (word32) Mem420[eax_887 + 0x00405C64 + eax_887:word16];
							if (dwLoc88B4_1020 > 0x00)
							{
								word32 ebx_915 = fp + ~0x8897 + dwLoc88BC_567;
								int32 esi_923 = 0x00;
								byte * edx_925 = ebx_915 - (esi_851 + ((int32) ax_893 << (byte) ((word32) bLoc88DC)) ^ ecx_237);
								do
								{
									word32 ecx_933 = (word32) *edx_925;
									*ebx_915 = (byte) ((ecx_237 << (byte) ecx_933) + ecx_933);
									esi_923 = esi_923 + 0x01;
									edx_925 = edx_925 + 0x01;
									ebx_915 = ebx_915 + 0x01;
								} while (esi_923 != dwLoc88B4_1020);
							}
							dwLoc88BC_567 = (word32) dwLoc88BC_567.u0 + ((word32) globals->t40603C + 0x01) *s dwLoc88B4_1020;
						}
						int32 ebx_1152;
						struct Eq_807 * esp_1151;
						if (dwLoc88BC_567 > 0x00)
						{
							struct Eq_1090 * esi_1411 = (struct Eq_1090 *) ~0x00;
							struct Eq_1092 * edi_1412 = null;
							Eq_585 ebx_1413 = 0x00;
							do
							{
								ui32 edx_1450 = (word32) ((word32) ebx_1413.u0 - 0x00008894 + (fp - 0x04));
								int32 ecx_1461 = (uint32) ((uint64) (uint32) ecx_237 /u (edx_1450 | 0x01)) + edx_1450;
								byte cl_1462 = (byte) ecx_1461;
								if (esi_1411 <= (struct Eq_1090 *) 0x43)
								{
									if (edi_1412 < (struct Eq_1092 *) 0x0F0F0F1F)
									{
										word32 edi_1601 = (word32) (edi_1412->b404000 != cl_1462) - 0x01 & edi_1412 + 0x01;
										edi_1412 = (word32) (edi_1601->b404000 != cl_1462) - 0x01 & edi_1601 + 0x01;
									}
									else
									{
										esi_1411 = esi_1411 + 0x01;
										if (esi_1411 <= (struct Eq_1090 *) 0x2F)
										{
											int32 ecx_1615 = (int32) esi_1411[0x00404010];
											ecx_1461 = (word32) (uint32) ((uint64) (uint32) ecx_237 /u (ecx_1615 | 0x01)) + ecx_1615;
										}
										else if (esi_1411 <= (struct Eq_1090 *) 0x3F)
											ecx_1461 = (int32) (esi_1411 - (ecx_237 << 0x30))->b404010;
										else
											ecx_1461 = (int32) (esi_1411 - (uint32) (0x40 % (ecx_237 - 0x01)))->b406000;
									}
								}
								byte al_1476 = (byte) ecx_1461;
								if (ecx_237 != 0x00)
									al_1476 = (byte) (ecx_1461 * 0x02);
								(word32) ebx_1413.u0 - 0x00008894 + (fp - 0x04) = (byte *) al_1476;
								ebx_1413 = (word32) ebx_1413.u0 + 0x01;
							} while (ebx_1413 == dwLoc88BC_567);
							*(esp_209 - 0x18) = 2441920163;
							*(esp_209 - 0x1C) = 2976162152;
							*(esp_209 - 0x14) = eax_17;
							<anonymous> * eax_1496 = fn004034A0(dwArg00, dwArg04, dwArg08);
							*(esp_209 - 0x08) = 0x00;
							*(esp_209 - 0x10) = 0x00;
							*(esp_209 - 0x1C) = eax_211;
							*(esp_209 - 0x0C) = (union Eq_585 *) dwLoc88BC_567;
							globals->ptr40602C = eax_1496;
							*(esp_209 - 0x14) = 0x04;
							*(esp_209 - 0x18) = 0x00;
							ptr32 esp_1506;
							word32 ebp_1507;
							word32 eax_1508;
							word32 edi_1509;
							word32 esi_1510;
							word32 ebx_1511;
							byte SZO_1512;
							byte C_1513;
							byte Z_1514;
							word32 edx_1515;
							word32 ecx_1516;
							byte SCZO_1517;
							byte cl_1518;
							byte CZ_1519;
							byte dl_1520;
							word16 dx_1521;
							byte al_1522;
							word16 bx_1523;
							word16 ax_1524;
							word16 cx_1525;
							byte S_1526;
							byte ah_1527;
							byte bl_1528;
							eax_1496();
							*(esp_1506 - 0x10) = eax_17;
							*(esp_1506 - 0x14) = ~0x6A2DD289;
							*(esp_1506 - 0x18) = 2976162152;
							<anonymous> * eax_1536 = fn004034A0(dwArg00, dwArg04, dwArg08);
							*(esp_1506 - 0x08) = 0x00;
							*(esp_1506 - 0x0C) = 0x00;
							*(esp_1506 - 0x10) = 0x00;
							*(esp_1506 - 0x14) = 0x02;
							*(esp_1506 - 0x18) = eax_1508;
							globals->ptr406030 = eax_1536;
							word32 esp_1543;
							word32 ebp_1544;
							int32 eax_1545;
							word32 edi_1546;
							word32 esi_1547;
							word32 ebx_1548;
							byte SZO_1549;
							byte C_1550;
							byte Z_1551;
							word32 edx_1552;
							word32 ecx_1553;
							byte SCZO_1554;
							byte cl_1555;
							byte CZ_1556;
							byte dl_1557;
							word16 dx_1558;
							byte al_1559;
							word16 bx_1560;
							word16 ax_1561;
							word16 cx_1562;
							byte S_1563;
							byte ah_1564;
							byte bl_1565;
							eax_1536();
							Eq_585 edx_1566 = 0x00;
							esp_1151 = esp_1543 - 0x14;
							ebx_1152 = eax_1545;
							do
							{
								*((word32) edx_1566 + eax_1545) = (byte) (word32) ((word32) edx_1566 - 0x00008894 + (fp - 0x04));
								edx_1566 = (word32) edx_1566 + 0x01;
							} while (edx_1566 != dwLoc88BC_567);
						}
						else
						{
							*(esp_209 - 0x18) = 2441920163;
							*(esp_209 - 0x1C) = 2976162152;
							*(esp_209 - 0x14) = eax_17;
							<anonymous> * eax_1653 = fn004034A0(dwArg00, dwArg04, dwArg08);
							*(esp_209 - 0x08) = 0x00;
							*(esp_209 - 0x10) = 0x00;
							*(esp_209 - 0x1C) = eax_211;
							*(esp_209 - 0x0C) = (union Eq_585 *) dwLoc88BC_567;
							globals->ptr40602C = eax_1653;
							*(esp_209 - 0x14) = 0x04;
							*(esp_209 - 0x18) = 0x00;
							ptr32 esp_1663;
							word32 ebp_1664;
							word32 eax_1665;
							word32 edi_1666;
							word32 esi_1667;
							word32 ebx_1668;
							byte SZO_1669;
							byte C_1670;
							byte Z_1671;
							word32 edx_1672;
							word32 ecx_1673;
							byte SCZO_1674;
							byte cl_1675;
							byte CZ_1676;
							byte dl_1677;
							word16 dx_1678;
							byte al_1679;
							word16 bx_1680;
							word16 ax_1681;
							word16 cx_1682;
							byte S_1683;
							byte ah_1684;
							byte bl_1685;
							eax_1653();
							*(esp_1663 - 0x10) = eax_17;
							*(esp_1663 - 0x14) = ~0x6A2DD289;
							*(esp_1663 - 0x18) = 2976162152;
							<anonymous> * eax_1693 = fn004034A0(dwArg00, dwArg04, dwArg08);
							*(esp_1663 - 0x08) = 0x00;
							*(esp_1663 - 0x0C) = 0x00;
							*(esp_1663 - 0x10) = 0x00;
							*(esp_1663 - 0x14) = 0x02;
							*(esp_1663 - 0x18) = eax_1665;
							globals->ptr406030 = eax_1693;
							word32 esp_1700;
							word32 ebp_1701;
							int32 eax_1702;
							word32 edi_1703;
							word32 esi_1704;
							word32 ebx_1705;
							byte SZO_1706;
							byte C_1707;
							byte Z_1708;
							word32 edx_1709;
							word32 ecx_1710;
							byte SCZO_1711;
							byte cl_1712;
							byte CZ_1713;
							byte dl_1714;
							word16 dx_1715;
							byte al_1716;
							word16 bx_1717;
							word16 ax_1718;
							word16 cx_1719;
							byte S_1720;
							byte ah_1721;
							byte bl_1722;
							eax_1693();
							esp_1151 = esp_1700 - 0x14;
							ebx_1152 = eax_1702;
						}
						esp_1151->dw0004 = 3533983127;
						esp_1151->dw0000 = 2976162152;
						esp_1151->dw0008 = eax_17;
						<anonymous> * eax_1158 = fn004034A0(dwArg00, dwArg04, dwArg08);
						esp_1151->dw0000 = ebx_1152;
						globals->ptr406034 = eax_1158;
						struct Eq_1388 * esp_1161;
						word32 ebp_1162;
						word32 eax_1163;
						word32 edi_1164;
						word32 esi_1165;
						word32 ebx_1166;
						byte SZO_1167;
						byte C_1168;
						byte Z_1169;
						word32 edx_1170;
						word32 ecx_1171;
						byte SCZO_1172;
						byte cl_1173;
						byte CZ_1174;
						byte dl_1175;
						word16 dx_1176;
						byte al_1177;
						word16 bx_1178;
						word16 ax_1179;
						word16 cx_1180;
						byte S_1181;
						byte ah_1182;
						byte bl_1183;
						eax_1158();
						esp_1161->dw0004 = edi_1164;
						esp_1161->dw0000 = ~0x0C1531BF;
						*(esp_1161 - 0x04) = 2976162152;
						<anonymous> * eax_1189 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1161 - 0x04) = esi_1165;
						globals->ptr406008 = eax_1189;
						ptr32 esp_1192;
						word32 ebp_1193;
						word32 eax_1194;
						word32 edi_1195;
						word32 esi_1196;
						word32 ebx_1197;
						byte SZO_1198;
						byte C_1199;
						byte Z_1200;
						word32 edx_1201;
						word32 ecx_1202;
						byte SCZO_1203;
						byte cl_1204;
						byte CZ_1205;
						byte dl_1206;
						word16 dx_1207;
						byte al_1208;
						word16 bx_1209;
						word16 ax_1210;
						word16 cx_1211;
						byte S_1212;
						byte ah_1213;
						byte bl_1214;
						eax_1189();
						*(esp_1192 - 0x04) = eax_211;
						struct Eq_1461 * esp_1219;
						word32 ebp_1220;
						word32 eax_1221;
						word32 edi_1222;
						word32 esi_1223;
						word32 ebx_1224;
						byte SZO_1225;
						byte C_1226;
						byte Z_1227;
						word32 edx_1228;
						word32 ecx_1229;
						byte SCZO_1230;
						byte cl_1231;
						byte CZ_1232;
						byte dl_1233;
						word16 dx_1234;
						byte al_1235;
						word16 bx_1236;
						word16 ax_1237;
						word16 cx_1238;
						byte S_1239;
						byte ah_1240;
						byte bl_1241;
						globals->ptr406008();
						esp_1219->dw0004 = edi_1222;
						esp_1219->dw0000 = ~0x456B9945;
						*(esp_1219 - 0x04) = 2976162152;
						<anonymous> * eax_1247 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1219 - 0x04) = fp - 0x0164;
						globals->ptr40601C = eax_1247;
						struct Eq_1510 * esp_1251;
						word32 ebp_1252;
						word32 eax_1253;
						word32 edi_1254;
						word32 esi_1255;
						word32 ebx_1256;
						byte SZO_1257;
						byte C_1258;
						byte Z_1259;
						word32 edx_1260;
						word32 ecx_1261;
						byte SCZO_1262;
						byte cl_1263;
						byte CZ_1264;
						byte dl_1265;
						word16 dx_1266;
						byte al_1267;
						word16 bx_1268;
						word16 ax_1269;
						word16 cx_1270;
						byte S_1271;
						byte ah_1272;
						byte bl_1273;
						eax_1247();
						esp_1251->dw0004 = edi_1254;
						esp_1251->ptr0000 = 2721421706;
						*(esp_1251 - 0x04) = 2976162152;
						<anonymous> * eax_1281 = fn004034A0(dwArg00, dwArg04, dwArg08);
						esp_1251->ptr0000 = fp - 616;
						esp_1251->dw0004 = 0x0104;
						*(esp_1251 - 0x04) = 0x00;
						globals->ptr406018 = eax_1281;
						ptr32 esp_1287;
						word32 ebp_1288;
						word32 eax_1289;
						word32 edi_1290;
						word32 esi_1291;
						word32 ebx_1292;
						byte SZO_1293;
						byte C_1294;
						byte Z_1295;
						word32 edx_1296;
						word32 ecx_1297;
						byte SCZO_1298;
						byte cl_1299;
						byte CZ_1300;
						byte dl_1301;
						word16 dx_1302;
						byte al_1303;
						word16 bx_1304;
						word16 ax_1305;
						word16 cx_1306;
						byte S_1307;
						byte ah_1308;
						byte bl_1309;
						eax_1281();
						*(esp_1287 - 0x04) = ebx_1292;
						*(esp_1287 - 0x08) = 3646652680;
						*(esp_1287 - 0x0C) = 2976162152;
						<anonymous> * eax_1315 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1287 - 0x0C) = fp - 616;
						globals->ptr406038 = eax_1315;
						struct Eq_1616 * esp_1318;
						word32 ebp_1319;
						word32 eax_1320;
						word32 edi_1321;
						word32 esi_1322;
						word32 ebx_1323;
						byte SZO_1324;
						byte C_1325;
						byte Z_1326;
						word32 edx_1327;
						word32 ecx_1328;
						byte SCZO_1329;
						byte cl_1330;
						byte CZ_1331;
						byte dl_1332;
						word16 dx_1333;
						byte al_1334;
						word16 bx_1335;
						word16 ax_1336;
						word16 cx_1337;
						byte S_1338;
						byte ah_1339;
						byte bl_1340;
						eax_1315();
						esp_1318->dw0004 = eax_17;
						esp_1318->dw0000 = 840618587;
						*(esp_1318 - 0x04) = 2976162152;
						<anonymous> * eax_1347 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1318 - 0x04) = ebx_1323;
						globals->ptr406020 = eax_1347;
						struct Eq_1661 * esp_1350;
						word32 ebp_1351;
						word32 eax_1352;
						word32 edi_1353;
						word32 esi_1354;
						word32 ebx_1355;
						byte SZO_1356;
						byte C_1357;
						byte Z_1358;
						word32 edx_1359;
						word32 ecx_1360;
						byte SCZO_1361;
						byte cl_1362;
						byte CZ_1363;
						byte dl_1364;
						word16 dx_1365;
						byte al_1366;
						word16 bx_1367;
						word16 ax_1368;
						word16 cx_1369;
						byte S_1370;
						byte ah_1371;
						byte bl_1372;
						eax_1347();
						esp_1350->dw0004 = eax_17;
						esp_1350->dw0000 = 0x30E1FE37;
						*(esp_1350 - 0x04) = 2976162152;
						<anonymous> * eax_1379 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1350 - 0x04) = 0x00;
						globals->ptr406024 = eax_1379;
						word32 esp_1382;
						word32 ebp_1383;
						word32 eax_1384;
						word32 edi_1385;
						word32 esi_1386;
						word32 ebx_1387;
						byte SZO_1388;
						byte C_1389;
						byte Z_1390;
						word32 edx_1391;
						word32 ecx_1392;
						byte SCZO_1393;
						byte cl_1394;
						byte CZ_1395;
						byte dl_1396;
						word16 dx_1397;
						byte al_1398;
						word16 bx_1399;
						word16 ax_1400;
						word16 cx_1401;
						byte S_1402;
						byte ah_1403;
						byte bl_1404;
						eax_1379();
						return 0x00;
					}
					cl_423 = 0x00;
					ebx_447 = 0x00;
l00401330:
					edx_425 = ebx_447;
				} while (edx_425 >= eax_429);
			}
			struct Eq_549 * edi_442 = fp - 0x10 + (edx_425 * 0x03) * 0x02;
			ebx_447 = edx_425 + 0x01;
			byte al_446 = (byte) (word32) edi_442->tFFFFF77C;
			struct Eq_565 * eax_454 = fp - 0x10 + (ebx_447 * 0x03) * 0x02;
			if ((byte) (word32) al_446 > *(eax_454 - 0x0884))
			{
				word16 dx_467 = (word16) (word32) edi_442->wFFFFF77A;
				Eq_600 cx_469 = (word16) (word32) edi_442->tFFFFF778;
				edi_442->tFFFFF778 = eax_454->tFFFFF778;
				edi_442->tFFFFF77C = (word16) (word32) *(eax_454 - 0x0884);
				*(eax_454 - 0x0886) = dx_467;
				*(eax_454 - 0x0884) = (byte) (word32) al_446;
				eax_454->tFFFFF778 = cx_469;
				cl_423 = 0x01;
				edx_425 = ebx_447;
				goto l00401332;
			}
			goto l00401330;
		}
	}
	return 0x00;
}

// 00403350: Register int32 fn00403350(Stack word32 dwArg04, Stack int32 dwArg08, Stack ptr32 dwArg0C)
int32 fn00403350(word32 dwArg04, int32 dwArg08, ptr32 dwArg0C)
{
	Eq_250 edx_8 = globals->t40603C;
	int32 edi_118 = dwArg04;
	int32 ecx_24 = (0x00 - (edx_8 < 0x01) & ~0x63) + 200;
	byte bl_29 = (byte) (word32) *dwArg0C;
	if (bl_29 != 0x00)
	{
		byte cl_67 = (byte) edx_8;
		int32 ebx_84 = edx_8 - 0x01 & 0x33;
		int32 esi_91 = dwArg08 *s dwArg04;
		int32 edx_90 = ((uint32) (100 % (edx_8 - 0x01)) *s (((word32) edx_8 + 0x01) *s 0x55 + (0x25 << cl_67) *s ecx_24) + ebx_84) *s dwArg08;
		int32 eax_96 = fn00403350((word32) bl_29 + esi_91, edx_90, dwArg0C + 0x01);
		<anonymous> * eax_99 = globals->ptr406028;
		if (eax_99 != null)
		{
			word32 esp_122;
			word32 ebp_123;
			byte SCZO_124;
			word32 edx_125;
			word32 eax_126;
			word32 esi_127;
			word32 edi_128;
			byte C_129;
			word32 ecx_130;
			byte SZO_131;
			word32 ebx_132;
			byte bl_133;
			byte Z_134;
			byte cl_135;
			eax_99();
		}
		edi_118 = eax_96;
	}
	return edi_118;
}

// 00403420: Register ui32 fn00403420(Stack ui32 dwArg04, Stack word32 dwArg08)
ui32 fn00403420(ui32 dwArg04, word32 dwArg08)
{
	Eq_250 esi_16 = globals->t40603C;
	uint32 edx_23 = SLICE(esi_16 * 98685563, word32, 32);
	return dwArg04 ^ fn00403350(0x00, (((word32) (edx_23 + (esi_16 - edx_23 >> 0x01) >> 0x09) + 1000) *s ((word32) ((esi_16 - 0x04104105 >> 0x01) + 0x04104105 >> 0x05) + 0x003F) + 0x02B1) + (SLICE(esi_16 * 797903939, word32, 32) >> 0x07), dwArg08);
}

// 004034A0: Register ptr32 fn004034A0(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
ptr32 fn004034A0(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	struct Eq_1977 * esi_201;
	Eq_250 ebx_121 = globals->t40603C;
	word32 edi_33 = dwArg0C *s (ebx_121 + 0x01) + Mem0[((uint32) ((uint64) ((uint32) ebx_121) /u (dwArg0C | 0x01)) + 0x78) + (dwArg0C + Mem0[dwArg0C + 0x3C:word32]):word32];
	word32 eax_34 = edi_33->dw0020;
	word32 ecx_36 = edi_33->dw0024;
	if (eax_34 != ~0x00)
		esi_201 = (uint32) ((uint64) (uint32) eax_34 % (ebx_121 - 0x01));
	else
		esi_201 = (struct Eq_1977 *) ~0x00;
	if ((edi_33->dw0018 & ebx_121 - 0x01) != 0x00)
	{
		word32 esi_107[] = esi_201 + dwArg0C;
		word32 eax_109 = (dwArg0C << (byte) ebx_121) + ecx_36;
		uint32 esi_111 = 0x00;
l0040352D:
		word16 * edx_137 = eax_109 + esi_111 * 0x02;
		word32 eax_139 = esi_107[esi_111];
		ui32 edx_140 = dwArg04;
		if (ebx_121 != 0x00)
			edx_140 = dwArg04 * 0x02;
		int32 eax_148 = fn00403420(edx_140, dwArg0C + eax_139 / 0x0040);
		ebx_121 = globals->t40603C;
		if (eax_148 == ((word32) ebx_121.u0 + 0x01) *s dwArg08)
		{
			Eq_2087 ecx_158[] = dwArg0C + edi_33->dw001C / 0x0040;
			word32 esi_164 = dwArg0C + Mem0[(ecx_158 + (word32) (*edx_137) * 0x04) + (ebx_121 << (byte) ecx_158):word32];
			return esi_164 + (uint32) ((uint64) ((uint32) ebx_121) /u (esi_164 | 0x01));
		}
		esi_111 = esi_111 + 0x01;
		if ((ebx_121 - 0x01 & edi_33->dw0018) > esi_111)
			goto l0040352D;
	}
	return 0x00;
}

// 004035B0: Register ui32 fn004035B0()
ui32 fn004035B0()
{
	Eq_250 esi_19 = globals->t40603C;
	uint32 eax_27 = *((word32) esi_19.u0 + (((fs->ptr0018)->dw0030 ^ esi_19)->ptr000C + 0x1C));
	byte dl_34 = (byte) (uint32) (0x6B % (esi_19 - 0x01));
	struct Eq_2122 * ebx_37 = eax_27 >> (byte) esi_19;
	do
	{
		ui32 eax_115;
		struct Eq_2135 * ecx_55 = ebx_37->dw0020 & esi_19 - 0x01;
		if (ecx_55->b0000 == dl_34)
		{
			if (ecx_55->b0002 == (byte) ((word32) bLoc18))
			{
				if (ecx_55->b0004 == (byte) (esi_19 ^ 114))
				{
					eax_115 = ebx_37->dw0008 | esi_19;
					return eax_115;
				}
			}
		}
		ebx_37 = ebx_37->dw0000 >> (byte) esi_19;
	} while (eax_27 == ebx_37->dw0000);
	eax_115 = 0x00;
	return eax_115;
}

// 00403640: void fn00403640(Register uint32 eax, Stack word32 dwArg00)
void fn00403640(uint32 eax, word32 dwArg00)
{
	struct Eq_2186 * ecx_10 = fp + 0x04;
	while (eax >= 0x1000)
	{
		ecx_10 = ecx_10 - 0x1000;
		ecx_10->dw0000 = ecx_10->dw0000;
		eax = eax - 0x1000;
	}
	word32 * ecx_22 = ecx_10 - eax;
	*ecx_22 = *ecx_22;
	word32 esp_32;
	word32 ecx_33;
	byte SCZO_34;
	word32 eax_35;
	byte C_36;
	byte SZO_37;
	dwArg00();
	return;
}

