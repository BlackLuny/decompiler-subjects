// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00401078(4198699, 0x062E);
	fn0040112B(bl);
	fn00401078(4198699, 0x062E);
	if (false)
	{
		*(fp - 0x18) = 0x00405000;
		*(fp - 0x1C) = 0x00401000;
		lstrcpyA(*(fp - 0x1C), *(fp - 0x18));
	}
	return 0x00;
}

// 00401078: void fn00401078(Stack word32 dwArg04, Stack word32 dwArg08)
void fn00401078(word32 dwArg04, word32 dwArg08)
{
	Eq_86 (* dwLoc08_24)[] = null;
	while (dwLoc08_24 < dwArg08)
	{
		if (dwLoc08_24 > (Eq_86 (*)[]) 0x01)
		{
			word32 eax_109 = dwLoc08_24 + dwArg04;
			Mem116[dwArg04 + dwLoc08_24:byte] = (byte) (DPB(eax_109, *eax_109, 0) ^ 0x1E);
		}
		if (dwLoc08_24 > (Eq_86 (*)[]) 0x02 && (dwLoc08_24 - 0x02 & 0x01) == 0x00)
		{
			word32 eax_98 = dwLoc08_24 + dwArg04;
			Mem104[dwArg04 + dwLoc08_24:byte] = (byte) (DPB(eax_98, *eax_98, 0) + 0x7F);
		}
		if (dwLoc08_24 > (Eq_86 (*)[]) 0x02)
		{
			Eq_86 (* edx_66)[] = dwLoc08_24 - (Eq_86 (*)[]) 0x02;
			if ((int32) (SEQ(edx_66 >> 0x1F, edx_66) % 0x03) == 0x00)
				Mem87[dwArg04 + dwLoc08_24:byte] = Mem0[dwLoc08_24 + dwArg04:byte] - 0xCC;
		}
		Mem60[dwArg04 + dwLoc08_24:byte] = Mem0[dwLoc08_24 + dwArg04:byte] - (byte) dwLoc08_24;
		dwLoc08_24 = dwLoc08_24 + 0x01;
	}
	return;
}

// 0040112B: void fn0040112B(Register byte bl)
void fn0040112B(byte bl)
{
fn0040112B_entry:
l0040112B:
fn0040112B_exit:
}

