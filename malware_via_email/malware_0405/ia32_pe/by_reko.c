// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_13;
	byte SCZO_14;
	word32 esi_15;
	byte SZO_16;
	byte C_17;
	word32 eax_18;
	byte Z_19;
	word32 ebx_20;
	word32 ebp_21;
	word32 edi_22;
	byte cl_23;
	byte dl_24;
	word32 edx_25;
	word32 ecx_26;
	byte S_27;
	SHLWAPI.dll!StrChrA();
	if (eax_18 == 0x00)
	{
		*(esp_13 - 0x04) = eax_18;
		*(esp_13 - 0x08) = 0x00404070;
		ptr32 esp_53;
		byte SCZO_54;
		word32 esi_55;
		byte SZO_56;
		byte C_57;
		word32 eax_58;
		byte Z_59;
		word32 ebx_60;
		word32 ebp_61;
		word32 edi_62;
		byte cl_63;
		byte dl_64;
		word32 edx_65;
		word32 ecx_66;
		byte S_67;
		SHLWAPI.dll!StrStrIA();
		if (eax_58 == 0x00)
		{
			*(esp_53 - 0x04) = ebx_60;
			*(esp_53 - 0x08) = ebp_61;
			*(esp_53 - 0x0C) = edi_62;
			*(esp_53 - 0x10) = 0x0040407C;
			*(esp_53 - 0x14) = 0x00404084;
			*(esp_53 - 0x14) = (HMODULE *) LoadLibraryA(*(esp_53 - 0x14));
			Eq_91 eax_85 = GetProcAddress(*(esp_53 - 0x14), *(esp_53 - 0x10));
			*(esp_53 - 0x10) = 0x00;
			*(esp_53 - 0x14) = 0x00;
			*(esp_53 - 0x18) = 0x00;
			*(esp_53 - 0x1C) = 0x00;
			*(esp_53 - 0x20) = 0x00;
			int32 eax_102 = eax_85();
			*(esp_53 - 0x24) = ~0x00;
			*(esp_53 - 0x28) = ~0x00;
			struct Eq_150 * edi_113 = eax_102 + 0x1C;
			if (AreAllAccessesGranted(*(esp_53 - 0x28), *(esp_53 - 0x24)) == 0x00)
				edi_113 = eax_102 + 0x1C ^ 0x0E;
			*(esp_53 - 0x24) = esp_53 - 0x10;
			*(esp_53 - 0x28) = 0x40;
			*(esp_53 - 44) = 0x3000;
			*(esp_53 - 0x30) = 0x00401000;
			VirtualProtect(*(esp_53 - 0x30), *(esp_53 - 44), *(esp_53 - 0x28), *(esp_53 - 0x24));
			struct Eq_220 * eax_135 = null;
			do
			{
				struct Eq_150 * esi_145;
				if (esi_145 == edi_113)
					esi_145 = null;
				eax_135[700564] = (struct Eq_220) (esi_145[0x00405000] ^ eax_135[700564] ^ 0x5A);
				struct Eq_150 * esi_153 = esi_145 + 0x01;
				if (esi_153 == edi_113)
					esi_153 = null;
				eax_135->b402379 = esi_153[0x00405000] ^ eax_135->b402379 ^ 0x5A;
				struct Eq_150 * esi_163 = esi_153 + 0x01;
				if (esi_163 == edi_113)
					esi_163 = null;
				eax_135->b40237A = esi_163[0x00405000] ^ eax_135->b40237A ^ 0x5A;
				struct Eq_150 * esi_173 = esi_163 + 0x01;
				if (esi_173 == edi_113)
					esi_173 = null;
				eax_135->b40237B = esi_173[0x00405000] ^ eax_135->b40237B ^ 0x5A;
				struct Eq_150 * esi_183 = esi_173 + 0x01;
				if (esi_183 == edi_113)
					esi_183 = null;
				eax_135->b40237C = esi_183[0x00405000] ^ eax_135->b40237C ^ 0x5A;
				struct Eq_150 * esi_193 = esi_183 + 0x01;
				if (esi_193 == edi_113)
					esi_193 = null;
				eax_135 = eax_135 + 0x01;
				eax_135->b402377 = esi_193[0x00405000] ^ eax_135->b40237D ^ 0x5A;
				esi_145 = esi_193 + 0x01;
			} while (eax_135 < (struct Eq_220 *) 0x1440);
			*(esp_53 - 0x0C) = 4202744;
			*(esp_53 - 0x08) = 0x00;
			struct Eq_343 * esi_210 = &globals->t403678;
			word32 ebp_213 = 4202744;
			uint32 ecx_221 = 0x00;
			do
			{
				Eq_351 eax_229 = esi_210->t0004;
				word16 * edx_235 = (char *) &esi_210->t0004 + 0x04;
				if (eax_229 - 0x08 >> 0x01 > 0x00)
				{
					uint32 ebx_384 = eax_229 - 0x08 >> 0x01;
					do
					{
						ui32 eax_388 = (word32) *edx_235;
						if ((eax_388 & 0xF000) == 0x3000)
						{
							struct Eq_377 * eax_402 = (eax_388 & 0x0FFF) + esi_210->dw0000;
							eax_402->dw4020F8 = eax_402->dw4020F8 + 0xF04020F8;
						}
						edx_235 = edx_235 + 0x01;
						ebx_384 = ebx_384 - 0x01;
					} while (ebx_384 != 0x00);
					ecx_221 = *(esp_53 - 0x08);
				}
				ecx_221 = (word32) esi_210->t0004 + ecx_221;
				*(esp_53 - 0x08) = ecx_221;
				esi_210 = esi_210 + Mem245[esi_210 + 0x04:word32];
			} while (ecx_221 < 232);
			*(esp_53 - 0x08) = 0x00402E6C;
			struct Eq_407 * edi_250 = &globals->t402E6C;
			if (globals->dw402E7C != 0x00)
			{
				edi_276 = edi_250;
				ebp_277 = ebp_213;
				do
				{
					struct Eq_407 * edi_276;
					word32 ebp_277;
					*(esp_53 - 0x24) = edi_276->dw000C + ebp_277;
					Eq_85 eax_286 = LoadLibraryA(*(esp_53 - 0x24));
					*(esp_53 - 0x04) = (HMODULE *) eax_286;
					Eq_85 ecx_288 = eax_286;
					if (eax_286 != null)
					{
						word32 eax_311 = edi_276->dw0000;
						if (eax_311 == 0x00)
							eax_311 = edi_276->dw0010;
						word32 * ebp_316 = ebp_277 + eax_311;
						int32 eax_319 = *ebp_316;
						word32 * edi_320 = edi_276->dw0010 + *(esp_53 - 0x0C);
						if (eax_319 != 0x00)
						{
							while (true)
							{
								Eq_91 eax_354;
								if (eax_319 < 0x00)
								{
									*(esp_53 - 0x24) = (word32) *ebp_316;
									*(esp_53 - 0x28) = (HMODULE *) ecx_288;
									eax_354 = GetProcAddress(*(esp_53 - 0x28), *(esp_53 - 0x24));
								}
								else
								{
									*(esp_53 - 0x24) = eax_319 + 0x02 + *(esp_53 - 0x0C);
									*(esp_53 - 0x28) = (HMODULE *) ecx_288;
									eax_354 = GetProcAddress(*(esp_53 - 0x28), *(esp_53 - 0x24));
								}
								*edi_320 = (word32) eax_354;
								ebp_316 = ebp_316 + 0x01;
								eax_319 = *ebp_316;
								edi_320 = edi_320 + 0x01;
								if (eax_319 == 0x00)
									break;
								ecx_288 = (Eq_85) *(esp_53 - 0x04);
							}
						}
						ebp_277 = *(esp_53 - 0x0C);
						edi_276 = (struct Eq_407 *) *(esp_53 - 0x08);
					}
					edi_276 = edi_276 + 0x01;
					*(esp_53 - 0x08) = (struct Eq_407 **) edi_276;
				} while (edi_276->dw0010 != 0x00);
			}
			ptr32 esp_257;
			byte SCZO_258;
			word32 esi_259;
			byte SZO_260;
			byte C_261;
			word32 eax_262;
			byte Z_263;
			word32 ebx_264;
			word32 ebp_265;
			word32 edi_266;
			byte cl_267;
			byte dl_268;
			word32 edx_269;
			word32 ecx_270;
			byte S_271;
			globals->t402B58();
			*(esp_257 - 0x04) = 0x00;
			ExitProcess(*(esp_257 - 0x04));
		}
	}
	return 0x00;
}

