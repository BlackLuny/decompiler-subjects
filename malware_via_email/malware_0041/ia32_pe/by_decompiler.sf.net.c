// subject.c
// Generated on TIMESTAMP by decompiling malware_via_email/malware_0041/ia32_pe/subject.exe
// using Decompiler version VERSION

#include "subject.h"

void fn00401000(word32 ebx)
{
	word32 * ecx_15;
	Eq_101 * edx_16;
	word32 ebp_17;
	word32 eax_18 = fn00401078(out ecx_15, out edx_16, out ebp_17);
	fp->tFFFFFFEE.u0 = globals->dw404400;
	fp->tFFFFFFEE.u0 = 0x00402000;
	fn0040112A(eax_18, ecx_15, edx_16, ebx, ebp_17);
	fp->tFFFFFFEE.u0 = 0x0000062E;
	fp->tFFFFFFEE.u0 = 0x0040112A;
	word32 ecx_38;
	word32 edx_39;
	word32 ebp_40;
	fn00401078(out ecx_38, out edx_39, out ebp_40);
	if (false)
	{
		fp->tFFFFFFEE.u0 = 0x00405000;
		fp->tFFFFFFEE.u0 = 0x00401000;
		lstrcpyA(fp->tFFFFFFEE, fp->tFFFFFFEE);
	}
	return;
}

word32 fn00401078(word32 * ecxOut, word32 * edxOut, word32 * ebpOut)
{
	word32 ecx_9;
	word32 edx_10;
	word32 ebp_11;
	return fn004010FD(fp - 0x00000004, out ecx_9, out edx_10, out ebp_11);
}

Eq_101 * fn004010F0(Eq_101 * edx, Eq_75 * ebp, Eq_101 * * ecxOut, Eq_101 * * edxOut, Eq_323 * * ebpOut)
{
	esp = fp;
	eax = Mem0[ebp - 0x00000004:word32];
	eax = eax + Mem0[ebp + 0x00000008:word32];
	al = Mem0[eax + 0x00000000:byte];
	eax = DPB(eax, al, 0, 8);
	eax = eax - 0x0000004D;
	al = (byte) eax;
	SCZO = cond(eax);
	Mem0[edx + 0x00000000:byte] = al;
	eax = fn004010FD(ebp, out ecx, out edx, out ebp);
	al = (byte) eax;
	return eax;
}

Eq_101 * fn004010FD(Eq_75 * ebp, word32 * ecxOut, Eq_101 * * edxOut, Eq_78 * * ebpOut)
{
	do
	{
		eax = Mem0[ebp - 0x00000004:word32];
		eax = eax & 0x00000001;
		SZO = cond(eax & eax);
		Z = SZO;
		C = false;
		if (Test(EQ,Z))
		{
			eax = Mem0[ebp - 0x00000004:word32];
			ecx = ebp->ptr0008;
			ecx = ecx + eax;
			eax = Mem0[ebp - 0x00000004:word32];
			eax = eax + Mem0[ebp + 0x00000008:word32];
			edx = Mem0[ebp - 0x00000004:word32];
			dl = (byte) edx;
			al = Mem0[eax + 0x00000000:byte];
			al = al - dl;
			SCZO = cond(al);
			Mem0[ecx + 0x00000000:byte] = al;
		}
		eax = ebp - 0x00000004;
		v12 = Mem0[eax + 0x00000000:word32] + 0x00000001;
		Mem0[eax + 0x00000000:word32] = v12;
		SZO = cond(v12);
		eax = Mem0[ebp - 0x00000004:word32];
		al = (byte) eax;
		SCZO = cond(eax - ebp->dw000C);
		SO = SCZO;
		if (Test(GE,SO))
		{
			esp = ebp;
			ebp = esp->ptr0000;
			esp = esp + 0x00000004;
			return eax;
		}
		SCZO = cond(ebp->t0004 - 0x00000001);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x00000004:word32];
			edx = ebp->ptr0008;
			edx = edx + eax;
			dl = (byte) edx;
			eax = Mem0[ebp - 0x00000004:word32];
			eax = eax + Mem0[ebp + 0x00000008:word32];
			al = Mem0[eax + 0x00000000:byte];
			eax = DPB(eax, al, 0, 8);
			eax = eax ^ 0x00000035;
			al = (byte) eax;
			SZO = cond(eax);
			C = false;
			Mem0[edx + 0x00000000:byte] = al;
		}
		SCZO = cond(ebp->t0004 - 0x00000002);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x00000004:word32];
			eax = eax - 0x00000002;
			eax = eax & 0x00000001;
			SZO = cond(eax & eax);
			Z = SZO;
			C = false;
			if (Test(EQ,Z))
			{
				eax = Mem0[ebp - 0x00000004:word32];
				ecx = ebp->ptr0008;
				ecx = ecx + eax;
				eax = Mem0[ebp - 0x00000004:word32];
				edx = ebp->ptr0008;
				edx = edx + eax;
				dl = (byte) edx;
				al.u0 = 0xE2;
				al = 0xE2 + Mem0[edx + 0x00000000:byte];
				SCZO = cond(al);
				Mem0[ecx + 0x00000000:byte] = al;
			}
		}
		SCZO = cond(ebp->t0004 - 0x00000002);
		SZO = SCZO;
		if (Test(LE,SZO))
			continue;
		eax = Mem0[ebp - 0x00000004:word32];
		eax = eax - 0x00000002;
		eax = eax & 0x00000001;
		SZO = cond(eax & eax);
		Z = SZO;
		C = false;
	} while (Test(NE,Z));
	eax = Mem0[ebp - 0x00000004:word32];
	edx = ebp->ptr0008;
	edx = edx + eax;
	dl = (byte) edx;
	SCZO = cond(edx);
	eax = fn004010F0(edx, ebp, out ecx, out edx, out ebp);
	al = (byte) eax;
	return eax;
}

void fn0040112A(word32 eax, word32 * ecx, Eq_101 * edx, word32 ebx, word32 ebp)
{
	*ecx = 0xDC4B4A4D;
	Eq_333 * eax_9 = DPB(eax, 0x6E, 8, 8);
	eax_9->dw0035 = eax_9->dw0035 ^ ecx;
	if (!OVERFLOW(eax_9->dw0035))
		return;
	else
	{
		word32 ecx_27;
		word32 edx_28;
		word32 ebp_29;
		fn004010F0(edx, (Eq_75 *) 0xB6463542, out ecx_27, out edx_28, out ebp_29);
		return;
	}
}

