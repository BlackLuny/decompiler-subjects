// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004038B8: Register (ptr uint32) HKrXZROZ_Mf_noYJLG(Stack uint32 dwArg04, Stack real32 rArg08)
uint32 * HKrXZROZ_Mf_noYJLG(uint32 dwArg04, real32 rArg08)
{
	uint32 ecx_19 = (byte) (globals->ptr40AB16 < eax) + ((word32) globals->t40ABD6 + globals->dw40AB76);
	globals->dw40AB76 = ecx_19;
	ui32 * edi_22 = globals->ptr40AD02;
	*edi_22 = *edi_22 | globals->t40ABA2;
	globals->dw40AB56 = globals->dw40AB56 - *globals->ptr40AC6E - (ebx < ecx_19);
	return eax;
}

// 00403900: void _riGFEGY_WGXY_qbsOD_(Stack char bArg04)
void _riGFEGY_WGXY_qbsOD_(char bArg04)
{
	globals->dw40AB9E = (word32) ((byte) (globals->t40AAF6 < edi) + ((word32) globals->t40AB6E + globals->dw40AB9E));
	ui32 * ebx_19 = globals->ptr40AD52;
	*ebx_19 = *ebx_19 & globals->dw40AB32;
	word32 * edi_23 = globals->ptr40ACC2;
	*edi_23 = *edi_23 - globals->dw40AB6A;
	return;
}

// 00403940: Register (ptr void) JVPFYysga_h(Stack int32 dwArg04, Stack (ptr real32) ptrArg08)
void(int32 dwArg04, real32 * ptrArg08)
{
	globals->t40AAF2 = globals->t40AAF2 ^ *globals->ptr40AD32;
	globals->dw40ABBA = globals->dw40ABBA & (word32) globals->t40ABDA;
	ui32 * ecx_22 = globals->ptr40AC7A;
	*ecx_22 = *ecx_22 | globals->dw40ABDE;
	return eax;
}

// 00403981: Register uint16 Q_B_GTvmg_bvsmX(Stack uint32 dwArg04)
uint16 Q_B_GTvmg_bvsmX(uint32 dwArg04)
{
	globals->dw40AB66 = globals->dw40AB66 + globals->dw40AB72;
	globals->t40AB12 = globals->t40AB12 ^ *globals->ptr40AD02;
	globals->t40AB46 = (word32) globals->t40AB46 & *globals->ptr40ACF2;
	return ax;
}

// 004039FA: Register word32 fn004039FA(Register Eq_50 edx, Register (ptr word32) ebx, Stack (ptr Eq_148) dwArg04, Stack byte bArg07, Stack word32 dwArg08)
word32 fn004039FA(Eq_50 edx, word32 * ebx, Eq_148 * dwArg04, byte bArg07, word32 dwArg08)
{
	ptr32 esp_149 = fp - 0x5C;
	ui32 dwLoc14_117 = 0x1B;
	while (dwLoc14_117 != 0x00)
	{
		if (dwLoc14_117 == 0x1D)
		{
			CreatePropertySheetPageA((PROPSHEETPAGEA_V4 *) 23155);
			esp_149 = fp - 0x5C;
		}
		dwLoc14_117 = dwLoc14_117 - 0x01;
	}
	ptr32 esp_114;
	word32 eax_125;
	if (true)
	{
		union Eq_233 * esi_208 = globals->ptr40ACDA;
		word32 ecx_197 = globals->dw40A0F0;
		*esi_208 = (union Eq_233 *) ((char *) *esi_208 + 44);
		esp_114 = fp - 100;
		if (0x01 == ecx_197 || 0x00 == *dwArg04->ptr0038)
		{
			eax_125 = ~0x101E;
			goto l00403C0D;
		}
		struct Eq_148 * ecx_242 = globals->ptr40A2D8;
		edx = *ecx_242->ptr0008;
		dwLoc14_117 = dwLoc14_117 & dwLoc18;
		word32 eax_251 = Mem210[Mem210[edx + 0x3C:word32] + 0x28 + edx:word32] + edx;
		if (ecx_242->dw0040 != 0x00)
		{
			struct Eq_291 * edx_291 = globals->ptr40A310;
			edx_291->t0000 = (<anonymous>) 233;
			struct Eq_291 * ecx_298 = globals->ptr40A310;
			ecx_298->dw0001 = eax_251 - ~0x2529 - ecx_298 - 0x252F;
			word32 ebp_320;
			byte SCZO_321;
			word32 eax_322;
			word32 ecx_323;
			byte Z_324;
			byte CZ_325;
			word32 esi_326;
			word32 edi_327;
			byte SZO_328;
			byte C_329;
			byte cl_331;
			word32 ebx_332;
			globals->ptr40A310();
			*dwArg08 = eax_322;
		}
		globals->dw40AB56 = globals->dw40AB56 ^ dwLoc3C;
		globals->t40A100 = null;
		globals->dw40AB0E = globals->dw40AB0E & 0x00;
l00403B8B:
		globals->dw40AB0E = globals->dw40AB0E + 0x01;
		if (globals->dw40AB0E != 0x2A)
		{
l00403BC8:
			if (globals->dw40AB0E >= 0x1C)
			{
				globals->dw40A104 = 0x00;
				eax_125 = ~0x101D;
l00403C0D:
				globals->dw40AB72 = globals->dw40AB72 - 4238242 - (edx < globals->t40AAF6);
				globals->dw40AB72 = globals->dw40AB72 ^ 0x0040AB12;
				return (eax_125 ^ 0x3530) + 0x252F;
			}
			goto l00403B8B;
		}
		word32 * esp_188 = esp_114 - 0x04;
		*esp_188 = 0x2920;
		*(esp_188 - 0x04) = 0x3A69;
		*(esp_188 - 0x08) = 0x72870000;
		*(esp_188 - 0x0C) = 0x75A5;
		esp_149 = esp_188 - 0x0C;
	}
	struct Eq_171 * esp_152 = esp_149 - 0x04;
	esp_152->t0000.u0 = 0x2454;
	*(esp_152 - 0x04) = 33958;
	*(esp_152 - 0x08) = dwLoc14_117;
	SetDIBits(*(esp_152 - 0x08), *(esp_152 - 0x04), esp_152->t0000, esp_152->t0004, esp_152->ptr0008, esp_152->ptr000C, esp_152->t0010);
	esp_114 = (char *) &esp_152->t0010 + 0x04;
	goto l00403BC8;
}

// 00403C31: Register (ptr ui32) fn00403C31(Stack ptr32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
ui32 * fn00403C31(ptr32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	globals->dw40AB42 = 22;
	Eq_399 eax_123 = ~0x101E;
	while (globals->dw40AB42 != 0x00)
	{
		if (globals->dw40AB42 == 0x26)
			eax_123 = SystemParametersInfoW(23276, 6300, dwLoc2C, 30379);
		globals->dw40AB42 = globals->dw40AB42 - 0x01;
	}
	if (false)
	{
		union Eq_428 * ecx_172 = globals->ptr40AC9A;
		*ecx_172 = (union Eq_428 *) ((char *) *ecx_172 + 66);
	}
	do
	{
		word32 edx_79 = 0x0040A0D4[(eax_123 + 0x01 & 0x03) * 0x04];
		int32 edi_81 = *edx_79 *s eax_123;
		globals->dw40ABBA = globals->dw40ABBA + 0x0040AB0E;
		globals->dw40ABBA = globals->dw40ABBA ^ 4238118;
		globals->dw40ABBA = globals->dw40ABBA + 0x0040AAFA;
		*edx_79 = edi_81 *s ~0x201B;
		globals->t40ABA2 = globals->t40ABA2 & 0x0040AB5E;
		globals->t40ABA2 = (word32) globals->t40ABA2 + 4238230;
		globals->t40ABA2 = (word32) globals->t40ABA2 + 4238114;
		ui32 * edx_103 = *((char *) globals->a40A0D4 + (eax_123 - 0x01 & 0x03) * 0x04);
		*edx_103 = *edx_103 ^ (eax_123 *s ~0x201C | eax_123);
		globals->dw40A304 = dwArg04;
		if (eax_123 == ~0x11DE)
			globals->ptr40A308 = dwArg08;
		else if (eax_123 == ~0x119E)
			globals->dw40A30C = dwArg0C;
		globals->dw40AB56 = globals->dw40AB56 + 0x2272;
		eax_123 = (eax_123 ^ 0x3530) + 0x01 ^ 0x3530;
		word32 * edx_136 = *((char *) globals->a40A0D4 + (eax_123 & 0x03) * 0x04);
		*edx_136 = *edx_136 + (eax_123 *s ~0x201D ^ eax_123);
		ui32 * edx_144 = *((char *) globals->a40A0D4 + (eax_123 - 0x02 & 0x03) * 0x04);
		*edx_144 = *edx_144 | eax_123 *s ~0x201A;
	} while (eax_123 != ~0x112E);
	return edx_144;
}

// 00403E03: void fn00403E03(Register (ptr Eq_568) eax)
void fn00403E03(Eq_568 * eax)
{
	globals->ptr40A554 = (word32 *) ((char *) &eax->t0000 + 0x04);
	globals->t40A548 = eax->t0008;
	globals->t40A54C = eax->t000C;
	globals->t40A550 = eax->t0010;
	return;
}

// 00403E27: Register Eq_575 fn00403E27(Register ptr32 ebp, Register (ptr Eq_590) esi, Register Eq_575 edi)
Eq_575 fn00403E27(ptr32 ebp, Eq_590 * esi, Eq_575 edi)
{
	esi->t0000.u0 = 0x01;
	InterlockedExchange(&globals->t40A2EC, 0x00760677);
	if (esi->t0000 == edi)
		return ecx;
l00403E46:
	ecx = esi->t0000;
	if (ecx < edi)
	{
		if (ecx != 0x00)
		{
			globals->dw40AB22 = globals->dw40AB22 & 0x00;
			do
			{
				globals->dw40AB22 = globals->dw40AB22 + 0x01;
				if (globals->dw40AB22 == 0x24)
					CreateStatusWindowW(0x4558, &globals->t40AF0F, (struct HWND__ *) 6888, *(ebp - 0x0C));
			} while (globals->dw40AB22 < 0x1E);
			esi->t0000 = (word32) ecx + ((uint32) ((uint64) ((uint32) edi) /u 0x0101) + 0x01);
l00403EE4:
			if (esi->t0000 != edi)
				goto l00403E46;
			return ecx;
		}
	}
	else if (ecx != 0x00)
	{
		esi->t0000 = ecx - 0x01;
		ecx = ecx - 0x01;
		goto l00403EE4;
	}
	esi->t0000 = edi;
	esi->t0000 = edi;
	goto l00403EE4;
}

// 00403EEE: Register word32 fn00403EEE(Register word32 edi)
word32 fn00403EEE(word32 edi)
{
	Eq_399 eax_11 = globals->t40A080;
	globals->dw40AB0A = globals->dw40AB0A & 0x00;
	while (globals->dw40AB0A < 0x14)
	{
		if (globals->dw40AB0A == 0x18)
			eax_11 = DestroyCaret();
		globals->dw40AB0A = globals->dw40AB0A + 0x01;
	}
	byte eax_32[] = *eax_11;
	if (~0x2C01 != 0x00)
	{
		dwLoc0C = eax_32;
		eax_32 = (byte (*)[]) *globals->ptr40A084;
	}
	Mem44[0x0040AAF6:word32] = Mem13[0x0040AAF6:word32] + Mem13[Mem13[0x0040ACA6:word32] + 0x00:word32];
	globals->ptr40A2F0 = dwLoc0C;
	globals->t40A2F4 = eax_32 + (0x04 - globals->ptr40A2F0);
	word32 eax_77 = ~0x101D;
	if (globals->ptr40A2F0 == null)
	{
		globals->t40ABDA = -globals->t40ABDA;
		eax_77 = ~0x101E;
	}
	return (eax_77 ^ 0x3530) + 0x252F;
}

// 00404004: void fn00404004()
void fn00404004()
{
	if (true)
		globals->dw40AB2A = globals->dw40AB2A | (word32) bLoc2C;
	globals->dw40ABD2 = globals->dw40ABD2 & 0x00;
	while (globals->dw40ABD2 < 0x19)
	{
		if (globals->dw40ABD2 == 0x23)
			FormatMessageA(0x48BC, dwLoc24, 0x2D2B, dwLoc2C, &globals->dw40ABA6, dwLoc1C, dwLoc1C);
		globals->dw40ABD2 = globals->dw40ABD2 + 0x01;
	}
	globals->dw40ABBE = globals->dw40ABBE - 4238242;
	globals->dw40ABBE = globals->dw40ABBE ^ 4238238;
	globals->dw40ABBE = globals->dw40ABBE - 0x0040AAF2;
	if (false)
		globals->dw40AB8E = globals->dw40AB8E & 0x3962;
	globals->t40AB12.u1 = 0x0040AB8A;
	globals->t40AB12 = globals->t40AB12 & 4238262;
	globals->t40AB12 = globals->t40AB12 - 4238286;
	word32 esp_154;
	word32 ebp_155;
	byte SCZO_156;
	word32 edx_157;
	byte CZ_158;
	word32 eax_159;
	word32 ecx_160;
	byte SZO_161;
	byte C_162;
	byte Z_163;
	globals->ptr40A580();
	return;
}

// 0040419E: Register (ptr word16) fn0040419E()
word16 * fn0040419E()
{
	globals->dw40AB86 = 0x1C;
	while (globals->dw40AB86 != 0x00)
	{
		if (globals->dw40AB86 == 0x1E)
			GetClipBox((struct HDC__ *) 0x30CE, &globals->dw40AB56);
		globals->dw40AB86 = globals->dw40AB86 - 0x01;
	}
	byte * edx_63 = globals->ptr40ACE6;
	*edx_63 = *edx_63 + 99;
	globals->dw40AB8E = globals->dw40AB8E & dwLoc44;
	ui32 eax_88 = 0x01 << bLoc0C << bLoc0C << bLoc0C << bLoc0C;
	ui32 *** eax_90 = globals->ptr40A040;
	word16 * eax_109 = ~(eax_88 - 0x01) & *(*(*eax_90));
	if (false)
	{
		int8 * ecx_169 = globals->ptr40AD3A;
		*ecx_169 = *ecx_169 >> 0x09;
	}
	globals->t40AAF6.u0 = 0x0040AB1A;
	globals->t40AAF6 = globals->t40AAF6 & 0x0040ABD2;
	word16 * dwLoc10_116 = eax_109;
	word16 ax_126 = *eax_109 - 0x022F;
	while ((ax_126 ^ 0x0330) != 23342)
	{
		globals->t40AB46 = (word32) globals->t40AB46 - 0x15D5;
		word16 * v28_150 = dwLoc10_116 - eax_88;
		dwLoc10_116 = v28_150;
		ax_126 = *v28_150 - 0x022F;
	}
	return dwLoc10_116;
}

// 00404365: void fn00404365(Stack word32 dwArg04, Stack Eq_959 dwArg08)
void fn00404365(word32 dwArg04, WPARAM dwArg08)
{
	Eq_960 eax_10 = dwArg04->t40A49C;
	uint32 dwLoc58_14 = dwLoc58 & 0x00;
	while (dwLoc58_14 < 0x12)
	{
		if (dwLoc58_14 == 0x1E)
			eax_10 = PropertySheetA(dwLoc28);
		dwLoc58_14 = dwLoc58_14 + 0x01;
	}
	if (false)
	{
		union Eq_1063 * ecx_431 = globals->ptr40ACBA;
		*ecx_431 = (union Eq_1063 *) (*ecx_431 - 0x317E);
	}
	union Eq_984 * edx_91 = globals->ptr40AD56;
	*edx_91 = (union Eq_984 *) (*edx_91 ^ 0x1116);
	globals->a40A340[((eax_10 ^ 0x3530) + 0x252F) * 0x02] = 0x00;
	word32 * eax_102 = globals->ptr40AD16;
	*eax_102 = *eax_102 + dwLocD8;
	byte * ebx_113 = globals->ptr40AD1A;
	*ebx_113 = *ebx_113 + 118;
	globals->dw40AB4E = globals->dw40AB4E & dwLoc90;
	globals->t40AB52.u1 = (byte) (0x3530 < globals->dw40AB2E) + ((word32) globals->t40AB52 + 0x0040AB0A);
	globals->t40AB52 = globals->t40AB52 & 4238202;
	globals->dw40AAEE = globals->dw40AAEE | (word32) bLocB4;
	globals->dw40AB3A = globals->dw40AB3A ^ dwLoc74;
	globals->dw40AB6A = globals->dw40AB6A & 0x00;
	while (globals->dw40AB6A < 0x11)
	{
		if (globals->dw40AB6A == 0x18)
			ImageList_AddMasked(dwLoc14, dwLoc18, dwLoc1C);
		globals->dw40AB6A = globals->dw40AB6A + 0x01;
	}
	if (0x00 != 0x00)
	{
		union Eq_1136 * edx_405 = globals->ptr40ACFE;
		*edx_405 = (union Eq_1136 *) ((char *) *edx_405 + 0x0036);
		union Eq_428 * edx_408 = globals->ptr40AC9A;
		*edx_408 = (union Eq_428 *) (*edx_408 - globals->t40AAF6);
		word32 * edx_414 = globals->ptr40AD66;
		*edx_414 = *edx_414 + dwLocB0;
	}
	ui32 * eax_275 = globals->ptr40AD62;
	*eax_275 = *eax_275 | 31545;
	word32 ecx_311;
	word32 edx_312;
	fn0040672B(globals->dw40A584, *globals->ptr40A2D8->ptr000C, fp - 0x30, 0x03, out ecx_311, out edx_312);
	if (fp <= 0x686E)
		globals->dw40ABB6 = globals->dw40ABB6 - (word32) globals->t40ABA2 - (fp < 0x686E);
	byte * eax_326 = globals->ptr40AC6A;
	*eax_326 = *eax_326 | 0x19;
	word32 ecx_339;
	word32 edx_340;
	word32 eax_341 = fn0040672B(globals->dw40A584, *globals->ptr40A2D8->ptr000C, fp - 0x54, 0x01, out ecx_339, out edx_340);
	globals->t40ABDA.u2 = 4238238;
	globals->t40ABDA.u1 = (byte) (globals->ptr40AB4A < dwArg08) + ((word32) globals->t40ABDA + 4238182);
	if (eax_341 != ((dwArg08[1059111] ^ 0x3530) + 0x4A5E) + (dwArg04->t40A49C ^ 0x3530))
	{
		globals->t40A4D8->t0000.u0 = 0x00;
		*globals->ptr40A2D8->ptr000C = (uint32) 0x00;
	}
	return;
}

// 004047C6: void fn004047C6()
void fn004047C6()
{
	globals->t40ABDA = globals->t40ABDA & 0x00;
	do
	{
		globals->t40ABDA = (word32) globals->t40ABDA + 0x01;
		if (globals->t40ABDA == 0x23)
			CreateHatchBrush(dwLoc2C, dwLoc14);
	} while (globals->t40ABDA < 0x1D);
	bool C_366 = cond(~0x051E);
	if (true)
	{
		globals->t40AB96 = globals->t40AB96 & 0xDF90;
		C_366 = false;
	}
	__rcr(dwLoc94, 0x01, C_366);
	byte * edi_59 = globals->ptr40ACCE;
	*edi_59 = *edi_59 | 0x53;
	if (fn00403EEE(0x252F) == 0x00)
		return;
	fn00404004();
	Eq_399 ecx_132 = globals->t40A2F4;
	globals->dw40AB42 = globals->dw40AB42 - dwLoc84;
	byte eax_140[] = globals->ptr40A2F0;
	ui32 dwLoc14_156 = 4294957777;
	int32 edx_157 = 0x00;
	if (0x00 == ecx_132)
		return;
l004048F6:
	byte bl_268;
	int32 ecx_203;
	byte cl_187 = eax_140[edx_157 * 0x01];
	byte bLoc05_188 = cl_187;
	int32 ebx_190 = 0x01;
	if (false)
	{
		globals->dw40AB6A = globals->dw40AB6A | 4238222;
		word32 ecx_288 = (word32) cl_187;
		bl_268 = (byte) ((word32) (byte) (DPB(ecx_288, ((byte) ecx_288 ^ 0x60) + 0x32, 0) + (word32) cl_187) - (word32) eax_140[edx_157 * 0x01]);
	}
	else
	{
		dwLoc44 = dwLoc44 & 0x00;
		do
		{
			uint32 ecx_321 = dwLoc44 + 0x01;
			dwLoc44 = ecx_321;
			if (ecx_321 == 22)
				eax_140 = SetWindowRgn((struct HWND__ *) 0x3B44, (struct HRGN__ *) 0x7CDD, ecx_132);
		} while (ecx_321 < 0x10);
		ecx_203 = ~0x11CF;
		if (false)
		{
l004049FA:
			byte bl_207 = eax_140[ebx_190];
			eax_140[ecx_203] = eax_140[ecx_203] ^ bl_207;
			globals->t40AB52.u1 = (byte) (globals->t40ABD6 < DPB(ebx_190, bl_207, 0)) + ((word32) globals->t40AB52 + *globals->ptr40ACAA);
			int32 ecx_221 = edx_157 *s 0x01;
			eax_140[ecx_221] = eax_140[ecx_221] + 0x01;
			globals->t40AB6E = globals->t40AB6E | 0x0040AB0E;
			globals->t40AB6E = (word32) globals->t40AB6E + 4238182;
			globals->t40AB6E = (word32) globals->t40AB6E + 4238178;
			int32 ecx_239 = edx_157 *s 0x01;
			eax_140[ecx_239] = eax_140[ecx_239] + bLoc05_188;
			int32 ecx_245 = edx_157 *s 0x01;
			eax_140[ecx_245] = eax_140[ecx_245] - 0x01;
			ui32 edx_257 = dwLoc14_156 + 0x01 ^ 0x3530 ^ 0x3530;
			dwLoc14_156 = edx_257;
			edx_157 = edx_257 + 0x252F;
			if (edx_257 + 0x252F != ecx_132)
				goto l004048F6;
			return;
		}
		bl_268 = __ror((byte) ((word32) cl_187 - 0x2F), 0x01);
	}
	globals->dw40AB1A = globals->dw40AB1A | 0x0040AB16;
	bLoc05_188 = bl_268;
	ecx_203 = edx_157 *s 0x01;
	ebx_190 = edx_157 *s 0x01;
	goto l004049FA;
}

// 00404AB9: Register Eq_1476 fn00404AB9(Register Eq_1476 ecx, Register Eq_959 edi, Register out ptr32 edxOut, Register out ptr32 ediOut)
Eq_1476 fn00404AB9(Eq_1476 ecx, WPARAM edi, ptr32 & edxOut, ptr32 & ediOut)
{
	struct Eq_1480 * edx_11;
	*edxOut = 0x05;
	word32 * esp_12 = fp - 0x08;
	if (globals->dw40A090 == 0x00)
	{
		globals->dw40ABCE = globals->dw40ABCE & 0x00;
		while (globals->dw40ABCE < 0x12)
		{
			if (globals->dw40ABCE == 0x14)
			{
				CreateHalftonePalette(dwLoc20);
				esp_12 = fp - 0x08;
			}
			globals->dw40ABCE = globals->dw40ABCE + 0x01;
		}
		edx_11[0x0040A4D7] = (struct Eq_1480) ((edx_11[0x0040A4D7] ^ 0x60) + 0x32);
		edx_11 = edx_11 + 0x01;
		*edxOut = edx_11;
		if (edx_11 < (struct Eq_1480 *) 0x14)
			goto l00404AC0;
	}
	bool Z_201 = cond(775);
	if (true)
	{
		esp_12 = fp - 0x18;
		edi = 0x00;
		if (*globals->ptr40A2D8->ptr000C == 0x00)
		{
			fn0040419E();
			edi = fn0040419E();
		}
		ecx.u0 = ~0x101E;
		*edxOut = 0x3530;
l00404B6F:
		ui32 ecx_165 = ecx ^ edx_11;
		struct Eq_1559 * eax_166 = ecx_165 + 0x4A5E + ecx_165;
		ui16 ax_170 = eax_166->w40A4BC ^ 0x0330;
		globals->dw40AB6A = globals->dw40AB6A + *globals->ptr40AC82;
		if (!OVERFLOW(dwLoc4C - 0x1EA6))
			Mem207[4238238:word32] = Mem175[4238238:word32] + Mem175[0x0040AB4A:word32] + (dwLoc4C <u 0x1EA6);
		else
		{
			union Eq_1063 * esi_208 = globals->ptr40ACBA;
			*esi_208 = (union Eq_1063 *) (*esi_208 | 0x7B);
		}
		globals->dw40ABA6 = globals->dw40ABA6 & dwLoc38;
		eax_166->w40A4C4 = (word16) (word32) (ax_170 + 0x022F);
		ecx = ecx_165 + 0x01 ^ edx_11;
		Z_201 = cond(ecx - ~0x101B);
	}
	if (!Z_201)
	{
		if (edi != 0x00)
		{
			union Eq_1476 * esp_100 = esp_12 - 0x04;
			*esp_100 = 0x09;
			ecx = *esp_100;
			Eq_1658 (* edx_112)[] = 0x0040A520 - ecx;
			*edxOut = edx_112;
			Eq_1679 (* esi_113)[] = 0x0040A640 - ecx;
			do
			{
				byte al_117 = Mem101[edx_112 + ecx:byte];
				globals->dw40AAFA = globals->dw40AAFA | 4238226;
				globals->dw40AAFA = globals->dw40AAFA + 0x0040AB1E;
				globals->dw40AAFA = globals->dw40AAFA ^ 0x0040ABB2;
				Mem129[esi_113 + ecx:byte] = (al_117 ^ 0x60) + 0x32;
				ecx = ecx - 0x01;
			} while (ecx != 0x00);
			*globals->ptr40A2D8->ptr000C = (uint32) edi;
		}
		word32 edi_92;
		*ediOut = *esp_12;
		return ecx;
	}
	goto l00404B6F;
}

// 00404C90: Register Eq_1694 fn00404C90(Register ptr32 ebp, Register (ptr Eq_575) esi, Register Eq_575 edi, Stack word32 dwArg00, Register out ptr32 ebxOut)
LONG fn00404C90(ptr32 ebp, Eq_575 * esi, Eq_575 edi, word32 dwArg00, ptr32 & ebxOut)
{
	do
	{
		*esi = 0x01;
		if (edi != 0x01)
		{
			do
			{
				Eq_575 ecx_80 = *esi;
				if (ecx_80 > edi)
					*esi = (union Eq_575 *) (ecx_80 - 0x01);
				else if (ecx_80 == 0x00)
					*esi = (union Eq_575 *) edi;
				else
				{
					globals->dw40ABBA = 0x11;
					while (globals->dw40ABBA != 0x00)
					{
						if (globals->dw40ABBA == 0x19)
							DefWindowProcA(*(ebp - 0x14), *(ebp - 0x18), *(ebp - 0x0C), 0x6CA2);
						globals->dw40ABBA = globals->dw40ABBA - 0x01;
					}
					union Eq_710 * ebx_140 = globals->ptr40ACA6;
					*ebx_140 = (union Eq_710 *) (*ebx_140 >> 0x01);
					*esi = (word32) ecx_80 + ((uint32) ((uint64) ((uint32) edi) /u 0x0101) + 0x01);
				}
			} while (*esi != edi);
		}
		Eq_599 eax_55 = InterlockedExchangeAdd(&globals->t40A2EC, 0x00760677);
	} while (eax_55 + 0x00760677 != Mem29[0x0040A2EC:word32]);
	return eax_55 + 0x00760677;
	word32 ebx_65;
	*ebxOut = dwArg00;
	return eax_55 + 0x00760677;
}

// 00404D4D: Register word32 fn00404D4D(Register Eq_283 ecx, Register (ptr word32) ebx, Stack Eq_174 dwArg00, Register out ptr32 ecxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out Eq_1820 ediOut)
word32 fn00404D4D(LRESULT ecx, word32 * ebx, Eq_174 dwArg00, ptr32 & ecxOut, ptr32 & ebxOut, ptr32 & esiOut, Eq_1820 & ediOut)
{
	uint32 dwLoc1C_25 = dwLoc1C & 0x00;
	while (dwLoc1C_25 < 0x1E)
	{
		if (dwLoc1C_25 == 0x26)
			CreateWaitableTimerW(dwLoc28, 0x00, &globals->t40AEBC);
		dwLoc1C_25 = dwLoc1C_25 + 0x01;
	}
	word32 dwLoc08_110;
	globals->dw40A0EC = globals->dw40A318;
	globals->dw40A0F0 = globals->dw40A31C;
	globals->dw40A0F4 = globals->dw40A320;
	word32 ebx_99;
	word32 esi_100;
	word32 edi_101;
	if (fn00404EEB(fn00403C31(fp - 0x08, *globals->ptr40A314, globals->dw40A2FC), ebx, fp - 0x04, out ebx_99, out esi_100, out edi_101) != 0x00)
	{
		globals->dw40A098 = globals->dw40A098 + 0x00677577;
		dwLoc08_110 = 0x00;
	}
	else
	{
		if (false)
		{
			word32 * ecx_169 = globals->ptr40ACE2;
			*ecx_169 = *ecx_169 - 22241;
			word32 * eax_173 = globals->ptr40AC82;
			*eax_173 = *eax_173 - 790448901;
		}
		struct Eq_148 * eax_156 = globals->ptr40A2D8;
		globals->t40AAF2 = (word32) globals->t40AAF2 - 0x01;
		word32 eax_162 = *eax_156->ptr003C;
		globals->dw40ABDE = ~globals->dw40ABDE;
		dwLoc08_110 = eax_162;
	}
	globals->ptr40A2F8 = fp;
	word32 * ecx_123 = globals->ptr40A2F8;
	*ecxOut = ecx_123;
	*ecx_123 = globals->t40A100 + dwArg00 / 0x04;
	return dwLoc08_110;
}

// 00404EEB: Register word32 fn00404EEB(Register Eq_50 edx, Register (ptr word32) ebx, Register Eq_630 ebp, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
word32 fn00404EEB(Eq_50 edx, word32 * ebx, HWND ebp, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 eax_8 = globals->dw40A304;
	globals->dw40AB42 = globals->dw40AB42 & 0x00;
	do
	{
		globals->dw40AB42 = globals->dw40AB42 + 0x01;
		if (globals->dw40AB42 == 0x20)
			CreateDCW(&globals->t40AEAC, &globals->t40AE94, &globals->t40AE85, (DEVMODEW *) 0x1DDC);
	} while (globals->dw40AB42 < 0x17);
	word32 eax_173 = globals->dw40A30C;
	word32 * esp_174 = fp - 0x54;
	if (true)
	{
		struct Eq_148 * v15_168 = globals->ptr40A2D8;
		ebx = globals->ptr40A308;
		dwLoc18 = eax_173;
		eax_173 = fn004039FA(edx, ebx, v15_168, SLICE(v15_168, byte, 24), eax_8);
		esp_174 = fp - 0x5C;
	}
	word32 eax_142;
	globals->t40AB6E = globals->t40AB6E ^ 0x0040AB5E;
	globals->t40AB6E = globals->t40AB6E - 0x0040AB22;
	word32 esi_116 = 0x252F;
	if (0x00 != eax_173)
		eax_142 = ~0x101D;
	else
	{
		word32 * esp_102 = esp_174 - 0x04;
		*esp_102 = 0x00031A16;
		*(esp_102 - 0x04) = dwLoc18;
		*(esp_102 - 0x08) = ebx;
		*(esp_102 - 0x0C) = (struct Eq_148 **) globals->ptr40A2D8;
		esi_116 = fn00405435(ebp, dwArg00, dwArg04, dwArg08, dwArg0C);
		globals->dw40ABD2 = globals->dw40ABD2 - globals->ptr40AB16;
		globals->ptr40A300 = fp;
		word32 * eax_124 = globals->ptr40A300;
		*eax_124 = globals->t40A100 + *eax_124 / 0x04;
		if (dwLoc3C >= 3155)
		{
			word32 * eax_152 = globals->ptr40ACCA;
			*eax_152 = *eax_152 - dwLoc30 - (dwLoc3C < 3155);
		}
		eax_142 = ~0x101E;
	}
	struct Eq_2080 * esp_87 = esp_174 + 0x01;
	word32 edi_86;
	*ediOut = *esp_174;
	word32 esi_90;
	*esiOut = esp_87->dw0000;
	word32 ebx_92;
	*ebxOut = esp_87->dw0004;
	return (eax_142 ^ 0x3530) + esi_116;
}

// 00405060: Register word32 fn00405060(Register Eq_1476 ecx, Register ui32 ebx, Register ptr32 ebp, Register Eq_959 edi, Register out ptr32 ecxOut)
word32 fn00405060(Eq_1476 ecx, ui32 ebx, ptr32 ebp, WPARAM edi, ptr32 & ecxOut)
{
	__align(fp - 0x04);
	struct Eq_2126 * esp_109 = fp - 0x44;
	word32 edx_24;
	word32 ecx_26;
	ui32 edi_102;
	*ecxOut = fn00404AB9(ecx, edi, out edx_24, out edi_102);
	uint32 dwLoc08_149 = dwLoc08 & 0x00;
	do
	{
		uint32 esi_104 = dwLoc08_149 + 0x01;
		dwLoc08_149 = esi_104;
		if (esi_104 == 0x26)
		{
			DestroyCursor((struct HICON__ *) 20602);
			esp_109 = fp - 0x44;
		}
	} while (esi_104 < 0x1F);
	word32 ecx_162;
	Eq_2157 dwLoc14_145 = (DWORD *) 0x0180;
	if (false)
	{
l0040534E:
		*ecxOut = ebx + 0x01 ^ esi_104;
		goto l00405353;
	}
	globals->t40ABE2 = (word32) globals->t40ABE2 | *globals->ptr40AD06;
	esi_104 = 0x3530;
	edi_102 = 0x252F;
l00405102:
	if (globals->dw40A090 != 0x00)
		goto l0040540C;
	struct Eq_148 * eax_488 = globals->ptr40A2D8;
	WPARAM * ecx_490 = eax_488->ptr000C;
	*ecxOut = ecx_490;
	if (*ecx_490 != 0x00)
	{
		word32 * esp_504 = esp_109 - 0x04;
		*esp_504 = 0x0040A524;
		*(esp_504 - 0x04) = 0x01;
		*(esp_504 - 0x08) = &eax_488->dw0040 + 0x04;
		*(esp_504 - 0x0C) = *ecx_490;
		*(esp_504 - 0x10) = globals->dw40A584;
		word32 ecx_518;
		word32 edx_519;
		globals->dw40A4EC = fn0040672B(dwArg00, dwArg04, dwArg08, dwArg0C, out ecx_518, out edx_519);
	}
	if (globals->dw40A4EC == 0x00)
	{
l004053B2:
		globals->t40ABD6.u0 = 0x1F;
		while (globals->t40ABD6 != 0x00)
		{
			if (globals->t40ABD6 == 0x2B)
			{
				LPDWORD * esp_129 = esp_109 - 0x04;
				*esp_129 = (LPDWORD *) dwLoc14_145;
				*(esp_129 - 0x04) = 0x0040ABAA;
				GetComputerNameW(*(esp_129 - 0x04), *esp_129);
			}
			globals->t40ABD6 = globals->t40ABD6 - 0x01;
		}
		ui32 eax_139 = (esp_109[0x03] ^ esi_104) + 0x01 ^ esi_104;
		esp_109[0x03] = (struct Eq_2126) eax_139;
		if (eax_139 == ~0x11EE)
		{
l0040540C:
			ui32 * esi_75 = globals->ptr40ACA2;
			*esi_75 = *esi_75 - 20124;
			return 0x01;
		}
		goto l00405102;
	}
	esp_109[0x05] = (struct Eq_2126) 0x00;
	*ecxOut = ~0x101E;
l00405353:
	Eq_2261 C_187;
	if (!P)
	{
		C_187.u0 = false;
		dwLoc0C = (word32) bLoc0C & (word32) globals->w40ABC6;
	}
	else
	{
		uint32 eax_461 = dwLoc08_149 - globals->dw40AB9A - (dwLoc0C < 0x4FCF);
		C_187 = cond(eax_461);
		dwLoc08_149 = eax_461;
	}
	int32 eax_192 = (byte) C_187.u0 + (dwLoc10 + (word32) globals->t40AB6E);
	word32 eax_195 = *esp_109[0x08];
	struct Eq_2284 * esp_196 = esp_109 - 0x04;
	esp_196->ptr0000 = (char *) 0x61;
	dwLoc10 = eax_192;
	esp_109 = (struct Eq_2126 *) ((char *) &esp_196->ptr0000 + 0x04);
	if ((uint32) ((uint64) (uint32) eax_195 % esp_196->ptr0000) > 0x8A || ecx_162 == ~0x102E)
		goto l004053B2;
	int32 ecx_215 = (esp_196->dw0020 ^ esi_104) + edi_102;
	globals->dw40ABA6 = globals->dw40ABA6 & 0x0040ABD2;
	globals->dw40ABA6 = globals->dw40ABA6 - 0x0040AB6E;
	esp_196->ptr0000 = &globals->b40A52C;
	*(esp_196 - 0x04) = 4236604;
	ebx = ecx_162 ^ esi_104;
	esp_196->ptr0014 = (uint32) ((uint64) (uint32) (ebx + 0x252F) % ecx_215) << 0x03;
	struct Eq_2126 * esp_230 = esp_196 - 0x04;
	int32 eax_234 = _stricmp(*(esp_196 - 0x04), esp_196->ptr0000);
	dwLoc14_145 = (DWORD *) 0x0765;
	if (false)
	{
		if (eax_234 != 0x00)
		{
			esp_196->ptr0000 = esp_196->ptr0014->ptr40A498;
			*(esp_196 - 0x04) = 0x0040A4C4;
			*(esp_196 - 0x08) = 0x0040A340;
			*(esp_196 - 0x0C) = 0x03;
			*(esp_196 - 0x10) = 0x0040A4F0;
			*(esp_196 - 0x14) = globals->dw40A4EC;
			*(esp_196 - 0x18) = globals->dw40A584;
			word32 ecx_443;
			word32 edx_444;
			fn0040672B(dwArg00, dwArg04, dwArg08, dwArg0C, out ecx_443, out edx_444);
		}
		esp_109[0x06] = (struct Eq_2126) ~0x24DE;
		esp_230 = esp_109;
		eax_234 = ~0x11EE;
l0040521B:
		if (eax_234 == ~0x11C9)
		{
			globals->dw40AB82 = globals->dw40AB82 & 0x00;
			while (globals->dw40AB82 < 0x1B)
			{
				if (globals->dw40AB82 == 0x1D)
				{
					int32 * esp_352 = esp_230 - 0x04;
					*esp_352 = eax_192;
					*(esp_352 - 0x04) = 0x3015;
					RestoreDC(*(esp_352 - 0x04), *esp_352);
				}
				globals->dw40AB82 = globals->dw40AB82 + 0x01;
			}
			WPARAM * eax_359 = globals->ptr40A2D8->ptr000C;
			struct Eq_2558 * esp_360 = esp_230 - 0x04;
			esp_360->dw0000 = 0x0040A638;
			*(esp_360 - 0x04) = *eax_359;
			globals->dw40AB2A = globals->dw40AB2A - *globals->ptr40AC9E;
			<anonymous> * eax_370 = esp_360->ptr0018;
			word32 ebp_372;
			byte SCZO_373;
			word32 eax_376;
			byte SZO_378;
			byte C_379;
			byte Z_380;
			byte CZ_381;
			word32 ecx_382;
			word32 edx_384;
			eax_370();
			globals->dw40A514 = eax_376;
		}
		else if (eax_234 == ~0x11DE)
		{
			word32 eax_389 = *globals->ptr40A11C;
			struct Eq_2642 * esp_390 = esp_230 - 0x04;
			esp_390->dw0000 = 0x0040A4DC;
			*(esp_390 - 0x04) = eax_389;
			*(esp_390 - 0x08) = 0x02;
			*(esp_390 - 0x0C) = 0x0040A1A4;
			*(esp_390 - 0x10) = eax_389;
			*(esp_390 - 0x14) = globals->dw40A584;
			word32 ecx_405;
			word32 edx_406;
			esp_390->dw0018 = fn0040672B(dwArg00, dwArg04, dwArg08, dwArg0C, out ecx_405, out edx_406);
			esp_230 = (struct Eq_2126 *) (&esp_390->dw0000 + 0x01);
		}
		eax_234 = esp_230[0x06] - 0x01 ^ esi_104;
		dwLoc0C = (word32) bLoc0C + (word32) globals->t40AB96;
		ecx_215 = eax_234;
	}
	ui32 ecx_253 = ecx_215 ^ esi_104;
	esp_230[0x06] = (struct Eq_2126) ecx_253;
	if (ecx_253 + edi_102 == 0x00)
	{
		word32 ecx_258 = esp_230[0x07];
		dwLoc10 = 0x6EF9;
		if (false)
		{
			dwLoc08_149 = dwLoc08_149 >> 0x01;
			dwLoc10 = 26516;
		}
		esp_230[0x06] = (struct Eq_2126) ((uint32) ((uint64) (uint32) ((esp_230[0x03] ^ esi_104) + edi_102) % ((ecx_258 ^ esi_104) + edi_102)) << 0x03);
		struct Eq_2527 * esp_278 = esp_230 - 0x04;
		esp_278->dw0000 = (word32) esp_230[0x06];
		*(esp_278 - 0x04) = esp_278->dw0014;
		fn00404365(dwArg00, dwArg04);
		esp_109 = (struct Eq_2126 *) (&esp_278->dw0000 + 0x01);
		goto l0040534E;
	}
	goto l0040521B;
}

// 00405435: Register word32 fn00405435(Stack Eq_630 dwArg00, Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr code) dwArg0C, Stack word32 dwArg10)
word32 fn00405435(HWND dwArg00, word32 dwArg04, word32 dwArg08, code * dwArg0C, word32 dwArg10)
{
	word32 * esp_108;
	if (dwArg10 != 549991)
	{
		word32 dwLoc10_112;
		if (dwArg10 == 0x00031A16)
			dwLoc10_112 = 394293;
		else
		{
			uint32 dwLoc40_122 = dwLoc40 & 0x00;
			while (dwLoc40_122 < 0x10)
			{
				if (dwLoc40_122 == 0x13)
				{
					SetScrollRange(dwLoc28, 15244, dwLoc24, dwLoc18, 0x00);
					dwLoc18 = dwLoc24;
					dwLoc20 = dwLoc28;
				}
				dwLoc40_122 = dwLoc40_122 + 0x01;
			}
			if (0x00 != *(globals->ptr40A2D8)->ptr000C && 0x00 == globals->dw40A090)
				fn004047C6();
			dwLoc10_112 = 549991;
		}
		fn00405435(dwLoc20, dwArg04, dwArg08, dwArg0C, dwLoc10_112);
		esp_108 = fp - 0x0C;
	}
	else
	{
		word32 ebp_226;
		word32 ecx_227;
		word32 esi_228;
		byte SCZO_229;
		byte Z_230;
		byte SZO_231;
		byte C_232;
		word32 eax_233;
		byte CZ_234;
		dwArg0C();
	}
	globals->t40ABD6 = globals->t40ABD6 - 0x39AA;
	union Eq_233 * ecx_46 = globals->ptr40ACDA;
	*ecx_46 = (union Eq_233 *) (*ecx_46 - 13668 - (globals->t40A100 < dwLoc8C));
	return *esp_108;
}

// 0040564B: Register Eq_399 fn0040564B(Register Eq_399 eax, Register uint32 ebx, Register uint32 edi, Register out ptr32 ecxOut, Register out ptr32 edxOut)
Eq_399 fn0040564B(Eq_399 eax, uint32 ebx, uint32 edi, ptr32 & ecxOut, ptr32 & edxOut)
{
	DWORD * dwLoc28_120 = fp - 0x10;
	uint32 dwLoc30_11 = dwLoc30 & 0x00;
	while (dwLoc30_11 < 0x1F)
	{
		if (dwLoc30_11 == 0x27)
			eax = LockFile(dwLoc20, dwLoc10, 22414, dwLoc20, 0x8757);
		dwLoc30_11 = dwLoc30_11 + 0x01;
	}
	if (true)
	{
		Eq_575 edx_216 = *eax;
		*edxOut = edx_216;
		dwLoc10 = edx_216;
		word32 ecx_218;
		*ecxOut = edx_216;
		if (edx_216 == 0x00)
			return 0x00;
		Mem241[Mem0[eax + 0x04:word32] + 0x00:word32] = edx_216 + Mem0[edx_216 + 0x3C:word32];
		byte * edx_253 = globals->ptr40AC7E;
		struct Eq_2865 * ecx_245 = **((word32) eax + 0x04);
		*edx_253 = *edx_253 + 0x47 + (ebx < dwLoc7C);
		word32 ecx_259 = ecx_245->dw0078;
		Eq_2887 edx_256 = *((word32) eax + 0x0018);
		word32 edx_258;
		*edxOut = fp - 0x24;
		word32 ecx_261;
		*ecxOut = ecx_259;
		if (ecx_259 == 0x00)
			return 0x00;
		uint32 ecx_330;
		**((word32) eax + 0x0C) = (word32) edx_216 + ecx_259;
		Eq_2941 ecx_269 = *((word32) eax + 0x0C);
		globals->dw40AB1A = (char *) *globals->ptr40ACFE + globals->dw40AB1A;
		struct Eq_2819 * ecx_275 = *ecx_269.dw0000;
		uint32 ecx_291 = ecx_275->dw0018;
		globals->t40AB8A = (word32) globals->t40AB8A + dwLocC4;
		globals->dw40AB9E = globals->dw40AB9E - 11752 - (edi < dwLoc30_11);
		dwLoc1C = ecx_275;
		uint32 ecx_311 = ecx_275->dw0014;
		dwLoc28_120 = fp - 0x18;
		if (ecx_311 > ecx_291)
			ecx_330 = ecx_311;
		else
			ecx_330 = ecx_291;
		globals->t40AB52 = globals->t40AB52 & 0x0040AB0E;
		Eq_1027 v31_336 = (word32) globals->t40AB52 + 4238178;
		globals->t40AB52 = v31_336;
		globals->t40AB52.u1 = (byte) (v31_336 < 0x00) + ((word32) globals->t40AB52 + 4238098);
		*edx_256.dw0000 = (Eq_2887) ecx_330;
		uint32 dwLoc44_344 = dwLoc44 & 0x00;
		do
		{
			uint32 edx_353 = dwLoc44_344 + 0x01;
			dwLoc44_344 = edx_353;
			if (edx_353 == 0x2B)
				eax = SetLocalTime((SYSTEMTIME *) 23636);
		} while (edx_353 < 0x1D);
		if (false)
			globals->t40ABE6 = globals->t40ABE6 - dwLoc88;
		word32 * ecx_384 = globals->ptr40AD1E;
		word32 ecx_380 = ecx_275->dw0024;
		*ecx_384 = *ecx_384 - 0x1909;
		**((word32) eax + 0x0014) = (word32) edx_216 + ecx_380;
		uint8 * edx_391 = globals->ptr40AC92;
		*edx_391 = *edx_391 >> 0x01;
	}
	Mem160[Mem0[eax + 0x08:word32] + 0x00:word32] = dwLoc10 + Mem0[dwLoc1C + 0x1C:word32];
	**((word32) eax + 0x0010) = (word32) dwLoc10 + *dwLoc28_120;
	globals->dw40AAFA = globals->dw40AAFA & 0x6DF3;
	**((word32) eax + 0x001C) = ~0x101A;
	Eq_2913 edx_187 = *((word32) eax + 0x0020);
	*edxOut = edx_187;
	*edx_187.dw0000 = (Eq_2913) ~0x101A;
	**((word32) eax + 0x0024) = ~0x101C;
	word32 ecx_185;
	*ecxOut = ~0x101A;
	return 0x01;
}

// 004059B2: Register Eq_575 Win32CrtStartup()
Eq_575 Win32CrtStartup()
{
	Eq_575 eax_259;
	ptr32 esp_12;
	ptr32 ebp_13;
	byte SCZO_14;
	int32 eax_15;
	byte SZO_16;
	byte C_17;
	word32 esi_18;
	word32 edi_19;
	byte Z_20;
	word16 ax_21;
	word32 ecx_22;
	word32 edx_23;
	byte CZ_24;
	word16 cx_25;
	word16 dx_26;
	word16 di_27;
	word16 si_28;
	word32 ebx_29;
	byte SO_30;
	SHLWAPI.dll!StrSpnA();
	if (eax_15 > 0x0A)
		eax_259.u0 = 0x00;
	else
	{
		*(esp_12 - 0x04) = esi_18;
		*(esp_12 - 0x08) = edi_19;
		word32 dwLoc0220_153 = 0x11;
		while (dwLoc0220_153 != 0x00)
		{
			if (dwLoc0220_153 == 0x18)
			{
				*(esp_12 - 0x0C) = 0x3899;
				*(esp_12 - 0x10) = 0x8BFF;
				*(esp_12 - 0x14) = dwLoc14;
				*(esp_12 - 0x18) = 7721;
				*(esp_12 - 0x1C) = dwLoc24;
				DialogBoxIndirectParamA(*(esp_12 - 0x1C), *(esp_12 - 0x18), *(esp_12 - 0x14), *(esp_12 - 0x10), *(esp_12 - 0x0C));
			}
			dwLoc0220_153 = dwLoc0220_153 - 0x01;
		}
		word32 ebx_187;
		word32 * eax_188 = fn00404C90(ebp_13, fp - 0x14, ~0x101E, ebp, out ebx_187);
		if (true)
		{
			*(esp_12 - 0x0C) = 0x46;
			*(esp_12 - 0x0C) = 0x3A;
			*(esp_12 - 0x0C) = 0x5C;
			*(esp_12 - 0x0C) = 0x4A;
			ui32 * ecx_284 = globals->ptr40ACAA;
			*ecx_284 = *ecx_284 | dwLoc025C;
			globals->t40ABAE = (word32) globals->t40ABAE - dwLoc03D4;
			*(esp_12 - 0x0C) = 0x48;
			*(esp_12 - 0x0C) = 0x44;
			ui32 * edx_322 = globals->ptr40AC6E;
			*edx_322 = *edx_322 & (word32) globals->b40ABCA;
			*(esp_12 - 0x0C) = 0x4B;
			globals->dw40AAEE = globals->dw40AAEE & 0x0040AAFA;
			globals->dw40ABBE = globals->dw40ABBE & dwLoc0294;
			*(esp_12 - 0x0C) = 0x44;
			byte * edi_375 = globals->ptr40ACAE;
			*edi_375 = *edi_375 + 0x2D;
			*(esp_12 - 0x0C) = 0x2E;
			*(esp_12 - 0x0C) = 0x44;
			*(esp_12 - 0x0C) = 0x4C;
			globals->dw40AB4E = globals->dw40AB4E & 0x00;
			while (globals->dw40AB4E < 22)
			{
				if (globals->dw40AB4E == 0x1D)
				{
					*(esp_12 - 0x10) = dwLoc20;
					*(esp_12 - 0x14) = 0x0040AB66;
					*(esp_12 - 0x18) = dwLoc18;
					*(esp_12 - 0x1C) = 0x0040AB82;
					*(esp_12 - 0x20) = dwLoc24;
					*(esp_12 - 0x24) = dwLoc28;
					*(esp_12 - 0x28) = dwLoc10;
					TransactNamedPipe(*(esp_12 - 0x28), *(esp_12 - 0x24), *(esp_12 - 0x20), *(esp_12 - 0x1C), *(esp_12 - 0x18), *(esp_12 - 0x14), *(esp_12 - 0x10));
				}
				globals->dw40AB4E = globals->dw40AB4E + 0x01;
			}
			*(esp_12 - 0x0C) = 464;
			*(esp_12 - 0x10) = 0x00;
			if (true)
				globals->ptr40AB02 = globals->ptr40AB02 - *globals->ptr40AC9E - (dwLoc0358 + dwLoc0364 < 0x00);
			*(esp_12 - 0x14) = fp - 484;
			memset(*(esp_12 - 0x14), *(esp_12 - 0x10), *(esp_12 - 0x0C));
			*(esp_12 - 0x0C) = fp - 0x021C;
			struct Eq_3451 * esp_484;
			ptr32 ebp_485;
			byte SCZO_486;
			word32 eax_487;
			byte SZO_488;
			byte C_489;
			word32 esi_490;
			word32 edi_491;
			byte Z_492;
			word16 ax_493;
			word32 ecx_494;
			word32 edx_495;
			byte CZ_496;
			word16 cx_497;
			word16 dx_498;
			word16 di_499;
			word16 si_500;
			word32 ebx_501;
			byte SO_502;
			SHLWAPI.dll!PathMakePrettyW();
			if ((fp - 0x021C & fp - 0x021C) != 0x00)
			{
				fn00403E27(ebp_485, fp - (struct Eq_3521 *) 0x0C, fp - (struct Eq_3523 *) 0x10);
				Eq_575 edi_635 = fp - (struct Eq_3523 *) 0x10 ^ fp - (struct Eq_3523 *) 0x10;
				fn00403E27(ebp_485, &globals->t40A548, edi_635);
				word32 ebx_646;
				fn00404C90(ebp_485, &globals->t40A54C, edi_635, ebp, out ebx_646);
				fn00403E27(ebp_485, &globals->t40A550, edi_635);
				fn00403E27(ebp_485, &globals->ptr40A554, edi_635);
			}
			fn00403E27(ebp_485, fp - 0x08, 0x06586468);
			fn00403E03(fp - (union Eq_575 *) 0x04);
			byte * esi_520 = globals->ptr40AD5A;
			Eq_575 edi_517 = globals->t40A548;
			*esi_520 = *esi_520 - 122;
			fn00403E27(ebp_485, &globals->dw40A4CC, edi_517);
			if (false)
				globals->dw40AB5E = globals->dw40AB5E + globals->dw40AB5A;
			ui32 ebx_534;
			fn00404C90(ebp_485, &globals->dw40A4D0, globals->t40A54C, ebp, out ebx_534);
			fn00403E27(ebp_485, &globals->dw40A4D4, globals->t40A550);
			Eq_1476 ecx_541 = fn00403E27(ebp_485, &globals->t40A4D8, dwLoc0C);
			Eq_575 eax_543 = GetCurrentProcessId();
			Eq_959 edi_544 = esp_484->t0000;
			globals->dw40ABBE = globals->dw40ABBE - 4238294 - (ecx_541 < dwLoc0348);
			if (eax_543 != 0x00)
				fn00405F2F(ecx_541, ebx_534, edi_544);
			else if (GetCurrentThreadId() != 0x00)
			{
				esp_484->t0004.u0 = 0x00;
				ExitProcess(esp_484->t0004);
			}
			*dwLoc0C = globals->t40A4D8->t0000;
			Eq_283 eax_564 = globals->dw40A104 ^ globals->t40A100;
			uint32 dwLoc0264_567 = dwLoc0264 & 0x00;
			do
			{
				uint32 ecx_576 = dwLoc0264_567 + 0x01;
				dwLoc0264_567 = ecx_576;
				if (ecx_576 == 0x1E)
				{
					esp_484->t0004.u0 = 34445;
					esp_484->t0000 = dwLoc2C;
					*(esp_484 - 0x04) = 33818;
					*(esp_484 - 0x08) = 0x31CE;
					*(esp_484 - 0x0C) = dwLoc20;
					eax_564 = SendDlgItemMessageA(*(esp_484 - 0x0C), *(esp_484 - 0x08), *(esp_484 - 0x04), esp_484->t0000, esp_484->t0004);
				}
			} while (ecx_576 < 0x13);
			globals->t40A100 = eax_564;
			eax_188 = globals->ptr40A554;
		}
		*eax_188 = globals->t40A100 + *eax_188 / 0x04;
		eax_259 = *dwLoc0C;
	}
	return eax_259;
}

// 00405F2F: void fn00405F2F(Register Eq_1476 ecx, Register ui32 ebx, Register Eq_959 edi)
void fn00405F2F(Eq_1476 ecx, ui32 ebx, WPARAM edi)
{
	globals->t40ABA2 = globals->t40ABA2 & globals->dw40ABEA;
	globals->ptr40A4B8 = null;
	Eq_283 ecx_101;
	if (fn00405060(ecx, ebx, fp - 0x04, edi, out ecx_101) == 0x00)
		return;
	ui32 edi_103 = ~0x1119;
	word32 * ebx_105 = fp;
	word32 esi_104 = 0x3530;
l00405FA6:
	word32 * eax_111;
	globals->dw40A318 = globals->dw40A4CC;
	globals->dw40A31C = globals->dw40A4D0;
	word32 eax_94 = globals->dw40A4D4;
	globals->ptr40AB02 = 4238222;
	globals->dw40A320 = eax_94;
	if (edi_103 == ~0x101C)
	{
		dwLoc18 = dwLoc18 & 0x00;
		while (dwLoc18 < 0x17)
		{
			if (dwLoc18 == 0x25)
			{
				SendMessageA(dwLoc24, 33790, 12190, ~0x101D);
				dwLoc50.u0 = ~0x101D;
			}
			dwLoc18 = dwLoc18 + 0x01;
		}
		eax_111 = globals->ptr40A4B8;
		if (false)
		{
l0040608B:
			edi_103 = edi_103 - (eax_111 ^ esi_104) - 0x252F ^ esi_104;
			if (edi_103 != ~0x101D)
				goto l00405FA6;
			return;
		}
		ecx_101 = globals->t40A100;
		*eax_111 = ecx_101 + *eax_111 / 0x04;
	}
	else if (edi_103 == ~0x11DE)
	{
		globals->ptr40A314 = fp - 0x0C;
		uint32 ecx_199;
		Eq_575 eax_203 = fn00404D4D(ecx_101, ebx_105, dwLoc50, out ecx_199, out ebx_105, out esi_104, out edi_103);
		ecx_101 = globals->t40A4D8;
		ecx_101->t0000 = eax_203;
		dwLoc18 = (word32) bLoc18 - dwLoc1C - (dwLoc1C < ecx_199);
	}
	globals->ptr40A4B8 = ebx_105;
	eax_111 = (word32 *) ~0x101D;
	edi_103 = edi_103 ^ esi_104;
	goto l0040608B;
}

// 0040672B: Register word32 fn0040672B(Stack word32 dwArg04, Stack Eq_959 dwArg08, Stack Eq_1108 dwArg0C, Stack word32 dwArg10, Register out ptr32 ecxOut, Register out ptr32 edxOut)
word32 fn0040672B(word32 dwArg04, WPARAM dwArg08, Eq_1108 dwArg0C, word32 dwArg10, ptr32 & ecxOut, ptr32 & edxOut)
{
fn0040672B_entry:
	*ecxOut = ecx
	*edxOut = edx
	globals->ptr40ABB2 = 0x0040AB76
	uint32 ebx_14 = ~0x101E
	ptr32 esp_15 = fp - 0x022C
	word32 dwLoc60_18 = ~0x101D
	word32 dwLoc4C_20 = ~0x101E
	ui32 dwLoc10_21 = ~0x101E
	uint32 edi_23 = 0x252F
	goto l0040675D
l0040672B:
l0040675D:
	word32 eax_150
	branch dwLoc4C_20 != ~0x101E l0040680D
l0040676C:
	dwLoc8C = dwLoc8C & 0x00
	goto l0040678B
l0040677C:
l0040678B:
	branch dwLoc8C >= 0x14 l004067BB
l0040679C:
	branch dwLoc8C != 0x1F l004067B6
l004067AD:
	HMENU * esp_786 = esp_15 - 0x04
	*esp_786 = (HMENU *) dwLoc24
	IsMenu(*esp_786)
l004067B6:
	dwLoc8C = dwLoc8C + 0x01
	goto l0040678B
l004067BB:
	word32 ecx_811
	word32 edx_812
	branch fn0040564B(fp - 0x88, ebx_14, edi_23, out ecx_811, out edx_812) == 0x00 l00406C97
l0040680D:
	branch dwLoc1C == ~0x101E l00406835
	branch dwLoc1C == ~0x101E l00406835
l00406816:
	branch dwLoc14->dw0018 == 0x00 l0040682D
	branch dwLoc14->dw0018 == 0x00 l0040682D
l00406823:
	branch dwLoc14->dw0014 != 0x00 l00406835
	branch dwLoc14->dw0014 != 0x00 l00406835
l0040682D:
	dwLoc60_18 = ~0x101E
	goto l00406ACF
l00406835:
	branch dwLoc18 == ~0x101E l00406C97
l0040683E:
	branch dwLoc10_21 == (dwLoc30 + 4294957777 ^ 0x3530) || dwLoc60_18 != ~0x101D l00406C97
	goto l0040689A
l00406879:
l0040688C:
l0040689A:
	Eq_3966 ecx_322 = dwLoc10_21 ^ 0x3530
	word32 ecx_323
	*ecxOut = (word32) ecx_322 + 0x0000252F
	branch ecx_322 <= 0x2529 l004068AD
l004068AA:
	dwLoc4C_20 = ~0x101D
l004068AD:
	branch (word32) ecx_322 + 0x0000252F >= dwLoc14->dw0018 l00406C97
l004068C0:
	word32 dwLocA8_335 = 0x19
l004068D1:
	branch dwLocA8_335 == 0x00 l0040692A
l004068E2:
	branch dwLocA8_335 != 0x20 l00406916
l004068F3:
	*(esp_15 - 0x04) = (HMENU *) dwLoc24
	*(esp_15 - 0x08) = 36602
	*(esp_15 - 0x0C) = 0x0040AB3A
	*(esp_15 - 0x10) = dwLoc10_21
	*(esp_15 - 0x14) = dwLoc1C
	*(esp_15 - 0x18) = 33267
	*(esp_15 - 0x1C) = 34436
	FormatMessageA(*(esp_15 - 0x1C), *(esp_15 - 0x18), *(esp_15 - 0x14), *(esp_15 - 0x10), *(esp_15 - 0x0C), *(esp_15 - 0x08), *(esp_15 - 0x04))
l00406916:
	dwLocA8_335 = dwLocA8_335 - 0x01
	goto l004068D1
l0040692A:
	Eq_3989 eax_371 = ((word32) ecx_322 + 0x0000252F) * 0x02
	uint32 edx_397 = dwLoc14->dw0014
	<anonymous> * eax_402 = ((word32) *((word32) eax_371 + dwLoc28) - 0x252F ^ 0x3530 ^ 0x3530) + 0x252F
	word32 edx_404
	*edxOut = edx_397 - 0x01
	branch eax_402 > edx_397 - 0x01 l00406C97
	goto l004069B4
l0040696E:
l004069B4:
	branch false l00406AF8
l004069D0:
	ui32 eax_614 = (word32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(((dwLoc48 ^ 0x3530) + 0x252F) *s ((word32) ecx_322 + 0x0000252F))[dwLoc28].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00]
	globals->dw40ABEA = globals->dw40ABEA + dwLocD0
	globals->dw40ABD2 = 0x18
	ui32 v29_607 = dwLoc20 & 0x00
	dwLoc20 = v29_607
	Eq_4127 eax_626 = ((dwLoc1C ^ 0x3530) + 0x252F) *s ((word32) ecx_322 + 0x0000252F)
	word32 * eax_634 = fp - 0x3C
l00406A48:
	branch globals->dw40ABD2 == 0x00 l00406A93
l00406A55:
	branch globals->dw40ABD2 != 0x1A l00406A81
l00406A62:
	*(esp_15 - 0x04) = 0x490B
	*(esp_15 - 0x08) = dwLoc28
	*(esp_15 - 0x0C) = dwLoc2C
	*(esp_15 - 0x10) = dwLoc10_21
	*(esp_15 - 0x14) = dwLoc28
	*(esp_15 - 0x18) = dwLoc18
	*(esp_15 - 0x1C) = 0x5043
	eax_634 = SetDIBits(*(esp_15 - 0x1C), *(esp_15 - 0x18), *(esp_15 - 0x14), *(esp_15 - 0x10), *(esp_15 - 0x0C), *(esp_15 - 0x08), *(esp_15 - 0x04))
l00406A81:
	globals->dw40ABD2 = globals->dw40ABD2 - 0x01
	goto l00406A48
l00406A93:
	globals->dw40AB86 = globals->dw40AB86 ^ 0x0040AB5A
	*eax_634 = (word32) *((word32) eax_626 + dwLoc34)
	*(esp_15 - 0x04) = fp - 0x20
	*(esp_15 - 0x08) = dwLoc3C + dwArg08
	*(esp_15 - 0x0C) = dwArg0C
	word32 ebp_704
	byte SCZO_705
	word32 esi_707
	word32 eax_709
	byte Z_710
	byte SZO_711
	byte C_712
	word32 ecx_713
	byte CZ_714
	word32 edx_715
	byte SO_716
	word16 ax_717
	dwArg04()
	branch v29_607 == 0x01 l00406ADF
l00406ACF:
	dwLoc10_21 = ((dwLoc10_21 ^ 0x3530) + 0x01 ^ 0x3530 ^ 0x3530) + 0x01 ^ 0x3530
	goto l0040675D
l00406ADF:
	eax_402 = dwLoc2C[eax_614] + dwArg08
l00406AF8:
	branch dwArg10 == 0x00 l00406C81
l00406B09:
	word32 * eax_471 = globals->ptr40AD12
	*eax_471 = (word32) ((byte) (dwLocC4 < 0x00) + (*eax_471 + 0x350F))
	globals->dw40AAFA = (ui32) ((byte) (dwLocC4 < 0x00) + (globals->dw40AAFA + (word32) wLoc0170))
	int32 eax_480 = (dwLoc18 ^ 0x3530) + 0x252F
	branch P l00406B97
	goto l00406B83
l00406B4B:
l00406B83:
	union Eq_984 * edx_571 = globals->ptr40AD56
	*edx_571 = (union Eq_984 *) (*edx_571 | 0x81)
	goto l00406BAC
l00406B97:
	globals->t40AB6E = globals->t40AB6E | dwLoc0130
l00406BAC:
	globals->dw40AB6A = globals->dw40AB6A + globals->dw40AB9A
	ptr32 eax_506 = esp_15
	int32 ecx_518 = eax_480 *s dwArg10
l00406BED:
	eax_506 = eax_506 - 0x01
	ecx_518 = ecx_518 - 0x01
	branch ecx_518 != 0x00 l00406BED
l00406BFC:
	int32 dwLoc10_539 = 0x00
	struct Eq_1219 * eax_540 = fp + 0x10
l00406C33:
	union Eq_4351 * ebx_549 = globals->ptr40AD42
	*ebx_549 = (union Eq_4351 *) ((char *) *ebx_549 + 111 + (eax_540 < globals->ptr40AB4A))
	eax_540 = eax_540 + 0x04
	((dwLoc18 ^ 0x3530) + 0x252F) *s dwLoc10_539 + eax_506 = eax_540->dw0000
	int32 v47_564 = dwLoc10_539 + 0x01
	dwLoc10_539 = v47_564
	branch v47_564 != dwArg10 l00406C33
l00406C84:
	word32 esp_446
	word32 ebp_447
	byte SCZO_448
	word32 ebx_449
	word32 esi_450
	word32 edi_451
	word32 eax_452
	byte Z_453
	byte SZO_454
	byte C_455
	word32 ecx_456
	byte CZ_457
	word32 edx_458
	byte SO_459
	word16 ax_460
	byte P_461
	eax_402()
	eax_150 = eax_452
	goto l00406CE7
l00406C97:
	globals->dw40AB86 = globals->dw40AB86 & 0x00
	goto l00406CB3
l00406CA6:
l00406CB3:
	branch globals->dw40AB86 >= 0x19 l00406CE5
l00406CC0:
	branch globals->dw40AB86 != 0x1F l00406CE0
l00406CCD:
	LPCWSTR * esp_213 = esp_15 - 0x04
	*esp_213 = (LPCWSTR *) &globals->t40AEE4
	*(esp_213 - 0x04) = dwLoc10_21
	*(esp_213 - 0x08) = 0x8CE8
	CreateWaitableTimerW(*(esp_213 - 0x08), *(esp_213 - 0x04), *esp_213)
l00406CE0:
	globals->dw40AB86 = globals->dw40AB86 + 0x01
	goto l00406CB3
l00406CE5:
	eax_150 = 0x00
l00406CE7:
	return eax_150
fn0040672B_exit:
}

// 00406D5A: Register (ptr void) __he_qt(Stack uint32 dwArg04)
void(uint32 dwArg04)
{
	globals->dw40AB36 = (word32) ((byte) (ecx < globals->dw40AB0E) + (globals->dw40AB36 + globals->dw40AB1E));
	globals->t40ABD6 = globals->t40ABD6 - *globals->ptr40AD22;
	globals->t40ABC2 = (word32) globals->t40ABC2 - *globals->ptr40AD4E;
	return eax;
}

// 00406DAD: void RF_Egdnkvdiiuncf(Stack uint32 dwArg04, Stack (ptr int16) ptrArg08)
void RF_Egdnkvdiiuncf(uint32 dwArg04, int16 * ptrArg08)
{
	globals->t40ABC2 = globals->t40ABC2 - globals->dw40AAFA;
	globals->dw40AB86 = globals->dw40AB86 + (word32) globals->t40AAF6;
	Mem30[4238226:word32] = Mem21[4238226:word32] + Mem21[Mem21[0x0040AD42:word32] + 0x00:word32] + (dwLoc08 <u edi);
	return;
}

// 00406DF7: Register (ptr cu8) kJAZuY_hvjqel_v_wuvzz(Stack uint32 dwArg04, Stack uint16 wArg08)
cu8 * kJAZuY_hvjqel_v_wuvzz(uint32 dwArg04, uint16 wArg08)
{
	ui32 * ebx_14 = globals->ptr40ACEA;
	*ebx_14 = *ebx_14 | globals->t40AB46;
	Eq_3057 edx_21 = (word32) globals->t40ABC2 | globals->ptr40AB16;
	globals->t40ABC2 = edx_21;
	globals->dw40AB5E = globals->dw40AB5E - *globals->ptr40AC9A - (globals->t40ABE6 < edx_21);
	return eax;
}

// 00406E3E: Register uint32 xcfq_xwotK(Stack (ptr uint32) ptrArg04)
uint32 xcfq_xwotK(uint32 * ptrArg04)
{
	Eq_2963 ecx_13 = (word32) globals->t40AB8A - *globals->ptr40ACF2;
	globals->t40AB8A = ecx_13;
	globals->t40ABE2.u1 = (byte) (dwLoc08 < ecx_13) + ((word32) globals->t40AB6E + (word32) globals->t40ABE2);
	globals->t40AB12 = globals->t40AB12 & *globals->ptr40ACA2;
	return eax;
}

