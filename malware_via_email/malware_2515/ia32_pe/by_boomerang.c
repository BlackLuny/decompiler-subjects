__size32 global322 = 0x159a55e5;// 4 bytes
unsigned int global323 = 0x5491333;
__size32 global328 = 0;// 4 bytes
unsigned int global329 = 0x79b5;
__size32 global330 = 0;// 4 bytes
__size32 global331 = 0;// 4 bytes
__size32 global332 = 0;// 4 bytes
__size32 global334 = 0x1f123bb5;// 4 bytes
int global337 = 0;
__size8 global343 = 0;// 1 bytes
__size32 global345 = 0;// 4 bytes
unsigned int global346 = 0;
__size32 global347 = 0;// 4 bytes
int global350 = 0;
__size32 global355 = 0x11170;// 4 bytes
unsigned int global397 = 0;
__size8 global420 = 0;// 1 bytes
int global422 = 0x90234cf3;
__size32 global423 = 0;// 4 bytes
int global427 = 0;
unsigned int global428 = 0;
unsigned int global437 = 0x3d05c700;
int global458 = 0;
__size32 global467 = 0;// 4 bytes
__size32 global468 = 0xdc004380;// 4 bytes
__size32 global485 = 0;// 4 bytes
int global487 = 0;
__size32 global488 = 0x35010000;// 4 bytes
int global498 = 0;
unsigned int global501 = 0;

__size32 proc2();
int proc3();
void _start();
__size32 proc4();
int proc5();
int proc6();
__size32 proc7();
int proc8();
__size32 proc9();
int proc10();
unsigned int proc11();
unsigned int proc12();
__size32 proc13();
unsigned int proc14();
void proc15(unsigned char param1, __size32 param2, __size32 param3);
void proc16();

// address: 0x401c89
__size32 proc1(__size32 param1) {
    __size32 eax; 		// r24
    unsigned int esp; 		// r28

    eax = param1 + ((unsigned int)(esp - 4) < 992) + 0x1824;
    return eax + 0x1620;
}

// address: 0x40136a
__size32 proc2() {
    int eax; 		// r24
    __size32 eax_1; 		// r24{28}
    int eax_2; 		// r24{299}
    unsigned int eax_3; 		// r24{339}
    int eax_4; 		// r24{195}
    unsigned int ecx; 		// r25
    unsigned int edx; 		// r26
    int local0; 		// m[esp - 448]
    unsigned char local1; 		// m[esp - 492]
    unsigned int local10; 		// m[esp - 560]
    unsigned char local11; 		// m[esp - 384]
    unsigned int local12; 		// m[esp - 340]
    unsigned int local13; 		// m[esp - 456]
    int local14; 		// m[esp - 388]{240}
    int local15; 		// eax_4{334}
    int local2; 		// m[esp - 172]
    unsigned int local3; 		// m[esp - 284]
    int local4; 		// m[esp - 520]
    int local5; 		// m[esp - 388]
    unsigned int local6; 		// m[esp - 428]
    unsigned int local7; 		// m[esp - 240]
    unsigned short local8; 		// m[esp - 220]
    unsigned int local9; 		// m[esp - 548]

    eax = eax & 0x1dc8;
    if (ecx < local3) {
L41:
        eax = eax + 0x158b & 0x1c0;
    } else {
        eax_1 = 0 - (ecx < local3);
        eax = eax_1 + 0x33b1;
        if ((unsigned int)(eax_1 + 0x33b1 & 0x2281) <= 0) {
            eax = eax_1 + 0x2ca1 & 0x18c;
            goto L41;
        }
    }
    eax_2 = eax;
    eax = (eax_2 | 0x34dc) - 0x1dcc;
    if (edx > local12) {
L27:
        eax = eax & 0x3695 ^ local6;
        eax = eax + LOGICALFLAGS32(eax) + 0x2575 & 0x2acc;
L26:
        eax_3 = eax;
        eax_4 = eax_3 ^ 0x2ff2;
        flags = LOGICALFLAGS32(eax_3 ^ 0x2ff2);
L25:
        local14 = local5 + eax_4 + CF;
        flags = ADDFLAGS32(local5, eax_4, local14);
        local15 = eax_4;
L24:
        eax_4 = local15;
        eax = eax_4 + CF + 0x3e38 ^ 0x16d9;
        eax = eax ^ 0x121b;
L23:
        eax = eax - 0xf23;
    } else {
        eax = (eax_2 | 0x34dc) - 22 & 0x4b3;
        if ((int)ecx < (int)eax) {
            goto L26;
        } else {
            eax_4 = eax - local10;
            flags = SUBFLAGS32(edx, ecx, edx - ecx);
            if (edx != ecx) {
                goto L25;
            } else {
                eax = eax_4 + ADDFLAGS32(eax_4, 0x1a76, eax_4 + 0x1a76) + 0x3dee;
                flags = LOGICALFLAGS32(eax_4 + ADDFLAGS32(eax_4, 0x1a76, eax_4 + 0x1a76) + 0x3dee & 0x1c03);
                local15 = eax;
                if ((unsigned int)(eax_4 + ADDFLAGS32(eax_4, 0x1a76, eax_4 + 0x1a76) + 0x3dee & 0x1c03) < 0) {
                    goto L24;
                } else {
                    eax = (eax_4 + ADDFLAGS32(eax_4, 0x1a76, eax_4 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7;
                    if ((unsigned int)(((eax_4 + ADDFLAGS32(eax_4, 0x1a76, eax_4 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) & ecx) < 0) {
                        goto L23;
                    } else {
                        eax = ((eax_4 + ADDFLAGS32(eax_4, 0x1a76, eax_4 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) - LOGICALFLAGS32(((eax_4 + ADDFLAGS32(eax_4, 0x1a76, eax_4 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) & ecx) - 0x43c2 | 0x9e8;
                        if ((unsigned int)(local0 & (((eax_4 + ADDFLAGS32(eax_4, 0x1a76, eax_4 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) - LOGICALFLAGS32(((eax_4 + ADDFLAGS32(eax_4, 0x1a76, eax_4 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) & ecx) - 0x43c2 | 0x9e8)) <= 0) {
                            eax = (local1) | local2;
                            eax = eax - 0x34a1 ^ 0x3e62;
                            goto L27;
                        }
                    }
                }
            }
        }
    }
    if (eax < 0) {
L19:
        eax = (local8);
    } else {
        if ((unsigned int)(eax & edx) <= 0) {
            goto L19;
        }
    }
    eax = eax - local13;
    eax = (eax | 0x358a) + LOGICALFLAGS32(eax | 0x358a) - ADDFLAGS32(eax | 0x358a, 0x35d3, (eax | 0x358a) + LOGICALFLAGS32(eax | 0x358a) + 0x35d3) + 0x1a35;
    if (ecx > edx) {
L14:
        eax = (eax & 0x37c) + 499;
    } else {
        eax = -1222 - LOGICALFLAGS32(0);
        if (local7 >= ecx) {
            eax = 0xffffed00 - LOGICALFLAGS32(0) + (local7 < ecx);
            goto L14;
        }
    }
    if ((edx & 0x672) != 0) {
L4:
L3:
    } else {
        if (ecx == local9) {
            goto L3;
        } else {
            if ((((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + ((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + 1354 & edx) == 0) {
                goto L3;
            } else {
                if ( !((unsigned int)(edx & 0x2d79) < 0 || (unsigned int)(((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + ((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + 1354 & 0x4f3) > 0)) {
                    if (((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + ((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local4) + 1354 >= ecx) {
                        goto L4;
                    }
                }
            }
        }
    }
    eax = (local11);
    return (eax & 0x567 ^ 0x353f) + 0x25b6;
}

// address: 0x404f15
int proc3() {
    unsigned int eax; 		// r24
    unsigned int edx; 		// r26
    void *esp; 		// r28
    unsigned int local0; 		// m[esp - 204]
    unsigned char local1; 		// m[esp - 136]
    int local2; 		// m[esp - 460]

    eax = proc8();
    eax = eax | local2;
    if ((unsigned int)(edx & eax) >= 0) {
    }
    proc8();
    if (edx < local0) {
L9:
    } else {
        eax = (local1);
        if (eax <= 0) {
            goto L9;
        }
    }
    proc1((esp - 468));
    eax = proc8();
    proc1(eax);
    eax = proc2();
    return eax | 0x95c; /* WARNING: Also returning: ecx := 0, edx := (esp - 172) */
}

// address: 0x403e3d
void _start() {
    int eax; 		// r24
    __size32 eax_1; 		// r24{189}
    int eax_2; 		// r24{1021}
    int eax_3; 		// r24{283}
    __size32 *ebp; 		// r29
    __size32 ebx; 		// r27
    __size32 ecx; 		// r25
    unsigned int edi; 		// r31
    __size32 edx; 		// r26
    __size32 esi; 		// r30
    void *esp; 		// r28
    int local0; 		// m[esp - 608]
    __size32 local1; 		// m[esp - 552]
    unsigned int local2; 		// m[esp - 176]
    int local3; 		// m[esp - 140]
    int local4; 		// m[esp - 228]
    unsigned int local5; 		// m[esp - 264]
    void *local6; 		// m[esp - 124]
    int local7; 		// m[esp - 672]
    int local8; 		// m[esp - 4]

    proc1(eax);
    proc2();
    global498 = (esp - 660);
    global467 = esi;
    global346 = edi;
    eax = global468 - ebx + ADDFLAGS32(0x4397e9, *0x4383e4, global468 + 0x4397e9) + 0x4397e9;
    global458 = ebx;
    global501 = edi;
    global485 = ecx;
    global345 = ecx;
    global397 = global397 - (eax & 0x1fa7);
    global330 = 0x439801;
    global487 = (esp - 4);
    eax = proc1(global488);
    if ((esp - 436) > 0) {
L100:
L99:
L98:
L97:
    } else {
        if (0x439801 != local3) {
            goto L99;
        } else {
            if ((unsigned int)((eax + local1 - ADDFLAGS32(eax + 0x35af, 0xff9, eax + 0x45a8) + 0x1316 & 0x3174) + 0xf0b & 0x439801) < 0) {
                goto L98;
            } else {
                if ((unsigned int)(esp - 436 & 0x2f67) > 0) {
                    goto L97;
                } else {
                    if (local6 <= esp - 436) {
                        goto L100;
                    }
                }
            }
        }
    }
    edx = proc3();
    if ((unsigned int)(edx & 0xfe1) > 0) {
L90:
    } else {
        if ((unsigned int)(edx & 0x3c4f) <= 0) {
            goto L90;
        }
    }
    ecx = proc4();
    eax = proc5();
    eax = eax - local7;
    if (0 == ecx) {
L83:
    } else {
        eax = eax ^ local2;
        if ((unsigned int)(eax - LOGICALFLAGS32(eax) - 0x39e5) <= 0) {
            goto L83;
        }
    }
    proc6();
    proc5();
    proc7();
    proc8();
    ecx = proc9();
    eax = proc10();
    tmp1 = (eax ^ 0x1b9c | 0x1dd7) & 0x1dd5;
    if (tmp1 != 0) {
L68:
L67:
    } else {
        if (0 < (unsigned int)(eax ^ 0x1b9c | 0x1dd7)) {
            goto L67;
        } else {
            if ((unsigned int)(ecx & (eax ^ 0x1b9c | 0x1dd7)) >= 0) {
                goto L68;
            }
        }
    }
    proc8();
    if (ecx >= 0) {
    }
    proc8();
    edx = proc3();
    proc5();
    if ( !((unsigned int)(edx & 0x2b13) < 0 || local5 < 0 || edx > 0)) {
    }
    proc11();
    if (0 == edx) {
    }
    eax = proc4(); /* Warning: also results in ecx */
    eax = eax + 0x1b2a | 0x17d1 | 0x3b63;
    eax += local2;
    if ( !(ecx != 0 || (local4 & (eax ^ 0x3a9f) + LOGICALFLAGS32(ecx) + 0x1a19) != 0)) {
    }
    eax_1 = proc12(); /* Warning: also results in ecx, edx */
    eax = (eax_1 + LOGICALFLAGS32(0) + 0x829 & 0x39fe | 513) + 0x216a;
    if ((eax_1 + LOGICALFLAGS32(0) + 0x829 & 0x39fe | 513) + 0x216a != local0) {
L36:
        eax = (eax ^ 0x200c) - 0x322a;
L35:
        eax_2 = eax;
        eax = eax_2 | 0xaea;
        flags = LOGICALFLAGS32(eax_2 | 0xaea);
    } else {
        eax = 0;
        if (ecx < 0) {
            goto L36;
        } else {
            eax = 0xfffff1ec;
            if ((ecx & 0x240a) == 0) {
                goto L35;
            } else {
                flags = LOGICALFLAGS32(ecx & 0xfffff1ec);
                if ((unsigned int)(ecx & 0xfffff1ec) <= 0) {
                    eax = (local2);
                    eax = eax ^ 0x1666;
                    goto L36;
                }
            }
        }
    }
    eax = eax - CF - 1919 | 0x3596;
    if (eax > 0) {
L29:
    } else {
        if ((edx & 0x140b) == 0) {
            goto L29;
        }
    }
    esp = proc13(); /* Warning: also results in ebp */
    local8 = 30;
    proc14();
    local8 = ebp - 600;
    *(__size32*)(esp - 8) = 0;
    *(union { __size32 * x5301; int x5302; }*)(esp - 12) = ebp - 392;
    eax = proc6();
    local8 = 0;
    *(int*)(esp - 8) = eax ^ 0x3558;
    *(int*)(esp - 12) = eax ^ 0x3558;
    proc2();
    local8 = 55;
    proc14();
    local8 = 0;
    *(__size32*)(esp - 8) = 61;
    *(__size32*)(esp - 12) = 0xe15927e4;
    proc10();
    local8 = ebp - 212;
    *(__size32*)(esp - 8) = 0;
    *(union { __size32 * x5305; int x5306; }*)(esp - 12) = ebp - 476;
    proc6();
    local8 = (eax | 0x1704) - LOGICALFLAGS32(eax | 0x1704) - 0x2344 | 0x1d17;
    *(__size32*)(esp - 8) = 1;
    *(__size32*)(esp - 12) = 0;
    proc4();
    *(__size32*)(ebp - 604) = *(ebp - 604) - eax + LOGICALFLAGS32(0);
    local8 = ebp - 284;
    *(__size32*)(esp - 8) = 0;
    *(union { __size32 * x5279; int x5280; }*)(esp - 12) = ebp - 492;
    proc6();
    local8 = 0;
    *(union { __size32 * x5281; int x5282; }*)(esp - 8) = ebp - 428;
    *(__size32*)(esp - 12) = 0xa798f85f;
    *(__size32*)(esp - 16) = edx;
    proc1(ebp - 428);
    local8 = edx;
    *(__size32*)(esp - 8) = 0;
    *(__size32*)(esp - 12) = 0;
    proc5();
    local8 = 0;
    *(union { __size32 * x5285; int x5286; }*)(esp - 8) = ebp - 596;
    *(__size32*)(esp - 12) = 0x350e6fec;
    *(__size32*)(esp - 16) = *(ebp - 56);
    proc1((eax | 0x27d6) + LOGICALFLAGS32(eax | 0x27d6) + 0x3eb4);
    local8 = eax ^ 0x3f83;
    *(__size32*)(esp - 8) = 31;
    *(__size32*)(esp - 12) = 0;
    proc4();
    local8 = 0xcfa4f009;
    *(__size32*)(esp - 8) = 0;
    *(__size32*)(esp - 12) = ecx;
    proc5();
    local8 = 38;
    proc14();
    *(__size32*)(ebp - 428) = *(ebp - 428) - eax + LOGICALFLAGS32(eax_3 ^ 0x29b4);
    local8 = 0;
    *(__size32*)(esp - 8) = 0;
    *(__size32*)(esp - 12) = 0;
    proc5();
    return;
}

// address: 0x4021d3
__size32 proc4() {
    int eax; 		// r24
    __size32 eax_1; 		// r24{22}
    union { int x287; bool x288; } eax_2; 		// r24{61}
    int ecx; 		// r25
    int edx; 		// r26
    void *esp; 		// r28
    int local0; 		// m[esp - 400]
    unsigned short local1; 		// m[esp - 48]

    eax = (local1);
    eax_2 = eax + ((esp - 4) < 512) + 93;
    eax_1 = ((eax_2 | 0x14cb) ^ 0x30cd) + 0xa27;
    eax = eax_1 + 0x19a6;
    if (ecx >= 0) {
        eax = ((eax_2 | 0x14cb) ^ 0x30cd) + 0x4de3;
        eax = eax - ADDFLAGS32(((eax_2 | 0x14cb) ^ 0x30cd) + 0x23cd, 0x2a16, eax) - 0x1685;
        tmp1 = local0 & edx;
        if (tmp1 <= 0) {
            eax = (eax - ADDFLAGS32(((eax_2 | 0x14cb) ^ 0x30cd) + 0x23cd, 0x2a16, eax) - 0x1685 & 0x1e85) + 0x330e;
        }
    }
    eax = proc1(eax);
    return eax; /* WARNING: Also returning: ecx := (esp - 428) */
}

// address: 0x404603
int proc5() {
    unsigned int eax; 		// r24
    unsigned int eax_1; 		// r24{26}
    unsigned int eax_2; 		// r24{53}
    unsigned int eax_3; 		// r24{79}
    int ecx; 		// r25
    unsigned int edx; 		// r26
    unsigned char local0; 		// m[esp - 172]
    unsigned int local1; 		// m[esp - 92]
    unsigned short local2; 		// m[esp - 748]
    __size32 local3; 		// m[esp - 400]
    unsigned short local4; 		// m[esp - 440]
    int local5; 		// m[esp - 540]
    __size32 local6; 		// m[esp - 400]{115}

    eax = proc14();
    local6 = local3 + (eax ^ 0x2fa5);
    eax = ((eax ^ 0x2fa5) + ADDFLAGS32(local3, eax ^ 0x2fa5, local6) + 0x506f ^ 0xffb) + LOGICALFLAGS32((eax ^ 0x2fa5) + ADDFLAGS32(local3, eax ^ 0x2fa5, local6) + 0x506f ^ 0xffb) + 0x3685;
    if ((ecx & 0x12c4) != 0) {
L8:
        eax = (eax & 0x216c) + LOGICALFLAGS32(eax & 0x216c) + 0x100f;
L7:
        eax = eax & local5;
L6:
        eax += 0xcb2;
L5:
        flags = LOGICALFLAGS32(eax + 0x9ca & 0x1245);
        eax = (local4);
    } else {
        eax_1 = (local0);
        eax = eax_1 + ADDFLAGS32(eax_1, 0x220b, eax_1 + 0x220b) + 0x42a6;
        if ((unsigned int)(ecx & eax_1 + ADDFLAGS32(eax_1, 0x220b, eax_1 + 0x220b) + 0x42a6) > 0) {
            goto L7;
        } else {
            eax = eax_1 + ADDFLAGS32(eax_1, 0x220b, eax_1 + 0x220b) + LOGICALFLAGS32(ecx & eax_1 + ADDFLAGS32(eax_1, 0x220b, eax_1 + 0x220b) + 0x42a6) + 0x47a6;
            if (edx != 0) {
                goto L6;
            } else {
                eax_2 = (local2);
                eax = eax_2 - 0x2933;
                if ((unsigned int)(eax_2 - 0x2933) > 0) {
                    goto L5;
                } else {
                    eax = eax_2 - 0x2933 ^ 0x1eb7;
                    tmp1 = edx - (eax_2 - 0x2933 ^ 0x1eb7);
                    flags = SUBFLAGS32(edx, eax_2 - 0x2933 ^ 0x1eb7, tmp1);
                    if (edx == (eax_2 - 0x2933 ^ 0x1eb7)) {
                        eax = (eax_2 - 0x2933 ^ 0x1eb7) + (edx < (unsigned int)(eax_2 - 0x2933 ^ 0x1eb7)) + 0x2e62;
                        eax += 1568;
                        goto L8;
                    }
                }
            }
        }
    }
    eax_3 = eax - CF + (eax < 0xa24) - 0x3120;
    eax = eax_3 + (eax_3 < 0x151d) - 194;
    eax = eax + ADDFLAGS32(eax_3 - 0x151d, 0x145b, eax) + 0x2c6f & 0xf71;
    if ((unsigned int)(ecx & 0x33fc) < 0) {
L1:
        eax = (eax + ADDFLAGS32(eax_3 - 0x151d, 0x145b, eax) + 0x2c6f & 0xf71) - (local1 < (unsigned int)(eax + ADDFLAGS32(eax_3 - 0x151d, 0x145b, eax) + 0x2c6f & 0xf71)) - 0x20de;
    } else {
        if (edx <= 0) {
            goto L1;
        }
    }
    return eax;
}

// address: 0x402df7
int proc6() {
    __size32 eax; 		// r24
    union { unsigned int x640; bool x641; } eax_1; 		// r24{3521}
    unsigned int eax_10; 		// r24{3809}
    unsigned int eax_11; 		// r24{3485}
    int eax_13; 		// r24{3125}
    unsigned int eax_14; 		// r24{3139}
    unsigned int eax_15; 		// r24{3647}
    int eax_16; 		// r24{2958}
    int eax_2; 		// r24{3200}
    unsigned int eax_4; 		// r24{1439}
    __size32 eax_5; 		// r24{1873}
    __size32 eax_6; 		// r24{2407}
    int eax_7; 		// r24{2158}
    int eax_8; 		// r24{1722}
    unsigned int eax_9; 		// r24{3872}
    unsigned int ecx; 		// r25
    unsigned int edx; 		// r26
    int esp; 		// r28
    unsigned int local0; 		// m[esp - 472]
    unsigned int local1; 		// m[esp - 172]
    unsigned int local10; 		// m[esp - 80]
    unsigned int local11; 		// m[esp - 428]
    int local12; 		// m[esp - 488]
    unsigned int local13; 		// m[esp - 168]
    unsigned short local14; 		// m[esp - 504]
    unsigned int local15; 		// m[esp - 296]
    int local16; 		// m[esp - 384]
    unsigned int local17; 		// m[esp - 524]
    unsigned int local18; 		// m[esp - 360]
    unsigned int local19; 		// m[esp - 352]
    unsigned int local2; 		// m[esp - 432]
    int local20; 		// m[esp - 92]
    unsigned int local21; 		// m[esp - 444]
    unsigned char local22; 		// m[esp - 424]
    int local23; 		// m[esp - 340]
    int local24; 		// m[esp - 456]
    __size32 local25; 		// m[esp - 60]
    int local26; 		// m[esp - 212]
    unsigned int local27; 		// m[esp - 112]
    __size32 local28; 		// m[esp - 272]
    int local29; 		// m[esp - 372]
    unsigned int local3; 		// m[esp - 264]
    unsigned int local30; 		// m[esp - 448]
    union { __size32 x570; bool x571; bool x569; bool x567; bool x565; } local31; 		// m[esp - 500]
    unsigned int local32; 		// m[esp - 200]
    int local33; 		// m[esp - 404]
    int local34; 		// m[esp - 228]
    int local35; 		// m[esp - 36]
    unsigned int local36; 		// m[esp - 324]
    int local37; 		// m[esp - 208]
    unsigned short local38; 		// m[esp - 32]
    int local39; 		// m[esp - 136]
    unsigned int local4; 		// m[esp - 512]
    unsigned int local40; 		// m[esp - 388]
    unsigned short local41; 		// m[esp - 368]
    unsigned int local42; 		// m[esp - 168]{3488}
    unsigned int local43; 		// m[esp - 296]{912}
    unsigned int local44; 		// m[esp - 312]{1903}
    unsigned int local5; 		// m[esp - 240]
    unsigned int local53; 		// eax{3896}
    unsigned char local6; 		// m[esp - 116]
    unsigned int local7; 		// m[esp - 164]
    unsigned int local8; 		// m[esp - 312]
    unsigned int local9; 		// m[esp - 188]

    proc2();
    proc3();
    proc3();
    proc11();
    eax = proc3(); /* Warning: also results in ecx, edx */
    local43 = local15 ^ eax;
    proc5();
    if (ecx <= edx) {
    }
    GetCurrentThreadId();
    proc8();
    eax = proc2();
    proc1(eax);
    proc8();
    proc2();
    eax = (local22);
    flags = LOGICALFLAGS32(0);
    CF = LOGICALFLAGS32(eax & 0x2f25);
    eax = GetCommandLineA();
    eax = eax - CF - 0x167f & 0x32af;
    eax_1 = ((eax ^ 0x1ce7) & 0x3fdb) + (local30 < (unsigned int)((eax ^ 0x1ce7) & 0x3fdb)) + 453;
    eax = eax_1 - 0x3eff;
    flags = LOGICALFLAGS32(eax_1 - 0x3eff);
    if (eax_1 - 0x3eff < 0) {
L428:
        eax = eax_1 + CF - 0x25bd;
    } else {
        flags = LOGICALFLAGS32(eax_1 - 0x3eff & 0x3f58);
        if ((eax_1 - 0x3eff & 0x3f58) == 0) {
            goto L428;
        }
    }
    proc1(eax);
    proc2();
    proc5();
    ecx = GetCurrentThreadId();
    proc2();
    if ((ecx & 0x3af2) == 0) {
L414:
    } else {
        if ((unsigned int)(ecx & 0x3ab6) >= 0) {
            goto L414;
        }
    }
    eax = proc3(); /* Warning: also results in ecx, edx */
    if ((unsigned int)(eax - 0x1f37) > local5) {
L410:
    } else {
        if (ecx == edx) {
            goto L410;
        }
    }
    proc8();
    proc3();
    proc8();
    proc11();
    ecx = GetCommandLineA(); /* Warning: also results in edx */
    eax_2 = proc5();
    eax = proc5();
    if (edx == 0) {
L394:
L393:
L392:
    } else {
        if (ecx < (unsigned int)(((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local26) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) - 0x20a1)) {
            goto L393;
        } else {
            if (ecx < 0) {
                goto L392;
            } else {
                if (((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local26) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) + LOGICALFLAGS32(((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local26) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) - 0x20a1) + LOGICALFLAGS32(ecx) + 0x20a4 >= local27) {
                    local1 = local1 & ((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local26) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) + LOGICALFLAGS32(((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local26) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) - 0x20a1) + LOGICALFLAGS32(ecx) + 0x20a4;
                    local2 = local2 & ((LOGICALFLAGS32(0) + 1205 | 0x3349) - local28 + LOGICALFLAGS32(LOGICALFLAGS32(0) + 1205 | 0x3349) ^ 0x38cd);
                    goto L394;
                }
            }
        }
    }
    proc1((esp - 420));
    proc8();
    GetCurrentThreadId();
    proc3();
    proc14();
    eax = GetLastError(); /* Warning: also results in ecx */
    if (eax == ecx) {
    }
    proc14();
    proc8();
    proc3();
    proc8();
    eax = proc11();
    proc1(eax - 1632);
    proc3();
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    eax = (local41);
    if ((unsigned int)(eax + 0x239a & 0x2f0e) > 0) {
L362:
L361:
L360:
    } else {
        tmp1 = ecx & eax - 0x139d & 0x3b11;
        if (tmp1 < 0) {
            goto L361;
        } else {
            if (ecx != edx || edx < local0) {
                goto L360;
            } else {
                if ((unsigned int)(edx & 0x51f) <= 0) {
                    goto L362;
                }
            }
        }
    }
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    if (edx < local5) {
L352:
L351:
    } else {
        tmp1 = 0 - (local21 < 0x324b) & ecx;
        if (tmp1 > 0) {
            goto L352;
        } else {
            eax = 0 - (local21 < 0x324b) & 0x2266;
            if (edx > ecx) {
                goto L352;
            } else {
                if ((edx & (eax | 0x1196)) == 0) {
                    goto L351;
                } else {
                    if (ecx == 0) {
                        goto L352;
                    }
                }
            }
        }
    }
    GetLastError();
    ecx = GetCommandLineA();
    proc5();
    eax = (local0);
    if ((eax - LOGICALFLAGS32(0) - 0x29ec ^ 0xd13 ^ local35) == 0) {
    }
    if ((int)local18 >= ecx) {
    }
    GetCurrentThreadId();
    proc5();
    eax = proc2();
    proc1(eax & 0x390d);
    proc11();
    if ((esp - 220) < 0) {
L327:
    } else {
        eax = (local1);
        if (eax <= esp - 220) {
            goto L327;
        }
    }
    eax = proc1(esp - 472);
    proc1((eax - 0x1f7b & 0x79a) + 0x1176);
    GetCurrentThreadId();
    proc8();
    GetCurrentThreadId();
    proc11();
    proc3();
    eax = proc5();
    eax_4 = proc1(eax + 0x31e1 | 0x3f82);
    eax = GetLastError(); /* Warning: also results in ecx, edx */
    eax = eax + (eax_4 < 0x31c5) + 79;
    if ((unsigned int)(edx & ecx) < 0) {
L305:
    } else {
        if (((eax & 0x3ea0) + LOGICALFLAGS32(local1 | (eax & 0x3ea0) - LOGICALFLAGS32(eax & 0x3ea0) - 0x1933) - LOGICALFLAGS32(eax & 0x3ea0) - 0xd22 ^ 0x11ac) == 0) {
            goto L305;
        }
    }
    GetCurrentThreadId();
    proc11();
    proc3();
    proc8();
    GetLastError();
    proc1((esp - 460));
    eax_5 = proc14();
    eax = proc3(); /* Warning: also results in edx */
    eax = proc2();
    local44 = local8 + (eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) - ADDFLAGS32(eax, 478, eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) + 478) - 0x2fe7 ^ 0x34fe);
    if ((edx & 0x2dc0) != 0) {
L289:
    } else {
        if ((unsigned int)(eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) - ADDFLAGS32(eax, 478, eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) + 478) - 0x2fe7 ^ 0x34fe) >= 0) {
            goto L289;
        }
    }
    proc14();
    if (local2 <= edx) {
    }
    proc14();
    if ((edx & 0x1a37) != 0) {
L279:
    } else {
        if (edx <= 0) {
            goto L279;
        }
    }
    edx = GetCurrentThreadId();
    proc14();
    proc5();
    proc11();
    proc14();
    proc8();
    eax_6 = proc14();
    eax = proc14();
    eax = eax + (eax_6 + 0x345e < 0x21e8) + 0x3273;
    eax = eax | local21;
    if (edx != 0) {
L265:
    } else {
        eax = (eax | 0x338b) + ((unsigned int)(eax | 0x338b) < 0xe4a) + 0x2e24;
        if (eax >= 0) {
            goto L265;
        }
    }
    eax = proc5();
    proc1(eax + LOGICALFLAGS32(0) - local3 + LOGICALFLAGS32(0) + ADDFLAGS32(eax - local3 + LOGICALFLAGS32(0), 0xf8f, eax + LOGICALFLAGS32(0) - local3 + LOGICALFLAGS32(0) + 0xf8f) - 0xbbb);
    GetLastError();
    proc1(0);
    eax = (local4);
    if ((eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + ADDFLAGS32(eax & 0x487, 0x306f, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + 0x306f) - ADDFLAGS32((eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + ADDFLAGS32(eax & 0x487, 0x306f, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + 0x306f) + 0x6b4f, 0x2a26, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + ADDFLAGS32(eax & 0x487, 0x306f, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + 0x306f) + 0x9575) + ((eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + ADDFLAGS32(eax & 0x487, 0x306f, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + 0x306f) + 0x9575 < 0x192e) + 0x59d9 <= esp - 372) {
    }
    eax = proc5();
    if ((eax & 0xc89) != 0) {
L252:
    } else {
        if ((eax & 0x25e1) != 0) {
            goto L252;
        }
    }
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    proc1((esp - 364));
    eax = proc14();
    eax_7 = eax + (ecx < 0) + 0x32f0;
    eax = (eax_7 & 0x435) - 0x2fbe;
    if (0 == edx) {
        eax = (eax_7 & 0x435) + ((unsigned int)((eax_7 & 0x435) - 0x2fbe) < 0x3901) - 0x5878;
    }
    proc1(eax);
    proc8();
    ecx = GetLastError(); /* Warning: also results in edx */
    eax = proc8();
    eax_8 = eax | local29;
    eax = eax_8 + LOGICALFLAGS32(eax_8) + 0x14dd & 0x131b;
    if (edx > (unsigned int)(eax_8 + LOGICALFLAGS32(eax_8) + 0x14dd & 0x131b)) {
L227:
        eax_9 = eax;
        eax = (eax_9 | 0xa08) - 0x575a;
        flags = SUBFLAGS32((eax_9 | 0xa08) - 0x2d81, 0x29d9, (eax_9 | 0xa08) - 0x575a);
L226:
        eax = eax - CF - 0x1cfb;
L225:
        eax = eax - local36 - 0x3df8;
        local44 = local8 + (eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) - ADDFLAGS32(eax, 478, eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) + 478) - 0x2fe7 ^ 0x34fe) - eax;
    } else {
        flags = LOGICALFLAGS32(ecx);
        if (ecx != 0) {
            goto L226;
        } else {
            eax = (local18);
            flags = LOGICALFLAGS32(ecx & 0x3b81);
            if ((unsigned int)(ecx & 0x3b81) > 0) {
                goto L226;
            } else {
                eax = eax - 464;
                if (edx > ecx) {
                    goto L225;
                } else {
                    if ((unsigned int)(edx & 0x2830) >= 0) {
                        eax = (local11);
                        local12 = local12 ^ eax;
                        eax = eax + LOGICALFLAGS32(local12) + 0xf4a ^ 1551;
                        goto L227;
                    }
                }
            }
        }
    }
    eax = proc8();
    eax = eax | local23;
    local24 = local24 & eax;
    if (edx != (eax + (eax < 1225) + local31 + ADDFLAGS32(eax + (eax < 1225) - LOGICALFLAGS32(local24) + 1454, local31, eax + (eax < 1225) + local31 - LOGICALFLAGS32(local24) + 1454) - LOGICALFLAGS32(local24) + 0x371d ^ 966)) {
L219:
    } else {
        if ((ecx & 0x2e21) == 0) {
            goto L219;
        }
    }
    proc2();
    proc14();
    if ((unsigned int)(ecx & 0x24d2) < 0) {
L211:
L210:
L209:
    } else {
        if ((ecx & 0x3c8f) != 0) {
            goto L210;
        } else {
            eax = (local3);
            if ((unsigned int)(edx & eax + 0x20b3) < 0) {
                goto L209;
            } else {
                if ((eax + 0x20b3 & 0x27bd) >= 0) {
                    goto L211;
                }
            }
        }
    }
    proc2();
    GetCurrentThreadId();
    proc5();
    proc5();
    proc11();
    proc2();
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    eax = proc1(esp - 512);
    local20 = local20 & eax;
    eax_11 = eax + 0x18f1 & 0x1e04 & 0x24e8;
    local42 = local13 - eax_11 + LOGICALFLAGS32(eax_11);
    local53 = eax_11;
    if (ecx <= 0) {
        eax = eax_11 - LOGICALFLAGS32(ecx) - 0x3feb;
        local53 = eax;
    }
    eax = local53;
    eax = (eax | 0x31c6) - LOGICALFLAGS32(eax | 0x31c6) - 0x8d4;
    if ((unsigned int)(ecx & edx) < 0) {
L188:
        eax_10 = eax;
        local42 = local13 - eax_11 + LOGICALFLAGS32(eax_11) | (eax_10 & 0x1d4) - ADDFLAGS32(eax_10 & 0x1d4, 0x28da, (eax_10 & 0x1d4) + 0x28da) - 0xcd2;
    } else {
        if (((eax | 0x31c6) - LOGICALFLAGS32(eax | 0x31c6) - 0x8d4 & 0xad8) < 0) {
            goto L188;
        } else {
            eax = (eax | 0x31c6) - LOGICALFLAGS32(eax | 0x31c6) + 0x2e1b;
            if (local20 != ecx) {
                goto L188;
            } else {
                if (edx >= ((eax | 0x31c6) - LOGICALFLAGS32(eax | 0x31c6) + local34 + 0x3ddd & 0x240a ^ local26)) {
                    eax = (local38);
                    local9 = local9 & (eax ^ 0x3301) - 0x26f2;
                    eax = (local10);
                    goto L188;
                }
            }
        }
    }
    eax = (local14);
    tmp1 = local39 & eax + 0xe37;
    if (tmp1 < 0) {
L183:
    } else {
        if (ecx != eax + 0xe37) {
            goto L183;
        }
    }
    GetCommandLineA();
    proc11();
    proc5();
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    if ((unsigned int)(edx & 0x366a) <= 0) {
        if (ecx <= edx) {
        }
    }
    proc14();
    proc8();
    GetCurrentThreadId();
    proc5();
    proc1((esp - 268));
    GetCurrentThreadId();
    proc5();
    eax = (local32);
    proc1(eax);
    proc3();
    proc3();
    eax = GetCommandLineA(); /* Warning: also results in edx */
    if ((unsigned int)(edx & 0x120f) < 0) {
L152:
    } else {
        if (((eax - ADDFLAGS32(local25, 0, local25 + LOGICALFLAGS32(0)) - 0xc11 | 0x3481) - LOGICALFLAGS32(edx & 0x120f) - 0x3d21 | 271) >= edx) {
            goto L152;
        }
    }
    proc14();
    eax = proc5();
    local16 = local16 | eax;
    proc11();
    GetCurrentThreadId();
    proc5();
    proc3();
    proc1((local17));
    proc3();
    proc3();
    proc8();
    eax = proc1(esp - 92);
    local19 = local19 - eax;
    GetLastError();
    proc2();
    ecx = proc3();
    if ((unsigned int)(ecx & 0x1f04) > 0) {
L129:
    } else {
        if (ecx >= 0) {
            goto L129;
        }
    }
    GetLastError();
    proc5();
    proc1(0);
    GetCurrentThreadId();
    proc11();
    ecx = proc3();
    proc14();
    eax = proc2();
    eax = proc1(eax - LOGICALFLAGS32(0) - 173 & 0x3e12);
    local23 += eax + (ecx < 0);
    proc11();
    proc8();
    proc2();
    proc14();
    eax = GetCurrentThreadId();
    proc1(eax);
    proc14();
    proc11();
    proc5();
    proc5();
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    proc14();
    eax = (local42);
    if (eax != edx) {
L94:
L93:
L92:
L91:
    } else {
        eax = (local23);
        if (edx < 0) {
            goto L93;
        } else {
            tmp1 = local16 & edx;
            if (tmp1 != 0) {
                goto L92;
            } else {
                local15 = local43 + eax - 0x109a;
                if ((eax - ADDFLAGS32(local43, eax - 0x109a, local15) - 0x2618 & 0x50 & 0x3597) != 0) {
                    goto L91;
                } else {
                    if ((unsigned int)(ecx & 0x33ae) >= 0) {
                        goto L94;
                    }
                }
            }
        }
    }
    eax = proc11();
    if (ecx < 0) {
L84:
    } else {
        if ((eax ^ 1442) - 1650 != 0) {
            goto L84;
        }
    }
    eax = proc8();
    eax = eax - (edx < 0) - 0x1cab;
    flags = SUBFLAGS32(eax, 0, eax);
    if (eax < 0) {
L78:
        eax_15 = eax;
        eax_14 = eax_15 + CF + 0x126f;
        flags = ADDFLAGS32(eax_15, 0x126f, eax_15 + CF + 0x126f);
    } else {
        eax_13 = (eax + 1487 | 372) + 0x1fff;
        eax = (eax_13 | 0x3d73) + LOGICALFLAGS32(eax_13 | 0x3d73) + 0x38bb;
        flags = SUBFLAGS32(0, (eax_13 | 0x3d73) + LOGICALFLAGS32(eax_13 | 0x3d73) + 0x38bb, 0xffffc745 - (eax_13 | 0x3d73) + LOGICALFLAGS32(eax_13 | 0x3d73));
        if (0 < (eax_13 | 0x3d73) + LOGICALFLAGS32(eax_13 | 0x3d73) + 0x38bb) {
            goto L78;
        } else {
            eax_14 = (local9);
            flags = LOGICALFLAGS32(ecx);
            if (ecx <= 0) {
                eax = eax_14 + 0x1c6e;
                flags = ADDFLAGS32(eax_14, 0x1c6e, eax_14 + 0x1c6e);
                goto L78;
            }
        }
    }
    eax = eax_14 - CF + local44 - 0x1b71;
    if ((ecx & eax) < 0) {
L72:
    } else {
        eax = eax ^ local33;
        if (ecx == eax - 0x21ed) {
            goto L72;
        }
    }
    proc1(0);
    proc11();
    proc3();
    eax = GetCurrentThreadId();
    tmp1 = (eax + 0x3d13 ^ 0xf27) & 0x695;
    if (tmp1 != 0) {
L63:
    } else {
        tmp1 = (eax + 0x3d13 ^ 0xf27) & 0x3aa0;
        if (tmp1 != 0) {
            goto L63;
        }
    }
    proc14();
    edx = GetCurrentThreadId();
    if (edx == 0) {
L58:
    } else {
        if (edx >= local19) {
            goto L58;
        }
    }
    proc8();
    proc11();
    eax_16 = proc11();
    eax = eax_16 - 0x237f & 0x2f2a ^ 0x33c3;
    eax = (local42);
    if (local4 != eax + LOGICALFLAGS32(eax ^ 0x2b27) + local10 + ADDFLAGS32(eax, 0x832, eax + LOGICALFLAGS32(eax ^ 0x2b27) + 0x832) + ADDFLAGS32(eax + LOGICALFLAGS32(eax_16 - 0x237f & 0x2f2a ^ 0x33c3 ^ 0x2b27) + 0x832, local10, eax + LOGICALFLAGS32(eax ^ 0x2b27) + local10 + ADDFLAGS32(eax, 0x832, eax + LOGICALFLAGS32(eax ^ 0x2b27) + 0x832) + 0x832) + 0x1499) {
L47:
L45:
    } else {
        if (eax + LOGICALFLAGS32(eax ^ 0x2b27) + local10 + ADDFLAGS32(eax, 0x832, eax + LOGICALFLAGS32(eax ^ 0x2b27) + 0x832) + ADDFLAGS32(eax + LOGICALFLAGS32(eax_16 - 0x237f & 0x2f2a ^ 0x33c3 ^ 0x2b27) + 0x832, local10, eax + LOGICALFLAGS32(eax ^ 0x2b27) + local10 + ADDFLAGS32(eax, 0x832, eax + LOGICALFLAGS32(eax ^ 0x2b27) + 0x832) + 0x832) + 0x1499 < edx) {
            goto L45;
        } else {
            if ((unsigned int)(edx & 0xd50) <= 0) {
                goto L47;
            }
        }
    }
    GetCurrentThreadId();
    proc1((esp - 288));
    proc11();
    proc2();
    GetCurrentThreadId();
    proc1((esp - 332));
    proc2();
    proc5();
    proc2();
    eax = (local6);
    if (0 <= (unsigned int)(eax & 0xe15)) {
    }
    proc1((esp - 68));
    proc14();
    GetCurrentThreadId();
    proc5();
    proc8();
    ecx = GetLastError(); /* Warning: also results in edx */
    eax = proc2();
    eax = (eax ^ 1033 | 0x31a6) + LOGICALFLAGS32(eax ^ 1033 | 0x31a6) + ADDFLAGS32(eax ^ 1033 | 0x31a6, 0xf33, (eax ^ 1033 | 0x31a6) + LOGICALFLAGS32(eax ^ 1033 | 0x31a6) + 0xf33) + 0x4662;
    tmp1 = local40 & ecx;
    if (tmp1 >= 0) {
        tmp1 = local37 & edx;
        if (tmp1 <= 0) {
            eax = (local6);
        }
    }
    proc1(eax);
    proc2();
    proc11();
    proc2();
    if (local5 == edx) {
    }
    proc11();
    eax = proc3(); /* Warning: also results in ecx, edx */
    return eax - 0x167e & 0xcde; /* WARNING: Also returning: ecx := ecx, edx := edx */
}

// address: 0x404f48
__size32 proc7() {
    union { void * x5695; int x5696; } eax; 		// r24
    int ecx; 		// r25
    int edx; 		// r26
    void *esp; 		// r28
    int local0; 		// m[esp - 48]

    proc11();
    eax = proc8();
    if (((eax ^ 0x30ec) & 0x29ee) == 0) {
L9:
L8:
    } else {
        if (edx != (eax ^ 0x30ec)) {
            goto L8;
        } else {
            if ((unsigned int)(eax ^ 0x30ec) <= ecx) {
                goto L9;
            }
        }
    }
    ecx = proc6(); /* Warning: also results in edx */
    if ((unsigned int)(ecx & 0xea1) < 0) {
L2:
    } else {
        if (local0 == edx) {
            goto L2;
        }
    }
    eax = proc1((esp - 292));
    return eax;
}

// address: 0x4023d2
int proc8() {
    int eax; 		// r24
    int eax_1; 		// r24{30}
    unsigned int ecx; 		// r25
    int edx; 		// r26
    unsigned int local0; 		// m[esp - 420]
    unsigned char local1; 		// m[esp - 128]
    int local2; 		// m[esp - 260]

    if ((ecx & edx) == 0) {
    }
    eax = (local1);
    eax_1 = (eax ^ 0x256b) - local2;
    if ((eax_1 & 0x1684) == 0) {
L1:
        eax = eax_1 | 0x39a6;
    } else {
        eax = (eax_1 & 0x23a ^ 0x3c0c) + LOGICALFLAGS32(eax_1 & 0x23a ^ 0x3c0c) + 0x2038;
        if (local0 >= ecx) {
            eax_1 = (eax_1 & 0x23a ^ 0x3c0c) + LOGICALFLAGS32(eax_1 & 0x23a ^ 0x3c0c) + 0x2038 & 0x3890 | 0xae2;
            goto L1;
        }
    }
    return eax;
}

// address: 0x4038b2
__size32 proc9() {
    int eax; 		// r24
    unsigned int ecx; 		// r25
    int local0; 		// m[esp - 160]
    int local1; 		// m[esp - 400]
    unsigned int local2; 		// m[esp - 64]

    eax = proc7();
    proc1(eax & 0x25bd);
    proc11();
    proc3();
    proc2();
    ecx = proc4();
    proc5();
    proc5();
    proc2();
    if (ecx <= 0) {
    }
    proc5();
    proc5();
    eax = proc5();
    if ((ecx & eax) == 0) {
L14:
L13:
    } else {
        if (0 == local0) {
            goto L13;
        } else {
            tmp1 = local1 & ecx;
            if (tmp1 <= 0) {
                goto L14;
            }
        }
    }
    proc2();
    proc2();
    if (0 <= local2) {
    }
    proc11();
    proc14();
    return 0;
}

// address: 0x4050a4
int proc10() {
    int eax; 		// r24
    __size32 ecx; 		// r25

    if ((ecx & 0x33a8) != 0) {
L1:
        eax = (eax | 566) - LOGICALFLAGS32(eax | 566) - 0x2dcd ^ 0x2d49;
    } else {
        if ((ecx & 0xc1) == 0) {
            eax = 0;
            goto L1;
        }
    }
    return eax;
}

// address: 0x404eee
unsigned int proc11() {
    unsigned int eax; 		// r24
    unsigned int eax_1; 		// r24{48}
    void *esp; 		// r28
    unsigned short local0; 		// m[esp - 128]
    int local1; 		// m[esp - 48]
    int local2; 		// m[esp - 572]
    unsigned short local3; 		// m[esp - 40]

    eax = eax + ((esp - 4) < 808) + 0x1733;
    local2 = local2 ^ eax;
    eax_1 = (local3);
    eax = eax_1 + LOGICALFLAGS32(local2) + 0x3992 & 0x3b14;
    if ((unsigned int)(eax_1 + LOGICALFLAGS32(local2) + 0x3992 & 0x3b14) < 0) {
L1:
        eax = eax & 0x16c8 ^ 0x3157;
    } else {
        eax = (local0);
        if ((unsigned int)(eax & 0x3a72) <= 0) {
            eax = eax & local1;
            eax = (eax ^ 0x3293) + LOGICALFLAGS32(eax ^ 0x3293) + 0x1105;
            goto L1;
        }
    }
    return eax;
}

// address: 0x404d68
unsigned int proc12() {
    __size32 eax; 		// r24
    __size32 eax_1; 		// r24{491}
    int eax_2; 		// r24{980}
    int eax_3; 		// r24{85}
    int eax_4; 		// r24{669}
    __size32 eax_5; 		// r24{846}
    __size32 eax_6; 		// r24{510}
    unsigned int eax_7; 		// r24{1050}
    int eax_8; 		// r24{729}
    unsigned int ecx; 		// r25
    int edx; 		// r26
    void *esp; 		// r28
    __size32 local0; 		// m[esp - 256]
    void *local1; 		// m[esp - 12]
    __size32 local10; 		// m[esp - 244]
    unsigned int local11; 		// m[esp - 248]
    unsigned int local12; 		// m[esp - 284]
    __size32 local13; 		// m[esp - 320]
    __size32 local14; 		// m[esp - 360]
    unsigned int local15; 		// m[esp - 188]
    unsigned char local16; 		// m[esp - 232]
    unsigned char local17; 		// m[esp - 116]
    unsigned char local18; 		// m[esp - 136]
    unsigned short local19; 		// m[esp - 152]
    int local2; 		// m[esp - 104]
    unsigned char local20; 		// m[esp - 76]
    __size32 local21; 		// m[esp - 200]
    unsigned int local22; 		// m[esp - 248]{1184}
    unsigned int local3; 		// m[esp - 228]
    unsigned int local4; 		// m[esp - 296]
    unsigned int local5; 		// m[esp - 16]
    __size32 local6; 		// m[esp - 20]
    int local7; 		// m[esp - 56]
    int local8; 		// m[esp - 168]
    __size32 local9; 		// m[esp - 172]

    proc14();
    proc2();
    proc14();
    proc11();
    proc5();
    proc2();
    eax_1 = proc8();
    eax = proc2();
    eax = eax - (eax_1 + 0x4cd5 < 0) - 0x33e7;
    if ((edx & 0x8da) != 0) {
L107:
    } else {
        if (eax + LOGICALFLAGS32(edx & 0x8da) + ADDFLAGS32(eax, 0x139a, eax + LOGICALFLAGS32(edx & 0x8da) + 0x139a) + 0x3213 <= local4) {
            goto L107;
        }
    }
    proc11();
    eax = (local16);
    if ((unsigned int)(eax & 0x1f1c) < 0) {
L103:
    } else {
        if ((unsigned int)(edx & (eax ^ 0x3763)) <= 0) {
            goto L103;
        }
    }
    eax = proc8();
    if (edx >= (unsigned int)(eax - local15 + ADDFLAGS32(eax, 0x1c03, eax + 0x1c03) + (eax + 0x1c03 < local15) - 2047)) {
        tmp1 = local7 & edx;
        if (tmp1 >= 0) {
        }
    }
    proc8();
    proc2();
    if (ecx != edx) {
L89:
    } else {
        if ( !(ecx < edx || (unsigned int)(ecx & 0x3de4) > 0)) {
            goto L89;
        }
    }
    proc14();
    proc5();
    do {
        local22 = local11;
        proc16();
        proc2();
        proc8();
        proc8();
        proc1(eax - LOGICALFLAGS32(eax_2 | 0x1e8c) - 0x144d | 896);
        eax = (eax_3 | 0x2f6f) & 0xb97;
        if (((esp - 144) & edx) != 0) {
L73:
            eax = (eax + 0x97c | 0x3192) + 1676;
            local2 += eax;
        } else {
            eax = ((eax_3 | 0x2f6f) & 0xb97) + 0x2512;
            if ((unsigned int)((eax & 0x17e1) - LOGICALFLAGS32(eax & 0x17e1) - 0x1919 & 0x3f8d) >= 0) {
                eax = (eax & 0x17e1) - LOGICALFLAGS32(eax & 0x17e1) - 0x58a0;
                goto L73;
            }
        }
        proc14();
        proc2();
        proc8();
        local11 = local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252);
        local7 = local7 | (eax_4 & 0x1252) - 0x2e8d;
        if ((unsigned int)((eax_4 & 0x1252) + LOGICALFLAGS32(local7) + ADDFLAGS32((eax_4 & 0x1252) - 0x2e8d, 0x2441, (eax_4 & 0x1252) + LOGICALFLAGS32(local7) - 0xa4c) + 0x2d02 & 0x22e4) >= 0) {
        }
        proc14();
        proc2();
        eax = eax + (eax < 0xd19) + 0x188c;
        local10 += eax;
        flags = SUBFLAGS32(0x3c2d, 0x439811, 0xffbca41c);
        proc11();
        local12 = local12 - eax + CF;
        proc14();
        proc2();
        proc8();
        eax = eax - local21;
        local14 += eax;
        proc2();
        local8 = local8 & eax_5 + 0x264b & 0xe7b;
        eax = (eax_5 + 0x264b & 0xe7b) + 0x18a9;
        proc1(eax + local13 + ADDFLAGS32(eax_5 + 0x264b & 0xe7b, 0x18a9, eax));
        proc1((esp - 372));
        eax = (local20);
        if ((eax - 0x2ac2 & 0x3de3) == 0) {
        }
        eax = (local17);
        if ((eax + 0x3e8d & 0x3481) < 0 || (esp - 300 & 0x18f0) != 0) {
L44:
        } else {
            if ((unsigned int)(esp - 300 & 0x3350) <= 0) {
                goto L44;
            }
        }
        global397 = 0;
        global355 = global355 - 1;
        proc2();
        local9 = local9 - eax;
        local13 += eax + 0x756b & 0x1686;
        proc8();
        eax = eax_6 + 0x5a6b;
        local5 = local5 & eax_6 + 0x5a6b;
        if (local1 == (esp - 300)) {
L29:
            eax_7 = eax;
            local6 = local6 + local22 - eax_7 + (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) + (eax_7 < (unsigned int)(local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252)));
            eax = ((eax_7 + (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) - local22 - 0x36c4 | 0x1c09) ^ 0xa19) & 0x1183 ^ 0x39c4;
            flags = LOGICALFLAGS32(((eax_7 + (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) - local22 - 0x36c4 | 0x1c09) ^ 0xa19) & 0x1183 ^ 0x39c4);
L26:
            eax = eax + CF + 0x16be;
        } else {
            eax = (eax_6 - LOGICALFLAGS32(0) + 0x2e47 ^ 0x33cd ^ 0x1cb0) - local3;
            flags = SUBFLAGS32(local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252), esp - 300, local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) + esp + 300);
            if (local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) != esp - 300) {
                goto L26;
            } else {
                if ((esp - 300 & 0x1375) != 0) {
                    eax = (eax_6 - LOGICALFLAGS32(0) + 0x2e47 ^ 0x33cd ^ 0x1cb0) + ADDFLAGS32((eax_6 - LOGICALFLAGS32(0) + 0x2e47 ^ 0x33cd ^ 0x1cb0) - local3, 0x22fc, (eax_6 - LOGICALFLAGS32(0) + 0x2e47 ^ 0x33cd ^ 0x1cb0) - local3 + 0x22fc) - local3 + 0x51c0;
                    if (esp - 300 >= 0) {
                        eax = (local18);
                        eax = (eax | 1919) ^ 0x2a15;
                        goto L29;
                    }
                }
            }
        }
        proc1(eax);
        if ((esp - 140) < eax) {
        }
        proc5();
        proc5();
        proc1((esp - 80));
        proc1((esp - 336));
        proc14();
        proc11();
        proc2();
        proc2();
        proc14();
        proc5();
        proc1(0);
        proc5();
        proc2();
        proc14();
        local0 = local0 - eax + ((unsigned int)(eax_8 & 0x274a) < 0x279b);
    } while (0 != *0x439811);
    eax = (local19);
    if (eax <= 0) {
        eax = eax - 0x3695;
    }
    return eax; /* WARNING: Also returning: ecx := (esp - 224) & 0xffff00ff | 0x1f00, edx := 0 */
}

// address: 0x402f17
__size32 proc13() {
    unsigned char ah; 		// r12
    int eax; 		// r24
    int eax_1; 		// r24{96}
    int eax_2; 		// r24{82}
    __size32 *ebp; 		// r29
    __size32 ebp_1; 		// r29{142}
    __size32 ebx; 		// r27
    unsigned int ecx; 		// r25
    unsigned int edx; 		// r26
    unsigned char local0; 		// m[esp - 396]
    unsigned int local1; 		// m[esp]
    int local2; 		// eax_2{151}

    eax_2 = 0;
    local2 = eax_2;
    if ((ecx & 0x2ff) == 0) {
L11:
        eax_2 = local2;
        eax_1 = eax_2 + eax_2 & 0x1720;
        flags = LOGICALFLAGS32(eax_2 + eax_2 & 0x1720);
    } else {
        eax = (local0);
        eax_1 = ((eax ^ 0x22d6) + LOGICALFLAGS32(eax ^ 0x22d6) + 0x3449 & 0xed8) + 0x3dba;
        flags = LOGICALFLAGS32(((eax ^ 0x22d6) + LOGICALFLAGS32(eax ^ 0x22d6) + 0x3449 & 0xed8) + 0x3dba & 0x334);
        local2 = eax_1;
        if ((((eax ^ 0x22d6) + LOGICALFLAGS32(eax ^ 0x22d6) + 0x3449 & 0xed8) + 0x3dba & 0x334) == 0) {
            goto L11;
        }
    }
    if ((unsigned int)(eax_1 + CF + eax_1 + CF + ADDFLAGS32(eax_1, 0xdac, eax_1 + CF + 0xdac) + 0x42d4 & 0x2069 & 0x2421) < edx) {
L7:
    } else {
        if (edx <= ecx) {
            goto L7;
        }
    }
    proc2();
    proc15(ah, global337, ebx);
    ebp_1 = *ebp;
    global350 = local1 - global437;
    *(__size32*)ebp = global427 + global422;
    return ebp_1;
}

// address: 0x404019
unsigned int proc14() {
    unsigned int eax; 		// r24
    unsigned int ecx; 		// r25
    unsigned char local0; 		// m[esp - 332]
    unsigned int local1; 		// m[esp - 300]
    unsigned int local2; 		// m[esp - 336]
    unsigned short local3; 		// m[esp - 52]

    eax = (local0);
    eax = eax ^ 0x33cd ^ 0x344b ^ 0x22b9;
    if (local1 != eax) {
L1:
        eax = (local3);
        eax = eax ^ 0x3278 | 0x3622;
    } else {
        eax = 0;
        if (ecx < 0) {
            goto L1;
        } else {
            if (0 == local2) {
                goto L1;
            }
        }
    }
    return eax;
}

// address: 0x405444
void proc15(unsigned char param1, __size32 param2, __size32 param3) {
    int local0; 		// m[esp]

    global420 = 61;
    global345 = global345 - 0x438f;
    global350 = global350 - param3;
    global423 += 0x362a;
    global422 = param2 + 338 ^ global422;
    global427 = local0 & 0xffff0000;
    global428 = (param1);
    return;
}

// address: 0x406dfc
void proc16() {
    __size32 ebx; 		// r27
    int ecx; 		// r25
    __size32 edi; 		// r31
    __size32 esi; 		// r30

    global346 += 95;
    global347 += 0x4a8e;
    global328 = global328 - 0x63b5;
    global330 = esi;
    global331 = edi;
    global332 = 62;
    global329 = global322;
    global343 += 78;
    ebx = *0x4399b8 + 0x43a096;
    global322 = global334;
    ebx = ebx + ADDFLAGS32(0x43a096, *0x4399b8, ebx) + 0x33c1;
    global334 = global323;
    global330 = global330 - ebx;
    global332 = 0x60a4;
    global350 = 0x1755;
    global345 = 0x5b9f;
    ecx = global323 / 0x80000 ^ global323 ^ global329 * 0x800 ^ global329 ^ (global329 * 0x800 ^ global329) / 256;
    global323 = ecx;
    global337 = ecx;
    global345 = global345 - 620;
    return;
}

