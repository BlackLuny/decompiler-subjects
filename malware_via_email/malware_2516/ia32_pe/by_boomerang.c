__size32 global322 = 0x1f123bb5;// 4 bytes
unsigned int global324 = 0x5491333;
unsigned int global326 = 0;
unsigned int global325 = 0;
int global328 = 0;
int global330 = 0;
unsigned int global332 = 0x4c62;
__size32 global333 = 0;// 4 bytes
__size32 global334 = 0;// 4 bytes
__size32 global336 = 0;// 4 bytes
__size32 global337 = 0x159a55e5;// 4 bytes
__size32 global340 = 0x89e58bc6;// 4 bytes
__size32 global350 = 0x11170;// 4 bytes
unsigned int global395 = 0;
__size32 global400 = 0;// 4 bytes
int global427 = 0xb5603c97;
int global430 = 0;
__size32 global448 = 0;// 4 bytes
int global468 = 0;
__size32 global479 = 0x5c70000;// 4 bytes
__size32 global480 = 0;// 4 bytes
__size32 global482 = 0;// 4 bytes
__size32 global483 = 0;// 4 bytes
__size32 global484 = 0;// 4 bytes
__size32 global494 = 0;// 4 bytes
int global497 = 0;
unsigned int global498 = 0;
unsigned int global513 = 0x64b5ffff;
int global517 = 0x241589f3;

__size32 proc2();
int proc3();
void _start();
__size32 proc4();
int proc5();
int proc6();
__size32 proc7();
int proc8();
__size32 proc9();
int proc10(int param1, __size32 param2);
unsigned int proc11();
unsigned int proc12();
__size32 proc13();
unsigned int proc14();
void proc15();
__size32 proc16();

// address: 0x4040f4
__size32 proc1(__size32 param1) {
    __size32 eax; 		// r24
    unsigned int esp; 		// r28

    eax = param1 + ((unsigned int)(esp - 4) < 992) + 0x1824;
    return eax + 0x1620;
}

// address: 0x402432
__size32 proc2() {
    int eax; 		// r24
    __size32 eax_1; 		// r24{109}
    int eax_2; 		// r24{293}
    int eax_3; 		// r24{39}
    unsigned int eax_4; 		// r24{328}
    unsigned int ecx; 		// r25
    unsigned int edx; 		// r26
    unsigned int local0; 		// m[esp - 240]
    unsigned int local1; 		// m[esp - 340]
    unsigned short local10; 		// m[esp - 220]
    int local11; 		// m[esp - 448]
    unsigned char local12; 		// m[esp - 492]
    int local13; 		// m[esp - 172]
    int local14; 		// m[esp - 388]{132}
    unsigned int local2; 		// m[esp - 560]
    unsigned char local3; 		// m[esp - 384]
    unsigned int local4; 		// m[esp - 284]
    unsigned int local5; 		// m[esp - 428]
    int local6; 		// m[esp - 388]
    unsigned int local7; 		// m[esp - 456]
    int local8; 		// m[esp - 520]
    unsigned int local9; 		// m[esp - 548]

    eax = eax & 0x1dc8;
    if (ecx < local4) {
L35:
        eax = eax + 0x158b & 0x1c0;
    } else {
        eax_1 = 0 - (ecx < local4);
        eax = eax_1 + 0x33b1;
        if ((unsigned int)(eax_1 + 0x33b1 & 0x2281) <= 0) {
            eax = eax_1 + 0x2ca1 & 0x18c;
            goto L35;
        }
    }
    eax_2 = eax;
    eax = (eax_2 | 0x34dc) - 0x1dcc;
    if (edx > local1) {
L27:
        eax = eax & 0x3695 ^ local5;
        eax = eax + LOGICALFLAGS32(eax) + 0x2575 & 0x2acc;
L25:
        eax_4 = eax;
        eax_3 = eax_4 ^ 0x2ff2;
        flags = LOGICALFLAGS32(eax_4 ^ 0x2ff2);
L24:
        local14 = local6 + eax_3 + CF;
        flags = ADDFLAGS32(local6, eax_3, local14);
L23:
        eax = eax_3 + CF + 0x3e38 ^ 0x16d9;
        eax = eax ^ 0x121b;
L22:
        eax = eax - 0xf23;
    } else {
        eax = (eax_2 | 0x34dc) - 22 & 0x4b3;
        if ((int)ecx < (int)eax) {
            goto L25;
        } else {
            eax_3 = eax - local2;
            flags = SUBFLAGS32(edx, ecx, edx - ecx);
            if (edx != ecx) {
                goto L24;
            } else {
                eax_3 = eax_3 + ADDFLAGS32(eax_3, 0x1a76, eax_3 + 0x1a76) + 0x3dee;
                flags = LOGICALFLAGS32(eax_3 + ADDFLAGS32(eax_3, 0x1a76, eax_3 + 0x1a76) + 0x3dee & 0x1c03);
                if ((unsigned int)(eax_3 + ADDFLAGS32(eax_3, 0x1a76, eax_3 + 0x1a76) + 0x3dee & 0x1c03) < 0) {
                    goto L23;
                } else {
                    eax = (eax_3 + ADDFLAGS32(eax_3, 0x1a76, eax_3 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7;
                    if ((unsigned int)(((eax_3 + ADDFLAGS32(eax_3, 0x1a76, eax_3 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) & ecx) < 0) {
                        goto L22;
                    } else {
                        eax = ((eax_3 + ADDFLAGS32(eax_3, 0x1a76, eax_3 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) - LOGICALFLAGS32(((eax_3 + ADDFLAGS32(eax_3, 0x1a76, eax_3 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) & ecx) - 0x43c2 | 0x9e8;
                        if ((unsigned int)(local11 & (((eax_3 + ADDFLAGS32(eax_3, 0x1a76, eax_3 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) - LOGICALFLAGS32(((eax_3 + ADDFLAGS32(eax_3, 0x1a76, eax_3 + 0x1a76) + 0x3dee & 0x173e & 0x3e8f) - 0x26d2 ^ 0x8d7) & ecx) - 0x43c2 | 0x9e8)) <= 0) {
                            eax = (local12) | local13;
                            eax = eax - 0x34a1 ^ 0x3e62;
                            goto L27;
                        }
                    }
                }
            }
        }
    }
    if (eax < 0) {
L17:
        eax = (local10);
    } else {
        if ((unsigned int)(eax & edx) <= 0) {
            goto L17;
        }
    }
    eax = eax - local7;
    eax = (eax | 0x358a) + LOGICALFLAGS32(eax | 0x358a) - ADDFLAGS32(eax | 0x358a, 0x35d3, (eax | 0x358a) + LOGICALFLAGS32(eax | 0x358a) + 0x35d3) + 0x1a35;
    if (ecx > edx) {
L12:
        eax = (eax & 0x37c) + 499;
    } else {
        eax = -1222 - LOGICALFLAGS32(0);
        if (local0 >= ecx) {
            eax = 0xffffed00 - LOGICALFLAGS32(0) + (local0 < ecx);
            goto L12;
        }
    }
    if ((edx & 0x672) != 0) {
L3:
L1:
    } else {
        if (ecx == local9 || (((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + ((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + 1354 & edx) == 0) {
            goto L1;
        } else {
            if ( !((unsigned int)(edx & 0x2d79) < 0 || (unsigned int)(((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + ((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + 1354 & 0x4f3) > 0)) {
                if (((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + ((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + LOGICALFLAGS32((eax & 0xdb6) + LOGICALFLAGS32(eax & 0xdb6) + 0x18d3 ^ local8) + 1354 >= ecx) {
                    goto L3;
                }
            }
        }
    }
    eax = (local3);
    return (eax & 0x567 ^ 0x353f) + 0x25b6;
}

// address: 0x40398e
int proc3() {
    unsigned int eax; 		// r24
    union { void * x4477; int x4478; } edx; 		// r26
    void *esp; 		// r28
    unsigned char local0; 		// m[esp - 136]
    unsigned int local1; 		// m[esp - 204]
    int local2; 		// m[esp - 460]

    eax = proc8();
    eax = eax | local2;
    if ((unsigned int)(edx & eax) >= 0) {
    }
    proc8();
    if (edx < local1) {
L9:
    } else {
        eax = (local0);
        if (eax <= 0) {
            goto L9;
        }
    }
    proc1((esp - 468));
    eax = proc8();
    proc1(eax);
    eax = proc2();
    return eax | 0x95c; /* WARNING: Also returning: ecx := 0, edx := (esp - 172) */
}

// address: 0x402c7a
void _start() {
    int eax; 		// r24
    __size32 eax_1; 		// r24{287}
    int eax_2; 		// r24{984}
    int eax_3; 		// r24{378}
    __size32 *ebp; 		// r29
    __size32 ebx; 		// r27
    unsigned int ecx; 		// r25
    __size32 edi; 		// r31
    int edx; 		// r26
    __size32 esi; 		// r30
    void *esp; 		// r28
    unsigned int local0; 		// m[esp - 176]
    int local1; 		// m[esp - 228]
    int local2; 		// m[esp - 672]
    int local3; 		// m[esp - 140]
    __size32 local4; 		// m[esp - 552]
    void *local5; 		// m[esp - 124]
    unsigned int local6; 		// m[esp - 264]
    int local7; 		// m[esp - 608]
    int local9; 		// m[esp - 4]

    proc1(eax);
    proc2();
    global497 = (esp - 660);
    global498 = esi;
    edx = (esp - 660 ^ 0x79d2) + global513 - 0x4398b0;
    global484 = 0x65a6;
    global325 = 0x519e;
    global494 = ebx;
    global480 = edi;
    global333 = 0xffffa6ba;
    global482 = ecx;
    global483 = ebx - global479;
    global484 += 0x5946;
    global468 = (esp - 4);
    eax = proc1(0xffffa6ba);
    if ((esp - 436) > 0) {
L100:
L99:
L98:
L97:
    } else {
        if (edx - global517 + 0x439781 != local3) {
            goto L99;
        } else {
            if ((unsigned int)(edx - global517 + 0x439781 & (eax + local4 - ADDFLAGS32(eax + 0x35af, 0xff9, eax + 0x45a8) + 0x1316 & 0x3174) + 0xf0b) < 0) {
                goto L98;
            } else {
                if ((unsigned int)(esp - 436 & 0x2f67) > 0) {
                    goto L97;
                } else {
                    if (local5 <= esp - 436) {
                        goto L100;
                    }
                }
            }
        }
    }
    edx = proc3();
    if ((unsigned int)(edx & 0xfe1) > 0) {
L90:
    } else {
        if ((unsigned int)(edx & 0x3c4f) <= 0) {
            goto L90;
        }
    }
    ecx = proc4();
    eax = proc5();
    eax = eax - local2;
    if (0 == ecx) {
L82:
    } else {
        eax = eax ^ local0;
        if ((unsigned int)(eax - LOGICALFLAGS32(eax) - 0x39e5) <= 0) {
            goto L82;
        }
    }
    proc6();
    proc5();
    proc7();
    proc8();
    eax = proc9(); /* Warning: also results in ecx */
    eax = proc10(eax, ecx);
    if (((eax ^ 0x1b9c | 0x1dd7) & 0x1dd5) != 0) {
L67:
L66:
    } else {
        if (0 < (unsigned int)(eax ^ 0x1b9c | 0x1dd7)) {
            goto L66;
        } else {
            tmp1 = ecx & (eax ^ 0x1b9c | 0x1dd7);
            if (tmp1 >= 0) {
                goto L67;
            }
        }
    }
    proc8();
    if (ecx >= 0) {
    }
    proc8();
    edx = proc3();
    proc5();
    if ( !((unsigned int)(edx & 0x2b13) < 0 || local6 < 0)) {
        if (edx <= 0) {
        }
    }
    proc11();
    if (0 == edx) {
    }
    eax = proc4(); /* Warning: also results in ecx */
    eax = eax + 0x1b2a | 0x17d1 | 0x3b63;
    eax += local0;
    if ( !(ecx != 0 || (local1 & (eax ^ 0x3a9f) + LOGICALFLAGS32(ecx) + 0x1a19) != 0)) {
    }
    eax_1 = proc12(); /* Warning: also results in ecx, edx */
    eax = (eax_1 + LOGICALFLAGS32(0) + 0x829 & 0x39fe | 513) + 0x216a;
    if ((eax_1 + LOGICALFLAGS32(0) + 0x829 & 0x39fe | 513) + 0x216a != local7) {
L34:
        eax = (eax ^ 0x200c) - 0x322a;
L32:
        eax_2 = eax;
        eax = eax_2 | 0xaea;
        flags = LOGICALFLAGS32(eax_2 | 0xaea);
    } else {
        eax = 0;
        if (ecx < 0) {
            goto L34;
        } else {
            eax = 0xfffff1ec;
            if ((ecx & 0x240a) == 0) {
                goto L32;
            } else {
                flags = LOGICALFLAGS32(ecx & 0xfffff1ec);
                if ((unsigned int)(ecx & 0xfffff1ec) <= 0) {
                    eax = (local0);
                    eax = eax ^ 0x1666;
                    goto L34;
                }
            }
        }
    }
    eax = eax - CF - 1919 | 0x3596;
    if (eax > 0) {
L28:
    } else {
        if ((edx & 0x140b) == 0) {
            goto L28;
        }
    }
    esp = proc13(); /* Warning: also results in ebp */
    local9 = 30;
    proc14();
    local9 = ebp - 600;
    *(__size32*)(esp - 8) = 0;
    *(union { __size32 * x4491; int x4492; }*)(esp - 12) = ebp - 392;
    eax = proc6();
    local9 = 0;
    *(int*)(esp - 8) = eax ^ 0x3558;
    *(int*)(esp - 12) = eax ^ 0x3558;
    proc2();
    local9 = 55;
    eax = proc14();
    local9 = 0;
    *(__size32*)(esp - 8) = 61;
    *(__size32*)(esp - 12) = 0xe15927e4;
    proc10(eax, 0);
    local9 = ebp - 212;
    *(__size32*)(esp - 8) = 0;
    *(union { __size32 * x4501; int x4502; }*)(esp - 12) = ebp - 476;
    eax = proc6();
    local9 = (eax | 0x1704) - LOGICALFLAGS32(eax | 0x1704) - 0x2344 | 0x1d17;
    *(__size32*)(esp - 8) = 1;
    *(__size32*)(esp - 12) = 0;
    eax = proc4();
    *(__size32*)(ebp - 604) = *(ebp - 604) - eax + LOGICALFLAGS32(0);
    local9 = ebp - 284;
    *(__size32*)(esp - 8) = 0;
    *(union { __size32 * x4505; int x4506; }*)(esp - 12) = ebp - 492;
    edx = proc6();
    local9 = 0;
    *(union { __size32 * x4507; int x4508; }*)(esp - 8) = ebp - 428;
    *(__size32*)(esp - 12) = 0xa798f85f;
    *(__size32*)(esp - 16) = edx;
    proc1(ebp - 428);
    local9 = edx;
    *(__size32*)(esp - 8) = 0;
    *(__size32*)(esp - 12) = 0;
    eax = proc5();
    local9 = 0;
    *(union { __size32 * x4493; int x4494; }*)(esp - 8) = ebp - 596;
    *(__size32*)(esp - 12) = 0x350e6fec;
    *(__size32*)(esp - 16) = *(ebp - 56);
    eax = proc1((eax | 0x27d6) + LOGICALFLAGS32(eax | 0x27d6) + 0x3eb4);
    local9 = eax ^ 0x3f83;
    *(__size32*)(esp - 8) = 31;
    *(__size32*)(esp - 12) = 0;
    ecx = proc4();
    local9 = 0xcfa4f009;
    *(__size32*)(esp - 8) = 0;
    *(__size32*)(esp - 12) = ecx;
    eax_3 = proc5();
    local9 = 38;
    eax = proc14();
    *(__size32*)(ebp - 428) = *(ebp - 428) - eax + LOGICALFLAGS32(eax_3 ^ 0x29b4);
    local9 = 0;
    *(__size32*)(esp - 8) = 0;
    *(__size32*)(esp - 12) = 0;
    proc5();
    return;
}

// address: 0x404034
__size32 proc4() {
    __size32 eax; 		// r24
    __size32 eax_1; 		// r24{56}
    union { int x287; bool x288; } eax_2; 		// r24{37}
    __size32 eax_3; 		// r24{44}
    union { void * x4551; int x4552; } ecx; 		// r25
    int edx; 		// r26
    void *esp; 		// r28
    int local0; 		// m[esp - 400]
    unsigned short local1; 		// m[esp - 48]

    eax = (local1);
    eax_2 = eax + ((esp - 4) < 512) + 93;
    eax_3 = ((eax_2 | 0x14cb) ^ 0x30cd) + 0xa27;
    eax_1 = eax_3 + 0x19a6;
    if ((int)ecx >= 0) {
        eax_1 = eax_3 - ADDFLAGS32(eax_3 + 0x19a6, 0x2a16, eax_3 + 0x43bc) + 0x2d37;
        tmp1 = local0 & edx;
        if (tmp1 <= 0) {
            eax_1 = (((eax_2 | 0x14cb) ^ 0x30cd) - ADDFLAGS32(((eax_2 | 0x14cb) ^ 0x30cd) + 0x23cd, 0x2a16, ((eax_2 | 0x14cb) ^ 0x30cd) + 0x4de3) + 0x375e & 0x1e85) + 0x330e;
        }
    }
    eax = proc1(eax_1);
    return eax; /* WARNING: Also returning: ecx := (esp - 428) */
}

// address: 0x4033a4
int proc5() {
    int eax; 		// r24
    unsigned int eax_1; 		// r24{34}
    unsigned int eax_2; 		// r24{80}
    unsigned int eax_3; 		// r24{132}
    int ecx; 		// r25
    unsigned int edx; 		// r26
    unsigned short local0; 		// m[esp - 440]
    int local1; 		// m[esp - 540]
    __size32 local2; 		// m[esp - 400]
    unsigned char local3; 		// m[esp - 172]
    unsigned short local4; 		// m[esp - 748]
    unsigned int local5; 		// m[esp - 92]
    __size32 local6; 		// m[esp - 400]{63}

    eax = proc14();
    local6 = local2 + (eax ^ 0x2fa5);
    eax = ((eax ^ 0x2fa5) + ADDFLAGS32(local2, eax ^ 0x2fa5, local6) + 0x506f ^ 0xffb) + LOGICALFLAGS32((eax ^ 0x2fa5) + ADDFLAGS32(local2, eax ^ 0x2fa5, local6) + 0x506f ^ 0xffb) + 0x3685;
    if ((ecx & 0x12c4) != 0) {
L10:
        eax = (eax & 0x216c) + LOGICALFLAGS32(eax & 0x216c) + 0x100f;
L9:
        eax = eax & local1;
L8:
        eax += 0xcb2;
L7:
        flags = LOGICALFLAGS32(eax + 0x9ca & 0x1245);
        eax = (local0);
    } else {
        eax_1 = (local3);
        eax = eax_1 + ADDFLAGS32(eax_1, 0x220b, eax_1 + 0x220b) + 0x42a6;
        if ((unsigned int)(ecx & eax_1 + ADDFLAGS32(eax_1, 0x220b, eax_1 + 0x220b) + 0x42a6) > 0) {
            goto L9;
        } else {
            eax = eax_1 + ADDFLAGS32(eax_1, 0x220b, eax_1 + 0x220b) + LOGICALFLAGS32(ecx & eax_1 + ADDFLAGS32(eax_1, 0x220b, eax_1 + 0x220b) + 0x42a6) + 0x47a6;
            if (edx != 0) {
                goto L8;
            } else {
                eax_2 = (local4);
                eax = eax_2 - 0x2933;
                if ((unsigned int)(eax_2 - 0x2933) > 0) {
                    goto L7;
                } else {
                    eax = eax_2 - 0x2933 ^ 0x1eb7;
                    tmp1 = edx - (eax_2 - 0x2933 ^ 0x1eb7);
                    flags = SUBFLAGS32(edx, eax_2 - 0x2933 ^ 0x1eb7, tmp1);
                    if (edx == (eax_2 - 0x2933 ^ 0x1eb7)) {
                        eax = (eax_2 - 0x2933 ^ 0x1eb7) + (edx < (unsigned int)(eax_2 - 0x2933 ^ 0x1eb7)) + 0x2e62;
                        eax += 1568;
                        goto L10;
                    }
                }
            }
        }
    }
    eax_3 = eax - CF + (eax < 0xa24) - 0x3120;
    eax = eax_3 + (eax_3 < 0x151d) - 194;
    eax = eax + ADDFLAGS32(eax_3 - 0x151d, 0x145b, eax) + 0x2c6f & 0xf71;
    if ((unsigned int)(ecx & 0x33fc) < 0) {
L1:
        eax = (eax + ADDFLAGS32(eax_3 - 0x151d, 0x145b, eax) + 0x2c6f & 0xf71) - (local5 < (unsigned int)(eax + ADDFLAGS32(eax_3 - 0x151d, 0x145b, eax) + 0x2c6f & 0xf71)) - 0x20de;
    } else {
        if (edx <= 0) {
            goto L1;
        }
    }
    return eax;
}

// address: 0x404209
int proc6() {
    unsigned int eax; 		// r24
    union { unsigned int x449; bool x450; } eax_1; 		// r24{517}
    unsigned int eax_10; 		// r24{3119}
    unsigned int eax_11; 		// r24{295}
    unsigned int eax_12; 		// r24{807}
    unsigned int eax_13; 		// r24{3128}
    int eax_15; 		// r24{682}
    unsigned int eax_16; 		// r24{696}
    unsigned int eax_17; 		// r24{3631}
    int eax_18; 		// r24{2880}
    int eax_2; 		// r24{478}
    unsigned int eax_4; 		// r24{2129}
    __size32 eax_5; 		// r24{1181}
    __size32 eax_6; 		// r24{3203}
    int eax_7; 		// r24{3310}
    int eax_8; 		// r24{2652}
    unsigned int eax_9; 		// r24{3690}
    unsigned int ecx; 		// r25
    unsigned int edx; 		// r26
    int esp; 		// r28
    unsigned int local0; 		// m[esp - 164]
    unsigned char local1; 		// m[esp - 424]
    unsigned int local10; 		// m[esp - 312]
    unsigned int local11; 		// m[esp - 188]
    unsigned int local12; 		// m[esp - 80]
    __size32 local13; 		// m[esp - 60]
    int local14; 		// m[esp - 228]
    int local15; 		// m[esp - 212]
    unsigned short local16; 		// m[esp - 368]
    unsigned int local17; 		// m[esp - 472]
    unsigned int local18; 		// m[esp - 264]
    unsigned int local19; 		// m[esp - 524]
    union { unsigned int x640; bool x641; } local2; 		// m[esp - 340]
    unsigned short local20; 		// m[esp - 504]
    int local21; 		// m[esp - 136]
    __size32 local22; 		// m[esp - 272]
    int local23; 		// m[esp - 208]
    unsigned char local24; 		// m[esp - 116]
    unsigned int local25; 		// m[esp - 324]
    int local26; 		// m[esp - 384]
    int local27; 		// m[esp - 404]
    unsigned int local28; 		// m[esp - 240]
    unsigned int local29; 		// m[esp - 112]
    unsigned int local3; 		// m[esp - 168]
    unsigned int local30; 		// m[esp - 200]
    int local31; 		// m[esp - 92]
    int local32; 		// m[esp - 36]
    int local33; 		// m[esp - 456]
    union { int x567; bool x568; bool x566; bool x564; bool x562; } local34; 		// m[esp - 500]
    unsigned int local35; 		// m[esp - 444]
    int local36; 		// m[esp - 372]
    unsigned int local37; 		// m[esp - 388]
    int local38; 		// m[esp - 488]
    unsigned int local39; 		// m[esp - 428]
    unsigned short local4; 		// m[esp - 32]
    unsigned int local40; 		// m[esp - 512]
    unsigned int local41; 		// m[esp - 352]
    unsigned int local42; 		// m[esp - 168]{298}
    unsigned int local43; 		// m[esp - 296]{2759}
    unsigned int local44; 		// m[esp - 312]{572}
    unsigned int local5; 		// m[esp - 172]
    unsigned int local53; 		// eax_12{3812}
    unsigned int local54; 		// eax_10{3970}
    unsigned int local6; 		// m[esp - 432]
    unsigned int local7; 		// m[esp - 360]
    unsigned int local8; 		// m[esp - 296]
    unsigned int local9; 		// m[esp - 448]

    proc2();
    proc3();
    proc3();
    proc11();
    eax = proc3(); /* Warning: also results in ecx, edx */
    local43 = local8 ^ eax;
    proc5();
    if (ecx <= edx) {
    }
    GetCurrentThreadId();
    proc8();
    eax = proc2();
    proc1(eax);
    proc8();
    proc2();
    eax = (local1);
    flags = LOGICALFLAGS32(0);
    CF = LOGICALFLAGS32(eax & 0x2f25);
    eax = GetCommandLineA();
    eax = eax - CF - 0x167f & 0x32af ^ 0x1ce7;
    eax_1 = (eax & 0x3fdb) + (local9 < (unsigned int)(eax & 0x3fdb)) + 453;
    eax = eax_1 - 0x3eff;
    flags = LOGICALFLAGS32(eax_1 - 0x3eff);
    if (eax_1 - 0x3eff < 0) {
L419:
        eax = eax_1 + CF - 0x25bd;
    } else {
        flags = LOGICALFLAGS32(eax_1 - 0x3eff & 0x3f58);
        if ((eax_1 - 0x3eff & 0x3f58) == 0) {
            goto L419;
        }
    }
    proc1(eax);
    proc2();
    proc5();
    ecx = GetCurrentThreadId();
    proc2();
    if ((ecx & 0x3af2) == 0) {
L407:
    } else {
        if ((unsigned int)(ecx & 0x3ab6) >= 0) {
            goto L407;
        }
    }
    eax = proc3(); /* Warning: also results in ecx, edx */
    if ((unsigned int)(eax - 0x1f37) > local28) {
L403:
    } else {
        if (ecx == edx) {
            goto L403;
        }
    }
    proc8();
    proc3();
    proc8();
    proc11();
    ecx = GetCommandLineA(); /* Warning: also results in edx */
    eax_2 = proc5();
    eax = proc5();
    if (edx == 0) {
L387:
L386:
L385:
    } else {
        if (ecx < (unsigned int)(((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local15) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) - 0x20a1)) {
            goto L386;
        } else {
            if (ecx < 0) {
                goto L385;
            } else {
                if (((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local15) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) + LOGICALFLAGS32(((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local15) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) - 0x20a1) + LOGICALFLAGS32(ecx) + 0x20a4 >= local29) {
                    local5 = local5 & ((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local15) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) + LOGICALFLAGS32(((eax - LOGICALFLAGS32(eax_2 | 0x1c93) - 0x16d6 & local15) - LOGICALFLAGS32(edx) - 0xdfd ^ 0x22d8) - 0x20a1) + LOGICALFLAGS32(ecx) + 0x20a4;
                    local6 = local6 & ((LOGICALFLAGS32(0) + 1205 | 0x3349) - local22 + LOGICALFLAGS32(LOGICALFLAGS32(0) + 1205 | 0x3349) ^ 0x38cd);
                    goto L387;
                }
            }
        }
    }
    proc1((esp - 420));
    proc8();
    GetCurrentThreadId();
    proc3();
    proc14();
    eax = GetLastError(); /* Warning: also results in ecx */
    if (eax == ecx) {
    }
    proc14();
    proc8();
    proc3();
    proc8();
    eax = proc11();
    proc1(eax - 1632);
    proc3();
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    eax = (local16);
    if ((unsigned int)(eax + 0x239a & 0x2f0e) > 0) {
L357:
L356:
L355:
    } else {
        tmp1 = ecx & eax - 0x139d & 0x3b11;
        if (tmp1 < 0) {
            goto L356;
        } else {
            if (ecx != edx || edx < local17) {
                goto L355;
            } else {
                if ((unsigned int)(edx & 0x51f) <= 0) {
                    goto L357;
                }
            }
        }
    }
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    if (edx < local28) {
L346:
L345:
    } else {
        tmp1 = 0 - (local35 < 0x324b) & ecx;
        if (tmp1 > 0) {
            goto L346;
        } else {
            eax = 0 - (local35 < 0x324b) & 0x2266;
            if (edx > ecx) {
                goto L346;
            } else {
                if ((edx & (eax | 0x1196)) == 0) {
                    goto L345;
                } else {
                    if (ecx == 0) {
                        goto L346;
                    }
                }
            }
        }
    }
    GetLastError();
    ecx = GetCommandLineA();
    proc5();
    eax = (local17);
    if ((eax - LOGICALFLAGS32(0) - 0x29ec ^ 0xd13 ^ local32) == 0) {
    }
    if ((int)local7 >= ecx) {
    }
    GetCurrentThreadId();
    proc5();
    eax = proc2();
    proc1(eax & 0x390d);
    proc11();
    if ((esp - 220) < 0) {
L324:
    } else {
        eax = (local5);
        if (eax <= esp - 220) {
            goto L324;
        }
    }
    eax = proc1(esp - 472);
    proc1((eax - 0x1f7b & 0x79a) + 0x1176);
    GetCurrentThreadId();
    proc8();
    GetCurrentThreadId();
    proc11();
    proc3();
    eax = proc5();
    eax_4 = proc1(eax + 0x31e1 | 0x3f82);
    eax = GetLastError(); /* Warning: also results in ecx, edx */
    eax = eax + (eax_4 < 0x31c5) + 79;
    if ((unsigned int)(edx & ecx) < 0) {
L304:
    } else {
        if (((eax & 0x3ea0) + LOGICALFLAGS32(local5 | (eax & 0x3ea0) - LOGICALFLAGS32(eax & 0x3ea0) - 0x1933) - LOGICALFLAGS32(eax & 0x3ea0) - 0xd22 ^ 0x11ac) == 0) {
            goto L304;
        }
    }
    GetCurrentThreadId();
    proc11();
    proc3();
    proc8();
    GetLastError();
    proc1((esp - 460));
    eax_5 = proc14();
    eax = proc3(); /* Warning: also results in edx */
    eax = proc2();
    local44 = local10 + (eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) - ADDFLAGS32(eax, 478, eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) + 478) - 0x2fe7 ^ 0x34fe);
    if ((edx & 0x2dc0) != 0) {
L288:
    } else {
        if ((unsigned int)(eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) - ADDFLAGS32(eax, 478, eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) + 478) - 0x2fe7 ^ 0x34fe) >= 0) {
            goto L288;
        }
    }
    proc14();
    if (local6 <= edx) {
    }
    proc14();
    if ((edx & 0x1a37) != 0) {
L277:
    } else {
        if (edx <= 0) {
            goto L277;
        }
    }
    edx = GetCurrentThreadId();
    proc14();
    proc5();
    proc11();
    proc14();
    proc8();
    eax_6 = proc14();
    eax = proc14();
    eax = eax + (eax_6 + 0x345e < 0x21e8) + 0x3273;
    eax = eax | local35;
    if (edx != 0) {
L262:
    } else {
        eax = (eax | 0x338b) + ((unsigned int)(eax | 0x338b) < 0xe4a) + 0x2e24;
        if (eax >= 0) {
            goto L262;
        }
    }
    eax = proc5();
    proc1(eax + LOGICALFLAGS32(0) - local18 + LOGICALFLAGS32(0) + ADDFLAGS32(eax - local18 + LOGICALFLAGS32(0), 0xf8f, eax + LOGICALFLAGS32(0) - local18 + LOGICALFLAGS32(0) + 0xf8f) - 0xbbb);
    GetLastError();
    proc1(0);
    eax = (local40);
    if ((eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + ADDFLAGS32(eax & 0x487, 0x306f, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + 0x306f) - ADDFLAGS32((eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + ADDFLAGS32(eax & 0x487, 0x306f, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + 0x306f) + 0x6b4f, 0x2a26, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + ADDFLAGS32(eax & 0x487, 0x306f, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + 0x306f) + 0x9575) + ((eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + ADDFLAGS32(eax & 0x487, 0x306f, (eax & 0x487) + LOGICALFLAGS32(eax & 0x487) + 0x306f) + 0x9575 < 0x192e) + 0x59d9 <= esp - 372) {
    }
    eax = proc5();
    if ((eax & 0xc89) != 0) {
L248:
    } else {
        if ((eax & 0x25e1) != 0) {
            goto L248;
        }
    }
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    proc1((esp - 364));
    eax = proc14();
    eax_7 = eax + (ecx < 0) + 0x32f0;
    eax = (eax_7 & 0x435) - 0x2fbe;
    if (0 == edx) {
        eax = (eax_7 & 0x435) + ((unsigned int)((eax_7 & 0x435) - 0x2fbe) < 0x3901) - 0x5878;
    }
    proc1(eax);
    proc8();
    ecx = GetLastError(); /* Warning: also results in edx */
    eax = proc8();
    eax_8 = eax | local36;
    eax = eax_8 + LOGICALFLAGS32(eax_8) + 0x14dd & 0x131b;
    if (edx > (unsigned int)(eax_8 + LOGICALFLAGS32(eax_8) + 0x14dd & 0x131b)) {
L222:
        eax_9 = eax;
        eax = (eax_9 | 0xa08) - 0x575a;
        flags = SUBFLAGS32((eax_9 | 0xa08) - 0x2d81, 0x29d9, (eax_9 | 0xa08) - 0x575a);
L221:
        eax = eax - CF - 0x1cfb;
L220:
        eax = eax - local25 - 0x3df8;
        local44 = local10 + (eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) - ADDFLAGS32(eax, 478, eax + ADDFLAGS32(eax, 0x960, eax + ADDFLAGS32(eax_5, 0x173e, eax_5 + 0x173e) + 0x960) + 478) - 0x2fe7 ^ 0x34fe) - eax;
    } else {
        flags = LOGICALFLAGS32(ecx);
        if (ecx != 0) {
            goto L221;
        } else {
            eax = (local7);
            flags = LOGICALFLAGS32(ecx & 0x3b81);
            if ((unsigned int)(ecx & 0x3b81) > 0) {
                goto L221;
            } else {
                eax = eax - 464;
                if (edx > ecx) {
                    goto L220;
                } else {
                    if ((unsigned int)(edx & 0x2830) >= 0) {
                        eax = (local39);
                        local38 = local38 ^ eax;
                        eax = eax + LOGICALFLAGS32(local38) + 0xf4a ^ 1551;
                        goto L222;
                    }
                }
            }
        }
    }
    eax = proc8();
    eax = eax | local2;
    local33 = local33 & eax;
    if (edx != (eax + (eax < 1225) + local34 + ADDFLAGS32(eax + (eax < 1225) - LOGICALFLAGS32(local33) + 1454, local34, eax + (eax < 1225) + local34 - LOGICALFLAGS32(local33) + 1454) - LOGICALFLAGS32(local33) + 0x371d ^ 966)) {
L213:
    } else {
        if ((ecx & 0x2e21) == 0) {
            goto L213;
        }
    }
    proc2();
    proc14();
    if ((unsigned int)(ecx & 0x24d2) < 0) {
L202:
L201:
L200:
    } else {
        if ((ecx & 0x3c8f) != 0) {
            goto L201;
        } else {
            eax = (local18);
            if ((unsigned int)(edx & eax + 0x20b3) < 0) {
                goto L200;
            } else {
                if ((eax + 0x20b3 & 0x27bd) >= 0) {
                    goto L202;
                }
            }
        }
    }
    proc2();
    GetCurrentThreadId();
    proc5();
    proc5();
    proc11();
    proc2();
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    eax = proc1(esp - 512);
    local31 = local31 & eax;
    eax_11 = eax + 0x18f1 & 0x1e04 & 0x24e8;
    local42 = local3 - eax_11 + LOGICALFLAGS32(eax_11);
    local53 = eax_11;
    if (ecx <= 0) {
        eax_12 = eax_11 - LOGICALFLAGS32(ecx) - 0x3feb;
        local53 = eax_12;
    }
    eax_12 = local53;
    eax_10 = (eax_12 | 0x31c6) - LOGICALFLAGS32(eax_12 | 0x31c6) - 0x8d4;
    local54 = eax_10;
    local54 = eax_10;
    if ((unsigned int)(ecx & edx) < 0 || ((eax_12 | 0x31c6) - LOGICALFLAGS32(eax_12 | 0x31c6) - 0x8d4 & 0xad8) < 0) {
L177:
        eax_10 = local54;
        local42 = local3 - eax_11 + LOGICALFLAGS32(eax_11) | (eax_10 & 0x1d4) - ADDFLAGS32(eax_10 & 0x1d4, 0x28da, (eax_10 & 0x1d4) + 0x28da) - 0xcd2;
    } else {
        eax_13 = (eax_12 | 0x31c6) - LOGICALFLAGS32(eax_12 | 0x31c6) + 0x2e1b;
        local54 = eax_13;
        if (local31 != ecx) {
            goto L177;
        } else {
            if (edx >= ((eax_12 | 0x31c6) - LOGICALFLAGS32(eax_12 | 0x31c6) + local14 + 0x3ddd & 0x240a ^ local15)) {
                eax = (local4);
                local11 = local11 & (eax ^ 0x3301) - 0x26f2;
                eax_10 = (local12);
                local54 = eax_10;
                goto L177;
            }
        }
    }
    eax = (local20);
    tmp1 = local21 & eax + 0xe37;
    if (tmp1 < 0) {
L172:
    } else {
        if (ecx != eax + 0xe37) {
            goto L172;
        }
    }
    GetCommandLineA();
    proc11();
    proc5();
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    if ((unsigned int)(edx & 0x366a) <= 0) {
        if (ecx <= edx) {
        }
    }
    proc14();
    proc8();
    GetCurrentThreadId();
    proc5();
    proc1((esp - 268));
    GetCurrentThreadId();
    proc5();
    eax = (local30);
    proc1(eax);
    proc3();
    proc3();
    eax = GetCommandLineA(); /* Warning: also results in edx */
    if ((unsigned int)(edx & 0x120f) < 0) {
L145:
    } else {
        if (((eax - ADDFLAGS32(local13, 0, local13 + LOGICALFLAGS32(0)) - 0xc11 | 0x3481) - LOGICALFLAGS32(edx & 0x120f) - 0x3d21 | 271) >= edx) {
            goto L145;
        }
    }
    proc14();
    eax = proc5();
    local26 = local26 | eax;
    proc11();
    GetCurrentThreadId();
    proc5();
    proc3();
    proc1((local19));
    proc3();
    proc3();
    proc8();
    eax = proc1(esp - 92);
    local41 = local41 - eax;
    GetLastError();
    proc2();
    ecx = proc3();
    if ((unsigned int)(ecx & 0x1f04) > 0) {
L124:
    } else {
        if (ecx >= 0) {
            goto L124;
        }
    }
    GetLastError();
    proc5();
    proc1(0);
    GetCurrentThreadId();
    proc11();
    ecx = proc3();
    proc14();
    eax = proc2();
    eax = proc1(eax - LOGICALFLAGS32(0) - 173 & 0x3e12);
    local2 += eax + (ecx < 0);
    proc11();
    proc8();
    proc2();
    proc14();
    eax = GetCurrentThreadId();
    proc1(eax);
    proc14();
    proc11();
    proc5();
    proc5();
    ecx = GetCurrentThreadId(); /* Warning: also results in edx */
    proc14();
    eax = (local42);
    if (eax != edx) {
L90:
L89:
L88:
L86:
    } else {
        eax = (local2);
        if (edx < 0) {
            goto L89;
        } else {
            tmp1 = local26 & edx;
            if (tmp1 != 0) {
                goto L88;
            } else {
                local8 = local43 + eax - 0x109a;
                if ((eax - ADDFLAGS32(local43, eax - 0x109a, local8) - 0x2618 & 0x50 & 0x3597) != 0) {
                    goto L86;
                } else {
                    if ((unsigned int)(ecx & 0x33ae) >= 0) {
                        goto L90;
                    }
                }
            }
        }
    }
    eax = proc11();
    if (ecx < 0) {
L80:
    } else {
        if ((eax ^ 1442) - 1650 != 0) {
            goto L80;
        }
    }
    eax = proc8();
    eax = eax - (edx < 0) - 0x1cab;
    flags = SUBFLAGS32(eax, 0, eax);
    if (eax < 0) {
L74:
        eax_17 = eax;
        eax_16 = eax_17 + CF + 0x126f;
        flags = ADDFLAGS32(eax_17, 0x126f, eax_17 + CF + 0x126f);
    } else {
        eax_15 = (eax + 1487 | 372) + 0x1fff;
        eax = (eax_15 | 0x3d73) + LOGICALFLAGS32(eax_15 | 0x3d73) + 0x38bb;
        flags = SUBFLAGS32(0, (eax_15 | 0x3d73) + LOGICALFLAGS32(eax_15 | 0x3d73) + 0x38bb, 0xffffc745 - (eax_15 | 0x3d73) + LOGICALFLAGS32(eax_15 | 0x3d73));
        if (0 < (eax_15 | 0x3d73) + LOGICALFLAGS32(eax_15 | 0x3d73) + 0x38bb) {
            goto L74;
        } else {
            eax_16 = (local11);
            flags = LOGICALFLAGS32(ecx);
            if (ecx <= 0) {
                eax = eax_16 + 0x1c6e;
                flags = ADDFLAGS32(eax_16, 0x1c6e, eax_16 + 0x1c6e);
                goto L74;
            }
        }
    }
    eax = eax_16 - CF + local44 - 0x1b71;
    if ((ecx & eax) < 0) {
L69:
    } else {
        eax = eax ^ local27;
        if (ecx == eax - 0x21ed) {
            goto L69;
        }
    }
    proc1(0);
    proc11();
    proc3();
    eax = GetCurrentThreadId();
    tmp1 = (eax + 0x3d13 ^ 0xf27) & 0x695;
    if (tmp1 != 0) {
L60:
    } else {
        tmp1 = (eax + 0x3d13 ^ 0xf27) & 0x3aa0;
        if (tmp1 != 0) {
            goto L60;
        }
    }
    proc14();
    edx = GetCurrentThreadId();
    if (edx == 0) {
L54:
    } else {
        if (edx >= local41) {
            goto L54;
        }
    }
    proc8();
    proc11();
    eax = proc11();
    eax_18 = eax - 0x237f & 0x2f2a ^ 0x33c3;
    eax = (local42);
    if (local40 != eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + local12 + ADDFLAGS32(eax, 0x832, eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + 0x832) + ADDFLAGS32(eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + 0x832, local12, eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + local12 + ADDFLAGS32(eax, 0x832, eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + 0x832) + 0x832) + 0x1499) {
L45:
L43:
    } else {
        if (eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + local12 + ADDFLAGS32(eax, 0x832, eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + 0x832) + ADDFLAGS32(eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + 0x832, local12, eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + local12 + ADDFLAGS32(eax, 0x832, eax + LOGICALFLAGS32(eax_18 ^ 0x2b27) + 0x832) + 0x832) + 0x1499 < edx) {
            goto L43;
        } else {
            if ((unsigned int)(edx & 0xd50) <= 0) {
                goto L45;
            }
        }
    }
    GetCurrentThreadId();
    proc1((esp - 288));
    proc11();
    proc2();
    GetCurrentThreadId();
    proc1((esp - 332));
    proc2();
    proc5();
    proc2();
    eax = (local24);
    if (0 <= (unsigned int)(eax & 0xe15)) {
    }
    proc1((esp - 68));
    proc14();
    GetCurrentThreadId();
    proc5();
    proc8();
    ecx = GetLastError(); /* Warning: also results in edx */
    eax = proc2();
    eax = (eax ^ 1033 | 0x31a6) + LOGICALFLAGS32(eax ^ 1033 | 0x31a6) + ADDFLAGS32(eax ^ 1033 | 0x31a6, 0xf33, (eax ^ 1033 | 0x31a6) + LOGICALFLAGS32(eax ^ 1033 | 0x31a6) + 0xf33) + 0x4662;
    tmp1 = local37 & ecx;
    if (tmp1 >= 0) {
        tmp1 = local23 & edx;
        if (tmp1 <= 0) {
            eax = (local24);
        }
    }
    proc1(eax);
    proc2();
    proc11();
    proc2();
    if (local28 == edx) {
    }
    proc11();
    eax = proc3(); /* Warning: also results in ecx, edx */
    return eax - 0x167e & 0xcde; /* WARNING: Also returning: ecx := ecx, edx := edx */
}

// address: 0x4027c8
__size32 proc7() {
    int eax; 		// r24
    int ecx; 		// r25
    int edx; 		// r26
    void *esp; 		// r28
    int local0; 		// m[esp - 48]

    proc11();
    eax = proc8();
    if (((eax ^ 0x30ec) & 0x29ee) == 0) {
L8:
L7:
    } else {
        if (edx != (eax ^ 0x30ec)) {
            goto L7;
        } else {
            if ((unsigned int)(eax ^ 0x30ec) <= ecx) {
                goto L8;
            }
        }
    }
    ecx = proc6(); /* Warning: also results in edx */
    if ((unsigned int)(ecx & 0xea1) < 0) {
L2:
    } else {
        if (local0 == edx) {
            goto L2;
        }
    }
    eax = proc1((esp - 292));
    return eax;
}

// address: 0x404fc5
int proc8() {
    unsigned int eax; 		// r24
    int eax_1; 		// r24{16}
    unsigned int ecx; 		// r25
    int edx; 		// r26
    unsigned char local0; 		// m[esp - 128]
    int local1; 		// m[esp - 260]
    unsigned int local2; 		// m[esp - 420]

    if ((ecx & edx) == 0) {
    }
    eax = (local0);
    eax_1 = (eax ^ 0x256b) - local1;
    if ((eax_1 & 0x1684) == 0) {
L1:
        eax = eax_1 | 0x39a6;
    } else {
        eax = (eax_1 & 0x23a ^ 0x3c0c) + LOGICALFLAGS32(eax_1 & 0x23a ^ 0x3c0c) + 0x2038;
        if (local2 >= ecx) {
            eax_1 = (eax_1 & 0x23a ^ 0x3c0c) + LOGICALFLAGS32(eax_1 & 0x23a ^ 0x3c0c) + 0x2038 & 0x3890 | 0xae2;
            goto L1;
        }
    }
    return eax;
}

// address: 0x404e96
__size32 proc9() {
    int eax; 		// r24
    unsigned int ecx; 		// r25
    int local0; 		// m[esp - 160]
    int local1; 		// m[esp - 400]
    unsigned int local2; 		// m[esp - 64]

    eax = proc7();
    proc1(eax & 0x25bd);
    proc11();
    proc3();
    proc2();
    ecx = proc4();
    proc5();
    proc5();
    proc2();
    if (ecx <= 0) {
    }
    proc5();
    proc5();
    eax = proc5();
    if ((ecx & eax) == 0) {
L12:
L11:
    } else {
        if (0 == local0) {
            goto L11;
        } else {
            tmp1 = local1 & ecx;
            if (tmp1 <= 0) {
                goto L12;
            }
        }
    }
    proc2();
    proc2();
    if (0 <= local2) {
    }
    proc11();
    eax = proc14();
    return eax - 0x2c6f; /* WARNING: Also returning: ecx := 0 */
}

// address: 0x403199
int proc10(int param1, __size32 param2) {
    int eax; 		// r24
    int local0; 		// param1{33}
    int local1; 		// param1{38}

    local0 = param1;
    local1 = param1;
    if ((param2 & 0x33a8) != 0) {
L1:
        param1 = local0;
        eax = (param1 | 566) - LOGICALFLAGS32(param1 | 566) - 0x2dcd ^ 0x2d49;
        local1 = eax;
    } else {
        if ((param2 & 0xc1) == 0) {
            eax = 0;
            local0 = eax;
            goto L1;
        }
    }
    param1 = local1;
    return param1;
}

// address: 0x4033d3
unsigned int proc11() {
    int eax; 		// r24
    unsigned int eax_1; 		// r24{26}
    void *esp; 		// r28
    int local0; 		// m[esp - 572]
    unsigned short local1; 		// m[esp - 40]
    unsigned short local2; 		// m[esp - 128]
    int local3; 		// m[esp - 48]

    eax = eax + ((esp - 4) < 808) + 0x1733;
    local0 = local0 ^ eax;
    eax_1 = (local1);
    eax = eax_1 + LOGICALFLAGS32(local0) + 0x3992 & 0x3b14;
    if ((unsigned int)(eax_1 + LOGICALFLAGS32(local0) + 0x3992 & 0x3b14) < 0) {
L1:
        eax = eax & 0x16c8 ^ 0x3157;
    } else {
        eax = (local2);
        if ((unsigned int)(eax & 0x3a72) <= 0) {
            eax = eax & local3;
            eax = (eax ^ 0x3293) + LOGICALFLAGS32(eax ^ 0x3293) + 0x1105;
            goto L1;
        }
    }
    return eax;
}

// address: 0x403e66
unsigned int proc12() {
    __size32 eax; 		// r24
    __size32 eax_1; 		// r24{400}
    int eax_2; 		// r24{119}
    int eax_3; 		// r24{867}
    int eax_4; 		// r24{290}
    __size32 eax_5; 		// r24{95}
    unsigned int eax_6; 		// r24{456}
    __size32 eax_7; 		// r24{57}
    void *eax_8; 		// r24{713}
    int eax_9; 		// r24{140}
    unsigned int ecx; 		// r25
    __size32 edi; 		// r31
    unsigned int edx; 		// r26
    void *esp; 		// r28
    __size32 local0; 		// m[esp - 256]
    __size32 local1; 		// m[esp - 320]
    unsigned int local10; 		// m[esp - 248]
    unsigned int local11; 		// m[esp - 188]
    __size32 local12; 		// m[esp - 172]
    int local13; 		// m[esp - 168]
    __size32 local14; 		// m[esp - 12]
    unsigned int local15; 		// m[esp - 296]
    unsigned char local16; 		// m[esp - 116]
    unsigned char local17; 		// m[esp - 76]
    unsigned char local18; 		// m[esp - 232]
    unsigned int local19; 		// m[esp - 228]
    unsigned int local2; 		// m[esp - 16]
    unsigned short local20; 		// m[esp - 152]
    unsigned char local21; 		// m[esp - 136]
    unsigned int local22; 		// m[esp - 248]{1211}
    __size32 local23; 		// %CF{1088}
    __size32 local25; 		// %CF{1133}
    __size32 local3; 		// m[esp - 200]
    __size32 local4; 		// m[esp - 360]
    int local5; 		// m[esp - 56]
    __size32 local6; 		// m[esp - 244]
    unsigned int local7; 		// m[esp - 284]
    int local8; 		// m[esp - 104]
    __size32 local9; 		// m[esp - 20]

    proc14();
    proc2();
    proc14();
    proc11();
    proc5();
    proc2();
    eax_1 = proc8();
    eax = proc2();
    eax = eax - (eax_1 + 0x4cd5 < 0) - 0x33e7;
    if ((edx & 0x8da) != 0) {
L123:
    } else {
        if (eax + LOGICALFLAGS32(edx & 0x8da) + ADDFLAGS32(eax, 0x139a, eax + LOGICALFLAGS32(edx & 0x8da) + 0x139a) + 0x3213 <= local15) {
            goto L123;
        }
    }
    proc11();
    eax = (local18);
    if ((unsigned int)(eax & 0x1f1c) < 0) {
L118:
    } else {
        if ((unsigned int)(edx & (eax ^ 0x3763)) <= 0) {
            goto L118;
        }
    }
    eax = proc8();
    if (edx >= (unsigned int)(eax - local11 + ADDFLAGS32(eax, 0x1c03, eax + 0x1c03) + (eax + 0x1c03 < local11) - 2047)) {
        tmp1 = local5 & edx;
        if (tmp1 >= 0) {
        }
    }
    proc8();
    proc2();
    if (ecx != edx) {
L105:
    } else {
        if ( !(ecx < edx || (unsigned int)(ecx & 0x3de4) > 0)) {
            goto L105;
        }
    }
    proc14();
    proc5();
    do {
        local22 = local10;
        edx = proc16();
        proc2();
        eax_2 = proc8();
        eax = proc8();
        eax_3 = proc1(eax - LOGICALFLAGS32(eax_2 | 0x1e8c) - 0x144d | 896);
        eax = (eax_3 | 0x2f6f) & 0xb97;
        if (((esp - 144) & edx) != 0) {
L86:
            eax = (eax + 0x97c | 0x3192) + 1676;
            local8 += eax;
        } else {
            if ((unsigned int)((((eax_3 | 0x2f6f) & 0xb97) + 0x2512 & 0x17e1) - LOGICALFLAGS32(((eax_3 | 0x2f6f) & 0xb97) + 0x2512 & 0x17e1) - 0x1919 & 0x3f8d) >= 0) {
                eax = (((eax_3 | 0x2f6f) & 0xb97) + 0x2512 & 0x17e1) - LOGICALFLAGS32(((eax_3 | 0x2f6f) & 0xb97) + 0x2512 & 0x17e1) - 0x58a0;
                goto L86;
            }
        }
        proc14();
        proc2();
        eax_4 = proc8();
        local10 = local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252);
        local5 = local5 | (eax_4 & 0x1252) - 0x2e8d;
        if ((unsigned int)((eax_4 & 0x1252) + LOGICALFLAGS32(local5) + ADDFLAGS32((eax_4 & 0x1252) - 0x2e8d, 0x2441, (eax_4 & 0x1252) + LOGICALFLAGS32(local5) - 0xa4c) + 0x2d02 & 0x22e4) >= 0) {
        }
        proc14();
        eax = proc2();
        eax = eax + (eax < 0xd19) + 0x188c;
        local6 += eax;
        flags = SUBFLAGS32(0x3c2d, 0x4398d8, 0xffbca355);
        eax = proc11();
        local7 = local7 - eax + CF;
        proc14();
        proc2();
        eax = proc8();
        eax = eax - local3;
        local4 += eax;
        eax_5 = proc2();
        local13 = local13 & eax_5 + 0x264b & 0xe7b;
        eax = (eax_5 + 0x264b & 0xe7b) + 0x18a9;
        proc1(eax + local1 + ADDFLAGS32(eax_5 + 0x264b & 0xe7b, 0x18a9, eax));
        proc1((esp - 372));
        eax = (local17);
        if ((eax - 0x2ac2 & 0x3de3) == 0) {
        }
        eax_6 = (local16);
        eax = eax_6 + 0x3e8d;
        if ((eax_6 + 0x3e8d & 0x3481) < 0) {
L54:
            flags = LOGICALFLAGS32(eax ^ 0xe68 ^ 0x190c);
        } else {
            if (((esp - 300) & 0x18f0) != 0) {
                goto L54;
            } else {
                flags = LOGICALFLAGS32(esp - 300 & 0x3350);
                if ((unsigned int)(esp - 300 & 0x3350) <= 0) {
                    eax = eax_6 + 0x1624;
                    goto L54;
                }
            }
        }
        local23 = CF;
        global350 = global350 - 1;
        eax = proc2();
        local12 = local12 - eax + (global395 - 1 < 0);
        local1 += eax + 0x756b & 0x1686;
        eax_7 = proc8();
        eax = eax_7 + 0x5a6b;
        local2 = local2 & eax_7 + 0x5a6b;
        if (local14 == 0x43a0ae) {
L39:
            local9 = local9 + local22 - eax + (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) + (eax < (unsigned int)(local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252)));
            eax = ((eax + (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) - local22 - 0x36c4 | 0x1c09) ^ 0xa19) & 0x1183 ^ 0x39c4;
            flags = LOGICALFLAGS32(((eax + (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) - local22 - 0x36c4 | 0x1c09) ^ 0xa19) & 0x1183 ^ 0x39c4);
        } else {
            eax = (eax_7 - LOGICALFLAGS32(0) + 0x2e47 ^ 0x33cd ^ 0x1cb0) - local19;
            flags = SUBFLAGS32(local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252), 0x43a0ae, local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) - 0x43a0ae);
            if (local22 - (eax_4 & 0x1252) + LOGICALFLAGS32(eax_4 & 0x1252) == 0x43a0ae) {
                eax = (eax_7 - LOGICALFLAGS32(0) + 0x2e47 ^ 0x33cd ^ 0x1cb0) + ADDFLAGS32((eax_7 - LOGICALFLAGS32(0) + 0x2e47 ^ 0x33cd ^ 0x1cb0) - local19, 0x22fc, (eax_7 - LOGICALFLAGS32(0) + 0x2e47 ^ 0x33cd ^ 0x1cb0) - local19 + 0x22fc) - local19 + 0x51c0;
                eax = (local21);
                eax = (eax | 1919) ^ 0x2a15;
                goto L39;
            }
        }
        local25 = CF;
        eax = eax + local25 + 0x16be;
        eax_8 = proc1(eax);
        if ((esp - 140) < eax_8) {
        }
        proc5();
        proc5();
        proc1((esp - 80));
        proc1((esp - 336));
        proc14();
        proc11();
        proc2();
        proc2();
        proc14();
        proc5();
        proc1(0);
        proc5();
        proc2();
        proc14();
        local0 = local0 - eax + ((unsigned int)(eax_9 & 0x274a) < 0x279b);
        edi = edi + local23 - global400 + 0x33b4;
    } while (0 != *0x4398d8);
    eax = (local20);
    if ( !((LOGICALFLAGS32(0) + 0x43b527 & 0xecc) != 0 || eax > 0)) {
        eax = eax - 0x3695;
    }
    return eax; /* WARNING: Also returning: ecx := 0x43a09a, edx := LOGICALFLAGS32(0) + 0x43b527 */
}

// address: 0x4031c8
__size32 proc13() {
    int eax; 		// r24
    unsigned int eax_1; 		// r24{16}
    int eax_2; 		// r24{164}
    __size32 *ebp; 		// r29
    __size32 ebp_1; 		// r29{147}
    unsigned int ecx; 		// r25
    unsigned int edx; 		// r26
    unsigned char local0; 		// m[esp - 396]
    __size32 local1; 		// m[esp + 8]

    eax = 0;
    if ((ecx & 0x2ff) == 0) {
L12:
        eax_2 = eax;
        eax = eax_2 + eax_2 & 0x1720;
        flags = LOGICALFLAGS32(eax_2 + eax_2 & 0x1720);
    } else {
        eax_1 = (local0);
        eax = ((eax_1 ^ 0x22d6) + LOGICALFLAGS32(eax_1 ^ 0x22d6) + 0x3449 & 0xed8) + 0x3dba;
        flags = LOGICALFLAGS32(((eax_1 ^ 0x22d6) + LOGICALFLAGS32(eax_1 ^ 0x22d6) + 0x3449 & 0xed8) + 0x3dba & 0x334);
        if ((((eax_1 ^ 0x22d6) + LOGICALFLAGS32(eax_1 ^ 0x22d6) + 0x3449 & 0xed8) + 0x3dba & 0x334) == 0) {
            goto L12;
        }
    }
    if ((unsigned int)(eax + CF + eax + CF + ADDFLAGS32(eax, 0xdac, eax + CF + 0xdac) + 0x42d4 & 0x2069 & 0x2421) < edx) {
L6:
    } else {
        if (edx <= ecx) {
            goto L6;
        }
    }
    proc2();
    proc15();
    global448 = local1;
    ebp_1 = *ebp;
    *(__size32*)ebp = global430 + global427;
    return ebp_1;
}

// address: 0x404e3c
unsigned int proc14() {
    unsigned int eax; 		// r24
    unsigned int ecx; 		// r25
    unsigned int local0; 		// m[esp - 336]
    unsigned short local1; 		// m[esp - 52]
    unsigned char local2; 		// m[esp - 332]
    unsigned int local3; 		// m[esp - 300]

    eax = (local2);
    eax = eax ^ 0x33cd ^ 0x344b ^ 0x22b9;
    if (local3 != eax) {
L2:
        eax = (local1);
        eax = eax ^ 0x3278 | 0x3622;
    } else {
        eax = 0;
        if (ecx < 0) {
            goto L2;
        } else {
            if (0 == local0) {
                goto L2;
            }
        }
    }
    return eax;
}

// address: 0x407943
void proc15() {
    __size8 bh; 		// r15
    int ebx; 		// r27
    __size32 edx; 		// r26
    int local0; 		// m[esp]

    global427 = edx + 719 ^ global427;
    global430 = local0 & 0xffff0000;
    global334 = global334 - (ebx & 0xffff00ff | (bh + ADDFLAGS32(edx, 719, edx + 719) + 9) * 256) + (edx + 719 ^ global427) + LOGICALFLAGS32(edx + 719 ^ global427) + 0x3336;
    return;
}

// address: 0x4061df
__size32 proc16() {
    unsigned int bl; 		// r11
    int ebx; 		// r27
    unsigned int ecx; 		// r25
    __size32 esi; 		// r30

    global336 = global336 - 0x25bb;
    global330 = ebx & 0xffff00ff | bl * 256;
    global325 = global340;
    esi = *0x439b04;
    global333 = 0x10be;
    global326 += esi;
    global334 = global334 - esi;
    global336 = esi;
    global332 = global337;
    global337 = global322;
    global322 = global324;
    global325 = (ecx / 16 + SHRFLAGS32(ecx / 16, ecx, 4) + 0x248a) / 8;
    global326 += 49;
    global326 += 0x3752;
    ecx = global324 / 0x80000 ^ global324 ^ global332 * 0x800 ^ global332 ^ (global332 * 0x800 ^ global332) / 256;
    global324 = ecx;
    global328 = ecx;
    return global324;
}

