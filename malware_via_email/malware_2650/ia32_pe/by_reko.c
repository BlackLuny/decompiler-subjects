// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000()
void fn00401000()
{
fn00401000_entry:
l00401000:
fn00401000_exit:
}

// 00401105: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 esp_43;
	word32 ebp_44;
	word32 edx_45;
	byte SZO_46;
	byte C_47;
	byte SCZO_48;
	word32 esi_49;
	word32 edi_50;
	word32 ecx_51;
	word32 ebx_52;
	word32 eax_53;
	byte Z_54;
	byte al_55;
	byte cl_56;
	byte dl_57;
	NTDLL.dll!NtSetSystemEnvironmentValueEx();
	if (eax_53 != 0xC0000002)
	{
		int3();
		word32 esp_522;
		word32 ebp_523;
		word32 edx_524;
		byte SZO_525;
		byte C_526;
		byte SCZO_527;
		word32 esi_528;
		word32 edi_529;
		word32 ecx_530;
		word32 ebx_531;
		word32 eax_532;
		byte Z_533;
		byte al_534;
		byte cl_535;
		byte dl_536;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_537;
		word32 ebp_538;
		word32 edx_539;
		byte SZO_540;
		byte C_541;
		byte SCZO_542;
		word32 esi_543;
		word32 edi_544;
		word32 ecx_545;
		word32 ebx_546;
		word32 eax_547;
		byte Z_548;
		byte al_549;
		byte cl_550;
		byte dl_551;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_552;
		word32 ebp_553;
		word32 edx_554;
		byte SZO_555;
		byte C_556;
		byte SCZO_557;
		word32 esi_558;
		word32 edi_559;
		word32 ecx_560;
		word32 ebx_561;
		word32 eax_562;
		byte Z_563;
		byte al_564;
		byte cl_565;
		byte dl_566;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_567;
		word32 ebp_568;
		word32 edx_569;
		byte SZO_570;
		byte C_571;
		byte SCZO_572;
		word32 esi_573;
		word32 edi_574;
		word32 ecx_575;
		word32 ebx_576;
		word32 eax_577;
		byte Z_578;
		byte al_579;
		byte cl_580;
		byte dl_581;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_582;
		word32 ebp_583;
		word32 edx_584;
		byte SZO_585;
		byte C_586;
		byte SCZO_587;
		word32 esi_588;
		word32 edi_589;
		word32 ecx_590;
		word32 ebx_591;
		word32 eax_592;
		byte Z_593;
		byte al_594;
		byte cl_595;
		byte dl_596;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_597;
		word32 ebp_598;
		word32 edx_599;
		byte SZO_600;
		byte C_601;
		byte SCZO_602;
		word32 esi_603;
		word32 edi_604;
		word32 ecx_605;
		word32 ebx_606;
		Eq_2 eax_607;
		byte Z_608;
		byte al_609;
		byte cl_610;
		byte dl_611;
		RTUTILS.dll!TraceDumpExA();
		fn00401000();
		return eax_607;
	}
	else
	{
		*(esp_43 - 0x04) = fp - 0x40;
		*(esp_43 - 0x08) = fp - 0x40;
		*(esp_43 - 0x0C) = fp - 0x40;
		*(esp_43 - 0x10) = fp - 0x40;
		*(esp_43 - 0x14) = fp - 0x40;
		word32 ebp_112;
		word32 edx_113;
		byte SZO_114;
		byte C_115;
		byte SCZO_116;
		word32 esi_117;
		word32 edi_118;
		word32 ecx_119;
		word32 ebx_120;
		word32 eax_121;
		byte Z_122;
		byte al_123;
		byte cl_124;
		byte dl_125;
		word32 esp_111;
		NTDLL.dll!NtQuerySemaphore();
		if ((eax_121 ^ 0xC0000003) != 0x00 && (eax_121 ^ 0xC0000003) != 0x01)
		{
			fn00401000();
			esp_111 = esp_111 + 0x04;
		}
		word32 * esp_136 = esp_111 - 0x04;
		*esp_136 = 0x00;
		*(esp_136 - 0x04) = 0x00;
		*(esp_136 - 0x08) = 0x00;
		*(esp_136 - 0x0C) = 0x00;
		*(esp_136 - 0x10) = 0x00;
		*(esp_136 - 0x14) = 0x00;
		*(esp_136 - 0x18) = 0x00;
		ptr32 esp_150;
		ptr32 ebp_151;
		word32 edx_152;
		byte SZO_153;
		byte C_154;
		byte SCZO_155;
		word32 esi_156;
		word32 edi_157;
		word32 ecx_158;
		word32 ebx_159;
		ui32 eax_160;
		byte Z_161;
		byte al_162;
		byte cl_163;
		byte dl_164;
		RTUTILS.dll!TraceDumpExA();
		if (eax_160 != 0x57)
		{
			fn00401000();
			return eax_160 - 0x57;
		}
		else
		{
			int32 eax_175 = 0x800FF9D2 - eax_160;
			word32 v16_176 = 0x00 - eax_175;
			ui32 v17_182 = v16_176 + ((dwLoc4C & (fp - (ui32 *) 0x40 & 0x00) + (eax_160 - 0x57)) + 2272615812 ^ 0x077AA4FF);
			Mem187[fp - 0x04 + -0x18:word32] = v17_182;
			word32 v20_208 = (dwLoc14 & 0x00) + ((fp - 0x04) + -((eax_175 *s 0x00 ^ 0x02A8) + ~0xFF));
			*(esp_150 - 0x04) = 0x00415000;
			ui32 edx_226 = ~((dwLoc08 & v17_182) + -((v20_208 - ~0x0F) *s 0x00 | 0x30));
			*(esp_150 - 0x08) = edx_226 - ~0x00;
			Eq_312 esi_196 = v17_182 - ((v16_176 + 0x8070A97B ^ ~0x00) + 0x01) + dwLoc1C;
			*(esp_150 - 0x0C) = (LPVOID *) esi_196;
			*(esp_150 - 0x10) = fp - (ui32 *) 0x01AC;
			int32 edi_243;
			fn0040135D(0x00415000, ebp_151, out edi_243);
			*(esp_150 - 0x0C) = 0x40;
			*(esp_150 - 0x10) = 0x3000;
			*(esp_150 - 0x14) = fp - (ui32 *) 0x28;
			*(esp_150 - 0x18) = 0x00;
			Eq_368 eax_268 = VirtualAlloc(*(esp_150 - 0x18), *(esp_150 - 0x14), *(esp_150 - 0x10), *(esp_150 - 0x0C));
			struct Eq_395 * dwLoc20_217 = v20_208 - ~0x0F;
			int32 dwLoc08_229 = edx_226 - ~0x00;
			Eq_399 dwLoc1C_258 = dwLoc1C & 0x00;
			ptr32 esp_269 = esp_150 - 0x08;
			Eq_368 dwLoc0C_270 = eax_268;
			Eq_368 ebx_271 = null;
			uint32 dwLoc01B0_278 = dwLoc01B0 & 0x00;
			if (0x00 == 0x00)
			{
				while (dwLoc01B0_278 < v20_208->dw0008)
				{
					word32 * esp_445 = esp_269 - 0x04;
					*esp_445 = 0x00415000;
					*(esp_445 - 0x04) = dwLoc20_217->t0004;
					*(esp_445 - 0x08) = dwLoc20_217->dw0000 + 0x00400000;
					Mem460[esp_445 - 0x0C + 0x00:word32] = eax_268 + dwLoc1C_258;
					fn00401352(dwLoc01B0_278, ebp_151);
					esp_269 = esp_445 - 0x0C;
					dwLoc1C_258 = (Eq_399) ((char *) dwLoc1C_258 + dwLoc20_217->t0004);
					dwLoc01B0_278 = dwLoc01B0_278 + 0x01;
					dwLoc20_217 = dwLoc20_217 + 0x01;
				}
				word32 * esp_475 = esp_269 - 0x04;
				*esp_475 = 0x00400000;
				*(esp_475 - 0x04) = v13;
				int32 ebx_494 = dwLoc01B0_278 & 0x00;
				ui32 eax_502 = *((char *) (v20_208 + ebx_494 / 0x0C) + 0x04) + (ebx_494 - v15) / 0x0C;
				*(esp_475 - 0x08) = eax_502;
				ui32 eax_506 = eax_502 & 0x00 | v12;
				*(esp_475 - 0x0C) = eax_506;
				*(esp_475 - 0x10) = eax_506 + 0x00035000;
				*(esp_475 - 0x14) = v12;
				return eax_506 + 0x00035000;
			}
			else
			{
l004012B4:
				*(esp_150 - 0x0C) = (LPVOID *) ebx_271;
				Eq_2 eax_307 = dwLoc0C_270 - esi_196;
				Eq_368 v43_313 = dwLoc0C_270 & ebx_271 *s 0x00 | eax_307;
				dwLoc0C_270 = v43_313;
				ebx_271 = dwArg0C;
				if (v43_313 < dwArg0C)
				{
					ui32 ecx_369 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg10[dwLoc08_229].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] & 0xFF ^ ~0x00;
					union Eq_2 * ecx_379 = (char *) v43_313 + (ecx_369 + 0x01 & 0x00 ^ dwArg04);
					word32 ecx_390 = DPB(Mem301[ecx_379 + 0x00:word32], (byte) ((~(-esi_196 - 0x01 | ~Mem301[dwArg08 + v43_313:word32]) & 0xFF) + (ecx_369 + 0x01)), 0);
					*(esp_150 - 0x0C) = 0x00;
					*ecx_379 = *(esp_150 - 0x0C);
					*(esp_150 - 0x0C) = (union Eq_2 **) ecx_379;
					Mem405[ecx_379 + 0x00:word32] = Mem401[ecx_379 + 0x00:word32] + -ecx_390 + fn004013B9();
					eax_307 = (*ecx_379 ^ ~0x00) + 0x01;
					*ecx_379 = (union Eq_2 *) eax_307;
					int32 edi_417 = (edi_243 & 0x00) + dwLoc08_229;
					dwLoc08_229 = edi_417 + 0x01;
					edi_243 = edi_417;
					if (edi_417 == 0x00)
						dwLoc08_229 = edi_417 + 0x01 & 0x00;
					if (dwLoc08_229 != 1880)
						goto l004012B4;
				}
				return eax_307;
			}
		}
	}
}

// 00401352: void fn00401352(Register uint32 ebx, Register ptr32 ebp)
void fn00401352(uint32 ebx, ptr32 ebp)
{
	if (true)
	{
		fn00401000();
		return;
	}
	else
	{
		word32 edi_9;
		uint32 ebx_10 = fn0040135D(ebx, ebp, out edi_9);
		return;
	}
}

// 0040135D: Register uint32 fn0040135D(Register uint32 ebx, Register ptr32 ebp, Register out ptr32 ediOut)
uint32 fn0040135D(uint32 ebx, ptr32 ebp, ptr32 & ediOut)
{
	*ediOut = edi;
	if (true)
	{
		fn00401000();
		return ebx;
	}
	else
	{
		word32 edx_30 = *(ebp - 0x08) + -~0x152F;
		*(ebp - 0x14) = *(ebp - 0x14) & 0x00;
		*(ebp - 0x14) = *(ebp - 0x14) + edx_30;
		uint32 ebx_42 = (ebx & 0x00) + *(ebp - 0x10);
		*(ebp - 0x08) = -*(ebp - 0x08);
		word32 edi_58;
		*ediOut = *(ebp - 0x14);
		return ebx_42;
	}
}

// 004013B9: FlagGroup bool fn004013B9()
bool fn004013B9()
{
	return false;
}

