/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1553/ia32_pe/subject.exe'
 */

/* DEST BLOCK NOT FOUND: 00401009 -> 004013cb */
/* DEST BLOCK NOT FOUND: 0040107c -> 00401408 */
/*	Procedure: 0x00401007 - 0x00401058
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401007()
{



    if(al & 8) {
        goto L004013cb;
    }
L0040100f:
    asm("smsw ax");
    if(al & 2) {
        goto L0040100f;
    }
    edi = edi + 1519416561;
    if(dl = dl - 1) {
        goto L004012b9;
    }
    > ? L004012b9 : ;
    *eax = *eax | dl;
    *eax = *eax + cl;
    al = al + 4;
    asm("rol dh,cl");
    asm("rol bh,0x1d");
    ebx = ~bh | edi;
    asm("rcl al,cl");
    return;
    edx = -813846266;
    ah = ~ah;
    ecx = ecx & -114972661;
    asm("adc ecx,0xa5d0a616");
    if(ecx = ecx - 1) {
        goto L00401087;
    }
    != ? 0x401087 : ;
    *(eax + -1957363328) = *(eax + -1957363328) + 236;
}

/* DEST BLOCK NOT FOUND: 004010bf -> 1b05d0d6 */
/* DEST BLOCK NOT FOUND: 00401173 -> 00401030 */
/* DEST BLOCK NOT FOUND: 00401179 -> 00401030 */
/* DEST BLOCK NOT FOUND: 004013d3 -> 00401007 */
/* DEST BLOCK NOT FOUND: 004013d9 -> 00401006 */
/*	Procedure: 0x00401059 - 0x004014ED
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    (save)ebp;
    ebp = esp;
    edi = edi - -1761195917;
    edx = ebx;
    esi = -1425224547;
    edi = edi + ebx - -393879555;
    edx = edx + -1398198602;
    edi = edi - 1;
    edx = edx - ebx;
    edi = edi + 1;
    edx = edx + 1;
    goto L00401408;
    *edi = al;
    edi = edi + 1;
    ah = ah + *eax;
    *eax = *eax - 1;
    *(edx + -2115775755) = *(edx + -2115775755) | 217;
    asm("in al,dx");
    ecx = ecx - 1;
    esi = esi + 1;
    (fsave)(frestore) / *ebx;
    return(al - 138);
    ch = ch ^ 254;
    asm("ror cl,cl");
L0040109c:
    asm("rcl ah,cl");
    ch = ch - 173 ^ bh;
    asm("adc edi,0xe8dcdd31");
    if(!(ah = ah | bh)) {
        != ? 0x40130a : ;
        *(eax + 1 + 1 + -964578361) = *(eax + 1 + 1 + -964578361) | eax + 1 + 1;
L004010b8:
        bl = 79;
        goto L1b05d0d6;
        cl = !L9A5983D2;
        bl = !bl;
        asm("fnclex");
        goto L004013c6;
        *(eax - 86) = *(eax - 86) & al;
L004010da:
        asm("rcr dl,cl");
        asm("ror ch,0x9");
        dl = dl << cl;
        dl = 163;
        asm("ror dl,cl");
        cl = !ch ^ 1;
        bl = bl << cl;
        goto L00401269;
        asm("adc [eax],cl");
        eax = eax + 1;
L004010f4:
        asm("adc edi,0x4634e2db");
        edx = ebx;
        ebx = 128140925;
        cl = 154;
        dl = dl >> 154;
        asm("ror bl,cl");
        cl = cl ^ dh;
        if(!(ecx = ch ^ 220 | esi)) {
            != ? 0x401220 : ;
            ah = ah + *eax;
            bh = bh + bh;
            *edi = al;
            edi = edi + 1;
            al = al + 129;
L00401122:
            asm("ror byte [eax+0x8032e50a],cl");
            asm("int 0xa9");
            al = al << cl;
            bl = bl | bh;
            cl = !cl;
            eax = eax ^ ebx;
            asm("rcl dl,cl");
            esi = ecx;
            edx = edx ^ (ch | ah);
            asm("rcr al,cl");
            if(!(al = al | ah)) {
                >= ? 0x401148 : ;
                *edi = al;
                edi = edi + 1;
                *eax = *eax | al;
                *edx = *edx + esi;
            }
            asm("stc");
            dl = ~dl;
            ecx = (ecx & -420966036) + 2075374443;
            eax = eax + 1;
            bl = bl - 1;
            ch = ch - 90;
            asm("adc al,0x4c");
            dl = 178;
            asm("sbb edx,0x377e9311");
            asm("adc ebx,0x15c62768");
            esi = esi + ebx;
            if(edx = edx | edi) {
                goto L00401030;
            }
            > ? L00401030 : ;
            *eax = *eax + al;
            bh :: 0;
            *(edx + 197459460) = *(edx + 197459460) & ch;
L00401186:
            asm("int1");
            ah = ((al | 22) & -112435453) >> cl;
            asm("sbb al,0x81");
            edi = -1489968755;
            asm("rol bl,cl");
            cl = cl + bl;
            bl = bh + 1 - 1;
            asm("jpe 0x4012ef");
            asm("jpo 0x4012ef");
            eax = eax + 1;
            bh = bh + bh;
            *(eax - 64) = *(eax - 64) | al;
L004011b6:
            asm("iret");
            asm("sbb al,al");
            asm("rcr dword [esi],0x80");
            *edi = (frestore);
            asm("rol bh,0x15");
            bh = bh & 131;
            asm("ror bh,0x1e");
            asm("int 0x2e");
            if(!(ebx = ebx | -1305978642)) {
                > ? L004011f6 : ;
                *eax = *eax | 16;
L004011d7:
                dh = dh + 1;
                al = al | dl;
                asm("adc cl,0x18");
                asm("adc edi,0x70c14b44");
                ah = ah << cl;
                dl = dl + 207;
                asm("rcl bh,cl");
                asm("ror ah,0x8");
                goto L0040124a;
                *(eax + 32) = *(eax + 32) + 1;
                *eax = *eax | ah;
                eax = eax + 1;
            }
            cl = cl | ch;
            bh = bh << cl;
            asm("ror bl,0x10");
            bh = bh >> cl;
            ch = ch & 105;
            bl = bl >> cl;
            ch = ch >> cl;
            asm("rol bl,0x4");
            if(edx != -1) {
                al = *(edx - 1);
                goto L0040147f;
            }
            al = 46;
            goto L0040147f;
            *(eax + ecx) = *(eax + ecx) + 66;
        }
        dh = dh | cl;
        esi = esi & 1050279595;
        edx = ecx;
        asm("adc edx,0x699b8c42");
        ebx = eax;
        ch = ch - (edx ^ eax);
        dl = dl | -490918836;
        ecx = -490918835;
        goto L0040138c;
        eax = eax + 1 + 1;
        *eax = *eax + edx;
        asm("adc [eax],al");
L0040124a:
        esi = esi | -199178346;
        al = (al >> cl) + bh;
        edx = edx | eax;
        ch = bh;
        edx = edx + 1;
        asm("adc ch,0x5b");
        bl = bl - 89;
        goto L00401458;
        *(eax + 1107296776) = *(eax + 1107296776) + eax;
L00401269:
        edx = 0;
        cl = cl | 147;
        ebx = -801130063;
        ecx = ecx - 1;
        asm("sbb edi,0xdff0a501");
        ch = cl + 1 & 196;
        if(esi = esi & -1647956835) {
            goto L004011b6;
        }
        > ? L004011b6 : ;
        *(edx + 50057730) = *(edx + 50057730) - 253;
L00401295:
        dh = dh + 1;
        ch = ch << cl;
        bh = bh | dh;
        ah = ~L0E585D0C - 99;
        edx = 1011497351;
        goto L004013e3;
        al = al + 1 + 4;
        ch = ch + *(edx + 19064961);
        (restore)ebx;
        asm("rep mov ah,bh");
        ah = ah >> cl;
        asm("adc edx,0x72903713");
        ah = (ah & 238 ^ ebx) << cl << cl;
        asm("sbb ecx,0x46898538");
        asm("rol ch,0x12");
        eax = 0;
        if(ecx = ecx + 1) {
            goto L004010da;
        }
        >= ? L004010da : ;
        al = 64;
        asm("rcr ch,cl");
        bl = bl << cl;
        al = ~al;
        asm("sbb ch,0xd6");
        asm("ror cl,cl");
        asm("rcr cl,cl");
        ch = 235;
        eax = eax + -280170785;
        edi = edi + 1;
    } else {
        al = al ^ 201;
        asm("ror bl,0xd");
        al = (eax ^ ecx) + dl;
        asm("ror cl,cl");
        al = al - ch;
        asm("rcr dl,cl");
        dl = dh;
        bh = bh ^ dl;
        ch = ch - ah;
        bl = bl | dl;
        ecx = ecx - 1913609849;
        ah = ah >> cl;
        goto L004014bc;
        al = al + 8;
        *edi = al;
        edi = edi + 1;
        *edi = al;
        edi = edi + 1;
        *eax = *eax + eax;
        (save) *(ecx + -2133620051);
L00401336:
        asm("cmc");
        asm("Unknown opcode 0xdb");
        eax = eax | ebx;
        edi = edi & 1114403284;
        esi = esi + ebx;
        dl = dl ^ ah;
        goto L00401122;
        asm("adc [edx+0x48be0020],ch");
L00401352:
        asm("jpe 0x40136e");
        dl = edx + 1 - 1;
        asm("rol ch,cl");
        asm("rcl bl,cl");
        ah = ah ^ 0;
        asm("rol bl,0x3");
        asm("rcl bl,cl");
        ah = ah - 1;
        ecx = ecx - 1440083962;
        asm("rcl bh,cl");
        dh = (edx ^ ecx) & 156;
        if(ecx = ecx | -1350805441) {
            goto L004010b8;
        }
        >= ? L004010b8 : ;
        al = al + 8;
        *(eax + -248337792) = *(eax + -248337792) + 3;
L0040138c:
        asm("salc");
        asm("rol dh,0x6");
        dl = dl ^ ah;
        asm("rol ch,0x3");
        ecx = ch >> cl & 1975106190;
        asm("adc cl,0xc9");
        bl = bl << cl;
        asm("ror al,cl");
        asm("sbb dl,0xa");
        asm("sbb esi,0x7e725fcc");
        if(al = al - 180) {
            goto L00401336;
        }
        >= ? 0x401336 : ;
        al = al + 2 + 16;
        *(edx + 1787861768) = *(edx + 1787861768) + ebp;
L004013c6:
        *(ecx - 55) = *(ecx - 55) + bl;
        asm("smsw ax");
        if(ecx + 1 != 2) {
            goto L00401007;
        }
        goto L00401006;
        *eax = *eax + 1;
        *eax = *eax & al;
        *(ecx + 1303853256) = *(ecx + 1303853256) | al;
L004013e3:
        esi = esi + 1;
        asm("sbb dh,0x9e");
        asm("ror cl,0x1b");
        eax = eax - ebx;
        cl = cl | bl;
        asm("ror bh,cl");
        dh = dh >> cl;
        if(ebx = ebx + 1) {
            goto L004011d7;
        }
        > ? L004011d7 : ;
        *eax = *eax | cl;
        al = al + *edx;
L00401408:
        esi = esi - ebx;
        asm("sbb edi,0x87e7bb71");
        esi = esi - eax;
        edi = edi + 1777292278;
        ecx = (ecx - edx ^ ebx) + 1 | edx;
        esi = eax;
        asm("sbb edi,0xe7e888ca");
        if(!(esi = esi - eax)) {
            >= ? 0x401432 : ;
            *edx = *edx + eax;
            *edx = *edx & al;
            *ebx = *ebx + 1;
        }
        asm("Unknown opcode 0xc7");
        al = al - dh;
        esi = esi + 1;
        eax = bh - -1955809223;
        ecx = ecx ^ esi;
        asm("rcl bh,cl");
        asm("rol dl,cl");
        bl = ~bl;
        asm("rcl bh,cl");
        asm("ror ch,cl");
        goto L00401352;
        al = al + 1;
        asm("adc [edx+0xcd0a0810],ch");
L00401458:
        edx = edx + -381942935;
        asm("ror cl,cl");
        eax = ebx;
        ch = ch ^ 106;
        bh = !bh >> cl;
        edx = edx - 1;
        ebx = ebx | -212639940;
        dh = !dh;
        asm("rcl bh,cl");
        goto L004010f4;
        *edi = al;
        edi = edi + 1;
        *edi = al;
        edi = edi + 1;
L0040147f:
        Lc04014b3();
        if(*(ecx + eax * 4) = *(ecx + eax * 4) + 1) {
            goto L0040109c;
        }
        ecx = ecx ^ ebx;
        edx = edx & -780876585;
        ecx = ecx | -206637334;
        edi = edi + ecx;
        eax = -262877590;
        asm("adc edi,0x85c655f5");
        if(ecx = ecx - 1 - -1238156640) {
            goto L00401295;
        }
        > ? L00401295 : ;
        bh = bh + bh;
        asm("adc [ecx+0x9a6498d0],al");
L004014bc:
        eax = eax - 1;
        asm("sbb dh,0xb5");
        asm("rcr dh,cl");
        esi = esi | -283760991;
        asm("rcl cl,cl");
        bh = bh ^ 182;
        cl = ~cl;
        if(edi = edi | edx) {
            goto L00401186;
        }
        > ? L00401186 : ;
        asm("adc [eax],ah");
        *(edx + -571990012) = *(edx + -571990012) - 13;
    }
    *eax = *eax + al;
}

/*	Procedure: 0x004014EE - 0x004015A3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004014EE()
{



    asm("xchg al,[esi]");
    eax = eax + -787469629 + 180553222;
    (restore)eax;
    asm("xchg eax,esi");
    *esi = *esi | al;
    51766799 = eax * ebp;
    asm("a16 jnz 0x40150a");
    al = al - bl;
    asm("popa");
    ah :: *(edi + 117);
    (restore)es;
    dl = dl - *(eax - 79);
    *esi & eax;
    (save)es;
    asm("%s ret");
    esi = esi + 1;
    asm("rol byte [esi-0x57],cl");
    eax = Lc24215e0();
    asm("sbb eax,0x459350ab");
    (save)es;
    (save)es;
    asm("xchg cl,[edx+0x6c8bc50]");
    (save)es;
    eax = eax + -1610201530;
    asm("%d pop eax");
    asm("xchg eax,esi");
    *esi = *esi | al;
    -374740465 = eax * ebp;
    eax = Le86d1ca5();
    asm("jpo 0x401576");
    (save)es;
    (save)es;
    (save)es;
    eax = Leb281d38();
    (restore)es;
    (save)eax;
    ebp = 973473285;
    asm("%s inc esi");
    asm("xchg ch,al");
    cl = 244;
    asm("Unknown opcode 0x82");
    asm("Unknown opcode 0xc7");
    asm("%g mov esi,0xeb060605");
    *edi = eax;
    edi = edi + 4;
    asm("in al,dx");
    (restore)eax;
    asm("xchg eax,esi");
    (restore)es;
    (save)es;
    (save)eax;
    *eax = *eax | ecx;
    (save)es;
    (save)es;
    al = *LC6460505;
    asm("Unknown opcode 0x82");
    eax = L77a851af();
    ebp = ebp + eax;
    -14 = *edi * eax;
    (restore)eax;
    (save)eax;
    asm("Unknown opcode 0x8f");
    eax = eax - 1;
    (save)es;
    (save)es;
    (save)-24;
    asm("xchg eax,esi");
    asm("cwde");
    asm("repne push ss");
    (save)eax;
    asm("sahf");
    asm("lds eax,[esi]");
    (save)es;
    (save)esi;
    (save)ss;
    asm("lds esi,[edx+0xc5d95046]");
    (save)es;
    (save)es;
    al = *%es:0xbae80826];
    asm("repne push ss");
    asm("hlt");
    asm("retf 0x65c7");
}

/* DEST BLOCK NOT FOUND: 0040169b -> ed061fd2 */
stack space not deallocated on return
/*	Procedure: 0x004015A4 - 0x004016C0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004015A4()
{



    *edi = *esi;
    edi = edi + 1;
    esi = esi + 1;
    *esi = *esi | al;
    (save)es;
    asm("in al,dx");
    (restore)eax;
    asm("xchg eax,esi");
    eax = eax + 1182093318;
    (save)es;
    (save)es;
    asm("%e cmp al,bl");
    *esi = *esi | al;
    asm("rcl byte [esi+0x67],1");
    if(al < bh) {
        sp = sp + 1;
        edi = edi + 1;
        *(esi + eax + -2031393337) = *(esi + eax + -2031393337) & ecx;
        (save)es;
        (save)es;
        *L8896502C :: edi;
        (save)es;
        (save)es;
        al - 204 :: bl;
        *esi = *esi ^ *%es:0xfe88636];
        asm("%e push es");
        (save)es;
        asm("a16 jnz 0x4015eb");
        ah = ah - *(edi + 117);
        *edx = *edx | ch;
        *L000000C3 = *L000000C3 ^ ch;
        goto L0040161d;
        (save)cs;
        asm("adc [eax+0x8],ah");
        (save)es;
        (save)es;
        al = al ^ ah;
        dh = dh ^ al;
        *(eax - 62) = *(eax - 62) + edx;
        ebx = ebx + -61;
        (save)es;
        *(esi + -1019855306) = *(esi + -1019855306) | al;
    }
    asm("adc [esi+0xd0060646],ah");
    esi = 912722037;
    asm("xchg ch,[edx]");
    return;
    asm("popa");
    edx = edx + *eax;
    asm("bound eax,[esi+0x6]");
    (save)es;
    asm("loopne 0x40166e");
L0040161d:
    (save)es;
    *(al + *(ebp + 6) + -958994298) = *(al + *(ebp + 6) + -958994298) | al + *(ebp + 6);
    asm("%s xor eax,ebx");
    dh = dh & *ecx;
    goto L0000ec06;
    if(!(al = L6a2821b0() | 232)) {
        (restore)eax;
        (save)eax;
        asm("loope 0x401649");
        (save)es;
        (save)es;
        al = *L05863636;
        asm("%s push dword 0xe82d0e75");
        edi = edi + 1;
        al = al ^ *esi;
L00401652:
        (save)es;
        (save)es;
    }
    (save)1640171638;
    eax = eax | ebx;
    asm("popa");
    (save)cs;
    asm("adc [ebp+eax*2+0x6],al");
    eax = Led061fd2(es) ^ ebx;
    asm("loop 0x401694");
    return;
    asm("popa");
    ebx = ebx | eax;
    asm("popa");
    (save)cs;
    asm("adc [eax],ch");
    *esi & eax;
    (save)es;
    esi = eax;
    eax = eax - 1;
    (save)es;
    (save)es;
    al = *LC3062636;
    (save)es;
    asm("Unknown opcode 0x26");
    asm("Unknown opcode 0xc6");
    asm("%s xor ebp,eax");
    *edx :: ch;
    (save)1640172407;
    esi = esi | *(eax + 112070662);
    (save)es;
    (save)es;
    (save)917507189;
    (save)eax;
    goto L00003a08;
    asm("%d ret");
    esi = esi + 1;
    goto L00401652;
    asm("in al,dx");
    (restore)eax;
    asm("xchg eax,esi");
    al :: *esi;
    2011752975 = eax * ebp;
    (restore)es;
    Lee901f23();
    *esi = *esi | al;
    return(L49b15135(es));
}

/*	Procedure: 0x004016C1 - 0x004016F6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004016C1()
{



    edx = -2058071951;
    (save)es;
    (save)es;
    al = *L3A368646;
    asm("%s inc esi");
    (save)eax;
    eax = -402258363;
    if(!( *edi & 198)) {
        dl = dl - *LE8060645;
        asm("lds eax,[%ds:esi]");
        (save)es;
        (save)-186252427;
    }
    (save)es;
    asm("Unknown opcode 0xc7");
    (save)eax & 101058649;
    asm("daa");
    *esi = *esi | al;
    (save)es;
    *(esi + 38) = *(esi + 38) | al;
    asm("%s inc esi");
}

/*	Procedure: 0x004016F7 - 0x00401731
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004016F7()
{



    808890383 = eax * ebp;
    (save)es;
    al = al ^ *esi;
    (save)es;
    asm("a16 jnz 0x40170b");
    dh = dh - *(eax + 141911814) - *(eax + -989114173);
    (save)es;
    (save)es;
    ah :: *(eax + 1183221254);
    if(ch == al) {
        asm("Unknown opcode 0xc6");
        asm("%s xor ebp,eax");
        -970705176 = *eax * ecx;
    }
    asm("xchg eax,esi");
    L3e62ff30();
    (save)eax;
    asm("rep add ebx,-0x3d");
}

/*	Procedure: 0x00401732 - 0x00401732
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401732()
{



}

/*	Procedure: 0x00401733 - 0x00401733
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401733()
{



}

/*	Procedure: 0x00401734 - 0x00401738
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401734()
{



    al = al | ch;
    asm("retf 0x6900");
}

stack space not deallocated on return
/*	Procedure: 0x00401739 - 0x004017A3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401739()
{



    (restore)es;
    asm("Unknown opcode 0xc6");
    asm("in al,dx");
    esp = esp ^ *(edi - 36);
    (save)ds;
    (save)es;
    (save)es;
    (save)es;
    eax = L08b80044();
    asm("enter 0xc7cc,0x25");
    asm("in al,dx");
    (save)es;
    (save)es;
    asm("hlt");
    if(!(esi = esi + 1)) {
        asm("Unknown opcode 0xc7");
        eax = eax & 101074602;
        (save)eax;
    }
    ebp = ebp + 1;
    (save)es;
    (save)es;
    eax - 1 :: *(eax + -387333368);
    asm("popa");
    eax = (al | ch) - 119;
    (restore)es;
    eax = L839051d9();
    *esi & eax;
    ds = es;
    (save)-88;
    asm("cwde");
    (save)eax;
    cl = 8;
    (save)es;
    (save)es;
    asm("xchg al,bl");
    dl :: *eax;
    *(esi + 180553222) = *(esi + 180553222) + al;
    eax = L96981a00() + 266889478;
    asm("out 0x15,al");
    *(eax - 69) = *(eax - 69) + edx;
    *esi & eax;
    (save)es;
    ah :: *esi;
    asm("%d inc esi");
    bh = bh | al;
    return(eax & -1010597103);
}

stack space not deallocated on return
/*	Procedure: 0x004017A4 - 0x004017AB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004017A4()
{



    asm("popa");
    (save)cs;
    asm("adc bh,ch");
    esi = esi + 1;
    (save)es;
    (save)es;
}

/*	Procedure: 0x004017AC - 0x004017C9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004017AC()
{



    asm("popa");
    eax = eax | ebx;
    asm("popa");
    (save)cs;
    asm("adc [ecx+0xe80606c5],ch");
    -58 = *ecx * ecx;
    asm("in al,dx");
    edx = edx ^ *(eax + 67);
    eax = eax + 973407750;
    *esi = *esi | dh;
    asm("xchg dl,[eax]");
    asm("retf 0x685");
}

stack space not deallocated on return
/*	Procedure: 0x004017CA - 0x004017D6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004017CA()
{



    (save)es;
    *(ecx + 720518595) = *(ecx + 720518595) ^ dl;
    asm("adc [esi+eax*2+0x6],cl");
    (save)es;
}

stack space not deallocated on return
/*	Procedure: 0x004017D7 - 0x0040181A
 *	Argument size: 20509
 *	Local size: 0
 *	Save regs size: 0
 */

L004017D7()
{



    *edx = *edx + ebp;
    *(ah | *(edi + 117)) = *(ah | *(edi + 117)) ^ ch;
    goto L0040180e;
    (save)cs;
    asm("adc [eax*4+0x56300606],dl");
    edi = -802536948;
    (restore)edx;
    eax = eax + 981878277;
    asm("xchg ah,[eax+0x7a6b91c7]");
    *ecx = *ecx << 1;
    asm("out 0x63,al");
    (restore)es;
    bh = al;
    asm("cmpsb");
    asm("into");
    L54cb0ae0(es, es, es);
    *esi = al;
    (save)es;
    (save)es;
L0040180e:
    asm("rol dword [edx-0x3a],0xc");
    asm("Unknown opcode 0xc6");
    esp = esp - 1;
    asm("Unknown opcode 0xc6");
    eax = gs;
    asm("cwde");
}

stack space not deallocated on return
/*	Procedure: 0x0040181B - 0x00401827
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040181B()
{



    asm("adc al,0x6");
    (save)es;
    (save)es;
    esi = esi + 1;
    ebx = ebx + 1;
    return(*%ss:0x59503686]);
}

/*	Procedure: 0x00401828 - 0x00401828
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401828()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401829 - 0x00401848
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401829()
{



    (fsave)(frestore) * *(edx + ecx - 52);
    eax = eax + 1023790141;
    edx = *(esi - 52);
    eax = eax + -892287171;
    edx = *(esi - 52);
    *L86C3C343 = eax + 1347849021;
    (save)es;
    return(*L86C3C343);
}

/*	Procedure: 0x00401849 - 0x0040184E
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401849()
{



    asm("%d adc cl,cl");
    return(eax + ebx);
}

stack space not deallocated on return
/*	Procedure: 0x0040184F - 0x0040196F
 *	Argument size: 20509
 *	Local size: 0
 *	Save regs size: 0
 */

L0040184F()
{



    asm("Unknown opcode 0xc7");
    asm("cmpsb");
    ebx = ebx + 1;
    asm("lds eax,[esi]");
    (save)es;
    asm("salc");
    *ebx = *ebx + ah;
    eax :: 1025730624;
    ebp :: *(esi + 88);
    asm("xchg eax,esi");
    *esi = *esi | al;
    (save)ss;
    *(L75c01bdd() + 230 + 1676019573) = L75c01bdd() + 230;
    (restore)es;
    (save)es;
    asm("popa");
    *edi = *esi;
    edi = edi + 4;
    esi = esi + 4;
    ebx = ebx + -61;
    *esi = *esi | dh;
    eax = L40901cef() + 109447302;
    asm("out 0x4,al");
    asm("Unknown opcode 0xc6");
    asm("popa");
    asm("Unknown opcode 0xc5");
    asm("Unknown opcode 0xc6");
    asm("hlt");
    asm("Unknown opcode 0xc6");
    asm("arpl [eax],cx");
    esi = esi + 1;
    asm("stc");
    asm("out 0x95,al");
    asm("xchg ah,dh");
    (save)eax;
    asm("xchg cl,al");
    (restore)eax;
    asm("Unknown opcode 0xc7");
    asm("%g dec ebx");
    asm("lds eax,[esi]");
    (save)es;
    asm("Unknown opcode 0xc6");
    asm("in al,dx");
    eax = eax + 134604006;
    asm("Unknown opcode 0xc7");
    asm("in eax,0x16");
    asm("lds eax,[esi]");
    (save)es;
    goto L004018fd;
    (save)es;
    (save)es;
    al :: *esi;
    *esi = *esi | al + 6;
    asm("xchg dh,[%ds:ebx+0x6]");
    asm("arpl [esi],ax");
    (save)es;
    asm("loop 0x401847");
    esi & esp;
    asm("loope 0x40184f");
    if(!(al = eax + *%es:ebp-0x1e] + 227)) {
        (restore)ecx;
        return(L03756926());
        return;
        esi = esi + 1;
        al :: *esi;
        return;
        asm("Unknown opcode 0xc6");
        asm("popa");
        esp = esp + esi;
        cl = al;
        eax = gs;
        asm("cwde");
        return;
        asm("in al,0xc3");
        return;
        return;
        *(ebp + -1010569392) = *(ebp + -1010569392) << 1;
        return(L1e022064());
        return;
        dh :: *%ss:esi];
        eax & 980936937;
L004018fd:
        L64282064();
        dl = dl | al;
        asm("sbb eax,0xabebd5e8");
        (save)eax;
        dh :: al;
        (save)es;
        (save)es;
        if(!(eax = eax + -402246082)) {
            (restore)eax;
            asm("xchg eax,esi");
            (restore)es;
        }
        (save)es;
        140624655 = eax * ebp;
        al = 195;
        *L000000C3 = *L000000C3 ^ ch;
        goto L00401954;
        (save)cs;
        asm("adc [edx+0x30060645],ah");
        asm("into");
        *L24102A49 = *L24102A49 + ah;
        (save)es;
        (save)es;
        (save)es;
        return;
        dl = dl | *(eax - 109);
        eax = eax + -2036333050;
        ch :: *(ecx - 24);
    }
    asm("Unknown opcode 0x0f");
    asm("out 0x15,al");
    (restore)ss;
    goto L000018e8;
    si = si - 1;
    return;
    (save)es;
    (save)es;
    (save)es;
L00401954:
    eax = 70;
    ebx = ebx + -61;
    -374740465 = *%ss:0x6059658] * ebp;
    ebx = ebx + 1;
    return(L159021d9());
}

/*	Procedure: 0x00401970 - 0x00401970
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401970()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401971 - 0x00401980
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401971()
{



    asm("xchg bh,[esi]");
    eax = eax + 143034051;
    eax = L4610215f();
    (save)eax;
    esp = eax;
}

/*	Procedure: 0x00401981 - 0x00401981
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401981()
{



}

/*	Procedure: 0x00401982 - 0x0040198B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401982()
{



    eax = Ld634553c();
    asm("Unknown opcode 0xc7");
    asm("%g pop eax");
    asm("Unknown opcode 0xc4");
}

/*	Procedure: 0x0040198C - 0x0040198C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040198C()
{



}

/*	Procedure: 0x0040198D - 0x0040198D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040198D()
{



}

/*	Procedure: 0x0040198E - 0x00401993
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040198E()
{



    asm("popa");
    bh = bh | ah;
    ch = 60;
}

stack space not deallocated on return
/*	Procedure: 0x00401994 - 0x0040199C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401994()
{



    asm("popa");
    ah :: bh;
    ch = 59;
    (save)eax;
    asm("xchg eax,esi");
    asm("Unknown opcode 0xc4");
}

/*	Procedure: 0x0040199D - 0x0040199D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040199D()
{



}

stack space not deallocated on return
/*	Procedure: 0x0040199E - 0x004019A1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040199E()
{



    (save)eax;
    asm("rol ah,cl");
}

/*	Procedure: 0x004019A2 - 0x004019A2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019A2()
{



}

/*	Procedure: 0x004019A3 - 0x004019A7
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019A3()
{



    asm("%e cmp al,bl");
}

/* DEST BLOCK NOT FOUND: 004019b5 -> d634553c */
/*	Procedure: 0x004019A8 - 0x004019BC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019A8()
{



    (save)es;
    *edi = eax;
    edi = edi + 4;
    asm("in al,dx");
    (restore)eax;
    asm("xchg eax,esi");
    *esi = *esi | al;
    51766799 = eax * ebp;
    goto L0000c343;
}

/*	Procedure: 0x004019BD - 0x004019D9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019BD()
{



    asm("%s xchg al,bl");
    asm("adc [ebp+0xc1060645],ch");
    != ? 0x4019cb : ;
    eax = eax + 554042886;
    asm("enter 0xc32a,0x61");
    *eax = *eax | edx;
    asm("insd");
    ebp = ebp + 1;
    (save)es;
    (save)es;
    asm("rol byte [edi],1");
}

stack space not deallocated on return
/*	Procedure: 0x004019DA - 0x004019EF
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019DA()
{



    asm("popa");
    asm("adc [esi+eax*8+0x6],bh");
    (save)es;
    asm("Unknown opcode 0xc1");
    if(!(eax = eax | 157401898)) {
        al :: *esi;
        (save)es;
    }
    (save)es;
    ds = eax;
    ebx = ebx + 1;
}

/*	Procedure: 0x004019F0 - 0x004019F0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019F0()
{



}

/* DEST BLOCK NOT FOUND: 004019f8 -> 00478fe5 */
stack space not deallocated on return
/*	Procedure: 0x004019F1 - 0x00401A63
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004019F1()
{



    eax = eax + 1177946170;
    (save)es;
    goto L00478fe5;
    if(!(esi = esi + 1)) {
        (save)1969751925;
        al = al + 38;
        asm("arpl [edx],di");
        (save)es;
        asm("Unknown opcode 0xc7");
        asm("Unknown opcode 0xc7");
        asm("xchg eax,ecx");
        if(eax = eax & -1010596947) {
            goto L00401a4d;
        }
        (save)1642595189;
        al = al | ch;
        asm("adc dword [eax+0x49],+0x43");
        return;
        return;
        eax = eax + 985908030;
        asm("out 0x75,eax");
        al = al + 48;
        (restore)ss;
        (restore)ss;
        (restore)ss;
        (restore)ss;
        asm("out 0x75,eax");
        *eax = *eax + esi;
        (restore)ss;
        (restore)ss;
        (restore)ss;
        (restore)ss;
        asm("out 0x75,eax");
        dh = dh + *eax;
    }
    ss = es;
    (save)es;
    (save)es;
    asm("out 0x75,eax");
    asm("adc [eax],dh");
    ss = es;
    (save)es;
    (save)es;
    asm("out 0x75,eax");
    eax = (eax | -1611786704) ^ 269448679;
L00401a4d:
    (save)es;
    (save)es;
    (save)es;
    (save)es;
    al = al - 80;
    asm("out dx,eax");
    esi = esi + 1;
    (save)es;
    (save)es;
    asm("xchg bh,[esi]");
    (save)es;
    return(*LC3033810);
}

stack space not deallocated on return
/*	Procedure: 0x00401A64 - 0x00401A89
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401A64()
{



    asm("Unknown opcode 0xc1");
    != ? 0x401a6a : ;
    *esi = *esi | al;
    (save)es;
    (save)es;
    *(edx + -1023254077) = *(edx + -1023254077) & edi;
    asm("popa");
    ebx = ebx + eax;
    asm("popa");
    (save)es;
    (save)es;
    (save)1640172917;
    al = (eax | -964685590) + 195;
    asm("popa");
    return(eax | -1015983894);
}

/*	Procedure: 0x00401A8A - 0x00401A8A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401A8A()
{



}

/*	Procedure: 0x00401A8B - 0x00401AE8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401A8B()
{



    dh :: *esi;
    (save)es;
    *eax = *eax ^ ch;
    goto L00401ac0;
    (save)cs;
    asm("adc [ebp+0x30060605],al");
    *edi = eax;
    edi = edi + 4;
    asm("adc eax,0x102a8fc1");
    (restore)es;
    return;
    return;
    return;
    return;
    dh = dh | *(eax + 74803014);
    ah = ah - *(edi + 117);
    *edx = *edx + ebp;
    *eax = *eax ^ ch;
    goto L00401ae1;
    (save)cs;
    (save)eax;
    eax = esi;
    (save)es;
    (save)es;
    asm("%s push dword 0x6be81775");
L00401ac0:
    (save)cs;
    return;
    asm("popa");
    (restore)ss;
    return;
    asm("popa");
    ch = ch | dl;
    asm("adc [eax],dh");
    bl & al;
    return;
    goto L00005006;
    asm("clc");
    asm("Unknown opcode 0xc4");
    return;
    return;
    *%ds:eax] = *%ds:eax] | cl;
    asm("xchg eax,edx");
    asm("%e repne int3");
L00401ae1:
    asm("sbb eax,0x731086d2");
    bl & al;
}

stack space not deallocated on return
/*	Procedure: 0x00401AE9 - 0x00401AF9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401AE9()
{



    asm("loop 0x401a6c");
    asm("repne pop eax");
    (save)eax;
    asm("int3");
    eax = eax + 84411910;
    return(*LC3843F10);
}

/*	Procedure: 0x00401AFA - 0x00401B02
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401AFA()
{



    edx = -943594986;
    asm("%g jns 0x401a86");
}

/*	Procedure: 0x00401B03 - 0x00401B03
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B03()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401B04 - 0x00401B1C
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B04()
{



    ebp = ebp + 1;
    (save)es;
    (save)es;
    al = *L75104BD0 + bl;
    asm("Unknown opcode 0xc7");
    *%gs:esi+0xb1100606] & eax;
    ebp = ebp + 1;
    (save)es;
    (save)es;
    (save)eax;
    asm("lahf");
    ebx = ebx + 1;
}

/*	Procedure: 0x00401B1D - 0x00401B1D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B1D()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401B1E - 0x00401B3A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B1E()
{



    (restore)ds;
    (save)eax;
    asm("int 0x46");
    (save)es;
    (save)es;
    asm("xchg dh,[esi]");
    asm("Unknown opcode 0x26");
    asm("Unknown opcode 0xc6");
    asm("%s xor ebp,eax");
    asm("%s inc eax");
    asm("Unknown opcode 0xc6");
    (save)esi;
    (save)1640172149;
    asm("adc [eax+0xc4d41006],dh");
}

/*	Procedure: 0x00401B3B - 0x00401B3B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B3B()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401B3C - 0x00401C2F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401B3C()
{



    (save)1498417525;
L00401b3f:
    asm("xchg al,[esi]");
    (save)es;
    ah :: *(eax + 638059784);
    asm("a16 jnz 0x401b55");
    dh = dh - *(eax + -349687613);
    asm("%c push cs");
    asm("adc [0x300606c6],dh");
    asm("adc eax,[edi]");
    asm("xchg eax,ebp");
    asm("loop 0x401b8a");
    asm("adc [eax+0xc3c3c383],bh");
    dl = dl | *(eax - 35);
    ebx = ebx + 1;
    return;
    return;
    al :: *(esi + 134759944);
    asm("out 0xd6,al");
    if(eax = eax + 1) {
        goto L00401b3f;
    }
    (restore)eax;
    asm("Unknown opcode 0xc7");
    asm("%g pop edi");
    eax = eax + 1640171014;
    asm("adc bl,al");
    asm("popa");
    *eax = *eax | edx;
    asm("out 0xc6,al");
    (save)es;
L00401b88:
    eax = L77282a05(es);
    ebp = ebp ^ eax;
    eax = eax ^ 1455833158;
    (save)eax;
    bl = bl + 1;
    return;
    return;
    dh :: *esi;
    al = *L84103626;
    asm("xchg al,[esi]");
    (save)es;
    dl = dl ^ bh;
    asm("Unknown opcode 0x62");
    asm("enter 0x2a52,0x10");
    (save)es;
    ebx = ebx + -61;
    return;
    ah = ah | *(edi + 117);
    ch = ch + *edx;
    asm("a16 jnz 0x401bb9");
    dh = dh - *(eax + 805744646);
    bl = bl - ch;
    asm("%c push cs");
    (save)eax;
    return;
    asm("Unknown opcode 0xc4");
    return;
    return;
    al = *%es:0xd086d005];
    (save)esi;
    asm("adc bh,al");
    (save)esi;
    (save)cs;
    edi = 1348864209;
L00401bd5:
    if(bh > *eax) {
        goto L00401b88;
    }
    (save)es;
    (save)es;
    asm("enter 0x6158,0xf");
    (save)1978142325;
    (save)cs;
    ecx = eax;
    bl & al;
    return;
    asm("xchg cl,[eax]");
    *(eax + 24471302) = *(eax + 24471302) | dh;
    al = al - bl;
    asm("popa");
    (restore)es;
    dh = dh - *eax;
    bl = bl - ch;
    asm("%c push cs");
    asm("adc [esi+eax*4+0xab300606],bl");
    asm("adc eax,0xf5508fc1");
    esi = esi + 1;
    (save)es;
    (save)es;
    asm("%d ret");
    esi = esi + 1 + 1;
    asm("out 0xb3,al");
    (save)es;
    asm("Unknown opcode 0xc7");
    asm("%g loope 0x401bdf");
    (save)es;
    (save)es;
    asm("out 0xd6,al");
    esi :: esp;
    asm("in al,0x7");
    (save)es;
    asm("Unknown opcode 0xc7");
    asm("%g pop ds");
    bl & al;
    return;
    goto L00401bd5;
    asm("in al,dx");
    (save)eax;
    *(ebx - 61) = *(ebx - 61) + 1;
}

/*	Procedure: 0x00401C30 - 0x00401C35
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401C30()
{



    return(eax + -1010615674);
}

stack space not deallocated on return
/*	Procedure: 0x00401C36 - 0x00401CAD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401C36()
{



    (save)16;
    asm("xchg eax,esi");
    eax = L76062437(es, es, es);
L00401c40:
    (save)cs;
    return;
    asm("loop 0x401c82");
    return;
    asm("loop 0x401c50");
    dl = dl - *eax;
    asm("adc al,[ebx+eax*8]");
    return;
    asm("insb");
    (save)eax;
    ebx = 96715715;
    asm("%e push es");
    (restore)eax;
    asm("xchg eax,esi");
    (restore)es;
    385018127 = eax * ebp;
    dl = dl | L642823dd(es);
    return(*L041550EB);
    return;
    asm("%e ret");
    eax = eax + -1020918466;
    asm("Unknown opcode 0xc6");
    if(!( *(ebp + 14) = *(ebp + 14) + dh)) {
        dl = dl - dh;
        asm("adc [edi-0x3a],ah");
        eax = L19282afd(es, es);
    }
    (save)eax;
    asm("pushf");
    ebx = ebx + -61;
    asm("%d ret");
    cl :: *%es:eax];
    asm("Unknown opcode 0xc7");
    asm("%g pop edx");
    (save)es;
    (save)es;
    if(esi = esi + 1) {
        goto L00401c40;
    }
    asm("clc");
    asm("hlt");
    if(!( *edx & ch)) {
        asm("Unknown opcode 0xc7");
        *%gs:ebx+eax*8] = *%gs:ebx+eax*8] + 1018620099;
    }
    (save)eax;
    *(ebx + eax * 8) & al;
}

stack space not deallocated on return
/*	Procedure: 0x00401CAE - 0x00401CB2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CAE()
{



    (save)eax;
    edi = edi - 1;
    return(al + 195);
}

stack space not deallocated on return
/*	Procedure: 0x00401CB3 - 0x00401CCA
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CB3()
{



    (save)eax;
    eax = eax | 147047172;
    asm("%s ret");
    eax + -328753018 :: 195;
    asm("loop 0x401cf8");
    asm("out 0x75,eax");
    eax = eax | ebx;
    asm("loop 0x401cfe");
}

/*	Procedure: 0x00401CCB - 0x00401CCD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CCB()
{



    asm("loop 0x401d08");
}

/*	Procedure: 0x00401CCE - 0x00401CD0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CCE()
{



    asm("loop 0x401d04");
}

/*	Procedure: 0x00401CD1 - 0x00401CD3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CD1()
{



    asm("loop 0x401d0e");
}

/*	Procedure: 0x00401CD4 - 0x00401CDA
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CD4()
{



    asm("loop 0x401d11");
    asm("adc bl,dh");
    return(eax + ebx);
}

stack space not deallocated on return
/*	Procedure: 0x00401CDB - 0x00401CE8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CDB()
{



    asm("adc [edi],bh");
    asm("xchg al,[esi]");
    (save)es;
    asm("adc [edx+0x50c3c384],bh");
    asm("%c inc esp");
}

/*	Procedure: 0x00401CE9 - 0x00401CE9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CE9()
{



}

/*	Procedure: 0x00401CEA - 0x00401CEA
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CEA()
{



}

/*	Procedure: 0x00401CEB - 0x00401CED
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CEB()
{



    asm("%s push es");
}

/*	Procedure: 0x00401CEE - 0x00401CFB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CEE()
{



    al = *%ds:0x30e03005];
    *ecx = 42;
    asm("adc dl,dl");
    return(eax + ebx);
}

/*	Procedure: 0x00401CFC - 0x00401D04
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401CFC()
{



    dl = dl - dh;
    -993898481 = eax * ebp;
}

/*	Procedure: 0x00401D05 - 0x00401D05
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D05()
{



}

/*	Procedure: 0x00401D06 - 0x00401D18
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D06()
{



    al = *L08053E46;
    edx = edx - 1;
    asm("adc bh,al");
    eax = eax & -1010580234;
    asm("cli");
    (restore)eax;
    (save)eax;
    asm("Unknown opcode 0xdf");
    asm("Unknown opcode 0xc4");
}

/*	Procedure: 0x00401D19 - 0x00401D19
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D19()
{



}

/*	Procedure: 0x00401D1A - 0x00401D28
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D1A()
{



    (restore)edx;
    *(esi + 14) :: dl;
    *edi = *edi | bl;
    asm("adc al,al");
    *esi = 6;
    (save)eax;
    asm("cmpsd");
    asm("Unknown opcode 0xc4");
}

/*	Procedure: 0x00401D29 - 0x00401D29
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D29()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401D2A - 0x00401DD1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401D2A()
{



    (save)es;
    asm("xchg ah,[esi]");
    if(!( *%ss:esi+0x26] = *%ss:esi+0x26] | dh)) {
        asm("Unknown opcode 0xc7");
        -2069466685 = *%gs:ebx+eax*8] * eax;
    }
    bh = bh - al;
    asm("hlt");
    asm("salc");
    asm("Unknown opcode 0xc7");
    *%gs:esi+0xf5e80606] = *%gs:esi+0xf5e80606] + 1;
    eax :: -967797050;
    asm("xchg al,[esi]");
    (save)es;
    asm("xchg al,[esi]");
    asm("%s push es");
    (save)es;
    dl = dl - *eax;
    *ebx = *ebx - eax;
L00401d58:
    return;
    return;
    return;
    al = al | bl;
    asm("popa");
    *eax = *eax | dh;
    bl = bl - ch;
    asm("%c push cs");
    asm("adc [ecx],dh");
    esi = esi + 1;
    (save)es;
    (save)es;
    cl = cl ^ al;
    ch = *edi;
    dl = dl - *%fs:eax];
    return(3);
    return;
    return;
    if(!(ch = ch | al)) {
        *(ebp - 96) = *(ebp - 96) >> 1;
    }
    asm("%s add eax,0x7f7a1856");
    *L6839994E = al;
    if(!( *esi = *esi | ah)) {
        asm("repne mov al,cl");
        asm("popa");
        (restore)es;
        if(al & 53) {
            goto L00401d58;
        }
        al & 61;
        esp = 105276496;
        (save)es;
        al = *L5806A086;
        asm("xchg eax,esi");
        *esi = *esi | al;
        68544015 = eax * ebp;
        goto L0000c3c3;
        cl :: *eax;
        asm("xchg ah,[eax+0x2a037567]");
        asm("o16 arpl [edi],ax");
        return;
        return;
        (save)es;
        (save)es;
        asm("Unknown opcode 0xc7");
        asm("in eax,0x80");
        ebx = ebx + -61;
    }
    return;
    asm("popa");
    (restore)es;
    al = 6;
    bh = bh << 1;
    (save)6;
    asm("jpo 0x401d54");
}

/*	Procedure: 0x00401DD2 - 0x00401DD2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401DD2()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401DD3 - 0x00401DEE
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401DD3()
{



    (save)es;
    (save)es;
    al = *LE8863608;
    -58 = *esi * ecx;
    asm("in al,dx");
    esp = esp ^ *(esi - 42);
    asm("%d inc esi");
    al = L6c0625d6(es, es) | 195;
    asm("popa");
    asm("Unknown opcode 0x0f");
}

/*	Procedure: 0x00401DEF - 0x00401DF5
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401DEF()
{



    asm("popa");
    return(eax | 53498090);
}

/*	Procedure: 0x00401DF6 - 0x00401DF6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401DF6()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401DF7 - 0x00401E10
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401DF7()
{



    al = *%ss:0x58368686];
    asm("xchg eax,esi");
    eax = eax + 266889478;
    asm("out 0x15,al");
    al = al + bl;
    asm("popa");
    *(edi + 117) = *(edi + 117) | ah;
    al = al + 42;
    (save)eax;
    return(eax & *ebx);
}

/*	Procedure: 0x00401E11 - 0x00401E11
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401E11()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401E12 - 0x00401E38
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401E12()
{



    asm("xchg ah,[eax+0x6860626]");
    eax = Lbb2825c7();
    (save)eax;
    *LE8C3C3C1 = eax;
    eax = -803802574;
    *(esi + 22) = *(esi + 22) | dl;
    asm("lds esi,[edx+0x8656e646]");
    asm("lodsd");
    asm("out 0x74,al");
    (save)es;
    (save)eax;
    return(al - 131);
}

/*	Procedure: 0x00401E39 - 0x00401E39
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401E39()
{



}

/* DEST BLOCK NOT FOUND: 00401e46 -> bb2825c7 */
stack space not deallocated on return
/*	Procedure: 0x00401E3A - 0x00401E78
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401E3A()
{



L00401e3a:
    (save)es;
    asm("xchg al,[%ss:esi-0x7a]");
    esi = esi + 1;
    51766799 = eax * ebp;
    goto L0000c608;
    asm("in al,dx");
    esp = esp ^ *(edi - 36);
    asm("%e push es");
    eax = Lc80ce756(es, es) & -1010613416;
    asm("Unknown opcode 0xc6");
    80 = *eax * ecx;
    *(ebx + eax * 8) = *(ebx + eax * 8) ^ al;
    return;
    asm("%e or bl,al");
    (save)es;
    (save)esi;
    asm("xchg eax,esi");
    asm("Unknown opcode 0xc6");
    if(*esi = *esi | bh) {
        goto L00401E3A;
    }
    (restore)eax;
    asm("Unknown opcode 0xc7");
    *%gs:ebx+eax*8] & al;
}

stack space not deallocated on return
/*	Procedure: 0x00401E79 - 0x00401EE0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401E79()
{



    L782826f3();
    (restore)es;
    eax = L08b258ed();
    < ? L00401ec0 : ;
    goto L00401ed8;
    asm("loopne 0x401e90");
    (save)es;
    (save)es;
    cl :: *eax;
    esi = esi + 1;
    bh :: *edx;
    asm("Unknown opcode 0xc7");
    asm("cmpsb");
    asm("rol byte [ecx+0xabebc3c3],1");
    asm("in al,dx");
    (restore)eax;
    asm("xchg eax,esi");
    *esi = *esi | al;
    if(!(-399644145 = eax * ebp)) {
        eax = L8d282658(es, es, es);
        asm("out 0xd6,al");
        (restore)es;
        (save)eax;
        asm("scasb");
        return;
        return;
        return;
        *esi = *esi | ah;
        asm("%e cmp ch,al");
        esi = esi + esp;
        asm("xchg eax,ebp");
        dh :: *eax;
        (save)es;
        asm("%s push es");
        (save)es;
        (save)1729510711;
        asm("aaa");
        eax :: 694708758;
        eax :: 1026123542;
        (save)ss;
        *edi = al;
        edi = edi + 1;
        al = 195;
    }
L00401ed8:
    dh = dh - *eax;
    bl = bl - ch;
    asm("%c push cs");
    asm("adc ah,dl");
}

/*	Procedure: 0x00401EE1 - 0x00401EE1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401EE1()
{



}

/*	Procedure: 0x00401EE2 - 0x00401EE2
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401EE2()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401EE3 - 0x00401EE8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401EE3()
{



    (save)eax;
    eax = eax - 1;
    ebx = ebx + -61;
}

stack space not deallocated on return
/*	Procedure: 0x00401EE9 - 0x00401F33
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401EE9()
{



    asm("xchg al,[%ss:esi]");
    *edx = *edx | bh;
    *eax = *eax ^ ch;
    goto L00401f20;
    (save)cs;
    asm("adc [ebp+0x30c3c3c3],bl");
    asm("lodsd");
    goto L0000841f;
    return;
    return;
    return;
    if(!(ch = ch | al)) {
        (restore)eax;
        asm("xchg eax,esi");
        *esi = *esi | al;
        650363777 = *(eax + 24) * edx;
    }
    *L7C2D283A = *L7C2D283A | al;
    return;
    *L58C878BC = *L58C878BC - al;
L00401f20:
    asm("Unknown opcode 0xc7");
    asm("%g pop ecx");
    asm("rol ebx,0xc3");
    asm("in al,dx");
    (restore)eax;
    asm("xchg eax,esi");
    (restore)es;
    (save)es;
    -1085232881 = eax * ebp;
    return(al + 195);
}

stack space not deallocated on return
/*	Procedure: 0x00401F34 - 0x00401F76
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401F34()
{



    asm("%d stosd");
    (restore)eax;
L00401f39:
    asm("xchg eax,esi");
    (restore)es;
    (save)es;
    1642606095 = eax * ebp;
    (restore)es;
    eax = L504327ab();
    (restore)edx;
    asm("Unknown opcode 0xc4");
    return;
    return;
    asm("%s inc esi");
    asm("xchg al,[%ds:0xc76c8646]");
    asm("rol dword [edi],1");
    al :: ch;
    asm("cmc");
    eax :: esi;
    asm("xchg eax,esi");
    (save)eax;
    return(L97064767() ^ bl);
    return;
    asm("rol byte [esi+0xe66c16f2],1");
    asm("xchg eax,ebp");
    (save)eax;
    if(eax = eax + 58193014) {
        goto L00401f39;
    }
}

/*	Procedure: 0x00401F77 - 0x00401F77
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401F77()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401F78 - 0x00401F91
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401F78()
{



    al :: bl;
    *(eax + -789387210) = *(eax + -789387210) | ah;
    asm("Unknown opcode 0xc6");
    al = L62065a68() | ch;
    asm("in al,0x3a");
    asm("Unknown opcode 0xc6");
    asm("arpl [eax],cx");
    (save)eax;
    asm("%e add eax,ebx");
}

stack space not deallocated on return
/*	Procedure: 0x00401F92 - 0x00401FC6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401F92()
{



    (restore)edi;
    asm("pusha");
    (save)es;
    (save)es;
    (save)es;
    asm("Unknown opcode 0x26");
    asm("Unknown opcode 0xc7");
    if(!(eax = eax & -1010597393)) {
        (save)es;
        (save)es;
        asm("%e sub al,bl");
        asm("popa");
    }
    edx = edx + *(eax - 84);
    ebx = ebx + 1042679235;
    al = *L4226C306;
    asm("cli");
    asm("xchg dl,[edi+0x98a8168a]");
    bl = *eax;
    asm("insb");
    ebx = ebx + -61;
    return(*LDD504AC6);
}

/*	Procedure: 0x00401FC7 - 0x00401FD0
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FC7()
{



    asm("xchg al,[esi-0x3d]");
    ecx = ecx + 1;
    return(*L29100886);
}

/*	Procedure: 0x00401FD1 - 0x00401FD1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FD1()
{



}

/*	Procedure: 0x00401FD2 - 0x00401FD6
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FD2()
{



    asm("Unknown opcode 0xc7");
    asm("out 0xff,al");
    asm("Unknown opcode 0xc4");
}

/*	Procedure: 0x00401FD7 - 0x00401FD7
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FD7()
{



}

/*	Procedure: 0x00401FD8 - 0x00401FDD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FD8()
{



    asm("repne push ss");
    asm("adc ch,dh");
    ecx = ecx + 1;
}

/*	Procedure: 0x00401FDE - 0x00401FDE
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FDE()
{



}

/*	Procedure: 0x00401FDF - 0x00401FE3
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FDF()
{



    asm("Unknown opcode 0xc7");
    asm("out 0x74,al");
    asm("Unknown opcode 0xc4");
}

/*	Procedure: 0x00401FE4 - 0x00401FE4
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FE4()
{



}

/*	Procedure: 0x00401FE5 - 0x00401FED
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FE5()
{



    asm("rol byte [esi+0x503a1276],cl");
    esp & eax;
}

/*	Procedure: 0x00401FEE - 0x00401FEE
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FEE()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401FEF - 0x00401FFB
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FEF()
{



    asm("%d xchg al,bl");
    asm("popa");
    eax = eax | ebx;
    asm("popa");
    (save)cs;
    asm("adc [esi+0x41],al");
}

/*	Procedure: 0x00401FFC - 0x00401FFC
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FFC()
{



}

/*	Procedure: 0x00401FFD - 0x00401FFD
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FFD()
{



}

stack space not deallocated on return
/*	Procedure: 0x00401FFE - 0x00402003
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00401FFE()
{



    asm("popa");
    eax = eax | ebx;
    asm("popa");
    (save)cs;
}

/*	Procedure: 0x00402004 - 0x00402009
 *	Argument size: -15613
 *	Local size: 0
 *	Save regs size: 0
 */

L00402004()
{



    asm("popa");
    return(al | 16);
}

/*	Procedure: 0x0040200A - 0x0040200A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040200A()
{



}

stack space not deallocated on return
/*	Procedure: 0x0040200B - 0x0040200F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040200B()
{



    (save)eax;
    asm("scasd");
    return(eax + ebx);
}

/*	Procedure: 0x00402010 - 0x00402015
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402010()
{



    al = al - 80;
    asm("%c add eax,ebx");
}

stack space not deallocated on return
/*	Procedure: 0x00402016 - 0x00402029
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402016()
{



    esi = esi + 1;
    asm("xchg dh,[esi]");
    ah :: *%ds:eax+0x85f8d1c7];
    asm("o16 salc");
    al = al + 6;
    (save)es;
    (save)es;
    (save)eax;
    asm("clc");
    asm("Unknown opcode 0xc4");
}

/*	Procedure: 0x0040202A - 0x0040202A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040202A()
{



}

stack space not deallocated on return
/*	Procedure: 0x0040202B - 0x0040203F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040202B()
{



    (save)-24;
    edx = *ecx % *ecx;
    asm("Unknown opcode 0xc6");
    if(!( *ecx = *ecx / *ecx)) {
        (save)cs;
        return(L7806282f());
        asm("loop 0x402075");
    }
    dl = dl - *(eax + 65);
    asm("Unknown opcode 0xc4");
}

/*	Procedure: 0x00402040 - 0x00402040
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402040()
{



}

/*	Procedure: 0x00402041 - 0x00402069
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402041()
{



    al = *%es:0x45613e06];
    ch = 186;
    dl = dh;
    asm("repne pop eax");
    if(!(al & 185)) {
        asm("xlatb");
        ebx = ebx + eax;
        return;
        asm("cli");
        (restore)eax;
        (save)eax;
        asm("xadd ebx,eax");
        return;
        *LC63AC346 = *LC63AC346 | al;
    }
    80 = *eax * ecx;
    cl = 4;
}

/*	Procedure: 0x0040206A - 0x0040206A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040206A()
{



}

/*	Procedure: 0x0040206B - 0x00402074
 *	Argument size: -27162
 *	Local size: 0
 *	Save regs size: 0
 */

L0040206B()
{



    return(L51262668() | ch);
}

/*	Procedure: 0x00402075 - 0x0040207A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L00402075()
{



    *(eax - 4) = *(eax - 4) | dl;
    return(al + 195);
}

stack space not deallocated on return
/*	Procedure: 0x0040207B - 0x004020B8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L0040207B()
{



    asm("Unknown opcode 0xc7");
    asm("rol dword [ebp+0xad04d1c7],1");
    asm("o16 int 0xc3");
    asm("Unknown opcode 0xc7");
    asm("lodsd");
    (save)esi;
    asm("adc [edi],al");
    (save)eax;
    ecx = ecx + 1;
    asm("rol ebx,0xc3");
    asm("xchg dh,[esi]");
    eax = eax + -2043017723;
    asm("adc al,0xc6");
    (save)es;
    (save)es;
    (save)es;
    asm("repne mov ch,[ebp+0x27ad10a7]");
    asm("adc [edx+0x18],cl");
    *L06300344 = al;
    (save)es;
    (save)es;
    (save)es;
    asm("out 0x75,eax");
    esi = esi + *eax;
    *%es:0xf05087bc] = al;
    esp = esp + 1;
}

/*	Procedure: 0x004020B9 - 0x004020B9
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004020B9()
{



}

/* DEST BLOCK NOT FOUND: 004023eb -> f912e71a */
/*	Procedure: 0x004020BA - 0x0040256A
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004020BA()
{



    eax = *%es:0x1362686] + 1;
    *eax = *eax | cl;
    *edx = *edx & al;
    asm("ror al,0x6");
    cl = *ebx;
    dl = 226;
    edx = esi;
    esi = esi - ebx;
    asm("rol dh,0x1e");
    edx = 1579282514;
    eax = ah << cl >> cl & 155801433;
    if(!(esi = esi - 91461209)) {
        >= ? L0040244f : ;
        eax = eax + 1;
        *(eax + -359999022) = *(eax + -359999022) | al;
L004020f7:
        eax = edi;
        esi = esi - cl - 115;
        cl = ch - 1 + 189;
        esi = esi ^ eax;
        ch = ch >> cl ^ 71;
        esi = esi + ebx;
        eax = eax - -1158099554;
        asm("rol cl,0x4");
        goto L0040223b;
        *(ecx + eax) = *(ecx + eax) | al;
        *(ebx + ecx * 4) = *(ebx + ecx * 4) + 209;
L00402123:
        dh = dh << cl;
        asm("adc ecx,0xf854d438");
        edx = (dh | 240) & 1087153014;
        ah = eax | -841512189 | 137;
        eax = ecx;
        ecx = ecx ^ esi;
        if(!(ah = (al ^ 33) - 168)) {
            >= ? L0040235b : ;
            asm("adc [eax+0x20],al");
            al = al + *(eax + -910138683);
L00402159:
            *(ecx + 120742648) = *(ecx + 120742648) | al;
            if(!(ebp = ebp + 1)) {
                dh = dh ^ 141;
                asm("rcr dh,cl");
                al = al | dl;
                asm("rcr dl,cl");
                asm("rcr ah,cl");
                cl = cl - dh;
                goto L004021f4;
                *(edx + 548013060) = *(edx + 548013060) - 128;
L0040217c:
                asm("aam 0x6f");
                al = al << cl;
                esi = esi + 1;
                asm("rcr al,cl");
                asm("rol cl,0x3");
                ch = ch - 1;
                al = al | 195;
                asm("ror cl,cl");
                ebx = ebx + 1;
                asm("sbb ah,0x65");
                goto L0040226a;
                *edi = al;
                edi = edi + 1;
                *eax = *eax + eax;
                *edi = al;
                edi = edi + 1;
L0040219b:
                eax = eax - 41003385;
                edx = edx | esi;
            }
            dl = 124;
            al = al + 2;
            ecx = ch + bl & 614227774;
            eax = (eax ^ 124) + 271531186;
            esi = esi - ebx;
            asm("jpe 0x4020c5");
            asm("jpo 0x4020c5");
            *eax = *eax & ah;
            asm("adc byte [eax],0x4");
            goto ( *edx);
L004021cd:
            asm("out dx,al");
            ah = ah - 67;
            esi = esi + 1;
            ecx = ecx & -1109587002;
            al = al + dh;
            al = dl;
            cl = cl + 1;
            ch = ch >> cl;
            if(al = al - bl) {
                goto L004020f7;
            }
            > ? L004020f7 : ;
            goto ( *eax);
            eax = *eax();
            asm("adc [eax-0x7f],al");
L004021f4:
            asm("Unknown opcode 0xc6");
            asm("in al,dx");
            asm("scasb");
            asm("in al,dx");
            asm("jpe 0x4021fe");
            return;
            edi = -1547196475;
            edi = edi - -933924940;
            asm("rol ah,cl");
            asm("rcr ch,cl");
            if(bh = ebx + edx + ah) {
                goto L00402390;
            }
            > ? L00402390 : ;
            ah = ah + *eax;
            *edx = *edx + 255;
            *eax = *eax + cl;
L00402222:
            dl = ~dl;
            ah = al >> cl ^ 22;
            esi = esi - 1;
            ah = al >> cl >> cl;
            asm("rol cl,0xd");
            asm("ror dl,cl");
            goto L00402315;
            *(eax + 4) = *(eax + 4) + eax;
L0040223b:
            esi = esi ^ edx;
            ch = ch ^ 68;
            cl = !( !ch ^ bl) ^ 214;
            cl = -1583116559 << -1583116559;
            if(esi = esi - edx) {
                goto L00402159;
            }
            >= ? 0x402159 : ;
            goto ( *(edx + 537133569));
            al = al + *(eax + -491131172);
L0040226a:
            al = *esi;
            esi = esi + 1;
            ch = *(edx + -1950288512);
            asm("iret");
            ah = ah | dh;
            ch = ch + 1;
            esi = 971818669;
            al = dh ^ 53 ^ 108;
            if(edi = edi - 1) {
                goto L004021cd;
            }
            != ? 0x4021cc : ;
            *eax = *eax + al;
            al = al + 1;
L0040229a:
            al = al + 156;
            asm("ror ah,0xd");
            edi = edi ^ -1651421352;
            asm("ror ch,0xe");
            ah = ah << cl;
            ecx = ecx | ebx;
            asm("rol ah,cl");
            eax = eax & -165106473;
            asm("adc ch,0x82");
            ah = ah - 1;
            if(ecx = ecx - 1) {
                goto L0040219b;
            }
            != ? 0x40219b : ;
            *eax = *eax + ecx;
            *(ecx + 260669417) = *(ecx + 260669417) & al;
            asm("sbb al,[ecx+0x3a14ee9]");
            eax = eax | -2126980480;
            asm("fisubr dword [ebx-0x79]");
            ch = -523534249;
            asm("ror ch,cl");
            al = !al;
            ebx = ebx - -1948184931;
            goto L0040233e;
            *edi = al;
            edi = edi + 1;
            al = al + 64;
L004022f3:
            ah = al << cl | cl;
            cl = !cl;
            dl = dl & 64;
            asm("ror dl,0x1");
            asm("ror al,0x1");
            eax = eax & -859705196;
            asm("rol dh,cl");
            goto L00402222;
            *edi = al;
            edi = edi + 1;
            *edx = *edx + al;
            *eax = *eax & al;
            *edi = al;
            edi = edi + 1;
L00402315:
            esi = esi - -1356695638;
            dl = dl >> cl;
            al = al + 1;
            asm("sbb esi,0x6d684f57");
            dl = dh >> cl >> cl;
            ah = bl;
            if(edx = (dl << cl) - 1) {
                goto L00402541;
            }
            >= ? 0x402541 : ;
            al = al + 16;
            *eax = *eax + esp;
L0040233e:
            asm("ror bh,cl");
            ebx = ebx + ecx;
            dl = dl ^ 54;
            esi = esi - eax;
            eax = edi;
            ebx = 7835732;
            (restore)ebx;
            dl = bl;
            esi = eax;
            asm("ror al,cl");
            goto L004023c2;
            *(eax + ecx) = *(eax + ecx) | al;
            *(ecx + -283453) = *(ecx + -283453) & al;
        }
        *(edx + 231391479) = *(edx + 231391479) - 1;
        al = al | 126;
        edx = edx - 236 + 236 + -731197163;
        ecx = 1511329131;
        dh = 0;
        goto L004024db;
        asm("adc [eax],al");
        *ecx = *ecx + al;
        *edx = *edx + cl;
L00402390:
        asm("les ecx,[edx]");
        asm("std");
        asm("adc ecx,0x5931ae77");
        asm("sbb ch,0xe7");
        asm("rol ah,0x3");
        esi = esi - edx;
        edx = edx & 1291607511;
        return;
        bh = bh ^ ah;
        asm("sbb al,0x2f");
        if(ah = ah | 112) {
            goto L0040247e;
        }
        > ? L0040247e : ;
        *edi = al;
        edi = edi + 1;
        al = al + 4;
        *(edx + -770453824) = *(edx + -770453824) + ebp;
L004023c2:
        asm("Unknown opcode 0xc4");
        al = al << cl;
        edi = edi + ecx;
        dl = !dl;
        edi = 196737603;
        if(!(ebx = ebx - -1108)) {
            >= ? 0x4023e8 : ;
            *L000001C0();
            asm("adc [ecx],al");
            al = al + 210;
        }
        asm("int 0xd2");
        goto Lf912e71a;
        dl = dl | ch;
        ch = al;
        dh = 1258609114 >> cl;
        (save)ebx;
        if(ecx = ecx + edi) {
            goto L00402123;
        }
        > ? L00402123 : ;
        *ecx = *ecx & al;
        *(eax + -1979665339) = *(eax + -1979665339) ^ 227;
L00402410:
        esi = esi | edx;
        eax = eax + 987208174 + -133697289;
        dl = cl;
        asm("rol al,0x14");
        asm("rol ah,cl");
        cl = !cl;
        ah = !ah;
        ch = ch & 7;
        goto L0040248d;
        *eax = *eax & 128;
        al = al + 194;
L00402438:
        asm("sbb ebp,[edx]");
        asm("repne mov dh,0xaa");
        ah = ah - 32;
        esi = esi - 1;
        cl = cl ^ 39;
        dh = dh ^ bh;
        goto L004024b7;
        eax = eax + 1 + 1;
        *ecx = *ecx + eax;
        *(ecx + -1874927902) = *(ecx + -1874927902) + al;
    }
    (save)esi;
    asm("aam 0x80");
    asm("imul byte [ecx]");
    cl = ~cl;
    dh = dh ^ 243;
    edx = edi;
    ah = ~ah;
    asm("rol dl,0x19");
    if(!(edx = edx & -319575661)) {
        >= ? 0x402504 : ;
        *eax = *eax + edx;
        *(edx + -943701984) = *(edx + -943701984) | ch;
L0040247e:
        (restore)ss;
        ah = ah + cl;
        asm("adc cl,0x11");
        eax = eax - ecx;
        bh = bh << cl;
        asm("adc ah,0x3a");
L0040248d:
        al = ah << cl | 136;
        esi = esi | ecx;
        *ebx = dl;
        al = eax - -1442422855 - 1;
        asm("rol ch,cl");
        asm("rcr cl,cl");
        asm("rcr al,cl");
        if(esi = esi - 1) {
            goto L0040217c;
        }
        >= ? 0x40217c : ;
        *edx = *edx + 1;
        al = al + *(eax + -20774136);
L004024b7:
        asm("enter 0xc4c0,0x10");
        ah = (al ^ dl) & 192;
        esi = esi - 1;
        edx = edx + 282045005;
        asm("rcr dl,cl");
        esi = esi + -1879171080;
        goto L004022f3;
        asm("adc [eax],dl");
        bh = bh + bh;
L004024db:
        edi = -1651424118;
        esi = esi + edx;
        edx = (dh >> cl) - eax;
        asm("rcl ah,cl");
        dl = dl - 65;
        ecx = ecx + -665792481;
        asm("adc ch,0x3a");
        eax = eax + 1;
        cl = (ecx | eax) & 66;
        ah = ah - 1;
        goto L0040229a;
        *(eax - 86) = *(eax - 86) | al;
    }
    eax = eax - -633976815;
    asm("sbb eax,0x81bddb15");
    eax = eax + 419637540;
    dh = dh - 247 << cl;
    asm("ror cl,0x3");
    asm("ror al,cl");
    asm("rcl dh,cl");
    asm("ror dl,0x1e");
    esi = esi | eax;
    al = al >> cl;
    asm("adc al,0x68");
    if(esi = esi | edx) {
        goto L00402438;
    }
    >= ? 0x402438 : ;
    ah = ah + *eax;
    bh :: 0;
    *eax = *eax | 255;
L00402541:
    asm("rcl dl,cl");
    dh = dh - 246;
    cl = cl - 240;
    al = al - 1 ^ 136;
    asm("adc edx,0x9a43ed46");
    asm("sbb al,0x12");
    if(dl = dl & 147) {
        goto L00402410;
    }
    >= ? 0x402410 : ;
    *(edx + -8386528) = *(edx + -8386528) & ch;
}

/* address  size  */
/* 0x00401059       0 */ /* unknown */ void 	__entry_point__;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
